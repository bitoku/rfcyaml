- title: __initial_text__
  contents:
  - "         Protocol Independent Multicast - Sparse Mode (PIM-SM):\n           \
    \         Protocol Specification (Revised)\n"
- title: Abstract
  contents:
  - "Abstract\n   This document specifies Protocol Independent Multicast - Sparse\
    \ Mode\n   (PIM-SM).  PIM-SM is a multicast routing protocol that can use the\n\
    \   underlying unicast routing information base or a separate multicast-\n   capable\
    \ routing information base.  It builds unidirectional shared\n   trees rooted\
    \ at a Rendezvous Point (RP) per group, and it optionally\n   creates shortest-path\
    \ trees per source.\n   This document obsoletes RFC 4601 by replacing it, addresses\
    \ the\n   errata filed against it, removes the optional (*,*,RP), PIM Multicast\n\
    \   Border Router features and authentication using IPsec that lack\n   sufficient\
    \ deployment experience (see Appendix A), and moves the PIM\n   specification\
    \ to Internet Standard.\n"
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This is an Internet Standards Track document.\n   This\
    \ document is a product of the Internet Engineering Task Force\n   (IETF).  It\
    \ represents the consensus of the IETF community.  It has\n   received public\
    \ review and has been approved for publication by the\n   Internet Engineering\
    \ Steering Group (IESG).  Further information on\n   Internet Standards is available\
    \ in Section 2 of RFC 5741.\n   Information about the current status of this document,\
    \ any errata,\n   and how to provide feedback on it may be obtained at\n   http://www.rfc-editor.org/info/rfc7761.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (c) 2016 IETF Trust and the persons identified\
    \ as the\n   document authors.  All rights reserved.\n   This document is subject\
    \ to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n\
    \   (http://trustee.ietf.org/license-info) in effect on the date of\n   publication\
    \ of this document.  Please review these documents\n   carefully, as they describe\
    \ your rights and restrictions with respect\n   to this document.  Code Components\
    \ extracted from this document must\n   include Simplified BSD License text as\
    \ described in Section 4.e of\n   the Trust Legal Provisions and are provided\
    \ without warranty as\n   described in the Simplified BSD License.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1. Introduction ....................................................5\n\
    \   2. Terminology .....................................................5\n  \
    \    2.1. Definitions ................................................5\n    \
    \  2.2. Pseudocode Notation ........................................7\n   3. PIM-SM\
    \ Protocol Overview ........................................7\n      3.1. Phase\
    \ One: RP Tree .........................................8\n      3.2. Phase Two:\
    \ Register-Stop ...................................9\n      3.3. Phase Three:\
    \ Shortest-Path Tree ...........................10\n      3.4. Source-Specific\
    \ Joins .....................................10\n      3.5. Source-Specific Prunes\
    \ ....................................11\n      3.6. Multi-Access Transit LANs\
    \ .................................11\n      3.7. RP Discovery ..............................................12\n\
    \   4. Protocol Specification .........................................12\n  \
    \    4.1. PIM Protocol State ........................................13\n    \
    \       4.1.1. General-Purpose State ..............................14\n      \
    \     4.1.2. (*,G) State ........................................15\n        \
    \   4.1.3. (S,G) State ........................................17\n          \
    \ 4.1.4. (S,G,rpt) State ....................................19\n           4.1.5.\
    \ State Summarization Macros .........................20\n      4.2. Data Packet\
    \ Forwarding Rules ..............................24\n           4.2.1. Last-Hop\
    \ Switchover to the SPT .....................27\n           4.2.2. Setting and\
    \ Clearing the (S,G) SPTbit ..............27\n      4.3. Designated Routers (DRs)\
    \ and Hello Messages ...............29\n           4.3.1. Sending Hello Messages\
    \ .............................29\n           4.3.2. DR Election ........................................31\n\
    \           4.3.3. Reducing Prune Propagation Delay on LANs ...........33\n  \
    \         4.3.4. Maintaining Secondary Address Lists ................36\n    \
    \  4.4. PIM Register Messages .....................................37\n      \
    \     4.4.1. Sending Register Messages from the DR ..............38\n        \
    \   4.4.2. Receiving Register Messages at the RP ..............43\n      4.5.\
    \ PIM Join/Prune Messages ...................................44\n           4.5.1.\
    \ Receiving (*,G) Join/Prune Messages ................45\n           4.5.2. Receiving\
    \ (S,G) Join/Prune Messages ................50\n           4.5.3. Receiving (S,G,rpt)\
    \ Join/Prune Messages ............54\n           4.5.4. Sending (*,G) Join/Prune\
    \ Messages ..................61\n           4.5.5. Sending (S,G) Join/Prune Messages\
    \ ..................65\n           4.5.6. (S,G,rpt) Periodic Messages ........................71\n\
    \           4.5.7. State Machine for (S,G,rpt) Triggered Messages .....72\n  \
    \    4.6. PIM Assert Messages .......................................76\n    \
    \       4.6.1. (S,G) Assert Message State Machine .................77\n      \
    \     4.6.2. (*,G) Assert Message State Machine .................85\n        \
    \   4.6.3. Assert Metrics .....................................93\n          \
    \ 4.6.4. AssertCancel Messages ..............................94\n           4.6.5.\
    \ Assert State Macros ................................95\n      4.7. PIM Bootstrap\
    \ and RP Discovery ............................98\n           4.7.1. Group-to-RP\
    \ Mapping ................................99\n           4.7.2. Hash Function\
    \ .....................................100\n      4.8. Source-Specific Multicast\
    \ ................................101\n           4.8.1. Protocol Modifications\
    \ for SSM Destination\n                  Addresses .........................................102\n\
    \           4.8.2. PIM-SSM-Only Routers ..............................102\n  \
    \    4.9. PIM Packet Formats .......................................104\n    \
    \       4.9.1. Encoded Source and Group Address Formats ..........105\n      \
    \     4.9.2. Hello Message Format ..............................108\n        \
    \   4.9.3. Register Message Format ...........................111\n          \
    \ 4.9.4. Register-Stop Message Format ......................113\n           4.9.5.\
    \ Join/Prune Message Format .........................114\n                  4.9.5.1.\
    \ Group Set Source List Rules ..............117\n                  4.9.5.2. Group\
    \ Set Fragmentation ..................120\n           4.9.6. Assert Message Format\
    \ .............................121\n      4.10. PIM Timers ..............................................122\n\
    \      4.11. Timer Values ............................................124\n  \
    \ 5. IANA Considerations ...........................................130\n    \
    \  5.1. PIM Address Family .......................................130\n      5.2.\
    \ PIM Hello Options ........................................130\n   6. Security\
    \ Considerations .......................................131\n      6.1. Attacks\
    \ Based on Forged Messages .........................131\n           6.1.1. Forged\
    \ Link-Local Messages ........................131\n           6.1.2. Forged Unicast\
    \ Messages ...........................132\n      6.2. Non-cryptographic Authentication\
    \ Mechanisms ..............132\n      6.3. Authentication ...........................................133\n\
    \      6.4. Denial-of-Service Attacks ................................133\n  \
    \ 7. References ....................................................133\n    \
    \  7.1. Normative References .....................................133\n      7.2.\
    \ Informative References ...................................134\n   Appendix A.\
    \ Functionality Removed from RFC 4601 ..................136\n   Acknowledgements\
    \ .................................................136\n   Authors' Addresses\
    \ ...............................................136\n"
- title: List of Figures (Shown in Tabular Form)
  contents:
  - "List of Figures (Shown in Tabular Form)\n   Figure 1. Per-(S,G) Register State\
    \ Machine at a DR ................39\n   Figure 2. Downstream Per-Interface (*,G)\
    \ State Machine ............47\n   Figure 3. Downstream Per-Interface (S,G) State\
    \ Machine ............51\n   Figure 4. Downstream Per-Interface (S,G,rpt) State\
    \ Machine ........56\n   Figure 5. Upstream (*,G) State Machine ............................62\n\
    \   Figure 6. Upstream (S,G) State Machine ............................66\n  \
    \ Figure 7. Upstream (S,G,rpt) State Machine for Triggered\n             Messages\
    \ ................................................72\n   Figure 8. Per-Interface\
    \ (S,G) Assert State Machine ................78\n   Figure 9. Per-interface (*,G)\
    \ Assert State Machine ................87\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   This document specifies a protocol for efficiently routing\
    \ multicast\n   groups that may span wide-area (and inter-domain) internets. \
    \ This\n   protocol is called Protocol Independent Multicast - Sparse Mode\n \
    \  (PIM-SM) because, although it may use the underlying unicast routing\n   to\
    \ provide reverse-path information for multicast tree building, it\n   is not\
    \ dependent on any particular unicast routing protocol.\n   PIM-SM Version 2 was\
    \ specified in RFC 4601 as a Proposed Standard.\n   This document is intended\
    \ to address the reported errata and to\n   remove the optional (*,*,RP), PIM\
    \ Multicast Border Router features\n   and authentication using IPsec that lacks\
    \ sufficient deployment\n   experience, to advance PIM-SM to Internet Standard.\n\
    \   This document specifies the same protocol as RFC 4601, and\n   implementations\
    \ per the specification in this document will be able\n   to interoperate successfully\
    \ with implementations per RFC 4601.\n"
- title: 2.  Terminology
  contents:
  - "2.  Terminology\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\"\
    , \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and\
    \ \"OPTIONAL\" in this\n   document are to be interpreted as described in RFC\
    \ 2119 [1].\n"
- title: 2.1.  Definitions
  contents:
  - "2.1.  Definitions\n   The following terms have special significance for PIM-SM:\n\
    \   Rendezvous Point (RP)\n      An RP is a router that has been configured to\
    \ be used as the root\n      of the non-source-specific distribution tree for\
    \ a multicast\n      group.  Join messages from receivers for a group are sent\
    \ towards\n      the RP, and data from senders is sent to the RP so that receivers\n\
    \      can discover who the senders are and start to receive traffic\n      destined\
    \ for the group.\n   Designated Router (DR)\n      A shared-media LAN like Ethernet\
    \ may have multiple PIM-SM routers\n      connected to it.  A single one of these\
    \ routers, the DR, will act\n      on behalf of directly connected hosts with\
    \ respect to the PIM-SM\n      protocol.  A single DR is elected per interface\
    \ (LAN or otherwise)\n      using a simple election process.\n   MRIB\n      Multicast\
    \ Routing Information Base.  This is the multicast\n      topology table, which\
    \ is typically derived from the unicast\n      routing table, or routing protocols\
    \ such as Multiprotocol BGP\n      (MBGP) that carry multicast-specific topology\
    \ information.  In\n      PIM-SM, the MRIB is used to decide where to send Join/Prune\n\
    \      messages.  A secondary function of the MRIB is to provide routing\n   \
    \   metrics for destination addresses; these metrics are used when\n      sending\
    \ and processing Assert messages.\n   RPF Neighbor\n      RPF stands for \"Reverse\
    \ Path Forwarding\".  The RPF Neighbor of a\n      router with respect to an address\
    \ is the neighbor that the MRIB\n      indicates should be used to forward packets\
    \ to that address.  In\n      the case of a PIM-SM multicast group, the RPF neighbor\
    \ is the\n      router that a Join message for that group would be directed to,\
    \ in\n      the absence of modifying Assert state.\n   TIB\n      Tree Information\
    \ Base.  This is the collection of state at a PIM\n      router that has been\
    \ created by receiving PIM Join/Prune messages,\n      PIM Assert messages, and\
    \ Internet Group Management Protocol (IGMP)\n      or Multicast Listener Discovery\
    \ (MLD) information from local\n      hosts.  It essentially stores the state\
    \ of all multicast\n      distribution trees at that router.\n   MFIB\n      Multicast\
    \ Forwarding Information Base.  The TIB holds all the\n      state that is necessary\
    \ to forward multicast packets at a router.\n      However, although this specification\
    \ defines forwarding in terms\n      of the TIB, to actually forward packets using\
    \ the TIB is very\n      inefficient.  Instead, a real router implementation will\
    \ normally\n      build an efficient MFIB from the TIB state to perform forwarding.\n\
    \      How this is done is implementation-specific and is not discussed\n    \
    \  in this document.\n   Upstream\n      Towards the root of the tree.  The root\
    \ of the tree may be either\n      the source or the RP, depending on the context.\n\
    \   Downstream\n      Away from the root of the tree.\n   GenID\n      Generation\
    \ Identifier, used to detect reboots.\n"
- title: 2.2.  Pseudocode Notation
  contents:
  - "2.2.  Pseudocode Notation\n   We use set notation in several places in this specification.\n\
    \      A (+) B is the union of two sets, A and B.\n      A (-) B is the elements\
    \ of set A that are not in set B.\n      NULL    is the empty set or list.\n \
    \  In addition, we use C-like syntax:\n      =       denotes assignment of a variable.\n\
    \      ==      denotes a comparison for equality.\n      !=      denotes a comparison\
    \ for inequality.\n   Braces { and } are used for grouping.\n   Unless otherwise\
    \ noted, operations specified by statements having\n   multiple (+) and (-) operators\
    \ should be evaluated from left to\n   right, i.e., A (+) B (-) C is the set resulting\
    \ from union of sets A\n   and B minus elements in set C.\n"
- title: 3.  PIM-SM Protocol Overview
  contents:
  - "3.  PIM-SM Protocol Overview\n   This section provides an overview of PIM-SM\
    \ behavior.  It is intended\n   as an introduction to how PIM-SM works, and it\
    \ is NOT definitive.\n   For the definitive specification, see Section 4.\n  \
    \ PIM relies on an underlying topology-gathering protocol to populate a\n   routing\
    \ table with routes.  This routing table is called the\n   Multicast Routing Information\
    \ Base (MRIB).  The routes in this table\n   may be taken directly from the unicast\
    \ routing table, or they may be\n   different and provided by a separate routing\
    \ protocol such as MBGP\n   [10].  Regardless of how it is created, the primary\
    \ role of the MRIB\n   in the PIM protocol is to provide the next-hop router along\
    \ a\n   multicast-capable path to each destination subnet.  The MRIB is used\n\
    \   to determine the next-hop neighbor to which any PIM Join/Prune\n   message\
    \ is sent.  Data flows along the reverse path of the Join\n   messages.  Thus,\
    \ in contrast to the unicast RIB, which specifies the\n   next hop that a data\
    \ packet would take to get to some subnet, the\n   MRIB gives reverse-path information\
    \ and indicates the path that a\n   multicast data packet would take from its\
    \ origin subnet to the router\n   that has the MRIB.\n   Like all multicast routing\
    \ protocols that implement the service model\n   from RFC 1112 [3], PIM-SM must\
    \ be able to route data packets from\n   sources to receivers without either the\
    \ sources or receivers knowing\n   a priori of the existence of the others.  This\
    \ is essentially done in\n   three phases, although as senders and receivers may\
    \ come and go at\n   any time, all three phases may occur simultaneously.\n"
- title: '3.1.  Phase One: RP Tree'
  contents:
  - "3.1.  Phase One: RP Tree\n   In phase one, a multicast receiver expresses its\
    \ interest in\n   receiving traffic destined for a multicast group.  Typically,\
    \ it does\n   this using IGMP [2] or MLD [4], but other mechanisms might also\
    \ serve\n   this purpose.  One of the receiver's local routers is elected as the\n\
    \   Designated Router (DR) for that subnet.  On receiving the receiver's\n   expression\
    \ of interest, the DR then sends a PIM Join message towards\n   the RP for that\
    \ multicast group.  This Join message is known as a\n   (*,G) Join because it\
    \ joins group G for all sources to that group.\n   The (*,G) Join travels hop-by-hop\
    \ towards the RP for the group, and\n   in each router it passes through, multicast\
    \ tree state for group G is\n   instantiated.  Eventually, the (*,G) Join either\
    \ reaches the RP or\n   reaches a router that already has (*,G) Join state for\
    \ that group.\n   When many receivers join the group, their Join messages converge\
    \ on\n   the RP and form a distribution tree for group G that is rooted at the\n\
    \   RP.  This is known as the RP Tree (RPT), and is also known as the\n   shared\
    \ tree because it is shared by all sources sending to that\n   group.  Join messages\
    \ are resent periodically so long as the receiver\n   remains in the group.  When\
    \ all receivers on a leaf-network leave the\n   group, the DR will send a PIM\
    \ (*,G) Prune message towards the RP for\n   that multicast group.  However, if\
    \ the Prune message is not sent for\n   any reason, the state will eventually\
    \ time out.\n   A multicast data sender just starts sending data destined for\
    \ a\n   multicast group.  The sender's local router (DR) takes those data\n  \
    \ packets, unicast-encapsulates them, and sends them directly to the\n   RP. \
    \ The RP receives these encapsulated data packets, decapsulates\n   them, and\
    \ forwards them onto the shared tree.  The packets then\n   follow the (*,G) multicast\
    \ tree state in the routers on the RP Tree,\n   being replicated wherever the\
    \ RP Tree branches, and eventually\n   reaching all the receivers for that multicast\
    \ group.  The process of\n   encapsulating data packets to the RP is called registering,\
    \ and the\n   encapsulation packets are known as PIM Register packets.\n   At\
    \ the end of phase one, multicast traffic is flowing encapsulated to\n   the RP,\
    \ and then natively over the RP tree to the multicast\n   receivers.\n"
- title: '3.2.  Phase Two: Register-Stop'
  contents:
  - "3.2.  Phase Two: Register-Stop\n   Register-encapsulation of data packets is\
    \ inefficient for two\n   reasons:\n   o  Encapsulation and decapsulation may\
    \ be relatively expensive\n      operations for a router to perform, depending\
    \ on whether or not\n      the router has appropriate hardware for these tasks.\n\
    \   o  Traveling all the way to the RP, and then back down the shared\n      tree\
    \ may result in the packets traveling a relatively long\n      distance to reach\
    \ receivers that are close to the sender.  For\n      some applications, this\
    \ increased latency or bandwidth consumption\n      is undesirable.\n   Although\
    \ Register-encapsulation may continue indefinitely, for these\n   reasons, the\
    \ RP will normally choose to switch to native forwarding.\n   To do this, when\
    \ the RP receives a register-encapsulated data packet\n   from source S on group\
    \ G, it will normally initiate an (S,G) source-\n   specific Join towards S. \
    \ This Join message travels hop-by-hop\n   towards S, instantiating (S,G) multicast\
    \ tree state in the routers\n   along the path.  (S,G) multicast tree state is\
    \ used only to forward\n   packets for group G if those packets come from source\
    \ S.  Eventually\n   the Join message reaches S's subnet or a router that already\
    \ has\n   (S,G) multicast tree state, and then packets from S start to flow\n\
    \   following the (S,G) tree state towards the RP.  These data packets\n   may\
    \ also reach routers with (*,G) state along the path towards the\n   RP; if they\
    \ do, they can shortcut onto the RP tree at this point.\n   While the RP is in\
    \ the process of joining the source-specific tree\n   for S, the data packets\
    \ will continue being encapsulated to the RP.\n   When packets from S also start\
    \ to arrive natively at the RP, the RP\n   will be receiving two copies of each\
    \ of these packets.  At this\n   point, the RP starts to discard the encapsulated\
    \ copy of these\n   packets, and it sends a Register-Stop message back to S's\
    \ DR to\n   prevent the DR from unnecessarily encapsulating the packets.\n   At\
    \ the end of phase two, traffic will be flowing natively from S\n   along a source-specific\
    \ tree to the RP, and from there along the\n   shared tree to the receivers. \
    \ Where the two trees intersect, traffic\n   may transfer from the source-specific\
    \ tree to the RP tree and thus\n   avoid taking a long detour via the RP.\n  \
    \ Note that a sender may start sending before or after a receiver joins\n   the\
    \ group, and thus phase two may happen before the shared tree to\n   the receiver\
    \ is built.\n"
- title: '3.3.  Phase Three: Shortest-Path Tree'
  contents:
  - "3.3.  Phase Three: Shortest-Path Tree\n   Although having the RP join back towards\
    \ the source removes the\n   encapsulation overhead, it does not completely optimize\
    \ the\n   forwarding paths.  For many receivers, the route via the RP may\n  \
    \ involve a significant detour when compared with the shortest path\n   from the\
    \ source to the receiver.\n   To obtain lower latencies or more efficient bandwidth\
    \ utilization, a\n   router on the receiver's LAN, typically the DR, may optionally\n\
    \   initiate a transfer from the shared tree to a source-specific\n   shortest-path\
    \ tree (SPT).  To do this, it issues an (S,G) Join\n   towards S.  This instantiates\
    \ state in the routers along the path to\n   S.  Eventually, this join either\
    \ reaches S's subnet or reaches a\n   router that already has (S,G) state.  When\
    \ this happens, data packets\n   from S start to flow following the (S,G) state\
    \ until they reach the\n   receiver.\n   At this point, the receiver (or a router\
    \ upstream of the receiver)\n   will be receiving two copies of the data: one\
    \ from the SPT and one\n   from the RPT.  When the first traffic starts to arrive\
    \ from the SPT,\n   the DR or upstream router starts to drop the packets for G\
    \ from S\n   that arrive via the RP tree.  In addition, it sends an (S,G) Prune\n\
    \   message towards the RP.  This is known as an (S,G,rpt) Prune.  The\n   Prune\
    \ message travels hop-by-hop, instantiating state along the path\n   towards the\
    \ RP indicating that traffic from S for G should NOT be\n   forwarded in this\
    \ direction.  The prune is propagated until it\n   reaches the RP or a router\
    \ that still needs the traffic from S for\n   other receivers.\n   By now, the\
    \ receiver will be receiving traffic from S along the\n   shortest-path tree between\
    \ the receiver and S.  In addition, the RP\n   is receiving the traffic from S,\
    \ but this traffic is no longer\n   reaching the receiver along the RP tree. \
    \ As far as the receiver is\n   concerned, this is the final distribution tree.\n"
- title: 3.4.  Source-Specific Joins
  contents:
  - "3.4.  Source-Specific Joins\n   IGMPv3 permits a receiver to join a group and\
    \ specify that it only\n   wants to receive traffic for a group if that traffic\
    \ comes from a\n   particular source.  If a receiver does this, and no other receiver\
    \ on\n   the LAN requires all the traffic for the group, then the DR may omit\n\
    \   performing a (*,G) join to set up the shared tree, and instead issue\n   a\
    \ source-specific (S,G) join only.\n   The range of multicast addresses from 232.0.0.0\
    \ to 232.255.255.255 is\n   currently set aside for source-specific multicast\
    \ in IPv4.  For\n   groups in this range, receivers should only issue source-specific\n\
    \   IGMPv3 joins.  If a PIM router receives a non-source-specific join\n   for\
    \ a group in this range, it should ignore it.\n"
- title: 3.5.  Source-Specific Prunes
  contents:
  - "3.5.  Source-Specific Prunes\n   IGMPv3 also permits a receiver to join a group\
    \ and to specify that it\n   only wants to receive traffic for a group if that\
    \ traffic does not\n   come from a specific source or sources.  In this case,\
    \ the DR will\n   perform a (*,G) join as normal, but may combine this with an\n\
    \   (S,G,rpt) prune for each of the sources the receiver does not wish to\n  \
    \ receive.\n"
- title: 3.6.  Multi-Access Transit LANs
  contents:
  - "3.6.  Multi-Access Transit LANs\n   The overview so far has concerned itself\
    \ with point-to-point transit\n   links.  However, using multi-access LANs such\
    \ as Ethernet for transit\n   is not uncommon.  This can cause complications for\
    \ three reasons:\n   o  Two or more routers on the LAN may issue (*,G) Joins to\
    \ different\n      upstream routers on the LAN because they have inconsistent\
    \ MRIB\n      entries regarding how to reach the RP.  Both paths on the RP tree\n\
    \      will be set up, causing two copies of all the shared tree traffic\n   \
    \   to appear on the LAN.\n   o  Two or more routers on the LAN may issue (S,G)\
    \ Joins to different\n      upstream routers on the LAN because they have inconsistent\
    \ MRIB\n      entries regarding how to reach source S.  Both paths on the\n  \
    \    source-specific tree will be set up, causing two copies of all the\n    \
    \  traffic from S to appear on the LAN.\n   o  A router on the LAN may issue a\
    \ (*,G) Join to one upstream router\n      on the LAN, and another router on the\
    \ LAN may issue an (S,G) Join\n      to a different upstream router on the same\
    \ LAN.  Traffic from S\n      may reach the LAN over both the RPT and the SPT.\
    \  If the receiver\n      behind the downstream (*,G) router doesn't issue an\
    \ (S,G,rpt)\n      prune, then this condition would persist.\n   All of these\
    \ problems are caused by there being more than one\n   upstream router with join\
    \ state for the group or source-group pair.\n   PIM does not prevent such duplicate\
    \ joins from occurring; instead,\n   when duplicate data packets appear on the\
    \ LAN from different routers,\n   these routers notice this and then elect a single\
    \ forwarder.  This\n   election is performed using PIM Assert messages, which\
    \ resolve the\n   problem in favor of the upstream router that has (S,G) state;\
    \ or, if\n   neither router or both routers have (S,G) state, then the problem\
    \ is\n   resolved in favor of the router with the best metric to the RP for RP\n\
    \   trees, or the best metric to the source for source-specific trees.\n   These\
    \ Assert messages are also received by the downstream routers on\n   the LAN,\
    \ and these cause subsequent Join messages to be sent to the\n   upstream router\
    \ that won the Assert.\n"
- title: 3.7.  RP Discovery
  contents:
  - "3.7.  RP Discovery\n   PIM-SM routers need to know the address of the RP for\
    \ each group for\n   which they have (*,G) state.  This address is obtained automatically\n\
    \   (e.g., embedded-RP), through a bootstrap mechanism, or through static\n  \
    \ configuration.\n   One dynamic way to do this is to use the Bootstrap Router\
    \ (BSR)\n   mechanism [11].  One router in each PIM domain is elected the BSR\n\
    \   through a simple election process.  All the routers in the domain\n   that\
    \ are configured to be candidates to be RPs periodically unicast\n   their candidacy\
    \ to the BSR.  From the candidates, the BSR picks an\n   RP-set, and periodically\
    \ announces this set in a Bootstrap message.\n   Bootstrap messages are flooded\
    \ hop-by-hop throughout the domain until\n   all routers in the domain know the\
    \ RP-Set.\n   To map a group to an RP, a router hashes the group address into\
    \ the\n   RP-set using an order-preserving hash function (one that minimizes\n\
    \   changes if the RP-Set changes).  The resulting RP is the one that it\n   uses\
    \ as the RP for that group.\n"
- title: 4.  Protocol Specification
  contents:
  - "4.  Protocol Specification\n   The specification of PIM-SM is broken into several\
    \ parts:\n   o  Section 4.1 details the protocol state stored.\n   o  Section\
    \ 4.2 specifies the data packet forwarding rules.\n   o  Section 4.3 specifies\
    \ Designated Router (DR) election and the\n      rules for sending and processing\
    \ Hello messages.\n   o  Section 4.4 specifies the PIM Register generation and\
    \ processing\n      rules.\n   o  Section 4.5 specifies the PIM Join/Prune generation\
    \ and processing\n      rules.\n   o  Section 4.6 specifies the PIM Assert generation\
    \ and processing\n      rules.\n   o  Section 4.7 specifies the RP discovery mechanisms.\n\
    \   o  Section 4.8 describes PIM-SSM, the subset of PIM required to\n      support\
    \ Source-Specific Multicast.\n   o  Section 4.9 specifies the PIM packet formats.\n\
    \   o  Section 4.10 provides a summary of PIM-SM timers, and Section 4.11\n  \
    \    provides their default values.\n"
- title: 4.1.  PIM Protocol State
  contents:
  - "4.1.  PIM Protocol State\n   This section specifies all the protocol state that\
    \ a PIM\n   implementation should maintain in order to function correctly.  We\n\
    \   term this state the Tree Information Base (TIB), as it holds the\n   state\
    \ of all the multicast distribution trees at this router.  In\n   this specification,\
    \ we define PIM mechanisms in terms of the TIB.\n   However, only a very simple\
    \ implementation would actually implement\n   packet forwarding operations in\
    \ terms of this state.  Most\n   implementations will use this state to build\
    \ a multicast forwarding\n   table, which would then be updated when the relevant\
    \ state in the TIB\n   changes.\n   Although we specify precisely the state to\
    \ be kept, this does not\n   mean that an implementation of PIM-SM needs to hold\
    \ the state in this\n   form.  This is actually an abstract state definition,\
    \ which is needed\n   in order to specify the router's behavior.  A PIM-SM implementation\n\
    \   is free to hold whatever internal state it requires and will still be\n  \
    \ conformant with this specification so long as it results in the same\n   externally\
    \ visible protocol behavior as an abstract router that holds\n   the following\
    \ state.\n   We divide TIB state into three sections:\n   (*,G) state\n      \
    \  State that maintains the RP tree for G.\n   (S,G) state\n        State that\
    \ maintains a source-specific tree for source S and\n        group G.\n   (S,G,rpt)\
    \ state\n        State that maintains source-specific information about source\
    \ S\n        on the RP tree for G.  For example, if a source is being\n      \
    \  received on the source-specific tree, it will normally have been\n        pruned\
    \ off the RP tree.  This prune state is (S,G,rpt) state.\n   The state that should\
    \ be kept is described below.  Of course,\n   implementations will only maintain\
    \ state when it is relevant to\n   forwarding operations; for example, the \"\
    NoInfo\" state might be\n   assumed from the lack of other state information rather\
    \ than being\n   held explicitly.\n"
- title: 4.1.1.  General-Purpose State
  contents:
  - "4.1.1.  General-Purpose State\n   A router holds the following non-group-specific\
    \ state:\n   For each interface:\n      o  Effective Override Interval\n     \
    \ o  Effective Propagation Delay\n      o  Suppression state: One of {\"Enable\"\
    , \"Disable\"}\n      Neighbor State:\n         For each neighbor:\n         o\
    \  Information from neighbor's Hello\n         o  Neighbor's GenID.\n        \
    \ o  Neighbor Liveness Timer (NLT)\n      Designated Router (DR) State:\n    \
    \     o  Designated Router's IP Address\n         o  DR's DR Priority\n   The\
    \ Effective Override Interval, the Effective Propagation Delay, and\n   the Interface\
    \ suppression state are described in Section 4.3.3.\n   Designated Router state\
    \ is described in Section 4.3.\n"
- title: 4.1.2.  (*,G) State
  contents:
  - "4.1.2.  (*,G) State\n   For every group G, a router keeps the following state:\n\
    \   (*,G) state:\n        For each interface:\n             Local Membership:\n\
    \                  State: One of {\"NoInfo\", \"Include\"}\n             PIM (*,G)\
    \ Join/Prune State:\n                  o  State: One of {\"NoInfo\" (NI), \"Join\"\
    \ (J),\n                     \"Prune-Pending\" (PP)}\n                  o  Prune-Pending\
    \ Timer (PPT)\n                  o  Join/Prune Expiry Timer (ET)\n           \
    \  (*,G) Assert Winner State\n                  o  State: One of {\"NoInfo\" (NI),\
    \ \"I lost Assert\" (L),\n                     \"I won Assert\" (W)}\n       \
    \           o  Assert Timer (AT)\n                  o  Assert winner's IP Address\
    \ (AssertWinner)\n                  o  Assert winner's Assert Metric (AssertWinnerMetric)\n\
    \        Not interface specific:\n             Upstream (*,G) Join/Prune State:\n\
    \                  o  State: One of {\"NotJoined(*,G)\", \"Joined(*,G)\"}\n  \
    \           o  Upstream Join/Prune Timer (JT)\n             o  Last RP Used\n\
    \             o  Last RPF Neighbor towards RP that was used\n   Local membership\
    \ is the result of the local membership mechanism\n   (such as IGMP or MLD) running\
    \ on that interface.  It need not be kept\n   if this router is not the DR on\
    \ that interface unless this router won\n   a (*,G) assert on this interface for\
    \ this group, although\n   implementations may optionally keep this state in case\
    \ they become\n   the DR or assert winner.  It is RECOMMENDED to store this information\n\
    \   if possible, as it reduces latency converging to stable operating\n   conditions\
    \ after a failure causing a change of DR.  This information\n   is used by the\
    \ pim_include(*,G) macro described in Section 4.1.5.\n   PIM (*,G) Join/Prune\
    \ state is the result of receiving PIM (*,G)\n   Join/Prune messages on this interface\
    \ and is specified in\n   Section 4.5.1.  The state is used by the macros that\
    \ calculate the\n   outgoing interface list in Section 4.1.5, and in the JoinDesired(*,G)\n\
    \   macro (defined in Section 4.5.4) that is used in deciding whether a\n   Join(*,G)\
    \ should be sent upstream.\n   (*,G) Assert Winner state is the result of sending\
    \ or receiving (*,G)\n   Assert messages on this interface.  It is specified in\
    \ Section 4.6.2.\n   The upstream (*,G) Join/Prune State reflects the state of\
    \ the\n   upstream (*,G) state machine described in Section 4.5.4.\n   The upstream\
    \ (*,G) Join/Prune Timer is used to send out periodic\n   Join(*,G) messages,\
    \ and to override Prune(*,G) messages from peers on\n   an upstream LAN interface.\n\
    \   The last RP used must be stored because if the RP changes, then state\n  \
    \ must be torn down and rebuilt for groups whose RP changes.\n   The last RPF\
    \ neighbor towards the RP is stored because if the MRIB\n   changes, then the\
    \ RPF neighbor towards the RP may change.  If it does\n   so, then we need to\
    \ trigger a new Join(*,G) to the new upstream\n   neighbor and a Prune(*,G) to\
    \ the old upstream neighbor.  Similarly,\n   if a router detects through a changed\
    \ GenID in a Hello message that\n   the upstream neighbor towards the RP has rebooted,\
    \ then it SHOULD\n   re-instantiate state by sending a Join(*,G).  These mechanisms\
    \ are\n   specified in Section 4.5.4.\n"
- title: 4.1.3.  (S,G) State
  contents:
  - "4.1.3.  (S,G) State\n   For every source/group pair (S,G), a router keeps the\
    \ following\n   state:\n   (S,G) state:\n        For each interface:\n       \
    \      Local Membership:\n                  State: One of {\"NoInfo\", \"Include\"\
    }\n             PIM (S,G) Join/Prune State:\n                  o  State: One of\
    \ {\"NoInfo\" (NI), \"Join\" (J),\n                     \"Prune-Pending\" (PP)}\n\
    \                  o  Prune-Pending Timer (PPT)\n                  o  Join/Prune\
    \ Expiry Timer (ET)\n             (S,G) Assert Winner State\n                \
    \  o  State: One of {\"NoInfo\" (NI), \"I lost Assert\" (L),\n               \
    \      \"I won Assert\" (W)}\n                  o  Assert Timer (AT)\n       \
    \           o  Assert winner's IP Address (AssertWinner)\n                  o\
    \  Assert winner's Assert Metric (AssertWinnerMetric)\n        Not interface specific:\n\
    \             Upstream (S,G) Join/Prune State:\n                  o  State: One\
    \ of {\"NotJoined(S,G)\", \"Joined(S,G)\"}\n             o  Upstream (S,G) Join/Prune\
    \ Timer (JT)\n             o  Last RPF Neighbor towards S that was used\n    \
    \         o  SPTbit (indicates (S,G) state is active)\n             o  (S,G) Keepalive\
    \ Timer (KAT)\n             Additional (S,G) state at the DR:\n              \
    \    o  Register state: One of {\"Join\" (J), \"Prune\" (P),\n               \
    \      \"Join-Pending\" (JP), \"NoInfo\" (NI)}\n                  o  Register-Stop\
    \ Timer (RST)\n   Local membership is the result of the local source-specific\n\
    \   membership mechanism (such as IGMP Version 3) running on that\n   interface\
    \ and specifying that this particular source should be\n   included.  As stored\
    \ here, this state is the resulting state after\n   any IGMPv3 inconsistencies\
    \ have been resolved.  It need not be kept\n   if this router is not the DR on\
    \ that interface unless this router won\n   an (S,G) assert on this interface\
    \ for this group.  However, it is\n   RECOMMENDED to store this information if\
    \ possible, as it reduces\n   latency converging to stable operating conditions\
    \ after a failure\n   causing a change of DR.  This information is used by the\n\
    \   pim_include(S,G) macro described in Section 4.1.5.\n   PIM (S,G) Join/Prune\
    \ state is the result of receiving PIM (S,G)\n   Join/Prune messages on this interface\
    \ and is specified in\n   Section 4.5.2.  The state is used by the macros that\
    \ calculate the\n   outgoing interface list in Section 4.1.5, and in the JoinDesired(S,G)\n\
    \   macro (defined in Section 4.5.5) that is used in deciding whether a\n   Join(S,G)\
    \ should be sent upstream.\n   (S,G) Assert Winner state is the result of sending\
    \ or receiving (S,G)\n   Assert messages on this interface.  It is specified in\
    \ Section 4.6.1.\n   The upstream (S,G) Join/Prune State reflects the state of\
    \ the\n   upstream (S,G) state machine described in Section 4.5.5.\n   The upstream\
    \ (S,G) Join/Prune Timer is used to send out periodic\n   Join(S,G) messages,\
    \ and to override Prune(S,G) messages from peers on\n   an upstream LAN interface.\n\
    \   The last RPF neighbor towards S is stored because if the MRIB\n   changes,\
    \ then the RPF neighbor towards S may change.  If it does so,\n   then we need\
    \ to trigger a new Join(S,G) to the new upstream neighbor\n   and a Prune(S,G)\
    \ to the old upstream neighbor.  Similarly, if the\n   router detects through\
    \ a changed GenID in a Hello message that the\n   upstream neighbor towards S\
    \ has rebooted, then it SHOULD\n   re-instantiate state by sending a Join(S,G).\
    \  These mechanisms are\n   specified in Section 4.5.5.\n   The SPTbit is used\
    \ to indicate whether forwarding is taking place on\n   the (S,G) Shortest Path\
    \ Tree (SPT) or on the (*,G) tree.  A router\n   can have (S,G) state and still\
    \ be forwarding on (*,G) state during\n   the interval when the source-specific\
    \ tree is being constructed.\n   When SPTbit is FALSE, only (*,G) forwarding state\
    \ is used to forward\n   packets from S to G.  When SPTbit is TRUE, both (*,G)\
    \ and (S,G)\n   forwarding state are used.\n   The (S,G) Keepalive Timer is updated\
    \ by data being forwarded using\n   this (S,G) forwarding state.  It is used to\
    \ keep (S,G) state alive in\n   the absence of explicit (S,G) Joins.  Amongst\
    \ other things, this is\n   necessary for the so-called \"turnaround rules\" --\
    \ when the RP uses\n   (S,G) joins to stop encapsulation, and then (S,G) prunes\
    \ to prevent\n   traffic from unnecessarily reaching the RP.\n   On a DR, the\
    \ (S,G) Register State is used to keep track of whether to\n   encapsulate data\
    \ to the RP on the Register Tunnel; the (S,G)\n   Register-Stop Timer tracks how\
    \ long before encapsulation begins again\n   for a given (S,G).\n"
- title: 4.1.4.  (S,G,rpt) State
  contents:
  - "4.1.4.  (S,G,rpt) State\n   For every source/group pair (S,G) for which a router\
    \ also has (*,G)\n   state, it also keeps the following state:\n   (S,G,rpt) state:\n\
    \        For each interface:\n             Local Membership:\n               \
    \   State: One of {\"NoInfo\", \"Exclude\"}\n             PIM (S,G,rpt) Join/Prune\
    \ State:\n                  o  State: One of {\"NoInfo\", \"Pruned\",\n      \
    \               \"Prune-Pending\"}\n                  o  Prune-Pending Timer (PPT)\n\
    \                  o  Join/Prune Expiry Timer (ET)\n        Not interface specific:\n\
    \             Upstream (S,G,rpt) Join/Prune State:\n                  o  State:\
    \ One of {\"RPTNotJoined(G)\",\n                     \"NotPruned(S,G,rpt)\", \"\
    Pruned(S,G,rpt)\"}\n                  o  Override Timer (OT)\n   Local membership\
    \ is the result of the local source-specific\n   membership mechanism (such as\
    \ IGMPv3) running on that interface and\n   specifying that although there is\
    \ (*,G) Include state, this\n   particular source should be excluded.  As stored\
    \ here, this state is\n   the resulting state after any IGMPv3 inconsistencies\
    \ between LAN\n   members have been resolved.  It need not be kept if this router\
    \ is\n   not the DR on that interface unless this router won a (*,G) assert on\n\
    \   this interface for this group.  However, we RECOMMEND storing this\n   information\
    \ if possible, as it reduces latency converging to stable\n   operating conditions\
    \ after a failure causing a change of DR.  This\n   information is used by the\
    \ pim_exclude(S,G) macro described in\n   Section 4.1.5.\n   PIM (S,G,rpt) Join/Prune\
    \ state is the result of receiving PIM\n   (S,G,rpt) Join/Prune messages on this\
    \ interface and is specified in\n   Section 4.5.3.  The state is used by the macros\
    \ that calculate the\n   outgoing interface list in Section 4.1.5, and in the\
    \ rules for adding\n   Prune(S,G,rpt) messages to Join(*,G) messages specified\
    \ in\n   Section 4.5.6.\n   The upstream (S,G,rpt) Join/Prune state is used along\
    \ with the\n   Override Timer to send the correct override messages in response\
    \ to\n   Join/Prune messages sent by upstream peers on a LAN.  This state and\n\
    \   behavior are specified in Section 4.5.7.\n"
- title: 4.1.5.  State Summarization Macros
  contents:
  - "4.1.5.  State Summarization Macros\n   Using this state, we define the following\
    \ \"macro\" definitions, which\n   we will use in the descriptions of the state\
    \ machines and pseudocode\n   in the following sections.\n   The most important\
    \ macros are those that define the outgoing\n   interface list (or \"olist\")\
    \ for the relevant state.  An olist can be\n   \"immediate\" if it is built directly\
    \ from the state of the relevant\n   type.  For example, the immediate_olist(S,G)\
    \ is the olist that would\n   be built if the router only had (S,G) state and\
    \ no (*,G) or (S,G,rpt)\n   state.  In contrast, the \"inherited\" olist inherits\
    \ state from other\n   types.  For example, the inherited_olist(S,G) is the olist\
    \ that is\n   relevant for forwarding a packet from S to G using both source-\n\
    \   specific and group-specific state.\n   There is no immediate_olist(S,G,rpt),\
    \ as (S,G,rpt) state is negative\n   state; it removes interfaces in the (*,G)\
    \ olist from the olist that\n   is actually used to forward traffic.  The inherited_olist(S,G,rpt)\
    \ is\n   therefore the olist that would be used for a packet from S to G\n   forwarding\
    \ on the RP tree.  It is a strict subset of\n   immediate_olist(*,G).\n   Generally\
    \ speaking, the inherited_olists are used for forwarding, and\n   the immediate_olists\
    \ are used to make decisions about state\n   maintenance.\n   immediate_olist(*,G)\
    \ =\n       joins(*,G) (+) pim_include(*,G) (-) lost_assert(*,G)\n   immediate_olist(S,G)\
    \ =\n       joins(S,G) (+) pim_include(S,G) (-) lost_assert(S,G)\n   inherited_olist(S,G,rpt)\
    \ =\n           ( joins(*,G) (-) prunes(S,G,rpt) )\n       (+) ( pim_include(*,G)\
    \ (-) pim_exclude(S,G))\n       (-) ( lost_assert(*,G) (+) lost_assert(S,G,rpt)\
    \ )\n   inherited_olist(S,G) =\n       inherited_olist(S,G,rpt) (+)\n       joins(S,G)\
    \ (+) pim_include(S,G) (-) lost_assert(S,G)\n   The macros pim_include(*,G) and\
    \ pim_include(S,G) indicate the\n   interfaces to which traffic might be forwarded\
    \ because of hosts that\n   are local members on that interface.  Note that normally\
    \ only the DR\n   cares about local membership, but when an assert happens, the\
    \ assert\n   winner takes over responsibility for forwarding traffic to local\n\
    \   members that have requested traffic on a group or source/group pair.\n   pim_include(*,G)\
    \ =\n       { all interfaces I such that:\n         ( ( I_am_DR( I ) AND lost_assert(*,G,I)\
    \ == FALSE )\n           OR AssertWinner(*,G,I) == me )\n          AND  local_receiver_include(*,G,I)\
    \ }\n   pim_include(S,G) =\n       { all interfaces I such that:\n         ( (I_am_DR(\
    \ I ) AND lost_assert(S,G,I) == FALSE )\n           OR AssertWinner(S,G,I) ==\
    \ me )\n          AND  local_receiver_include(S,G,I) }\n   pim_exclude(S,G) =\n\
    \       { all interfaces I such that:\n         ( (I_am_DR( I ) AND lost_assert(*,G,I)\
    \ == FALSE )\n           OR AssertWinner(*,G,I) == me )\n          AND  local_receiver_exclude(S,G,I)\
    \ }\n   The clause \"local_receiver_include(S,G,I)\" is true if the IGMP/MLD\n\
    \   module or other local membership mechanism has determined that local\n   members\
    \ on interface I desire to receive traffic sent specifically by\n   S to G.  \"\
    local_receiver_include(*,G,I)\" is true if the IGMP/MLD\n   module or other local\
    \ membership mechanism has determined that local\n   members on interface I desire\
    \ to receive all traffic sent to G\n   (possibly excluding traffic from a specific\
    \ set of sources).\n   \"local_receiver_exclude(S,G,I)\" is true if\n   \"local_receiver_include(*,G,I)\"\
    \ is true but none of the local members\n   desire to receive traffic from S.\n\
    \   The set \"joins(*,G)\" is the set of all interfaces on which the router\n\
    \   has received (*,G) Joins:\n   joins(*,G) =\n       { all interfaces I such\
    \ that\n         DownstreamJPState(*,G,I) is either Join or Prune-Pending }\n\
    \   DownstreamJPState(*,G,I) is the state of the finite state machine in\n   Section\
    \ 4.5.1.\n   The set \"joins(S,G)\" is the set of all interfaces on which the\
    \ router\n   has received (S,G) Joins:\n   joins(S,G) =\n       { all interfaces\
    \ I such that\n         DownstreamJPState(S,G,I) is either Join or Prune-Pending\
    \ }\n   DownstreamJPState(S,G,I) is the state of the finite state machine in\n\
    \   Section 4.5.2.\n   The set \"prunes(S,G,rpt)\" is the set of all interfaces\
    \ on which the\n   router has received (*,G) joins and (S,G,rpt) prunes:\n   prunes(S,G,rpt)\
    \ =\n       { all interfaces I such that\n         DownstreamJPState(S,G,rpt,I)\
    \ is Prune or PruneTmp }\n   DownstreamJPState(S,G,rpt,I) is the state of the\
    \ finite state machine\n   in Section 4.5.3.\n   The set \"lost_assert(*,G)\"\
    \ is the set of all interfaces on which the\n   router has received (*,G) joins\
    \ but has lost a (*,G) assert.  The\n   macro lost_assert(*,G,I) is defined in\
    \ Section 4.6.5.\n   lost_assert(*,G) =\n       { all interfaces I such that\n\
    \         lost_assert(*,G,I) == TRUE }\n   The set \"lost_assert(S,G,rpt)\" is\
    \ the set of all interfaces on which\n   the router has received (*,G) joins but\
    \ has lost an (S,G) assert.\n   The macro lost_assert(S,G,rpt,I) is defined in\
    \ Section 4.6.5.\n   lost_assert(S,G,rpt) =\n       { all interfaces I such that\n\
    \         lost_assert(S,G,rpt,I) == TRUE }\n   The set \"lost_assert(S,G)\" is\
    \ the set of all interfaces on which the\n   router has received (S,G) joins but\
    \ has lost an (S,G) assert.  The\n   macro lost_assert(S,G,I) is defined in Section\
    \ 4.6.5.\n   lost_assert(S,G) =\n       { all interfaces I such that\n       \
    \  lost_assert(S,G,I) == TRUE }\n   The following pseudocode macro definitions\
    \ are also used in many\n   places in the specification.  Basically, RPF' is the\
    \ RPF neighbor\n   towards an RP or source unless a PIM-Assert has overridden\
    \ the normal\n   choice of neighbor.\n     neighbor RPF'(*,G) {\n         if (\
    \ I_Am_Assert_Loser(*, G, RPF_interface(RP(G))) ) {\n              return AssertWinner(*,\
    \ G, RPF_interface(RP(G)) )\n         } else {\n              return NBR( RPF_interface(RP(G)),\
    \ MRIB.next_hop( RP(G) ) )\n         }\n     }\n     neighbor RPF'(S,G,rpt) {\n\
    \         if( I_Am_Assert_Loser(S, G, RPF_interface(RP(G)) ) ) {\n           \
    \   return AssertWinner(S, G, RPF_interface(RP(G)) )\n         } else {\n    \
    \          return RPF'(*,G)\n         }\n     }\n     neighbor RPF'(S,G) {\n \
    \        if ( I_Am_Assert_Loser(S, G, RPF_interface(S) )) {\n              return\
    \ AssertWinner(S, G, RPF_interface(S) )\n         } else {\n              return\
    \ NBR( RPF_interface(S), MRIB.next_hop( S ) )\n         }\n     }\n   RPF'(*,G)\
    \ and RPF'(S,G) indicate the neighbor from which data packets\n   should be coming\
    \ and to which joins should be sent on the RP tree and\n   SPT, respectively.\n\
    \   RPF'(S,G,rpt) is basically RPF'(*,G) modified by the result of an\n   Assert(S,G)\
    \ on RPF_interface(RP(G)).  In such a case, packets from S\n   will be originating\
    \ from a different router than RPF'(*,G).  If we\n   only have active (*,G) Join\
    \ state, we need to accept packets from\n   RPF'(S,G,rpt) and add a Prune(S,G,rpt)\
    \ to the periodic Join(*,G)\n   messages that we send to RPF'(*,G) (see Section\
    \ 4.5.6).\n   The function MRIB.next_hop( S ) returns an address of the next-hop\n\
    \   PIM neighbor toward the host S, as indicated by the current MRIB.  If\n  \
    \ S is directly adjacent, then MRIB.next_hop( S ) returns NULL.  At the\n   RP\
    \ for G, MRIB.next_hop( RP(G)) returns NULL.\n   The function NBR( I, A ) uses\
    \ information gathered through PIM Hello\n   messages to map the IP address A\
    \ of a directly connected PIM neighbor\n   router on interface I to the primary\
    \ IP address of the same router\n   (Section 4.3.4).  The primary IP address of\
    \ a neighbor is the address\n   that it uses as the source of its PIM Hello messages.\
    \  Note that a\n   neighbor's IP address may be non-unique within the PIM neighbor\n\
    \   database due to scope issues.  The address must, however, be unique\n   amongst\
    \ the addresses of all the PIM neighbors on a specific\n   interface.\n   I_Am_Assert_Loser(S,\
    \ G, I) is true if the Assert state machine (in\n   Section 4.6.1) for (S,G) on\
    \ Interface I is in \"I am Assert Loser\"\n   state.\n   I_Am_Assert_Loser(*,\
    \ G, I) is true if the Assert state machine (in\n   Section 4.6.2) for (*,G) on\
    \ Interface I is in \"I am Assert Loser\"\n   state.\n"
- title: 4.2.  Data Packet Forwarding Rules
  contents:
  - "4.2.  Data Packet Forwarding Rules\n   The PIM-SM packet forwarding rules are\
    \ defined below in pseudocode.\n      iif is the incoming interface of the packet.\n\
    \      S is the source address of the packet.\n      G is the destination address\
    \ of the packet (group address).\n      RP is the address of the Rendezvous Point\
    \ for this group.\n      RPF_interface(S) is the interface the MRIB indicates\
    \ would be used\n         to route packets to S.\n      RPF_interface(RP) is the\
    \ interface the MRIB indicates would be\n         used to route packets to the\
    \ RP, except at the RP when it is\n         the decapsulation interface (the \"\
    virtual\" interface on which\n         Register packets are received).\n   First,\
    \ we restart (or start) the Keepalive Timer if the source is on\n   a directly\
    \ connected subnet.\n   Second, we check to see if the SPTbit should be set because\
    \ we've now\n   switched from the RP tree to the SPT.\n   Next, we check to see\
    \ whether the packet should be accepted based on\n   TIB state and the interface\
    \ that the packet arrived on.\n   If the packet should be forwarded using (S,G)\
    \ state, we then build an\n   outgoing interface list for the packet.  If this\
    \ list is not empty,\n   then we restart the (S,G) state Keepalive Timer.\n  \
    \ If the packet should be forwarded using (*,G) state, then we just\n   build\
    \ an outgoing interface list for the packet.  We also check if we\n   should initiate\
    \ a switch to start receiving this source on a shortest\n   path tree.\n   Finally,\
    \ we remove the incoming interface from the outgoing interface\n   list we've\
    \ created, and if the resulting outgoing interface list is\n   not empty, we forward\
    \ the packet out of those interfaces.\n   On receipt of data from S to G on interface\
    \ iif:\n    if( DirectlyConnected(S) == TRUE AND iif == RPF_interface(S) ) {\n\
    \         set KeepaliveTimer(S,G) to Keepalive_Period\n         # Note: A register\
    \ state transition or UpstreamJPState(S,G)\n         # transition may happen as\
    \ a result of restarting\n         # KeepaliveTimer, and must be dealt with here.\n\
    \    }\n   if( iif == RPF_interface(S) AND UpstreamJPState(S,G) == Joined AND\n\
    \      inherited_olist(S,G) != NULL ) {\n          set KeepaliveTimer(S,G) to\
    \ Keepalive_Period\n   }\n   Update_SPTbit(S,G,iif)\n   oiflist = NULL\n   if(\
    \ iif == RPF_interface(S) AND SPTbit(S,G) == TRUE ) {\n      oiflist = inherited_olist(S,G)\n\
    \   } else if( iif == RPF_interface(RP(G)) AND SPTbit(S,G) == FALSE ) {\n    \
    \ oiflist = inherited_olist(S,G,rpt)\n     CheckSwitchToSpt(S,G)\n   } else {\n\
    \      # Note: RPF check failed.\n      # A transition in an Assert finite state\
    \ machine may cause an\n      # Assert(S,G) or Assert(*,G) message to be sent\
    \ out interface iif.\n      # See Section 4.6 for details.\n      if ( SPTbit(S,G)\
    \ == TRUE AND iif is in inherited_olist(S,G) ) {\n         send Assert(S,G) on\
    \ iif\n      } else if ( SPTbit(S,G) == FALSE AND\n                  iif is in\
    \ inherited_olist(S,G,rpt) ) {\n         send Assert(*,G) on iif\n      }\n  \
    \ }\n   oiflist = oiflist (-) iif\n   forward packet on all interfaces in oiflist\n\
    \   This pseudocode employs several \"macro\" definitions:\n   DirectlyConnected(S)\
    \ is TRUE if the source S is on any subnet that is\n   directly connected to this\
    \ router (or for packets originating on this\n   router).\n   inherited_olist(S,G)\
    \ and inherited_olist(S,G,rpt) are defined in\n   Section 4.1.\n   Basically,\
    \ inherited_olist(S,G) is the outgoing interface list for\n   packets forwarded\
    \ on (S,G) state, taking into account (*,G) state,\n   asserts, etc.\n   inherited_olist(S,G,rpt)\
    \ is the outgoing interface list for packets\n   forwarded on (*,G) state, taking\
    \ into account (S,G,rpt) prune state,\n   asserts, etc.\n   Update_SPTbit(S,G,iif)\
    \ is defined in Section 4.2.2.\n   CheckSwitchToSpt(S,G) is defined in Section\
    \ 4.2.1.\n   UpstreamJPState(S,G) is the state of the finite state machine in\n\
    \   Section 4.5.5.\n   Keepalive_Period is defined in Section 4.11.\n   Data-triggered\
    \ PIM-Assert messages sent from the above forwarding\n   code SHOULD be rate-limited\
    \ in an implementation-dependent manner.\n"
- title: 4.2.1.  Last-Hop Switchover to the SPT
  contents:
  - "4.2.1.  Last-Hop Switchover to the SPT\n   In Sparse-Mode PIM, last-hop routers\
    \ join the shared tree towards the\n   RP.  Once traffic from sources to joined\
    \ groups arrives at a last-hop\n   router, it has the option of switching to receive\
    \ the traffic on a\n   shortest path tree (SPT).\n   The decision for a router\
    \ to switch to the SPT is controlled as\n   follows:\n     void\n     CheckSwitchToSpt(S,G)\
    \ {\n       if ( ( pim_include(*,G) (-) pim_exclude(S,G)\n              (+) pim_include(S,G)\
    \ != NULL )\n            AND SwitchToSptDesired(S,G) ) {\n              # Note:\
    \ Restarting the KAT will result in the SPT switch.\n              set KeepaliveTimer(S,G)\
    \ to Keepalive_Period\n       }\n     }\n   SwitchToSptDesired(S,G) is a policy\
    \ function that is implementation\n   defined.  An \"infinite threshold\" policy\
    \ can be implemented by making\n   SwitchToSptDesired(S,G) return false all the\
    \ time.  A \"switch on\n   first packet\" policy can be implemented by making\n\
    \   SwitchToSptDesired(S,G) return true once a single packet has been\n   received\
    \ for the source and group.\n"
- title: 4.2.2.  Setting and Clearing the (S,G) SPTbit
  contents:
  - "4.2.2.  Setting and Clearing the (S,G) SPTbit\n   The (S,G) SPTbit is used to\
    \ distinguish whether to forward on (*,G)\n   or on (S,G) state.  When switching\
    \ from the RP tree to the source\n   tree, there is a transition period when data\
    \ is arriving due to\n   upstream (*,G) state while upstream (S,G) state is being\
    \ established,\n   during which time a router should continue to forward only\
    \ on (*,G)\n   state.  This prevents temporary black holes that would be caused\
    \ by\n   sending a Prune(S,G,rpt) before the upstream (S,G) state has finished\n\
    \   being established.\n   Thus, when a packet arrives, the (S,G) SPTbit is updated\
    \ as follows:\n     void\n     Update_SPTbit(S,G,iif) {\n       if ( iif == RPF_interface(S)\n\
    \             AND JoinDesired(S,G) == TRUE\n             AND ( DirectlyConnected(S)\
    \ == TRUE\n                   OR RPF_interface(S) != RPF_interface(RP(G))\n  \
    \                 OR inherited_olist(S,G,rpt) == NULL\n                   OR (\
    \ ( RPF'(S,G) == RPF'(*,G) ) AND\n                        ( RPF'(S,G) != NULL\
    \ ) )\n                   OR ( I_Am_Assert_Loser(S,G,iif) ) ) ) {\n          Set\
    \ SPTbit(S,G) to TRUE\n       }\n     }\n   Additionally, a router can set SPTbit(S,G)\
    \ to TRUE in other cases,\n   such as when it receives an Assert(S,G) on RPF_interface(S)\
    \ (see\n   Section 4.6.1).\n   JoinDesired(S,G) is defined in Section 4.5.5 and\
    \ indicates whether we\n   have the appropriate (S,G) Join state to wish to send\
    \ a Join(S,G)\n   upstream.\n   Basically, Update_SPTbit(S,G,iif) will set the\
    \ SPTbit if we have the\n   appropriate (S,G) join state, and if the packet arrived\
    \ on the\n   correct upstream interface for S, and if one or more of the following\n\
    \   conditions apply:\n   1.  The source is directly connected, in which case\
    \ the switch to the\n       SPT is a no-op.\n   2.  The RPF interface to S is\
    \ different from the RPF interface to the\n       RP.  The packet arrived on RPF_interface(S),\
    \ and so the SPT must\n       have been completed.\n   3.  No one wants the packet\
    \ on the RP tree.\n   4.  RPF'(S,G) == RPF'(*,G).  In this case, the router will\
    \ never be\n       able to tell if the SPT has been completed, so it should just\n\
    \       switch immediately.  The RPF'(S,G) != NULL check ensures that the\n  \
    \     SPTbit is set only if the RPF neighbor towards S is valid.\n   In the case\
    \ where the RPF interface is the same for the RP and for S,\n   but RPF'(S,G)\
    \ and RPF'(*,G) differ, we wait for an Assert(S,G), which\n   indicates that the\
    \ upstream router with (S,G) state believes the SPT\n   has been completed.  However,\
    \ item (3) above is needed because there\n   may not be any (*,G) state to trigger\
    \ an Assert(S,G) to happen.\n   The SPTbit is cleared in the (S,G) upstream state\
    \ machine (see\n   Section 4.5.5) when JoinDesired(S,G) becomes FALSE.\n"
- title: 4.3.  Designated Routers (DRs) and Hello Messages
  contents:
  - "4.3.  Designated Routers (DRs) and Hello Messages\n   A shared-media LAN like\
    \ Ethernet may have multiple PIM-SM routers\n   connected to it.  A single one\
    \ of these routers, the DR, will act on\n   behalf of directly connected hosts\
    \ with respect to the PIM-SM\n   protocol.  Because the distinction between LANs\
    \ and point-to-point\n   interfaces can sometimes be blurred, and because routers\
    \ may also\n   have multicast host functionality, the PIM-SM specification makes\
    \ no\n   distinction between the two.  Thus, DR election will happen on all\n\
    \   interfaces, LAN or otherwise.\n   DR election is performed using Hello messages.\
    \  Hello messages are\n   also the way that option negotiation takes place in\
    \ PIM, so that\n   additional functionality can be enabled, or parameters tuned.\n"
- title: 4.3.1.  Sending Hello Messages
  contents:
  - "4.3.1.  Sending Hello Messages\n   PIM Hello messages are sent periodically on\
    \ each PIM-enabled\n   interface.  They allow a router to learn about the neighboring\
    \ PIM\n   routers on each interface.  Hello messages are also the mechanism\n\
    \   used to elect a DR, and to negotiate additional capabilities.  A\n   router\
    \ must record the Hello information received from each PIM\n   neighbor.\n   Hello\
    \ messages MUST be sent on all active interfaces, including\n   physical point-to-point\
    \ links, and are multicast to the\n   'ALL-PIM-ROUTERS' group address ('224.0.0.13'\
    \ for IPv4 and 'ff02::d'\n   for IPv6).\n   We note that some implementations\
    \ do not send Hello messages on\n   point-to-point interfaces.  This is non-compliant\
    \ behavior.  A\n   compliant PIM router MUST send Hello messages, even on point-to-point\n\
    \   interfaces.\n   A per-interface Hello Timer (HT(I)) is used to trigger sending\
    \ Hello\n   messages on each active interface.  When PIM is enabled on an\n  \
    \ interface or a router first starts, the Hello Timer of that interface\n   is\
    \ set to a random value between 0 and Triggered_Hello_Delay.  This\n   prevents\
    \ synchronization of Hello messages if multiple routers are\n   powered on simultaneously.\
    \  After the initial randomized interval,\n   Hello messages MUST be sent every\
    \ Hello_Period seconds.  The\n   Hello Timer SHOULD NOT be reset except when it\
    \ expires.\n   Note that neighbors will not accept Join/Prune or Assert messages\n\
    \   from a router unless they have first heard a Hello message from that\n   router.\
    \  Thus, if a router needs to send a Join/Prune or Assert\n   message on an interface\
    \ on which it has not yet sent a Hello message\n   with the currently configured\
    \ IP address, then it MUST immediately\n   send the relevant Hello message without\
    \ waiting for the Hello Timer\n   to expire, followed by the Join/Prune or Assert\
    \ message.\n   The DR Priority option allows a network administrator to give\n\
    \   preference to a particular router in the DR election process by\n   giving\
    \ it a numerically larger DR Priority.  The DR Priority option\n   SHOULD be included\
    \ in every Hello message, even if no DR Priority is\n   explicitly configured\
    \ on that interface.  This is necessary because\n   priority-based DR election\
    \ is only enabled when all neighbors on an\n   interface advertise that they are\
    \ capable of using the DR Priority\n   option.  The default priority is 1.\n \
    \  The Generation Identifier (GenID) option SHOULD be included in all\n   Hello\
    \ messages.  The GenID option contains a randomly generated\n   32-bit value that\
    \ is regenerated each time PIM forwarding is started\n   or restarted on the interface,\
    \ including when the router itself\n   restarts.  When a Hello message with a\
    \ new GenID is received from a\n   neighbor, any old Hello information about that\
    \ neighbor SHOULD be\n   discarded and superseded by the information from the\
    \ new Hello\n   message.  This may cause a new DR to be chosen on that interface.\n\
    \   The LAN Prune Delay option SHOULD be included in all Hello messages\n   sent\
    \ on multi-access LANs.  This option advertises a router's\n   capability to use\
    \ values other than the defaults for the\n   Propagation_Delay and Override_Interval,\
    \ which affect the setting of\n   the Prune-Pending, Upstream Join, and Override\
    \ Timers (defined in\n   Section 4.10).\n   The Address List option advertises\
    \ all the secondary addresses\n   associated with the source interface of the\
    \ router originating the\n   message.  The option MUST be included in all Hello\
    \ messages if there\n   are secondary addresses associated with the source interface\
    \ and MAY\n   be omitted if no secondary addresses exist.\n   To allow new or\
    \ rebooting routers to learn of PIM neighbors quickly,\n   when a Hello message\
    \ is received from a new neighbor, or a Hello\n   message with a new GenID is\
    \ received from an existing neighbor, a new\n   Hello message SHOULD be sent on\
    \ this interface after a randomized\n   delay between 0 and Triggered_Hello_Delay.\
    \  This triggered message\n   need not change the timing of the scheduled periodic\
    \ message.  If a\n   router needs to send a Join/Prune to the new neighbor or\
    \ send an\n   Assert message in response to an Assert message from the new neighbor\n\
    \   before this randomized delay has expired, then it MUST immediately\n   send\
    \ the relevant Hello message without waiting for the Hello Timer\n   to expire,\
    \ followed by the Join/Prune or Assert message.  If it does\n   not do this, then\
    \ the new neighbor will discard the Join/Prune or\n   Assert message.\n   Before\
    \ an interface goes down or changes primary IP address, a Hello\n   message with\
    \ a zero HoldTime SHOULD be sent immediately (with the old\n   IP address if the\
    \ IP address changed).  This will cause PIM neighbors\n   to remove this neighbor\
    \ (or its old IP address) immediately.  After\n   an interface has changed its\
    \ IP address, it MUST send a Hello message\n   with its new IP address.  If an\
    \ interface changes one of its\n   secondary IP addresses, a Hello message with\
    \ an updated Address List\n   option and a non-zero HoldTime SHOULD be sent immediately.\
    \  This will\n   cause PIM neighbors to update this neighbor's list of secondary\n\
    \   addresses immediately.\n"
- title: 4.3.2.  DR Election
  contents:
  - "4.3.2.  DR Election\n   When a PIM Hello message is received on interface I,\
    \ the following\n   information about the sending neighbor is recorded:\n    \
    \  neighbor.interface\n            The interface on which the Hello message arrived.\n\
    \      neighbor.primary_ip_address\n            The IP address that the PIM neighbor\
    \ used as the source\n            address of the Hello message.\n      neighbor.genid\n\
    \            The Generation ID of the PIM neighbor.\n      neighbor.dr_priority\n\
    \            The DR Priority field of the PIM neighbor, if it is present\n   \
    \         in the Hello message.\n      neighbor.dr_priority_present\n        \
    \    A flag indicating if the DR Priority field was present in\n            the\
    \ Hello message.\n      neighbor.timeout\n            A timer value to time out\
    \ the neighbor state when it becomes\n            stale, also known as the Neighbor\
    \ Liveness Timer.\n            The Neighbor Liveness Timer (NLT(N,I)) is reset\
    \ to\n            Hello_Holdtime (from the Hello Holdtime option) whenever a\n\
    \            Hello message is received containing a Holdtime option, or\n    \
    \        to Default_Hello_Holdtime if the Hello message does not\n           \
    \ contain the Holdtime option.\n            Neighbor state is deleted when the\
    \ neighbor timeout expires.\n   The function for computing the DR on interface\
    \ I is:\n     host\n     DR(I) {\n         dr = me\n         for each neighbor\
    \ on interface I {\n             if ( dr_is_better( neighbor, dr, I ) == TRUE\
    \ ) {\n                 dr = neighbor\n             }\n         }\n         return\
    \ dr\n     }\n   The function used for comparing DR \"metrics\" on interface I\
    \ is:\n     bool\n     dr_is_better(a,b,I) {\n         if( there is a neighbor\
    \ n on I for which n.dr_priority_present\n                 is false ) {\n    \
    \         return a.primary_ip_address > b.primary_ip_address\n         } else\
    \ {\n             return ( a.dr_priority > b.dr_priority ) OR\n              \
    \      ( a.dr_priority == b.dr_priority AND\n                      a.primary_ip_address\
    \ > b.primary_ip_address )\n         }\n     }\n   The trivial function I_am_DR(I)\
    \ is defined to aid readability:\n     bool\n     I_am_DR(I) {\n        return\
    \ DR(I) == me\n     }\n   The DR Priority is a 32-bit unsigned number, and the\
    \ numerically\n   larger priority is always preferred.  A router's idea of the\
    \ current\n   DR on an interface can change when a PIM Hello message is received,\n\
    \   when a neighbor times out, or when a router's own DR Priority\n   changes.\
    \  If the router becomes the DR or ceases to be the DR, this\n   will normally\
    \ cause the DR Register state machine to change state.\n   Subsequent actions\
    \ are determined by that state machine.\n      We note that some PIM implementations\
    \ do not send Hello messages\n      on point-to-point interfaces and thus cannot\
    \ perform DR election\n      on such interfaces.  This is non-compliant behavior.\
    \  DR election\n      MUST be performed on ALL active PIM-SM interfaces.\n"
- title: 4.3.3.  Reducing Prune Propagation Delay on LANs
  contents:
  - "4.3.3.  Reducing Prune Propagation Delay on LANs\n   In addition to the information\
    \ recorded for the DR Election, the\n   following per-neighbor information is\
    \ obtained from the LAN Prune\n   Delay Hello option:\n      neighbor.lan_prune_delay_present\n\
    \            A flag indicating if the LAN Prune Delay option was present\n   \
    \         in the Hello message.\n      neighbor.tracking_support\n           \
    \ A flag storing the value of the T bit in the LAN Prune Delay\n            option\
    \ if it is present in the Hello message.  This\n            indicates the neighbor's\
    \ capability to disable Join message\n            suppression.\n      neighbor.propagation_delay\n\
    \            The Propagation Delay field of the LAN Prune Delay option\n     \
    \       (if present) in the Hello message.\n      neighbor.override_interval\n\
    \            The Override_Interval field of the LAN Prune Delay option\n     \
    \       (if present) in the Hello message.\n   The additional state described\
    \ above is deleted along with the DR\n   neighbor state when the neighbor timeout\
    \ expires.\n   Just like the DR Priority option, the information provided in the\
    \ LAN\n   Prune Delay option is not used unless all neighbors on a link\n   advertise\
    \ the option.  The function below computes this state:\n     bool\n     lan_delay_enabled(I)\
    \ {\n         for each neighbor on interface I {\n             if ( neighbor.lan_prune_delay_present\
    \ == false ) {\n                 return false\n             }\n         }\n  \
    \       return true\n     }\n   The Propagation Delay inserted by a router in\
    \ the LAN Prune Delay\n   option expresses the expected message propagation delay\
    \ on the link\n   and SHOULD be configurable by the system administrator.  It\
    \ is used\n   by upstream routers to figure out how long they should wait for\
    \ a\n   Join override message before pruning an interface.\n   PIM implementers\
    \ SHOULD enforce a lower bound on the permitted values\n   for this delay to allow\
    \ for scheduling and processing delays within\n   their router.  Such delays may\
    \ cause received messages to be\n   processed later as well as triggered messages\
    \ to be sent later than\n   intended.  Setting this Propagation Delay to too low\
    \ a value may\n   result in temporary forwarding outages because a downstream\
    \ router\n   will not be able to override a neighbor's Prune message before the\n\
    \   upstream neighbor stops forwarding.\n   When all routers on a link are in\
    \ a position to negotiate a\n   Propagation Delay different from the default,\
    \ the largest value from\n   those advertised by each neighbor is chosen.  The\
    \ function for\n   computing the Effective Propagation Delay of interface I is:\n\
    \     time_interval\n     Effective_Propagation_Delay(I) {\n         if ( lan_delay_enabled(I)\
    \ == false ) {\n             return Propagation_delay_default\n         }\n  \
    \       delay = Propagation_Delay(I)\n         for each neighbor on interface\
    \ I {\n             if ( neighbor.propagation_delay > delay ) {\n            \
    \     delay = neighbor.propagation_delay\n             }\n         }\n       \
    \  return delay\n     }\n   To avoid synchronization of override messages when\
    \ multiple\n   downstream routers share a multi-access link, the sending of such\n\
    \   messages is delayed by a small random amount of time.  The period of\n   randomization\
    \ should represent the size of the PIM router population\n   on the link.  Each\
    \ router expresses its view of the amount of\n   randomization necessary in the\
    \ Override Interval field of the LAN\n   Prune Delay option.\n   When all routers\
    \ on a link are in a position to negotiate an Override\n   Interval different\
    \ from the default, the largest value from those\n   advertised by each neighbor\
    \ is chosen.  The function for computing\n   the Effective Override Interval of\
    \ interface I is:\n     time_interval\n     Effective_Override_Interval(I) {\n\
    \         if ( lan_delay_enabled(I) == false ) {\n             return t_override_default\n\
    \         }\n         delay = Override_Interval(I)\n         for each neighbor\
    \ on interface I {\n             if ( neighbor.override_interval > delay ) {\n\
    \                 delay = neighbor.override_interval\n             }\n       \
    \  }\n         return delay\n     }\n   Although the mechanisms are not specified\
    \ in this document, it is\n   possible for upstream routers to explicitly track\
    \ the join\n   membership of individual downstream routers if Join suppression\
    \ is\n   disabled.  A router can advertise its willingness to disable Join\n \
    \  suppression by using the T bit in the LAN Prune Delay Hello option.\n   Unless\
    \ all PIM routers on a link negotiate this capability, explicit\n   tracking and\
    \ the disabling of the Join suppression mechanism are not\n   possible.  The function\
    \ for computing the state of Suppression on\n   interface I is:\n     bool\n \
    \    Suppression_Enabled(I) {\n         if ( lan_delay_enabled(I) == false ) {\n\
    \             return true\n         }\n         for each neighbor on interface\
    \ I {\n             if ( neighbor.tracking_support == false ) {\n            \
    \     return true\n             }\n         }\n         return false\n     }\n\
    \   Note that the setting of Suppression_Enabled(I) affects the value of\n   t_suppressed\
    \ (see Section 4.11).\n"
- title: 4.3.4.  Maintaining Secondary Address Lists
  contents:
  - "4.3.4.  Maintaining Secondary Address Lists\n   Communication of a router's interface\
    \ secondary addresses to its PIM\n   neighbors is necessary to provide the neighbors\
    \ with a mechanism for\n   mapping next_hop information obtained through their\
    \ MRIB to a primary\n   address that can be used as a destination for Join/Prune\
    \ messages.\n   The mapping is performed through the NBR macro.  The primary address\n\
    \   of a PIM neighbor is obtained from the source IP address used in its\n   PIM\
    \ Hello messages.  Secondary addresses are carried within the Hello\n   message\
    \ in an Address List Hello option.  The primary address of the\n   source interface\
    \ of the router MUST NOT be listed within the Address\n   List Hello option.\n\
    \   In addition to the information recorded for the DR Election, the\n   following\
    \ per-neighbor information is obtained from the Address List\n   Hello option:\n\
    \      neighbor.secondary_address_list\n            The list of secondary addresses\
    \ used by the PIM neighbor on\n            the interface through which the Hello\
    \ message was\n            transmitted.\n   When processing a received PIM Hello\
    \ message containing an Address\n   List Hello option, the list of secondary addresses\
    \ in the message\n   completely replaces any previously associated secondary addresses\
    \ for\n   that neighbor.  If a received PIM Hello message does not contain an\n\
    \   Address List Hello option, then all secondary addresses associated\n   with\
    \ the neighbor MUST be deleted.  If a received PIM Hello message\n   contains\
    \ an Address List Hello option that includes the primary\n   address of the sending\
    \ router in the list of secondary addresses\n   (although this is not expected),\
    \ then the addresses listed in the\n   message, excluding the primary address,\
    \ are used to update the\n   associated secondary addresses for that neighbor.\n\
    \   All the advertised secondary addresses in received Hello messages\n   must\
    \ be checked against those previously advertised by all other PIM\n   neighbors\
    \ on that interface.  If there is a conflict and the same\n   secondary address\
    \ was previously advertised by another neighbor, then\n   only the most recently\
    \ received mapping MUST be maintained, and an\n   error message SHOULD be logged\
    \ to the administrator in a rate-limited\n   manner.\n   Within one Address List\
    \ Hello option, all the addresses MUST be of\n   the same address family.  It\
    \ is not permitted to mix IPv4 and IPv6\n   addresses within the same message.\
    \  In addition, the address family\n   of the fields in the message SHOULD be\
    \ the same as the IP source and\n   destination addresses of the packet header.\n"
- title: 4.4.  PIM Register Messages
  contents:
  - "4.4.  PIM Register Messages\n   The Designated Router (DR) on a LAN or point-to-point\
    \ link\n   encapsulates multicast packets from local sources to the RP for the\n\
    \   relevant group unless it recently received a Register-Stop message\n   for\
    \ that (S,G) or (*,G) from the RP.  When the DR receives a\n   Register-Stop message\
    \ from the RP, it starts a Register-Stop Timer to\n   maintain this state.  Just\
    \ before the Register-Stop Timer expires,\n   the DR sends a Null-Register message\
    \ to the RP to allow the RP to\n   refresh the Register-Stop information at the\
    \ DR.  If the\n   Register-Stop Timer actually expires, the DR will resume\n \
    \  encapsulating packets from the source to the RP.\n"
- title: 4.4.1.  Sending Register Messages from the DR
  contents:
  - "4.4.1.  Sending Register Messages from the DR\n   Every PIM-SM router has the\
    \ capability to be a DR.  The state machine\n   below is used to implement Register\
    \ functionality.  For the purposes\n   of specification, we represent the mechanism\
    \ to encapsulate packets\n   to the RP as a Register-Tunnel interface, which is\
    \ added to or\n   removed from the (S,G) olist.  The tunnel interface then takes\
    \ part\n   in the normal packet forwarding rules as specified in Section 4.2.\n\
    \   If register state is maintained, it is maintained only for directly\n   connected\
    \ sources and is per-(S,G).  There are four states in the\n   DR's per-(S,G) Register\
    \ state machine:\n      Join (J)\n            The register tunnel is \"joined\"\
    \ (the join is actually\n            implicit, but the DR acts as if the RP has\
    \ joined the DR on\n            the tunnel interface).\n      Prune (P)\n    \
    \        The register tunnel is \"pruned\" (this occurs when a\n            Register-Stop\
    \ is received).\n      Join-Pending (JP)\n            The register tunnel is pruned\
    \ but the DR is contemplating\n            adding it back.\n      NoInfo (NI)\n\
    \            No information.  This is the initial state, and the state\n     \
    \       when the router is not the DR.\n   In addition, a Register-Stop Timer\
    \ (RST) is kept if the state machine\n   is not in the NoInfo state.\n       \
    \    Figure 1: Per-(S,G) Register State Machine at a DR\n"
- title: +----------++----------------------------------------------------------+
  contents:
  - '+----------++----------------------------------------------------------+

    '
- title: '|          ||                          Event                           |'
  contents:
  - '|          ||                          Event                           |

    '
- title: '|          ++----------+-----------+-----------+-----------+-----------+'
  contents:
  - '|          ++----------+-----------+-----------+-----------+-----------+

    '
- title: '|Prev State||Register- | Could     | Could     | Register- | RP changed|'
  contents:
  - '|Prev State||Register- | Could     | Could     | Register- | RP changed|

    '
- title: '|          ||Stop Timer| Register  | Register  | Stop      |           |'
  contents:
  - '|          ||Stop Timer| Register  | Register  | Stop      |           |

    '
- title: '|          ||expires   | ->True    | ->False   | received  |           |'
  contents:
  - '|          ||expires   | ->True    | ->False   | received  |           |

    '
- title: +----------++----------+-----------+-----------+-----------+-----------+
  contents:
  - '+----------++----------+-----------+-----------+-----------+-----------+

    '
- title: '|NoInfo    ||-         | -> J state| -         | -         | -         |'
  contents:
  - '|NoInfo    ||-         | -> J state| -         | -         | -         |

    '
- title: '|(NI)      ||          | add reg   |           |           |           |'
  contents:
  - '|(NI)      ||          | add reg   |           |           |           |

    '
- title: '|          ||          | tunnel    |           |           |           |'
  contents:
  - '|          ||          | tunnel    |           |           |           |

    '
- title: +----------++----------+-----------+-----------+-----------+-----------+
  contents:
  - '+----------++----------+-----------+-----------+-----------+-----------+

    '
- title: '|          ||-         | -         | -> NI     | -> P state| -> J state|'
  contents:
  - '|          ||-         | -         | -> NI     | -> P state| -> J state|

    '
- title: '|          ||          |           | state     |           |           |'
  contents:
  - '|          ||          |           | state     |           |           |

    '
- title: '|          ||          |           | remove reg| remove reg| update reg|'
  contents:
  - '|          ||          |           | remove reg| remove reg| update reg|

    '
- title: '|Join (J)  ||          |           | tunnel    | tunnel;   | tunnel    |'
  contents:
  - '|Join (J)  ||          |           | tunnel    | tunnel;   | tunnel    |

    '
- title: '|          ||          |           |           | set       |           |'
  contents:
  - '|          ||          |           |           | set       |           |

    '
- title: '|          ||          |           |           | Register- |           |'
  contents:
  - '|          ||          |           |           | Register- |           |

    '
- title: '|          ||          |           |           | Stop      |           |'
  contents:
  - '|          ||          |           |           | Stop      |           |

    '
- title: '|          ||          |           |           | Timer(*)  |           |'
  contents:
  - '|          ||          |           |           | Timer(*)  |           |

    '
- title: +----------++----------+-----------+-----------+-----------+-----------+
  contents:
  - '+----------++----------+-----------+-----------+-----------+-----------+

    '
- title: '|          ||-> J state| -         | -> NI     | -> P state| -> J state|'
  contents:
  - '|          ||-> J state| -         | -> NI     | -> P state| -> J state|

    '
- title: '|          ||          |           | state     |           |           |'
  contents:
  - '|          ||          |           | state     |           |           |

    '
- title: '|Join-     ||add reg   |           |           | set       | add reg   |'
  contents:
  - '|Join-     ||add reg   |           |           | set       | add reg   |

    '
- title: '|Pending   ||tunnel    |           |           | Register- | tunnel;   |'
  contents:
  - '|Pending   ||tunnel    |           |           | Register- | tunnel;   |

    '
- title: '|(JP)      ||          |           |           | Stop      | cancel    |'
  contents:
  - '|(JP)      ||          |           |           | Stop      | cancel    |

    '
- title: '|          ||          |           |           | Timer(*)  | Register- |'
  contents:
  - '|          ||          |           |           | Timer(*)  | Register- |

    '
- title: '|          ||          |           |           |           | Stop Timer|'
  contents:
  - '|          ||          |           |           |           | Stop Timer|

    '
- title: +----------++----------+-----------+-----------+-----------+-----------+
  contents:
  - '+----------++----------+-----------+-----------+-----------+-----------+

    '
- title: '|          ||-> JP     | -         | -> NI     | -         | -> J state|'
  contents:
  - '|          ||-> JP     | -         | -> NI     | -         | -> J state|

    '
- title: '|          ||state     |           | state     |           |           |'
  contents:
  - '|          ||state     |           | state     |           |           |

    '
- title: '|          ||set       |           |           |           | add reg   |'
  contents:
  - '|          ||set       |           |           |           | add reg   |

    '
- title: '|Prune (P) ||Register- |           |           |           | tunnel;   |'
  contents:
  - '|Prune (P) ||Register- |           |           |           | tunnel;   |

    '
- title: '|          ||Stop      |           |           |           | cancel    |'
  contents:
  - '|          ||Stop      |           |           |           | cancel    |

    '
- title: '|          ||Timer(**);|           |           |           | Register- |'
  contents:
  - '|          ||Timer(**);|           |           |           | Register- |

    '
- title: '|          ||send Null-|           |           |           | Stop Timer|'
  contents:
  - '|          ||send Null-|           |           |           | Stop Timer|

    '
- title: '|          ||Register  |           |           |           |           |'
  contents:
  - '|          ||Register  |           |           |           |           |

    '
- title: +----------++----------+-----------+-----------+-----------+-----------+
  contents:
  - "+----------++----------+-----------+-----------+-----------+-----------+\n  \
    \ Notes:\n   (*)  The Register-Stop Timer is set to a random value chosen\n  \
    \      uniformly from the interval ( 0.5 * Register_Suppression_Time,\n      \
    \  1.5 * Register_Suppression_Time) minus Register_Probe_Time.\n        Subtracting\
    \ off Register_Probe_Time is a bit unnecessary because\n        it is really small\
    \ compared to Register_Suppression_Time, but\n        this was in the old specification\
    \ and is kept for compatibility.\n   (**) The Register-Stop Timer is set to Register_Probe_Time.\n\
    \   The following three actions are defined:\n   Add Register Tunnel\n      A\
    \ Register-Tunnel virtual interface, VI, is created (if it doesn't\n      already\
    \ exist) with its encapsulation target being RP(G).\n      DownstreamJPState(S,G,VI)\
    \ is set to Join state, causing the tunnel\n      interface to be added to immediate_olist(S,G)\
    \ and\n      inherited_olist(S,G).\n   Remove Register Tunnel\n      VI is the\
    \ Register-Tunnel virtual interface with encapsulation\n      target of RP(G).\
    \  DownstreamJPState(S,G,VI) is set to NoInfo\n      state, causing the tunnel\
    \ interface to be removed from\n      immediate_olist(S,G) and inherited_olist(S,G).\
    \  If\n      DownstreamJPState(S,G,VI) is NoInfo for all (S,G), then VI can be\n\
    \      deleted.\n   Update Register Tunnel\n      This action occurs when RP(G)\
    \ changes.\n      VI_old is the Register-Tunnel virtual interface with encapsulation\n\
    \      target old_RP(G).  A Register-Tunnel virtual interface, VI_new, is\n  \
    \    created (if it doesn't already exist) with its encapsulation\n      target\
    \ being new_RP(G).  DownstreamJPState(S,G,VI_old) is set to\n      NoInfo state,\
    \ and DownstreamJPState(S,G,VI_new) is set to Join\n      state.  If DownstreamJPState(S,G,VI_old)\
    \ is NoInfo for all (S,G),\n      then VI_old can be deleted.\n      Note that\
    \ we cannot simply change the encapsulation target of\n      VI_old because not\
    \ all groups using that encapsulation tunnel will\n      have moved to the same\
    \ new RP.\n   CouldRegister(S,G)\n      The macro \"CouldRegister\" in the state\
    \ machine is defined as:\n         bool CouldRegister(S,G) {\n            return\
    \ ( I_am_DR( RPF_interface(S) ) AND\n                     KeepaliveTimer(S,G)\
    \ is running AND\n                     DirectlyConnected(S) == TRUE )\n      \
    \   }\n      Note that on reception of a packet at the DR from a directly\n  \
    \    connected source, KeepaliveTimer(S,G) needs to be set by the\n      packet\
    \ forwarding rules before computing CouldRegister(S,G) in the\n      register\
    \ state machine, or the first packet from a source won't be\n      registered.\n\
    \   Encapsulating Data Packets in the Register Tunnel\n      Conceptually, the\
    \ Register Tunnel is an interface with a smaller\n      MTU than the underlying\
    \ IP interface towards the RP.  IP\n      fragmentation on packets forwarded on\
    \ the Register Tunnel is\n      performed based upon this smaller MTU.  The encapsulating\
    \ DR may\n      perform Path MTU Discovery to the RP to determine the effective\n\
    \      MTU of the tunnel.  Fragmentation for the smaller MTU should take\n   \
    \   both the outer IP header and the PIM register header overhead into\n     \
    \ account.  If a multicast packet is fragmented on the way into the\n      Register\
    \ Tunnel, each fragment is encapsulated individually so it\n      contains IP,\
    \ PIM, and inner IP headers.\n      In IPv6, the DR MUST perform Path MTU Discovery,\
    \ and an ICMP\n      Packet Too Big message MUST be sent by the encapsulating\
    \ DR if it\n      receives a packet that will not fit in the effective MTU of\
    \ the\n      tunnel.  If the MTU between the DR and the RP results in the\n  \
    \    effective tunnel MTU being smaller than 1280 (the IPv6 minimum\n      MTU),\
    \ the DR MUST send Fragmentation Required messages with an MTU\n      value of\
    \ 1280 and MUST fragment its PIM register messages as\n      required, using an\
    \ IPv6 fragmentation header between the outer\n      IPv6 header and the PIM Register\
    \ header.\n      The TTL of a forwarded data packet is decremented before it is\n\
    \      encapsulated in the Register Tunnel.  The encapsulating packet\n      uses\
    \ the normal TTL that the router would use for any locally\n      generated IP\
    \ packet.\n      The IP Explicit Congestion Notification (ECN) bits should be\n\
    \      copied from the original packet to the IP header of the\n      encapsulating\
    \ packet.  They SHOULD NOT be set independently by the\n      encapsulating router.\n\
    \      The Diffserv Code Point (DSCP) should be copied from the original\n   \
    \   packet to the IP header of the encapsulating packet.  It MAY be\n      set\
    \ independently by the encapsulating router, based upon static\n      configuration\
    \ or traffic classification.  See [12] for more\n      discussion on setting the\
    \ DSCP on tunnels.\n   Handling Register-Stop(*,G) Messages at the DR\n      An\
    \ old RP might send a Register-Stop message with the source\n      address set\
    \ to all zeros.  This was the normal course of action in\n      RFC 2362 when\
    \ the Register message matched against (*,G) state at\n      the RP, and it was\
    \ defined as meaning \"stop encapsulating all\n      sources for this group\"\
    .  However, the behavior of such a\n      Register-Stop(*,G) is ambiguous or incorrect\
    \ in some\n      circumstances.\n      We specify that an RP should not send Register-Stop(*,G)\
    \ messages,\n      but for compatibility, a DR should be able to accept one if\
    \ it is\n      received.\n      A Register-Stop(*,G) should be treated as a Register-Stop(S,G)\
    \ for\n      all (S,G) Register state machines that are not in the NoInfo\n  \
    \    state.  A router should not apply a Register-Stop(*,G) to sources\n     \
    \ that become active after the Register-Stop(*,G) was received.\n"
- title: 4.4.2.  Receiving Register Messages at the RP
  contents:
  - "4.4.2.  Receiving Register Messages at the RP\n   When an RP receives a Register\
    \ message, the course of action is\n   decided according to the following pseudocode:\n\
    \   packet_arrives_on_rp_tunnel( pkt ) {\n       if( outer.dst is not one of my\
    \ addresses ) {\n           drop the packet silently.\n           # Note: This\
    \ may be a spoofing attempt.\n       }\n       if( I_am_RP(G) AND outer.dst ==\
    \ RP(G) ) {\n             sentRegisterStop = FALSE;\n             if ( SPTbit(S,G)\
    \ OR\n              ( SwitchToSptDesired(S,G) AND\n                ( inherited_olist(S,G)\
    \ == NULL ))) {\n               send Register-Stop(S,G) to outer.src\n       \
    \        sentRegisterStop = TRUE;\n             }\n             if ( SPTbit(S,G)\
    \ OR SwitchToSptDesired(S,G) ) {\n                  if ( sentRegisterStop == TRUE\
    \ ) {\n                       set KeepaliveTimer(S,G) to RP_Keepalive_Period;\n\
    \                  } else {\n                       set KeepaliveTimer(S,G) to\
    \ Keepalive_Period;\n                  }\n             }\n             if( !SPTbit(S,G)\
    \ AND ! pkt.NullRegisterBit ) {\n                  decapsulate and forward the\
    \ inner packet to\n                  inherited_olist(S,G,rpt) # Note (+)\n   \
    \          }\n       } else {\n           send Register-Stop(S,G) to outer.src\n\
    \           # Note (*)\n       }\n   }\n   outer.dst is the IP destination address\
    \ of the encapsulating header.\n   outer.src is the IP source address of the encapsulating\
    \ header, i.e.,\n   the DR's address.\n   I_am_RP(G) is true if the group-to-RP\
    \ mapping indicates that this\n   router is the RP for the group.\n   Note (*):\
    \ This may block traffic from S for Register_Suppression_Time\n             if\
    \ the DR learned about a new group-to-RP mapping before\n             the RP did.\
    \  However, this doesn't matter unless we figure\n             out some way for\
    \ the RP also to accept (*,G) joins when it\n             doesn't yet realize\
    \ that it is about to become the RP\n             for G.  This will all get sorted\
    \ out once the RP learns the\n             new group-to-RP mapping.  We decided\
    \ to do nothing about\n             this and just accept the fact that PIM may\
    \ suffer\n             interrupted (*,G) connectivity following an RP change.\n\
    \   Note (+): Implementations SHOULD NOT make this a special case, but\n     \
    \        SHOULD arrange that this path rejoin the normal packet\n            \
    \ forwarding path.  All of the appropriate actions from the\n             \"On\
    \ receipt of data from S to G on interface iif\"\n             pseudocode in Section\
    \ 4.2 should be performed.\n   KeepaliveTimer(S,G) is restarted at the RP when\
    \ packets arrive on the\n   proper tunnel interface and the RP desires to switch\
    \ to the SPT or\n   the SPTbit is already set.  This may cause the upstream (S,G)\
    \ state\n   machine to trigger a join if the inherited_olist(S,G) is not NULL.\n\
    \   An RP should preserve (S,G) state that was created in response to a\n   Register\
    \ message for at least ( 3 * Register_Suppression_Time );\n   otherwise, the RP\
    \ may stop joining (S,G) before the DR for S has\n   restarted sending registers.\
    \  Traffic would then be interrupted until\n   the Register-Stop Timer expires\
    \ at the DR.\n   Thus, at the RP, KeepaliveTimer(S,G) should be restarted to (\
    \ 3 *\n   Register_Suppression_Time + Register_Probe_Time ).\n   When forwarding\
    \ a packet from the Register Tunnel, the TTL of the\n   original data packet is\
    \ decremented after it is decapsulated.\n   The IP ECN bits should be copied from\
    \ the IP header of the Register\n   packet to the decapsulated packet.\n   The\
    \ DSCP should be copied from the IP header of the Register packet\n   to the decapsulated\
    \ packet.  The RP MAY retain the DSCP of the inner\n   packet or re-classify the\
    \ packet and apply a different DSCP.\n   Scenarios where each of these might be\
    \ useful are discussed in [12].\n"
- title: 4.5.  PIM Join/Prune Messages
  contents:
  - "4.5.  PIM Join/Prune Messages\n   A PIM Join/Prune message consists of a list\
    \ of groups and a list of\n   Joined and Pruned sources for each group.  When\
    \ processing a received\n   Join/Prune message, each Joined or Pruned source for\
    \ a group is\n   effectively considered individually, and applies to one or more\
    \ of\n   the following state machines.  When considering a Join/Prune message\n\
    \   whose Upstream Neighbor Address field addresses this router, (*,G)\n   Joins\
    \ and Prunes can affect both the (*,G) and (S,G,rpt) downstream\n   state machines,\
    \ while (S,G), and (S,G,rpt) Joins and Prunes can only\n   affect their respective\
    \ downstream state machines.  When considering\n   a Join/Prune message whose\
    \ Upstream Neighbor Address field addresses\n   another router, most Join or Prune\
    \ messages could affect each\n   upstream state machine.\n   In general, a PIM\
    \ Join/Prune message should only be accepted for\n   processing if it comes from\
    \ a known PIM neighbor.  A PIM router hears\n   about PIM neighbors through PIM\
    \ Hello messages.  If a router receives\n   a Join/Prune message from a particular\
    \ IP source address and it has\n   not seen a PIM Hello message from that source\
    \ address, then the\n   Join/Prune message SHOULD be discarded without further\
    \ processing.\n   In addition, if the Hello message from a neighbor was authenticated\n\
    \   (see Section 6.3), then all Join/Prune messages from that neighbor\n   MUST\
    \ also be authenticated.\n   We note that some older PIM implementations incorrectly\
    \ fail to send\n   Hello messages on point-to-point interfaces, so we also RECOMMEND\n\
    \   that a configuration option be provided to allow interoperation with\n   such\
    \ older routers, but that this configuration option SHOULD NOT be\n   enabled\
    \ by default.\n"
- title: 4.5.1.  Receiving (*,G) Join/Prune Messages
  contents:
  - "4.5.1.  Receiving (*,G) Join/Prune Messages\n   When a router receives a Join(*,G),\
    \ it must first check to see\n   whether the RP in the message matches RP(G) (the\
    \ router's idea of who\n   the RP is).  If the RP in the message does not match\
    \ RP(G), the\n   Join(*,G) should be silently dropped.  (Note that other source\
    \ list\n   entries, such as (S,G,rpt) or (S,G), in the same Group-Specific Set\n\
    \   should still be processed.)  If a router has no RP information (e.g.,\n  \
    \ has not recently received a BSR message), then it may choose to\n   accept Join(*,G)\
    \ and treat the RP in the message as RP(G).  Received\n   Prune(*,G) messages\
    \ are processed even if the RP in the message does\n   not match RP(G).\n   The\
    \ per-interface state machine for receiving (*,G) Join/Prune\n   messages is given\
    \ below.  There are three states:\n      NoInfo (NI)\n            The interface\
    \ has no (*,G) Join state and no timers running.\n      Join (J)\n           \
    \ The interface has (*,G) Join state, which will cause the\n            router\
    \ to forward packets destined for G from this interface\n            except if\
    \ there is also (S,G,rpt) prune information (see\n            Section 4.5.3) or\
    \ the router lost an assert on this\n            interface.\n      Prune-Pending\
    \ (PP)\n            The router has received a Prune(*,G) on this interface from\n\
    \            a downstream neighbor and is waiting to see whether the\n       \
    \     prune will be overridden by another downstream router.  For\n          \
    \  forwarding purposes, the Prune-Pending state functions\n            exactly\
    \ like the Join state.\n   In addition, the state machine uses two timers:\n \
    \     Expiry Timer (ET)\n            This timer is restarted when a valid Join(*,G)\
    \ is received.\n            Expiry of the Expiry Timer causes the interface state\
    \ to\n            revert to NoInfo for this group.\n      Prune-Pending Timer\
    \ (PPT)\n            This timer is set when a valid Prune(*,G) is received.\n\
    \            Expiry of the Prune-Pending Timer causes the interface state\n  \
    \          to revert to NoInfo for this group.\n         Figure 2: Downstream\
    \ Per-Interface (*,G) State Machine\n"
- title: +------------++--------------------------------------------------------+
  contents:
  - '+------------++--------------------------------------------------------+

    '
- title: '|            ||                         Event                          |'
  contents:
  - '|            ||                         Event                          |

    '
- title: '|            ++-------------+--------------+-------------+-------------+'
  contents:
  - '|            ++-------------+--------------+-------------+-------------+

    '
- title: '|Prev State  ||Receive      | Receive      | Prune-      | Expiry Timer|'
  contents:
  - '|Prev State  ||Receive      | Receive      | Prune-      | Expiry Timer|

    '
- title: '|            ||Join(*,G)    | Prune(*,G)   | Pending     | Expires     |'
  contents:
  - '|            ||Join(*,G)    | Prune(*,G)   | Pending     | Expires     |

    '
- title: '|            ||             |              | Timer       |             |'
  contents:
  - '|            ||             |              | Timer       |             |

    '
- title: '|            ||             |              | Expires     |             |'
  contents:
  - '|            ||             |              | Expires     |             |

    '
- title: +------------++-------------+--------------+-------------+-------------+
  contents:
  - '+------------++-------------+--------------+-------------+-------------+

    '
- title: '|            ||-> J state   | -> NI state  | -           | -           |'
  contents:
  - '|            ||-> J state   | -> NI state  | -           | -           |

    '
- title: '|NoInfo (NI) ||start Expiry |              |             |             |'
  contents:
  - '|NoInfo (NI) ||start Expiry |              |             |             |

    '
- title: '|            ||Timer        |              |             |             |'
  contents:
  - '|            ||Timer        |              |             |             |

    '
- title: +------------++-------------+--------------+-------------+-------------+
  contents:
  - '+------------++-------------+--------------+-------------+-------------+

    '
- title: '|            ||-> J state   | -> PP state  | -           | -> NI state |'
  contents:
  - '|            ||-> J state   | -> PP state  | -           | -> NI state |

    '
- title: '|Join (J)    ||restart      | start Prune- |             |             |'
  contents:
  - '|Join (J)    ||restart      | start Prune- |             |             |

    '
- title: '|            ||Expiry Timer | Pending      |             |             |'
  contents:
  - '|            ||Expiry Timer | Pending      |             |             |

    '
- title: '|            ||             | Timer        |             |             |'
  contents:
  - '|            ||             | Timer        |             |             |

    '
- title: +------------++-------------+--------------+-------------+-------------+
  contents:
  - '+------------++-------------+--------------+-------------+-------------+

    '
- title: '|Prune-      ||-> J state   | -> PP state  | -> NI state | -> NI state |'
  contents:
  - '|Prune-      ||-> J state   | -> PP state  | -> NI state | -> NI state |

    '
- title: '|Pending (PP)||restart      |              | Send Prune- |             |'
  contents:
  - '|Pending (PP)||restart      |              | Send Prune- |             |

    '
- title: '|            ||Expiry Timer |              | Echo(*,G)   |             |'
  contents:
  - '|            ||Expiry Timer |              | Echo(*,G)   |             |

    '
- title: +------------++-------------+--------------+-------------+-------------+
  contents:
  - "+------------++-------------+--------------+-------------+-------------+\n  \
    \ The transition events \"Receive Join(*,G)\" and \"Receive Prune(*,G)\"\n   imply\
    \ receiving a Join or Prune targeted to this router's primary IP\n   address on\
    \ the received interface.  If the upstream neighbor address\n   field is not correct,\
    \ these state transitions in this state machine\n   MUST NOT occur, although seeing\
    \ such a packet may cause state\n   transitions in other state machines.\n   On\
    \ unnumbered interfaces on point-to-point links, the router's\n   address should\
    \ be the same as the source address it chose for the\n   Hello message it sent\
    \ over that interface.  However, on point-to-\n   point links it is RECOMMENDED\
    \ that for backwards compatibility PIM\n   Join/Prune messages with an upstream\
    \ neighbor address field of all\n   zeros also be accepted.\n   Transitions from\
    \ NoInfo State\n   When in NoInfo state, the following event may trigger a transition:\n\
    \      Receive Join(*,G)\n            A Join(*,G) is received on interface I with\
    \ its Upstream\n            Neighbor Address set to the router's primary IP address\n\
    \            on I.\n            The (*,G) downstream state machine on interface\
    \ I\n            transitions to the Join state.  The Expiry Timer (ET) is\n  \
    \          started and set to the HoldTime from the triggering\n            Join/Prune\
    \ message.\n   Transitions from Join State\n   When in Join state, the following\
    \ events may trigger a transition:\n      Receive Join(*,G)\n            A Join(*,G)\
    \ is received on interface I with its Upstream\n            Neighbor Address set\
    \ to the router's primary IP address\n            on I.\n            The (*,G)\
    \ downstream state machine on interface I remains in\n            Join state,\
    \ and the Expiry Timer (ET) is restarted.  The ET\n            is set to the maximum\
    \ of its current value and the HoldTime\n            from the triggering Join/Prune\
    \ message.\n      Receive Prune(*,G)\n            A Prune(*,G) is received on\
    \ interface I with its Upstream\n            Neighbor Address set to the router's\
    \ primary IP address\n            on I.\n            The (*,G) downstream state\
    \ machine on interface I\n            transitions to the Prune-Pending state.\
    \  The\n            Prune-Pending Timer is started.  It is set to the\n      \
    \      J/P_Override_Interval(I) if the router has more than one\n            neighbor\
    \ on that interface; otherwise, it is set to zero,\n            causing it to\
    \ expire immediately.\n      Expiry Timer Expires\n            The Expiry Timer\
    \ for the (*,G) downstream state machine on\n            interface I expires.\n\
    \            The (*,G) downstream state machine on interface I\n            transitions\
    \ to the NoInfo state.\n   Transitions from Prune-Pending State\n   When in Prune-Pending\
    \ state, the following events may trigger a\n   transition:\n      Receive Join(*,G)\n\
    \            A Join(*,G) is received on interface I with its Upstream\n      \
    \      Neighbor Address set to the router's primary IP address\n            on\
    \ I.\n            The (*,G) downstream state machine on interface I\n        \
    \    transitions to the Join state.  The Prune-Pending Timer is\n            canceled\
    \ (without triggering an expiry event).  The\n            Expiry Timer (ET) is\
    \ restarted and is then set to the\n            maximum of its current value and\
    \ the HoldTime from the\n            triggering Join/Prune message.\n      Expiry\
    \ Timer Expires\n            The Expiry Timer for the (*,G) downstream state machine\
    \ on\n            interface I expires.\n            The (*,G) downstream state\
    \ machine on interface I\n            transitions to the NoInfo state.\n     \
    \ Prune-Pending Timer Expires\n            The Prune-Pending Timer for the (*,G)\
    \ downstream state\n            machine on interface I expires.\n            The\
    \ (*,G) downstream state machine on interface I\n            transitions to the\
    \ NoInfo state.  A PruneEcho(*,G) is sent\n            onto the subnet connected\
    \ to interface I.\n            The action \"Send PruneEcho(*,G)\" is triggered\
    \ when the\n            router stops forwarding on an interface as a result of\
    \ a\n            prune.  A PruneEcho(*,G) is simply a Prune(*,G) message sent\n\
    \            by the upstream router on a LAN with its own address in the\n   \
    \         Upstream Neighbor Address field.  Its purpose is to add\n          \
    \  additional reliability so that if a Prune that should have\n            been\
    \ overridden by another router is lost locally on the\n            LAN, then the\
    \ PruneEcho may be received and cause the\n            override to happen.  A\
    \ PruneEcho(*,G) need not be sent on an\n            interface that contains only\
    \ a single PIM neighbor during\n            the time this state machine was in\
    \ Prune-Pending state.\n"
- title: 4.5.2.  Receiving (S,G) Join/Prune Messages
  contents:
  - "4.5.2.  Receiving (S,G) Join/Prune Messages\n   The per-interface state machine\
    \ for receiving (S,G) Join/Prune\n   messages is given below and is almost identical\
    \ to that for (*,G)\n   messages.  There are three states:\n      NoInfo (NI)\n\
    \            The interface has no (S,G) Join state and no (S,G) timers\n     \
    \       running.\n      Join (J)\n            The interface has (S,G) Join state,\
    \ which will cause the\n            router to forward packets from S destined\
    \ for G from this\n            interface if the (S,G) state is active (the SPTbit\
    \ is set)\n            except if the router lost an assert on this interface.\n\
    \      Prune-Pending (PP)\n            The router has received a Prune(S,G) on\
    \ this interface from\n            a downstream neighbor and is waiting to see\
    \ whether the\n            prune will be overridden by another downstream router.\
    \  For\n            forwarding purposes, the Prune-Pending state functions\n \
    \           exactly like the Join state.\n   In addition, there are two timers:\n\
    \      Expiry Timer (ET)\n            This timer is set when a valid Join(S,G)\
    \ is received.\n            Expiry of the Expiry Timer causes this state machine\
    \ to\n            revert to NoInfo state.\n      Prune-Pending Timer (PPT)\n \
    \           This timer is set when a valid Prune(S,G) is received.\n         \
    \   Expiry of the Prune-Pending Timer causes this state machine\n            to\
    \ revert to NoInfo state.\n         Figure 3: Downstream Per-Interface (S,G) State\
    \ Machine\n"
- title: +------------++--------------------------------------------------------+
  contents:
  - '+------------++--------------------------------------------------------+

    '
- title: '|            ||                         Event                          |'
  contents:
  - '|            ||                         Event                          |

    '
- title: '|            ++-------------+--------------+-------------+-------------+'
  contents:
  - '|            ++-------------+--------------+-------------+-------------+

    '
- title: '|Prev State  ||Receive      | Receive      | Prune-      | Expiry Timer|'
  contents:
  - '|Prev State  ||Receive      | Receive      | Prune-      | Expiry Timer|

    '
- title: '|            ||Join(S,G)    | Prune(S,G)   | Pending     | Expires     |'
  contents:
  - '|            ||Join(S,G)    | Prune(S,G)   | Pending     | Expires     |

    '
- title: '|            ||             |              | Timer       |             |'
  contents:
  - '|            ||             |              | Timer       |             |

    '
- title: '|            ||             |              | Expires     |             |'
  contents:
  - '|            ||             |              | Expires     |             |

    '
- title: +------------++-------------+--------------+-------------+-------------+
  contents:
  - '+------------++-------------+--------------+-------------+-------------+

    '
- title: '|            ||-> J state   | -> NI state  | -           | -           |'
  contents:
  - '|            ||-> J state   | -> NI state  | -           | -           |

    '
- title: '|NoInfo (NI) ||start Expiry |              |             |             |'
  contents:
  - '|NoInfo (NI) ||start Expiry |              |             |             |

    '
- title: '|            ||Timer        |              |             |             |'
  contents:
  - '|            ||Timer        |              |             |             |

    '
- title: +------------++-------------+--------------+-------------+-------------+
  contents:
  - '+------------++-------------+--------------+-------------+-------------+

    '
- title: '|            ||-> J state   | -> PP state  | -           | -> NI state |'
  contents:
  - '|            ||-> J state   | -> PP state  | -           | -> NI state |

    '
- title: '|Join (J)    ||restart      | start Prune- |             |             |'
  contents:
  - '|Join (J)    ||restart      | start Prune- |             |             |

    '
- title: '|            ||Expiry Timer | Pending      |             |             |'
  contents:
  - '|            ||Expiry Timer | Pending      |             |             |

    '
- title: '|            ||             | Timer        |             |             |'
  contents:
  - '|            ||             | Timer        |             |             |

    '
- title: +------------++-------------+--------------+-------------+-------------+
  contents:
  - '+------------++-------------+--------------+-------------+-------------+

    '
- title: '|Prune-      ||-> J state   | -> PP state  | -> NI state | -> NI state |'
  contents:
  - '|Prune-      ||-> J state   | -> PP state  | -> NI state | -> NI state |

    '
- title: '|Pending (PP)||restart      |              | Send Prune- |             |'
  contents:
  - '|Pending (PP)||restart      |              | Send Prune- |             |

    '
- title: '|            ||Expiry Timer |              | Echo(S,G)   |             |'
  contents:
  - '|            ||Expiry Timer |              | Echo(S,G)   |             |

    '
- title: +------------++-------------+--------------+-------------+-------------+
  contents:
  - "+------------++-------------+--------------+-------------+-------------+\n  \
    \ The transition events \"Receive Join(S,G)\" and \"Receive Prune(S,G)\"\n   imply\
    \ receiving a Join or Prune targeted to this router's primary IP\n   address on\
    \ the received interface.  If the upstream neighbor address\n   field is not correct,\
    \ these state transitions in this state machine\n   MUST NOT occur, although seeing\
    \ such a packet may cause state\n   transitions in other state machines.\n   On\
    \ unnumbered interfaces on point-to-point links, the router's\n   address SHOULD\
    \ be the same as the source address it chose for the\n   Hello message it sent\
    \ over that interface.  However, on point-to-\n   point links it is RECOMMENDED\
    \ that for backwards compatibility PIM\n   Join/Prune messages with an upstream\
    \ neighbor address field of all\n   zeros also be accepted.\n   Transitions from\
    \ NoInfo State\n   When in NoInfo state, the following event may trigger a transition:\n\
    \      Receive Join(S,G)\n            A Join(S,G) is received on interface I with\
    \ its Upstream\n            Neighbor Address set to the router's primary IP address\n\
    \            on I.\n            The (S,G) downstream state machine on interface\
    \ I\n            transitions to the Join state.  The Expiry Timer (ET) is\n  \
    \          started and set to the HoldTime from the triggering\n            Join/Prune\
    \ message.\n   Transitions from Join State\n   When in Join state, the following\
    \ events may trigger a transition:\n      Receive Join(S,G)\n            A Join(S,G)\
    \ is received on interface I with its Upstream\n            Neighbor Address set\
    \ to the router's primary IP address\n            on I.\n            The (S,G)\
    \ downstream state machine on interface I remains in\n            Join state.\
    \  The Expiry Timer (ET) is restarted and is then\n            set to the maximum\
    \ of its current value and the HoldTime\n            from the triggering Join/Prune\
    \ message.\n      Receive Prune(S,G)\n            A Prune(S,G) is received on\
    \ interface I with its Upstream\n            Neighbor Address set to the router's\
    \ primary IP address\n            on I.\n            The (S,G) downstream state\
    \ machine on interface I\n            transitions to the Prune-Pending state.\
    \  The\n            Prune-Pending Timer is started.  It is set to the\n      \
    \      J/P_Override_Interval(I) if the router has more than one\n            neighbor\
    \ on that interface; otherwise, it is set to zero,\n            causing it to\
    \ expire immediately.\n      Expiry Timer Expires\n            The Expiry Timer\
    \ for the (S,G) downstream state machine on\n            interface I expires.\n\
    \            The (S,G) downstream state machine on interface I\n            transitions\
    \ to the NoInfo state.\n   Transitions from Prune-Pending State\n   When in Prune-Pending\
    \ state, the following events may trigger a\n   transition:\n      Receive Join(S,G)\n\
    \            A Join(S,G) is received on interface I with its Upstream\n      \
    \      Neighbor Address set to the router's primary IP address\n            on\
    \ I.\n            The (S,G) downstream state machine on interface I\n        \
    \    transitions to the Join state.  The Prune-Pending Timer is\n            canceled\
    \ (without triggering an expiry event).  The\n            Expiry Timer (ET) is\
    \ restarted and is then set to the\n            maximum of its current value and\
    \ the HoldTime from the\n            triggering Join/Prune message.\n      Expiry\
    \ Timer Expires\n            The Expiry Timer for the (S,G) downstream state machine\
    \ on\n            interface I expires.\n            The (S,G) downstream state\
    \ machine on interface I\n            transitions to the NoInfo state.\n     \
    \ Prune-Pending Timer Expires\n            The Prune-Pending Timer for the (S,G)\
    \ downstream state\n            machine on interface I expires.\n            The\
    \ (S,G) downstream state machine on interface I\n            transitions to the\
    \ NoInfo state.  A PruneEcho(S,G) is sent\n            onto the subnet connected\
    \ to interface I.\n            The action \"Send PruneEcho(S,G)\" is triggered\
    \ when the\n            router stops forwarding on an interface as a result of\
    \ a\n            prune.  A PruneEcho(S,G) is simply a Prune(S,G) message sent\n\
    \            by the upstream router on a LAN with its own address in the\n   \
    \         Upstream Neighbor Address field.  Its purpose is to add\n          \
    \  additional reliability so that if a Prune that should have\n            been\
    \ overridden by another router is lost locally on the\n            LAN, then the\
    \ PruneEcho may be received and cause the\n            override to happen.  A\
    \ PruneEcho(S,G) need not be sent on an\n            interface that contains only\
    \ a single PIM neighbor during\n            the time this state machine was in\
    \ Prune-Pending state.\n"
- title: 4.5.3.  Receiving (S,G,rpt) Join/Prune Messages
  contents:
  - "4.5.3.  Receiving (S,G,rpt) Join/Prune Messages\n   The per-interface state machine\
    \ for receiving (S,G,rpt) Join/Prune\n   messages is given below.  There are five\
    \ states:\n      NoInfo (NI)\n            The interface has no (S,G,rpt) Prune\
    \ state and no (S,G,rpt)\n            timers running.\n      Prune (P)\n     \
    \       The interface has (S,G,rpt) Prune state, which will cause\n          \
    \  the router not to forward packets from S destined for G from\n            this\
    \ interface even though the interface has active (*,G)\n            Join state.\n\
    \      Prune-Pending (PP)\n            The router has received a Prune(S,G,rpt)\
    \ on this interface\n            from a downstream neighbor and is waiting to\
    \ see whether the\n            prune will be overridden by another downstream\
    \ router.  For\n            forwarding purposes, the Prune-Pending state functions\n\
    \            exactly like the NoInfo state.\n      PruneTmp (P')\n           \
    \ This state is a transient state that for forwarding purposes\n            behaves\
    \ exactly like the Prune state.  A (*,G) Join has been\n            received (which\
    \ may cancel the (S,G,rpt) Prune).  As we\n            parse the Join/Prune message\
    \ from top to bottom, we first\n            enter this state if the message contains\
    \ a (*,G) Join.\n            Later in the message, we will normally encounter\
    \ an\n            (S,G,rpt) prune to reinstate the Prune state.  However, if\n\
    \            we reach the end of the message without encountering such an\n  \
    \          (S,G,rpt) prune, then we will revert to NoInfo state in this\n    \
    \        state machine.\n            As no time is spent in this state, no timers\
    \ can expire.\n      Prune-Pending-Tmp (PP')\n            This state is a transient\
    \ state that is identical to P'\n            except that it is associated with\
    \ the PP state rather than\n            the P state.  For forwarding purposes,\
    \ PP' behaves exactly\n            like the PP state.\n   In addition, there are\
    \ two timers:\n      Expiry Timer (ET)\n            This timer is set when a valid\
    \ Prune(S,G,rpt) is received.\n            Expiry of the Expiry Timer causes this\
    \ state machine to\n            revert to NoInfo state.\n      Prune-Pending Timer\
    \ (PPT)\n            This timer is set when a valid Prune(S,G,rpt) is received.\n\
    \            Expiry of the Prune-Pending Timer causes this state machine\n   \
    \         to move on to Prune state.\n       Figure 4: Downstream Per-Interface\
    \ (S,G,rpt) State Machine\n"
- title: +----------++----------------------------------------------------------+
  contents:
  - '+----------++----------------------------------------------------------+

    '
- title: '|          ||                          Event                           |'
  contents:
  - '|          ||                          Event                           |

    '
- title: '|          ++---------+----------+----------+--------+--------+--------+'
  contents:
  - '|          ++---------+----------+----------+--------+--------+--------+

    '
- title: '|Prev      ||Receive  | Receive  | Receive  | End of | Prune- | Expiry |'
  contents:
  - '|Prev      ||Receive  | Receive  | Receive  | End of | Prune- | Expiry |

    '
- title: '|State     ||Join(*,G)| Join     | Prune    | Message| Pending| Timer  |'
  contents:
  - '|State     ||Join(*,G)| Join     | Prune    | Message| Pending| Timer  |

    '
- title: '|          ||         | (S,G,rpt)| (S,G,rpt)|        | Timer  | Expires|'
  contents:
  - '|          ||         | (S,G,rpt)| (S,G,rpt)|        | Timer  | Expires|

    '
- title: '|          ||         |          |          |        | Expires|        |'
  contents:
  - '|          ||         |          |          |        | Expires|        |

    '
- title: +----------++---------+----------+----------+--------+--------+--------+
  contents:
  - '+----------++---------+----------+----------+--------+--------+--------+

    '
- title: '|          ||-        | -        | -> PP    | -      | -      | -      |'
  contents:
  - '|          ||-        | -        | -> PP    | -      | -      | -      |

    '
- title: '|          ||         |          | state    |        |        |        |'
  contents:
  - '|          ||         |          | state    |        |        |        |

    '
- title: '|          ||         |          | start    |        |        |        |'
  contents:
  - '|          ||         |          | start    |        |        |        |

    '
- title: '|NoInfo    ||         |          | Prune-   |        |        |        |'
  contents:
  - '|NoInfo    ||         |          | Prune-   |        |        |        |

    '
- title: '|(NI)      ||         |          | Pending  |        |        |        |'
  contents:
  - '|(NI)      ||         |          | Pending  |        |        |        |

    '
- title: '|          ||         |          | Timer;   |        |        |        |'
  contents:
  - '|          ||         |          | Timer;   |        |        |        |

    '
- title: '|          ||         |          | start    |        |        |        |'
  contents:
  - '|          ||         |          | start    |        |        |        |

    '
- title: '|          ||         |          | Expiry   |        |        |        |'
  contents:
  - '|          ||         |          | Expiry   |        |        |        |

    '
- title: '|          ||         |          | Timer    |        |        |        |'
  contents:
  - '|          ||         |          | Timer    |        |        |        |

    '
- title: +----------++---------+----------+----------+--------+--------+--------+
  contents:
  - '+----------++---------+----------+----------+--------+--------+--------+

    '
- title: '|          ||-> P''    | -> NI    | -> P     | -      | -      | -> NI  |'
  contents:
  - '|          ||-> P''    | -> NI    | -> P     | -      | -      | -> NI  |

    '
- title: '|          ||state    | state    | state    |        |        | state  |'
  contents:
  - '|          ||state    | state    | state    |        |        | state  |

    '
- title: '|Prune (P) ||         |          | restart  |        |        |        |'
  contents:
  - '|Prune (P) ||         |          | restart  |        |        |        |

    '
- title: '|          ||         |          | Expiry   |        |        |        |'
  contents:
  - '|          ||         |          | Expiry   |        |        |        |

    '
- title: '|          ||         |          | Timer    |        |        |        |'
  contents:
  - '|          ||         |          | Timer    |        |        |        |

    '
- title: +----------++---------+----------+----------+--------+--------+--------+
  contents:
  - '+----------++---------+----------+----------+--------+--------+--------+

    '
- title: '|Prune-    ||-> PP''   | -> NI    | -        | -      | -> P   | -      |'
  contents:
  - '|Prune-    ||-> PP''   | -> NI    | -        | -      | -> P   | -      |

    '
- title: '|Pending   ||state    | state    |          |        | state  |        |'
  contents:
  - '|Pending   ||state    | state    |          |        | state  |        |

    '
- title: '|(PP)      ||         |          |          |        |        |        |'
  contents:
  - '|(PP)      ||         |          |          |        |        |        |

    '
- title: +----------++---------+----------+----------+--------+--------+--------+
  contents:
  - '+----------++---------+----------+----------+--------+--------+--------+

    '
- title: '|          ||-        | -        | -> P     | -> NI  | -      | -      |'
  contents:
  - '|          ||-        | -        | -> P     | -> NI  | -      | -      |

    '
- title: '|PruneTmp  ||         |          | state    | state  |        |        |'
  contents:
  - '|PruneTmp  ||         |          | state    | state  |        |        |

    '
- title: '|(P'')      ||         |          | restart  |        |        |        |'
  contents:
  - '|(P'')      ||         |          | restart  |        |        |        |

    '
- title: '|          ||         |          | Expiry   |        |        |        |'
  contents:
  - '|          ||         |          | Expiry   |        |        |        |

    '
- title: '|          ||         |          | Timer    |        |        |        |'
  contents:
  - '|          ||         |          | Timer    |        |        |        |

    '
- title: +----------++---------+----------+----------+--------+--------+--------+
  contents:
  - '+----------++---------+----------+----------+--------+--------+--------+

    '
- title: '|          ||-        | -        | -> PP    | -> NI  | -      | -      |'
  contents:
  - '|          ||-        | -        | -> PP    | -> NI  | -      | -      |

    '
- title: '|Prune-    ||         |          | state    | state  |        |        |'
  contents:
  - '|Prune-    ||         |          | state    | state  |        |        |

    '
- title: '|Pending-  ||         |          | restart  |        |        |        |'
  contents:
  - '|Pending-  ||         |          | restart  |        |        |        |

    '
- title: '|Tmp (PP'') ||         |          | Expiry   |        |        |        |'
  contents:
  - '|Tmp (PP'') ||         |          | Expiry   |        |        |        |

    '
- title: '|          ||         |          | Timer    |        |        |        |'
  contents:
  - '|          ||         |          | Timer    |        |        |        |

    '
- title: +----------++---------+----------+----------+--------+--------+--------+
  contents:
  - "+----------++---------+----------+----------+--------+--------+--------+\n  \
    \ The transition events \"Receive Join(S,G,rpt)\", \"Receive\n   Prune(S,G,rpt)\"\
    , and \"Receive Join(*,G)\" imply receiving a Join or\n   Prune targeted to this\
    \ router's primary IP address on the received\n   interface.  If the upstream\
    \ neighbor address field is not correct,\n   these state transitions in this state\
    \ machine MUST NOT occur,\n   although seeing such a packet may cause state transitions\
    \ in other\n   state machines.\n   On unnumbered interfaces on point-to-point\
    \ links, the router's\n   address should be the same as the source address it\
    \ chose for the\n   Hello message it sent over that interface.  However, on point-to-\n\
    \   point links it is RECOMMENDED that PIM Join/Prune messages with an\n   upstream\
    \ neighbor address field of all zeros also be accepted.\n   Transitions from NoInfo\
    \ State\n   When in NoInfo (NI) state, the following event may trigger a\n   transition:\n\
    \      Receive Prune(S,G,rpt)\n            A Prune(S,G,rpt) is received on interface\
    \ I with its\n            Upstream Neighbor Address set to the router's primary\
    \ IP\n            address on I.\n            The (S,G,rpt) downstream state machine\
    \ on interface I\n            transitions to the Prune-Pending state.  The Expiry\
    \ Timer\n            (ET) is started and set to the HoldTime from the triggering\n\
    \            Join/Prune message.  The Prune-Pending Timer is started.  It\n  \
    \          is set to the J/P_Override_Interval(I) if the router has\n        \
    \    more than one neighbor on that interface; otherwise, it is\n            set\
    \ to zero, causing it to expire immediately.\n   Transitions from Prune-Pending\
    \ State\n   When in Prune-Pending (PP) state, the following events may trigger\
    \ a\n   transition:\n      Receive Join(*,G)\n            A Join(*,G) is received\
    \ on interface I with its Upstream\n            Neighbor Address set to the router's\
    \ primary IP address\n            on I.\n            The (S,G,rpt) downstream\
    \ state machine on interface I\n            transitions to the Prune-Pending-Tmp\
    \ state whilst the\n            remainder of the compound Join/Prune message containing\
    \ the\n            Join(*,G) is processed.\n      Receive Join(S,G,rpt)\n    \
    \        A Join(S,G,rpt) is received on interface I with its Upstream\n      \
    \      Neighbor Address set to the router's primary IP address\n            on\
    \ I.\n            The (S,G,rpt) downstream state machine on interface I\n    \
    \        transitions to the NoInfo state.  The ET and PPT are\n            canceled.\n\
    \      Prune-Pending Timer Expires\n            The Prune-Pending Timer for the\
    \ (S,G,rpt) downstream state\n            machine on interface I expires.\n  \
    \          The (S,G,rpt) downstream state machine on interface I\n           \
    \ transitions to the Prune state.\n   Transitions from Prune State\n   When in\
    \ Prune (P) state, the following events may trigger a\n   transition:\n      Receive\
    \ Join(*,G)\n            A Join(*,G) is received on interface I with its Upstream\n\
    \            Neighbor Address set to the router's primary IP address\n       \
    \     on I.\n            The (S,G,rpt) downstream state machine on interface I\n\
    \            transitions to the PruneTmp state whilst the remainder of\n     \
    \       the compound Join/Prune message containing the Join(*,G) is\n        \
    \    processed.\n      Receive Join(S,G,rpt)\n            A Join(S,G,rpt) is received\
    \ on interface I with its Upstream\n            Neighbor Address set to the router's\
    \ primary IP address\n            on I.\n            The (S,G,rpt) downstream\
    \ state machine on interface I\n            transitions to the NoInfo state. \
    \ The ET and PPT are\n            canceled.\n      Receive Prune(S,G,rpt)\n  \
    \          A Prune(S,G,rpt) is received on interface I with its\n            Upstream\
    \ Neighbor Address set to the router's primary IP\n            address on I.\n\
    \            The (S,G,rpt) downstream state machine on interface I\n         \
    \   remains in Prune state.  The Expiry Timer (ET) is restarted\n            and\
    \ is then set to the maximum of its current value and the\n            HoldTime\
    \ from the triggering Join/Prune message.\n      Expiry Timer Expires\n      \
    \      The Expiry Timer for the (S,G,rpt) downstream state machine\n         \
    \   on interface I expires.\n            The (S,G,rpt) downstream state machine\
    \ on interface I\n            transitions to the NoInfo state.\n   Transitions\
    \ from Prune-Pending-Tmp State\n   When in Prune-Pending-Tmp (PP') state and processing\
    \ a compound\n   Join/Prune message, the following events may trigger a transition:\n\
    \      Receive Prune(S,G,rpt)\n            The compound Join/Prune message contains\
    \ a Prune(S,G,rpt)\n            that is received on interface I with its Upstream\
    \ Neighbor\n            Address set to the router's primary IP address on I.\n\
    \            The (S,G,rpt) downstream state machine on interface I\n         \
    \   transitions back to the Prune-Pending state.  The\n            Expiry Timer\
    \ (ET) is restarted and is then set to the\n            maximum of its current\
    \ value and the HoldTime from the\n            triggering Join/Prune message.\n\
    \      End of Message\n            The end of the compound Join/Prune message\
    \ is reached.\n            The (S,G,rpt) downstream state machine on interface\
    \ I\n            transitions to the NoInfo state.  The ET and PPT are\n      \
    \      canceled.\n   Transitions from PruneTmp State\n   When in PruneTmp (P')\
    \ state and processing a compound Join/Prune\n   message, the following events\
    \ may trigger a transition:\n      Receive Prune(S,G,rpt)\n            The compound\
    \ Join/Prune message contains a Prune(S,G,rpt).\n            The (S,G,rpt) downstream\
    \ state machine on interface I\n            transitions back to the Prune state.\
    \  The Expiry Timer (ET)\n            is restarted and is then set to the maximum\
    \ of its current\n            value and the HoldTime from the triggering Join/Prune\n\
    \            message.\n      End of Message\n            The end of the compound\
    \ Join/Prune message is reached.\n            The (S,G,rpt) downstream state machine\
    \ on interface I\n            transitions to the NoInfo state.  ET is canceled.\n\
    \   Note: Receiving a Prune(*,G) does not affect the (S,G,rpt) downstream\n  \
    \ state machine.\n"
- title: 4.5.4.  Sending (*,G) Join/Prune Messages
  contents:
  - "4.5.4.  Sending (*,G) Join/Prune Messages\n   The per-interface state machines\
    \ for (*,G) hold join state from\n   downstream PIM routers.  This state then\
    \ determines whether a router\n   needs to propagate a Join(*,G) upstream towards\
    \ the RP.\n   If a router wishes to propagate a Join(*,G) upstream, it must also\n\
    \   watch for messages on its upstream interface from other routers on\n   that\
    \ subnet, and these may modify its behavior.  If it sees a\n   Join(*,G) to the\
    \ correct upstream neighbor, it should suppress its\n   own Join(*,G).  If it\
    \ sees a Prune(*,G) to the correct upstream\n   neighbor, it should be prepared\
    \ to override that prune by sending a\n   Join(*,G) almost immediately.  Finally,\
    \ if it sees the Generation ID\n   (see Section 4.3) of the correct upstream neighbor\
    \ change, it knows\n   that the upstream neighbor has lost state, and it should\
    \ be prepared\n   to refresh the state by sending a Join(*,G) almost immediately.\n\
    \   If a (*,G) Assert occurs on the upstream interface, and this changes\n   this\
    \ router's idea of the upstream neighbor, it should be prepared to\n   ensure\
    \ that the Assert winner is aware of downstream routers by\n   sending a Join(*,G)\
    \ almost immediately.\n   In addition, if the MRIB changes to indicate that the\
    \ next hop\n   towards the RP has changed, and either the upstream interface changes\n\
    \   or there is no Assert winner on the upstream interface, the router\n   should\
    \ prune off from the old next hop and join towards the new\n   next hop.\n   The\
    \ upstream (*,G) state machine only contains two states:\n      Not Joined\n \
    \           The downstream state machines indicate that the router does\n    \
    \        not need to join the RP tree for this group.\n      Joined\n        \
    \    The downstream state machines indicate that the router\n            should\
    \ join the RP tree for this group.\n   In addition, one timer JT(*,G) is kept\
    \ that is used to trigger the\n   sending of a Join(*,G) to the upstream next\
    \ hop towards the RP,\n   RPF'(*,G).\n                 Figure 5: Upstream (*,G)\
    \ State Machine\n"
- title: +-------------------++-------------------------------------------------+
  contents:
  - '+-------------------++-------------------------------------------------+

    '
- title: '|                   ||                      Event                      |'
  contents:
  - '|                   ||                      Event                      |

    '
- title: '|  Prev State       ++------------------------+------------------------+'
  contents:
  - '|  Prev State       ++------------------------+------------------------+

    '
- title: '|                   ||   JoinDesired(*,G)     |    JoinDesired(*,G)    |'
  contents:
  - '|                   ||   JoinDesired(*,G)     |    JoinDesired(*,G)    |

    '
- title: '|                   ||   ->True               |    ->False             |'
  contents:
  - '|                   ||   ->True               |    ->False             |

    '
- title: +-------------------++------------------------+------------------------+
  contents:
  - '+-------------------++------------------------+------------------------+

    '
- title: '|                   ||   -> J state           |    -                   |'
  contents:
  - '|                   ||   -> J state           |    -                   |

    '
- title: '|  NotJoined (NJ)   ||   Send Join(*,G);      |                        |'
  contents:
  - '|  NotJoined (NJ)   ||   Send Join(*,G);      |                        |

    '
- title: '|                   ||   set Join Timer to    |                        |'
  contents:
  - '|                   ||   set Join Timer to    |                        |

    '
- title: '|                   ||   t_periodic           |                        |'
  contents:
  - '|                   ||   t_periodic           |                        |

    '
- title: +-------------------++------------------------+------------------------+
  contents:
  - '+-------------------++------------------------+------------------------+

    '
- title: '|  Joined (J)       ||   -                    |    -> NJ state         |'
  contents:
  - '|  Joined (J)       ||   -                    |    -> NJ state         |

    '
- title: '|                   ||                        |    Send Prune(*,G);    |'
  contents:
  - '|                   ||                        |    Send Prune(*,G);    |

    '
- title: '|                   ||                        |    cancel Join Timer   |'
  contents:
  - '|                   ||                        |    cancel Join Timer   |

    '
- title: +-------------------++------------------------+------------------------+
  contents:
  - "+-------------------++------------------------+------------------------+\n  \
    \ In addition, we have the following transitions, which occur within\n   the Joined\
    \ state:\n"
- title: +----------------------------------------------------------------------+
  contents:
  - '+----------------------------------------------------------------------+

    '
- title: '|                        In Joined (J) State                           |'
  contents:
  - '|                        In Joined (J) State                           |

    '
- title: +----------------+-----------------+-----------------+-----------------+
  contents:
  - '+----------------+-----------------+-----------------+-----------------+

    '
- title: '|Timer Expires   | See Join(*,G)   | See Prune(*,G)  | RPF''(*,G)       |'
  contents:
  - '|Timer Expires   | See Join(*,G)   | See Prune(*,G)  | RPF''(*,G)       |

    '
- title: '|                | to RPF''(*,G)    | to RPF''(*,G)    | changes due to  |'
  contents:
  - '|                | to RPF''(*,G)    | to RPF''(*,G)    | changes due to  |

    '
- title: '|                |                 |                 | an Assert       |'
  contents:
  - '|                |                 |                 | an Assert       |

    '
- title: +----------------+-----------------+-----------------+-----------------+
  contents:
  - '+----------------+-----------------+-----------------+-----------------+

    '
- title: '|Send            | Increase Join   | Decrease Join   | Decrease Join   |'
  contents:
  - '|Send            | Increase Join   | Decrease Join   | Decrease Join   |

    '
- title: '|Join(*,G); set  | Timer to        | Timer to        | Timer to        |'
  contents:
  - '|Join(*,G); set  | Timer to        | Timer to        | Timer to        |

    '
- title: '|Join Timer to   | t_joinsuppress  | t_override      | t_override      |'
  contents:
  - '|Join Timer to   | t_joinsuppress  | t_override      | t_override      |

    '
- title: '|t_periodic      |                 |                 |                 |'
  contents:
  - '|t_periodic      |                 |                 |                 |

    '
- title: +----------------+-----------------+-----------------+-----------------+
  contents:
  - '+----------------+-----------------+-----------------+-----------------+

    '
- title: +----------------------------------------------------------------------+
  contents:
  - '+----------------------------------------------------------------------+

    '
- title: '|                         In Joined (J) State                          |'
  contents:
  - '|                         In Joined (J) State                          |

    '
- title: +----------------------------------+-----------------------------------+
  contents:
  - '+----------------------------------+-----------------------------------+

    '
- title: '|    RPF''(*,G) changes not         |       RPF''(*,G) GenID changes     |'
  contents:
  - '|    RPF''(*,G) changes not         |       RPF''(*,G) GenID changes     |

    '
- title: '|    due to an Assert              |                                   |'
  contents:
  - '|    due to an Assert              |                                   |

    '
- title: +----------------------------------+-----------------------------------+
  contents:
  - '+----------------------------------+-----------------------------------+

    '
- title: '|    Send Join(*,G) to new         |       Decrease Join Timer to      |'
  contents:
  - '|    Send Join(*,G) to new         |       Decrease Join Timer to      |

    '
- title: '|    next hop; send                |       t_override                  |'
  contents:
  - '|    next hop; send                |       t_override                  |

    '
- title: '|    Prune(*,G) to old next        |                                   |'
  contents:
  - '|    Prune(*,G) to old next        |                                   |

    '
- title: '|    hop; set Join Timer to        |                                   |'
  contents:
  - '|    hop; set Join Timer to        |                                   |

    '
- title: '|    t_periodic                    |                                   |'
  contents:
  - '|    t_periodic                    |                                   |

    '
- title: +----------------------------------+-----------------------------------+
  contents:
  - "+----------------------------------+-----------------------------------+\n  \
    \ This state machine uses the following macro:\n     bool JoinDesired(*,G) {\n\
    \        if (immediate_olist(*,G) != NULL)\n            return TRUE\n        else\n\
    \            return FALSE\n     }\n   JoinDesired(*,G) is true when the router\
    \ has forwarding state that\n   would cause it to forward traffic for G using\
    \ shared tree state.\n   Note that although JoinDesired is true, the router's\
    \ sending of a\n   Join(*,G) message may be suppressed by another router sending\
    \ a\n   Join(*,G) onto the upstream interface.\n   Transitions from NotJoined\
    \ State\n   When the upstream (*,G) state machine is in NotJoined state, the\n\
    \   following event may trigger a state transition:\n      JoinDesired(*,G) becomes\
    \ True\n            The macro JoinDesired(*,G) becomes True, e.g., because the\n\
    \            downstream state for (*,G) has changed so that at least one\n   \
    \         interface is in immediate_olist(*,G).\n            The upstream (*,G)\
    \ state machine transitions to the Joined\n            state.  Send Join(*,G)\
    \ to the appropriate upstream neighbor,\n            which is RPF'(*,G).  Set\
    \ the Join Timer (JT) to expire after\n            t_periodic seconds.\n   Transitions\
    \ from Joined State\n   When the upstream (*,G) state machine is in Joined state,\
    \ the\n   following events may trigger state transitions:\n      JoinDesired(*,G)\
    \ becomes False\n            The macro JoinDesired(*,G) becomes False, e.g., because\
    \ the\n            downstream state for (*,G) has changed so no interface is in\n\
    \            immediate_olist(*,G).\n            The upstream (*,G) state machine\
    \ transitions to the\n            NotJoined state.  Send Prune(*,G) to the appropriate\n\
    \            upstream neighbor, which is RPF'(*,G).  Cancel the\n            Join\
    \ Timer (JT).\n      Join Timer Expires\n            The Join Timer (JT) expires,\
    \ indicating time to send a\n            Join(*,G).\n            Send Join(*,G)\
    \ to the appropriate upstream neighbor, which\n            is RPF'(*,G).  Restart\
    \ the Join Timer (JT) to expire after\n            t_periodic seconds.\n     \
    \ See Join(*,G) to RPF'(*,G)\n            This event is only relevant if RPF_interface(RP(G))\
    \ is a\n            shared medium.  This router sees another router on\n     \
    \       RPF_interface(RP(G)) send a Join(*,G) to RPF'(*,G).  This\n          \
    \  causes this router to suppress its own Join.\n            The upstream (*,G)\
    \ state machine remains in Joined state.\n            Let t_joinsuppress be the\
    \ minimum of t_suppressed and the\n            HoldTime from the Join/Prune message\
    \ triggering this event.\n            If the Join Timer is set to expire in less\
    \ than\n            t_joinsuppress seconds, reset it so that it expires after\n\
    \            t_joinsuppress seconds.  If the Join Timer is set to expire\n   \
    \         in more than t_joinsuppress seconds, leave it unchanged.\n      See\
    \ Prune(*,G) to RPF'(*,G)\n            This event is only relevant if RPF_interface(RP(G))\
    \ is a\n            shared medium.  This router sees another router on\n     \
    \       RPF_interface(RP(G)) send a Prune(*,G) to RPF'(*,G).  As\n           \
    \ this router is in Joined state, it must override the Prune\n            after\
    \ a short random interval.\n            The upstream (*,G) state machine remains\
    \ in Joined state.\n            If the Join Timer is set to expire in more than\n\
    \            t_override seconds, reset it so that it expires after\n         \
    \   t_override seconds.  If the Join Timer is set to expire in\n            less\
    \ than t_override seconds, leave it unchanged.\n      RPF'(*,G) changes due to\
    \ an Assert\n            The current next hop towards the RP changes due to an\n\
    \            Assert(*,G) on the RPF_interface(RP(G)).\n            The upstream\
    \ (*,G) state machine remains in Joined state.\n            If the Join Timer\
    \ is set to expire in more than\n            t_override seconds, reset it so that\
    \ it expires after\n            t_override seconds.  If the Join Timer is set\
    \ to expire in\n            less than t_override seconds, leave it unchanged.\n\
    \      RPF'(*,G) changes not due to an Assert\n            An event occurred that\
    \ caused the next hop towards the RP\n            for G to change.  This may be\
    \ caused by a change in the MRIB\n            routing database or the group-to-RP\
    \ mapping.  Note that this\n            transition does not occur if an Assert\
    \ is active and the\n            upstream interface does not change.\n       \
    \     The upstream (*,G) state machine remains in Joined state.\n            Send\
    \ Join(*,G) to the new upstream neighbor, which is the\n            new value\
    \ of RPF'(*,G).  Send Prune(*,G) to the old upstream\n            neighbor, which\
    \ is the old value of RPF'(*,G).  Use the new\n            value of RP(G) in the\
    \ Prune(*,G) message or all zeros if\n            RP(G) becomes unknown (old value\
    \ of RP(G) may be used\n            instead to improve behavior in routers implementing\
    \ older\n            versions of this specification).  Set the Join Timer (JT)\
    \ to\n            expire after t_periodic seconds.\n      RPF'(*,G) GenID changes\n\
    \            The Generation ID of the router that is RPF'(*,G) changes.\n    \
    \        This normally means that this neighbor has lost state, and\n        \
    \    so the state must be refreshed.\n            The upstream (*,G) state machine\
    \ remains in Joined state.\n            If the Join Timer is set to expire in\
    \ more than\n            t_override seconds, reset it so that it expires after\n\
    \            t_override seconds.\n"
- title: 4.5.5.  Sending (S,G) Join/Prune Messages
  contents:
  - "4.5.5.  Sending (S,G) Join/Prune Messages\n   The per-interface state machines\
    \ for (S,G) hold join state from\n   downstream PIM routers.  This state then\
    \ determines whether a router\n   needs to propagate a Join(S,G) upstream towards\
    \ the source.\n   If a router wishes to propagate a Join(S,G) upstream, it must\
    \ also\n   watch for messages on its upstream interface from other routers on\n\
    \   that subnet, and these may modify its behavior.  If it sees a\n   Join(S,G)\
    \ to the correct upstream neighbor, it should suppress its\n   own Join(S,G).\
    \  If it sees a Prune(S,G), Prune(S,G,rpt), or\n   Prune(*,G) to the correct upstream\
    \ neighbor towards S, it should be\n   prepared to override that prune by scheduling\
    \ a Join(S,G) to be sent\n   almost immediately.  Finally, if it sees the Generation\
    \ ID of its\n   upstream neighbor change, it knows that the upstream neighbor\
    \ has\n   lost state, and it should refresh the state by scheduling a Join(S,G)\n\
    \   to be sent almost immediately.\n   If an (S,G) Assert occurs on the upstream\
    \ interface, and this changes\n   this router's idea of the upstream neighbor,\
    \ it should be prepared to\n   ensure that the Assert winner is aware of downstream\
    \ routers by\n   scheduling a Join(S,G) to be sent almost immediately.\n   In\
    \ addition, if MRIB changes cause the next hop towards the source to\n   change,\
    \ and either the upstream interface changes or there is no\n   Assert winner on\
    \ the upstream interface, the router should send a\n   prune to the old next hop\
    \ and a join to the new next hop.\n   The upstream (S,G) state machine only contains\
    \ two states:\n      Not Joined\n            The downstream state machines and\
    \ local membership\n            information do not indicate that the router needs\
    \ to join\n            the shortest-path tree for this (S,G).\n      Joined\n\
    \            The downstream state machines and local membership\n            information\
    \ indicate that the router should join the\n            shortest-path tree for\
    \ this (S,G).\n   In addition, one timer JT(S,G) is kept that is used to trigger\
    \ the\n   sending of a Join(S,G) to the upstream next hop towards S, RPF'(S,G).\n\
    \                 Figure 6: Upstream (S,G) State Machine\n"
- title: +-------------------+--------------------------------------------------+
  contents:
  - '+-------------------+--------------------------------------------------+

    '
- title: '|                   |                      Event                       |'
  contents:
  - '|                   |                      Event                       |

    '
- title: '|  Prev State       +-------------------------+------------------------+'
  contents:
  - '|  Prev State       +-------------------------+------------------------+

    '
- title: '|                   |   JoinDesired(S,G)      |   JoinDesired(S,G)     |'
  contents:
  - '|                   |   JoinDesired(S,G)      |   JoinDesired(S,G)     |

    '
- title: '|                   |   ->True                |   ->False              |'
  contents:
  - '|                   |   ->True                |   ->False              |

    '
- title: +-------------------+-------------------------+------------------------+
  contents:
  - '+-------------------+-------------------------+------------------------+

    '
- title: '|  NotJoined (NJ)   |   -> J state            |   -                    |'
  contents:
  - '|  NotJoined (NJ)   |   -> J state            |   -                    |

    '
- title: '|                   |   Send Join(S,G);       |                        |'
  contents:
  - '|                   |   Send Join(S,G);       |                        |

    '
- title: '|                   |   set Join Timer to     |                        |'
  contents:
  - '|                   |   set Join Timer to     |                        |

    '
- title: '|                   |   t_periodic            |                        |'
  contents:
  - '|                   |   t_periodic            |                        |

    '
- title: +-------------------+-------------------------+------------------------+
  contents:
  - '+-------------------+-------------------------+------------------------+

    '
- title: '|  Joined (J)       |   -                     |   -> NJ state          |'
  contents:
  - '|  Joined (J)       |   -                     |   -> NJ state          |

    '
- title: '|                   |                         |   Send Prune(S,G);     |'
  contents:
  - '|                   |                         |   Send Prune(S,G);     |

    '
- title: '|                   |                         |   set SPTbit(S,G) to   |'
  contents:
  - '|                   |                         |   set SPTbit(S,G) to   |

    '
- title: '|                   |                         |   FALSE; cancel Join   |'
  contents:
  - '|                   |                         |   FALSE; cancel Join   |

    '
- title: '|                   |                         |   Timer                |'
  contents:
  - '|                   |                         |   Timer                |

    '
- title: +-------------------+-------------------------+------------------------+
  contents:
  - "+-------------------+-------------------------+------------------------+\n  \
    \ In addition, we have the following transitions, which occur within\n   the Joined\
    \ state:\n"
- title: +----------------------------------------------------------------------+
  contents:
  - '+----------------------------------------------------------------------+

    '
- title: '|                         In Joined (J) State                          |'
  contents:
  - '|                         In Joined (J) State                          |

    '
- title: +-----------------+-----------------+-----------------+----------------+
  contents:
  - '+-----------------+-----------------+-----------------+----------------+

    '
- title: '| Timer Expires   | See Join(S,G)   | See Prune(S,G)  | See Prune      |'
  contents:
  - '| Timer Expires   | See Join(S,G)   | See Prune(S,G)  | See Prune      |

    '
- title: '|                 | to RPF''(S,G)    | to RPF''(S,G)    | (S,G,rpt) to   |'
  contents:
  - '|                 | to RPF''(S,G)    | to RPF''(S,G)    | (S,G,rpt) to   |

    '
- title: '|                 |                 |                 | RPF''(S,G)      |'
  contents:
  - '|                 |                 |                 | RPF''(S,G)      |

    '
- title: +-----------------+-----------------+-----------------+----------------+
  contents:
  - '+-----------------+-----------------+-----------------+----------------+

    '
- title: '| Send            | Increase Join   | Decrease Join   | Decrease Join  |'
  contents:
  - '| Send            | Increase Join   | Decrease Join   | Decrease Join  |

    '
- title: '| Join(S,G); set  | Timer to        | Timer to        | Timer to       |'
  contents:
  - '| Join(S,G); set  | Timer to        | Timer to        | Timer to       |

    '
- title: '| Join Timer to   | t_joinsuppress  | t_override      | t_override     |'
  contents:
  - '| Join Timer to   | t_joinsuppress  | t_override      | t_override     |

    '
- title: '| t_periodic      |                 |                 |                |'
  contents:
  - '| t_periodic      |                 |                 |                |

    '
- title: +-----------------+-----------------+-----------------+----------------+
  contents:
  - '+-----------------+-----------------+-----------------+----------------+

    '
- title: +----------------------------------------------------------------------+
  contents:
  - '+----------------------------------------------------------------------+

    '
- title: '|                        In Joined (J) State                           |'
  contents:
  - '|                        In Joined (J) State                           |

    '
- title: +-----------------+-----------------+----------------+-----------------+
  contents:
  - '+-----------------+-----------------+----------------+-----------------+

    '
- title: '| See Prune(*,G)  | RPF''(S,G)       | RPF''(S,G)      | RPF''(S,G)       |'
  contents:
  - '| See Prune(*,G)  | RPF''(S,G)       | RPF''(S,G)      | RPF''(S,G)       |

    '
- title: '| to RPF''(S,G)    | changes not     | GenID changes  | changes due to  |'
  contents:
  - '| to RPF''(S,G)    | changes not     | GenID changes  | changes due to  |

    '
- title: '|                 | due to an       |                | an Assert       |'
  contents:
  - '|                 | due to an       |                | an Assert       |

    '
- title: '|                 | Assert          |                |                 |'
  contents:
  - '|                 | Assert          |                |                 |

    '
- title: +-----------------+-----------------+----------------+-----------------+
  contents:
  - '+-----------------+-----------------+----------------+-----------------+

    '
- title: '| Decrease Join   | Send Join(S,G)  | Decrease Join  | Decrease Join   |'
  contents:
  - '| Decrease Join   | Send Join(S,G)  | Decrease Join  | Decrease Join   |

    '
- title: '| Timer to        | to new next     | Timer to       | Timer to        |'
  contents:
  - '| Timer to        | to new next     | Timer to       | Timer to        |

    '
- title: '| t_override      | hop; send       | t_override     | t_override      |'
  contents:
  - '| t_override      | hop; send       | t_override     | t_override      |

    '
- title: '|                 | Prune(S,G) to   |                |                 |'
  contents:
  - '|                 | Prune(S,G) to   |                |                 |

    '
- title: '|                 | old next hop;   |                |                 |'
  contents:
  - '|                 | old next hop;   |                |                 |

    '
- title: '|                 | set Join Timer  |                |                 |'
  contents:
  - '|                 | set Join Timer  |                |                 |

    '
- title: '|                 | to t_periodic   |                |                 |'
  contents:
  - '|                 | to t_periodic   |                |                 |

    '
- title: +-----------------+-----------------+----------------+-----------------+
  contents:
  - "+-----------------+-----------------+----------------+-----------------+\n  \
    \ This state machine uses the following macro:\n     bool JoinDesired(S,G) {\n\
    \         return( immediate_olist(S,G) != NULL\n                 OR ( KeepaliveTimer(S,G)\
    \ is running\n                      AND inherited_olist(S,G) != NULL ) )\n   \
    \  }\n   JoinDesired(S,G) is true when the router has forwarding state that\n\
    \   would cause it to forward traffic for G using source tree state.  The\n  \
    \ source tree state can be as a result of either active source-specific\n   join\
    \ state, or the (S,G) Keepalive Timer and active non-source-\n   specific state.\
    \  Note that although JoinDesired is true, the router's\n   sending of a Join(S,G)\
    \ message may be suppressed by another router\n   sending a Join(S,G) onto the\
    \ upstream interface.\n   Transitions from NotJoined State\n   When the upstream\
    \ (S,G) state machine is in NotJoined state, the\n   following event may trigger\
    \ a state transition:\n      JoinDesired(S,G) becomes True\n            The macro\
    \ JoinDesired(S,G) becomes True, e.g., because the\n            downstream state\
    \ for (S,G) has changed so that at least one\n            interface is in inherited_olist(S,G).\n\
    \            The upstream (S,G) state machine transitions to the Joined\n    \
    \        state.  Send Join(S,G) to the appropriate upstream neighbor,\n      \
    \      which is RPF'(S,G).  Set the Join Timer (JT) to expire after\n        \
    \    t_periodic seconds.\n   Transitions from Joined State\n   When the upstream\
    \ (S,G) state machine is in Joined state, the\n   following events may trigger\
    \ state transitions:\n      JoinDesired(S,G) becomes False\n            The macro\
    \ JoinDesired(S,G) becomes False, e.g., because the\n            downstream state\
    \ for (S,G) has changed so no interface is in\n            inherited_olist(S,G).\n\
    \            The upstream (S,G) state machine transitions to the\n           \
    \ NotJoined state.  Send Prune(S,G) to the appropriate\n            upstream neighbor,\
    \ which is RPF'(S,G).  Cancel the\n            Join Timer (JT), and set SPTbit(S,G)\
    \ to FALSE.\n      Join Timer Expires\n            The Join Timer (JT) expires,\
    \ indicating time to send a\n            Join(S,G).\n            Send Join(S,G)\
    \ to the appropriate upstream neighbor, which\n            is RPF'(S,G).  Restart\
    \ the Join Timer (JT) to expire after\n            t_periodic seconds.\n     \
    \ See Join(S,G) to RPF'(S,G)\n            This event is only relevant if RPF_interface(S)\
    \ is a shared\n            medium.  This router sees another router on RPF_interface(S)\n\
    \            send a Join(S,G) to RPF'(S,G).  This causes this router to\n    \
    \        suppress its own Join.\n            The upstream (S,G) state machine\
    \ remains in Joined state.\n            Let t_joinsuppress be the minimum of t_suppressed\
    \ and the\n            HoldTime from the Join/Prune message triggering this event.\n\
    \            If the Join Timer is set to expire in less than\n            t_joinsuppress\
    \ seconds, reset it so that it expires after\n            t_joinsuppress seconds.\
    \  If the Join Timer is set to expire\n            in more than t_joinsuppress\
    \ seconds, leave it unchanged.\n      See Prune(S,G) to RPF'(S,G)\n          \
    \  This event is only relevant if RPF_interface(S) is a shared\n            medium.\
    \  This router sees another router on RPF_interface(S)\n            send a Prune(S,G)\
    \ to RPF'(S,G).  As this router is in Joined\n            state, it must override\
    \ the Prune after a short random\n            interval.\n            The upstream\
    \ (S,G) state machine remains in Joined state.\n            If the Join Timer\
    \ is set to expire in more than\n            t_override seconds, reset it so that\
    \ it expires after\n            t_override seconds.\n      See Prune(S,G,rpt)\
    \ to RPF'(S,G)\n            This event is only relevant if RPF_interface(S) is\
    \ a shared\n            medium.  This router sees another router on RPF_interface(S)\n\
    \            send a Prune(S,G,rpt) to RPF'(S,G).  If the upstream router\n   \
    \         is an RFC-2362-compliant PIM router, then the Prune(S,G,rpt)\n     \
    \       will cause it to stop forwarding.  For backwards\n            compatibility,\
    \ this router should override the prune so that\n            forwarding continues.\n\
    \            The upstream (S,G) state machine remains in Joined state.\n     \
    \       If the Join Timer is set to expire in more than\n            t_override\
    \ seconds, reset it so that it expires after\n            t_override seconds.\n\
    \      See Prune(*,G) to RPF'(S,G)\n            This event is only relevant if\
    \ RPF_interface(S) is a shared\n            medium.  This router sees another\
    \ router on RPF_interface(S)\n            send a Prune(*,G) to RPF'(S,G).  If\
    \ the upstream router is\n            an RFC-2362-compliant PIM router, then the\
    \ Prune(*,G) will\n            cause it to stop forwarding.  For backwards compatibility,\n\
    \            this router should override the prune so that forwarding\n      \
    \      continues.\n            The upstream (S,G) state machine remains in Joined\
    \ state.\n            If the Join Timer is set to expire in more than\n      \
    \      t_override seconds, reset it so that it expires after\n            t_override\
    \ seconds.\n      RPF'(S,G) changes due to an Assert\n            The current\
    \ next hop towards S changes due to an Assert(S,G)\n            on the RPF_interface(S).\n\
    \            The upstream (S,G) state machine remains in Joined state.\n     \
    \       If the Join Timer is set to expire in more than\n            t_override\
    \ seconds, reset it so that it expires after\n            t_override seconds.\
    \  If the Join Timer is set to expire in\n            less than t_override seconds,\
    \ leave it unchanged.\n      RPF'(S,G) changes not due to an Assert\n        \
    \    An event occurred that caused the next hop towards S to\n            change.\
    \  Note that this transition does not occur if an\n            Assert is active\
    \ and the upstream interface does not change.\n            The upstream (S,G)\
    \ state machine remains in Joined state.\n            Send Join(S,G) to the new\
    \ upstream neighbor, which is the\n            new value of RPF'(S,G).  Send Prune(S,G)\
    \ to the old upstream\n            neighbor, which is the old value of RPF'(S,G).\
    \  Set the\n            Join Timer (JT) to expire after t_periodic seconds.\n\
    \      RPF'(S,G) GenID changes\n            The Generation ID of the router that\
    \ is RPF'(S,G) changes.\n            This normally means that this neighbor has\
    \ lost state, and\n            so the state must be refreshed.\n            The\
    \ upstream (S,G) state machine remains in Joined state.\n            If the Join\
    \ Timer is set to expire in more than\n            t_override seconds, reset it\
    \ so that it expires after\n            t_override seconds.\n"
- title: 4.5.6.  (S,G,rpt) Periodic Messages
  contents:
  - "4.5.6.  (S,G,rpt) Periodic Messages\n   (S,G,rpt) Joins and Prunes are (S,G)\
    \ Joins or Prunes sent on the RP\n   tree with the RPT bit set, either to modify\
    \ the results of (*,G)\n   Joins, or to override the behavior of other upstream\
    \ LAN peers.  The\n   next section describes the rules for sending triggered messages.\n\
    \   This section describes the rules for including a Prune(S,G,rpt)\n   message\
    \ with a Join(*,G).\n   When a router is going to send a Join(*,G), it should\
    \ use the\n   following pseudocode, for each (S,G) for which it has state, to\n\
    \   decide whether to include a Prune(S,G,rpt) in the compound Join/Prune\n  \
    \ message:\n     if( SPTbit(S,G) == TRUE ) {\n         # Note: If receiving (S,G)\
    \ on the SPT, we only prune off the\n         # shared tree if the RPF neighbors\
    \ differ.\n          if( RPF'(*,G) != RPF'(S,G) ) {\n              add Prune(S,G,rpt)\
    \ to compound message\n          }\n     } else if ( inherited_olist(S,G,rpt)\
    \ == NULL ) {\n       # Note: All (*,G) olist interfaces received RPT prunes for\
    \ (S,G).\n       add Prune(S,G,rpt) to compound message\n     } else if ( RPF'(*,G)\
    \ != RPF'(S,G,rpt) {\n       # Note: We joined the shared tree, but there was\
    \ an (S,G) assert\n       # and the source tree RPF neighbor is different.\n \
    \      add Prune(S,G,rpt) to compound message\n     }\n   Note that Join(S,G,rpt)\
    \ is normally sent not as a periodic message,\n   but only as a triggered message.\n"
- title: 4.5.7.  State Machine for (S,G,rpt) Triggered Messages
  contents:
  - "4.5.7.  State Machine for (S,G,rpt) Triggered Messages\n   The state machine\
    \ for (S,G,rpt) triggered messages is required\n   per-(S,G) when there is (*,G)\
    \ join state at a router, and the router\n   or any of its upstream LAN peers\
    \ wishes to prune S off the RP tree.\n   There are three states in the state machine.\
    \  One of the states is\n   when there is no (*,G) join state at this router.\
    \  If there is (*,G)\n   join state at the router, then the state machine must\
    \ be at one of\n   the other two states.  The three states are:\n      Pruned(S,G,rpt)\n\
    \         (*,G) Joined, but (S,G,rpt) pruned.\n      NotPruned(S,G,rpt)\n    \
    \     (*,G) Joined, and (S,G,rpt) not pruned.\n      RPTNotJoined(G)\n       \
    \  (*,G) has not been joined.\n   In addition, there is an (S,G,rpt) Override\
    \ Timer, OT(S,G,rpt), which\n   is used to delay triggered Join(S,G,rpt) messages\
    \ to prevent\n   implosions of triggered messages.\n   Figure 7: Upstream (S,G,rpt)\
    \ State Machine for Triggered Messages\n"
- title: +------------++--------------------------------------------------------+
  contents:
  - '+------------++--------------------------------------------------------+

    '
- title: '|            ||                           Event                        |'
  contents:
  - '|            ||                           Event                        |

    '
- title: '|            ++--------------+--------------+-------------+------------+'
  contents:
  - '|            ++--------------+--------------+-------------+------------+

    '
- title: '|Prev State  || PruneDesired | PruneDesired | RPTJoin     | inherited_ |'
  contents:
  - '|Prev State  || PruneDesired | PruneDesired | RPTJoin     | inherited_ |

    '
- title: '|            || (S,G,rpt)    | (S,G,rpt)    | Desired(G)  | olist      |'
  contents:
  - '|            || (S,G,rpt)    | (S,G,rpt)    | Desired(G)  | olist      |

    '
- title: '|            || ->True       | ->False      | ->False     | (S,G,rpt)  |'
  contents:
  - '|            || ->True       | ->False      | ->False     | (S,G,rpt)  |

    '
- title: '|            ||              |              |             | ->non-NULL |'
  contents:
  - '|            ||              |              |             | ->non-NULL |

    '
- title: +------------++--------------+--------------+-------------+------------+
  contents:
  - '+------------++--------------+--------------+-------------+------------+

    '
- title: '|RPTNotJoined|| -> P state   | -            | -           | -> NP state|'
  contents:
  - '|RPTNotJoined|| -> P state   | -            | -           | -> NP state|

    '
- title: '|(G) (NJ)    ||              |              |             |            |'
  contents:
  - '|(G) (NJ)    ||              |              |             |            |

    '
- title: +------------++--------------+--------------+-------------+------------+
  contents:
  - '+------------++--------------+--------------+-------------+------------+

    '
- title: '|Pruned      || -            | -> NP state  | -> NJ state | -          |'
  contents:
  - '|Pruned      || -            | -> NP state  | -> NJ state | -          |

    '
- title: '|(S,G,rpt)   ||              | Send Join    |             |            |'
  contents:
  - '|(S,G,rpt)   ||              | Send Join    |             |            |

    '
- title: '|(P)         ||              | (S,G,rpt)    |             |            |'
  contents:
  - '|(P)         ||              | (S,G,rpt)    |             |            |

    '
- title: +------------++--------------+--------------+-------------+------------+
  contents:
  - '+------------++--------------+--------------+-------------+------------+

    '
- title: '|NotPruned   || -> P state   | -            | -> NJ state | -          |'
  contents:
  - '|NotPruned   || -> P state   | -            | -> NJ state | -          |

    '
- title: '|(S,G,rpt)   || Send Prune   |              | Cancel OT   |            |'
  contents:
  - '|(S,G,rpt)   || Send Prune   |              | Cancel OT   |            |

    '
- title: '|(NP)        || (S,G,rpt);   |              |             |            |'
  contents:
  - '|(NP)        || (S,G,rpt);   |              |             |            |

    '
- title: '|            || cancel OT    |              |             |            |'
  contents:
  - '|            || cancel OT    |              |             |            |

    '
- title: +------------++--------------+--------------+-------------+------------+
  contents:
  - "+------------++--------------+--------------+-------------+------------+\n  \
    \ Additionally, we have the following transitions within the\n   NotPruned(S,G,rpt)\
    \ state, which are all used for prune override\n   behavior.\n"
- title: +----------------------------------------------------------------------+
  contents:
  - '+----------------------------------------------------------------------+

    '
- title: '|                    In NotPruned(S,G,rpt) State                       |'
  contents:
  - '|                    In NotPruned(S,G,rpt) State                       |

    '
- title: +----------+--------------+--------------+--------------+--------------+
  contents:
  - '+----------+--------------+--------------+--------------+--------------+

    '
- title: '|Override  | See Prune    | See Join     | See Prune    | RPF''         |'
  contents:
  - '|Override  | See Prune    | See Join     | See Prune    | RPF''         |

    '
- title: '|Timer     | (S,G,rpt) to | (S,G,rpt) to | (S,G) to     | (S,G,rpt) -> |'
  contents:
  - '|Timer     | (S,G,rpt) to | (S,G,rpt) to | (S,G) to     | (S,G,rpt) -> |

    '
- title: '|expires   | RPF''         | RPF''         | RPF''         | RPF'' (*,G)   |'
  contents:
  - '|expires   | RPF''         | RPF''         | RPF''         | RPF'' (*,G)   |

    '
- title: '|          | (S,G,rpt)    | (S,G,rpt)    | (S,G,rpt)    |              |'
  contents:
  - '|          | (S,G,rpt)    | (S,G,rpt)    | (S,G,rpt)    |              |

    '
- title: +----------+--------------+--------------+--------------+--------------+
  contents:
  - '+----------+--------------+--------------+--------------+--------------+

    '
- title: '|Send Join | OT = min(OT, | Cancel OT    | OT = min(OT, | OT = min(OT, |'
  contents:
  - '|Send Join | OT = min(OT, | Cancel OT    | OT = min(OT, | OT = min(OT, |

    '
- title: '|(S,G,rpt);| t_override)  |              | t_override)  | t_override)  |'
  contents:
  - '|(S,G,rpt);| t_override)  |              | t_override)  | t_override)  |

    '
- title: '|leave OT  |              |              |              |              |'
  contents:
  - '|leave OT  |              |              |              |              |

    '
- title: '|unset     |              |              |              |              |'
  contents:
  - '|unset     |              |              |              |              |

    '
- title: +----------+--------------+--------------+--------------+--------------+
  contents:
  - "+----------+--------------+--------------+--------------+--------------+\n  \
    \ Note that the min function in the above state machine considers a\n   non-running\
    \ timer to have an infinite value (e.g., min(not-running,\n   t_override) = t_override).\n\
    \   This state machine uses the following macros:\n     bool RPTJoinDesired(G)\
    \ {\n       return (JoinDesired(*,G))\n     }\n   RPTJoinDesired(G) is true when\
    \ the router has forwarding state that\n   would cause it to forward traffic for\
    \ G using (*,G) shared tree\n   state.\n     bool PruneDesired(S,G,rpt) {\n  \
    \        return ( RPTJoinDesired(G) AND\n                   ( inherited_olist(S,G,rpt)\
    \ == NULL\n                     OR (SPTbit(S,G)==TRUE\n                      \
    \   AND (RPF'(*,G) != RPF'(S,G)) )))\n     }\n   PruneDesired(S,G,rpt) can only\
    \ be true if RPTJoinDesired(G) is true.\n   If RPTJoinDesired(G) is true, then\
    \ PruneDesired(S,G,rpt) is true\n   either if there are no outgoing interfaces\
    \ that S would be forwarded\n   on, or if the router has active (S,G) forwarding\
    \ state but RPF'(*,G)\n   != RPF'(S,G).\n   The state machine contains the following\
    \ transition events:\n      See Join(S,G,rpt) to RPF'(S,G,rpt)\n            This\
    \ event is only relevant in the \"Not Pruned\" state.\n            The router\
    \ sees a Join(S,G,rpt) from someone else to\n            RPF'(S,G,rpt), which\
    \ is the correct upstream neighbor.  If\n            we're in \"NotPruned\" state\
    \ and the (S,G,rpt) Override Timer\n            is running, then this is because\
    \ we have been triggered to\n            send our own Join(S,G,rpt) to RPF'(S,G,rpt).\
    \  Someone else\n            beat us to it, so there's no need to send our own\
    \ Join.\n            The action is to cancel the Override Timer.\n      See Prune(S,G,rpt)\
    \ to RPF'(S,G,rpt)\n            This event is only relevant in the \"NotPruned\"\
    \ state.\n            The router sees a Prune(S,G,rpt) from someone else to\n\
    \            RPF'(S,G,rpt), which is the correct upstream neighbor.  If\n    \
    \        we're in the \"NotPruned\" state, then we want to continue to\n     \
    \       receive traffic from S destined for G, and that traffic is\n         \
    \   being supplied by RPF'(S,G,rpt).  Thus, we need to override\n            the\
    \ Prune.\n            The action is to set the (S,G,rpt) Override Timer to the\n\
    \            randomized prune-override interval, t_override.  However, if\n  \
    \          the Override Timer is already running, we only set the timer\n    \
    \        if doing so would set it to a lower value.  At the end of\n         \
    \   this interval, if no one else has sent a Join, then we will\n            do\
    \ so.\n      See Prune(S,G) to RPF'(S,G,rpt)\n            This event is only relevant\
    \ in the \"NotPruned\" state.\n            This transition and action are the\
    \ same as the above\n            transition and action, except that the Prune\
    \ does not have\n            the RPT bit set.  This transition is necessary to\
    \ be\n            compatible with routers implemented from RFC 2362 that don't\n\
    \            maintain separate (S,G) and (S,G,rpt) state.\n      The (S,G,rpt)\
    \ prune Override Timer expires\n            This event is only relevant in the\
    \ \"NotPruned\" state.\n            When the Override Timer expires, we must send\
    \ a\n            Join(S,G,rpt) to RPF'(S,G,rpt) to override the Prune message\n\
    \            that caused the timer to be running.  We only send this if\n    \
    \        RPF'(S,G,rpt) equals RPF'(*,G); if this were not the case,\n        \
    \    then the Join might be sent to a router that does not have\n            (*,G)\
    \ Join state, and so the behavior would not be well\n            defined.  If\
    \ RPF'(S,G,rpt) is not the same as RPF'(*,G),\n            then it may stop forwarding\
    \ S.  However, if this happens,\n            then the router will send an AssertCancel(S,G),\
    \ which would\n            then cause RPF'(S,G,rpt) to become equal to RPF'(*,G)\
    \ (see\n            below).\n      RPF'(S,G,rpt) changes to become equal to RPF'(*,G)\n\
    \            This event is only relevant in the \"NotPruned\" state.\n       \
    \     RPF'(S,G,rpt) can only be different from RPF'(*,G) if an\n            (S,G)\
    \ Assert has happened, which means that traffic from S\n            is arriving\
    \ on the SPT, and so Prune(S,G,rpt) will have been\n            sent to RPF'(*,G).\
    \  When RPF'(S,G,rpt) changes to become\n            equal to RPF'(*,G), we need\
    \ to trigger a Join(S,G,rpt) to\n            RPF'(*,G) to cause that router to\
    \ start forwarding S again.\n            The action is to set the (S,G,rpt) Override\
    \ Timer to the\n            randomized prune-override interval t_override.  However,\
    \ if\n            the timer is already running, we only set the timer if doing\n\
    \            so would set it to a lower value.  At the end of this\n         \
    \   interval, if no one else has sent a Join, then we will\n            do so.\n\
    \      PruneDesired(S,G,rpt)->TRUE\n            See macro above.  This event is\
    \ relevant in the \"NotPruned\"\n            and \"RPTNotJoined(G)\" states.\n\
    \            The router wishes to receive traffic for G but does not wish\n  \
    \          to receive traffic from S destined for G.  This causes the\n      \
    \      router to transition into the Pruned state.\n            If the router\
    \ was previously in NotPruned state, then the\n            action is to send a\
    \ Prune(S,G,rpt) to RPF'(S,G,rpt), and to\n            cancel the Override Timer.\
    \  If the router was previously in\n            RPTNotJoined(G) state, then there\
    \ is no need to trigger an\n            action in this state machine because sending\
    \ a\n            Prune(S,G,rpt) is handled by the rules for sending the\n    \
    \        Join(*,G).\n      PruneDesired(S,G,rpt)->FALSE\n            See macro\
    \ above.  This transition is only relevant in the\n            \"Pruned\" state.\n\
    \            If the router is in the Pruned(S,G,rpt) state, and\n            PruneDesired(S,G,rpt)\
    \ changes to FALSE, this could be\n            because the router no longer has\
    \ RPTJoinDesired(G) true, or\n            it now wishes to receive traffic from\
    \ S again.  If it is the\n            former, then this transition should not\
    \ happen, but instead\n            the \"RPTJoinDesired(G)->FALSE\" transition\
    \ should happen.\n            Thus, this transition should be interpreted as\n\
    \            \"PruneDesired(S,G,rpt)->FALSE AND RPTJoinDesired(G)==TRUE\".\n \
    \           The action is to send a Join(S,G,rpt) to RPF'(S,G,rpt).\n      RPTJoinDesired(G)->FALSE\n\
    \            This event is relevant in the \"Pruned\" and \"NotPruned\"\n    \
    \        states.\n            The router no longer wishes to receive any traffic\
    \ destined\n            for G on the RP Tree.  This causes a transition to the\n\
    \            RPTNotJoined(G) state, and the Override Timer is canceled if\n  \
    \          it was running.  Any further actions are handled by the\n         \
    \   appropriate upstream state machine for (*,G).\n      inherited_olist(S,G,rpt)\
    \ becomes non-NULL\n            This transition is only relevant in the RPTNotJoined(G)\n\
    \            state.\n            The router has joined the RP tree (handled by\
    \ the (*,G)\n            upstream state machine as appropriate) and wants to receive\n\
    \            traffic from S.  This does not trigger any events in this\n     \
    \       state machine, but causes a transition to the\n            NotPruned(S,G,rpt)\
    \ state.\n"
- title: 4.6.  PIM Assert Messages
  contents:
  - "4.6.  PIM Assert Messages\n   Where multiple PIM routers peer over a shared LAN,\
    \ it is possible for\n   more than one upstream router to have valid forwarding\
    \ state for a\n   packet, which can lead to packet duplication (see Section 3.6).\
    \  PIM\n   does not attempt to prevent this from occurring.  Instead, it detects\n\
    \   when this has happened and elects a single forwarder amongst the\n   upstream\
    \ routers to prevent further duplication.  This election is\n   performed using\
    \ PIM Assert messages.  Assert messages are also\n   received by downstream routers\
    \ on the LAN, and these cause subsequent\n   Join/Prune messages to be sent to\
    \ the upstream router that won the\n   Assert.\n   In general, a PIM Assert message\
    \ should only be accepted for\n   processing if it comes from a known PIM neighbor.\
    \  A PIM router hears\n   about PIM neighbors through PIM Hello messages.  If\
    \ a router receives\n   an Assert message from a particular IP source address\
    \ and it has not\n   seen a PIM Hello message from that source address, then the\
    \ Assert\n   message SHOULD be discarded without further processing.  In addition,\n\
    \   if the Hello message from a neighbor was authenticated (see\n   Section 6.3),\
    \ then all Assert messages from that neighbor MUST also\n   be authenticated.\n\
    \   We note that some older PIM implementations incorrectly fail to send\n   Hello\
    \ messages on point-to-point interfaces, so we also RECOMMEND\n   that a configuration\
    \ option be provided to allow interoperation with\n   such older routers, but\
    \ that this configuration option SHOULD NOT be\n   enabled by default.\n"
- title: 4.6.1.  (S,G) Assert Message State Machine
  contents:
  - "4.6.1.  (S,G) Assert Message State Machine\n   The (S,G) Assert state machine\
    \ for interface I is shown in Figure 8.\n   There are three states:\n      NoInfo\
    \ (NI)\n            This router has no (S,G) assert state on interface I.\n  \
    \    I am Assert Winner (W)\n            This router has won an (S,G) assert on\
    \ interface I.  It is\n            now responsible for forwarding traffic from\
    \ S destined for G\n            out of interface I.  Irrespective of whether it\
    \ is the DR\n            for I, while a router is the assert winner, it is also\n\
    \            responsible for forwarding traffic onto I on behalf of local\n  \
    \          hosts on I that have made membership requests that\n            specifically\
    \ refer to S (and G).\n      I am Assert Loser (L)\n            This router has\
    \ lost an (S,G) assert on interface I.  It\n            must not forward packets\
    \ from S destined for G onto\n            interface I.  If it is the DR on I,\
    \ it is no longer\n            responsible for forwarding traffic onto I to satisfy\
    \ local\n            hosts with membership requests that specifically refer to\
    \ S\n            and G.\n   In addition, there is also an Assert Timer (AT) that\
    \ is used to\n   time out asserts on the assert losers and to resend asserts on\
    \ the\n   assert winner.\n           Figure 8: Per-Interface (S,G) Assert State\
    \ Machine\n"
- title: +----------------------------------------------------------------------+
  contents:
  - '+----------------------------------------------------------------------+

    '
- title: '|                         In NoInfo (NI) State                         |'
  contents:
  - '|                         In NoInfo (NI) State                         |

    '
- title: +---------------+-------------------+------------------+---------------+
  contents:
  - '+---------------+-------------------+------------------+---------------+

    '
- title: '| Receive       |  Receive Assert   |  Data arrives    |  Receive      |'
  contents:
  - '| Receive       |  Receive Assert   |  Data arrives    |  Receive      |

    '
- title: '| Inferior      |  with RPTbit      |  from S to G on  |  Acceptable   |'
  contents:
  - '| Inferior      |  with RPTbit      |  from S to G on  |  Acceptable   |

    '
- title: '| Assert with   |  set and          |  I and           |  Assert with  |'
  contents:
  - '| Assert with   |  set and          |  I and           |  Assert with  |

    '
- title: '| RPTbit clear  |  CouldAssert      |  CouldAssert     |  RPTbit clear |'
  contents:
  - '| RPTbit clear  |  CouldAssert      |  CouldAssert     |  RPTbit clear |

    '
- title: '|               |  (S,G,I)          |  (S,G,I)         |  and AssTrDes |'
  contents:
  - '|               |  (S,G,I)          |  (S,G,I)         |  and AssTrDes |

    '
- title: '|               |                   |                  |  (S,G,I)      |'
  contents:
  - '|               |                   |                  |  (S,G,I)      |

    '
- title: +---------------+-------------------+------------------+---------------+
  contents:
  - '+---------------+-------------------+------------------+---------------+

    '
- title: '| -> W state    |  -> W state       |  -> W state      |  -> L state   |'
  contents:
  - '| -> W state    |  -> W state       |  -> W state      |  -> L state   |

    '
- title: '| [Actions A1]  |  [Actions A1]     |  [Actions A1]    |  [Actions A6] |'
  contents:
  - '| [Actions A1]  |  [Actions A1]     |  [Actions A1]    |  [Actions A6] |

    '
- title: +---------------+-------------------+------------------+---------------+
  contents:
  - '+---------------+-------------------+------------------+---------------+

    '
- title: +----------------------------------------------------------------------+
  contents:
  - '+----------------------------------------------------------------------+

    '
- title: '|                   In I Am Assert Winner (W) State                    |'
  contents:
  - '|                   In I Am Assert Winner (W) State                    |

    '
- title: +----------------+------------------+-----------------+----------------+
  contents:
  - '+----------------+------------------+-----------------+----------------+

    '
- title: '| Assert Timer   |   Receive        |  Receive        |  CouldAssert   |'
  contents:
  - '| Assert Timer   |   Receive        |  Receive        |  CouldAssert   |

    '
- title: '| Expires        |   Inferior       |  Preferred      |  (S,G,I) ->    |'
  contents:
  - '| Expires        |   Inferior       |  Preferred      |  (S,G,I) ->    |

    '
- title: '|                |   Assert         |  Assert         |  FALSE         |'
  contents:
  - '|                |   Assert         |  Assert         |  FALSE         |

    '
- title: +----------------+------------------+-----------------+----------------+
  contents:
  - '+----------------+------------------+-----------------+----------------+

    '
- title: '| -> W state     |   -> W state     |  -> L state     |  -> NI state   |'
  contents:
  - '| -> W state     |   -> W state     |  -> L state     |  -> NI state   |

    '
- title: '| [Actions A3]   |   [Actions A3]   |  [Actions A2]   |  [Actions A4]  |'
  contents:
  - '| [Actions A3]   |   [Actions A3]   |  [Actions A2]   |  [Actions A4]  |

    '
- title: +----------------+------------------+-----------------+----------------+
  contents:
  - '+----------------+------------------+-----------------+----------------+

    '
- title: +---------------------------------------------------------------------+
  contents:
  - '+---------------------------------------------------------------------+

    '
- title: '|                   In I Am Assert Loser (L) State                    |'
  contents:
  - '|                   In I Am Assert Loser (L) State                    |

    '
- title: +-------------+-------------+-------------+-------------+-------------+
  contents:
  - '+-------------+-------------+-------------+-------------+-------------+

    '
- title: '|Receive      |Receive      |Receive      |Assert Timer |Current      |'
  contents:
  - '|Receive      |Receive      |Receive      |Assert Timer |Current      |

    '
- title: '|Preferred    |Acceptable   |Inferior     |Expires      |Winner''s     |'
  contents:
  - '|Preferred    |Acceptable   |Inferior     |Expires      |Winner''s     |

    '
- title: '|Assert       |Assert with  |Assert or    |             |GenID        |'
  contents:
  - '|Assert       |Assert with  |Assert or    |             |GenID        |

    '
- title: '|             |RPTbit clear |Assert       |             |Changes or   |'
  contents:
  - '|             |RPTbit clear |Assert       |             |Changes or   |

    '
- title: '|             |from Current |Cancel from  |             |NLT Expires  |'
  contents:
  - '|             |from Current |Cancel from  |             |NLT Expires  |

    '
- title: '|             |Winner       |Current      |             |             |'
  contents:
  - '|             |Winner       |Current      |             |             |

    '
- title: '|             |             |Winner       |             |             |'
  contents:
  - '|             |             |Winner       |             |             |

    '
- title: +-------------+-------------+-------------+-------------+-------------+
  contents:
  - '+-------------+-------------+-------------+-------------+-------------+

    '
- title: '|-> L state   |-> L state   |-> NI state  |-> NI state  |-> NI state  |'
  contents:
  - '|-> L state   |-> L state   |-> NI state  |-> NI state  |-> NI state  |

    '
- title: '|[Actions A2] |[Actions A2] |[Actions A5] |[Actions A5] |[Actions A5] |'
  contents:
  - '|[Actions A2] |[Actions A2] |[Actions A5] |[Actions A5] |[Actions A5] |

    '
- title: +-------------+-------------+-------------+-------------+-------------+
  contents:
  - '+-------------+-------------+-------------+-------------+-------------+

    '
- title: +----------------------------------------------------------------------+
  contents:
  - '+----------------------------------------------------------------------+

    '
- title: '|                    In I Am Assert Loser (L) State                    |'
  contents:
  - '|                    In I Am Assert Loser (L) State                    |

    '
- title: +----------------+-----------------+------------------+----------------+
  contents:
  - '+----------------+-----------------+------------------+----------------+

    '
- title: '| AssTrDes       |  my_metric ->   |  RPF_interface   |  Receive       |'
  contents:
  - '| AssTrDes       |  my_metric ->   |  RPF_interface   |  Receive       |

    '
- title: '| (S,G,I) ->     |  better than    |  (S) stops       |  Join(S,G) on  |'
  contents:
  - '| (S,G,I) ->     |  better than    |  (S) stops       |  Join(S,G) on  |

    '
- title: '| FALSE          |  winner''s       |  being I         |  interface I   |'
  contents:
  - '| FALSE          |  winner''s       |  being I         |  interface I   |

    '
- title: '|                |  metric         |                  |                |'
  contents:
  - '|                |  metric         |                  |                |

    '
- title: +----------------+-----------------+------------------+----------------+
  contents:
  - '+----------------+-----------------+------------------+----------------+

    '
- title: '| -> NI state    |  -> NI state    |  -> NI state     |  -> NI State   |'
  contents:
  - '| -> NI state    |  -> NI state    |  -> NI state     |  -> NI State   |

    '
- title: '| [Actions A5]   |  [Actions A5]   |  [Actions A5]    |  [Actions A5]  |'
  contents:
  - '| [Actions A5]   |  [Actions A5]   |  [Actions A5]    |  [Actions A5]  |

    '
- title: +----------------+-----------------+------------------+----------------+
  contents:
  - "+----------------+-----------------+------------------+----------------+\n  \
    \ Note that for reasons of compactness, \"AssTrDes(S,G,I)\" is used in\n   the\
    \ state machine table to refer to AssertTrackingDesired(S,G,I).\n   Terminology:\n\
    \      A \"preferred assert\" is one with a better metric than the current\n \
    \     winner.\n      An \"acceptable assert\" is one that has a better metric\
    \ than\n      my_assert_metric(S,G,I).  An assert is never considered acceptable\n\
    \      if its metric is infinite.\n      An \"inferior assert\" is one with a\
    \ worse metric than\n      my_assert_metric(S,G,I).  An assert is never considered\
    \ inferior\n      if my_assert_metric(S,G,I) is infinite.\n   The state machine\
    \ uses the following macros:\n   CouldAssert(S,G,I) =\n        SPTbit(S,G)==TRUE\n\
    \        AND (RPF_interface(S) != I)\n        AND (I in ( ( joins(*,G) (-) prunes(S,G,rpt)\
    \ )\n                    (+) ( pim_include(*,G) (-) pim_exclude(S,G) )\n     \
    \               (-) lost_assert(*,G)\n                    (+) joins(S,G) (+) pim_include(S,G)\
    \ ) )\n   CouldAssert(S,G,I) is true for downstream interfaces that would be in\n\
    \   the inherited_olist(S,G) if (S,G) assert information was not taken\n   into\
    \ account.\n   AssertTrackingDesired(S,G,I) =\n        (I in ( joins(*,G) (-)\
    \ prunes(S,G,rpt)\n                (+) ( pim_include(*,G) (-) pim_exclude(S,G)\
    \ )\n                (-) lost_assert(*,G)\n                (+) joins(S,G) ) )\n\
    \        OR (local_receiver_include(S,G,I) == TRUE\n            AND (I_am_DR(I)\
    \ OR (AssertWinner(S,G,I) == me)))\n        OR ((RPF_interface(S) == I) AND (JoinDesired(S,G)\
    \ == TRUE))\n        OR ((RPF_interface(RP(G)) == I) AND (JoinDesired(*,G) ==\
    \ TRUE)\n            AND (SPTbit(S,G) == FALSE))\n   AssertTrackingDesired(S,G,I)\
    \ is true on any interface in which an\n   (S,G) assert might affect the router's\
    \ behavior on that interface.\n   The first three lines of AssertTrackingDesired\
    \ account for (*,G) join\n   and local membership information received on I that\
    \ might cause the\n   router to be interested in asserts on I.\n   The 4th line\
    \ accounts for (S,G) join information received on I that\n   might cause the router\
    \ to be interested in asserts on I.\n   The 5th and 6th lines account for (S,G)\
    \ local membership information\n   on I.  Note that we can't use the pim_include(S,G)\
    \ macro, since it\n   uses lost_assert(S,G,I) and would result in the router forgetting\n\
    \   that it lost an assert if the only reason it was interested was local\n  \
    \ membership.  The AssertWinner(S,G,I) check forces an assert winner to\n   keep\
    \ on being responsible for forwarding as long as local receivers\n   are present.\
    \  Removing this check would make the assert winner\n   give up forwarding as\
    \ soon as the information that originally caused\n   it to forward went away,\
    \ and the task of forwarding for local\n   receivers would revert back to the\
    \ DR.\n   The last three lines account for the fact that a router must keep\n\
    \   track of assert information on upstream interfaces in order to send\n   joins\
    \ and prunes to the proper neighbor.\n   Transitions from NoInfo State\n   When\
    \ in NoInfo state, the following events may trigger transitions:\n      Receive\
    \ Inferior Assert with RPTbit cleared\n            An assert is received for (S,G)\
    \ with the RPT bit cleared\n            that is inferior to our own assert metric.\
    \  The RPT bit\n            cleared indicates that the sender of the assert had\
    \ (S,G)\n            forwarding state on this interface.  If the assert is\n \
    \           inferior to our metric, then we must also have (S,G)\n           \
    \ forwarding state (i.e., CouldAssert(S,G,I)==TRUE) as (S,G)\n            asserts\
    \ have priority over (*,G) asserts, and so we should\n            be the assert\
    \ winner.  We transition to the \"I am Assert\n            Winner\" state and\
    \ perform Actions A1 (below).\n      Receive Assert with RPTbit set AND CouldAssert(S,G,I)==TRUE\n\
    \            An assert is received for (S,G) on I with the RPT bit set\n     \
    \       (it is a (*,G) assert).  CouldAssert(S,G,I) is TRUE only if\n        \
    \    we have (S,G) forwarding state on this interface, so we\n            should\
    \ be the assert winner.  We transition to the \"I am\n            Assert Winner\"\
    \ state and perform Actions A1 (below).\n      An (S,G) data packet arrives on\
    \ interface I, AND\n         CouldAssert(S,G,I)==TRUE\n            An (S,G) data\
    \ packet arrived on a downstream interface that\n            is in our (S,G) outgoing\
    \ interface list.  We optimistically\n            assume that we will be the assert\
    \ winner for this (S,G), and\n            so we transition to the \"I am Assert\
    \ Winner\" state and\n            perform Actions A1 (below), which will initiate\
    \ the assert\n            negotiation for (S,G).\n      Receive Acceptable Assert\
    \ with RPT bit clear AND\n         AssertTrackingDesired(S,G,I)==TRUE\n      \
    \      We're interested in (S,G) Asserts, either because I is a\n            downstream\
    \ interface for which we have (S,G) or (*,G)\n            forwarding state, or\
    \ because I is the upstream interface for\n            S and we have (S,G) forwarding\
    \ state.  The received assert\n            has a better metric than our own, so\
    \ we do not win the\n            Assert.  We transition to \"I am Assert Loser\"\
    \ and perform\n            Actions A6 (below).\n   Transitions from \"I am Assert\
    \ Winner\" State\n   When in \"I am Assert Winner\" state, the following events\
    \ trigger\n   transitions:\n      Assert Timer Expires\n            The (S,G)\
    \ Assert Timer expires.  As we're in the Winner\n            state, we must still\
    \ have (S,G) forwarding state that is\n            actively being kept alive.\
    \  We resend the (S,G) Assert and\n            restart the Assert Timer (Actions\
    \ A3 below).  Note that the\n            assert winner's Assert Timer is engineered\
    \ to expire shortly\n            before timers on assert losers; this prevents\
    \ unnecessary\n            thrashing of the forwarder and periodic flooding of\n\
    \            duplicate packets.\n      Receive Inferior Assert\n            We\
    \ receive an (S,G) assert or (*,G) assert mentioning S that\n            has a\
    \ worse metric than our own.  Whoever sent the assert is\n            in error,\
    \ and so we resend an (S,G) Assert and restart the\n            Assert Timer (Actions\
    \ A3 below).\n      Receive Preferred Assert\n            We receive an (S,G)\
    \ assert that has a better metric than our\n            own.  We transition to\
    \ \"I am Assert Loser\" state and perform\n            Actions A2 (below).  Note\
    \ that this may affect the value of\n            JoinDesired(S,G) and PruneDesired(S,G,rpt),\
    \ which could\n            cause transitions in the upstream (S,G) or (S,G,rpt)\
    \ state\n            machines.\n      CouldAssert(S,G,I) -> FALSE\n          \
    \  Our (S,G) forwarding state or RPF interface changed so as to\n            make\
    \ CouldAssert(S,G,I) become false.  We can no longer\n            perform the\
    \ actions of the assert winner, and so we\n            transition to NoInfo state\
    \ and perform Actions A4 (below).\n            This includes sending a \"canceling\
    \ assert\" with an infinite\n            metric.\n   Transitions from \"I am Assert\
    \ Loser\" State\n   When in \"I am Assert Loser\" state, the following transitions\
    \ can\n   occur:\n      Receive Preferred Assert\n            We receive an assert\
    \ that is better than that of the current\n            assert winner.  We stay\
    \ in Loser state and perform\n            Actions A2 below.\n      Receive Acceptable\
    \ Assert with RPTbit clear from Current Winner\n            We receive an assert\
    \ from the current assert winner that is\n            better than our own metric\
    \ for this (S,G) (although the\n            metric may be worse than the winner's\
    \ previous metric).  We\n            stay in Loser state and perform Actions A2\
    \ below.\n      Receive Inferior Assert or Assert Cancel from Current Winner\n\
    \            We receive an assert from the current assert winner that is\n   \
    \         worse than our own metric for this group (typically, because\n     \
    \       the winner's metric became worse or because it is an assert\n        \
    \    cancel).  We transition to NoInfo state, deleting the (S,G)\n           \
    \ assert information and allowing the normal PIM Join/Prune\n            mechanisms\
    \ to operate.  Usually, we will eventually\n            re-assert and win when\
    \ data packets from S have started\n            flowing again.\n      Assert Timer\
    \ Expires\n            The (S,G) Assert Timer expires.  We transition to NoInfo\n\
    \            state, deleting the (S,G) assert information (Actions A5\n      \
    \      below).\n      Current Winner's GenID Changes or NLT Expires\n        \
    \    The Neighbor Liveness Timer associated with the current\n            winner\
    \ expires or we receive a Hello message from the\n            current winner reporting\
    \ a different GenID from the one it\n            previously reported.  This indicates\
    \ that the current\n            winner's interface or router has gone down (and\
    \ may have\n            come back up), and so we must assume that it no longer\
    \ knows\n            it was the winner.  We transition to the NoInfo state,\n\
    \            deleting this (S,G) assert information (Actions A5 below).\n    \
    \  AssertTrackingDesired(S,G,I)->FALSE\n            AssertTrackingDesired(S,G,I)\
    \ becomes FALSE.  Our forwarding\n            state has changed so that (S,G)\
    \ Asserts on interface I are\n            no longer of interest to us.  We transition\
    \ to the NoInfo\n            state, deleting the (S,G) assert information.\n \
    \     My metric becomes better than the assert winner's metric\n            my_assert_metric(S,G,I)\
    \ has changed so that now my assert\n            metric for (S,G) is better than\
    \ the metric we have stored\n            for the current assert winner.  This\
    \ might happen when the\n            underlying routing metric changes, or when\n\
    \            CouldAssert(S,G,I) becomes true, for example, when\n            SPTbit(S,G)\
    \ becomes true.  We transition to NoInfo state,\n            delete this (S,G)\
    \ assert state (Actions A5 below), and allow\n            the normal PIM Join/Prune\
    \ mechanisms to operate.  Usually,\n            we will eventually re-assert and\
    \ win when data packets from\n            S have started flowing again.\n    \
    \  RPF_interface(S) stops being interface I\n            Interface I used to be\
    \ the RPF interface for S, and now it\n            is not.  We transition to NoInfo\
    \ state, deleting this (S,G)\n            assert state (Actions A5 below).\n \
    \     Receive Join(S,G) on Interface I\n            We receive a Join(S,G) that\
    \ has the Upstream Neighbor\n            Address field set to my primary IP address\
    \ on interface I.\n            The action is to transition to NoInfo state, delete\
    \ this\n            (S,G) assert state (Actions A5 below), and allow the normal\n\
    \            PIM Join/Prune mechanisms to operate.  If whoever sent the\n    \
    \        Join was in error, then the normal assert mechanism will\n          \
    \  eventually re-apply, and we will lose the assert again.\n            However,\
    \ whoever sent the assert may know that the previous\n            assert winner\
    \ has died, and so we may end up being the new\n            forwarder.\n   (S,G)\
    \ Assert State Machine Actions\n      A1: Send Assert(S,G).\n          Set Assert\
    \ Timer to (Assert_Time - Assert_Override_Interval).\n          Store self as\
    \ AssertWinner(S,G,I).\n          Store spt_assert_metric(S,I) as AssertWinnerMetric(S,G,I).\n\
    \      A2: Store new assert winner as AssertWinner(S,G,I) and assert\n       \
    \   winner metric as AssertWinnerMetric(S,G,I).\n          Set Assert Timer to\
    \ Assert_Time.\n      A3: Send Assert(S,G).\n          Set Assert Timer to (Assert_Time\
    \ - Assert_Override_Interval).\n      A4: Send AssertCancel(S,G).\n          Delete\
    \ assert information (AssertWinner(S,G,I) and\n          AssertWinnerMetric(S,G,I)\
    \ will then return to their default\n          values).\n      A5: Delete assert\
    \ information (AssertWinner(S,G,I) and\n          AssertWinnerMetric(S,G,I) will\
    \ then return to their default\n          values).\n      A6: Store new assert\
    \ winner as AssertWinner(S,G,I) and assert\n          winner metric as AssertWinnerMetric(S,G,I).\n\
    \          Set Assert Timer to Assert_Time.\n          If (I is RPF_interface(S))\
    \ AND (UpstreamJPState(S,G) ==\n          Joined) set SPTbit(S,G) to TRUE.\n \
    \  Note that some of these actions may cause the value of\n   JoinDesired(S,G),\
    \ PruneDesired(S,G,rpt), or RPF'(S,G) to change,\n   which could cause further\
    \ transitions in other state machines.\n"
- title: 4.6.2.  (*,G) Assert Message State Machine
  contents:
  - "4.6.2.  (*,G) Assert Message State Machine\n   The (*,G) Assert state machine\
    \ for interface I is shown in Figure 9.\n   There are three states:\n      NoInfo\
    \ (NI)\n            This router has no (*,G) assert state on interface I.\n  \
    \    I am Assert Winner (W)\n            This router has won a (*,G) assert on\
    \ interface I.  It is\n            now responsible for forwarding traffic destined\
    \ for G onto\n            interface I with the exception of traffic for which\
    \ it has\n            (S,G) \"I am Assert Loser\" state.  Irrespective of whether\
    \ it\n            is the DR for I, it is also responsible for handling the\n \
    \           membership requests for G from local hosts on I.\n      I am Assert\
    \ Loser (L)\n            This router has lost a (*,G) assert on interface I. \
    \ It must\n            not forward packets for G onto interface I with the\n \
    \           exception of traffic from sources for which it has (S,G) \"I\n   \
    \         am Assert Winner\" state.  If it is the DR, it is no longer\n      \
    \      responsible for handling the membership requests for group G\n        \
    \    from local hosts on I.\n   In addition, there is also an Assert Timer (AT)\
    \ that is used to time\n   out asserts on the assert losers and to resend asserts\
    \ on the assert\n   winner.\n   When an Assert message is received with a source\
    \ address other than\n   zero, a PIM implementation must first match it against\
    \ the possible\n   events in the (S,G) assert state machine and process any transitions\n\
    \   and actions, before considering whether the Assert message matches\n   against\
    \ the (*,G) assert state machine.\n   It is important to note that NO TRANSITION\
    \ CAN OCCUR in the (*,G)\n   state machine as a result of receiving an Assert\
    \ message unless the\n   (S,G) assert state machine for the relevant S and G is\
    \ in the\n   \"NoInfo\" state after the (S,G) state machine has processed the\n\
    \   message.  Also, NO TRANSITION CAN OCCUR in the (*,G) state machine as\n  \
    \ a result of receiving an assert message if that message triggers any\n   change\
    \ of state in the (S,G) state machine.  Obviously, when the\n   source address\
    \ in the received message is set to zero, an (S,G) state\n   machine for the S\
    \ and G does not exist and can be assumed to be in\n   the \"NoInfo\" state.\n\
    \   For example, if both the (S,G) and (*,G) assert state machines are in\n  \
    \ the NoInfo state when an Assert message arrives, and the message\n   causes\
    \ the (S,G) state machine to transition to either \"W\" or \"L\"\n   state, then\
    \ the assert will not be processed by the (*,G) assert\n   state machine.\n  \
    \ Another example: if the (S,G) assert state machine is in \"L\" state\n   when\
    \ an assert message is received, and the assert metric in the\n   message is worse\
    \ than my_assert_metric(S,G,I), then the (S,G) assert\n   state machine will transition\
    \ to NoInfo state.  In such a case, if\n   the (*,G) assert state machine were\
    \ in NoInfo state, it might appear\n   that it would transition to \"W\" state,\
    \ but this is not the case\n   because this message already triggered a transition\
    \ in the (S,G)\n   assert state machine.\n           Figure 9: Per-Interface (*,G)\
    \ Assert State Machine\n"
- title: +----------------------------------------------------------------------+
  contents:
  - '+----------------------------------------------------------------------+

    '
- title: '|                         In NoInfo (NI) State                         |'
  contents:
  - '|                         In NoInfo (NI) State                         |

    '
- title: +-----------------------+-----------------------+----------------------+
  contents:
  - '+-----------------------+-----------------------+----------------------+

    '
- title: '| Receive Inferior      |  Data arrives for G   |  Receive Acceptable  |'
  contents:
  - '| Receive Inferior      |  Data arrives for G   |  Receive Acceptable  |

    '
- title: '| Assert with RPTbit    |  on I and             |  Assert with RPTbit  |'
  contents:
  - '| Assert with RPTbit    |  on I and             |  Assert with RPTbit  |

    '
- title: '| set and               |  CouldAssert          |  set and AssTrDes    |'
  contents:
  - '| set and               |  CouldAssert          |  set and AssTrDes    |

    '
- title: '| CouldAssert(*,G,I)    |  (*,G,I)              |  (*,G,I)             |'
  contents:
  - '| CouldAssert(*,G,I)    |  (*,G,I)              |  (*,G,I)             |

    '
- title: +-----------------------+-----------------------+----------------------+
  contents:
  - '+-----------------------+-----------------------+----------------------+

    '
- title: '| -> W state            |  -> W state           |  -> L state          |'
  contents:
  - '| -> W state            |  -> W state           |  -> L state          |

    '
- title: '| [Actions A1]          |  [Actions A1]         |  [Actions A2]        |'
  contents:
  - '| [Actions A1]          |  [Actions A1]         |  [Actions A2]        |

    '
- title: +-----------------------+-----------------------+----------------------+
  contents:
  - '+-----------------------+-----------------------+----------------------+

    '
- title: +---------------------------------------------------------------------+
  contents:
  - '+---------------------------------------------------------------------+

    '
- title: '|                    In I Am Assert Winner (W) State                  |'
  contents:
  - '|                    In I Am Assert Winner (W) State                  |

    '
- title: +----------------+-----------------+-----------------+----------------+
  contents:
  - '+----------------+-----------------+-----------------+----------------+

    '
- title: '| Assert Timer   |  Receive        |  Receive        |  CouldAssert   |'
  contents:
  - '| Assert Timer   |  Receive        |  Receive        |  CouldAssert   |

    '
- title: '| Expires        |  Inferior       |  Preferred      |  (*,G,I) ->    |'
  contents:
  - '| Expires        |  Inferior       |  Preferred      |  (*,G,I) ->    |

    '
- title: '|                |  Assert         |  Assert         |  FALSE         |'
  contents:
  - '|                |  Assert         |  Assert         |  FALSE         |

    '
- title: +----------------+-----------------+-----------------+----------------+
  contents:
  - '+----------------+-----------------+-----------------+----------------+

    '
- title: '| -> W state     |  -> W state     |  -> L state     |  -> NI state   |'
  contents:
  - '| -> W state     |  -> W state     |  -> L state     |  -> NI state   |

    '
- title: '| [Actions A3]   |  [Actions A3]   |  [Actions A2]   |  [Actions A4]  |'
  contents:
  - '| [Actions A3]   |  [Actions A3]   |  [Actions A2]   |  [Actions A4]  |

    '
- title: +----------------+-----------------+-----------------+----------------+
  contents:
  - '+----------------+-----------------+-----------------+----------------+

    '
- title: +---------------------------------------------------------------------+
  contents:
  - '+---------------------------------------------------------------------+

    '
- title: '|                    In I Am Assert Loser (L) State                   |'
  contents:
  - '|                    In I Am Assert Loser (L) State                   |

    '
- title: +-------------+-------------+-------------+-------------+-------------+
  contents:
  - '+-------------+-------------+-------------+-------------+-------------+

    '
- title: '|Receive      |Receive      |Receive      |Assert Timer |Current      |'
  contents:
  - '|Receive      |Receive      |Receive      |Assert Timer |Current      |

    '
- title: '|Preferred    |Acceptable   |Inferior     |Expires      |Winner''s     |'
  contents:
  - '|Preferred    |Acceptable   |Inferior     |Expires      |Winner''s     |

    '
- title: '|Assert with  |Assert from  |Assert or    |             |GenID        |'
  contents:
  - '|Assert with  |Assert from  |Assert or    |             |GenID        |

    '
- title: '|RPTbit set   |Current      |Assert       |             |Changes or   |'
  contents:
  - '|RPTbit set   |Current      |Assert       |             |Changes or   |

    '
- title: '|             |Winner with  |Cancel from  |             |NLT Expires  |'
  contents:
  - '|             |Winner with  |Cancel from  |             |NLT Expires  |

    '
- title: '|             |RPTbit set   |Current      |             |             |'
  contents:
  - '|             |RPTbit set   |Current      |             |             |

    '
- title: '|             |             |Winner       |             |             |'
  contents:
  - '|             |             |Winner       |             |             |

    '
- title: +-------------+-------------+-------------+-------------+-------------+
  contents:
  - '+-------------+-------------+-------------+-------------+-------------+

    '
- title: '|-> L state   |-> L state   |-> NI state  |-> NI state  |-> NI state  |'
  contents:
  - '|-> L state   |-> L state   |-> NI state  |-> NI state  |-> NI state  |

    '
- title: '|[Actions A2] |[Actions A2] |[Actions A5] |[Actions A5] |[Actions A5] |'
  contents:
  - '|[Actions A2] |[Actions A2] |[Actions A5] |[Actions A5] |[Actions A5] |

    '
- title: +-------------+-------------+-------------+-------------+-------------+
  contents:
  - '+-------------+-------------+-------------+-------------+-------------+

    '
- title: +----------------------------------------------------------------------+
  contents:
  - '+----------------------------------------------------------------------+

    '
- title: '|                    In I Am Assert Loser (L) State                    |'
  contents:
  - '|                    In I Am Assert Loser (L) State                    |

    '
- title: +----------------+----------------+-----------------+------------------+
  contents:
  - '+----------------+----------------+-----------------+------------------+

    '
- title: '| AssTrDes       | my_metric ->   |  RPF_interface  |  Receive         |'
  contents:
  - '| AssTrDes       | my_metric ->   |  RPF_interface  |  Receive         |

    '
- title: '| (*,G,I) ->     | better than    |  (RP(G)) stops  |  Join(*,G) on    |'
  contents:
  - '| (*,G,I) ->     | better than    |  (RP(G)) stops  |  Join(*,G) on    |

    '
- title: '| FALSE          | Winner''s       |  being I        |  Interface I     |'
  contents:
  - '| FALSE          | Winner''s       |  being I        |  Interface I     |

    '
- title: '|                | metric         |                 |                  |'
  contents:
  - '|                | metric         |                 |                  |

    '
- title: +----------------+----------------+-----------------+------------------+
  contents:
  - '+----------------+----------------+-----------------+------------------+

    '
- title: '| -> NI state    | -> NI state    |  -> NI state    |  -> NI State     |'
  contents:
  - '| -> NI state    | -> NI state    |  -> NI state    |  -> NI State     |

    '
- title: '| [Actions A5]   | [Actions A5]   |  [Actions A5]   |  [Actions A5]    |'
  contents:
  - '| [Actions A5]   | [Actions A5]   |  [Actions A5]   |  [Actions A5]    |

    '
- title: +----------------+----------------+-----------------+------------------+
  contents:
  - "+----------------+----------------+-----------------+------------------+\n  \
    \ The state machine uses the following macros:\n      CouldAssert(*,G,I) =\n \
    \         ( I in ( joins(*,G) (+) pim_include(*,G)) )\n          AND (RPF_interface(RP(G))\
    \ != I)\n   CouldAssert(*,G,I) is true on downstream interfaces for which we have\n\
    \   (*,G) join state, or local members that requested any traffic\n   destined\
    \ for G.\n      AssertTrackingDesired(*,G,I) =\n          CouldAssert(*,G,I)\n\
    \          OR (local_receiver_include(*,G,I)==TRUE\n              AND (I_am_DR(I)\
    \ OR AssertWinner(*,G,I) == me))\n          OR (RPF_interface(RP(G)) == I AND\
    \ RPTJoinDesired(G))\n   AssertTrackingDesired(*,G,I) is true on any interface\
    \ on which a\n   (*,G) assert might affect the router's behavior on that interface.\n\
    \   Note that for reasons of compactness, \"AssTrDes(*,G,I)\" is used in\n   the\
    \ state machine table to refer to AssertTrackingDesired(*,G,I).\n   Terminology:\n\
    \      A \"preferred assert\" is one with a better metric than the current\n \
    \     winner.\n      An \"acceptable assert\" is one that has a better metric\
    \ than\n      my_assert_metric(*,G,I).  An assert is never considered acceptable\n\
    \      if its metric is infinite.\n      An \"inferior assert\" is one with a\
    \ worse metric than\n      my_assert_metric(*,G,I).  An assert is never considered\
    \ inferior\n      if my_assert_metric(*,G,I) is infinite.\n   Transitions from\
    \ NoInfo State\n   When in NoInfo state, the following events trigger transitions,\
    \ but\n   only if the (S,G) assert state machine is in NoInfo state before and\n\
    \   after consideration of the received message:\n      Receive Inferior Assert\
    \ with RPTbit set AND\n         CouldAssert(*,G,I)==TRUE\n            An Inferior\
    \ (*,G) assert is received for G on Interface I.\n            If CouldAssert(*,G,I)\
    \ is TRUE, then I is our downstream\n            interface, and we have (*,G)\
    \ forwarding state on this\n            interface, so we should be the assert\
    \ winner.  We transition\n            to the \"I am Assert Winner\" state and\
    \ perform Actions A1\n            (below).\n      A data packet destined for G\
    \ arrives on interface I, AND\n         CouldAssert(*,G,I)==TRUE\n           \
    \ A data packet destined for G arrived on a downstream\n            interface\
    \ that is in our (*,G) outgoing interface list.  We\n            therefore believe\
    \ we should be the forwarder for this (*,G),\n            and so we transition\
    \ to the \"I am Assert Winner\" state and\n            perform Actions A1 (below).\n\
    \      Receive Acceptable Assert with RPT bit set AND\n         AssertTrackingDesired(*,G,I)==TRUE\n\
    \            We're interested in (*,G) Asserts, either because I is a\n      \
    \      downstream interface for which we have (*,G) forwarding\n            state,\
    \ or because I is the upstream interface for RP(G) and\n            we have (*,G)\
    \ forwarding state.  We get a (*,G) Assert that\n            has a better metric\
    \ than our own, so we do not win the\n            Assert.  We transition to \"\
    I am Assert Loser\" and perform\n            Actions A2 (below).\n   Transitions\
    \ from \"I am Assert Winner\" State\n   When in \"I am Assert Winner\" state,\
    \ the following events trigger\n   transitions, but only if the (S,G) assert state\
    \ machine is in NoInfo\n   state before and after consideration of the received\
    \ message:\n      Receive Inferior Assert\n            We receive a (*,G) assert\
    \ that has a worse metric than our\n            own.  Whoever sent the assert\
    \ has lost, and so we resend a\n            (*,G) Assert and restart the Assert\
    \ Timer (Actions A3\n            below).\n      Receive Preferred Assert\n   \
    \         We receive a (*,G) assert that has a better metric than our\n      \
    \      own.  We transition to \"I am Assert Loser\" state and perform\n      \
    \      Actions A2 (below).\n   When in \"I am Assert Winner\" state, the following\
    \ events trigger\n   transitions:\n      Assert Timer Expires\n            The\
    \ (*,G) Assert Timer expires.  As we're in the Winner\n            state, then\
    \ we must still have (*,G) forwarding state that\n            is actively being\
    \ kept alive.  To prevent unnecessary\n            thrashing of the forwarder\
    \ and periodic flooding of\n            duplicate packets, we resend the (*,G)\
    \ Assert and restart\n            the Assert Timer (Actions A3 below).\n     \
    \ CouldAssert(*,G,I) -> FALSE\n            Our (*,G) forwarding state or RPF interface\
    \ changed so as to\n            make CouldAssert(*,G,I) become false.  We can\
    \ no longer\n            perform the actions of the assert winner, and so we\n\
    \            transition to NoInfo state and perform Actions A4 (below).\n   Transitions\
    \ from \"I am Assert Loser\" State\n   When in \"I am Assert Loser\" state, the\
    \ following events trigger\n   transitions, but only if the (S,G) assert state\
    \ machine is in NoInfo\n   state before and after consideration of the received\
    \ message:\n      Receive Preferred Assert with RPTbit set\n            We receive\
    \ a (*,G) assert that is better than that of the\n            current assert winner.\
    \  We stay in Loser state and perform\n            Actions A2 below.\n      Receive\
    \ Acceptable Assert from Current Winner with RPTbit set\n            We receive\
    \ a (*,G) assert from the current assert winner\n            that is better than\
    \ our own metric for this group (although\n            the metric may be worse\
    \ than the winner's previous metric).\n            We stay in Loser state and\
    \ perform Actions A2 below.\n      Receive Inferior Assert or Assert Cancel from\
    \ Current Winner\n            We receive an assert from the current assert winner\
    \ that is\n            worse than our own metric for this group (typically because\n\
    \            the winner's metric became worse or is now an assert\n          \
    \  cancel).  We transition to NoInfo state, delete this (*,G)\n            assert\
    \ state (Actions A5), and allow the normal PIM\n            Join/Prune mechanisms\
    \ to operate.  Usually, we will\n            eventually re-assert and win when\
    \ data packets for G have\n            started flowing again.\n   When in \"I\
    \ am Assert Loser\" state, the following events trigger\n   transitions:\n   \
    \   Assert Timer Expires\n            The (*,G) Assert Timer expires.  We transition\
    \ to NoInfo\n            state and delete this (*,G) assert information (Actions\
    \ A5).\n      Current Winner's GenID Changes or NLT Expires\n            The Neighbor\
    \ Liveness Timer associated with the current\n            winner expires or we\
    \ receive a Hello message from the\n            current winner reporting a different\
    \ GenID from the one it\n            previously reported.  This indicates that\
    \ the current\n            winner's interface or router has gone down (and may\
    \ have\n            come back up), and so we must assume that it no longer knows\n\
    \            it was the winner.  We transition to the NoInfo state,\n        \
    \    deleting the (*,G) assert information (Actions A5).\n      AssertTrackingDesired(*,G,I)->FALSE\n\
    \            AssertTrackingDesired(*,G,I) becomes FALSE.  Our forwarding\n   \
    \         state has changed so that (*,G) Asserts on interface I are\n       \
    \     no longer of interest to us.  We transition to NoInfo state\n          \
    \  and delete this (*,G) assert information (Actions A5).\n      My metric becomes\
    \ better than the assert winner's metric\n            My routing metric, rpt_assert_metric(G,I),\
    \ has changed so\n            that now my assert metric for (*,G) is better than\
    \ the\n            metric we have stored for the current assert winner.  We\n\
    \            transition to NoInfo state, delete this (*,G) assert state\n    \
    \        (Actions A5), and allow the normal PIM Join/Prune mechanisms\n      \
    \      to operate.  Usually, we will eventually re-assert and win\n          \
    \  when data packets for G have started flowing again.\n      RPF_interface(RP(G))\
    \ stops being interface I\n            Interface I used to be the RPF interface\
    \ for RP(G), and now\n            it is not.  We transition to NoInfo state and\
    \ delete this\n            (*,G) assert state (Actions A5).\n      Receive Join(*,G)\
    \ on interface I\n            We receive a Join(*,G) that has the Upstream Neighbor\n\
    \            Address field set to my primary IP address on interface I.\n    \
    \        The action is to transition to NoInfo state, delete this\n          \
    \  (*,G) assert state (Actions A5), and allow the normal PIM\n            Join/Prune\
    \ mechanisms to operate.  If whoever sent the Join\n            was in error,\
    \ then the normal assert mechanism will\n            eventually re-apply, and\
    \ we will lose the assert again.\n            However, whoever sent the assert\
    \ may know that the previous\n            assert winner has died, so we may end\
    \ up being the new\n            forwarder.\n   (*,G) Assert State Machine Actions\n\
    \      A1: Send Assert(*,G).\n          Set Assert Timer to (Assert_Time - Assert_Override_Interval).\n\
    \          Store self as AssertWinner(*,G,I).\n          Store rpt_assert_metric(G,I)\
    \ as AssertWinnerMetric(*,G,I).\n      A2: Store new assert winner as AssertWinner(*,G,I)\
    \ and assert\n          winner metric as AssertWinnerMetric(*,G,I).\n        \
    \  Set Assert Timer to Assert_Time.\n      A3: Send Assert(*,G).\n          Set\
    \ Assert Timer to (Assert_Time - Assert_Override_Interval).\n      A4: Send AssertCancel(*,G).\n\
    \          Delete assert information (AssertWinner(*,G,I) and\n          AssertWinnerMetric(*,G,I)\
    \ will then return to their default\n          values).\n      A5: Delete assert\
    \ information (AssertWinner(*,G,I) and\n          AssertWinnerMetric(*,G,I) will\
    \ then return to their default\n          values).\n   Note that some of these\
    \ actions may cause the value of\n   JoinDesired(*,G) or RPF'(*,G) to change,\
    \ which could cause further\n   transitions in other state machines.\n"
- title: 4.6.3.  Assert Metrics
  contents:
  - "4.6.3.  Assert Metrics\n   Assert metrics are defined as:\n     struct assert_metric\
    \ {\n       rpt_bit_flag;\n       metric_preference;\n       route_metric;\n \
    \      ip_address;\n     };\n   When comparing assert_metrics, the rpt_bit_flag,\
    \ metric_preference,\n   and route_metric fields are compared in order, where\
    \ the first lower\n   value wins.  If all fields are equal, the primary IP address\
    \ of the\n   router that sourced the Assert message is used as a tie-breaker,\
    \ with\n   the highest IP address winning.\n   An assert metric for (S,G) to include\
    \ in (or compare against) an\n   Assert message sent on interface I should be\
    \ computed using the\n   following pseudocode:\n     assert_metric\n     my_assert_metric(S,G,I)\
    \ {\n         if( CouldAssert(S,G,I) == TRUE ) {\n             return spt_assert_metric(S,I)\n\
    \         } else if( CouldAssert(*,G,I) == TRUE ) {\n             return rpt_assert_metric(G,I)\n\
    \         } else {\n             return infinite_assert_metric()\n         }\n\
    \     }\n   spt_assert_metric(S,I) gives the assert metric we use if we're\n \
    \  sending an assert based on active (S,G) forwarding state:\n     assert_metric\n\
    \     spt_assert_metric(S,I) {\n        return {0,MRIB.pref(S),MRIB.metric(S),my_ip_address(I)}\n\
    \     }\n   rpt_assert_metric(G,I) gives the assert metric we use if we're\n \
    \  sending an assert based only on (*,G) forwarding state:\n     assert_metric\n\
    \     rpt_assert_metric(G,I) {\n         return {1,MRIB.pref(RP(G)),MRIB.metric(RP(G)),my_ip_address(I)}\n\
    \     }\n   MRIB.pref(X) and MRIB.metric(X) are the routing preference and\n \
    \  routing metrics associated with the route to a particular (unicast)\n   destination\
    \ X, as determined by the MRIB.  my_ip_address(I) is simply\n   the router's primary\
    \ IP address that is associated with the local\n   interface I.\n   infinite_assert_metric()\
    \ is an assert metric that the router uses for\n   an Assert that does not match\
    \ either (S,G) or (*,G) forwarding state:\n     assert_metric\n     infinite_assert_metric()\
    \ {\n          return {1,infinity,infinity,0}\n     }\n"
- title: 4.6.4.  AssertCancel Messages
  contents:
  - "4.6.4.  AssertCancel Messages\n   An AssertCancel message is simply an RPT Assert\
    \ message but with an\n   infinite metric.  It is sent by the assert winner when\
    \ it deletes the\n   forwarding state that had caused the assert to occur.  Other\
    \ routers\n   will see this metric, and it will cause any other router that has\n\
    \   forwarding state to send its own assert, and to take over forwarding.\n  \
    \ An AssertCancel(S,G) is an infinite metric assert with the RPT bit\n   set that\
    \ names S as the source.\n   An AssertCancel(*,G) is an infinite metric assert\
    \ with the RPT bit\n   set and the source set to zero.\n   AssertCancel messages\
    \ are simply an optimization.  The original\n   Assert timeout mechanism will\
    \ allow a subnet to eventually become\n   consistent; the AssertCancel mechanism\
    \ simply causes faster\n   convergence.  No special processing is required for\
    \ an AssertCancel\n   message, since it is simply an Assert message from the current\n\
    \   winner.\n"
- title: 4.6.5.  Assert State Macros
  contents:
  - "4.6.5.  Assert State Macros\n   The macros lost_assert(S,G,rpt,I), lost_assert(S,G,I),\
    \ and\n   lost_assert(*,G,I) are used in the olist computations of Section 4.1\n\
    \   and are defined as:\n     bool lost_assert(S,G,rpt,I) {\n       if ( RPF_interface(RP(G))\
    \ == I  OR\n            ( RPF_interface(S) == I AND SPTbit(S,G) == TRUE ) ) {\n\
    \          return FALSE\n       } else {\n          return ( AssertWinner(S,G,I)\
    \ != NULL AND\n                   AssertWinner(S,G,I) != me )\n       }\n    \
    \ }\n     bool lost_assert(S,G,I) {\n       if ( RPF_interface(S) == I ) {\n \
    \         return FALSE\n       } else {\n          return ( AssertWinner(S,G,I)\
    \ != NULL AND\n                   AssertWinner(S,G,I) != me  AND\n           \
    \        (AssertWinnerMetric(S,G,I) is better\n                      than spt_assert_metric(S,I)\
    \ )\n       }\n     }\n   Note: The term \"AssertWinnerMetric(S,G,I) is better\
    \ than\n   spt_assert_metric(S,I)\" is required to correctly handle the\n   transition\
    \ phase when a router has (S,G) join state but has not yet\n   set the SPTbit.\
    \  In this case, it needs to ignore the assert state if\n   it will win the assert\
    \ once the SPTbit is set.\n     bool lost_assert(*,G,I) {\n       if ( RPF_interface(RP(G))\
    \ == I ) {\n          return FALSE\n       } else {\n          return ( AssertWinner(*,G,I)\
    \ != NULL AND\n                   AssertWinner(*,G,I) != me )\n       }\n    \
    \ }\n   AssertWinner(S,G,I) is the IP source address of the Assert(S,G)\n   packet\
    \ that won an Assert.\n   AssertWinner(*,G,I) is the IP source address of the\
    \ Assert(*,G)\n   packet that won an Assert.\n   AssertWinnerMetric(S,G,I) is\
    \ the Assert metric of the Assert(S,G)\n   packet that won an Assert.\n   AssertWinnerMetric(*,G,I)\
    \ is the Assert metric of the Assert(*,G)\n   packet that won an Assert.\n   AssertWinner(S,G,I)\
    \ defaults to NULL and AssertWinnerMetric(S,G,I)\n   defaults to Infinity when\
    \ in the NoInfo state.\n   Summary of Assert Rules and Rationale\n   This section\
    \ summarizes the key rules for sending and reacting to\n   asserts and the rationale\
    \ for these rules.  This section is not\n   intended to be and should not be treated\
    \ as a definitive\n   specification of protocol behavior.  The state machines\
    \ and\n   pseudocode should be consulted for that purpose.  Rather, this\n   section\
    \ is intended to document important aspects of the Assert\n   protocol behavior\
    \ and to provide information that may prove helpful\n   to the reader in understanding\
    \ and implementing this part of the\n   protocol.\n   1.  Behavior: Downstream\
    \ neighbors send Join(*,G) and Join(S,G)\n       periodic messages to the appropriate\
    \ RPF' neighbor, i.e., the RPF\n       neighbor as modified by the assert process.\
    \  They are not always\n       sent to the RPF neighbor as indicated by the MRIB.\
    \  Normal\n       suppression and override rules apply.\n       Rationale: By\
    \ sending the periodic and triggered Join messages to\n       the RPF' neighbor\
    \ instead of the RPF neighbor, the downstream\n       router avoids re-triggering\
    \ the Assert process with every Join.\n       A side effect of sending Joins to\
    \ the Assert winner is that\n       traffic will not switch back to the \"normal\"\
    \ RPF neighbor until\n       the Assert times out.  This will not happen until\
    \ data stops\n       flowing, if item 8, below, is implemented.\n   2.  Behavior:\
    \ The assert winner for (*,G) acts as the local DR for\n       (*,G) on behalf\
    \ of IGMP/MLD members.\n       Rationale: This is required to allow a single router\
    \ to merge\n       PIM and IGMP/MLD joins and leaves.  Without this, overrides\n\
    \       don't work.\n   3.  Behavior: The assert winner for (S,G) acts as the\
    \ local DR for\n       (S,G) on behalf of IGMPv3 members.\n       Rationale: Same\
    \ rationale as for item 2.\n   4.  Behavior: (S,G) and (*,G) prune overrides are\
    \ sent to the RPF'\n       neighbor and not to the regular RPF neighbor.\n   \
    \    Rationale: Same rationale as for item 1.\n   5.  Behavior: An (S,G,rpt) prune\
    \ override is not sent (at all) if\n       RPF'(S,G,rpt) != RPF'(*,G).\n     \
    \  Rationale: This avoids keeping state alive on the (S,G) tree when\n       only\
    \ (*,G) downstream members are left.  Also, it avoids sending\n       (S,G,rpt)\
    \ joins to a router that is not on the (*,G) tree.  This\n       behavior might\
    \ be confusing, although this specification does\n       indicate that such a\
    \ join SHOULD be dropped.\n   6.  Behavior: An assert loser that receives a Join(S,G)\
    \ with an\n       Upstream Neighbor Address that is its primary IP address on\
    \ that\n       interface expires the (S,G) Assert Timer.\n       Rationale: This\
    \ is necessary in order to have rapid convergence\n       in the event that the\
    \ downstream router that initially sent a\n       join to the prior Assert winner\
    \ has undergone a topology change.\n   7.  Behavior: An assert loser that receives\
    \ a Join(*,G) with an\n       Upstream Neighbor Address that is its primary IP\
    \ address on that\n       interface expires the (*,G) Assert Timer and all (S,G)\
    \ assert\n       timers that do not have corresponding Prune(S,G,rpt) messages\
    \ in\n       the compound Join/Prune message.\n       Rationale: Same rationale\
    \ as for item 6.\n   8.  Behavior: An assert winner for (*,G) or (S,G) sends a\
    \ canceling\n       assert when it is about to stop forwarding on a (*,G) or an\
    \ (S,G)\n       entry.  This behavior does not apply to (S,G,rpt).\n       Rationale:\
    \ This allows switching back to the shared tree after\n       the last SPT router\
    \ on the LAN leaves.  Doing this prevents\n       downstream routers on the shared\
    \ tree from keeping SPT state\n       alive.\n   9.  Behavior: Resend the assert\
    \ messages before timing out an assert.\n       (This behavior is optional.)\n\
    \       Rationale: This prevents the periodic duplicates that would\n       otherwise\
    \ occur each time that an assert times out and is then\n       re-established.\n\
    \   10. Behavior: When RPF'(S,G,rpt) changes to be the same as RPF'(*,G),\n  \
    \     we need to trigger a Join(S,G,rpt) to RPF'(*,G).\n       Rationale: This\
    \ allows switching back to the RPT after the last\n       SPT member leaves.\n"
- title: 4.7.  PIM Bootstrap and RP Discovery
  contents:
  - "4.7.  PIM Bootstrap and RP Discovery\n   For correct operation, every PIM router\
    \ within a PIM domain must be\n   able to map a particular multicast group address\
    \ to the same RP.  If\n   this is not the case, then black holes may appear, where\
    \ some\n   receivers in the domain cannot receive some groups.  A domain in this\n\
    \   context is a contiguous set of routers that all implement PIM and are\n  \
    \ configured to operate within a common boundary.\n   A notable exception to this\
    \ is where a PIM domain is broken up into\n   multiple administrative scope regions;\
    \ these are regions where a\n   border has been configured so that a range of\
    \ multicast groups will\n   not be forwarded across that border.  For more information\
    \ on\n   Administratively Scoped IP Multicast, see RFC 2365.  The modified\n \
    \  criteria for admin-scoped regions are that the region is convex with\n   respect\
    \ to forwarding based on the MRIB, and that all PIM routers\n   within the scope\
    \ region map scoped groups to the same RP within that\n   region.\n   This specification\
    \ does not mandate the use of a single mechanism to\n   provide routers with the\
    \ information to perform the group-to-RP\n   mapping.  Currently, four mechanisms\
    \ are possible, and all four have\n   associated problems:\n   Static Configuration\n\
    \         A PIM router MUST support the static configuration of group-to-\n  \
    \       RP mappings.  Such a mechanism is not robust to failures but\n       \
    \  does at least provide a basic interoperability mechanism.\n   Embedded-RP\n\
    \         Embedded-RP defines an address allocation policy in which the\n    \
    \     address of the Rendezvous Point (RP) is encoded in an IPv6\n         multicast\
    \ group address [16].\n   Cisco's Auto-RP\n         Auto-RP uses a PIM Dense-Mode\
    \ (PIM-DM) multicast group to\n         announce group-to-RP mappings from a central\
    \ location.  This\n         mechanism is not useful if PIM Dense Mode is not being\
    \ run in\n         parallel with PIM Sparse Mode; it was only intended for use\n\
    \         with PIM Sparse Mode Version 1.  No standard specification\n       \
    \  currently exists.\n   Bootstrap Router (BSR)\n         RFC 2362 specifies a\
    \ bootstrap mechanism based on the automatic\n         election of a BSR.  Any\
    \ router in the domain that is configured\n         to be a possible RP reports\
    \ its candidacy to the BSR, and then\n         a domain-wide flooding mechanism\
    \ distributes the BSR's chosen\n         set of RPs throughout the domain.  As\
    \ specified in RFC 2362,\n         the BSR mechanism is flawed in its handling\
    \ of admin-scoped\n         regions that are smaller than a PIM domain, but the\
    \ mechanism\n         does work for global-scoped groups.\n   As far as PIM-SM\
    \ is concerned, the only important requirement is that\n   all routers in the\
    \ domain (or admin scope zone for scoped regions)\n   receive the same set of\
    \ group-range-to-RP mappings.  This may be\n   achieved through the use of any\
    \ of these mechanisms, or through\n   alternative mechanisms not currently specified.\n\
    \   It must be operationally ensured that any RP address configured,\n   learned,\
    \ or advertised is reachable from all routers in the PIM\n   domain.\n"
- title: 4.7.1.  Group-to-RP Mapping
  contents:
  - "4.7.1.  Group-to-RP Mapping\n   Using one of the mechanisms described above,\
    \ a PIM router receives\n   one or more possible group-range-to-RP mappings. \
    \ Each mapping\n   specifies a range of multicast groups (expressed as a group\
    \ and mask)\n   and the RP to which such groups should be mapped.  Each mapping\
    \ may\n   also have an associated priority.  It is possible to receive multiple\n\
    \   mappings, all of which might match the same multicast group; this is\n   the\
    \ common case with the BSR mechanism.  The algorithm for performing\n   the group-to-RP\
    \ mapping is as follows:\n   1.  Perform longest match on group range to obtain\
    \ a list of RPs.\n   2.  From this list of matching RPs, find the ones with highest\n\
    \       priority.\n       Eliminate any RPs from the list that have lower priorities.\n\
    \   3.  If only one RP remains in the list, use that RP.\n   4.  If multiple RPs\
    \ are in the list, use the PIM hash function to\n       choose one.\n   Thus,\
    \ if two or more group-range-to-RP mappings cover a particular\n   group, the\
    \ one with the longest mask is the mapping to use.  If the\n   mappings have the\
    \ same mask length, then the one with the highest\n   priority is chosen.  If\
    \ there is more than one matching entry with\n   the same longest mask and the\
    \ priorities are identical, then a hash\n   function (see Section 4.7.2) is applied\
    \ to choose the RP.\n   This algorithm is invoked by a DR when it needs to determine\
    \ an RP\n   for a given group, e.g., upon reception of a packet or IGMP/MLD\n\
    \   membership indication for a group for which the DR does not know\n   the RP.\n\
    \   Furthermore, the mapping function is invoked by all routers upon\n   receiving\
    \ a (*,G) Join/Prune message.\n   Note that if the set of possible group-range-to-RP\
    \ mappings changes,\n   each router will need to check whether any existing groups\
    \ are\n   affected.  This may, for example, cause a DR or acting DR to re-join\n\
    \   a group, or cause it to restart register encapsulation to the new RP.\n  \
    \    Implementation note: The bootstrap mechanism described in RFC 2362\n    \
    \  omitted step 1 above.  However, of the implementations we are\n      aware\
    \ of, approximately half performed step 1 anyway.  Note that\n      implementations\
    \ of BSR that omit step 1 will not correctly\n      interoperate with implementations\
    \ of this specification when used\n      with the BSR mechanism described in [11].\n"
- title: 4.7.2.  Hash Function
  contents:
  - "4.7.2.  Hash Function\n   The hash function is used by all routers within a domain,\
    \ to map a\n   group to one of the RPs from the matching set of group-range-to-RP\n\
    \   mappings (this set of mappings all have the same longest mask length\n   and\
    \ same highest priority).  The algorithm takes as input the group\n   address,\
    \ and the addresses of the candidate RPs from the mappings,\n   and gives as output\
    \ one RP address to be used.\n   The protocol requires that all routers hash to\
    \ the same RP within a\n   domain (except for transients).  The following hash\
    \ function must be\n   used in each router:\n   1.  For RP addresses in the matching\
    \ group-range-to-RP mappings,\n       compute a value:\n   Value(G,M,C(i))=\n\
    \   (1103515245 * ((1103515245 * (G&M)+12345) XOR C(i)) + 12345) mod 2^31\n  \
    \     where C(i) is the RP address and M is a hash-mask.  If BSR is\n       being\
    \ used, the hash-mask is given in the Bootstrap messages.  If\n       BSR is not\
    \ being used, the alternative mechanism that supplies\n       the group-range-to-RP\
    \ mappings may supply the value, or else it\n       defaults to a mask with the\
    \ most significant 30 bits being one\n       for IPv4 and the most significant\
    \ 126 bits being one for IPv6.\n       The hash-mask allows a small number of\
    \ consecutive groups\n       (e.g., 4) to always hash to the same RP.  For instance,\n\
    \       hierarchically encoded data can be sent on consecutive group\n       addresses\
    \ to get the same delay and fate-sharing characteristics.\n       For address\
    \ families other than IPv4, a 32-bit digest to be used\n       as C(i) and G must\
    \ first be derived from the actual RP or group\n       address.  Such a digest\
    \ method must be used consistently\n       throughout the PIM domain.  For IPv6\
    \ addresses, it is RECOMMENDED\n       to use the equivalent IPv4 address for\
    \ an IPv4-compatible\n       address, and the exclusive-or of each 32-bit segment\
    \ of the\n       address for all other IPv6 addresses.  For example, the digest\
    \ of\n       the IPv6 address 3ffe:b00:c18:1::10 would be computed as\n      \
    \ 0x3ffe0b00 ^ 0x0c180001 ^ 0x00000000 ^ 0x00000010,\n       where the '^' symbol\
    \ represents the exclusive-or operation.\n   2.  The candidate RP with the highest\
    \ resulting hash value is then\n       the RP chosen by this hash function.  If\
    \ more than one RP has the\n       same highest hash value, the RP with the highest\
    \ IP address is\n       chosen.\n"
- title: 4.8.  Source-Specific Multicast
  contents:
  - "4.8.  Source-Specific Multicast\n   The Source-Specific Multicast (SSM) service\
    \ model [6] can be\n   implemented with a strict subset of the PIM-SM protocol\
    \ mechanisms.\n   Both regular IP Multicast and SSM semantics can coexist on a\
    \ single\n   router, and both can be implemented using the PIM-SM protocol.  A\n\
    \   range of multicast addresses, currently 232.0.0.0/8 in IPv4 and\n   ff3x::/32\
    \ for IPv6, is reserved for SSM, and the choice of semantics\n   is determined\
    \ by the multicast group address in both data packets and\n   PIM messages.\n"
- title: 4.8.1.  Protocol Modifications for SSM Destination Addresses
  contents:
  - "4.8.1.  Protocol Modifications for SSM Destination Addresses\n   The following\
    \ rules override the normal PIM-SM behavior for a\n   multicast address G in the\
    \ SSM range:\n   o  A router MUST NOT send a (*,G) Join/Prune message for any\
    \ reason.\n   o  A router MUST NOT send an (S,G,rpt) Join/Prune message for any\n\
    \      reason.\n   o  A router MUST NOT send a Register message for any packet\
    \ that is\n      destined to an SSM address.\n   o  A router MUST NOT forward\
    \ packets based on (*,G) or (S,G,rpt)\n      state.  The (*,G)- and (S,G,rpt)-related\
    \ state summarization\n      macros are NULL for any SSM address, for the purposes\
    \ of packet\n      forwarding.\n   o  A router acting as an RP MUST NOT forward\
    \ any Register-\n      encapsulated packet that has an SSM destination address\
    \ and SHOULD\n      respond with a Register-Stop message to such a Register message.\n\
    \   o  A router MAY optimize out the creation and maintenance of\n      (S,G,rpt)\
    \ and (*,G) state for SSM destination addresses -- this\n      state is not needed\
    \ for SSM packets.\n   The last three rules are present to deal with SSM-unaware\
    \ \"legacy\"\n   routers that may be sending (*,G) and (S,G,rpt) Join/Prunes,\
    \ or\n   Register messages for SSM destination addresses.  Note that this\n  \
    \ specification does not attempt to aid an SSM-unaware \"legacy\" router\n   with\
    \ SSM operations.\n"
- title: 4.8.2.  PIM-SSM-Only Routers
  contents:
  - "4.8.2.  PIM-SSM-Only Routers\n   An implementer may choose to implement only\
    \ the subset of PIM\n   Sparse Mode that provides SSM forwarding semantics.\n\
    \   A PIM-SSM-only router MUST implement the following portions of this\n   specification:\n\
    \   o  Upstream (S,G) state machine (Section 4.5.5)\n   o  Downstream (S,G) state\
    \ machine (Section 4.5.2)\n   o  (S,G) Assert state machine (Section 4.6.1)\n\
    \   o  Hello messages, neighbor discovery, and DR election (Section 4.3)\n   o\
    \  Packet forwarding rules (Section 4.2)\n   A PIM-SSM-only router does not need\
    \ to implement the following\n   protocol elements:\n   o  Register state machine\
    \ (Section 4.4)\n   o  (*,G) and (S,G,rpt) downstream state machines (Sections\
    \ 4.5.1 and\n      4.5.3)\n   o  (*,G) and (S,G,rpt) upstream state machines (Sections\
    \ 4.5.4,\n      4.5.6, and 4.5.7)\n   o  (*,G) Assert state machine (Section 4.6.2)\n\
    \   o  Bootstrap RP election (Section 4.7)\n   o  Keepalive Timer\n   o  SPTbit\
    \ (Section 4.2.2)\n   The Keepalive Timer should be treated as always running,\
    \ and the\n   SPTbit should be treated as always being set for an SSM address.\n\
    \   Additionally, the packet forwarding rules of Section 4.2 can be\n   simplified\
    \ in a PIM-SSM-only router:\n     oiflist = NULL\n     if( iif == RPF_interface(S)\
    \ AND UpstreamJPState(S,G) == Joined ) {\n         oiflist = inherited_olist(S,G)\n\
    \     } else if( iif is in inherited_olist(S,G) ) {\n         send Assert(S,G)\
    \ on iif\n     }\n     oiflist = oiflist (-) iif\n     forward packet on all interfaces\
    \ in oiflist\n   This is nothing more than the reduction of the normal PIM-SM\n\
    \   forwarding rule, with all (S,G,rpt) and (*,G) clauses replaced\n   with NULL.\n"
- title: 4.9.  PIM Packet Formats
  contents:
  - "4.9.  PIM Packet Formats\n   This section describes the details of the packet\
    \ formats for PIM\n   control messages.\n   All PIM control messages have IP protocol\
    \ number 103.\n   PIM messages are either unicast (e.g., Registers and Register-Stop)\n\
    \   or multicast with TTL 1 to the 'ALL-PIM-ROUTERS' group (e.g.,\n   Join/Prune,\
    \ Asserts).  The source address used for unicast messages\n   is a domain-wide\
    \ reachable address; the source address used for\n   multicast messages is the\
    \ link-local address of the interface on\n   which the message is being sent.\n\
    \   The IPv4 'ALL-PIM-ROUTERS' group is '224.0.0.13'.  The IPv6\n   'ALL-PIM-ROUTERS'\
    \ group is 'ff02::d'.\n   The PIM header common to all PIM messages is:\n    0\
    \                   1                   2                   3\n    0 1 2 3 4 5\
    \ 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |PIM Ver| Type  |   Reserved    |           Checksum            |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   PIM Ver\n         PIM Version number is 2.\n   Type\n         Types for specific\
    \ PIM messages.  PIM Types are:\n   Message Type                          Destination\n\
    \   ---------------------------------------------------------------------\n  \
    \ 0 = Hello                             Multicast to ALL-PIM-ROUTERS\n   1 = Register\
    \                          Unicast to RP\n   2 = Register-Stop               \
    \      Unicast to source of Register\n                                       \
    \     packet\n   3 = Join/Prune                        Multicast to ALL-PIM-ROUTERS\n\
    \   4 = Bootstrap                         Multicast to ALL-PIM-ROUTERS\n   5 =\
    \ Assert                            Multicast to ALL-PIM-ROUTERS\n   6 = Graft\
    \ (used in PIM-DM only)       Unicast to RPF'(S)\n   7 = Graft-Ack (used in PIM-DM\
    \ only)   Unicast to source of Graft\n                                       \
    \     packet\n   8 = Candidate-RP-Advertisement        Unicast to Domain's BSR\n\
    \   Reserved\n         Set to zero on transmission.  Ignored upon receipt.\n \
    \  Checksum\n         The checksum is a standard IP checksum, i.e., the 16-bit\
    \ one's\n         complement of the one's complement sum of the entire PIM\n \
    \        message, excluding the \"Multicast data packet\" section of the\n   \
    \      Register message.  For computing the checksum, the checksum\n         field\
    \ is zeroed.  If the packet's length is not an integral\n         number of 16-bit\
    \ words, the packet is padded with a trailing\n         byte of zero before performing\
    \ the checksum.\n         For IPv6, the checksum also includes the IPv6 \"pseudo-header\"\
    ,\n         as specified in RFC 2460, Section 8.1 [5].  This\n         \"pseudo-header\"\
    \ is prepended to the PIM header for the purposes\n         of calculating the\
    \ checksum.  The \"Upper-Layer Packet Length\"\n         in the pseudo-header\
    \ is set to the length of the PIM message,\n         except in Register messages\
    \ where it is set to the length of\n         the PIM register header (8).  The\
    \ Next Header value used in the\n         pseudo-header is 103.\n   If a message\
    \ is received with an unrecognized PIM Ver or Type field,\n   or if a message's\
    \ destination does not correspond to the table above,\n   the message MUST be\
    \ discarded, and an error message SHOULD be logged\n   to the administrator in\
    \ a rate-limited manner.\n"
- title: 4.9.1.  Encoded Source and Group Address Formats
  contents:
  - "4.9.1.  Encoded Source and Group Address Formats\n   Encoded Unicast Address\n\
    \   An encoded unicast address takes the following format:\n    0            \
    \       1                   2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1\
    \ 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |  Addr Family  | Encoding Type |     Unicast Address\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+...\n\
    \   Addr Family\n         The PIM address family of the 'Unicast Address' field\
    \ of this\n         address.\n         Values 0-127 are as assigned by the IANA\
    \ for Internet Address\n         Families in [7].  Values 128-250 are reserved\
    \ to be assigned by\n         the IANA for PIM-specific Address Families.  Values\
    \ 251 through\n         255 are designated for Private Use.  As there is no assignment\n\
    \         authority for this space, collisions should be expected.\n   Encoding\
    \ Type\n         The type of encoding used within a specific Address Family.\n\
    \         The value '0' is reserved for this field and represents the\n      \
    \   native encoding of the Address Family.\n   Unicast Address\n         The unicast\
    \ address as represented by the given Address Family\n         and Encoding Type.\n\
    \   Encoded Group Address\n   Encoded group addresses take the following format:\n\
    \    0                   1                   2                   3\n    0 1 2\
    \ 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |  Addr Family  | Encoding Type |B| Reserved  |Z|  Mask Len     |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                Group multicast Address\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+...\n\
    \   Addr Family\n         Described above.\n   Encoding Type\n         Described\
    \ above.\n   [B]idirectional PIM\n         Indicates that the group range uses\
    \ Bidirectional PIM [13].\n         For PIM-SM as defined in this specification,\
    \ this bit MUST be\n         zero.\n   Reserved\n         Transmitted as zero.\
    \  Ignored upon receipt.\n   Admin Scope [Z]one\n         Indicates that the group\
    \ range is an admin scope zone.  This is\n         used in the Bootstrap Router\
    \ mechanism [11] only.  For all\n         other purposes, this bit is set to zero\
    \ and ignored on receipt.\n   Mask Len\n         The Mask length field is 8 bits.\
    \  The value is the number of\n         contiguous one bits that are left-justified\
    \ and used as a mask;\n         when combined with the group address, it describes\
    \ a range of\n         groups.  It is less than or equal to the address length\
    \ in bits\n         for the given Address Family and Encoding Type.  If the message\n\
    \         is sent for a single group, then the Mask length must equal the\n  \
    \       address length in bits for the given Address Family and\n         Encoding\
    \ Type (e.g., 32 for IPv4 native encoding, 128 for IPv6\n         native encoding).\n\
    \   Group multicast Address\n         Contains the group address.\n   Encoded\
    \ Source Address\n   An encoded source address takes the following format:\n \
    \   0                   1                   2                   3\n    0 1 2 3\
    \ 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   | Addr Family   | Encoding Type | Rsrvd   |S|W|R|  Mask Len     |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                        Source Address\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-...\n\
    \   Addr Family\n         Described above.\n   Encoding Type\n         Described\
    \ above.\n   Reserved\n         Transmitted as zero, ignored on receipt.\n   S\
    \     The Sparse bit is a 1-bit value, set to 1 for PIM-SM.  It is\n         used\
    \ for PIM Version 1 compatibility.\n   W     The WC (or WildCard) bit is a 1-bit\
    \ value for use with PIM\n         Join/Prune messages (see Section 4.9.5.1).\n\
    \   R     The RPT (or Rendezvous Point Tree) bit is a 1-bit value for use\n  \
    \       with PIM Join/Prune messages (see Section 4.9.5.1).  If the\n        \
    \ WC bit is 1, the RPT bit MUST be 1.\n   Mask Len\n         The mask length field\
    \ is 8 bits.  The value is the number of\n         contiguous one bits that are\
    \ left-justified and used as a mask;\n         when combined with the source address,\
    \ it describes a source\n         subnet.  The mask length MUST be equal to the\
    \ mask length in\n         bits for the given Address Family and Encoding Type\
    \ (32 for\n         IPv4 native and 128 for IPv6 native).  A router SHOULD ignore\n\
    \         any messages received with any other mask length.\n   Source Address\n\
    \         The source address.\n"
- title: 4.9.2.  Hello Message Format
  contents:
  - "4.9.2.  Hello Message Format\n   A Hello message is sent periodically by routers\
    \ on all interfaces.\n    0                   1                   2          \
    \         3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0\
    \ 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n  \
    \ |PIM Ver| Type  |   Reserved    |           Checksum            |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |          OptionType           |         OptionLength          |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                          OptionValue                          |\n   |  \
    \                            ...                              |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                               .                               |\n   |  \
    \                             .                               |\n   |        \
    \                       .                               |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |          OptionType           |         OptionLength          |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                          OptionValue                          |\n   |  \
    \                            ...                              |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   PIM Version, Type, Reserved, Checksum\n         Described in Section 4.9.\n\
    \   OptionType\n         The type of the option given in the following OptionValue\n\
    \         field.\n   OptionLength\n         The length of the OptionValue field\
    \ in bytes.\n   OptionValue\n         A variable-length field, carrying the value\
    \ of the option.\n   The Option fields may contain the following values:\n   o\
    \  OptionType 1: Holdtime\n       0                   1                   2  \
    \                 3\n       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4\
    \ 5 6 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |          Type = 1             |         Length = 2            |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |\
    \          Holdtime             |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n \
    \     Holdtime is the amount of time a receiver must keep the neighbor\n     \
    \ reachable, in seconds.  If the Holdtime is set to '0xffff', the\n      receiver\
    \ of this message never times out the neighbor.  This may\n      be used with\
    \ dial-on-demand links, to avoid keeping the link up\n      with periodic Hello\
    \ messages.\n      An implementation MAY provide a configuration mechanism to\
    \ reject\n      a Hello message with holdtime 0xffff, and/or provide a mechanism\n\
    \      to remove a neighbor.\n      Hello messages with a Holdtime value set to\
    \ '0' are also sent by a\n      router on an interface about to go down or changing\
    \ IP address\n      (see Section 4.3.1).  These are effectively goodbye messages,\
    \ and\n      the receiving routers SHOULD immediately time out the neighbor\n\
    \      information for the sender.\n   o  OptionType 2: LAN Prune Delay\n    \
    \   0                   1                   2                   3\n       0 1\
    \ 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |          Type = 2             |          Length = 4           |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |T|\
    \      Propagation_Delay      |      Override_Interval        |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      The LAN Prune Delay option is used to tune the prune propagation\n    \
    \  delay on multi-access LANs.  The T bit specifies the ability of\n      the\
    \ sending router to disable Join suppression.  Propagation_Delay\n      and Override_Interval\
    \ are time intervals in units of milliseconds.\n      A router originating a LAN\
    \ Prune Delay option on interface I sets\n      the Propagation_Delay field to\
    \ the configured value of\n      Propagation_Delay(I) and the value of the Override_Interval\
    \ field\n      to the value of Override_Interval(I).  On a receiving router, the\n\
    \      values of the fields are used to tune the value of the\n      Effective_Override_Interval(I)\
    \ and its derived timer values.\n      Section 4.3.3 describes how these values\
    \ affect the behavior of a\n      router.\n   o  OptionTypes 3 through 16: Reserved;\
    \ to be defined in future\n      versions of this document.\n   o  OptionType\
    \ 18: Deprecated and should not be used.\n   o  OptionType 19: DR Priority\n \
    \      0                   1                   2                   3\n       0\
    \ 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |          Type = 19            |          Length = 4           |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |\
    \                         DR Priority                           |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      DR Priority is a 32-bit unsigned number and should be considered\n    \
    \  in the DR election as described in Section 4.3.2.\n   o  OptionType 20: Generation\
    \ ID\n       0                   1                   2                   3\n \
    \      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n     \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      | \
    \         Type = 20            |          Length = 4           |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |                       Generation ID                           |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      Generation\
    \ ID is a random 32-bit value for the interface on which\n      the Hello message\
    \ is sent.  The Generation ID is regenerated\n      whenever PIM forwarding is\
    \ started or restarted on the interface.\n   o  OptionType 24: Address List\n\
    \       0                   1                   2                   3\n      \
    \ 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |          Type = 24            |      Length = <Variable>      |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |\
    \         Secondary Address 1 (Encoded-Unicast format)          |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                                     ...\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |         Secondary Address N (Encoded-Unicast format)          |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      The\
    \ contents of the Address List Hello option are described in\n      Section 4.3.4.\
    \  All addresses within a single Address List must\n      belong to the same address\
    \ family.\n   OptionTypes 17 through 65000 are assigned by the IANA.\n   OptionTypes\
    \ 65001 through 65535 are reserved for Private Use,\n   as defined in [9].\n \
    \  Unknown options MUST be ignored and MUST NOT prevent a neighbor\n   relationship\
    \ from being formed.  The Holdtime option MUST be\n   implemented; the DR Priority\
    \ and Generation ID options SHOULD be\n   implemented.  The Address List option\
    \ MUST be implemented for IPv6.\n"
- title: 4.9.3.  Register Message Format
  contents:
  - "4.9.3.  Register Message Format\n   A Register message is sent by the DR to the\
    \ RP when a multicast\n   packet needs to be transmitted on the RP-tree.  The\
    \ IP source address\n   is set to the address of the DR, the destination address\
    \ to the RP's\n   address.  The IP TTL of the PIM packet is the system's normal\n\
    \   unicast TTL.\n    0                   1                   2              \
    \     3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n\
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   |PIM\
    \ Ver| Type  |   Reserved    |           Checksum            |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |B|N|                       Reserved2                           |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                                                               |\n   .  \
    \                   Multicast data packet                     .\n   |        \
    \                                                       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   PIM Version, Type, Reserved, Checksum\n         Described in Section 4.9.\
    \  Note that in order to reduce\n         encapsulation overhead, the checksum\
    \ for Registers is done only\n         on the first 8 bytes of the packet, including\
    \ the PIM header\n         and the next 4 bytes, excluding the data packet portion.\
    \  For\n         interoperability reasons, a message carrying a checksum\n   \
    \      calculated over the entire PIM Register message should also be\n      \
    \   accepted.  When calculating the checksum, the IPv6\n         pseudo-header\
    \ \"Upper-Layer Packet Length\" is set to 8.\n   B     The Border bit.  This specification\
    \ deprecates the Border bit.\n         A router MUST set the B bit to 0 on transmission\
    \ and MUST\n         ignore this bit on reception.\n   N     The Null-Register\
    \ bit.  Set to 1 by a DR that is probing the RP\n         before expiring its\
    \ local Register-Suppression Timer.  Set to 0\n         otherwise.\n   Reserved2\n\
    \         Transmitted as zero, ignored on receipt.\n   Multicast data packet\n\
    \         The original packet sent by the source.  This packet must be of\n  \
    \       the same address family as the encapsulating PIM packet, e.g.,\n     \
    \    an IPv6 data packet must be encapsulated in an IPv6 PIM packet.\n       \
    \  Note that the TTL of the original packet is decremented before\n         encapsulation,\
    \ just like any other packet that is forwarded.\n         In addition, the RP\
    \ decrements the TTL after decapsulating,\n         before forwarding the packet\
    \ down the shared tree.\n         For (S,G) Null-Registers, the Multicast data\
    \ packet portion\n         contains a dummy IP header with S as the source address\n\
    \         and G as the destination address.  When generating an IPv4\n       \
    \  Null-Register message, the fields in the dummy IPv4 header\n         SHOULD\
    \ be filled in according to the following table.  Other\n         IPv4 header\
    \ fields may contain any value that is valid for\n         that field.\n     \
    \    Field                  Value\n         ---------------------------------------\n\
    \         IP Version             4\n         Header Length          5\n      \
    \   Checksum               Header checksum\n         Fragmentation offset   0\n\
    \         More Fragments         0\n         Total Length           20\n     \
    \    IP Protocol            103 (PIM)\n         On receipt of an (S,G) Null-Register,\
    \ if the Header Checksum\n         field is non-zero, the recipient SHOULD check\
    \ the checksum and\n         discard Null-Registers that have a bad checksum.\
    \  The recipient\n         SHOULD NOT check the value of any individual fields;\
    \ a correct\n         IP header checksum is sufficient.  If the Header Checksum\
    \ field\n         is zero, the recipient MUST NOT check the checksum.\n      \
    \   With IPv6, an implementation generates a dummy IP header\n         followed\
    \ by a dummy PIM header with values according to the\n         following table\
    \ in addition to the source and group.  Other\n         IPv6 header fields may\
    \ contain any value that is valid for that\n         field.\n         Header Field\
    \   Value\n         --------------------------------------\n         IP Version\
    \     6\n         Next Header    103 (PIM)\n         Length         4\n      \
    \   PIM Version    0\n         PIM Type       0\n         PIM Reserved   0\n \
    \        PIM Checksum   PIM checksum, including\n                        IPv6\
    \ \"pseudo-header\";\n                        see Section 4.9\n         On receipt\
    \ of an IPv6 (S,G) Null-Register, if the dummy PIM\n         header is present,\
    \ the recipient SHOULD check the checksum and\n         discard Null-Registers\
    \ that have a bad checksum.\n"
- title: 4.9.4.  Register-Stop Message Format
  contents:
  - "4.9.4.  Register-Stop Message Format\n   A Register-Stop is unicast from the\
    \ RP to the sender of the Register\n   message.  The IP source address is the\
    \ address to which the register\n   was addressed.  The IP destination address\
    \ is the source address of\n   the register message.\n    0                  \
    \ 1                   2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4\
    \ 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |PIM Ver| Type  |   Reserved    |           Checksum            |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |             Group Address (Encoded-Group format)              |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |            Source Address (Encoded-Unicast format)            |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   PIM Version, Type, Reserved, Checksum\n         Described in Section 4.9.\n\
    \   Group Address\n         The group address from the multicast data packet in\
    \ the\n         Register.  The format for this address is described in\n     \
    \    Section 4.9.1.  Note that for Register-Stops the Mask Len field\n       \
    \  contains the full address length * 8 (e.g., 32 for IPv4 native\n         encoding),\
    \ if the message is sent for a single group.\n   Source Address\n         The\
    \ host address of the source from the multicast data packet\n         in the register.\
    \  The format for this address is given in the\n         encoded unicast address\
    \ in Section 4.9.1.  A special wildcard\n         value consisting of an address\
    \ field of all zeros can be used\n         to indicate any source.\n"
- title: 4.9.5.  Join/Prune Message Format
  contents:
  - "4.9.5.  Join/Prune Message Format\n   A Join/Prune message is sent by routers\
    \ towards upstream sources and\n   RPs.  Joins are sent to build shared trees\
    \ (RP trees) or source trees\n   (SPT).  Prunes are sent to prune source trees\
    \ when members leave\n   groups as well as sources that do not use the shared\
    \ tree.\n    0                   1                   2                   3\n \
    \   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |PIM Ver| Type  |   Reserved    |           Checksum            |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |        Upstream Neighbor Address (Encoded-Unicast format)     |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |  Reserved     | Num groups    |          Holdtime             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |         Multicast Group Address 1 (Encoded-Group format)      |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |   Number of Joined Sources    |   Number of Pruned Sources    |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |        Joined Source Address 1 (Encoded-Source format)        |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                             .                                 |\n   |  \
    \                           .                                 |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |        Joined Source Address n (Encoded-Source format)        |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |        Pruned Source Address 1 (Encoded-Source format)        |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                             .                                 |\n   |  \
    \                           .                                 |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |        Pruned Source Address n (Encoded-Source format)        |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                           .                                   |\n   |  \
    \                         .                                   |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |         Multicast Group Address m (Encoded-Group format)      |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |   Number of Joined Sources    |   Number of Pruned Sources    |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |        Joined Source Address 1 (Encoded-Source format)        |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                             .                                 |\n   |  \
    \                           .                                 |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |        Joined Source Address n (Encoded-Source format)        |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |        Pruned Source Address 1 (Encoded-Source format)        |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                             .                                 |\n   |  \
    \                           .                                 |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |        Pruned Source Address n (Encoded-Source format)        |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   PIM Version, Type, Reserved, Checksum\n         Described in Section 4.9.\n\
    \   Unicast Upstream Neighbor Address\n         The primary address of the upstream\
    \ neighbor that is the target\n         of the message.  The format for this address\
    \ is given in the\n         encoded unicast address in Section 4.9.1.\n   Reserved\n\
    \         Transmitted as zero, ignored on receipt.\n   Holdtime\n         The\
    \ amount of time a receiver MUST keep the Join/Prune state\n         alive, in\
    \ seconds.  If the Holdtime is set to '0xffff', the\n         receiver of this\
    \ message SHOULD hold the state until canceled\n         by the appropriate canceling\
    \ Join/Prune message, or timed out\n         according to local policy.  This\
    \ may be used with dial-on-\n         demand links, to avoid keeping the link\
    \ up with periodic\n         Join/Prune messages.\n         Note that the HoldTime\
    \ MUST be larger than the\n         J/P_Override_Interval(I).\n   Number of Groups\n\
    \         The number of multicast group sets contained in the message.\n   Multicast\
    \ group address\n         For format description, see Section 4.9.1.\n   Number\
    \ of Joined Sources\n         Number of joined source addresses listed for a given\
    \ group.\n   Joined Source Address 1 .. n\n         This list contains the sources\
    \ for a given group that the\n         sending router will forward multicast datagrams\
    \ from if\n         received on the interface on which the Join/Prune message\n\
    \         is sent.\n         See Section 4.9.1 for the format description for\
    \ the\n         encoded source address.\n   Number of Pruned Sources\n       \
    \  Number of pruned source addresses listed for a group.\n   Pruned Source Address\
    \ 1 .. n\n         This list contains the sources for a given group that the\n\
    \         sending router does not want to forward multicast datagrams\n      \
    \   from when received on the interface on which the Join/Prune\n         message\
    \ is sent.\n   Within one PIM Join/Prune message, all the Multicast Group addresses,\n\
    \   Joined Source addresses, and Pruned Source addresses MUST be of the\n   same\
    \ address family.  It is NOT PERMITTED to mix IPv4 and IPv6\n   addresses within\
    \ the same message.  In addition, the address family\n   of the fields in the\
    \ message SHOULD be the same as the IP source and\n   destination addresses of\
    \ the packet.  This permits maximum\n   implementation flexibility for dual-stack\
    \ IPv4/IPv6 routers.  If a\n   router receives a message with mixed family addresses,\
    \ it SHOULD only\n   process the addresses that are of the same family as the\
    \ unicast\n   upstream neighbor address.\n"
- title: 4.9.5.1.  Group Set Source List Rules
  contents:
  - "4.9.5.1.  Group Set Source List Rules\n   As described above, Join/Prune messages\
    \ are composed of one or more\n   group sets.  Each set contains two source lists:\
    \ the Joined Sources\n   and the Pruned Sources.  This section describes the different\
    \ types\n   of group sets and source list entries that can exist in a Join/Prune\n\
    \   message.\n   There is one valid group set type:\n   Group-Specific Set\n \
    \        A Group-Specific Set is represented by a valid IP multicast\n       \
    \  address in the group address field and the full length of the\n         IP\
    \ address in the mask length field of the Multicast Group\n         Address. \
    \ Each Join/Prune message SHOULD NOT contain more than\n         one group-specific\
    \ set for the same IP multicast address.  Each\n         group-specific set may\
    \ contain (*,G), (S,G,rpt), and (S,G)\n         source list entries in the Joined\
    \ or Pruned lists.\n      (*,G)\n            The (*,G) source list entry is used\
    \ in Join/Prune messages\n            sent towards the RP for the specified group.\
    \  It expresses\n            interest (or lack thereof) in receiving traffic sent\
    \ to the\n            group through the RP shared tree.  There MUST only be one\n\
    \            such entry in both the Joined and Pruned lists of a group-\n    \
    \        specific set.\n            (*,G) source list entries have the Source-Address\
    \ set to the\n            address of the RP for group G, the Source-Address Mask-Len\n\
    \            set to the full length of the IP address, and both the WC\n     \
    \       and RPT bits of the encoded-source-address set.\n      (S,G,rpt)\n   \
    \         The (S,G,rpt) source list entry is used in Join/Prune\n            messages\
    \ sent towards the RP for the specified group.  It\n            expresses interest\
    \ (or lack thereof) in receiving traffic\n            through the shared tree\
    \ sent by the specified source to this\n            group.  For each source address,\
    \ the entry MUST exist in\n            only one of the Joined and Pruned source\
    \ lists of a group-\n            specific set, but not both.\n            (S,G,rpt)\
    \ source list entries have the Source-Address set to\n            the address\
    \ of the source S, the Source-Address Mask-Len set\n            to the full length\
    \ of the IP address, and the WC bit cleared\n            and the RPT bit set in\
    \ the encoded source address.\n      (S,G)\n            The (S,G) source list\
    \ entry is used in Join/Prune messages\n            sent towards the specified\
    \ source.  It expresses interest\n            (or lack thereof) in receiving traffic\
    \ through the shortest\n            path tree sent by the source to the specified\
    \ group.  For\n            each source address, the entry MUST exist in only one\
    \ of the\n            Joined and Pruned source lists of a group-specific set,\
    \ but\n            not both.\n            (S,G) source list entries have the Source-Address\
    \ set to the\n            address of the source S, the Source-Address Mask-Len\
    \ set to\n            the full length of the IP address, and both the WC and RPT\n\
    \            bits of the encoded source address cleared.\n   The rules described\
    \ above are sufficient to prevent invalid\n   combinations of source list entries\
    \ in group-specific sets.  There\n   are, however, a number of combinations that\
    \ have a valid\n   interpretation but that are not generated by the protocol as\n\
    \   described in this specification:\n   o  Combining a (*,G) Join and an (S,G,rpt)\
    \ Join entry in the same\n      message is redundant, as the (*,G) entry covers\
    \ the information\n      provided by the (S,G,rpt) entry.\n   o  The same applies\
    \ for a (*,G) Prune and an (S,G,rpt) Prune.\n   o  The combination of a (*,G)\
    \ Prune and an (S,G,rpt) Join is also not\n      generated.  (S,G,rpt) Joins are\
    \ only sent when the router is\n      receiving all traffic for a group on the\
    \ shared tree and it wishes\n      to indicate a change for the particular source.\
    \  As a (*,G) prune\n      indicates that the router no longer wishes to receive\
    \ shared tree\n      traffic, the (S,G,rpt) Join would be meaningless.\n   o \
    \ As Join/Prune messages are targeted to a single PIM neighbor,\n      including\
    \ both an (S,G) Join and an (S,G,rpt) Prune in the same\n      message is usually\
    \ redundant.  The (S,G) Join informs the neighbor\n      that the sender wishes\
    \ to receive the particular source on the\n      shortest path tree.  It is therefore\
    \ unnecessary for the router to\n      say that it no longer wishes to receive\
    \ it on the shared tree.\n      However, there is a valid interpretation for this\
    \ combination of\n      entries.  A downstream router may have to instruct its\
    \ upstream\n      only to start forwarding a specific source once it has started\n\
    \      receiving the source on the shortest-path tree.\n   o  The combination\
    \ of an (S,G) Prune and an (S,G,rpt) Join could\n      possibly be used by a router\
    \ to switch from receiving a particular\n      source on the shortest-path tree\
    \ back to receiving it on the\n      shared tree (provided that the RPF neighbor\
    \ for the shortest-path\n      and shared trees is common).  However, Sparse-Mode\
    \ PIM does not\n      provide a mechanism for explicitly switching back to the\
    \ shared\n      tree.\n   The rules are summarized in the table below.\n   +----------++------+-------+-----------+-----------+-------+-------+\n\
    \   |          ||Join  | Prune | Join      | Prune     | Join  | Prune |\n   |\
    \          ||(*,G) | (*,G) | (S,G,rpt) | (S,G,rpt) | (S,G) | (S,G) |\n   +----------++------+-------+-----------+-----------+-------+-------+\n\
    \   |Join      ||-     | no    | ?         | yes       | yes   | yes   |\n   |(*,G)\
    \     ||      |       |           |           |       |       |\n   +----------++------+-------+-----------+-----------+-------+-------+\n\
    \   |Prune     ||no    | -     | ?         | ?         | yes   | yes   |\n   |(*,G)\
    \     ||      |       |           |           |       |       |\n   +----------++------+-------+-----------+-----------+-------+-------+\n\
    \   |Join      ||?     | ?     | -         | no        | yes   | ?     |\n   |(S,G,rpt)\
    \ ||      |       |           |           |       |       |\n   +----------++------+-------+-----------+-----------+-------+-------+\n\
    \   |Prune     ||yes   | ?     | no        | -         | yes   | ?     |\n   |(S,G,rpt)\
    \ ||      |       |           |           |       |       |\n   +----------++------+-------+-----------+-----------+-------+-------+\n\
    \   |Join      ||yes   | yes   | yes       | yes       | -     | no    |\n   |(S,G)\
    \     ||      |       |           |           |       |       |\n   +----------++------+-------+-----------+-----------+-------+-------+\n\
    \   |Prune     ||yes   | yes   | ?         | ?         | no    | -     |\n   |(S,G)\
    \     ||      |       |           |           |       |       |\n   +----------++------+-------+-----------+-----------+-------+-------+\n\
    \   yes   Allowed and expected.\n   no    Combination is not allowed by the protocol\
    \ and MUST NOT be\n         generated by a router.  A router MAY accept these\
    \ messages, but\n         the result is undefined.  An error message MAY be logged\
    \ to the\n         administrator in a rate-limited manner.\n   ?     Combination\
    \ not expected by the protocol, but well defined.  A\n         router MAY accept\
    \ it but SHOULD NOT generate it.\n   The order of source list entries in a group\
    \ set source list is not\n   important, except where limited by the packet format\
    \ itself.\n"
- title: 4.9.5.2.  Group Set Fragmentation
  contents:
  - "4.9.5.2.  Group Set Fragmentation\n   When building a Join/Prune for a particular\
    \ neighbor, a router should\n   try to include in the message as much of the information\
    \ it needs to\n   convey to the neighbor as possible.  This implies adding one\
    \ group\n   set for each multicast group that has information pending\n   transmission\
    \ and within each set including all relevant source list\n   entries.\n   On a\
    \ router with a large amount of multicast state, the number of\n   entries that\
    \ must be included may result in packets that are larger\n   than the maximum\
    \ IP packet size.  In most such cases, the information\n   may be split into multiple\
    \ messages.\n   There is an exception with group sets that contain a (*,G) Joined\n\
    \   source list entry.  The group set expresses the router's interest in\n   receiving\
    \ all traffic for the specified group on the shared tree, and\n   it MUST include\
    \ an (S,G,rpt) Pruned source list entry for every\n   source that the router does\
    \ not wish to receive.  This list of\n   (S,G,rpt) Pruned source list entries\
    \ MUST NOT be split in multiple\n   messages.\n   If only N (S,G,rpt) Prune entries\
    \ fit into a maximum-sized Join/Prune\n   message, but the router has more than\
    \ N (S,G,rpt) Prunes to add, then\n   the router MUST choose to include the first\
    \ N (numerically smallest\n   in network byte order) IP addresses, and the rest\
    \ are ignored (not\n   included).\n"
- title: 4.9.6.  Assert Message Format
  contents:
  - "4.9.6.  Assert Message Format\n   The Assert message is used to resolve forwarder\
    \ conflicts between\n   routers on a link.  It is sent when a router receives\
    \ a multicast\n   data packet on an interface on which the router would normally\
    \ have\n   forwarded that packet.  Assert messages may also be sent in response\n\
    \   to an Assert message from another router.\n    0                   1     \
    \              2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7\
    \ 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |PIM Ver| Type  |   Reserved    |           Checksum            |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |              Group Address (Encoded-Group format)             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |            Source Address (Encoded-Unicast format)            |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |R|                      Metric Preference                      |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                             Metric                            |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   PIM Version, Type, Reserved, Checksum\n         Described in Section 4.9.\n\
    \   Group Address\n         The group address for which the router wishes to resolve\
    \ the\n         forwarding conflict.  This is an encoded group address, as\n \
    \        specified in Section 4.9.1.\n   Source Address\n         Source address\
    \ for which the router wishes to resolve the\n         forwarding conflict.  The\
    \ source address MAY be set to zero for\n         (*,G) asserts (see below). \
    \ The format for this address is\n         given in the encoded unicast address\
    \ in Section 4.9.1.\n   R     RPTbit is a 1-bit value.  The RPTbit is set to 1\
    \ for\n         Assert(*,G) messages and 0 for Assert(S,G) messages.\n   Metric\
    \ Preference\n         Preference value assigned to the unicast routing protocol\
    \ that\n         provided the route to the multicast source or Rendezvous Point.\n\
    \   Metric\n         The unicast routing table metric associated with the route\
    \ used\n         to reach the multicast source or Rendezvous Point.  The metric\n\
    \         is in units applicable to the unicast routing protocol used.\n   Assert\
    \ messages can be sent to resolve a forwarding conflict for all\n   traffic to\
    \ a given group or for a specific source and group.\n   Assert(S,G)\n        \
    \ Source-specific asserts are sent by routers forwarding a\n         specific\
    \ source on the shortest-path tree (SPTbit is TRUE).\n         (S,G) Asserts have\
    \ the Group-Address field set to the group G\n         and the Source-Address\
    \ field set to the source S.  The RPTbit\n         is set to 0, the Metric-Preference\
    \ is set to MRIB.pref(S), and\n         the Metric is set to MRIB.metric(S).\n\
    \   Assert(*,G)\n         Group-specific asserts are sent by routers forwarding\
    \ data for\n         the group and source(s) under contention on the shared tree.\n\
    \         (*,G) asserts have the Group-Address field set to the group G.\n   \
    \      For data-triggered Asserts, the Source-Address field MAY be set\n     \
    \    to the IP source address of the data packet that triggered the\n        \
    \ Assert and is set to zero otherwise.  The RPTbit is set to 1,\n         the\
    \ Metric-Preference is set to MRIB.pref(RP(G)), and the\n         Metric is set\
    \ to MRIB.metric(RP(G)).\n"
- title: 4.10.  PIM Timers
  contents:
  - "4.10.  PIM Timers\n   PIM-SM maintains the following timers, as discussed in\
    \ Section 4.11.\n   All timers are countdown timers; they are set to a value and\
    \ count\n   down to zero, at which point they typically trigger an action.  Of\n\
    \   course, they can just as easily be implemented as count-up timers,\n   where\
    \ the absolute expiry time is stored and compared against a\n   real-time clock,\
    \ but the language in this specification assumes that\n   they count downwards\
    \ to zero.\n   Global Timers\n   Per interface (I):\n        Hello Timer: HT(I)\n\
    \        Per neighbor (N):\n             Neighbor Liveness Timer: NLT(N,I)\n \
    \       Per Group (G):\n             (*,G) Join Expiry Timer: ET(*,G,I)\n    \
    \         (*,G) Prune-Pending Timer: PPT(*,G,I)\n             (*,G) Assert Timer:\
    \ AT(*,G,I)\n             Per Source (S):\n                  (S,G) Join Expiry\
    \ Timer: ET(S,G,I)\n                  (S,G) Prune-Pending Timer: PPT(S,G,I)\n\
    \                  (S,G) Assert Timer: AT(S,G,I)\n                  (S,G,rpt)\
    \ Prune Expiry Timer: ET(S,G,rpt,I)\n                  (S,G,rpt) Prune-Pending\
    \ Timer: PPT(S,G,rpt,I)\n   Per Group (G):\n        (*,G) Upstream Join Timer:\
    \ JT(*,G)\n        Per Source (S):\n             (S,G) Upstream Join Timer: JT(S,G)\n\
    \             (S,G) Keepalive Timer: KAT(S,G)\n             (S,G,rpt) Upstream\
    \ Override Timer: OT(S,G,rpt)\n   At the DRs or relevant Assert Winners only:\n\
    \        Per Source,Group pair (S,G):\n             Register-Stop Timer: RST(S,G)\n"
- title: 4.11.  Timer Values
  contents:
  - "4.11.  Timer Values\n   When timers are started or restarted, they are set to\
    \ default values.\n   This section summarizes those default values.\n   Note that\
    \ protocol events or configuration may change the default\n   value of a timer\
    \ on a specific interface.  When timers are\n   initialized in this document,\
    \ the value specific to the interface in\n   context must be used.\n   Some of\
    \ the timers listed below (Prune-Pending, Upstream Join,\n   Upstream Override)\
    \ can be set to values that depend on the settings\n   of the Propagation_Delay\
    \ and Override_Interval of the corresponding\n   interface.  The default values\
    \ for these are given below.\n   Variable Name: Propagation_Delay(I)\n"
- title: +-------------------------------+--------------+----------------------+
  contents:
  - '+-------------------------------+--------------+----------------------+

    '
- title: '|  Value Name                   |  Value       |  Explanation         |'
  contents:
  - '|  Value Name                   |  Value       |  Explanation         |

    '
- title: +-------------------------------+--------------+----------------------+
  contents:
  - '+-------------------------------+--------------+----------------------+

    '
- title: '|  Propagation_delay_default    |  0.5 secs    |  Expected            |'
  contents:
  - '|  Propagation_delay_default    |  0.5 secs    |  Expected            |

    '
- title: '|                               |              |  propagation delay   |'
  contents:
  - '|                               |              |  propagation delay   |

    '
- title: '|                               |              |  over the local      |'
  contents:
  - '|                               |              |  over the local      |

    '
- title: '|                               |              |  link.               |'
  contents:
  - '|                               |              |  link.               |

    '
- title: +-------------------------------+--------------+----------------------+
  contents:
  - "+-------------------------------+--------------+----------------------+\n   The\
    \ default value of the Propagation_delay_default is chosen to be\n   relatively\
    \ large to provide compatibility with older PIM\n   implementations.\n   Variable\
    \ Name: Override_Interval(I)\n"
- title: +--------------------------+-----------------+-------------------------+
  contents:
  - '+--------------------------+-----------------+-------------------------+

    '
- title: '|  Value Name              |    Value        |    Explanation          |'
  contents:
  - '|  Value Name              |    Value        |    Explanation          |

    '
- title: +--------------------------+-----------------+-------------------------+
  contents:
  - '+--------------------------+-----------------+-------------------------+

    '
- title: '|  t_override_default      |    2.5 secs     |    Default delay        |'
  contents:
  - '|  t_override_default      |    2.5 secs     |    Default delay        |

    '
- title: '|                          |                 |    interval over        |'
  contents:
  - '|                          |                 |    interval over        |

    '
- title: '|                          |                 |    which to randomize   |'
  contents:
  - '|                          |                 |    which to randomize   |

    '
- title: '|                          |                 |    when scheduling a    |'
  contents:
  - '|                          |                 |    when scheduling a    |

    '
- title: '|                          |                 |    delayed Join         |'
  contents:
  - '|                          |                 |    delayed Join         |

    '
- title: '|                          |                 |    message.             |'
  contents:
  - '|                          |                 |    message.             |

    '
- title: +--------------------------+-----------------+-------------------------+
  contents:
  - "+--------------------------+-----------------+-------------------------+\n  \
    \ Timer Name: Hello Timer (HT(I))\n"
- title: +---------------------+--------+---------------------------------------+
  contents:
  - '+---------------------+--------+---------------------------------------+

    '
- title: '|Value Name           | Value  | Explanation                           |'
  contents:
  - '|Value Name           | Value  | Explanation                           |

    '
- title: +---------------------+--------+---------------------------------------+
  contents:
  - '+---------------------+--------+---------------------------------------+

    '
- title: '|Hello_Period         | 30 secs| Periodic interval for Hello messages. |'
  contents:
  - '|Hello_Period         | 30 secs| Periodic interval for Hello messages. |

    '
- title: +---------------------+--------+---------------------------------------+
  contents:
  - '+---------------------+--------+---------------------------------------+

    '
- title: '|Triggered_Hello_Delay| 5 secs | Randomized interval for initial Hello |'
  contents:
  - '|Triggered_Hello_Delay| 5 secs | Randomized interval for initial Hello |

    '
- title: '|                     |        | message on bootup or triggered Hello  |'
  contents:
  - '|                     |        | message on bootup or triggered Hello  |

    '
- title: '|                     |        | message to a rebooting neighbor.      |'
  contents:
  - '|                     |        | message to a rebooting neighbor.      |

    '
- title: +---------------------+--------+---------------------------------------+
  contents:
  - "+---------------------+--------+---------------------------------------+\n  \
    \ At system power-up, the timer is initialized to\n   rand(0, Triggered_Hello_Delay)\
    \ to prevent synchronization.  When a\n   new or rebooting neighbor is detected,\
    \ a responding Hello is sent\n   within rand(0, Triggered_Hello_Delay).\n   Timer\
    \ Name: Neighbor Liveness Timer (NLT(N,I))\n"
- title: +--------------------------+----------------------+--------------------+
  contents:
  - '+--------------------------+----------------------+--------------------+

    '
- title: '| Value Name               |  Value               |  Explanation       |'
  contents:
  - '| Value Name               |  Value               |  Explanation       |

    '
- title: +--------------------------+----------------------+--------------------+
  contents:
  - '+--------------------------+----------------------+--------------------+

    '
- title: '| Default_Hello_Holdtime   |  3.5 * Hello_Period  |  Default holdtime  |'
  contents:
  - '| Default_Hello_Holdtime   |  3.5 * Hello_Period  |  Default holdtime  |

    '
- title: '|                          |                      |  to keep neighbor  |'
  contents:
  - '|                          |                      |  to keep neighbor  |

    '
- title: '|                          |                      |  state alive       |'
  contents:
  - '|                          |                      |  state alive       |

    '
- title: +--------------------------+----------------------+--------------------+
  contents:
  - '+--------------------------+----------------------+--------------------+

    '
- title: '| Hello_Holdtime           |  from message        |  Holdtime from     |'
  contents:
  - '| Hello_Holdtime           |  from message        |  Holdtime from     |

    '
- title: '|                          |                      |  Hello message     |'
  contents:
  - '|                          |                      |  Hello message     |

    '
- title: '|                          |                      |  Holdtime option.  |'
  contents:
  - '|                          |                      |  Holdtime option.  |

    '
- title: +--------------------------+----------------------+--------------------+
  contents:
  - "+--------------------------+----------------------+--------------------+\n  \
    \ The Holdtime in a Hello message should be set to\n   (3.5 * Hello_Period), giving\
    \ a default value of 105 seconds.\n   Timer Names: Expiry Timer (ET(*,G,I), ET(S,G,I),\
    \ ET(S,G,rpt,I))\n"
- title: +----------------+----------------+------------------------------------+
  contents:
  - '+----------------+----------------+------------------------------------+

    '
- title: '| Value Name     |  Value         |  Explanation                       |'
  contents:
  - '| Value Name     |  Value         |  Explanation                       |

    '
- title: +----------------+----------------+------------------------------------+
  contents:
  - '+----------------+----------------+------------------------------------+

    '
- title: '| J/P_HoldTime   |  from message  |  Holdtime from Join/Prune message  |'
  contents:
  - '| J/P_HoldTime   |  from message  |  Holdtime from Join/Prune message  |

    '
- title: +----------------+----------------+------------------------------------+
  contents:
  - "+----------------+----------------+------------------------------------+\n  \
    \ The value of J/P Holdtime that is included in Join/Prune messages is\n   specified\
    \ below, in the description of \"Upstream Join Timer (JT(*,G),\n   JT(S,G))\"\
    .\n   Timer Names: Prune-Pending Timer (PPT(*,G,I), PPT(S,G,I),\n   PPT(S,G,rpt,I))\n"
- title: +--------------------------+---------------------+---------------------+
  contents:
  - '+--------------------------+---------------------+---------------------+

    '
- title: '|Value Name                | Value               | Explanation         |'
  contents:
  - '|Value Name                | Value               | Explanation         |

    '
- title: +--------------------------+---------------------+---------------------+
  contents:
  - '+--------------------------+---------------------+---------------------+

    '
- title: '|J/P_Override_Interval(I)  | Default:            | Short period after  |'
  contents:
  - '|J/P_Override_Interval(I)  | Default:            | Short period after  |

    '
- title: '|                          | Effective_          | a join or prune to  |'
  contents:
  - '|                          | Effective_          | a join or prune to  |

    '
- title: '|                          | Propagation_        | allow other         |'
  contents:
  - '|                          | Propagation_        | allow other         |

    '
- title: '|                          | Delay(I) +          | routers on the LAN  |'
  contents:
  - '|                          | Delay(I) +          | routers on the LAN  |

    '
- title: '|                          | Effective_Override_ | to override the     |'
  contents:
  - '|                          | Effective_Override_ | to override the     |

    '
- title: '|                          | Interval(I)         | join or prune       |'
  contents:
  - '|                          | Interval(I)         | join or prune       |

    '
- title: +--------------------------+---------------------+---------------------+
  contents:
  - "+--------------------------+---------------------+---------------------+\n  \
    \ Note that both Effective_Propagation_Delay(I) and\n   Effective_Override_Interval(I)\
    \ are interface-specific values that may\n   change when Hello messages are received\
    \ (see Section 4.3.3).\n   Timer Names: Assert Timer (AT(*,G,I), AT(S,G,I))\n"
- title: +---------------------------+---------------------+--------------------+
  contents:
  - '+---------------------------+---------------------+--------------------+

    '
- title: '| Value Name                | Value               | Explanation        |'
  contents:
  - '| Value Name                | Value               | Explanation        |

    '
- title: +---------------------------+---------------------+--------------------+
  contents:
  - '+---------------------------+---------------------+--------------------+

    '
- title: '| Assert_Override_Interval  | Default: 3 secs     | Short interval     |'
  contents:
  - '| Assert_Override_Interval  | Default: 3 secs     | Short interval     |

    '
- title: '|                           |                     | before an assert   |'
  contents:
  - '|                           |                     | before an assert   |

    '
- title: '|                           |                     | times out where    |'
  contents:
  - '|                           |                     | times out where    |

    '
- title: '|                           |                     | the assert winner  |'
  contents:
  - '|                           |                     | the assert winner  |

    '
- title: '|                           |                     | resends an Assert  |'
  contents:
  - '|                           |                     | resends an Assert  |

    '
- title: '|                           |                     | message            |'
  contents:
  - '|                           |                     | message            |

    '
- title: +---------------------------+---------------------+--------------------+
  contents:
  - '+---------------------------+---------------------+--------------------+

    '
- title: '| Assert_Time               | Default: 180 secs   | Period after last  |'
  contents:
  - '| Assert_Time               | Default: 180 secs   | Period after last  |

    '
- title: '|                           |                     | assert before      |'
  contents:
  - '|                           |                     | assert before      |

    '
- title: '|                           |                     | assert state is    |'
  contents:
  - '|                           |                     | assert state is    |

    '
- title: '|                           |                     | timed out          |'
  contents:
  - '|                           |                     | timed out          |

    '
- title: +---------------------------+---------------------+--------------------+
  contents:
  - "+---------------------------+---------------------+--------------------+\n  \
    \ Note that for historical reasons, the Assert message lacks a Holdtime\n   field.\
    \  Thus, changing the Assert Time from the default value is not\n   recommended.\n\
    \   Timer Names: Upstream Join Timer (JT(*,G), JT(S,G))\n"
- title: +-------------+--------------------+-----------------------------------+
  contents:
  - '+-------------+--------------------+-----------------------------------+

    '
- title: '|Value Name   | Value              | Explanation                       |'
  contents:
  - '|Value Name   | Value              | Explanation                       |

    '
- title: +-------------+--------------------+-----------------------------------+
  contents:
  - '+-------------+--------------------+-----------------------------------+

    '
- title: '|t_periodic   | Default: 60 secs   | Period between Join/Prune messages|'
  contents:
  - '|t_periodic   | Default: 60 secs   | Period between Join/Prune messages|

    '
- title: +-------------+--------------------+-----------------------------------+
  contents:
  - '+-------------+--------------------+-----------------------------------+

    '
- title: '|t_suppressed | rand(1.1 *         | Suppression period when someone   |'
  contents:
  - '|t_suppressed | rand(1.1 *         | Suppression period when someone   |

    '
- title: '|             | t_periodic, 1.4 *  | else sends a J/P message so we    |'
  contents:
  - '|             | t_periodic, 1.4 *  | else sends a J/P message so we    |

    '
- title: '|             | t_periodic) when   | don''t need to do so.              |'
  contents:
  - '|             | t_periodic) when   | don''t need to do so.              |

    '
- title: '|             | Suppression_       |                                   |'
  contents:
  - '|             | Suppression_       |                                   |

    '
- title: '|             | Enabled(I) is      |                                   |'
  contents:
  - '|             | Enabled(I) is      |                                   |

    '
- title: '|             | true, 0 otherwise  |                                   |'
  contents:
  - '|             | true, 0 otherwise  |                                   |

    '
- title: +-------------+--------------------+-----------------------------------+
  contents:
  - '+-------------+--------------------+-----------------------------------+

    '
- title: '|t_override   | rand(0, Effective_ | Randomized delay to prevent       |'
  contents:
  - '|t_override   | rand(0, Effective_ | Randomized delay to prevent       |

    '
- title: '|             | Override_          | response implosion when sending a |'
  contents:
  - '|             | Override_          | response implosion when sending a |

    '
- title: '|             | Interval(I))       | Join message to override someone  |'
  contents:
  - '|             | Interval(I))       | Join message to override someone  |

    '
- title: '|             |                    | else''s Prune message.             |'
  contents:
  - '|             |                    | else''s Prune message.             |

    '
- title: +-------------+--------------------+-----------------------------------+
  contents:
  - "+-------------+--------------------+-----------------------------------+\n  \
    \ t_periodic may be set to take into account such things as the\n   configured\
    \ bandwidth and expected average number of multicast route\n   entries for the\
    \ attached network or link (e.g., the period would be\n   longer for lower-speed\
    \ links, or for routers in the center of the\n   network that expect to have a\
    \ larger number of entries).  If the\n   Join/Prune-Period is modified during\
    \ operation, these changes should\n   be made relatively infrequently, and the\
    \ router should continue to\n   refresh at its previous Join/Prune-Period for\
    \ at least\n   Join/Prune-Holdtime, in order to allow the upstream router to adapt.\n\
    \   The Holdtime specified in a Join/Prune message should be set to\n   (3.5 *\
    \ t_periodic).\n   t_override depends on the Effective Override Interval of the\
    \ upstream\n   interface, which may change when Hello messages are received.\n\
    \   t_suppressed depends on the Suppression State of the upstream\n   interface\
    \ (Section 4.3.3) and becomes zero when suppression is\n   disabled.\n   Timer\
    \ Name: Upstream Override Timer (OT(S,G,rpt))\n"
- title: +---------------+--------------------------+---------------------------+
  contents:
  - '+---------------+--------------------------+---------------------------+

    '
- title: '| Value Name    | Value                    |  Explanation              |'
  contents:
  - '| Value Name    | Value                    |  Explanation              |

    '
- title: +---------------+--------------------------+---------------------------+
  contents:
  - '+---------------+--------------------------+---------------------------+

    '
- title: '| t_override    | see Upstream Join Timer  |  see Upstream Join Timer  |'
  contents:
  - '| t_override    | see Upstream Join Timer  |  see Upstream Join Timer  |

    '
- title: +---------------+--------------------------+---------------------------+
  contents:
  - "+---------------+--------------------------+---------------------------+\n  \
    \ The Upstream Override Timer is only ever set to the t_override value;\n   this\
    \ value is defined earlier in this section, under \"Timer Names:\n   Upstream\
    \ Join Timer (JT(*,G), JT(S,G))\".\n   Timer Name: Keepalive Timer (KAT(S,G))\n"
- title: +-----------------------+-----------------------+----------------------+
  contents:
  - '+-----------------------+-----------------------+----------------------+

    '
- title: '| Value Name            |  Value                |  Explanation         |'
  contents:
  - '| Value Name            |  Value                |  Explanation         |

    '
- title: +-----------------------+-----------------------+----------------------+
  contents:
  - '+-----------------------+-----------------------+----------------------+

    '
- title: '| Keepalive_Period      |  Default: 210 secs    |  Period after last   |'
  contents:
  - '| Keepalive_Period      |  Default: 210 secs    |  Period after last   |

    '
- title: '|                       |                       |  (S,G) data packet   |'
  contents:
  - '|                       |                       |  (S,G) data packet   |

    '
- title: '|                       |                       |  during which (S,G)  |'
  contents:
  - '|                       |                       |  during which (S,G)  |

    '
- title: '|                       |                       |  Join state will be  |'
  contents:
  - '|                       |                       |  Join state will be  |

    '
- title: '|                       |                       |  maintained even in  |'
  contents:
  - '|                       |                       |  maintained even in  |

    '
- title: '|                       |                       |  the absence of      |'
  contents:
  - '|                       |                       |  the absence of      |

    '
- title: '|                       |                       |  (S,G) Join          |'
  contents:
  - '|                       |                       |  (S,G) Join          |

    '
- title: '|                       |                       |  messages.           |'
  contents:
  - '|                       |                       |  messages.           |

    '
- title: +-----------------------+-----------------------+----------------------+
  contents:
  - '+-----------------------+-----------------------+----------------------+

    '
- title: '| RP_Keepalive_Period   |  ( 3 * Register_      |  As                  |'
  contents:
  - '| RP_Keepalive_Period   |  ( 3 * Register_      |  As                  |

    '
- title: '|                       |  Suppression_Time )   |  Keepalive_Period,   |'
  contents:
  - '|                       |  Suppression_Time )   |  Keepalive_Period,   |

    '
- title: '|                       |  + Register_          |  but at the RP when  |'
  contents:
  - '|                       |  + Register_          |  but at the RP when  |

    '
- title: '|                       |  Probe_Time           |  a Register-Stop is  |'
  contents:
  - '|                       |  Probe_Time           |  a Register-Stop is  |

    '
- title: '|                       |                       |  sent.               |'
  contents:
  - '|                       |                       |  sent.               |

    '
- title: +-----------------------+-----------------------+----------------------+
  contents:
  - "+-----------------------+-----------------------+----------------------+\n  \
    \ The normal keepalive period for the KAT(S,G) defaults to 210 seconds.\n   However,\
    \ at the RP, the keepalive period must be at least the\n   Register_Suppression_Time,\
    \ or the RP may time out the (S,G) state\n   before the next Null-Register arrives.\
    \  Thus, the KAT(S,G) is set to\n   max(Keepalive_Period, RP_Keepalive_Period)\
    \ when a Register-Stop\n   is sent.\n   Timer Name: Register-Stop Timer (RST(S,G))\n"
- title: +---------------------------+--------------------+---------------------+
  contents:
  - '+---------------------------+--------------------+---------------------+

    '
- title: '|Value Name                 | Value              | Explanation         |'
  contents:
  - '|Value Name                 | Value              | Explanation         |

    '
- title: +---------------------------+--------------------+---------------------+
  contents:
  - '+---------------------------+--------------------+---------------------+

    '
- title: '|Register_Suppression_Time  | Default: 60 secs   | Period during       |'
  contents:
  - '|Register_Suppression_Time  | Default: 60 secs   | Period during       |

    '
- title: '|                           |                    | which a DR stops    |'
  contents:
  - '|                           |                    | which a DR stops    |

    '
- title: '|                           |                    | sending Register-   |'
  contents:
  - '|                           |                    | sending Register-   |

    '
- title: '|                           |                    | encapsulated data   |'
  contents:
  - '|                           |                    | encapsulated data   |

    '
- title: '|                           |                    | to the RP after     |'
  contents:
  - '|                           |                    | to the RP after     |

    '
- title: '|                           |                    | receiving a         |'
  contents:
  - '|                           |                    | receiving a         |

    '
- title: '|                           |                    | Register-Stop       |'
  contents:
  - '|                           |                    | Register-Stop       |

    '
- title: '|                           |                    | message.            |'
  contents:
  - '|                           |                    | message.            |

    '
- title: +---------------------------+--------------------+---------------------+
  contents:
  - '+---------------------------+--------------------+---------------------+

    '
- title: '|Register_Probe_Time        | Default: 5 secs    | Time before RST     |'
  contents:
  - '|Register_Probe_Time        | Default: 5 secs    | Time before RST     |

    '
- title: '|                           |                    | expires when a DR   |'
  contents:
  - '|                           |                    | expires when a DR   |

    '
- title: '|                           |                    | may send a Null-    |'
  contents:
  - '|                           |                    | may send a Null-    |

    '
- title: '|                           |                    | Register to the RP  |'
  contents:
  - '|                           |                    | Register to the RP  |

    '
- title: '|                           |                    | to cause it to      |'
  contents:
  - '|                           |                    | to cause it to      |

    '
- title: '|                           |                    | resend a Register-  |'
  contents:
  - '|                           |                    | resend a Register-  |

    '
- title: '|                           |                    | Stop message.       |'
  contents:
  - '|                           |                    | Stop message.       |

    '
- title: +---------------------------+--------------------+---------------------+
  contents:
  - "+---------------------------+--------------------+---------------------+\n  \
    \ If the Register_Suppression_Time or the Register_Probe_Time is\n   configured\
    \ to values other than the defaults, it MUST be ensured that\n   the value of\
    \ the Register_Probe_Time is less than half the value of\n   the Register_Suppression_Time\
    \ to prevent a possible negative value in\n   the setting of the Register-Stop\
    \ Timer.\n"
- title: 5.  IANA Considerations
  contents:
  - '5.  IANA Considerations

    '
- title: 5.1.  PIM Address Family
  contents:
  - "5.1.  PIM Address Family\n   The PIM Address Family field was chosen to be 8\
    \ bits as a tradeoff\n   between packet format and use of the IANA-assigned numbers.\
    \  Because\n   when the PIM packet format was designed only 15 values were assigned\n\
    \   for Address Families, and large numbers of new Address Family values\n   were\
    \ not envisioned, 8 bits seemed large enough.  However, the IANA\n   assigns Address\
    \ Families in a 16-bit field.  Therefore, the PIM\n   Address Family is allocated\
    \ as follows:\n      Values 0 through 127 are designated to have the same meaning\
    \ as\n      IANA-assigned Address Family Numbers [7].\n      Values 128 through\
    \ 250 are designated to be assigned for PIM by\n      the IANA based upon IESG\
    \ Approval, as defined in [9].\n      Values 251 through 255 are designated for\
    \ Private Use, as defined\n      in [9].\n"
- title: 5.2.  PIM Hello Options
  contents:
  - "5.2.  PIM Hello Options\n   Values 17 through 65000 are to be assigned by the\
    \ IANA.  Since the\n   space is large, they may be assigned as First Come First\
    \ Served, as\n   defined in [9].  Such assignments are valid for one year and\
    \ may be\n   renewed.  Permanent assignments require a specification (see\n  \
    \ \"Specification Required\" in [9]).\n"
- title: 6.  Security Considerations
  contents:
  - "6.  Security Considerations\n   This section describes various possible security\
    \ concerns related to\n   the PIM-SM protocol.  The reader is referred to [8],\
    \ [14], and [15]\n   for further discussion of PIM-SM and multicast security.\n\
    \   Note that PIM relies upon an MRIB populated outside of PIM;\n   therefore,\
    \ securing the sources of change to the MRIB is RECOMMENDED.\n"
- title: 6.1.  Attacks Based on Forged Messages
  contents:
  - "6.1.  Attacks Based on Forged Messages\n   The extent of possible damage depends\
    \ on the type of counterfeit\n   messages accepted.  We next consider the impact\
    \ of possible\n   forgeries, including forged link-local (Join/Prune, Hello, and\n\
    \   Assert) and forged unicast (Register and Register-Stop) messages.\n"
- title: 6.1.1.  Forged Link-Local Messages
  contents:
  - "6.1.1.  Forged Link-Local Messages\n   Join/Prune, Hello, and Assert messages\
    \ are all sent to the link-local\n   ALL-PIM-ROUTERS multicast address and thus\
    \ are not forwarded by a\n   compliant router.  A forged message of this type\
    \ can only reach a LAN\n   if it was sent by a local host or if it was allowed\
    \ onto the LAN by a\n   compromised or non-compliant router.\n   1.  A forged\
    \ Join/Prune message can cause multicast traffic to be\n       delivered to links\
    \ where there are no legitimate requesters,\n       potentially wasting bandwidth\
    \ on that link.  A forged leave\n       message on a multi-access LAN is generally\
    \ not a significant\n       attack in PIM, because any legitimately joined router\
    \ on the LAN\n       would override the leave with a join before the upstream\
    \ router\n       stops forwarding data to the LAN.\n   2.  By forging a Hello\
    \ message, an unauthorized router can cause\n       itself to be elected as the\
    \ Designated Router on a LAN.  The\n       Designated Router on a LAN is (in the\
    \ absence of asserts)\n       responsible for forwarding traffic to that LAN on\
    \ behalf of any\n       local members.  The Designated Router is also responsible\
    \ for\n       register-encapsulating to the RP any packets that are originated\n\
    \       by hosts on the LAN.  Thus, the ability of local hosts to send\n     \
    \  and receive multicast traffic may be compromised by a forged\n       Hello\
    \ message.\n   3.  By forging an Assert message on a multi-access LAN, an attacker\n\
    \       could cause the legitimate designated forwarder to stop\n       forwarding\
    \ traffic to the LAN.  Such a forgery would prevent any\n       hosts downstream\
    \ of that LAN from receiving traffic.\n"
- title: 6.1.2.  Forged Unicast Messages
  contents:
  - "6.1.2.  Forged Unicast Messages\n   Register messages and Register-Stop messages\
    \ are forwarded by\n   intermediate routers to their destination using normal\
    \ IP forwarding.\n   Without data origin authentication, an attacker who is located\n\
    \   anywhere in the network may be able to forge a Register or\n   Register-Stop\
    \ message.  We next consider the effect of a forgery of\n   each of these messages.\n\
    \   1.  By forging a Register message, an attacker can cause the RP to\n     \
    \  inject forged traffic onto the shared multicast tree.\n   2.  By forging a\
    \ Register-Stop message, an attacker can prevent a\n       legitimate DR from\
    \ registering packets to the RP.  This can\n       prevent local hosts on that\
    \ LAN from sending multicast packets.\n   The above two PIM messages are not changed\
    \ by intermediate routers\n   and need only be examined by the intended receiver.\
    \  Thus, these\n   messages can be authenticated end-to-end.  Attacks on Register\
    \ and\n   Register-Stop messages do not apply to a PIM-SSM-only implementation,\n\
    \   as these messages are not required for PIM-SSM.\n"
- title: 6.2.  Non-cryptographic Authentication Mechanisms
  contents:
  - "6.2.  Non-cryptographic Authentication Mechanisms\n   A PIM router SHOULD provide\
    \ an option to limit the set of neighbors\n   from which it will accept Join/Prune,\
    \ Assert, and Hello messages.\n   Either static configuration of IP addresses\
    \ or an IPsec security\n   association MAY be used.  Furthermore, a PIM router\
    \ SHOULD NOT accept\n   protocol messages from a router from which it has not\
    \ yet received a\n   valid Hello message.\n   A Designated Router MUST NOT register-encapsulate\
    \ a packet and send\n   it to the RP unless the source address of the packet is\
    \ a legal\n   address for the subnet on which the packet was received.  Similarly,\n\
    \   a Designated Router SHOULD NOT accept a Register-Stop packet whose IP\n  \
    \ source address is not a valid RP address for the local domain.\n   An implementation\
    \ SHOULD provide a mechanism to allow an RP to\n   restrict the range of source\
    \ addresses from which it accepts\n   Register-encapsulated packets.\n   All options\
    \ that restrict the range of addresses from which packets\n   are accepted MUST\
    \ default to allowing all packets.\n"
- title: 6.3.  Authentication
  contents:
  - "6.3.  Authentication\n   This document refers to RFC 5796 [8], which specifies\
    \ mechanisms to\n   authenticate PIM-SM link-local messages using the IPsec Encapsulating\n\
    \   Security Payload (ESP) or (optionally) the Authentication Header\n   (AH).\
    \  It also points out that non-link-local PIM-SM messages (i.e.,\n   Register\
    \ and Register-Stop messages) can be secured by a normal\n   unicast IPsec Security\
    \ Association (SA) between two communicants.\n"
- title: 6.4.  Denial-of-Service Attacks
  contents:
  - "6.4.  Denial-of-Service Attacks\n   There are a number of possible denial-of-service\
    \ attacks against PIM\n   that can be caused by generating false PIM protocol\
    \ messages or even\n   by generating false traffic.  Authenticating PIM protocol\
    \ traffic\n   prevents some, but not all, of these attacks.  Two of the possible\n\
    \   attacks include the following:\n   o  Sending packets to many different group\
    \ addresses quickly can be a\n      denial-of-service attack in and of itself.\
    \  This will cause many\n      register-encapsulated packets, loading the DR,\
    \ the RP, and the\n      routers between the DR and the RP.\n   o  Forging Join\
    \ messages can cause a multicast tree to get set up.\n      A large number of\
    \ forged joins can consume router resources and\n      result in denial of service.\n"
- title: 7.  References
  contents:
  - '7.  References

    '
- title: 7.1.  Normative References
  contents:
  - "7.1.  Normative References\n   [1]  Bradner, S., \"Key words for use in RFCs\
    \ to Indicate Requirement\n        Levels\", BCP 14, RFC 2119, DOI 10.17487/RFC2119,\
    \ March 1997,\n        <http://www.rfc-editor.org/info/rfc2119>.\n   [2]  Cain,\
    \ B., Deering, S., Kouvelas, I., Fenner, B., and A.\n        Thyagarajan, \"Internet\
    \ Group Management Protocol, Version 3\",\n        RFC 3376, DOI 10.17487/RFC3376,\
    \ October 2002,\n        <http://www.rfc-editor.org/info/rfc3376>.\n   [3]  Deering,\
    \ S., \"Host extensions for IP multicasting\", STD 5,\n        RFC 1112, DOI 10.17487/RFC1112,\
    \ August 1989,\n        <http://www.rfc-editor.org/info/rfc1112>.\n   [4]  Deering,\
    \ S., Fenner, W., and B. Haberman, \"Multicast Listener\n        Discovery (MLD)\
    \ for IPv6\", RFC 2710, DOI 10.17487/RFC2710,\n        October 1999, <http://www.rfc-editor.org/info/rfc2710>.\n\
    \   [5]  Deering, S. and R. Hinden, \"Internet Protocol, Version 6 (IPv6)\n  \
    \      Specification\", RFC 2460, DOI 10.17487/RFC2460, December 1998,\n     \
    \   <http://www.rfc-editor.org/info/rfc2460>.\n   [6]  Holbrook, H. and B. Cain,\
    \ \"Source-Specific Multicast for IP\",\n        RFC 4607, DOI 10.17487/RFC4607,\
    \ August 2006,\n        <http://www.rfc-editor.org/info/rfc4607>.\n   [7]  IANA,\
    \ \"Address Family Numbers\",\n        <http://www.iana.org/assignments/address-family-numbers>.\n\
    \   [8]  Atwood, W., Islam, S., and M. Siami, \"Authentication and\n        Confidentiality\
    \ in Protocol Independent Multicast Sparse Mode\n        (PIM-SM) Link-Local Messages\"\
    , RFC 5796, DOI 10.17487/RFC5796,\n        March 2010, <http://www.rfc-editor.org/info/rfc5796>.\n\
    \   [9]  Narten, T. and H. Alvestrand, \"Guidelines for Writing an IANA\n    \
    \    Considerations Section in RFCs\", BCP 26, RFC 5226,\n        DOI 10.17487/RFC5226,\
    \ May 2008,\n        <http://www.rfc-editor.org/info/rfc5226>.\n"
- title: 7.2.  Informative References
  contents:
  - "7.2.  Informative References\n   [10] Bates, T., Chandra, R., Katz, D., and Y.\
    \ Rekhter, \"Multiprotocol\n        Extensions for BGP-4\", RFC 4760, DOI 10.17487/RFC4760,\n\
    \        January 2007, <http://www.rfc-editor.org/info/rfc4760>.\n   [11] Bhaskar,\
    \ N., Gall, A., Lingard, J., and S. Venaas, \"Bootstrap\n        Router (BSR)\
    \ Mechanism for Protocol Independent Multicast\n        (PIM)\", RFC 5059, DOI\
    \ 10.17487/RFC5059, January 2008,\n        <http://www.rfc-editor.org/info/rfc5059>.\n\
    \   [12] Black, D., \"Differentiated Services and Tunnels\", RFC 2983,\n     \
    \   DOI 10.17487/RFC2983, October 2000,\n        <http://www.rfc-editor.org/info/rfc2983>.\n\
    \   [13] Handley, M., Kouvelas, I., Speakman, T., and L. Vicisano,\n        \"\
    Bidirectional Protocol Independent Multicast (BIDIR-PIM)\",\n        RFC 5015,\
    \ DOI 10.17487/RFC5015, October 2007,\n        <http://www.rfc-editor.org/info/rfc5015>.\n\
    \   [14] Savola, P., Lehtonen, R., and D. Meyer, \"Protocol Independent\n    \
    \    Multicast - Sparse Mode (PIM-SM) Multicast Routing Security\n        Issues\
    \ and Enhancements\", RFC 4609, DOI 10.17487/RFC4609,\n        October 2006, <http://www.rfc-editor.org/info/rfc4609>.\n\
    \   [15] Savola, P. and J. Lingard, \"Host Threats to Protocol Independent\n \
    \       Multicast (PIM)\", RFC 5294, DOI 10.17487/RFC5294, August 2008,\n    \
    \    <http://www.rfc-editor.org/info/rfc5294>.\n   [16] Savola, P. and B. Haberman,\
    \ \"Embedding the Rendezvous Point (RP)\n        Address in an IPv6 Multicast\
    \ Address\", RFC 3956,\n        DOI 10.17487/RFC3956, November 2004,\n       \
    \ <http://www.rfc-editor.org/info/rfc3956>.\n   [17] Zheng, L., Zhang, J., and\
    \ R. Parekh, \"Survey Report on Protocol\n        Independent Multicast - Sparse\
    \ Mode (PIM-SM) Implementations and\n        Deployments\", RFC 7063, DOI 10.17487/RFC7063,\
    \ December 2013,\n        <http://www.rfc-editor.org/info/rfc7063>.\n"
- title: Appendix A.  Functionality Removed from RFC 4601
  contents:
  - "Appendix A.  Functionality Removed from RFC 4601\n   Based on a survey of PIM\
    \ implementations and deployments [17]\n   conducted by the IETF PIM working group,\
    \ the following functionality\n   of RFC 4601 has been removed due to lack of\
    \ sufficient implementation\n   and deployment experience:\n   o  (*,*,RP) State\n\
    \   o  PIM Multicast Border Router (PMBR)\n   o  Authentication using IPsec\n"
- title: Acknowledgements
  contents:
  - "Acknowledgements\n   PIM-SM was designed over many years by a large group of\
    \ people,\n   including ideas, comments, and corrections from Deborah Estrin,\
    \ Dino\n   Farinacci, Ahmed Helmy, David Thaler, Steve Deering, Van Jacobson,\
    \ C.\n   Liu, Puneet Sharma, Liming Wei, Tom Pusateri, Tony Ballardie, Scott\n\
    \   Brim, Jon Crowcroft, Paul Francis, Joel Halpern, Horst Hodel, Polly\n   Huang,\
    \ Stephen Ostrowski, Lixia Zhang, Girish Chandranmenon, Brian\n   Haberman, Hal\
    \ Sandick, Mike Mroz, Garry Kump, Pavlin Radoslavov, Mike\n   Davison, James Huang,\
    \ Christopher Thomas Brown, and James Lingard.\n   Thanks are due to the American\
    \ Licorice Company, for its obscure but\n   possibly essential role in the creation\
    \ of this document.\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Bill Fenner\n   Arista Networks\n   Email: fenner@arista.com\n\
    \   Mark Handley\n   Department of Computer Science\n   University College London\n\
    \   Gower Street\n   London WC1E 6BT\n   United Kingdom\n   Email: M.Handley@cs.ucl.ac.uk\n\
    \   Hugh Holbrook\n   Arista Networks\n   5453 Great America Parkway\n   Santa\
    \ Clara, CA  95054\n   Email: holbrook@arista.com\n   Isidor Kouvelas\n   Arista\
    \ Networks\n   5453 Great America Parkway\n   Santa Clara, CA  95054\n   Email:\
    \ kouvelas@arista.com\n   Rishabh Parekh\n   Cisco Systems, Inc.\n   170 W. Tasman\
    \ Drive\n   San Jose, CA  95134\n   Email: riparekh@cisco.com\n   Zhaohui Zhang\n\
    \   Juniper Networks\n   10 Technology Park Drive\n   Westford, MA  01886\n  \
    \ Email: zzhang@juniper.net\n   Lianshu Zheng\n   Huawei Technologies Co., Ltd\n\
    \   Huawei Campus, 156 Beiqing Road, Hai-dian District\n   Beijing  100089\n \
    \  China\n   Email: vero.zheng@huawei.com\n"
