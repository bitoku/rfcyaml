- contents:
  - '             The Use of RSVP with IETF Integrated Services

    '
  title: __initial_text__
- contents:
  - "Status of this Memo\n   This document specifies an Internet standards track protocol
    for the\n   Internet community, and requests discussion and suggestions for\n
    \  improvements.  Please refer to the current edition of the \"Internet\n   Official
    Protocol Standards\" (STD 1) for the standardization state\n   and status of this
    protocol.  Distribution of this memo is unlimited.\n"
  title: Status of this Memo
- contents:
  - "Abstract\n   This note describes the use of the RSVP resource reservation protocol\n
    \  with the Controlled-Load and Guaranteed QoS control services.  The\n   RSVP
    protocol defines several data objects which carry resource\n   reservation information
    but are opaque to RSVP itself.  The usage and\n   data format of those objects
    is given here.\n"
  title: Abstract
- contents:
  - "1. Introduction\n   The Internet integrated services framework provides the ability
    for\n   applications to choose among multiple, controlled levels of delivery\n
    \  service for their data packets. To support this capability, two\n   things
    are required:\n      - Individual network elements (subnets and IP routers) along
    the\n      path followed by an application's data packets must support\n      mechanisms
    to control the quality of service delivered to those\n      packets.\n      -
    A way to communicate the application's requirements to network\n      elements
    along the path and to convey QoS management information\n      between network
    elements and the application must be provided.\n   In the integrated services
    framework the first function is provided\n   by QoS control services such as Controlled-Load
    [RFC 2211] and\n   Guaranteed [RFC 2212].  The second function may be provided
    in a\n   number of ways, but is frequently implemented by a resource\n   reservation
    setup protocol such as RSVP [RFC 2205].\n   Because RSVP is designed to be used
    with a variety of QoS control\n   services, and because the QoS control services
    are designed to be\n   used with a variety of setup mechanisms, a logical separation
    exists\n   between the two specifications. The RSVP specification does not\n   define
    the internal format of those RSVP protocol fields, or objects,\n   which are related
    to invoking QoS control services. Rather, RSVP\n   treats these objects as opaque.
    \ The objects can carry different\n   information to meet different application
    and QoS control service\n   requirements.\n   Similarly, interfaces to the QoS
    control services are defined in a\n   general format, so that the services can
    be used with a variety of\n   setup mechanisms.\n   This RFC provides the information
    required to use RSVP and the\n   integrated service framework's QoS control services
    together. It\n   defines the usage and contents of three RSVP protocol objects,
    the\n   FLOWSPEC, ADSPEC, and SENDER_TSPEC, in an environment supporting the\n
    \  Controlled-Load and/or Guaranteed QoS control services. If new\n   services
    or capabilities are added to the integrated services\n   framework, this note
    will be revised as required.\n"
  title: 1. Introduction
- contents:
  - "2. Use of RSVP\n   Several types of data must be transported between applications
    and\n   network elements to correctly invoke QoS control services.\n      NOTE:
    In addition to the data used to directly invoke QoS control\n      services, RSVP
    carries authentication, accounting, and policy\n      information needed to manage
    the use of these services. This note\n      is concerned only with the RSVP objects
    needed to actually invoke\n      QoS control services, and does not discuss accounting
    or policy\n      objects.\n   This data includes:\n      - Information generated
    by each receiver describing the QoS\n      control service desired, a description
    of the traffic flow to\n      which the resource reservation should apply (the
    Receiver TSpec),\n      and whatever parameters are required to invoke the service
    (the\n      Receiver RSpec). This information is carried from the receivers to\n
    \     intermediate network elements and the sender(s) by RSVP FLOWSPEC\n      objects.
    The information being carried in a FLOWSPEC object may\n      change at intermediate
    points in the network due to reservation\n      merging and other factors.\n      -
    Information generated at each sender describing the data traffic\n      generated
    by that sender (the Sender TSpec). This information is\n      carried from the
    sender to intermediate network elements and the\n      receiver(s) by RSVP, but
    is never modified by intermediate\n      elements within the network. This information
    is carried in RSVP\n      SENDER_TSPEC objects.\n      - Information generated
    or modified within the network and used at\n      the receivers to make reservation
    decisions.  This information\n      might include available services, delay and
    bandwidth estimates,\n      and operating parameters used by specific QoS control
    services.\n      this information is collected from network elements and carried\n
    \     towards receivers in RSVP ADSPEC objects.  Rather than carrying\n      information
    from each intermediate node separately to the\n      receivers, the information
    in the ADSPEC represents a summary,\n      computed as the ADSPEC passes each
    hop.  The size of this summary\n      remains (roughly) constant as the ADSPEC
    flows through the\n      network, giving good scaling properties.\n   From the
    point of view of RSVP objects, the breakdown is as follows:\n      - The RSVP
    SENDER_TSPEC object carries the traffic specification\n      (sender TSpec) generated
    by each data source within an RSVP\n      session.  It is transported unchanged
    through the network, and\n      delivered to both intermediate nodes and receiving
    applications.\n      - The RSVP ADSPEC object carries information which is generated
    at\n      either data sources or intermediate network elements, is flowing\n      downstream
    towards receivers, and may be used and updated inside\n      the network before
    being delivered to receiving applications.\n      This information includes both
    parameters describing the\n      properties of the data path, including the availability
    of\n      specific QoS control services, and parameters required by specific\n
    \     QoS control services to operate correctly.\n      - The RSVP FLOWSPEC object
    carries reservation request\n      (Receiver_TSpec and RSpec) information generated
    by data\n      receivers.  The information in the FLOWSPEC flows upstream towards\n
    \     data sources.  It may be used or updated at intermediate network\n      elements
    before arriving at the sending application.\n        NOTE: The existence of both
    SENDER_TSPEC and ADSPEC RSVP objects\n        is somewhat historical. Using the
    message format described in\n        this note it would be possible to place all
    of the service\n        control information carried \"downstream\" by RSVP in
    the same\n        object. However, the distinction between data which is not\n
    \       updated within the network (in the SENDER_TSPEC object) and data\n        which
    is updated within the network (in the ADSPEC object) may\n        be useful to
    an implementation in practice, and is therefore\n        retained.\n"
  - contents:
    - "2.1 Summary of operation\n   Operation proceeds as follows:\n   An application
      instance participating in an RSVP session as a data\n   sender registers with
      RSVP. One piece of information provided by the\n   application instance is the
      Sender TSpec describing the traffic the\n   application expects to generate.
      \ This information is used to\n   construct an RSVP SENDER_TSPEC object, which
      is included in RSVP PATH\n   messages generated for the application.\n   The
      sending application also constructs an initial RSVP ADSPEC\n   object.  This
      adspec carries information about the QoS control\n   capabilities and requirements
      of the sending application itself, and\n   forms the starting point for the
      accumulation of path properties\n   described below. The ADSPEC is added to
      the RSVP PATH message created\n   at the sender.\n      NOTE: For the convenience
      of application programmers, a host RSVP\n      implementation may allow the
      sending application not to provide an\n      initial adspec, instead supplying
      its own default.  This usage is\n      most likely when the application sender
      does not itself\n      participate in the end-to-end QoS control process (by
      actively\n      scheduling CPU usage and similar means) and does not itself
      care\n      which QoS control service is selected by the receivers.\n      Typically
      the default ADSPEC supplied by the host RSVP in this\n      case would support
      all QoS control services known to the host.\n      However, the exact behavior
      of this mechanism is implementation\n      dependent.\n   The ADSPEC is modified
      by subsequent network elements as the RSVP\n   PATH message moves from sender
      to receiver(s).  At each network\n   element, the ADSPEC is passed from RSVP
      to the traffic control\n   module.  The traffic control module updates the ADSPEC,
      which may\n   contain data for several QoS control services, by identifying
      the\n   services mentioned in the ADSPEC and calling each such service to\n
      \  update its portion of the ADSPEC. If the traffic control module\n   discovers
      a QoS control service mentioned in the ADSPEC but not\n   implemented by the
      network element, a flag is set to report this to\n   the receiver.  The updated
      ADSPEC is then returned to RSVP for\n   delivery to the next hop along the path.\n
      \  Upon arrival of the PATH message at an application receiver, the data\n   in
      the SENDER_TSPEC and ADSPEC objects is passed across the RSVP API\n   to the
      application.  The application (perhaps with the help of a\n   library of common
      resource-reservation functions) interprets the\n   arriving data, and uses it
      to guide the selection of resource\n   reservation parameters.  Examples of
      this include use of the arriving\n   \"PATH_MTU\" composed characterization
      parameter [RFC 2215] to\n   determine the maximum packet size parameter in the
      reservation\n   request and use of the arriving Guaranteed service \"C\" and
      \"D\"\n   parameters [RFC 2212] to calculate a mathematical bound on delivered\n
      \  packet delay when using the Guaranteed service.\n   An application receiver
      wishing to make a resource reservation\n   supplies its local RSVP with the
      necessary reservation parameters.\n   Among these are the QoS control service
      desired (Guaranteed or\n   Controlled-Load), the traffic specifier (TSpec) describing
      the level\n   of traffic for which resources should be reserved, and, if needed
      by\n   the selected QoS control service, an RSpec describing the level of\n
      \  service desired.  These parameters are composed into an RSVP FLOWSPEC\n   object
      and transmitted upstream by RSVP.\n   At each RSVP-aware point in the network,
      the SENDER_TSPECs arriving\n   in PATH messages and the FLOWSPECs arriving in
      RESV messages are used\n   to request an appropriate resource reservation from
      the desired QoS\n   control service.  State merging, message forwarding, and
      error\n   handling proceed according to the rules of the RSVP protocol.\n   Finally,
      the merged FLOWSPEC object arriving at each of an RSVP\n   session's data senders
      is delivered to the application to inform each\n   sender of the merged reservation
      request and properties of the data\n   path.\n"
    title: 2.1 Summary of operation
  - contents:
    - "2.2. RSVP support for multiple QoS control services\n   The design described
      in this note supports RSVP sessions in which the\n   receivers choose a QoS
      control service at runtime.\n   To make this possible, a receiver must have
      all the information\n   needed to choose a particular service before it makes
      the choice.\n   This means that the RSVP SENDER_TSPEC and ADSPEC objects must
      provide\n   the receivers with information for all services which might be\n
      \  chosen.\n   The Sender TSpec used by the two currently defined QoS control\n
      \  services is identical.  This simplifies the RSVP SENDER_TSPEC object,\n   which
      need carry only a single TSpec data structure in this shared\n   format.  This
      common SENDER_TSPEC can be used with either Guaranteed\n   or Controlled-Load
      service.\n   The RSVP ADSPEC carries information needed by receivers to choose
      a\n   service and determine the reservation parameters. This includes:\n      -
      Whether or not there is a non-RSVP hop along the path. If there\n      is a
      non-RSVP hop, the application's traffic will receive\n      reservationless
      best-effort service at at least one point on the\n      path.\n      - Whether
      or not a specific QoS control service is implemented at\n      every hop along
      the path. For example, a receiver might learn that\n      at least one integrated-services
      aware hop along the path supports\n      the Controlled-Load service but not
      the Guaranteed service.\n      - Default or global values for the general characterization\n
      \     parameters described in [RFC 2215]. These values describe\n      properties
      of the path itself, irrespective of the selected QoS\n      control service.
      A value reported in this section of the ADSPEC\n      applies to all services
      unless a different, service-specific value\n      is also present in the ADSPEC.\n
      \     - A service-specific value for one or more general\n      characterization
      parameters, if the service-specific value differs\n      from the default value.\n
      \     - Values of the per-service characterization parameters defined by\n      each
      supported service.\n   Data in the ADSPEC is divided into blocks or fragments,
      each of which\n   is associated with a specific service.  This allows the adspec
      to\n   carry information about multiple services, allows new services to be\n
      \  deployed in the future without immediately updating existing code,\n   and
      allows an application which will never use a particular service\n   to omit
      the ADSPEC data for that service.  The structure of the\n   ADSPEC is described
      in detail in Section 3.3.\n   A sender may indicate that a specific QoS control
      service should\n   *not* be used by the receivers within an RSVP session.  This
      is done\n   by omitting all mention of that service from the ADSPEC, as described\n
      \  in Section 3.3.  Upon arrival at a receiver, the complete absence of\n   an
      ADSPEC fragment for a specific service indicates to receivers that\n   the service
      should not be used.\n      NOTE: In RSVP Version 1, all receivers within a session
      are\n      required to choose the same QoS control service.  This restriction\n
      \     is imposed by the difficulty of merging reservations requesting\n      different
      QoS control services, and the current lack of a general\n      service replacement
      mechanism.  The restriction may be eliminated\n      in the future.\n      Considering
      this restriction, it may be useful to coordinate the\n      receivers' selection
      of a QoS control service by having the\n      sender(s) offer only one choice,
      using the ADSPEC mechanism\n      mentioned above.  All receivers must then
      select the same service.\n      Alternatively, the coordination might be accomplished
      by using a\n      higher-level session announcement and setup mechanism to inform\n
      \     the receivers of the QoS control service in use, by manual\n      configuration
      of the receivers, or by an agreement protocol\n      running among the session
      receivers themselves.\n      As with the ADSPEC, the FLOWSPEC and SENDER_TSPEC
      object formats\n      described in Section 3 are capable of carrying TSpecs
      and RSpecs\n      for more than one QoS control service in separate data fragments.\n
      \     Currently, use of a FLOWSPEC or SENDER_TSPEC containing fragments\n      for
      more than one QoS control service is not supported.  In the\n      future, this
      capability may be used to implement a more flexible\n      service request and
      replacement scheme, allowing applications to\n      obtain useful end-to-end
      QoS control when not all intermediate\n      nodes support the same set of QoS
      services.  RSVP-application APIs\n      should be designed to support passing
      SENDER_TSPEC, FLOWSPEC, and\n      ADSPEC objects of variable size and containing
      information about\n      multiple QoS control services between RSVP and its
      clients.\n"
    title: 2.2. RSVP support for multiple QoS control services
  - contents:
    - "2.3. Use of ADSPEC Information\n   This section gives some details about setting
      reservation parameters\n   and the use of information conveyed by the RSVP ADSPEC
      object.\n"
    - contents:
      - "2.3.1. Determining the availability of a QoS control service\n   The RSVP
        ADSPEC carries flag bits telling the application receivers\n   whether or
        not a completely reservation-capable path exists between\n   each sender and
        the receiver. These bits are called \"break bits\",\n   because they indicate
        breaks in the QoS control along a network path.\n   Break bits are carried
        within the header which begins each per-\n   service data fragment of an RSVP
        ADSPEC.\n   Service number 1 is used within the ADSPEC to identify a fragment\n
        \  carrying information about global parameter values that apply to all\n
        \  services (see [RFC 2215] for more details). The break bit in service\n
        \  1's per-service header is used to tell the receiver(s) whether all of\n
        \  the network elements along the path from sender to receiver support\n   RSVP
        and integrated services.  If a receiver finds this bit set, at\n   least one
        network element along the data transmission path between\n   the ADSPEC's
        sender and the receiver can not provide QoS control\n   services at all.  This
        bit corresponds to the global NON_IS_HOP\n   characterization parameter defined
        in [RFC 2215].\n      NOTE: If this bit is set, the values of all other parameters
        in\n      the ADSPEC are unreliable. The bit being set indicates that at\n
        \     least one node along the sender-receiver path did not fully\n      process
        the ADSPEC.\n   Service-specific break bits tell the receiver(s) whether all
        of the\n   network elements along the path from sender to receiver support
        a\n   particular QoS control service.  The break bit for each service is\n
        \  carried within the ADSPEC's per-service header for that service.  If\n
        \  a bit is set at the receiver, at least one network element along the\n
        \  data transmission path supports RSVP but does not support the QoS\n   control
        service corresponding to the per-service header.  These bits\n   correspond
        to the service-specific NON_IS_HOP characterization\n   parameters defined
        in [RFC 2215].\n   Section 3 gives more information about break bits.\n"
      title: 2.3.1. Determining the availability of a QoS control service
    - contents:
      - "2.3.2. Determining Path MTU\n   Both Guaranteed and Controlled-Load QoS control
        services place an\n   upper bound on packet size, and require that the application
        limit\n   the maximum size of packets subject to resource reservation. For
        both\n   services, the desired maximum packet size is a parameter of the\n
        \  reservation request, and the service will reject (with an admission\n   control
        error) reservation requests specifying a packet size larger\n   than that
        supported by the service.\n   Since RSVP reservation requests are made by
        receivers, this implies\n   that the *receivers* in an RSVP session, as well
        as the senders, need\n   to know the MTU supported by the QoS control services
        along a data\n   path.  Further, in some unusual cases the MTU supported by
        a QoS\n   control service may differ from that supported by the same router\n
        \  when providing best effort service.\n   A scalable form of MTU negotiation
        is used to address these problems.\n   MTU negotiation in an RSVP system works
        as follows:\n      - Each sending application joining an RSVP session fills
        in the M\n      (maximum packet size) parameter in its generated Sender_TSpec\n
        \     (carried from senders to receivers in a SENDER_TSPEC object) with\n
        \     the maximum packet size it wishes to send covered by resource\n      reservation.\n
        \     - Each RSVP PATH message from a sending application also carries\n      an
        ADSPEC object containing at least one PATH_MTU characterization\n      parameter.
        When it arrives at the receiver, this parameter gives\n      the minimum MTU
        at any point along the path from sender to\n      receiver.  Generally, only
        the \"global\" PATH_MTU parameter\n      (service 1, parameter 9) will be
        present, in which case its value\n      is a legal MTU for all reservation
        requests. If a service specific\n      PATH_MTU parameter is present, its
        value will be smaller than that\n      of the global parameter, and should
        be used for reservation\n      requests for that service.\n      - Each receiver
        takes the minimum of all the PATH_MTU values (for\n      the desired QoS control
        service) arriving in ADSPEC messages from\n      different senders and uses
        that value as the MTU in its\n      reservation requests.  This value is used
        to fill in the M\n      parameter of the TSpec created at the receiver.  In
        the case of a\n      FF style reservation, a receiver may also choose to use
        the MTU\n      derived from each sender's ADSPEC in the FLOWSPEC generated
        for\n      that sender, if the receiver is concerned about obtaining the\n
        \     maximum MTU on each data path. To accomodate changes in the data\n      path,
        the receiver may continue to watch the arriving ADSPECS, and\n      modify
        the reservation if a newly arriving ADSPEC indicates a\n      smaller MTU
        than is currently in use.\n      - As reservation requests (RESV messages)
        move from receivers to\n      senders, reservation parameters are merged at
        intermediate nodes.\n      As part of this merging, the smaller of two M parameters
        arriving\n      at a merge point will be forwarded in the upstream RESV message.\n
        \     - As reservation requests arrive at intermediate RSVPs, the\n      minimum
        of the receivers' requested TSpec and the sum of the\n      sender TSpecs
        is taken, and a reservation for the resulting TSpec\n      is made. The reservation
        will use the smaller of the actual path\n      MTU value computed by the receivers
        and the largest maximum packet\n      size declared by any of the sender(s).
        (The TSpec sum() function\n      result's M parameter is the max of the summed
        TSpec M parameters).\n      - When the completely merged RESV message arrives
        at each sender,\n      the MTU value (M parameter) in the merged FLOWSPEC
        object will\n      have been set to the smallest acceptable MTU of the data
        paths\n      from that sender to any session receiver. This MTU should be
        used\n      by the sending application to size its packets. Any packets larger\n
        \     than this MTU may be delivered as best-effort rather than being\n      covered
        by the session's resource reservation.\n      Note that senders do *not* adjust
        the value of their\n      Sender_TSpec's M field to match the actual packet
        size selected in\n      this step. The value of M represents the largest packet
        the sender\n      could send, not the largest packet the sender is currently\n
        \     sending.\n   Note that the scheme above will allow each sender in a
        session to use\n   the largest MTU appropriate for that sender, in cases where
        different\n   data paths or receivers have different acceptable MTU's.\n"
      title: 2.3.2. Determining Path MTU
    title: 2.3. Use of ADSPEC Information
  title: 2. Use of RSVP
- contents:
  - "3. RSVP Object Formats\n   This section specifies the detailed contents and wire
    format of RSVP\n   SENDER_TSPEC, ADSPEC, and FLOWSPEC objects for use with the\n
    \  Guaranteed and Controlled-Load QoS control services. The object\n   formats
    specified here are based on the general message construction\n   rules given in
    Appendix 1.\n"
  - contents:
    - "3.1. RSVP SENDER_TSPEC Object\n   The RSVP SENDER_TSPEC object carries information
      about a data\n   source's generated traffic. The required RSVP SENDER_TSPEC
      object\n   contains a global Token_Bucket_TSpec parameter (service_number 1,\n
      \  parameter 127, as defined in [RFC 2215]). This TSpec carries traffic\n   information
      usable by either the Guaranteed or Controlled-Load QoS\n   control services.\n
      \       31           24 23           16 15            8 7             0\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  1   | 0 (a) |    reserved           |             7 (b)             |\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  2   |    1  (c)     |0| reserved    |             6 (d)             |\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  3   |   127 (e)     |    0 (f)      |             5 (g)             |\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  4   |  Token Bucket Rate [r] (32-bit IEEE floating point number)    |\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  5   |  Token Bucket Size [b] (32-bit IEEE floating point number)    |\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  6   |  Peak Data Rate [p] (32-bit IEEE floating point number)       |\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  7   |  Minimum Policed Unit [m] (32-bit integer)                    |\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  8   |  Maximum Packet Size [M]  (32-bit integer)                    |\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \    (a) - Message format version number (0)\n     (b) - Overall length (7 words
      not including header)\n     (c) - Service header, service number 1 (default/global
      information)\n     (d) - Length of service 1 data, 6 words not including header\n
      \    (e) - Parameter ID, parameter 127 (Token_Bucket_TSpec)\n     (f) - Parameter
      127 flags (none set)\n     (g) - Parameter 127 length, 5 words not including
      header\n   In this TSpec, the parameters [r] and [b] are set to reflect the\n
      \  sender's view of its generated traffic. The peak rate parameter [p]\n   may
      be set to the sender's peak traffic generation rate (if known and\n   controlled),
      the physical interface line rate (if known), or positive\n   infinity (if no
      better value is available).  Positive infinity is\n   represented as an IEEE
      single-precision floating-point number with an\n   exponent of all ones (255)
      and a sign and mantissa of all zeros.  The\n   format of IEEE floating-point
      numbers is further summarized in [RFC\n   1832].\n   The minimum policed unit
      parameter [m] should generally be set equal\n   to the size of the smallest
      packet generated by the application. This\n   packet size includes the application
      data and all protocol headers at\n   or above the IP level (IP, TCP, UDP, RTP,
      etc.). The size given does\n   not include any link-level headers, because these
      headers will change\n   as the packet crosses different portions of the internetwork.\n
      \  The [m] parameter is used by nodes within the network to compute the\n   maximum
      bandwidth overhead needed to carry a flow's packets over the\n   particular
      link-level technology, based on the ratio of [m] to the\n   link-level header
      size. This allows the correct amount of bandwidth\n   to be allocated to the
      flow at each point in the net.  Note that\n   smaller values of this parameter
      lead to increased overhead\n   estimates, and thus increased likelyhood of a
      reservation request\n   being rejected by the node. In some cases, an application\n
      \  transmitting a low percentage of very small packets may therefore\n   choose
      to set the value of [m] larger than the actual minimum\n   transmitted packet
      size. This will increase the likelyhood of the\n   reservation succeeding, at
      the expense of policing packets of size\n   less than [m] as if they were of
      size [m].\n   Note that the an [m] value of zero is illegal. A value of zero
      would\n   indicate that no data or IP headers are present, and would give an\n
      \  infinite amount of link-level overhead.\n   The maximum packet size parameter
      [M] should be set to the size of\n   the largest packet the application might
      wish to generate, as\n   described in Section 2.3.2. This value must, by definition,
      be equal\n   to or larger than the value of [m].\n"
    title: 3.1. RSVP SENDER_TSPEC Object
  - contents:
    - "3.2. RSVP FLOWSPEC Object\n   The RSVP FLOWSPEC object carries information
      necessary to make\n   reservation requests from the receiver(s) into the network.
      This\n   includes an indication of which QoS control service is being\n   requested,
      and the parameters needed for that service.\n   The QoS control service requested
      is indicated by the service_number\n   in the FLOWSPEC's per-service header.\n"
    - contents:
      - "3.2.1 FLOWSPEC object when requesting Controlled-Load service\n   The format
        of an RSVP FLOWSPEC object originating at a receiver\n   requesting Controlled-Load
        service is shown below. Each of the TSpec\n   fields is represented using
        the preferred concrete representation\n   specified in the 'Invocation Information'
        section of [RFC 2211]. The\n   value of 5 in the per-service header (field
        (c), below) indicates\n   that Controlled-Load service is being requested.\n
        \       31           24 23           16 15            8 7             0\n
        \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  1   | 0 (a) |    reserved           |             7 (b)             |\n
        \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  2   |    5  (c)     |0| reserved    |             6 (d)             |\n
        \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  3   |   127 (e)     |    0 (f)      |             5 (g)             |\n
        \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  4   |  Token Bucket Rate [r] (32-bit IEEE floating point number)    |\n
        \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  5   |  Token Bucket Size [b] (32-bit IEEE floating point number)    |\n
        \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  6   |  Peak Data Rate [p] (32-bit IEEE floating point number)       |\n
        \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  7   |  Minimum Policed Unit [m] (32-bit integer)                    |\n
        \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  8   |  Maximum Packet Size [M]  (32-bit integer)                    |\n
        \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \    (a) - Message format version number (0)\n     (b) - Overall length (7
        words not including header)\n     (c) - Service header, service number 5 (Controlled-Load)\n
        \    (d) - Length of controlled-load data, 6 words not including\n           per-service
        header\n     (e) - Parameter ID, parameter 127 (Token Bucket TSpec)\n     (f)
        - Parameter 127 flags (none set)\n     (g) - Parameter 127 length, 5 words
        not including per-service\n           header\n   In this object, the TSpec
        parameters [r], [b], and [p] are set to\n   reflect the traffic parameters
        of the receiver's desired reservation\n   (the Reservation TSpec). The meaning
        of these fields is discussed\n   fully in [RFC 2211]. Note that it is unlikely
        to make sense for the\n   [p] term to be smaller than the [r] term.\n   The
        maximum packet size parameter [M] should be set to the value of\n   the smallest
        path MTU, which the receiver learns from information in\n   arriving RSVP
        ADSPEC objects.  Alternatively, if the receiving\n   application has built-in
        knowledge of the maximum packet size in use\n   within the RSVP session, and
        this value is smaller than the smallest\n   path MTU, [M] may be set to this
        value.  Note that requesting a value\n   of [M] larger than the service modules
        along the data path can\n   support will cause the reservation to fail. See
        section 2.3.2 for\n   further discussion of the MTU value.\n   The value of
        [m] can be chosen in several ways. Recall that when a\n   resource reservation
        is installed at each intermediate node, the\n   value used for [m] is the
        smaller of the receiver's request and the\n   values in each sender's SENDER_TSPEC.\n
        \  If the application has a fixed, known minimum packet size, than that\n
        \  value should be used for [m]. This is the most desirable case.\n   For
        a shared reservation style, the receiver may choose between two\n   options,
        or pick some intermediate point between them.\n      - if the receiver chooses
        a large value for [m], then the\n      reservation will allocate less overhead
        for link-level headers.\n      However, if a new sender with a smaller SENDER_TSPEC
        [m] joins the\n      session later, an already-installed reservation may fail
        at that\n      time.\n      - if the receiver chooses a value of [m] equal
        to the smallest\n      value which might be used by any sender, then the reservation
        will\n      be forced to allocate more overhead for link-level headers.\n
        \     However it will not fail later if a new sender with a smaller\n      SENDER_TSPEC
        [m] joins the session.\n   For a FF reservation style, if no application-specific
        value is known\n   the receiver should simply use the value of [m] arriving
        in each\n   sender's SENDER_TSPEC for its reservation request to that sender.\n"
      title: 3.2.1 FLOWSPEC object when requesting Controlled-Load service
    - contents:
      - "3.2.2. FLOWSPEC Object when Requesting Guaranteed Service\n   The format
        of an RSVP FLOWSPEC object originating at a receiver\n   requesting Guaranteed
        service is shown below. The flowspec object\n   used to request guaranteed
        service carries a TSpec and RSpec\n   specifying the traffic parameters of
        the flow desired by the\n   receiver.\n   Each of the TSpec and RSpec fields
        is represented using the preferred\n   concrete representation specified in
        the 'Invocation Information'\n   section of [RFC 2212]. The value of 2 for
        the service header\n   identifier (field (c) in the picture below) indicates
        that Guaranteed\n   service is being requested.\n        31           24 23
        \          16 15            8 7             0\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  1   | 0 (a) |    Unused             |            10 (b)             |\n
        \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  2   |    2  (c)     |0| reserved    |             9 (d)             |\n
        \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  3   |   127 (e)     |    0 (f)      |             5 (g)             |\n
        \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  4   |  Token Bucket Rate [r] (32-bit IEEE floating point number)    |\n
        \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  5   |  Token Bucket Size [b] (32-bit IEEE floating point number)    |\n
        \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  6   |  Peak Data Rate [p] (32-bit IEEE floating point number)       |\n
        \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  7   |  Minimum Policed Unit [m] (32-bit integer)                    |\n
        \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  8   |  Maximum Packet Size [M]  (32-bit integer)                    |\n
        \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  9   |     130 (h)   |    0 (i)      |            2 (j)              |\n
        \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  10  |  Rate [R]  (32-bit IEEE floating point number)                |\n
        \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  11  |  Slack Term [S]  (32-bit integer)                             |\n
        \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \    (a) - Message format version number (0)\n     (b) - Overall length (9
        words not including header)\n     (c) - Service header, service number 2 (Guaranteed)\n
        \    (d) - Length of per-service data, 9 words not including per-service\n
        \          header\n     (e) - Parameter ID, parameter 127 (Token Bucket TSpec)\n
        \    (f) - Parameter 127 flags (none set)\n     (g) - Parameter 127 length,
        5 words not including parameter header\n     (h) - Parameter ID, parameter
        130 (Guaranteed Service RSpec)\n     (i) - Parameter 130 flags (none set)\n
        \    (j) - Parameter 130 length, 2 words not including parameter header\n
        \  In this object, the TSpec parameters [r], [b], and [p] are set to\n   reflect
        the traffic parameters of the receiver's desired reservation\n   (the Reservation
        TSpec). The meaning of these fields is discussed\n   fully in [RFC 2212].
        Note that it is unlikely to make sense for the\n   [p] term to be smaller
        than the [r] term.\n   The RSpec terms [R] and [S] are selected to obtain
        the desired\n   bandwidth and delay guarantees. This selection is described
        in [RFC\n   2212].\n   The [m] and [M] parameters are set identically to those
        for the\n   Controlled-Load service FLOWSPEC, described in the previous section.\n"
      title: 3.2.2. FLOWSPEC Object when Requesting Guaranteed Service
    title: 3.2. RSVP FLOWSPEC Object
  - contents:
    - "3.3. RSVP ADSPEC Object\n   An RSVP ADSPEC object is constructed from data
      fragments contributed\n   by each service which might be used by the application.
      \ The ADSPEC\n   begins with an overall message header, followed by a fragment
      for the\n   default general parameters, followed by fragments for every QoS\n
      \  control service which may be selected by application receivers. The\n   size
      of the ADSPEC varies depending on the number and size of per-\n   service data
      fragments present and the presence of non-default\n   general parameters (described
      in Section 3.3.5).\n   The complete absence of a data fragment for a particular
      service\n   means that the application sender does not know or care about that\n
      \  service, and is a signal to intermediate nodes not to add or update\n   information
      about that service to the ADSPEC. It is also a signal to\n   application receivers
      that they should not select that service when\n   making reservations.\n   Each
      fragment present is identified by a per-service data header.\n   Each header
      contains a field identifying the service, a break bit,\n   and a length field.\n
      \  The length field allows the ADSPEC information for a service to be\n   skipped
      over by a network elements which does not recognize or\n   implement the service.
      \ When an element does this, it sets the break\n   bit, indicating that the
      service's ADSPEC data was not updated at at\n   least one hop. Note that a service's
      break bit can be set without\n   otherwise supporting the service in any way.
      \ In all cases, a network\n   element encountering a per-service data header
      it does not understand\n   simply sets bit 23 to report that the service is
      not supported, then\n   skips over the rest of the fragment.\n   Data fragments
      must always appear in an ADSPEC in service_number\n   order. In particular,
      the default general parameters fragment\n   (service_number 1) always comes
      first.\n   Within a data fragment, the service-specific data must alway come\n
      \  first, followed by any non-default general parameters which may be\n   present,
      ordered by parameter_number. The size and structure of the\n   service-specific
      data is fixed by the service definition, and does\n   not require run-time parsing.
      The remainder of the fragment, which\n   carries non-default general parameters,
      varies in size and structure\n   depending on which, if any, of these parameters
      are present. This\n   part of the fragment must be parsed by examining the per-parameter\n
      \  headers.\n   Since the overall size of each data fragment is variable, it
      is\n   always necessary to examine the length field to find the end of the\n
      \  fragment, rather than assuming a fixed-size structure.\n   3.3.1. RSVP ADSPEC
      format\n   The basic ADSPEC format is shown below. The message header and the\n
      \  default general parameters fragment are always present. The fragments\n   for
      Guaranteed or Controlled-Load service may be omitted if the\n   service is not
      to be used by the RSVP session. Additional data\n   fragments will be added
      if new services are defined.\n       31           24 23            16 15            8
      7             0\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \      | 0 (a) |      reserved         |  Msg length - 1 (b)           |\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \      |                                                               |\n       |
      \   Default General Parameters fragment (Service 1)  (c)       |\n       |    (Always
      Present)                                           |\n       |                                                               |\n
      \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n       |
      \                                                              |\n       |    Guaranteed
      Service Fragment (Service 2)    (d)             |\n       |    (Present if application
      might use Guaranteed Service)      |\n       |                                                               |\n
      \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n       |
      \                                                              |\n       |    Controlled-Load
      Service Fragment (Service 5)  (e)          |\n       |    (Present if application
      might use Controlled-Load Service) |\n       |                                                               |\n
      \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     (a)
      - Message format version number (0)\n     (b) - Overall message length not including
      header word\n     (c, d, e) - Data fragments\n"
    - contents:
      - "3.3.2. Default General Characterization Parameters ADSPEC data fragment\n
        \  All RSVP ADSPECs carry the general characterization parameters\n   defined
        in [RFC 2215].  Values for global or default general\n   parameters (values
        which apply to the all services or the path\n   itself) are carried in the
        per-service data fragment for service\n   number 1, as shown in the picture
        above.  This fragment is always\n   present, and always first in the message.\n
        \      31            24 23           16 15            8 7             0\n
        \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  1   |    1  (c)     |x| reserved    |           8 (d)               |\n
        \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  2   |    4 (e)      |    (f)        |           1 (g)               |\n
        \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  3   |        IS hop cnt (32-bit unsigned integer)                   |\n
        \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  4   |    6 (h)      |    (i)        |           1 (j)               |\n
        \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  5   |  Path b/w estimate  (32-bit IEEE floating point number)       |\n
        \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  6   |     8 (k)     |    (l)        |           1 (m)               |\n
        \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  7   |        Minimum path latency (32-bit integer)                  |\n
        \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  8   |     10 (n)    |      (o)      |           1 (p)               |\n
        \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  9   |      Composed MTU (32-bit unsigned integer)                   |\n
        \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \    (c) - Per-Service header, service number 1 (Default General\n           Parameters)\n
        \    (d) - Global Break bit ([RFC 2215], Parameter 2) (marked x) and\n           length
        of General Parameters data block.\n     (e) - Parameter ID, parameter 4 (Number-of-IS-hops
        param from\n           [RFC 2215])\n     (f) - Parameter 4 flag byte\n     (g)
        - Parameter 4 length, 1 word not including header\n     (h) - Parameter ID,
        parameter 6 (Path-BW param from [RFC 2215])\n     (i) - Parameter 6 flag byte\n
        \    (j) - Parameter 6 length, 1 word not including header\n     (k) - Parameter
        ID, parameter 8 (minimum path latency from [RFC\n           2215])\n     (l)
        - Parameter 8 flag byte\n     (m) - Parameter 8 length, 1 word not including
        header\n     (n) - Parameter ID, parameter 10 (composed path MTU from [RFC
        2215])\n     (o) - Parameter 10 flag byte\n     (p) - Parameter 10 length,
        1 word not including header\n   Rules for composing general parameters appear
        in [RFC 2215].\n   In the above fragment, the global break bit (bit 23 of
        word 1, marked\n   with (x) in the picture) is used to indicate the existence
        of a\n   network element not supporting QoS control services somewhere in
        the\n   data path.  This bit is cleared when the ADSPEC is created, and set\n
        \  to one if a network element which does not support RSVP or integrated\n
        \  services is encountered.  An ADSPEC arriving at a receiver with this\n
        \  bit set indicates that all other parameters in the ADSPEC may be\n   invalid,
        since not all network elements along the path support\n   updating of the
        ADSPEC.\n   The general parameters are updated at every network node which\n
        \  supports RSVP:\n      - When a PATH message ADSPEC encounters a network
        element\n      implementing integrated services, the portion of the ADSPEC\n
        \     associated with service number 1 is passed to the module\n      implementing
        general parameters. This module updates the global\n      general parameters.\n
        \     - When a PATH message ADSPEC encounters a network element that\n      does
        *not* support RSVP or implement integrated services, the\n      break bit
        in the general parameters service header must be set. In\n      practice,
        this bit will usually be set by another network element\n      which supports
        RSVP, but has been made aware of the gap in\n      integrated services coverage.\n
        \     - In either case, the ADSPEC is passed back to RSVP for delivery\n      to
        the next hop along the path.\n"
      title: 3.3.2. Default General Characterization Parameters ADSPEC data fragment
    - contents:
      - "3.3.3. Guaranteed Service ADSPEC data fragment\n   The Guaranteed service
        uses the RSVP ADSPEC to carry data needed to\n   compute the C and D terms
        passed from the network to the application.\n   The minimum size of a non-empty
        guaranteed service data fragment is 8\n   32-bit words.  The ADSPEC fragment
        for Guaranteed service has the\n   following format:\n       31            24
        23           16 15            8 7             0\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  1   |     2 (a)     |x|  reserved   |             N-1 (b)           |\n
        \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  2   |    133 (c)    |     0 (d)     |             1 (e)             |\n
        \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  3   |   End-to-end composed value for C [Ctot] (32-bit integer)     |\n
        \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  4   |     134 (f)   |       (g)     |             1 (h)             |\n
        \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  5   |   End-to-end composed value for D [Dtot] (32-bit integer)     |\n
        \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  6   |     135 (i)   |       (j)     |             1 (k)             |\n
        \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  7   | Since-last-reshaping point composed C [Csum] (32-bit integer) |\n
        \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  8   |     136 (l)   |       (m)     |             1 (n)             |\n
        \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  9   | Since-last-reshaping point composed D [Dsum] (32-bit integer) |\n
        \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  10  | Service-specific general parameter headers/values, if present |\n
        \   .  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   .\n   N   |                                                               |\n
        \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \    (a) - Per-Service header, service number 2 (Guaranteed)\n     (b) - Break
        bit and Length of per-service data in 32-bit\n           words not including
        header word.\n     (c) - Parameter ID, parameter 133 (Composed Ctot)\n     (d)
        - Parameter 133 flag byte\n     (e) - Parameter 133 length, 1 word not including
        header\n     (f) - Parameter ID, parameter 134 (Composed Dtot)\n     (g) -
        Parameter 134 flag byte\n     (h) - Parameter 134 length, 1 word not including
        header\n     (i) - Parameter ID, parameter 135 (Composed Csum).\n     (j)
        - Parameter 135 flag byte\n     (k) - Parameter 135 length, 1 word not including
        header\n     (l) - Parameter ID, parameter 136 (Composed Dsum).\n     (m)
        - Parameter 136 flag byte\n     (n) - Parameter 136 length, 1 word not including
        header\n   When a node which actually implements guaranteed service creates
        the\n   guaranteed service adspec fragment, the parameter values are set to\n
        \  the local values for each parameter. When an application or network\n   element
        which does not itself implement guaranteed service creates a\n   guaranteed
        service adspec fragment, it should set the values of each\n   parameter to
        zero, and set the break bit to indicate that the service\n   is not actually
        implemented at the node.\n   An application or host RSVP which is creating
        a guaranteed service\n   adspec fragment but does not itself implement the
        guaranteed service\n   may create a truncated \"empty\" guaranteed adspec
        fragment consisting\n   of only a header word:\n       31            24 23
        \          16 15            8 7             0\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  1   |     2 (a)     |1|    (b)      |         0 (c)                 |\n
        \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \    (a) - Per-Service header, service number 2 (Guaranteed)\n     (b) - Break
        bit (set, service not implemented)\n     (c) - Length of per-service data
        in 32-bit words not\n           including header word.\n   This might occur
        if the sending application or host does not do\n   resource reservation iself,
        but still wants the network to do so.\n   Note that in this case the break
        bit will always be set, since the\n   creator of the adspec fragment does
        not itself implement guaranteed\n   service.\n   When a PATH message ADSPEC
        containing a per-service header for\n   Guaranteed service encounters a network
        element implementing\n   Guaranteed service, the guaranteed service data fragment
        is updated:\n      - If the data block in the ADSPEC is an empty (header-only)
        block\n      the header-only fragment must first be expanded into the complete\n
        \     data fragment described above, with initial values of Ctot, Dtot,\n
        \     Csum, and Dsum set to zero. An empty fragment can be recognized\n      quickly
        by checking for a size field of zero.  The value of the\n      break bit in
        the header is preserved when the additional\n      Guaranteed service data
        is added. The overall message length and\n      the guaranteed-service data
        fragment size (field (b) in the\n      pictures above) are changed to reflect
        the increased message\n      length.\n      The values of Ctot, Csum, Dtot,
        and Dsum in the ADSPEC data\n      fragment are then composed with the local
        values exported by the\n      network element according to the composition
        functions defined in\n      [RFC 2212].\n      - When a PATH message ADSPEC
        with a Guaranteed service header\n      encounters a network element that
        supports RSVP but does *not*\n      implement Guaranteed service, the network
        element sets the break\n      bit in the Guaranteed service header.\n      -
        The new values are placed in the correct fields of the ADSPEC,\n      and
        the ADSPEC is passed back to RSVP for delivery to the next hop\n      along
        the path.\n   When a PATH message ADSPEC containing a Guaranteed service data\n
        \  fragment encounters a network element that supports RSVP but does\n   *not*
        implement Guaranteed service, the network element sets the\n   break bit in
        the Guaranteed service header.\n   When a PATH message ADSPEC *without* a
        Guaranteed service header\n   encounters a network element implementing Guaranteed
        service, the\n   Guaranteed service module of the network element leaves the
        ADSPEC\n   unchanged. The absence of a Guaranteed service per-service header
        in\n   the ADSPEC indicates that the application does not care about\n   Guaranteed
        service.\n"
      title: 3.3.3. Guaranteed Service ADSPEC data fragment
    - contents:
      - "3.3.4. Controlled-Load Service ADSPEC data fragment\n   Unlike the Guaranteed
        service, the Controlled-Load service does not\n   require extra ADSPEC data
        to function correctly. The only ADSPEC data\n   specific to the Controlled-Load
        service is the Controlled-Load break\n   bit.  Therefore the usual Controlled-Load
        service data block contains\n   no extra information. The minimum size of
        the controlled-load service\n   data fragment is 1 32-bit word.\n       31
        \           24 23           16 15            8 7             0\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  1   |     5 (a)     |x|  (b)        |            N-1 (c)            |\n
        \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  2   | Service-specific general parameter headers/values, if present |\n
        \   .  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \   .\n   N   |                                                               |\n
        \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \    (a) - Per-Service header, service number 5 (Controlled-Load)\n     (b)
        - Break bit\n     (c) - Length of per-service data in 32 bit words not including\n
        \          header word.\n   The Controlled-Load portion of the ADSPEC is processed
        according to\n   the following rules:\n      - When a PATH message ADSPEC
        with a Controlled-Load service header\n      encounters a network element
        implementing Controlled-Load service,\n      the network element makes no
        changes to the service header.\n      - When a PATH message ADSPEC with a
        Controlled-Load service header\n      encounters a network element that supports
        RSVP but does *not*\n      implement Controlled-Load service, the network
        element sets the\n      break bit in the Controlled-Load service header.\n
        \     - In either case, the ADSPEC is passed back to RSVP for delivery\n      to
        the next hop along the path.\n"
      title: 3.3.4. Controlled-Load Service ADSPEC data fragment
    - contents:
      - "3.3.5. Overriding Global ADSPEC Data with Service-Specific Information\n
        \  In some cases, the default values for the general parameters are not\n
        \  correct for a particular service. For example, an implementation of\n   Guaranteed
        service may accept only packets with a smaller maximum\n   size than the link
        MTU, or the percentage of outgoing link bandwidth\n   made available to the
        Controlled-Load service at a network element\n   may be administratively limited
        to less than the overall bandwidth.\n   In these cases, a service-specific
        value, as well as the default\n   value, is reported to the receiver receiving
        the ADSPEC.  Service-\n   specific information which overrides general information
        is carried\n   by a parameter with the same name as the general parameter,
        placed\n   within the data fragment of the QoS control service to which it\n
        \  applies. These service-specific values are referred to as override or\n
        \  service-specific general parameters.\n   For example, the following Controlled-Load
        ADSPEC fragment carries\n   information overriding the global path bandwidth
        estimate with a\n   different value:\n       31           24 23           16
        15            8 7             0\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  1   |     5 (a)     |x| (b)         |             2 (c)             |\n
        \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  2   |     6 (d)     |      0 (d)    |             1 (e)             |\n
        \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  3   |  Path b/w estimate for C-L service (32b IEEE FP number)       |\n
        \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \    (a) - Per-Service header, service number 5 (Controlled-Load)\n     (b)
        - Break bit\n     (c) - Length of per-service data, two words not including
        header\n     (c) - Parameter ID, parameter 6\n           (AVAILABLE_PATH_BANDWIDTH
        general parameter from [RFC 2215])\n     (d) - Parameter 6 flags (none set)\n
        \    (e) - Parameter 6 length, one word not including header\n   The presence
        of override parameters in a data fragment can be quickly\n   detected by examining
        the fragment's length field, which will be\n   larger than the \"standard\"
        length for the fragment.  Specific\n   override parameters can be easily identified
        by examining the\n   parameter headers, because they have parameter_number's
        from the\n   general parameter portion of the number space (1-127), but are
        found\n   in service-specific data blocks (those with service_numbers between
        2\n   and 254 in the per_service header field).\n   The presence of override
        parameters in a data fragment is optional. A\n   parameter header/value pair
        is added only when a particular\n   application or QoS control service wishes
        to override the global\n   value of a general parameter with a service-specific
        value.\n   As with IP options, it is only the use of these override parameters\n
        \  that is optional. All implementations must be prepared to receive and\n
        \  process override parameters.\n   The basic principle for handling override
        parameters is to use the\n   override value (local or adspec) if it exists,
        and to use the default\n   value otherwise. If a local node exports an override
        value for a\n   general parameter, but there is no override value in the arriving\n
        \  adspec, the local node adds it. The following pseudo-code fragment\n   gives
        more detail:\n   /* Adspec parameter processing rules *\n   <get arriving
        ADSPEC from RSVP>\n   for ( <each service number N with a fragment in the
        ADSPEC> ) {\n     if ( <the local node does not support the service> ) {\n
        \      <set the break bit in the service header>\n     } else {\n       for
        ( <each parameter in the data fragment for service N> ) {\n         if ( <
        the local service N supplies a value for the parameter> ) {\n            <compose
        the arriving and values and update the adspec>\n         } else {\n            /*
        Must be a general parameter, or service N would have\n             * supplied
        a value..\n             */\n            <compose the arriving value with the
        local default value\n             and update the adspec>\n         }\n       }\n
        \      for ( <any parameters supplied by the local service N\n             implementation
        but not found in the adspec> ) {\n            /*\n             * Must be an
        override value for a general parameter,\n             * or the adspec would
        have contained a value..\n             */\n            <compose the local
        override value with the arriving default\n             value (from the service
        1 data fragment) and add the parameter\n             to the adspec's service
        N fragment in parameter_number order>\n       }\n     }\n   }\n   <pass updated
        ADSPEC back to RSVP>\n   In practice, the two 'for' loops can be combined.
        Since override\n   parameters within a service's fragment are transmitted
        in numerical\n   order, it is possible to determine whether a parameter is
        present\n   without scanning the entire fragment. Also, because the data\n
        \  fragments are ordered by service_number, the default values for\n   general
        parameters will always be read before they might be needed to\n   update local
        override values in the second for loop.\n"
      title: 3.3.5. Overriding Global ADSPEC Data with Service-Specific Information
    - contents:
      - "3.3.6. Example\n   The picture below shows the complete adspec for an application
        which\n   can use either controlled-load or guaranteed service. In the example,\n
        \  data fragments are present for general parameters, guaranteed, and\n   controlled-load
        services. All fragments are of standard size, and\n   there are no override
        parameters present.\n       31            24 23           16 15            8
        7             0\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  1   | 0 (a) |    Unused             |          19 (b)               |\n
        \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  2   |    1  (c)     |x| reserved (d)|           8 (e)               |\n
        \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  3   |    4 (f)      |    (g)        |           1 (h)               |\n
        \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  4   |  zero extension of ..           IS hop cnt (16-bit unsigned)  |\n
        \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  5   |    6 (i)      |    (j)        |           1 (k)               |\n
        \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  6   |  Path b/w estimate  (32-bit IEEE floating point number)       |\n
        \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  7   |     8 (l)     |    (m)        |           1 (n)               |\n
        \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  8   |        Minimum path latency (32-bit integer)                  |\n
        \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  9   |     10 (o)    |      (p)      |           1 (q)               |\n
        \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  10  |  zero extension of ..        composed MTU (16-bit unsigned)   |\n
        \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  11  |     2 (r)     |x| reserved (s)|             8 (t)             |\n
        \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  12  |    133 (u)    |       (v)     |             1 (w)             |\n
        \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  13  |   End-to-end composed value for C [Ctot] (32-bit integer)     |\n
        \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  14  |     134 (x)   |       (y)     |             1 (z)             |\n
        \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  15  |   End-to-end composed value for D [Dtot] (32-bit integer)     |\n
        \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  16  |     135 (aa   |       (bb     |             1 (cc)            |\n
        \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  17  | Since-last-reshaping point composed C [Csum] (32-bit integer) |\n
        \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  18  |     136 (dd)  |       (ee)    |             1 (ff)            |\n
        \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  19  | Since-last-reshaping point composed D [Dsum] (32-bit integer) |\n
        \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  20  |     5 (gg     |x   0  (hh)    |             0 (ii)            |\n
        \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \    Word 1: Message Header:\n     (a) - Message header and version number\n
        \    (b) - Message length - 19 words not including header\n     Words 2-7:
        Default general characterization parameters\n     (c) - Per-Service header,
        service number 1\n           (Default General Parameters)\n     (d) - Global
        Break bit (NON_IS_HOP general parameter 2) (marked x)\n     (e) - Length of
        General Parameters data block (8 words)\n     (f) - Parameter ID, parameter
        4 (NUMBER_OF_IS_HOPS\n           general parameter)\n     (g) - Parameter
        4 flag byte\n     (h) - Parameter 4 length, 1 word not including header\n
        \    (i) - Parameter ID, parameter 6 (AVAILABLE_PATH_BANDWIDTH\n           general
        parameter)\n     (j) - Parameter 6 flag byte\n     (k) - Parameter 6 length,
        1 word not including header\n     (l) - Parameter ID, parameter 8 (MINIMUM_PATH_LATENCY\n
        \          general parameter)\n     (m) - Parameter 8 flag byte\n     (n)
        - Parameter 8 length, 1 word not including header\n     (o) - Parameter ID,
        parameter 10 (PATH_MTU general parameter)\n     (p) - Parameter 10 flag byte\n
        \    (q) - Parameter 10 length, 1 word not including header\n     Words 11-19:
        Guaranteed service parameters\n     (r) - Per-Service header, service number
        2 (Guaranteed)\n     (s) - Break bit\n     (t) - Length of per-service data,
        8 words not including header\n     (u) - Parameter ID, parameter 133 (Composed
        Ctot)\n     (v) - Composed Ctot flag byte\n     (w) - Composed Ctot length,
        1 word not including header\n     (x) - Parameter ID, parameter 134 (Composed
        Dtot)\n     (y) - Composed Dtot flag byte\n     (z) - Composed Dtot length,
        1 word not including header\n     (aa)- Parameter ID, parameter 135 (Composed
        Csum).\n     (bb)- Composed Csum flag byte\n     (cc)- Composed Csum length,
        1 word not including header\n     (dd)- Parameter ID, parameter 136 (Composed
        Dsum).\n     (ee)- Composed Dsum flag byte\n     (ff)- Composed Dsum length,
        1 word not including header\n     Word 20: Controlled-Load parameters\n     (gg
        - Per-Service header, service number 5 (Controlled-Load)\n     (hh)- Break
        bit\n     (ii)- Length of controlled-load data, 0 words not including header\n"
      title: 3.3.6. Example
    title: 3.3. RSVP ADSPEC Object
  title: 3. RSVP Object Formats
- contents:
  - "4. Security Considerations\n   The message formatting and usage rules described
    in this note raise\n   no security issues. The overall use of these rules to implement\n
    \  multiple qualities of service using RSVP and integrated services\n   scheduling
    modules introduces a new security requirement; the need to\n   control and authenticate
    access to enhanced qualities of service.\n   This requirement is discussed further
    in [RFC 2205], [RFC 2212], and\n   [RFC 2211]. [RFCRSVPMD5] describes the mechanism
    used to protect the\n   integrity of RSVP messages carrying the information described
    here.\n"
  title: 4. Security Considerations
- contents:
  - "Appendix 1: Message construction rules\n   This section gives the rule used to
    generate the object formats of\n   Section 3. It is a general wire format for
    encoding integrated\n   services data objects within setup and management protocol
    messages.\n   The format has a three-level structure:\n      - An overall message
    header carries a version number and message\n      length.  Providing this header
    in a standard format allows the\n      same code library to handle data objects
    carried by multiple setup\n      protocols.\n      - Per-service fragments carry
    information about a specific QoS\n      control service, such as guaranteed [RFC
    2212] or controlled load\n      [RFC 2211]. Each per-service fragment carries
    one or more\n      parameters.  The set of parameters present in a fragment is\n
    \     determined by the needs of the protocol in use. Examples are given\n      in
    Section 2.\n      - Parameters are the actual data used to control or monitor
    a\n      service. A parameter may be a single quantity such as an integer,\n      or
    a composite data structure such as a TSpec. The parameters\n      specific to
    a service are defined by the service specification.\n      The available general
    parameters, with definitions shared by many\n      services, are defined by [RFC
    2215].\n"
  title: 'Appendix 1: Message construction rules'
- contents:
  - "A1.1. Message Header\n   The 32-bit message header specifies the message format
    version number\n   and total length of the message. The overall message must be
    aligned\n   to a 32-bit boundary within the transport protocol's data packet.\n
    \  The message length is measured in 32-bit words *not including the\n   word
    containing the header*. This is to lower the probability of an\n   accidentally
    cleared word resulting in an infinite loop in the\n   message parser.\n   The
    Message Header is represented by a 32-bit bitfield laid out as\n   shown below
    and then encoded as an XDR unsigned integer. Encoding as\n   an XDR unsigned integer
    is equivalent to converting the bitfield from\n   the machine's native format
    to big-endian network byte order.\n   Message Header\n       MSB                                                           LSB\n
    \      31    28 27                   16 15                            0\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
    \      |   V   |    Unused             |     OVERALL LENGTH            |\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
    \  V               - Message format version; currently 0\n   OVERALL LENGTH  -
    Message length in 32-bit words not including header\n"
  title: A1.1. Message Header
- contents:
  - "A1.2. Per-Service Data Header\n   The message header is followed by one or more
    service-specific data\n   blocks, each containing the data associated with a specific
    QoS\n   control service. Each service-specific data block begins with an\n   identifying
    header. This 32-bit header contains the service number, a\n   one-bit flag (the
    \"break bit\", because it indicates a break in the\n   QoS control path) and a
    length field. The length field specifies the\n   number of 32-bit words used to
    hold data specific to this service as\n   a count of 32-bit words *not including
    the word containing the\n   header*.\n   The break bit, if set, indicates that
    the service specified by the\n   header was unsupported or unrecognized at some
    point in the message's\n   path through the network. This bit corresponds to the
    general\n   parameter NON_IS_HOP defined in [RFC 2215]. It is cleared when a\n
    \  message is first generated, and set whenever the message passes\n   through
    an element that does not recognize the service_number in the\n   per-service header.\n
    \  The Per-Service Data Header is represented by a 32-bit bitfield laid\n   out
    as shown below and then encoded as an XDR unsigned integer.\n   Per-Service Data
    Header\n       MSB                                                           LSB\n
    \      31            24 23           16 15                            0\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
    \      |  SVC_NUMBER   |B| Reserved    |            SVC_LENGTH         |\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
    \  SVC_NUMBER      - Service ID number (defined in service specification).\n   B
    \              - Break bit - service unsupported/break in path.\n   SVC_LENGTH
    \     - Service-specific data length in 32-bit words,\n                     not
    including header.\n"
  title: A1.2. Per-Service Data Header
- contents:
  - "A1.3. Parameter Header\n   The per-service header is followed by one or more
    service parameter\n   blocks, each identified by a Parameter Header. This header
    contains\n   the parameter identifier (parameter number), the length of the data\n
    \  carrying the parameter's value, and a flag field. The data field(s)\n   of
    the parameter follow.  The parameter number, as well as the\n   meaning and format
    of the data words following the header, are given\n   by the specification which
    defines the parameter.\n   The Parameter Header is represented by a 32-bit bitfield
    laid out as\n   shown below and then encoded as an XDR unsigned integer.\n   Parameter
    Header\n       MSB                                                           LSB\n
    \      31            24 23           16 15                            0\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
    \      |  PARAM_NUM    |I   FLAGS      |         PARAM_LENGTH          |\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
    \  PARAM_NUM       - Parameter number (defined in service specification)\n   FLAGS
    \          - Per-parameter flags\n   PARAM_LENGTH    - Length of per-parameter
    data in 32-bit words, not\n                     including the header word.\n   The
    following flags are currently defined in the FLAGS field:\n   I (bit 23)      -
    INVALID\n                     This flag indicates that the parameter value was\n
    \                    not correctly processed at one or more network\n                     elements
    along a data path.  It is intended for use\n                     in a possible
    future service composition scheme.\n   Other bits in the FLAGS field of the parameter
    header are currently\n   reserved, and should be set to zero.\n"
  title: A1.3. Parameter Header
- contents:
  - "A1.4. Parameter Data\n   Following the Parameter Header is the actual data representing
    the\n   parameter value. Parameter values are encoded into one or more 32-bit\n
    \  words using the XDR external data representation described in [RFC\n   1832],
    and the resulting words are placed in the message.\n   The document defining a
    parameter should provide an XDR description\n   of the parameter's data fields.
    If it does not, a description should\n   be provided in this note.\n"
  title: A1.4. Parameter Data
- contents:
  - "References\n   [RFC 2205] Braden, B., Ed., et. al., \"Resource Reservation Protocol\n
    \  (RSVP) - Version 1 Functional Specification\", RFC 2205, September\n   1997.\n
    \  [RFC 2216] Shenker, S., and J. Wroclawski. \"Network Element QoS\n   Control
    Service Specification Template\", RFC 2216, September 1997.\n   [RFC 2212] Shenker,
    S., Partridge, C., and R Guerin, \"Specification\n   of Guaranteed Quality of
    Service\", RFC 2212, September 1997.\n   [RFC 2211] Wroclawski, J., \"Specification
    of the Controlled Load\n   Quality of Service\", RFC 2211, September 1997.\n   [RFC
    2215] Shenker, S., and J. Wroclawski, \"General Characterization\n   Parameters
    for Integrated Service Network Elements\", RFC 2215,\n   September 1997.\n   [RFCRSVPMD5]
    Baker, F., \"RSVP Cryptographic Authentication\", Work in\n   Progress.\n   [RFC
    1832] Srinivansan, R., \"XDR: External Data Representation\n   Standard\", RFC
    1832, August 1995.\n"
  title: References
- contents:
  - "Author's Address\n   John Wroclawski\n   MIT Laboratory for Computer Science\n
    \  545 Technology Sq.\n   Cambridge, MA  02139\n   Phone: 617-253-7885\n   Fax:
    \  617-253-2673 (FAX)\n   EMail: jtw@lcs.mit.edu\n"
  title: Author's Address
