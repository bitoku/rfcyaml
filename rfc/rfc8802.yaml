- title: __initial_text__
  contents:
  - ''
- title: Independent Submission                                       J.J. Aranda
  contents:
  - "Independent Submission                                       J.J. Aranda\n  \
    \               The Quality for Service (Q4S) Protocol\n"
- title: Abstract
  contents:
  - "Abstract\n   This memo describes an application-level protocol for the\n   communication\
    \ of end-to-end QoS compliance information based on the\n   HyperText Transfer\
    \ Protocol (HTTP) and the Session Description\n   Protocol (SDP).  The Quality\
    \ for Service (Q4S) protocol provides a\n   mechanism to negotiate and monitor\
    \ latency, jitter, bandwidth, and\n   packet loss, and to alert whenever one of\
    \ the negotiated conditions\n   is violated.\n   Implementation details on the\
    \ actions to be triggered upon reception/\n   detection of QoS alerts exchanged\
    \ by the protocol are out of scope of\n   this document; it is either application\
    \ dependent (e.g., act to\n   increase quality or reduce bit-rate) or network\
    \ dependent (e.g.,\n   change connection's quality profile).\n   This protocol\
    \ specification is the product of research conducted over\n   a number of years;\
    \ it is presented here as a permanent record and to\n   offer a foundation for\
    \ future similar work.  It does not represent a\n   standard protocol and does\
    \ not have IETF consensus.\n"
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This document is not an Internet Standards Track specification;\
    \ it is\n   published for informational purposes.\n   This is a contribution to\
    \ the RFC Series, independently of any other\n   RFC stream.  The RFC Editor has\
    \ chosen to publish this document at\n   its discretion and makes no statement\
    \ about its value for\n   implementation or deployment.  Documents approved for\
    \ publication by\n   the RFC Editor are not candidates for any level of Internet\
    \ Standard;\n   see Section 2 of RFC 7841.\n   Information about the current status\
    \ of this document, any errata,\n   and how to provide feedback on it may be obtained\
    \ at\n   https://www.rfc-editor.org/info/rfc8802.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (c) 2020 IETF Trust and the persons identified\
    \ as the\n   document authors.  All rights reserved.\n   This document is subject\
    \ to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n\
    \   (https://trustee.ietf.org/license-info) in effect on the date of\n   publication\
    \ of this document.  Please review these documents\n   carefully, as they describe\
    \ your rights and restrictions with respect\n   to this document.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1.  Introduction\n     1.1.  Scope\n     1.2.  Motivation\n\
    \     1.3.  Summary of Features\n     1.4.  Differences from OWAMP/TWAMP\n   2.\
    \  Terminology\n   3.  Overview of Operation\n   4.  Q4S Messages\n     4.1. \
    \ Requests\n     4.2.  Responses\n     4.3.  Header Fields\n       4.3.1.  Common\
    \ Q4S Header Fields\n       4.3.2.  Specific Q4S Request Header Fields\n     \
    \  4.3.3.  Specific Q4S Response Header Fields\n     4.4.  Bodies\n       4.4.1.\
    \  Encoding\n   5.  Q4S Method Definitions\n     5.1.  BEGIN\n     5.2.  READY\n\
    \     5.3.  PING\n     5.4.  BWIDTH\n     5.5.  Q4S-ALERT\n     5.6.  Q4S-RECOVERY\n\
    \     5.7.  CANCEL\n   6.  Response Codes\n     6.1.  100 Trying\n     6.2.  Success\
    \ 2xx\n       6.2.1.  200 OK\n     6.3.  Redirection 3xx\n     6.4.  Request Failure\
    \ 4xx\n       6.4.1.  400 Bad Request\n       6.4.2.  404 Not Found\n       6.4.3.\
    \  405 Method Not Allowed\n       6.4.4.  406 Not Acceptable\n       6.4.5.  408\
    \ Request Timeout\n       6.4.6.  413 Request Entity Too Large\n       6.4.7.\
    \  414 Request-URI Too Long\n       6.4.8.  415 Unsupported Media Type\n     \
    \  6.4.9.  416 Unsupported URI Scheme\n     6.5.  Server Failure 5xx\n       6.5.1.\
    \  500 Server Internal Error\n       6.5.2.  501 Not Implemented\n       6.5.3.\
    \  503 Service Unavailable\n       6.5.4.  504 Server Time-Out\n       6.5.5.\
    \  505 Version Not Supported\n       6.5.6.  513 Message Too Large\n     6.6.\
    \  Global Failures 6xx\n       6.6.1.  600 Session Does Not Exist\n       6.6.2.\
    \  601 Quality Level Not Allowed\n       6.6.3.  603 Session Not Allowed\n   \
    \    6.6.4.  604 Authorization Not Allowed\n   7.  Protocol\n     7.1.  Protocol\
    \ Phases\n     7.2.  SDP Structure\n       7.2.1.  \"qos-level\" Attribute\n \
    \      7.2.2.  \"alerting-mode\" Attribute\n       7.2.3.  \"alert-pause\" Attribute\n\
    \       7.2.4.  \"recovery-pause\" Attribute\n       7.2.5.  \"public-address\"\
    \ Attributes\n       7.2.6.  \"latency\" Attribute\n       7.2.7.  \"jitter\"\
    \ Attribute\n       7.2.8.  \"bandwidth\" Attribute\n       7.2.9.  \"packetloss\"\
    \ Attribute\n       7.2.10. \"flow\" Attributes\n       7.2.11. \"measurement\"\
    \ Attributes\n       7.2.12. \"max-content-length\" Attribute\n     7.3.  Measurements\n\
    \       7.3.1.  Latency\n       7.3.2.  Jitter\n       7.3.3.  Bandwidth\n   \
    \    7.3.4.  Packet Loss\n     7.4.  Handshake Phase\n     7.5.  Negotiation Phase\n\
    \       7.5.1.  Stage 0: Measurement of Latencies and Jitter\n       7.5.2.  Stage\
    \ 1: Measurement of Bandwidth and Packet Loss\n       7.5.3.  Quality Constraints\
    \ Not Reached\n         7.5.3.1.  Actuator Role\n         7.5.3.2.  Policy Server\
    \ Role\n       7.5.4.  \"qos-level\" Changes\n     7.6.  Continuity Phase\n  \
    \   7.7.  Termination Phase\n       7.7.1.  Sanity Check of Quality Sessions\n\
    \     7.8.  Dynamic Constraints and Flows\n     7.9.  \"qos-level\" Upgrade and\
    \ Downgrade Operation\n   8.  General User Agent Behavior\n     8.1.  Roles in\
    \ Peer-to-Peer Scenarios\n     8.2.  Multiple Quality Sessions in Parallel\n \
    \    8.3.  General Client Behavior\n       8.3.1.  Generating Requests\n     8.4.\
    \  General Server Behavior\n   9.  Implementation Recommendations\n     9.1. \
    \ Default Client Constraints\n     9.2.  Latency and Jitter Measurements\n   \
    \  9.3.  Bandwidth Measurements\n     9.4.  Packet Loss Measurement Resolution\n\
    \     9.5.  Measurements and Reactions\n     9.6.  Instability Treatments\n  \
    \     9.6.1.  Loss of Control Packets\n       9.6.2.  Outlier Samples\n     9.7.\
    \  Scenarios\n       9.7.1.  Client to ACP\n       9.7.2.  Client to Client\n\
    \   10. Security Considerations\n     10.1.  Confidentiality Issues\n     10.2.\
    \  Integrity of Measurements and Authentication\n     10.3.  Privacy of Measurements\n\
    \     10.4.  Availability Issues\n     10.5.  Bandwidth Occupancy Issues\n   11.\
    \ Future Code Point Requirements\n     11.1.  Service Port\n   12. IANA Considerations\n\
    \   13. References\n     13.1.  Normative References\n     13.2.  Informative\
    \ References\n   Acknowledgements\n   Contributors\n   Authors' Addresses\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   The World Wide Web (WWW) is a distributed hypermedia system\
    \ that has\n   gained widespread acceptance among Internet users.  Although WWW\n\
    \   browsers support other, preexisting Internet application protocols,\n   the\
    \ primary protocol used between WWW clients and servers became the\n   HyperText\
    \ Transfer Protocol (HTTP) ([RFC7230], [RFC7231], [RFC7232],\n   [RFC7233], [RFC7234],\
    \ and [RFC7235]).  Since then, HTTP over TLS\n   (known as HTTPS and described\
    \ in [RFC2818]) has become an imperative\n   for providing secure and authenticated\
    \ WWW access.  The mechanisms\n   described in this document are equally applicable\
    \ to HTTP and HTTPS.\n   The ease of use of the Web has prompted its widespread\
    \ employment as\n   a client/server architecture for many applications.  Many\
    \ of such\n   applications require the client and the server to be able to\n \
    \  communicate with each other and exchange information with certain\n   quality\
    \ constraints.\n   Quality in communications at the application level consists\
    \ of four\n   measurable parameters:\n   Latency:  The time a message takes to\
    \ travel from source to\n         destination.  It may be approximated as RTT/2\
    \ (round-trip\n         time), assuming the networks are symmetrical.  In this\
    \ context,\n         we will consider the statistical median formula.\n   Jitter:\
    \  Latency variation.  There are some formulas to calculate\n         jitter,\
    \ and in this context, we will consider the arithmetic\n         mean formula.\n\
    \   Bandwidth:  Bit rate of communication.  To ensure quality, a protocol\n  \
    \       must ensure the availability of the bandwidth needed by the\n        \
    \ application.\n   Packet loss:  The percentage of packet loss is closely related\
    \ to\n         bandwidth and jitter.  Packet loss affects bandwidth because a\n\
    \         high packet loss sometimes implies retransmissions that also\n     \
    \    consumes extra bandwidth, other times the retransmissions are\n         not\
    \ achieved (for example, in video streaming over UDP), and\n         the information\
    \ received is less than the required bandwidth.\n         In terms of jitter,\
    \ a packet loss sometimes is seen by the\n         destination as a larger time\
    \ between arrivals, causing a jitter\n         growth.\n   Any other communication\
    \ parameter, such as throughput, is not a\n   network parameter because it depends\
    \ on protocol window size and\n   other implementation-dependent aspects.\n  \
    \ The Q4S protocol provides a mechanism for quality monitoring based on\n   an\
    \ HTTP syntax and the Session Description Protocol (SDP) in order to\n   be easily\
    \ integrated in the WWW, but it may be used by any type of\n   application, not\
    \ only those based on HTTP.  Quality requirements may\n   be needed by any type\
    \ of application that communicates using any kind\n   of protocol, especially\
    \ those with real-time constraints.  Depending\n   on the nature of each application,\
    \ the constraints may be different,\n   leading to different parameter thresholds\
    \ that need to be met.\n   Q4S is an application-level client/server protocol\
    \ that continuously\n   measures session quality for a given flow (or set of flows),\
    \ end-to-\n   end (e2e) and in real time; raising alerts if quality parameters\
    \ are\n   below a given negotiated threshold and sending recoveries when\n   quality\
    \ parameters are restored.  Q4S describes when these\n   notifications, alerts,\
    \ and recoveries need to be sent and the entity\n   receiving them.  The actions\
    \ undertaken by the receiver of the alert\n   are out of scope of the protocol.\n\
    \   Q4S is session-independent from the application flows to minimize the\n  \
    \ impact on them.  To perform the measurements, two control flows are\n   created\
    \ on both communication paths (forward and reverse directions).\n   This protocol\
    \ specification is the product of research conducted over\n   a number of years\
    \ and is presented here as a permanent record and to\n   offer a foundation for\
    \ future similar work.  It does not represent a\n   standard protocol and does\
    \ not have IETF consensus.\n"
- title: 1.1.  Scope
  contents:
  - "1.1.  Scope\n   The purpose of Q4S is to measure end-to-end network quality in\
    \ real\n   time.  Q4S does not transport any application data.  This means that\n\
    \   Q4S is designed to be used jointly with other transport protocols\n   such\
    \ as Real-time Transport Protocol (RTP) [RFC3550], Transmission\n   Control Protocol\
    \ (TCP) [RFC0793], QUIC [QUIC], HTTP [RFC7230], etc.\n   Some existent transport\
    \ protocols are focused on real-time media\n   transport and certain connection\
    \ metrics are available, which is the\n   case of RTP and RTP Control Protocol\
    \ (RTCP) [RFC3550].  Other\n   protocols such as QUIC provide low connection latencies\
    \ as well as\n   advanced congestion control.  These protocols transport data\n\
    \   efficiently and provide a lot of functionalities.  However, there are\n  \
    \ currently no other quality measurement protocols offering the same\n   level\
    \ of function as Q4S.  See Section 1.4 for a discussion of the\n   IETF's quality\
    \ measurement protocols, One-Way Active Measurement\n   Protocol (OWAMP) and Two-Way\
    \ Active Measurement Protocol (TWAMP).\n   Q4S enables applications to become\
    \ reactive under e2e network quality\n   changes.  To achieve it, an independent\
    \ Q4S stack application must\n   run in parallel with the target application.\
    \  Then, Q4S metrics may\n   be used to trigger actions on the target application,\
    \ such as speed\n   adaptation to latency in multiuser games, bitrate control\
    \ at\n   streaming services, intelligent commutation of delivery node at\n   Content\
    \ Delivery Networks, and whatever the target application\n   allows.\n"
- title: 1.2.  Motivation
  contents:
  - "1.2.  Motivation\n   Monitoring quality of service (QoS) in computer networks\
    \ is useful\n   for several reasons:\n   *  It enables real-time services and\
    \ applications to verify whether\n      network resources achieve a certain QoS\
    \ level.  This helps real-\n      time services and applications to run over the\
    \ Internet, allowing\n      the existence of Application Content Providers (ACPs),\
    \ which offer\n      guaranteed real-time services to the end users.\n   *  Real-time\
    \ monitoring allows applications to adapt themselves to\n      network conditions\
    \ (application-based QoS) and/or request more\n      network quality from the\
    \ Internet Service Provider (ISP) (if the\n      ISP offers this possibility).\n\
    \   *  Monitoring may also be required by peer-to-peer (P2P) real-time\n     \
    \ applications for which Q4S can be used.\n   *  Monitoring enables ISPs to offer\
    \ QoS to any ACP or end user\n      application in an accountable way.\n   * \
    \ Monitoring enables e2e negotiation of QoS parameters,\n      independently of\
    \ the ISPs of both endpoints.\n   A protocol to monitor QoS must address the following\
    \ issues:\n   *  Must be ready to be used in conjunction with current standard\n\
    \      protocols and applications, without forcing a change on them.\n   *  Must\
    \ have a formal and compact way to specify quality constraints\n      desired\
    \ by the application to run.\n   *  Must have measurement mechanisms that avoid\
    \ application disruption\n      and minimize network resources consumption.\n\
    \   *  Must have specific messages to alert about the violation of\n      quality\
    \ constraints in different directions (forward and reverse)\n      because network\
    \ routing may not be symmetrical, and of course,\n      quality constraints may\
    \ not be symmetrical.\n   *  After having alerted about the violation of quality\
    \ constraints,\n      must have specific messages to inform about the recovery\
    \ of\n      quality constraints in corresponding directions (forward and\n   \
    \   reverse).\n   *  Must protect the data (constraints, measurements, QoS levels\n\
    \      demanded from the network) in order to avoid the injection of\n      malicious\
    \ data in the measurements.\n"
- title: 1.3.  Summary of Features
  contents:
  - "1.3.  Summary of Features\n   The Quality for Service (Q4S) protocol is a message-oriented\n\
    \   communication protocol that can be used in conjunction with any other\n  \
    \ application-level protocol.  Q4S is a measurement protocol.  Any\n   action\
    \ taken derived from its measurements are out of scope of the\n   protocol.  These\
    \ actions depend on the application provider and may\n   be application-level\
    \ adaptive reactions, may involve requests to the\n   ISP, or whatever the application\
    \ provider decides.\n   The benefits in quality measurements provided by Q4S can\
    \ be used by\n   any type of application that uses any type of protocol for data\n\
    \   transport.  It provides a quality monitoring scheme for any\n   communication\
    \ that takes place between the client and the server, not\n   only for the Q4S\
    \ communication itself.\n   Q4S does not establish multimedia sessions, and it\
    \ does not transport\n   application data.  It monitors the fulfillment of the\
    \ quality\n   requirements of the communication between the client and the server;\n\
    \   therefore, it does not impose any restrictions on the type of\n   application,\
    \ protocol, or usage of the monitored quality connection.\n   Some applications\
    \ may vary their quality requirements dynamically for\n   any given quality parameter.\
    \  Q4S is able to adapt to the changing\n   application needs, modifying the parameter\
    \ thresholds to the new\n   values and monitoring the network quality according\
    \ to the new\n   quality constraints.  It will raise alerts if the new constraints\
    \ are\n   violated.\n   The Q4S session lifetime is composed of four phases with\
    \ different\n   purposes: Handshake, Negotiation, Continuity, and Termination.\n\
    \   Negotiation and Continuity phases perform network parameter\n   measurements\
    \ per a negotiated measurement procedure.  Different\n   measurement procedures\
    \ could be used inside Q4S, although one default\n   measurement mechanism is\
    \ needed for compatibility reasons and is the\n   one defined in this document.\
    \  Basically, Q4S defines how to\n   transport application quality requirements\
    \ and measurement results\n   between a client and server and how to provide monitoring\
    \ and\n   alerting, too.\n   Q4S must be executed just before starting a client-server\
    \ application\n   that needs a quality connection in terms of latency, jitter,\n\
    \   bandwidth, and/or packet loss.  Once the client and server have\n   succeeded\
    \ in establishing communication under quality constraints,\n   the application\
    \ can start, and Q4S continues measuring and alerting\n   if necessary.\n   The\
    \ quality parameters can be suggested by the client in the first\n   message of\
    \ the Handshake phase, but it is the server that accepts\n   these parameter values\
    \ or forces others.  The server is in charge of\n   deciding the final values\
    \ of quality connection.\n"
- title: 1.4.  Differences from OWAMP/TWAMP
  contents:
  - "1.4.  Differences from OWAMP/TWAMP\n   OWAMP [RFC4656] and TWAMP [RFC5357] are\
    \ two protocols to measure\n   network quality in terms of RTT, but they have\
    \ a different goal than\n   Q4S.  The main difference is the scope: Q4S is designed\
    \ to assist\n   reactive applications, whereas OWAMP/TWAMP is designed to measure\n\
    \   just network delay.\n   The differences can be summarized in the following\
    \ points:\n   *  OWAMP and TWAMP are not intended for measuring availability of\n\
    \      resources (certain bandwidth availability, for example) but only\n    \
    \  RTT.  However, Q4S is intended for measuring required bandwidth,\n      packet\
    \ loss, jitter, and latency in both directions.  Available\n      bandwidth is\
    \ not measured by Q4S, but bandwidth required for a\n      specific application\
    \ is.\n   *  OWAMP and TWAMP do not have responsivity control (which defines\n\
    \      the speed of protocol reactions under network quality changes)\n      because\
    \ these protocols are designed to measure network\n      performance, not to assist\
    \ reactive applications, and do not\n      detect the fluctuations of quality\
    \ within certain time intervals\n      to take reactive actions.  However, responsivity\
    \ control is a key\n      feature of Q4S.\n   *  OWAMP and TWAMP are not intended\
    \ to run in parallel with reactive\n      applications, but the Q4S protocol's\
    \ goal is to run in parallel\n      and assist reactive applications in making\
    \ decisions based on Q4S-\n      ALERT packets, which may trigger actions.\n"
- title: 2.  Terminology
  contents:
  - "2.  Terminology\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\"\
    , \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"NOT RECOMMENDED\"\
    , \"MAY\", and\n   \"OPTIONAL\" in this document are to be interpreted as described\
    \ in\n   BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all\n\
    \   capitals, as shown here.\n"
- title: 3.  Overview of Operation
  contents:
  - "3.  Overview of Operation\n   This section introduces the basic operation of\
    \ Q4S using simple\n   examples.  This section is of a tutorial nature and does\
    \ not contain\n   any normative statements.\n   The first example shows the basic\
    \ functions of Q4S: communication\n   establishment between a client and a server,\
    \ quality requirement\n   negotiations for the requested application, application\
    \ start and\n   continuous quality parameter measurements, and finally communication\n\
    \   termination.\n   The client triggers the establishment of the communication\
    \ by\n   requesting a specific service or application from the server.  This\n\
    \   first message must have a special URI [RFC3986], which may force the\n   use\
    \ of the Q4S protocol if it is implemented in a standard web\n   browser.  This\
    \ message consists of a Q4S BEGIN method, which can\n   optionally include a proposal\
    \ for the communication quality\n   requirements in an SDP body.  This option\
    \ gives the client a certain\n   negotiation capacity about quality requirements,\
    \ but it will be the\n   server who finally decides the stated requirements.\n\
    \   This request is answered by the server with a Q4S 200 OK response\n   letting\
    \ the client know that it accepts the request.  This response\n   message must\
    \ contain an SDP body with the following:\n   *  The assigned Q4S sess-id.\n \
    \  *  The quality constraints required by the requested application.\n   *  The\
    \ measurement procedure to use.\n   *  \"alerting-mode\" attribute: There are\
    \ two different scenarios for\n      sending alerts that trigger actions either\
    \ on the network or in\n      the application when measurements identify violated\
    \ quality\n      constraints.  In both cases, alerts are triggered by the server.\n\
    \      (a)  Q4S-aware-network scenario: The network is Q4S aware and\n       \
    \    reacts by itself to these alerts.  In this scenario, Q4S-\n           ALERT\
    \ messages are sent by the server to the client, and\n           network elements\
    \ inspect and process these alert messages.\n           The alerting mode in this\
    \ scenario is called Q4S-aware-\n           network alerting mode.\n      (b)\
    \  Reactive scenario: As shown in Figure 1, the network is not\n           Q4S\
    \ aware.  In this scenario, alert notifications are sent to\n           a specific\
    \ node, called an Actuator, which is in charge of\n           making decisions\
    \ regarding what actions to trigger: either to\n           change application\
    \ behavior to adapt it to network conditions\n           and/or invoke a network\
    \ policy server in order to reconfigure\n           the network and request better\
    \ quality for application flows.\n                    |  App |<----- app flows---------->|Application|\n\
    \                    |Client|                           +-----------+\n      \
    \              | Q4S  |<----Q4S---->| Q4S  |<----->|Actuator|\n              \
    \      |Client|             |Server|       +--------+\n                      \
    \      Figure 1: Reactive Scenario\n           The format of messages exchanged\
    \ between the server stack and\n           the Actuator doesn't follow Q4S codification\
    \ rules; their\n           format will be implementation dependent.  In this way,\
    \ we\n           will call the messages sent from the server stack to the\n  \
    \         Actuator \"notifications\" (e.g., alert notifications) and the\n   \
    \        messages sent from the Actuator to the server stack in\n           response\
    \ to notifications \"acknowledges\" (e.g., alert\n           acknowledges).\n\
    \   *  \"alert-pause\" attribute: The amount of time between consecutive\n   \
    \   alerts.  In the Q4S-aware-network scenario, the server has to wait\n     \
    \ this period of time between Q4S-ALERT messages sent to the client.\n      In\
    \ the Reactive scenario, the server stack has to wait this period\n      of time\
    \ between alert notifications sent to the Actuator.\n      Measurements are not\
    \ stopped in Negotiation or Continuity phases\n      during this period of time,\
    \ but no alerts are sent, even with\n      violated network quality constraints,\
    \ in order to leave time for\n      network reconfiguration or for application\
    \ adjustments.\n   *  \"recovery-pause\" attribute: The amount of time the Q4S\
    \ server\n      waits before trying to recover the initial \"qos-level\"\n   \
    \   (Section 7.2.1).  After having detected violation of quality\n      constraints\
    \ several times, the \"qos-level\" will have been\n      increased accordingly.\
    \  If this violation detection finally stops,\n      the server waits for a period\
    \ of time (recovery time), and if the\n      situation persists, it tries to recover\
    \ to previous \"qos-level\"\n      values gradually by sending Q4S-RECOVERY messages\
    \ to the client in\n      the Q4S-aware-network scenario, or recovery notifications\
    \ to the\n      Actuator in the Reactive scenario (Section 7.9).\n   It is important\
    \ to highlight that any Q4S 200 OK response sent by the\n   server to the client\
    \ at any time during the life of a quality session\n   may contain an SDP body\
    \ with new values of quality constraints\n   required by the application.  Depending\
    \ on the phase and the state of\n   the measurement procedure within the specific\
    \ phase, the client will\n   react accordingly to take into account the new quality\
    \ constraints in\n   the measurement procedure.\n   Once the communication has\
    \ been established (i.e., the Handshake\n   phase is finished), the protocol will\
    \ verify that the communication\n   path between the client and the server meets\
    \ the quality constraints\n   in both directions, from and to the server (Negotiation\
    \ phase).  This\n   Negotiation phase requires taking measurements of the quality\n\
    \   parameters: latencies, jitter, bandwidth, and packet loss.  This\n   phase\
    \ is initiated with a client message containing a Q4S READY\n   method, which\
    \ will be answered by the server with a Q4S 200 OK\n   response.\n   Negotiation\
    \ measurements are achieved in two sequential stages:\n   Stage 0:  latency and\
    \ jitter measurements\n   Stage 1:  bandwidth and packet loss measurements\n \
    \  Stage 0 measurements are taken through Q4S PING messages sent from\n   both\
    \ the client and the server.  All Q4S PING requests will be\n   answered by Q4S\
    \ 200 OK messages to allow for bidirectional\n   measurements.\n   Different client\
    \ and server implementations may send a different\n   number of PING messages\
    \ for measuring, although at least 255 messages\n   should be considered to perform\
    \ the latency measurement.  The Stage 0\n   measurements only may be considered\
    \ ended when neither client nor\n   server receive new PING messages after an\
    \ implementation-dependent\n   guard time.  Only after Stage 0 has ended, can\
    \ the client send a\n   \"READY 1\" message.\n   After a pre-agreed number of\
    \ measurements have been performed,\n   determined by the measurement procedure\
    \ sent by the server, three\n   scenarios may be possible:\n   (a)  Measurements\
    \ do not meet the requirements: in this case, the\n        stage 0 is repeated\
    \ after sending an alert from the server to\n        the client or from the server\
    \ stack to the Actuator, depending\n        on the alerting mode defined in the\
    \ Handshake phase.  Notice\n        that measurements continue to be taken but\
    \ no alerts are sent\n        during the \"alert-pause\" time.  In the Reactive\
    \ scenario, the\n        Actuator will decide either to forward the alert notification\
    \ to\n        the network policy server or to the application, depending on\n\
    \        where reconfiguration actions have to be taken.\n   (b)  Measurements\
    \ do meet the requirements: in this case, client\n        moves to stage 1 by\
    \ sending a new READY message.\n   (c)  At any time during the measurement procedure,\
    \ the Q4S 200 OK\n        message sent by the server to the client, in response\
    \ to a Q4S\n        PING message, contains an SDP body with new values of quality\n\
    \        constraints required by the application.  This means the\n        application\
    \ has varied their quality requirements dynamically;\n        therefore, quality\
    \ thresholds used while monitoring quality\n        parameters have to be changed\
    \ to the new constraints.  In this\n        case, the client moves to the beginning\
    \ of Stage 0 for\n        initiating the negotiation measurements again.\n   Stage\
    \ 1 is optional.  Its purpose is to measure the availability of\n   application-needed\
    \ bandwidth.  If the \"bandwidth\" attribute is set to\n   zero kbps in the SDP,\
    \ the client can skip stage 1 by sending a \"READY\n   2\" message after completion\
    \ of stage 0.  Stage 1 measurements are\n   achieved through Q4S BWIDTH messages\
    \ sent from both the client and\n   the server.  Unlike PING messages, Q4S BWIDTH\
    \ requests will not be\n   answered.\n   If Stage 0 and 1 meet the application\
    \ quality constraints, the\n   application may start.  Q4S will enter the Continuity\
    \ phase by\n   measuring the network quality parameters through the Q4S PING message\n\
    \   exchange on both connection paths and raising alerts in case of\n   violation.\n\
    \   Once the client wants to terminate the quality session, it sends a\n   Q4S\
    \ CANCEL message, which will be acknowledged by the server with\n   another Q4S\
    \ CANCEL message.  Termination of quality sessions are\n   always initiated by\
    \ the client because Q4S TCP requests follow the\n   client/server schema.\n \
    \  Figure 2 depicts the message exchange in a successful scenario.\n         \
    \      | Client                             Server |\n   Handshake   |     ---------\
    \ Q4S BEGIN ----------->      |\n               |     <-------- Q4S 200 OK -----------\
    \      |\n   Negotiation |                                           |\n   (Stage\
    \ 0)   |     --------- Q4S READY 0---------->      |\n               |     <--------\
    \ Q4S 200 OK -----------      |\n               |     --------- Q4S PING ------------>\
    \      |\n               |     <-------- Q4S 200 OK -----------      |\n     \
    \          |     <-------- Q4S PING -------------      |\n               |   \
    \   -------- Q4S 200 OK ---------->      |\n               |     --------- Q4S\
    \ PING ------------>      |\n               |     <-------- Q4S PING -------------\
    \      |\n               |     --------- Q4S 200 OK ---------->      |\n     \
    \          |     <-------- Q4S 200 OK -----------      |\n   Negotiation |   \
    \                                        |\n   (Stage 1)   |     --------- Q4S\
    \ READY 1---------->      |\n               |     <-------- Q4S 200 OK -----------\
    \      |\n               |     --------- Q4S BWITDH ---------->      |\n     \
    \          |     <-------- Q4S BWIDTH------------      |\n               |   \
    \  --------- Q4S BWITDH ---------->      |\n               |     <-------- Q4S\
    \ BWIDTH------------      |\n   Continuity  |     --------- Q4S READY 2 --------->\
    \      |\n               |     <-------- Q4S 200 OK -----------      | app start\n\
    \               |     --------- Q4S PING ------------>      |\n              \
    \ |     <-------- Q4S 200 OK -----------      |\n               |     <--------\
    \ Q4S PING -------------      |\n               |      -------- Q4S 200 OK ---------->\
    \      |\n   Termination |     --------- Q4S CANCEL ---------->      | app end\n\
    \               |     <-------- Q4S CANCEL -----------      |\n              \
    \   Figure 2: Successful Q4S Message Exchange\n   Both client and server measurements\
    \ are included in the PING and\n   BWIDTH messages, allowing both sides of the\
    \ communication channel to\n   be aware of all measurements in both directions.\n\
    \   The following two examples show the behavior of the Q4S protocol when\n  \
    \ quality constraints are violated, and alerts are generated; and,\n   later on,\
    \ when the violation of quality constraints stops leading to\n   the execution\
    \ of the recovery process.  The first example (Figure 3)\n   shows the Q4S-aware-network\
    \ alerting mode scenario:\n               | Client                           \
    \  Server |\n   Handshake   |     --------- Q4S BEGIN ----------->      |\n  \
    \             |     <-------- Q4S 200 OK -----------      |\n   Negotiation |\
    \                                           |\n   (Stage 0)   |     ---------\
    \ Q4S READY 0---------->      |\n               |     <-------- Q4S 200 OK -----------\
    \      |\n               |     --------- Q4S PING ------------>      |\n     \
    \          |     <-------- Q4S 200 OK -----------      |\n               |   \
    \  <-------- Q4S PING -------------      |\n               |      -------- Q4S\
    \ 200 OK ---------->      |\n               |     <-------- Q4S-ALERT ------------\
    \      |\n               |     -------- Q4S-ALERT ------------>      |\n     \
    \          |          (alert-pause start)              |\n   Repetition  |   \
    \                                        |\n   of Stage 0  |     --------- Q4S\
    \ READY 0---------->      |\n               |     <-------- Q4S 200 OK -----------\
    \      |\n               |     --------- Q4S PING ------------>      |\n     \
    \          |     <-------- Q4S 200 OK -----------      |\n               |   \
    \  <-------- Q4S PING -------------      |\n   Negotiation |                 \
    \                          |\n   (Stage 1)   |     --------- Q4S READY 1---------->\
    \      |\n               |     <-------- Q4S 200 OK -----------      |\n     \
    \          |     --------- Q4S BWITDH ---------->      |\n               |   \
    \  <-------- Q4S BWIDTH------------      |\n   Continuity  |     --------- Q4S\
    \ READY 2 --------->      |\n               |     <-------- Q4S 200 OK -----------\
    \      | app start\n               |     --------- Q4S PING ------------>    \
    \  |\n               |     <-------- Q4S 200 OK -----------      |\n         \
    \      |     <-------- Q4S PING -------------      |\n               |      --------\
    \ Q4S 200 OK ---------->      |\n               |(alert-pause expires &      \
    \               |\n               |     <-------- Q4S-ALERT ------------     \
    \ |\n               |     --------- Q4S-ALERT ----------->      |\n          \
    \     |           (alert-pause start)             |\n               |     ---------\
    \ Q4S PING ------------>      |\n               |     <-------- Q4S 200 OK -----------\
    \      |\n               |     <-------- Q4S PING -------------      |\n     \
    \          |     --------- Q4S 200 OK ---------->      |\n               |(alert-pause\
    \ expires &                     |\n               |     <-------- Q4S-ALERT ------------\
    \      |\n               |     --------- Q4S-ALERT ----------->      |\n     \
    \          |           (alert-pause)                   |\n               |   \
    \  --------- Q4S PING ------------>      |\n               |     <-------- Q4S\
    \ 200 OK -----------      |\n               |     <-------- Q4S PING -------------\
    \      |\n               |      -------- Q4S 200 OK ---------->      |\n     \
    \          |(alert-pause expires &                     |\n               |   \
    \        (recovery-pause start)          |\n               |     --------- Q4S\
    \ PING ------------>      |\n               |     <-------- Q4S 200 OK -----------\
    \      |\n               |     <-------- Q4S PING -------------      |\n     \
    \          |      -------- Q4S 200 OK ---------->      |\n               |(recovery-pause\
    \ expires &                  |\n               |     -------- Q4S-RECOVERY ----------->\
    \    |\n               |          (recovery-pause start)           |\n       \
    \        |     --------- Q4S PING ------------>      |\n               |     <--------\
    \ Q4S 200 OK -----------      |\n               |     <-------- Q4S PING -------------\
    \      |\n               |      -------- Q4S 200 OK ---------->      |\n   Termination\
    \ |     --------- Q4S CANCEL ---------->      | app end\n               |    \
    \ <-------- Q4S CANCEL -----------      |\n                 Figure 3: Q4S-Aware-Network\
    \ Alerting Mode\n   In this Q4S-aware-network alerting mode scenario, the server\
    \ may send\n   Q4S alerts to the client at any time upon detection of violated\n\
    \   quality constraints.  This alerting exchange must not interrupt the\n   continuity\
    \ quality parameter measurements between client and server.\n   The second example\
    \ depicted in Figure 4 represents the Reactive\n   scenario, in which alert notifications\
    \ are sent from the server stack\n   to the Actuator, which is in charge of deciding\
    \ to act over\n   application behavior and/or to invoke a network policy server.\
    \  The\n   Actuator is an entity that has a defined set of different quality\n\
    \   levels and decides how to act depending on the actions stated for\n   each\
    \ of these levels; it can take actions for making adjustments on\n   the application,\
    \ or it can send a request to the policy server for\n   acting on the network.\
    \  The policy server also has a defined set of\n   different quality levels previously\
    \ agreed upon between the\n   Application Content Provider and the ISP.  The Reactive\
    \ alerting mode\n   is the default mode.\n               | Client            \
    \   Server      Actuator |\n   Handshake   |   ----- Q4S BEGIN ----->        \
    \          |\n               |   <---- Q4S 200 OK -----                  |\n \
    \  Negotiation |                                           |\n   (Stage 0)   |\
    \   ----- Q4S READY 0---->                  |\n               |   <---- Q4S 200\
    \ OK -----                  |\n               |   ----- Q4S PING ------>     \
    \             |\n               |   <---- Q4S 200 OK -----                  |\n\
    \               |   <---- Q4S PING -------                  |\n              \
    \ |    ---- Q4S 200 OK ---->                  |\n               |  (alert-pause\
    \ start)                      |\n   Repetition  |                            \
    \               |\n   of Stage 0  |   ----- Q4S READY 0---->                 \
    \ |\n               |   <---- Q4S 200 OK -----                  |\n          \
    \     |   ----- Q4S PING ------>                  |\n               |   <----\
    \ Q4S 200 OK -----                  |\n               |   <---- Q4S PING -------\
    \                  |\n               |(alert-pause expires &                 \
    \    |\n               |   ----- Q4S PING ------>                  |\n       \
    \        |   <---- Q4S 200 OK -----                  |\n               |   <----\
    \ Q4S PING -------                  |\n   Negotiation |                      \
    \                     |\n   (Stage 1)   |   ----- Q4S READY 1---->           \
    \       |\n               |   <---- Q4S 200 OK -----                  |\n    \
    \           |   ----- Q4S BWITDH ---->                  |\n               |  \
    \ <---- Q4S BWIDTH------                  |\n   Continuity  |   ----- Q4S READY\
    \ 2 --->                  |\n               |   <---- Q4S 200 OK -----       \
    \           | app start\n               |(alert-pause expires &              \
    \       |\n               |(recovery-pause start)                     |\n    \
    \           |   ----- Q4S PING ------>                  |\n               |  \
    \ <---- Q4S 200 OK -----                  |\n               |   <---- Q4S PING\
    \ -------                  |\n               |   ----- Q4S PING ------>      \
    \            |\n               |(recovery-pause expires &                  |\n\
    \               |(recovery-pause start)                     |\n              \
    \ |   <---- Q4S 200 OK -----                  |\n               |   <---- Q4S\
    \ PING -------                  |\n               |   ----- Q4S 200 OK ----> \
    \                 |\n               |   ----- Q4S PING ------>               \
    \   |\n   Termination |   ----- Q4S CANCEL ---->                  | app end\n\
    \               |   <---- Q4S CANCEL -----                  |\n              \
    \        Figure 4: Reactive Alerting Mode\n   At the end of any stage of the Negotiation\
    \ phase, the server sends an\n   alert notification to the Actuator if quality\
    \ constraints are\n   violated.  During the period of time defined by the \"alert-pause\"\
    \n   attribute, no further alert notifications are sent, but measurements\n  \
    \ are not interrupted.  This way, both the client and the server will\n   detect\
    \ network improvements as soon as possible.  In a similar way\n   during the Continuity\
    \ phase, the server may send alert notifications\n   at any time to the Actuator\
    \ upon detection of violated quality\n   constraints.  This alerting exchange\
    \ must not interrupt the\n   continuity measurements between client and server.\n\
    \   Finally, in the Termination phase, Q4S CANCEL messages sent from the\n   client\
    \ to the server must be forwarded from the server to the\n   Actuator in order\
    \ to release possible assigned resources for the\n   session.\n"
- title: 4.  Q4S Messages
  contents:
  - "4.  Q4S Messages\n   Q4S is a text-based protocol and uses the UTF-8 charset\
    \ [RFC3629].  A\n   Q4S message is either a request or a response.\n   Both request\
    \ and response messages use the basic format of Internet\n   Message Format [RFC5322].\
    \  Both types of messages consist of a start-\n   line, one or more header fields,\
    \ an empty line indicating the end of\n   the header fields, and an optional message-body.\
    \  This document uses\n   ABNF notation [RFC5234] for the definitions of the syntax\
    \ of\n   messages.\n   The start-line, each message-header line, and the empty\
    \ line MUST be\n   terminated by a carriage-return line-feed sequence (CRLF).\
    \  Note that\n   the empty line MUST be present even if the message-body is not.\n\
    \         generic-message  =  start-line CRLF\n                             *message-header\
    \ CRLF\n                             CRLF\n                             [ message-body\
    \ ]\n         start-line       =  Request-Line / Status-Line\n   Much of Q4S's\
    \ messages and header field syntax are identical to\n   HTTP/1.1.  However, Q4S\
    \ is not an extension of HTTP.\n"
- title: 4.1.  Requests
  contents:
  - "4.1.  Requests\n   Q4S requests are distinguished by having a Request-Line for\
    \ a start-\n   line.  A Request-Line contains a method name, a Request-URI, and\
    \ the\n   protocol version separated by a single space (SP) character.\n   The\
    \ Request-Line ends with CRLF.  No CR or LF are allowed except in\n   the end-of-line\
    \ CRLF sequence.  No linear whitespace (LWSP) is\n   allowed in any of the elements.\n\
    \      Request-Line  =  Method SP Request-URI SP Q4S-Version CRLF\n   Method:\
    \  This specification defines seven methods: BEGIN for starting\n         and\
    \ negotiating quality sessions, READY for synchronization of\n         measurements,\
    \ PING and BWIDTH for quality measurements\n         purposes, CANCEL for terminating\
    \ sessions, Q4S-ALERT for\n         reporting quality violations, and Q4S-RECOVERY\
    \ for reporting\n         quality recovery.\n   Request-URI:  The Request-URI\
    \ is a Q4S URI [RFC3986] as described in\n         Section 7.4.  The Request-URI\
    \ MUST NOT contain unescaped spaces\n         or control characters and MUST NOT\
    \ be enclosed in \"<>\".\n   Q4S-Version:  Both request and response messages\
    \ include the version\n         of Q4S in use.  To be compliant with this specification,\n\
    \         applications sending Q4S messages MUST include a Q4S-Version of\n  \
    \       \"Q4S/1.0\".  The Q4S-Version string is case insensitive, but\n      \
    \   implementations MUST send uppercase.  Unlike HTTP/1.1, Q4S\n         treats\
    \ the version number as a literal string.  In practice,\n         this should\
    \ make no difference.\n"
- title: 4.2.  Responses
  contents:
  - "4.2.  Responses\n   Q4S responses are distinguished from requests by having a\
    \ Status-Line\n   as their start-line.  A Status-Line consists of the protocol\
    \ version\n   followed by a numeric Status-Code and its associated textual phrase,\n\
    \   with each element separated by a single SP character.  No CR or LF is\n  \
    \ allowed except in the final CRLF sequence.\n      Status-Line  =  Q4S-Version\
    \ SP Status-Code SP Reason-Phrase CRLF\n   The Status-Code is a 3-digit integer\
    \ result code that indicates the\n   outcome of an attempt to understand and satisfy\
    \ a request.  The\n   Reason-Phrase is intended to give a short textual description\
    \ of the\n   Status-Code.  The Status-Code is intended for use by automata,\n\
    \   whereas the Reason-Phrase is intended for the human user.  A client\n   is\
    \ not required to examine or display the Reason-Phrase.\n   While this specification\
    \ suggests specific wording for the Reason-\n   Phrase, implementations MAY choose\
    \ other text, for example, in the\n   language indicated in the Accept-Language\
    \ header field of the\n   request.\n   The first digit of the Status-Code defines\
    \ the class of response.\n   The last two digits do not have any categorization\
    \ role.  For this\n   reason, any response with a status code between 100 and\
    \ 199 is\n   referred to as a \"1xx response\", any response with a status code\n\
    \   between 200 and 299 as a \"2xx response\", and so on.  Q4S/1.0 allows\n  \
    \ following values for the first digit:\n   1xx:  Provisional -- request received,\
    \ continuing to process the\n         request;\n   2xx:  Success -- the action\
    \ was successfully received, understood,\n         and accepted;\n   3xx:  Redirection\
    \ -- further action needs to be taken in order to\n         complete the request;\n\
    \   4xx:  Request Failure -- the request contains bad syntax or cannot be\n  \
    \       fulfilled at this server;\n   5xx:  Server Error -- the server failed\
    \ to fulfill an apparently\n         valid request;\n   6xx:  Global Failure --\
    \ the request cannot be fulfilled at any\n         server.\n   The status codes\
    \ are the same as described in HTTP [RFC7231].  In the\n   same way as HTTP, Q4S\
    \ applications are not required to understand the\n   meaning of all registered\
    \ status codes, though such understanding is\n   obviously desirable.  However,\
    \ applications MUST understand the class\n   of any status code, as indicated\
    \ by the first digit, and treat any\n   unrecognized response as being equivalent\
    \ to the x00 status code of\n   that class.\n   The Q4S-ALERT, Q4S-RECOVERY, and\
    \ CANCEL requests do not have to be\n   responded to.  However, after receiving\
    \ a Q4S-ALERT, Q4S-RECOVERY, or\n   CANCEL request, the server SHOULD send a Q4S-ALERT,\
    \ Q4S-RECOVERY, or\n   CANCEL request to the client.\n"
- title: 4.3.  Header Fields
  contents:
  - "4.3.  Header Fields\n   Q4S header fields are identical to HTTP header fields\
    \ in both syntax\n   and semantics.\n   Some header fields only make sense in\
    \ requests or responses.  These\n   are called request header fields and response\
    \ header fields,\n   respectively.  If a header field appears in a message that\
    \ does not\n   match its category (such as a request header field in a response),\
    \ it\n   MUST be ignored.\n"
- title: 4.3.1.  Common Q4S Header Fields
  contents:
  - "4.3.1.  Common Q4S Header Fields\n   These fields may appear in request and response\
    \ messages.\n   Session-Id:  the value for this header field is the same sess-id\
    \ used\n         in SDP (embedded in the SDP \"o=\" line) and is assigned by the\n\
    \         server.  The messages without SDP MUST include this header\n       \
    \  field.  If a message has an SDP body, this header field is\n         optional.\
    \  The method of sess-id allocation is up to the\n         creating tool, but\
    \ it is suggested that a UTC timestamp be used\n         to ensure uniqueness.\n\
    \   Sequence-Number:  sequential and cyclic positive integer number\n        \
    \ assigned to PING and BWIDTH messages and acknowledged in 200 OK\n         responses.\n\
    \   Timestamp:  this optional header field contains the system time (with\n  \
    \       the best possible accuracy).  It indicates the time in which\n       \
    \  the PING request was sent.  If this header field is present in\n         PING\
    \ messages, then the 200 OK response messages MUST include\n         this value.\n\
    \   Stage:  this is used in the client's READY requests and the server's\n   \
    \      200 OK responses during the Negotiation and Continuity phases\n       \
    \  in order to synchronize the initiation of the measurements.\n         Example:\
    \ Stage: 0\n"
- title: 4.3.2.  Specific Q4S Request Header Fields
  contents:
  - "4.3.2.  Specific Q4S Request Header Fields\n   In addition to HTTP header fields,\
    \ these are the specific Q4S request\n   header fields:\n   User-Agent:  this\
    \ header field contains information about the\n         implementation of the\
    \ user agent.  This is for statistical\n         purposes, the tracing of protocol\
    \ violations, and the automated\n         recognition of user agents for the sake\
    \ of tailoring responses\n         to avoid particular user agent limitations.\
    \  User agents SHOULD\n         include this field with requests.  The field MAY\
    \ contain\n         multiple product tokens and comments identifying the agent\
    \ and\n         any sub-products that form a significant part of the user\n  \
    \       agent.  By convention, the product tokens are listed in order\n      \
    \   of their significance for identifying the application.\n   Signature:  this\
    \ header field contains a digital signature that can\n         be used by the\
    \ network, Actuator, or policy server to validate\n         the SDP, preventing\
    \ security attacks.  The Signature is an\n         optional header field generated\
    \ by the server according to the\n         pre-agreed security policies between\
    \ the Application Content\n         Provider and the ISP.  For example, a hash\
    \ algorithm and\n         encryption method such as SHA256 [RFC6234] and RSA [RFC8017]\n\
    \         based on the server certificate could be used.  This\n         certificate\
    \ is supposed to be delivered by a Certification\n         Authority (CA) or policy\
    \ owner to the server.  The signature is\n         applied to the SDP body.\n\
    \               Signature= RSA ( SHA256 (<sdp>), <certificate> )\n         If\
    \ the Signature header field is not present, other validation\n         mechanisms\
    \ MAY be implemented in order to provide assured\n         quality with security\
    \ and control.\n   Measurements:  this header field carries the measurements of\
    \ the\n         quality parameters in PING and BWIDTH requests.  The format is:\n\
    \           Measurements: \"l=\" \" \"|[0..9999] \", j=\" \" \"|[0..9999] \",\
    \ pl=\"\n           \" \"|[0.00 .. 100.00] \", bw=\" \" \"|[0..999999]\n     \
    \    Where \"l\" stands for latency followed by the measured value (in\n     \
    \    milliseconds) or an empty space, \"j\" stands for jitter followed\n     \
    \    by the measured value (in milliseconds) or an empty space, \"pl\"\n     \
    \    stands for packet loss followed by the measured value (in\n         percentage\
    \ with two decimals) or an empty space, and \"bw\"\n         stands for bandwidth\
    \ followed by the measured value (in kbps)\n         or an empty space.\n"
- title: 4.3.3.  Specific Q4S Response Header Fields
  contents:
  - "4.3.3.  Specific Q4S Response Header Fields\n   Expires:  its purpose is to provide\
    \ a sanity check and allow the\n         server to close inactive sessions.  If\
    \ the client does not send\n         a new request before the expiration time,\
    \ the server MAY close\n         the session.  The value MUST be an integer, and\
    \ the measurement\n         units are milliseconds.\n         In order to keep\
    \ the session open, the server MUST send a Q4S\n         alert before the session\
    \ expiration (Expires header field),\n         with the same quality levels and\
    \ an alert cause of \"keep-\n         alive\".  The purpose of this alert is to\
    \ avoid TCP sockets,\n         which were opened with READY message, from being\
    \ closed,\n         specially in NAT scenarios.\n"
- title: 4.4.  Bodies
  contents:
  - "4.4.  Bodies\n   Requests, including new requests defined in extensions to this\n\
    \   specification, MAY contain message bodies unless otherwise noted.\n   The\
    \ interpretation of the body depends on the request method.\n   For response messages,\
    \ the request method and the response status\n   code determine the type and interpretation\
    \ of any message body.  All\n   responses MAY include a body.\n   The Internet\
    \ media type of the message body MUST be given by the\n   Content-Type header\
    \ field.\n"
- title: 4.4.1.  Encoding
  contents:
  - "4.4.1.  Encoding\n   The body MUST NOT be compressed.  This mechanism is valid\
    \ for other\n   protocols such as HTTP and SIP [RFC3261], but a compression/coding\n\
    \   scheme will limit the way the request is parsed to certain logical\n   implementations,\
    \ thus making the protocol concept more implementation\n   dependent.  In addition,\
    \ the bandwidth calculation may not be valid\n   if compression is used.  Therefore,\
    \ the HTTP Accept-Encoding request\n   header field cannot be used in Q4S with\
    \ values different from\n   \"identity\", and if it is present in a request, the\
    \ server MUST ignore\n   it.  In addition, the response header field Content-Encoding\
    \ is\n   optional, but if present, the unique permitted value is \"identity\"\
    .\n   The body length in bytes MUST be provided by the Content-Length\n   header\
    \ field.  The \"chunked\" transfer encoding of HTTP/1.1 MUST NOT\n   be used for\
    \ Q4S.\n      |  Note: The chunked encoding modifies the body of a message in\n\
    \      |  order to transfer it as a series of chunks, each one with its\n    \
    \  |  own size indicator.\n"
- title: 5.  Q4S Method Definitions
  contents:
  - "5.  Q4S Method Definitions\n   The Method token indicates the method to be performed\
    \ on the resource\n   identified by the Request-URI.  The method is case sensitive.\n\
    \    Method  = \"BEGIN\" | \"READY\" | \"PING\" | \"BWIDTH\" |\n             \
    \ \"Q4S-ALERT\" | \"Q4S-RECOVERY\" | \"CANCEL\" | extension-method\n    extension-method\
    \ = token\n   The list of methods allowed by a resource can be specified in an\n\
    \   Allow header field [RFC7231].  The return code of the response always\n  \
    \ notifies the client when a method is currently allowed on a resource,\n   since\
    \ the set of allowed methods can change dynamically.  Any server\n   application\
    \ SHOULD return the status code 405 (Method Not Allowed) if\n   the method is\
    \ known, but not allowed for the requested resource, and\n   501 (Not Implemented)\
    \ if the method is unrecognized or not\n   implemented by the server.\n"
- title: 5.1.  BEGIN
  contents:
  - "5.1.  BEGIN\n   The BEGIN method requests information from a resource identified\
    \ by a\n   Q4S URI.  The purpose of this method is to start the quality session.\n\
    \   This method is used only during the Handshake phase to retrieve the\n   SDP\
    \ containing the sess-id and all quality and operation parameters\n   for the\
    \ desired application to run.\n   When a BEGIN message is received by the server,\
    \ any current quality\n   session MUST be canceled, and a new session should be\
    \ created.\n   The response to a Q4S BEGIN request is not cacheable.\n"
- title: 5.2.  READY
  contents:
  - "5.2.  READY\n   The READY method is used to synchronize the starting time for\
    \ the\n   sending of PING and BWIDTH messages over UDP between clients and\n \
    \  servers.  Including the Stage header field in this method is\n   mandatory.\n\
    \   This message is used only in Negotiation and Continuity phases, and\n   only\
    \ just before making a measurement.  Otherwise (outside of this\n   context),\
    \ the server MUST ignore this method.\n"
- title: 5.3.  PING
  contents:
  - "5.3.  PING\n   This message is used during the Negotiation and Continuity phases\
    \ to\n   measure the RTT and jitter of a session.  The message MUST be sent\n\
    \   only over UDP ports.\n   The fundamental difference between the PING and BWIDTH\
    \ requests is\n   reflected in the different measurements achieved with them.\
    \  PING is\n   a short message, and it MUST be answered in order to measure RTT\
    \ and\n   jitter, whereas BWIDTH is a long message and MUST NOT be answered.\n\
    \   PING is a request method that can be originated by either the client\n   or\
    \ the server.  The client MUST also answer the server PING messages,\n   assuming\
    \ a \"server role\" for these messages during the measurement\n   process.\n \
    \  Including the Measurements header field in this method is mandatory,\n   and\
    \ provides updated measurements values for latency, jitter, and\n   packet loss\
    \ to the counterpart.\n"
- title: 5.4.  BWIDTH
  contents:
  - "5.4.  BWIDTH\n   This message is used only during the Negotiation phase to measure\
    \ the\n   bandwidth and packet loss of a session.  The message MUST be sent\n\
    \   only over UDP ports.\n   BWIDTH is a request method that can be originated\
    \ by either the\n   client or the server.  Both client and server MUST NOT answer\
    \ BWIDTH\n   messages.\n   Including the Measurements header field in this method\
    \ is mandatory\n   and provides updated measurements values for bandwidth and\
    \ packet\n   loss to the counterpart.\n"
- title: 5.5.  Q4S-ALERT
  contents:
  - "5.5.  Q4S-ALERT\n   This is the request message that Q4S generates when the measurements\n\
    \   indicate that quality constraints are being violated.  It is used\n   during\
    \ the Negotiation and Continuity phases.\n   This informative message indicates\
    \ that the user experience is being\n   degraded and includes the details of the\
    \ problem (bandwidth, jitter,\n   packet loss measurements).  The Q4S-ALERT message\
    \ does not contain\n   any detail on the actions to be taken, which depend on\
    \ the agreements\n   between all involved parties.\n   Unless there is an error\
    \ condition, an answer to a Q4S-ALERT request\n   is optional and is formatted\
    \ as a request Q4S-ALERT message.  If\n   there is an error condition, then a\
    \ response message is sent.  The\n   response to a Q4S-ALERT request is not cacheable.\n\
    \   This method MUST be initiated by the server in both alerting modes.\n   In\
    \ the Q4S-aware-network alerting mode, the Q4S-ALERT messages are\n   sent by\
    \ the server to the client, advising the network to react by\n   itself.  In the\
    \ Reactive alerting mode, alert notifications are\n   triggered by the server\
    \ stack and sent to the Actuator (see Figure 1,\n   \"Reactive Scenario\").\n\
    \   Client----q4s----SERVER STACK--->ACTUATOR-->APP OR POLICY SERVER\n   The way\
    \ in which the server stack notifies the Actuator is\n   implementation dependent,\
    \ and the communication between the Actuator\n   and the network policy server\
    \ is defined by the protocol and API that\n   the policy server implements.\n"
- title: 5.6.  Q4S-RECOVERY
  contents:
  - "5.6.  Q4S-RECOVERY\n   This is the request message that Q4S generates when the\
    \ measurements\n   indicate that quality constraints, which had been violated,\
    \ have been\n   fulfilled during a period of time (\"recovery-pause\").  It is\
    \ used\n   during the Negotiation and Continuity phases.\n   This informative\
    \ message indicates that the \"qos-level\" could be\n   increased gradually until\
    \ the initial \"qos-level\" is recovered (the\n   \"qos-level\" established at\
    \ the beginning of the session that was\n   decreased during violation of constraints.\
    \  See Section 7.9).  The\n   Q4S-RECOVERY message does not contain any detail\
    \ on the actions to be\n   taken, which depends on the agreements between all\
    \ involved parties.\n   The answer to a Q4S-RECOVERY request is formatted as a\
    \ request Q4S-\n   RECOVERY message.  A Q4S-RECOVERY request MUST NOT be answered\
    \ with a\n   response message unless there is an error condition.  The response\
    \ to\n   a Q4S-RECOVERY request is not cacheable.\n   Like the Q4S-ALERT message,\
    \ the Q4S-RECOVERY method is always\n   initiated by the server in both alerting\
    \ modes.  In the Q4S-aware-\n   network alerting mode, the Q4S-RECOVERY messages\
    \ are sent by the\n   server to the client, advising the network to react by itself.\
    \  In\n   the Reactive alerting mode, recovery notifications are triggered by\n\
    \   the server stack and sent to the Actuator (see Figure 1, \"Reactive\n   Scenario\"\
    ).\n"
- title: 5.7.  CANCEL
  contents:
  - "5.7.  CANCEL\n   The purpose of the CANCEL message is the release of the Q4S\
    \ Session-\n   Id and the possible resources assigned to the session.  This message\n\
    \   could be triggered by the Q4S stack or by the application using the\n   stack\
    \ (through an implementation-dependent API).\n   In the same way as Q4S-ALERT,\
    \ CANCEL must not be answered with a\n   response message, but with an answer\
    \ formatted as a request Q4S-\n   CANCEL message.\n   In the Reactive scenario,\
    \ the server stack MUST react to the Q4S\n   CANCEL messages received from the\
    \ client by forwarding a cancel\n   notification to the Actuator, in order to\
    \ release possible assigned\n   resources for the session (at the application\
    \ or at the policy\n   server).  The Actuator MUST answer the cancel notification\
    \ with a\n   cancel acknowledge towards the server stack, acknowledging the\n\
    \   reception.\n"
- title: 6.  Response Codes
  contents:
  - "6.  Response Codes\n   Q4S response codes are used for TCP and UDP.  However,\
    \ in UDP, only\n   the response code 200 is used.\n   The receiver of an unknown\
    \ response code must take a generic action\n   for the received error group (1xx,\
    \ 2xx, 3xx, 4xx, 5xx, 6xx).  In case\n   of an unknown error group, the expected\
    \ action should be the same as\n   with the 6xx error group.\n"
- title: 6.1.  100 Trying
  contents:
  - "6.1.  100 Trying\n   This response indicates that the request has been received\
    \ by the\n   next-hop server and that some unspecified action is being taken on\n\
    \   behalf of this request (for example, a database is being consulted).\n   This\
    \ response, like all other provisional responses, stops\n   retransmissions of\
    \ a Q4S-ALERT during the \"alert-pause\" time.\n"
- title: 6.2.  Success 2xx
  contents:
  - "6.2.  Success 2xx\n   2xx responses give information about the success of a request.\n"
- title: 6.2.1.  200 OK
  contents:
  - "6.2.1.  200 OK\n   The request has succeeded.\n"
- title: 6.3.  Redirection 3xx
  contents:
  - "6.3.  Redirection 3xx\n   3xx responses give information about the user's new\
    \ location or about\n   alternative services that might be able to satisfy the\
    \ request.\n   The requesting client SHOULD retry the request at the new address(es)\n\
    \   given by the Location header field.\n"
- title: 6.4.  Request Failure 4xx
  contents:
  - "6.4.  Request Failure 4xx\n   4xx responses are definite failure responses from\
    \ a particular\n   server.  The client SHOULD NOT retry the same request without\n\
    \   modification (for example, adding appropriate header fields or SDP\n   values).\
    \  However, the same request to a different server might be\n   successful.\n"
- title: 6.4.1.  400 Bad Request
  contents:
  - "6.4.1.  400 Bad Request\n   The request could not be understood due to malformed\
    \ syntax.  The\n   Reason-Phrase SHOULD identify the syntax problem in more detail,\
    \ for\n   example, \"Missing Sequence-Number header field\".\n"
- title: 6.4.2.  404 Not Found
  contents:
  - "6.4.2.  404 Not Found\n   The server has definitive information that the user\
    \ does not exist at\n   the domain specified in the Request-URI.  This status\
    \ is also\n   returned if the domain in the Request-URI does not match any of\
    \ the\n   domains handled by the recipient of the request.\n"
- title: 6.4.3.  405 Method Not Allowed
  contents:
  - "6.4.3.  405 Method Not Allowed\n   The method specified in the Request-Line is\
    \ understood, but not\n   allowed for the address identified by the Request-URI.\n\
    \   The response MUST include an Allow header field containing a list of\n   valid\
    \ methods for the indicated address.\n"
- title: 6.4.4.  406 Not Acceptable
  contents:
  - "6.4.4.  406 Not Acceptable\n   The resource identified by the request is only\
    \ able to generate\n   response entities that have content characteristics that\
    \ are not\n   acceptable according to the Accept header field sent in the request.\n"
- title: 6.4.5.  408 Request Timeout
  contents:
  - "6.4.5.  408 Request Timeout\n   The server could not produce a response within\
    \ a suitable amount of\n   time, and the client MAY repeat the request without\
    \ modifications at\n   any later time.\n"
- title: 6.4.6.  413 Request Entity Too Large
  contents:
  - "6.4.6.  413 Request Entity Too Large\n   The server is refusing to process a\
    \ request because the request\n   entity-body is larger than the one that the\
    \ server is willing or able\n   to process.  The server MAY close the connection\
    \ to prevent the\n   client from continuing the request.\n"
- title: 6.4.7.  414 Request-URI Too Long
  contents:
  - "6.4.7.  414 Request-URI Too Long\n   The server is refusing to process the request\
    \ because the Request-URI\n   is longer than the one that the server accepts.\n"
- title: 6.4.8.  415 Unsupported Media Type
  contents:
  - "6.4.8.  415 Unsupported Media Type\n   The server is refusing to process the\
    \ request because the message\n   body of the request is in a format not supported\
    \ by the server for\n   the requested method.  The server MUST return a list of\
    \ acceptable\n   formats using the Accept, Accept-Encoding, or Accept-Language\
    \ header\n   field, depending on the specific problem with the content.\n"
- title: 6.4.9.  416 Unsupported URI Scheme
  contents:
  - "6.4.9.  416 Unsupported URI Scheme\n   The server cannot process the request\
    \ because the scheme of the URI\n   in the Request-URI is unknown to the server.\n"
- title: 6.5.  Server Failure 5xx
  contents:
  - "6.5.  Server Failure 5xx\n   5xx responses are failure responses given when a\
    \ server itself is\n   having trouble.\n"
- title: 6.5.1.  500 Server Internal Error
  contents:
  - "6.5.1.  500 Server Internal Error\n   The server encountered an unexpected condition\
    \ that prevented it from\n   fulfilling the request.  The client MAY display the\
    \ specific error\n   condition and MAY retry the request after several seconds.\n"
- title: 6.5.2.  501 Not Implemented
  contents:
  - "6.5.2.  501 Not Implemented\n   The server does not support the functionality\
    \ required to fulfill the\n   request.  This is the appropriate response when\
    \ a server does not\n   recognize the request method, and it is not capable of\
    \ supporting it\n   for any user.\n   Note that a 405 (Method Not Allowed) is\
    \ sent when the server\n   recognizes the request method, but that method is not\
    \ allowed or\n   supported.\n"
- title: 6.5.3.  503 Service Unavailable
  contents:
  - "6.5.3.  503 Service Unavailable\n   The server is temporarily unable to process\
    \ the request due to a\n   temporary overloading or maintenance of the server.\
    \  The server MAY\n   indicate when the client should retry the request in a Retry-After\n\
    \   header field.  If no Retry-After is given, the client MUST act as if\n   it\
    \ had received a 500 (Server Internal Error) response.\n   A client receiving\
    \ a 503 (Service Unavailable) SHOULD attempt to\n   forward the request to an\
    \ alternate server.  It SHOULD NOT forward\n   any other requests to that server\
    \ for the duration specified in the\n   Retry-After header field, if present.\n\
    \   Servers MAY refuse the connection or drop the request instead of\n   responding\
    \ with 503 (Service Unavailable).\n"
- title: 6.5.4.  504 Server Time-Out
  contents:
  - "6.5.4.  504 Server Time-Out\n   The server did not receive a timely response\
    \ from an external server\n   it accessed in attempting to process the request.\n"
- title: 6.5.5.  505 Version Not Supported
  contents:
  - "6.5.5.  505 Version Not Supported\n   The server does not support, or refuses\
    \ to support, the Q4S protocol\n   version that was used in the request.  The\
    \ server is indicating that\n   it is unable or unwilling to complete the request\
    \ using the same\n   major version as the client, other than with this error message.\n\
    \   In the case that the Q4S version is not supported, this error may be\n   sent\
    \ by the server in the Handshake phase just after receiving the\n   first BEGIN\
    \ message from client.\n"
- title: 6.5.6.  513 Message Too Large
  contents:
  - "6.5.6.  513 Message Too Large\n   The server was unable to process the request\
    \ because the message\n   length exceeded its capabilities.\n"
- title: 6.6.  Global Failures 6xx
  contents:
  - "6.6.  Global Failures 6xx\n   6xx responses indicate that a server has definitive\
    \ information about\n   a particular policy not satisfied for processing the request.\n"
- title: 6.6.1.  600 Session Does Not Exist
  contents:
  - "6.6.1.  600 Session Does Not Exist\n   The Session-Id is not valid.\n"
- title: 6.6.2.  601 Quality Level Not Allowed
  contents:
  - "6.6.2.  601 Quality Level Not Allowed\n   The \"qos-level\" requested is not\
    \ allowed for the client/server pair.\n"
- title: 6.6.3.  603 Session Not Allowed
  contents:
  - "6.6.3.  603 Session Not Allowed\n   The session is not allowed due to some policy\
    \ (the number of sessions\n   allowed for the server is exceeded, or the time\
    \ band of the Q4S-ALERT\n   is not allowed for the client/server pair, etc.).\n"
- title: 6.6.4.  604 Authorization Not Allowed
  contents:
  - "6.6.4.  604 Authorization Not Allowed\n   The policy server does not authorize\
    \ the Q4S-ALERT quality session\n   improvement operation due to an internal or\
    \ external reason.\n"
- title: 7.  Protocol
  contents:
  - "7.  Protocol\n   This section describes the measurement procedures, the SDP structure\n\
    \   of the Q4S messages, the different Q4S protocol phases, and the\n   messages\
    \ exchanged in them.\n"
- title: 7.1.  Protocol Phases
  contents:
  - "7.1.  Protocol Phases\n   All elements of the IP network contribute to quality\
    \ in terms of\n   latency, jitter, bandwidth, and packet loss.  All these elements\
    \ have\n   their own quality policies in terms of priorities, traffic mode,\n\
    \   etc., and each element has its own way to manage the quality.  The\n   purpose\
    \ of a quality connection is to establish end-to-end\n   communication with enough\
    \ quality for the application to function\n   flawlessly.\n   To monitor quality\
    \ constraints of the application, four phases are\n   defined and can be seen\
    \ in Figure 5:\n   | Handshake ---> Negotiation -+--> Continuity ----> Termination\
    \ |\n   |                   A         |    (app start) |    (app end)   |\n  \
    \ |                   |     violated     |     violated  |        |\n   |    \
    \               |    constraints   |   constraints |        |\n              \
    \       Figure 5: Session Lifetime Phases\n   Handshake phase:  in which the server\
    \ is contacted by the client, and\n      in the answer message, the quality constraints\
    \ for the application\n      are communicated in the embedded SDP.\n   Negotiation\
    \ phase:  in which the quality of the connection is\n      measured in both directions\
    \ (latency, jitter, bandwidth, and\n      packet loss), and Q4S messages may be\
    \ sent in order to alert if\n      the measured quality does not meet the constraints.\
    \  This phase is\n      iterative until quality constraints are reached, or the\
    \ session is\n      canceled after a number of measurement cycles with consistent\n\
    \      violation of the quality constraints.  The number of measurement\n    \
    \  cycles executed depends on the \"qos-level\", which is incremented\n      in\
    \ each cycle until a maximum \"qos-level\" value is reached.  Just\n      after\
    \ reaching the quality requirements, Q4S provides a simple\n      optional mechanism\
    \ using HTTP to start the application.\n   Continuity phase:  in which quality\
    \ is continuously measured.  In\n      this phase, the measurements MUST avoid\
    \ disturbing the application\n      by consuming network resources.  If quality\
    \ constraints are not\n      met, the server stack will notify the Actuator with\
    \ an alert\n      notification.  If later the quality improves, the server stack\n\
    \      will notify the Actuator, in this case with a recovery\n      notification.\
    \  After several alert notifications with no quality\n      improvements, the\
    \ Q4S stack SHOULD move to the Termination phase.\n   Termination phase:  in which\
    \ the Q4S session is terminated.  The\n      application may be closed also or\
    \ may not start.\n"
- title: 7.2.  SDP Structure
  contents:
  - "7.2.  SDP Structure\n   The original goal of SDP was to announce necessary information\
    \ for\n   the participants and multicast MBONE (Multicast Backbone)\n   applications.\
    \  Right now, its use has been extended to the\n   announcement and the negotiation\
    \ of multimedia sessions.  The purpose\n   of Q4S is not to establish media stream\
    \ sessions, but to monitor a\n   quality connection.  This connection may be later\
    \ used to establish\n   any type of session including media sessions; Q4S does\
    \ not impose any\n   conditions on the type of communication requiring quality\
    \ parameters.\n   SDP will be used by Q4S to exchange quality constraints and\
    \ will\n   therefore always have all the media descriptions (\"m=\") set to zero.\n\
    \   The SDP embedded in the messages is the container of the quality\n   parameters.\
    \  As these may vary depending on the direction of the\n   communication (to and\
    \ from the client), all quality parameters need\n   to specify the uplink and\
    \ downlink values: <uplink> / <downlink> (see\n   Section 7.5.3 for an example).\
    \  When one or both of these values are\n   empty, it MUST be understood as needing\
    \ no constraint on that\n   parameter and/or that direction.\n   The uplink direction\
    \ MUST be considered as being the communication\n   from the client to the server.\
    \  The downlink direction MUST be\n   considered as being the communication from\
    \ the server to the client.\n   The SDP information can comprise all or some of\
    \ the following\n   parameters shown in the example below.  This is an example\
    \ of an SDP\n   message used by Q4S included in the 200 OK response to a Q4S BEGIN\n\
    \   request.\n   v=0\n   o=q4s-UA 53655765 2353687637 IN IP4 192.0.2.33\n   s=Q4S\n\
    \   i=Q4S parameters\n   t=0 0\n   a=qos-level:0/0\n   a=alerting-mode:Reactive\n\
    \   a=alert-pause:5000\n   a=public-address:client IP4 198.51.100.51\n   a=public-address:server\
    \ IP4 198.51.100.58\n   a=measurement:procedure default(50/50,75/75,5000,40/80,100/256)\n\
    \   a=latency:40\n   a=jitter:10/10\n   a=bandwidth:20/6000\n   a=packetloss:0.50/0.50\n\
    \   a=flow:app clientListeningPort TCP/10000-20000\n   a=flow:app clientListeningPort\
    \ UDP/15000-18000\n   a=flow:app serverListeningPort TCP/56000\n   a=flow:app\
    \ serverListeningPort UDP/56000\n   a=flow:q4s clientListeningPort UDP/55000\n\
    \   a=flow:q4s clientListeningPort TCP/55001\n   a=flow:q4s serverListeningPort\
    \ UDP/56000\n   a=flow:q4s serverListeningPort TCP/56001\n   As quality constraints\
    \ may be changed by applications at any time\n   during the Q4S session lifetime,\
    \ any Q4S 200 OK response sent by the\n   server to the client in the Negotiation\
    \ and Continuity phases could\n   also include an SDP body with the new quality\
    \ requirements stated by\n   the applications from then on.  Therefore, in response\
    \ to any PING\n   request sent by the client to the server, the server could send\
    \ a Q4S\n   200 OK with an embedded SDP message that specifies new quality\n \
    \  constraints requested by the application.\n"
- title: 7.2.1.  "qos-level" Attribute
  contents:
  - "7.2.1.  \"qos-level\" Attribute\n   The \"qos-level\" attribute contains the\
    \ QoS level for uplink and\n   downlink.  Default values are 0 for both directions.\
    \  The meaning of\n   each level is out of scope of Q4S, but a higher level SHOULD\n\
    \   correspond to a better service quality.\n   Appropriate attribute values:\
    \ [0..9] \"/\" [0..9]\n   The \"qos-level\" attribute may be changed during the\
    \ session lifetime,\n   raising or lowering the value as necessary following the\
    \ network\n   measurements and the application needs.\n"
- title: 7.2.2.  "alerting-mode" Attribute
  contents:
  - "7.2.2.  \"alerting-mode\" Attribute\n   The \"alerting-mode\" attribute specifies\
    \ the player in charge of\n   triggering Q4S alerts in the case of constraint\
    \ violation.  There are\n   two possible values:\n   Appropriate attribute values:\
    \ <\"Q4S-aware-network\"|\"Reactive\">\n   Q4S-aware-network:  Q4S-ALERT messages\
    \ are triggered by the server to\n         the client.  In this case, the network\
    \ is supposed to be Q4S\n         aware, and reacts by itself to these alerts.\n\
    \   Reactive:  alert notifications are sent by the server stack to the\n     \
    \    Actuator.  In this case, the network is not Q4S aware, and a\n         specific\
    \ node (Actuator) is in charge of triggering tuning\n         mechanisms, either\
    \ on the network or in the application.\n   The \"alerting-mode\" attribute is\
    \ optional, and if not present,\n   Reactive alerting mode is assumed.\n"
- title: 7.2.3.  "alert-pause" Attribute
  contents:
  - "7.2.3.  \"alert-pause\" Attribute\n   In the Q4S-aware-network scenario, the\
    \ \"alert-pause\" attribute\n   specifies the amount of time (in milliseconds)\
    \ the server waits\n   between consecutive Q4S-ALERT messages sent to the client.\
    \  In the\n   Reactive scenario, the \"alert-pause\" attribute specifies the amount\n\
    \   of time (in milliseconds) the server stack waits between consecutive\n   alert\
    \ notifications sent to the Actuator.  Measurements are not\n   stopped in Negotiation\
    \ or Continuity phases during this period of\n   time, but no Q4S-ALERT messages\
    \ or alert notifications are fired,\n   even with violated quality constraints,\
    \ allowing for either network\n   reconfigurations or application adjustments.\n\
    \   Appropriate attribute values: [0..60000]\n"
- title: 7.2.4.  "recovery-pause" Attribute
  contents:
  - "7.2.4.  \"recovery-pause\" Attribute\n   In the Q4S-aware-network scenario, the\
    \ \"recovery-pause\" attribute\n   specifies the amount of time (in milliseconds)\
    \ the server waits for\n   initiating the \"qos-level\" recovery process.  Once\
    \ the recovery\n   process has started, the \"recovery-pause\" attribute also\
    \ states the\n   amount of time (in milliseconds) between consecutive Q4S-RECOVERY\n\
    \   messages sent by the server to the client (in the Q4S-aware-network\n   scenario)\
    \ or between recovery notifications sent by the server stack\n   to the Actuator\
    \ (in the Reactive scenario).\n   Appropriate attribute values: [0..60000]\n"
- title: 7.2.5.  "public-address" Attributes
  contents:
  - "7.2.5.  \"public-address\" Attributes\n   This attribute contains the public\
    \ IP address of the client and the\n   server.  The server fills these attributes\
    \ with its own public IP\n   address and the public IP address of the first message\
    \ received from\n   the client in the Handshake phase.\n   The purpose of these\
    \ attributes is to make available the addressing\n   information to the network\
    \ policy server or other external entities\n   in charge of processing Q4S-ALERT\
    \ messages.\n   Appropriate attribute values: <\"client\"|\"server\"> <\"IP4\"\
    |\"IP6\">\n   <value of IP address>\n"
- title: 7.2.6.  "latency" Attribute
  contents:
  - "7.2.6.  \"latency\" Attribute\n   The maximum latency (considered equal for uplink\
    \ and downlink)\n   tolerance is specified in the \"latency\" attribute, expressed\
    \ in\n   milliseconds.  In the Q4S-aware-network scenario, if the latency\n  \
    \ constraints are not met, a Q4S-ALERT method will be sent to the\n   client.\
    \  In the Reactive scenario, if the latency constraints are not\n   met, an alert\
    \ notification will be sent to the Actuator.  If the\n   \"latency\" attribute\
    \ is not present or has a 0 value, no latency\n   constraints need to be met,\
    \ and no measurements MAY be taken.\n   Appropriate attribute values: [0..9999]\n"
- title: 7.2.7.  "jitter" Attribute
  contents:
  - "7.2.7.  \"jitter\" Attribute\n   The maximum uplink and downlink jitter tolerance\
    \ is specified in the\n   \"jitter\" attribute, expressed in milliseconds.  In\
    \ the Q4S-aware-\n   network scenario, if the jitter constraints are not met,\
    \ a Q4S-ALERT\n   method will be sent to the client.  In the Reactive scenario,\
    \ if the\n   latency constraints are not met, an alert notification will be sent\n\
    \   to the Actuator.  If the \"jitter\" attribute is not present or has a 0\n\
    \   value, no jitter constraints need to be met, and no measurements MAY\n   be\
    \ taken.\n   Appropriate attribute values: [0..9999] \"/\" [0..9999]\n"
- title: 7.2.8.  "bandwidth" Attribute
  contents:
  - "7.2.8.  \"bandwidth\" Attribute\n   The minimum uplink and downlink bandwidth\
    \ is specified in the\n   \"bandwidth\" attribute, expressed in kbps.  In the\
    \ Q4S-aware-network\n   scenario, if the bandwidth constraints are not met, a\
    \ Q4S-ALERT\n   method will be sent to the client.  In the Reactive scenario,\
    \ an\n   alert notification will be sent to the Actuator.  If the \"bandwidth\"\
    \n   attribute is not present or has a 0 value, no bandwidth constraints\n   need\
    \ to be met, and no measurements MAY be taken.\n   Appropriate attribute values:\
    \ [0..99999] \"/\" [0..99999]\n"
- title: 7.2.9.  "packetloss" Attribute
  contents:
  - "7.2.9.  \"packetloss\" Attribute\n   The maximum uplink and downlink packet loss\
    \ tolerance is specified in\n   the \"packetloss\" attribute expressed in percentage\
    \ (two decimal\n   accuracy).  In the Q4S-aware-network scenario, if the packetloss\n\
    \   constraints are not met, a Q4S-ALERT method will be sent to the\n   client.\
    \  In the Reactive scenario, an alert notification will be sent\n   to the Actuator.\
    \  If the \"packetloss\" attribute is not present or has\n   a 0 value, no packet\
    \ loss constraints need to be met, and no\n   measurements MAY be taken.\n   Appropriate\
    \ attribute values: [0.00 ..100.00] \"/\"[0.00 ..100.00]\n"
- title: 7.2.10.  "flow" Attributes
  contents:
  - "7.2.10.  \"flow\" Attributes\n   These attributes specify the flows (protocol,\
    \ destination IP/ports)\n   of data over TCP and UDP ports to be used in uplink\
    \ and downlink\n   communications.\n   Several \"flow\" attributes can be defined.\
    \  These flows identify the\n   listening port (client or server), the protocol\
    \ (TCP [RFC0793] or UDP\n   [RFC0768]) with the range of ports that are going\
    \ to be used by the\n   application and, of course, by the Q4S protocol (for quality\n\
    \   measurements).  All defined flows (\"app\" and \"q4s\") will be\n   considered\
    \ within the same quality profile, which is determined by\n   the \"qos-level\"\
    \ attribute in each direction.  This allows us to\n   assume that measurements\
    \ on \"q4s\" flows are the same as experienced\n   by the application, which is\
    \ using \"app\" flows.\n   During Negotiation and Continuity phases, the specified\
    \ Q4S ports in\n   the \"flow:q4s\" attributes of SDP will be used for Q4S messages.\n\
    \   The Q4S flows comprise two UDP flows and two TCP flows (one uplink\n   and\
    \ one downlink for each one), whereas application traffic MAY\n   consist of many\
    \ flows, depending on its nature.  The Handshake phase\n   takes place through\
    \ the Q4S Contact URI, using the standard Q4S TCP\n   port.  However, the Negotiation\
    \ and Continuity phases will take place\n   on the Q4S ports (UDP and TCP) specified\
    \ in the SDP.\n   The \"clientListeningPort\" is a port on which the client listens\
    \ for\n   server requests and MUST be used as the origin port of client\n   responses.\
    \  The \"serverListeningPort\" is a port on which the server\n   is listening\
    \ for incoming messages from the client.  The origin port\n   of server responses\
    \ may be different than the \"serverListeningPort\"\n   value.\n   If \"clientListeningPort\"\
    \ is zero (\"a=flow:q4s clientListeningPort\n   TCP/0\"), the client MAY choose\
    \ one randomly per OS standard rules.\n   Client ports inside the SDP must always\
    \ be matched against actual\n   received port values on the server side in order\
    \ to deal with NAT/\n   NAPT devices.  If a zero value or incorrect value is present,\
    \ the\n   server must set the value to the received origin port in the next\n\
    \   message with SDP (200 OK, ALERT, and CANCEL messages).\n   Attribute values:\n\
    \      <\"q4s\"|\"app\"> <\"serverListeningPort\"|\"clientListeningPort\">\n \
    \  <\"UDP\"|\"TCP\"> <0..65535> [ \"-\" [0..65535]]\n"
- title: 7.2.11.  "measurement" Attributes
  contents:
  - "7.2.11.  \"measurement\" Attributes\n   These attributes contain the measurement\
    \ procedure and the results of\n   the quality measurements.\n   Measurement parameters\
    \ are included using the session attribute\n   \"measurement\".  The first measurement\
    \ parameter is the procedure.\n   Q4S provides a \"default\" procedure for measurements,\
    \ but others like\n   RTP/RTCP might be used and defined later.  This document\
    \ will only\n   define and explain the \"default\" procedure.\n   In the initial\
    \ client request, a set of measurement procedures can be\n   sent to the server\
    \ for negotiation.  One measurement procedure line\n   MUST be included in the\
    \ SDP message for each proposed method.  The\n   server MUST answer with only\
    \ one line with the chosen procedure.\n   For each procedure, a set of values\
    \ of parameters separated by \",\"\n   can be included in the same attribute line.\
    \  The amount and type of\n   parameters depends on the procedure type.\n   In\
    \ the following example, the \"default\" procedure type is chosen:\n      a=measurement:procedure\
    \ default(50/50,75/75,5000,40/80,100/256)\n   In the \"default\" procedure, the\
    \ meaning of these parameters is the\n   following:\n   *  The first parameter\
    \ is the interval of time (in milliseconds)\n      between PING requests during\
    \ the Negotiation phase.  Uplink and\n      downlink values from the client's\
    \ point of view are separated by\n      \"/\".  This allows different responsiveness\
    \ values depending on the\n      control resources used in each direction.\n \
    \  *  The second parameter is the time interval (in milliseconds)\n      between\
    \ PING requests during the Continuity phase.  Uplink and\n      downlink values\
    \ are separated by \"/\".  This allows two different\n      responsiveness values\
    \ depending on the control resources used in\n      each direction.\n   *  The\
    \ third parameter is the time interval to be used to measure\n      bandwidth\
    \ during the Negotiation phase.\n   *  The fourth parameter indicates the window\
    \ size for jitter and\n      latency calculations.  Uplink and downlink values\
    \ are separated by\n      \"/\".\n   *  The fifth parameter indicates the window\
    \ size for packet loss\n      calculations.  Uplink and downlink values are separated\
    \ by \"/\".\n   There are four more \"measurement\" attributes:\n   a=measurement:latency\
    \ 45\n   a=measurement:jitter 3/12\n   a=measurement:bandwidth 200/9800\n   a=measurement:packetloss\
    \ 0.00/1.00\n   The \"measurement:latency\", \"measurement:jitter\",\n   \"measurement:bandwidth\"\
    , and \"measurement:packetloss\" attributes\n   contain the values measured for\
    \ each of these quality parameters in\n   uplink and downlink directions.  Notice\
    \ that latency is considered\n   equal for uplink and downlink directions.  Quality\
    \ parameter values\n   in these \"measurement\" attributes provide a snapshot\
    \ of the quality\n   reached and MUST only be included in Q4S-ALERT messages in\
    \ the SDP\n   body such that they can be protected from malicious attacks as these\n\
    \   alerts include a signature of the SDP body in the header.  The rest\n   of\
    \ the messages will include the measured values in the Measurements\n   header\
    \ field.\n   In the case of the \"default\" procedure, the valid values are as\n\
    \   follows:\n   a=measurement:procedure default,[0..999]\"/\" [0..999]  \",\"\
    \ [0..999]\n   \"/\" [0..999] \",\" [0..9999] \",\" [0..999]/[0..999] \",\"\n\
    \   [0..999]/[0..999]\n"
- title: 7.2.12.  "max-content-length" Attribute
  contents:
  - "7.2.12.  \"max-content-length\" Attribute\n   The adaptation of measurement traffic\
    \ to approximate the actual data\n   streams' characteristics is convenient to\
    \ accurately estimate the\n   expected QoS for applications.  Particularly, packet\
    \ size can have a\n   remarkable effect on bandwidth estimations.  Moreover, this\
    \ can\n   produce problems depending on the MTU of the end hosts and links\n \
    \  along the path.\n   Therefore, the maximum content length MAY be set in an\
    \ attribute\n   denoted as \"max-content-length\".  Its value MUST be given in\
    \ bytes\n   and MUST NOT include application, transport, network, or link layer\n\
    \   headers, i.e., size of the content length at the application layer.\n   If\
    \ not set, the value MUST be 1000 bytes.\n   Furthermore, this attribute MAY be\
    \ used to communicate MTU limits in\n   endpoints, hence reducing possible bias\
    \ as a result of network-layer\n   fragmentation.\n   For instance:\n   a=max-content-length:1300\n"
- title: 7.3.  Measurements
  contents:
  - "7.3.  Measurements\n   This section describes the way quality parameters are\
    \ measured as\n   defined by the \"default\" procedure.  Measurements MUST be\
    \ taken for\n   any quality parameter with constraints, that is, specified in\
    \ the SDP\n   attributes with non-zero values.  For absent attributes, measurements\n\
    \   MAY be omitted.\n"
- title: 7.3.1.  Latency
  contents:
  - "7.3.1.  Latency\n   Latency measurements will be performed if the \"latency\"\
    \ attribute\n   and/or the \"a=measurement:latency\" attribute are present and\
    \ have\n   non-zero values.\n   Q4S defines a PING method in order to exchange\
    \ packets between the\n   client and the server.  Based on this PING exchange,\
    \ the client and\n   the server are able to calculate the round-trip time (RTT).\
    \  The RTT\n   is the sum of downlink latency (normally named \"reverse latency\"\
    ) and\n   uplink latency (normally named \"forward latency\").\n   At least 255\
    \ samples of RTT MUST be taken by the client and server.\n   As the forward and\
    \ reverse latencies are impossible to measure, the\n   client and server will\
    \ assume that both latencies are identical\n   (symmetric network assumption).\
    \  The latency will therefore be\n   calculated as the statistical median value\
    \ of all the RTT samples\n   divided by 2.\n"
- title: 7.3.2.  Jitter
  contents:
  - "7.3.2.  Jitter\n   Jitter measurements will be performed if the \"jitter\" attribute\
    \ and/\n   or the \"a=measurement:jitter\" attribute are present and have non-zero\n\
    \   values.\n   The jitter can be calculated independently by the client and by\
    \ the\n   server.  The downlink jitter is calculated by the client taking into\n\
    \   account the time interval between PING requests as defined by the\n   \"measurement:procedure\"\
    \ attribute in the first or second parameter\n   depending on the Q4S protocol\
    \ phase.  The client and the server MUST\n   send these PING requests at the specified\
    \ intervals.  The client\n   measures the downlink jitter, whereas the server\
    \ measures the uplink\n   jitter.  Note that PING responses are not taken into\
    \ account when\n   calculating jitter values.\n   Every time a PING request is\
    \ received by an endpoint (either server\n   or client), the corresponding jitter\
    \ value is updated with the\n   statistical jitter value, which is the arithmetic\
    \ mean of the\n   absolute values of elapsed times calculated on the first 255\
    \ packets\n   received.\n   Each endpoint sends a PING periodically with a fixed\
    \ interval, and\n   each value of \"elapsed time\" (ET) should be very close to\
    \ this\n   interval.  If a PING message is lost, the ET value is doubled.\n  \
    \ Identifying lost PING messages, however, is not an issue because all\n   PING\
    \ messages are labeled with a Sequence-Number header field.\n   Therefore, the\
    \ receiver can discard this ET value.\n   In order to have the first jitter sample,\
    \ the receiver MUST wait\n   until it receives 3 PING requests, because each ET\
    \ is the time\n   between two PINGs, and a jitter measurement needs at least two\
    \ ET.\n   The client measures the values of RTT and downlink jitter, and the\n\
    \   server measures RTT and uplink jitter, but all measurements are\n   shared\
    \ with the counterpart by means of the Measurements header field\n   of the PING\
    \ message.\n"
- title: 7.3.3.  Bandwidth
  contents:
  - "7.3.3.  Bandwidth\n   Bandwidth measurements will be performed if the \"bandwidth\"\
    \ attribute\n   and/or the \"a=measurement:bandwidth\" attribute is present and\
    \ has\n   non-zero values.\n   In order to measure the available bandwidth, both\
    \ the client and the\n   server MUST start sending BWIDTH messages simultaneously\
    \ using the\n   UDP control ports exchanged during the Handshake phase in the\
    \ SDP\n   message at the needed rate to verify the availability of the\n   bandwidth\
    \ constraint in each direction.  The messages are sent during\n   the period of\
    \ time defined in the third parameter of the SDP\n   \"measurement:procedure default\"\
    \ attribute in milliseconds.\n   a=measurement:procedure default(50/50,75/75,5000,256/256,256/256)\n\
    \           |             Rate                               |\n           | \
    \             A                                 |\n           |downlink rate-|-------------------+\
    \ <-- traffic |\n           |  uplink rate-|-------------------+ <-- traffic |\n\
    \           |              0   1   2   3   4   5     (sec.)  |\n             \
    \ Figure 6: Bandwidth and Packet Loss Measurements\n   The goal of these measurements\
    \ is not to identify the available\n   bandwidth of the communication path, but\
    \ to determine if the required\n   bandwidth is available, meeting the application's\
    \ constraints.\n   Therefore, the requested bandwidth MUST be measured sending\
    \ only the\n   highest bitrate required by the bandwidth attribute.  This is\n\
    \   illustrated in Figure 6.\n   ALERTS are not expected during bandwidth measurement,\
    \ but only at the\n   end of the measurement time.\n   When measuring bandwidth,\
    \ all BWIDTH requests sent MUST be 1 kilobyte\n   in length (UDP payload length\
    \ by default), they MUST include a\n   Sequence-Number header field with a sequential\
    \ number starting at 0,\n   and their content MUST consist of randomly generated\
    \ values to\n   minimize the effect of compression elements along the path.  The\n\
    \   Sequence-Number MUST be incremented by 1 with each BWIDTH packet\n   sent.\
    \  If any measurement stage needs to be repeated, the sequence\n   number MUST\
    \ start at zero again.  BWIDTH requests MUST NOT be\n   answered.  Examples:\n\
    \   Client message:\n   =========================\n          BWIDTH q4s://www.example.com\
    \ Q4S/1.0\n          User-Agent: q4s-ua-experimental-1.0\n          Session-Id:\
    \ 53655765\n          Sequence-Number: 0\n          Content-Type: text\n     \
    \     Content-Length: XXXX\n          Measurements: l=22, j=10, pl=0.00, bw=3000\n\
    \          VkZaU1FrNVZNVlZSV0doT1ZrZ (to complete up to \"max-content-\n   =========================\n\
    \   The client MUST send BWIDTH packets to the server to allow the server\n  \
    \ to measure the uplink bandwidth.  The server MUST send BWIDTH packets\n   to\
    \ the client to allow the client to measure the downlink bandwidth.\n   Server\
    \ message:\n   =========================\n          BWIDTH q4s://www.example.com\
    \ Q4S/1.0\n          Session-Id: 53655765\n          Sequence-Number: 0\n    \
    \      Content-Type: text\n          Content-Length: XXXX\n          Measurements:\
    \ l=22, j=7, pl=0.00, bw=200\n          ZY0VaT1ZURlZVVmhyUFE9PQ (to complete up\
    \ to max-content-\n   =========================\n"
- title: 7.3.4.  Packet Loss
  contents:
  - "7.3.4.  Packet Loss\n   Packet loss and bandwidth are measured simultaneously\
    \ using the\n   BWIDTH packets sent by both the client and the server.  Because\
    \ the\n   BWIDTH packets contain a Sequence-Number header field incremented\n\
    \   sequentially with each sent packet, lost packets can be easily\n   identified.\
    \  The lost packets MUST be counted during the measurement\n   time.\n"
- title: 7.4.  Handshake Phase
  contents:
  - "7.4.  Handshake Phase\n   The first phase consists of a Q4S BEGIN method issued\
    \ from the client\n   to the server as shown in Figure 7.\n   The first Q4S message\
    \ MUST have a special URI [RFC3986], which forces\n   the use of the Q4S protocol\
    \ if it is implemented in a standard web\n   browser.\n   This URI, named \"Contact\
    \ URI\", is used to request the start of a\n   session.  Its scheme MUST be:\n\
    \         \"q4s:\" \"//\" host [\":\" port] [path[\"?\" query]\n   Optionally,\
    \ the client can send the desired quality parameters\n   enclosed in the body\
    \ of the message as an SDP document.  The server\n   MAY take them into account\
    \ when building the answer message with the\n   final values in the SDP body,\
    \ following a request/response schema\n   [RFC3264].\n   If the request is accepted,\
    \ the server MUST answer it with a Q4S 200\n   OK message, which MUST contain\
    \ an SDP body [RFC4566] with the\n   assigned sess-id (embedded in the SDP \"\
    o=\" line), the IP addresses to\n   be used, the flow ports to be used, the measurement\
    \ procedure to be\n   followed, and information about the required quality constraints.\n\
    \   Additionally, the \"alerting-mode\" and \"alert-pause\" time attributes\n\
    \   may be included.  Q4S responses should use the protocol designator\n   \"\
    Q4S/1.0\".\n   After these two messages are exchanged, the first phase is completed.\n\
    \   The quality parameter thresholds have been sent to the client.  The\n   next\
    \ step is to measure the actual quality of the communication path\n   between\
    \ the client and the server and alert if the Service Level\n   Agreement (SLA)\
    \ is being violated.\n           | Client                            Server  \
    \     |\n           |     ------- Q4S BEGIN ------------>            |\n     \
    \      |     <------ Q4S 200 OK ------------            |\n                  \
    \       Figure 7: Handshake Phase\n   The following is an example of a client\
    \ request and a server answer:\n   Client Request:\n   =========================\n\
    \   BEGIN q4s://www.example.com Q4S/1.0\n   Content-Type: application/sdp\n  \
    \ User-Agent: q4s-ua-experimental-1.0\n   Content-Length: 142\n   (SDP not shown)\n\
    \   =========================\n   Server Answer:\n   =========================\n\
    \   Q4S/1.0 200 OK\n   Date: Mon, 10 Jun 2010 10:00:01 GMT\n   Content-Type: application/sdp\n\
    \   Expires: 3000\n   Signature: 6ec1ba40e2adf2d783de530ae254acd4f3477ac4\n  \
    \ Content-Length: 131\n   (SDP not shown)\n   =========================\n   The\
    \ header fields used are explained in Section 4.3.\n"
- title: 7.5.  Negotiation Phase
  contents:
  - "7.5.  Negotiation Phase\n   The Negotiation phase is in charge of measuring the\
    \ quality\n   parameters and verifying that the communication paths meet the\n\
    \   required quality constraints in both directions as specified in the\n   SDP\
    \ body.\n   The measured parameters will be compared with the quality constraints\n\
    \   specified in the SDP body.  If the quality session is compliant with\n   all\
    \ the quality constraints, the application can start.\n   If the quality constraints\
    \ are not met, a higher quality service\n   level will be demanded.  Depending\
    \ on the scenario, this quality\n   upgrade will be managed as follows:\n   In\
    \ the Q4S-aware-network scenario:  a Q4S-ALERT method will be\n      triggered\
    \ by the server to the client, and the client will answer\n      with the same\
    \ Q4S-ALERT method.  After receiving the same Q4S-\n      ALERT from the counterpart,\
    \ no other alerts will be triggered by\n      the server during the \"alert-pause\"\
    \ period of time in order to\n      allow the network to react, but measurements\
    \ will continue to be\n      taken to achieve early detection of improved network\
    \ quality\n      conditions and a fast application start.\n   In the Reactive\
    \ scenario:  an alert notification will be sent by the\n      server stack to\
    \ the Actuator, and the Actuator will answer with an\n      alert acknowledgement.\
    \  After receiving the alert acknowledgement\n      from the Actuator, the server\
    \ stack will not send other alert\n      notifications during the \"alert-pause\"\
    \ period of time in order to\n      allow the Actuator to react and trigger actions\
    \ on the application\n      or on the policy server, but measurements will continue\
    \ to be\n      taken to achieve early detection of improved network quality\n\
    \      conditions and a fast application start.\n   In both scenarios stated above,\
    \ if after several measurement cycles,\n   the network constraints cannot be met,\
    \ the quality session is\n   terminated.  Concretely when, under all possible\
    \ actions taken by\n   Actuator, the quality remains below requirements, the session\
    \ must be\n   terminated.\n   The steps to be taken in this phase depend on the\
    \ measurement\n   procedure exchanged during the Handshake phase.  This document\
    \ only\n   describes the \"default\" procedure, but others can be used, like RTP/\n\
    \   RTCP [RFC3550].\n   Measurements of latency and jitter are made by calculating\
    \ the\n   differences in the arrival times of packets and can be achieved with\n\
    \   little bandwidth consumption.  The bandwidth measurement, on the\n   other\
    \ hand, involves higher bandwidth consumption in both directions\n   (uplink and\
    \ downlink).\n   To avoid wasting unnecessary network resources, these two types\
    \ of\n   measurements will be performed in two separate stages.  If the\n   required\
    \ latencies and jitters cannot be reached, it makes no sense\n   to waste network\
    \ resources measuring bandwidth.  In addition, if\n   achieving the required latency\
    \ and jitter thresholds implies\n   upgrading the quality session level, the chance\
    \ of obtaining\n   compliant bandwidth measurements without retries is higher,\
    \ saving\n   network traffic again.  Therefore, the \"default\" procedure determines\n\
    \   that the measurements are taken in two stages:\n   Stage 0:  Measurement of\
    \ latencies, jitters, and packet loss\n   Stage 1:  Measurement of bandwidths\
    \ and packet loss\n   Notice that packet loss can be measured in both stages,\
    \ as all\n   messages exchanged include a Sequence-Number header field that allows\n\
    \   for easy packet loss detection.\n   The client starts the Negotiation phase\
    \ by sending a READY request\n   using the TCP Q4S ports defined in the SDP. \
    \ This READY request\n   includes a Stage header field that indicates the measurement\
    \ stage.\n   If either jitter, latency, or both are specified, the Negotiation\n\
    \   phase begins with the measurement of latencies and jitters (stage 0).\n  \
    \ If none of those attributes is specified, stage 0 is skipped.\n"
- title: '7.5.1.  Stage 0: Measurement of Latencies and Jitter'
  contents:
  - "7.5.1.  Stage 0: Measurement of Latencies and Jitter\n   The Stage 0 MUST start\
    \ with a synchronization message exchange\n   initiated with the client's READY\
    \ message.\n   Client Request, READY message:\n   =========================\n\
    \          READY q4s://www.example.com Q4S/1.0\n          Stage: 0\n         \
    \ Session-Id: 53655765\n          User-Agent: q4s-ua-experimental-1.0\n      \
    \    Content-Length: 0\n   =========================\n   Server Response:\n  \
    \ =========================\n     Q4S/1.0 200 OK\n          Session-Id: 53655765\n\
    \          Stage:0\n          Content-Length: 0\n   =========================\n\
    \   This triggers the exchange of a sequence of PING requests and\n   responses\
    \ that will lead to the calculation of RTT (latency), jitter,\n   and packet loss.\n\
    \   After receiving a 200 OK, the client must send the first PING\n   message,\
    \ and the server will wait to send PINGs until the reception\n   of this first\
    \ client PING.\n   The client and server MUST send PING requests to each other.\
    \  The\n   Sequence-Number header field of the first PING MUST be set to 0.  The\n\
    \   client and server will manage their own sequence numbers.\n           | Client\
    \                                Server   |\n           |      --------- Q4S READY\
    \ 0 --------->          |\n           |      <-------- Q4S 200 OK -----------\
    \          |\n           |      --------- Q4S PING ------------>          |\n\
    \           |      <-------- Q4S 200 OK -----------          |\n           | \
    \     <-------- Q4S PING -------------          |\n           |       --------\
    \ Q4S 200 OK ---------->          |\n           |      --------- Q4S PING ------------>\
    \          |\n           |      <-------- Q4S PING -------------          |\n\
    \           |      --------- Q4S 200 OK ---------->          |\n           | \
    \     <-------- Q4S 200 OK -----------          |\n       Figure 8: Simultaneous\
    \ Exchange of PING Request and Responses\n   The following is an example of the\
    \ PING request sent from the client\n   and the server's response:\n   Client\
    \ Request:\n   =========================\n          PING q4s://www.example.com\
    \ Q4S/1.0\n          Session-Id: 53655765\n          Sequence-Number: 0\n    \
    \      User-Agent: q4s-ua-experimental-1.0\n          Measurements: l=22, j=12,\
    \ pl=0.20, bw=\n          Content-Length: 0\n   =========================\n  \
    \ Server Response:\n   =========================\n     Q4S/1.0 200 OK\n      \
    \    Session-Id: 53655765\n          Sequence-Number: 0\n          Content-Length:\
    \ 0\n   =========================\n   The function of the PING method is similar\
    \ to the ICMP echo request\n   message [RFC0792].  The server MUST answer as soon\
    \ as it receives the\n   message.\n   Both endpoints MUST send Q4S PING messages\
    \ with the periodicity\n   specified in the first parameter of SDP \"measurement:procedure\"\
    \n   attribute, always using the same UDP ports and incrementing the\n   Sequence-Number\
    \ with each message.\n   In the following example, the value of the first parameter\
    \ of the SDP\n   \"measurement:procedure\" attribute is 50 milliseconds (from\
    \ the client\n   to the server) and 60 ms (from the server to the client):\n \
    \  a=measurement:procedure default(50/60,50/50,5000,256/256,256/256)\n   They\
    \ MUST NOT wait for a response to send the next PING request.  The\n   Sequence-Number\
    \ header field value is incremented sequentially and\n   MUST start at zero. \
    \ If this stage is repeated, the initial Sequence-\n   Number MUST start at zero\
    \ again.\n   All PING requests MUST contain a Measurements header field with the\n\
    \   values of the latency, jitter, and packet loss measured by each\n   entity\
    \ up to that moment.  The client will send its measurements to\n   the server,\
    \ and the server will send its measurements to the client.\n   Example:\n    \
    \     Measurements: l=22, j=13, pl=0.10, bw=\n   Where \"l\" stands for latency,\
    \ \"j\" for jitter, \"pl\" for packet loss,\n   and \"bw\" for bandwidth.  The\
    \ bandwidth value is omitted, as it is not\n   measured at this stage.\n   Optionally\
    \ the PING request can include a Timestamp header field with\n   the time in which\
    \ the message has been sent.  In the case that the\n   header field is present,\
    \ the server MUST include the header field in\n   the response without changing\
    \ the value.\n   A minimum number of PING messages MUST be exchanged in order\
    \ to be\n   able to measure latency, jitter, and packet loss with certain\n  \
    \ accuracy (at least 256 samples are RECOMMENDED to get an accurate\n   packet\
    \ loss measurement).  Both the client and the server calculate\n   the respective\
    \ measured parameter values.  The mechanisms to\n   calculate the different parameters\
    \ are described in Section 7.3.\n   At the end of this stage 0, there are three\
    \ possibilities:\n   *  The latency, jitter, and packetloss constraints are reached\
    \ in\n      both directions\n   *  The latency, jitter, and packetloss constraints\
    \ are not reached in\n      one or both directions\n   In the first case, Stage\
    \ 0 is finished.  The client and server are\n   ready for Stage 1: bandwidth and\
    \ packet loss measurement.  The client\n   moves to stage 1 by sending a READY\
    \ message that includes the header\n   field, \"Stage: 1\".\n   If the bandwidth\
    \ constraints are either empty or have a value of\n   zero, the Negotiation phase\
    \ MUST terminate, and both client and\n   server may initiate the Continuity phase.\
    \  In this case, client moves\n   to the Continuity phase by sending a READY message\
    \ that includes the\n   header field, \"Stage: 2\".\n   The second case, in which\
    \ one or more quality constraints have not\n   been met, is detailed in Section\
    \ 7.5.4.\n"
- title: '7.5.2.  Stage 1: Measurement of Bandwidth and Packet Loss'
  contents:
  - "7.5.2.  Stage 1: Measurement of Bandwidth and Packet Loss\n   This stage begins\
    \ in a similar way to stage 0, sending a READY\n   request over TCP.  The value\
    \ of the READY message's Stage header\n   field is 1.  The server answers with\
    \ a Q4S 200 OK message to\n   synchronize the initiation of the measurements as\
    \ shown in Figure 9.\n           | Client                                Server\
    \   |\n           |      --------- Q4S READY 1 ----------->        |\n       \
    \    |      <-------- Q4S 200 OK -------------        |\n           |      ---------\
    \ Q4S BWIDTH  ----------->        |\n           |      <-------- Q4S BWIDTH  ------------\
    \        |\n           |      --------- Q4S BWIDTH  ----------->        |\n  \
    \         |      <-------- Q4S BWIDTH  ------------        |\n          Figure\
    \ 9: Starting Bandwidth and Packet Loss Measurement\n   Client Request:\n   =========================\n\
    \          READY q4s://www.example.com Q4S/1.0\n          User-Agent: q4s-ua-experimental-1.0\n\
    \          Stage: 1\n          Session-Id: 53655765\n          Content-Length:\
    \ 0\n   =========================\n   Server Response:\n   =========================\n\
    \     Q4S/1.0 200 OK\n          Session-Id: 53655765\n          Stage: 1\n   \
    \       Content-Length: 0\n   =========================\n   Just after receiving\
    \ the 200 OK, both the client and the server MUST\n   start sending BWIDTH messages\
    \ simultaneously using the UDP \"q4s\"\n   ports.  Section 7.3.3 describes the\
    \ bandwidth measurement in detail.\n   At the end of this stage 1, there are three\
    \ possibilities:\n   *  The bandwidth and packetloss constraints are reached in\
    \ both\n      directions.\n   *  The bandwidth and packetloss constraints are\
    \ not reached in one or\n      both directions.\n   In the first case, Stage 1\
    \ is finished.  The client and server are\n   ready for the Continuity phase.\
    \  The client moves to this phase by\n   sending a READY message that includes\
    \ the header field, \"Stage: 2\".\n   The server answer MUST be 200 OK as shown\
    \ in Figure 10.\n           | Client                                Server   |\n\
    \           |     ---------  Q4S READY 2 -------------->     |\n           | \
    \    <---- Q4S 200 OK with trigger URI-----     |\n           |     ---------\
    \   HTTP GET ---------------->     |\n           |            (Application starts)\
    \                |\n             Figure 10: Trigger the Application Using HTTP\
    \ URI\n   Client Request:\n   =========================\n   READY q4s://www.example.com\
    \ Q4S/1.0\n   User-Agent: q4s-ua-experimental-1.0\n   Stage: 2\n   Session-Id:\
    \ 53655765\n   Content-Length: 0\n   =========================\n   Server Answer:\n\
    \   =========================\n   Q4S/1.0 200 OK\n   Date: Mon, 10 Jun 2010 10:00:01\
    \ GMT\n   Session-Id: 53655765\n   Trigger-URI: http://www.example.com/app_start\n\
    \   Expires: 3000\n   Content-Type: application/sdp\n   Signature: 6ec1ba40e2adf2d783de530ae254acd4f3477ac4\n\
    \   Content-Length: 131\n   (SDP not shown)\n   =========================\n  \
    \ If the Trigger-URI header field is present, the client SHOULD send an\n   HTTP\
    \ request to this URI.\n   The second case, with violated network constraints,\
    \ is explained in\n   Section 7.5.4.\n"
- title: 7.5.3.  Quality Constraints Not Reached
  contents:
  - "7.5.3.  Quality Constraints Not Reached\n   After finishing Stage 1 of the Negotiation\
    \ phase, the client and the\n   server have each other's measured parameter values\
    \ as these have been\n   exchanged in the Measurements header fields of the PING\
    \ and BWIDTH\n   messages.  If there is one or more parameters that do not comply\
    \ with\n   the uplink or downlink application constraints required, both the\n\
    \   server and the client are aware of it.\n   If there is any quality parameter\
    \ that does not meet the uplink or\n   downlink quality constraints specified\
    \ in the SDP message, two\n   scenarios are possible depending on the specified\
    \ alerting mode (if\n   not present, the default value is Reactive alerting mode):\n\
    \   (a)  Q4S-aware-network alerting mode: the server MUST send a Q4S-\n      \
    \  ALERT message to the client including the digital Signature\n        header\
    \ field, and the client MUST answer with the same Q4S-ALERT\n        message.\
    \  The Signature header field contains the signed hash\n        value of the SDP\
    \ body in order to protect all the SDP data, and\n        therefore it MUST contain\
    \ the \"measurement\" parameters in the\n        body.\n      Server request\n\
    \      Q4S-ALERT q4s://www.example.com Q4S/1.0\n      Host: www.example.com\n\
    \      User-Agent: q4s-ua-experimental-1.0\n      Session-Id: 53655765\n     \
    \ Content-Type: application/sdp\n      Content-Length: 142\n      v=0\n      o=q4s-UA\
    \ 53655765 2353687637 IN IP4 192.0.2.33\n      s=Q4S\n      i=Q4S parameters\n\
    \      t=0 0\n      a=qos-level:1/2\n      a=alerting-mode: Q4S-aware-network\n\
    \      a=alert-pause:5000\n      a=public-address:client IP4 198.51.100.51\n \
    \     a=public-address:server IP4 198.51.100.58\n      a=latency:40\n      a=jitter:10/10\n\
    \      a=bandwidth:20/6000\n      a=packetloss:0.50/0.50\n      a=flow:app downlink\
    \ TCP/10000-20000\n      a=flow:app uplink TCP/56000\n      a=flow:q4s downlink\
    \ UDP/55000\n      a=flow:q4s downlink TCP/55001\n      a=flow:q4s uplink UDP/56000\n\
    \      a=flow:q4s uplink TCP/56001\n      a=measurement:procedure default(50/50,50/50,5000,256/256,256/256)\n\
    \      a=measurement:latency 30\n      a=measurement:jitter 6/4\n      a=measurement:bandwidth\
    \ 200/4000\n      a=measurement:packetloss 0.20/0.33\n        At this point, both\
    \ the client and server keep on measuring but\n        without sending new Q4S-ALERT\
    \ messages during the \"alert-pause\"\n        milliseconds.\n   (b)  Reactive\
    \ alerting mode: the server stack MUST send an alert\n        notification to\
    \ the Actuator, and the Actuator MUST answer with\n        an acknowledgement\
    \ to the received alert notification.  The\n        alert notification sent to\
    \ the Actuator by the server stack\n        doesn't follow Q4S message style but\
    \ should have all the\n        information the Actuator will need for the actions\
    \ to be taken,\n        which will be implementation dependent.\n   At this point\
    \ during Negotiation phase, both the client and server\n   keep on measuring without\
    \ sending new alert notifications to the\n   Actuator during the \"alert-pause\"\
    \ milliseconds specified in the SDP.\n   This way, both client and server will\
    \ detect any improvement in\n   network conditions as soon as the network reacts.\
    \  The application\n   can start as soon as the number of measurements indicated\
    \ in the\n   \"measurement:procedure\" attribute indicates that the quality\n\
    \   parameters are met.\n   The same applies to Continuity phase: the measurement\
    \ dialog between\n   client and server must not be interrupted by any possible\
    \ ALERT\n   message.\n"
- title: 7.5.3.1.  Actuator Role
  contents:
  - "7.5.3.1.  Actuator Role\n   The actuator receives notifications of unmet requirements\
    \ from the\n   Q4S server stack and acts upon the application or the network policy\n\
    \   server, according to logic out of scope of this protocol.\n   The Actuator\
    \ logic activates mechanisms at the application level and/\n   or the network\
    \ level based on a quality level dictionary, in which\n   the meaning of each\
    \ level is implementation dependent, and each level\n   involves different actions\
    \ based on rules to keep a certain user\n   experience quality.\n   The type of\
    \ actions that an Actuator can take at the application\n   level are application\
    \ dependent and MAY involve:\n   *  Reduction of application functionalities,\
    \ such as limitation of\n      application speed or application options.\n   *\
    \  Reduction of application resources usage, such as reduction of\n      frames\
    \ per second in a video application or any other parameter\n      modification\
    \ in order to adapt to network conditions.\n   Apart from actions at the application\
    \ level, the Actuator MAY act at\n   the network level if a network policy server\
    \ is available.\n"
- title: 7.5.3.2.  Policy Server Role
  contents:
  - "7.5.3.2.  Policy Server Role\n   A network policy server may be part of the Reactive\
    \ scenario, and it\n   is in charge of managing network quality provision.  A\
    \ network policy\n   server may implement all or some of these features (but\n\
    \   implementation is not exclusive to):\n   *  Server validation in terms of\
    \ quality constraints\n   *  Authentication (Signature validation) and security\
    \ (blocking of\n      malicious clients)\n   *  Policy rules (the following rules\
    \ are only examples):\n      -  Maximum quality level allowed for the ACP\n  \
    \    -  Time bands allowed for providing quality sessions\n      -  Number of\
    \ simultaneous quality sessions allowed\n      -  Maximum time used by allowed\
    \ quality sessions\n      -  Etc.\n   If any of the policy rules fail, a Q4S-ALERT\
    \ message MUST be answered\n   by a 6xx error indicating the cause.\n"
- title: 7.5.4.  "qos-level" Changes
  contents:
  - "7.5.4.  \"qos-level\" Changes\n   If any constraint was violated, the server\
    \ MAY trigger a Q4S-ALERT\n   asking for a higher \"qos-level\" attribute.  The\
    \ maximum \"qos-level\"\n   allowed is 9 for both uplink and downlink.\n   If\
    \ the \"qos-level\" has reached the maximum value for the downlink or\n   uplink\
    \ without matching the constraints, then a CANCEL request MUST\n   be sent by\
    \ the client using the TCP port determined in the Handshake\n   phase in order\
    \ to release the session.  In reaction to the reception\n   of the CANCEL request,\
    \ the server MUST send a CANCEL request, too.\n   If no CANCEL request is received,\
    \ the expiration time cancels the\n   session on the server side.\n   Client Request:\n\
    \   =========================\n   CANCEL q4s://www.example.com Q4S/1.0\n   User-Agent:\
    \ q4s-ua-experimental-1.0\n   Session-Id: 53655765\n   Content-Type: application/sdp\n\
    \   Content-Length: 142\n   (SDP not shown)\n   =========================\n  \
    \ Server Request in reaction to Client Request:\n   =========================\n\
    \   CANCEL q4s://www.example.com Q4S/1.0\n   Session-Id: 53655765\n   Expires:\
    \ 0\n   Content-Type: application/sdp\n   Signature: 6ec1ba40e2adf2d783de530ae254acd4f3477ac4\n\
    \   Content-Length: 131\n   (SDP not shown)\n   =========================\n"
- title: 7.6.  Continuity Phase
  contents:
  - "7.6.  Continuity Phase\n   During the Negotiation phase, latency, jitter, bandwidth,\
    \ and packet\n   loss have been measured.  During the Continuity phase, bandwidth\
    \ will\n   not be measured again because bandwidth measurements may disturb\n\
    \   application performance.\n   This phase is supposed to be executed at the\
    \ same time as the real-\n   time application is being used.\n   This document\
    \ only covers the \"default\" procedure.  The continuity\n   operation with the\
    \ \"default\" procedure is based on a sliding window\n   of samples.  The number\
    \ of samples involved in the sliding window may\n   be different for jitter and\
    \ latency than for packet loss calculations\n   according to the fifth and sixth\
    \ parameters of the\n   \"measurement:procedure\" attribute.  In the example,\
    \ shown in\n   Figure 11, the jitter and latency sliding window comprises 40\n\
    \   samples, whereas the size of the packet loss sliding window is 100\n   samples:\n\
    \   a=measurement:procedure default(50/50,75/75,5000,40/40,100/100)\n   In addition,\
    \ the sizes of these windows are configurable per\n   direction: uplink and downlink\
    \ values may differ.\n   PING requests are sent continuously (in both directions),\
    \ and when\n   the Sequence-Number header field reaches the maximum value, the\n\
    \   client continues sending PING messages with the Sequence-Number\n   header\
    \ field starting again at zero.  When the server PING Sequence-\n   Number header\
    \ field reaches the maximum value, it does the same,\n   starting again from zero.\n\
    \   On the client side, the measured values of downlink jitter, downlink\n   packet\
    \ loss, and latency are calculated using the last samples,\n   discarding older\
    \ ones, in a sliding window schema.\n          | 55 56 57 . . . 253 254 255 0\
    \ 1 2 . . . 55 56     |\n          |        A                                \
    \   A     |\n                     Figure 11: Sliding Samples Window\n   Only if\
    \ the server detects that the measured values (downlink or\n   uplink jitter,\
    \ packet loss, or latency) are not reaching the quality\n   constraints, a Q4S-ALERT\
    \ is triggered and sent either to the client\n   or to the Actuator, depending\
    \ on the alerting mode, and the \"alert-\n   pause\" timer is started.\n   In\
    \ the Q4S-aware-network alerting mode shown in Figure 12, if the\n   client receives\
    \ a Q4S-ALERT message, it MUST answer by sending the\n   Q4S-ALERT request message\
    \ including the SDP (with its corresponding\n   digital signature) back to the\
    \ server.\n   Both client and server will keep performing measurements, but Q4S-\n\
    \   ALERT messages MUST NOT be sent during \"alert-pause\" milliseconds.\n   The\
    \ operations needed to act on the network and the agents in charge\n   of them\
    \ are out of scope of this document.\n           | Client                    \
    \  Server             |\n           |   ----------- PING ---------->         \
    \        |\n           |   <--------- 200 OK ----------                 |\n  \
    \         |   <------- Q4S-ALERT ---------                 |\n           |   --------\
    \ Q4S-ALERT -------->                 |\n           |   <---------- PING -----------\
    \                 |\n           |   ---------- 200 OK --------->             \
    \    |\n           |   ----------- PING ---------->                 |\n      \
    \     |   <--------- 200 OK ----------                 |\n           |   <----------\
    \ PING -----------                 |\n           |   ---------- 200 OK --------->\
    \                 |\n          Figure 12: Continuity in Q4S-Aware-Network Alerting\
    \ Mode\n   In the Reactive scenario shown in Figure 13, if the server detects\n\
    \   that the measured values (downlink or uplink jitter, packet loss, or\n   latency)\
    \ are not reaching the quality constraints, an alert\n   notification is triggered\
    \ and sent to the Actuator.  The Actuator\n   MUST then answer to the server stack\
    \ with an alert acknowledgement.\n   The measurement dialog between the client\
    \ and the server MUST NOT be\n   interrupted by any possible ALERT message.\n\
    \           | Client             Server             Actuator |\n           | \
    \  --- PING ---------->                         |\n           |   <-- 200 OK----------\
    \                         |\n           |   <----- PING --------             \
    \            |\n           |   <--- 200 OK -------- ---- alert              |\n\
    \           |   --- PING ----------> <--- alert              |\n           | \
    \  <-- 200 OK----------                         |\n           |   <----- PING\
    \ --------                         |\n           |   --- 200 OK -------->    \
    \                     |\n              Figure 13: Continuity in Reactive Alerting\
    \ Mode\n"
- title: 7.7.  Termination Phase
  contents:
  - "7.7.  Termination Phase\n   The Termination phase is the endpoint for the established\
    \ Q4S session\n   that is reached in the following cases:\n   *  A CANCEL message\
    \ has been received.  The client sends a CANCEL\n      message due to the network's\
    \ inability to meet the required\n      quality constraints.  The client and server\
    \ application will be\n      notified by their respective Q4S stacks.\n   *  Session\
    \ expires: if after the Expires time, no client or server\n      activity is detected,\
    \ that end cancels the session.\n   *  A BEGIN message has been received by the\
    \ server.  The pre-existing\n      Q4S quality session is canceled, and a new\
    \ session will be\n      initiated.\n   The meaning of the Termination phase in\
    \ terms of the release of\n   resources or accounting is application dependent\
    \ and out of scope of\n   the Q4S protocol.\n   In the Reactive alerting mode,\
    \ Q4S CANCEL messages received by the\n   Q4S server must cause the server stack\
    \ to send cancel notifications\n   to the Actuator in order to release possible\
    \ assigned resources for\n   the session.\n"
- title: 7.7.1.  Sanity Check of Quality Sessions
  contents:
  - "7.7.1.  Sanity Check of Quality Sessions\n   A session may finish due to several\
    \ reasons (client shutdown, client\n   CANCEL request, constraints not reached,\
    \ etc.), and any session\n   finished MUST release the assigned resources.\n \
    \  In order to release the assigned server resources for the session,\n   the\
    \ Expires header field indicates the maximum interval of time\n   without exchanging\
    \ any Q4S message.\n"
- title: 7.8.  Dynamic Constraints and Flows
  contents:
  - "7.8.  Dynamic Constraints and Flows\n   Depending on the nature of the application,\
    \ the quality constraints\n   to be reached may evolve, changing some or all quality\
    \ constraint\n   values in any direction.\n   The client MUST be able to deal\
    \ with this possibility.  When the\n   server sends an SDP document attached to\
    \ a response (200 OK or Q4S-\n   ALERT, etc.), the client MUST take all the new\
    \ received values,\n   overriding any previous value in use.\n   The dynamic changes\
    \ on the quality constraints can be a result of two\n   possibilities:\n   * \
    \ The application communicates to the Q4S server a change in the\n      constraints.\
    \  In this case, the application requirements can\n      evolve, and the Q4S server\
    \ will be aware of them.\n   *  The application uses TCP flows.  In that case,\
    \ in order to\n      guarantee a constant throughput, the nature of TCP behavior\
    \ forces\n      the use of a composite constraint function, which depends on RTT,\n\
    \      packet loss, and a window control mechanism implemented in each\n     \
    \ TCP stack.\n   TCP throughput can be less than actual bandwidth if the Bandwidth-\n\
    \   Delay Product (BDP) is large, or if the network suffers from a high\n   packet\
    \ loss rate.  In both cases, TCP congestion control algorithms\n   may result\
    \ in a suboptimal performance.\n   Different TCP congestion control implementations\
    \ like Reno [RENO],\n   High Speed TCP [RFC3649], CUBIC [CUBIC], Compound TCP\
    \ (CTCP) [CTCP],\n   etc., reach different throughputs under the same network\
    \ conditions\n   of RTT and packet loss.  In all cases, depending on the RTT-measured\n\
    \   value, the Q4S server could dynamically change the packetloss\n   constraints\
    \ (defined in the SDP) in order to make it possible to\n   reach a required throughput\
    \ or vice versa (using\n   \"measurement:packetloss\" to change dynamically the\
    \ latency\n   constraints).\n   A general guideline for calculating the packet\
    \ loss constraint and\n   the RTT constraint consists of approximating the throughput\
    \ by using\n   a simplified formula, which should take into account the TCP stack\n\
    \   implementation of the receiver, in addition to the RTT and packet\n   loss:\n\
    \             Th= Function( RTT, packet loss, ...)\n   Then, depending on RTT-measured\
    \ values, set dynamically the packet\n   loss constraint.\n   It is possible to\
    \ easily calculate a worst-case boundary for the Reno\n   algorithm, which should\
    \ ensure for all algorithms that the target\n   throughput is actually achieved,\
    \ except that high-speed algorithms\n   will then have even larger throughput\
    \ if more bandwidth is available.\n   For the Reno algorithm, the Mathis formula\
    \ may be used [RENO] for the\n   upper bound on the throughput:\n            \
    \ Th <= (MSS/RTT)*(1 / sqrt{p})\n   In the absence of packet loss, a practical\
    \ limit for the TCP\n   throughput is the receiver_window_size divided by the\
    \ RTT.  However,\n   if the TCP implementation uses a window scale option, this\
    \ limit can\n   reach the available bandwidth value.\n"
- title: 7.9.  "qos-level" Upgrade and Downgrade Operation
  contents:
  - "7.9.  \"qos-level\" Upgrade and Downgrade Operation\n   Each time the server\
    \ detects a violation of constraints, the alert\n   mechanism is triggered, the\
    \ \"alert-pause\" timer is started, and the\n   \"qos-level\" is increased.  When\
    \ this happens repeatedly, and the\n   \"qos-level\" reaches its maximum value\
    \ (value 9), the session is\n   canceled.  But when the violation of constraints\
    \ stops before\n   reaching \"qos-level\" maximum value, the recovery mechanism\
    \ allows for\n   the \"qos-level\" upgrade gradually.\n   This downgrade and upgrade\
    \ of \"qos-level\" is explained with the\n   following example:\n   1.  A Q4S\
    \ session is initiated successfully with \"qos-level=0\".\n   2.  During the Continuity\
    \ phase, violation of constraints is\n       detected; the \"qos-level\" is increased\
    \ to 1, a Q4S-ALERT is sent\n       by the server to the client, and an \"alert-pause\"\
    \ timer is\n       started.\n   3.  The \"alert-pause\" timer expires, and still\
    \ a violation of\n       constraints is detected; the \"qos-level\" is increased\
    \ to 2, a\n       Q4S-ALERT is sent by the server to the client, and an \"alert-\n\
    \       pause\" timer is started.\n   4.  The \"alert-pause\" timer expires, but\
    \ the violation of constraints\n       has stopped; the \"recovery-pause\" timer\
    \ is started.\n   5.  The \"recovery-pause\" timer expires, and no violation of\n\
    \       constraints has been detected.  Meanwhile, the \"qos-level\" is\n    \
    \   decreased to 1, a Q4S-RECOVERY is sent by the server to the\n       client,\
    \ and the \"recovery-pause\" timer is started again.\n   6.  The \"recovery-pause\"\
    \ timer expires again, and no violation of\n       constraints has been detected.\
    \  Meanwhile, the \"qos-level\" is\n       decreased to 0, and a Q4S-RECOVERY\
    \ is sent by the server to the\n       client.  The \"recovery-pause\" timer is\
    \ not started this time as\n       the \"qos-level\" has reached its initial value.\n\
    \   When the network configuration allows for the possibility of managing\n  \
    \ Q4S flows and application flows independently (either is a network-\n   based\
    \ QoS or a Q4S-aware network), the \"qos-level\" downgrade process\n   could be\
    \ managed more efficiently using a strategy that allows for\n   carrying out \"\
    qos-level\" downgrades excluding application flows from\n   SDP dynamically. \
    \ The Q4S flows would be downgraded to allow for\n   measurements on a lower quality\
    \ level without interference of the\n   application flows.  A Q4S client MUST\
    \ allow this kind of SDP\n   modification by the server.\n   Periodically (every\
    \ several minutes, depending on the implementation)\n   a Q4S-ALERT could be triggered,\
    \ in which the level is downgraded for\n   Q4S flows, excluding application flows\
    \ from the embedded SDP of that\n   request.\n   This mechanism allows the measurement\
    \ at lower levels of quality\n   while application flows continue using a higher\
    \ \"qos-level\" value.\n   *  If the measurements in the lower level meet the\
    \ quality\n      constraints, then a Q4S-RECOVERY message to this lower \"qos-level\"\
    \n      may be triggered, in which the SDP includes the application flows\n  \
    \    in addition to the Q4S flows.\n   *  If the measurements in the lower level\
    \ do not meet the\n      constraints, then a new Q4S-ALERT to the previous \"\
    qos-level\" MUST\n      be triggered, in which the SDP includes only the Q4S flows.\n\
    \           | qos-level                                      |\n           | \
    \  A                                            |\n           |  4|          \
    \                                  |\n           |  3|             +------+  \
    \                     |\n           |  2|        +----+      +----+     +--- \
    \        |\n           |  1|   +----+                +-----+            |\n  \
    \         |  0+---+---------------------------------> time |\n               \
    \ Figure 14: Possible Evolution of \"qos-level\"\n   This mechanism, illustrated\
    \ in Figure 14, avoids the risk of\n   disturbing the application while the measurements\
    \ are being run in\n   lower levels.  However, this optional optimization of resources\
    \ MUST\n   be used carefully.\n   The chosen period to measure a lower \"qos-level\"\
    \ is implementation\n   dependent.  Therefore, it is not included as a\n   \"\
    measurement:procedure\" parameter.  It is RECOMMENDED to use a large\n   value,\
    \ such as 20 minutes.\n"
- title: 8.  General User Agent Behavior
  contents:
  - '8.  General User Agent Behavior

    '
- title: 8.1.  Roles in Peer-to-Peer Scenarios
  contents:
  - "8.1.  Roles in Peer-to-Peer Scenarios\n   In order to allow peer-to-peer applications,\
    \ a Q4S User Agent (UA)\n   MUST be able to assume both the client and server\
    \ role.  The role\n   assumed depends on who sends the first message.\n   In a\
    \ communication between two UAs, the UA that first sends the Q4S\n   BEGIN request\
    \ to start the Handshake phase shall assume the client\n   role.\n   If both UAs\
    \ send the BEGIN request at the same time, they will wait\n   for a random time\
    \ to restart again as shown in Figure 15.\n   Otherwise, an UA may be configured\
    \ to act only as server (e.g.,\n   content provider's side).\n           | UA(Client)\
    \                         UA(Server) |\n           |     -------- Q4S BEGIN ------------->\
    \         |\n           |     <------- Q4S BEGIN --------------         |\n  \
    \         |     ------- Q4S BEGIN -------------->         |\n           |    \
    \ <------ Q4S 200 OK --------------         |\n                            Figure\
    \ 15: P2P Roles\n"
- title: 8.2.  Multiple Quality Sessions in Parallel
  contents:
  - "8.2.  Multiple Quality Sessions in Parallel\n   A Q4S session is intended to\
    \ be used for an application.  This means\n   that for using the application,\
    \ the client MUST establish only one\n   Q4S session against the server.  Indeed,\
    \ the relation between the\n   Session-Id and the application is 1 to 1.\n   If\
    \ a user wants to participate in several independent Q4S sessions\n   simultaneously\
    \ against different servers (or against the same\n   server), it can execute different\
    \ Q4S clients to establish separately\n   different Q4S sessions, but it is NOT\
    \ RECOMMENDED because:\n   *  The establishment of a new Q4S session may affect\
    \ other running\n      applications over other Q4S sessions during bandwidth measurement.\n\
    \   *  If the Negotiation phase is executed separately before running any\n  \
    \    application, the summation of bandwidth requirements could not be\n     \
    \ met when the applications are running in parallel.\n"
- title: 8.3.  General Client Behavior
  contents:
  - "8.3.  General Client Behavior\n   A Q4S client has different behaviors.  We will\
    \ use letters X, Y, and\n   Z to designate each different behavior (follow the\
    \ letters in\n   Figure 16 and their descriptions below).\n   X)  When it sends\
    \ messages over TCP (methods BEGIN, READY, Q4S-ALERT,\n       Q4S-RECOVERY, and\
    \ CANCEL), it behaves strictly like a state\n       machine that sends requests\
    \ and waits for responses.  Depending\n       on the response type, it enters\
    \ into a new state.\n   When it sends UDP messages (methods PING and BWIDTH),\
    \ a Q4S client is\n   not strictly a state machine that sends messages and waits\
    \ for\n   responses because of the following:\n   Y)  During the measurement of\
    \ latency, jitter, and packet loss, the\n       PING requests are sent periodically,\
    \ not just after receiving the\n       response to the previous request.  In addition,\
    \ the client MUST\n       answer the PING requests coming from the server, therefore\
    \ the\n       client assumes temporarily the role of a server.\n   Z)  During\
    \ the bandwidth and packet loss measurement stage, the\n       client does not\
    \ expect to receive responses when sending BWIDTH\n       requests to the server.\
    \  In addition, it MUST receive and process\n       all server messages in order\
    \ to achieve the downlink measurement.\n   The Q4S-ALERT and CANCEL may have a\
    \ conventional answer if an error\n   is produced, otherwise the corresponding\
    \ answer is formatted as a\n   request message.\n     | Handshake |    Negotiation\
    \         |Continuity |Termination|\n     |   Phase   |      Phase           \
    \  |   Phase   |  Phase    |\n     | X ---------> Y --> X --> Z --> X ---> Y -->\
    \ X ---> X       |\n     |           |  A     |     A     |   |  A     |  |  \
    \         |\n                   Figure 16: Phases and Client Behaviors\n"
- title: 8.3.1.  Generating Requests
  contents:
  - "8.3.1.  Generating Requests\n   A valid Q4S request formulated by a client MUST,\
    \ at a minimum,\n   contain the following header fields:\n   If no SDP is included:\
    \  the header fields Session-Id and Sequence-\n      Number are mandatory.\n \
    \  If SDP is included:  the Session-Id is embedded into the SDP,\n      therefore\
    \ the inclusion of the Session-Id header field is\n      optional, but if present,\
    \ must have the same value.  Measurements\n      are embedded into the SDP only\
    \ for Q4S-ALERT messages in order to\n      be signed.\n   At any time, if the\
    \ server sends new SDP with updated values, the\n   client MUST take it into account.\n"
- title: 8.4.  General Server Behavior
  contents:
  - "8.4.  General Server Behavior\n   If a server does not understand a header field\
    \ in a request (that is,\n   the header field is not defined in this specification\
    \ or in any\n   supported extension), the server MUST ignore that header field\
    \ and\n   continue processing the message.\n   The role of the server is changed\
    \ at Negotiation and Continuity\n   phases, in which the server MUST send packets\
    \ to measure jitter,\n   latency, and bandwidth.  Therefore, the different behaviors\
    \ of the\n   server are (follow the letters in Figure 17 and their descriptions\n\
    \   below):\n   R)  When the client sends messages over TCP (methods BEGIN, READY\n\
    \       Q4S-ALERT, Q4S-RECOVERY, and CANCEL), it behaves strictly like a\n   \
    \    state machine that receives messages and sends responses.\n   When the client\
    \ begins to send UDP messages (methods PING and\n   BWIDTH), a Q4S server is not\
    \ strictly a state machine that receives\n   messages and sends responses because\
    \ of the following:\n   S)  During the measurement of latency, jitter, and packet\
    \ loss, the\n       PING requests are sent periodically by the client and also\
    \ by the\n       server.  In this case, the server behaves as a server answering\n\
    \       client requests but also behaves temporarily as a client, sending\n  \
    \     PING requests toward the client and receiving responses.\n   T)  During\
    \ bandwidth and packet loss measurement, the server sends\n       BWIDTH requests\
    \ to the client.  In addition, it MUST receive and\n       process client messages\
    \ in order to achieve the uplink\n       measurement.\n   The Q4S-ALERT and CANCEL\
    \ may have a conventional answer if an error\n   is produced, otherwise the corresponding\
    \ answer is formatted as a\n   request message.\n     | Handshake |    Negotiation\
    \         |Continuity |Termination|\n     |   Phase   |      Phase           \
    \  |   Phase   |  Phase    |\n     | R ---------> S --> R --> T --> R ---> S -->\
    \ R ---> R       |\n     |           |  A     |     A     |   |  A     |  |  \
    \         |\n                   Figure 17: Phases and Server Behaviors\n"
- title: 9.  Implementation Recommendations
  contents:
  - '9.  Implementation Recommendations

    '
- title: 9.1.  Default Client Constraints
  contents:
  - "9.1.  Default Client Constraints\n   To provide a default configuration, it would\
    \ be good if the client\n   had a configurable set of quality headers in the implementation\n\
    \   settings menu.  Otherwise, these quality headers will not be present\n   in\
    \ the first message.\n   Different business models (out of scope of this proposal)\
    \ may be\n   achieved: depending on who pays for the quality session, the server\n\
    \   can accept certain client parameters sent in the first message, or\n   force\
    \ billing parameters on the server side.\n"
- title: 9.2.  Latency and Jitter Measurements
  contents:
  - "9.2.  Latency and Jitter Measurements\n   Different client and server implementations\
    \ may send a different\n   number of PING messages for measuring, although at\
    \ least 255 messages\n   should be considered to perform the latency measurement.\
    \  The Stage 0\n   measurements may be considered ended only when neither the\
    \ client nor\n   server receive new PING messages after an implementation-dependent\n\
    \   guard time.  Only after, the client can send a \"READY 1\" message.\n   In\
    \ execution systems, where the timers are not accurate, a\n   recommended approach\
    \ consists of including the optional Timestamp\n   header field in the PING request\
    \ with the time in which the message\n   has been sent.  This allows an accurate\
    \ measurement of the jitter\n   even with no identical intervals of time between\
    \ PINGs.\n"
- title: 9.3.  Bandwidth Measurements
  contents:
  - "9.3.  Bandwidth Measurements\n   In programming languages or operating systems\
    \ with limited timers or\n   clock resolution, it is recommended to use an approach\
    \ based on\n   several intervals to send messages of 1KB (= 8000 bits) in order\
    \ to\n   reach the required bandwidth consumption, using a rate as close as\n\
    \   possible to a constant rate.\n   For example, if the resolution is 1 millisecond,\
    \ and the bandwidth to\n   reach is 11 Mbps, a good approach consists of sending:\n\
    \         1 message of 1KB every 1 millisecond +\n         1 message of 1KB every\
    \ 3 milliseconds +\n         1 message of 1KB every 23 milliseconds\n   The number\
    \ of intervals depends on the required bandwidth and\n   accuracy that the programmer\
    \ wants to achieve.\n   Considering messages of 1KB (= 8000 bits), a general approach\
    \ to\n   determine these intervals is the following:\n   (1)  Compute target bandwidth\
    \ / 8000 bits.  In the example above, it\n        is 11 Mbps / 8000 = 1375 messages\
    \ per second.\n   (2)  Divide the number of messages per second by 1000 to determine\n\
    \        the number of messages per millisecond: 1375 / 1000 = 1.375.\n      \
    \  The integer value is the number of messages per millisecond (in\n        this\
    \ case, one).  The pending bandwidth is now 375 messages per\n        second.\n\
    \   (3)  To achieve the 375 messages per second, use a submultiple of\n      \
    \  1000, which must be less than 375:\n            1000 / 2 = 500 > 375\n    \
    \        1000 / 3 = 333 < 375\n        In this case, a message every 3 ms is suitable.\
    \  The new pending\n        target bandwidth is 375 - 333 = 42 messages per second.\n\
    \   (4)  Repeat the same strategy as point 3 to reach the pending\n        bandwidth.\
    \  In this case, 23 ms is suitable because of the\n        following:\n      \
    \      1000 / 22 = 45 > 42\n            1000 / 23 = 43 > 42\n            1000\
    \ / 24 = 41.6 < 42\n   We can choose 24 ms, but then we need to cover an additional\
    \ 0.4\n   messages per second (42 - 41.6 = 0.4), and 43 is a number higher than\n\
    \   42 but very close to it.\n   In execution systems where the timers are not\
    \ accurate, a recommended\n   approach consists of checking at each interval the\
    \ number of packets\n   that should have been sent at this timestamp since origin\
    \ and send\n   the needed number of packets in order to reach the required\n \
    \  bandwidth.\n   The shorter the packets used, the more constant the rate of\
    \ bandwidth\n   measurement.  However, this may stress the execution system in\
    \ charge\n   of receiving and processing packets.  As a consequence, some packets\n\
    \   may be lost because of stack overflows.  To deal with this potential\n   issue,\
    \ a larger packet is RECOMMENDED (2KB or more), taking into\n   account the overhead\
    \ produced by the chunks' headers.\n"
- title: 9.4.  Packet Loss Measurement Resolution
  contents:
  - "9.4.  Packet Loss Measurement Resolution\n   Depending on the application nature\
    \ and network conditions, a packet\n   loss resolution less than 1% may be needed.\
    \  In such cases, there is\n   no limit to the number of samples used for this\
    \ calculation.  A\n   trade-off between time and resolution should be reached\
    \ in each case.\n   For example, in order to have a resolution of 1/10000, the\
    \ last 10000\n   samples should be considered in the packet loss measured value.\n\
    \   The problem of this approach is the reliability of old samples.  If\n   the\
    \ interval used between PING messages is 50 ms, then to have a\n   resolution\
    \ of 1/1000, it takes 50 seconds, and a resolution of\n   1/10000 takes 500 seconds\
    \ (more than 8 minutes).  The reliability of\n   a packet loss calculation based\
    \ on a sliding window of 8 minutes\n   depends on how fast network conditions\
    \ evolve.\n"
- title: 9.5.  Measurements and Reactions
  contents:
  - "9.5.  Measurements and Reactions\n   Q4S can be used as a mechanism to measure\
    \ and trigger network tuning\n   and application-level actions (i.e. lowering\
    \ video bit-rate, reducing\n   multiplayer interaction speed, etc.) in real time\
    \ in order to reach\n   the application constraints, addressing measured possible\
    \ network\n   degradation.\n"
- title: 9.6.  Instability Treatments
  contents:
  - "9.6.  Instability Treatments\n   There are two scenarios in which Q4S can be\
    \ affected by network\n   problems: loss of Q4S packets and outlier samples.\n"
- title: 9.6.1.  Loss of Control Packets
  contents:
  - "9.6.1.  Loss of Control Packets\n   Lost UDP packets (PING or BWIDTH messages)\
    \ don't cause any problems\n   for the Q4S state machine, but if TCP packets are\
    \ delivered too late\n   (which we will consider as \"lost\"), some undesirable\
    \ consequences\n   could arise.\n   Q4S does have protection mechanisms to overcome\
    \ these situations.\n   Examples:\n   *  If a BEGIN packet or its corresponding\
    \ answer is lost, after a\n      certain timeout, the client SHOULD resend another\
    \ BEGIN packet,\n      resetting the session\n   *  If a READY packet is lost,\
    \ after a certain timeout, the client\n      SHOULD resend another READY packet.\n\
    \   *  If a Q4S-ALERT request or its corresponding answer is lost, after\n   \
    \   a certain timeout, the originator SHOULD resend another Q4S-ALERT\n      packet.\n\
    \   *  If a CANCEL request or its corresponding answer is lost, after a\n    \
    \  certain timeout, the originator SHOULD resend another CANCEL\n      packet.\n"
- title: 9.6.2.  Outlier Samples
  contents:
  - "9.6.2.  Outlier Samples\n   Outlier samples are those jitter or latency values\
    \ far from the\n   general/average values of most samples.\n   Hence, the Q4S\
    \ default measurement method uses the statistical median\n   formula for latency\
    \ calculation, and the outlier samples are\n   neutralized.  This is a very common\
    \ filter for noise or errors on\n   signal and image processing.\n"
- title: 9.7.  Scenarios
  contents:
  - "9.7.  Scenarios\n   Q4S could be used in two scenarios:\n   *  client to ACP\n\
    \   *  client to client (peer-to-peer scenario)\n"
- title: 9.7.1.  Client to ACP
  contents:
  - "9.7.1.  Client to ACP\n   One server:\n   It is the common scenario in which\
    \ the client contacts the server to\n   establish a Q4S session.\n   N servers:\n\
    \   In Content Delivery Networks and in general applications where\n   delivery\
    \ of contents can be achieved by different delivery nodes, two\n   working mechanisms\
    \ can be defined:\n   Starting mode:  the end user may run Q4S against several\
    \ delivery\n      nodes and after some seconds choose the best one to start the\n\
    \      multimedia session.\n   Prevention mode:  during a streaming session, the\
    \ user keeps several\n      Q4S dialogs against different alternative delivery\
    \ nodes.  In case\n      of congestion, the end user MAY change to the best alternative\n\
    \      delivery node.\n"
- title: 9.7.2.  Client to Client
  contents:
  - "9.7.2.  Client to Client\n   In order to solve the client-to-client scenario,\
    \ a Q4S register\n   function MUST be implemented.  This allows clients to contact\
    \ each\n   other for sending the BEGIN message.  In this scenario, the Register\n\
    \   server would be used by peers to publish their Q4S-Resource-Server\n   header\
    \ and their public IP address to enable the assumption of the\n   server role.\n\
    \   The register function is out of scope of this protocol version\n   because\
    \ different HTTP mechanisms can be used, and Q4S MUST NOT force\n   any.\n"
- title: 10.  Security Considerations
  contents:
  - '10.  Security Considerations

    '
- title: 10.1.  Confidentiality Issues
  contents:
  - "10.1.  Confidentiality Issues\n   Because Q4S does not transport any application\
    \ data, Q4S does not\n   jeopardize the security of application data.  However,\
    \ other certain\n   considerations may take place, like identity impersonation\
    \ and\n   measurements privacy and integrity.\n"
- title: 10.2.  Integrity of Measurements and Authentication
  contents:
  - "10.2.  Integrity of Measurements and Authentication\n   Identity impersonation\
    \ could potentially produce anomalous Q4S\n   measurements.  If this attack is\
    \ based on spoofing of the server IP\n   address, it can be avoided using the\
    \ digital signature mechanism\n   included in the SDP.  The network can easily\
    \ validate this digital\n   signature using the public key of the server certificate.\n\
    \   Integrity of Q4S measurements under any malicious manipulation (such\n   as\
    \ a Man-in-the-Middle (MITM) attack) relies on the same mechanism,\n   the SDP\
    \ signature.\n   The Signature header field contains the signed hash value of\
    \ the SDP\n   body in order to protect all the SDP data, including the\n   measurements.\
    \  This signature not only protects the integrity of data\n   but also authenticates\
    \ the server.\n"
- title: 10.3.  Privacy of Measurements
  contents:
  - "10.3.  Privacy of Measurements\n   This protocol could be supported over IPsec.\
    \  Q4S relies on UDP and\n   TCP, and IPsec supports both.  If Q4S is used for\
    \ application-based\n   QoS, then IPsec is operationally valid; however, if Q4S\
    \ is used to\n   trigger network-based actions, then measurements could be incorrect\n\
    \   unless the IPsec ports can be a target of potential action over the\n   network\
    \ (such as prioritizing IPsec flows to measure the new,\n   upgraded state of\
    \ certain application flows).\n"
- title: 10.4.  Availability Issues
  contents:
  - "10.4.  Availability Issues\n   Any loss of connectivity may interrupt the availability\
    \ of the Q4S\n   service and may result in higher packet loss measurements, which\
    \ is\n   just the desired behavior in these situations.\n   In order to mitigate\
    \ availability issues caused by malicious attacks\n   (such as DoS and DDoS),\
    \ a good practice is to enable the Q4S service\n   only for authenticated users.\
    \  Q4S can be launched after the user is\n   authenticated by the application.\
    \  At this moment, the user's IP\n   address is known, and the Q4S service may\
    \ be enabled for this IP\n   address.  Otherwise, the Q4S service should appear\
    \ unreachable.\n"
- title: 10.5.  Bandwidth Occupancy Issues
  contents:
  - "10.5.  Bandwidth Occupancy Issues\n   Q4S bandwidth measurement is limited to\
    \ the application needs.  It\n   means that all available bandwidth is not measured,\
    \ but only the\n   fraction required by the application.  This allows other applications\n\
    \   to use the rest of available bandwidth normally.\n   However, a malicious\
    \ Q4S client could restart Q4S sessions just after\n   finishing the Negotiation\
    \ phase.  The consequence would be to waste\n   bandwidth for nothing.\n   In\
    \ order to mitigate this possible anomalous behavior, it is\n   RECOMMENDED to\
    \ configure the server to reject sessions from the same\n   endpoint when this\
    \ situation is detected.\n"
- title: 11.  Future Code Point Requirements
  contents:
  - "11.  Future Code Point Requirements\n   If the ideas described in this document\
    \ are pursued to become a\n   protocol specification, then the code points described\
    \ in this\n   document will need to be assigned by IANA.\n"
- title: 11.1.  Service Port
  contents:
  - "11.1.  Service Port\n   An assigned port would make possible a future Q4S-aware\
    \ network\n   capable of reacting by itself to Q4S alerts.  A specific port would\n\
    \   simplify the identification of the protocol by network elements in\n   charge\
    \ of making possible reactive decisions.  Therefore, the need\n   for a port assignment\
    \ by IANA may be postponed until there is the\n   need for a future Q4S-aware\
    \ network.\n   Service Name: Q4S\n   Transport Protocol(s): TCP\n   Assignee:\n\
    \      Name: Jose Javier Garcia Aranda\n      Email: jose_javier.garcia_aranda@nokia.com\n\
    \   Contact:\n      Name: Jose Javier Garcia Aranda\n      Email: jose_javier.garcia_aranda@nokia.com\n\
    \   Description:  The service associated with this request is in charge\n    \
    \     of the establishment of new Q4S sessions, and during the\n         session,\
    \ manages the handoff to a new protocol phase\n         (Handshake, Negotiation\
    \ and Continuity) as well as sends alerts\n         when measurements do not meet\
    \ the requirements.\n   Reference:  This document.  This service does not use\
    \ IP-layer\n         broadcast, multicast, or anycast communication.\n"
- title: 12.  IANA Considerations
  contents:
  - "12.  IANA Considerations\n   This document has no IANA actions.\n"
- title: 13.  References
  contents:
  - '13.  References

    '
- title: 13.1.  Normative References
  contents:
  - "13.1.  Normative References\n   [RFC7230]  Fielding, R., Ed. and J. Reschke,\
    \ Ed., \"Hypertext Transfer\n              Protocol (HTTP/1.1): Message Syntax\
    \ and Routing\",\n              RFC 7230, DOI 10.17487/RFC7230, June 2014,\n \
    \             <https://www.rfc-editor.org/info/rfc7230>.\n   [RFC7231]  Fielding,\
    \ R., Ed. and J. Reschke, Ed., \"Hypertext Transfer\n              Protocol (HTTP/1.1):\
    \ Semantics and Content\", RFC 7231,\n              DOI 10.17487/RFC7231, June\
    \ 2014,\n              <https://www.rfc-editor.org/info/rfc7231>.\n   [RFC7232]\
    \  Fielding, R., Ed. and J. Reschke, Ed., \"Hypertext Transfer\n             \
    \ Protocol (HTTP/1.1): Conditional Requests\", RFC 7232,\n              DOI 10.17487/RFC7232,\
    \ June 2014,\n              <https://www.rfc-editor.org/info/rfc7232>.\n   [RFC7233]\
    \  Fielding, R., Ed., Lafon, Y., Ed., and J. Reschke, Ed.,\n              \"Hypertext\
    \ Transfer Protocol (HTTP/1.1): Range Requests\",\n              RFC 7233, DOI\
    \ 10.17487/RFC7233, June 2014,\n              <https://www.rfc-editor.org/info/rfc7233>.\n\
    \   [RFC7234]  Fielding, R., Ed., Nottingham, M., Ed., and J. Reschke,\n     \
    \         Ed., \"Hypertext Transfer Protocol (HTTP/1.1): Caching\",\n        \
    \      RFC 7234, DOI 10.17487/RFC7234, June 2014,\n              <https://www.rfc-editor.org/info/rfc7234>.\n\
    \   [RFC7235]  Fielding, R., Ed. and J. Reschke, Ed., \"Hypertext Transfer\n \
    \             Protocol (HTTP/1.1): Authentication\", RFC 7235,\n             \
    \ DOI 10.17487/RFC7235, June 2014,\n              <https://www.rfc-editor.org/info/rfc7235>.\n\
    \   [RFC2818]  Rescorla, E., \"HTTP Over TLS\", RFC 2818,\n              DOI 10.17487/RFC2818,\
    \ May 2000,\n              <https://www.rfc-editor.org/info/rfc2818>.\n   [RFC2119]\
    \  Bradner, S., \"Key words for use in RFCs to Indicate\n              Requirement\
    \ Levels\", BCP 14, RFC 2119,\n              DOI 10.17487/RFC2119, March 1997,\n\
    \              <https://www.rfc-editor.org/info/rfc2119>.\n   [RFC8174]  Leiba,\
    \ B., \"Ambiguity of Uppercase vs Lowercase in RFC\n              2119 Key Words\"\
    , BCP 14, RFC 8174, DOI 10.17487/RFC8174,\n              May 2017, <https://www.rfc-editor.org/info/rfc8174>.\n\
    \   [RFC3986]  Berners-Lee, T., Fielding, R., and L. Masinter, \"Uniform\n   \
    \           Resource Identifier (URI): Generic Syntax\", STD 66,\n           \
    \   RFC 3986, DOI 10.17487/RFC3986, January 2005,\n              <https://www.rfc-editor.org/info/rfc3986>.\n\
    \   [RFC3629]  Yergeau, F., \"UTF-8, a transformation format of ISO\n        \
    \      10646\", STD 63, RFC 3629, DOI 10.17487/RFC3629, November\n           \
    \   2003, <https://www.rfc-editor.org/info/rfc3629>.\n   [RFC5322]  Resnick, P.,\
    \ Ed., \"Internet Message Format\", RFC 5322,\n              DOI 10.17487/RFC5322,\
    \ October 2008,\n              <https://www.rfc-editor.org/info/rfc5322>.\n  \
    \ [RFC5234]  Crocker, D., Ed. and P. Overell, \"Augmented BNF for Syntax\n   \
    \           Specifications: ABNF\", STD 68, RFC 5234,\n              DOI 10.17487/RFC5234,\
    \ January 2008,\n              <https://www.rfc-editor.org/info/rfc5234>.\n  \
    \ [RFC6234]  Eastlake 3rd, D. and T. Hansen, \"US Secure Hash Algorithms\n   \
    \           (SHA and SHA-based HMAC and HKDF)\", RFC 6234,\n              DOI\
    \ 10.17487/RFC6234, May 2011,\n              <https://www.rfc-editor.org/info/rfc6234>.\n\
    \   [RFC8017]  Moriarty, K., Ed., Kaliski, B., Jonsson, J., and A. Rusch,\n  \
    \            \"PKCS #1: RSA Cryptography Specifications Version 2.2\",\n     \
    \         RFC 8017, DOI 10.17487/RFC8017, November 2016,\n              <https://www.rfc-editor.org/info/rfc8017>.\n\
    \   [RFC3264]  Rosenberg, J. and H. Schulzrinne, \"An Offer/Answer Model\n   \
    \           with Session Description Protocol (SDP)\", RFC 3264,\n           \
    \   DOI 10.17487/RFC3264, June 2002,\n              <https://www.rfc-editor.org/info/rfc3264>.\n\
    \   [RFC4566]  Handley, M., Jacobson, V., and C. Perkins, \"SDP: Session\n   \
    \           Description Protocol\", RFC 4566, DOI 10.17487/RFC4566,\n        \
    \      July 2006, <https://www.rfc-editor.org/info/rfc4566>.\n"
- title: 13.2.  Informative References
  contents:
  - "13.2.  Informative References\n   [RFC3550]  Schulzrinne, H., Casner, S., Frederick,\
    \ R., and V.\n              Jacobson, \"RTP: A Transport Protocol for Real-Time\n\
    \              Applications\", STD 64, RFC 3550, DOI 10.17487/RFC3550,\n     \
    \         July 2003, <https://www.rfc-editor.org/info/rfc3550>.\n   [RFC0793]\
    \  Postel, J., \"Transmission Control Protocol\", STD 7,\n              RFC 793,\
    \ DOI 10.17487/RFC0793, September 1981,\n              <https://www.rfc-editor.org/info/rfc793>.\n\
    \   [RFC0792]  Postel, J., \"Internet Control Message Protocol\", STD 5,\n   \
    \           RFC 792, DOI 10.17487/RFC0792, September 1981,\n              <https://www.rfc-editor.org/info/rfc792>.\n\
    \   [QUIC]     Iyengar, J. and M. Thomson, \"QUIC: A UDP-Based Multiplexed\n \
    \             and Secure Transport\", Work in Progress, Internet-Draft,\n    \
    \          draft-ietf-quic-transport-29, 9 June 2020,\n              <https://tools.ietf.org/html/draft-ietf-quic-transport-\n\
    \              29>.\n   [RFC4656]  Shalunov, S., Teitelbaum, B., Karp, A., Boote,\
    \ J., and M.\n              Zekauskas, \"A One-way Active Measurement Protocol\n\
    \              (OWAMP)\", RFC 4656, DOI 10.17487/RFC4656, September 2006,\n  \
    \            <https://www.rfc-editor.org/info/rfc4656>.\n   [RFC5357]  Hedayat,\
    \ K., Krzanowski, R., Morton, A., Yum, K., and J.\n              Babiarz, \"A\
    \ Two-Way Active Measurement Protocol (TWAMP)\",\n              RFC 5357, DOI\
    \ 10.17487/RFC5357, October 2008,\n              <https://www.rfc-editor.org/info/rfc5357>.\n\
    \   [RFC3261]  Rosenberg, J., Schulzrinne, H., Camarillo, G., Johnston,\n    \
    \          A., Peterson, J., Sparks, R., Handley, M., and E.\n              Schooler,\
    \ \"SIP: Session Initiation Protocol\", RFC 3261,\n              DOI 10.17487/RFC3261,\
    \ June 2002,\n              <https://www.rfc-editor.org/info/rfc3261>.\n   [RFC0768]\
    \  Postel, J., \"User Datagram Protocol\", STD 6, RFC 768,\n              DOI\
    \ 10.17487/RFC0768, August 1980,\n              <https://www.rfc-editor.org/info/rfc768>.\n\
    \   [RENO]     Mathis, M., Semke, J., Mahdavi, J., and T. Ott, \"The\n       \
    \       Macroscopic Behavior of the TCP Congestion Avoidance\n              Algorithm\"\
    , ACM SIGCOMM Computer Communication Review, pp.\n              67-82, DOI 10.1145/263932.264023,\
    \ July 1997,\n              <https://doi.org/10.1145/263932.264023>.\n   [RFC3649]\
    \  Floyd, S., \"HighSpeed TCP for Large Congestion Windows\",\n              RFC\
    \ 3649, DOI 10.17487/RFC3649, December 2003,\n              <https://www.rfc-editor.org/info/rfc3649>.\n\
    \   [CUBIC]    Rhee, I., Xu, L., and S. Ha, \"CUBIC for Fast Long-Distance\n \
    \             Networks\", Work in Progress, Internet-Draft, draft-rhee-\n    \
    \          tcpm-cubic-02, 26 August 2008,\n              <https://tools.ietf.org/html/draft-rhee-tcpm-cubic-02>.\n\
    \   [CTCP]     Sridharan, M., Tan, K., Bansal, D., and D. Thaler,\n          \
    \    \"Compound TCP: A New TCP Congestion Control for High-Speed\n           \
    \   and Long Distance Networks\", Work in Progress, Internet-\n              Draft,\
    \ draft-sridharan-tcpm-ctcp-02, 11 November 2008,\n              <https://tools.ietf.org/html/draft-sridharan-tcpm-ctcp-\n\
    \              02>.\n"
- title: Acknowledgements
  contents:
  - "Acknowledgements\n   Many people have made comments and suggestions contributing\
    \ to this\n   document.  In particular, we would like to thank:\n   Victor Villagra,\
    \ Sonia Herranz, Clara Cubillo Pastor, Francisco Duran\n   Pina, Michael Scharf,\
    \ Jesus Soto Viso, and Federico Guillen.\n   Additionally, we want to thank the\
    \ Spanish Centre for the Development\n   of Industrial Technology (CDTI) as well\
    \ as the Spanish Science and\n   Tech Ministry, which funds this initiative through\
    \ their innovation\n   programs.\n"
- title: Contributors
  contents:
  - "Contributors\n   Jacobo Perez Lajo\n   Nokia Spain\n   Email: jacobo.perez@nokia.com\n\
    \   Luis Miguel Diaz Vizcaino\n   Nokia Spain\n   Email: Luismi.Diaz@nokia.com\n\
    \   Gonzalo Munoz Fernandez\n   Nokia Spain\n   Email: gonzalo.munoz_fernandez.ext@nokia.com\n\
    \   Manuel Alarcon Granero\n   Nokia Spain\n   Email: manuel.alarcon_granero.ext@nokia.com\n\
    \   Francisco Jose Juan Quintanilla\n   Nokia Spain\n   Email: francisco_jose.juan_quintanilla.ext@nokia.com\n\
    \   Carlos Barcenilla\n   Universidad Politecnica de Madrid\n   Juan Quemada\n\
    \   Universidad Politecnica de Madrid\n   Email: jquemada@dit.upm.es\n   Ignacio\
    \ Maestro\n   Tecnalia Research & Innovation\n   Email: ignacio.maestro@tecnalia.com\n\
    \   Lara Fajardo Iba\xF1ez\n   Optiva Media\n   Email: lara.fajardo@optivamedia.com\n\
    \   Pablo L\xF3pez Zapico\n   Optiva Media\n   Email: Pablo.lopez@optivamedia.com\n\
    \   David Muelas Recuenco\n   Universidad Autonoma de Madrid\n   Email: dav.muelas@uam.es\n\
    \   Jesus Molina Merchan\n   Universidad Autonoma de Madrid\n   Email: jesus.molina@uam.es\n\
    \   Jorge E. Lopez de Vergara Mendez\n   Universidad Autonoma de Madrid\n   Email:\
    \ jorge.lopez_vergara@uam.es\n   Victor Manuel Maroto Ortega\n   Optiva Media\n\
    \   Email: victor.maroto@optivamedia.com\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Jose Javier Garcia Aranda\n   Nokia\n   Mar\xEDa Tubau\
    \ 9\n   28050 Madrid\n   Spain\n   Phone: +34 91 330 4348\n   Email: jose_javier.garcia_aranda@nokia.com\n\
    \   M\xF3nica Cort\xE9s\n   Nokia\n   Mar\xEDa Tubau 9\n   28050 Madrid\n   Spain\n\
    \   Email: monica.cortes_sack@nokia.com\n   Joaqu\xEDn Salvach\xFAa\n   Universidad\
    \ Politecnica de Madrid\n   Avenida Complutense 30\n   28040 Madrid\n   Spain\n\
    \   Phone: +34 91 0672134\n   Email: Joaquin.salvachua@upm.es\n   Maribel Narganes\n\
    \   Tecnalia Research & Innovation\n   Parque Cient\xEDfico y Tecnol\xF3gico de\
    \ Bizkaia\n   Astondo Bidea, Edificio 700\n   E-48160 Derio Bizkaia\n   Spain\n\
    \   Phone: +34 946 430 850\n   Email: maribel.narganes@tecnalia.com\n   I\xF1\
    aki Mart\xEDnez-Sarriegui\n   Optiva Media\n   Edificio Europa II,\n   Calle Musgo\
    \ 2, 1G,\n   28023 Madrid\n   Spain\n"
