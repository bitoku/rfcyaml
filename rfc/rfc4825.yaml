- contents:
  - "                 The Extensible Markup Language (XML)\n                  Configuration
    Access Protocol (XCAP)\n"
  title: __initial_text__
- contents:
  - "Status of This Memo\n   This document specifies an Internet standards track protocol
    for the\n   Internet community, and requests discussion and suggestions for\n
    \  improvements.  Please refer to the current edition of the \"Internet\n   Official
    Protocol Standards\" (STD 1) for the standardization state\n   and status of this
    protocol.  Distribution of this memo is unlimited.\n"
  title: Status of This Memo
- contents:
  - "Copyright Notice\n   Copyright (C) The IETF Trust (2007).\n"
  title: Copyright Notice
- contents:
  - "Abstract\n   This specification defines the Extensible Markup Language (XML)\n
    \  Configuration Access Protocol (XCAP).  XCAP allows a client to read,\n   write,
    and modify application configuration data stored in XML format\n   on a server.
    \ XCAP maps XML document sub-trees and element attributes\n   to HTTP URIs, so
    that these components can be directly accessed by\n   HTTP.\n"
  title: Abstract
- contents:
  - "Table of Contents\n   1.  Introduction . . . . . . . . . . . . . . . . . . .
    . . . . . .  4\n   2.  Overview of Operation  . . . . . . . . . . . . . . . .
    . . . .  5\n   3.  Terminology  . . . . . . . . . . . . . . . . . . . . . . .
    . .  5\n   4.  Definitions  . . . . . . . . . . . . . . . . . . . . . . . . .
    \ 6\n   5.  Application Usages . . . . . . . . . . . . . . . . . . . . . .  7\n
    \    5.1.  Application Unique ID (AUID) . . . . . . . . . . . . . . .  7\n     5.2.
    \ Default Document Namespace . . . . . . . . . . . . . . . .  8\n     5.3.  Data
    Validation  . . . . . . . . . . . . . . . . . . . . .  9\n     5.4.  Data Semantics
    . . . . . . . . . . . . . . . . . . . . . . 10\n     5.5.  Naming Conventions
    . . . . . . . . . . . . . . . . . . . . 11\n     5.6.  Resource Interdependencies
    . . . . . . . . . . . . . . . . 11\n     5.7.  Authorization Policies . . . .
    . . . . . . . . . . . . . . 12\n     5.8.  Data Extensibility . . . . . . . .
    . . . . . . . . . . . . 12\n     5.9.  Documenting Application Usages . . . .
    . . . . . . . . . . 13\n     5.10. Guidelines for Creating Application Usages
    . . . . . . . . 13\n   6.  URI Construction . . . . . . . . . . . . . . . . .
    . . . . . . 15\n     6.1.  XCAP Root  . . . . . . . . . . . . . . . . . . . .
    . . . . 15\n     6.2.  Document Selector  . . . . . . . . . . . . . . . . . .
    . . 16\n     6.3.  Node Selector  . . . . . . . . . . . . . . . . . . . . . .
    18\n     6.4.  Namespace Bindings for the Selector  . . . . . . . . . . . 23\n
    \  7.  Client Operations  . . . . . . . . . . . . . . . . . . . . . . 24\n     7.1.
    \ Create or Replace a Document . . . . . . . . . . . . . . . 26\n     7.2.  Delete
    a Document  . . . . . . . . . . . . . . . . . . . . 26\n     7.3.  Fetch a Document
    . . . . . . . . . . . . . . . . . . . . . 26\n     7.4.  Create or Replace an
    Element . . . . . . . . . . . . . . . 26\n     7.5.  Delete an Element  . . .
    . . . . . . . . . . . . . . . . . 29\n     7.6.  Fetch an Element . . . . . .
    . . . . . . . . . . . . . . . 30\n     7.7.  Create or Replace an Attribute .
    . . . . . . . . . . . . . 30\n     7.8.  Delete an Attribute  . . . . . . . .
    . . . . . . . . . . . 31\n     7.9.  Fetch an Attribute . . . . . . . . . . .
    . . . . . . . . . 31\n     7.10. Fetch Namespace Bindings . . . . . . . . . .
    . . . . . . . 32\n     7.11. Conditional Operations . . . . . . . . . . . . .
    . . . . . 32\n   8.  Server Behavior  . . . . . . . . . . . . . . . . . . . .
    . . . 34\n     8.1.  POST Handling  . . . . . . . . . . . . . . . . . . . . .
    . 35\n     8.2.  PUT Handling . . . . . . . . . . . . . . . . . . . . . . . 35\n
    \      8.2.1.  Locating the Parent  . . . . . . . . . . . . . . . . . 35\n       8.2.2.
    \ Verifying Document Content . . . . . . . . . . . . . . 36\n       8.2.3.  Creation
    . . . . . . . . . . . . . . . . . . . . . . . 37\n       8.2.4.  Replacement  .
    . . . . . . . . . . . . . . . . . . . . 41\n       8.2.5.  Validation . . . .
    . . . . . . . . . . . . . . . . . . 42\n       8.2.6.  Conditional Processing
    . . . . . . . . . . . . . . . . 43\n       8.2.7.  Resource Interdependencies
    . . . . . . . . . . . . . . 44\n     8.3.  GET Handling . . . . . . . . . . .
    . . . . . . . . . . . . 44\n     8.4.  DELETE Handling  . . . . . . . . . . .
    . . . . . . . . . . 45\n     8.5.  Managing Etags . . . . . . . . . . . . . .
    . . . . . . . . 46\n   9.  Cache Control  . . . . . . . . . . . . . . . . . .
    . . . . . . 47\n   10. Namespace Binding Format . . . . . . . . . . . . . . .
    . . . . 47\n   11. Detailed Conflict Reports  . . . . . . . . . . . . . . . .
    . . 47\n     11.1. Document Structure . . . . . . . . . . . . . . . . . . . .
    48\n     11.2. XML Schema . . . . . . . . . . . . . . . . . . . . . . . . 50\n
    \  12. XCAP Server Capabilities . . . . . . . . . . . . . . . . . . . 53\n     12.1.
    Application Unique ID (AUID) . . . . . . . . . . . . . . . 54\n     12.2. XML
    Schema . . . . . . . . . . . . . . . . . . . . . . . . 54\n     12.3. Default
    Document Namespace . . . . . . . . . . . . . . . . 56\n     12.4. MIME Type  .
    . . . . . . . . . . . . . . . . . . . . . . . 56\n     12.5. Validation Constraints
    . . . . . . . . . . . . . . . . . . 56\n     12.6. Data Semantics . . . . . .
    . . . . . . . . . . . . . . . . 56\n     12.7. Naming Conventions . . . . . .
    . . . . . . . . . . . . . . 56\n     12.8. Resource Interdependencies . . . .
    . . . . . . . . . . . . 56\n     12.9. Authorization Policies . . . . . . . .
    . . . . . . . . . . 56\n   13. Examples . . . . . . . . . . . . . . . . . . .
    . . . . . . . . 56\n   14. Security Considerations  . . . . . . . . . . . . .
    . . . . . . 59\n   15. IANA Considerations  . . . . . . . . . . . . . . . . .
    . . . . 60\n     15.1. XCAP Application Unique IDs  . . . . . . . . . . . . .
    . . 60\n     15.2. MIME Types . . . . . . . . . . . . . . . . . . . . . . . .
    61\n       15.2.1. application/xcap-el+xml MIME Type  . . . . . . . . . . 61\n
    \      15.2.2. application/xcap-att+xml MIME Type . . . . . . . . . . 62\n       15.2.3.
    application/xcap-ns+xml MIME Type  . . . . . . . . . . 63\n       15.2.4. application/xcap-error+xml
    MIME Type . . . . . . . . . 64\n       15.2.5. application/xcap-caps+xml MIME
    Type  . . . . . . . . . 64\n     15.3. URN Sub-Namespace Registrations  . . .
    . . . . . . . . . . 65\n       15.3.1. urn:ietf:params:xml:ns:xcap-error  . .
    . . . . . . . . 65\n       15.3.2. urn:ietf:params:xml:ns:xcap-caps . . . . .
    . . . . . . 66\n     15.4. XML Schema Registrations . . . . . . . . . . . . .
    . . . . 67\n       15.4.1. XCAP Error Schema Registration . . . . . . . . . .
    . . 67\n       15.4.2. XCAP Capabilities Schema Registration  . . . . . . . .
    67\n   16. Acknowledgements . . . . . . . . . . . . . . . . . . . . . . . 67\n
    \  17. References . . . . . . . . . . . . . . . . . . . . . . . . . . 67\n     17.1.
    Normative References . . . . . . . . . . . . . . . . . . . 67\n     17.2. Informative
    References . . . . . . . . . . . . . . . . . . 69\n"
  title: Table of Contents
- contents:
  - "1.  Introduction\n   In many communications applications, such as Voice over
    IP, instant\n   messaging, and presence, it is necessary for network servers to\n
    \  access per-user information in the process of servicing a request.\n   This
    per-user information resides within the network, but is managed\n   by the end
    user themselves.  Its management can be done through a\n   multiplicity of access
    points, including the web, a wireless handset,\n   or a PC application.\n   There
    are many examples of per-user information.  One is presence\n   [20] authorization
    policy, which defines rules about which watchers\n   are allowed to subscribe
    to a presentity, and what information they\n   are allowed to access.  Another
    is presence lists, which are lists of\n   users whose presence is desired by a
    watcher [26].  One way to obtain\n   presence information for the list is to subscribe
    to a resource which\n   represents that list [21].  In this case, the Resource
    List Server\n   (RLS) requires access to this list in order to process a SIP [16]\n
    \  SUBSCRIBE [28] request for it.  Another way to obtain presence for\n   the
    users on the list is for a watcher to subscribe to each user\n   individually.
    \ In that case, it is convenient to have a server store\n   the list, and when
    the client boots, it fetches the list from the\n   server.  This would allow a
    user to access their resource lists from\n   different clients.\n   This specification
    describes a protocol that can be used to\n   manipulate this per-user data.  It
    is called the Extensible Markup\n   Language (XML) Configuration Access Protocol
    (XCAP).  XCAP is a set\n   of conventions for mapping XML documents and document
    components into\n   HTTP URIs, rules for how the modification of one resource
    affects\n   another, data validation constraints, and authorization policies\n
    \  associated with access to those resources.  Because of this\n   structure,
    normal HTTP primitives can be used to manipulate the data.\n   XCAP is based heavily
    on ideas borrowed from the Application\n   Configuration Access Protocol (ACAP)
    [25], but it is not an extension\n   of it, nor does it have any dependencies
    on it.  Like ACAP, XCAP is\n   meant to support the configuration needs for a
    multiplicity of\n   applications, rather than just a single one.\n   XCAP was
    not designed as a general purpose XML search protocol, XML\n   database update
    protocol, nor a general purpose, XML-based\n   configuration protocol for network
    elements.\n"
  title: 1.  Introduction
- contents:
  - "2.  Overview of Operation\n   Each application (where an application refers to
    a use case that\n   implies a collection of data and associated semantics) that
    makes use\n   of XCAP specifies an application usage (Section 5).  This application\n
    \  usage defines the XML schema [2] for the data used by the\n   application,
    along with other key pieces of information.  The\n   principal task of XCAP is
    to allow clients to read, write, modify,\n   create, and delete pieces of that
    data.  These operations are\n   supported using HTTP/1.1 [6].  An XCAP server
    acts as a repository\n   for collections of XML documents.  There will be documents
    stored for\n   each application.  Within each application, there are documents\n
    \  stored for each user.  Each user can have a multiplicity of documents\n   for
    a particular application.  To access some component of one of\n   those documents,
    XCAP defines an algorithm for constructing a URI\n   that can be used to reference
    that component.  Components refer to\n   any element or attribute within the document.
    \ Thus, the HTTP URIs\n   used by XCAP point to a document, or to pieces of information
    that\n   are finer grained than the XML document itself.  An HTTP resource\n   that
    follows the naming conventions and validation constraints\n   defined here is
    called an XCAP resource.\n   Since XCAP resources are also HTTP resources, they
    can be accessed\n   using HTTP methods.  Reading an XCAP resource is accomplished
    with\n   HTTP GET, creating or modifying one is done with HTTP PUT, and\n   removing
    one of the resources is done with an HTTP DELETE.  XCAP\n   resources do not represent
    processing scripts; as a result, POST\n   operations to HTTP URIs representing
    XCAP resources are not defined.\n   Properties that HTTP associates with resources,
    such as entity tags,\n   also apply to XCAP resources.  Indeed, entity tags are
    particularly\n   useful in XCAP, as they allow a number of conditional operations
    to\n   be performed.\n   XML documents that are equivalent for the purposes of
    many\n   applications may differ in their physical representation.  With XCAP\n
    \  resources, the canonical form with comments [19] of an XML document\n   determines
    the logical equivalence.  In other words, the canonical\n   specification determines
    how significant whitespace MUST be\n   processed.  It also implies that, for example,
    new inserted\n   attributes may appear in any order within the physical\n   representation.\n"
  title: 2.  Overview of Operation
- contents:
  - "3.  Terminology\n   In this document, the key words \"MUST\", \"MUST NOT\", \"REQUIRED\",\n
    \  \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\",\n
    \  and \"OPTIONAL\" are to be interpreted as described in RFC 2119 [7] and\n   indicate
    requirement levels for compliant implementations.\n"
  title: 3.  Terminology
- contents:
  - "4.  Definitions\n   The following terms are used throughout this document:\n
    \  XCAP Resource:  An HTTP resource representing an XML document, an\n      element
    within an XML document, or an attribute of an element\n      within an XML document
    that follows the naming and validation\n      constraints of XCAP.\n   XCAP Server:
    \ An HTTP server that understands how to follow the\n      naming and validation
    constraints defined in this specification.\n   XCAP Client:  An HTTP client that
    understands how to follow the\n      naming and validation constraints defined
    in this specification.\n   Application:  A collection of software components within
    a network\n      whose operation depends on data managed and stored on an XCAP\n
    \     server.\n   Application Usage:  Detailed information on the interaction
    of an\n      application with the XCAP server.\n   Application Unique ID (AUID):
    \ A unique identifier within the\n      namespace of application unique IDs created
    by this specification\n      that differentiates XCAP resources accessed by one
    application\n      from XCAP resources accessed by another.\n   Naming Conventions:
    \ The part of an application usage that specifies\n      well-known URIs used
    by an application, or more generally,\n      specifies the URIs that are typically
    accessed by an application\n      during its processing.\n   XCAP User Identifier
    (XUI):  The XUI is a string, valid as a path\n      element in an HTTP URI, that
    is associated with each user served\n      by the XCAP server.\n   XCAP Root:
    \ A context that contains all the documents across all\n      application usages
    and users that are managed by the server.\n   Document Selector:  A sequence of
    path segments, with each segment\n      being separated by a \"/\", that identify
    the XML document within an\n      XCAP root that is being selected.\n   Node Selector:
    \ A sequence of path segments, with each segment being\n      separated by a \"/\",
    that identify the XML node (element or\n      attribute) being selected within
    a document.\n   Node Selector Separator:  A single path segment equal to two tilde\n
    \     characters \"~~\" that is used to separate the document selector\n      from
    the node selector within an HTTP URI.\n   Document URI:  The HTTP URI containing
    the XCAP root and document\n      selector, resulting in the selection of a specific
    document.  As a\n      result, performing a GET against the document URI would
    retrieve\n      the document.\n   Node URI:  The HTTP URI containing the XCAP
    root, document selector,\n      node selector separator, and node selector, resulting
    in the\n      selection of a specific XML node.\n   XCAP Root URI:  An HTTP URI
    that represents the XCAP root.  Although\n      a syntactically valid URI, the
    XCAP Root URI does not correspond\n      to an actual resource on an XCAP server.
    \ Actual resources are\n      created by appending additional path information
    to the XCAP Root\n      URI.\n   Global Tree:  A URI that represents the parent
    for all global\n      documents for a particular application usage within a particular\n
    \     XCAP root.\n   Home Directory:  A URI that represents the parent for all
    documents\n      for a particular user for a particular application usage within
    a\n      particular XCAP root.\n   Positional Insertion:  A PUT operation that
    results in the insertion\n      of a new element into a document such that its
    position, relative\n      to other children of the same parent, is set by the
    client.\n"
  title: 4.  Definitions
- contents:
  - "5.  Application Usages\n   Each XCAP resource on a server is associated with
    an application.  In\n   order for an application to use those resources, application
    specific\n   conventions must be specified.  Those conventions include the XML\n
    \  schema that defines the structure and constraints of the data, well-\n   known
    URIs to bootstrap access to the data, and so on.  All of those\n   application
    specific conventions are defined by the application\n   usage.\n"
  - contents:
    - "5.1.  Application Unique ID (AUID)\n   Each application usage is associated
      with a name, called an\n   Application Unique ID (AUID).  This name uniquely
      identifies the\n   application usage within the namespace of application usages,
      and is\n   different from AUIDs used by other applications.  AUIDs exist in
      one\n   of two namespaces.  The first namespace is the IETF namespace.  This\n
      \  namespace contains a set of tokens, each of which is registered with\n   IANA.
      \ These registrations occur with the publication of standards\n   track RFCs
      [27], based on the guidelines in Section 15.  The second\n   namespace is the
      vendor-proprietary namespace.  Each AUID in that\n   namespace is prefixed with
      the reverse domain name of the\n   organization creating the AUID, followed
      by a period, followed by any\n   vendor defined token.  As an example, the example.com
      domain can\n   create an AUID with the value \"com.example.foo\" but cannot
      create one\n   with the value \"org.example.foo\".  AUIDs within the vendor
      namespace\n   do not need to be registered with IANA.  The vendor namespace
      is also\n   meant to be used in lab environments where no central registry is\n
      \  needed.  The syntax for AUIDs, expressed in ABNF [12] (and using some\n   of
      the BNF defined in RFC 3986 [13]), is:\n   AUID             =  global-a-uid
      / vendor-a-uid\n   global-a-uid     =  a-uid\n   a-uid            =  1*a-uid-char\n
      \  vendor-a-uid     =  rev-hostname \".\" a-uid\n   rev-hostname     =  toplabel
      *( \".\" domainlabel  )\n   domainlabel      =  alphanum\n                       /
      alphanum *( alphanum / \"-\" ) alphanum\n   toplabel         =  ALPHA / ALPHA
      *( alphanum / \"-\" ) alphanum\n   a-uid-char       =  a-uid-unreserved / pct-encoded
      / sub-delims\n                       / \":\" / \"@\"\n                                  ;pct-encoded
      from RFC 3986\n                                  ;sub-delims from RFC 3986\n
      \  alphanum         = ALPHA / DIGIT\n                                  ;DIGIT
      from RFC 4234\n                                  ;ALPHA from RFC 4234\n   a-uid-unreserved
      = ALPHA / DIGIT / \"-\" / \"_\" / \"~\"\n   The allowed characters for the auid
      production is a subset of the\n   pchar production defined in RFC 3986.  In
      particular, it omits the\n   \".\", which allows for the auid to be separated
      from the reverse\n   hostname.\n"
    title: 5.1.  Application Unique ID (AUID)
  - contents:
    - "5.2.  Default Document Namespace\n   In order for the XCAP server to match
      a URI to an element or\n   attribute of a document, any XML namespace prefixes
      used within the\n   URI must be expanded [3].  This expansion requires a namespace\n
      \  binding context.  That context maps namespace prefixes to namespace\n   URIs.
      \ It also defines a default namespace that applies to elements\n   in the URI
      without namespace prefixes.  The namespace binding context\n   comes from two
      sources.  First, the mapping of namespace prefixes to\n   namespace URIs is
      obtained from the URI itself (see Section 6.4).\n   However, the default document
      namespace is defined by the application\n   usage itself, and applies to all
      URIs referencing resources within\n   that application usage.  All application
      usages MUST define a\n   namespace URI that represents the default document
      namespace to be\n   used when evaluating URIs.  The default document namespace
      does not\n   apply to elements or attributes within the documents themselves
      -- it\n   applies only to the evaluation of URIs within that application usage.\n
      \  Indeed, the term 'default document namespace' is distinct from the\n   term
      'default namespace'.  The latter has the standard meaning within\n   XML documents,
      and the former refers to the default used in\n   evaluation of XCAP URIs.  XCAP
      does not change in any way the\n   mechanisms for determining the default namespace
      within XML\n   documents.  However, if a document contains a URI representing
      an\n   XCAP resource, the default document namespace defined by the\n   application
      usage applies to that URI as well.\n"
    title: 5.2.  Default Document Namespace
  - contents:
    - "5.3.  Data Validation\n   One of the responsibilities of an XCAP server is
      to validate the\n   content of each XCAP resource when an XCAP client tries
      to modify\n   one.  This is done using two mechanisms.  Firstly, all application\n
      \  usages MUST describe their document contents using XML schema [2].\n   The
      application usage MUST also identify the MIME type for documents\n   compliant
      to that schema.\n   Unfortunately, XML schemas cannot represent every form of
      data\n   constraint.  As an example, one XML element may contain an integer\n
      \  that defines the maximum number of instances of another element.\n   This
      constraint cannot be represented with XML schema.  However, such\n   constraints
      may be important to the application usage.  The\n   application usage defines
      any additional constraints beyond those in\n   the schema.\n   Of particular
      importance are uniqueness constraints.  In many cases,\n   an application will
      require that there be only one instance of some\n   element or attribute within
      a particular scope.  Each uniqueness\n   constraint needs to be specified by
      identifying the field, or\n   combinations of fields, that need to be unique,
      and then identifying\n   the scope in which that uniqueness applies.  One typical
      scope is the\n   set of all elements of a certain name within the same parent.\n
      \  Another typical scope is the set of all URIs valid within a\n   particular
      domain.  In some cases, these constraints can be specified\n   using XML schema,
      which provides the <unique> element for this\n   purpose.  Other uniqueness
      constraints, such as URI uniqueness across\n   a domain, cannot be expressed
      by schema.  Whether or not the schema\n   is used to express some of the uniqueness
      requirements, the\n   application usage MUST specify all uniqueness requirements
      when it\n   defines its data validation needs.\n   For example, the resource
      lists application usage [22] requires that\n   each <list> element have a unique
      value for the \"name\" attribute\n   within a single parent.  As another example,
      the RLS services\n   application usage [22] requires that the value of the \"uri\"
      attribute\n   of the <service> element be a URI that is unique within the domain
      of\n   the URI.\n   URI constraints represent another form of constraints.  These
      are\n   constraints on the scheme or structure of the scheme-specific part of\n
      \  the URI.  These kinds of constraints cannot be expressed in an XML\n   schema.
      \ If these constraints are important to an application usage,\n   they need
      to be explicitly called out.\n   Another important data constraint is referential
      integrity.\n   Referential integrity is important when the name or value of
      an\n   element or attribute is used as a key to select another element or\n
      \  attribute.  An application usage MAY specify referential integrity\n   constraints.
      \ However, XCAP servers are not a replacement for\n   Relational Database Management
      Systems (RDBMS), and therefore clients\n   MUST NOT depend on servers to maintain
      referential integrity.  XCAP\n   clients are responsible for making all the
      appropriate changes to\n   documents in order to maintain referential integrity.\n
      \  Another constraint is character encoding.  XML allows documents to be\n   encoded
      using several different character sets.  However, this\n   specification mandates
      that all documents used with XCAP MUST be\n   encoded using UTF-8.  This cannot
      be changed by an application usage.\n   The data validation information is consumed
      by both clients, which\n   use them to make sure they construct requests that
      will be accepted\n   by the server, and by servers, which validate the constraints
      when\n   they receive a request (with the exception of referential integrity\n
      \  constraints, which are not validated by the server).\n"
    title: 5.3.  Data Validation
  - contents:
    - "5.4.  Data Semantics\n   For each application usage, the data present in the
      XML document has\n   a well-defined semantic.  The application usage defines
      that\n   semantic, so that a client can properly construct a document in order\n
      \  to achieve the desired result.  They are not used by the server, as\n   it
      is purposefully unaware of the semantics of the data it is\n   managing.  The
      data semantics are expressed in English prose by the\n   application usage.\n
      \  One particularly important semantic is the base URI that is to be\n   used
      for the resolution of any relative URI references pointed to\n   XCAP resources.
      \ As discussed below, relative URI references pointing\n   to XCAP resources
      cannot be resolved using the retrieval URI as the\n   base URI.  Therefore,
      it is up to the application usage to specify\n   the base URI.\n"
    title: 5.4.  Data Semantics
  - contents:
    - "5.5.  Naming Conventions\n   In addition to defining the meaning of the document
      in the context of\n   a particular application, an application usage has to
      specify how the\n   applications obtain the documents they need.  In particular,
      it needs\n   to define any well-known URIs used for bootstrapping purposes,
      and\n   document any other conventions on the URIs used by an application.\n
      \  It should also document how documents reference each other.  These\n   conventions
      are called naming conventions.\n   For many application usages, users need only
      a single document.  In\n   such a case, it is RECOMMENDED that the application
      usage require\n   that this document be called \"index\" and exist within the
      user's home\n   directory.\n   As an example, the RLS services application usage
      allows an RLS to\n   obtain the contents of a resource list when the RLS receives
      a\n   SUBSCRIBE request for a SIP URI identifying an RLS service.  The\n   application
      usage specifies that the list of service definitions is\n   present within a
      specific document with a specific name within the\n   global tree.  This allows
      the RLS to perform a single XCAP request to\n   fetch the service definition
      for the service associated with the SIP\n   URI in a SUBSCRIBE request.\n   Naming
      conventions are used by XCAP clients to construct their URIs.\n   The XCAP server
      does not make use of them.\n"
    title: 5.5.  Naming Conventions
  - contents:
    - "5.6.  Resource Interdependencies\n   When a user modifies an XCAP resource,
      the content of many other\n   resources is affected.  For example, when a user
      deletes an XML\n   element within a document, it does so by issuing a DELETE
      request\n   against the URI for the element resource.  However, deleting this\n
      \  element also deletes all child elements and their attributes, each of\n   which
      is also an XCAP resource.  As such, manipulation of one\n   resource affects
      the state of other resources.\n   For the most part, these interdependencies
      are fully specified by the\n   XML schema used by the application usage.  However,
      in some\n   application usages, there is a need for the server to relate\n   resources
      together, and such a relationship cannot be specified\n   through a schema.
      \ This occurs when changes in one document will\n   affect another document.
      \ Typically, this is the case when an\n   application usage is defining a document
      that acts as a collection of\n   information defined in other documents.\n   As
      an example, when a user creates a new RLS service (that is, it\n   creates a
      new <service> element within an RLS services document), the\n   server adds
      that element to a read-only global list of services\n   maintained by the server
      in the global tree.  This read-only global\n   list is accessed by the RLS when
      processing a SIP SUBSCRIBE request.\n   Resource interdependencies are used
      by both XCAP clients and servers.\n"
    title: 5.6.  Resource Interdependencies
  - contents:
    - "5.7.  Authorization Policies\n   By default, each user is able to access (read,
      modify, and delete)\n   all the documents below their home directory, and any
      user is able to\n   read documents within the global directory.  However, only
      trusted\n   users, explicitly provisioned into the server, can modify global\n
      \  documents.\n   The application usage can specify a different authorization
      policy\n   that applies to all documents associated with that application usage.\n
      \  An application usage can also specify whether another application\n   usage
      is used to define the authorization policies.  An application\n   usage for
      setting authorization policies can also be defined\n   subsequent to the definition
      of the main application usage.  In such\n   a case, the main application usage
      needs only to specify that such a\n   usage will be defined in the future.\n
      \  If an application usage does not wish to change the default\n   authorization
      policy, it can merely state that the default policy is\n   used.\n   The authorization
      policies defined by the application usage are used\n   by the XCAP server during
      its operation.\n"
    title: 5.7.  Authorization Policies
  - contents:
    - "5.8.  Data Extensibility\n   An XCAP server MUST understand an application
      usage in order to\n   process an HTTP request made against a resource for that
      particular\n   application usage.  However, it is not required for the server
      to\n   understand all of the contents of a document used by an application\n
      \  usage.  A server is required to understand the baseline schema\n   defined
      by the application usage.  However, those schemas can define\n   points of extensibility
      where new content can be added from other\n   namespaces and corresponding schemas.
      \ Sometimes, the server will\n   understand those namespaces and therefore have
      access to their\n   schemas.  Sometimes, it will not.\n   A server MUST allow
      for documents that contain elements from\n   namespaces not known to the server.
      \ In such a case, the server\n   cannot validate that such content is schema
      compliant; it will only\n   verify that the XML is well-formed.\n   If a client
      wants to verify that a server supports a particular\n   namespace before operating
      on a resource, it can query the server for\n   its capabilities using the XCAP
      Capabilities application usage,\n   discussed in Section 12.\n"
    title: 5.8.  Data Extensibility
  - contents:
    - "5.9.  Documenting Application Usages\n   Application usages are documented
      in specifications that convey the\n   information described above.  In particular,
      an application usage\n   specification MUST provide the following information:\n
      \  o  Application Unique ID (AUID): If the application usage is meant\n      for
      general use on the Internet, the application usage MUST\n      register the
      AUID into the IETF tree using the IANA procedures\n      defined in Section
      15.\n   o  XML Schema\n   o  Default Document Namespace\n   o  MIME Type\n   o
      \ Validation Constraints\n   o  Data Semantics\n   o  Naming Conventions\n   o
      \ Resource Interdependencies\n   o  Authorization Policies\n"
    title: 5.9.  Documenting Application Usages
  - contents:
    - "5.10.  Guidelines for Creating Application Usages\n   The primary design task
      when creating a new application usage is to\n   define the schema.  Although
      XCAP can be used with any XML document,\n   intelligent schema design will improve
      the efficiency and utility of\n   the document when it is manipulated with XCAP.\n
      \  XCAP provides three fundamental ways to select elements amongst a set\n   of
      siblings: by the expanded name of the element, by its position, or\n   by the
      value of a specific attribute.  Positional selection always\n   allows a client
      to get exactly what it wants.  However, it requires a\n   client to cache a
      copy of the document in order to construct the\n   predicate.  Furthermore,
      if a client performs a PUT, it requires the\n   client to reconstruct the PUT
      processing that a server would follow\n   in order to update its local cached
      copy.  Otherwise, the client will\n   be forced to re-GET the document after
      every PUT, which is\n   inefficient.  As such, it is a good idea to design schemas
      such that\n   common operations can be performed without requiring the client
      to\n   cache a copy of the document.\n   Without positional selection, a client
      can pick the element at each\n   step by its expanded name or the value of an
      attribute.  Many schemas\n   include elements that can be repeated within a
      parent (often,\n   minOccurs equals zero or one, and maxOccurs is unbounded).
      \ As such,\n   all of the elements have the same name.  This leaves the attribute\n
      \  value as the only way to select an element.  Because of this, if an\n   application
      usage expects the user to manipulate elements or\n   attributes that are descendants
      of an element that can repeat, that\n   element SHOULD include, in its schema,
      an attribute that can be\n   suitably used as a unique index.  Furthermore,
      the naming conventions\n   defined by that application usage SHOULD specify
      this uniqueness\n   constraint explicitly.\n   URIs often make a good choice
      for such a unique index.  They have\n   fundamental uniqueness properties, and
      are also usually of semantic\n   significance in the application usage.  However,
      care must be taken\n   when using a URI as an attribute value.  URI equality
      is usually\n   complex.  However, attribute equality is performed by the server\n
      \  using XML rules, which are based on case sensitive string comparison.\n   Thus,
      XCAP will match URIs based on lexical equality, not functional\n   equality.
      \ In such cases, an application usage SHOULD consider these\n   implications
      carefully.\n   XCAP provides the ability of a client to operate on a single
      element,\n   attribute, or document at a time.  As a result, it may be possible\n
      \  that common operations the client might perform will require a\n   sequence
      of multiple requests.  This is inefficient, and introduces\n   the possibility
      of failure conditions when another client modifies\n   the document in the middle
      of a sequence.  In such a case, the client\n   will be forced to detect this
      case using entity tags (discussed below\n   in Section 7.11), and undo its previous
      changes.  This is very\n   difficult.\n   As a result, the schemas SHOULD be
      defined so that common operations\n   generally require a single request to
      perform.  Consider an example.\n   Let's say an application usage is defining
      permissions for users to\n   perform certain operations.  The schema can be
      designed in two ways.\n   The top level of the tree can identify users, and
      within each user,\n   there can be the permissions associated with the user.
      \ In an\n   alternative design, the top level of the tree identifies each\n
      \  permission, and within that permission, the set of users who have it.\n   If,
      in this application usage, it is common to change the permission\n   for a user
      from one value to another, the former schema design is\n   better for xcap;
      it will require a single PUT to make such a change.\n   In the latter case,
      either the entire document needs to be replaced\n   (which is a single operation),
      or two PUT operations need to occur --\n   one to remove the user from the old
      permission, and one to add the\n   user to the new permission.\n   Naming conventions
      form another key part of the design of an\n   application usage.  The application
      usage should be certain that XCAP\n   clients know where to \"start\" to retrieve
      and modify documents of\n   interest.  Generally, this will involve the specification
      of a well-\n   known document at a well-known URI.  That document can contain\n
      \  references to other documents that the client needs to read or\n   modify.\n"
    title: 5.10.  Guidelines for Creating Application Usages
  title: 5.  Application Usages
- contents:
  - "6.  URI Construction\n   In order to manipulate an XCAP resource, the data must
    be represented\n   by an HTTP URI.  XCAP defines a specific naming convention
    for\n   constructing these URIs.  The URI is constructed by concatenating the\n
    \  XCAP root with the document selector with the node selector separator\n   with
    a percent-encoded form of the node selector.  This is followed\n   by an optional
    query component that defines namespace bindings used\n   in evaluating the URI.
    \ The XCAP root is the enclosing context in\n   which all XCAP resources live.
    \ The document selector is a path that\n   identifies a document within the XCAP
    root.  The node selector\n   separator is a path segment with a value of double
    tilde (\"~~\"), and\n   SHOULD NOT be percent-encoded, as advised in Section 2.3
    of RFC 3986\n   [13].  URIs containing %7E%7E should be normalized to ~~ for\n
    \  comparison; they are equivalent.  The node selector separator is a\n   piece
    of syntactic sugar that separates the document selector from\n   the node selector.
    \ The node selector is an expression that\n   identifies a component of the document,
    such as an element or\n   attribute.  It is possible that a \"~~\" appears as
    part of the node\n   selector itself; in such a case, the first \"~~\" in the
    URI is the\n   node selector separator.\n   The sections below describe these
    components in more detail.\n"
  - contents:
    - "6.1.  XCAP Root\n   The root of the XCAP hierarchy is called the XCAP root.
      \ It defines\n   the context in which all other resources exist.  The XCAP root
      is\n   represented with an HTTP URI, called the XCAP Root URI.  This URI is\n
      \  a valid HTTP URI; however, it doesn't point to any resource that\n   actually
      exists on the server.  Its purpose is to identify the root\n   of the tree within
      the domain where all XCAP documents are stored.\n   It can be any valid HTTP
      URI, but MUST NOT contain a query component\n   (a complete XCAP URI may have
      a query component, but it is not part\n   of the XCAP root URI).  It is RECOMMENDED
      that it be equal to\n   xcap.domain, where domain is the domain of the provider.
      \ As an\n   example, \"http://xcap.example.com\" might be used as the XCAP root
      URI\n   within the example.com domain.  Typically, the XCAP root URI is\n   provisioned
      into client devices.  If not explicitly provisioned,\n   clients SHOULD assume
      the form xcap.domain, where domain is the\n   domain of their service provider
      (for SIP, this would be the domain\n   part of their Address-of-Record (AOR)).
      \ A server or domain MAY\n   support multiple XCAP root URIs.  In such a case,
      it is effectively\n   operating as if it were serving separate domains.  There
      is never\n   information carryover or interactions between resources in different\n
      \  XCAP root URIs.\n   When a client generates an HTTP request to a URI identifying
      an XCAP\n   resource, RFC 2616 procedures for the construction of the Request-URI\n
      \  apply.  In particular, the authority component of the URI may not be\n   present
      in the Request-URI if the request is sent directly to the\n   origin server.\n
      \  The XCAP root URI can also be a relative HTTP URI.  It is the\n   responsibility
      of the application usage to specify the base URI for\n   an HTTP URI representing
      an XCAP resource whenever such a URI appears\n   within a document defined by
      that application usage.  Generally\n   speaking, it is unsafe to use the retrieval
      URI as the base URI.\n   This is because any URI that points to an ancestor
      for a particular\n   element or attribute can contain content including that
      element or\n   attribute.  If that element or attribute contained a relative
      URI\n   reference, it would be resolved relative to whatever happened to be\n
      \  used to retrieve the content, and this will often not be the base URI\n   defined
      by the application usage.\n"
    title: 6.1.  XCAP Root
  - contents:
    - "6.2.  Document Selector\n   Each document within the XCAP root is identified
      by its document\n   selector.  The document selector is a sequence of path segments,\n
      \  separated by a slash (\"/\").  These path segments define a\n   hierarchical
      structure for organizing documents within any XCAP root.\n   The first path
      segment MUST be the XCAP AUID.  So, continuing the\n   example above, all of
      the documents used by the resource lists\n   application would be under \"http://xcap.example.com/resource-lists\".\n
      \  o  Implementors making use of HTTP servlets should be aware that XCAP\n      may
      require them to get authorization from the server\n      administrator to place
      resources within this specific subset of\n      the URI namespace.\n   It is
      assumed that each application will have data that is set by\n   users, and/or
      it will have global data that applies to all users.  As\n   a result, beneath
      each AUID, there are two sub-trees.  One, called\n   \"users\", holds the documents
      that are applicable to specific users,\n   and the other, called \"global\",
      holds documents applicable to all\n   users.  The sub-tree beneath \"global\"
      is called the global tree.  The\n   path segment after the AUID MUST either
      be \"global\" or \"users\".\n   Within the \"users\" tree are zero or more sub-trees,
      each of which\n   identifies documents that apply to a specific user.  Each
      user known\n   to the server is associated with a username, called the XCAP
      User\n   Identifier (XUI).  Typically, an endpoint is provisioned with the\n
      \  value of the XUI.  For systems that support SIP applications, it is\n   RECOMMENDED
      that the XUI be equal to the Address-of-Record (AOR) for\n   the user (i.e.,
      sip:joe@example.com).  Since SIP endpoints generally\n   know their AOR, they
      will also know their XUI.  As a consequence, if\n   no XUI is explicitly provisioned,
      a SIP User Agent SHOULD assume it\n   is equal to their AOR.  This XUI MUST
      be used as the path segment\n   beneath the \"users\" segment.  Since the SIP
      URI allows for characters\n   that are not permitted in HTTP URI path segments
      (such as the '?' and\n   '/' characters, which are permitted in the user part
      of the SIP URI),\n   any such characters MUST be percent encoded.  The sub-tree
      beneath an\n   XUI for a particular user is called their home directory.  \"User\"
      in\n   this context should be interpreted loosely; a user might correspond\n
      \  to a device, for example.\n   XCAP does not itself define what it means for
      documents to \"apply\" to\n   a user, beyond specification of a baseline authorization
      policy,\n   described below in Section 8.  Each application usage can specify\n
      \  additional authorization policies that depend on data used by the\n   application
      itself.\n   The remainder of the document selector (the path following \"global\"\n
      \  or the XUI) points to specific documents for that application usage.\n   Subdirectories
      are permitted, but are NOT RECOMMENDED.  XCAP provides\n   no way to create
      sub-directories or to list their contents, thus\n   limiting their utility.
      \ If subdirectories are used, there MUST NOT\n   be a document in a directory
      with the same name as a sub-directory.\n   The final path segment in the document
      selector identifies the actual\n   document in the hierarchy.  This is equivalent
      to a filename, except\n   that XCAP does not require that its document resources
      be stored as\n   files in a file system.  However, the term \"filename\" is
      used to\n   describe the final path segment in the document selector.  In\n
      \  traditional filesystems, the filename would have a filename\n   extension,
      such as \".xml\".  There is nothing in this specification\n   that requires
      or prevents such extensions from being used in the\n   filename.  In some cases,
      the application usage will specify a naming\n   convention for documents, and
      those naming conventions may or may not\n   specify a file extension.  For example,
      in the RLS services\n   application usage [22], documents in the user's home
      directory with\n   the filename \"index\" will be used by the server to compute
      the global\n   index, which is also a document with the filename \"index\".
      \ Barring\n   specific guidelines in the application usage, if a user has a
      single\n   document for a particular application usage, this SHOULD be called\n
      \  \"index\".\n   When the naming conventions in an application usage do not
      constrain\n   the filename conventions (or, more generally, the document selector),\n
      \  an application will know the filename (or more generally, the\n   document
      selector) because it is included as a reference in a\n   document accessed by
      the client.  As another example, within the\n   index document defined by RLS
      services, the <service> element has a\n   child element called <resource-list>
      whose content is a URI pointing\n   to a resource list within the users home
      directory.\n   As a result, if the user creates a new document, and then references\n
      \  that document from a well-known document (such as the index document\n   above),
      it doesn't matter whether or not the user includes an\n   extension in the filename,
      as long as the user is consistent and\n   maintains referential integrity.\n
      \  As an example, the path segment\n   \"/resource-lists/users/sip:joe@example.com/index\"
      is a document\n   selector.  Concatenating the XCAP root URI with the document
      selector\n   produces the HTTP URI \"http://xcap.example.com/resource-lists/users/\n
      \  sip:joe@example.com/index\".  In this URI, the AUID is \"resource-\n   lists\",
      and the document is in the user tree with the XUI\n   \"sip:joe@example.com\"
      with filename \"index\".\n"
    title: 6.2.  Document Selector
  - contents:
    - "6.3.  Node Selector\n   The node selector specifies specific nodes of the XML
      document that\n   are to be accessed.  A node refers to an XML element, an attribute
      of\n   an element, or a set of namespace bindings.  The node selector is an\n
      \  expression that identifies an element, attribute, or set of namespace\n   bindings.
      \ Its grammar is:\n   node-selector          = element-selector [\"/\" terminal-selector]\n
      \  terminal-selector      = attribute-selector / namespace-selector /\n                            extension-selector\n
      \  element-selector       = step *( \"/\" step)\n   step                   =
      by-name / by-pos / by-attr / by-pos-attr /\n                            extension-selector\n
      \  by-name                = NameorAny\n   by-pos                 = NameorAny
      \"[\" position \"]\"\n   position               = 1*DIGIT\n   attr-test              =
      \"@\" att-name \"=\" att-value\n   by-attr                = NameorAny \"[\"
      attr-test \"]\"\n   by-pos-attr            = NameorAny \"[\" position \"]\"
      \"[\" attr-test \"]\"\n   NameorAny              = QName / \"*\"   ; QName from
      XML Namespaces\n   att-name               = QName\n   att-value              =
      AttValue      ; from XML specification\n   attribute-selector     = \"@\" att-name\n
      \  namespace-selector     = \"namespace::*\"\n   extension-selector     = 1*(
      %x00-2e / %x30-ff )  ; anything but \"/\"\n   The QName grammar is defined in
      the XML namespaces [3] specification,\n   and the AttValue grammar is defined
      in the XML specification XML 1.0\n   [1].\n   The extension-selector is included
      for purposes of extensibility.  It\n   can be composed of any character except
      the slash, which is the\n   delimiter amongst steps.  Any characters in an extension
      that cannot\n   be represented in a URI MUST be percent-encoded before placement
      into\n   a URI.\n   Note that the double quote, left square bracket and right
      square\n   bracket characters, which are meaningful to XCAP, cannot be directly\n
      \  represented in the HTTP URI.  As a result, they are percent-encoded\n   when
      placed within the HTTP URI.  In addition to these characters, an\n   apostrophe
      (') character can be used as a delimiter within XPath\n   expressions.  Furthermore,
      since XML allows for non-ASCII characters,\n   the names of elements and attributes
      may not be directly\n   representable in a URI.  Any such characters MUST be
      represented by\n   converting them to an octet sequence corresponding to their\n
      \  representation in UTF-8, and then percent-encoding that sequence of\n   octets.\n
      \  Similarly, the XML specification defines the QName production for the\n   grammar
      for element and attribute names, and the AttValue production\n   for the attribute
      values.  Unfortunately, the characters permitted by\n   these productions include
      some that are not allowed for pchar, which\n   is the production for the allowed
      set of characters in path segments\n   in the URI.  The AttValue production
      allows many such characters\n   within the US-ASCII set, including the space.
      \ Those characters MUST\n   be percent-encoded when placed in the URI.  Furthermore,
      QName and\n   AttValue allow many Unicode characters, outside of US-ASCII.  When\n
      \  these characters need to be represented in the HTTP URI, they are\n   percent-encoded.
      \ To do this, the data should be encoded first as\n   octets according to the
      UTF-8 character encoding [18], and then only\n   those octets that do not correspond
      to characters in the pchar set\n   should be percent-encoded.  For example,
      the character A would be\n   represented as \"A\", the character LATIN CAPITAL
      LETTER A WITH GRAVE\n   would be represented as \"%C3%80\", and the character
      KATAKANA LETTER A\n   would be represented as \"%E3%82%A2\".\n   As a result,
      the grammar above represents the expressions processed\n   by the XCAP server
      internally after it has decoded the URI.  The on-\n   the-wire format is dictated
      by RFC 3986 [13].  In the discussions and\n   examples below, when the node
      selectors are not part of an HTTP URI,\n   they are presented in their internal
      format prior to encoding.  If an\n   example includes a node selector within
      an HTTP URI, it is presented\n   in its percent-encoded form.\n   The node selector
      is based on the concepts in XPath [10].  Indeed,\n   the node selector expression,
      before it is percent-encoded for\n   representation in the HTTP URI, happens
      to be a valid XPath\n   expression.  However, XPath provides a set of functionality
      far\n   richer than is needed here, and its breadth would introduce much\n   unneeded
      complexity into XCAP.\n   To determine the XML element, attribute, or namespace
      bindings\n   selected by the node selector, processing begins at the root node
      of\n   the XML document.  The first step in the element selector is then\n   taken.
      \ Each step chooses a single XML element within the current\n   document context.
      \ The document context is the point within the XML\n   document from which a
      specific step is evaluated.  The document\n   context begins at the root node
      of the document.  When a step\n   determines an element within that context,
      that element becomes the\n   new context for evaluation of the next step.  Each
      step can select an\n   element by its name (expanded), by a combination of name
      and\n   attribute value, by name and position, or by name, position and\n   attribute.
      \ In all cases, the name can be wildcarded, so that all\n   elements get selected.\n
      \  The selection operation operates as follows.  Within the current\n   document
      context, the children of that context are enumerated in\n   document order.
      \ If the context is the root node of the document, its\n   child element is
      the root element of the document.  If the context is\n   an element, its children
      are all of the children of that element\n   (naturally).  Next, those elements
      whose name is not a match for\n   NameorAny are discarded.  An element name
      is a match if NameorAny is\n   the wildcard, or if it is not a wildcard, the
      element name matches\n   NameorAny.  Matching is discussed below.  The result
      is an ordered\n   list of elements.\n   The elements in the list are further
      filtered by the predicates,\n   which are the expressions in square brackets
      following NameorAny.\n   Each predicate further prunes the elements from the
      current ordered\n   list.  These predicates are evaluated in order.  If the
      content of\n   the predicate is a position, the position-th element is selected\n
      \  (that is, treat \"position\" as a variable, and take the element whose\n
      \  position equals that variable), and all others are discarded.  If\n   there
      are fewer elements in the list than the value of position, the\n   result is
      a no-match.\n   If the content of the predicate is an attribute name and value,
      all\n   elements possessing an attribute with that name and value are\n   selected,
      and all others are discarded.  Note that, although a\n   document can have namespace
      declarations within elements, those\n   elements cannot be selected using a
      namespace declaration as a\n   predicate.  That is, a step like \"el-name[@xmlns='namespace']\"
      will\n   never match an element, even if there is an element in the list that\n
      \  specifies a default namespace of \"namespace\".  In other words, a\n   namespace
      node is NOT an attribute.  If the namespaces in scope for\n   an element are
      needed, they can be selected using the namespace-\n   selector described below.
      \ If there are no elements with attributes\n   having the given name and value,
      the result is a no-match.\n   After the predicates have been applied, the result
      will be a\n   no-match, one element, or multiple elements.  If the result is\n
      \  multiple elements, the node selector is invalid.  Each step in a node\n   selector
      MUST produce a single element to form the context for the\n   next step.  This
      is more restrictive than general XPath expressions,\n   which allow a context
      to contain multiple nodes.  If the result is a\n   no-match, the node selector
      is invalid.  The node selector is only\n   valid if a single element was selected.
      \ This element becomes the\n   context for the evaluation of the next step in
      the node selector\n   expression.\n   The last location step is either the previously
      described element\n   selector or a \"terminal selector\".  If the terminal
      selector is an\n   attribute selector, the server checks to see if there is
      an attribute\n   with the same expanded name in the current element context.
      \ If there\n   is not, the result is considered a no-match.  Otherwise, that\n
      \  attribute is selected.  If the terminal selector is a namespace\n   selector,
      the result is equal to the set of namespace bindings in\n   scope for the element,
      including the possible default namespace\n   declaration.  This specification
      defines a syntax for representing\n   namespace bindings, so they can be returned
      to the client in an HTTP\n   response.\n   As a result, once the entire node
      selector is evaluated against the\n   document, the result will either be a
      no-match, invalid, a single\n   element, a single attribute, or a set of namespace
      bindings.\n   Matching of element names is performed as follows.  The element
      being\n   compared in the step has its name expanded as described in XML\n   namespaces
      [3].  The element name in the step is also expanded.  This\n   expansion requires
      that any namespace prefix is converted to its\n   namespace URI.  Doing that
      requires a set of bindings from prefixes\n   to namespace URIs.  This set of
      bindings is obtained from the query\n   component of the URI (see Section 6.4).
      \ If the prefix of the QName\n   of an element is empty, the corresponding URI
      is then the default\n   document namespace URI defined by the application usage,
      or null if\n   not defined.  Comparisons are then performed as described in
      XML\n   namespaces [3].  Note that the namespace prefix expansions described\n
      \  here are different than those specified in the XPath 1.0\n   specification,
      but are closer to those currently defined by the XPath\n   2.0 specification
      [24].\n   Matching of attribute names proceeds in a similar way.  The attribute\n
      \  in the document has its name expanded as described in XML namespaces\n   [3].
      \ If the attribute name in the attribute selector has a namespace\n   prefix,
      its name is expanded using the namespace bindings obtained\n   from the query
      component of the URI.  An unprefixed attribute QName\n   is in no namespace.\n
      \  Comments, text content (including whitespace), and processing\n   instructions
      can be present in a document, but cannot be selected by\n   the expressions
      defined here.  Of course, if such information is\n   present in a document,
      and a user selects an XML element enclosing\n   that data, that information
      would be included in a resulting GET, for\n   example.  Furthermore, whitespace
      is respected by XCAP.  If a client\n   PUTs an element or document that contains
      whitespace, the server\n   retains that whitespace, and will return the element
      or document back\n   to the client with exactly the same whitespace.  Similarly,
      when an\n   element is inserted, no additional whitespace is added around the\n
      \  inserted element, and the element gets inserted in a very specific\n   location
      relative to any whitespace, comments, or processing\n   instructions around
      it.  Section 8.2.3 describes where the insertion\n   occurs.\n   As an example,
      consider the following XML document:\n   <?xml version=\"1.0\"?>\n   <watcherinfo
      xmlns=\"urn:ietf:params:xml:ns:watcherinfo\"\n                version=\"0\"
      state=\"full\">\n     <watcher-list resource=\"sip:professor@example.net\"\n
      \                  package=\"presence\">\n       <watcher status=\"active\"\n
      \               id=\"8ajksjda7s\"\n                duration-subscribed=\"509\"\n
      \               event=\"approved\">sip:userA@example.net</watcher>\n       <watcher
      status=\"pending\"\n                id=\"hh8juja87s997-ass7\"\n                display-name=\"Mr.
      Subscriber\"\n                event=\"subscribe\">sip:userB@example.org</watcher>\n
      \    </watcher-list>\n   </watcherinfo>\n                      Figure 3: Example
      XML Document\n   Assuming that the default document namespace for this application\n
      \  usage is \"urn:ietf:params:xml:ns:watcherinfo\", the node selector\n   watcherinfo/watcher-list/watcher[@id=\"8ajksjda7s\"]
      would select the\n   following XML element:\n   <watcher status=\"active\"\n
      \      id=\"8ajksjda7s\"\n       duration-subscribed=\"509\"\n       event=\"approved\">sip:userA@example.net</watcher>\n"
    title: 6.3.  Node Selector
  - contents:
    - "6.4.  Namespace Bindings for the Selector\n   In order to expand the namespace
      prefixes used in the node selector,\n   a set of bindings from those namespace
      prefixes to namespace URI must\n   be used.  Those bindings are contained in
      the query component of the\n   URI.  If no query component is present, it means
      that only the\n   default document namespace (as identified by the application
      usage)\n   is defined.  The query component is formatted as a valid xpointer\n
      \  expression [5] after suitable URI encoding as defined in Section 4.1\n   of
      the Xpointer framework.  This xpointer expression SHOULD only\n   contain expressions
      from the xmlns() scheme [4].  A server compliant\n   to this specification MUST
      ignore any xpointer expressions not from\n   the xmlns() scheme.  The xmlns()
      xpointer expressions define the set\n   of namespace bindings in use for evaluating
      the URI.\n   Note that xpointer expressions were originally designed for usage\n
      \  within fragment identifiers of URIs.  However, within XCAP, they are\n   used
      within query components of URIs.\n   The following example shows a more complex
      matching operation, this\n   time including the usage of namespace bindings.
      \ Consider the\n   following document:\n   <?xml version=\"1.0\"?>\n   <foo
      xmlns=\"urn:test:default-namespace\">\n     <ns1:bar xmlns:ns1=\"urn:test:namespace1-uri\"\n
      \             xmlns=\"urn:test:namespace1-uri\">\n       <baz/>\n       <ns2:baz
      xmlns:ns2=\"urn:test:namespace2-uri\"/>\n     </ns1:bar>\n     <ns3:hi xmlns:ns3=\"urn:test:namespace3-uri\">\n
      \      <there/>\n     </ns3:hi>\n   </foo>\n   Assume that this document has
      a document URI of\n   \"http://xcap.example.com/test/users/sip:joe@example.com/index\",
      where\n   \"test\" is the application usage.  This application usage defines
      a\n   default document namespace of \"urn:test:default-namespace\".  The XCAP\n
      \  URI:\n   http://xcap.example.com/test/users/sip:joe@example.com/index/\n
      \  ~~/foo/a:bar/b:baz?xmlns(a=urn:test:namespace1-uri)\n   xmlns(b=urn:test:namespace1-uri)\n
      \  will select the first <baz> child element of the <bar> element in the\n   document.
      \ The XCAP URI:\n   http://xcap.example.com/test/users/sip:joe@example.com/index/\n
      \  ~~/foo/a:bar/b:baz?xmlns(a=urn:test:namespace1-uri)\n   xmlns(b=urn:test:namespace2-uri)\n
      \  will select the second <baz> child element of the <bar> element in\n   the
      document.  The following XCAP URI will also select the second\n   <baz> child
      element of the <bar> element in the document:\n   http://xcap.example.com/test/users/sip:joe@example.com/index/\n
      \  ~~/d:foo/a:bar/b:baz?xmlns(a=urn:test:namespace1-uri)\n   xmlns(b=urn:test:namespace2-uri)\n
      \  xmlns(d=urn:test:default-namespace)\n"
    title: 6.4.  Namespace Bindings for the Selector
  title: 6.  URI Construction
- contents:
  - "7.  Client Operations\n   An XCAP client is an HTTP/1.1 compliant client.  Specific
    data\n   manipulation tasks are accomplished by invoking the right set of HTTP\n
    \  methods with the right set of headers on the server.  This section\n   describes
    those in detail.\n   In all cases where the client modifies a document, by deleting
    or\n   inserting a document, element or attribute resource, the client\n   SHOULD
    verify that, if the operation were to succeed, the resulting\n   document would
    meet the data constraints defined by the application\n   usage, including schema
    validation.  For example, if the client\n   performs a PUT operation to \"http://xcap.example.com/rls-services/\n
    \  users/sip:joe@example.com/mybuddies\", rls-services is the application\n   unique
    ID, and the constraints defined by it SHOULD be followed.\n   The client will
    know what URI to use based on the naming conventions\n   described by the application
    usage.\n   If the document, after modification, does not meet the data\n   constraints,
    the server will reject it with a 409.  The 409 response\n   may contain an XML
    body, formatted according to the schema in\n   Section 11.2, which provides further
    information on the nature of the\n   error.  The client MAY use this information
    to try and alter the\n   request so that, this time, it might succeed.  The client
    SHOULD NOT\n   simply retry the request without changing some aspect of it.\n
    \  In some cases, the application usage will dictate a uniqueness\n   constraint
    that the client cannot guarantee on its own.  One such\n   example is that a URI
    has to be unique within a domain.  Typically,\n   the client is not the owner
    of the domain, and so it cannot be sure\n   that a URI is unique.  In such a case,
    the client can either generate\n   a sufficiently random identifier, or it can
    pick a \"vanity\"\n   identifier in the hopes that it is not taken.  In either
    case, if the\n   identifier is not unique, the server will reject the request
    with a\n   409 and suggest alternatives that the client can use to try again.\n
    \  If the server does not suggest alternatives, the client SHOULD\n   attempt
    to use random identifiers with increasing amounts of\n   randomness.\n   HTTP
    also specifies that PUT and DELETE requests are idempotent.\n   This means that,
    if the client performs a PUT on a document and it\n   succeeds, it can perform
    the same PUT, and the resulting document\n   will look the same.  Similarly, when
    a client performs a DELETE, if\n   it succeeds, a subsequent DELETE to the same
    URI will generate a 404;\n   the resource no longer exists on the server since
    it was deleted by\n   the previous DELETE operation.  To maintain this property,
    the client\n   SHOULD construct its URIs such that, after the modification has
    taken\n   place, the URI in the request will point to the resource just\n   inserted
    for PUT (i.e., the body of the request), and will point to\n   nothing for DELETE.
    \ If this property is maintained, it is the case\n   that GET to the URI in the
    PUT will return the same content (i.e.,\n   GET(PUT(X)) == x).  This property
    implies idempotency.  Although a\n   request can still be idempotent if it does
    not possess this property,\n   XCAP does not permit such requests.  If the client's
    request does not\n   have this property, the server will reject the request with
    a 409 and\n   indicate a cannot-insert error condition.\n   If the result of the
    PUT is a 200 or 201 response, the operation was\n   successful.  Other response
    codes to any request, such as a\n   redirection, are processed as per RFC 2616
    [6].\n"
  - contents:
    - "7.1.  Create or Replace a Document\n   To create or replace a document, the
      client constructs a URI that\n   references the location where the document
      is to be placed.  This URI\n   MUST be a document URI, and therefore contain
      the XCAP root and\n   document selector.  The client then invokes a PUT method
      on that URI.\n   The MIME content type MUST be the type defined by the application\n
      \  usage.  For example, it would be \"application/rls-services+xml\" for\n   an
      RLS services [22] document, and not \"application/xml\".\n   If the Request-URI
      identifies a document that already exists in the\n   server, the PUT operation
      replaces that document with the content of\n   the request.  If the Request-URI
      does not identify an existing\n   document, the document is created on the server
      at that specific URI.\n"
    title: 7.1.  Create or Replace a Document
  - contents:
    - "7.2.  Delete a Document\n   To delete a document, the client constructs a URI
      that references the\n   document to be deleted.  This URI MUST be a document
      URI.  The client\n   then invokes a DELETE operation on the URI to delete the
      document.\n"
    title: 7.2.  Delete a Document
  - contents:
    - "7.3.  Fetch a Document\n   As one would expect, fetching a document is trivially
      accomplished by\n   performing an HTTP GET request with the Request URI set
      to the\n   document URI.\n"
    title: 7.3.  Fetch a Document
  - contents:
    - "7.4.  Create or Replace an Element\n   To create or replace an XML element
      within an existing document, the\n   client constructs a URI whose document
      selector points to the\n   document to be modified.  The node selector MUST
      be present in the\n   URI, delimited from the document selector with the node
      selector\n   separator.  The query component MUST be present if the node selector\n
      \  makes use of namespace prefixes, in which case, the xmlns()\n   expressions
      in the query component MUST define those prefixes.  To\n   create this element
      within the document, the node selector is\n   constructed such that it is a
      no-match against the current document,\n   but if the element in the body of
      the request was added to the\n   document as desired by the client, the node
      selector would select\n   that element.  To replace an element in the document,
      the node\n   selector is constructed so that it is a match against the element
      in\n   the current document to be replaced, as well as a match to the new\n
      \  element (present in the body of the PUT request) that is to replace\n   it.\n
      \  Oftentimes, the client will wish to insert an element into a document\n   in
      a certain position relative to other children of the same parent.\n   This is
      called a positional insertion.  They often arise because the\n   schema constrains
      where the element can occur, or because ordering of\n   elements is significant
      within the schema.  To accomplish this, the\n   client can use a node selector
      of the following form:\n     parent/*[position][unique-attribute-value]\n   Here,
      \"parent\" is an expression for the parent of the element to be\n   inserted.
      \"position\" is the position amongst the existing child\n   elements of this
      parent where the new element is to be inserted.\n   \"unique-attribute-value\"
      is an attribute name and value for the\n   element to be inserted, which is
      different from the current element\n   in \"position\".  The second predicate
      is needed so that the overall\n   expression is a no-match when evaluated against
      the current children.\n   Otherwise, the PUT would replace the existing element
      in that\n   position.  Note that in addition to wildcard \"*\" a QName can also
      be\n   used as a node test.  The insert logic is described in more detail in\n
      \  Section 8.2.3.\n   Consider the example document in Figure 3.  The client
      would like to\n   insert a new <watcher> element as the second element underneath\n
      \  <watcher-list>.  However, it cannot just PUT to a URI with the\n   watcherinfo/watcher-list/*[2]
      node selector; this node selector would\n   select the existing second child
      element of <watcher-list> and\n   replace it.  Thus, the PUT has to be made
      to a URI with watcherinfo/\n   watcher-list/*[2][@id=\"hhggff\"] as the node
      selector, where \"hhggff\"\n   is the value of the \"id\" attribute of the new
      element to be inserted.\n   This node-selector is a no-match against the current
      document, and\n   would be a match against the new element if it was inserted
      as the\n   second child element of <watcher-list>.\n   The \"*\" indicates that
      all element children of <watcher-info> are to\n   be considered when computing
      the position for insertion.  If, instead\n   of a wildcard *, an element name
      (QName) was present, the expression\n   above would insert the new element as
      the position-th element amongst\n   those with the same expanded name (see Section
      8.2.3 for a discussion\n   on insertion rules).\n   Once the client constructs
      the URI, it invokes the HTTP PUT method.\n   The content in the request MUST
      be an XML element.  Specifically, it\n   contains the element, starting with
      the opening bracket for the begin\n   tag for that element, including the attributes
      and content of that\n   element (whether it be text or other child elements),
      and ending with\n   the closing bracket for the end tag for that element.  The
      MIME type\n   in the request MUST be \"application/xcap-el+xml\", defined in\n
      \  Section 15.2.1.  If the node selector, when evaluated against the\n   current
      document, results in a no-match, the server performs a\n   creation operation.
      \ If the node selector, when evaluated against the\n   current document, is
      a match for an element in the current document,\n   the server replaces it with
      the content of the PUT request.  This\n   replacement is complete; that is,
      the old element (including its\n   attributes, namespace declarations and content:
      text, element,\n   comment and processing instruction nodes) are removed, and
      the new\n   one, including its attributes, namespace declarations and content,
      is\n   put in its place.\n   To be certain that element insertions have the
      GET(PUT(x))==x\n   property, the client can check that the attribute predicates
      in the\n   final path segment of the URI match the attributes of the element
      in\n   the body of the request.  As an example of a request that would not\n
      \  have this property, and therefore would not be idempotent, consider\n   the
      following PUT request (URIs are line-folded for readability):\n   PUT\n   /rls-services/users/sip:bill@example.com/index/~~/rls-services/\n
      \  service%5b@uri=%22sip:good-friends@example.com%22%5d\n    HTTP/1.1\n   Content-Type:application/xcap-el+xml\n
      \  Host: xcap.example.com\n   <service uri=\"sip:mybuddies@example.com\">\n
      \    <resource-list>http://xcap.example.com/resource-lists/users\n   /sip:joe@example.com/index/~~/resource-lists/list%5b@name=%22l1%22%5d\n
      \  </resource-list>\n     <packages>\n      <package>presence</package>\n     </packages>\n
      \  </service>\n   This request will fail with a 409.  The Request URI contains
      a final\n   path segment with a predicate based on attributes:\n   @uri=\"sip:good-friends@example.com\".
      \ However, this will not match\n   the value of the \"uri\" attribute in the
      element in the body\n   (sip:mybuddies@example.com).\n   The GET(PUT(x))==x
      property introduces some limitations on the types\n   of operations possible.
      \ It will not be possible to replace an\n   element with one that has a new
      value for an attribute that is the\n   sole unique element identifier, if the
      URI contained a node selector\n   that was using the previous value of that
      attribute for purposes of\n   selecting the element.  This is exactly the use
      case in the example\n   above.  To get around this limitation, the selection
      can be done by\n   position instead of attribute value, or the parent of the
      element to\n   be replaced can be selected, and then the body of the PUT operation\n
      \  would contain the parent, the child to be replaced, and all other\n   siblings.\n"
    title: 7.4.  Create or Replace an Element
  - contents:
    - "7.5.  Delete an Element\n   To delete an element from a document, the client
      constructs a URI\n   whose document selector points to the document containing
      the element\n   to be deleted.  The node selector MUST identify a single element.\n
      \  The node selector MUST be present following the node selector\n   separator,
      and identify the specific element to be deleted.\n   Furthermore, the node selector
      MUST match no element after the\n   deletion of the target element.  This is
      required to maintain the\n   idempotency property of HTTP deletions.  The query
      component MUST be\n   present if the node selector makes use of namespace prefixes,
      in\n   which case the xmlns() expressions in the query component MUST define\n
      \  those prefixes.\n   If the client wishes to delete an element in a specific
      position,\n   this is referred to as a positional deletion.  Like a positional\n
      \  insertion, the node selector has the following form:\n     parent/*[position][unique-attribute-value]\n
      \  Where \"parent\" is an expression for the parent of the element to be\n   deleted,
      \"position\" is the position of the element to be deleted\n   amongst the existing
      child elements of this parent, and \"unique-\n   attribute-value\" is an attribute
      name and value for the element to be\n   deleted, where this attribute name
      and value are different than any\n   of the siblings of the element.\n   Positional
      deletions without using a unique attribute name and value\n   are possible,
      but only in limited cases where idempotency is\n   guaranteed.  In particular,
      if a DELETE operation refers to an\n   element by name and position alone (parent/elname[n]),
      this is\n   permitted only when the element to be deleted is the last element\n
      \  amongst all its siblings with that name.  Similarly, if a DELETE\n   operation
      refers to an element by position alone (parent/*[n]), this\n   is permitted
      only when the element to be deleted is the last amongst\n   all sibling elements,
      regardless of name.\n   The client then invokes the HTTP DELETE method.  The
      server will\n   remove the element from the document (including its attributes,\n
      \  namespace declarations, and its descendant nodes, such as any\n   children).\n"
    title: 7.5.  Delete an Element
  - contents:
    - "7.6.  Fetch an Element\n   To fetch an element of a document, the client constructs
      a URI whose\n   document selector points to the document containing the element
      to be\n   fetched.  The node selector MUST be present following the node\n   selector
      separator, and must identify the element to be fetched.  The\n   query component
      MUST be present if the node selector makes use of\n   namespace prefixes, in
      which case the xmlns() expressions in the\n   query component MUST define those
      prefixes.\n   The client then invokes the GET method.  The 200 OK response will\n
      \  contain that XML element.  Specifically, it contains the content of\n   the
      XML document, starting with the opening bracket for the begin tag\n   for that
      element, and ending with the closing bracket for the end tag\n   for that element.
      \ This will, as a result, include all attributes,\n   namespace declarations
      and descendant nodes: elements, comments,\n   text, and processing instructions
      of that element.\n"
    title: 7.6.  Fetch an Element
  - contents:
    - "7.7.  Create or Replace an Attribute\n   To create or replace an attribute
      in an existing element of a\n   document, the client constructs a URI whose
      document selector points\n   to the document to be modified.  The node selector,
      following the\n   node selector separator, MUST be present.  The node selector
      MUST be\n   constructed such that, if the attribute was created or replaced
      as\n   desired, the node selector would select that attribute.  If the node\n
      \  selector, when evaluated against the current document, results in a\n   no-match,
      it is a creation operation.  If it matches an existing\n   attribute, it is
      a replacement operation.  The query component MUST\n   be present if the node
      selector makes use of namespace prefixes, in\n   which case the xmlns() expressions
      in the query component MUST define\n   those prefixes.\n   The client then invokes
      the HTTP PUT method.  The content defined by\n   the request MUST be the value
      of the attribute, compliant to the\n   grammar for AttValue as defined in XML
      1.0 [1].  Note that, unlike\n   when AttValue is present in the URI, there is
      no percent-encoding of\n   the body.  This request MUST be sent with the Content-Type
      of\n   \"application/xcap-att+xml\" as defined in Section 15.2.2.  The server\n
      \  will add the attribute such that, if the node selector is evaluated\n   on
      the resulting document, it will return the attribute present in\n   the request.\n
      \  To be certain that attribute insertions have the GET(PUT(x))==x\n   property,
      the client can check that any attribute predicate in the\n   path segment that
      selects the element into which the attribute is\n   inserted, matches a different
      attribute than the one being inserted\n   by the request.  As an example of
      a request that would not have this\n   property, and therefore would not be
      idempotent, consider the\n   following PUT request (URIs are line-folded for
      readability):\n   PUT\n   /rls-services/users/sip:bill@example.com/index/~~/rls-services\n
      \  /service%5b@uri=%22sip:good-friends@example.com%22%5d/@uri\n    HTTP/1.1\n
      \  Content-Type:application/xcap-att+xml\n   Host: xcap.example.com\n   \"sip:bad-friends@example.com\"\n
      \  This request will fail with a 409.\n   As with element insertions and replacements,
      the GET(PUT(x))==x\n   property introduces limitations on attribute replacements.
      \ It will\n   not be possible to replace the attribute value of an attribute,
      when\n   that attribute is the sole unique element identifier, and the URI\n
      \  contains a node selector that uses the previous value of the\n   attribute
      to select the affected element.  This is the use case in\n   the example above.
      \ Instead, the element can be selected\n   positionally, or its entire parent
      replaced.\n"
    title: 7.7.  Create or Replace an Attribute
  - contents:
    - "7.8.  Delete an Attribute\n   To delete an attribute from the document, the
      client constructs a URI\n   whose document selector points to the document containing
      the\n   attribute to be deleted.  The node selector MUST be present following\n
      \  the node selector separator, and evaluate to an attribute in the\n   document
      to be deleted.  The query component MUST be present if the\n   node selector
      makes use of namespace prefixes, in which case the\n   xmlns() expressions in
      the query component MUST define those\n   prefixes.\n   The client then invokes
      the HTTP DELETE method.  The server will\n   remove the attribute from the document.\n"
    title: 7.8.  Delete an Attribute
  - contents:
    - "7.9.  Fetch an Attribute\n   To fetch an attribute of a document, the client
      constructs a URI\n   whose document selector points to the document containing
      the\n   attribute to be fetched.  The node selector MUST be present following\n
      \  the node selector separator, containing an expression identifying the\n   attribute
      whose value is to be fetched.  The query component MUST be\n   present if the
      node selector makes use of namespace prefixes, in\n   which case the xmlns()
      expressions in the query component MUST define\n   those prefixes.\n   The client
      then invokes the GET method.  The 200 OK response will\n   contain an \"application/xcap-att+xml\"
      document with the specified\n   attribute, formatted according to the grammar
      of AttValue as defined\n   in the XML 1.0 specifications.\n"
    title: 7.9.  Fetch an Attribute
  - contents:
    - "7.10.  Fetch Namespace Bindings\n   If a client wishes to insert an element
      or attribute into a document,\n   and that element or attribute is part of a
      namespace declared\n   elsewhere in the document, the client will need to know
      the namespace\n   bindings in order to construct the XML content in the request.
      \ If\n   the client has a cached copy of the document, it will know the\n   bindings.
      \ However, if it doesn't have the whole document cached, it\n   can be useful
      to fetch just the bindings that are in scope for an\n   element, in order to
      construct a subsequent PUT request.\n   To get those bindings, the client constructs
      a URI whose document\n   selector points to the document containing the element
      whose\n   namespace bindings are to be fetched.  The node selector MUST be\n
      \  present following the node selector separator, containing an\n   expression
      identifying the desired namespace bindings.  The query\n   component MUST be
      present if the node selector makes use of namespace\n   prefixes, in which case
      the xmlns() expressions in the query\n   component MUST define those prefixes.\n
      \  The client then invokes the GET method.  The 200 OK response will\n   contain
      an \"application/xcap-ns+xml\" document with the namespace\n   definitions.
      \ The format for this document is defined in Section 10.\n   A client cannot
      set the namespace prefixes in scope for an element.\n   As such, a node selector
      that identifies namespace prefixes MUST NOT\n   appear in a PUT or DELETE request.\n"
    title: 7.10.  Fetch Namespace Bindings
  - contents:
    - "7.11.  Conditional Operations\n   The HTTP specification defines several header
      fields that can be used\n   by a client to make the processing of the request
      conditional.  In\n   particular, the If-None-Match and If-Match header fields
      allow a\n   client to make them conditional on the current value of the entity\n
      \  tag for the resource.  These conditional operations are particularly\n   useful
      for XCAP resources.\n   For example, it is anticipated that clients will frequently
      wish to\n   cache the current version of a document.  So, when the client starts\n
      \  up, it will fetch the current document from the server and store it.\n   When
      it does so, the GET response will contain the entity tag for the\n   document
      resource.  Each resource within a document maintained by the\n   server will
      share the same value of the entity tag.  As a result, the\n   entity tag returned
      by the server for the document resource is\n   applicable to element and attribute
      resources within the document.\n   If the client wishes to insert or modify
      an element or attribute\n   within the document, but it wants to be certain
      that the document\n   hasn't been modified since the client last operated on
      it, it can\n   include an If-Match header field in the request, containing the
      value\n   of the entity tag known to the client for all resources within the\n
      \  document.  If the document has changed, the server will reject this\n   request
      with a 412 response.  In that case, the client will need to\n   flush its cached
      version, fetch the entire document, and store the\n   new entity tag returned
      by the server in the 200 OK to the GET\n   request.  It can then retry the request,
      placing the new entity tag\n   in the If-Match header field.  If this succeeds,
      the Etag header\n   field in the response to PUT contains the entity tag for
      the resource\n   that was just inserted or modified.  Because all resources
      in a\n   document share the same value for their entity tag, this entity tag\n
      \  value can be applied to the modification of other resources.\n   A client
      can also conditionally delete elements or attributes by\n   including an If-Match
      header field in DELETE requests.  Note that the\n   200 OK responses to a DELETE
      will contain an Etag header field,\n   containing the entity tag for all of
      the other resources in the\n   document, even though the resource identified
      by the DELETE request\n   no longer exists.\n   When a client uses conditional
      PUT and DELETE operations, it can\n   apply those changes to its local cached
      copy, and update the value of\n   the entity tag for the locally cached copy
      based on the Etag header\n   field returned in the response.  As long as no
      other clients try to\n   modify the document, the client will be able to perform
      conditional\n   operations on the document without ever having to perform separate\n
      \  GET operations to synchronize the document and its entity tags with\n   the
      server.  If another client tries to modify the document, this\n   will be detected
      by the conditional mechanisms, and the client will\n   need to perform a GET
      to resynchronize its copy unless it has some\n   other means to learn about
      the change.\n   If a client does not perform a conditional operation, but did
      have a\n   cached copy of the document, that cached copy will become invalid\n
      \  once the operation is performed (indeed, it may have become invalid\n   even
      beforehand).  Unconditional operations should only be performed\n   by clients
      when knowledge of the entire document is not important for\n   the operation
      to succeed.\n   As another example, a when a client fetches a document, and
      there is\n   an older version cached, it is useful for clients to use a\n   conditional
      GET in order to reduce network usage if the cached copy\n   is still valid.
      \ This is done by including, in the GET request, the\n   If-None-Match header
      field with a value equal to the current etag\n   held by the client for the
      document.  The server will only generate a\n   200 OK response if the etag held
      by the server differs than that held\n   by the client.  If it doesn't differ,
      the server will respond with a\n   304 response.\n"
    title: 7.11.  Conditional Operations
  title: 7.  Client Operations
- contents:
  - "8.  Server Behavior\n   An XCAP server is an HTTP/1.1 compliant origin server.
    \ The behaviors\n   mandated by this specification relate to the way in which
    the HTTP\n   URI is interpreted and the content is constructed.\n   An XCAP server
    MUST be explicitly aware of the application usage\n   against which requests are
    being made.  That is, the server must be\n   explicitly configured to handle URIs
    for each specific application\n   usage, and must be aware of the constraints
    imposed by that\n   application usage.\n   When the server receives a request,
    the treatment depends on the URI.\n   If the URI refers to an application usage
    not understood by the\n   server, the server MUST reject the request with a 404
    (Not Found)\n   response.  If the URI refers to a user (identified by an XUI)
    that is\n   not recognized by the\n   server, it MUST reject the request with
    a 404 (Not Found).  If the\n   URI includes extension-selectors that the server
    doesn't understand,\n   it MUST reject the request with a 404 (Not Found).\n   Next,
    the server authenticates the request.  All XCAP servers MUST\n   implement HTTP
    Digest [11].  Furthermore, servers MUST implement HTTP\n   over TLS, RFC 2818
    [14].  It is RECOMMENDED that administrators use\n   an HTTPS URI as the XCAP
    root URI, so that the digest client\n   authentication occurs over TLS.\n   Next,
    the server determines if the client has authorization to\n   perform the requested
    operation on the resource.  The application\n   usage defines the authorization
    policies.  An application usage may\n   specify that the default is used.  This
    default is described in\n   Section 5.7.\n   Next, the server makes sure that
    it can properly evaluate the request\n   URI.  The server MUST separate the document
    selector from the node\n   selector, by splitting the URI at the first instance
    of the node\n   selector separator (\"~~\").  The server MUST check the node selector\n
    \  in the request URI, if present.  If any qualified names are present\n   that
    use a namespace prefix, and that prefix is not defined in an\n   xmlns() expression
    in the query component of the request URI, the\n   server MUST reject the request
    with a 400 response.\n   After checking the namespace prefix definitions, the
    specific\n   behavior depends on the method and what the URI refers to.\n"
  - contents:
    - "8.1.  POST Handling\n   XCAP resources do not represent processing scripts.
      \ As a result,\n   POST operations to HTTP URIs representing XCAP resources
      are not\n   defined.  A server receiving such a request for an XCAP resource\n
      \  SHOULD return a 405.\n"
    title: 8.1.  POST Handling
  - contents:
    - "8.2.  PUT Handling\n   The behavior of a server in receipt of a PUT request
      is as specified\n   in HTTP/1.1, Section 9.6 -- the content of the request is
      placed at\n   the specified location.  This section serves to define the notion
      of\n   \"placement\" and \"specified location\" within the context of XCAP\n
      \  resources.\n   If the request URI contained a namespace-selector, the server
      MUST\n   reject the request with a 405 (Method Not Allowed) and MUST include\n
      \  an Allow header field including the GET method.\n"
    - contents:
      - "8.2.1.  Locating the Parent\n   The first step the server performs is to
        locate the parent, whether\n   it is a directory or element, in which the
        resource is to be placed.\n   To do that, the server removes the last path
        segment from the URI.\n   The rest of the URI refers to the parent.  This
        parent can be a\n   document, element, or prefix of a document selector (called
        a\n   directory, even though this specification does not mandate that\n   documents
        are actually stored in a filesystem).  This URI is called\n   the parent URI.
        \ The path segment that was removed is called the\n   target selector, and
        the node (element, document, or attribute) it\n   describes is called the
        target node.\n   If the parent URI has no node selector separator, it is referring
        to\n   the directory into which the document should be inserted.  In normal\n
        \  XCAP operations, this will be either the user's home directory or the\n
        \  global directory, which will always exist on the server.  However, if\n
        \  an application usage is making use of subdirectories (despite the\n   fact
        that this is not recommended), it is possible that the directory\n   into
        which the document should be inserted does not exist.  In this\n   case, the
        server MUST return a 409 response, and SHOULD include a\n   detailed conflict
        report including the <no-parent> element.  Detailed\n   conflict reports are
        discussed in Section 11.  If the directory does\n   exist, the server checks
        to see if there is a document with the same\n   filename as the target node.
        \ If there is, the operation is the\n   replacement operation, discussed in
        Section 8.2.4.  If it does not\n   exist, it is the creation operation discussed
        in Section 8.2.3.\n   If the parent URI has a node selector separator, the
        document\n   selector is extracted, and that document is retrieved.  If the\n
        \  document does not exist, the server MUST return a 409 response, and\n   SHOULD
        include a detailed conflict report including the <no-parent>\n   element.
        \ If it does exist, the node selector is extracted and\n   decoded (recall
        that the node selector is percent-encoded).  The node\n   selector is applied
        to the document based on the matching operations\n   discussed in Section
        6.3.  If the result is a no-match or invalid,\n   the server MUST return a
        409 response, and SHOULD include a detailed\n   conflict report including
        the <no-parent> element.\n   If the node-selector is valid, the server examines
        the target\n   selector, and evaluates it within the context of the parent
        node.  If\n   the target node exists within the parent, the operation is a\n
        \  replacement, as described in Section 8.2.4.  If it does not exist, it\n
        \  is the creation operation, discussed in Section 8.2.3.\n   Before performing
        the replacement or creation, as determined based on\n   the logic above, the
        server validates the content of the request as\n   described in Section 8.2.2.\n"
      title: 8.2.1.  Locating the Parent
    - contents:
      - "8.2.2.  Verifying Document Content\n   If the PUT request is for a document
        (the request URI had no node\n   selector separator), the content of the request
        body has to be a\n   well-formed XML document.  If it is not, the server MUST
        reject the\n   request with a 409 response code.  That response SHOULD include
        a\n   detailed conflict report including the <not-well-formed> element.  If\n
        \  the document is well-formed but not UTF-8 encoded, the server MUST\n   reject
        the request with a 409 response code.  That response SHOULD\n   include a
        detailed conflict report including the <not-utf-8> element.\n   If the MIME
        type in the Content-Type header field of the request is\n   not equal to the
        MIME type defined for the application usage, the\n   server MUST reject the
        request with a 415.\n   If the PUT request is for an element, the content
        of the request body\n   has to be a well-balanced region of an XML document,
        also known as an\n   XML fragment body in The XML Fragment Interchange [23]
        specification,\n   including only a single element.  If it is not, the server
        MUST\n   reject the request with a 409 response code.  That response SHOULD\n
        \  include a detailed conflict report including the <not-xml-frag>\n   element.
        \ If the fragment body is well-balanced but contains\n   characters outside
        of the UTF-8 character set, the server MUST reject\n   the request with a
        409 response code.  That response SHOULD include a\n   detailed conflict report
        including the <not-utf-8> element.  If the\n   MIME type in the Content-Type
        header field of the request is not\n   equal to \"application/xcap-el+xml\",
        the server MUST reject the\n   request with a 415.\n   If the PUT request
        is for an attribute, the content of the request\n   body has to be a sequence
        of characters that comply with the grammar\n   for AttValue as defined above.
        \ If it is not, the server MUST reject\n   the request with a 409 response
        code.  That response SHOULD include a\n   detailed conflict report including
        the <not-xml-att-value> element.\n   If the attribute value is valid but contains
        characters outside of\n   the UTF-8 character set, the server MUST reject
        the request with a\n   409 response code.  That response SHOULD include a
        detailed conflict\n   report including the <not-utf-8> element.If the MIME
        type in the\n   Content-Type header field of the request is not equal to\n
        \  \"application/xcap-att+xml\", the server MUST reject the request with a\n
        \  415.\n"
      title: 8.2.2.  Verifying Document Content
    - contents:
      - "8.2.3.  Creation\n   The steps in this sub-section are followed if the PUT
        request will\n   result in the creation of a new document, element, or attribute.\n
        \  If the PUT request is for a document, the content of the request body\n
        \  is placed into the directory, and its filename is associated with the\n
        \  target node, which is a document.\n   If the PUT request is for an element,
        the server inserts the content\n   of the request body as a new child element
        of the parent element\n   selected in Section 8.2.1.  The insertion is done
        such that the\n   request URI, when evaluated, would now point to the element
        that was\n   inserted.  There exist three possible ways in which new elements
        are\n   positioned.\n   First, if there were no other sibling elements with
        the same expanded\n   name, and the insertion is not positionally constrained,
        the new\n   element is inserted such that it is the last element amongst all\n
        \  element siblings.  Furthermore, if there were comment, text, or\n   processing
        instruction nodes after the former last element, they MUST\n   occur prior
        to the insertion of the new element.  This case occurs\n   when one of the
        following are true:\n   o  The element name in the target selector is not
        wildcarded.  There\n      could be an attribute selector (in which case, it
        would have to\n      match an attribute of the element being inserted), and
        the\n      position in the target selector will either be absent or have a\n
        \     value of 1 (a value greater than 1 would always result in\n      rejection
        of the request, since this is the first element with the\n      given name
        underneath the parent).\n   o  The element name in the target selector is
        wildcarded, but there\n      are no other elements underneath the same parent.
        \ There could be\n      an attribute selector (in which case, it would have
        to match an\n      attribute of the element being inserted), and the position
        in the\n      target selector will either be absent or have a value of 1 (a\n
        \     value greater than 1 would always result in rejection of the\n      request,
        since this is the first element underneath the parent).\n   o  The element
        name in the target selector is wildcarded, and there\n      are other elements
        underneath the same parent.  However, there is\n      an attribute selector
        that matches none of the attributes in the\n      other sibling elements underneath
        the parent, but does match an\n      attribute of the element to be inserted.
        \ The position in the\n      target selector is absent.\n   Secondly, if there
        were sibling elements with the same name already\n   in the document, but
        the insertion is positionally unconstrained, the\n   server MUST insert the
        element such that it is in the \"earliest last\"\n   position.  \"Earliest
        last\" means that the new element MUST be\n   inserted so that there are no
        elements after it with the same\n   expanded name, and for all insertion positions
        where this is true, it\n   is inserted such that as many sibling nodes (element,
        comment, text,\n   or processing instruction) appear after it as possible.
        \ This case\n   occurs when the target selector is defined by a by-name or
        by-attr\n   production, and there is no position indicated.\n   Lastly, if
        the element is positionally constrained, the server MUST\n   insert the element
        so that it is in the \"earliest nth\" position.\n   When n>1 and NameofAny
        is not a wildcard, the element MUST be\n   inserted so that there are n-1
        sibling elements before it with the\n   same expanded name.  If there are
        not n-1 sibling elements with the\n   same expanded name, the request will
        fail.  When n>1 and NameorAny is\n   a wildcard, the element MUST be inserted
        so that there are n-1\n   sibling elements before it, each of which can have
        any expanded name.\n   If there are not n-1 sibling elements in the document,
        the request\n   will fail.  In both of these cases, the new element is inserted
        such\n   that as many sibling nodes appear after it as possible.  When n=1
        and\n   NameorAny is not a wildcard, the insertion is positionally\n   constrained
        when an element with the same expanded name already\n   appears as a child
        of the same parent.  In this case, the new element\n   MUST appear just before
        the existing first element with this same\n   expanded name.  When n=1 and
        NameorAny is wildcarded, the insertion\n   is positionally constrained when
        there is also an attribute selector\n   that didn't match the first sibling
        of the parent (if it did match,\n   or was absent, this wouldn't have been
        an insertion).  In this case,\n   the new element MUST appear just before
        all existing elements,\n   regardless of their expanded name.\n   In practice,
        this insertion logic keeps elements with the same\n   expanded names closely
        together.  This simplifies the application\n   logic when the content model
        is described by XML schema with\n   <sequence> rules and maxOccurs=\"unbounded\"
        cardinalities, like:\n   <xs:element name=\"foobar\">\n     <xs:complexType>\n
        \      <xs:sequence>\n         <xs:element ref=\"foo\" maxOccurs=\"unbounded\"
        />\n         <xs:element ref=\"bar\" maxOccurs=\"unbounded\" />\n       </xs:sequence>\n
        \    </xs:complexType>\n   </xs:element>\n   Based on this schema, the document
        contains some number of <foo>\n   elements followed by some number of <bar>
        elements.  Either <bar> or\n   <foo> elements may easily be added without
        wildcards and positional\n   constraints.  Note that if \"minOccurs\" cardinality
        of <foo> element\n   were zero and <foo> elements do not yet exist, a positional
        predicate\n   with the * wildcard must be used.\n   The whole insert logic
        is best described by complete examples.\n   Consider the following document:\n
        \  <?xml version=\"1.0\"?>\n   <root>\n    <el1 att=\"first\"/>\n    <el1
        att=\"second\"/>\n    <!-- comment -->\n    <el2 att=\"first\"/>\n   </root>\n
        \  A PUT request whose content is <el1 att=\"third\"/> and whose node\n   selector
        is root/el1[@att=\"third\"] would result in the following\n   document:\n
        \  <?xml version=\"1.0\"?>\n   <root>\n    <el1 att=\"first\"/>\n    <el1
        att=\"second\"/><el1 att=\"third\"/>\n    <!-- comment -->\n    <el2 att=\"first\"/>\n
        \  </root>\n   Notice how it has been inserted as the third <el1> element
        in the\n   document, and just before the comment and whitespace nodes.  It
        would\n   have been inserted in exactly the same place if the node selector
        had\n   been root/el1[3][@att=\"third\"] or root/*[3][@att=\"third\"].\n   If
        the content of the request had been <el3 att=\"first\"/> and the\n   node
        selector was root/el3, it would result in the following\n   document:\n   <?xml
        version=\"1.0\"?>\n   <root>\n    <el1 att=\"first\"/>\n    <el1 att=\"second\"/>\n
        \   <!-- comment -->\n    <el2 att=\"first\"/>\n   <el3 att=\"first\"/></root>\n
        \  A PUT request whose content is <el2 att=\"2\"/> and whose node selector\n
        \  is root/el2[@att=\"2\"] would result in the following document:\n   <?xml
        version=\"1.0\"?>\n   <root>\n    <el1 att=\"first\"/>\n    <el1 att=\"second\"/>\n
        \   <!-- comment -->\n    <el2 att=\"first\"/><el2 att=\"2\"/>\n   </root>\n
        \  It would have been inserted in exactly the same place if the node\n   selector
        had been root/el2[2][@att=\"2\"].  However, a selector root/\n   *[2][@att=\"2\"]
        would result in the following document:\n   <?xml version=\"1.0\"?>\n   <root>\n
        \   <el1 att=\"first\"/><el2 att=\"2\"/>\n    <el1 att=\"second\"/>\n    <!--
        comment -->\n    <el2 att=\"first\"/>\n   </root>\n   Lastly, if the node
        selector had been root/el2[1][@att=\"2\"] the\n   result would be:\n   <?xml
        version=\"1.0\"?>\n   <root>\n    <el1 att=\"first\"/>\n    <el1 att=\"second\"/>\n
        \   <!-- comment -->\n    <el2 att=\"2\"/><el2 att=\"first\"/>\n   </root>\n
        \  It is possible that the element cannot be inserted such that the\n   request
        URI, when evaluated, returns the content provided in the\n   request.  Such
        a request is not allowed for PUT.  This happens when\n   the element in the
        body is not described by the expression in the\n   target selector.  An example
        of this case is described in\n   Section 7.4.  If this happens, the server
        MUST NOT perform the\n   insertion, and MUST reject the request with a 409
        response.  The body\n   of the response SHOULD contain a detailed conflict
        report containing\n   the <cannot-insert> element.  It is important to note
        that schema\n   compliance does not play a role while performing the insertion.
        \ That\n   is, the decision of where the element gets inserted is dictated\n
        \  entirely by the structure of the request-URI, the current document,\n   and
        the rules in this specification.\n   If the element being inserted (or any
        of its children) contain\n   namespace declarations, those declarations are
        retained when the\n   element is inserted, even if those same declarations
        exist in a\n   parent element after insertion.  The XCAP server MUST NOT remove\n
        \  redundant namespace declarations or otherwise change the namespace\n   declarations
        that were present in the element being inserted.\n   If the PUT request is
        for an attribute, the server inserts the\n   content of the request body as
        the value of the attribute.  The name\n   of the attribute is equal to the
        att-name from the attribute-selector\n   in the target selector.\n   Assuming
        that the insertion can be accomplished, the server verifies\n   that the insertion
        results in a document that meets the constraints\n   of the application usage.
        \ This is discussed in Section 8.2.5.\n"
      title: 8.2.3.  Creation
    - contents:
      - "8.2.4.  Replacement\n   The steps in this sub-section are followed if the
        PUT request will\n   result in the replacement of a document, element, or
        attribute with\n   the contents of the request.\n   If the PUT request is
        for a document, the content of the request body\n   is placed into the directory,
        replacing the document with the same\n   filename.\n   If the PUT request
        is for an element, the server replaces the target\n   node with the content
        of the request body.  As in the creation case,\n   it is possible that, after
        replacement, the request URI does not\n   select the element that was just
        inserted.  If this happens, the\n   server MUST NOT perform the replacement,
        and MUST reject the request\n   with a 409 response.  The body of the response
        SHOULD contain a\n   detailed conflict report containing the <cannot-insert>
        element.\n   As with creation, replacement of an element does not result in
        the\n   changing or elimination of namespace declarations within the newly\n
        \  modified element.\n   If the PUT request is for an attribute, the server
        sets the value of\n   the selected attribute to the content of the request
        body.  It is\n   possible in the replacement case (but not in the creation
        case),\n   that, after replacement of the attribute, the request URI no longer\n
        \  selects the attribute that was just replaced.  The scenario in which\n
        \  this can happen is discussed in Section 7.7.  If this is the case,\n   the
        server MUST NOT perform the replacement, and MUST reject the\n   request with
        a 409 response.  The body of the response SHOULD contain\n   a detailed conflict
        report containing the <cannot-insert> element.\n"
      title: 8.2.4.  Replacement
    - contents:
      - "8.2.5.  Validation\n   Once the document, element, or attribute has been
        tentatively\n   inserted, the server needs to verify that the resulting document\n
        \  meets the data constraints outlined by the application usage.\n   First,
        the server checks that the final document is compliant with\n   the schema.
        \ If it is not, the server MUST NOT perform the insertion.\n   It MUST reject
        the request with a 409 response.  That response SHOULD\n   contain a detailed
        conflict report containing the <schema-validation-\n   error> element.  If
        a schema allows for elements or attributes from\n   other namespaces, and
        the new document contains elements or\n   attributes from an unknown namespace,
        the server MUST allow the\n   change.  In other words, it is not necessary
        for an XCAP server to\n   understand the namespaces and corresponding schemas
        for elements and\n   attributes within a document, as long as the schema itself
        allows for\n   such elements or attributes to be included.  Of course, such
        unknown\n   namespaces would not be advertised by the server in its XCAP\n
        \  capabilities document, discussed in Section 12.\n   If the final document
        contains elements or attributes from a\n   namespace that the server does
        understand (and has consequently\n   advertised in its XCAP capabilities document),
        but the server does\n   not have the schema for that particular element or
        attribute, the\n   server MUST reject the request with a 409 response.  That
        response\n   SHOULD contain a detailed conflict report containing the <schema-\n
        \  validation-error> element.\n   Next, the server checks for any uniqueness
        constraints identified by\n   the application usage.  If the application usage
        required that a\n   particular element or attribute had a unique value within
        a specific\n   scope, the server would check that this uniqueness property
        still\n   exists.  If the application usage required that a URI within the\n
        \  document was unique within the domain, the server checks whether it\n   is
        the case.  If any of these uniqueness constraints are not met, the\n   server
        MUST NOT perform the insertion.  It MUST reject the request\n   with a 409
        response.  That response SHOULD contain a detailed\n   conflict report containing
        the <uniqueness-failure> element.  That\n   element can contain suggested
        values that the client can use to\n   retry.  These SHOULD be values that,
        at the time the server generates\n   the 409, would meet the uniqueness constraints.\n
        \  The server also checks for URI constraints and other non-schema data\n
        \  constraints.  If the document fails one of these constraints, the\n   server
        MUST NOT perform the insertion.  It MUST reject the request\n   with a 409
        response.  That response SHOULD contain a detailed\n   conflict report containing
        the <constraint-failure> element.  That\n   element indicates that the document
        failed non-schema data\n   constraints explicitly called out by the application
        usage.\n   Element or attribute removals have similar constraints.  The server\n
        \  checks the document for schema validity and compliance to constraints\n
        \  defined by the application usage, and rejects the request as\n   described
        above, if either check fails.\n"
      title: 8.2.5.  Validation
    - contents:
      - "8.2.6.  Conditional Processing\n   A PUT request for an XCAP resource, like
        any other HTTP resource, can\n   be made conditional through usage of the
        If-Match and If-None-Match\n   header fields.  For a replacement, these are
        processed as defined in\n   [6].  For an insertion of an element or attribute,
        conditional\n   operations are permitted.  The entity tag that is used for
        the\n   procedures in [6] is the one for all of the resources within the same\n
        \  document as the parent of the element or attribute being inserted.\n   One
        way to think of this is that, logically speaking, upon receipt of\n   the
        PUT request, the XCAP server instantiates the etag for the\n   resource referenced
        by the request, and then applies the processing\n   of the request.  Because
        of this behavior, it is not possible to\n   perform a conditional insert on
        an attribute or element that is\n   conditioned on the operation being an
        insertion and not a\n   replacement.  In other words, a conditional PUT of
        an element or\n   attribute with an If-None-Match: * will always fail.\n"
      title: 8.2.6.  Conditional Processing
    - contents:
      - "8.2.7.  Resource Interdependencies\n   Because XCAP resources include elements,
        attributes, and documents,\n   each of which has its own HTTP URI, the creation
        or modification of\n   one resource affects the state of many others.  For
        example,\n   insertion of a document creates resources on the server for all
        of\n   the elements and attributes within that document.  After the server\n
        \  has performed the insertion associated with the PUT, the server MUST\n
        \  create and/or modify those resources affected by that PUT.  The\n   structure
        of the document completely defines the inter-relationship\n   between those
        resources.\n   However, the application usage can specify other resource inter-\n
        \  dependencies.  The server MUST create or modify the resources\n   specified
        by the application usage.\n   If the creation or replacement was successful,
        and the resource\n   interdependencies are resolved, the server returns a
        201 Created or\n   200 OK, respectively.  Note that a 201 Created is generated
        for\n   creation of new documents, elements, or attributes.  A 200 OK\n   response
        to PUT MUST not contain any content.  Per the\n   recommendations of RFC 2616,
        the 201 can contain a Location header\n   field and entity that identify the
        resource that was created.  An\n   entity tag MUST be included in all successful
        responses to a PUT.\n"
      title: 8.2.7.  Resource Interdependencies
    title: 8.2.  PUT Handling
  - contents:
    - "8.3.  GET Handling\n   The semantics of GET are as specified in RFC 2616.  This
      section\n   clarifies the specific content to be returned for a particular URI\n
      \  that represents an XCAP resource.\n   If the request URI contains only a
      document selector, the server\n   returns the document specified by the URI
      if it exists, else returns\n   a 404 response.  The MIME type of the body of
      the 200 OK response\n   MUST be the MIME type defined by that application usage
      (i.e.,\n   \"application/resource-lists+xml\").\n   If the request URI contains
      a node selector, the server obtains the\n   document specified by the document
      selector, and if it is found,\n   evaluates the node-selector within that document.
      \ If no document is\n   found, or if the node-selector is a no-match or invalid,
      the server\n   returns a 404 response.  Otherwise, the server returns a 200
      OK\n   response.  If the node selector identifies an XML element, that\n   element
      is returned in the 200 OK response as an XML fragment body\n   containing the
      selected element.  The server MUST NOT add namespace\n   bindings representing
      namespaces used by the element or its children,\n   but declared in ancestor
      elements; the client will either know these\n   bindings already (since it has
      a cached copy of the whole document),\n   or it can learn them by explicitly
      querying for the bindings.  The\n   MIME type of the response MUST be \"application/xcap-el+xml\".
      \ If the\n   node selector identifies an XML attribute, the value of that\n
      \  attribute is returned in the body of the response.  The MIME type of\n   the
      response MUST be \"application/xcap-att+xml\".  If the node\n   selector identifies
      a set of namespace bindings, the server computes\n   the set of namespace bindings
      in scope for the element (including the\n   default) and encodes it using the
      \"application/xcap-ns+xml\" format\n   defined in Section 10.  That document
      is then returned in the body of\n   the response.\n   GET operations can be
      conditional, and follow the procedures defined\n   in [6].\n   Note that the
      GET of a resource that was just PUT might not be octet-\n   for-octet equivalent
      to what was PUT, due to XML normalization and\n   equivalency rules.\n   A successful
      response to a GET MUST include an entity tag.\n"
    title: 8.3.  GET Handling
  - contents:
    - "8.4.  DELETE Handling\n   The semantics of DELETE are as specified in RFC 2616.
      \ This section\n   clarifies the specific content to be deleted for a particular
      URI\n   that represents an XCAP resource.\n   If the request URI contained a
      namespace-selector, the server MUST\n   reject the request with a 405 (Method
      Not Allowed) and MUST include\n   an Allow header field including the GET method.\n
      \  If the request URI contains only a document selector, the server\n   deletes
      the document specified by the URI if it exists and returns a\n   200 OK, else
      returns a 404 response.\n   If the request URI contains a node selector, the
      server obtains the\n   document specified by the document selector, and if it
      is found,\n   evaluates the node-selector within that document.  If no document
      is\n   found, or if the node-selector is a no-match or invalid (note that it\n
      \  will be invalid if multiple elements or attributes are selected), the\n   server
      returns a 404 response.  Otherwise, the server removes the\n   specified element
      or attribute from the document and performs the\n   validation checks defined
      in Section 8.2.5.  Note that this deletion\n   does not include any white space
      around the element that was deleted;\n   the XCAP server MUST preserve surrounding
      whitespace.  It is possible\n   that, after deletion, the request URI selects
      another element in the\n   document.  If this happens, the server MUST NOT perform
      the deletion,\n   and MUST reject the request with a 409 response.  The body
      of the\n   response SHOULD contain a detailed conflict report containing the\n
      \  <cannot-delete> element.  If the deletion will cause a failure of one\n   of
      the constraints, the deletion MUST NOT take place.  The server\n   follows the
      procedures in Section 8.2.5 for computing the 409\n   response.  If the deletion
      results in a document that is still valid,\n   the server MUST perform the deletion,
      process the resource\n   interdependencies defined by the application usage,
      and return a 200\n   OK response.\n   DELETE operations can be conditional,
      and follow the procedures\n   defined in [6].\n   Before the server returns
      the 200 OK response to a DELETE, it MUST\n   process the resource interdependencies
      as defined in Section 8.2.7.\n   As long as the document still exists after
      the delete operation, any\n   successful response to DELETE MUST include the
      entity tag of the\n   document.\n"
    title: 8.4.  DELETE Handling
  - contents:
    - "8.5.  Managing Etags\n   An XCAP server MUST maintain entity tags for all resources
      that it\n   maintains.  This specification introduces the additional constraint\n
      \  that when one resource within a document (including the document\n   itself)
      changes, that resource is assigned a new etag, and all other\n   resources within
      that document MUST be assigned the same etag value.\n   Effectively, there is
      a single etag for the entire document.  An XCAP\n   server MUST include the
      Etag header field in all 200 or 201 responses\n   to PUT, GET, and DELETE, assuming
      the document itself still exists\n   after the operation.  In the case of a
      DELETE, the entity tag refers\n   to the value of the entity tag for the document
      after the deletion of\n   the element or attribute.\n   XCAP resources do not
      introduce new requirements on the strength of\n   the entity tags.\n   As a
      result of this constraint, when a client makes a change to an\n   element or
      attribute within a document, the response to that\n   operation will convey
      the entity tag of the resource that was just\n   affected.  Since the client
      knows that this entity tag value is\n   shared by all of the other resources
      in the document, the client can\n   make conditional requests against other
      resources using that entity\n   tag.\n"
    title: 8.5.  Managing Etags
  title: 8.  Server Behavior
- contents:
  - "9.  Cache Control\n   An XCAP resource is a valid HTTP resource, and therefore,
    it can be\n   cached by clients and network caches.  Network caches, however,
    will\n   not be aware of the interdependencies between XCAP resources.  As\n   such,
    a change to an element in a document by a client will\n   invalidate other XCAP
    resources affected by the change.  For\n   application usages containing data
    that is likely to be dynamic or\n   written by clients, servers SHOULD indicate
    a no-cache directive.\n"
  title: 9.  Cache Control
- contents:
  - "10.  Namespace Binding Format\n   A node-selector can identify a set of namespace
    bindings that are in\n   scope for a particular element.  In order to convey these
    bindings in\n   a GET response, a way is needed to encode them.\n   Encoding is
    trivially done by including a single XML element in an\n   XML fragment body.
    \ This element has the same local-name as the\n   element whose namespace bindings
    are desired, and also the same\n   namespace-prefix.  The element has an xmlns
    attribute identifying the\n   default namespace in scope, and an xmlns:prefix
    declaration for each\n   prefix that is in scope.\n   For example, consider the
    XML document in Section 6.4.  The node-\n   selector df:foo/df2:bar/df2:baz/namespace::*
    will select the\n   namespaces in scope for the <baz> element in the document,
    assuming\n   the request is accompanied by a query component that contains\n   xmlns(df=urn:test:default-namespace)
    and\n   xmlns(df2=urn:test:namespace1-uri).  A GET containing this node\n   selector
    and namespace bindings will produce the following result:\n   <baz xmlns=\"urn:test:namespace1-uri\"\n
    \       xmlns:ns1=\"urn:tes:namespace1-uri\"/>\n   It is important to note that
    the client does not need to know the\n   actual namespace bindings in order to
    construct the URI.  It does\n   need to know the namespace URI for each element
    in the node-selector.\n   The namespace bindings present in the query component
    are defined by\n   the client, mapping those URIs to a set of prefixes.  The bindings\n
    \  returned by the server are the actual bindings used in the document.\n"
  title: 10.  Namespace Binding Format
- contents:
  - "11.  Detailed Conflict Reports\n   In cases where the server returns a 409 error
    response, that response\n   will usually include a document in the body of the
    response which\n   provides further details on the nature of the error.  This
    document\n   is an XML document, formatted according to the schema of\n   Section
    11.2.  Its MIME type, registered by this specification, is\n   \"application/xcap-error+xml\".\n"
  - contents:
    - "11.1.  Document Structure\n   The document structure is simple.  It contains
      the root element\n   <xcap-error>.  The content of this element is a specific
      error\n   condition.  Each error condition is represented by a different\n   element.
      \ This allows for different error conditions to provide\n   different data about
      the nature of the error.  All error elements\n   support a \"phrase\" attribute,
      which can contain text meant for\n   rendering to a human user.\n   The following
      error elements are defined by this specification:\n   <not-well-formed>:  This
      indicates that the body of the request was\n      not a well-formed XML document.\n
      \  <not-xml-frag>:  This indicates that the request was supposed to\n      contain
      a valid XML fragment body, but did not.  Most likely this\n      is because
      the XML in the body was malformed or not balanced.\n   <no-parent>:  This indicates
      that an attempt to insert a document,\n      element, or attribute failed because
      the directory, document, or\n      element into which the insertion was supposed
      to occur does not\n      exist.  This error element can contain an optional
      <ancestor>\n      element, which provides an HTTP URI that represents the closest\n
      \     parent that would be a valid point of insertion.  This HTTP URI\n      MAY
      be a relative URI, relative to the document itself.  Because\n      this is
      a valid HTTP URI, its node selector component MUST be\n      percent-encoded.\n
      \  <schema-validation-error>:  This element indicates that the document\n      was
      not compliant to the schema after the requested operation was\n      performed.\n
      \  <not-xml-att-value>:  This indicates that the request was supposed to\n      contain
      a valid XML attribute value, but did not.\n   <cannot-insert>:  This indicates
      that the requested PUT operation\n      could not be performed because a GET
      of that resource after the\n      PUT would not yield the content of the PUT
      request.\n   <cannot-delete>:  This indicates that the requested DELETE operation\n
      \     could not be performed because it would not be idempotent.\n   <uniqueness-failure>:
      \ This indicates that the requested operation\n      would result in a document
      that did not meet a uniqueness\n      constraint defined by the application
      usage.  For each URI,\n      element, or attribute specified by the client that
      is not unique,\n      an <exists> element is present as the content of the error\n
      \     element.  Each <exists> element has a \"field\" attribute that\n      contains
      a relative URI identifying the XML element or attribute\n      whose value needs
      to be unique, but wasn't.  The relative URI is\n      relative to the document
      itself, and will therefore start with the\n      root element.  The query component
      of the URI MUST be present if\n      the node selector portion of the URI contains
      namespace prefixes.\n      Since the \"field\" node selector is a valid HTTP
      URI, it MUST be\n      percent-encoded.  The <exists> element can optionally
      contain a\n      list of <alt-value> elements.  Each one is a suggested alternate\n
      \     value that does not currently exist on the server.\n   <constraint-failure>:
      \ This indicates that the requested operation\n      would result in a document
      that failed a data constraint defined\n      by the application usage, but not
      enforced by the schema or a\n      uniqueness constraint.\n   <extension>:  This
      indicates an error condition that is defined by an\n      extension to XCAP.
      \ Clients that do not understand the content of\n      the extension element
      MUST discard the xcap-error document and\n      treat the error as an unqualified
      409.\n   <not-utf-8>:  This indicates that the request could not be completed\n
      \     because it would have produced a document not encoded in UTF-8.\n   As
      an example, the following document indicates that the user\n   attempted to
      create an RLS service using the URI\n   sip:friends@example.com, but that URI
      already exists:\n   <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n   <xcap-error
      xmlns=\"urn:ietf:params:xml:ns:xcap-error\">\n    <uniqueness-failure>\n     <exists
      field=\"rls-services/service/@uri\">\n       <alt-value>sip:mybuddies@example.com</alt-value>\n
      \    </exists>\n    </uniqueness-failure>\n   </xcap-error>\n"
    title: 11.1.  Document Structure
  - contents:
    - "11.2.  XML Schema\n   <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n   <xs:schema
      targetNamespace=\"urn:ietf:params:xml:ns:xcap-error\"\n    xmlns=\"urn:ietf:params:xml:ns:xcap-error\"\n
      \   xmlns:xs=\"http://www.w3.org/2001/XMLSchema\"\n    elementFormDefault=\"qualified\"\n
      \   attributeFormDefault=\"unqualified\">\n    <xs:element name=\"error-element\"
      abstract=\"true\"/>\n    <xs:element name=\"xcap-error\">\n     <xs:annotation>\n
      \     <xs:documentation>Indicates the reason for the error.\n     </xs:documentation>\n
      \    </xs:annotation>\n     <xs:complexType>\n      <xs:sequence>\n       <xs:element
      ref=\"error-element\"/>\n      </xs:sequence>\n     </xs:complexType>\n    </xs:element>\n
      \   <xs:element name=\"extension\" substitutionGroup=\"error-element\">\n     <xs:complexType>\n
      \     <xs:sequence>\n       <xs:any namespace=\"##any\" processContents=\"lax\"\n
      \              minOccurs=\"0\" maxOccurs=\"unbounded\"/>\n      </xs:sequence>\n
      \    </xs:complexType>\n    </xs:element>\n    <xs:element name=\"schema-validation-error\"\n
      \    substitutionGroup=\"error-element\">\n     <xs:annotation>\n      <xs:documentation>This
      element indicates\n   that the document was not compliant to the schema after
      the requested\n   operation was performed.</xs:documentation>\n     </xs:annotation>\n
      \    <xs:complexType>\n      <xs:attribute name=\"phrase\" type=\"xs:string\"
      use=\"optional\"/>\n     </xs:complexType>\n    </xs:element>\n    <xs:element
      name=\"not-xml-frag\" substitutionGroup=\"error-element\">\n     <xs:annotation>\n
      \     <xs:documentation>This indicates that the request was supposed to\n   contain
      a valid XML fragment body, but did not.</xs:documentation>\n     </xs:annotation>\n
      \    <xs:complexType>\n      <xs:attribute name=\"phrase\" type=\"xs:string\"
      use=\"optional\"/>\n     </xs:complexType>\n    </xs:element>\n    <xs:element
      name=\"no-parent\" substitutionGroup=\"error-element\">\n     <xs:annotation>\n
      \     <xs:documentation>This indicates that an attempt to insert\n   an element,
      attribute, or document failed because the document or\n   element into which
      the insertion was\n   supposed to occur does not exist.</xs:documentation>\n
      \    </xs:annotation>\n     <xs:complexType>\n      <xs:sequence>\n       <xs:element
      name=\"ancestor\" type=\"xs:anyURI\" minOccurs=\"0\">\n        <xs:annotation>\n
      \        <xs:documentation>Contains an HTTP URI that points to the\n   element
      that is the closest ancestor that does exist.\n         </xs:documentation>\n
      \       </xs:annotation>\n       </xs:element>\n      </xs:sequence>\n      <xs:attribute
      name=\"phrase\" type=\"xs:string\" use=\"optional\"/>\n     </xs:complexType>\n
      \   </xs:element>\n    <xs:element name=\"cannot-insert\" substitutionGroup=\"error-element\">\n
      \    <xs:annotation>\n      <xs:documentation>This indicates that the requested\n
      \  PUT operation could not be performed because a GET of that resource\n   after
      the PUT would not yield the content of the PUT request.\n      </xs:documentation>\n
      \    </xs:annotation>\n     <xs:complexType>\n      <xs:attribute name=\"phrase\"
      type=\"xs:string\" use=\"optional\"/>\n     </xs:complexType>\n    </xs:element>\n
      \   <xs:element name=\"not-xml-att-value\"\n     substitutionGroup=\"error-element\">\n
      \    <xs:annotation>\n      <xs:documentation>This indicates that the\n   request
      was supposed to contain a valid XML attribute value, but did\n   not.</xs:documentation>\n
      \    </xs:annotation>\n     <xs:complexType>\n      <xs:attribute name=\"phrase\"
      type=\"xs:string\" use=\"optional\"/>\n     </xs:complexType>\n    </xs:element>\n
      \   <xs:element name=\"uniqueness-failure\"\n     substitutionGroup=\"error-element\">\n
      \    <xs:annotation>\n      <xs:documentation>This indicates that the\n   requested
      operation would result in a document that did not meet a\n   uniqueness constraint
      defined by the application usage.\n      </xs:documentation>\n     </xs:annotation>\n
      \    <xs:complexType>\n      <xs:sequence>\n       <xs:element name=\"exists\"
      maxOccurs=\"unbounded\">\n        <xs:annotation>\n         <xs:documentation>For
      each URI,\n   element, or attribute specified by the client that is not unique,\n
      \  one of these is present.</xs:documentation>\n        </xs:annotation>\n        <xs:complexType>\n
      \        <xs:sequence minOccurs=\"0\">\n          <xs:element name=\"alt-value\"
      type=\"xs:string\"\n           maxOccurs=\"unbounded\">\n           <xs:annotation>\n
      \           <xs:documentation>An optional set of alternate values can be\n   provided.</xs:documentation>\n
      \          </xs:annotation>\n          </xs:element>\n         </xs:sequence>\n
      \        <xs:attribute name=\"field\" type=\"xs:string\" use=\"required\"/>\n
      \       </xs:complexType>\n       </xs:element>\n      </xs:sequence>\n      <xs:attribute
      name=\"phrase\" type=\"xs:string\" use=\"optional\"/>\n     </xs:complexType>\n
      \   </xs:element>\n    <xs:element name=\"not-well-formed\"\n     substitutionGroup=\"error-element\">\n
      \    <xs:annotation>\n      <xs:documentation>This indicates that the body of
      the request was\n   not a well-formed document.</xs:documentation>\n     </xs:annotation>\n
      \    <xs:complexType>\n      <xs:attribute name=\"phrase\" type=\"xs:string\"
      use=\"optional\"/>\n     </xs:complexType>\n    </xs:element>\n    <xs:element
      name=\"constraint-failure\"\n     substitutionGroup=\"error-element\">\n     <xs:annotation>\n
      \     <xs:documentation>This indicates that the\n   requested operation would
      result in a document that failed a data\n   constraint defined by the application
      usage, but not enforced by the\n   schema or a uniqueness constraint.</xs:documentation>\n
      \    </xs:annotation>\n     <xs:complexType>\n      <xs:attribute name=\"phrase\"
      type=\"xs:string\" use=\"optional\"/>\n     </xs:complexType>\n    </xs:element>\n
      \   <xs:element name=\"cannot-delete\" substitutionGroup=\"error-element\">\n
      \    <xs:annotation>\n      <xs:documentation>This indicates that the requested
      DELETE\n   operation could not be performed because it would not be\n   idempotent.</xs:documentation>\n
      \    </xs:annotation>\n     <xs:complexType>\n      <xs:attribute name=\"phrase\"
      type=\"xs:string\" use=\"optional\"/>\n     </xs:complexType>\n    </xs:element>\n
      \   <xs:element name=\"not-utf-8\" substitutionGroup=\"error-element\">\n     <xs:annotation>\n
      \     <xs:documentation>This indicates that the request could not be\n         completed
      because it would have produced a document not\n         encoded in UTF-8.</xs:documentation>\n
      \    </xs:annotation>\n     <xs:complexType>\n      <xs:attribute name=\"phrase\"
      type=\"xs:string\" use=\"optional\"/>\n     </xs:complexType>\n    </xs:element>\n
      \  </xs:schema>\n"
    title: 11.2.  XML Schema
  title: 11.  Detailed Conflict Reports
- contents:
  - "12.  XCAP Server Capabilities\n   XCAP can be extended through the addition of
    new application usages\n   and extensions to the core protocol.  Application usages
    may define\n   MIME types with XML schemas that allow new extension nodes from
    new\n   namespaces.  It will often be necessary for a client to determine\n   what
    extensions, application usages, or namespaces a server supports\n   before making
    a request.  To enable that, this specification defines\n   an application usage
    with the AUID \"xcap-caps\".  All XCAP servers\n   MUST support this application
    usage.  This usage defines a single\n   document within the global tree that lists
    the capabilities of the\n   server.  Clients can read this well-known document,
    and therefore\n   learn the capabilities of the server.\n   The structure of the
    document is simple.  The root element is <xcap-\n   caps>.  Its children are <auids>,
    <extensions>, and <namespaces>.\n   Each of these contain a list of AUIDs, extensions,
    and namespaces\n   supported by the server.  Extensions are named by tokens defined
    by\n   the extension, and typically define new selectors.  Namespaces are\n   identified
    by their namespace URI.  To 'support' a namespace, the\n   server must have the
    schemas for all elements within that namespace,\n   and be able to validate them
    if they appear within documents.  Since\n   all XCAP servers support the \"xcap-caps\"
    AUID, it MUST be listed in\n   the <auids> element, and the \"urn:ietf:params:xml:ns:xcap-caps\"\n
    \  namespace MUST be listed in the <namespaces> element.\n   The following sections
    provide the information needed to define this\n   application usage.\n"
  - contents:
    - "12.1.  Application Unique ID (AUID)\n   This specification defines the \"xcap-caps\"
      AUID within the IETF tree,\n   via the IANA registration in Section 15.\n"
    title: 12.1.  Application Unique ID (AUID)
  - contents:
    - "12.2.  XML Schema\n   <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n   <xs:schema
      targetNamespace=\"urn:ietf:params:xml:ns:xcap-caps\"\n    xmlns=\"urn:ietf:params:xml:ns:xcap-caps\"\n
      \   xmlns:xs=\"http://www.w3.org/2001/XMLSchema\"\n    elementFormDefault=\"qualified\"
      attributeFormDefault=\"unqualified\">\n    <xs:element name=\"xcap-caps\">\n
      \    <xs:annotation>\n      <xs:documentation>Root element for xcap-caps</xs:documentation>\n
      \    </xs:annotation>\n     <xs:complexType>\n      <xs:sequence>\n       <xs:element
      name=\"auids\">\n        <xs:annotation>\n         <xs:documentation>List of
      supported AUID.</xs:documentation>\n        </xs:annotation>\n        <xs:complexType>\n
      \        <xs:sequence minOccurs=\"0\" maxOccurs=\"unbounded\">\n          <xs:element
      name=\"auid\" type=\"auidType\"/>\n         </xs:sequence>\n        </xs:complexType>\n
      \      </xs:element>\n       <xs:element name=\"extensions\" minOccurs=\"0\">\n
      \       <xs:annotation>\n         <xs:documentation>List of supported extensions.\n
      \        </xs:documentation>\n        </xs:annotation>\n        <xs:complexType>\n
      \        <xs:sequence minOccurs=\"0\" maxOccurs=\"unbounded\">\n          <xs:element
      name=\"extension\" type=\"extensionType\"/>\n         </xs:sequence>\n        </xs:complexType>\n
      \      </xs:element>\n       <xs:element name=\"namespaces\">\n        <xs:annotation>\n
      \        <xs:documentation>List of supported namespaces.\n         </xs:documentation>\n
      \       </xs:annotation>\n        <xs:complexType>\n         <xs:sequence minOccurs=\"0\"
      maxOccurs=\"unbounded\">\n          <xs:element name=\"namespace\" type=\"namespaceType\"/>\n
      \        </xs:sequence>\n        </xs:complexType>\n       </xs:element>\n       <xs:any
      namespace=\"##other\" processContents=\"lax\"\n        minOccurs=\"0\" maxOccurs=\"unbounded\"/>\n
      \     </xs:sequence>\n     </xs:complexType>\n    </xs:element>\n    <xs:simpleType
      name=\"auidType\">\n     <xs:annotation>\n      <xs:documentation>AUID Type</xs:documentation>\n
      \    </xs:annotation>\n     <xs:restriction base=\"xs:string\"/>\n    </xs:simpleType>\n
      \   <xs:simpleType name=\"extensionType\">\n     <xs:annotation>\n      <xs:documentation>Extension
      Type</xs:documentation>\n     </xs:annotation>\n     <xs:restriction base=\"xs:string\"/>\n
      \   </xs:simpleType>\n    <xs:simpleType name=\"namespaceType\">\n     <xs:annotation>\n
      \     <xs:documentation>Namespace type</xs:documentation>\n     </xs:annotation>\n
      \    <xs:restriction base=\"xs:anyURI\"/>\n    </xs:simpleType>\n   </xs:schema>\n"
    title: 12.2.  XML Schema
  - contents:
    - "12.3.  Default Document Namespace\n   The default document namespace used in
      evaluating a URI is\n   urn:ietf:params:xml:ns:xcap-caps.\n"
    title: 12.3.  Default Document Namespace
  - contents:
    - "12.4.  MIME Type\n   Documents conformant to this schema are known by the MIME
      type\n   \"application/xcap-caps+xml\", registered in Section 15.2.5.\n"
    title: 12.4.  MIME Type
  - contents:
    - "12.5.  Validation Constraints\n   There are no additional validation constraints
      associated with this\n   application usage.\n"
    title: 12.5.  Validation Constraints
  - contents:
    - "12.6.  Data Semantics\n   Data semantics are defined above.\n"
    title: 12.6.  Data Semantics
  - contents:
    - "12.7.  Naming Conventions\n   A server MUST maintain a single instance of the
      document in the\n   global tree, using the filename \"index\".  There MUST NOT
      be an\n   instance of this document in the user's tree.\n"
    title: 12.7.  Naming Conventions
  - contents:
    - "12.8.  Resource Interdependencies\n   There are no resource interdependencies
      in this application usage\n   beyond those defined by the schema.\n"
    title: 12.8.  Resource Interdependencies
  - contents:
    - "12.9.  Authorization Policies\n   This application usage does not change the
      default authorization\n   policy defined by XCAP.\n"
    title: 12.9.  Authorization Policies
  title: 12.  XCAP Server Capabilities
- contents:
  - "13.  Examples\n   This section goes through several examples, making use of the\n
    \  resource-lists and rls-services [22] XCAP application usages.\n   First, a
    user Bill creates a new document (see Section 7.1).  This\n   document is a new
    resource-list, initially with a single list, called\n   friends, with no users
    in it:\n   PUT\n   /resource-lists/users/sip:bill@example.com/index HTTP/1.1\n
    \  Content-Type:application/resource-lists+xml\n   Host: xcap.example.com\n   <?xml
    version=\"1.0\" encoding=\"UTF-8\"?>\n   <resource-lists xmlns=\"urn:ietf:params:xml:ns:resource-lists\">\n
    \    <list name=\"friends\">\n     </list>\n   </resource-lists>\n                          Figure
    24: New Document\n   Next, Bill creates an RLS services document defining a single
    RLS\n   service referencing this list.  This service has a URI of\n   sip:myfriends@example.com
    (URIs are line-folded for readability):\n   PUT\n   /rls-services/users/sip:bill@example.com/index
    HTTP/1.1\n   Content-Type:application/rls-services+xml\n   Host: xcap.example.com\n
    \  <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n   <rls-services xmlns=\"urn:ietf:params:xml:ns:rls-services\">\n
    \  <service uri=\"sip:myfriends@example.com\">\n     <resource-list>http://xcap.example.com/resource-lists/users/\n
    \  sip:bill@example.com/index/~~/resource-lists/\n   list%5b@name=%22friends%22%5d\n
    \  </resource-list>\n     <packages>\n      <package>presence</package>\n     </packages>\n
    \   </service>\n   </rls-services>\n                      Figure 25: RLS Services
    Example\n   Next, Bill creates an element in the resource-lists document\n   (Section
    7.4).  In particular, he adds an entry to the list:\n   PUT\n   /resource-lists/users/sip:bill@example.com/index\n
    \  /~~/resource-lists/list%5b@name=%22friends%22%5d/entry HTTP/1.1\n   Content-Type:application/xcap-el+xml\n
    \  Host: xcap.example.com\n   <entry uri=\"sip:bob@example.com\">\n       <display-name>Bob
    Jones</display-name>\n     </entry>\n                    Figure 26: Resource Lists
    Document\n   Next, Bill fetches the document (Section 7.3):\n   GET\n   /resource-lists/users/sip:bill@example.com/index
    HTTP/1.1\n                        Figure 27: Fetch Operation\n   And the result
    is (note how white space text nodes appear in the\n   document):\n   HTTP/1.1
    200 OK\n   Etag: \"wwhha\"\n   Content-Type: application/resource-lists+xml\n
    \  <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n   <resource-lists xmlns=\"urn:ietf:params:xml:ns:resource-lists\">\n
    \    <list name=\"friends\">\n     <entry uri=\"sip:bob@example.com\">\n       <display-name>Bob
    Jones</display-name>\n     </entry></list>\n   </resource-lists>\n                        Figure
    28: Results of Fetch\n   Next, Bill adds another entry to the list, which is another
    list that\n   has three entries.  This is another element creation (Section 7.4):\n
    \  PUT\n   /resource-lists/users/sip:bill@example.com/index/~~/\n   resource-lists/list%5b@name=%22friends%22%5d/\n
    \  list%5b@name=%22close-friends%22%5d HTTP/1.1\n   Content-Type: application/xcap-el+xml\n
    \  Host: xcap.example.com\n   <list name=\"close-friends\">\n      <entry uri=\"sip:joe@example.com\">\n
    \       <display-name>Joe Smith</display-name>\n      </entry>\n      <entry uri=\"sip:nancy@example.com\">\n
    \       <display-name>Nancy Gross</display-name>\n      </entry>\n      <entry
    uri=\"sip:petri@example.com\">\n        <display-name>Petri Aukia</display-name>\n
    \     </entry>\n   </list>\n                        Figure 29: Adding an Entry\n
    \  Then, Bill decides he doesn't want Petri on the list, so he deletes\n   the
    entry (Section 7.5):\n   DELETE\n   /resource-lists/users/sip:bill@example.com/index/\n
    \  ~~/resource-lists/list/list/\n   entry%5b@uri=%22sip:petri@example.com%22%5d
    HTTP/1.1\n   Host: xcap.example.com\n                       Figure 30: Deleting
    an Entry\n   Bill decides to check on the URI for Nancy, so he fetches a\n   particular
    attribute (Section 7.6):\n   GET\n   /resource-lists/users/sip:bill@example.com/index/\n
    \  ~~/resource-lists/list/list/entry%5b2%5d/@uri HTTP/1.1\n   Host: xcap.example.com\n
    \                    Figure 31: Fetching an Attribute\n   and the server responds:\n
    \  HTTP/1.1 200 OK\n   Etag: \"ad88\"\n   Content-Type:application/xcap-att+xml\n
    \  \"sip:nancy@example.com\"\n                        Figure 32: Results of Fetch\n"
  title: 13.  Examples
- contents:
  - "14.  Security Considerations\n   Frequently, the data manipulated by XCAP contains
    sensitive\n   information.  To avoid eavesdroppers from seeing this information,
    it\n   is RECOMMENDED that an administrator hand out an HTTPS URI as the\n   XCAP
    root URI.  This will result in TLS-encrypted communications\n   between the client
    and server, preventing any eavesdropping.  Clients\n   MUST implement TLS, assuring
    that such URIs will be usable by the\n   client.\n   Client and server authentication
    are also important.  A client needs\n   to be sure it is talking to the server
    it believes it is contacting.\n   Otherwise, it may be given false information,
    which can lead to\n   denial-of-service attacks against a client.  To prevent
    this, a\n   client SHOULD attempt to upgrade [15] any connections to TLS.\n   Similarly,
    authorization of read and write operations against the\n   data is important,
    and this requires client authentication.  As a\n   result, a server SHOULD challenge
    a client using HTTP Digest [11] to\n   establish its identity, and this SHOULD
    be done over a TLS\n   connection.  Clients MUST implement digest authentication,
    assuring\n   interoperability with servers that challenge the client.  Servers\n
    \  MUST NOT perform basic authentication without a TLS connection to the\n   client.\n
    \  Because XCAP is a usage of HTTP and not a separate protocol, it runs\n   on
    the same port numbers as HTTP traffic normally does.  This makes\n   it difficult
    to apply port-based filtering rules in firewalls to\n   separate the treatment
    of XCAP traffic from other HTTP traffic.\n   However, this problem exists broadly
    today because HTTP is used to\n   access a wide breadth of content, all on the
    same port, and XCAP\n   views application configuration documents as just another
    type of\n   HTTP content.  As such, separate treatment of XCAP traffic from other\n
    \  HTTP traffic requires firewalls to examine the URL itself.  There is\n   no
    foolproof way to identify a URL as pointing to an XCAP resource.\n   However,
    the presence of the double tilde (~~) is a strong hint that\n   the URL points
    to an XML element or attribute.  As always, care must\n   be taken in looking
    for the double-tilde due to the breadth of ways\n   in which a URI can be encoded
    on-the-wire [29] [13].\n"
  title: 14.  Security Considerations
- contents:
  - "15.  IANA Considerations\n   There are several IANA considerations associated
    with this\n   specification.\n"
  - contents:
    - "15.1.  XCAP Application Unique IDs\n   Per this specification's instructions,
      IANA created a new registry\n   for XCAP application unique IDs (AUIDs).  This
      registry is defined as\n   a table that contains three columns:\n   AUID:  This
      will be a string provided in the IANA registrations into\n      the registry.\n
      \  Description:  This is text that is supplied by the IANA registration\n      into
      the registry.\n   Reference:  This is a reference to the RFC containing the\n
      \     registration.\n   Per this specification's instructions, IANA created
      this table with\n   an initial entry.  The resulting table looks like:\n   Application
      Unique\n       ID (AUID)          Description                      Reference\n
      \  --------------------   -------------------------------  ---------\n   xcap-caps
      \             Capabilities of an XCAP server   RFC 4825\n   XCAP AUIDs are registered
      by the IANA when they are published in\n   standards track RFCs.  The IANA Considerations
      section of the RFC\n   must include the following information, which appears
      in the IANA\n   registry along with the RFC number of the publication.\n   o
      \ Name of the AUID.  The name MAY be of any length, but SHOULD be no\n      more
      than 20 characters long.  The name MUST consist of alphanum\n      and mark
      [16] characters only.\n   o  Descriptive text that describes the application
      usage.\n"
    title: 15.1.  XCAP Application Unique IDs
  - contents:
    - "15.2.  MIME Types\n   This specification requests the registration of several
      new MIME\n   types according to the procedures of RFC 4288 [8] and guidelines
      in\n   RFC 3023 [9].\n"
    - contents:
      - "15.2.1.  application/xcap-el+xml MIME Type\n   MIME media type name:  application\n
        \  MIME subtype name:  xcap-el+xml\n   Mandatory parameters:  none\n   Optional
        parameters:  Same as charset parameter application/xml as\n      specified
        in RFC 3023 [9].\n   Encoding considerations:  Same as encoding considerations
        of\n      application/xml as specified in RFC 3023 [9].\n   Security considerations:
        \ See Section 10 of RFC 3023 [9].\n   Interoperability considerations:  none\n
        \  Published specification:  RFC 4825\n   Applications that use this media
        type:  This document type has been\n      used to support transport of XML
        fragment bodies in RFC 4825, the\n      XML Configuration Access Protocol
        (XCAP).\n   Additional Information:\n         Magic Number: none\n         File
        Extension: .xel\n         Macintosh file type code: \"TEXT\"\n   Personal
        and email address for further information:\n      Jonathan Rosenberg, jdrosen@jdrosen.net\n
        \  Intended usage:  COMMON\n   Author/Change controller:  The IETF.\n"
      title: 15.2.1.  application/xcap-el+xml MIME Type
    - contents:
      - "15.2.2.  application/xcap-att+xml MIME Type\n   MIME media type name:  application\n
        \  MIME subtype name:  xcap-att+xml\n   Mandatory parameters:  none\n   Optional
        parameters:  Same as charset parameter application/xml as\n      specified
        in RFC 3023 [9].\n   Encoding considerations:  Same as encoding considerations
        of\n      application/xml as specified in RFC 3023 [9].\n   Security considerations:
        \ See Section 10 of RFC 3023 [9].\n   Interoperability considerations:  none\n
        \  Published specification:  RFC 4825\n   Applications that use this media
        type:  This document type has been\n      used to support transport of XML
        attribute values in RFC 4825, the\n      XML Configuration Access Protocol
        (XCAP).\n   Additional Information:\n         Magic Number: none\n         File
        Extension: .xav\n         Macintosh file type code: \"TEXT\"\n   Personal
        and email address for further information:\n      Jonathan Rosenberg, jdrosen@jdrosen.net\n
        \  Intended usage:  COMMON\n   Author/Change controller:  The IETF.\n"
      title: 15.2.2.  application/xcap-att+xml MIME Type
    - contents:
      - "15.2.3.  application/xcap-ns+xml MIME Type\n   MIME media type name:  application\n
        \  MIME subtype name:  xcap-ns+xml\n   Mandatory parameters:  none\n   Optional
        parameters:  Same as charset parameter application/xml as\n      specified
        in RFC 3023 [9].\n   Encoding considerations:  Same as encoding considerations
        of\n      application/xml as specified in RFC 3023 [9].\n   Security considerations:
        \ See Section 10 of RFC 3023 [9].\n   Interoperability considerations:  none\n
        \  Published specification:  RFC 4825\n   Applications that use this media
        type:  This document type has been\n      used to support transport of XML
        fragment bodies in RFC 4825, the\n      XML Configuration Access Protocol
        (XCAP).\n   Additional Information:\n      Magic Number:  none\n      File
        Extension:  .xns\n      Macintosh file type code:  \"TEXT\"\n   Personal and
        email address for further information:\n      Jonathan Rosenberg, jdrosen@jdrosen.net\n
        \  Intended usage:  COMMON\n   Author/Change controller:  The IETF.\n"
      title: 15.2.3.  application/xcap-ns+xml MIME Type
    - contents:
      - "15.2.4.  application/xcap-error+xml MIME Type\n   MIME media type name:  application\n
        \  MIME subtype name:  xcap-error+xml\n   Mandatory parameters:  none\n   Optional
        parameters:  Same as charset parameter application/xml as\n      specified
        in RFC 3023 [9].\n   Encoding considerations:  Same as encoding considerations
        of\n      application/xml as specified in RFC 3023 [9].\n   Security considerations:
        \ See Section 10 of RFC 3023 [9].\n   Interoperability considerations:  none\n
        \  Published specification:  RFC 4825\n   Applications that use this media
        type:  This document type conveys\n      error conditions defined in RFC 4825\n
        \  Additional Information:\n      Magic Number:  none\n      File Extension:
        \ .xer\n      Macintosh file type code:  \"TEXT\"\n   Personal and email address
        for further information:\n      Jonathan Rosenberg, jdrosen@jdrosen.net\n
        \  Intended usage:  COMMON\n   Author/Change controller:  The IETF.\n"
      title: 15.2.4.  application/xcap-error+xml MIME Type
    - contents:
      - "15.2.5.  application/xcap-caps+xml MIME Type\n   MIME media type name:  application\n
        \  MIME subtype name:  xcap-caps+xml\n   Mandatory parameters:  none\n   Optional
        parameters:  Same as charset parameter application/xml as\n      specified
        in RFC 3023 [9].\n   Encoding considerations:  Same as encoding considerations
        of\n      application/xml as specified in RFC 3023 [9].\n   Security considerations:
        \ See Section 10 of RFC 3023 [9].\n   Interoperability considerations:  none\n
        \  Published specification:  RFC 4825\n   Applications that use this media
        type:  This document type conveys\n      capabilities of an XML Configuration
        Access Protocol (XCAP)\n      server, as defined in RFC 4825.\n   Additional
        Information:\n      Magic Number:  none\n      File Extension:  .xca\n      Macintosh
        file type code:  \"TEXT\"\n   Personal and email address for further information:\n
        \     Jonathan Rosenberg, jdrosen@jdrosen.net\n   Intended usage:  COMMON\n
        \  Author/Change controller:  The IETF.\n"
      title: 15.2.5.  application/xcap-caps+xml MIME Type
    title: 15.2.  MIME Types
  - contents:
    - "15.3.  URN Sub-Namespace Registrations\n   This specification registers several
      new XML namespaces, as per the\n   guidelines in RFC 3688 [17].\n"
    - contents:
      - "15.3.1.  urn:ietf:params:xml:ns:xcap-error\n   URI:  The URI for this namespace
        is urn:ietf:params:xml:ns:xcap-error\n   Registrant Contact:  IETF, SIMPLE
        working group, (simple@ietf.org),\n      Jonathan Rosenberg (jdrosen@jdrosen.net).\n"
      - "XML:\n           BEGIN\n           <?xml version=\"1.0\"?>\n           <!DOCTYPE
        html PUBLIC \"-//W3C//DTD XHTML Basic 1.0//EN\"\n              \"http://www.w3.org/TR/xhtml-basic/xhtml-basic10.dtd\">\n
        \          <html xmlns=\"http://www.w3.org/1999/xhtml\">\n           <head>\n
        \            <meta http-equiv=\"content-type\"\n                content=\"text/html;charset=iso-8859-1\"/>\n
        \            <title>XCAP Error Namespace</title>\n           </head>\n           <body>\n
        \            <h1>Namespace for XCAP Error Documents</h1>\n             <h2>urn:ietf:params:xml:ns:xcap-error</h2>\n
        \            <p>See <a href=\"http://www.rfc-editor.org/rfc/rfc4825.txt\">\n
        \               RFC4825</a></p>\n           </body>\n           </html>\n
        \          END\n"
      title: 15.3.1.  urn:ietf:params:xml:ns:xcap-error
    - contents:
      - "15.3.2.  urn:ietf:params:xml:ns:xcap-caps\n   URI:  The URI for this namespace
        is urn:ietf:params:xml:ns:xcap-caps\n   Registrant Contact:  IETF, SIMPLE
        working group, (simple@ietf.org),\n      Jonathan Rosenberg (jdrosen@jdrosen.net).\n"
      - "XML:\n           BEGIN\n           <?xml version=\"1.0\"?>\n           <!DOCTYPE
        html PUBLIC \"-//W3C//DTD XHTML Basic 1.0//EN\"\n              \"http://www.w3.org/TR/xhtml-basic/xhtml-basic10.dtd\">\n
        \          <html xmlns=\"http://www.w3.org/1999/xhtml\">\n           <head>\n
        \            <meta http-equiv=\"content-type\"\n                content=\"text/html;charset=iso-8859-1\"/>\n
        \            <title>XCAP Capabilities Namespace</title>\n           </head>\n
        \          <body>\n             <h1>Namespace for XCAP Capability Documents</h1>\n
        \            <h2>urn:ietf:params:xml:ns:xcap-caps</h2>\n             <p>See
        <a href=\"http://www.rfc-editor.org/rfc/rfc4825.txt\">\n                RFC4825</a></p>\n
        \          </body>\n           </html>\n           END\n"
      title: 15.3.2.  urn:ietf:params:xml:ns:xcap-caps
    title: 15.3.  URN Sub-Namespace Registrations
  - contents:
    - "15.4.  XML Schema Registrations\n   This section registers two XML schemas
      per the procedures in [17].\n"
    - contents:
      - "15.4.1.  XCAP Error Schema Registration\n   URI:  urn:ietf:params:xml:schema:xcap-error\n
        \  Registrant Contact:  IETF, SIMPLE working group, (simple@ietf.org),\n      Jonathan
        Rosenberg (jdrosen@jdrosen.net).\n   XML Schema:  The XML for this schema
        can be found as the sole content\n      of Section 11.2.\n"
      title: 15.4.1.  XCAP Error Schema Registration
    - contents:
      - "15.4.2.  XCAP Capabilities Schema Registration\n   URI:  urn:ietf:params:xml:schema:xcap-caps\n
        \  Registrant Contact:  IETF, SIMPLE working group, (simple@ietf.org),\n      Jonathan
        Rosenberg (jdrosen@jdrosen.net).\n   XML Schema:  The XML for this schema
        can be found as the sole content\n      of Section 12.2.\n"
      title: 15.4.2.  XCAP Capabilities Schema Registration
    title: 15.4.  XML Schema Registrations
  title: 15.  IANA Considerations
- contents:
  - "16.  Acknowledgements\n   The author would like to thank Jari Urpalainen, who
    has contributed\n   many important comments and has assisted with edit passes
    in the\n   document.  The author would also like to thank Ben Campbell,\n   Eva-Maria
    Leppanen, Hisham Khartabil, Chris Newman, Joel Halpern,\n   Lisa Dusseault, Tim
    Bray, Pete Cordell, Jeroen van Bemmel, Christian\n   Schmidt, and Spencer Dawkins
    for their input and comments.  A special\n   thanks to Ted Hardie for his input
    and support.\n"
  title: 16.  Acknowledgements
- contents:
  - '17.  References

    '
  - contents:
    - "17.1.  Normative References\n   [1]   Maler, E., Yergeau, F., Paoli, J., Bray,
      T., and C. Sperberg-\n         McQueen, \"Extensible Markup Language (XML) 1.0
      (Third\n         Edition)\", World Wide Web Consortium FirstEdition REC-xml-\n
      \        20040204, February 2004,\n         <http://www.w3.org/TR/2004/REC-xml-20040204>.\n
      \  [2]   Thompson, H., Maloney, M., Mendelsohn, N., and D. Beech, \"XML\n         Schema
      Part 1: Structures Second Edition\", World Wide Web\n         Consortium Recommendation
      REC-xmlschema-1-20041028,\n         October 2004,\n         <http://www.w3.org/TR/2004/REC-xmlschema-1-20041028>.\n
      \  [3]   Layman, A., Hollander, D., and T. Bray, \"Namespaces in XML\",\n         World
      Wide Web Consortium FirstEdition REC-xml-names-19990114,\n         January 1999,\n
      \        <http://www.w3.org/TR/1999/REC-xml-names-19990114>.\n   [4]   Daniel,
      R., DeRose, S., Maler, E., and J. Marsh, \"XPointer\n         xmlns() Scheme\",
      World Wide Web Consortium Recommendation REC-\n         xptr-xmlns-20030325,
      March 2003,\n         <http://www.w3.org/TR/2003/REC-xptr-xmlns-20030325>.\n
      \  [5]   Grosso, P., Marsh, J., Maler, E., and N. Walsh, \"XPointer\n         Framework\",
      World Wide Web Consortium Recommendation REC-xptr-\n         framework-20030325,
      March 2003,\n         <http://www.w3.org/TR/2003/REC-xptr-framework-20030325>.\n
      \  [6]   Fielding, R., Gettys, J., Mogul, J., Frystyk, H., Masinter, L.,\n         Leach,
      P., and T. Berners-Lee, \"Hypertext Transfer Protocol --\n         HTTP/1.1\",
      RFC 2616, June 1999.\n   [7]   Bradner, S., \"Key words for use in RFCs to Indicate
      Requirement\n         Levels\", BCP 14, RFC 2119, March 1997.\n   [8]   Freed,
      N. and J. Klensin, \"Media Type Specifications and\n         Registration Procedures\",
      BCP 13, RFC 4288, December 2005.\n   [9]   Murata, M., St. Laurent, S., and
      D. Kohn, \"XML Media Types\",\n         RFC 3023, January 2001.\n   [10]  Clark,
      J. and S. DeRose, \"XML Path Language (XPath) Version\n         1.0\", World
      Wide Web Consortium Recommendation REC-xpath-\n         19991116, November 1999,\n
      \        <http://www.w3.org/TR/1999/REC-xpath-19991116>.\n   [11]  Franks, J.,
      Hallam-Baker, P., Hostetler, J., Lawrence, S.,\n         Leach, P., Luotonen,
      A., and L. Stewart, \"HTTP Authentication:\n         Basic and Digest Access
      Authentication\", RFC 2617, June 1999.\n   [12]  Crocker, D., Ed. and P. Overell,
      \"Augmented BNF for Syntax\n         Specifications: ABNF\", RFC 4234, October
      2005.\n   [13]  Berners-Lee, T., Fielding, R., and L. Masinter, \"Uniform\n
      \        Resource Identifier (URI): Generic Syntax\", STD 66, RFC 3986,\n         January
      2005.\n   [14]  Rescorla, E., \"HTTP Over TLS\", RFC 2818, May 2000.\n   [15]
      \ Khare, R. and S. Lawrence, \"Upgrading to TLS Within HTTP/1.1\",\n         RFC
      2817, May 2000.\n   [16]  Rosenberg, J., Schulzrinne, H., Camarillo, G., Johnston,
      A.,\n         Peterson, J., Sparks, R., Handley, M., and E. Schooler, \"SIP:\n
      \        Session Initiation Protocol\", RFC 3261, June 2002.\n   [17]  Mealling,
      M., \"The IETF XML Registry\", BCP 81, RFC 3688,\n         January 2004.\n   [18]
      \ Yergeau, F., \"UTF-8, a transformation format of ISO 10646\",\n         STD
      63, RFC 3629, November 2003.\n   [19]  Boyer, J., \"Canonical XML Version 1.0\",
      World Wide Web\n         Consortium Recommendation REC-xml-c14n-20010315, March
      2001,\n         <http://www.w3.org/TR/2001/REC-xml-c14n-20010315>.\n"
    title: 17.1.  Normative References
  - contents:
    - "17.2.  Informative References\n   [20]  Rosenberg, J., \"A Presence Event Package
      for the Session\n         Initiation Protocol (SIP)\", RFC 3856, August 2004.\n
      \  [21]  Roach, A., Campbell, B., and J. Rosenberg, \"A Session\n         Initiation
      Protocol (SIP) Event Notification Extension for\n         Resource Lists\",
      RFC 4662, August 2006.\n   [22]  Rosenberg, J., \"Extensible Markup Language
      (XML) Formats for\n         Representing Resource Lists\", RFC 4826, May 2007.\n
      \  [23]  Grosso, P. and D. Veillard, \"XML Fragment Interchange\", World\n         Wide
      Web Consortium CR CR-xml-fragment-20010212, February 2001,\n         <http://www.w3.org/TR/2001/CR-xml-fragment-20010212>.\n
      \  [24]  Berglund, A., Boag, S., Chamberlin, D., Fernandez, M., Kay, M.,\n         Robie,
      J., and J. Simeon, \"XML Path Language (XPath) 2.0\",\n         World Wide Web
      Consortium\n         CR http://www.w3.org/TR/2005/CR-xpath20-20051103,\n         November
      2005.\n   [25]  Newman, C. and J. Myers, \"ACAP -- Application Configuration\n
      \        Access Protocol\", RFC 2244, November 1997.\n   [26]  Day, M., Rosenberg,
      J., and H. Sugano, \"A Model for Presence\n         and Instant Messaging\",
      RFC 2778, February 2000.\n   [27]  Narten, T. and H. Alvestrand, \"Guidelines
      for Writing an IANA\n         Considerations Section in RFCs\", BCP 26, RFC
      2434,\n         October 1998.\n   [28]  Roach, A., \"Session Initiation Protocol
      (SIP)-Specific Event\n         Notification\", RFC 3265, June 2002.\n   [29]
      \ Duerst, M. and M. Suignard, \"Internationalized Resource\n         Identifiers
      (IRIs)\", RFC 3987, January 2005.\n"
    title: 17.2.  Informative References
  title: 17.  References
- contents:
  - "Author's Address\n   Jonathan Rosenberg\n   Cisco\n   Edison, NJ\n   US\n   EMail:
    jdrosen@cisco.com\n   URI:   http://www.jdrosen.net\n"
  title: Author's Address
- contents:
  - "Full Copyright Statement\n   Copyright (C) The IETF Trust (2007).\n   This document
    is subject to the rights, licenses and restrictions\n   contained in BCP 78, and
    except as set forth therein, the authors\n   retain all their rights.\n   This
    document and the information contained herein are provided on an\n   \"AS IS\"
    basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS\n   OR IS SPONSORED
    BY (IF ANY), THE INTERNET SOCIETY, THE IETF TRUST AND\n   THE INTERNET ENGINEERING
    TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS\n   OR IMPLIED, INCLUDING BUT NOT
    LIMITED TO ANY WARRANTY THAT THE USE OF\n   THE INFORMATION HEREIN WILL NOT INFRINGE
    ANY RIGHTS OR ANY IMPLIED\n   WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR
    PURPOSE.\n"
  title: Full Copyright Statement
- contents:
  - "Intellectual Property\n   The IETF takes no position regarding the validity or
    scope of any\n   Intellectual Property Rights or other rights that might be claimed
    to\n   pertain to the implementation or use of the technology described in\n   this
    document or the extent to which any license under such rights\n   might or might
    not be available; nor does it represent that it has\n   made any independent effort
    to identify any such rights.  Information\n   on the procedures with respect to
    rights in RFC documents can be\n   found in BCP 78 and BCP 79.\n   Copies of IPR
    disclosures made to the IETF Secretariat and any\n   assurances of licenses to
    be made available, or the result of an\n   attempt made to obtain a general license
    or permission for the use of\n   such proprietary rights by implementers or users
    of this\n   specification can be obtained from the IETF on-line IPR repository
    at\n   http://www.ietf.org/ipr.\n   The IETF invites any interested party to bring
    to its attention any\n   copyrights, patents or patent applications, or other
    proprietary\n   rights that may cover technology that may be required to implement\n
    \  this standard.  Please address the information to the IETF at\n   ietf-ipr@ietf.org.\n"
  title: Intellectual Property
- contents:
  - "Acknowledgement\n   Funding for the RFC Editor function is currently provided
    by the\n   Internet Society.\n"
  title: Acknowledgement
