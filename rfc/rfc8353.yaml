- title: __initial_text__
  contents:
  - '      Generic Security Service API Version 2: Java Bindings Update

    '
- title: Abstract
  contents:
  - "Abstract\n   The Generic Security Services Application Programming Interface\n\
    \   (GSS-API) offers application programmers uniform access to security\n   services\
    \ atop a variety of underlying cryptographic mechanisms.  This\n   document updates\
    \ the Java bindings for the GSS-API that are specified\n   in \"Generic Security\
    \ Service API Version 2: Java Bindings Update\"\n   (RFC 5653).  This document\
    \ obsoletes RFC 5653 by adding a new output\n   token field to the GSSException\
    \ class so that when the initSecContext\n   or acceptSecContext methods of the\
    \ GSSContext class fail, it has a\n   chance to emit an error token that can be\
    \ sent to the peer for\n   debugging or informational purpose.  The stream-based\
    \ GSSContext\n   methods are also removed in this version.\n   The GSS-API is\
    \ described at a language-independent conceptual level\n   in \"Generic Security\
    \ Service Application Program Interface Version 2,\n   Update 1\" (RFC 2743).\
    \  The GSS-API allows a caller application to\n   authenticate a principal identity,\
    \ to delegate rights to a peer, and\n   to apply security services such as confidentiality\
    \ and integrity on a\n   per-message basis.  Examples of security mechanisms defined\
    \ for\n   GSS-API are \"The Simple Public-Key GSS-API Mechanism (SPKM)\"\n   (RFC\
    \ 2025) and \"The Kerberos Version 5 Generic Security Service\n   Application\
    \ Program Interface (GSS-API) Mechanism: Version 2\"\n   (RFC 4121).\n"
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This is an Internet Standards Track document.\n   This\
    \ document is a product of the Internet Engineering Task Force\n   (IETF).  It\
    \ represents the consensus of the IETF community.  It has\n   received public\
    \ review and has been approved for publication by the\n   Internet Engineering\
    \ Steering Group (IESG).  Further information on\n   Internet Standards is available\
    \ in Section 2 of RFC 7841.\n   Information about the current status of this document,\
    \ any errata,\n   and how to provide feedback on it may be obtained at\n   https://www.rfc-editor.org/info/rfc8353.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (c) 2018 IETF Trust and the persons identified\
    \ as the\n   document authors.  All rights reserved.\n   This document is subject\
    \ to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n\
    \   (https://trustee.ietf.org/license-info) in effect on the date of\n   publication\
    \ of this document.  Please review these documents\n   carefully, as they describe\
    \ your rights and restrictions with respect\n   to this document.  Code Components\
    \ extracted from this document must\n   include Simplified BSD License text as\
    \ described in Section 4.e of\n   the Trust Legal Provisions and are provided\
    \ without warranty as\n   described in the Simplified BSD License.\n   This document\
    \ may contain material from IETF Documents or IETF\n   Contributions published\
    \ or made publicly available before November\n   10, 2008.  The person(s) controlling\
    \ the copyright in some of this\n   material may not have granted the IETF Trust\
    \ the right to allow\n   modifications of such material outside the IETF Standards\
    \ Process.\n   Without obtaining an adequate license from the person(s) controlling\n\
    \   the copyright in such materials, this document may not be modified\n   outside\
    \ the IETF Standards Process, and derivative works of it may\n   not be created\
    \ outside the IETF Standards Process, except to format\n   it for publication\
    \ as an RFC or to translate it into languages other\n   than English.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1.  Introduction  . . . . . . . . . . . . . . . . . . .\
    \ . . . . .   6\n   2.  Notational Conventions  . . . . . . . . . . . . . . .\
    \ . . . .   7\n   3.  GSS-API Operational Paradigm  . . . . . . . . . . . . .\
    \ . . .   7\n   4.  Additional Controls . . . . . . . . . . . . . . . . . . .\
    \ . .   9\n     4.1.  Delegation  . . . . . . . . . . . . . . . . . . . . . .\
    \ .  10\n     4.2.  Mutual Authentication . . . . . . . . . . . . . . . . . .\
    \  11\n     4.3.  Replay and Out-of-Sequence Detection  . . . . . . . . . .  11\n\
    \     4.4.  Anonymous Authentication  . . . . . . . . . . . . . . . .  12\n  \
    \   4.5.  Integrity and Confidentiality . . . . . . . . . . . . . .  13\n    \
    \ 4.6.  Inter-process Context Transfer  . . . . . . . . . . . . .  13\n     4.7.\
    \  The Use of Incomplete Contexts  . . . . . . . . . . . . .  14\n   5.  Calling\
    \ Conventions . . . . . . . . . . . . . . . . . . . . .  15\n     5.1.  Package\
    \ Name  . . . . . . . . . . . . . . . . . . . . . .  15\n     5.2.  Provider Framework\
    \  . . . . . . . . . . . . . . . . . . .  15\n     5.3.  Integer Types . . . .\
    \ . . . . . . . . . . . . . . . . . .  16\n     5.4.  Opaque Data Types . . .\
    \ . . . . . . . . . . . . . . . . .  16\n     5.5.  Strings . . . . . . . . .\
    \ . . . . . . . . . . . . . . . .  16\n     5.6.  Object Identifiers  . . . .\
    \ . . . . . . . . . . . . . . .  16\n     5.7.  Object Identifier Sets  . . .\
    \ . . . . . . . . . . . . . .  17\n     5.8.  Credentials . . . . . . . . . .\
    \ . . . . . . . . . . . . .  17\n     5.9.  Contexts  . . . . . . . . . . . .\
    \ . . . . . . . . . . . .  19\n     5.10. Authentication Tokens . . . . . . .\
    \ . . . . . . . . . . .  20\n     5.11. Inter-process Tokens  . . . . . . . .\
    \ . . . . . . . . . .  20\n     5.12. Error Reporting . . . . . . . . . . . .\
    \ . . . . . . . . .  20\n       5.12.1.  GSS Status Codes . . . . . . . . . .\
    \ . . . . . . . .  21\n       5.12.2.  Mechanism-Specific Status Codes  . . .\
    \ . . . . . . .  23\n       5.12.3.  Supplementary Status Codes . . . . . . .\
    \ . . . . . .  23\n     5.13. Names . . . . . . . . . . . . . . . . . . . . .\
    \ . . . . .  24\n     5.14. Channel Bindings  . . . . . . . . . . . . . . . .\
    \ . . . .  27\n     5.15. Optional Parameters . . . . . . . . . . . . . . . .\
    \ . . .  28\n   6.  Introduction to GSS-API Classes and Interfaces  . . . . .\
    \ . .  28\n     6.1.  GSSManager Class  . . . . . . . . . . . . . . . . . . .\
    \ .  28\n     6.2.  GSSName Interface . . . . . . . . . . . . . . . . . . . .\
    \  29\n     6.3.  GSSCredential Interface . . . . . . . . . . . . . . . . .  30\n\
    \     6.4.  GSSContext Interface  . . . . . . . . . . . . . . . . . .  31\n  \
    \   6.5.  MessageProp Class . . . . . . . . . . . . . . . . . . . .  32\n    \
    \ 6.6.  GSSException Class  . . . . . . . . . . . . . . . . . . .  32\n     6.7.\
    \  Oid Class . . . . . . . . . . . . . . . . . . . . . . . .  32\n     6.8.  ChannelBinding\
    \ Class  . . . . . . . . . . . . . . . . . .  33\n   7.  Detailed GSS-API Class\
    \ Description  . . . . . . . . . . . . .  33\n     7.1.  public abstract class\
    \ GSSManager  . . . . . . . . . . . .  33\n       7.1.1.  getInstance . . . .\
    \ . . . . . . . . . . . . . . . . .  34\n       7.1.2.  getMechs  . . . . . .\
    \ . . . . . . . . . . . . . . . .  34\n       7.1.3.  getNamesForMech . . . .\
    \ . . . . . . . . . . . . . . .  35\n       7.1.4.  getMechsForName . . . . .\
    \ . . . . . . . . . . . . . .  35\n       7.1.5.  createName  . . . . . . . .\
    \ . . . . . . . . . . . . .  35\n       7.1.6.  createName  . . . . . . . . .\
    \ . . . . . . . . . . . .  36\n       7.1.7.  createName  . . . . . . . . . .\
    \ . . . . . . . . . . .  36\n       7.1.8.  createName  . . . . . . . . . . .\
    \ . . . . . . . . . .  37\n       7.1.9.  createCredential  . . . . . . . . .\
    \ . . . . . . . . .  38\n       7.1.10. createCredential  . . . . . . . . . .\
    \ . . . . . . . .  38\n       7.1.11. createCredential  . . . . . . . . . . .\
    \ . . . . . . .  39\n       7.1.12. createContext . . . . . . . . . . . . . .\
    \ . . . . . .  39\n       7.1.13. createContext . . . . . . . . . . . . . . .\
    \ . . . . .  40\n       7.1.14. createContext . . . . . . . . . . . . . . . .\
    \ . . . .  40\n       7.1.15. addProviderAtFront  . . . . . . . . . . . . . .\
    \ . . .  41\n         7.1.15.1.  addProviderAtFront Example Code  . . . . . .\
    \ . .  42\n       7.1.16. addProviderAtEnd  . . . . . . . . . . . . . . . . .\
    \ .  43\n         7.1.16.1.  addProviderAtEnd Example Code  . . . . . . . . .\
    \  43\n       7.1.17. Example Code  . . . . . . . . . . . . . . . . . . . .  44\n\
    \     7.2.  public interface GSSName  . . . . . . . . . . . . . . . .  45\n  \
    \     7.2.1.  Static Constants  . . . . . . . . . . . . . . . . . .  45\n    \
    \   7.2.2.  equals  . . . . . . . . . . . . . . . . . . . . . . .  46\n      \
    \ 7.2.3.  equals  . . . . . . . . . . . . . . . . . . . . . . .  46\n       7.2.4.\
    \  canonicalize  . . . . . . . . . . . . . . . . . . . .  47\n       7.2.5.  export\
    \  . . . . . . . . . . . . . . . . . . . . . . .  47\n       7.2.6.  toString\
    \  . . . . . . . . . . . . . . . . . . . . . .  47\n       7.2.7.  getStringNameType\
    \ . . . . . . . . . . . . . . . . . .  47\n       7.2.8.  isAnonymous . . . .\
    \ . . . . . . . . . . . . . . . . .  47\n       7.2.9.  isMN  . . . . . . . .\
    \ . . . . . . . . . . . . . . . .  48\n       7.2.10. Example Code  . . . . .\
    \ . . . . . . . . . . . . . . .  48\n     7.3.  public interface GSSCredential\
    \ implements Cloneable . . .  49\n       7.3.1.  Static Constants  . . . . . .\
    \ . . . . . . . . . . . .  50\n       7.3.2.  dispose . . . . . . . . . . . .\
    \ . . . . . . . . . . .  50\n       7.3.3.  getName . . . . . . . . . . . . .\
    \ . . . . . . . . . .  50\n       7.3.4.  getName . . . . . . . . . . . . . .\
    \ . . . . . . . . .  51\n       7.3.5.  getRemainingLifetime  . . . . . . . .\
    \ . . . . . . . .  51\n       7.3.6.  getRemainingInitLifetime  . . . . . . .\
    \ . . . . . . .  51\n       7.3.7.  getRemainingAcceptLifetime  . . . . . . .\
    \ . . . . . .  51\n       7.3.8.  getUsage  . . . . . . . . . . . . . . . . .\
    \ . . . . .  52\n       7.3.9.  getUsage  . . . . . . . . . . . . . . . . . .\
    \ . . . .  52\n       7.3.10. getMechs  . . . . . . . . . . . . . . . . . . .\
    \ . . .  52\n       7.3.11. add . . . . . . . . . . . . . . . . . . . . . . .\
    \ . .  52\n       7.3.12. equals  . . . . . . . . . . . . . . . . . . . . . .\
    \ .  53\n       7.3.13. Example Code  . . . . . . . . . . . . . . . . . . . .\
    \  54\n     7.4.  public interface GSSContext . . . . . . . . . . . . . . .  54\n\
    \       7.4.1.  Static Constants  . . . . . . . . . . . . . . . . . .  55\n  \
    \     7.4.2.  initSecContext  . . . . . . . . . . . . . . . . . . .  56\n    \
    \   7.4.3.  acceptSecContext  . . . . . . . . . . . . . . . . . .  56\n      \
    \ 7.4.4.  isEstablished . . . . . . . . . . . . . . . . . . . .  57\n       7.4.5.\
    \  dispose . . . . . . . . . . . . . . . . . . . . . . .  57\n       7.4.6.  getWrapSizeLimit\
    \  . . . . . . . . . . . . . . . . . .  58\n       7.4.7.  wrap  . . . . . . .\
    \ . . . . . . . . . . . . . . . . .  58\n       7.4.8.  unwrap  . . . . . . .\
    \ . . . . . . . . . . . . . . . .  59\n       7.4.9.  getMIC  . . . . . . . .\
    \ . . . . . . . . . . . . . . .  60\n       7.4.10. verifyMIC . . . . . . . .\
    \ . . . . . . . . . . . . . .  61\n       7.4.11. export  . . . . . . . . . .\
    \ . . . . . . . . . . . . .  62\n       7.4.12. requestMutualAuth . . . . . .\
    \ . . . . . . . . . . . .  62\n       7.4.13. requestReplayDet  . . . . . . .\
    \ . . . . . . . . . . .  63\n       7.4.14. requestSequenceDet  . . . . . . .\
    \ . . . . . . . . . .  63\n       7.4.15. requestCredDeleg  . . . . . . . . .\
    \ . . . . . . . . .  63\n       7.4.16. requestAnonymity  . . . . . . . . . .\
    \ . . . . . . . .  64\n       7.4.17. requestConf . . . . . . . . . . . . . .\
    \ . . . . . . .  64\n       7.4.18. requestInteg  . . . . . . . . . . . . . .\
    \ . . . . . .  64\n       7.4.19. requestLifetime . . . . . . . . . . . . . .\
    \ . . . . .  64\n       7.4.20. setChannelBinding . . . . . . . . . . . . . .\
    \ . . . .  65\n       7.4.21. getCredDelegState . . . . . . . . . . . . . . .\
    \ . . .  65\n       7.4.22. getMutualAuthState  . . . . . . . . . . . . . . .\
    \ . .  65\n       7.4.23. getReplayDetState . . . . . . . . . . . . . . . . .\
    \ .  65\n       7.4.24. getSequenceDetState . . . . . . . . . . . . . . . . .\
    \  66\n       7.4.25. getAnonymityState . . . . . . . . . . . . . . . . . .  66\n\
    \       7.4.26. isTransferable  . . . . . . . . . . . . . . . . . . .  66\n  \
    \     7.4.27. isProtReady . . . . . . . . . . . . . . . . . . . . .  66\n    \
    \   7.4.28. getConfState  . . . . . . . . . . . . . . . . . . . .  66\n      \
    \ 7.4.29. getIntegState . . . . . . . . . . . . . . . . . . . .  67\n       7.4.30.\
    \ getLifetime . . . . . . . . . . . . . . . . . . . . .  67\n       7.4.31. getSrcName\
    \  . . . . . . . . . . . . . . . . . . . . .  67\n       7.4.32. getTargName .\
    \ . . . . . . . . . . . . . . . . . . . .  67\n       7.4.33. getMech . . . .\
    \ . . . . . . . . . . . . . . . . . . .  67\n       7.4.34. getDelegCred  . .\
    \ . . . . . . . . . . . . . . . . . .  68\n       7.4.35. isInitiator . . . .\
    \ . . . . . . . . . . . . . . . . .  68\n       7.4.36. Example Code  . . . .\
    \ . . . . . . . . . . . . . . . .  68\n     7.5.  public class MessageProp  .\
    \ . . . . . . . . . . . . . . .  70\n       7.5.1.  Constructors  . . . . . .\
    \ . . . . . . . . . . . . . .  70\n       7.5.2.  getQOP  . . . . . . . . . .\
    \ . . . . . . . . . . . . .  71\n       7.5.3.  getPrivacy  . . . . . . . . .\
    \ . . . . . . . . . . . .  71\n       7.5.4.  getMinorStatus  . . . . . . . .\
    \ . . . . . . . . . . .  71\n       7.5.5.  getMinorString  . . . . . . . . .\
    \ . . . . . . . . . .  71\n       7.5.6.  setQOP  . . . . . . . . . . . . . .\
    \ . . . . . . . . .  71\n       7.5.7.  setPrivacy  . . . . . . . . . . . . .\
    \ . . . . . . . .  72\n       7.5.8.  isDuplicateToken  . . . . . . . . . . .\
    \ . . . . . . .  72\n       7.5.9.  isOldToken  . . . . . . . . . . . . . . .\
    \ . . . . . .  72\n       7.5.10. isUnseqToken  . . . . . . . . . . . . . . .\
    \ . . . . .  72\n       7.5.11. isGapToken  . . . . . . . . . . . . . . . . .\
    \ . . . .  72\n       7.5.12. setSupplementaryStates  . . . . . . . . . . . .\
    \ . . .  72\n     7.6.  public class ChannelBinding . . . . . . . . . . . . .\
    \ . .  73\n       7.6.1.  Constructors  . . . . . . . . . . . . . . . . . . .\
    \ .  73\n       7.6.2.  getInitiatorAddress . . . . . . . . . . . . . . . . .\
    \  74\n       7.6.3.  getAcceptorAddress  . . . . . . . . . . . . . . . . .  74\n\
    \       7.6.4.  getApplicationData  . . . . . . . . . . . . . . . . .  74\n  \
    \     7.6.5.  equals  . . . . . . . . . . . . . . . . . . . . . . .  75\n    \
    \ 7.7.  public class Oid  . . . . . . . . . . . . . . . . . . . .  75\n      \
    \ 7.7.1.  Constructors  . . . . . . . . . . . . . . . . . . . .  75\n       7.7.2.\
    \  toString  . . . . . . . . . . . . . . . . . . . . . .  76\n       7.7.3.  equals\
    \  . . . . . . . . . . . . . . . . . . . . . . .  76\n       7.7.4.  getDER  .\
    \ . . . . . . . . . . . . . . . . . . . . . .  76\n       7.7.5.  containedIn\
    \ . . . . . . . . . . . . . . . . . . . . .  77\n     7.8.  public class GSSException\
    \ extends Exception . . . . . . .  77\n       7.8.1.  Static Constants  . . .\
    \ . . . . . . . . . . . . . . .  77\n       7.8.2.  Constructors  . . . . . .\
    \ . . . . . . . . . . . . . .  80\n       7.8.3.  getMajor  . . . . . . . . .\
    \ . . . . . . . . . . . . .  81\n       7.8.4.  getMinor  . . . . . . . . . .\
    \ . . . . . . . . . . . .  81\n       7.8.5.  getMajorString  . . . . . . . .\
    \ . . . . . . . . . . .  81\n       7.8.6.  getMinorString  . . . . . . . . .\
    \ . . . . . . . . . .  81\n       7.8.7.  getOutputToken  . . . . . . . . . .\
    \ . . . . . . . . .  82\n       7.8.8.  setMinor  . . . . . . . . . . . . . .\
    \ . . . . . . . .  82\n       7.8.9.  toString  . . . . . . . . . . . . . . .\
    \ . . . . . . .  82\n       7.8.10. getMessage  . . . . . . . . . . . . . . .\
    \ . . . . . .  82\n   8.  Sample Applications . . . . . . . . . . . . . . . .\
    \ . . . . .  83\n     8.1.  Simple GSS Context Initiator  . . . . . . . . . .\
    \ . . . .  83\n     8.2.  Simple GSS Context Acceptor . . . . . . . . . . . .\
    \ . . .  87\n   9.  Security Considerations . . . . . . . . . . . . . . . . .\
    \ . .  90\n   10. IANA Considerations . . . . . . . . . . . . . . . . . . . .\
    \ .  91\n   11. Changes since RFC 5653  . . . . . . . . . . . . . . . . . . .\
    \  91\n   12. Changes since RFC 2853  . . . . . . . . . . . . . . . . . . .  93\n\
    \   13. References  . . . . . . . . . . . . . . . . . . . . . . . . .  94\n  \
    \   13.1.  Normative References . . . . . . . . . . . . . . . . . .  94\n    \
    \ 13.2.  Informative References . . . . . . . . . . . . . . . . .  95\n   Acknowledgments\
    \ . . . . . . . . . . . . . . . . . . . . . . . . .  96\n   Authors' Addresses\
    \  . . . . . . . . . . . . . . . . . . . . . . .  96\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   This document specifies Java language bindings for the Generic\n\
    \   Security Services Application Programming Interface (GSS-API) version\n  \
    \ 2.  GSS-API version 2 is described in a language-independent format\n   in RFC\
    \ 2743 [RFC2743].  The GSS-API allows a caller application to\n   authenticate\
    \ a principal identity, delegate rights to a peer, and\n   apply security services\
    \ such as confidentiality and integrity on a\n   per-message basis.\n   This document\
    \ and its predecessors, RFC 2853 [RFC2853] and RFC 5653\n   [RFC5653], leverage\
    \ the work done by the working group (WG) in the\n   area of RFC 2743 [RFC2743]\
    \ and the C-bindings of RFC 2744 [RFC2744].\n   Whenever appropriate, text has\
    \ been used from the C-bindings document\n   (RFC 2744) to explain generic concepts\
    \ and provide direction to the\n   implementors.\n   The design goals of this\
    \ API have been to satisfy all the\n   functionality defined in RFC 2743 [RFC2743]\
    \ and to provide these\n   services in an object-oriented method.  The specification\
    \ also aims\n   to satisfy the needs of both types of Java application developers,\n\
    \   those who would like access to a \"system-wide\" GSS-API\n   implementation,\
    \ as well as those who would want to provide their own\n   \"custom\" implementation.\n\
    \   A system-wide implementation is one that is available to all\n   applications\
    \ in the form of a library package.  It may be the\n   standard package in the\
    \ Java runtime environment (JRE) being used, or\n   it may be additionally installed\
    \ and accessible to any application\n   via the CLASSPATH.\n   A custom implementation\
    \ of the GSS-API, on the other hand, is one\n   that would, in most cases, be\
    \ bundled with the application during\n   distribution.  It is expected that such\
    \ an implementation would be\n   meant to provide for some particular need of\
    \ the application, such as\n   support for some specific mechanism.\n   The design\
    \ of this API also aims to provide a flexible framework to\n   add and manage\
    \ GSS-API mechanisms.  GSS-API leverages the Java\n   Cryptography Architecture\
    \ (JCA) provider model to support the\n   plugability of mechanisms.  Mechanisms\
    \ can be added on a system-wide\n   basis, where all users of the framework will\
    \ have them available.\n   The specification also allows for the addition of mechanisms\
    \ per\n   instance of the GSS-API.\n   Lastly, this specification presents an\
    \ API that will naturally fit\n   within the operation environment of the Java\
    \ platform.  Readers are\n   assumed to be familiar with both the GSS-API and\
    \ the Java platform.\n"
- title: 2.  Notational Conventions
  contents:
  - "2.  Notational Conventions\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\"\
    , \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"\
    NOT RECOMMENDED\", \"MAY\", and\n   \"OPTIONAL\" in this document are to be interpreted\
    \ as described in\n   BCP 14 [RFC2119] [RFC8174] when, and only when, they appear\
    \ in all\n   capitals, as shown here.\n"
- title: 3.  GSS-API Operational Paradigm
  contents:
  - "3.  GSS-API Operational Paradigm\n   \"Generic Security Service Application Programming\
    \ Interface, Version\n   2\" [RFC2743] defines a generic security API to calling\
    \ applications.\n   It allows a communicating application to authenticate the\
    \ user\n   associated with another application, to delegate rights to another\n\
    \   application, and to apply security services such as confidentiality\n   and\
    \ integrity on a per-message basis.\n   There are four stages to using GSS-API:\n\
    \   1) The application acquires a set of credentials with which it may\n     \
    \ prove its identity to other processes.  The application's\n      credentials\
    \ vouch for its global identity, which may or may not be\n      related to any\
    \ local username under which it may be running.\n   2) A pair of communicating\
    \ applications establish a joint security\n      context using their credentials.\
    \  The security context\n      encapsulates shared state information, which is\
    \ required in order\n      that per-message security services may be provided.\
    \  Examples of\n      state information that might be shared between applications\
    \ as\n      part of a security context are cryptographic keys and message\n  \
    \    sequence numbers.  As part of the establishment of a security\n      context,\
    \ the context initiator is authenticated to the responder\n      and may require\
    \ that the responder is authenticated back to the\n      initiator.  The initiator\
    \ may optionally give the responder the\n      right to initiate further security\
    \ contexts, acting as an agent or\n      delegate of the initiator.  This transfer\
    \ of rights is termed\n      \"delegation\" and is achieved by creating a set\
    \ of credentials,\n      similar to those used by the initiating application,\
    \ but which may\n      be used by the responder.\n      A GSSContext object is\
    \ used to establish and maintain the shared\n      information that makes up the\
    \ security context.  Certain\n      GSSContext methods will generate a token,\
    \ which applications treat\n      as cryptographically protected, opaque data.\
    \  The caller of such a\n      GSSContext method is responsible for transferring\
    \ the token to the\n      peer application, encapsulated if necessary in an application-to-\n\
    \      application protocol.  On receipt of such a token, the peer\n      application\
    \ should pass it to a corresponding GSSContext method,\n      which will decode\
    \ the token and extract the information, updating\n      the security context\
    \ state information accordingly.\n   3) Per-message services are invoked on a\
    \ GSSContext object to apply\n      either:\n      integrity and data origin authentication,\
    \ or\n      confidentiality, integrity, and data origin authentication\n     \
    \ to application data, which are treated by GSS-API as arbitrary\n      octet\
    \ strings.  An application transmitting a message that it\n      wishes to protect\
    \ will call the appropriate GSSContext method\n      (getMIC or wrap) to apply\
    \ protection before sending the resulting\n      token to the receiving application.\
    \  The receiver will pass the\n      received token (and, in the case of data\
    \ protected by getMIC, the\n      accompanying message data) to the corresponding\
    \ decoding method of\n      the GSSContext interface (verifyMIC or unwrap) to\
    \ remove the\n      protection and validate the data.\n   4) At the completion\
    \ of a communications session (which may extend\n      across several transport\
    \ connections), each application uses a\n      GSSContext method to invalidate\
    \ the security context and release\n      any system or cryptographic resources\
    \ held.  Multiple contexts may\n      also be used (either successively or simultaneously)\
    \ within a\n      single communications association, at the discretion of the\n\
    \      applications.\n"
- title: 4.  Additional Controls
  contents:
  - "4.  Additional Controls\n   This section discusses the OPTIONAL services that\
    \ a context initiator\n   may request of the GSS-API before the context establishment.\
    \  Each of\n   these services is requested by calling the appropriate mutator\
    \ method\n   in the GSSContext object before the first call to init is performed.\n\
    \   Only the context initiator can request context flags.\n   The OPTIONAL services\
    \ defined are:\n      Delegation: The (usually temporary) transfer of rights from\n\
    \      initiator to acceptor, enabling the acceptor to authenticate\n      itself\
    \ as an agent of the initiator.\n      Mutual Authentication: In addition to the\
    \ initiator authenticating\n      its identity to the context acceptor, the context\
    \ acceptor SHOULD\n      also authenticate itself to the initiator.\n      Replay\
    \ Detection: In addition to providing message integrity\n      services, GSSContext\
    \ per-message operations of getMIC and wrap\n      SHOULD include message numbering\
    \ information to enable verifyMIC\n      and unwrap to detect if a message has\
    \ been duplicated.\n      Out-of-Sequence Detection: In addition to providing\
    \ message\n      integrity services, GSSContext per-message operations (getMIC\
    \ and\n      wrap) SHOULD include message sequencing information to enable\n \
    \     verifyMIC and unwrap to detect if a message has been received out\n    \
    \  of sequence.\n      Anonymous Authentication: The establishment of the security\n\
    \      context SHOULD NOT reveal the initiator's identity to the context\n   \
    \   acceptor.\n   Some mechanisms may not support all OPTIONAL services, and some\n\
    \   mechanisms may only support some services in conjunction with others.\n  \
    \ The GSSContext interface offers query methods to allow the\n   verification\
    \ by the calling application of which services will be\n   available from the\
    \ context when the establishment phase is complete.\n   In general, if the security\
    \ mechanism is capable of providing a\n   requested service, it SHOULD do so even\
    \ if additional services must\n   be enabled in order to provide the requested\
    \ service.  If the\n   mechanism is incapable of providing a requested service,\
    \ it SHOULD\n   proceed without the service leaving the application to abort the\n\
    \   context establishment process if it considers the requested service\n   to\
    \ be mandatory.\n   Some mechanisms MAY specify that support for some services\
    \ is\n   optional and that implementors of the mechanism need not provide it.\n\
    \   This is most commonly true of the confidentiality service, often\n   because\
    \ of legal restrictions on the use of data encryption, but it\n   may apply to\
    \ any of the services.  Such mechanisms are required to\n   send at least one\
    \ token from acceptor to initiator during context\n   establishment when the initiator\
    \ indicates a desire to use such a\n   service, so that the initiating GSS-API\
    \ can correctly indicate\n   whether the service is supported by the acceptor's\
    \ GSS-API.\n"
- title: 4.1.  Delegation
  contents:
  - "4.1.  Delegation\n   The GSS-API allows delegation to be controlled by the initiating\n\
    \   application via the requestCredDeleg method before the first call to\n   init\
    \ has been issued.  Some mechanisms do not support delegation, and\n   for such\
    \ mechanisms, attempts by an application to enable delegation\n   are ignored.\n\
    \   The acceptor of a security context, for which the initiator enabled\n   delegation,\
    \ can check if delegation was enabled by using the\n   getCredDelegState method\
    \ of the GSSContext interface.  In cases when\n   it is enabled, the delegated\
    \ credential object can be obtained by\n   calling the getDelegCred method.  The\
    \ obtained GSSCredential object\n   may then be used to initiate subsequent GSS-API\
    \ security contexts as\n   an agent or delegate of the initiator.  If the original\
    \ initiator's\n   identity is \"A\" and the delegate's identity is \"B\", then,\
    \ depending\n   on the underlying mechanism, the identity embodied by the delegated\n\
    \   credential may be either \"A\" or \"B acting for A\".\n   For many mechanisms\
    \ that support delegation, a simple boolean does\n   not provide enough control.\
    \  Examples of additional aspects of\n   delegation control that a mechanism might\
    \ provide to an application\n   are duration of delegation, network addresses\
    \ from which delegation\n   is valid, and constraints on the tasks that may be\
    \ performed by a\n   delegate.  Such controls are presently outside the scope\
    \ of the\n   GSS-API.  GSS-API implementations supporting mechanisms offering\n\
    \   additional controls SHOULD provide extension routines that allow\n   these\
    \ controls to be exercised (perhaps by modifying the initiator's\n   GSS-API credential\
    \ object prior to its use in establishing a\n   context).  However, the simple\
    \ delegation control provided by GSS-API\n   SHOULD always be able to override\
    \ other mechanism-specific delegation\n   controls.  If the application instructs\
    \ the GSSContext object that\n   delegation is not desired, then the implementation\
    \ MUST NOT permit\n   delegation to occur.  This is an exception to the general\
    \ rule that a\n   mechanism may enable services even if they are not requested\
    \ --\n   delegation may only be provided at the explicit request of the\n   application.\n"
- title: 4.2.  Mutual Authentication
  contents:
  - "4.2.  Mutual Authentication\n   Usually, a context acceptor will require that\
    \ a context initiator\n   authenticate itself so that the acceptor may make an\
    \ access-control\n   decision prior to performing a service for the initiator.\
    \  In some\n   cases, the initiator may also request that the acceptor authenticate\n\
    \   itself.  GSS-API allows the initiating application to request this\n   mutual\
    \ authentication service by calling the requestMutualAuth method\n   of the GSSContext\
    \ interface with a \"true\" parameter before making the\n   first call to init.\
    \  The initiating application is informed as to\n   whether or not the context\
    \ acceptor has authenticated itself.  Note\n   that some mechanisms may not support\
    \ mutual authentication, and other\n   mechanisms may always perform mutual authentication,\
    \ whether or not\n   the initiating application requests it.  In particular, mutual\n\
    \   authentication may be required by some mechanisms in order to support\n  \
    \ replay or out-of-sequence message detection, and for such mechanisms,\n   a\
    \ request for either of these services will automatically enable\n   mutual authentication.\n"
- title: 4.3.  Replay and Out-of-Sequence Detection
  contents:
  - "4.3.  Replay and Out-of-Sequence Detection\n   The GSS-API MAY provide detection\
    \ of mis-ordered messages once a\n   security context has been established.  Protection\
    \ MAY be applied to\n   messages by either application, by calling either getMIC\
    \ or wrap\n   methods of the GSSContext interface, and verified by the peer\n\
    \   application by calling verifyMIC or unwrap for the peer's GSSContext\n   object.\n\
    \   The getMIC method calculates a cryptographic checksum (authentication\n  \
    \ tag) of an application message, and returns that checksum in a token.\n   The\
    \ application SHOULD pass both the token and the message to the\n   peer application,\
    \ which presents them to the verifyMIC method of the\n   peer's GSSContext object.\n\
    \   The wrap method calculates a cryptographic checksum of an application\n  \
    \ message, and places both the checksum and the message inside a single\n   token.\
    \  The application SHOULD pass the token to the peer\n   application, which presents\
    \ it to the unwrap method of the peer's\n   GSSContext object to extract the message\
    \ and verify the checksum.\n   Either pair of routines may be capable of detecting\
    \ out-of-sequence\n   message delivery or the duplication of messages.  Details\
    \ of such\n   mis-ordered messages are indicated through supplementary query\n\
    \   methods of the MessageProp object that is filled in by each of these\n   routines.\n\
    \   A mechanism need not maintain a list of all tokens that have been\n   processed\
    \ in order to support these status codes.  A typical\n   mechanism might retain\
    \ information about only the most recent \"N\"\n   tokens processed, allowing\
    \ it to distinguish duplicates and missing\n   tokens within the most recent \"\
    N\" messages; the receipt of a token\n   older than the most recent \"N\" would\
    \ result in the isOldToken method\n   of the instance of MessageProp to return\
    \ \"true\".\n"
- title: 4.4.  Anonymous Authentication
  contents:
  - "4.4.  Anonymous Authentication\n   In certain situations, an application may\
    \ wish to initiate the\n   authentication process to authenticate a peer, without\
    \ revealing its\n   own identity.  As an example, consider an application providing\n\
    \   access to a database containing medical information and offering\n   unrestricted\
    \ access to the service.  A client of such a service might\n   wish to authenticate\
    \ the service (in order to establish trust in any\n   information retrieved from\
    \ it), but might not wish the service to be\n   able to obtain the client's identity\
    \ (perhaps due to privacy concerns\n   about the specific inquiries, or perhaps\
    \ simply to avoid being placed\n   on mailing-lists).\n   In normal use of the\
    \ GSS-API, the initiator's identity is made\n   available to the acceptor as a\
    \ result of the context establishment\n   process.  However, context initiators\
    \ may request that their identity\n   not be revealed to the context acceptor.\
    \  Many mechanisms do not\n   support anonymous authentication, and for such mechanisms,\
    \ the\n   request will not be honored.  An authentication token will still be\n\
    \   generated, but the application is always informed if a requested\n   service\
    \ is unavailable, and has the option to abort context\n   establishment if anonymity\
    \ is valued above the other security\n   services that would require a context\
    \ to be established.\n   In addition to informing the application that a context\
    \ is\n   established anonymously (via the isAnonymous method of the GSSContext\n\
    \   class), the getSrcName method of the acceptor's GSSContext object\n   will,\
    \ for such contexts, return a reserved internal-form name,\n   defined by the\
    \ implementation.\n   The toString method for a GSSName object representing an\
    \ anonymous\n   entity will return a printable name.  The returned value will\
    \ be\n   syntactically distinguishable from any valid principal name supported\n\
    \   by the implementation.  The associated name-type Object Identifier\n   (OID)\
    \ will be an OID representing the value of NT_ANONYMOUS.  This\n   name-type OID\
    \ will be defined as a public, static Oid object of the\n   GSSName class.  The\
    \ printable form of an anonymous name SHOULD be\n   chosen such that it implies\
    \ anonymity, since this name may appear in,\n   for example, audit logs.  For\
    \ example, the string \"<anonymous>\" might\n   be a good choice, if no valid\
    \ printable names supported by the\n   implementation can begin with \"<\" and\
    \ end with \">\".\n   When using the equal method of the GSSName interface, and\
    \ one of the\n   operands is a GSSName instance representing an anonymous entity,\
    \ the\n   method MUST return \"false\".\n"
- title: 4.5.  Integrity and Confidentiality
  contents:
  - "4.5.  Integrity and Confidentiality\n   If a GSSContext supports the integrity\
    \ service, the getMic method may\n   be used to create message integrity check\
    \ tokens on application\n   messages.\n   If a GSSContext supports the confidentiality\
    \ service, the wrap method\n   may be used to encrypt application messages.  Messages\
    \ are\n   selectively encrypted, under the control of the setPrivacy method of\n\
    \   the MessageProp object used in the wrap method.  Confidentiality will\n  \
    \ be applied if the privacy state is set to true.\n"
- title: 4.6.  Inter-process Context Transfer
  contents:
  - "4.6.  Inter-process Context Transfer\n   GSS-APIv2 provides functionality that\
    \ allows a security context to be\n   transferred between processes on a single\
    \ machine.  These are\n   implemented using the export method of GSSContext and\
    \ a byte array\n   constructor of the same class.  The most common use for such\
    \ a\n   feature is a client-server design where the server is implemented as\n\
    \   a single process that accepts incoming security contexts, which then\n   launches\
    \ child processes to deal with the data on these contexts.  In\n   such a design,\
    \ the child processes must have access to the security\n   context object created\
    \ within the parent so that they can use per-\n   message protection services\
    \ and delete the security context when the\n   communication session ends.\n \
    \  Since the security context data structure is expected to contain\n   sequencing\
    \ information, it is impractical in general to share a\n   context between processes.\
    \  Thus, the GSSContext interface provides\n   an export method that the process,\
    \ which currently owns the context,\n   can call to declare that it has no intention\
    \ to use the context\n   subsequently and to create an inter-process token containing\n\
    \   information needed by the adopting process to successfully recreate\n   the\
    \ context.  After successful completion of export, the original\n   security context\
    \ is made inaccessible to the calling process by\n   GSS-API, and any further\
    \ usage of this object will result in\n   failures.  The originating process transfers\
    \ the inter-process token\n   to the adopting process, which creates a new GSSContext\
    \ object using\n   the byte array constructor.  The properties of the context\
    \ are\n   equivalent to that of the original context.\n   The inter-process token\
    \ MAY contain sensitive data from the original\n   security context (including\
    \ cryptographic keys).  Applications using\n   inter-process tokens to transfer\
    \ security contexts MUST take\n   appropriate steps to protect these tokens in\
    \ transit.\n   Implementations are not required to support the inter-process\n\
    \   transfer of security contexts.  Calling the isTransferable method of\n   the\
    \ GSSContext interface will indicate if the context object is\n   transferable.\n"
- title: 4.7.  The Use of Incomplete Contexts
  contents:
  - "4.7.  The Use of Incomplete Contexts\n   Some mechanisms may allow the per-message\
    \ services to be used before\n   the context establishment process is complete.\
    \  For example, a\n   mechanism may include sufficient information in its initial\
    \ context-\n   level tokens for the context acceptor to immediately decode messages\n\
    \   protected with wrap or getMIC.  For such a mechanism, the initiating\n   application\
    \ need not wait until subsequent context-level tokens have\n   been sent and received\
    \ before invoking the per-message protection\n   services.\n   An application\
    \ can invoke the isProtReady method of the GSSContext\n   class to determine if\
    \ the per-message services are available in\n   advance of complete context establishment.\
    \  Applications wishing to\n   use per-message protection services on partially\
    \ established contexts\n   SHOULD query this method before attempting to invoke\
    \ wrap or getMIC.\n"
- title: 5.  Calling Conventions
  contents:
  - "5.  Calling Conventions\n   Java provides the implementors with not just a syntax\
    \ for the\n   language but also an operational environment.  For example, memory\
    \ is\n   automatically managed and does not require application intervention.\n\
    \   These language features have allowed for a simpler API and have led\n   to\
    \ the elimination of certain GSS-API functions.\n   Moreover, the JCA defines\
    \ a provider model that allows for\n   implementation-independent access to security\
    \ services.  Using this\n   model, applications can seamlessly switch between\
    \ different\n   implementations and dynamically add new services.  The GSS-API\n\
    \   specification leverages these concepts by the usage of providers for\n   the\
    \ mechanism implementations.\n"
- title: 5.1.  Package Name
  contents:
  - "5.1.  Package Name\n   The classes and interfaces defined in this document reside\
    \ in the\n   package called \"org.ietf.jgss\".  Applications that wish to make\
    \ use\n   of this API should import this package name as shown in Section 8.\n"
- title: 5.2.  Provider Framework
  contents:
  - "5.2.  Provider Framework\n   Java security APIs use a provider architecture that\
    \ allows\n   applications to be implementation independent and security API\n\
    \   implementations to be modular and extensible.  The\n   java.security.Provider\
    \ class is an abstract class that a vendor\n   extends.  This class maps various\
    \ properties that represent different\n   security services that are available\
    \ to the names of the actual\n   vendor classes that implement those services.\
    \  When requesting a\n   service, an application simply specifies the desired\
    \ provider, and\n   the API delegates the request to service classes available\
    \ from that\n   provider.\n   Using the Java security provider model insulates\
    \ applications from\n   implementation details of the services they wish to use.\n\
    \   Applications can switch between providers easily, and new providers\n   can\
    \ be added as needed, even at runtime.\n   The GSS-API may use providers to find\
    \ components for specific\n   underlying security mechanisms.  For instance, a\
    \ particular provider\n   might contain components that will allow the GSS-API\
    \ to support the\n   Kerberos v5 mechanism [RFC4121], and another might contain\
    \ components\n   to support the Simple Public-Key GSS-API Mechanism (SPKM) [RFC2025].\n\
    \   By delegating mechanism-specific functionality to the components\n   obtained\
    \ from providers, the GSS-API can be extended to support an\n   arbitrary list\
    \ of mechanisms.\n   How the GSS-API locates and queries these providers is beyond\
    \ the\n   scope of this document and is being deferred to a Service Provider\n\
    \   Interface (SPI) specification.  The availability of such an SPI\n   specification\
    \ is not mandatory for the adoption of this API\n   specification nor is it mandatory\
    \ to use providers in the\n   implementation of a GSS-API framework.  However,\
    \ by using the\n   provider framework together with an SPI specification, one\
    \ can create\n   an extensible and implementation-independent GSS-API framework.\n"
- title: 5.3.  Integer Types
  contents:
  - "5.3.  Integer Types\n   All numeric values are declared as the \"int\" primitive\
    \ Java type.\n   The Java specification guarantees that this will be a 32-bit\
    \ two's\n   complement signed number.\n   Throughout this API, the \"boolean\"\
    \ primitive Java type is used\n   wherever a boolean value is required or returned.\n"
- title: 5.4.  Opaque Data Types
  contents:
  - "5.4.  Opaque Data Types\n   Java byte arrays are used to represent opaque data\
    \ types that are\n   consumed and produced by the GSS-API in the form of tokens.\
    \  Java\n   arrays contain a length field that enables the users to easily\n \
    \  determine their size.  The language has automatic garbage collection\n   that\
    \ alleviates the need by developers to release memory and\n   simplifies buffer\
    \ ownership issues.\n"
- title: 5.5.  Strings
  contents:
  - "5.5.  Strings\n   The String object will be used to represent all textual data.\
    \  The\n   Java String object transparently treats all characters as two-byte\n\
    \   Unicode characters, which allows support for many locals.  All\n   routines\
    \ returning or accepting textual data will use the String\n   object.\n"
- title: 5.6.  Object Identifiers
  contents:
  - "5.6.  Object Identifiers\n   An Oid object will be used to represent Universal\
    \ Object Identifiers\n   (OIDs).  OIDs are ISO-defined, hierarchically globally\
    \ interpretable\n   identifiers used within the GSS-API framework to identify\
    \ security\n   mechanisms and name formats.  The Oid object can be created from\
    \ a\n   string representation of its dot notation (e.g., \"1.3.6.1.5.6.2\") as\n\
    \   well as from its ASN.1 DER encoding.  Methods are also provided to\n   test\
    \ equality and provide the DER representation for the object.\n   An important\
    \ feature of the Oid class is that its instances are\n   immutable -- i.e., there\
    \ are no methods defined that allow one to\n   change the contents of an Oid object.\
    \  This property allows one to\n   treat these objects as \"statics\" without\
    \ the need to perform copies.\n   Certain routines allow the usage of a default\
    \ OID.  A \"null\" value\n   can be used in those cases.\n"
- title: 5.7.  Object Identifier Sets
  contents:
  - "5.7.  Object Identifier Sets\n   The Java bindings represent Object Identifier\
    \ sets as arrays of Oid\n   objects.  All Java arrays contain a length field,\
    \ which allows for\n   easy manipulation and reference.\n   In order to support\
    \ the full functionality of RFC 2743 [RFC2743], the\n   Oid class includes a method\
    \ that checks for existence of an Oid\n   object within a specified array.  This\
    \ is equivalent in functionality\n   to gss_test_oid_set_member.  The use of Java\
    \ arrays and Java's\n   automatic garbage collection has eliminated the need for\
    \ the\n   following routines: gss_create_empty_oid_set, gss_release_oid_set,\n\
    \   and gss_add_oid_set_member.  Java GSS-API implementations will not\n   contain\
    \ them.  Java's automatic garbage collection and the immutable\n   property of\
    \ the Oid object eliminates the memory management issues of\n   the C counterpart.\n\
    \   Whenever a default value for an Object Identifier set is required, a\n   \"\
    null\" value can be used.  Please consult the detailed method\n   description\
    \ for details.\n"
- title: 5.8.  Credentials
  contents:
  - "5.8.  Credentials\n   GSS-API credentials are represented by the GSSCredential\
    \ interface.\n   The interface contains several constructs to allow for the creation\n\
    \   of most common credential objects for the initiator and the acceptor.\n  \
    \ Comparisons are performed using the interface's \"equals\" method.  The\n  \
    \ following general description of GSS-API credentials is included from\n   the\
    \ C-bindings specification [RFC2744]:\n      GSS-API credentials can contain mechanism-specific\
    \ principal\n      authentication data for multiple mechanisms.  A GSS-API credential\n\
    \      is composed of a set of credential-elements, each of which is\n      applicable\
    \ to a single mechanism.  A credential may contain at\n      most one credential-element\
    \ for each supported mechanism.  A\n      credential-element identifies the data\
    \ needed by a single\n      mechanism to authenticate a single principal, and\
    \ conceptually\n      contains two credential-references that describe the actual\n\
    \      mechanism-specific authentication data, one to be used by GSS-API\n   \
    \   for initiating contexts, and one to be used for accepting\n      contexts.\
    \  For mechanisms that do not distinguish between acceptor\n      and initiator\
    \ credentials, both references would point to the same\n      underlying mechanism-specific\
    \ authentication data.\n   Credentials describe a set of mechanism-specific principals\
    \ and give\n   their holder the ability to act as any of those principals.  All\n\
    \   principal identities asserted by a single GSS-API credential SHOULD\n   belong\
    \ to the same entity, although enforcement of this property is\n   an implementation-specific\
    \ matter.  A single GSSCredential object\n   represents all the credential elements\
    \ that have been acquired.\n   The creation of a GSSContext object allows the\
    \ value of \"null\" to be\n   specified as the GSSCredential input parameter.\
    \  This will indicate a\n   desire by the application to act as a default principal.\
    \  While\n   individual GSS-API implementations are free to determine such default\n\
    \   behavior as appropriate to the mechanism, the following default\n   behavior\
    \ by these routines is RECOMMENDED for portability:\n   For the initiator side\
    \ of the context:\n   1) If there is only a single principal capable of initiating\
    \ security\n      contexts for the chosen mechanism that the application is\n\
    \      authorized to act on behalf of, then that principal shall be used;\n  \
    \    otherwise,\n   2) If the platform maintains a concept of a default network\
    \ identity\n      for the chosen mechanism, and if the application is authorized\
    \ to\n      act on behalf of that identity for the purpose of initiating\n   \
    \   security contexts, then the principal corresponding to that\n      identity\
    \ shall be used; otherwise,\n   3) If the platform maintains a concept of a default\
    \ local identity,\n      and provides a means to map local identities into network\n\
    \      identities for the chosen mechanism, and if the application is\n      authorized\
    \ to act on behalf of the network-identity image of the\n      default local identity\
    \ for the purpose of initiating security\n      contexts using the chosen mechanism,\
    \ then the principal\n      corresponding to that identity shall be used; otherwise,\n\
    \   4) A user-configurable default identity should be used.\n   For the acceptor\
    \ side of the context:\n   1) If there is only a single authorized principal identity\
    \ capable of\n      accepting security contexts for the chosen mechanism, then\
    \ that\n      principal shall be used; otherwise,\n   2) If the mechanism can\
    \ determine the identity of the target\n      principal by examining the context-establishment\
    \ token processed\n      during the accept method, and if the accepting application\
    \ is\n      authorized to act as that principal for the purpose of accepting\n\
    \      security contexts using the chosen mechanism, then that principal\n   \
    \   identity shall be used; otherwise,\n   3) If the mechanism supports context\
    \ acceptance by any principal, and\n      if mutual authentication was not requested,\
    \ any principal that the\n      application is authorized to accept security contexts\
    \ under using\n      the chosen mechanism may be used; otherwise,\n   4) A user-configurable\
    \ default identity shall be used.\n   The purpose of the above rules is to allow\
    \ security contexts to be\n   established by both initiator and acceptor using\
    \ the default behavior\n   whenever possible.  Applications requesting default\
    \ behavior are\n   likely to be more portable across mechanisms and implementations\
    \ than\n   ones that instantiate a GSSCredential object representing a specific\n\
    \   identity.\n"
- title: 5.9.  Contexts
  contents:
  - "5.9.  Contexts\n   The GSSContext interface is used to represent one end of a\
    \ GSS-API\n   security context, storing state information appropriate to that\
    \ end\n   of the peer communication, including cryptographic state information.\n\
    \   The instantiation of the context object is done differently by the\n   initiator\
    \ and the acceptor.  After the context has been instantiated,\n   the initiator\
    \ MAY choose to set various context options that will\n   determine the characteristics\
    \ of the desired security context.  When\n   all the application-desired characteristics\
    \ have been set, the\n   initiator will call the initSecContext method, which\
    \ will produce a\n   token for consumption by the peer's acceptSecContext method.\
    \  It is\n   the responsibility of the application to deliver the authentication\n\
    \   token(s) between the peer applications for processing.  Upon\n   completion\
    \ of the context-establishment phase, context attributes can\n   be retrieved,\
    \ by both the initiator and acceptor, using the accessor\n   methods.  These will\
    \ reflect the actual attributes of the established\n   context and might not match\
    \ the initiator-requested values.  If any\n   retrieved attribute does not match\
    \ the desired value but it is\n   necessary for the application protocol, the\
    \ application SHOULD\n   destroy the security context and not use it for application\
    \ traffic.\n   Otherwise, at this point, the context can be used by the application\n\
    \   to apply cryptographic services to its data.\n"
- title: 5.10.  Authentication Tokens
  contents:
  - "5.10.  Authentication Tokens\n   A token is a caller-opaque type that GSS-API\
    \ uses to maintain\n   synchronization between each end of the GSS-API security\
    \ context.\n   The token is a cryptographically protected octet string, generated\
    \ by\n   the underlying mechanism at one end of a GSS-API security context for\n\
    \   use by the peer mechanism at the other end.  Encapsulation (if\n   required)\
    \ within the application protocol and transfer of the token\n   are the responsibility\
    \ of the peer applications.\n   Java GSS-API uses byte arrays to represent authentication\
    \ tokens.\n"
- title: 5.11.  Inter-process Tokens
  contents:
  - "5.11.  Inter-process Tokens\n   Certain GSS-API routines are intended to transfer\
    \ data between\n   processes in multi-process programs.  These routines use a\
    \ caller-\n   opaque octet string, generated by the GSS-API in one process for\
    \ use\n   by the GSS-API in another process.  The calling application is\n   responsible\
    \ for transferring such tokens between processes.  Note\n   that, while GSS-API\
    \ implementors are encouraged to avoid placing\n   sensitive information within\
    \ inter-process tokens, or to\n   cryptographically protect them, many implementations\
    \ will be unable\n   to avoid placing key material or other sensitive data within\
    \ them.\n   It is the application's responsibility to ensure that inter-process\n\
    \   tokens are protected in transit and transferred only to processes\n   that\
    \ are trustworthy.  An inter-process token is represented using a\n   byte array\
    \ emitted from the export method of the GSSContext\n   interface.  The receiver\
    \ of the inter-process token would initialize\n   a GSSContext object with this\
    \ token to create a new context.  Once a\n   context has been exported, the GSSContext\
    \ object is invalidated and\n   is no longer available.\n"
- title: 5.12.  Error Reporting
  contents:
  - "5.12.  Error Reporting\n   RFC 2743 [RFC2743] defined the usage of major and\
    \ minor status values\n   for the signaling of GSS-API errors.  The major code,\
    \ also called the\n   GSS status code, is used to signal errors at the GSS-API\
    \ level,\n   independent of the underlying mechanism(s).  The minor status value\n\
    \   or Mechanism status code, is a mechanism-defined error value\n   indicating\
    \ a mechanism-specific error code.\n   Java GSS-API uses exceptions implemented\
    \ by the GSSException class to\n   signal both minor and major error values. \
    \ Both mechanism-specific\n   errors and GSS-API level errors are signaled through\
    \ instances of\n   this class.  The usage of exceptions replaces the need for\
    \ major and\n   minor codes to be used within the API calls.  The GSSException\
    \ class\n   also contains methods to obtain textual representations for both the\n\
    \   major and minor values, which is equivalent to the functionality of\n   gss_display_status.\
    \  A GSSException object MAY also include an output\n   token that SHOULD be sent\
    \ to the peer.\n   If an exception is thrown during context establishment, the\
    \ context\n   negotiation has failed and the GSSContext object MUST be abandoned.\n\
    \   If it is thrown in a per-message call, the context MAY remain useful.\n"
- title: 5.12.1.  GSS Status Codes
  contents:
  - "5.12.1.  GSS Status Codes\n   GSS status codes indicate errors that are independent\
    \ of the\n   underlying mechanism(s) used to provide the security service.  The\n\
    \   errors that can be indicated via a GSS status code are generic API\n   routine\
    \ errors (errors that are defined in the GSS-API\n   specification).  These bindings\
    \ take advantage of the Java exceptions\n   mechanism, thus eliminating the need\
    \ for calling errors.\n   A GSS status code indicates a single fatal generic API\
    \ error from the\n   routine that has thrown the GSSException.  Using exceptions\
    \ announces\n   that a fatal error has occurred during the execution of the method.\n\
    \   The GSS-API operational model also allows for the signaling of\n   supplementary\
    \ status information from the per-message calls.  These\n   need to be handled\
    \ as return values since using exceptions is not\n   appropriate for informatory\
    \ or warning-like information.  The methods\n   that are capable of producing\
    \ supplementary information are the two\n   per-message methods GSSContext.verifyMIC()\
    \ and GSSContext.unwrap().\n   These methods fill the supplementary status codes\
    \ in the MessageProp\n   object that was passed in.\n   A GSSException object,\
    \ along with providing the functionality for\n   setting the various error codes\
    \ and translating them into textual\n   representation, also contains the definitions\
    \ of all the numeric\n   error values.  The following table lists the definitions\
    \ of error\n   codes:\n   Table: GSS Status Codes\n   +----------------------+-------+------------------------------------+\n\
    \   | Name                 | Value | Meaning                            |\n  \
    \ +----------------------+-------+------------------------------------+\n   |\
    \ BAD_BINDINGS         | 1     | Incorrect channel bindings were    |\n   |  \
    \                    |       | supplied.                          |\n   | BAD_MECH\
    \             | 2     | An unsupported mechanism was       |\n   |           \
    \           |       | requested.                         |\n   | BAD_NAME    \
    \         | 3     | An invalid name was supplied.      |\n   | BAD_NAMETYPE  \
    \       | 4     | A supplied name was of an          |\n   |                 \
    \     |       | unsupported type.                  |\n   | BAD_STATUS        \
    \   | 5     | An invalid status code was         |\n   |                     \
    \ |       | supplied.                          |\n   | BAD_MIC              |\
    \ 6     | A token had an invalid MIC.        |\n   | CONTEXT_EXPIRED      | 7\
    \     | The context has expired.           |\n   | CREDENTIALS_EXPIRED  | 8  \
    \   | The referenced credentials have    |\n   |                      |      \
    \ | expired.                           |\n   | DEFECTIVE_CREDENTIAL | 9     |\
    \ A supplied credential was invalid. |\n   | DEFECTIVE_TOKEN      | 10    | A\
    \ supplied token was invalid.      |\n   | FAILURE              | 11    | Miscellaneous\
    \ failure, unspecified |\n   |                      |       | at the GSS-API level.\
    \              |\n   | NO_CONTEXT           | 12    | Invalid context has been\
    \ supplied. |\n   | NO_CRED              | 13    | No credentials were supplied,\
    \ or   |\n   |                      |       | the credentials were unavailable\
    \   |\n   |                      |       | or inaccessible.                  \
    \ |\n   | BAD_QOP              | 14    | The quality of protection (QOP)    |\n\
    \   |                      |       | requested could not be provided.   |\n  \
    \ | UNAUTHORIZED         | 15    | The operation is forbidden by the  |\n   |\
    \                      |       | local security policy.             |\n   | UNAVAILABLE\
    \          | 16    | The operation or option is         |\n   |              \
    \        |       | unavailable.                       |\n   | DUPLICATE_ELEMENT\
    \    | 17    | The requested credential element   |\n   |                    \
    \  |       | already exists.                    |\n   | NAME_NOT_MN          |\
    \ 18    | The provided name was not a        |\n   |                      |  \
    \     | mechanism name.                    |\n   +----------------------+-------+------------------------------------+\n\
    \   The following four status codes (DUPLICATE_TOKEN, OLD_TOKEN,\n   UNSEQ_TOKEN,\
    \ and GAP_TOKEN) are contained in a GSSException only if\n   detected during context\
    \ establishment, in which case it is a fatal\n   error.  (During per-message calls,\
    \ these values are indicated as\n   supplementary information contained in the\
    \ MessageProp object.)  They\n   are:\n   +-----------------+-------+-----------------------------------------+\n\
    \   | Name            | Value | Meaning                                 |\n  \
    \ +-----------------+-------+-----------------------------------------+\n   |\
    \ DUPLICATE_TOKEN | 19    | The token was a duplicate of an earlier |\n   |  \
    \               |       | version.                                |\n   | OLD_TOKEN\
    \       | 20    | The token's validity period has         |\n   |            \
    \     |       | expired.                                |\n   | UNSEQ_TOKEN  \
    \   | 21    | A later token has already been          |\n   |                \
    \ |       | processed.                              |\n   | GAP_TOKEN       |\
    \ 22    | The expected token was not received.    |\n   +-----------------+-------+-----------------------------------------+\n\
    \   The GSS major status code of FAILURE is used to indicate that the\n   underlying\
    \ mechanism detected an error for which no specific GSS\n   status code is defined.\
    \  The mechanism-specific status code can\n   provide more details about the error.\n\
    \   The different major status codes that can be contained in the\n   GSSException\
    \ object thrown by the methods in this specification are\n   the same as the major\
    \ status codes returned by the corresponding\n   calls in RFC 2743 [RFC2743].\n"
- title: 5.12.2.  Mechanism-Specific Status Codes
  contents:
  - "5.12.2.  Mechanism-Specific Status Codes\n   Mechanism-specific status codes\
    \ are communicated in two ways: they\n   are part of any GSSException thrown from\
    \ the mechanism-specific layer\n   to signal a fatal error, or they are part of\
    \ the MessageProp object\n   that the per-message calls use to signal non-fatal\
    \ errors.\n   A default value of 0 in either the GSSException object or the\n\
    \   MessageProp object will be used to represent the absence of any\n   mechanism-specific\
    \ status code.\n"
- title: 5.12.3.  Supplementary Status Codes
  contents:
  - "5.12.3.  Supplementary Status Codes\n   Supplementary status codes are confined\
    \ to the per-message methods of\n   the GSSContext interface.  Because of the\
    \ informative nature of these\n   errors, it is not appropriate to use exceptions\
    \ to signal them.\n   Instead, the per-message operations of the GSSContext interface\n\
    \   return these values in a MessageProp object.\n   The MessageProp class defines\
    \ query methods that return boolean\n   values indicating the following supplementary\
    \ states:\n   Table: Supplementary Status Methods\n   +------------------+------------------------------------------------+\n\
    \   | Method Name      | Meaning when \"true\" is returned                |\n\
    \   +------------------+------------------------------------------------+\n  \
    \ | isDuplicateToken | The token was a duplicate of an earlier token. |\n   |\
    \ isOldToken       | The token's validity period has expired.       |\n   | isUnseqToken\
    \     | A later token has already been processed.      |\n   | isGapToken    \
    \   | An expected per-message token was not          |\n   |                 \
    \ | received.                                      |\n   +------------------+------------------------------------------------+\n\
    \   A \"true\" return value for any of the above methods indicates that the\n\
    \   token exhibited the specified property.  The application MUST\n   determine\
    \ the appropriate course of action for these supplementary\n   values.  They are\
    \ not treated as errors by the GSS-API.\n"
- title: 5.13.  Names
  contents:
  - "5.13.  Names\n   A name is used to identify a person or entity.  GSS-API authenticates\n\
    \   the relationship between a name and the entity claiming the name.\n   Since\
    \ different authentication mechanisms may employ different\n   namespaces for\
    \ identifying their principals, GSS-API's naming support\n   is necessarily complex\
    \ in multi-mechanism environments (or even in\n   some single-mechanism environments\
    \ where the underlying mechanism\n   supports multiple namespaces).\n   Two distinct\
    \ conceptual representations are defined for names:\n   1) A GSS-API form represented\
    \ by implementations of the GSSName\n      interface: A single GSSName object\
    \ MAY contain multiple names from\n      different namespaces, but all names SHOULD\
    \ refer to the same\n      entity.  An example of such an internal name would\
    \ be the name\n      returned from a call to the getName method of the GSSCredential\n\
    \      interface, when applied to a credential containing credential\n      elements\
    \ for multiple authentication mechanisms employing\n      different namespaces.\
    \  This GSSName object will contain a distinct\n      name for the entity for\
    \ each authentication mechanism.\n      For GSS-API implementations supporting\
    \ multiple namespaces,\n      GSSName implementations MUST contain sufficient\
    \ information to\n      determine the namespace to which each primitive name belongs.\n\
    \   2) Mechanism-specific contiguous byte array and string forms:\n      Different\
    \ GSSName initialization methods are provided to handle\n      both byte array\
    \ and string formats and to accommodate various\n      calling applications and\
    \ name types.  These formats are capable of\n      containing only a single name\
    \ (from a single namespace).\n      Contiguous string names are always accompanied\
    \ by an Object\n      Identifier specifying the namespace to which the name belongs,\
    \ and\n      their format is dependent on the authentication mechanism that\n\
    \      employs that name.  The string name forms are assumed to be\n      printable\
    \ and may therefore be used by GSS-API applications for\n      communication with\
    \ their users.  The byte array name formats are\n      assumed to be in non-printable\
    \ formats (e.g., the byte array\n      returned from the export method of the\
    \ GSSName interface).\n   A GSSName object can be converted to a contiguous representation\
    \ by\n   using the toString method.  This will guarantee that the name will be\n\
    \   converted to a printable format.  Different initialization methods in\n  \
    \ the GSSName interface are defined to allow support for multiple\n   syntaxes\
    \ for each supported namespace and to allow users the freedom\n   to choose a\
    \ preferred name representation.  The toString method\n   SHOULD use an implementation-chosen\
    \ printable syntax for each\n   supported name type.  To obtain the printable\
    \ name type, the\n   getStringNameType method can be used.\n   There is no guarantee\
    \ that calling the toString method on the GSSName\n   interface will produce the\
    \ same string form as the original imported\n   string name.  Furthermore, it\
    \ is possible that the name was not even\n   constructed from a string representation.\
    \  The same applies to\n   namespace identifiers, which may not necessarily survive\
    \ unchanged\n   after a journey through the internal name form.  An example of\
    \ this\n   might be a mechanism that authenticates X.500 names but provides an\n\
    \   algorithmic mapping of Internet DNS names into X.500.  That\n   mechanism's\
    \ implementation of GSSName might, when presented with a\n   DNS name, generate\
    \ an internal name that contained both the original\n   DNS name and the equivalent\
    \ X.500 name.  Alternatively, it might only\n   store the X.500 name.  In the\
    \ latter case, the toString method of\n   GSSName would most likely generate a\
    \ printable X.500 name, rather\n   than the original DNS name.\n   The context\
    \ acceptor can obtain a GSSName object representing the\n   entity performing\
    \ the context initiation (through the usage of the\n   getSrcName method).  Since\
    \ this name has been authenticated by a\n   single mechanism, it contains only\
    \ a single name (even if the\n   internal name presented by the context initiator\
    \ to the GSSContext\n   object had multiple components).  Such names are termed\
    \ internal-\n   mechanism names (or MNs), and the names emitted by the GSSContext\n\
    \   interface's getSrcName and getTargName methods are always of this\n   type.\
    \  Since some applications may require MNs without wanting to\n   incur the overhead\
    \ of an authentication operation, creation methods\n   are provided that take\
    \ not only the name buffer and name type but\n   also the mechanism OID for which\
    \ this name should be created.  When\n   dealing with an existing GSSName object,\
    \ the canonicalize method may\n   be invoked to convert a general internal name\
    \ into an MN.\n   GSSName objects can be compared using their equal method, which\n\
    \   returns \"true\" if the two names being compared refer to the same\n   entity.\
    \  This is the preferred way to perform name comparisons\n   instead of using\
    \ the printable names that a given GSS-API\n   implementation may support.  Since\
    \ GSS-API assumes that all primitive\n   names contained within a given internal\
    \ name refer to the same\n   entity, equal can return \"true\" if the two names\
    \ have at least one\n   primitive name in common.  If the implementation embodies\
    \ knowledge\n   of equivalence relationships between names taken from different\n\
    \   namespaces, this knowledge may also allow successful comparisons of\n   internal\
    \ names containing no overlapping primitive elements.\n   However, applications\
    \ SHOULD note that to avoid surprising behavior,\n   it is best to ensure that\
    \ the names being compared are either both\n   mechanism names for the same mechanism\
    \ or both internal names that\n   are not mechanism names.  This holds whether\
    \ the equals method is\n   used directly or the export method is used to generate\
    \ byte strings\n   that are then compared byte-by-byte.\n   When used in large\
    \ access control lists, the overhead of creating a\n   GSSName object on each\
    \ name and invoking the equal method on each\n   name from the Access Control\
    \ List (ACL) may be prohibitive.  As an\n   alternative way of supporting this\
    \ case, GSS-API defines a special\n   form of the contiguous byte array name,\
    \ which MAY be compared\n   directly (byte by byte).  Contiguous names suitable\
    \ for comparison\n   are generated by the export method.  Exported names MAY be\n\
    \   re-imported by using the byte array constructor and specifying the\n   NT_EXPORT_NAME\
    \ as the name type Object Identifier.  The resulting\n   GSSName name will also\
    \ be an MN.\n   The GSSName interface defines public static Oid objects representing\n\
    \   the standard name types.  Structurally, an exported name object\n   consists\
    \ of a header containing an OID identifying the mechanism that\n   authenticated\
    \ the name, and a trailer containing the name itself,\n   where the syntax of\
    \ the trailer is defined by the individual\n   mechanism specification.  Detailed\
    \ description of the format is\n   specified in the language-independent GSS-API\
    \ specification\n   [RFC2743].\n   Note that the results obtained by using the\
    \ equals method will in\n   general be different from those obtained by invoking\
    \ canonicalize and\n   export and then comparing the byte array output.  The first\
    \ series of\n   operation determines whether two (unauthenticated) names identify\
    \ the\n   same principal; the second determines whether a particular mechanism\n\
    \   would authenticate them as the same principal.  These two operations\n   will\
    \ in general give the same results only for MNs.\n   It is important to note that\
    \ the above are guidelines as to how\n   GSSName implementations SHOULD behave\
    \ and are not intended to be\n   specific requirements of how name objects must\
    \ be implemented.  The\n   mechanism designers are free to decide on the details\
    \ of their\n   implementations of the GSSName interface as long as the behavior\n\
    \   satisfies the above guidelines.\n"
- title: 5.14.  Channel Bindings
  contents:
  - "5.14.  Channel Bindings\n   GSS-API supports the use of user-specified tags to\
    \ identify a given\n   context to the peer application.  These tags are intended\
    \ to be used\n   to identify the particular communications channel that carries\
    \ the\n   context.  Channel bindings are communicated to the GSS-API using the\n\
    \   ChannelBinding object.  The application MAY use byte arrays as well\n   as\
    \ instances of InetAddress to specify the application data to be\n   used in the\
    \ channel binding.  The InetAddress for the initiator and/\n   or acceptor can\
    \ be used within an instance of a ChannelBinding.\n   ChannelBinding can be set\
    \ for the GSSContext object using the\n   setChannelBinding method before the\
    \ first call to init or accept has\n   been performed.  Unless the setChannelBinding\
    \ method has been used to\n   set the ChannelBinding for a GSSContext object,\
    \ \"null\" ChannelBinding\n   will be assumed.  InetAddress is currently the only\
    \ address type\n   defined within the Java platform and as such, it is the only\
    \ one\n   supported within the ChannelBinding class.  Applications that use\n\
    \   other types of addresses can include them as part of the application-\n  \
    \ specific data.\n   Conceptually, the GSS-API concatenates the initiator and\
    \ acceptor\n   address information and the application-supplied byte array to\
    \ form\n   an octet string.  The mechanism calculates a Message Integrity Code\n\
    \   (MIC) over this octet string and binds the MIC to the context\n   establishment\
    \ token emitted by the init method of the GSSContext\n   interface.  The same\
    \ bindings are set by the context acceptor for its\n   GSSContext object, and\
    \ during processing of the accept method, a MIC\n   is calculated in the same\
    \ way.  The calculated MIC is compared with\n   that found in the token, and if\
    \ the MICs differ, accept will throw a\n   GSSException with the major code set\
    \ to BAD_BINDINGS, and the context\n   will not be established.  Some mechanisms\
    \ may include the actual\n   channel-binding data in the token (rather than just\
    \ a MIC);\n   applications SHOULD therefore not use confidential data as channel-\n\
    \   binding components.\n   Individual mechanisms may impose additional constraints\
    \ on addresses\n   that may appear in channel bindings.  For example, a mechanism\
    \ may\n   verify that the initiator address field of the channel binding\n   contains\
    \ the correct network address of the host system.  Portable\n   applications SHOULD\
    \ therefore ensure that they either provide correct\n   information for the address\
    \ fields or omit the setting of the\n   addressing information.\n"
- title: 5.15.  Optional Parameters
  contents:
  - "5.15.  Optional Parameters\n   Whenever the application wishes to omit an optional\
    \ parameter, the\n   \"null\" value SHALL be used.  The detailed method descriptions\n\
    \   indicate which parameters are optional.  Method overloading has also\n   been\
    \ used as a technique to indicate default parameters.\n"
- title: 6.  Introduction to GSS-API Classes and Interfaces
  contents:
  - "6.  Introduction to GSS-API Classes and Interfaces\n   This section presents\
    \ a brief description of the classes and\n   interfaces that constitute the GSS-API.\
    \  The implementations of these\n   are obtained from the CLASSPATH defined by\
    \ the application.  If Java\n   GSS becomes part of the standard Java APIs, then\
    \ these classes will\n   be available by default on all systems as part of the\
    \ JRE's system\n   classes.\n   This section also shows the corresponding RFC\
    \ 2743 [RFC2743]\n   functionality implemented by each of the classes.  Detailed\n\
    \   description of these classes and their methods is presented in\n   Section\
    \ 7.\n"
- title: 6.1.  GSSManager Class
  contents:
  - "6.1.  GSSManager Class\n   This abstract class serves as a factory to instantiate\n\
    \   implementations of the GSS-API interfaces and also provides methods\n   to\
    \ make queries about underlying security mechanisms.\n   A default implementation\
    \ can be obtained using the static method\n   getInstance().  Applications that\
    \ desire to provide their own\n   implementation of the GSSManager class can simply\
    \ extend the abstract\n   class themselves.\n   This class contains equivalents\
    \ of the following RFC 2743 [RFC2743]\n   routines:\n   +----------------------------+-------------------------+------------+\n\
    \   | RFC 2743 Routine           | Function                | Section(s) |\n  \
    \ +----------------------------+-------------------------+------------+\n   |\
    \ gss_import_name            | Create an internal name | 7.1.5 -    |\n   |  \
    \                          | from the supplied       | 7.1.8      |\n   |    \
    \                        | information.            |            |\n   | gss_acquire_cred\
    \           | Acquire credential for  | 7.1.9 -    |\n   |                   \
    \         | use.                    | 7.1.11     |\n   | gss_import_sec_context\
    \     | Create a previously     | 7.1.14     |\n   |                         \
    \   | exported context.       |            |\n   | gss_indicate_mechs        \
    \ | List the mechanisms     | 7.1.2      |\n   |                            |\
    \ supported by this GSS-  |            |\n   |                            | API\
    \ implementation.     |            |\n   | gss_inquire_mechs_for_name | List the\
    \ mechanisms     | 7.1.4      |\n   |                            | supporting\
    \ the          |            |\n   |                            | specified name\
    \ type.    |            |\n   | gss_inquire_names_for_mech | List the name types\
    \     | 7.1.3      |\n   |                            | supported by the     \
    \   |            |\n   |                            | specified mechanism.   \
    \ |            |\n   +----------------------------+-------------------------+------------+\n"
- title: 6.2.  GSSName Interface
  contents:
  - "6.2.  GSSName Interface\n   GSS-API names are represented in the Java bindings\
    \ through the\n   GSSName interface.  Different name formats and their definitions\
    \ are\n   identified with Universal OIDs.  The format of the names can be\n  \
    \ derived based on the unique OID of each name type.  The following\n   GSS-API\
    \ routines are provided by the GSSName interface:\n   +-----------------------+------------------------------+------------+\n\
    \   | RFC 2743 Routine      | Function                     | Section(s) |\n  \
    \ +-----------------------+------------------------------+------------+\n   |\
    \ gss_display_name      | Convert internal name        | 7.2.6      |\n   |  \
    \                     | representation to text       |            |\n   |    \
    \                   | format.                      |            |\n   | gss_compare_name\
    \      | Compare two internal names.  | 7.2.2,     |\n   |                   \
    \    |                              | 7.2.3      |\n   | gss_release_name    \
    \  | Release resources associated | N/A        |\n   |                       |\
    \ with the internal name.      |            |\n   | gss_canonicalize_name | Convert\
    \ an internal name to  | 7.2.4      |\n   |                       | a mechanism\
    \ name.            |            |\n   | gss_export_name       | Convert a mechanism\
    \ name to  | 7.2.5      |\n   |                       | export format.       \
    \        |            |\n   | gss_duplicate_name    | Create a copy of the   \
    \      | N/A        |\n   |                       | internal name.           \
    \    |            |\n   +-----------------------+------------------------------+------------+\n\
    \   The gss_release_name call is not provided as Java does its own\n   garbage\
    \ collection.  The gss_duplicate_name call is also redundant;\n   the GSSName\
    \ interface has no mutator methods that can change the\n   state of the object,\
    \ so it is safe for sharing across threads.\n"
- title: 6.3.  GSSCredential Interface
  contents:
  - "6.3.  GSSCredential Interface\n   The GSSCredential interface is responsible\
    \ for the encapsulation of\n   GSS-API credentials.  Credentials identify a single\
    \ entity and\n   provide the necessary cryptographic information to enable the\n\
    \   creation of a context on behalf of that entity.  A single credential\n   may\
    \ contain multiple mechanism-specific credentials, each referred to\n   as a credential\
    \ element.  The GSSCredential interface provides the\n   functionality of the\
    \ following GSS-API routines:\n   +--------------------------+---------------------------+------------+\n\
    \   | RFC 2743 Routine         | Function                  | Section(s) |\n  \
    \ +--------------------------+---------------------------+------------+\n   |\
    \ gss_add_cred             | Constructs credentials    | 7.3.11     |\n   |  \
    \                        | incrementally.            |            |\n   | gss_inquire_cred\
    \         | Obtain information about  | 7.3.3 -    |\n   |                   \
    \       | credential.               | 7.3.10     |\n   | gss_inquire_cred_by_mech\
    \ | Obtain per-mechanism      | 7.3.4 -    |\n   |                          |\
    \ information about a       | 7.3.9      |\n   |                          | credential.\
    \               |            |\n   | gss_release_cred         | Dispose of credentials\
    \    | 7.3.2      |\n   |                          | after use.              \
    \  |            |\n   +--------------------------+---------------------------+------------+\n"
- title: 6.4.  GSSContext Interface
  contents:
  - "6.4.  GSSContext Interface\n   This interface encapsulates the functionality\
    \ of context-level calls\n   required for security context establishment and management\
    \ between\n   peers as well as the per-message services offered to applications.\
    \  A\n   context is established between a pair of peers and allows the usage\n\
    \   of security services on a per-message basis on application data.  It\n   is\
    \ created over a single security mechanism.  The GSSContext\n   interface provides\
    \ the functionality of the following GSS-API\n   routines:\n   +------------------------+-----------------------------+------------+\n\
    \   | RFC 2743 Routine       | Function                    | Section(s) |\n  \
    \ +------------------------+-----------------------------+------------+\n   |\
    \ gss_init_sec_context   | Initiate the creation of a  | 7.4.2      |\n   |  \
    \                      | security context with a     |            |\n   |    \
    \                    | peer.                       |            |\n   | gss_accept_sec_context\
    \ | Accept a security context   | 7.4.3      |\n   |                        |\
    \ initiated by a peer.        |            |\n   | gss_delete_sec_context | Destroy\
    \ a security context. | 7.4.5      |\n   | gss_context_time       | Obtain remaining\
    \ context    | 7.4.30     |\n   |                        | time.             \
    \          |            |\n   | gss_inquire_context    | Obtain context      \
    \        | 7.4.21 -   |\n   |                        | characteristics.      \
    \      | 7.4.35     |\n   | gss_wrap_size_limit    | Determine token-size limit\
    \  | 7.4.6      |\n   |                        | for gss_wrap.               |\
    \            |\n   | gss_export_sec_context | Transfer security context   | 7.4.11\
    \     |\n   |                        | to another process.         |         \
    \   |\n   | gss_get_mic            | Calculate a cryptographic   | 7.4.9     \
    \ |\n   |                        | Message Integrity Code      |            |\n\
    \   |                        | (MIC) for a message.        |            |\n  \
    \ | gss_verify_mic         | Verify integrity on a       | 7.4.10     |\n   |\
    \                        | received message.           |            |\n   | gss_wrap\
    \               | Attach a MIC to a message   | 7.4.7      |\n   |           \
    \             | and optionally encrypt the  |            |\n   |             \
    \           | message content.            |            |\n   | gss_unwrap    \
    \         | Obtain a previously wrapped | 7.4.8      |\n   |                 \
    \       | application message         |            |\n   |                   \
    \     | verifying its integrity and |            |\n   |                     \
    \   | optionally decrypting it.   |            |\n   +------------------------+-----------------------------+------------+\n\
    \   The functionality offered by the gss_process_context_token routine\n   has\
    \ not been included in the Java bindings specification.  The\n   corresponding\
    \ functionality of gss_delete_sec_context has also been\n   modified to not return\
    \ any peer tokens.  This has been proposed in\n   accordance to the recommendations\
    \ stated in RFC 2743 [RFC2743].\n   GSSContext does offer the functionality of\
    \ destroying the locally\n   stored context information.\n"
- title: 6.5.  MessageProp Class
  contents:
  - "6.5.  MessageProp Class\n   This helper class is used in the per-message operations\
    \ on the\n   context.  An instance of this class is created by the application\
    \ and\n   then passed into the per-message calls.  In some cases, the\n   application\
    \ conveys information to the GSS-API implementation through\n   this object, and\
    \ in other cases, the GSS-API returns information to\n   the application by setting\
    \ it in this object.  See the description of\n   the per-message operations wrap,\
    \ unwrap, getMIC, and verifyMIC in the\n   GSSContext interfaces for details.\n"
- title: 6.6.  GSSException Class
  contents:
  - "6.6.  GSSException Class\n   Exceptions are used in the Java bindings to signal\
    \ fatal errors to\n   the calling applications.  This replaces the major and minor\
    \ codes\n   used in the C-bindings specification as a method of signaling\n  \
    \ failures.  The GSSException class handles both minor and major codes,\n   as\
    \ well as their translation into textual representation.  All\n   GSS-API methods\
    \ are declared as throwing this exception.\n   +--------------------+----------------------------+-----------------+\n\
    \   | RFC 2743 Routine   | Function                   | Section         |\n  \
    \ +--------------------+----------------------------+-----------------+\n   |\
    \ gss_display_status | Retrieve textual           | 7.8.5, 7.8.6,   |\n   |  \
    \                  | representation of error    | 7.8.9, 7.8.10   |\n   |    \
    \                | codes.                     |                 |\n   +--------------------+----------------------------+-----------------+\n"
- title: 6.7.  Oid Class
  contents:
  - "6.7.  Oid Class\n   This utility class is used to represent Universal Object\
    \ Identifiers\n   and their associated operations.  GSS-API uses Object Identifiers\
    \ to\n   distinguish between security mechanisms and name types.  This class,\n\
    \   aside from being used whenever an Object Identifier is needed,\n   implements\
    \ the following GSS-API functionality:\n   +-------------------------+-------------------------------+---------+\n\
    \   | RFC 2743 Routine        | Function                      | Section |\n  \
    \ +-------------------------+-------------------------------+---------+\n   |\
    \ gss_test_oid_set_member | Determine if the specified    | 7.7.5   |\n   |  \
    \                       | OID is part of a set of OIDs. |         |\n   +-------------------------+-------------------------------+---------+\n"
- title: 6.8.  ChannelBinding Class
  contents:
  - "6.8.  ChannelBinding Class\n   An instance of this class is used to specify channel-binding\n\
    \   information to the GSSContext object before the start of a security\n   context\
    \ establishment.  The application may use a byte array to\n   specify application\
    \ data to be used in the channel binding as well as\n   to use instances of the\
    \ InetAddress.  InetAddress is currently the\n   only address type defined within\
    \ the Java platform and as such, it is\n   the only one supported within the ChannelBinding\
    \ class.  Applications\n   that use other types of addresses can include them\
    \ as part of the\n   application data.\n"
- title: 7.  Detailed GSS-API Class Description
  contents:
  - "7.  Detailed GSS-API Class Description\n   This section lists a detailed description\
    \ of all the public methods\n   that each of the GSS-API classes and interfaces\
    \ MUST provide.\n"
- title: 7.1.  public abstract class GSSManager
  contents:
  - "7.1.  public abstract class GSSManager\n   The GSSManager class is an abstract\
    \ class that serves as a factory\n   for three GSS interfaces: GSSName, GSSCredential,\
    \ and GSSContext.  It\n   also provides methods for applications to determine\
    \ what mechanisms\n   are available from the GSS implementation and what name\
    \ types these\n   mechanisms support.  An instance of the default GSSManager subclass\n\
    \   MAY be obtained through the static method getInstance(), but\n   applications\
    \ are free to instantiate other subclasses of GSSManager.\n   All but one method\
    \ in this class are declared abstract.  This means\n   that subclasses have to\
    \ provide the complete implementation for those\n   methods.  The only exception\
    \ to this is the static method\n   getInstance(), which will have platform-specific\
    \ code to return an\n   instance of the default subclass.\n   Platform providers\
    \ of GSS are REQUIRED not to add any constructors to\n   this class, whether the\
    \ constructor is private, public, or protected.\n   This will ensure that all\
    \ subclasses invoke only the default\n   constructor provided to the base class\
    \ by the compiler.\n   A subclass extending the GSSManager abstract class MAY\
    \ be implemented\n   as a modular provider-based layer that utilizes some well-known\n\
    \   service provider specification.  The GSSManager API provides the\n   application\
    \ with methods to set provider preferences on such an\n   implementation.  These\
    \ methods also allow the implementation to throw\n   a well-defined exception\
    \ in case provider-based configuration is not\n   supported.  Applications that\
    \ expect to be portable SHOULD be aware\n   of this and recover cleanly by catching\
    \ the exception.\n   It is envisioned that there will be three most common ways\
    \ in which\n   providers will be used:\n   1) The application does not care about\
    \ what provider is used (the\n      default case).\n   2) The application wants\
    \ a particular provider to be used\n      preferentially, either for a particular\
    \ mechanism or all the time,\n      irrespective of the mechanism.\n   3) The\
    \ application wants to use the locally configured providers as\n      far as possible,\
    \ but if support is missing for one or more\n      mechanisms, then it wants to\
    \ fall back on its own provider.\n   The GSSManager class has two methods that\
    \ enable these modes of\n   usage: addProviderAtFront() and addProviderAtEnd().\
    \  These methods\n   have the effect of creating an ordered list of <provider,\
    \ OID> pairs\n   where each pair indicates a preference of provider for a given\
    \ OID.\n   The use of these methods does not require any knowledge of whatever\n\
    \   service provider specification the GSSManager subclass follows.  It\n   is\
    \ hoped that these methods will serve the needs of most\n   applications.  Additional\
    \ methods MAY be added to an extended\n   GSSManager that could be part of a service\
    \ provider specification\n   that is standardized later.\n   When neither of the\
    \ methods is called, the implementation SHOULD\n   choose a default provider for\
    \ each mechanism it supports.\n"
- title: 7.1.1.  getInstance
  contents:
  - "7.1.1.  getInstance\n   public static GSSManager getInstance()\n   Returns the\
    \ default GSSManager implementation.\n"
- title: 7.1.2.  getMechs
  contents:
  - "7.1.2.  getMechs\n   public abstract Oid[] getMechs()\n   Returns an array of\
    \ Oid objects indicating the mechanisms available\n   to GSS-API callers.  A \"\
    null\" value is returned when no mechanisms\n   are available (an example of this\
    \ would be when mechanisms are\n   dynamically configured, and currently no mechanisms\
    \ are installed).\n"
- title: 7.1.3.  getNamesForMech
  contents:
  - "7.1.3.  getNamesForMech\n   public abstract Oid[] getNamesForMech(Oid mech)\n\
    \                         throws GSSException\n   Returns name type OIDs supported\
    \ by the specified mechanism.\n   Parameters:\n   mech                The Oid\
    \ object for the mechanism to query.\n"
- title: 7.1.4.  getMechsForName
  contents:
  - "7.1.4.  getMechsForName\n   public abstract Oid[] getMechsForName(Oid nameType)\n\
    \   Returns an array of Oid objects corresponding to the mechanisms that\n   support\
    \ the specific name type. \"null\" is returned when no mechanisms\n   are found\
    \ to support the specified name type.\n   Parameters:\n   nameType           \
    \ The Oid object for the name type.\n"
- title: 7.1.5.  createName
  contents:
  - "7.1.5.  createName\n   public abstract GSSName createName(String nameStr, Oid\
    \ nameType)\n                   throws GSSException\n   Factory method to convert\
    \ a contiguous string name from the specified\n   namespace to a GSSName object.\
    \  In general, the GSSName object\n   created will not be an MN; two examples\
    \ that are exceptions to this\n   are when the namespace type parameter indicates\
    \ NT_EXPORT_NAME or\n   when the GSS-API implementation does not support multiple\
    \ mechanisms.\n   Parameters:\n   nameStr             The string representing\
    \ a printable form of the\n                       name to create.\n   nameType\
    \            The OID specifying the namespace of the printable\n             \
    \          name is supplied.  Note that nameType serves to\n                 \
    \      describe and qualify the interpretation of the\n                      \
    \ input nameStr; it does not necessarily imply a\n                       type\
    \ for the output GSSName implementation.  The\n                       \"null\"\
    \ value can be used to specify that a\n                       mechanism-specific\
    \ default printable syntax\n                       SHOULD be assumed by each mechanism\
    \ that examines\n                       nameStr.\n"
- title: 7.1.6.  createName
  contents:
  - "7.1.6.  createName\n   public abstract GSSName createName(byte[] name, Oid nameType)\n\
    \                   throws GSSException\n   Factory method to convert a contiguous\
    \ byte array containing a name\n   from the specified namespace to a GSSName object.\
    \  In general, the\n   GSSName object created will not be an MN; two examples\
    \ that are\n   exceptions to this are when the namespace type parameter indicates\n\
    \   NT_EXPORT_NAME or when the GSS-API implementation is not a multi-\n   mechanism.\n\
    \   Parameters:\n   name                The byte array containing the name to\
    \ create.\n   nameType            The OID specifying the namespace of the name\n\
    \                       supplied in the byte array.  Note that nameType\n    \
    \                   serves to describe and qualify the interpretation\n      \
    \                 of the input name byte array; it does not\n                \
    \       necessarily imply a type for the output GSSName\n                    \
    \   implementation.  The \"null\" value can be used to\n                     \
    \  specify that a mechanism-specific default syntax\n                       SHOULD\
    \ be assumed by each mechanism that examines\n                       the byte\
    \ array.\n"
- title: 7.1.7.  createName
  contents:
  - "7.1.7.  createName\n   public abstract GSSName createName(String nameStr, Oid\
    \ nameType,\n                   Oid mech) throws GSSException\n   Factory method\
    \ to convert a contiguous string name from the specified\n   namespace to a GSSName\
    \ object that is a mechanism name (MN).  In\n   other words, this method is a\
    \ utility that does the equivalent of two\n   steps: the createName described\
    \ in Section 7.1.5 and also the\n   GSSName.canonicalize() described in Section\
    \ 7.2.4.\n   Parameters:\n   nameStr             The string representing a printable\
    \ form of the\n                       name to create.\n   nameType           \
    \ The OID specifying the namespace of the printable\n                       name\
    \ supplied.  Note that nameType serves to\n                       describe and\
    \ qualify the interpretation of the\n                       input nameStr; it\
    \ does not necessarily imply a\n                       type for the output GSSName\
    \ implementation.  The\n                       \"null\" value can be used to specify\
    \ that a\n                       mechanism-specific default printable syntax\n\
    \                       SHOULD be assumed when the mechanism examines\n      \
    \                 nameStr.\n   mech                OID specifying the mechanism\
    \ for which this name\n                       should be created.\n"
- title: 7.1.8.  createName
  contents:
  - "7.1.8.  createName\n   public abstract GSSName createName(byte[] name, Oid nameType,\n\
    \                   Oid mech) throws GSSException\n   Factory method to convert\
    \ a contiguous byte array containing a name\n   from the specified namespace to\
    \ a GSSName object that is an MN.  In\n   other words, this method is a utility\
    \ that does the equivalent of two\n   steps: the createName described in Section\
    \ 7.1.6 and also the\n   GSSName.canonicalize() described in Section 7.2.4.\n\
    \   Parameters:\n   name                The byte array representing the name to\
    \ create.\n   nameType            The OID specifying the namespace of the name\n\
    \                       supplied in the byte array.  Note that nameType\n    \
    \                   serves to describe and qualify the interpretation\n      \
    \                 of the input name byte array; it does not\n                \
    \       necessarily imply a type for the output GSSName\n                    \
    \   implementation.  The \"null\" value can be used to\n                     \
    \  specify that a mechanism-specific default syntax\n                       SHOULD\
    \ be assumed by each mechanism that examines\n                       the byte\
    \ array.\n   mech                OID specifying the mechanism for which this name\n\
    \                       should be created.\n"
- title: 7.1.9.  createCredential
  contents:
  - "7.1.9.  createCredential\n   public abstract GSSCredential createCredential(int\
    \ usage)\n                   throws GSSException\n   Factory method for acquiring\
    \ default credentials.  This will cause\n   the GSS-API to use system-specific\
    \ defaults for the set of\n   mechanisms, name, and a DEFAULT lifetime.\n   Parameters:\n\
    \   usage               The intended usage for this credential object.\n     \
    \                  The value of this parameter MUST be one of:\n             \
    \          GSSCredential.INITIATE_AND_ACCEPT(0),\n                       GSSCredential.INITIATE_ONLY(1),\
    \ or\n                       GSSCredential.ACCEPT_ONLY(2)\n"
- title: 7.1.10.  createCredential
  contents:
  - "7.1.10.  createCredential\n   public abstract GSSCredential createCredential(GSSName\
    \ aName,\n                   int lifetime, Oid mech, int usage)\n            \
    \       throws GSSException\n   Factory method for acquiring a single-mechanism\
    \ credential.\n   Parameters:\n   aName               Name of the principal for\
    \ whom this credential is\n                       to be acquired.  Use \"null\"\
    \ to specify the\n                       default principal.\n   lifetime     \
    \       The number of seconds that credentials should\n                      \
    \ remain valid.  Use\n                       GSSCredential.INDEFINITE_LIFETIME\
    \ to request that\n                       the credentials have the maximum permitted\n\
    \                       lifetime.  Use GSSCredential.DEFAULT_LIFETIME to\n   \
    \                    request default credential lifetime.\n   mech           \
    \     The OID of the desired mechanism.  Use \"(Oid)\n                       null\"\
    \ to request the default mechanism.\n   usage               The intended usage\
    \ for this credential object.\n                       The value of this parameter\
    \ MUST be one of:\n                       GSSCredential.INITIATE_AND_ACCEPT(0),\n\
    \                       GSSCredential.INITIATE_ONLY(1), or\n                 \
    \      GSSCredential.ACCEPT_ONLY(2)\n"
- title: 7.1.11.  createCredential
  contents:
  - "7.1.11.  createCredential\n   public abstract GSSCredential createCredential(GSSName\
    \ aName,\n                   int lifetime, Oid[] mechs, int usage)\n         \
    \          throws GSSException\n   Factory method for acquiring credentials over\
    \ a set of mechanisms.\n   Acquires credentials for each of the mechanisms specified\
    \ in the\n   array called mechs.  To determine the list of mechanisms for which\n\
    \   the acquisition of credentials succeeded, the caller should use the\n   GSSCredential.getMechs()\
    \ method.\n   Parameters:\n   aName               Name of the principal for whom\
    \ this credential is\n                       to be acquired.  Use \"null\" to\
    \ specify the\n                       default principal.\n   lifetime        \
    \    The number of seconds that credentials should\n                       remain\
    \ valid.  Use\n                       GSSCredential.INDEFINITE_LIFETIME to request\
    \ that\n                       the credentials have the maximum permitted\n  \
    \                     lifetime.  Use GSSCredential.DEFAULT_LIFETIME to\n     \
    \                  request default credential lifetime.\n   mechs            \
    \   The array of mechanisms over which the credential\n                      \
    \ is to be acquired.  Use \"(Oid[]) null\" for\n                       requesting\
    \ a system-specific default set of\n                       mechanisms.\n   usage\
    \               The intended usage for this credential object.\n             \
    \          The value of this parameter MUST be one of:\n                     \
    \  GSSCredential.INITIATE_AND_ACCEPT(0),\n                       GSSCredential.INITIATE_ONLY(1),\
    \ or\n                       GSSCredential.ACCEPT_ONLY(2)\n"
- title: 7.1.12.  createContext
  contents:
  - "7.1.12.  createContext\n   public abstract GSSContext createContext(GSSName peer,\
    \ Oid mech,\n                   GSSCredential myCred, int lifetime)\n        \
    \           throws GSSException\n   Factory method for creating a context on the\
    \ initiator's side.\n   Context flags may be modified through the mutator methods\
    \ prior to\n   calling GSSContext.initSecContext().\n   Parameters:\n   peer \
    \               Name of the target peer.\n   mech                OID of the desired\
    \ mechanism.  Use \"(Oid) null\"\n                       to request the default\
    \ mechanism.\n   myCred              Credentials of the initiator.  Use \"null\"\
    \ to act\n                       as a default initiator principal.\n   lifetime\
    \            The request lifetime, in seconds, for the\n                     \
    \  context.  Use GSSContext.INDEFINITE_LIFETIME and\n                       GSSContext.DEFAULT_LIFETIME\
    \ to request indefinite\n                       or default context lifetime.\n"
- title: 7.1.13.  createContext
  contents:
  - "7.1.13.  createContext\n   public abstract GSSContext createContext(GSSCredential\
    \ myCred)\n                   throws GSSException\n   Factory method for creating\
    \ a context on the acceptor's side.  The\n   context's properties will be determined\
    \ from the input token supplied\n   to the accept method.\n   Parameters:\n  \
    \ myCred              Credentials for the acceptor.  Use \"null\" to act\n   \
    \                    as a default acceptor principal.\n"
- title: 7.1.14.  createContext
  contents:
  - "7.1.14.  createContext\n   public abstract GSSContext createContext(byte[] interProcessToken)\n\
    \                   throws GSSException\n   Factory method for importing a previously\
    \ exported context.  The\n   context properties will be determined from the input\
    \ token and can't\n   be modified through the set methods.\n   Parameters:\n \
    \  interProcessToken   The token previously emitted from the export\n        \
    \               method.\n"
- title: 7.1.15.  addProviderAtFront
  contents:
  - "7.1.15.  addProviderAtFront\n   public abstract void addProviderAtFront(Provider\
    \ p, Oid mech)\n                   throws GSSException\n   This method is used\
    \ to indicate to the GSSManager that the\n   application would like a particular\
    \ provider to be used ahead of all\n   others when support is desired for the\
    \ given mechanism.  When a value\n   of \"null\" is used instead of an Oid object\
    \ for the mechanism, the\n   GSSManager MUST use the indicated provider ahead\
    \ of all others no\n   matter what the mechanism is.  Only when the indicated\
    \ provider does\n   not support the needed mechanism should the GSSManager move\
    \ on to a\n   different provider.\n   Calling this method repeatedly preserves\
    \ the older settings but\n   lowers them in preference thus forming an ordered\
    \ list of provider\n   and OID pairs that grows at the top.\n   Calling addProviderAtFront\
    \ with a null Oid will remove all previous\n   preferences that were set for this\
    \ provider in the GSSManager\n   instance.  Calling addProviderAtFront with a\
    \ non-null Oid will remove\n   any previous preference that was set using this\
    \ mechanism and this\n   provider together.\n   If the GSSManager implementation\
    \ does not support an SPI with a\n   pluggable provider architecture, it SHOULD\
    \ throw a GSSException with\n   the status code GSSException.UNAVAILABLE to indicate\
    \ that the\n   operation is unavailable.\n   Parameters:\n   p               \
    \    The provider instance that should be used\n                       whenever\
    \ support is needed for mech.\n   mech                The mechanism for which\
    \ the provider is being\n                       set.\n"
- title: 7.1.15.1.  addProviderAtFront Example Code
  contents:
  - "7.1.15.1.  addProviderAtFront Example Code\n   Suppose an application desired\
    \ that provider A always be checked\n   first when any mechanism is needed, it\
    \ would call:\n   <CODE BEGINS>\n   GSSManager mgr = GSSManager.getInstance();\n\
    \   // mgr may at this point have its own pre-configured list\n   // of provider\
    \ preferences.  The following will prepend to\n   // any such list:\n   mgr.addProviderAtFront(A,\
    \ null);\n   <CODE ENDS>\n   Now if it also desired that the mechanism of OID\
    \ m1 always be\n   obtained from provider B before the previous set A was checked,\
    \ it\n   would call:\n   <CODE BEGINS>\n   mgr.addProviderAtFront(B, m1);\n  \
    \ <CODE ENDS>\n   The GSSManager would then first check with B if m1 was needed.\
    \  In\n   case B did not provide support for m1, the GSSManager would continue\n\
    \   on to check with A.  If any mechanism m2 is needed where m2 is\n   different\
    \ from m1, then the GSSManager would skip B and check with A\n   directly.\n \
    \  Suppose, at a later time, the following call is made to the same\n   GSSManager\
    \ instance:\n   <CODE BEGINS>\n   mgr.addProviderAtFront(B, null)\n   <CODE ENDS>\n\
    \   then the previous setting with the pair (B, m1) is subsumed by this\n   and\
    \ SHOULD be removed.  Effectively, the list of preferences now\n   becomes {(B,\
    \ null), (A, null), ... //followed by the pre-configured\n   list}.\n   Please\
    \ note, however, that the following call:\n   <CODE BEGINS>\n   mgr.addProviderAtFront(A,\
    \ m3)\n   <CODE ENDS>\n   does not subsume the previous setting of (A, null),\
    \ and the list will\n   effectively become {(A, m3), (B, null), (A, null), ...}\n"
- title: 7.1.16.  addProviderAtEnd
  contents:
  - "7.1.16.  addProviderAtEnd\n   public abstract void addProviderAtEnd(Provider\
    \ p, Oid mech)\n                   throws GSSException\n   This method is used\
    \ to indicate to the GSSManager that the\n   application would like a particular\
    \ provider to be used if no other\n   provider can be found that supports the\
    \ given mechanism.  When a\n   value of \"null\" is used instead of an Oid object\
    \ for the mechanism,\n   the GSSManager MUST use the indicated provider for any\
    \ mechanism.\n   Calling this method repeatedly preserves the older settings but\n\
    \   raises them above newer ones in preference, thus forming an ordered\n   list\
    \ of providers and OID pairs that grows at the bottom.  Thus, the\n   older provider\
    \ settings will be utilized first before this one is.\n   If there are any previously\
    \ existing preferences that conflict with\n   the preference being set here, then\
    \ the GSSManager SHOULD ignore this\n   request.\n   If the GSSManager implementation\
    \ does not support an SPI with a\n   pluggable provider architecture, it SHOULD\
    \ throw a GSSException with\n   the status code GSSException.UNAVAILABLE to indicate\
    \ that the\n   operation is unavailable.\n   Parameters:\n   p               \
    \    The provider instance that should be used\n                       whenever\
    \ support is needed for mech.\n   mech                The mechanism for which\
    \ the provider is being\n                       set.\n"
- title: 7.1.16.1.  addProviderAtEnd Example Code
  contents:
  - "7.1.16.1.  addProviderAtEnd Example Code\n   Suppose an application desired that\
    \ when a mechanism of OID m1 is\n   needed, the system default providers always\
    \ be checked first, and\n   only when they do not support m1 should a provider\
    \ A be checked.  It\n   would then make the call:\n   <CODE BEGINS>\n   GSSManager\
    \ mgr = GSSManager.getInstance();\n   mgr.addProviderAtEnd(A, m1);\n   <CODE ENDS>\n\
    \   Now, if it also desired that provider B be checked for all mechanisms\n  \
    \ after all configured providers have been checked, it would then call:\n   <CODE\
    \ BEGINS>\n   mgr.addProviderAtEnd(B, null);\n   <CODE ENDS>\n   Effectively,\
    \ the list of preferences now becomes {..., (A, m1), (B,\n   null)}.\n   Suppose,\
    \ at a later time, the following call is made to the same\n   GSSManager instance:\n\
    \   <CODE BEGINS>\n   mgr.addProviderAtEnd(B, m2)\n   <CODE ENDS>\n   then the\
    \ previous setting with the pair (B, null) subsumes this;\n   therefore, this\
    \ request SHOULD be ignored.  The same would happen if\n   a request is made for\
    \ the already existing pairs of (A, m1) or (B,\n   null).\n   Please note, however,\
    \ that the following call:\n   <CODE BEGINS>\n   mgr.addProviderAtEnd(A, null)\n\
    \   <CODE ENDS>\n   is not subsumed by the previous setting of (A, m1), and the\
    \ list will\n   effectively become {..., (A, m1), (B, null), (A, null)}.\n"
- title: 7.1.17.  Example Code
  contents:
  - "7.1.17.  Example Code\n   <CODE BEGINS>\n   GSSManager mgr = GSSManager.getInstance();\n\
    \   // What mechs are available to us?\n   Oid[] supportedMechs = mgr.getMechs();\n\
    \   // Set a preference for the provider to be used when support\n   // is needed\
    \ for the mechanisms:\n   //  \"1.2.840.113554.1.2.2\" and \"1.3.6.1.5.5.1.1\"\
    .\n   Oid krb = new Oid(\"1.2.840.113554.1.2.2\");\n   Oid spkm1 = new Oid(\"\
    1.3.6.1.5.5.1.1\");\n   Provider p = (Provider) (new com.foo.security.Provider());\n\
    \   mgr.addProviderAtFront(p, krb);\n   mgr.addProviderAtFront(p, spkm1);\n  \
    \ // What name types does this spkm implementation support?\n   Oid[] nameTypes\
    \ = mgr.getNamesForMech(spkm1);\n   <CODE ENDS>\n"
- title: 7.2.  public interface GSSName
  contents:
  - "7.2.  public interface GSSName\n   This interface encapsulates a single GSS-API\
    \ principal entity.\n   Different name formats and their definitions are identified\
    \ with\n   Universal OIDs.  The format of the names can be derived based on the\n\
    \   unique OID of its namespace type.\n"
- title: 7.2.1.  Static Constants
  contents:
  - "7.2.1.  Static Constants\n   public static final Oid NT_HOSTBASED_SERVICE\n \
    \  OID indicating a host-based service name form.  It is used to\n   represent\
    \ services associated with host computers.  This name form is\n   constructed\
    \ using two elements, \"service\" and \"hostname\", as follows:\n      service@hostname\n\
    \   Values for the \"service\" element are registered with the IANA.  It\n   represents\
    \ the following value: { iso(1) member-body(2) United\n   States(840) mit(113554)\
    \ infosys(1) gssapi(2) generic(1)\n   service_name(4) }\n   public static final\
    \ Oid NT_USER_NAME\n   Name type to indicate a named user on a local system. \
    \ It represents\n   the following value: { iso(1) member-body(2) United States(840)\n\
    \   mit(113554) infosys(1) gssapi(2) generic(1) user_name(1) }\n   public static\
    \ final Oid NT_MACHINE_UID_NAME\n   Name type to indicate a numeric user identifier\
    \ corresponding to a\n   user on a local system (e.g., Uid).  It represents the\
    \ following\n   value: { iso(1) member-body(2) United States(840) mit(113554)\n\
    \   infosys(1) gssapi(2) generic(1) machine_uid_name(2) }\n   public static final\
    \ Oid NT_STRING_UID_NAME\n   Name type to indicate a string of digits representing\
    \ the numeric\n   user identifier of a user on a local system.  It represents\
    \ the\n   following value: { iso(1) member-body(2) United States(840)\n   mit(113554)\
    \ infosys(1) gssapi(2) generic(1) string_uid_name(3) }\n   public static final\
    \ Oid NT_ANONYMOUS\n   Name type for representing an anonymous entity.  It represents\
    \ the\n   following value: { iso(1), org(3), dod(6), internet(1), security(5),\n\
    \   nametypes(6), gss-anonymous-name(3) }\n   public static final Oid NT_EXPORT_NAME\n\
    \   Name type used to indicate an exported name produced by the export\n   method.\
    \  It represents the following value: { iso(1), org(3), dod(6),\n   internet(1),\
    \ security(5), nametypes(6), gss-api-exported-name(4) }\n"
- title: 7.2.2.  equals
  contents:
  - "7.2.2.  equals\n   public boolean equals(GSSName another) throws GSSException\n\
    \   Compares two GSSName objects to determine whether they refer to the\n   same\
    \ entity.  This method MAY throw a GSSException when the names\n   cannot be compared.\
    \  If either of the names represents an anonymous\n   entity, the method will\
    \ return \"false\".\n   Parameters:\n   another             GSSName object with\
    \ which to compare.\n"
- title: 7.2.3.  equals
  contents:
  - "7.2.3.  equals\n   public boolean equals(Object another)\n   A variation of the\
    \ equals method, described in Section 7.2.2, that is\n   provided to override\
    \ the Object.equals() method that the implementing\n   class will inherit.  The\
    \ behavior is exactly the same as that in\n   Section 7.2.2 except that no GSSException\
    \ is thrown; instead, \"false\"\n   will be returned in the situation where an\
    \ error occurs.  (Note that\n   the Java language specification requires that\
    \ two objects that are\n   equal according to the equals(Object) method MUST return\
    \ the same\n   integer result when the hashCode() method is called on them.)\n\
    \   Parameters:\n   another             GSSName object with which to compare.\n"
- title: 7.2.4.  canonicalize
  contents:
  - "7.2.4.  canonicalize\n   public GSSName canonicalize(Oid mech) throws GSSException\n\
    \   Creates an MN from an arbitrary internal name.  This is equivalent to\n  \
    \ using the factory methods described in Sections 7.1.7 or 7.1.8 that\n   take\
    \ the mechanism name as one of their parameters.\n   Parameters:\n   mech    \
    \            The OID for the mechanism for which the canonical\n             \
    \          form of the name is requested.\n"
- title: 7.2.5.  export
  contents:
  - "7.2.5.  export\n   public byte[] export() throws GSSException\n   Returns a canonical\
    \ contiguous byte representation of an MN, suitable\n   for direct, byte-by-byte\
    \ comparison by authorization functions.  If\n   the name is not an MN, implementations\
    \ MAY throw a GSSException with\n   the NAME_NOT_MN status code.  If an implementation\
    \ chooses not to\n   throw an exception, it SHOULD use some system-specific default\n\
    \   mechanism to canonicalize the name and then export it.  The format of\n  \
    \ the header of the output buffer is specified in RFC 2743 [RFC2743].\n"
- title: 7.2.6.  toString
  contents:
  - "7.2.6.  toString\n   public String toString()\n   Returns a textual representation\
    \ of the GSSName object.  To retrieve\n   the printed name format, which determines\
    \ the syntax of the returned\n   string, the getStringNameType method can be used.\n"
- title: 7.2.7.  getStringNameType
  contents:
  - "7.2.7.  getStringNameType\n   public Oid getStringNameType() throws GSSException\n\
    \   Returns the OID representing the type of name returned through the\n   toString\
    \ method.  Using this OID, the syntax of the printable name\n   can be determined.\n"
- title: 7.2.8.  isAnonymous
  contents:
  - "7.2.8.  isAnonymous\n   public boolean isAnonymous()\n   Tests if this name object\
    \ represents an anonymous entity.  Returns\n   \"true\" if this is an anonymous\
    \ name.\n"
- title: 7.2.9.  isMN
  contents:
  - "7.2.9.  isMN\n   public boolean isMN()\n   Tests if this name object contains\
    \ only one mechanism element and is\n   thus a mechanism name as defined by RFC\
    \ 2743 [RFC2743].\n"
- title: 7.2.10.  Example Code
  contents:
  - "7.2.10.  Example Code\n   Included below are code examples utilizing the GSSName\
    \ interface.\n   The code below creates a GSSName, converts it to an MN, performs\
    \ a\n   comparison, obtains a printable representation of the name, exports\n\
    \   it, and then re-imports to obtain a new GSSName.\n   <CODE BEGINS>\n   GSSManager\
    \ mgr = GSSManager.getInstance();\n   // create a host-based service name\n  \
    \ GSSName name = mgr.createName(\"service@host\",\n                   GSSName.NT_HOSTBASED_SERVICE);\n\
    \   Oid krb5 = new Oid(\"1.2.840.113554.1.2.2\");\n   GSSName mechName = name.canonicalize(krb5);\n\
    \   // the above two steps are equivalent to the following\n   GSSName mechName\
    \ = mgr.createName(\"service@host\",\n                   GSSName.NT_HOSTBASED_SERVICE,\
    \ krb5);\n   // perform name comparison\n   if (name.equals(mechName))\n     \
    \      print(\"Names are equals.\");\n   // obtain textual representation of name\
    \ and its printable\n   // name type\n   print(mechName.toString() +\n       \
    \  mechName.getStringNameType().toString());\n   // export the name\n   byte[]\
    \ exportName = mechName.export();\n   // create a new name object from the exported\
    \ buffer\n   GSSName newName = mgr.createName(exportName,\n                  \
    \   GSSName.NT_EXPORT_NAME);\n   <CODE ENDS>\n"
- title: 7.3.  public interface GSSCredential implements Cloneable
  contents:
  - "7.3.  public interface GSSCredential implements Cloneable\n   This interface\
    \ encapsulates the GSS-API credentials for an entity.  A\n   credential contains\
    \ all the necessary cryptographic information to\n   enable the creation of a\
    \ context on behalf of the entity that it\n   represents.  It MAY contain multiple,\
    \ distinct, mechanism-specific\n   credential elements, each containing information\
    \ for a specific\n   security mechanism, but all referring to the same entity.\n\
    \   A credential MAY be used to perform context initiation, acceptance,\n   or\
    \ both.\n   GSS-API implementations MUST impose a local access-control policy\
    \ on\n   callers to prevent unauthorized callers from acquiring credentials to\n\
    \   which they are not entitled.  GSS-API credential creation is not\n   intended\
    \ to provide a \"login to the network\" function, as such a\n   function would\
    \ involve the creation of new credentials rather than\n   merely acquiring a handle\
    \ to existing credentials.  Such functions,\n   if required, SHOULD be defined\
    \ in implementation-specific extensions\n   to the API.\n   If credential acquisition\
    \ is time-consuming for a mechanism, the\n   mechanism MAY choose to delay the\
    \ actual acquisition until the\n   credential is required (e.g., by GSSContext).\
    \  Such mechanism-\n   specific implementation decisions SHOULD be invisible to\
    \ the calling\n   application; thus, the query methods immediately following the\n\
    \   creation of a credential object MUST return valid credential data and\n  \
    \ may therefore incur the overhead of a deferred credential\n   acquisition.\n\
    \   Applications will create a credential object passing the desired\n   parameters.\
    \  The application can then use the query methods to obtain\n   specific information\
    \ about the instantiated credential object\n   (equivalent to the gss_inquire\
    \ routines).  When the credential is no\n   longer needed, the application SHOULD\
    \ call the dispose (equivalent to\n   gss_release_cred) method to release any\
    \ resources held by the\n   credential object and to destroy any cryptographically\
    \ sensitive\n   information.\n   Classes implementing this interface also implement\
    \ the Cloneable\n   interface.  This indicates that the class will support the\
    \ clone()\n   method that will allow the creation of duplicate credentials.  This\n\
    \   is useful when called just before the add() call to retain a copy of\n   the\
    \ original credential.\n"
- title: 7.3.1.  Static Constants
  contents:
  - "7.3.1.  Static Constants\n   public static final int INITIATE_AND_ACCEPT\n  \
    \ Credential usage flag requesting that it be able to be used for both\n   context\
    \ initiation and acceptance.  The value of this constant is 0.\n   public static\
    \ final int INITIATE_ONLY\n   Credential usage flag requesting that it be able\
    \ to be used for\n   context initiation only.  The value of this constant is 1.\n\
    \   public static final int ACCEPT_ONLY\n   Credential usage flag requesting that\
    \ it be able to be used for\n   context acceptance only.  The value of this constant\
    \ is 2.\n   public static final int DEFAULT_LIFETIME\n   A lifetime constant representing\
    \ the default credential lifetime.\n   The value of this constant is 0.\n   public\
    \ static final int INDEFINITE_LIFETIME\n   A lifetime constant representing indefinite\
    \ credential lifetime.  The\n   value of this constant is the maximum integer\
    \ value in Java --\n   Integer.MAX_VALUE.\n"
- title: 7.3.2.  dispose
  contents:
  - "7.3.2.  dispose\n   public void dispose() throws GSSException\n   Releases any\
    \ sensitive information that the GSSCredential object may\n   be containing. \
    \ Applications SHOULD call this method as soon as the\n   credential is no longer\
    \ needed to minimize the time any sensitive\n   information is maintained.\n"
- title: 7.3.3.  getName
  contents:
  - "7.3.3.  getName\n   public GSSName getName() throws GSSException\n   Retrieves\
    \ the name of the entity that the credential asserts.\n"
- title: 7.3.4.  getName
  contents:
  - "7.3.4.  getName\n   public GSSName getName(Oid mechOID) throws GSSException\n\
    \   Retrieves a mechanism name of the entity that the credential asserts.\n  \
    \ Equivalent to calling canonicalize() on the name returned by\n   Section 7.3.3.\n\
    \   Parameters:\n   mechOID             The mechanism for which information should\
    \ be\n                       returned.\n"
- title: 7.3.5.  getRemainingLifetime
  contents:
  - "7.3.5.  getRemainingLifetime\n   public int getRemainingLifetime() throws GSSException\n\
    \   Returns the remaining lifetime in seconds for a credential.  The\n   remaining\
    \ lifetime is the minimum lifetime for any of the underlying\n   credential mechanisms.\
    \  A return value of\n   GSSCredential.INDEFINITE_LIFETIME indicates that the\
    \ credential does\n   not expire.  A return value of 0 indicates that the credential\
    \ is\n   already expired.\n"
- title: 7.3.6.  getRemainingInitLifetime
  contents:
  - "7.3.6.  getRemainingInitLifetime\n   public int getRemainingInitLifetime(Oid\
    \ mech) throws GSSException\n   Returns the remaining lifetime in seconds for\
    \ the credential to\n   remain capable of initiating security contexts under the\
    \ specified\n   mechanism.  A return value of GSSCredential.INDEFINITE_LIFETIME\n\
    \   indicates that the credential does not expire for context initiation.\n  \
    \ A return value of 0 indicates that the credential is already expired.\n   Parameters:\n\
    \   mechOID             The mechanism for which information should be\n      \
    \                 returned.\n"
- title: 7.3.7.  getRemainingAcceptLifetime
  contents:
  - "7.3.7.  getRemainingAcceptLifetime\n   public int getRemainingAcceptLifetime(Oid\
    \ mech) throws GSSException\n   Returns the remaining lifetime in seconds for\
    \ the credential to\n   remain capable of accepting security contexts under the\
    \ specified\n   mechanism.  A return value of GSSCredential.INDEFINITE_LIFETIME\n\
    \   indicates that the credential does not expire for context acceptance.\n  \
    \ A return value of 0 indicates that the credential is already expired.\n   Parameters:\n\
    \   mechOID             The mechanism for which information should be\n      \
    \                 returned.\n"
- title: 7.3.8.  getUsage
  contents:
  - "7.3.8.  getUsage\n   public int getUsage() throws GSSException\n   Returns the\
    \ credential usage flag as a union over all mechanisms.\n   The return value will\
    \ be one of GSSCredential.INITIATE_AND_ACCEPT(0),\n   GSSCredential.INITIATE_ONLY(1),\
    \ or GSSCredential.ACCEPT_ONLY(2).\n   Specifically, GSSCredential.INITIATE_AND_ACCEPT(0)\
    \ SHOULD be returned\n   as long as there exists one credential element allowing\
    \ context\n   initiation and one credential element allowing context acceptance.\n\
    \   These two credential elements are not necessarily the same one, nor\n   do\
    \ they need to use the same mechanism(s).\n"
- title: 7.3.9.  getUsage
  contents:
  - "7.3.9.  getUsage\n   public int getUsage(Oid mechOID) throws GSSException\n \
    \  Returns the credential usage flag for the specified mechanism only.\n   The\
    \ return value will be one of GSSCredential.INITIATE_AND_ACCEPT(0),\n   GSSCredential.INITIATE_ONLY(1),\
    \ or GSSCredential.ACCEPT_ONLY(2).\n   Parameters:\n   mechOID             The\
    \ mechanism for which information should be\n                       returned.\n"
- title: 7.3.10.  getMechs
  contents:
  - "7.3.10.  getMechs\n   public Oid[] getMechs() throws GSSException\n   Returns\
    \ an array of mechanisms supported by this credential.\n"
- title: 7.3.11.  add
  contents:
  - "7.3.11.  add\n   public void add(GSSName aName, int initLifetime, int acceptLifetime,\n\
    \                   Oid mech, int usage) throws GSSException\n   Adds a mechanism-specific\
    \ credential element to an existing\n   credential.  This method allows the construction\
    \ of credentials one\n   mechanism at a time.\n   This routine is envisioned to\
    \ be used mainly by context acceptors\n   during the creation of acceptance credentials,\
    \ which are to be used\n   with a variety of clients using different security\
    \ mechanisms.\n   This routine adds the new credential element \"in-place\". \
    \ To add the\n   element in a new credential, first call clone() to obtain a copy\
    \ of\n   this credential, then call its add() method.\n   Parameters:\n   aName\
    \               Name of the principal for whom this credential is\n          \
    \             to be acquired.  Use \"null\" to specify the\n                 \
    \      default principal.\n   initLifetime        The number of seconds that credentials\
    \ should\n                       remain valid for initiating security contexts.\n\
    \                       Use GSSCredential.INDEFINITE_LIFETIME to request\n   \
    \                    that the credentials have the maximum permitted\n       \
    \                lifetime.  Use GSSCredential.DEFAULT_LIFETIME to\n          \
    \             request default credential lifetime.\n   acceptLifetime      The\
    \ number of seconds that credentials should\n                       remain valid\
    \ for accepting security contexts.\n                       Use GSSCredential.INDEFINITE_LIFETIME\
    \ to request\n                       that the credentials\n                  \
    \     have the maximum permitted lifetime.  Use\n                       GSSCredential.DEFAULT_LIFETIME\
    \ to request default\n                       credential lifetime.\n   mech   \
    \             The mechanisms over which the credential is to be\n            \
    \           acquired.\n   usage               The intended usage for this credential\
    \ object.\n                       The value of this parameter MUST be one of:\n\
    \                       GSSCredential.INITIATE_AND_ACCEPT(0),\n              \
    \         GSSCredential.INITIATE_ONLY(1), or\n                       GSSCredential.ACCEPT_ONLY(2)\n"
- title: 7.3.12.  equals
  contents:
  - "7.3.12.  equals\n   public boolean equals(Object another)\n   Tests if this GSSCredential\
    \ refers to the same entity as the supplied\n   object.  The two credentials MUST\
    \ be acquired over the same\n   mechanisms and MUST refer to the same principal.\
    \  Returns \"true\" if\n   the two GSSCredentials refer to the same entity, or\
    \ \"false\"\n   otherwise.  (Note that the Java language specification [JLS] requires\n\
    \   that two objects that are equal according to the equals(Object)\n   method\
    \ MUST return the same integer result when the hashCode() method\n   is called\
    \ on them.)\n   Parameters:\n   another             Another GSSCredential object\
    \ for comparison.\n"
- title: 7.3.13.  Example Code
  contents:
  - "7.3.13.  Example Code\n   This example code demonstrates the creation of a GSSCredential\n\
    \   implementation for a specific entity, querying of its fields, and its\n  \
    \ release when it is no longer needed.\n   <CODE BEGINS>\n   GSSManager mgr =\
    \ GSSManager.getInstance();\n   // start by creating a name object for the entity\n\
    \   GSSName name = mgr.createName(\"userName\", GSSName.NT_USER_NAME);\n   //\
    \ now acquire credentials for the entity\n   GSSCredential cred = mgr.createCredential(name,\n\
    \              GSSCredential.INDEFINITE_LIFETIME,\n              (Oid[])null,\n\
    \              GSSCredential.ACCEPT_ONLY);\n   // display credential information\
    \ - name, remaining lifetime,\n   // and the mechanisms it has been acquired over\n\
    \   print(cred.getName().toString());\n   print(cred.getRemainingLifetime());\n\
    \   Oid[] mechs = cred.getMechs();\n   if (mechs != null) {\n      for (int i\
    \ = 0; i < mechs.length; i++)\n          print(mechs[i].toString());\n   }\n \
    \  // release system resources held by the credential\n   cred.dispose();\n  \
    \ <CODE ENDS>\n"
- title: 7.4.  public interface GSSContext
  contents:
  - "7.4.  public interface GSSContext\n   This interface encapsulates the GSS-API\
    \ security context and provides\n   the security services (wrap, unwrap, getMIC,\
    \ and verifyMIC) that are\n   available over the context.  Security contexts are\
    \ established\n   between peers using locally acquired credentials.  Multiple\
    \ contexts\n   may exist simultaneously between a pair of peers, using the same\
    \ or\n   different set of credentials.  GSS-API functions in a manner\n   independent\
    \ of the underlying transport protocol and depends on its\n   calling application\
    \ to transport its tokens between peers.\n   Before the context establishment\
    \ phase is initiated, the context\n   initiator may request specific characteristics\
    \ desired of the\n   established context.  These can be set using the set methods.\
    \  After\n   the context is established, the caller can check the actual\n   characteristic\
    \ and services offered by the context using the query\n   methods.\n   The context\
    \ establishment phase begins with the first call to the\n   init method by the\
    \ context initiator.  During this phase, the\n   initSecContext and acceptSecContext\
    \ methods will produce GSS-API\n   authentication tokens, which the calling application\
    \ needs to send to\n   its peer.  If an error occurs at any point, an exception\
    \ will get\n   thrown and the code will start executing in a catch block where\
    \ the\n   exception may contain an output token that should be sent to the peer\n\
    \   for debugging or informational purpose.  If not, the normal flow of\n   code\
    \ continues, and the application can make a call to the\n   isEstablished() method.\
    \  If this method returns \"false\", it indicates\n   that a token is needed from\
    \ its peer in order to continue the context\n   establishment phase.  A return\
    \ value of \"true\" signals that the local\n   end of the context is established.\
    \  This may still require that a\n   token be sent to the peer, if one is produced\
    \ by GSS-API.  During the\n   context establishment phase, the isProtReady() method\
    \ may be called\n   to determine if the context can be used for the per-message\n\
    \   operations.  This allows applications to use per-message operations\n   on\
    \ contexts that aren't fully established.\n   After the context has been established\
    \ or the isProtReady() method\n   returns \"true\", the query routines can be\
    \ invoked to determine the\n   actual characteristics and services of the established\
    \ context.  The\n   application can also start using the per-message methods of\
    \ wrap and\n   getMIC to obtain cryptographic operations on application-supplied\n\
    \   data.\n   When the context is no longer needed, the application SHOULD call\n\
    \   dispose to release any system resources the context may be using.\n"
- title: 7.4.1.  Static Constants
  contents:
  - "7.4.1.  Static Constants\n   public static final int DEFAULT_LIFETIME\n   A lifetime\
    \ constant representing the default context lifetime.  The\n   value of this constant\
    \ is 0.\n   public static final int INDEFINITE_LIFETIME\n   A lifetime constant\
    \ representing indefinite context lifetime.  The\n   value of this constant is\
    \ the maximum integer value in Java --\n   Integer.MAX_VALUE.\n"
- title: 7.4.2.  initSecContext
  contents:
  - "7.4.2.  initSecContext\n   public byte[] initSecContext(byte[] inputBuf, int\
    \ offset, int len)\n                 throws GSSException\n   Called by the context\
    \ initiator to start the context creation\n   process.  This method MAY return\
    \ an output token that the application\n   will need to send to the peer for processing\
    \ by the accept call.  The\n   application can call isEstablished() to determine\
    \ if the context\n   establishment phase is complete for this peer.  A return\
    \ value of\n   \"false\" from isEstablished() indicates that more tokens are expected\n\
    \   to be supplied to the initSecContext() method.  Note that it is\n   possible\
    \ that the initSecContext() method will return a token for the\n   peer and isEstablished()\
    \ will return \"true\" also.  This indicates\n   that the token needs to be sent\
    \ to the peer, but the local end of the\n   context is now fully established.\n\
    \   Upon completion of the context establishment, the available context\n   options\
    \ may be queried through the get methods.\n   A GSSException will be thrown if\
    \ the call fails.  Users SHOULD call\n   its getOutputToken() method to find out\
    \ if there is a token that can\n   be sent to the acceptor to communicate the\
    \ reason for the error.\n   Parameters:\n   inputBuf            Token generated\
    \ by the peer.  This parameter is\n                       ignored on the first\
    \ call.\n   offset              The offset within the inputBuf where the token\n\
    \                       begins.\n   len                 The length of the token\
    \ within the inputBuf\n                       (starting at the offset).\n"
- title: 7.4.3.  acceptSecContext
  contents:
  - "7.4.3.  acceptSecContext\n   public byte[] acceptSecContext(byte[] inTok, int\
    \ offset, int len)\n              throws GSSException\n   Called by the context\
    \ acceptor upon receiving a token from the peer.\n   This method MAY return an\
    \ output token that the application will need\n   to send to the peer for further\
    \ processing by the init call.\n   The \"null\" return value indicates that no\
    \ token needs to be sent to\n   the peer.  The application can call isEstablished()\
    \ to determine if\n   the context establishment phase is complete for this peer.\
    \  A return\n   value of \"false\" from isEstablished() indicates that more tokens\
    \ are\n   expected to be supplied to this method.\n   Note that it is possible\
    \ that acceptSecContext() will return a token\n   for the peer and isEstablished()\
    \ will return \"true\" also.  This\n   indicates that the token needs to be sent\
    \ to the peer, but the local\n   end of the context is now fully established.\n\
    \   Upon completion of the context establishment, the available context\n   options\
    \ may be queried through the get methods.\n   A GSSException will be thrown if\
    \ the call fails.  Users SHOULD call\n   its getOutputToken() method to find out\
    \ if there is a token that can\n   be sent to the initiator to communicate the\
    \ reason for the error.\n   Parameters:\n   inTok               Token generated\
    \ by the peer.\n   offset              The offset within the inTok where the token\n\
    \                       begins.\n   len                 The length of the token\
    \ within the inTok\n                       (starting at the offset).\n"
- title: 7.4.4.  isEstablished
  contents:
  - "7.4.4.  isEstablished\n   public boolean isEstablished()\n   Used during context\
    \ establishment to determine the state of the\n   context.  Returns \"true\" if\
    \ this is a fully established context on\n   the caller's side and no more tokens\
    \ are needed from the peer.\n   Should be called after a call to initSecContext()\
    \ or\n   acceptSecContext() when no GSSException is thrown.\n"
- title: 7.4.5.  dispose
  contents:
  - "7.4.5.  dispose\n   public void dispose() throws GSSException\n   Releases any\
    \ system resources and cryptographic information stored in\n   the context object.\
    \  This will invalidate the context.\n"
- title: 7.4.6.  getWrapSizeLimit
  contents:
  - "7.4.6.  getWrapSizeLimit\n   public int getWrapSizeLimit(int qop, boolean confReq,\n\
    \              int maxTokenSize) throws GSSException\n   Returns the maximum message\
    \ size that, if presented to the wrap\n   method with the same confReq and qop\
    \ parameters, will result in an\n   output token containing no more than the maxTokenSize\
    \ bytes.\n   This call is intended for use by applications that communicate over\n\
    \   protocols that impose a maximum message size.  It enables the\n   application\
    \ to fragment messages prior to applying protection.\n   GSS-API implementations\
    \ are RECOMMENDED but not required to detect\n   invalid QOP values when getWrapSizeLimit\
    \ is called.  This routine\n   guarantees only a maximum message size, not the\
    \ availability of\n   specific QOP values for message protection.\n   Successful\
    \ completion of this call does not guarantee that wrap will\n   be able to protect\
    \ a message of the computed length, since this\n   ability may depend on the availability\
    \ of system resources at the\n   time that wrap is called.  However, if the implementation\
    \ itself\n   imposes an upper limit on the length of messages that may be\n  \
    \ processed by wrap, the implementation SHOULD NOT return a value that\n   is\
    \ greater than this length.\n   Parameters:\n   qop                 Indicates\
    \ the level of protection wrap will be\n                       asked to provide.\n\
    \   confReq             Indicates if wrap will be asked to provide\n         \
    \              privacy service.\n   maxTokenSize        The desired maximum size\
    \ of the token emitted by\n                       wrap.\n"
- title: 7.4.7.  wrap
  contents:
  - "7.4.7.  wrap\n   public byte[] wrap(byte[] inBuf, int offset, int len,\n    \
    \                  MessageProp msgProp) throws GSSException\n   Applies per-message\
    \ security services over the established security\n   context.  The method will\
    \ return a token with a cryptographic MIC and\n   MAY optionally encrypt the specified\
    \ inBuf.  The returned byte array\n   will contain both the MIC and the message.\n\
    \   The MessageProp object is instantiated by the application and used to\n  \
    \ specify a QOP value that selects cryptographic algorithms and a\n   privacy\
    \ service to optionally encrypt the message.  The underlying\n   mechanism that\
    \ is used in the call may not be able to provide the\n   privacy service.  It\
    \ sets the actual privacy service that it does\n   provide in this MessageProp\
    \ object, which the caller SHOULD then\n   query upon return.  If the mechanism\
    \ is not able to provide the\n   requested QOP, it throws a GSSException with\
    \ the BAD_QOP code.\n   Since some application-level protocols may wish to use\
    \ tokens emitted\n   by wrap to provide \"secure framing\", implementations SHOULD\
    \ support\n   the wrapping of zero-length messages.\n   The application will be\
    \ responsible for sending the token to the\n   peer.\n   Parameters:\n   inBuf\
    \               Application data to be protected.\n   offset              The\
    \ offset within the inBuf where the data\n                       begins.\n   len\
    \                 The length of the data within the inBuf (starting\n        \
    \               at the offset).\n   msgProp             Instance of MessageProp\
    \ that is used by the\n                       application to set the desired QOP\
    \ and privacy\n                       state.  Set the desired QOP to 0 to request\
    \ the\n                       default QOP.  Upon return from this method, this\n\
    \                       object will contain the actual privacy state that\n  \
    \                     was applied to the message by the underlying\n         \
    \              mechanism.\n"
- title: 7.4.8.  unwrap
  contents:
  - "7.4.8.  unwrap\n   public byte[] unwrap(byte[] inBuf, int offset, int len,\n\
    \                        MessageProp msgProp) throws GSSException\n   Used by\
    \ the peer application to process tokens generated with the\n   wrap call.  The\
    \ method will return the message supplied in the peer\n   application to the wrap\
    \ call, verifying the embedded MIC.\n   The MessageProp object is instantiated\
    \ by the application and is used\n   by the underlying mechanism to return information\
    \ to the caller such\n   as the QOP, whether confidentiality was applied to the\
    \ message, and\n   other supplementary message state information.\n   Since some\
    \ application-level protocols may wish to use tokens emitted\n   by wrap to provide\
    \ \"secure framing\", implementations SHOULD support\n   the wrapping and unwrapping\
    \ of zero-length messages.\n   Parameters:\n   inBuf               GSS-API wrap\
    \ token received from peer.\n   offset              The offset within the inBuf\
    \ where the token\n                       begins.\n   len                 The\
    \ length of the token within the inBuf\n                       (starting at the\
    \ offset).\n   msgProp             Upon return from the method, this object will\n\
    \                       contain the applied QOP, the privacy state of the\n  \
    \                     message, and supplementary information, described\n    \
    \                   in Section 5.12.3, stating whether the token was\n       \
    \                a duplicate, old, out of sequence, or arriving\n            \
    \           after a gap.\n"
- title: 7.4.9.  getMIC
  contents:
  - "7.4.9.  getMIC\n   public byte[] getMIC(byte[] inMsg, int offset, int len,\n\
    \                        MessageProp msgProp) throws GSSException\n   Returns\
    \ a token containing a cryptographic MIC for the supplied\n   message for transfer\
    \ to the peer application.  Unlike wrap, which\n   encapsulates the user message\
    \ in the returned token, only the message\n   MIC is returned in the output token.\n\
    \   Note that privacy can only be applied through the wrap call.\n   Since some\
    \ application-level protocols may wish to use tokens emitted\n   by getMIC to\
    \ provide \"secure framing\", implementations SHOULD support\n   derivation of\
    \ MICs from zero-length messages.\n   Parameters:\n   inMsg               Message\
    \ over which to generate MIC.\n   offset              The offset within the inMsg\
    \ where the token\n                       begins.\n   len                 The\
    \ length of the token within the inMsg\n                       (starting at the\
    \ offset).\n   msgProp             Instance of MessageProp that is used by the\n\
    \                       application to set the desired QOP.  Set the\n       \
    \                desired QOP to 0 in msgProp to request the\n                \
    \       default QOP.  Alternatively, pass in \"null\" for\n                  \
    \     msgProp to request default QOP.\n"
- title: 7.4.10.  verifyMIC
  contents:
  - "7.4.10.  verifyMIC\n   public void verifyMIC(byte[] inTok, int tokOffset, int\
    \ tokLen,\n                         byte[] inMsg, int msgOffset, int msgLen,\n\
    \                         MessageProp msgProp) throws GSSException\n   Verifies\
    \ the cryptographic MIC, contained in the token parameter,\n   over the supplied\
    \ message.\n   The MessageProp object is instantiated by the application and is\
    \ used\n   by the underlying mechanism to return information to the caller such\n\
    \   as the QOP indicating the strength of protection that was applied to\n   the\
    \ message and other supplementary message state information.\n   Since some application-level\
    \ protocols may wish to use tokens emitted\n   by getMIC to provide \"secure framing\"\
    , implementations SHOULD support\n   the calculation and verification of MICs\
    \ over zero-length messages.\n   Parameters:\n   inTok               Token generated\
    \ by peer's getMIC method.\n   tokOffset           The offset within the inTok\
    \ where the token\n                       begins.\n   tokLen              The\
    \ length of the token within the inTok\n                       (starting at the\
    \ offset).\n   inMsg               Application message over which to verify the\n\
    \                       cryptographic MIC.\n   msgOffset           The offset\
    \ within the inMsg where the message\n                       begins.\n   msgLen\
    \              The length of the message within the inMsg\n                  \
    \     (starting at the offset).\n   msgProp             Upon return from the method,\
    \ this object will\n                       contain the applied QOP and supplementary\n\
    \                       information, described in Section 5.12.3, stating\n  \
    \                     whether the token was a duplicate, old, out of\n       \
    \                sequence, or arriving after a gap.  The\n                   \
    \    confidentiality state will be set to \"false\".\n"
- title: 7.4.11.  export
  contents:
  - "7.4.11.  export\n   public byte[] export() throws GSSException\n   Provided to\
    \ support the sharing of work between multiple processes.\n   This routine will\
    \ typically be used by the context acceptor, in an\n   application where a single\
    \ process receives incoming connection\n   requests and accepts security contexts\
    \ over them, then passes the\n   established context to one or more other processes\
    \ for message\n   exchange.\n   This method deactivates the security context and\
    \ creates an inter-\n   process token that, when passed to the byte array constructor\
    \ of the\n   GSSContext interface in another process, will re-activate the context\n\
    \   in the second process.  Only a single instantiation of a given\n   context\
    \ may be active at any one time; a subsequent attempt by a\n   context exporter\
    \ to access the exported security context will fail.\n   The implementation MAY\
    \ constrain the set of processes by which the\n   inter-process token may be imported,\
    \ either as a function of local\n   security policy or as a result of implementation\
    \ decisions.  For\n   example, some implementations may constrain contexts to\
    \ be passed\n   only between processes that run under the same account, or which\
    \ are\n   part of the same process group.\n   The inter-process token MAY contain\
    \ security-sensitive information\n   (for example, cryptographic keys).  While\
    \ mechanisms are encouraged\n   either to avoid placing such sensitive information\
    \ within inter-\n   process tokens or to encrypt the token before returning it\
    \ to the\n   application, in a typical GSS-API implementation, this may not be\n\
    \   possible.  Thus, the application MUST take care to protect the inter-\n  \
    \ process token and ensure that any process to which the token is\n   transferred\
    \ is trustworthy.\n"
- title: 7.4.12.  requestMutualAuth
  contents:
  - "7.4.12.  requestMutualAuth\n   public void requestMutualAuth(boolean state) throws\
    \ GSSException\n   Sets the request state of the mutual authentication flag for\
    \ the\n   context.  This method is only valid before the context creation\n  \
    \ process begins and only for the initiator.\n   Parameters:\n   state       \
    \        Boolean representing if mutual authentication\n                     \
    \  should be requested during context establishment.\n"
- title: 7.4.13.  requestReplayDet
  contents:
  - "7.4.13.  requestReplayDet\n   public void requestReplayDet(boolean state) throws\
    \ GSSException\n   Sets the request state of the replay detection service for\
    \ the\n   context.  This method is only valid before the context creation\n  \
    \ process begins and only for the initiator.\n   Parameters:\n   state       \
    \        Boolean representing if replay detection is\n                       desired\
    \ over the established context.\n"
- title: 7.4.14.  requestSequenceDet
  contents:
  - "7.4.14.  requestSequenceDet\n   public void requestSequenceDet(boolean state)\
    \ throws GSSException\n   Sets the request state for the sequence-checking service\
    \ of the\n   context.  This method is only valid before the context creation\n\
    \   process begins and only for the initiator.\n   Parameters:\n   state     \
    \          Boolean representing if sequence detection is\n                   \
    \    desired over the established context.\n"
- title: 7.4.15.  requestCredDeleg
  contents:
  - "7.4.15.  requestCredDeleg\n   public void requestCredDeleg(boolean state) throws\
    \ GSSException\n   Sets the request state for the credential delegation flag for\
    \ the\n   context.  This method is only valid before the context creation\n  \
    \ process begins and only for the initiator.\n   Parameters:\n   state       \
    \        Boolean representing if credential delegation is\n                  \
    \     desired.\n"
- title: 7.4.16.  requestAnonymity
  contents:
  - "7.4.16.  requestAnonymity\n   public void requestAnonymity(boolean state) throws\
    \ GSSException\n   Requests anonymous support over the context.  This method is\
    \ only\n   valid before the context creation process begins and only for the\n\
    \   initiator.\n   Parameters:\n   state               Boolean representing if\
    \ anonymity support is\n                       requested.\n"
- title: 7.4.17.  requestConf
  contents:
  - "7.4.17.  requestConf\n   public void requestConf(boolean state) throws GSSException\n\
    \   Requests that confidentiality service be available over the context.\n   This\
    \ method is only valid before the context creation process begins\n   and only\
    \ for the initiator.\n   Parameters:\n   state               Boolean indicating\
    \ if confidentiality services\n                       are to be requested for\
    \ the context.\n"
- title: 7.4.18.  requestInteg
  contents:
  - "7.4.18.  requestInteg\n   public void requestInteg(boolean state) throws GSSException\n\
    \   Requests that integrity services be available over the context.  This\n  \
    \ method is only valid before the context creation process begins and\n   only\
    \ for the initiator.\n   Parameters:\n   state               Boolean indicating\
    \ if integrity services are to\n                       be requested for the context.\n"
- title: 7.4.19.  requestLifetime
  contents:
  - "7.4.19.  requestLifetime\n   public void requestLifetime(int lifetime) throws\
    \ GSSException\n   Sets the desired lifetime for the context in seconds.  This\
    \ method is\n   only valid before the context creation process begins and only\
    \ for\n   the initiator.  Use GSSContext.INDEFINITE_LIFETIME and\n   GSSContext.DEFAULT_LIFETIME\
    \ to request indefinite or default context\n   lifetime.\n   Parameters:\n   lifetime\
    \            The desired context lifetime in seconds.\n"
- title: 7.4.20.  setChannelBinding
  contents:
  - "7.4.20.  setChannelBinding\n   public void setChannelBinding(ChannelBinding cb)\
    \ throws GSSException\n   Sets the channel bindings to be used during context\
    \ establishment.\n   This method is only valid before the context creation process\
    \ begins.\n   Parameters:\n   cb                  Channel bindings to be used.\n"
- title: 7.4.21.  getCredDelegState
  contents:
  - "7.4.21.  getCredDelegState\n   public boolean getCredDelegState()\n   Returns\
    \ the state of the delegated credentials for the context.  When\n   issued before\
    \ context establishment is completed or when the\n   isProtReady method returns\
    \ \"false\", it returns the desired state;\n   otherwise, it will indicate the\
    \ actual state over the established\n   context.\n"
- title: 7.4.22.  getMutualAuthState
  contents:
  - "7.4.22.  getMutualAuthState\n   public boolean getMutualAuthState()\n   Returns\
    \ the state of the mutual authentication option for the\n   context.  When issued\
    \ before context establishment completes or when\n   the isProtReady method returns\
    \ \"false\", it returns the desired state;\n   otherwise, it will indicate the\
    \ actual state over the established\n   context.\n"
- title: 7.4.23.  getReplayDetState
  contents:
  - "7.4.23.  getReplayDetState\n   public boolean getReplayDetState()\n   Returns\
    \ the state of the replay detection option for the context.\n   When issued before\
    \ context establishment completes or when the\n   isProtReady method returns \"\
    false\", it returns the desired state;\n   otherwise, it will indicate the actual\
    \ state over the established\n   context.\n"
- title: 7.4.24.  getSequenceDetState
  contents:
  - "7.4.24.  getSequenceDetState\n   public boolean getSequenceDetState()\n   Returns\
    \ the state of the sequence detection option for the context.\n   When issued\
    \ before context establishment completes or when the\n   isProtReady method returns\
    \ \"false\", it returns the desired state;\n   otherwise, it will indicate the\
    \ actual state over the established\n   context.\n"
- title: 7.4.25.  getAnonymityState
  contents:
  - "7.4.25.  getAnonymityState\n   public boolean getAnonymityState()\n   Returns\
    \ \"true\" if this is an anonymous context.  When issued before\n   context establishment\
    \ completes or when the isProtReady method\n   returns \"false\", it returns the\
    \ desired state; otherwise, it will\n   indicate the actual state over the established\
    \ context.\n"
- title: 7.4.26.  isTransferable
  contents:
  - "7.4.26.  isTransferable\n   public boolean isTransferable() throws GSSException\n\
    \   Returns \"true\" if the context is transferable to other processes\n   through\
    \ the use of the export method.  This call is only valid on\n   fully established\
    \ contexts.\n"
- title: 7.4.27.  isProtReady
  contents:
  - "7.4.27.  isProtReady\n   public boolean isProtReady()\n   Returns \"true\" if\
    \ the per-message operations can be applied over the\n   context.  Some mechanisms\
    \ may allow the usage of per-message\n   operations before the context is fully\
    \ established.  This will also\n   indicate that the get methods will return actual\
    \ context state\n   characteristics instead of the desired ones.\n"
- title: 7.4.28.  getConfState
  contents:
  - "7.4.28.  getConfState\n   public boolean getConfState()\n   Returns the confidentiality\
    \ service state over the context.  When\n   issued before context establishment\
    \ completes or when the isProtReady\n   method returns \"false\", it returns the\
    \ desired state; otherwise, it\n   will indicate the actual state over the established\
    \ context.\n"
- title: 7.4.29.  getIntegState
  contents:
  - "7.4.29.  getIntegState\n   public boolean getIntegState()\n   Returns the integrity\
    \ service state over the context.  When issued\n   before context establishment\
    \ completes or when the isProtReady method\n   returns \"false\", it returns the\
    \ desired state; otherwise, it will\n   indicate the actual state over the established\
    \ context.\n"
- title: 7.4.30.  getLifetime
  contents:
  - "7.4.30.  getLifetime\n   public int getLifetime()\n   Returns the context lifetime\
    \ in seconds.  When issued before context\n   establishment completes or when\
    \ the isProtReady method returns\n   \"false\", it returns the desired lifetime;\
    \ otherwise, it will indicate\n   the remaining lifetime for the context.\n"
- title: 7.4.31.  getSrcName
  contents:
  - "7.4.31.  getSrcName\n   public GSSName getSrcName() throws GSSException\n   Returns\
    \ the name of the context initiator.  This call is valid only\n   after the context\
    \ is fully established or the isProtReady method\n   returns \"true\".  It is\
    \ guaranteed to return an MN.\n"
- title: 7.4.32.  getTargName
  contents:
  - "7.4.32.  getTargName\n   public GSSName getTargName() throws GSSException\n \
    \  Returns the name of the context target (acceptor).  This call is\n   valid\
    \ only after the context is fully established or the isProtReady\n   method returns\
    \ \"true\".  It is guaranteed to return an MN.\n"
- title: 7.4.33.  getMech
  contents:
  - "7.4.33.  getMech\n   public Oid getMech() throws GSSException\n   Returns the\
    \ mechanism OID for this context.  This method MAY be\n   called before the context\
    \ is fully established, but the mechanism\n   returned MAY change on successive\
    \ calls in a negotiated mechanism\n   case.\n"
- title: 7.4.34.  getDelegCred
  contents:
  - "7.4.34.  getDelegCred\n   public GSSCredential getDelegCred() throws GSSException\n\
    \   Returns the delegated credential object on the acceptor's side.  To\n   check\
    \ for availability of delegated credentials, call\n   getDelegCredState.  This\
    \ call is only valid on fully established\n   contexts.\n"
- title: 7.4.35.  isInitiator
  contents:
  - "7.4.35.  isInitiator\n   public boolean isInitiator() throws GSSException\n \
    \  Returns \"true\" if this is the initiator of the context.  This call is\n \
    \  only valid after the context creation process has started.\n"
- title: 7.4.36.  Example Code
  contents:
  - "7.4.36.  Example Code\n   The example code presented below demonstrates the usage\
    \ of the\n   GSSContext interface for the initiating peer.  Different operations\n\
    \   on the GSSContext object are presented, including: object\n   instantiation,\
    \ setting of desired flags, context establishment, query\n   of actual context\
    \ flags, per-message operations on application data,\n   and finally context deletion.\n\
    \   <CODE BEGINS>\n   GSSManager mgr = GSSManager.getInstance();\n   // start\
    \ by creating the name for a service entity\n   GSSName targetName = mgr.createName(\"\
    service@host\",\n                        GSSName.NT_HOSTBASED_SERVICE);\n   //\
    \ create a context using default credentials for the above entity\n   // and the\
    \ implementation-specific default mechanism\n   GSSContext context = mgr.createContext(targetName,\n\
    \                   null,   /* default mechanism */\n                   null,\
    \   /* default credentials */\n                   GSSContext.INDEFINITE_LIFETIME);\n\
    \   // set desired context options - all others are \"false\" by default\n   context.requestConf(true);\n\
    \   context.requestMutualAuth(true);\n   context.requestReplayDet(true);\n   context.requestSequenceDet(true);\n\
    \   // establish a context between peers - using byte arrays\n   byte[] inTok\
    \ = new byte[0];\n   try {\n       do {\n           byte[] outTok = context.initSecContext(inTok,\
    \ 0,\n                                                 inTok.length);\n      \
    \     // send the token if present\n           if (outTok != null)\n         \
    \      sendToken(outTok);\n           // check if we should expect more tokens\n\
    \           if (context.isEstablished())\n               break;\n           //\
    \ another token expected from peer\n           inTok = readToken();\n       }\
    \ while (true);\n   } catch (GSSException e) {\n       print(\"GSSAPI error: \"\
    \ + e.getMessage());\n       // If the exception contains an output token,\n \
    \      // it should be sent to the acceptor.\n       byte[] outTok = e.getOutputToken();\n\
    \       if (outTok != null) {\n           sendToken(outTok);\n       }\n     \
    \  return;\n   }\n   // display context information\n   print(\"Remaining lifetime\
    \ in seconds = \" + context.getLifetime());\n   print(\"Context mechanism = \"\
    \ + context.getMech().toString());\n   print(\"Initiator = \" + context.getSrcName().toString());\n\
    \   print(\"Acceptor = \" + context.getTargName().toString());\n   if (context.getConfState())\n\
    \       print(\"Confidentiality security service available\");\n   if (context.getIntegState())\n\
    \       print(\"Integrity security service available\");\n   // perform wrap on\
    \ an application-supplied message, appMsg,\n   // using QOP = 0, and requesting\
    \ privacy service\n   byte[] appMsg ...\n   MessageProp mProp = new MessageProp(0,\
    \ true);\n   byte[] tok = context.wrap(appMsg, 0, appMsg.length, mProp);\n   if\
    \ (mProp.getPrivacy())\n       print(\"Message protected with privacy.\");\n \
    \  sendToken(tok);\n   // release the local end of the context\n   context.dispose();\n\
    \   <CODE ENDS>\n"
- title: 7.5.  public class MessageProp
  contents:
  - "7.5.  public class MessageProp\n   This is a utility class used within the per-message\
    \ GSSContext\n   methods to convey per-message properties.\n   When used with\
    \ the GSSContext interface's wrap and getMIC methods, an\n   instance of this\
    \ class is used to indicate the desired QOP and to\n   request if confidentiality\
    \ services are to be applied to caller-\n   supplied data (wrap only).  To request\
    \ default QOP, the value of 0\n   should be used for QOP.  A QOP is an integer\
    \ value defined by an\n   mechanism.\n   When used with the unwrap and verifyMIC\
    \ methods of the GSSContext\n   interface, an instance of this class will be used\
    \ to indicate the\n   applied QOP and confidentiality services over the supplied\
    \ message.\n   In the case of verifyMIC, the confidentiality state will always\
    \ be\n   \"false\".  Upon return from these methods, this object will also\n \
    \  contain any supplementary status values applicable to the processed\n   token.\
    \  The supplementary status values can indicate old tokens, out\n   of sequence\
    \ tokens, gap tokens, or duplicate tokens.\n"
- title: 7.5.1.  Constructors
  contents:
  - "7.5.1.  Constructors\n   public MessageProp(boolean privState)\n   Constructor\
    \ that sets QOP to 0 indicating that the default QOP is\n   requested.\n   Parameters:\n\
    \   privState           The desired privacy state. \"true\" for privacy and\n\
    \                       \"false\" for integrity only.\n   public MessageProp(int\
    \ qop, boolean privState)\n   Constructor that sets the values for the QOP and\
    \ privacy state.\n   Parameters:\n   qop                 The desired QOP.  Use\
    \ 0 to request a default QOP.\n   privState           The desired privacy state.\
    \ \"true\" for privacy and\n                       \"false\" for integrity only.\n"
- title: 7.5.2.  getQOP
  contents:
  - "7.5.2.  getQOP\n   public int getQOP()\n   Retrieves the QOP value.\n"
- title: 7.5.3.  getPrivacy
  contents:
  - "7.5.3.  getPrivacy\n   public boolean getPrivacy()\n   Retrieves the privacy\
    \ state.\n"
- title: 7.5.4.  getMinorStatus
  contents:
  - "7.5.4.  getMinorStatus\n   public int getMinorStatus()\n   Retrieves the minor\
    \ status that the underlying mechanism might have\n   set.\n"
- title: 7.5.5.  getMinorString
  contents:
  - "7.5.5.  getMinorString\n   public String getMinorString()\n   Returns a string\
    \ explaining the mechanism-specific error code. \"null\"\n   will be returned\
    \ when no mechanism error code has been set.\n"
- title: 7.5.6.  setQOP
  contents:
  - "7.5.6.  setQOP\n   public void setQOP(int qopVal)\n   Sets the QOP value.\n \
    \  Parameters:\n   qopVal              The QOP value to be set.  Use 0 to request\
    \ a\n                       default QOP value.\n"
- title: 7.5.7.  setPrivacy
  contents:
  - "7.5.7.  setPrivacy\n   public void setPrivacy(boolean privState)\n   Sets the\
    \ privacy state.\n   Parameters:\n   privState           The privacy state to\
    \ set.\n"
- title: 7.5.8.  isDuplicateToken
  contents:
  - "7.5.8.  isDuplicateToken\n   public boolean isDuplicateToken()\n   Returns \"\
    true\" if this is a duplicate of an earlier token.\n"
- title: 7.5.9.  isOldToken
  contents:
  - "7.5.9.  isOldToken\n   public boolean isOldToken()\n   Returns \"true\" if the\
    \ token's validity period has expired.\n"
- title: 7.5.10.  isUnseqToken
  contents:
  - "7.5.10.  isUnseqToken\n   public boolean isUnseqToken()\n   Returns \"true\"\
    \ if a later token has already been processed.\n"
- title: 7.5.11.  isGapToken
  contents:
  - "7.5.11.  isGapToken\n   public boolean isGapToken()\n   Returns \"true\" if an\
    \ expected per-message token was not received.\n"
- title: 7.5.12.  setSupplementaryStates
  contents:
  - "7.5.12.  setSupplementaryStates\n   public void setSupplementaryStates(boolean\
    \ duplicate,\n                  boolean old, boolean unseq, boolean gap,\n   \
    \               int minorStatus, String minorString)\n   This method sets the\
    \ state for the supplementary information flags\n   and the minor status in MessageProp.\
    \  It is not used by the\n   application but by the GSS implementation to return\
    \ this information\n   to the caller of a per-message context method.\n   Parameters:\n\
    \   duplicate           \"true\" if the token was a duplicate of an earlier\n\
    \                       token; otherwise, \"false\".\n   old                 \"\
    true\" if the token's validity period has\n                       expired; otherwise,\
    \ \"false\".\n   unseq               \"true\" if a later token has already been\n\
    \                       processed; otherwise, \"false\".\n   gap             \
    \    \"true\" if one or more predecessor tokens have not\n                   \
    \    yet been successfully processed; otherwise,\n                       \"false\"\
    .\n   minorStatus         The integer minor status code that the underlying\n\
    \                       mechanism wants to set.\n   minorString         The textual\
    \ representation of the minorStatus\n                       value.\n"
- title: 7.6.  public class ChannelBinding
  contents:
  - "7.6.  public class ChannelBinding\n   The GSS-API accommodates the concept of\
    \ caller-provided channel-\n   binding information.  Channel bindings are used\
    \ to strengthen the\n   quality with which peer entity authentication is provided\
    \ during\n   context establishment.  They enable the GSS-API callers to bind the\n\
    \   establishment of the security context to relevant characteristics\n   like\
    \ addresses or to application-specific data.\n   The caller initiating the security\
    \ context MUST determine the\n   appropriate channel-binding values to set in\
    \ the GSSContext object.\n   The acceptor MUST provide an identical binding in\
    \ order to validate\n   that received tokens possess correct channel-related characteristics.\n\
    \   Use of channel bindings is OPTIONAL in GSS-API.  Since channel-\n   binding\
    \ information may be transmitted in context establishment\n   tokens, applications\
    \ SHOULD therefore not use confidential data as\n   channel-binding components.\n"
- title: 7.6.1.  Constructors
  contents:
  - "7.6.1.  Constructors\n   public ChannelBinding(InetAddress initAddr, InetAddress\
    \ acceptAddr,\n                         byte[] appData)\n   Create a ChannelBinding\
    \ object with user-supplied address information\n   and data. \"null\" values\
    \ can be used for any fields that the\n   application does not want to specify.\n\
    \   Parameters:\n   initAddr            The address of the context initiator.\
    \  The \"null\"\n                       value can be supplied to indicate that\
    \ the\n                       application does not want to set this value.\n \
    \  acceptAddr          The address of the context acceptor.  The \"null\"\n  \
    \                     value can be supplied to indicate that the\n           \
    \            application does not want to set this value.\n   appData        \
    \     Application-supplied data to be used as part of\n                      \
    \ the channel bindings.  The \"null\" value can be\n                       supplied\
    \ to indicate that the application does\n                       not want to set\
    \ this value.\n   public ChannelBinding(byte[] appData)\n   Creates a ChannelBinding\
    \ object without any addressing information.\n   Parameters:\n   appData     \
    \        Application-supplied data to be used as part of\n                   \
    \    the channel bindings.\n"
- title: 7.6.2.  getInitiatorAddress
  contents:
  - "7.6.2.  getInitiatorAddress\n   public InetAddress getInitiatorAddress()\n  \
    \ Returns the initiator's address for this channel binding. \"null\" is\n   returned\
    \ if the address has not been set.\n"
- title: 7.6.3.  getAcceptorAddress
  contents:
  - "7.6.3.  getAcceptorAddress\n   public InetAddress getAcceptorAddress()\n   Returns\
    \ the acceptor's address for this channel binding. \"null\" is\n   returned if\
    \ the address has not been set.\n"
- title: 7.6.4.  getApplicationData
  contents:
  - "7.6.4.  getApplicationData\n   public byte[] getApplicationData()\n   Returns\
    \ application data being used as part of the ChannelBinding.\n   \"null\" is returned\
    \ if no application data has been specified for the\n   channel binding.\n"
- title: 7.6.5.  equals
  contents:
  - "7.6.5.  equals\n   public boolean equals(Object obj)\n   Returns \"true\" if\
    \ two channel bindings match.  (Note that the Java\n   language specification\
    \ requires that two objects that are equal\n   according to the equals(Object)\
    \ method MUST return the same integer\n   result when the hashCode() method is\
    \ called on them.)\n   Parameters:\n   obj                 Another channel binding\
    \ with which to compare.\n"
- title: 7.7.  public class Oid
  contents:
  - "7.7.  public class Oid\n   This class represents Universal OIDs and their associated\
    \ operations.\n   OIDs are hierarchically globally interpretable identifiers used\n\
    \   within the GSS-API framework to identify mechanisms and name formats.\n  \
    \ The structure and encoding of OIDs is defined in ISOIEC-8824\n   [ISOIEC-8824]\
    \ and ISOIEC-8825 [ISOIEC-8825].  For example, the OID\n   representation of the\
    \ Kerberos v5 mechanism is\n   \"1.2.840.113554.1.2.2\".\n   The GSSName name\
    \ class contains public static Oid objects\n   representing the standard name\
    \ types defined in GSS-API.\n"
- title: 7.7.1.  Constructors
  contents:
  - "7.7.1.  Constructors\n   public Oid(String strOid) throws GSSException\n   Creates\
    \ an Oid object from a string representation of its integer\n   components (e.g.,\
    \ \"1.2.840.113554.1.2.2\").\n   Parameters:\n   strOid              The string\
    \ representation for the OID.\n   public Oid(InputStream derOid) throws GSSException\n\
    \   Creates an Oid object from its DER encoding.  This refers to the full\n  \
    \ encoding including tag and length.  The structure and encoding of\n   OIDs is\
    \ defined in ISOIEC-8824 [ISOIEC-8824] and ISOIEC-8825\n   [ISOIEC-8825].  This\
    \ method is identical in functionality to its byte\n   array counterpart.\n  \
    \ Parameters:\n   derOid              Stream containing the DER-encoded OID.\n\
    \   public Oid(byte[] derOid) throws GSSException\n   Creates an Oid object from\
    \ its DER encoding.  This refers to the full\n   encoding including tag and length.\
    \  The structure and encoding of\n   OIDs is defined in ISOIEC-8824 [ISOIEC-8824]\
    \ and ISOIEC-8825\n   [ISOIEC-8825].  This method is identical in functionality\
    \ to its byte\n   array counterpart.\n   Parameters:\n   derOid              Byte\
    \ array storing a DER-encoded OID.\n"
- title: 7.7.2.  toString
  contents:
  - "7.7.2.  toString\n   public String toString()\n   Returns a string representation\
    \ of the OID's integer components in\n   dot-separated notation (e.g., \"1.2.840.113554.1.2.2\"\
    ).\n"
- title: 7.7.3.  equals
  contents:
  - "7.7.3.  equals\n   public boolean equals(Object Obj)\n   Returns \"true\" if\
    \ the two Oid objects represent the same OID value.\n   (Note that the Java language\
    \ specification [JLS] requires that two\n   objects that are equal according to\
    \ the equals(Object) method MUST\n   return the same integer result when the hashCode()\
    \ method is called\n   on them.)\n   Parameters:\n   obj                 Another\
    \ Oid object with which to compare.\n"
- title: 7.7.4.  getDER
  contents:
  - "7.7.4.  getDER\n   public byte[] getDER()\n   Returns the full ASN.1 DER encoding\
    \ for this Oid object, which\n   includes the tag and length.\n"
- title: 7.7.5.  containedIn
  contents:
  - "7.7.5.  containedIn\n   public boolean containedIn(Oid[] oids)\n   A utility\
    \ method to test if an Oid object is contained within the\n   supplied Oid object\
    \ array.\n   Parameters:\n   oids                An array of OIDs to search.\n"
- title: 7.8.  public class GSSException extends Exception
  contents:
  - "7.8.  public class GSSException extends Exception\n   This exception is thrown\
    \ whenever a fatal GSS-API error occurs\n   including mechanism-specific errors.\
    \  It MAY contain both, the major\n   and minor, GSS-API status codes.  The mechanism\
    \ implementors are\n   responsible for setting appropriate minor status codes\
    \ when throwing\n   this exception.  Aside from delivering the numeric error code(s)\
    \ to\n   the caller, this class performs the mapping from their numeric values\n\
    \   to textual representations.  This exception MAY also include an\n   output\
    \ token that SHOULD be sent to the peer.  For example, when an\n   initSecContext\
    \ call fails due to a fatal error, the mechanism MAY\n   define an error token\
    \ that SHOULD be sent to the peer for debugging\n   or informational purposes.\
    \  All Java GSS-API methods are declared\n   throwing this exception.\n   All\
    \ implementations are encouraged to use the Java\n   internationalization techniques\
    \ to provide local translations of the\n   message strings.\n"
- title: 7.8.1.  Static Constants
  contents:
  - "7.8.1.  Static Constants\n   All valid major GSS-API error code values are declared\
    \ as constants\n   in this class.\n   public static final int BAD_BINDINGS\n \
    \  Channel-bindings mismatch error.  The value of this constant is 1.\n   public\
    \ static final int BAD_MECH\n   Unsupported mechanism requested error.  The value\
    \ of this constant is\n   2.\n   public static final int BAD_NAME\n   Invalid\
    \ name provided error.  The value of this constant is 3.\n   public static final\
    \ int BAD_NAMETYPE\n   Name of unsupported type provided error.  The value of\
    \ this constant\n   is 4.\n   public static final int BAD_STATUS\n   Invalid status\
    \ code error - this is the default status value.  The\n   value of this constant\
    \ is 5.\n   public static final int BAD_MIC\n   Token had invalid integrity check\
    \ error.  The value of this constant\n   is 6.\n   public static final int CONTEXT_EXPIRED\n\
    \   Specified security context expired error.  The value of this constant\n  \
    \ is 7.\n   public static final int CREDENTIALS_EXPIRED\n   Expired credentials\
    \ detected error.  The value of this constant is 8.\n   public static final int\
    \ DEFECTIVE_CREDENTIAL\n   Defective credential error.  The value of this constant\
    \ is 9.\n   public static final int DEFECTIVE_TOKEN\n   Defective token error.\
    \  The value of this constant is 10.\n   public static final int FAILURE\n   General\
    \ failure, unspecified at GSS-API level.  The value of this\n   constant is 11.\n\
    \   public static final int NO_CONTEXT\n   Invalid security context error.  The\
    \ value of this constant is 12.\n   public static final int NO_CRED\n   Invalid\
    \ credentials error.  The value of this constant is 13.\n   public static final\
    \ int BAD_QOP\n   Unsupported QOP value error.  The value of this constant is\
    \ 14.\n   public static final int UNAUTHORIZED\n   Operation unauthorized error.\
    \  The value of this constant is 15.\n   public static final int UNAVAILABLE\n\
    \   Operation unavailable error.  The value of this constant is 16.\n   public\
    \ static final int DUPLICATE_ELEMENT\n   Duplicate credential element requested\
    \ error.  The value of this\n   constant is 17.\n   public static final int NAME_NOT_MN\n\
    \   Name contains multi-mechanism elements error.  The value of this\n   constant\
    \ is 18.\n   public static final int DUPLICATE_TOKEN\n   The token was a duplicate\
    \ of an earlier token.  This is contained in\n   an exception only when detected\
    \ during context establishment, in\n   which case it is considered a fatal error.\
    \  (Non-fatal supplementary\n   codes are indicated via the MessageProp object.)\
    \  The value of this\n   constant is 19.\n   public static final int OLD_TOKEN\n\
    \   The token's validity period has expired.  This is contained in an\n   exception\
    \ only when detected during context establishment, in which\n   case it is considered\
    \ a fatal error.  (Non-fatal supplementary codes\n   are indicated via the MessageProp\
    \ object.)  The value of this\n   constant is 20.\n   public static final int\
    \ UNSEQ_TOKEN\n   A later token has already been processed.  This is contained\
    \ in an\n   exception only when detected during context establishment, in which\n\
    \   case it is considered a fatal error.  (Non-fatal supplementary codes\n   are\
    \ indicated via the MessageProp object.)  The value of this\n   constant is 21.\n\
    \   public static final int GAP_TOKEN\n   An expected per-message token was not\
    \ received.  This is contained in\n   an exception only when detected during context\
    \ establishment, in\n   which case it is considered a fatal error.  (Non-fatal\
    \ supplementary\n   codes are indicated via the MessageProp object.)  The value\
    \ of this\n   constant is 22.\n"
- title: 7.8.2.  Constructors
  contents:
  - "7.8.2.  Constructors\n   public GSSException(int majorCode)\n   Creates a GSSException\
    \ object with a specified major code.\n   Calling this constructor is equivalent\
    \ to calling\n   GSSException(majorCode, null, 0, null, null).\n   public GSSException(int\
    \ majorCode, int minorCode, String minorString)\n   Creates a GSSException object\
    \ with the specified major code, minor\n   code, and minor code textual explanation.\
    \  This constructor is to be\n   used when the exception is originating from the\
    \ security mechanism.\n   It allows to specify the GSS code and the mechanism\
    \ code.\n   Calling this constructor is equivalent to calling\n   GSSException(majorCode,\
    \ null, minorCode, minorString, null).\n   public GSSException(int majorCode,\
    \ String majorString,\n                       int minorCode, String minorString,\n\
    \                       byte[] outputToken)\n   Creates a GSSException object\
    \ with the specified major code, major\n   code textual explanation, minor code,\
    \ minor code textual explanation,\n   and an output token.  This is a general-purpose\
    \ constructor that can\n   be used to create any type of GSSException.\n   Parameters:\n\
    \   majorCode           The GSS error code causing this exception to be\n    \
    \                   thrown.\n   majorString         The textual explanation of\
    \ the GSS error code.\n                       If null is provided, a default explanation\
    \ that\n                       matches the majorCode will be set.\n   minorCode\
    \           The mechanism error code causing this exception\n                \
    \       to be thrown.  Can be 0 if no mechanism error\n                      \
    \ code is available.\n   minorString         The textual explanation of the mechanism\
    \ error\n                       code.  Can be null if no textual explanation is\n\
    \                       available.\n   outputToken         The output token that\
    \ SHOULD be sent to the peer.\n                       Can be null if no such token\
    \ is available.  It\n                       MUST NOT be an empty array.  When\
    \ provided, the\n                       array will be cloned to protect against\n\
    \                       subsequent modifications.\n"
- title: 7.8.3.  getMajor
  contents:
  - "7.8.3.  getMajor\n   public int getMajor()\n   Returns the major code representing\
    \ the GSS error code that caused\n   this exception to be thrown.\n"
- title: 7.8.4.  getMinor
  contents:
  - "7.8.4.  getMinor\n   public int getMinor()\n   Returns the mechanism error code\
    \ that caused this exception.  The\n   minor code is set by the underlying mechanism.\
    \  The value of 0\n   indicates that the mechanism error code is not set.\n"
- title: 7.8.5.  getMajorString
  contents:
  - "7.8.5.  getMajorString\n   public String getMajorString()\n   Returns a string\
    \ explaining the GSS major error code causing this\n   exception to be thrown.\n"
- title: 7.8.6.  getMinorString
  contents:
  - "7.8.6.  getMinorString\n   public String getMinorString()\n   Returns a string\
    \ explaining the mechanism-specific error code. \"null\"\n   will be returned\
    \ when no string explaining the mechanism error code\n   has been set.\n"
- title: 7.8.7.  getOutputToken
  contents:
  - "7.8.7.  getOutputToken\n   public byte[] getOutputToken\n   Returns the output\
    \ token in a new byte array.\n   If the method (for example, GSSContext#initSecContext)\
    \ that throws\n   this GSSException needs to generate an output token that SHOULD\
    \ be\n   sent to the peer, that token will be stored in this GSSException and\n\
    \   can be retrieved with this method.\n   The return value MUST be null if no\
    \ such token is generated.  It MUST\n   NOT be an empty byte array.\n"
- title: 7.8.8.  setMinor
  contents:
  - "7.8.8.  setMinor\n   public void setMinor(int minorCode, String message)\n  \
    \ Used internally by the GSS-API implementation and the underlying\n   mechanisms\
    \ to set the minor code and its textual representation.\n   Parameters:\n   minorCode\
    \           The mechanism-specific error code.\n   message             A textual\
    \ explanation of the mechanism error\n                       code.\n"
- title: 7.8.9.  toString
  contents:
  - "7.8.9.  toString\n   public String toString()\n   Returns a textual representation\
    \ of both the major and minor status\n   codes.\n"
- title: 7.8.10.  getMessage
  contents:
  - "7.8.10.  getMessage\n   public String getMessage()\n   Returns a detailed message\
    \ of this exception.  Overrides\n   Throwable.getMessage.  It is customary in\
    \ Java to use this method to\n   obtain exception information.\n"
- title: 8.  Sample Applications
  contents:
  - '8.  Sample Applications

    '
- title: 8.1.  Simple GSS Context Initiator
  contents:
  - "8.1.  Simple GSS Context Initiator\n   <CODE BEGINS>\n   import org.ietf.jgss.*;\n\
    \   /**\n    * This is a partial sketch for a simple client program that acts\n\
    \    * as a GSS context initiator.  It illustrates how to use the Java\n    *\
    \ bindings for the GSS-API specified in RFC 8353.\n    *\n    *\n    * This code\
    \ sketch assumes the existence of a GSS-API\n    * implementation that supports\
    \ the mechanism that it will need\n    * and is present as a library package (org.ietf.jgss)\
    \ either as\n    * part of the standard JRE or in the CLASSPATH the application\n\
    \    * specifies.\n    */\n    public class SimpleClient {\n        private String\
    \ serviceName; // name of peer (i.e., server)\n        private GSSCredential clientCred\
    \ = null;\n        private GSSContext context = null;\n        private Oid mech;\
    \ // underlying mechanism to use\n        private GSSManager mgr = GSSManager.getInstance();\n\
    \        ...\n        ...\n        private void clientActions() {\n          \
    \ initializeGSS();\n           establishContext();\n           doCommunication();\n\
    \        }\n       /**\n        * Acquire credentials for the client.\n      \
    \  */\n       private void initializeGSS() {\n           try {\n             \
    \  clientCred = mgr.createCredential(null /*default princ*/,\n               \
    \    GSSCredential.INDEFINITE_LIFETIME /* max lifetime */,\n                 \
    \  mech /* mechanism to use */,\n                   GSSCredential.INITIATE_ONLY\
    \ /* init context */);\n               print(\"GSSCredential created for \" +\n\
    \                     clientCred.getName().toString());\n               print(\"\
    Credential lifetime (sec)=\" +\n                     clientCred.getRemainingLifetime());\n\
    \           } catch (GSSException e) {\n               print(\"GSS-API error in\
    \ credential acquisition: \"\n                     + e.getMessage());\n      \
    \         ...\n               ...\n           }\n           ...\n           ...\n\
    \       }\n       /**\n        * Does the security context establishment with\
    \ the\n        * server.\n        */\n       private void establishContext() {\n\
    \           byte[] inToken = new byte[0];\n           byte[] outToken = null;\n\
    \           try {\n               GSSName peer = mgr.createName(serviceName,\n\
    \                                     GSSName.NT_HOSTBASED_SERVICE);\n       \
    \        context = mgr.createContext(peer, mech, clientCred,\n               \
    \       GSSContext.INDEFINITE_LIFETIME/*lifetime*/);\n               // Will need\
    \ to support confidentiality\n               context.requestConf(true);\n    \
    \           while (!context.isEstablished()) {\n                   outToken =\
    \ context.initSecContext(inToken, 0,\n                                       \
    \            inToken.length);\n                   if (outToken != null)\n    \
    \                   writeGSSToken(outToken);\n                   if (!context.isEstablished())\n\
    \                       inToken = readGSSToken();\n               }\n        \
    \       peer = context.getTargName();\n               print(\"Security context\
    \ established with \" + peer +\n                     \" using underlying mechanism\
    \ \" + mech.toString());\n           } catch (GSSException e) {\n            \
    \    print(\"GSS-API error during context establishment: \"\n                \
    \      + e.getMessage());\n                // If the exception contains an output\
    \ token,\n                // it should be sent to the acceptor.\n            \
    \    byte[] outTok = e.getOutputToken();\n                if (outTok != null)\
    \ {\n                    writeGSSToken(outTok);\n                }\n         \
    \       ...\n                ...\n           }\n           ...\n           ...\n\
    \       }\n       /**\n        * Sends some data to the server and reads back\
    \ the\n        * response.\n        */\n       private void doCommunication()\
    \  {\n           byte[] inToken = null;\n           byte[] outToken = null;\n\
    \           byte[] buffer;\n           // Container for multiple input-output\
    \ arguments to and\n           // from the per-message routines (e.g., wrap/unwrap).\n\
    \           MessageProp messgInfo = new MessageProp(true);\n           try {\n\
    \               /*\n                * Now send some bytes to the server to be\n\
    \                * processed.  They will be integrity protected\n            \
    \    * but not encrypted for privacy.\n                */\n               buffer\
    \ = readFromFile();\n               // Set privacy to \"false\" and use the default\
    \ QOP\n               messgInfo.setPrivacy(false);\n               outToken =\
    \ context.wrap(buffer, 0, buffer.length,\n                                   \
    \    messgInfo);\n               writeGSSToken(outToken);\n               /*\n\
    \                * Now read the response from the server.\n                */\n\
    \               inToken = readGSSToken();\n               buffer = context.unwrap(inToken,\
    \ 0,\n                             inToken.length, messgInfo);\n             \
    \  // All ok if no exception was thrown!\n               GSSName peer = context.getTargName();\n\
    \               print(\"Message from \"  + peer.toString()\n                 \
    \    + \" arrived.\");\n               print(\"Was it encrypted? \"  +\n     \
    \                messgInfo.getPrivacy());\n               print(\"Duplicate Token?\
    \ \"   +\n                     messgInfo.isDuplicateToken());\n              \
    \ print(\"Old Token? \"         +\n                     messgInfo.isOldToken());\n\
    \               print(\"Unsequenced Token? \" +\n                     messgInfo.isUnseqToken());\n\
    \               print(\"Gap Token? \"         +\n                     messgInfo.isGapToken());\n\
    \               ...\n               ...\n           } catch (GSSException e) {\n\
    \               print(\"GSS-API error in per-message calls: \"\n             \
    \        + e.getMessage());\n               ...\n               ...\n        \
    \   }\n           ...\n           ...\n       } // end of doCommunication method\n\
    \       ...\n       ...\n   } // end of class SimpleClient\n   <CODE ENDS>\n"
- title: 8.2.  Simple GSS Context Acceptor
  contents:
  - "8.2.  Simple GSS Context Acceptor\n   <CODE BEGINS>\n   import org.ietf.jgss.*;\n\
    \   /**\n    * This is a partial sketch for a simple server program that acts\n\
    \    * as a GSS context acceptor.  It illustrates how to use the Java\n    * bindings\
    \ for the GSS-API specified in\n    * Generic Security Service API Version 2 :\
    \ Java Bindings.\n    *\n    * This code sketch assumes the existence of a GSS-API\n\
    \    * implementation that supports the mechanisms that it will need\n    * and\
    \ is present as a library package (org.ietf.jgss) either as\n    * part of the\
    \ standard JRE or in the CLASSPATH the application\n    * specifies.\n    */\n\
    \   import org.ietf.jgss.*;\n   public class SimpleServer {\n       private String\
    \ serviceName;\n       private GSSName name;\n       private GSSCredential cred;\n\
    \       private GSSManager mgr;\n       ...\n       ...\n       /**\n        *\
    \ Wait for client connections, establish security contexts,\n        * and provide\
    \ service.\n        */\n       private void loop() throws Exception {\n      \
    \     ...\n           ...\n           mgr = GSSManager.getInstance();\n      \
    \     name = mgr.createName(serviceName,\n                     GSSName.NT_HOSTBASED_SERVICE);\n\
    \           cred = mgr.createCredential(name,\n                     GSSCredential.INDEFINITE_LIFETIME,\n\
    \                     (Oid[])null,\n                     GSSCredential.ACCEPT_ONLY);\n\
    \           // Loop infinitely\n           while (true) {\n               Socket\
    \ s = serverSock.accept();\n               // Start a new thread to serve this\
    \ connection\n               Thread serverThread = new ServerThread(s);\n    \
    \           serverThread.start();\n           }\n       }\n       /**\n      \
    \  * Inner class ServerThread whose run() method provides the\n        * secure\
    \ service to a connection.\n        */\n       private class ServerThread extends\
    \ Thread {\n           ...\n           ...\n           /**\n            * Deals\
    \ with the connection from one client.  It also\n            * handles all GSSException's\
    \ thrown while talking to\n            * this client.\n            */\n      \
    \     public void run() {\n               byte[] inToken = null;\n           \
    \    byte[] outToken = null;\n               byte[] buffer;\n               //\
    \ Container for multiple input-output arguments to\n               // and from\
    \ the per-message routines\n               // (i.e., wrap/unwrap).\n         \
    \      MessageProp supplInfo = new MessageProp(true);\n               try {\n\
    \                   // Now do the context establishment loop\n               \
    \    GSSContext context = mgr.createContext(cred);\n                   while (!context.isEstablished())\
    \ {\n                       inToken = readGSSToken();\n                      \
    \ outToken = context.acceptSecContext(inToken,\n                             \
    \                   0, inToken.length);\n                       if (outToken !=\
    \ null)\n                           writeGSSToken(outToken);\n               \
    \    }\n                   // SimpleServer wants confidentiality to be\n     \
    \              // available.  Check for it.\n                   if (!context.getConfState()){\n\
    \                       ...\n                       ...\n                   }\n\
    \                   GSSName peer = context.getSrcName();\n                   Oid\
    \ mech = context.getMech();\n                   print(\"Security context established\
    \ with \" +\n                          peer.toString() +\n                   \
    \      \" using underlying mechanism \" +\n                         mech.toString());\n\
    \                   // Now read the bytes sent by the client to be\n         \
    \          // processed.\n                   inToken = readGSSToken();\n     \
    \              // Unwrap the message\n                   buffer = context.unwrap(inToken,\
    \ 0,\n                               inToken.length, supplInfo);\n           \
    \        // All ok if no exception was thrown!\n                   // Print other\
    \ supplementary per-message status\n                   // information.\n     \
    \              print(\"Message from \" +\n                           peer.toString()\
    \ + \" arrived.\");\n                   print(\"Was it encrypted? \" +\n     \
    \                      supplInfo.getPrivacy());\n                   print(\"Duplicate\
    \ Token? \" +\n                           supplInfo.isDuplicateToken());\n   \
    \                print(\"Old Token? \"  + supplInfo.isOldToken());\n         \
    \          print(\"Unsequenced Token? \" +\n                           supplInfo.isUnseqToken());\n\
    \                   print(\"Gap Token? \"  + supplInfo.isGapToken());\n      \
    \             /*\n                    * Now process the bytes and send back an\n\
    \                    * encrypted response.\n                    */\n         \
    \          buffer = serverProcess(buffer);\n                   // Encipher it\
    \ and send it across\n                   supplInfo.setPrivacy(true); // privacy\
    \ requested\n                   supplInfo.setQOP(0); // default QOP\n        \
    \           outToken = context.wrap(buffer, 0, buffer.length,\n              \
    \                                supplInfo);\n                   writeGSSToken(outToken);\n\
    \               } catch (GSSException e) {\n                   print(\"GSS-API\
    \ Error: \" + e.getMessage());\n                   // Alternatively, could call\
    \ e.getMajorMessage()\n                   // and e.getMinorMessage()\n       \
    \            // If the exception contains an output token,\n                 \
    \  // it should be sent to the initiator.\n                   byte[] outTok =\
    \ e.getOutputToken();\n                   if (outTok != null) {\n            \
    \           writeGSSToken(outTok);\n                   }\n                   print(\"\
    Abandoning security context.\");\n                   ...\n                   ...\n\
    \               }\n               ...\n               ...\n           } // end\
    \ of run method in ServerThread\n       } // end of inner class ServerThread\n\
    \       ...\n       ...\n   } // end of class SimpleServer\n   <CODE ENDS>\n"
- title: 9.  Security Considerations
  contents:
  - "9.  Security Considerations\n   The Java language security model allows platform\
    \ providers to have\n   policy-based fine-grained access control over any resource\
    \ that an\n   application wants.  When using a Java security manager (such as,\
    \ but\n   not limited to, the case of applets running in browsers), the\n   application\
    \ code is in a sandbox by default.\n   Administrators of the platform JRE determine\
    \ what permissions, if\n   any, are to be given to source from different codebases.\
    \  Thus, the\n   administrator has to be aware of any special requirements that\
    \ the\n   GSS provider might have for system resources.  For instance, a\n   Kerberos\
    \ provider might wish to make a network connection to the Key\n   Distribution\
    \ Center (KDC) to obtain initial credentials.  This would\n   not be allowed under\
    \ the sandbox unless the administrator had granted\n   permissions for this. \
    \ Also, note that this granting and checking of\n   permissions happens transparently\
    \ to the application and is outside\n   the scope of this document.\n   The Java\
    \ language allows administrators to pre-configure a list of\n   security service\
    \ providers in the <JRE>/lib/security/java.security\n   file.  At runtime, the\
    \ system approaches these providers in order of\n   preference when looking for\
    \ security-related services.  Applications\n   have a means to modify this list\
    \ through methods in the \"Security\"\n   class in the \"java.security\" package.\
    \  However, since these\n   modifications would be visible in the entire Java\
    \ Virtual Machine\n   (JVM) and thus affect all code executing in it, this operation\
    \ is not\n   available in the sandbox and requires special permissions to perform.\n\
    \   Thus, when a GSS application has special needs that are met by a\n   particular\
    \ security provider, it has two choices:\n   1) Install the provider on a JVM-wide\
    \ basis using the\n      java.security.Security class and then depend on the system\
    \ to find\n      the right provider automatically when the need arises.  (This\n\
    \      would require the application to be granted a \"insertProvider\n      SecurityPermission\"\
    .)\n   2) Pass an instance of the provider to the local instance of\n      GSSManager\
    \ so that only factory calls going through that\n      GSSManager use the desired\
    \ provider.  (This would not require any\n      permissions.)\n"
- title: 10.  IANA Considerations
  contents:
  - "10.  IANA Considerations\n   This document has no IANA actions.\n"
- title: 11.  Changes since RFC 5653
  contents:
  - "11.  Changes since RFC 5653\n   This document has following changes:\n   1) New\
    \ error token embedded in GSSException\n      There is a design flaw in the initSecContext\
    \ and acceptSecContext\n      methods of the GSSContext class defined in \"Generic\
    \ Security\n      Service API Version 2: Java Bindings Update\" [RFC5653].\n \
    \     The methods could either return a token (possibly null if no more\n    \
    \  tokens are needed) when the call succeeds or throw a GSSException\n      if\
    \ there is a failure, but NOT both.  On the other hand, the\n      C-bindings\
    \ of GSS-API [RFC2744] can return both; that is to say, a\n      call to the GSS_Init_sec_context()\
    \ function can return a major\n      status code, and at the same time, fill in\
    \ the output_token\n      argument if there is one.\n      Without the ability\
    \ to emit an error token when there is a\n      failure, a Java application has\
    \ no mechanism to tell the other\n      side what the error is.  For example,\
    \ a \"reject\" NegTokenResp\n      token can never be transmitted for the SPNEGO\
    \ mechanism [RFC4178].\n      While a Java method can never return a value and\
    \ throw an\n      exception at the same time, we can embed the error token inside\n\
    \      the exception so that the caller has a chance to retrieve it.\n      This\
    \ update adds a new GSSException constructor to include this\n      token inside\
    \ a GSSException object and a getOutputToken() method\n      to retrieve the token.\
    \  The specification for the initSecContext\n      and acceptSecContext methods\
    \ are updated to describe the new\n      behavior.  Various examples are also\
    \ updated.\n      New JGSS programs SHOULD make use of this new feature, but it\
    \ is\n      not mandatory.  A program that intends to run with both old and\n\
    \      new GSS Java bindings can use reflection to check the availability\n  \
    \    of this new method and call it accordingly.\n   2) Removing Stream-Based\
    \ GSSContext Methods\n      The overloaded methods of GSSContext that use input\
    \ and output\n      streams as the means to convey authentication and per-message\n\
    \      GSS-API tokens as described in Section 5.15 of RFC 5653 [RFC5653]\n   \
    \   are removed in this update as the wire protocol should be defined\n      by\
    \ an application and not a library.  It's also impossible to\n      implement\
    \ these methods correctly when the token has no self-\n      framing (where the\
    \ end cannot be determined), or the library has\n      no knowledge of the token\
    \ format (for example, as a bridge talking\n      to another GSS library).  These\
    \ methods include initSecContext\n      (Section 7.4.5 of RFC 5653 [RFC5653]),\
    \ acceptSecContext\n      (Section 7.4.9 of RFC 5653 [RFC5653]), wrap (Section\
    \ 7.4.15 of RFC\n      5653 [RFC5653]), unwrap (Section 7.4.17 of RFC 5653 [RFC5653]),\n\
    \      getMIC (Section 7.4.19 of RFC 5653 [RFC5653]), and verifyMIC\n      (Section\
    \ 7.4.21 of RFC 5653 [RFC5653]).\n"
- title: 12.  Changes since RFC 2853
  contents:
  - "12.  Changes since RFC 2853\n   This document has the following changes:\n  \
    \ 1) Major GSS Status Code Constant Values\n      RFC 2853 listed all the GSS\
    \ status code values in two different\n      sections: Section 4.12.1 defined\
    \ numeric values for them, and\n      Section 6.8.1 defined them as static constants\
    \ in the GSSException\n      class without assigning any values.  Due to an inconsistent\n\
    \      ordering between these two sections, all of the GSS major status\n    \
    \  codes resulted in misalignment and a subsequent disagreement\n      between\
    \ deployed implementations.\n      This document defines the numeric values of\
    \ the GSS status codes\n      in both sections, while maintaining the original\
    \ ordering from\n      Section 6.8.1 of RFC 2853 [RFC2853], and it obsoletes the\
    \ GSS\n      status code values defined in Section 4.12.1.  The relevant\n   \
    \   sections in this document are Sections 5.12.1 and 7.8.1.\n   2) GSS Credential\
    \ Usage Constant Values\n      RFC 2853, Section 6.3.2 defines static constants\
    \ for the\n      GSSCredential usage flags.  However, the values of these constants\n\
    \      were not defined anywhere in RFC 2853 [RFC2853].\n      This document defines\
    \ the credential usage values in\n      Section 7.3.1.  The original ordering\
    \ of these values from\n      Section 6.3.2 of RFC 2853 [RFC2853] is maintained.\n\
    \   3) GSS Host-Based Service Name\n      RFC 2853 [RFC2853], Section 6.2.2 defines\
    \ the static constant for\n      the GSS host-based service OID NT_HOSTBASED_SERVICE,\
    \ using a\n      deprecated OID value.\n      This document updates the NT_HOSTBASED_SERVICE\
    \ OID value in\n      Section 7.2.1 to be consistent with the C-bindings in RFC\
    \ 2744\n      [RFC2744].\n"
- title: 13.  References
  contents:
  - '13.  References

    '
- title: 13.1.  Normative References
  contents:
  - "13.1.  Normative References\n   [RFC2025]  Adams, C., \"The Simple Public-Key\
    \ GSS-API Mechanism\n              (SPKM)\", RFC 2025, DOI 10.17487/RFC2025, October\
    \ 1996,\n              <https://www.rfc-editor.org/info/rfc2025>.\n   [RFC2119]\
    \  Bradner, S., \"Key words for use in RFCs to Indicate\n              Requirement\
    \ Levels\", BCP 14, RFC 2119,\n              DOI 10.17487/RFC2119, March 1997,\n\
    \              <https://www.rfc-editor.org/info/rfc2119>.\n   [RFC2743]  Linn,\
    \ J., \"Generic Security Service Application Program\n              Interface\
    \ Version 2, Update 1\", RFC 2743,\n              DOI 10.17487/RFC2743, January\
    \ 2000,\n              <https://www.rfc-editor.org/info/rfc2743>.\n   [RFC2744]\
    \  Wray, J., \"Generic Security Service API Version 2 :\n              C-bindings\"\
    , RFC 2744, DOI 10.17487/RFC2744, January 2000,\n              <https://www.rfc-editor.org/info/rfc2744>.\n\
    \   [RFC2853]  Kabat, J. and M. Upadhyay, \"Generic Security Service API\n   \
    \           Version 2 : Java Bindings\", RFC 2853,\n              DOI 10.17487/RFC2853,\
    \ June 2000,\n              <https://www.rfc-editor.org/info/rfc2853>.\n   [RFC4121]\
    \  Zhu, L., Jaganathan, K., and S. Hartman, \"The Kerberos\n              Version\
    \ 5 Generic Security Service Application Program\n              Interface (GSS-API)\
    \ Mechanism: Version 2\", RFC 4121,\n              DOI 10.17487/RFC4121, July\
    \ 2005,\n              <https://www.rfc-editor.org/info/rfc4121>.\n   [RFC4178]\
    \  Zhu, L., Leach, P., Jaganathan, K., and W. Ingersoll, \"The\n             \
    \ Simple and Protected Generic Security Service Application\n              Program\
    \ Interface (GSS-API) Negotiation Mechanism\",\n              RFC 4178, DOI 10.17487/RFC4178,\
    \ October 2005,\n              <https://www.rfc-editor.org/info/rfc4178>.\n  \
    \ [RFC5653]  Upadhyay, M. and S. Malkani, \"Generic Security Service API\n   \
    \           Version 2: Java Bindings Update\", RFC 5653,\n              DOI 10.17487/RFC5653,\
    \ August 2009,\n              <https://www.rfc-editor.org/info/rfc5653>.\n   [RFC8174]\
    \  Leiba, B., \"Ambiguity of Uppercase vs Lowercase in RFC\n              2119\
    \ Key Words\", BCP 14, RFC 8174, DOI 10.17487/RFC8174,\n              May 2017,\
    \ <https://www.rfc-editor.org/info/rfc8174>.\n"
- title: 13.2.  Informative References
  contents:
  - "13.2.  Informative References\n   [ISOIEC-8824]\n              International\
    \ Organization for Standardization,\n              \"Information technology --\
    \ Abstract Syntax Notation One\n              (ASN.1): Specification of basic\
    \ notation\", ISO/\n              IEC 8824-1:2014, November 2015,\n          \
    \    <https://www.iso.org/standard/68350.html>.\n   [ISOIEC-8825]\n          \
    \    International Organization for Standardization,\n              \"Information\
    \ technology -- ASN.1 encoding rules:\n              Specification of Basic Encoding\
    \ Rules (BER), Canonical\n              Encoding Rules (CER) and Distinguished\
    \ Encoding Rules\n              (DER)\", ISO/IEC 8825-1:2015, November 2015,\n\
    \              <https://www.iso.org/standard/68345.html>.\n   [JLS]      Gosling,\
    \ J., Joy, B., Steele, G., Bracha, G., Buckley, A.,\n              and D. Smith,\
    \ \"The Java Language Specification\", Java SE\n              10 Edition, February\
    \ 2018,\n              <https://docs.oracle.com/javase/specs/jls/se10/html/\n\
    \              index.html>.\n"
- title: Acknowledgments
  contents:
  - "Acknowledgments\n   We would like to thank Mike Eisler, Lin Ling, Ram Marti,\
    \ Michael\n   Saltz, and other members of Sun's development team for their helpful\n\
    \   input, comments, and suggestions.\n   We would also like to thank Greg Hudson,\
    \ Benjamin Kaduk, Joe Salowey\n   and Michael Smith for many insightful ideas\
    \ and suggestions that have\n   contributed to this document.\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Mayank D. Upadhyay\n   Google Inc.\n   1600 Amphitheatre\
    \ Parkway\n   Mountain View, CA  94043\n   United States of America\n   Email:\
    \ m.d.upadhyay+ietf@gmail.com\n   Seema Malkani\n   ActivIdentity Corp.\n   6623\
    \ Dumbarton Circle\n   Fremont, California  94555\n   United States of America\n\
    \   Email: Seema.Malkani@gmail.com\n   Weijun Wang\n   Oracle\n   Building No.\
    \ 24, Zhongguancun Software Park\n   Beijing  100193\n   China\n   Email: weijun.wang@oracle.com\n"
