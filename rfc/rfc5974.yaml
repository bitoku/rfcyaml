- title: __initial_text__
  contents:
  - ' NSIS Signaling Layer Protocol (NSLP) for Quality-of-Service Signaling

    '
- title: Abstract
  contents:
  - "Abstract\n   This specification describes the NSIS Signaling Layer Protocol (NSLP)\n\
    \   for signaling Quality of Service (QoS) reservations in the Internet.\n   It\
    \ is in accordance with the framework and requirements developed in\n   NSIS.\
    \  Together with General Internet Signaling Transport (GIST), it\n   provides\
    \ functionality similar to RSVP and extends it.  The QoS NSLP\n   is independent\
    \ of the underlying QoS specification or architecture\n   and provides support\
    \ for different reservation models.  It is\n   simplified by the elimination of\
    \ support for multicast flows.  This\n   specification explains the overall protocol\
    \ approach, describes the\n   design decisions made, and provides examples.  It\
    \ specifies object,\n   message formats, and processing rules.\n"
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This document is not an Internet Standards Track specification;\
    \ it is\n   published for examination, experimental implementation, and\n   evaluation.\n\
    \   This document defines an Experimental Protocol for the Internet\n   community.\
    \  This document is a product of the Internet Engineering\n   Task Force (IETF).\
    \  It represents the consensus of the IETF\n   community.  It has received public\
    \ review and has been approved for\n   publication by the Internet Engineering\
    \ Steering Group (IESG).  Not\n   all documents approved by the IESG are a candidate\
    \ for any level of\n   Internet Standard; see Section 2 of RFC 5741.\n   Information\
    \ about the current status of this document, any errata,\n   and how to provide\
    \ feedback on it may be obtained at\n   http://www.rfc-editor.org/info/rfc5974.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (c) 2010 IETF Trust and the persons identified\
    \ as the\n   document authors.  All rights reserved.\n   This document is subject\
    \ to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n\
    \   (http://trustee.ietf.org/license-info) in effect on the date of\n   publication\
    \ of this document.  Please review these documents\n   carefully, as they describe\
    \ your rights and restrictions with respect\n   to this document.  Code Components\
    \ extracted from this document must\n   include Simplified BSD License text as\
    \ described in Section 4.e of\n   the Trust Legal Provisions and are provided\
    \ without warranty as\n   described in the Simplified BSD License.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1.  Introduction . . . . . . . . . . . . . . . . . . .\
    \ . . . . . .  4\n   2.  Terminology  . . . . . . . . . . . . . . . . . . . .\
    \ . . . . .  5\n   3.  Protocol Overview  . . . . . . . . . . . . . . . . . .\
    \ . . . .  6\n     3.1.  Overall Approach . . . . . . . . . . . . . . . . . .\
    \ . . .  6\n       3.1.1.  Protocol Messages  . . . . . . . . . . . . . . . .\
    \ . .  9\n       3.1.2.  QoS Models and QoS Specifications  . . . . . . . . .\
    \ . 10\n       3.1.3.  Policy Control . . . . . . . . . . . . . . . . . . . .\
    \ 12\n     3.2.  Design Background  . . . . . . . . . . . . . . . . . . . . 13\n\
    \       3.2.1.  Soft States  . . . . . . . . . . . . . . . . . . . . . 13\n  \
    \     3.2.2.  Sender and Receiver Initiation . . . . . . . . . . . . 13\n    \
    \   3.2.3.  Protection against Message Re-ordering and\n               Duplication\
    \  . . . . . . . . . . . . . . . . . . . . . 14\n       3.2.4.  Explicit Confirmations\
    \ . . . . . . . . . . . . . . . . 14\n       3.2.5.  Reduced Refreshes  . . .\
    \ . . . . . . . . . . . . . . . 14\n       3.2.6.  Summary Refreshes and Summary\
    \ Tear . . . . . . . . . . 15\n       3.2.7.  Message Scoping  . . . . . . . .\
    \ . . . . . . . . . . . 15\n       3.2.8.  Session Binding  . . . . . . . . .\
    \ . . . . . . . . . . 16\n       3.2.9.  Message Binding  . . . . . . . . . .\
    \ . . . . . . . . . 16\n       3.2.10. Layering . . . . . . . . . . . . . . .\
    \ . . . . . . . . 17\n       3.2.11. Support for Request Priorities . . . . .\
    \ . . . . . . . 18\n       3.2.12. Rerouting  . . . . . . . . . . . . . . . .\
    \ . . . . . . 19\n       3.2.13. Preemption . . . . . . . . . . . . . . . . .\
    \ . . . . . 24\n     3.3.  GIST Interactions  . . . . . . . . . . . . . . . .\
    \ . . . . 24\n       3.3.1.  Support for Bypassing Intermediate Nodes . . . .\
    \ . . . 25\n       3.3.2.  Support for Peer Change Identification . . . . . .\
    \ . . 25\n       3.3.3.  Support for Stateless Operation  . . . . . . . . . .\
    \ . 26\n       3.3.4.  Priority of Signaling Messages . . . . . . . . . . . .\
    \ 26\n       3.3.5.  Knowledge of Intermediate QoS-NSLP-Unaware Nodes . . . 26\n\
    \   4.  Examples of QoS NSLP Operation . . . . . . . . . . . . . . . . 26\n  \
    \   4.1.  Sender-Initiated Reservation . . . . . . . . . . . . . . . 27\n    \
    \ 4.2.  Sending a Query  . . . . . . . . . . . . . . . . . . . . . 28\n     4.3.\
    \  Basic Receiver-Initiated Reservation . . . . . . . . . . . 29\n     4.4.  Bidirectional\
    \ Reservations . . . . . . . . . . . . . . . . 31\n     4.5.  Aggregate Reservations\
    \ . . . . . . . . . . . . . . . . . . 33\n     4.6.  Message Binding  . . . .\
    \ . . . . . . . . . . . . . . . . . 34\n     4.7.  Reduced-State or Stateless\
    \ Interior Nodes  . . . . . . . . 38\n       4.7.1.  Sender-Initiated Reservation\
    \ . . . . . . . . . . . . . 38\n       4.7.2.  Receiver-Initiated Reservation\
    \ . . . . . . . . . . . . 40\n     4.8.  Proxy Mode . . . . . . . . . . . . .\
    \ . . . . . . . . . . . 41\n   5.  QoS NSLP Functional Specification  . . . .\
    \ . . . . . . . . . . 42\n     5.1.  QoS NSLP Message and Object Formats  . .\
    \ . . . . . . . . . 42\n       5.1.1.  Common Header  . . . . . . . . . . . .\
    \ . . . . . . . . 42\n       5.1.2.  Message Formats  . . . . . . . . . . . .\
    \ . . . . . . . 44\n       5.1.3.  Object Formats . . . . . . . . . . . . . .\
    \ . . . . . . 47\n     5.2.  General Processing Rules . . . . . . . . . . . .\
    \ . . . . . 60\n       5.2.1.  State Manipulation . . . . . . . . . . . . . .\
    \ . . . . 61\n       5.2.2.  Message Forwarding . . . . . . . . . . . . . . .\
    \ . . . 62\n       5.2.3.  Standard Message Processing Rules  . . . . . . . .\
    \ . . 62\n       5.2.4.  Retransmissions  . . . . . . . . . . . . . . . . . .\
    \ . 62\n       5.2.5.  Rerouting  . . . . . . . . . . . . . . . . . . . . . .\
    \ 63\n     5.3.  Object Processing  . . . . . . . . . . . . . . . . . . . . 65\n\
    \       5.3.1.  Reservation Sequence Number (RSN)  . . . . . . . . . . 65\n  \
    \     5.3.2.  Request Identification Information (RII) . . . . . . . 66\n    \
    \   5.3.3.  BOUND-SESSION-ID . . . . . . . . . . . . . . . . . . . 67\n      \
    \ 5.3.4.  REFRESH-PERIOD . . . . . . . . . . . . . . . . . . . . 67\n       5.3.5.\
    \  INFO-SPEC  . . . . . . . . . . . . . . . . . . . . . . 68\n       5.3.6.  SESSION-ID-LIST\
    \  . . . . . . . . . . . . . . . . . . . 70\n       5.3.7.  RSN-LIST . . . . .\
    \ . . . . . . . . . . . . . . . . . . 71\n       5.3.8.  QSPEC  . . . . . . .\
    \ . . . . . . . . . . . . . . . . . 71\n     5.4.  Message Processing Rules .\
    \ . . . . . . . . . . . . . . . . 72\n       5.4.1.  RESERVE Messages . . . .\
    \ . . . . . . . . . . . . . . . 72\n       5.4.2.  QUERY Messages . . . . . .\
    \ . . . . . . . . . . . . . . 77\n       5.4.3.  RESPONSE Messages  . . . . .\
    \ . . . . . . . . . . . . . 78\n       5.4.4.  NOTIFY Messages  . . . . . . .\
    \ . . . . . . . . . . . . 79\n   6.  IANA Considerations  . . . . . . . . . .\
    \ . . . . . . . . . . . 80\n     6.1.  QoS NSLP Message Type  . . . . . . . .\
    \ . . . . . . . . . . 81\n     6.2.  NSLP Message Objects . . . . . . . . . .\
    \ . . . . . . . . . 81\n     6.3.  QoS NSLP Binding Codes . . . . . . . . . .\
    \ . . . . . . . . 82\n     6.4.  QoS NSLP Error Classes and Error Codes . . .\
    \ . . . . . . . 82\n     6.5.  QoS NSLP Error Source Identifiers  . . . . . .\
    \ . . . . . . 83\n     6.6.  NSLP IDs and Router Alert Option Values  . . . .\
    \ . . . . . 83\n   7.  Security Considerations  . . . . . . . . . . . . . . .\
    \ . . . . 83\n     7.1.  Trust Relationship Model . . . . . . . . . . . . . .\
    \ . . . 85\n     7.2.  Authorization Model Examples . . . . . . . . . . . . .\
    \ . . 87\n       7.2.1.  Authorization for the Two-Party Approach . . . . . .\
    \ . 87\n       7.2.2.  Token-Based Three-Party Approach . . . . . . . . . . .\
    \ 88\n       7.2.3.  Generic Three-Party Approach . . . . . . . . . . . . . 90\n\
    \     7.3.  Computing the Authorization Decision . . . . . . . . . . . 90\n  \
    \ 8.  Acknowledgments  . . . . . . . . . . . . . . . . . . . . . . . 91\n   9.\
    \  Contributors . . . . . . . . . . . . . . . . . . . . . . . . . 91\n   10. References\
    \ . . . . . . . . . . . . . . . . . . . . . . . . . . 91\n     10.1. Normative\
    \ References . . . . . . . . . . . . . . . . . . . 91\n     10.2. Informative\
    \ References . . . . . . . . . . . . . . . . . . 91\n   Appendix A.  Abstract\
    \ NSLP-RMF API . . . . . . . . . . . . . . . . 94\n     A.1.  Triggers from QOS-NSLP\
    \ towards RMF . . . . . . . . . . . . 94\n     A.2.  Triggers from RMF/QOSM towards\
    \ QOS-NSLP  . . . . . . . . . 96\n     A.3.  Configuration Interface  . . . .\
    \ . . . . . . . . . . . . . 99\n   Appendix B.  Glossary  . . . . . . . . . .\
    \ . . . . . . . . . . .  100\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   This document defines a Quality of Service (QoS) NSIS Signaling\
    \ Layer\n   Protocol (NSLP), henceforth referred to as the \"QoS NSLP\".  This\n\
    \   protocol establishes and maintains state at nodes along the path of a\n  \
    \ data flow for the purpose of providing some forwarding resources for\n   that\
    \ flow.  It is intended to satisfy the QoS-related requirements of\n   RFC 3726\
    \ [RFC3726].  This QoS NSLP is part of a larger suite of\n   signaling protocols,\
    \ whose structure is outlined in the NSIS\n   framework [RFC4080].  The abstract\
    \ NTLP has been developed into a\n   concrete protocol, GIST (General Internet\
    \ Signaling Transport)\n   [RFC5971].  The QoS NSLP relies on GIST to carry out\
    \ many aspects of\n   signaling message delivery.\n   The design of the QoS NSLP\
    \ is conceptually similar to RSVP [RFC2205]\n   and uses soft-state peer-to-peer\
    \ refresh messages as the primary\n   state management mechanism (i.e., state\
    \ installation/refresh is\n   performed between pairs of adjacent NSLP nodes,\
    \ rather than in an\n   end-to-end fashion along the complete signaling path).\
    \  The QoS NSLP\n   extends the set of reservation mechanisms to meet the requirements\
    \ of\n   RFC 3726 [RFC3726], in particular, support of sender- or receiver-\n\
    \   initiated reservations, as well as a type of bidirectional\n   reservation\
    \ and support of reservations between arbitrary nodes,\n   e.g., edge-to-edge,\
    \ end-to-access, etc.  On the other hand, there is\n   currently no support for\
    \ IP multicast.\n   A distinction is made between the operation of the signaling\
    \ protocol\n   and the information required for the operation of the Resource\n\
    \   Management Function (RMF).  This document describes the signaling\n   protocol,\
    \ whilst [RFC5975] describes the RMF-related information\n   carried in the QSPEC\
    \ (QoS Specification) object in QoS NSLP messages.\n   This is similar to the\
    \ decoupling between RSVP and the IntServ\n   architecture [RFC1633].  The QSPEC\
    \ carries information on resources\n   available, resources required, traffic\
    \ descriptions, and other\n   information required by the RMF.\n   This document\
    \ is structured as follows.  The overall protocol design\n   is outlined in Section\
    \ 3.1.  The operation and use of the QoS NSLP is\n   described in more detail\
    \ in the rest of Section 3.  Section 4 then\n   clarifies the protocol by means\
    \ of a number of examples.  These\n   sections should be read by people interested\
    \ in the overall protocol\n   capabilities.  The functional specification in Section\
    \ 5 contains\n   more detailed object and message formats and processing rules\
    \ and\n   should be the basis for implementers.  The subsequent sections\n   describe\
    \ IANA allocation issues and security considerations.\n"
- title: 2.  Terminology
  contents:
  - "2.  Terminology\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\"\
    , \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and\
    \ \"OPTIONAL\" in this\n   document are to be interpreted as described in RFC\
    \ 2119 [RFC2119].\n   The terminology defined by GIST [RFC5971] applies to this\
    \ document.\n   In addition, the following terms are used:\n   QNE: an NSIS Entity\
    \ (NE), which supports the QoS NSLP.\n   QNI: the first node in the sequence of\
    \ QNEs that issues a reservation\n   request for a session.\n   QNR: the last\
    \ node in the sequence of QNEs that receives a\n   reservation request for a session.\n\
    \   P-QNE: Proxy-QNE, a node set to reply to messages with the PROXY\n   scope\
    \ flag set.\n   Session: A session defines an association between a QNI and QNR\n\
    \   related to a data flow.  Intermediate QNEs on the path, the QNI, and\n   the\
    \ QNR use the same identifier to refer to the state stored for the\n   association.\
    \  The same QNI and QNR may have more than one session\n   active at any one time.\n\
    \   Session Identification (SESSION-ID, SID): This is a cryptographically\n  \
    \ random and (probabilistically) globally unique identifier of the\n   application-layer\
    \ session that is associated with a certain flow.\n   Often, there will only be\
    \ one data flow for a given session, but in\n   mobility/multihoming scenarios,\
    \ there may be more than one, and they\n   may be differently routed [RFC4080].\n\
    \   Source or message source: The one of two adjacent NSLP peers that is\n   sending\
    \ a signaling message (maybe the upstream or the downstream\n   peer).  Note that\
    \ this is not necessarily the QNI.\n   QoS NSLP operation state: State used/kept\
    \ by the QoS NSLP processing\n   to handle messaging aspects.\n   QoS reservation\
    \ state: State used/kept by the Resource Management\n   Function to describe reserved\
    \ resources for a session.\n   Flow ID: This is essentially the Message Routing\
    \ Information (MRI) in\n   GIST for path-coupled signaling.\n   Figure 1 shows\
    \ the components that have a role in a QoS NSLP\n   signaling session.  The flow\
    \ sender and receiver would in most cases\n   be part of the QNI and QNR nodes.\
    \  Yet, these may be separate nodes,\n   too.\n                        QoS NSLP\
    \ nodes\n  IP address            (QoS-unaware NSIS nodes are          IP address\n\
    \  = Flow                 not shown)                          = Flow\n  Source\
    \                 |          |            |           Destination\n  Address \
    \               |          |            |           Address\n                \
    \         V          V            V\n  +--------+  Data +------+      +------+\
    \       +------+     +--------+\n  |  Flow  |-------|------|------|------|-------|------|---->|\
    \  Flow  |\n  | Sender |  Flow |      |      |      |       |      |     |Receiver|\n\
    \  +--------+       | QNI  |      | QNE  |       | QNR  |     +--------+\n   \
    \                |      |      |      |       |      |\n                   +------+\
    \      +------+       +------+\n                           =====================>\n\
    \                           <=====================\n                         \
    \        Signaling\n                                   Flow\n             Figure\
    \ 1: Components of the QoS NSLP Architecture\n   A glossary of terms and abbreviations\
    \ used in this document can be\n   found in Appendix B.\n"
- title: 3.  Protocol Overview
  contents:
  - '3.  Protocol Overview

    '
- title: 3.1.  Overall Approach
  contents:
  - "3.1.  Overall Approach\n   This section presents a logical model for the operation\
    \ of the QoS\n   NSLP and associated provisioning mechanisms within a single node.\n\
    \   The model is shown in Figure 2.\n                                     +-----------------+\n\
    \                                     |      Local      |\n                  \
    \                   | Applications or |\n                                    \
    \ |Management (e.g.,|\n                                     | for aggregates)\
    \ |\n                                     +-----------------+\n              \
    \                                ^\n                                         \
    \     V\n                                              V\n               +----------+\
    \             +----------+      +---------+\n               | QoS NSLP |     \
    \        | Resource |      | Policy  |\n               |Processing|<<<<<<>>>>>>>|Management|<<<>>>|\
    \ Control |\n               +----------+             +----------+      +---------+\n\
    \                 .  ^   |              *      ^\n                 |  V   .  \
    \          *        ^\n               +----------+        *          ^\n     \
    \          |   NTLP   |       *           ^\n               |Processing|     \
    \  *           V\n               +----------+       *           V\n          \
    \       |      |         *           V\n     ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n\
    \                 .      .         *           V\n                 |      |  \
    \       *     .............................\n                 .      .       \
    \  *     .   Traffic Control         .\n                 |      |         *  \
    \   .                +---------+.\n                 .      .         *     . \
    \               |Admission|.\n                 |      |         *     .      \
    \          | Control |.\n       +----------+    +------------+   .           \
    \     +---------+.\n   <-.-|  Input   |    | Outgoing   |-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.->\n\
    \       |  Packet  |    | Interface  |   .+----------+    +---------+.\n   ===>|Processing|====|\
    \ Selection  |===.|  Packet  |====| Packet  |.==>\n       |          |    |(Forwarding)|\
    \   .|Classifier|     Scheduler|.\n       +----------+    +------------+   .+----------+\
    \    +---------+.\n                                        .............................\n\
    \           <.-.-> = signaling flow\n           =====> = data flow (sender -->\
    \ receiver)\n           <<<>>> = control and configuration operations\n      \
    \     ****** = routing table manipulation\n                       Figure 2: QoS\
    \ NSLP in a Node\n   This diagram shows an example implementation scenario where\
    \ QoS\n   conditioning is performed on the output interface.  However, this\n\
    \   does not limit the possible implementations.  For example, in some\n   cases,\
    \ traffic conditioning may be performed on the incoming\n   interface, or it may\
    \ be split over the input and output interfaces.\n   Also, the interactions with\
    \ the Policy Control component may be more\n   complex, involving interaction\
    \ with the Resource Management Function,\n   and the AAA infrastructure.\n   From\
    \ the perspective of a single node, the request for QoS may result\n   from a\
    \ local application request or from processing an incoming QoS\n   NSLP message.\
    \  The request from a local application includes not only\n   user applications\
    \ but also network management and the policy control\n   module.  For example,\
    \ a request could come from multimedia\n   applications, initiate a tunnel to\
    \ handle an aggregate, interwork\n   with some other reservation protocol (such\
    \ as RSVP), and contain an\n   explicit teardown triggered by a AAA policy control\
    \ module.  In this\n   sense, the model does not distinguish between hosts and\
    \ routers.\n   Incoming messages are captured during input packet processing and\n\
    \   handled by GIST.  Only messages related to QoS are passed to the QoS\n   NSLP.\
    \  GIST may also generate triggers to the QoS NSLP (e.g.,\n   indications that\
    \ a route change has occurred).  The QoS request is\n   handled by the RMF, which\
    \ coordinates the activities required to\n   grant and configure the resource.\
    \  It also handles policy-specific\n   aspects of QoS signaling.\n   The grant\
    \ processing involves two local decision modules, 'policy\n   control' and 'admission\
    \ control'.  Policy control determines whether\n   the user is authorized to make\
    \ the reservation.  Admission control\n   determines whether the network of the\
    \ node has sufficient available\n   resources to supply the requested QoS.  If\
    \ both checks succeed,\n   parameters are set in the packet classifier and in\
    \ the link-layer\n   interface (e.g., in the packet scheduler) to obtain the desired\
    \ QoS.\n   Error notifications are passed back to the request originator.  The\n\
    \   Resource Management Function may also manipulate the forwarding\n   tables\
    \ at this stage to select (or at least pin) a route; this must\n   be done before\
    \ interface-dependent actions are carried out (including\n   sending outgoing\
    \ messages over any new route), and is in any case\n   invisible to the operation\
    \ of the protocol.\n   Policy control is expected to make use of the authentication\n\
    \   infrastructure or the authentication protocols external to the node\n   itself.\
    \  Some discussion can be found in a separate document on\n   authorization issues\
    \ [qos-auth].  More generally, the processing of\n   policy and Resource Management\
    \ Functions may be outsourced to an\n   external node, leaving only 'stubs' co-located\
    \ with the NSLP node;\n   this is not visible to the protocol operation.  A more\
    \ detailed\n   discussion of authentication and authorization can be found in\n\
    \   Section 3.1.3.\n   Admission control, packet scheduling, and any part of policy\
    \ control\n   beyond simple authorization have to be implemented using specific\n\
    \   definitions for types and levels of QoS.  A key assumption is made\n   that\
    \ the QoS NSLP is independent of the QoS parameters (e.g., IntServ\n   service\
    \ elements).  These are captured in a QoS model and interpreted\n   only by the\
    \ resource management and associated functions, and are\n   opaque to the QoS\
    \ NSLP itself.  QoS models are discussed further in\n   Section 3.1.2.\n   The\
    \ final stage of processing for a resource request is to indicate\n   to the QoS\
    \ NSLP protocol processing that the required resources have\n   been configured.\
    \  The QoS NSLP may generate an acknowledgment message\n   in one direction, and\
    \ may forward the resource request in the other.\n   Message routing is carried\
    \ out by the GIST module.  Note that while\n   Figure 2 shows a unidirectional\
    \ data flow, the signaling messages can\n   pass in both directions through the\
    \ node, depending on the particular\n   message and orientation of the reservation.\n"
- title: 3.1.1.  Protocol Messages
  contents:
  - "3.1.1.  Protocol Messages\n   The QoS NSLP uses four message types:\n   RESERVE:\
    \ The RESERVE message is the only message that manipulates QoS\n   NSLP reservation\
    \ state.  It is used to create, refresh, modify, and\n   remove such state.  The\
    \ result of a RESERVE message is the same\n   whether a message is received once\
    \ or many times.\n   QUERY: A QUERY message is used to request information about\
    \ the data\n   path without making a reservation.  This functionality can be used\
    \ to\n   make reservations or to support certain QoS models.  The information\n\
    \   obtained from a QUERY may be used in the admission control process of\n  \
    \ a QNE (e.g., in case of measurement-based admission control).  Note\n   that\
    \ a QUERY does not change existing reservation state.\n   RESPONSE: The RESPONSE\
    \ message is used to provide information about\n   the result of a previous QoS\
    \ NSLP message.  This includes explicit\n   confirmation of the state manipulation\
    \ signaled in the RESERVE\n   message, and the response to a QUERY message or\
    \ an error code if the\n   QNE or QNR is unable to provide the requested information\
    \ or if the\n   response is negative.  The RESPONSE message does not cause any\n\
    \   reservation state to be installed or modified.\n   NOTIFY: NOTIFY messages\
    \ are used to convey information to a QNE.\n   They differ from RESPONSE messages\
    \ in that they are sent\n   asynchronously and need not refer to any particular\
    \ state or\n   previously received message.  The information conveyed by a NOTIFY\n\
    \   message is typically related to error conditions.  Examples would be\n   notification\
    \ to an upstream peer about state being torn down or\n   notification when a reservation\
    \ has been preempted.\n   QoS NSLP messages are sent peer-to-peer.  This means\
    \ that a QNE\n   considers its adjacent upstream or downstream peer to be the\
    \ source\n   of each message.\n   Each protocol message has a common header which\
    \ indicates the message\n   type and contains various flag bits.  Message formats\
    \ are defined in\n   Section 5.1.2.  Message processing rules are defined in Section\
    \ 5.4.\n   QoS NSLP messages contain three types of objects:\n   1.  Control Information:\
    \ Control information objects carry general\n       information for the QoS NSLP\
    \ processing, such as sequence numbers\n       or whether a response is required.\n\
    \   2.  QoS specifications (QSPECs): QSPEC objects describe the actual\n     \
    \  resources that are required and depend on the QoS model being\n       used.\
    \  Besides any resource description, they may also contain\n       other control\
    \ information used by the RMF's processing.\n   3.  Policy objects: Policy objects\
    \ contain data used to authorize the\n       reservation of resources.\n   Object\
    \ formats are defined in Section 5.1.3.  Object processing rules\n   are defined\
    \ in Section 5.3.\n"
- title: 3.1.2.  QoS Models and QoS Specifications
  contents:
  - "3.1.2.  QoS Models and QoS Specifications\n   The QoS NSLP provides flexibility\
    \ over the exact patterns of\n   signaling messages that are exchanged.  The decoupling\
    \ of QoS NSLP\n   and QSPEC allows the QoS NSLP to be ignorant about the ways\
    \ in which\n   traffic, resources, etc., are described, and it can treat the QSPEC\n\
    \   as an opaque object.  Various QoS models can be designed, and these\n   do\
    \ not affect the specification of the QoS NSLP protocol.  Only the\n   RMF specific\
    \ to a given QoS model will need to interpret the QSPEC.\n   The Resource Management\
    \ Function (RMF) reserves resources for each\n   flow.\n   The QSPEC fulfills\
    \ a similar purpose to the TSpec, RSpec, and AdSpec\n   objects used with RSVP\
    \ and specified in RFC 2205 [RFC2205] and RFC\n   2210 [RFC2210].  At each QNE,\
    \ the content of the QSPEC is interpreted\n   by the Resource Management Function\
    \ and the Policy Control Function\n   for the purposes of traffic and policy control\
    \ (including admission\n   control and configuration of the packet classifier\
    \ and scheduler).\n   The QoS NSLP does not mandate any particular behavior for\
    \ the RMF,\n   instead providing interoperability at the signaling-protocol level\n\
    \   whilst leaving the validation of RMF behavior to contracts external\n   to\
    \ the protocol itself.  The RMF may make use of various elements\n   from the\
    \ QoS NSLP message, not only the QSPEC object.\n   Still, this specification assumes\
    \ that resource sharing is possible\n   between flows with the same SESSION-ID\
    \ that originate from the same\n   QNI or between flows with a different SESSION-ID\
    \ that are related\n   through the BOUND-SESSION-ID object.  For flows with the\
    \ same\n   SESSION-ID, resource sharing is only applicable when the existing\n\
    \   reservation is not just replaced (which is indicated by the REPLACE\n   flag\
    \ in the common header).  We assume that the QoS model supports\n   resource sharing\
    \ between flows.  A QoS Model may elect to implement a\n   more general behavior\
    \ of supporting relative operations on existing\n   reservations, such as ADDING\
    \ or SUBTRACTING a certain amount of\n   resources from the current reservation.\
    \  A QoS Model may also elect\n   to allow resource sharing more generally, e.g.,\
    \ between all flows\n   with the same Differentiated Service Code Point (DSCP).\n\
    \   The QSPEC carries a collection of objects that can describe QoS\n   specifications\
    \ in a number of different ways.  A generic template is\n   defined in [RFC5975]\
    \ and contains object formats for generally useful\n   elements of the QoS description,\
    \ which is designed to ensure\n   interoperability when using the basic set of\
    \ objects.  A QSPEC\n   describing the resources requested will usually contain\
    \ objects that\n   need to be understood by all implementations, and it can also\
    \ be\n   enhanced with additional objects specific to a QoS model to provide a\n\
    \   more exact definition to the RMF, which may be better able to use its\n  \
    \ specific resource management mechanisms (which may, e.g., be link\n   specific)\
    \ as a result.\n   A QoS Model defines the behavior of the RMF, including inputs\
    \ and\n   outputs, and how QSPEC information is used to describe resources\n \
    \  available, resources required, traffic descriptions, and control\n   information\
    \ required by the RMF.  A QoS Model also describes the\n   minimum set of parameters\
    \ QNEs should use in the QSPEC when signaling\n   about this QoS Model.\n   QoS\
    \ Models may be local (private to one network), implementation/\n   vendor specific,\
    \ or global (implementable by different networks and\n   vendors).  All QSPECs\
    \ should follow the design of the QSPEC template.\n   The definition of a QoS\
    \ model may also have implications on how local\n   behavior should be implemented\
    \ in the areas where the QoS NSLP gives\n   freedom to implementers.  For example,\
    \ it may be useful to identify\n   recommended behavior for how a forwarded RESERVE\
    \ message relates to a\n   received one, or for when additional signaling sessions\
    \ should be\n   started based on existing sessions, such as required for aggregate\n\
    \   reservations.  In some cases, suggestions may be made on whether\n   state\
    \ that may optionally be retained should be held in particular\n   scenarios.\
    \  A QoS model may specify reservation preemption, e.g., an\n   incoming resource\
    \ request may cause removal of an earlier established\n   reservation.\n"
- title: 3.1.3.  Policy Control
  contents:
  - "3.1.3.  Policy Control\n   Getting access to network resources, e.g., network\
    \ access in general\n   or access to QoS, typically involves some kind of policy\
    \ control.\n   One example of this is authorization of the resource requester.\n\
    \   Policy control for QoS NSLP resource reservation signaling is\n   conceptually\
    \ organized as illustrated below in Figure 3.\n                              \
    \    +-------------+\n                                  | Policy      |\n    \
    \                              | Decision    |\n                             \
    \     | Point (PDP) |\n                                  +------+------+\n   \
    \                                      |\n                                 /-\\\
    -----+-----/\\\n                             ////                \\\\\\\\\n  \
    \                         ||                        ||\n                     \
    \     |      Policy transport      |\n                           ||          \
    \              ||\n                             \\\\\\\\                ////\n\
    \                                 \\-------+------/\n                        \
    \                 |\n   +-------------+ QoS signaling  +------+------+\n   | \
    \ Entity     |<==============>| QNE = Policy|<=========>\n   |  requesting | Data\
    \ Flow      | Enforcement |\n   |  resource   |----------------|-Point (PEP)-|---------->\n\
    \   +-------------+                +-------------+\n           Figure 3: Policy\
    \ Control with the QoS NSLP Signaling\n   From the QoS NSLP point of view, the\
    \ policy control model is\n   essentially a two-party model between neighboring\
    \ QNEs.  The actual\n   policy decision may depend on the involvement of a third\
    \ entity (the\n   Policy Decision Point, PDP), but this happens outside of the\
    \ QoS NSLP\n   protocol by means of existing policy infrastructure (Common Open\n\
    \   Policy Service (COPS), Diameter, etc.).  The policy control model for\n  \
    \ the entire end-to-end chain of QNEs is therefore one of transitivity,\n   where\
    \ each of the QNEs exchanges policy information with its QoS NSLP\n   policy peer.\n\
    \   The authorization of a resource request often depends on the identity\n  \
    \ of the entity making the request.  Authentication may be required.\n   The GIST\
    \ channel security mechanisms provide one way of\n   authenticating the QoS NSLP\
    \ peer that sent the request, and so may be\n   used in making the authorization\
    \ decision.\n   Additional information might also be provided in order to assist\
    \ in\n   making the authorization decision.  This might include alternative\n\
    \   methods of authenticating the request.\n   The QoS NSLP does not currently\
    \ contain objects to carry\n   authorization information.  At the time of writing,\
    \ there exists a\n   separate individual work [NSIS-AUTH] that defines this functionality\n\
    \   for the QoS NSLP and the NAT and firewall (NATFW) NSLP.\n   It is generally\
    \ assumed that policy enforcement is likely to\n   concentrate on border nodes\
    \ between administrative domains.  This may\n   mean that nodes within the domain\
    \ are \"Policy-Ignorant Nodes\" that\n   perform no per-request authentication\
    \ or authorization, relying on\n   the border nodes to perform the enforcement.\
    \  In such cases, the\n   policy management between ingress and egress edge of\
    \ a domain relies\n   on the internal chain of trust between the nodes in the\
    \ domain.  If\n   this is not acceptable, a separate signaling session can be\
    \ set up\n   between the ingress and egress edge nodes in order to exchange policy\n\
    \   information.\n"
- title: 3.2.  Design Background
  contents:
  - "3.2.  Design Background\n   This section presents some of the key functionality\
    \ behind the\n   specification of the QoS NSLP.\n"
- title: 3.2.1.  Soft States
  contents:
  - "3.2.1.  Soft States\n   The NSIS protocol suite takes a soft-state approach to\
    \ state\n   management.  This means that reservation state in QNEs must be\n \
    \  periodically refreshed.  The frequency with which state installation\n   is\
    \ refreshed is expressed in the REFRESH-PERIOD object.  This object\n   contains\
    \ a value in milliseconds indicating how long the state that\n   is signaled for\
    \ remains valid.  Maintaining the reservation beyond\n   this lifetime can be\
    \ done by sending a RESERVE message periodically.\n"
- title: 3.2.2.  Sender and Receiver Initiation
  contents:
  - "3.2.2.  Sender and Receiver Initiation\n   The QoS NSLP supports both sender-initiated\
    \ and receiver-initiated\n   reservations.  For a sender-initiated reservation,\
    \ RESERVE messages\n   travel in the same direction as the data flow that is being\
    \ signaled\n   for (the QNI is at the side of the source of the data flow).  For\
    \ a\n   receiver-initiated reservation, RESERVE messages travel in the\n   opposite\
    \ direction (the QNI is at the side of the receiver of the\n   data flow).\n \
    \  Note: these definitions follow the definitions in Section 3.3.1 of\n   RFC\
    \ 4080 [RFC4080].  The main issue is about which node is in charge\n   of requesting\
    \ and maintaining the resource reservation.  In a\n   receiver-initiated reservation,\
    \ even though the sender sends the\n   initial QUERY, the receiver is still in\
    \ charge of making the actual\n   resource request and maintaining the reservation.\n"
- title: 3.2.3.  Protection against Message Re-ordering and Duplication
  contents:
  - "3.2.3.  Protection against Message Re-ordering and Duplication\n   RESERVE messages\
    \ affect the installed reservation state.  Unlike\n   NOTIFY, QUERY, and RESPONSE\
    \ messages, the order in which RESERVE\n   messages are received influences the\
    \ eventual reservation state that\n   will be stored at a QNE; that is, the most\
    \ recent RESERVE message\n   replaces the current reservation.  Therefore, in\
    \ order to protect\n   against RESERVE message re-ordering or duplication, the\
    \ QoS NSLP uses\n   a Reservation Sequence Number (RSN).  The RSN has local significance\n\
    \   only, i.e., between a QNE and its downstream peers.\n"
- title: 3.2.4.  Explicit Confirmations
  contents:
  - "3.2.4.  Explicit Confirmations\n   A QNE may require a confirmation that the\
    \ end-to-end reservation is\n   in place, or a reply to a query along the path.\
    \  For such requests,\n   it must be able to keep track of which request each\
    \ response refers\n   to.  This is supported by including a Request Identification\n\
    \   Information (RII) object in a QoS NSLP message.\n"
- title: 3.2.5.  Reduced Refreshes
  contents:
  - "3.2.5.  Reduced Refreshes\n   For scalability, the QoS NSLP supports an abbreviated\
    \ form of refresh\n   RESERVE message.  In this case, the refresh RESERVE references\
    \ the\n   reservation using the RSN and the SESSION-ID, and does not include\n\
    \   the full reservation specification (including QSPEC).  By default,\n   state\
    \ refresh should be performed with reduced refreshes in order to\n   save bytes\
    \ during transmission.  Stateless QNEs will require full\n   refresh since they\
    \ do not store the whole reservation information.\n   If the stateful QNE does\
    \ not support reduced refreshes, or there is a\n   mismatch between the local\
    \ and received RSN, the stateful QNE must\n   reply with a RESPONSE carrying an\
    \ INFO-SPEC indicating the error.\n   Furthermore, the QNE must stop sending reduced\
    \ refreshes to this peer\n   if the error indicates that support for this feature\
    \ is lacking.\n"
- title: 3.2.6.  Summary Refreshes and Summary Tear
  contents:
  - "3.2.6.  Summary Refreshes and Summary Tear\n   For limiting the number of individual\
    \ messages, the QoS NSLP supports\n   summary refresh and summary tear messages.\
    \  When sending a refreshing\n   RESERVE for a certain (primary) session, a QNE\
    \ may include a SESSION-\n   ID-LIST object where the QNE indicates (secondary)\
    \ sessions that are\n   also refreshed.  An RSN-LIST object must also be added.\
    \  The SESSION-\n   IDs and RSNs are stacked in the objects such that the index\
    \ in both\n   stacks refer to the same reservation state, i.e., the SESSION-ID\
    \ and\n   RSN at index i in both objects refers to the same session.  If the\n\
    \   receiving stateful QNE notices unknown SESSION-IDs or a mismatch with\n  \
    \ RSNs for a session, it will reply back to the upstream stateful QNE\n   with\
    \ an error.\n   In order to tear down several sessions at once, a QNE may include\n\
    \   SESSION-ID-LIST and RSN-LIST objects in a tearing reserve.  The\n   downstream\
    \ stateful QNE must then also tear down the other sessions\n   indicated.  The\
    \ downstream stateful QNE must silently ignore any\n   unknown SESSION-IDs.\n\
    \   GIST provides a SII-Handle for every downstream session.  The SII-\n   Handle\
    \ identifies a peer and should be the same for all sessions\n   whose downstream\
    \ peer is the same.  The QoS NSLP uses this\n   information to decide whether\
    \ summary refresh messages can be sent or\n   when a summary tear is possible.\n"
- title: 3.2.7.  Message Scoping
  contents:
  - "3.2.7.  Message Scoping\n   A QNE may use local policy when deciding whether\
    \ to propagate a\n   message or not.  For example, the local policy can define/configure\n\
    \   that a QNE is, for a particular session, a QNI and/or a QNR.  The QoS\n  \
    \ NSLP also includes an explicit mechanism to restrict message\n   propagation\
    \ by means of a scoping mechanism.\n   For a RESERVE or a QUERY message, two scoping\
    \ flags limit the part of\n   the path on which state is installed on the downstream\
    \ nodes that can\n   respond.  When the SCOPING flag is set to zero, it indicates\
    \ that the\n   scope is \"whole path\" (default).  When set to one, the scope\
    \ is\n   \"single hop\".  When the PROXY scope flag is set, the path is\n   terminated\
    \ at a pre-defined Proxy QNE (P-QNE).  This is similar to\n   the Localized RSVP\
    \ [lrsvp].\n   The propagation of a RESPONSE message is limited by the RII object,\n\
    \   which ensures that it is not forwarded back along the path further\n   than\
    \ the node that requested the RESPONSE.\n"
- title: 3.2.8.  Session Binding
  contents:
  - "3.2.8.  Session Binding\n   Session binding is defined as the enforcement of\
    \ a relation between\n   different QoS NSLP sessions (i.e., signaling flows with\
    \ different\n   SESSION-IDs (SIDs) as defined in GIST [RFC5971]).\n   Session\
    \ binding indicates a unidirectional dependency relation\n   between two or more\
    \ sessions by including a BOUND-SESSION-ID object.\n   A session with SID_A (the\
    \ binding session) can express its\n   unidirectional dependency relation to another\
    \ session with SID_B (the\n   bound session) by including a BOUND-SESSION-ID object\
    \ containing\n   SID_B in its messages.\n   The concept of session binding is\
    \ used to indicate the unidirectional\n   dependency relation between the end-to-end\
    \ session and the aggregate\n   session in case of aggregate reservations.  In\
    \ case of bidirectional\n   reservations, it is used to express the unidirectional\
    \ dependency\n   relation between the sessions used for forward and reverse\n\
    \   reservation.  Typically, the dependency relation indicated by session\n  \
    \ binding is purely informative in nature and does not automatically\n   trigger\
    \ any implicit action in a QNE.  A QNE may use the dependency\n   relation information\
    \ for local resource optimization or to explicitly\n   tear down reservations\
    \ that are no longer useful.  However, by using\n   an explicit binding code (see\
    \ Section 5.1.3.4), it is possible to\n   formalize this dependency relation,\
    \ meaning that if the bound session\n   (e.g., session with SID_B) is terminated,\
    \ the binding session (e.g.,\n   the session with SID_A) must be terminated also.\n\
    \   A message may include more than one BOUND-SESSION-ID object.  This\n   may\
    \ happen, e.g., in certain aggregation and bidirectional\n   reservation scenarios,\
    \ where an end-to-end session has a\n   unidirectional dependency relation with\
    \ an aggregate session and at\n   the same time it has a unidirectional dependency\
    \ relation with\n   another session used for the reverse path.\n"
- title: 3.2.9.  Message Binding
  contents:
  - "3.2.9.  Message Binding\n   QoS NSLP supports binding of messages in order to\
    \ allow for\n   expressing dependencies between different messages.  The message\n\
    \   binding can indicate either a unidirectional or bidirectional\n   dependency\
    \ relation between two messages by including the MSG-ID\n   object in one message\
    \ (\"binding message\") and the BOUND-MSG-ID object\n   in the other message (\"\
    bound message\").  The unidirectional\n   dependency means that only RESERVE messages\
    \ are bound to each other\n   whereas a bidirectional dependency means that there\
    \ is also a\n   dependency for the related RESPONSE messages.  The message binding\n\
    \   can be used to speed up signaling by starting two signaling exchanges\n  \
    \ simultaneously that are synchronized later by using message IDs.\n   This can\
    \ be used as an optimization technique, for example, in\n   scenarios where aggregate\
    \ reservations are used.  Section 4.6\n   provides more details.\n"
- title: 3.2.10.  Layering
  contents:
  - "3.2.10.  Layering\n   The QoS NSLP supports layered reservations.  Layered reservations\
    \ may\n   occur when certain parts of the network (domains) implement one or\n\
    \   more local QoS models or when they locally apply specific transport\n   characteristics\
    \ (e.g., GIST unreliable transfer mode instead of\n   reliable transfer mode).\
    \  They may also occur when several per-flow\n   reservations are locally combined\
    \ into an aggregate reservation.\n"
- title: 3.2.10.1.  Local QoS Models
  contents:
  - "3.2.10.1.  Local QoS Models\n   A domain may have local policies regarding QoS\
    \ model implementation,\n   i.e., it may map incoming traffic to its own locally\
    \ defined QoS\n   models.  The QSPEC allows this functionality, and the operation\
    \ is\n   transparent to the QoS NSLP.  The use of local QoS models within a\n\
    \   domain is performed in the RMF.\n"
- title: 3.2.10.2.  Local Control Plane Properties
  contents:
  - "3.2.10.2.  Local Control Plane Properties\n   The way signaling messages are\
    \ handled is mainly determined by the\n   parameters that are sent over the GIST-NSLP\
    \ API and by the domain\n   internal configuration.  A domain may have a policy\
    \ to implement\n   local transport behavior.  It may, for instance, elect to use\
    \ an\n   unreliable transport locally in the domain while still keeping end-\n\
    \   to-end reliability intact.\n   The QoS NSLP supports this situation by allowing\
    \ two sessions to be\n   set up for the same reservation.  The local session has\
    \ the desired\n   local transport properties and is interpreted in internal QNEs.\
    \  This\n   solution poses two requirements: the end-to-end session must be able\n\
    \   to bypass intermediate nodes, and the egress QNE needs to bind both\n   sessions\
    \ together.  Bypassing intermediate nodes is achieved with\n   GIST.  The local\
    \ session and the end-to-end session are bound at the\n   egress QNE by means\
    \ of the BOUND-SESSION-ID object.\n"
- title: 3.2.10.3.  Aggregate Reservations
  contents:
  - "3.2.10.3.  Aggregate Reservations\n   In some cases, it is desirable to create\
    \ reservations for an\n   aggregate, rather than on a per-flow basis, in order\
    \ to reduce the\n   amount of reservation state needed as well as the processing\
    \ load for\n   signaling messages.  Note that the QoS NSLP does not specify how\n\
    \   reservations need to be combined in an aggregate or how end-to-end\n   properties\
    \ need to be computed, but only provides signaling support\n   for aggregate reservations.\n\
    \   The essential difference with the layering approaches described in\n   Sections\
    \ 3.2.10.1 and 3.2.10.2 is that the aggregate reservation\n   needs a MRI that\
    \ describes all traffic carried in the aggregate\n   (e.g., a DSCP in case of\
    \ IntServ over Diffserv).  The need for a\n   different MRI mandates the use of\
    \ two different sessions, as\n   described in Section 3.2.10.2 and in the RSVP\
    \ aggregation solution in\n   RFC 3175 [RFC3175].\n   Edge QNEs of the aggregation\
    \ domain that want to maintain some end-\n   to-end properties may establish a\
    \ peering relation by sending the\n   end-to-end message transparently over the\
    \ domain (using the\n   intermediate node bypass capability described above).\
    \  Updating the\n   end-to-end properties in this message may require some knowledge\
    \ of\n   the aggregated session (e.g., for updating delay values).  For this\n\
    \   purpose, the end-to-end session contains a BOUND-SESSION-ID carrying\n   the\
    \ SESSION-ID of the aggregate session.\n"
- title: 3.2.11.  Support for Request Priorities
  contents:
  - "3.2.11.  Support for Request Priorities\n   This specification acknowledges the\
    \ fact that in some situations,\n   some messages or reservations may be more\
    \ important than others, and\n   therefore it foresees mechanisms to give these\
    \ messages or\n   reservations priority.\n   Priority of certain signaling messages\
    \ over others may be required in\n   mobile scenarios when a message loss during\
    \ call setup is less\n   harmful than during handover.  This situation only occurs\
    \ when GIST\n   or QoS NSLP processing is the congested part or scarce resource.\n\
    \   Priority of certain reservations over others may be required when QoS\n  \
    \ resources are oversubscribed.  In that case, existing reservations\n   may be\
    \ preempted in order to make room for new higher-priority\n   reservations.  A\
    \ typical approach to deal with priority and\n   preemption is through the specification\
    \ of a setup priority and\n   holding priority for each reservation.  The Resource\
    \ Management\n   Function at each QNE then keeps track of the resource consumption\
    \ at\n   each priority level.  Reservations are established when resources, at\n\
    \   their setup priority level, are still available.  They may cause\n   preemption\
    \ of reservations with a lower holding priority than their\n   setup priority.\n\
    \   Support of reservation priority is a QSPEC parameter and therefore\n   outside\
    \ the scope of this specification.  The GIST specification\n   provides a mechanism\
    \ to support a number of levels of message\n   priority that can be requested\
    \ over the NSLP-GIST API.\n"
- title: 3.2.12.  Rerouting
  contents:
  - "3.2.12.  Rerouting\n   The QoS NSLP needs to adapt to route changes in the data\
    \ path.  This\n   assumes the capability to detect rerouting events, create a\
    \ QoS\n   reservation on the new path, and optionally tear down reservations on\n\
    \   the old path.\n   From an NSLP perspective, rerouting detection can be performed\
    \ in two\n   ways.  It can either come through NetworkNotification from GIST,\
    \ or\n   from information seen at the NSLP.  In the latter case, the QoS NSLP\n\
    \   node is able to detect changes in its QoS NSLP peers by keeping track\n  \
    \ of a Source Identification Information (SII) handle that provides\n   information\
    \ similar in nature to the RSVP_HOP object described in RFC\n   2205 [RFC2205].\
    \  When a RESERVE message with an existing SESSION-ID\n   and a different SII\
    \ is received, the QNE knows its upstream or\n   downstream peer has changed,\
    \ for sender-oriented and receiver-\n   oriented reservations, respectively.\n\
    \   Reservation on the new path happens when a RESERVE message arrives at\n  \
    \ the QNE beyond the point where the old and new paths diverge.  If the\n   QoS\
    \ NSLP suspects that a reroute has occurred, then a full RESERVE\n   message (including\
    \ the QSPEC) would be sent.  A refreshing RESERVE\n   (with no QSPEC) will be\
    \ identified as an error by a QNE on the new\n   path, which does not have the\
    \ reservation installed (i.e., it was not\n   on the old path) or which previously\
    \ had a different previous-hop\n   QNE.  It will send back an error message that\
    \ results in a full\n   RESERVE message being sent.  Rapid recovery at the NSLP\
    \ layer\n   therefore requires short refresh periods.  Detection before the next\n\
    \   RESERVE message arrives is only possible at the IP layer or through\n   monitoring\
    \ of GIST peering relations (e.g., by monitoring the Time to\n   Live (TTL), i.e.,\
    \ the number of GIST hops between NSLP peers, or\n   observing the changes in\
    \ the outgoing interface towards GIST peer).\n   These mechanisms can provide\
    \ implementation-specific optimizations\n   and are outside the scope of this\
    \ specification.\n   When the QoS NSLP is aware of the route change, it needs\
    \ to set up\n   the reservation on the new path.  This is done by sending a new\n\
    \   RESERVE message.  If the next QNE is in fact unchanged, then this\n   will\
    \ be used to refresh/update the existing reservation.  Otherwise,\n   it will\
    \ lead to the reservation being installed on the new path.\n   Note that the operation\
    \ for a receiver-initiated reservation session\n   differs a bit from the above\
    \ description.  If the routing changes in\n   the middle of the path, at some\
    \ point (i.e., the divergence point)\n   the QNE that notices that its downstream\
    \ path has changed (indicated\n   by a NetworkNotification from GIST), and it\
    \ must send a QUERY with\n   the R-flag downstream.  The QUERY will be processed\
    \ as above, and at\n   some point hits a QNE for which the path downstream towards\
    \ the QNI\n   remains (i.e., the convergence point).  This node must then send\
    \ a\n   full RESERVE upstream to set up the reservation state along the new\n\
    \   path.  It should not send the QUERY further downstream, since this\n   would\
    \ have no real use.  Similarly, when the QNE that sent the QUERY\n   receives\
    \ the RESERVE, it should not send the RESERVE further\n   upstream.\n   After\
    \ the reservation on the new path is set up, the branching node\n   may want to\
    \ tear down the reservation on the old path (sooner than\n   would result from\
    \ normal soft-state timeout).  This functionality is\n   supported by keeping\
    \ track of the old SII-Handle provided over the\n   GIST API.  This handle can\
    \ be used by the QoS NSLP to route messages\n   explicitly to the next node.\n\
    \   If the old path is downstream, the QNE can send a tearing RESERVE\n   using\
    \ the old SII-Handle.  If the old path is upstream, the QNE can\n   send a NOTIFY\
    \ with the code for \"Route Change\".  This is forwarded\n   upstream until it\
    \ hits a QNE that can issue a tearing RESERVE\n   downstream.  A separate document\
    \ discusses in detail the effect of\n   mobility on the QoS NSLP signaling [NSIS-MOB].\n\
    \   A QNI or a branch node may wish to keep the reservation on the old\n   branch.\
    \  For instance, this could be the case when a mobile node has\n   experienced\
    \ a mobility event and wishes to keep reservation to its\n   old attachment point\
    \ in case it moves back there.  For this purpose,\n   a REPLACE flag is provided\
    \ in the QoS NSLP common header, which, when\n   not set, indicates that the reservation\
    \ on the old branch should be\n   kept.\n   Note that keeping old reservations\
    \ affects the resources available to\n   other nodes.  Thus, the operator of the\
    \ access network must make the\n   final decision on whether this behavior is\
    \ allowed.  Also, the QNEs\n   in the access network may add this flag even if\
    \ the mobile node has\n   not used the flag initially.\n   The latency in detecting\
    \ that a new downstream peer exists or that\n   truncation has happened depends\
    \ on GIST.  The default QUERY message\n   transmission interval is 30 seconds.\
    \  More details on how NSLPs are\n   able to affect the discovery of new peers\
    \ or rerouting can be found\n   in the GIST specification.\n"
- title: 3.2.12.1.  Last Node Behavior
  contents:
  - "3.2.12.1.  Last Node Behavior\n   The design of the QoS NSLP allows reservations\
    \ to be installed at a\n   subset of the nodes along a path.  In particular, usage\
    \ scenarios\n   include cases where the data flow endpoints do not support the\
    \ QoS\n   NSLP.\n   In the case where the data flow receiver does not support\
    \ the QoS\n   NSLP, some particular considerations must be given to node discovery\n\
    \   and rerouting at the end of the signaling path.\n   There are three cases\
    \ for the last node on the signaling path:\n   1)  the last node is the data receiver,\n\
    \   2)  the last node is a configured proxy for the data receiver, or\n   3) \
    \ the last node is not the data receiver and is not explicitly\n       configured\
    \ to act as a signaling proxy on behalf of the data\n       receiver.\n   Cases\
    \ (1) and (2) can be handled by the QoS NSLP itself during the\n   initial path\
    \ setup, since the QNE knows that it should terminate the\n   signaling.  Case\
    \ (3) requires some assistance from GIST, which\n   provides messages across the\
    \ API to indicate that no further GIST\n   nodes that support QoS NSLP are present\
    \ downstream, and that probing\n   of the downstream route change needs to continue\
    \ once the reservation\n   is installed to detect any changes in this situation.\n\
    \   Two particular scenarios need to be considered in this third case.\n   In\
    \ the first, referred to as \"Path Extension\", rerouting occurs such\n   that\
    \ an additional QNE is inserted into the signaling path between\n   the old last\
    \ node and the data receiver, as shown in Figure 4.\n           /-------\\   Initial\
    \ route\n          /         v\n              /-\\\n           /--|B|--\\    \
    \            +-+\n          /   \\-/   \\               |x| = QoS NSLP aware\n\
    \       +-+           /-\\            +-+\n   ----|A|           |D|\n       +-+\
    \           \\-/            /-\\\n          \\   +-+   /               |x| = QoS\
    \ NSLP unaware\n           \\--|C|--/                \\-/\n              +-+\n\
    \          \\         ^\n           \\-------/   Updated route\n             \
    \            Figure 4: Path Extension\n   When rerouting occurs, the data path\
    \ changes from A-B-D to A-C-D.\n   Initially the signaling path ends at A.  Despite\
    \ initially being the\n   last node, node A needs to continue to attempt to send\
    \ messages\n   downstream to probe for path changes, unless it has been explicitly\n\
    \   configured as a signaling proxy for the data flow receiver.  This is\n   required\
    \ so that the signaling path change is detected, and C will\n   become the new\
    \ last QNE.\n   In a second case, referred to as \"Path Truncation\", rerouting\
    \ occurs\n   such that the QNE that was the last node on the signaling path is\
    \ no\n   longer on the data path.  This is shown in Figure 5.\n           /-------\\\
    \   Initial route\n          /         v\n              +-+\n           /--|B|--\\\
    \                 +-+\n          /   +-+   \\                |x| = QoS NSLP aware\n\
    \       +-+           /-\\             +-+\n   ----|A|           |D|\n       +-+\
    \           \\-/             /-\\\n          \\   /-\\   /                |x|\
    \ = QoS NSLP unaware\n           \\--|C|--/                 \\-/\n           \
    \   \\-/\n          \\         ^\n           \\-------/   Updated route\n    \
    \                     Figure 5: Path Truncation\n   When rerouting occurs, the\
    \ data path again changes from A-B-D to\n   A-C-D.  The signaling path initially\
    \ ends at B, but this node is not\n   on the new path.  In this case, the normal\
    \ GIST path change detection\n   procedures at A will detect the path change and\
    \ notify the QoS NSLP.\n   GIST will also notify the signaling application that\
    \ no downstream\n   GIST nodes supporting the QoS NSLP are present.  Node A will\
    \ take\n   over as the last node on the signaling path.\n"
- title: 3.2.12.2.  Handling Spurious Route Change Notifications
  contents:
  - "3.2.12.2.  Handling Spurious Route Change Notifications\n   The QoS NSLP is notified\
    \ by GIST (with the NetworkNotification\n   primitive) when GIST believes that\
    \ a rerouting event may have\n   occurred.  In some cases, events that are detected\
    \ as possible route\n   changes will turn out not to be.  The QoS NSLP will not\
    \ always be\n   able to detect this, even after receiving messages from the 'new'\n\
    \   peer.\n   As part of the RecvMessage API primitive, GIST provides an SII-Handle\n\
    \   that can be used by the NSLP to direct a signaling message to a\n   particular\
    \ peer.  The current SII-Handle will change if the signaling\n   peer changes.\
    \  However, it is not guaranteed to remain the same after\n   a rerouting event\
    \ where the peer does not change.  Therefore, the QoS\n   NSLP mechanism for reservation\
    \ maintenance after a route change\n   includes robustness mechanisms to avoid\
    \ accidentally tearing down a\n   reservation in situations where the peer QNE\
    \ has remained the same\n   after a 'route change' notification from GIST.\n \
    \  A simple example that illustrates the problem is shown in Figure 6\n   below.\n\
    \           (1)                         +-+\n         /-----\\               \
    \        |x| = QoS NSLP aware\n       +-+     /-\\ (3) +-+             +-+\n \
    \  ----|A|     |B|-----|C|----\n       +-+     \\-/     +-+             /-\\\n\
    \         \\-----/                       |x| = QoS NSLP unaware\n           (2)\
    \                         \\-/\n                    Figure 6: Spurious Reroute\
    \ Alerting\n   In this example, the initial route A-B-C uses links (1) and (3).\n\
    \   After link (1) fails, the path is rerouted using links (2) and (3).\n   The\
    \ set of QNEs along the path is unchanged (it is A-C in both cases,\n   since\
    \ B does not support the QoS NSLP).\n   When the outgoing interface at A has changes,\
    \ GIST may signal across\n   its API to the NSLP with a NetworkNotification. \
    \ The QoS NSLP at A\n   will then attempt to repair the path by installing the\
    \ reservation on\n   the path (2),(3).  In this case, however, the old and new\
    \ paths are\n   the same.\n   To install the new reservation, A will send a RESERVE\
    \ message, which\n   GIST will transport to C (discovering the new next peer as\n\
    \   appropriate).  The RESERVE also requests a RESPONSE from the QNR.\n   When\
    \ this RESERVE message is received through the RecvMessage API\n   call from GIST\
    \ at the QoS NSLP at C, the SII-Handle will be unchanged\n   from its previous\
    \ communications from A.\n   A RESPONSE message will be sent by the QNR, and be\
    \ forwarded from C\n   to A.  This confirms that the reservation was installed\
    \ on the new\n   path.  The SII-Handle passed with the RecvMessage call from GIST\
    \ to\n   the QoS NSLP will be different to that seen previously, since the\n \
    \  interface being used on A has changed.\n   At this point, A can attempt to\
    \ tear down the reservation on the old\n   path.  The RESERVE message with the\
    \ TEAR flag set is sent down the\n   old path by using the GIST explicit routing\
    \ mechanism and specifying\n   the SII-Handle relating to the 'old' peer QNE.\n\
    \   If RSNs were being incremented for each of these RESERVE and RESERVE-\n  \
    \ with-TEAR messages, the reservation would be torn down at C and any\n   QNEs\
    \ further along the path.  To avoid this, the RSN is used in a\n   special way.\
    \  The RESERVE down the new path is sent with the new\n   current RSN set to the\
    \ old RSN plus 2.  The RESERVE-with-TEAR down\n   the old path is sent with an\
    \ RSN set to the new current RSN minus 1.\n   This is the peer from which it was\
    \ receiving RESERVE messages (see\n   for more details).\n"
- title: 3.2.13.  Preemption
  contents:
  - "3.2.13.  Preemption\n   The QoS NSLP provides building blocks to implement preemption.\
    \  This\n   specification does not define how preemption should work, but only\n\
    \   provides signaling mechanisms that can be used by QoS models.  For\n   example,\
    \ an INFO-SPEC object can be added to messages to indicate\n   that the signaled\
    \ session was preempted.  A BOUND-SESSION-ID object\n   can carry the Session\
    \ ID of the flow that caused the preemption of\n   the signaled session.  How\
    \ these are used by QoS models is out of\n   scope of the QoS NSLP specification.\n"
- title: 3.3.  GIST Interactions
  contents:
  - "3.3.  GIST Interactions\n   The QoS NSLP uses GIST for delivery of all its messages.\
    \  Messages\n   are passed from the NSLP to GIST via an API (defined in Appendix\
    \ B of\n   [RFC5971]), which also specifies additional information, including\
    \ an\n   identifier for the signaling application (e.g., 'QoS NSLP'), session\n\
    \   identifier, MRI, and an indication of the intended direction (towards\n  \
    \ data sender or receiver).  On reception, GIST provides the same\n   information\
    \ to the QoS NSLP.  In addition to the NSLP message data\n   itself, other meta-data\
    \ (e.g., session identifier and MRI) can be\n   transferred across this interface.\n\
    \   The QoS NSLP keeps message and reservation state per session.  A\n   session\
    \ is identified by a Session Identifier (SESSION-ID).  The\n   SESSION-ID is the\
    \ primary index for stored NSLP state and needs to be\n   constant and unique\
    \ (with a sufficiently high probability) along a\n   path through the network.\
    \  The QoS NSLP picks a value for Session-ID.\n   This value is subsequently used\
    \ by GIST and the QoS NSLP to refer to\n   this session.\n   Currently, the QoS\
    \ NSLP specification considers mainly the path-\n   coupled MRM.  However, extensions\
    \ may specify how other types of MRMs\n   may be applied in combination with the\
    \ QoS NSLP.\n   When GIST passes the QoS NSLP data to the NSLP for processing,\
    \ it\n   must also indicate the value of the 'D' (Direction) flag for that\n \
    \  message in the MRI.\n   The QoS NSLP does not provide any method of interacting\
    \ with\n   firewalls or Network Address Translators (NATs).  It assumes that a\n\
    \   basic NAT traversal service is provided by GIST.\n"
- title: 3.3.1.  Support for Bypassing Intermediate Nodes
  contents:
  - "3.3.1.  Support for Bypassing Intermediate Nodes\n   The QoS NSLP may want to\
    \ restrict the handling of its messages to\n   specific nodes.  This functionality\
    \ is needed to support layering\n   (explained in Section 3.2.10), when only the\
    \ edge QNEs of a domain\n   process the message.  This requires a mechanism at\
    \ the GIST level\n   (which can be invoked by the QoS NSLP) to bypass intermediate\
    \ nodes\n   between the edges of the domain.\n   The intermediate nodes are bypassed\
    \ using multiple levels of the\n   router alert option.  In that case, internal\
    \ routers are configured\n   to handle only certain levels of router alerts. \
    \ This is accomplished\n   by marking this message at the ingress, i.e., modifying\
    \ the QoS NSLP\n   default NSLPID value to an NSLPID predefined value (see Section\
    \ 6.6).\n   The egress stops this marking process by reassigning the QoS NSLP\n\
    \   default NSLPID value to the original RESERVE message.  The exact\n   operation\
    \ of modifying the NSLPID must be specified in the relevant\n   QoS model specification.\n"
- title: 3.3.2.  Support for Peer Change Identification
  contents:
  - "3.3.2.  Support for Peer Change Identification\n   There are several circumstances\
    \ where it is necessary for a QNE to\n   identify the adjacent QNE peer, which\
    \ is the source of a signaling\n   application message.  For example, it may be\
    \ to apply the policy that\n   \"state can only be modified by messages from the\
    \ node that created\n   it\" or it might be that keeping track of peer identity\
    \ is used as a\n   (fallback) mechanism for rerouting detection at the NSLP layer.\n\
    \   This functionality is implemented in the GIST service interface with\n   SII-handle.\
    \  As shown in the above example, we assume the SII-\n   handling will support\
    \ both its own SII and its peer's SII.\n   Keeping track of the SII of a certain\
    \ reservation also provides a\n   means for the QoS NSLP to detect route changes.\
    \  When a QNE receives\n   a RESERVE referring to existing state but with a different\
    \ SII, it\n   knows that its upstream peer has changed.  It can then use the old\n\
    \   SII to initiate a teardown along the old section of the path.  This\n   functionality\
    \ is supported in the GIST service interface when the\n   peer's SII (which is\
    \ stored on message reception) is passed to GIST\n   upon message transmission.\n"
- title: 3.3.3.  Support for Stateless Operation
  contents:
  - "3.3.3.  Support for Stateless Operation\n   Stateless or reduced-state QoS NSLP\
    \ operation makes the most sense\n   when some nodes are able to operate in a\
    \ stateless way at the GIST\n   level as well.  Such nodes should not worry about\
    \ keeping reverse\n   state, message fragmentation and reassembly (at GIST), congestion\n\
    \   control, or security associations.  A stateless or reduced-state QNE\n   will\
    \ be able to inform the underlying GIST of this situation.  GIST\n   service interface\
    \ supports this functionality with the Retain-State\n   attribute in the MessageReceived\
    \ primitive.\n"
- title: 3.3.4.  Priority of Signaling Messages
  contents:
  - "3.3.4.  Priority of Signaling Messages\n   The QoS NSLP will generate messages\
    \ with a range of performance\n   requirements for GIST.  These requirements may\
    \ result from a\n   prioritization at the QoS NSLP (Section 3.2.11) or from the\n\
    \   responsiveness expected by certain applications supported by the QoS\n   NSLP.\
    \  GIST service interface supports this with the 'priority'\n   transfer attribute.\n"
- title: 3.3.5.  Knowledge of Intermediate QoS-NSLP-Unaware Nodes
  contents:
  - "3.3.5.  Knowledge of Intermediate QoS-NSLP-Unaware Nodes\n   In some cases, it\
    \ is useful to know that there are routers along the\n   path where QoS cannot\
    \ be provided.  The GIST service interface\n   supports this by keeping track\
    \ of IP-TTL and Original-TTL in the\n   RecvMessage primitive.  A difference between\
    \ the two indicates the\n   number of QoS-NSLP-unaware nodes.  In this case, the\
    \ QNE that detects\n   this difference should set the \"B\" (BREAK) flag.  If\
    \ a QNE receives a\n   QUERY or RESERVE message with the BREAK flag set, and then\
    \ generates\n   a QUERY, RESERVE, or RESPONSE message, it can set the BREAK flag\
    \ in\n   those messages.  There are however, situations where the egress QNE\n\
    \   in a local domain may have some other means to provide QoS [RFC5975].\n  \
    \ For example, in a local domain that is aware of RMD-QOSM [RFC5977]\n   (or a\
    \ similar QoS Model) and that uses either NTLP stateless nodes or\n   NSIS-unaware\
    \ nodes, the end-to-end RESERVE or QUERY message bypasses\n   these NTLP stateless\
    \ or NSIS-unaware nodes.  However, the reservation\n   within the local domain\
    \ can be signaled by the RMD-QOSM (or a similar\n   QoS Model).  In such situations,\
    \ the \"B\" (BREAK) flag in the end-to-\n   end RESERVE or QUERY message should\
    \ not be set by the edges of the\n   local domain.\n"
- title: 4.  Examples of QoS NSLP Operation
  contents:
  - "4.  Examples of QoS NSLP Operation\n   The QoS NSLP can be used in a number of\
    \ ways.  The examples here give\n   an indication of some of the basic processing.\
    \  However, they are not\n   exhaustive and do not attempt to cover the details\
    \ of the protocol\n   processing.\n"
- title: 4.1.  Sender-Initiated Reservation
  contents:
  - "4.1.  Sender-Initiated Reservation\n   QNI        QNE        QNE        QNR\n\
    \    |          |          |          |\n    | RESERVE  |          |         \
    \ |\n    +--------->|          |          |\n    |          | RESERVE  |     \
    \     |\n    |          +--------->|          |\n    |          |          | RESERVE\
    \  |\n    |          |          +--------->|\n    |          |          |    \
    \      |\n    |          |          | RESPONSE |\n    |          |          |<---------+\n\
    \    |          | RESPONSE |          |\n    |          |<---------+         \
    \ |\n    | RESPONSE |          |          |\n    |<---------+          |     \
    \     |\n    |          |          |          |\n    |          |          | \
    \         |\n               Figure 7: Basic Sender-Initiated Reservation\n   To\
    \ make a new reservation, the QNI constructs a RESERVE message\n   containing\
    \ a QSPEC object, from its chosen QoS model, that describes\n   the required QoS\
    \ parameters.\n   The RESERVE message is passed to GIST, which transports it to\
    \ the\n   next QNE.  There, it is delivered to the QoS NSLP processing, which\n\
    \   examines the message.  Policy control and admission control decisions\n  \
    \ are made.  The exact processing also takes into account the QoS model\n   being\
    \ used.  The node performs appropriate actions (e.g., installing\n   the reservation)\
    \ based on the QSPEC object in the message.\n   The QoS NSLP then generates a\
    \ new RESERVE message (usually based on\n   the one received).  This is passed\
    \ to GIST, which forwards it to the\n   next QNE.\n   The same processing is performed\
    \ at further QNEs along the path, up\n   to the QNR.  The determination that a\
    \ node is the QNR may be made\n   directly (e.g., that node is the destination\
    \ for the data flow), or\n   using GIST functionality to determine that there\
    \ are no more QNEs\n   between this node and the data flow destination.\n   Any\
    \ node may include a request for a RESPONSE in its RESERVE\n   messages.  It does\
    \ so by including a Request Identification\n   Information (RII) object in the\
    \ RESERVE message.  If the message\n   already includes an RII, an interested\
    \ QNE must not add a new RII\n   object or replace the old RII object.  Instead,\
    \ it needs to remember\n   the RII value so that it can match a RESPONSE message\
    \ belonging to\n   the RESERVE.  When it receives the RESPONSE, it forwards the\
    \ RESPONSE\n   upstream towards the RII originating node.\n   In this example,\
    \ the RESPONSE message is forwarded peer-to-peer along\n   the reverse of the\
    \ path that the RESERVE message took (using GIST\n   path state), and so is seen\
    \ by all the QNEs on this segment of the\n   path.  It is only forwarded as far\
    \ as the node that requested the\n   RESPONSE originally.\n   The reservation\
    \ can subsequently be refreshed by sending further\n   RESERVE messages containing\
    \ the complete reservation information, as\n   for the initial reservation.  The\
    \ reservation can also be modified in\n   the same way, by changing the QSPEC\
    \ data to indicate a different set\n   of resources to reserve.\n   The overhead\
    \ required to perform refreshes can be reduced, in a\n   similar way to that proposed\
    \ for RSVP in RFC 2961 [RFC2961].  Once a\n   RESPONSE message has been received\
    \ indicating the successful\n   installation of a reservation, subsequent refreshing\
    \ RESERVE messages\n   can simply refer to the existing reservation, rather than\
    \ including\n   the complete reservation specification.\n"
- title: 4.2.  Sending a Query
  contents:
  - "4.2.  Sending a Query\n   QUERY messages can be used to gather information from\
    \ QNEs along the\n   path.  For example, they can be used to find out what resources\
    \ are\n   available before a reservation is made.\n   In order to perform a query\
    \ along a path, the QNE constructs a QUERY\n   message.  This message includes\
    \ a QSPEC containing the actual query\n   to be performed at QNEs along the path.\
    \  It also contains an RII\n   object used to match the response back to the query,\
    \ and an indicator\n   of the query scope (next node, whole path, proxy).  The\
    \ QUERY message\n   is passed to GIST to forward it along the path.\n   A QNE\
    \ receiving a QUERY message should inspect it and create a new\n   message based\
    \ on it, with the query objects modified as required.\n   For example, the query\
    \ may request information on whether a flow can\n   be admitted, and so a node\
    \ processing the query might record the\n   available bandwidth.  The new message\
    \ is then passed to GIST for\n   further forwarding (unless it knows it is the\
    \ QNR or is the limit for\n   the scope in the QUERY).\n   At the QNR, a RESPONSE\
    \ message must be generated if the QUERY message\n   includes an RII object. \
    \ Various objects from the received QUERY\n   message have to be copied into the\
    \ RESPONSE message.  It is then\n   passed to GIST to be forwarded peer-to-peer\
    \ back along the path.\n   Each QNE receiving the RESPONSE message should inspect\
    \ the RII object\n   to see if it 'belongs' to it (i.e., it was the one that originally\n\
    \   created it).  If it does not, then it simply passes the message back\n   to\
    \ GIST to be forwarded upstream.\n   If there was an error in processing a RESERVE,\
    \ instead of an RII, the\n   RESPONSE may carry an RSN.  Thus, a QNE must also\
    \ be prepared to look\n   for an RSN object if no RII was present, and act based\
    \ on the error\n   code set in the INFO-SPEC of the RESPONSE.\n"
- title: 4.3.  Basic Receiver-Initiated Reservation
  contents:
  - "4.3.  Basic Receiver-Initiated Reservation\n   As described in the NSIS framework\
    \ [RFC4080], in some signaling\n   applications, a node at one end of the data\
    \ flow takes responsibility\n   for requesting special treatment -- such as a\
    \ resource reservation --\n   from the network.  Both ends then agree whether\
    \ sender- or receiver-\n   initiated reservation is to be done.  In case of a\
    \ receiver-initiated\n   reservation, both ends agree whether a \"One Pass With\
    \ Advertising\"\n   (OPWA) [opwa95] model is being used.  This negotiation can\
    \ be\n   accomplished using mechanisms that are outside the scope of NSIS.\n \
    \  To make a receiver-initiated reservation, the QNR constructs a QUERY\n   message,\
    \ which MUST contain a QSPEC object from its chosen QoS model\n   (see Figure\
    \ 8).  The QUERY must have the RESERVE-INIT flag set.  This\n   QUERY message\
    \ does not need to trigger a RESPONSE message and\n   therefore, the QNI must\
    \ not include the RII object (Section 5.4.2) in\n   the QUERY message.  The QUERY\
    \ message may be used to gather\n   information along the path, which is carried\
    \ by the QSPEC object.  An\n   example of such information is the \"One Pass With\
    \ Advertising\" (OPWA)\n   model [opwa95].  This QUERY message causes GIST reverse-path\
    \ state to\n   be installed.\n    QNR        QNE        QNE        QNI\n   sender\
    \                          receiver\n     |          |          |          |\n\
    \     | QUERY    |          |          |\n     +--------->|          |       \
    \   |\n     |          | QUERY    |          |\n     |          +--------->| \
    \         |\n     |          |          | QUERY    |\n     |          |      \
    \    +--------->|\n     |          |          |          |\n     |          |\
    \          | RESERVE  |\n     |          |          |<---------+\n     |     \
    \     | RESERVE  |          |\n     |          |<---------+          |\n     |\
    \ RESERVE  |          |          |\n     |<---------+          |          |\n\
    \     |          |          |          |\n     | RESPONSE |          |       \
    \   |\n     +--------->|          |          |\n     |          | RESPONSE | \
    \         |\n     |          +--------->|          |\n     |          |      \
    \    | RESPONSE |\n     |          |          +--------->|\n     |          |\
    \          |          |\n              Figure 8: Basic Receiver-Initiated Reservation\n\
    \   The QUERY message is transported by GIST to the next downstream QoS\n   NSLP\
    \ node.  There, it is delivered to the QoS NSLP processing, which\n   examines\
    \ the message.  The exact processing also takes into account\n   the QoS model\
    \ being used and may include gathering information on\n   path characteristics\
    \ that may be used to predict the end-to-end QoS.\n   The QNE generates a new\
    \ QUERY message (usually based on the one\n   received).  This is passed to GIST,\
    \ which forwards it to the next\n   QNE.  The same processing is performed at\
    \ further QNEs along the\n   path, up to the flow receiver.  The receiver detects\
    \ that this QUERY\n   message carries the RESERVE-INIT flag and by using the information\n\
    \   contained in the received QUERY message, such as the QSPEC,\n   constructs\
    \ a RESERVE message.\n   The RESERVE is forwarded peer-to-peer along the reverse\
    \ of the path\n   that the QUERY message took (using GIST reverse-path state).\
    \  Similar\n   to the sender-initiated approach, any node may include an RII in\
    \ its\n   RESERVE messages.  The RESPONSE is sent back to confirm that the\n \
    \  resources are set up.  The reservation can subsequently be refreshed\n   with\
    \ RESERVE messages in the upstream direction.\n"
- title: 4.4.  Bidirectional Reservations
  contents:
  - "4.4.  Bidirectional Reservations\n   The term \"bidirectional reservation\" refers\
    \ to two different cases\n   that are supported by this specification:\n   o \
    \ Binding two sender-initiated reservations together, e.g., one\n      sender-initiated\
    \ reservation from QNE A to QNE B and another one\n      from QNE B to QNE A (Figure\
    \ 9).\n   o  Binding a sender-initiated and a receiver-initiated reservation\n\
    \      together, e.g., a sender-initiated reservation from QNE A towards\n   \
    \   QNE B, and a receiver-initiated reservation from QNE A towards QNE\n     \
    \ B for the data flow in the opposite direction (from QNE B to QNE\n      A).\
    \  This case is particularly useful when one end of the\n      communication has\
    \ all required information to set up both sessions\n      (Figure 10).\n   Both\
    \ ends have to agree on which bidirectional reservation type they\n   need to\
    \ use.  This negotiation can be accomplished using mechanisms\n   that are outside\
    \ the scope of NSIS.\n   The scenario with two sender-initiated reservations is\
    \ shown in\n   Figure 9.  Note that RESERVE messages for both directions may visit\n\
    \   different QNEs along the path because of asymmetric routing.  Both\n   directions\
    \ of the flows are bound by inserting the BOUND-SESSION-ID\n   object at the QNI\
    \ and QNR.  RESPONSE messages are optional and not\n   shown in the picture for\
    \ simplicity.\n      A          QNE        QNE        B\n      |          |  FLOW-1\
    \  |          |\n      |===============================>|\n      |RESERVE-1 |\
    \          |          |\n   QNI+--------->|RESERVE-1 |          |\n      |   \
    \       +-------------------->|QNR\n      |          |          |          |\n\
    \      |          |  FLOW-2  |          |\n      |<===============================|\n\
    \      |          |          |RESERVE-2 |\n      |  RESERVE-2          |<---------+QNI\n\
    \   QNR|<--------------------+          |\n      |          |          |     \
    \     |\n      Figure 9: Bidirectional Reservation for Sender+Sender Scenario\n\
    \   The scenario with a sender-initiated and a receiver-initiated\n   reservation\
    \ is shown in Figure 10.  In this case, QNI A sends out two\n   RESERVE messages,\
    \ one for the sender-initiated and one for the\n   receiver-initiated reservation.\
    \  Note that the sequence of the two\n   RESERVE messages may be interleaved.\n\
    \          A          QNE        QNE        B\n          |          |  FLOW-1\
    \  |          |\n          |===============================>|\n          |RESERVE-1\
    \ |          |          |\n       QNI+--------->|RESERVE-1 |          |\n    \
    \      |          +-------------------->|QNR\n          |          |         \
    \ |          |\n          |          |  FLOW-2  |          |\n          |<===============================|\n\
    \          |          |          |  QUERY-2 |\n          |          |  QUERY-2\
    \ |<---------+QNR\n       QNI|<--------------------+          |\n          | \
    \         |          |          |\n          |RESERVE-2 |          |         \
    \ |\n       QNI+--------->|RESERVE-2 |          |\n          |          +-------------------->|QNR\n\
    \          |          |          |          |\n     Figure 10: Bidirectional Reservation\
    \ for Sender+Receiver Scenario\n"
- title: 4.5.  Aggregate Reservations
  contents:
  - "4.5.  Aggregate Reservations\n   In order to reduce signaling and per-flow state\
    \ in the network, the\n   reservations for a number of flows may be aggregated.\n\
    \   QNI        QNE      QNE/QNI'     QNE'    QNR'/QNE      QNR\n             \
    \        aggregator           deaggregator\n    |          |          |      \
    \    |          |          |\n    | RESERVE  |          |          |         \
    \ |          |\n    +--------->|          |          |          |          |\n\
    \    |          | RESERVE  |          |          |          |\n    |         \
    \ +--------->|          |          |          |\n    |          |          | RESERVE\
    \  |          |          |\n    |          |          +-------------------->|\
    \          |\n    |          |          | RESERVE' |          |          |\n \
    \   |          |          +=========>| RESERVE' |          |\n    |          |\
    \          |          +=========>| RESERVE  |\n    |          |          |   \
    \       |          +--------->|\n    |          |          |          | RESPONSE'|\
    \          |\n    |          |          | RESPONSE'|<=========+          |\n \
    \   |          |          |<=========+          |          |\n    |          |\
    \          |          |          | RESPONSE |\n    |          |          |   \
    \       | RESPONSE |<---------+\n    |          |          |<--------------------+\
    \          |\n    |          | RESPONSE |          |          |          |\n \
    \   |          |<---------+          |          |          |\n    | RESPONSE |\
    \          |          |          |          |\n    |<---------+          |   \
    \       |          |          |\n    |          |          |          |      \
    \    |          |\n    |          |          |          |          |         \
    \ |\n         Figure 11: Sender-Initiated Reservation with Aggregation\n   An\
    \ end-to-end per-flow reservation is initiated with the messages\n   shown in\
    \ Figure 11 as \"RESERVE\".\n   At the aggregator, a reservation for the aggregated\
    \ flow is initiated\n   (shown in Figure 11 as \"RESERVE'\").  This may use the\
    \ same QoS model\n   as the end-to-end reservation but has an MRI identifying\
    \ the\n   aggregated flow (e.g., tunnel) instead of for the individual flows.\n\
    \   This document does not specify how the QSPEC of the aggregate session\n  \
    \ can be derived from the QSPECs of the end-to-end sessions.\n   The messages\
    \ used for the signaling of the individual reservation\n   need to be marked such\
    \ that the intermediate routers will not inspect\n   them.  In the QoS NSLP, the\
    \ following marking policy is applied; see\n   also RFC 3175.\n   All routers\
    \ use essentially the same algorithm for which messages\n   they process, i.e.,\
    \ all messages at aggregation level 0.  However,\n   messages have their aggregation\
    \ level incremented on entry to an\n   aggregation region and decremented on exit.\
    \  In this technique, the\n   interior routers are not required to do any rewriting\
    \ of the RAO\n   values.  However, the aggregating/deaggregating routers must\n\
    \   distinguish the interfaces and associated aggregation levels.  These\n   routers\
    \ also perform message rewriting at these boundaries.\n   In particular, the Aggregator\
    \ performs the marking by modifying the\n   QoS NSLP default NSLPID value to an\
    \ NSLPID predefined value; see\n   Section 6.6.  A RAO value is then uniquely\
    \ derivable from each\n   predefined NSLPID.  However, the RAO does not have to\
    \ have a one-to-\n   one relation to a specific NSLPID.\n             Aggregator\
    \                    Deaggregator\n                +---+     +---+     +---+ \
    \    +---+\n                |QNI|-----|QNE|-----|QNE|-----|QNR|         aggregate\n\
    \                +---+     +---+     +---+     +---+         reservation\n   +---+\
    \     +---+     .....     .....     +---+     +---+\n   |QNI|-----|QNE|-----.\
    \   .-----.   .-----|QNE|-----|QNR|  end-to-end\n   +---+     +---+     .....\
    \     .....     +---+     +---+  reservation\n                    Figure 12: Reservation\
    \ Aggregation\n   The deaggregator acts as the QNR for the aggregate reservation.\n\
    \   Session binding information carried in the RESERVE message enables\n   the\
    \ deaggregator to associate the end-to-end and aggregate\n   reservations with\
    \ one another (using the BOUND-SESSION-ID).\n   The key difference between this\
    \ example and the one shown in\n   Section 4.7.1 is that the flow identifier for\
    \ the aggregate is\n   expected to be different to that for the end-to-end reservation.\
    \  The\n   aggregate reservation can be updated independently of the per-flow\n\
    \   end-to-end reservations.\n"
- title: 4.6.  Message Binding
  contents:
  - "4.6.  Message Binding\n   Section 4.5 sketches the interaction of an aggregated\
    \ end-to-end flow\n   and an aggregate.  For this scenario, and probably others,\
    \ it is\n   useful to have a method for synchronizing the exchanges of signaling\n\
    \   messages of different sessions.  This can be used to speed up\n   signaling,\
    \ because some message exchanges can be started\n   simultaneously and can be\
    \ processed in parallel until further\n   processing of a message from one particular\
    \ session depends on\n   another message from a different session.  For instance,\
    \ Figure 11\n   shows a case where inclusion of a new reservation requires that\
    \ the\n   capacity of the encompassing aggregate be increased first.  So the\n\
    \   RESERVE (bound message) for the individual flow arriving at the\n   deaggregator\
    \ should wait until the RESERVE' (binding message) for the\n   aggregate arrived\
    \ successfully (otherwise, the individual flow cannot\n   be included in the existing\
    \ aggregate and cannot be admitted).\n   Another alternative would be to increase\
    \ the aggregate first and then\n   to reserve resources for a set of aggregated\
    \ individual flows.  In\n   this case, the binding and synchronization between\
    \ the (RESERVE and\n   RESERVE') messages are not needed.\n   A message binding\
    \ may be used (depending an the aggregators policy)\n   as follows: a QNE (aggregator\
    \ QNI' in Figure 14) generates randomly a\n   128-bit MSG-ID (same rules apply\
    \ as for generating a SESSION-ID) and\n   includes it as BOUND-MSG-ID object into\
    \ the bound signaling message\n   (RESERVE (1) in Figure 13) that should wait\
    \ for the arrival of a\n   related binding signaling message (RESERVE' (3) in\
    \ Figure 13) that\n   carries the associated MSG-ID object.  The BOUND-SESSION-ID\
    \ should\n   also be set accordingly.  Only one MSG-ID or BOUND-MSG-ID object\
    \ per\n   message is allowed.  If the dependency relation between the two\n  \
    \ messages is bidirectional, then the Message_Binding_Type flag is SET\n   (value\
    \ is 1).  Otherwise, the Message_Binding_Type flag is UNSET.  In\n   most cases,\
    \ an RII object must be included in order to get a\n   corresponding RESPONSE\
    \ back.\n   Depending on the arrival sequence of the bound signaling message\n\
    \   (RESERVE (1) in Figure 13) and the \"triggering\" binding signaling\n   message\
    \ (RESERVE' (3) in Figure 13), different situations can be\n   identified:\n \
    \  o  The bound signaling (RESERVE (1)) arrives first.  The receiving\n      QNE\
    \ enqueues (probably after some pre-processing) the signaling\n      (RESERVE\
    \ (1)) message for the corresponding session.  It also\n      starts a MsgIDWait\
    \ timer in order to discard the message in case\n      the related \"triggering\"\
    \ message (RESERVE' in Figure 13) does not\n      arrive.  The timeout period\
    \ for this time SHOULD be set to the\n      default retransmission timeout period\
    \ (QOSNSLP_REQUEST_RETRY).  In\n      case a retransmitted RESERVE message arrives\
    \ before the timeout,\n      it will simply override the waiting message (i.e.,\
    \ the latter is\n      discarded, and the new message is now waiting with the\
    \ MsgIDWait\n      timer being reset).\n   At the same time, the \"triggering\"\
    \ message including a MSG-ID object,\n   carrying the same value as the BOUND-MSG-ID\
    \ object is sent by the\n   same initiating QNE (QNI' in Figure 13).  The intermediate\
    \ QNE' sees\n   the MSG-ID object, but can determine that it is not the endpoint\
    \ for\n   the session (QNR') and therefore simply forwards the message after\n\
    \   normal processing.  The receiving QNE (QNR') as endpoint for the\n   aggregate\
    \ session (i.e., deaggregator) interprets the MSG-ID object\n   and looks for\
    \ a corresponding waiting message with a BOUND-MSG-ID of\n   the same value whose\
    \ waiting condition is satisfied now.  Depending\n   on successful processing\
    \ of the RESERVE' (3), processing of the\n   waiting RESERVE will be resumed,\
    \ and the MsgIDWait timer will be\n   stopped as soon as the related RESERVE'\
    \ arrived.\n      QNI        QNE      QNE/QNI'     QNE'    QNR'/QNE      QNR\n\
    \                        aggregator           deaggregator\n       |         \
    \ |          |          |          |          |\n       | RESERVE  |         \
    \ |          |          |          |\n       +--------->|          |         \
    \ |          |          |\n       |          | RESERVE  |          |         \
    \ |          |\n       |          +--------->|          |          |         \
    \ |\n       |          |          | RESERVE  |          |          |\n       |\
    \          |          |   (1)    |          |          |\n       |          |\
    \          +-------------------->|          |\n       |          |          |\
    \ RESERVE' |          |          |\n       |          |          |   (2)    |\
    \          |          |\n       |          |          +=========>| RESERVE' |\
    \          |\n       |          |          |          |   (3)    |          |\n\
    \       |          |          |          +=========>| RESERVE  |\n       |   \
    \       |          |          |          |   (4)    |\n       |          |   \
    \       |          |          +--------->|\n       |          |          |   \
    \       | RESPONSE'|          |\n       |          |          | RESPONSE'|<=========+\
    \          |\n       |          |          |<=========+          |          |\n\
    \       |          |          |          |          | RESPONSE |\n       |   \
    \       |          |          | RESPONSE |<---------+\n       |          |   \
    \       |<--------------------+          |\n       |          | RESPONSE |   \
    \       |          |          |\n       |          |<---------+          |   \
    \       |          |\n       | RESPONSE |          |          |          |   \
    \       |\n       |<---------+          |          |          |          |\n \
    \      |          |          |          |          |          |\n       |    \
    \      |          |          |          |          |\n   (1):     RESERVE:  SESSION-ID=F,\
    \ BOUND-MSG-ID=x, BOUND-SESSION-ID=A\n   (2)+(3): RESERVE': SESSION-ID=A, MSG-ID=x\n\
    \   (4):     RESERVE:  SESSION-ID=F  (MSG-ID object was removed)\n           \
    \    Figure 13: Example for Using Message Binding\n   Several further cases have\
    \ to be considered in this context:\n   o  \"Triggering message\" (3) arrives\
    \ before waiting (bound) message\n      (1): In this case, the processing of the\
    \ triggering message\n      depends on the value of the Message_Binding_Type flag.\
    \  If\n      Message_Binding_Type is UNSET (value is 0), then the triggering\n\
    \      message can be processed normally, but the MSG-ID and the result\n    \
    \  (success or failure) should be saved for the waiting message.\n      Thus,\
    \ the RESPONSE' can be sent by the QNR' immediately.  If the\n      waiting message\
    \ (1) finally arrives at the QNR', it can be\n      detected that the waiting\
    \ condition was already satisfied because\n      the triggering message already\
    \ arrived earlier.  If\n      Message_Binding_Type is SET (value is 1), then the\
    \ triggering\n      message interprets the MSG-ID object and looks for the\n \
    \     corresponding waiting message with a BOUND-MSG-ID of the same\n      value,\
    \ which in this case has not yet arrived.  It then starts a\n      MsgIDWait timer\
    \ in order to discard the message in case the\n      related message (RESERVE\
    \ (1) in Figure 14) does not arrive.\n      Depending on successful processing\
    \ of the RESERVE (1), processing\n      of the waiting RESERVE' will be resumed,\
    \ the MsgIDWait timer will\n      be stopped as soon as the related RESERVE arrives\
    \ and the\n      RESPONSE' can be sent by the QNR' towards the QNI'.\n   o  The\
    \ \"triggering message\" (3) does not arrive at all: this may be\n      due to\
    \ message loss (which will cause a retransmission by the QNI'\n      if the RII\
    \ object is included) or due to a reservation failure at\n      an intermediate\
    \ node (QNE' in the example).  The MsgIDWait timeout\n      will then simply discard\
    \ the waiting message at QNR'.  In this\n      case, the QNR' MAY send a RESPONSE\
    \ message towards the QNI\n      informing it that the synchronization of the\
    \ two messages has\n      failed.\n   o  Retransmissions should use the same MSG-ID\
    \ because usually only\n      one of the two related messages is retransmitted.\
    \  As mentioned\n      above: retransmissions will only occur if the RII object\
    \ is set in\n      the RESERVE.  If a retransmitted message with a MSG-ID arrives\n\
    \      while a bound message with the same MSG-ID is still waiting, the\n    \
    \  retransmitted message will replace the bound message.\n   For a receiving node,\
    \ there are conceptually two lists indexed by\n   message IDs.  One list contains\
    \ the IDs and results of triggering\n   messages (those carrying a MSG-ID object),\
    \ the other list contains\n   the IDs and message contents of the bound waiting\
    \ messages (those who\n   carried a BOUND-MSG-ID).  The former list is used when\
    \ a triggering\n   message arrives before the bound message.  The latter list\
    \ is used\n   when a bound message arrives before a triggering message.\n"
- title: 4.7.  Reduced-State or Stateless Interior Nodes
  contents:
  - "4.7.  Reduced-State or Stateless Interior Nodes\n   This example uses a different\
    \ QoS model within a domain, in\n   conjunction with GIST and NSLP functionality\
    \ that allows the interior\n   nodes to avoid storing GIST and QoS NSLP state.\
    \  As a result, the\n   interior nodes only store the QSPEC-related reservation\
    \ state or even\n   no state at all.  This allows the QoS model to use a form\
    \ of\n   \"reduced-state\" operation, where reservation states with a coarser\n\
    \   granularity (e.g., per-class) are used, or a \"stateless\" operation\n   where\
    \ no QoS NSLP state is needed (or created).  This is useful,\n   e.g., for measurement-based\
    \ admission control schemes.\n   The key difference between this example and the\
    \ use of different QoS\n   models in Section 4.5 is the transport characteristics\
    \ for the\n   reservation, i.e., GIST can be used in a different way for the edge-\n\
    \   to-edge and hop-by-hop sessions.  The reduced-state reservation can\n   be\
    \ updated independently of the per-flow end-to-end reservations.\n"
- title: 4.7.1.  Sender-Initiated Reservation
  contents:
  - "4.7.1.  Sender-Initiated Reservation\n   The QNI initiates a RESERVE message\
    \ (see Figure 14).  At the QNEs on\n   the edges of the stateless or reduced-state\
    \ region, the processing is\n   different and the nodes support two QoS models.\
    \  At the ingress, the\n   original RESERVE message is forwarded but ignored by\
    \ the stateless or\n   reduced-state nodes.  This is accomplished by marking this\
    \ message at\n   the ingress, i.e., modifying the QoS NSLP default NSLPID value\
    \ to an\n   NSLPID predefined value (see Section 4.6).  The egress must reassign\n\
    \   the QoS NSLP default NSLPID value to the original end-to-end RESERVE\n   message.\
    \  An example of such operation is given in [RFC5977].\n   The egress node is\
    \ the next QoS-NSLP hop for the end-to-end RESERVE\n   message.  Reliable GIST\
    \ transfer mode can be used between the ingress\n   and egress without requiring\
    \ GIST state in the interior.  At the\n   egress node, the RESERVE message is\
    \ then forwarded normally.\n   At the ingress, a second RESERVE' message is also\
    \ built (Figure 14).\n   This makes use of a QoS model suitable for a reduced-state\
    \ or\n   stateless form of operation (such as the RMD per-hop reservation).\n\
    \   Since the original RESERVE and the RESERVE' messages are addressed\n   identically,\
    \ the RESERVE' message also arrives at the same egress QNE\n   that was also traversed\
    \ by the RESERVE message.  Message binding is\n   used to synchronize the messages.\n\
    \   When processed by interior (stateless) nodes, the QoS NSLP processing\n  \
    \ exercises its options to not keep state wherever possible, so that no\n   per-flow\
    \ QoS NSLP state is stored.  Some state, e.g., per class, for\n   the QSPEC-related\
    \ data may be held at these interior nodes.  The QoS\n   NSLP also requests that\
    \ GIST use different transport characteristics\n   (e.g., sending of messages\
    \ in unreliable GIST transfer mode).  It\n   also requests the local GIST processing\
    \ not to retain messaging\n   association state or reverse message routing state.\n\
    \   Nodes, such as those in the interior of the stateless or reduced-\n   state\
    \ domain, that do not retain reservation state cannot send back\n   RESPONSE messages\
    \ (and so cannot use the refresh reduction\n   extension).\n   At the egress node,\
    \ the RESERVE' message is interpreted in\n   conjunction with the reservation\
    \ state from the end-to-end RESERVE\n   message (using information carried in\
    \ the message to correlate the\n   signaling flows).  The RESERVE message is only\
    \ forwarded further if\n   the processing of the RESERVE' message was successful\
    \ at all nodes in\n   the local domain; otherwise, the end-to-end reservation\
    \ is regarded\n   as having failed to be installed.  This can be realized by using\
    \ the\n   message binding functionality described in Section 4.6 to synchronize\n\
    \   the arrival of the bound signaling message (end-to-end RESERVE) and\n   the\
    \ binding signaling message (local RESERVE').\n           QNE             QNE\
    \             QNE            QNE\n         ingress         interior        interior\
    \        egress\n     GIST stateful  GIST stateless  GIST stateless  GIST stateful\n\
    \            |               A               B              |\n    RESERVE | \
    \              |               |              |\n   -------->| RESERVE       |\
    \               |              |\n            +--------------------------------------------->|\n\
    \            | RESERVE'      |               |              |\n            +-------------->|\
    \               |              |\n            |               | RESERVE'     \
    \ |              |\n            |               +-------------->|            \
    \  |\n            |               |               | RESERVE'     |\n         \
    \   |               |               +------------->|\n            |          \
    \     |               |  RESPONSE'   |\n            |<---------------------------------------------+\n\
    \            |               |               |              | RESERVE\n      \
    \      |               |               |              +-------->\n           \
    \ |               |               |              | RESPONSE\n            |   \
    \            |               |              |<--------\n            |        \
    \       |               |     RESPONSE |\n            |<---------------------------------------------+\n\
    \    RESPONSE|               |               |              |\n   <--------| \
    \              |               |              |\n    Figure 14: Sender-Initiated\
    \ Reservation with Reduced-State Interior\n                                  \
    \ Nodes\n   Resource management errors in the example above are reflected in the\n\
    \   QSPEC and QoS model processing.  For example, if the RESERVE' fails\n   at\
    \ QNE A, it cannot send an error message back to the ingress QNE.\n   Thus, the\
    \ RESERVE' is forwarded along the intended path, but the\n   QSPEC includes information\
    \ for subsequent QNEs telling them an error\n   happened upstream.  It is up to\
    \ the QoS model to determine what to\n   do.  Eventually, the RESERVE' will reach\
    \ the egress QNE, and again,\n   the QoS model then determines the response.\n"
- title: 4.7.2.  Receiver-Initiated Reservation
  contents:
  - "4.7.2.  Receiver-Initiated Reservation\n   Since NSLP neighbor relationships\
    \ are not maintained in the reduced-\n   state region, only sender-initiated signaling\
    \ can be supported within\n   the reduced-state region.  If a receiver-initiated\
    \ reservation over a\n   stateless or reduced-state domain is required, this can\
    \ be\n   implemented as shown in Figure 15.\n           QNE            QNE   \
    \         QNE\n         ingress        interior        egress\n     GIST stateful\
    \  GIST stateless  GIST stateful\n            |               |              \
    \ |\n    QUERY   |               |               |\n   -------->| QUERY      \
    \   |               |\n            +------------------------------>|\n       \
    \     |               |               | QUERY\n            |               | \
    \              +-------->\n            |               |               | RESERVE\n\
    \            |               |               |<--------\n            |       \
    \        |      RESERVE  |\n            |<------------------------------+\n  \
    \          | RESERVE'      | RESERVE'      |\n            |-------------->|-------------->|\n\
    \            |               |     RESPONSE' |\n            |<------------------------------+\n\
    \    RESERVE |               |               |\n   <--------|               |\
    \               |\n   Figure 15: Receiver-Initiated Reservation with Reduced-State\
    \ Interior\n                                   Nodes\n   The RESERVE message that\
    \ is received by the egress QNE of the\n   stateless domain is sent transparently\
    \ to the ingress QNE (known as\n   the source of the QUERY message).  When the\
    \ RESERVE message reaches\n   the ingress, the ingress QNE needs to send a sender-initiated\n\
    \   RESERVE' over the stateless domain.  The ingress QNE needs to wait\n   for\
    \ a RESPONSE'.  If the RESPONSE' notifies that the reservation was\n   accomplished\
    \ successfully, then the ingress QNE sends a RESERVE\n   message further upstream.\n"
- title: 4.8.  Proxy Mode
  contents:
  - "4.8.  Proxy Mode\n   Besides the sender- and receiver-initiated reservations,\
    \ the QoS NSLP\n   includes a functionality we refer to as Proxy Mode.  Here a\
    \ QNE is\n   set by administrator assignment to work as a proxy QNE (P-QNE) for\
    \ a\n   certain region, e.g., for an administrative domain.  A node\n   initiating\
    \ the signaling may set the PROXY scope flag to indicate\n   that the signaling\
    \ is meant to be confined within the area controlled\n   by the proxy, e.g., the\
    \ local access network.\n   The Proxy Mode has two uses.  First, it allows the\
    \ QoS NSLP signaling\n   to be confined to a pre-defined section of the path.\
    \  Second, it\n   allows a node to make reservations for an incoming data flow.\n\
    \   For outgoing data flows and sender-initiated reservations, the end\n   host\
    \ is the QNI, and sends a RESERVE with the PROXY scope flag set.\n   The P-QNE\
    \ is the QNR; it will receive the RESERVE, notice the PROXY\n   scope flag is\
    \ set and reply with a RESPONSE (if requested).  This\n   operation is the same\
    \ as illustrated in Figure 7.  The receiver-\n   oriented reservation for outgoing\
    \ flows works the same way as in\n   Figure 8, except that the P-QNE is the QNI.\n\
    \   For incoming data flows, the end host is the QNI, and it sends a\n   RESERVE\
    \ towards the data sender with the PROXY scope flag set.  Here\n   the end host\
    \ sets the MRI so that it indicates the end host as the\n   receiver of the data,\
    \ and sets the D-flag.\n   GIST is able to send messages towards the data sender\
    \ if there is\n   existing message routing state or it is able to use the Upstream\n\
    \   Q-mode Encapsulation.  In some cases, GIST will be unable to\n   determine\
    \ the appropriate next hop for the message, and so will\n   indicate a failure\
    \ to deliver it (by sending an error message).  This\n   may occur, for example,\
    \ if GIST attempts to determine an upstream\n   next hop and there are multiple\
    \ possible inbound routes that could be\n   used.\n   Bidirectional reservations\
    \ can be used, as discussed in Section 4.4.\n   The P-QNE will be the QNR or QNI\
    \ for reservations.\n   If the PROXY scope flag is set in an incoming QoS NSLP\
    \ message, the\n   QNE must set the same flag in all QoS NSLP messages it sends\
    \ that are\n   related to this session.\n"
- title: 5.  QoS NSLP Functional Specification
  contents:
  - '5.  QoS NSLP Functional Specification

    '
- title: 5.1.  QoS NSLP Message and Object Formats
  contents:
  - "5.1.  QoS NSLP Message and Object Formats\n   A QoS NSLP message consists of\
    \ a common header, followed by a body\n   consisting of a variable number of variable-length,\
    \ typed \"objects\".\n   The common header and other objects are encapsulated\
    \ together in a\n   GIST NSLP-Data object.  The following subsections define the\
    \ formats\n   of the common header and each of the QoS NSLP message types.  In\
    \ the\n   message formats, the common header is denoted as COMMON-HEADER.\n  \
    \ For each QoS NSLP message type, there is a set of rules for the\n   permissible\
    \ choice of object types.  These rules are specified using\n   the Augmented Backus-Naur\
    \ Form (ABNF) specified in RFC 5234\n   [RFC5234].  The ABNF implies an order\
    \ for the objects in a message.\n   However, in many (but not all) cases, object\
    \ order makes no logical\n   difference.  An implementation SHOULD create messages\
    \ with the\n   objects in the order shown here, but MUST accept the objects in\
    \ any\n   order.\n"
- title: 5.1.1.  Common Header
  contents:
  - "5.1.1.  Common Header\n   All GIST NSLP-Data objects for the QoS NSLP MUST contain\
    \ this common\n   header as the first 32 bits of the object (this is not the same\
    \ as\n   the GIST Common Header).\n    0                   1                 \
    \  2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3\
    \ 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   | Message Type  | Message Flags |      Generic Flags            |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   The fields in the common header are as follows:\n   Msg Type: 8 bits\n   \
    \   1 = RESERVE\n      2 = QUERY\n      3 = RESPONSE\n      4 = NOTIFY\n   Message-specific\
    \ flags: 8 bits\n      These flags are defined as part of the specification of\
    \ individual\n      messages, and, thus, are different with each message type.\n\
    \   Generic flags: 16 bits\n      Generic flags have the same meaning for all\
    \ message types.  There\n      exist currently four generic flags: the (next hop)\
    \ Scoping flag\n      (S), the Proxy scope flag (P), the Acknowledgement Requested\
    \ flag\n      (A), and the Break flag (B).\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |         Reserved      |B|A|P|S|\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   SCOPING (S) - when set, indicates that the message is scoped and\n   should\
    \ not travel down the entire path but only as far as the next\n   QNE (scope=\"\
    next hop\").  By default, this flag is not set (default\n   scope=\"whole path\"\
    ).\n   PROXY (P) - when set, indicates that the message is scoped, and\n   should\
    \ not travel down the entire path but only as far as the P-QNE.\n   By default,\
    \ this flag is not set.\n   ACK-REQ (A) - when set, indicates that the message\
    \ should be\n   acknowledged by the receiving peer.  The flag is only used between\n\
    \   stateful peers, and only used with RESERVE and QUERY messages.\n   Currently,\
    \ the flag is only used with refresh messages.  By default,\n   the flag is not\
    \ set.\n   BREAK (B) - when set, indicates that there are routers along the path\n\
    \   where QoS cannot be provided.\n   The set of appropriate flags depends on\
    \ the particular message being\n   processed.  Any bit not defined as a flag for\
    \ a particular message\n   MUST be set to zero on sending and MUST be ignored\
    \ on receiving.\n   The ACK-REQ flag is useful when a QNE wants to make sure the\
    \ messages\n   received by the downstream QNE are truly processed by the QoS NSLP,\n\
    \   not just delivered by GIST.  This is useful for faster dead peer\n   detection\
    \ on the NSLP layer.  This liveliness test can only be used\n   with refresh RESERVE\
    \ messages.  The ACK-REQ flag must not be set for\n   RESERVE messages that already\
    \ include an RII object, since a\n   confirmation has already been requested from\
    \ the QNR.  Reliable\n   transmission of messages between two QoS NSLP peers should\
    \ be handled\n   by GIST, not the NSLP by itself.\n"
- title: 5.1.2.  Message Formats
  contents:
  - '5.1.2.  Message Formats

    '
- title: 5.1.2.1.  RESERVE
  contents:
  - "5.1.2.1.  RESERVE\n   The format of a RESERVE message is as follows:\n      RESERVE\
    \ = COMMON-HEADER\n                RSN [ RII ] [ REFRESH-PERIOD ] [ *BOUND-SESSION-ID\
    \ ]\n                [ SESSION-ID-LIST [ RSN-LIST ] ]\n                [ MSG-ID\
    \ / BOUND-MSG-ID ] [ INFO-SPEC ]\n                [ [ PACKET-CLASSIFIER ] QSPEC\
    \ ]\n   The RSN is the only mandatory object and MUST always be present in\n \
    \  all cases.  A QSPEC MUST be included in the initial RESERVE sent\n   towards\
    \ the QNR.  A PACKET-CLASSIFIER MAY be provided.  If the\n   PACKET-CLASSIFIER\
    \ is not provided, then the full set of information\n   provided in the GIST MRI\
    \ for the session should be used for packet\n   classification purposes.\n   Subsequent\
    \ RESERVE messages meant as reduced refreshes, where no\n   QSPEC is provided,\
    \ MUST NOT include a PACKET-CLASSIFIER either.\n   There are no requirements on\
    \ transmission order, although the above\n   order is recommended.\n   Two message-specific\
    \ flags are defined for use in the common header\n   with the RESERVE message.\
    \  These are:\n   +-+-+-+-+-+-+-+-+\n   |Reserved   |T|R|\n   +-+-+-+-+-+-+-+-+\n\
    \   TEAR (T) - when set, indicates that reservation state and QoS NSLP\n   operation\
    \ state should be torn down.  The former is indicated to the\n   RMF.  Depending\
    \ on the QoS model, the tear message may include a\n   QSPEC to further specify\
    \ state removal, e.g., for an aggregation, the\n   QSPEC may specify the amount\
    \ of resources to be removed from the\n   aggregate.\n   REPLACE (R) - when set,\
    \ the flag has two uses.  First, it indicates\n   that a RESERVE with different\
    \ MRI (but same SID) replaces an existing\n   one, so the old one MAY be torn\
    \ down immediately.  This is the\n   default situation.  This flag may be unset\
    \ to indicate a desire from\n   an upstream node to keep an existing reservation\
    \ on an old branch in\n   place.  Second, this flag is also used to indicate whether\
    \ the\n   reserved resources on the old branch should be torn down or not when\n\
    \   a data path change happens.  In this case, the MRI is the same and\n   only\
    \ the route path changes.\n   If the REFRESH-PERIOD is not present, a default\
    \ value of 30 seconds\n   is assumed.\n   If the session of this message is bound\
    \ to another session, then the\n   RESERVE message MUST include the SESSION-ID\
    \ of that other session in\n   a BOUND-SESSION-ID object.  In the situation of\
    \ aggregated tunnels,\n   the aggregated session MAY not include the SESSION-ID\
    \ of its bound\n   sessions in BOUND-SESSION-ID(s).\n   The negotiation of whether\
    \ to perform sender- or receiver-initiated\n   signaling is done outside the QoS\
    \ NSLP.  Yet, in theory, it is\n   possible that a \"reservation collision\" may\
    \ occur if the sender\n   believes that a sender-initiated reservation should\
    \ be performed for\n   a flow, whilst the other end believes that it should be\
    \ starting a\n   receiver-initiated reservation.  If different session identifiers\
    \ are\n   used, then this error condition is transparent to the QoS NSLP,\n  \
    \ though it may result in an error from the RMF.  Otherwise, the\n   removal of\
    \ the duplicate reservation is left to the QNIs/QNRs for the\n   two sessions.\n\
    \   If a reservation is already installed and a RESERVE message is\n   received\
    \ with the same session identifier from the other direction\n   (i.e., going upstream\
    \ where the reservation was installed by a\n   downstream RESERVE message, or\
    \ vice versa), then an error indicating\n   \"RESERVE received from wrong direction\"\
    \ MUST be sent in a RESPONSE\n   message to the signaling message source for this\
    \ second RESERVE.\n   A refresh right along the path can be forced by requesting\
    \ a RESPONSE\n   from the far end (i.e., by including an RII object in the RESERVE\n\
    \   message).  Without this, a refresh RESERVE would not trigger RESERVE\n   messages\
    \ to be sent further along the path, as each hop has its own\n   refresh timer.\n\
    \   A QNE may ask for confirmation of a tear operation by including an\n   RII\
    \ object.  QoS NSLP retransmissions SHOULD be disabled.  A QNE\n   sending a tearing\
    \ RESERVE with an RII included MAY ask GIST to use\n   reliable transport.  When\
    \ the QNE sends out a tearing RESERVE, it\n   MUST NOT send refresh messages anymore.\n\
    \   If the routing path changed due to mobility and the mobile node's IP\n   address\
    \ changed, and it sent a Mobile IP binding update, the\n   resulting refresh is\
    \ a new RESERVE.  This RESERVE includes a new MRI\n   and will be propagated end-to-end;\
    \ there is no need to force end-to-\n   end forwarding by including an RII.\n\
    \   Note: It is possible for a host to use this mechanism to constantly\n   force\
    \ the QNEs on the path to send refreshing RESERVE messages.  It\n   may, therefore,\
    \ be appropriate for QNEs to perform rate-limiting on\n   the refresh messages\
    \ that they send.\n"
- title: 5.1.2.2.  QUERY
  contents:
  - "5.1.2.2.  QUERY\n   The format of a QUERY message is as follows:\n      QUERY\
    \ = COMMON-HEADER\n              [ RII ] [ *BOUND-SESSION-ID ]\n             \
    \ [ PACKET-CLASSIFIER ] [ INFO-SPEC ] QSPEC [ QSPEC ]\n   QUERY messages MUST\
    \ always include a QSPEC.  QUERY messages MAY\n   include a PACKET-CLASSIFIER\
    \ when the message is used to trigger a\n   receiver-initiated reservation.  If\
    \ a PACKET-CLASSIFIER is not\n   included then the full GIST MRI should be used\
    \ for packet\n   classification purposes in the subsequent RESERVE.  A QUERY message\n\
    \   MAY contain a second QSPEC object.\n   A QUERY message for requesting information\
    \ about network resources\n   MUST contain an RII object to match an incoming\
    \ RESPONSE to the\n   QUERY.\n   The QSPEC object describes what is being queried\
    \ for and may contain\n   objects that gather information along the data path.\
    \  There are no\n   requirements on transmission order, although the above order\
    \ is\n   recommended.\n   One message-specific flag is defined for use in the\
    \ common header\n   with the QUERY message.  It is:\n   +-+-+-+-+-+-+-+-+\n  \
    \ |Reserved     |R|\n   +-+-+-+-+-+-+-+-+\n   RESERVE-INIT (R) - when this is\
    \ set, the QUERY is meant as a trigger\n   for the recipient to make a resource\
    \ reservation by sending a\n   RESERVE.\n   If the session of this message is\
    \ bound to another session, then the\n   RESERVE message MUST include the SESSION-ID\
    \ of that other session in\n   a BOUND-SESSION-ID object.  In the situation of\
    \ aggregated tunnels,\n   the aggregated session MAY not include the SESSION-ID\
    \ of its bound\n   sessions in BOUND-SESSION-ID(s).\n"
- title: 5.1.2.3.  RESPONSE
  contents:
  - "5.1.2.3.  RESPONSE\n   The format of a RESPONSE message is as follows:\n    \
    \  RESPONSE = COMMON-HEADER\n                 [ RII / RSN ] INFO-SPEC [SESSION-ID-LIST\
    \ [ RSN-LIST ] ]\n                 [ QSPEC ]\n   A RESPONSE message MUST contain\
    \ an INFO-SPEC object that indicates\n   the success of a reservation installation\
    \ or an error condition.\n   Depending on the value of the INFO-SPEC, the RESPONSE\
    \ MAY also\n   contain a QSPEC object.  The value of an RII or an RSN object was\n\
    \   provided by some previous QNE.  There are no requirements on\n   transmission\
    \ order, although the above order is recommended.\n   No message-specific flags\
    \ are defined for use in the common header\n   with the RESPONSE message.\n"
- title: 5.1.2.4.  NOTIFY
  contents:
  - "5.1.2.4.  NOTIFY\n   The format of a NOTIFY message is as follows:\n      NOTIFY\
    \ = COMMON-HEADER\n               INFO-SPEC [ QSPEC ]\n   A NOTIFY message MUST\
    \ contain an INFO-SPEC object indicating the\n   reason for the notification.\
    \  Depending on the INFO-SPEC value, it\n   MAY contain a QSPEC object providing\
    \ additional information.\n   No message-specific flags are defined for use with\
    \ the NOTIFY\n   message.\n"
- title: 5.1.3.  Object Formats
  contents:
  - "5.1.3.  Object Formats\n   The QoS NSLP uses a Type-Length-Value (TLV) object\
    \ format similar to\n   that used by GIST.  Every object consists of one or more\
    \ 32-bit words\n   with a one-word header.  For convenience, the standard object\
    \ header\n   is shown here:\n    0                   1                   2   \
    \                3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6\
    \ 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |A|B|r|r|         Type          |r|r|r|r|        Length         |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   The value for the Type field comes from the shared NSLP object type\n   space;\
    \ the various objects are presented in subsequent sections.  The\n   Length field\
    \ is given in units of 32-bit words and measures the\n   length of the Value component\
    \ of the TLV object (i.e., it does not\n   include the standard header).\n   The\
    \ bits marked 'A' and 'B' are flags used to signal the desired\n   treatment for\
    \ objects whose treatment has not been defined in the\n   protocol specification\
    \ (i.e., whose Type field is unknown at the\n   receiver).  The following four\
    \ categories of object have been\n   identified, and are described here.\n   \
    \   AB=00 (\"Mandatory\"): If the object is not understood, the entire\n     \
    \ message containing it MUST be rejected, and an error message sent\n      back.\n\
    \      AB=01 (\"Ignore\"): If the object is not understood, it MUST be\n     \
    \ deleted and the rest of the message processed as usual.\n      AB=10 (\"Forward\"\
    ): If the object is not understood, it MUST be\n      retained unchanged in any\
    \ message forwarded as a result of message\n      processing, but not stored locally.\n\
    \      AB=11 (\"Refresh\"): If the object is not understood, it should be\n  \
    \    incorporated into the locally stored QoS NSLP signaling\n      application\
    \ operational state for this flow/session, forwarded in\n      any resulting message,\
    \ and also used in any refresh or repair\n      message that is generated locally.\
    \  The contents of this object\n      does not need to be interpreted, and should\
    \ only be stored as\n      bytes on the QNE.\n   The remaining bits marked 'r'\
    \ are reserved.  These SHALL be set to 0\n   and SHALL be ignored on reception.\
    \  The extensibility flags AB are\n   similar to those used in the GIST specification.\
    \  All objects defined\n   in this specification MUST be understood by all QNEs;\
    \ thus, they MUST\n   have the AB-bits set to \"00\".  A QoS NSLP implementation\
    \ must\n   recognize objects of the following types: RII, RSN, REFRESH-PERIOD,\n\
    \   BOUND-SESSION-ID, INFO-SPEC, and QSPEC.\n   The object header is followed\
    \ by the Value field, which varies for\n   different objects.  The format of the\
    \ Value field for currently\n   defined objects is specified below.\n   The object\
    \ diagrams here use '//' to indicate a variable-sized field.\n"
- title: 5.1.3.1.  Request Identification Information (RII)
  contents:
  - "5.1.3.1.  Request Identification Information (RII)\n   Type: 0x001\n   Length:\
    \ Fixed - 1 32-bit word\n   Value: An identifier that MUST be (probabilistically)\
    \ unique within\n   the context of a SESSION-ID and SHOULD be different every\
    \ time a\n   RESPONSE is desired.  Used by a QNE to match back a RESPONSE to a\n\
    \   request in a RESERVE or QUERY message.\n    0                   1        \
    \           2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9\
    \ 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |            Request Identification Information (RII)           |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n"
- title: 5.1.3.2.  Reservation Sequence Number (RSN)
  contents:
  - "5.1.3.2.  Reservation Sequence Number (RSN)\n   Type: 0x002\n   Length: Fixed\
    \ - 2 32-bit words\n   Value: An incrementing sequence number that indicates the\
    \ order in\n   which state-modifying actions are performed by a QNE, and an epoch\n\
    \   identifier to allow the identification of peer restarts.  The RSN has\n  \
    \ local significance only, i.e., between a QNE and its downstream\n   stateful\
    \ peers.  The RSN is not reset when the downstream peer\n   changes.\n    0  \
    \                 1                   2                   3\n    0 1 2 3 4 5 6\
    \ 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |               Reservation Sequence Number (RSN)               |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                       Epoch Identifier                        |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n"
- title: 5.1.3.3.  Refresh Period (REFRESH-PERIOD)
  contents:
  - "5.1.3.3.  Refresh Period (REFRESH-PERIOD)\n   Type: 0x003\n   Length: Fixed -\
    \ 1 32-bit word\n   Value: The refresh timeout period R used to generate this\
    \ message; in\n   milliseconds.\n    0                   1                   2\
    \                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5\
    \ 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                      Refresh Period (R)                       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n"
- title: 5.1.3.4.  Bound Session ID (BOUND-SESSION-ID)
  contents:
  - "5.1.3.4.  Bound Session ID (BOUND-SESSION-ID)\n   Type: 0x004\n   Length: Fixed\
    \ - 5 32-bit words\n   Value: contains an 8-bit Binding_Code that indicates the\
    \ nature of\n   the binding.  The rest specifies the SESSION-ID (as specified\
    \ in GIST\n   [RFC5971]) of the session that MUST be bound to the session\n  \
    \ associated with the message carrying this object.\n    0                   1\
    \                   2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5\
    \ 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                  RESERVED                     |  Binding Code |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                                                               |\n   +  \
    \                                                             +\n   |        \
    \                                                       |\n   +              \
    \            Session ID                           +\n   |                    \
    \                                           |\n   +                          \
    \                                     +\n   |                                \
    \                               |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   Currently defined Binding Codes are:\n   o  0x01 - Tunnel and end-to-end sessions\n\
    \   o  0x02 - Bidirectional sessions\n   o  0x03 - Aggregate sessions\n   o  0x04\
    \ - Dependent sessions (binding session is alive only if the\n      other session\
    \ is also alive)\n   o  0x05 - Indicated session caused preemption\n   More binding\
    \ codes may be defined based on the above five atomic\n   binding actions.  Note\
    \ a message may include more than one BOUND-\n   SESSION-ID object.  This may\
    \ be needed in case one needs to define\n   more specifically the reason for binding,\
    \ or if the session depends\n   on more than one other session (with possibly\
    \ different reasons).\n   Note that a session with, e.g., SID_A (the binding session),\
    \ can\n   express its unidirectional dependency relation to another session\n\
    \   with, e.g., SID_B (the bound session), by including a\n   BOUND-SESSION-ID\
    \ object containing SID_B in its messages.\n"
- title: 5.1.3.5.  Packet Classifier (PACKET-CLASSIFIER)
  contents:
  - "5.1.3.5.  Packet Classifier (PACKET-CLASSIFIER)\n   Type: 0x005\n   Length: Variable\n\
    \   Value: Contains variable-length MRM-specific data\n    0                 \
    \  1                   2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3\
    \ 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   //          Method-specific classifier data (variable)         //\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   At this stage, the QoS NSLP only uses the path-coupled routing MRM.\n   The\
    \ method-specific classifier data is four bytes long and consists\n   of a set\
    \ of flags:\n    0                   1                   2                   3\n\
    \    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-++-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |X|Y|P|T|F|S|A|B|                      Reserved                |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-++-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   The flags are:\n   X - Source Address and Prefix\n   Y - Destination Address\
    \ and Prefix\n   P - Protocol\n   T - Diffserv Code Point\n   F - Flow Label\n\
    \   S - SPI\n   A - Source Port\n   B - Destination Port\n   The flags indicate\
    \ which fields from the MRI MUST be used by the\n   packet classifier.  This allows\
    \ a subset of the information in the\n   MRI to be used for identifying the set\
    \ of packets that are part of\n   the reservation.  Flags MUST only be set if\
    \ the data is present in\n   the MRI (i.e., where there is a corresponding flag\
    \ in the GIST MRI,\n   the flag can only be set if the corresponding GIST MRI\
    \ flag is set).\n   It should be noted that some flags in the PACKET-CLASSIFIER\
    \ (X and Y)\n   relate to data that is always present in the MRI, but are optional\
    \ to\n   use for QoS NSLP packet classification.  The appropriate set of flags\n\
    \   set may depend, to some extent, on the QoS model being used.\n   As mentioned\
    \ earlier in this section, the QoS NSLP is currently only\n   defined for use\
    \ with the Path-Coupled Message Routing Method (MRM) in\n   GIST.  Future work\
    \ may extend the QoS NSLP to additional routing\n   mechanisms.  Such MRMs must\
    \ include sufficient information in the MRI\n   to allow the subset of packets\
    \ for which QoS is to be provided to be\n   identified.  When QoS NSLP is extended\
    \ to support a new MRM,\n   appropriate method-specific classifier data for the\
    \ PACKET-CLASSIFIER\n   object MUST be defined.\n"
- title: 5.1.3.6.  Information Object (INFO-SPEC) and Error Codes
  contents:
  - "5.1.3.6.  Information Object (INFO-SPEC) and Error Codes\n   Type: 0x006\n  \
    \ Length: Variable\n   Value: Contains 8 reserved bits, an 8-bit error code, a\
    \ 4-bit error\n   class, a 4-bit error source identifier type, and an 8-bit error\n\
    \   source identifier length (in 32-bit words), an error source\n   identifier,\
    \ and optionally variable-length error-specific\n   information.\n    0      \
    \             1                   2                   3\n    0 1 2 3 4 5 6 7 8\
    \ 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |    Reserved   |  Error Code   |E-Class|ESI Typ|   ESI-Length  |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   //                   Error Source Identifier                   //\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   //             Optional error-specific information             //\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   Class Field:\n   The four E-Class bits of the object indicate the error severity\n\
    \   class.  The currently defined error classes are:\n   o  1 - Informational\n\
    \   o  2 - Success\n   o  3 - Protocol Error\n   o  4 - Transient Failure\n  \
    \ o  5 - Permanent Failure\n   o  6 - QoS Model Error\n   Error field:\n   Within\
    \ each error severity class, a number of Error Code values are\n   defined.\n\
    \   o Informational:\n      *  0x01 -  Unknown BOUND-SESSION-ID: the message refers\
    \ to an\n                 unknown SESSION-ID in its BOUND-SESSION-ID object.\n\
    \      *  0x02 -  Route Change: possible route change occurred on\n          \
    \       downstream path.\n      *  0x03 -  Reduced refreshes not supported; full\
    \ QSPEC required.\n      *  0x04 -  Congestion situation: Possible congestion\
    \ situation\n                 occurred on downstream path.\n      *  0x05 -  Unknown\
    \ SESSION-ID in SESSION-ID-LIST.\n      *  0x06 -  Mismatching RSN in RSN-LIST.\n\
    \   o Success:\n      *  0x01 -  Reservation successful\n      *  0x02 -  Teardown\
    \ successful\n      *  0x03 -  Acknowledgement\n      *  0x04 -  Refresh successful\n\
    \   o Protocol Error:\n      *  0x01 -  Illegal message type: the type given in\
    \ the Message\n                 Type field of the common header is unknown.\n\
    \      *  0x02 -  Wrong message length: the length given for the message\n   \
    \              does not match the length of the message data.\n      *  0x03 -\
    \  Bad flags value: an undefined flag or combination of\n                 flags\
    \ was set in the generic flags.\n      *  0x04 -  Bad flags value: an undefined\
    \ flag or combination of\n                 flags was set in the message-specific\
    \ flags.\n      *  0x05 -  Mandatory object missing: an object required in a\n\
    \                 message of this type was missing.\n      *  0x06 -  Illegal\
    \ object present: an object was present that must\n                 not be used\
    \ in a message of this type.\n      *  0x07 -  Unknown object present: an object\
    \ of an unknown type\n                 was present in the message.\n      *  0x08\
    \ -  Wrong object length: the length given for the object\n                 did\
    \ not match the length of the object data present.\n      *  0x09 -  RESERVE received\
    \ from wrong direction.\n      *  0x0a -  Unknown object field value: a field\
    \ in an object had an\n                 unknown value.\n      *  0x0b -  Duplicate\
    \ object present.\n      *  0x0c -  Malformed QSPEC.\n      *  0x0d -  Unknown\
    \ MRI.\n      *  0x0e -  Erroneous value in the TLV object's value field.\n  \
    \    *  0x0f -  Incompatible QSPEC.\n   o Transient Failure:\n      *  0x01 -\
    \  No GIST reverse-path forwarding state\n      *  0x02 -  No path state for RESERVE,\
    \ when doing a receiver-\n                 oriented reservation\n      *  0x03\
    \ -  RII conflict\n      *  0x04 -  Full QSPEC required\n      *  0x05 -  Mismatch\
    \ synchronization between end-to-end RESERVE and\n                 intra-domain\
    \ RESERVE\n      *  0x06 -  Reservation preempted\n      *  0x07 -  Reservation\
    \ failure\n      *  0x08 -  Path truncated - Next peer dead\n   o Permanent Failure:\n\
    \      *  0x01 -  Internal or system error\n      *  0x02 -  Authorization failure\n\
    \   o QoS Model Error:\n      This error class can be used by QoS models to add\
    \ error codes\n      specific to the QoS model being used.  All these errors and\
    \ events\n      are created outside the QoS NSLP itself.  The error codes in this\n\
    \      class are defined in QoS model specifications.  Note that this\n      error\
    \ class may also include codes that are not purely errors, but\n      rather some\
    \ non-fatal information.\n   Error Source Identifier (ESI)\n   The Error Source\
    \ Identifier is for diagnostic purposes and its\n   inclusion is OPTIONAL.  It\
    \ is suggested that implementations use this\n   for the IP address, host name,\
    \ or other identifier of the QNE\n   generating the INFO-SPEC to aid diagnostic\
    \ activities.  A QNE SHOULD\n   NOT be used in any purpose other than error logging\
    \ or being\n   presented to the user as part of any diagnostic information.  A\
    \ QNE\n   SHOULD NOT attempt to send a message to that address.\n   If no Error\
    \ Source Identifier is included, the Error Source\n   Identifier Type field must\
    \ be zero.\n   Currently three Error Source Identifiers have been defined: IPv4,\n\
    \   IPv6, and FQDN.\n   Error Source Identifier: IPv4\n   Error Source Identifier\
    \ Type: 0x1\n    0                   1                   2                   3\n\
    \    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                      32-bit IPv4 address                      |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   Error Source Identifier: IPv6\n   Error Source Identifier Type: 0x2\n    0\
    \                   1                   2                   3\n    0 1 2 3 4 5\
    \ 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                                                               |\n   +  \
    \                                                             +\n   |        \
    \                                                       |\n   +              \
    \        128-bit IPv6 address                     +\n   |                    \
    \                                           |\n   +                          \
    \                                     +\n   |                                \
    \                               |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   Error Source Identifier: FQDN in UTF-8\n   Error Source Identifier Type: 0x3\n\
    \    0                   1                   2                   3\n    0 1 2\
    \ 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   //                            FQDN                             //\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   If the length of the FQDN is not a multiple of 32-bits, the field is\n   padded\
    \ with zero octets to the next 32-bit boundary.\n   If a QNE encounters protocol\
    \ errors, it MAY include additional\n   information, mainly for diagnostic purposes.\
    \  Additional information\n   MAY be included if the type of an object is erroneous,\
    \ or a field has\n   an erroneous value.\n   If the type of an object is erroneous,\
    \ the following optional error-\n   specific information may be included at the\
    \ end of the INFO-SPEC.\n   Object Type Info:\n    0                   1     \
    \              2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7\
    \ 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |         Object Type           |           Reserved            |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   This object provides information about the type of object that caused\n  \
    \ the error.\n   If a field in an object had an incorrect value, the following\n\
    \   Optional error-specific information may be added at the end of the\n   INFO-SPEC.\n\
    \   Object Value Info:\n    0                   1                   2        \
    \           3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9\
    \ 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   | Rsvd  |  Real Object Length   |            Offset             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   //                           Object                            //\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   Real Object Length: Since the length in the original TLV header may\n   be\
    \ inaccurate, this field provides the actual length of the object\n   (including\
    \ the TLV Header) included in the error message.\n   Offset: Indicates which part\
    \ of the erroneous object is included.\n   When this field is set to \"0\", the\
    \ complete object is included.  If\n   Offset is bigger than \"0\", the erroneous\
    \ object from offset\n   (calculated from the beginning of the object) to the\
    \ end of the\n   object is included.\n   Object: The invalid TLV object (including\
    \ the TLV Header).\n   This object carries information about a TLV object that\
    \ was found to\n   be invalid in the original message.  An error message may contain\n\
    \   more than one Object Value Info object.\n"
- title: 5.1.3.7.  SESSION-ID List (SESSION-ID-LIST)
  contents:
  - "5.1.3.7.  SESSION-ID List (SESSION-ID-LIST)\n   Type: 0x007\n   Length: Variable\n\
    \   Value: A list of 128-bit SESSION-IDs used in summary refresh and\n   summary\
    \ tear messages.  All SESSION-IDs are concatenated together.\n    0          \
    \         1                   2                   3\n    0 1 2 3 4 5 6 7 8 9 0\
    \ 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                                                               |\n   +  \
    \                                                             +\n   |        \
    \                                                       |\n   +              \
    \            Session ID 1                         +\n   |                    \
    \                                           |\n   +                          \
    \                                     +\n   |                                \
    \                               |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   :                                                               :\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                                                               |\n   +  \
    \                                                             +\n   |        \
    \                                                       |\n   +              \
    \            Session ID n                         +\n   |                    \
    \                                           |\n   +                          \
    \                                     +\n   |                                \
    \                               |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n"
- title: 5.1.3.8.  Reservation Sequence Number (RSN) List (RSN-LIST)
  contents:
  - "5.1.3.8.  Reservation Sequence Number (RSN) List (RSN-LIST)\n   Type: 0x008\n\
    \   Length: Variable\n   Value: A list of 32-bit Reservation Sequence Number (RSN)\
    \ values.\n   All RSN are concatenated together.\n    0                   1  \
    \                 2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6\
    \ 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                       Epoch Identifier                        |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |             Reservation Sequence Number 1 (RSN1)              |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   :                                                               :\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |             Reservation Sequence Number n (RSNn)              |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n"
- title: 5.1.3.9.  Message ID (MSG-ID)
  contents:
  - "5.1.3.9.  Message ID (MSG-ID)\n   Type: 0x009\n   Length: Fixed - 5 32-bit words\n\
    \   Value: contains a 1-bit Message_Binding_Type (D) that indicates the\n   dependency\
    \ relation of a message binding.  The rest specifies a\n   128-bit randomly generated\
    \ value that \"uniquely\" identifies this\n   particular message.\n       0  \
    \                 1                   2                   3\n       0 1 2 3 4\
    \ 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |                  RESERVED                                   |D|\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |\
    \                                                               |\n      +   \
    \                                                            +\n      |      \
    \                                                         |\n      +         \
    \                 Message ID                           +\n      |            \
    \                                                   |\n      +               \
    \                                                +\n      |                  \
    \                                             |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   The Message Binding Codes are:\n   * 0 - Unidirectional binding dependency\n\
    \   * 1 - Bidirectional binding dependency\n"
- title: 5.1.3.10.  Bound Message ID (BOUND-MSG-ID)
  contents:
  - "5.1.3.10.  Bound Message ID (BOUND-MSG-ID)\n   Type: 0x00A\n   Length: Fixed\
    \ - 5 32-bit words\n   Value: contains a 1-bit Message_Binding_Type (D) that indicates\
    \ the\n   dependency relation of a message binding.  The rest specifies a\n  \
    \ 128-bit randomly generated value that refers to a Message ID in\n   another\
    \ message.\n       0                   1                   2                 \
    \  3\n       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n\
    \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   \
    \   |                  RESERVED                                   |D|\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |                                                               |\n   \
    \   +                                                               +\n      |\
    \                                                               |\n      +   \
    \                     Bound Message ID                       +\n      |      \
    \                                                         |\n      +         \
    \                                                      +\n      |            \
    \                                                   |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   The Message Binding Codes are:\n   * 0 - Unidirectional binding dependency\n\
    \   * 1 - Bidirectional binding dependency\n"
- title: 5.1.3.11.  QoS Specification (QSPEC)
  contents:
  - "5.1.3.11.  QoS Specification (QSPEC)\n   Type: 0x00B\n   Length: Variable\n \
    \  Value: Variable-length QSPEC (QoS specification) information, which\n   is\
    \ dependent on the QoS model.\n   The contents and encoding rules for this object\
    \ are specified in\n   other documents.  See [RFC5975].\n    0               \
    \    1                   2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2\
    \ 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                                                               |\n   // \
    \                        QSPEC Data                          //\n   |        \
    \                                                       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n"
- title: 5.2.  General Processing Rules
  contents:
  - "5.2.  General Processing Rules\n   This section provides the general processing\
    \ rules used by QoS-NSLP.\n   The triggers communicated between RM/QOSM and QoS-NSLP\n\
    \   functionalities are given in Appendices Appendix A.1, Appendix A.2,\n   and\
    \ Appendix A.3.\n"
- title: 5.2.1.  State Manipulation
  contents:
  - "5.2.1.  State Manipulation\n   The processing of a message and its component\
    \ objects involves\n   manipulating the QoS NSLP and reservation state of a QNE.\n\
    \   For each flow, a QNE stores (RMF-related) reservation state that\n   depends\
    \ on:\n   o  the QoS model / QSPEC used,\n   o  the QoS NSLP operation state,\
    \ which includes non-persistent state\n      (e.g., the API parameters while a\
    \ QNE is processing a message),\n      and\n   o  the persistent state, which\
    \ is kept as long as the session is\n      active.\n   The persistent QoS NSLP\
    \ state is conceptually organized in a table\n   with the following structure.\
    \  The primary key (index) for the table\n   is the SESSION-ID:\n   SESSION-ID\n\
    \      A 128-bit identifier.\n   The state information for a given key includes:\n\
    \   Flow ID\n      Based on GIST MRI.  Several entries are possible in case of\n\
    \      mobility events.\n   SII-Handle for each upstream and downstream peer\n\
    \      The SII-Handle is a local identifier generated by GIST and passed\n   \
    \   over the API.  It is a handle that allows to refer to a particular\n     \
    \ GIST next hop.  See SII-Handle in [RFC5971] for more information.\n   RSN from\
    \ the upstream peer\n      The RSN is a 32-bit counter.\n   The latest local RSN\n\
    \      A 32-bit counter.\n   List of RII for outstanding responses with processing\
    \ information.\n      The RII is a 32-bit number.\n   State lifetime\n      The\
    \ state lifetime indicates how long the state that is being\n      signaled for\
    \ remains valid.\n   List of bound sessions\n      A list of BOUND-SESSION-ID\
    \ 128-bit identifiers for each session\n      bound to this state.\n   Scope of\
    \ the signaling\n      If the Proxy scope is used, a flag is needed to identify\
    \ all\n      signaling of this session as being scoped.\n   Adding the state requirements\
    \ of all these items gives an upper bound\n   on the state to be kept by a QNE.\
    \  The need to keep state depends on\n   the desired functionality at the NSLP\
    \ layer.\n"
- title: 5.2.2.  Message Forwarding
  contents:
  - "5.2.2.  Message Forwarding\n   QoS NSLP messages are sent peer-to-peer along\
    \ the path.  The QoS NSLP\n   does not have the concept of a message being sent\
    \ directly to the end\n   of the path.  Instead, messages are received by a QNE,\
    \ which may then\n   send another message (which may be identical to the received\
    \ message\n   or contain some subset of objects from it) to continue in the same\n\
    \   direction (i.e., towards the QNI or QNR) as the message received.\n   The\
    \ decision on whether to generate a message to forward may be\n   affected by\
    \ the value of the SCOPING or PROXY flags, or by the\n   presence of an RII object.\n"
- title: 5.2.3.  Standard Message Processing Rules
  contents:
  - "5.2.3.  Standard Message Processing Rules\n   If a mandatory object is missing\
    \ from a message then the receiving\n   QNE MUST NOT propagate the message any\
    \ further.  It MUST construct a\n   RESPONSE message indicating the error condition\
    \ and send it back to\n   the peer QNE that sent the message.\n   If a message\
    \ contains an object of an unrecognised type, then the\n   behavior depends on\
    \ the AB extensibility flags.\n   If the Proxy scope flag was set in an incoming\
    \ QoS NSLP message, the\n   QNE must set the same flag in all QoS NSLP messages\
    \ it sends that are\n   related to this session.\n"
- title: 5.2.4.  Retransmissions
  contents:
  - "5.2.4.  Retransmissions\n   Retransmissions may happen end-to-end (e.g., between\
    \ QNI and QNR\n   using an RII object) or peer-to-peer (between two adjacent QNEs).\n\
    \   When a QNE transmits a RESERVE with an RII object set, it waits for a\n  \
    \ RESPONSE from the responding QNE.  QoS NSLP messages for which a\n   response\
    \ is requested by including an RII object, but that fail to\n   elicit a response\
    \ are retransmitted.  Similarly, a QNE may include\n   the ACK-REQ flag to request\
    \ confirmation of a refresh message\n   reception from its immediate peer.  The\
    \ retransmitted message should\n   be exactly the same as the original message,\
    \ e.g., the RSN is not\n   modified with each retransmission.\n   The initial\
    \ retransmission occurs after a QOSNSLP_REQUEST_RETRY wait\n   period.  Retransmissions\
    \ MUST be made with exponentially increasing\n   wait intervals (doubling the\
    \ wait each time).  QoS NSLP messages\n   SHOULD be retransmitted until either\
    \ a RESPONSE (which might be an\n   error) has been obtained, or until QOSNSLP_RETRY_MAX\
    \ seconds after\n   the initial transmission.  In the latter case, a failure SHOULD\
    \ be\n   indicated to the signaling application.  The default values for the\n\
    \   above-mentioned timers are:\n   QOSNSLP_REQUEST_RETRY: 2 seconds      Wait\
    \ interval before initial\n                                         retransmit\
    \ of the message\n   QOSNSLP_RETRY_MAX:    30 seconds      Period to retry sending\
    \ the\n                                         message before giving up\n   Retransmissions\
    \ SHOULD be disabled for tear messages.\n"
- title: 5.2.5.  Rerouting
  contents:
  - '5.2.5.  Rerouting

    '
- title: 5.2.5.1.  Last Node Behavior
  contents:
  - "5.2.5.1.  Last Node Behavior\n   As discussed in Section 3.2.12, some care needs\
    \ to be taken to handle\n   cases where the last node on the path may change.\n\
    \   A node that is the last node on the path, but not the data receiver\n   (or\
    \ an explicitly configured proxy for it), MUST continue to attempt\n   to send\
    \ messages downstream to probe for path changes.  This must be\n   done in order\
    \ to handle the \"Path Extension\" case described in\n   Section 5.2.5.1.\n  \
    \ A node on the path, that was not previously the last node, MUST take\n   over\
    \ as the last node on the signaling path if GIST path change\n   detection identifies\
    \ that there are no further downstream nodes on\n   the path.  This must be done\
    \ in order to handle the \"Path Truncation\"\n   case described in Section 5.2.5.1.\n"
- title: 5.2.5.2.  Avoiding Mistaken Teardown
  contents:
  - "5.2.5.2.  Avoiding Mistaken Teardown\n   In order to handle the spurious route\
    \ change problem described in\n   Section 3.2.12.2, the RSN must be used in a\
    \ particular way when\n   maintaining the reservation after a route change is\
    \ believed to have\n   occurred.\n   We assume that the current RSN (RSN[current])\
    \ is initially RSN0.\n   When a route change is believed to have occurred, the\
    \ QNE SHOULD send\n   a RESERVE message, including the full QSPEC.  This must\
    \ contain an\n   RSN which is RSN[current] = RSN0 + 2.  It SHOULD include an RII\
    \ to\n   request a response from the QNR.  An SII-Handle MUST NOT be specified\n\
    \   when passing this message over the API to GIST, so that the message\n   is\
    \ correctly routed to the new peer QNE.\n   When the QNE receives the RESPONSE\
    \ message that relates to the\n   RESERVE message sent down the new path, it SHOULD\
    \ send a RESERVE\n   message with the TEAR flag sent down the old path.  To do\
    \ so, it MUST\n   request GIST to use its explicit routing mechanism, and the\
    \ QoS NSLP\n   MUST supply an SII-Handle relating to the old peer QNE.  When sending\n\
    \   this RESERVE message, it MUST contain an RSN that is RSN[current] -\n   1.\
    \  (RSN[current] remains unchanged.)\n   If the RESPONSE received after sending\
    \ the RESERVE down the new path\n   contains the code \"Refresh successful\" in\
    \ the INFO-SPEC, then the QNE\n   MAY elect not to send the tearing RESERVE, since\
    \ this indicates that\n   the path is unchanged.\n"
- title: 5.2.5.3.  Upstream Route Change Notification
  contents:
  - "5.2.5.3.  Upstream Route Change Notification\n   GIST may notify the QoS NSLP\
    \ that a possible upstream route change\n   has occurred over the GIST API.  On\
    \ receiving such a notification,\n   the QoS NSLP SHOULD send a NOTIFY message\
    \ with Informational code\n   0x02 for signaling sessions associated with the\
    \ identified MRI.  If\n   this is sent, it MUST be sent to the old peer using\
    \ the GIST explicit\n   routing mechanism through the use of the SII-Handle.\n\
    \   On receiving such a NOTIFY message, the QoS NSLP SHOULD use the\n   InvalidateRoutingState\
    \ API call to inform GIST that routing state may\n   be out of date.  The QoS\
    \ NSLP SHOULD send a NOTIFY message upstream.\n   The NOTIFY message should be\
    \ propagated back to the QNI or QNR.\n"
- title: 5.2.5.4.  Route Change Oscillation
  contents:
  - "5.2.5.4.  Route Change Oscillation\n   In some circumstances, a route change\
    \ may occur, but the path then\n   falls back to the original route.\n   After\
    \ a route change the routers on the old path will continue to\n   refresh the\
    \ reservation until soft state times out or an explicit\n   TEAR is received.\n\
    \   After detecting an upstream route change, a QNE SHOULD consider the\n   new\
    \ upstream peer as current and not fall back to the old upstream\n   peer unless:\n\
    \   o  it stops receiving refreshes from the old upstream peer for at\n      least\
    \ the soft-state timeout period and then starts receiving\n      messages from\
    \ the old upstream peer again, or\n   o  it stops receiving refreshes from the\
    \ new upstream peer for at\n      least the soft-state timeout period.\n   GIST\
    \ routing state keeps track of the latest upstream peer it has\n   seen, and so\
    \ may spuriously indicate route changes occur when the old\n   upstream peer refreshes\
    \ its routing state until the state at that\n   node is explicitly torn down or\
    \ times out.\n"
- title: 5.3.  Object Processing
  contents:
  - "5.3.  Object Processing\n   This section presents processing rules for individual\
    \ QoS NSLP\n   objects.\n"
- title: 5.3.1.  Reservation Sequence Number (RSN)
  contents:
  - "5.3.1.  Reservation Sequence Number (RSN)\n   A QNE's own RSN is a sequence number\
    \ which applies to a particular\n   signaling session (i.e., with a particular\
    \ SESSION-ID).  It MUST be\n   incremented for each new RESERVE message where\
    \ the reservation for\n   the session changes.  The RSN is manipulated using the\
    \ serial number\n   arithmetic rules from [RFC1982], which also defines wrapping\
    \ rules\n   and the meaning of 'equals', 'less than', and 'greater than' for\n\
    \   comparing sequence numbers in a circular sequence space.\n   The RSN starts\
    \ at zero.  It is stored as part of the per-session\n   state, and it carries\
    \ on incrementing (i.e., it is not reset to zero)\n   when a downstream peer change\
    \ occurs.  (Note that Section 5.2.5.2\n   provides some particular rules for use\
    \ when a downstream peer\n   changes.)\n   The RSN object also contains an Epoch\
    \ Identifier, which provides a\n   method for determining when a peer has restarted\
    \ (e.g., due to node\n   reboot or software restart).  The exact method for providing\
    \ this\n   value is implementation defined.  Options include storing a serial\n\
    \   number that is incremented on each restart, picking a random value on\n  \
    \ each restart, or using the restart time.\n   On receiving a RESERVE message\
    \ a QNE examines the Epoch Identifier to\n   determine if the peer sending the\
    \ message has restarted.  If the\n   Epoch Identifier is different to that stored\
    \ for the reservation then\n   the RESERVE message MUST be treated as an updated\
    \ reservation (even\n   if the RSN is less than the current stored value), and\
    \ the stored RSN\n   and Epoch Identifier MUST be updated to the new values.\n\
    \   When receiving a RESERVE message, a QNE uses the RSN given in the\n   message\
    \ to determine whether the state being requested is different\n   to that already\
    \ stored.  If the RSN is equal to that stored for the\n   current reservation,\
    \ the current state MUST be refreshed.  If the RSN\n   is greater than the current\
    \ stored value, the current reservation\n   MUST be modified appropriately as\
    \ specified in the QSPEC (provided\n   that admission control and policy control\
    \ succeed), and the stored\n   RSN value updated to that for the new reservation.\
    \  If the RSN is\n   greater than the current stored value and the RESERVE was\
    \ a reduced\n   refresh, the QNE SHOULD send upstream a transient error message\
    \ \"Full\n   QSPEC required\".  If the RSN is less than the current value, then\
    \ it\n   indicates an out-of-order message, and the RESERVE message MUST be\n\
    \   discarded.\n   If the QNE does not store per-session state (and so does not\
    \ keep any\n   previous RSN values), then it MAY ignore the value of the RSN.\
    \  It\n   MUST also copy the same RSN into the RESERVE message (if any) that it\n\
    \   sends as a consequence of receiving this one.\n"
- title: 5.3.2.  Request Identification Information (RII)
  contents:
  - "5.3.2.  Request Identification Information (RII)\n   A QNE sending QUERY or RESERVE\
    \ messages may require a response to be\n   sent.  It does so by including a Request\
    \ Identification Information\n   (RII) object.  When creating an RII object, the\
    \ QNE MUST select the\n   value for the RII such that it is probabilistically\
    \ unique within the\n   given session.  A RII object is typically set by the QNI.\n\
    \   A number of choices are available when implementing this.\n   Possibilities\
    \ might include using a random value, or a node\n   identifier together with a\
    \ counter.  If the value collides with one\n   selected by another QNE for a different\
    \ QUERY, then RESPONSE messages\n   may be incorrectly terminated, and may not\
    \ be passed back to the node\n   that requested them.\n   The node that created\
    \ the RII object MUST remember the value used in\n   the RII in order to match\
    \ back any RESPONSE it will receive.  The\n   node SHOULD use a timer to identify\
    \ situations where it has taken too\n   long to receive the expected RESPONSE.\
    \  If the timer expires without\n   receiving a RESPONSE, the node MAY perform\
    \ a retransmission as\n   discussed in Section 5.2.4.  In this case, the QNE MUST\
    \ NOT generate\n   any RESPONSE or NOTIFY message to notify this error.\n   If\
    \ an intermediate QNE wants to receive a response for an outgoing\n   message,\
    \ but the message already included an RII when it arrived, the\n   QNE MUST NOT\
    \ add a new RII object nor replace the old RII object, but\n   MUST simply remember\
    \ this RII in order to match a later RESPONSE\n   message.  When it receives the\
    \ RESPONSE, it forwards the RESPONSE\n   upstream towards the RII originating\
    \ node.  Note that only the node\n   that originally created the RII can set up\
    \ a retransmission timer.\n   Thus, if an intermediate QNE decides to use the\
    \ RII already contained\n   in the message, it MUST NOT set up a retransmission\
    \ timer, but rely\n   on the retransmission timer set up by the QNE that inserted\
    \ the RII.\n   When receiving a message containing an RII object the node MUST\
    \ send\n   a RESPONSE if\n      o The SCOPING flag is set ('next hop' scope),\n\
    \      o The PROXY scope flag is set and the QNE is the P-QNE, or\n      o This\
    \ QNE is the last one on the path for the given session.\n   and the QNE keeps\
    \ per-session state for the given session.\n   In the rare event that the QNE\
    \ wants to request a response for a\n   message that already included an RII,\
    \ and this RII value conflicts\n   with an existing RII value on the QNE, the\
    \ node should interrupt the\n   processing the message, send an error message\
    \ upstream to indicate an\n   RII collision, and request a retry with a new RII\
    \ value.\n"
- title: 5.3.3.  BOUND-SESSION-ID
  contents:
  - "5.3.3.  BOUND-SESSION-ID\n   As shown in the examples in Section 4, the QoS NSLP\
    \ can relate\n   multiple sessions together.  It does this by including the SESSION-ID\n\
    \   from one session in a BOUND-SESSION-ID object in messages in another\n   session.\n\
    \   When receiving a message with a BOUND-SESSION-ID object, a QNE MUST\n   copy\
    \ the BOUND-SESSION-ID object into all messages it sends for the\n   same session.\
    \  A QNE that stores per-session state MUST store the\n   value of the BOUND-SESSION-ID.\n\
    \   The BOUND-SESSION-ID is only indicative in nature.  However, a QNE\n   implementation\
    \ may use BOUND-SESSION-ID information to optimize\n   resource allocation, e.g.,\
    \ for bidirectional reservations.  When\n   receiving a teardown message (e.g.,\
    \ a RESERVE message with teardown\n   semantics) for an aggregate reservation,\
    \ the QNE may use this\n   information to initiate a teardown for end-to-end sessions\
    \ bound to\n   the aggregate.  A QoS NSLP implementation MUST be ready to process\n\
    \   more than one BOUND-SESSION-ID object within a single message.\n"
- title: 5.3.4.  REFRESH-PERIOD
  contents:
  - "5.3.4.  REFRESH-PERIOD\n   Refresh timer management values are carried by the\
    \ REFRESH-PERIOD\n   object, which has local significance only.  At the expiration\
    \ of a\n   \"refresh timeout\" period, each QNE independently examines its state\n\
    \   and sends a refreshing RESERVE message to the next QNE peer where it\n   is\
    \ absorbed.  This peer-to-peer refreshing (as opposed to the QNI\n   initiating\
    \ a refresh that travels all the way to the QNR) allows QNEs\n   to choose refresh\
    \ intervals as appropriate for their environment.\n   For example, it is conceivable\
    \ that refreshing intervals in the\n   backbone, where reservations are relatively\
    \ stable, are much larger\n   than in an access network.  The \"refresh timeout\"\
    \ is calculated\n   within the QNE and is not part of the protocol; however, it\
    \ must be\n   chosen to be compatible with the reservation lifetime as expressed\
    \ by\n   the REFRESH-PERIOD and with an assessment of the reliability of\n   message\
    \ delivery.\n   The details of timer management and timer changes (slew handling\
    \ and\n   so on) are identical to the ones specified in Section 3.7 of RFC 2205\n\
    \   [RFC2205].\n   There are two time parameters relevant to each QoS NSLP state\
    \ in a\n   node: the refresh period R between generation of successive refreshes\n\
    \   for the state by the neighbor node, and the local state's lifetime L.\n  \
    \ Each RESERVE message may contain a REFRESH-PERIOD object specifying\n   the\
    \ R value that was used to generate this (refresh) message.  This R\n   value\
    \ is then used to determine the value for L when the state is\n   received and\
    \ stored.  The values for R and L may vary from peer to\n   peer.\n"
- title: 5.3.5.  INFO-SPEC
  contents:
  - "5.3.5.  INFO-SPEC\n   The INFO-SPEC object is carried by the RESPONSE and NOTIFY\
    \ messages,\n   and it is used to report a successful, an unsuccessful, or an\
    \ error\n   situation.  In case of an error situation, the error messages SHOULD\n\
    \   be generated even if no RII object is included in the RESERVE or in\n   the\
    \ QUERY messages.  Note that when the TEAR flag is set in the\n   RESERVE message\
    \ an error situation SHOULD NOT trigger the generation\n   of a RESPONSE message.\n\
    \   Six classes of INFO-SPEC objects are identified and specified in\n   Section\
    \ 5.1.3.6.  The message processing rules for each class are\n   defined below.\n\
    \   A RESPONSE message MUST carry INFO-SPEC objects towards the QNI.  The\n  \
    \ RESPONSE message MUST be forwarded unconditionally up to the QNI.\n   The actions\
    \ that SHOULD be undertaken by the QNI that receives the\n   INFO-SPEC object\
    \ are specified by the local policy of the QoS model\n   supported by this QNE.\
    \  The default action is that the QNI that\n   receives the INFO-SPEC object SHOULD\
    \ NOT trigger any other QoS NSLP\n   procedure.\n   The Informational INFO-SPEC\
    \ class MUST be generated by a stateful QoS\n   NSLP QNE when an Informational\
    \ error class is caught.  The\n   Informational INFO-SPEC object MUST be carried\
    \ by a RESPONSE or a\n   NOTIFY message.\n   In case of a unidirectional reservation,\
    \ the Success INFO-SPEC class\n   MUST be generated by a stateful QoS NSLP QNR\
    \ when a RESERVE message\n   is received and the reservation state installation\
    \ or refresh\n   succeeded.  In case of a bidirectional reservation, the INFO-SPEC\n\
    \   object SHOULD be generated by a stateful QoS NSLP QNE when a RESERVE\n   message\
    \ is received and the reservation state installation or refresh\n   succeeded.\
    \  The Success INFO-SPEC object MUST be carried by a\n   RESPONSE or a NOTIFY\
    \ message.\n   In case of a unidirectional reservation, the Protocol Error INFO-SPEC\n\
    \   class MUST be generated by a stateful QoS NSLP QNE when a RESERVE or\n   QUERY\
    \ message is received by the QNE and a protocol error is caught.\n   In case of\
    \ a bidirectional reservation, the Protocol Error INFO-SPEC\n   class SHOULD be\
    \ generated by a stateful QoS NSLP QNE when a RESERVE\n   or QUERY message is\
    \ received by the QNE and a protocol error is\n   caught.  A RESPONSE message\
    \ MUST carry this object, which MUST be\n   forwarded unconditionally towards\
    \ the upstream QNE that generated the\n   RESERVE or QUERY message that triggered\
    \ the generation of this INFO-\n   SPEC object.  The default action for a stateless\
    \ QoS NSLP QNE that\n   detects such an error is that none of the QoS NSLP objects\
    \ SHOULD be\n   processed, and the RESERVE or QUERY message SHOULD be forwarded\n\
    \   downstream.\n   In case of a unidirectional reservation, the Transient Failure\
    \ INFO-\n   SPEC class MUST be generated by a stateful QoS NSLP QNE when a\n \
    \  RESERVE or QUERY message is received by the QNE and one Transient\n   failure\
    \ error code is caught, or when an event happens that causes a\n   transient error.\
    \  In case of a bidirectional reservation, the\n   Transient Failure INFO-SPEC\
    \ class SHOULD be generated by a stateful\n   QoS NSLP QNE when a RESERVE or QUERY\
    \ message is received by the QNE\n   and one Transient failure error code is caught.\n\
    \   A RESPONSE message MUST carry this object, which MUST be forwarded\n   unconditionally\
    \ towards the upstream QNE that generated the RESERVE\n   or QUERY message that\
    \ triggered the generation of this INFO-SPEC\n   object.  The transient RMF-related\
    \ error MAY also be carried by a\n   NOTIFY message.  The default action is that\
    \ the QNE that receives\n   this INFO-SPEC object SHOULD re-trigger the retransmission\
    \ of the\n   RESERVE or QUERY message that triggered the generation of the INFO-\n\
    \   SPEC object.  The default action for a stateless QoS NSLP QNE that\n   detects\
    \ such an error is that none of the QoS NSLP objects SHOULD be\n   processed and\
    \ the RESERVE or QUERY message SHOULD be forwarded\n   downstream.\n   In case\
    \ of a unidirectional reservation, the Permanent Failure INFO-\n   SPEC class\
    \ MUST be generated by a stateful QoS NSLP QNE when a\n   RESERVE or QUERY message\
    \ is received by a QNE and an internal or\n   system error occurred, or authorization\
    \ failed.  In case of a\n   bidirectional reservation, the Permanent Failure INFO-SPEC\
    \ class\n   SHOULD be generated by a stateful QoS NSLP QNE when a RESERVE or\n\
    \   QUERY message is received by a QNE and an internal or system error\n   occurred,\
    \ or authorization failed.  A RESPONSE message MUST carry\n   this object, which\
    \ MUST be forwarded unconditionally towards the\n   upstream QNE that generated\
    \ the RESERVE or QUERY message that\n   triggered this protocol error.  The internal,\
    \ system, or permanent\n   RMF-related errors MAY also be carried by a NOTIFY\
    \ message.  The\n   default action for a stateless QoS NSLP QNE that detects such\
    \ an\n   error is that none of the QoS NSLP objects SHOULD be processed and\n\
    \   the RESERVE or QUERY message SHOULD be forwarded downstream.\n   The QoS-specific\
    \ error class may be used when errors outside the QoS\n   NSLP itself occur that\
    \ are related to the particular QoS model being\n   used.  The processing rules\
    \ of these errors are not specified in this\n   document.\n"
- title: 5.3.6.  SESSION-ID-LIST
  contents:
  - "5.3.6.  SESSION-ID-LIST\n   A SESSION-ID-LIST is carried in RESERVE messages.\
    \  It is used in two\n   cases, to refresh or to tear down the indicated sessions.\
    \  A SESSION-\n   ID-LIST carries information about sessions that should be refreshed\n\
    \   or torn down, in addition to the main (primary) session indicated in\n   the\
    \ RESERVE.\n   If the primary SESSION-ID is not understood, the SESSION-ID-LIST\n\
    \   object MUST NOT be processed.\n   When a stateful QNE goes through the SESSION-ID-LIST,\
    \ if it finds one\n   or more unknown SESSION-ID values, it SHOULD construct an\n\
    \   informational RESPONSE message back to the upstream stateful QNE with\n  \
    \ the error code for unknown SESSION-ID in SESSION-ID-LIST, and include\n   all\
    \ unknown SESSION-IDs in a SESSION-ID-LIST.\n   If the RESERVE is a tear, for\
    \ each session in the SESSION-ID-LIST,\n   the stateful QNE MUST inform the RMF\
    \ that the reservation is no\n   longer required.  RSN values MUST also be interpreted\
    \ in order to\n   distinguish whether the tear down is valid, or whether it is\n\
    \   referring to an old state, and, thus, should be silently discarded.\n   If\
    \ the RESERVE is a refresh, the stateful QNE MUST also process the\n   RSN-LIST\
    \ object as detailed in the next section.\n   If the RESERVE is a tear, for each\
    \ session in the SESSION-ID-LIST,\n   the QNE MUST inform the RMF that the reservation\
    \ is no longer\n   required.  RSN values MUST be interpreted.\n   Note that a\
    \ stateless QNE cannot support summary or single reduced\n   refreshes, and always\
    \ needs full single refreshes.\n"
- title: 5.3.7.  RSN-LIST
  contents:
  - "5.3.7.  RSN-LIST\n   An RSN-LIST MUST be carried in RESERVE messages when a QNE\
    \ wants to\n   perform a refresh or teardown of several sessions with a single\
    \ NSLP\n   message.  The RSN-LIST object MUST be populated with RSN values of\n\
    \   the same sessions and in the same order as indicated in the SESSION-\n   ID-LIST.\
    \  Thus, entries in both objects at position X refer to the\n   same session.\n\
    \   If the primary session and RSN reference in the RESERVE were not\n   understood,\
    \ the stateful QNE MUST NOT process the RSN-LIST.  Instead,\n   an error RESPONSE\
    \ SHOULD be sent back to the upstream stateful QNE.\n   On receiving an RSN-LIST\
    \ object, the stateful QNE should check\n   whether the number of items in the\
    \ SESSION-ID-LIST and RSN-LIST\n   objects match.  If there is a mismatch, the\
    \ stateful QNE SHOULD send\n   back a protocol error indicating a bad value in\
    \ the object.\n   While matching the RSN-LIST values to the SESSION-ID-LIST values,\
    \ if\n   one or more RSN values in the RSN-LIST are not in synch with the\n  \
    \ local values, the stateful QNE SHOULD construct an informational\n   RESPONSE\
    \ message with an error code for RSN mismatch in the RSN-LIST.\n   The stateful\
    \ QNE MUST include the erroneous SESSION-ID and RSN values\n   in SESSION-ID-LIST\
    \ and RSN-LIST objects in the RESPONSE.\n   If no errors were found in processing\
    \ the RSN-LIST, the stateful QNE\n   refreshes the reservation states of all sessions\
    \ -- the primary\n   single session indicated in the refresh, and all sessions\
    \ in the\n   SESSION-ID-LIST.\n   For each successfully processed session in the\
    \ RESERVE, the stateful\n   QNE performs a refresh of the reservation state. \
    \ Thus, even if some\n   sessions were not in synch, the remaining sessions in\
    \ the SESSION-ID-\n   LIST and RSN-LIST are refreshed.\n"
- title: 5.3.8.  QSPEC
  contents:
  - "5.3.8.  QSPEC\n   The contents of the QSPEC depend on the QoS model being used.\
    \  A\n   template for QSPEC objects can be found in [RFC5975].\n   Upon reception,\
    \ the complete QSPEC is passed to the Resource\n   Management Function (RMF),\
    \ along with other information from the\n   message necessary for the RMF processing.\
    \  A QNE may also receive an\n   INFO-SPEC that includes a partial or full QSPEC.\
    \  This will also be\n   passed to the RMF.\n"
- title: 5.4.  Message Processing Rules
  contents:
  - "5.4.  Message Processing Rules\n   This section provides rules for message processing.\
    \  Not all possible\n   error situations are considered.  A general rule for dealing\
    \ with\n   erroneous messages is that a node should evaluate the situation\n \
    \  before deciding how to react.  There are two ways to react to\n   erroneous\
    \ messages:\n   a) Silently drop the message, or\n   b) Drop the message, and\
    \ reply with an error code to the sender.\n   The default behavior, in order to\
    \ protect the QNE from a possible\n   denial-of-service attack, is to silently\
    \ drop the message.  However,\n   if the QNE is able to authenticate the sender,\
    \ e.g., through GIST,\n   the QNE may send a proper error message back to the\
    \ neighbor QNE in\n   order to let it know that there is an inconsistency in the\
    \ states of\n   adjacent QNEs.\n"
- title: 5.4.1.  RESERVE Messages
  contents:
  - "5.4.1.  RESERVE Messages\n   The RESERVE message is used to manipulate QoS reservation\
    \ state in\n   QNEs.  A RESERVE message may create, refresh, modify, or remove\
    \ such\n   state.  A QNE sending a RESERVE MAY require a response to be sent by\n\
    \   including a Request Identification Information (RII) object; see\n   Section\
    \ 5.3.2.\n   RESERVE messages MUST only be sent towards the QNR.  A QNE that\n\
    \   receives a RESERVE message checks the message format.  In case of\n   malformed\
    \ messages, the QNE MAY send a RESPONSE message with the\n   appropriate INFO-SPEC.\n\
    \   Before performing any state-changing actions, a QNE MUST determine\n   whether\
    \ the request is authorized.  The way to do this check depends\n   on the authorization\
    \ model being used.\n   When the RESERVE is authorized, a QNE checks the COMMON-HEADER\
    \ flags.\n   If the TEAR flag is set, the message is a tearing RESERVE that\n\
    \   indicates complete QoS NSLP state removal (as opposed to a\n   reservation\
    \ of zero resources).  On receiving such a RESERVE message,\n   the QNE MUST inform\
    \ the RMF that the reservation is no longer\n   required.  The RSN value MUST\
    \ be processed.  After this, there are\n   two modes of operation:\n   1.  If\
    \ the tearing RESERVE did not include an RII, i.e., the QNI did\n       not want\
    \ a confirmation, the QNE SHOULD remove the QoS NSLP\n       state.  It MAY signal\
    \ to GIST (over the API) that reverse-path\n       state for this reservation\
    \ is no longer required.  Any errors in\n       processing the tearing RESERVE\
    \ SHOULD NOT be sent back towards\n       the QNI since the upstream QNEs will\
    \ already have removed their\n       session states; thus, they are unable to\
    \ do anything to the\n       error.\n   2.  If an RII was included, the stateful\
    \ QNE SHOULD still keep the\n       NSLP operational state until a RESPONSE for\
    \ the tear going\n       towards the QNI is received.  This operational state\
    \ SHOULD be\n       kept for one refresh interval, after which the NSLP operational\n\
    \       state for the session is removed.  Depending on the QoS model,\n     \
    \  the tear message MAY include a QSPEC to further specify state\n       removal.\
    \  If the QoS model requires a QSPEC, and none is\n       provided, the QNE SHOULD\
    \ reply with an error message and SHOULD\n       NOT remove the reservation.\n\
    \   If the tearing RESERVE includes a QSPEC, but none is required by the\n   QoS\
    \ model, the QNE MAY silently discard the QSPEC and proceed as if\n   it did not\
    \ exist in the message.  In general, a QoS NSLP\n   implementation should carefully\
    \ consider when an error message should\n   be sent, and when not.  If the tearing\
    \ RESERVE did not include an\n   RII, then the upstream QNE has removed the RMF\
    \ and NSLP states, and\n   it will not be able to do anything to the error.  If\
    \ an RII was\n   included, the upstream QNE may still have the NSLP operational\
    \ state,\n   but no RMF state.\n   If a QNE receives a tearing RESERVE for a session\
    \ for which it still\n   has the operational state, but the RMF state was removed,\
    \ the QNE\n   SHOULD accept the message and forward it downstream as if all is\n\
    \   well.\n   If the tearing RESERVE includes a SESSION-ID-LIST, the stateful\
    \ QNE\n   MUST process the object as described earlier in this document, and\n\
    \   for each identified session, indicate to the RMF that the reservation\n  \
    \ is no longer required.\n   If a QNE receives a refreshing RESERVE for a session\
    \ for which it\n   still has the operational state, but the RMF state was removed,\
    \ the\n   QNE MUST silently drop the message and not forward it downstream.\n\
    \   As discussed in Section 5.2.5.2, to avoid incorrect removal of state\n   after\
    \ a rerouting event, a node receiving a RESERVE message that has\n   the TEAR\
    \ flag set and that does not come from the current peer QNE\n   (identified by\
    \ its SII) MUST be ignored and MUST NOT be forwarded.\n   If the QNE has reservations\
    \ that are bound and dependent to this\n   session (they contain the SESSION-ID\
    \ of this session in their BOUND-\n   SESSION-ID object and use Binding Code 0x04),\
    \ it MUST send a NOTIFY\n   message for each of the reservations with an appropriate\
    \ INFO-SPEC.\n   If the QNE has reservations that are bound, but that they are\
    \ not\n   dependent to this session (the Binding Code in the BOUND-SESSION-ID\n\
    \   object has one of the values: 0x01, 0x02, or 0x03), it MAY send a\n   NOTIFY\
    \ message for each of the reservations with an appropriate INFO-\n   SPEC.  The\
    \ QNE MAY elect to send RESERVE messages with the TEAR flag\n   set for these\
    \ reservations.\n   The default behavior of a QNE that receives a RESERVE with\
    \ a\n   SESSION-ID for which it already has state installed but with a\n   different\
    \ flow ID is to replace the existing reservation (and to tear\n   down the reservation\
    \ on the old branch if the RESERVE is received\n   with a different SII).\n  \
    \ In some cases, this may not be the desired behavior, so the QNI or a\n   QNE\
    \ MAY set the REPLACE flag in the common header to zero to indicate\n   that the\
    \ new session does not replace the existing one.\n   A QNE that receives a RESERVE\
    \ with the REPLACE flag set to zero but\n   with the same SII will indicate REPLACE=0\
    \ to the RMF (where it will\n   be used for the resource handling).  Furthermore,\
    \ if the QNE\n   maintains a QoS NSLP state, then it will also add the new flow\
    \ ID in\n   the QoS NSLP state.  If the SII is different, this means that the\
    \ QNE\n   is a merge point.  In that case, in addition to the operations\n   specified\
    \ above, the value REPLACE=0 is also indicating that a\n   tearing RESERVE SHOULD\
    \ NOT be sent on the old branch.\n   When a QNE receives a RESERVE message with\
    \ an unknown SESSION-ID and\n   this message contains no QSPEC because it was\
    \ meant as a refresh,\n   then the node MUST send a RESPONSE message with an INFO-SPEC\
    \ that\n   indicates a missing QSPEC to the upstream peer (\"Full QSPEC\n   required\"\
    ).  The upstream peer SHOULD send a complete RESERVE (i.e.,\n   one containing\
    \ a QSPEC) on the new path (new SII).\n   At a QNE, resource handling is performed\
    \ by the RMF.  For sessions\n   with the REPLACE flag set to zero, we assume that\
    \ the QoS model\n   includes directions to deal with resource sharing.  This may\
    \ include\n   adding the reservations or taking the maximum of the two or more\n\
    \   complex mathematical operations.\n   This resource-handling mechanism in the\
    \ QoS model is also applicable\n   to sessions that have different SESSION-IDs\
    \ but that are related\n   through the BOUND-SESSION-ID object.  Session replacement\
    \ is not an\n   issue here, but the QoS model may specify whether or not to let\
    \ the\n   sessions that are bound together share resources on common links.\n\
    \   Finally, it is possible that a RESERVE is received with no QSPEC at\n   all.\
    \  This is the case of a reduced refresh.  In this case, rather\n   than sending\
    \ a refreshing RESERVE with the full QSPEC, only the\n   SESSION-ID and the RSN\
    \ are sent to refresh the reservation.  Note\n   that this mechanism just reduces\
    \ the message size (and probably eases\n   processing).  One RESERVE per session\
    \ is still needed.  Such a\n   reduced refresh may further include a SESSION-ID-LIST\
    \ and RSN-LIST,\n   which indicate further sessions to be refreshed along the\
    \ primary\n   session.  The processing of these objects was described earlier\
    \ in\n   this document.\n   If the REPLACE flag is set, the QNE SHOULD update\
    \ the reservation\n   state according to the QSPEC contained in the message (if\
    \ the QSPEC\n   is missing, the QNE SHOULD indicate this error by replying with\
    \ a\n   RESPONSE containing the corresponding INFO-SPEC \"Full QSPEC\n   required\"\
    ).  It MUST update the lifetime of the reservation.  If the\n   REPLACE flag is\
    \ not set, a QNE SHOULD NOT remove the old reservation\n   state if the SII that\
    \ is passed by GIST over the API is different\n   than the SII that was stored\
    \ for this reservation.  The QNE MAY elect\n   to keep sending refreshing RESERVE\
    \ messages.\n   If a stateful QoS NSLP QNE receives a RESERVE message with the\
    \ BREAK\n   flag set, then the BREAK flag of newly generated messages (e.g.,\n\
    \   RESERVE or RESPONSE) MUST be set.  When a stateful QoS NSLP QNE\n   receives\
    \ a RESERVE message with the BREAK flag not set, then the IP-\n   TTL and Original-TTL\
    \ values in the GIST RecvMessage primitive MUST be\n   monitored.  If they differ,\
    \ it is RECOMMENDED to set the BREAK flag\n   in newly generated messages (e.g.,\
    \ RESERVE or RESPONSE).  In\n   situations where a QNE or a domain is able to\
    \ provide QoS using other\n   means (see Section 3.3.5), the BREAK flag SHOULD\
    \ NOT be set.\n   If the RESERVE message included an RII, and any of the following\
    \ are\n   true, the QNE MUST send a RESPONSE message:\n   o  If the QNE is configured,\
    \ for a particular session, to be a QNR,\n   o  the SCOPING flag is set,\n   o\
    \  the Proxy scope flag is set and the QNE is a P-QNE, or\n   o  the QNE is the\
    \ last QNE on the path to the destination.\n   When a QNE receives a RESERVE message,\
    \ its processing may involve\n   sending out another RESERVE message.\n   If a\
    \ QNE has received a RESPONSE mandating the use of full refreshes\n   from its\
    \ downstream peer for a session, the QNE MUST continue to use\n   full refresh\
    \ messages.\n   If the session of this message is bound to another session, then\
    \ the\n   RESERVE message MUST include the SESSION-ID of that other session in\n\
    \   a BOUND-SESSION-ID object.  In the situation of aggregated tunnels,\n   the\
    \ aggregated session MAY not include the SESSION-ID of its bound\n   sessions\
    \ in BOUND-SESSION-ID(s).\n   In case of receiver-initiated reservations, the\
    \ RESERVE message must\n   follow the same path that has been followed by the\
    \ QUERY message.\n   Therefore, GIST is informed, over the QoS NSLP/GIST API,\
    \ to pass the\n   message upstream, i.e., by setting GIST \"D\" flag; see GIST\
    \ [RFC5971].\n   The QNE MUST create a new RESERVE and send it to its next peer,\
    \ when:\n   -  A new resource setup was done,\n   -  A new resource setup was\
    \ not done, but the QOSM still defines that\n      a RESERVE must be propagated,\n\
    \   -  The RESERVE is a refresh and includes a new MRI, or\n   -  If the RESERVE-INIT\
    \ flag is included in an arrived QUERY.\n   If the QNE sent out a refresh RESERVE\
    \ with the ACK-REQ flag set, and\n   did not receive a RESPONSE from its immediate\
    \ stateful peer within\n   the retransmission period of QOSNSLP_RETRY_MAX, the\
    \ QNE SHOULD send a\n   NOTIFY to its immediate upstream stateful peer and indicate\
    \ \"Path\n   truncated - Next peer dead\" in the INFO-SPEC.  The ACK-REQ flag\n\
    \   SHOULD NOT be added to a RESERVE that already include an RII object,\n   since\
    \ a confirmation from the QNR has already been requested.\n   Finally, if a received\
    \ RESERVE requested acknowledgement through the\n   ACK-REQ flag in the COMMON\
    \ HEADER flags and the processing of the\n   message was successful, the stateful\
    \ QNE SHOULD send back a RESPONSE\n   with an INFO-SPEC carrying the acknowledgement\
    \ success code.  The QNE\n   MAY include the ACK-REQ flag in the next refresh\
    \ message it will send\n   for the session.  The use of the ACK-REQ-flag for diagnostic\
    \ purposes\n   is a policy issue.  An acknowledged refresh message can be used\
    \ to\n   probe the end-to-end path in order to check that it is still intact.\n"
- title: 5.4.2.  QUERY Messages
  contents:
  - "5.4.2.  QUERY Messages\n   A QUERY message is used to request information about\
    \ the data path\n   without making a reservation.  This functionality can be used\
    \ to\n   'probe' the network for path characteristics or for support of\n   certain\
    \ QoS models, or to initiate a receiver-initiated reservation.\n   A QNE sending\
    \ a QUERY indicates a request for a response by including\n   a Request Identification\
    \ Information (RII) object; see Section 5.3.2.\n   A request to initiate a receiver-initiated\
    \ reservation is done\n   through the RESERVE-INIT flag; see Section 5.1.2.2.\n\
    \   When a QNE receives a QUERY message the QSPEC is passed to the RMF\n   for\
    \ processing.  The RMF may return a modified QSPEC that is used in\n   any QUERY\
    \ or RESPONSE message sent out as a result of the QUERY\n   processing.\n   When\
    \ processing a QUERY message, a QNE checks whether the RESERVE-\n   INIT flag\
    \ is set.  If the flag is set, the QUERY is used to install\n   reverse-path state.\
    \  In this case, if the QNE is not the QNI, it\n   creates a new QUERY message\
    \ to send downstream.  The QSPEC MUST be\n   passed to the RMF where it may be\
    \ modified by the QoS-model-specific\n   QUERY processing.  If the QNE is the\
    \ QNI, the QNE creates a RESERVE\n   message, which contains a QSPEC received\
    \ from the RMF and which may\n   be based on the received QSPEC.  If this node\
    \ was not expecting to\n   perform a receiver-initiated reservation, then an error\
    \ MUST be sent\n   back along the path.\n   The QNE MUST generate a RESPONSE message\
    \ and pass it back along the\n   reverse of the path used by the QUERY if:\n \
    \  o  an RII object is present,\n   o  the QNE is the QNR,\n   o  the SCOPING\
    \ flag is set, or\n   o  the PROXY scope flag is set, and the QNE is a P-QNE.\n\
    \   If an RII object is present, and if the QNE is the QNR, the SCOPING\n   flag\
    \ is set or the PROXY scope flag is set and the QNE is a P-QNE,\n   the QNE MUST\
    \ generate a RESPONSE message and pass it back along the\n   reverse of the path\
    \ used by the QUERY.\n   In other cases, the QNE MUST generate a QUERY message\
    \ that is then\n   forwarded further along the path using the same MRI, Session\
    \ ID, and\n   Direction as provided when the QUERY was received over the GIST\
    \ API.\n   The QSPEC to be used is that provided by the RMF as described\n   previously.\
    \  When generating a QUERY to send out to pass the query\n   further along the\
    \ path, the QNE MUST copy the RII object (if present)\n   unchanged into the new\
    \ QUERY message.  A QNE that is also interested\n   in the response to the query\
    \ keeps track of the RII to identify the\n   RESPONSE when it passes through it.\n\
    \   Note that QUERY messages with the RESERVE-INIT flag set MUST be\n   answered\
    \ by the QNR.  This feature may be used, e.g., following\n   handovers, to set\
    \ up new path state in GIST and to request that the\n   other party to send a\
    \ RESERVE back on this new GIST path.\n   If a stateful QoS NSLP QNE receives\
    \ a QUERY message with the RESERVE-\n   INIT flag and BREAK flag set, then the\
    \ BREAK flag of newly generated\n   messages (e.g., QUERY, RESERVE, or RESPONSE)\
    \ MUST be set.  When a\n   stateful QoS NSLP QNE receives a QUERY message with\
    \ the RESERVE-INIT\n   flag set and BREAK flag not set, then the IP-TTL and Original-TTL\n\
    \   values in GIST RecvMessage primitive MUST be monitored.  If they\n   differ,\
    \ it is RECOMMENDED to set the BREAK flag in newly generated\n   messages (e.g.,\
    \ QUERY, RESERVE, or RESPONSE).  In situations where a\n   QNE or a domain is\
    \ able to provide QoS using other means (see\n   Section 3.3.5), the BREAK flag\
    \ SHOULD NOT be set.\n   Finally, if a received QUERY requested acknowledgement\
    \ through the\n   ACK-REQ flag in the COMMON HEADER flags and the processing of\
    \ the\n   message was successful, the stateful QNE SHOULD send back a RESPONSE\n\
    \   with an INFO-SPEC carrying the acknowledgement success code.\n"
- title: 5.4.3.  RESPONSE Messages
  contents:
  - "5.4.3.  RESPONSE Messages\n   The RESPONSE message is used to provide information\
    \ about the result\n   of a previous QoS NSLP message, e.g., confirmation of a\
    \ reservation\n   or information resulting from a QUERY.  The RESPONSE message\
    \ does not\n   cause any state to be installed, but may cause state(s) to be\n\
    \   modified, e.g., if the RESPONSE contains information about an error.\n   A\
    \ RESPONSE message MUST be sent when the QNR processes a RESERVE or\n   QUERY\
    \ message containing an RII object or if the QNE receives a\n   scoped RESERVE\
    \ or a scoped QUERY.  In this case, the RESPONSE message\n   MUST contain the\
    \ RII object copied from the RESERVE or the QUERY.\n   Also, if there is an error\
    \ in processing a received RESERVE, a\n   RESPONSE is sent indicating the nature\
    \ of the error.  In this case,\n   the RII and RSN, if available, MUST be included\
    \ in the RESPONSE.\n   On receipt of a RESPONSE message containing an RII object,\
    \ the\n   stateful QoS NSLP QNE MUST attempt to match it to the outstanding\n\
    \   response requests for that signaling session.  If the match succeeds,\n  \
    \ then the RESPONSE MUST NOT be forwarded further along the path if it\n   contains\
    \ an Informational or Success INFO-SPEC class.  If the QNE did\n   not insert\
    \ this RII itself, it must forward the RESPONSE to the next\n   peer.  Thus, for\
    \ RESPONSEs indicating success, forwarding should only\n   stop if the QNE inserted\
    \ the RII by itself.  If the RESPONSE carries\n   an INFO-SPEC indicating an error,\
    \ forwarding SHOULD continue upstream\n   towards the QNI by using RSNs as described\
    \ in the next paragraph.\n   On receipt of a RESPONSE message containing an RSN\
    \ object, a stateful\n   QoS NSLP QNE MUST compare the RSN to that of the appropriate\n\
    \   signaling session.  If the match succeeds, then the INFO-SPEC MUST be\n  \
    \ processed.  If the INFO-SPEC object is used to send error\n   notifications\
    \ then the node MUST use the stored upstream peer RSN\n   value, associated with\
    \ the same session, and forward the RESPONSE\n   message further along the path\
    \ towards the QNI.\n   If the INFO-SPEC is not used to notify error situations\
    \ (see above),\n   then if the RESPONSE message carries an RSN, the message MUST\
    \ NOT be\n   forwarded further along the path.\n   If there is no match for RSN,\
    \ the message SHOULD be silently dropped.\n   On receipt of a RESPONSE message\
    \ containing neither an RII nor an RSN\n   object, the RESPONSE MUST NOT be forwarded\
    \ further along the path.\n   In the typical case, RESPONSE messages do not change\
    \ the states\n   installed in intermediate QNEs.  However, depending on the QoS\
    \ model,\n   there may be situations where states are affected, e.g.,\n   -  if\
    \ the RESPONSE includes an INFO-SPEC describing an error\n      situation resulting\
    \ in reservations to be removed, or\n   -  the QoS model allows a QSPEC to define\
    \ [min,max] limits on the\n      resources requested, and downstream QNEs gave\
    \ less resources than\n      their upstream nodes, which means that the upstream\
    \ nodes may\n      release a part of the resource reservation.\n   If a stateful\
    \ QoS NSLP QNE receives a RESPONSE message with the BREAK\n   flag set, then the\
    \ BREAK flag of newly generated message (e.g.,\n   RESPONSE) MUST be set.\n"
- title: 5.4.4.  NOTIFY Messages
  contents:
  - "5.4.4.  NOTIFY Messages\n   NOTIFY messages are used to convey information to\
    \ a QNE\n   asynchronously.  NOTIFY messages do not cause any state to be\n  \
    \ installed.  The decision to remove state depends on the QoS model.\n   The exact\
    \ operation depends on the QoS model.  A NOTIFY message does\n   not directly\
    \ cause other messages to be sent.  NOTIFY messages are\n   sent asynchronously,\
    \ rather than in response to other messages.  They\n   may be sent in either direction\
    \ (upstream or downstream).\n   A special case of synchronous NOTIFY is when the\
    \ upstream QNE is\n   asked to use reduced refresh by setting the appropriate\
    \ flag in the\n   RESERVE.  The QNE receiving such a RESERVE MUST reply with a\
    \ NOTIFY\n   and a proper INFO-SPEC code indicating whether the QNE agrees to\
    \ use\n   reduced refresh between the upstream QNE.\n   The Transient error code\
    \ 0x07 \"Reservation preempted\" is sent to the\n   QNI whose resources were preempted.\
    \  The NOTIFY message carries\n   information to the QNI that one QNE no longer\
    \ has a reservation for\n   the session.  It is up to the QNI to decide what to\
    \ do based on the\n   QoS model being used.  The QNI would normally tear down\
    \ the preempted\n   reservation by sending a RESERVE with the TEAR flag set using\
    \ the SII\n   of the preempted reservation.  However, the QNI can follow other\n\
    \   procedures as specified in its QoS Model.  More discussion on\n   preemption\
    \ can be found in the QSPEC Template [RFC5975] and the\n   individual QoS Model\
    \ specifications.\n"
- title: 6.  IANA Considerations
  contents:
  - "6.  IANA Considerations\n   This section provides guidance to the Internet Assigned\
    \ Numbers\n   Authority (IANA) regarding registration of values related to the\
    \ QoS\n   NSLP, in accordance with BCP 26, RFC 5226 [RFC5226].\n   Per QoS NSLP,\
    \ IANA has created a number of new registries:\n      - QoS NSLP Message Types\n\
    \      - QoS NSLP Binding Codes\n      - QoS NSLP Error Classes\n        - Informational\
    \ Error Codes\n        - Success Error Codes\n        - Protocol Error Codes\n\
    \        - Transient Failure Codes\n        - Permanent Failure Codes\n      -\
    \ QoS NSLP Error Source Identifiers\n   IANA has also registered new values in\
    \ a number of registries:\n      - NSLP Object Types\n      - NSLP Identifiers\
    \ (under GIST Parameters)\n      - Router Alert Option Values (IPv4 and IPv6)\n"
- title: 6.1.  QoS NSLP Message Type
  contents:
  - "6.1.  QoS NSLP Message Type\n   The QoS NSLP Message Type is an 8-bit value.\
    \  This specification\n   defines four QoS NSLP message types, which form the\
    \ initial contents\n   of this registry: RESERVE (0x01), QUERY (0x02), RESPONSE\
    \ (0x03), and\n   NOTIFY (0x04).\n   The value 0 is reserved.  Values 240 to 255\
    \ are for Experimental/\n   Private Use.  The registration procedure is IETF Review.\n\
    \   When a new message type is defined, any message flags used with it\n   must\
    \ also be defined.\n"
- title: 6.2.  NSLP Message Objects
  contents:
  - "6.2.  NSLP Message Objects\n   A new registry has been created for NSLP Message\
    \ Objects.  This is a\n   12-bit field (giving values from 0 to 4095).  This registry\
    \ is shared\n   between a number of NSLPs.\n   Registration procedures are as\
    \ follows:\n      0: Reserved\n      1-1023: IETF Review\n      1024-1999: Specification\
    \ Required\n   Allocation policies are as follows:\n      2000-2047: Private/Experimental\
    \ Use\n      2048-4095: Reserved\n   When a new object is defined, the extensibility\
    \ bits (A/B) must also\n   be defined.\n   This document defines eleven new NSLP\
    \ message objects.  These are\n   described in Section 5.1.3: RII (0x001), RSN\
    \ (0x002), REFRESH-PERIOD\n   (0x003), BOUND-SESSION-ID (0x004), PACKET-CLASSIFIER\
    \ (0x005), INFO-\n   SPEC (0x006), SESSION-ID-LIST (0x007), RSN-LIST (0x008),\
    \ MSG-ID\n   (0x009), BOUND-MSG-ID (0x00A), and QSPEC (0x00B).\n   Additional\
    \ values are to be assigned from the IETF Review section of\n   the NSLP Message\
    \ Objects registry.\n"
- title: 6.3.  QoS NSLP Binding Codes
  contents:
  - "6.3.  QoS NSLP Binding Codes\n   A new registry has been created for the 8-bit\
    \ Binding Codes used in\n   the BOUND-SESSION-ID object.  The initial values for\
    \ this registry\n   are listed in Section 5.1.3.4.\n   The registration procedure\
    \ is IETF Review.  Value 0 is reserved.\n   Values 128 to 159 are for Experimental/Private\
    \ Use.  Other values are\n   Reserved.\n"
- title: 6.4.  QoS NSLP Error Classes and Error Codes
  contents:
  - "6.4.  QoS NSLP Error Classes and Error Codes\n   In addition, Error Classes and\
    \ Error Codes for the INFO-SPEC object\n   are defined.  These are described in\
    \ Section 5.1.3.6.\n   The Error Class is 4 bits in length.  The initial values\
    \ are:\n      0: Reserved\n      1: Informational\n      2: Success\n      3:\
    \ Protocol Error\n      4: Transient Failure\n      5: Permanent Failure\n   \
    \   6: QoS Model Error\n      7: Signaling session failure (described in [RFC5973])\n\
    \      8-15: Reserved\n   Additional values are to be assigned based on IETF Review.\n\
    \   The Error Code is 8 bits in length.  Each Error Code is assigned\n   within\
    \ a particular Error Class.  This requires the creation of a\n   registry for\
    \ Error Codes in each Error Class.  The Error Code 0 in\n   each class is Reserved.\n\
    \   Policies for the error code registries are as follows:\n      0-63: IETF Review\n\
    \      64-127: Specification Required\n      128-191: Experimental/Private Use\n\
    \      192-255: Reserved\n   The initial assignments for the Error Code registries\
    \ are given in\n   Section 5.1.3.6.  Experimental and Reserved values are relevant\
    \ to\n   all Error classes.\n"
- title: 6.5.  QoS NSLP Error Source Identifiers
  contents:
  - "6.5.  QoS NSLP Error Source Identifiers\n   Section 5.1.3.6 defines Error Source\
    \ Identifiers, the type of which\n   is identified by a 4-bit value.\n   The value\
    \ 0 is reserved.\n   Values 1-3 are given in Section 5.1.3.6.\n   Values 14 and\
    \ 15 are for Experimental/Private Use.\n   The registration procedure is Specification\
    \ Required.\n"
- title: 6.6.  NSLP IDs and Router Alert Option Values
  contents:
  - "6.6.  NSLP IDs and Router Alert Option Values\n   This specification defines\
    \ an NSLP for use with GIST.  Furthermore,\n   it specifies that a number of NSLPID\
    \ values are used for the support\n   of bypassing intermediary nodes.  Consequently,\
    \ new identifiers must\n   be assigned for them from the GIST NSLP identifier\
    \ registry.  As\n   required by the QoS NSLP, 32 NSLPID values have been assigned,\n\
    \   corresponding to QoS NSLP Aggregation Levels 0 to 31.\n   The GIST specification\
    \ also requires that NSLPIDs be associated with\n   specific Router Alert Option\
    \ (RAO) values (although multiple NSLPIDs\n   may be associated with the same\
    \ value).  For the purposes of the QoS\n   NSLP, each of its NSLPID values should\
    \ be associated with a different\n   RAO value.  A block of 32 new IPv4 RAO values\
    \ and a block of 32 new\n   IPv6 RAO values have been assigned, corresponding\
    \ to QoS NSLP\n   Aggregation Levels 0 to 31.\n"
- title: 7.  Security Considerations
  contents:
  - "7.  Security Considerations\n   The security requirement for the QoS NSLP is\
    \ to protect the signaling\n   exchange for establishing QoS reservations against\
    \ identified\n   security threats.  For the signaling problem as a whole, these\n\
    \   threats have been outlined in NSIS threats [RFC4081]; the NSIS\n   framework\
    \ [RFC4080] assigns a subset of the responsibility to GIST,\n   and the remaining\
    \ threats need to be addressed by NSLPs.  The main\n   issues to be handled can\
    \ be summarized as:\n   Authorization:\n      The QoS NSLP must assure that the\
    \ network is protected against\n      theft-of-service by offering mechanisms\
    \ to authorize the QoS\n      reservation requester.  A user requesting a QoS\
    \ reservation might\n      want proper resource accounting and protection against\
    \ spoofing\n      and other security vulnerabilities that lead to denial of service\n\
    \      and financial loss.  In many cases, authorization is based on the\n   \
    \   authenticated identity.  The authorization solution must provide\n      guarantees\
    \ that replay attacks are either not possible or limited\n      to a certain extent.\
    \  Authorization can also be based on traits\n      that enable the user to remain\
    \ anonymous.  Support for user\n      identity confidentiality can be accomplished.\n\
    \   Message Protection:\n      Signaling message content should be protected against\n\
    \      modification, replay, injection, and eavesdropping while in\n      transit.\
    \  Authorization information, such as authorization tokens,\n      needs protection.\
    \  This type of protection at the NSLP layer is\n      necessary to protect messages\
    \ between NSLP nodes.\n   Rate Limitation:\n      QNEs should perform rate-limiting\
    \ on the refresh messages that\n      they send.  An attacker could send erroneous\
    \ messages on purpose,\n      forcing the QNE to constantly reply with an error\
    \ message.\n      Authentication mechanisms would help in figuring out if error\n\
    \      situations should be reported to the sender, or silently ignored.\n   \
    \   If the sender is authenticated, the QNE should reply promptly.\n   Prevention\
    \ of Denial-of-Service Attacks:\n      GIST and QoS NSLP nodes have finite resources\
    \ (state storage,\n      processing power, bandwidth).  The protocol mechanisms\
    \ in this\n      document try to minimize exhaustion attacks against these\n \
    \     resources when performing authentication and authorization for QoS\n   \
    \   resources.\n   To some extent, the QoS NSLP relies on the security mechanisms\n\
    \   provided by GIST, which by itself relies on existing authentication\n   and\
    \ key exchange protocols.  Some signaling messages cannot be\n   protected by\
    \ GIST and hence should be used with care by the QoS NSLP.\n   An API must ensure\
    \ that the QoS NSLP implementation is aware of the\n   underlying security mechanisms\
    \ and must be able to indicate which\n   degree of security is provided between\
    \ two GIST peers.  If a level of\n   security protection for QoS NSLP messages\
    \ that is required goes\n   beyond the security offered by GIST or underlying\
    \ security\n   mechanisms, additional security mechanisms described in this document\n\
    \   must be used.  Due to the different usage environments and scenarios\n   where\
    \ NSIS is used, it is very difficult to make general statements\n   without reducing\
    \ its flexibility.\n"
- title: 7.1.  Trust Relationship Model
  contents:
  - "7.1.  Trust Relationship Model\n   This specification is based on a model that\
    \ requires trust between\n   neighboring NSLP nodes to establish a chain-of-trust\
    \ along the QoS\n   signaling path.  The model is simple to deploy, was used in\
    \ previous\n   QoS authorization environments (such as RSVP), and seems to provide\n\
    \   sufficiently strong security properties.  We refer to this model as\n   the\
    \ New Jersey Turnpike.\n   On the New Jersey Turnpike, motorists pick up a ticket\
    \ at a toll\n   booth when entering the highway.  At the highway exit, the ticket\
    \ is\n   presented and payment is made at the toll booth for the distance\n  \
    \ driven.  For QoS signaling in the Internet, this procedure is roughly\n   similar.\
    \  In most cases, the data sender is charged for transmitted\n   data traffic\
    \ where charging is provided only between neighboring\n   entities.\n      +------------------+\
    \  +------------------+  +------------------+\n      |          Network |  | \
    \         Network |  |          Network |\n      |             X    |  |     \
    \        Y    |  |             Z    |\n      |                  |  |         \
    \         |  |                  |\n      |              ----------->         \
    \ ----------->              |\n      |                  |  |                 \
    \ |  |                  |\n      |                  |  |                  |  |\
    \                  |\n      +--------^---------+  +------------------+  +-------+----------+\n\
    \               |                                          .\n               |\
    \                                          .\n               |               \
    \                           v\n            +--+---+  Data                   Data\
    \      +--+---+\n            | Node |  ==============================>  | Node\
    \ |\n            |  A   |  Sender                Receiver   |  B   |\n       \
    \     +------+                                   +------+\n        Legend:\n \
    \       ----> Peering relationship that allows neighboring\n              networks/entities\
    \ to charge each other for the\n              QoS reservation and data traffic\n\
    \        ====> Data flow\n        .... Communication to the end host\n       \
    \            Figure 16: New Jersey Turnpike Model\n   The model shown in Figure\
    \ 16 uses peer-to-peer relationships between\n   different administrative domains\
    \ as a basis for accounting and\n   charging.  As mentioned above, based on the\
    \ peering relationship, a\n   chain-of-trust is established.  There are several\
    \ issues that come to\n   mind when considering this type of model:\n   o  The\
    \ model allows authorization on a request basis or on a per-\n      session basis.\
    \  Authorization mechanisms are elaborated in\n      Section 7.2.  The duration\
    \ for which the QoS authorization is\n      valid needs to be controlled.  Combining\
    \ the interval with the\n      soft-state interval is possible.  Notifications\
    \ from the networks\n      also seem to be a viable approach.\n   o  The price\
    \ for a QoS reservation needs to be determined somehow and\n      communicated\
    \ to the charged entity and to the network where the\n      charged entity is\
    \ attached.  Protocols providing \"Advice of\n      Charge\" functionality are\
    \ out of scope.\n   o  This architecture is simple enough to allow a scalable\
    \ solution\n      (ignoring reverse charging, multicast issues, and price\n  \
    \    distribution).\n   Charging the data sender as performed in the model simplifies\n\
    \   security handling by demanding only peer-to-peer security protection.\n  \
    \ Node A would perform authentication and key establishment.  The\n   established\
    \ security association (together with the session key)\n   would allow the user\
    \ to protect QoS signaling messages.  The identity\n   used during the authentication\
    \ and key establishment phase would be\n   used by Network X (see Figure 16) to\
    \ perform the so-called policy-\n   based admission control procedure.  In our\
    \ context, this user\n   identifier would be used to establish the necessary infrastructure\
    \ to\n   provide authorization and charging.  Signaling messages later\n   exchanged\
    \ between the different networks are then also subject to\n   authentication and\
    \ authorization.  However, the authenticated entity\n   is thereby the neighboring\
    \ network and not the end host.\n   The New Jersey Turnpike model is attractive\
    \ because of its\n   simplicity.  S. Shenker, et al. [shenker] discuss various\
    \ accounting\n   implications and introduced the edge pricing model.  The edge\
    \ pricing\n   model shows similarity to the model described in this section, with\n\
    \   the exception that mobility and the security implications are not\n   addressed.\n"
- title: 7.2.  Authorization Model Examples
  contents:
  - "7.2.  Authorization Model Examples\n   Various authorization models can be used\
    \ in conjunction with the QoS\n   NSLP.\n"
- title: 7.2.1.  Authorization for the Two-Party Approach
  contents:
  - "7.2.1.  Authorization for the Two-Party Approach\n   The two-party approach (Figure\
    \ 17) is conceptually the simplest\n   authorization model.\n   +-------------+\
    \  QoS request     +--------------+\n   |  Entity     |----------------->| Entity\
    \       |\n   |  requesting |                  | authorizing  |\n   |  resource\
    \   |granted / rejected| resource     |\n   |             |<-----------------|\
    \ request      |\n   +-------------+                  +--------------+\n     \
    \        ^                           ^\n             +...........................+\n\
    \                     compensation\n                       Figure 17: Two-Party\
    \ Approach\n   In this example, the authorization decision only involves the two\n\
    \   entities, or makes use of previous authorization using an out-of-band\n  \
    \ mechanism to avoid the need for active participation of an external\n   entity\
    \ during the NSIS protocol execution.\n   This type of model may be applicable,\
    \ e.g., between two neighboring\n   networks (inter-domain signaling) where a\
    \ long-term contract (or\n   other out-of-band mechanisms) exists to manage charging\
    \ and provides\n   sufficient information to authorize individual requests.\n"
- title: 7.2.2.  Token-Based Three-Party Approach
  contents:
  - "7.2.2.  Token-Based Three-Party Approach\n   An alternative approach makes use\
    \ of tokens, such as those described\n   in RFC 3520 [RFC3520] and RFC 3521 [RFC3521]\
    \ or used as part of the\n   Open Settlement Protocol [osp].  Authorization tokens\
    \ are used to\n   associate two different signaling protocols runs (e.g., SIP\
    \ and NSIS)\n   and their authorization decision with each other.  The latter\
    \ is a\n   form of assertion or trait.  As an example, with the authorization\n\
    \   token mechanism, some form of authorization is provided by the SIP\n   proxy,\
    \ which acts as the resource-authorizing entity in Figure 18.\n   If the request\
    \ is authorized, then the SIP signaling returns an\n   authorization token that\
    \ can be included in the QoS signaling\n   protocol messages to refer to the previous\
    \ authorization decision.\n   The tokens themselves may take a number of different\
    \ forms, some of\n   which may require the entity performing the QoS reservation\
    \ to query\n   the external state.\n     Authorization\n     Token Request   +--------------+\n\
    \     +-------------->| Entity C     | financial settlement\n     |          \
    \     | authorizing  | <..................+\n     |               | resource \
    \    |                    .\n     |        +------+ request      |           \
    \         .\n     |        |      +--------------+                    .\n    \
    \ |        |                                          .\n     |        |Authorization\
    \                             .\n     |        |Token                        \
    \             .\n     |        |                                          .\n\
    \     |        |                                          .\n     |        | \
    \                                         .\n     |        |      QoS request\
    \                         .\n   +-------------+ + Authz. Token   +--------------+\
    \     .\n   |  Entity     |----------------->| Entity B     |     .\n   |  requesting\
    \ |                  | performing   |     .\n   |  resource   |granted / rejected|\
    \ QoS          |  <..+\n   |      A      |<-----------------| reservation  |\n\
    \   +-------------+                  +--------------+\n                Figure\
    \ 18: Token-Based Three-Party Approach\n   For the digital money type of systems\
    \ (e.g., OSP tokens), the token\n   represents a limited amount of credit.  So,\
    \ new tokens must be sent\n   with later refresh messages once the credit is exhausted.\n"
- title: 7.2.3.  Generic Three-Party Approach
  contents:
  - "7.2.3.  Generic Three-Party Approach\n   Another method is for the node performing\
    \ the QoS reservation to\n   delegate the authorization decision to a third party,\
    \ as illustrated\n   in Figure 19.  The authorization decision may be performed\
    \ on a per-\n   request basis, periodically, or on a per-session basis.\n    \
    \                                +--------------+\n                          \
    \          | Entity C     |\n                                    | authorizing\
    \  |\n                                    | resource     |\n                 \
    \                   | request      |\n                                    +-----------+--+\n\
    \                                       ^        |\n                         \
    \          QoS |        | QoS\n                                  authz|      \
    \  |authz\n                                   req.|        | res.\n          \
    \            QoS              |        v\n   +-------------+    request      \
    \ +--+-----------+\n   |  Entity     |----------------->| Entity B     |\n   |\
    \  requesting |                  | performing   |\n   |  resource   |granted /\
    \ rejected| QoS          |\n   |      A      |<-----------------| reservation\
    \  |\n   +-------------+                  +--------------+\n                 \
    \     Figure 19: Three-Party Approach\n"
- title: 7.3.  Computing the Authorization Decision
  contents:
  - "7.3.  Computing the Authorization Decision\n   Whenever an authorization decision\
    \ has to be made there is the\n   question about which information serves as an\
    \ input to the\n   authorizing entity.  The following information items have been\n\
    \   mentioned in the past for computing the authorization decision (in\n   addition\
    \ to the authenticated identity):\n      Price\n      QoS objects\n      Policy\
    \ rules\n   Policy rules take into consideration attributes like time of day,\n\
    \   subscription to certain services, membership, etc., when computing an\n  \
    \ authorization decision.\n   The policies used to make the authorization are\
    \ outside the scope of\n   this document and are implementation/deployment specific.\n"
- title: 8.  Acknowledgments
  contents:
  - "8.  Acknowledgments\n   The authors would like to thank Eleanor Hepworth, Ruediger\
    \ Geib,\n   Roland Bless, Nemeth Krisztian, Markus Ott, Mayi Zoumaro-Djayoon,\n\
    \   Martijn Swanink, and Ruud Klaver for their useful comments.  Roland,\n   especially,\
    \ has done deep reviews of the document, making sure the\n   protocol is well\
    \ defined.  Bob Braden provided helpful comments and\n   guidance which were gratefully\
    \ received.\n"
- title: 9.  Contributors
  contents:
  - "9.  Contributors\n   This document combines work from three individual documents.\
    \  The\n   following authors from these documents also contributed to this\n \
    \  document: Robert Hancock (Siemens/Roke Manor Research), Hannes\n   Tschofenig\
    \ and Cornelia Kappler (Siemens AG), Lars Westberg and\n   Attila Bader (Ericsson),\
    \ and Maarten Buechli (Dante) and Eric\n   Waegeman (Alcatel).  In addition, Roland\
    \ Bless has contributed\n   considerable amounts of text all along the writing\
    \ of this\n   specification.\n   Sven Van den Bosch was the initial editor of\
    \ earlier draft versions\n   of this document.  Since version 06 of the document,\
    \ Jukka Manner has\n   taken the editorship.  Yacine El Mghazli (Alcatel) contributed\
    \ text\n   on AAA.  Charles Shen and Henning Schulzrinne suggested the use of\n\
    \   the reason field in the BOUND-SESSION-ID.\n"
- title: 10.  References
  contents:
  - '10.  References

    '
- title: 10.1.  Normative References
  contents:
  - "10.1.  Normative References\n   [RFC1982]    Elz, R. and R. Bush, \"Serial Number\
    \ Arithmetic\",\n                RFC 1982, August 1996.\n   [RFC2119]    Bradner,\
    \ S., \"Key words for use in RFCs to Indicate\n                Requirement Levels\"\
    , BCP 14, RFC 2119, March 1997.\n   [RFC5971]    Schulzrinne, H. and R. Hancock,\
    \ \"GIST: General Internet\n                Signalling Transport\", RFC 5971,\
    \ October 2010.\n   [RFC5975]    Ash, G., Bader, A., Kappler, C., and D. Oran,\
    \ \"QSPEC\n                Template for the Quality-of-Service NSIS Signaling\
    \ Layer\n                Protocol (NSLP)\", RFC 5975, October 2010.\n"
- title: 10.2.  Informative References
  contents:
  - "10.2.  Informative References\n   [NSIS-AUTH]  Manner, J., Stiemerling, M., Tschofenig,\
    \ H., and R.\n                Bless, Ed., \"Authorization for NSIS Signaling Layer\n\
    \                Protocols\", Work in Progress, May 2010.\n   [NSIS-MOB]   Sanda,\
    \ T., Fu, X., Jeong, S., Manner, J., and H.\n                Tschofenig, \"NSIS\
    \ Protocols operation in Mobile\n                Environments\", Work in Progress,\
    \ May 2010.\n   [RFC1633]    Braden, B., Clark, D., and S. Shenker, \"Integrated\n\
    \                Services in the Internet Architecture: an Overview\",\n     \
    \           RFC 1633, June 1994.\n   [RFC2205]    Braden, B., Zhang, L., Berson,\
    \ S., Herzog, S., and S.\n                Jamin, \"Resource ReSerVation Protocol\
    \ (RSVP) -- Version\n                1 Functional Specification\", RFC 2205, September\
    \ 1997.\n   [RFC2210]    Wroclawski, J., \"The Use of RSVP with IETF Integrated\n\
    \                Services\", RFC 2210, September 1997.\n   [RFC2961]    Berger,\
    \ L., Gan, D., Swallow, G., Pan, P., Tommasi, F.,\n                and S. Molendini,\
    \ \"RSVP Refresh Overhead Reduction\n                Extensions\", RFC 2961, April\
    \ 2001.\n   [RFC3175]    Baker, F., Iturralde, C., Le Faucheur, F., and B. Davie,\n\
    \                \"Aggregation of RSVP for IPv4 and IPv6 Reservations\",\n   \
    \             RFC 3175, September 2001.\n   [RFC3520]    Hamer, L-N., Gage, B.,\
    \ Kosinski, B., and H. Shieh,\n                \"Session Authorization Policy\
    \ Element\", RFC 3520,\n                April 2003.\n   [RFC3521]    Hamer, L-N.,\
    \ Gage, B., and H. Shieh, \"Framework for\n                Session Set-up with\
    \ Media Authorization\", RFC 3521,\n                April 2003.\n   [RFC3726]\
    \    Brunner, M., \"Requirements for Signaling Protocols\",\n                RFC\
    \ 3726, April 2004.\n   [RFC4080]    Hancock, R., Karagiannis, G., Loughney, J.,\
    \ and S. Van\n                den Bosch, \"Next Steps in Signaling (NSIS): Framework\"\
    ,\n                RFC 4080, June 2005.\n   [RFC4081]    Tschofenig, H. and D.\
    \ Kroeselberg, \"Security Threats for\n                Next Steps in Signaling\
    \ (NSIS)\", RFC 4081, June 2005.\n   [RFC5226]    Narten, T. and H. Alvestrand,\
    \ \"Guidelines for Writing an\n                IANA Considerations Section in\
    \ RFCs\", BCP 26, RFC 5226,\n                May 2008.\n   [RFC5234]    Crocker,\
    \ D. and P. Overell, \"Augmented BNF for Syntax\n                Specifications:\
    \ ABNF\", STD 68, RFC 5234, January 2008.\n   [RFC5973]    Stiemerling, M., Tschofenig,\
    \ H., Aoun, C., and E.\n                Davies, \"NAT/Firewall NSIS Signaling\
    \ Layer Protocol\n                (NSLP)\", RFC 5973, October 2010.\n   [RFC5977]\
    \    Bader, A., Westberg, L., Karagiannis, G., Kappler, C.,\n                Tschofenig,\
    \ H., and T. Phelan, \"RMD-QOSM: The NSIS\n                Quality-of-Service\
    \ Model for Resource Management in\n                Diffserv\", RFC 5977, October\
    \ 2010.\n   [lrsvp]      Manner, J. and K. Raatikainen, \"Localized QoS Management\n\
    \                for Multimedia Applications in Wireless Access\n            \
    \    Networks\", IASTED IMSA, Technical Specification 101 321,\n             \
    \   p. 193-200, August 2004.\n   [opwa95]     Breslau, L., \"Two Issues in Reservation\
    \ Establishment\",\n                Proc. ACM SIGCOMM '95, Cambridge MA, August\
    \ 1995.\n   [osp]        ETSI, \"Telecommunications and Internet Protocol\n  \
    \              Harmonization Over Networks (TIPHON); Open Settlement\n       \
    \         Protocol (OSP) for Inter-Domain pricing, authorization,\n          \
    \      and usage exchange\", Technical Specification 101 321,\n              \
    \  version 4.1.1.\n   [qos-auth]   Tschofenig, H., \"QoS NSLP Authorization Issues\"\
    , Work\n                in Progress, June 2003.\n   [shenker]    Shenker, S.,\
    \ et al., \"Pricing in computer networks:\n                Reshaping the research\
    \ agenda\", Proc. of TPRC 1995,\n                1995.\n"
- title: Appendix A.  Abstract NSLP-RMF API
  contents:
  - "Appendix A.  Abstract NSLP-RMF API\n   This appendix is purely informational\
    \ and provides an abstract API\n   between the QoS NSLP and the RMF.  It should\
    \ not be taken as a strict\n   rule for implementors, but rather it helps clarify\
    \ the interface\n   between the NSLP and RMF.\n"
- title: A.1.  Triggers from QOS-NSLP towards RMF
  contents:
  - "A.1.  Triggers from QOS-NSLP towards RMF\n   The QoS-NSLP triggers the RMF/QOSM\
    \ functionality by using the\n   sendrmf() primitive:\n   int sendrmf(sid, nslp_req_type,\
    \ qspec, authorization_info,\n   NSLP_objects, filter, features_in, GIST_API_triggers,\n\
    \   incoming_interface, outgoing_interface)\n   o  sid: SESSION-ID - The NSIS\
    \ session identifier\n   o  nslp_req_type: indicates type of request:\n      *\
    \  RESERVE\n      *  QUERY\n      *  RESPONSE\n      *  NOTIFY\n   o  qspec: the\
    \ QSPEC object, if present\n   o  authorization_info: the AUTH_SESSION object,\
    \ if present\n   o  NSLP_objects: data structure that contains a list with received\n\
    \      QoS-NSLP objects.  This list can be used by, e.g., local\n      applications,\
    \ network management, or policy control modules:\n      *  RII\n      *  RSN\n\
    \      *  BOUND-SESSION-ID list\n      *  REFRESH-PERIOD\n      *  SESSION-ID-LIST\n\
    \      *  RSN-LIST\n      *  INFO-SPEC\n      *  MSG-ID\n      *  BOUND-MSG-ID\n\
    \   o  filter: the information for packet filtering, based on the MRI and\n  \
    \    the PACKET-CLASSIFIER object.\n   o  features_in: it represents the flags\
    \ included in the common header\n      of the received QOS-NSLP message, but also\
    \ additional triggers:\n      *  BREAK\n      *  REQUEST REDUCED REFRESHES\n \
    \     *  RESERVE-INIT\n      *  TEAR\n      *  REPLACE\n      *  ACK-REQ\n   \
    \   *  PROXY\n      *  SCOPING\n      *  synchronization_required: this attribute\
    \ is set (see Sections\n         Section 4.6 and Section 4.7.1, for example) when\
    \ the QoS-NSLP\n         functionality supported by a QNE Egress receives a non-tearing\n\
    \         RESERVE message that includes a MSG-ID or a BOUND-MSG-ID\n         object,\
    \ and the BINDING_CODE value of the BOUND-SESSION-ID\n         object is equal\
    \ to one of the following values:\n         +  Tunnel and end-to-end sessions\n\
    \         +  Aggregate sessions\n      *  GIST_API_triggers: it represents the\
    \ attributes that are\n         provided by GIST to QoS-NSLP via the GIST API:\n\
    \         +  NSLPID\n         +  Routing-State-Check\n         +  SII-Handle\n\
    \         +  Transfer-Attributes\n         +  GIST-Hop-Count\n         +  IP-TTL\n\
    \         +  IP-Distance\n   o  incoming_interface: the ID of the incoming interface.\
    \  Used only\n      when the QNE reserves resources on incoming interface.  Default\
    \ is\n      0 (no reservations on incoming interface)\n   o  outgoing_interface:\
    \ the ID of the outgoing interface.  Used only\n      when the QNE reserves resources\
    \ on outgoing interface.  Default is\n      0 (no reservations on outgoing interface)\n"
- title: A.2.  Triggers from RMF/QOSM towards QOS-NSLP
  contents:
  - "A.2.  Triggers from RMF/QOSM towards QOS-NSLP\n   The RMF triggers the QoS-NSLP\
    \ functionality using the \"recvrmf()\" and\n   \"config()\" primitives to perform\
    \ either all or a subset of the\n   features listed below.\n   The recvrmf() primitive\
    \ represents either a response to a request\n   that has been sent via the API\
    \ by the QoS-NSLP or an asynchronous\n   notification.  Note that when the RMF/QOSM\
    \ receives a request via the\n   API from the QoS-NSLP function, one or more \"\
    recvrmf()\" response\n   primitives can be sent via the API towards QoS-NSLP.\
    \  In this way,\n   the QOS-NSLP can generate one or more QoS-NSLP messages that\
    \ can be\n   used, for example, in the situation that the arrival of one end-to-\n\
    \   end RESERVE triggers the generation of two (or more) RESERVE\n   messages:\
    \ an end-to-end RESERVE message and one (or more) intra-\n   domain (local) RESERVE\
    \ message.\n   The config() primitive is used to configure certain features, such\
    \ as\n   QNE type, stateful or stateless operation, or bypassing of end-to-end\n\
    \   messages.\n   Note that the selection of the subset of triggers is controlled\
    \ by\n   the QoS Model.\n   int recvrmf(sid, nslp_resp_type, qspec, authorization_info,\
    \ status,\n   NSLP_objects, filter, features_out, GIST_API_triggers\n   incoming_interface,\
    \ outgoing_interface)\n   o  sid: SESSION-ID - The NSIS session identifier\n \
    \  o  nslp_resp_type: indicates type of response:\n      *  RESERVE\n      * \
    \ QUERY\n      *  RESPONSE\n      *  NOTIFY\n   o  qspec: the QSPEC object, if\
    \ present\n   o  authorization_info: the AUTHO_SESSION object, if present\n  \
    \ o  status: boolean that notifies the status of the reservation and\n      can\
    \ be used by QOS-NSLP to include in the INFO-SPEC object:\n      *  RESERVATION_SUCCESSFUL\n\
    \      *  TEAR_DOWN_SUCCESSFUL\n      *  NO RESOURCES\n      *  RESERVATION_FAILURE\n\
    \      *  RESERVATION_PREEMPTED: reservation was preempted\n      *  AUTHORIZATION_FAILED:\
    \ authorizing the request failed\n      *  MALFORMED_QSPEC: request failed due\
    \ to malformed qspec\n      *  SYNCHRONIZATION_FAILED: Mismatch synchronization\
    \ between an\n         end-to-end RESERVE and an intra-domain RESERVE (see Sections\n\
    \         Section 4.6 and Section 4.7.1)\n      *  CONGESTION_SITUATION: Possible\
    \ congestion situation occurred on\n         downstream path\n      *  QoS Model\
    \ Error\n   o  NSLP_objects: data structure that contains a list with QoS-NSLP\n\
    \      objects that can be used by QoS-NSLP when the QNE is a QNI, QNR,\n    \
    \  QNI_Ingress, QNR_Ingress, QNI_Egress, or QNR_Egress:\n      *  RII\n      *\
    \  RSN\n      *  BOUND-SESSION-ID list\n      *  REFRESH-PERIOD\n      *  SESSION-ID-LIST\n\
    \      *  RSN-LIST\n      *  MSG-ID\n      *  BOUND-MSG-ID\n   o  filter: it represents\
    \ the MRM-related PACKET CLASSIFIER\n   o  features_out: it represents (among\
    \ others) the flags that can be\n      used by the QOS-NSLP for newly generated\
    \ QoS-NSLP messages:\n      *  BREAK\n      *  REQUEST REDUCED REFRESHES\n   \
    \   *  RESERVE-INIT\n      *  TEAR\n      *  REPLACE\n      *  ACK-REQ\n     \
    \ *  PROXY\n      *  SCOPING\n      *  BYPASSING - when the outgoing message should\
    \ be bypassed, then\n         it includes the required bypassing level.  Otherwise,\
    \ it is\n         empty.  It can be set only by QNI_Ingress, QNR_Ingress,\n  \
    \       QNI_Egress, or QNR_Egress.  It can be unset only by\n         QNI_Ingress,\
    \ QNR_Ingress, QNI_Egress, or QNR_Egress.\n      *  BINDING () - when BINDING\
    \ is required, then it includes a\n         BOUND-SESSION-ID list.  Otherwise,\
    \ it is empty.  It can only be\n         requested by the following QNE types:\
    \ QNI, QNR, QNI_Ingress,\n         QNR_Ingress, QNI_Egress, or QNR_Egress.\n \
    \     *  NEW_SID - it requests to generate a new session with a new\n        \
    \ SESSION-ID.  If the QoS-NSLP generates a new SESSION-ID, then\n         the\
    \ QoS-NSLP has to return the value of this new SESSION-ID to\n         the RMF/QOSM.\
    \  It can be requested by a QNI, QNR, QNI_Ingress,\n         QNI_Egress, QNR_Ingress,\
    \ or QNR_Egress.\n      *  NEW_RSN - it requests to generate a new RSN.  If the\
    \ QoS-NSLP\n         generates a new RSN, then the QoS-NSLP has to return the\
    \ value\n         of this new RSN to the RMF/QOSM.\n      *  NEW_RII - it requests\
    \ to generate a new RII.  If the QoS-NSLP\n         generates a new RII, then\
    \ the QoS-NSLP has to return the value\n         of this new RII to the RMF/QOSM.\n\
    \   o  GIST_API_triggers: it represents the attributes that are provided\n   \
    \   to GIST via QoS-NSLP via the GIST API:\n      *  NSLPID\n      *  SII-Handle\n\
    \      *  Transfer-Attributes\n      *  GIST-Hop-Count\n      *  IP-TTL\n    \
    \  *  ROUTING-STATE-CHECK (if set, it requires that GIST create a\n         routing\
    \ state)\n   o  incoming_interface: the ID of the incoming interface.  Used only\n\
    \      when the QNE reserves resources on the incoming interface.\n      Default\
    \ is 0 (no reservations on the incoming interface).\n   o  outgoing_interface:\
    \ the ID of the outgoing interface.  Used only\n      when the QNE reserves resources\
    \ on the outgoing interface.\n      Default is 0 (no reservations on the outgoing\
    \ interface).\n"
- title: A.3.  Configuration Interface
  contents:
  - "A.3.  Configuration Interface\n   The config() function is meant for configuring\
    \ per-session settings,\n   from the RMF towards the NSLP.\n   int config(sid,\
    \ qne_type, state_type, bypassing_type)\n   o  sid: SESSION-ID - The NSIS session\
    \ identifier\n   o  qne_type: it defines the type of a QNE\n      *  QNI\n   \
    \   *  QNI_Ingress: the QNE is a QNI and an Ingress QNE\n      *  QNE: the QNE\
    \ is not a QNI or QNR\n      *  QNE_Interior: the QNE is an Interior QNE, but\
    \ it is not a QNI\n         or QNR\n      *  QNI_Egress: the QNE is a QNI and\
    \ an Egress QNE\n      *  QNR\n      *  QNR_Ingress: the QNE is a QNR and an Ingress\
    \ QNE\n      *  QNR_Egress: the QNE is a QNR and an Egress QNE\n   o  state_type:\
    \ it defines if the QNE keeps QoS-NSLP operational\n      states\n      *  STATEFUL\n\
    \      *  STATELESS\n   o  bypassing_type: it defines if a QNE bypasses end-to-end\
    \ messages\n      or not\n"
- title: Appendix B.  Glossary
  contents:
  - "Appendix B.  Glossary\n   AAA: Authentication, Authorization, and Accounting\n\
    \   EAP: Extensible Authentication Protocol\n   MRI: Message Routing Information\
    \ (see [RFC5971])\n   NAT: Network Address Translator\n   NSLP: NSIS Signaling\
    \ Layer Protocol (see [RFC4080])\n   NTLP: NSIS Transport Layer Protocol (see\
    \ [RFC4080])\n   OPWA: One Pass With Advertising\n   OSP: Open Settlement Protocol\n\
    \   PIN: Policy-Ignorant Node\n   QNE: an NSIS Entity (NE), which supports the\
    \ QoS NSLP (see Section 2)\n   QNI: the first node in the sequence of QNEs that\
    \ issues a reservation\n   request for a session (see Section 22)\n   QNR: the\
    \ last node in the sequence of QNEs that receives a\n   reservation request for\
    \ a session (see Section 22)\n   QSPEC: Quality-of-Service Specification\n   RII:\
    \ Request Identification Information\n   RMD: Resource Management for Diffserv\n\
    \   RMF: Resource Management Function\n   RSN: Reservation Sequence Number\n \
    \  RSVP: Resource Reservation Protocol (see [RFC2205])\n   SII: Source Identification\
    \ Information\n   SIP: Session Initiation Protocol\n   SLA: Service Level Agreement\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Jukka Manner\n   Aalto University\n   Department of Communications\
    \ and Networking (Comnet)\n   P.O. Box 13000\n   FIN-00076 Aalto\n   Finland\n\
    \   Phone: +358 9 470 22481\n   EMail: jukka.manner@tkk.fi\n   URI:   http://www.netlab.tkk.fi/~jmanner/\n\
    \   Georgios Karagiannis\n   University of Twente/Ericsson\n   P.O. Box 217\n\
    \   Enschede  7500 AE\n   The Netherlands\n   EMail: karagian@cs.utwente.nl\n\
    \   Andrew McDonald\n   Roke Manor Research Ltd\n   Old Salisbury Lane\n   Romsey,\
    \ Hampshire  S051 0ZN\n   United Kingdom\n   EMail: andrew.mcdonald@roke.co.uk\n"
