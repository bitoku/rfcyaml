- contents:
  - "            DOMAIN NAMES - IMPLEMENTATION AND SPECIFICATION\n1. STATUS OF THIS
    MEMO\nThis RFC describes the details of the domain system and protocol, and\nassumes
    that the reader is familiar with the concepts discussed in a\ncompanion RFC, \"Domain
    Names - Concepts and Facilities\" [RFC-1034].\nThe domain system is a mixture
    of functions and data types which are an\nofficial protocol and functions and
    data types which are still\nexperimental.  Since the domain system is intentionally
    extensible, new\ndata types and experimental behavior should always be expected
    in parts\nof the system beyond the official protocol.  The official protocol parts\ninclude
    standard queries, responses and the Internet class RR data\nformats (e.g., host
    addresses).  Since the previous RFC set, several\ndefinitions have changed, so
    some previous definitions are obsolete.\nExperimental or obsolete features are
    clearly marked in these RFCs, and\nsuch information should be used with caution.\nThe
    reader is especially cautioned not to depend on the values which\nappear in examples
    to be current or complete, since their purpose is\nprimarily pedagogical.  Distribution
    of this memo is unlimited.\n                           Table of Contents\n  1.
    STATUS OF THIS MEMO                                              1\n  2. INTRODUCTION
    \                                                    3\n      2.1. Overview                                                   3\n
    \     2.2. Common configurations                                      4\n      2.3.
    Conventions                                                7\n          2.3.1.
    Preferred name syntax                                7\n          2.3.2. Data
    Transmission Order                              8\n          2.3.3. Character
    Case                                       9\n          2.3.4. Size limits                                         10\n
    \ 3. DOMAIN NAME SPACE AND RR DEFINITIONS                            10\n      3.1.
    Name space definitions                                    10\n      3.2. RR definitions
    \                                           11\n          3.2.1. Format                                              11\n
    \         3.2.2. TYPE values                                         12\n          3.2.3.
    QTYPE values                                        12\n          3.2.4. CLASS
    values                                        13\n          3.2.5. QCLASS values
    \                                      13\n      3.3. Standard RRs                                              13\n
    \         3.3.1. CNAME RDATA format                                  14\n          3.3.2.
    HINFO RDATA format                                  14\n          3.3.3. MB RDATA
    format (EXPERIMENTAL)                      14\n          3.3.4. MD RDATA format
    (Obsolete)                          15\n          3.3.5. MF RDATA format (Obsolete)
    \                         15\n          3.3.6. MG RDATA format (EXPERIMENTAL)
    \                     16\n          3.3.7. MINFO RDATA format (EXPERIMENTAL)                   16\n
    \         3.3.8. MR RDATA format (EXPERIMENTAL)                      17\n          3.3.9.
    MX RDATA format                                     17\n          3.3.10. NULL
    RDATA format (EXPERIMENTAL)                   17\n          3.3.11. NS RDATA format
    \                                   18\n          3.3.12. PTR RDATA format                                   18\n
    \         3.3.13. SOA RDATA format                                   19\n          3.3.14.
    TXT RDATA format                                   20\n      3.4. ARPA Internet
    specific RRs                                20\n          3.4.1. A RDATA format
    \                                     20\n          3.4.2. WKS RDATA format                                    21\n
    \     3.5. IN-ADDR.ARPA domain                                       22\n      3.6.
    Defining new types, classes, and special namespaces       24\n  4. MESSAGES                                                        25\n
    \     4.1. Format                                                    25\n          4.1.1.
    Header section format                               26\n          4.1.2. Question
    section format                             28\n          4.1.3. Resource record
    format                              29\n          4.1.4. Message compression                                 30\n
    \     4.2. Transport                                                 32\n          4.2.1.
    UDP usage                                           32\n          4.2.2. TCP usage
    \                                          32\n  5. MASTER FILES                                                    33\n
    \     5.1. Format                                                    33\n      5.2.
    Use of master files to define zones                       35\n      5.3. Master
    file example                                       36\n  6. NAME SERVER IMPLEMENTATION
    \                                     37\n      6.1. Architecture                                              37\n
    \         6.1.1. Control                                             37\n          6.1.2.
    Database                                            37\n          6.1.3. Time
    \                                               39\n      6.2. Standard query
    processing                                 39\n      6.3. Zone refresh and reload
    processing                        39\n      6.4. Inverse queries (Optional)                                40\n
    \         6.4.1. The contents of inverse queries and responses       40\n          6.4.2.
    Inverse query and response example                  41\n          6.4.3. Inverse
    query processing                            42\n      6.5. Completion queries
    and responses                          42\n  7. RESOLVER IMPLEMENTATION                                         43\n
    \     7.1. Transforming a user request into a query                  43\n      7.2.
    Sending the queries                                       44\n      7.3. Processing
    responses                                      46\n      7.4. Using the cache
    \                                          47\n  8. MAIL SUPPORT                                                    47\n
    \     8.1. Mail exchange binding                                     48\n      8.2.
    Mailbox binding (Experimental)                            48\n  9. REFERENCES
    and BIBLIOGRAPHY                                     50\n  Index                                                              54\n2.
    INTRODUCTION\n2.1. Overview\nThe goal of domain names is to provide a mechanism
    for naming resources\nin such a way that the names are usable in different hosts,
    networks,\nprotocol families, internets, and administrative organizations.\nFrom
    the user's point of view, domain names are useful as arguments to a\nlocal agent,
    called a resolver, which retrieves information associated\nwith the domain name.
    \ Thus a user might ask for the host address or\nmail information associated with
    a particular domain name.  To enable\nthe user to request a particular type of
    information, an appropriate\nquery type is passed to the resolver with the domain
    name.  To the user,\nthe domain tree is a single information space; the resolver
    is\nresponsible for hiding the distribution of data among name servers from\nthe
    user.\nFrom the resolver's point of view, the database that makes up the domain\nspace
    is distributed among various name servers.  Different parts of the\ndomain space
    are stored in different name servers, although a particular\ndata item will be
    stored redundantly in two or more name servers.  The\nresolver starts with knowledge
    of at least one name server.  When the\nresolver processes a user query it asks
    a known name server for the\ninformation; in return, the resolver either receives
    the desired\ninformation or a referral to another name server.  Using these\nreferrals,
    resolvers learn the identities and contents of other name\nservers.  Resolvers
    are responsible for dealing with the distribution of\nthe domain space and dealing
    with the effects of name server failure by\nconsulting redundant databases in
    other servers.\nName servers manage two kinds of data.  The first kind of data
    held in\nsets called zones; each zone is the complete database for a particular\n\"pruned\"
    subtree of the domain space.  This data is called\nauthoritative.  A name server
    periodically checks to make sure that its\nzones are up to date, and if not, obtains
    a new copy of updated zones\nfrom master files stored locally or in another name
    server.  The second\nkind of data is cached data which was acquired by a local
    resolver.\nThis data may be incomplete, but improves the performance of the\nretrieval
    process when non-local data is repeatedly accessed.  Cached\ndata is eventually
    discarded by a timeout mechanism.\nThis functional structure isolates the problems
    of user interface,\nfailure recovery, and distribution in the resolvers and isolates
    the\ndatabase update and refresh problems in the name servers.\n2.2. Common configurations\nA
    host can participate in the domain name system in a number of ways,\ndepending
    on whether the host runs programs that retrieve information\nfrom the domain system,
    name servers that answer queries from other\nhosts, or various combinations of
    both functions.  The simplest, and\nperhaps most typical, configuration is shown
    below:\n                 Local Host                        |  Foreign\n                                                   |\n
    \   +---------+               +----------+         |  +--------+\n    |         |
    user queries  |          |queries  |  |        |\n    |  User   |-------------->|
    \         |---------|->|Foreign |\n    | Program |               | Resolver |
    \        |  |  Name  |\n    |         |<--------------|          |<--------|--|
    Server |\n    |         | user responses|          |responses|  |        |\n    +---------+
    \              +----------+         |  +--------+\n                                |
    \    A            |\n                cache additions |     | references |\n                                V
    \    |            |\n                              +----------+         |\n                              |
    \ cache   |         |\n                              +----------+         |\nUser
    programs interact with the domain name space through resolvers; the\nformat of
    user queries and user responses is specific to the host and\nits operating system.
    \ User queries will typically be operating system\ncalls, and the resolver and
    its cache will be part of the host operating\nsystem.  Less capable hosts may
    choose to implement the resolver as a\nsubroutine to be linked in with every program
    that needs its services.\nResolvers answer user queries with information they
    acquire via queries\nto foreign name servers and the local cache.\nNote that the
    resolver may have to make several queries to several\ndifferent foreign name servers
    to answer a particular user query, and\nhence the resolution of a user query may
    involve several network\naccesses and an arbitrary amount of time.  The queries
    to foreign name\nservers and the corresponding responses have a standard format
    described\nin this memo, and may be datagrams.\nDepending on its capabilities,
    a name server could be a stand alone\nprogram on a dedicated machine or a process
    or processes on a large\ntimeshared host.  A simple configuration might be:\n
    \                Local Host                        |  Foreign\n                                                   |\n
    \     +---------+                                  |\n     /         /|                                  |\n
    \   +---------+ |             +----------+         |  +--------+\n    |         |
    |             |          |responses|  |        |\n    |         | |             |
    \  Name   |---------|->|Foreign |\n    |  Master |-------------->|  Server  |
    \        |  |Resolver|\n    |  files  | |             |          |<--------|--|
    \       |\n    |         |/              |          | queries |  +--------+\n
    \   +---------+               +----------+         |\nHere a primary name server
    acquires information about one or more zones\nby reading master files from its
    local file system, and answers queries\nabout those zones that arrive from foreign
    resolvers.\nThe DNS requires that all zones be redundantly supported by more than\none
    name server.  Designated secondary servers can acquire zones and\ncheck for updates
    from the primary server using the zone transfer\nprotocol of the DNS.  This configuration
    is shown below:\n                 Local Host                        |  Foreign\n
    \                                                  |\n      +---------+                                  |\n
    \    /         /|                                  |\n    +---------+ |             +----------+
    \        |  +--------+\n    |         | |             |          |responses|  |
    \       |\n    |         | |             |   Name   |---------|->|Foreign |\n
    \   |  Master |-------------->|  Server  |         |  |Resolver|\n    |  files
    \ | |             |          |<--------|--|        |\n    |         |/              |
    \         | queries |  +--------+\n    +---------+               +----------+
    \        |\n                                A     |maintenance |  +--------+\n
    \                               |     +------------|->|        |\n                                |
    \     queries     |  |Foreign |\n                                |                  |
    \ |  Name  |\n                                +------------------|--| Server |\n
    \                            maintenance responses |  +--------+\nIn this configuration,
    the name server periodically establishes a\nvirtual circuit to a foreign name
    server to acquire a copy of a zone or\nto check that an existing copy has not
    changed.  The messages sent for\nthese maintenance activities follow the same
    form as queries and\nresponses, but the message sequences are somewhat different.\nThe
    information flow in a host that supports all aspects of the domain\nname system
    is shown below:\n                 Local Host                        |  Foreign\n
    \                                                  |\n    +---------+               +----------+
    \        |  +--------+\n    |         | user queries  |          |queries  |  |
    \       |\n    |  User   |-------------->|          |---------|->|Foreign |\n
    \   | Program |               | Resolver |         |  |  Name  |\n    |         |<--------------|
    \         |<--------|--| Server |\n    |         | user responses|          |responses|
    \ |        |\n    +---------+               +----------+         |  +--------+\n
    \                               |     A            |\n                cache additions
    |     | references |\n                                V     |            |\n                              +----------+
    \        |\n                              |  Shared  |         |\n                              |
    database |         |\n                              +----------+         |\n                                A
    \    |            |\n      +---------+     refreshes |     | references |\n     /
    \        /|               |     V            |\n    +---------+ |             +----------+
    \        |  +--------+\n    |         | |             |          |responses|  |
    \       |\n    |         | |             |   Name   |---------|->|Foreign |\n
    \   |  Master |-------------->|  Server  |         |  |Resolver|\n    |  files
    \ | |             |          |<--------|--|        |\n    |         |/              |
    \         | queries |  +--------+\n    +---------+               +----------+
    \        |\n                                A     |maintenance |  +--------+\n
    \                               |     +------------|->|        |\n                                |
    \     queries     |  |Foreign |\n                                |                  |
    \ |  Name  |\n                                +------------------|--| Server |\n
    \                            maintenance responses |  +--------+\nThe shared database
    holds domain space data for the local name server\nand resolver.  The contents
    of the shared database will typically be a\nmixture of authoritative data maintained
    by the periodic refresh\noperations of the name server and cached data from previous
    resolver\nrequests.  The structure of the domain data and the necessity for\nsynchronization
    between name servers and resolvers imply the general\ncharacteristics of this
    database, but the actual format is up to the\nlocal implementor.\nInformation
    flow can also be tailored so that a group of hosts act\ntogether to optimize activities.
    \ Sometimes this is done to offload less\ncapable hosts so that they do not have
    to implement a full resolver.\nThis can be appropriate for PCs or hosts which
    want to minimize the\namount of new network code which is required.  This scheme
    can also\nallow a group of hosts can share a small number of caches rather than\nmaintaining
    a large number of separate caches, on the premise that the\ncentralized caches
    will have a higher hit ratio.  In either case,\nresolvers are replaced with stub
    resolvers which act as front ends to\nresolvers located in a recursive server
    in one or more name servers\nknown to perform that service:\n                   Local
    Hosts                     |  Foreign\n                                                   |\n
    \   +---------+                                    |\n    |         | responses
    \                         |\n    | Stub    |<--------------------+              |\n
    \   | Resolver|                     |              |\n    |         |----------------+
    \   |              |\n    +---------+ recursive      |    |              |\n                queries
    \       |    |              |\n                               V    |              |\n
    \   +---------+ recursive     +----------+         |  +--------+\n    |         |
    queries       |          |queries  |  |        |\n    | Stub    |-------------->|
    Recursive|---------|->|Foreign |\n    | Resolver|               | Server   |         |
    \ |  Name  |\n    |         |<--------------|          |<--------|--| Server |\n
    \   +---------+ responses     |          |responses|  |        |\n                              +----------+
    \        |  +--------+\n                              |  Central |         |\n
    \                             |   cache  |         |\n                              +----------+
    \        |\nIn any case, note that domain components are always replicated for\nreliability
    whenever possible.\n2.3. Conventions\nThe domain system has several conventions
    dealing with low-level, but\nfundamental, issues.  While the implementor is free
    to violate these\nconventions WITHIN HIS OWN SYSTEM, he must observe these conventions
    in\nALL behavior observed from other hosts.\n2.3.1. Preferred name syntax\nThe
    DNS specifications attempt to be as general as possible in the rules\nfor constructing
    domain names.  The idea is that the name of any\nexisting object can be expressed
    as a domain name with minimal changes.\nHowever, when assigning a domain name
    for an object, the prudent user\nwill select a name which satisfies both the rules
    of the domain system\nand any existing rules for the object, whether these rules
    are published\nor implied by existing programs.\nFor example, when naming a mail
    domain, the user should satisfy both the\nrules of this memo and those in RFC-822.
    \ When creating a new host name,\nthe old rules for HOSTS.TXT should be followed.
    \ This avoids problems\nwhen old software is converted to use domain names.\nThe
    following syntax will result in fewer problems with many\napplications that use
    domain names (e.g., mail, TELNET).\n<domain> ::= <subdomain> | \" \"\n<subdomain>
    ::= <label> | <subdomain> \".\" <label>\n<label> ::= <letter> [ [ <ldh-str> ]
    <let-dig> ]\n<ldh-str> ::= <let-dig-hyp> | <let-dig-hyp> <ldh-str>\n<let-dig-hyp>
    ::= <let-dig> | \"-\"\n<let-dig> ::= <letter> | <digit>\n<letter> ::= any one
    of the 52 alphabetic characters A through Z in\nupper case and a through z in
    lower case\n<digit> ::= any one of the ten digits 0 through 9\nNote that while
    upper and lower case letters are allowed in domain\nnames, no significance is
    attached to the case.  That is, two names with\nthe same spelling but different
    case are to be treated as if identical.\nThe labels must follow the rules for
    ARPANET host names.  They must\nstart with a letter, end with a letter or digit,
    and have as interior\ncharacters only letters, digits, and hyphen.  There are
    also some\nrestrictions on the length.  Labels must be 63 characters or less.\nFor
    example, the following strings identify hosts in the Internet:\nA.ISI.EDU XX.LCS.MIT.EDU
    SRI-NIC.ARPA\n2.3.2. Data Transmission Order\nThe order of transmission of the
    header and data described in this\ndocument is resolved to the octet level.  Whenever
    a diagram shows a\ngroup of octets, the order of transmission of those octets
    is the normal\norder in which they are read in English.  For example, in the following\ndiagram,
    the octets are transmitted in the order they are numbered.\n     0                   1\n
    \    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
    \   |       1       |       2       |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
    \   |       3       |       4       |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
    \   |       5       |       6       |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\nWhenever
    an octet represents a numeric quantity, the left most bit in\nthe diagram is the
    high order or most significant bit.  That is, the bit\nlabeled 0 is the most significant
    bit.  For example, the following\ndiagram represents the value 170 (decimal).\n
    \    0 1 2 3 4 5 6 7\n    +-+-+-+-+-+-+-+-+\n    |1 0 1 0 1 0 1 0|\n    +-+-+-+-+-+-+-+-+\nSimilarly,
    whenever a multi-octet field represents a numeric quantity\nthe left most bit
    of the whole field is the most significant bit.  When\na multi-octet quantity
    is transmitted the most significant octet is\ntransmitted first.\n2.3.3. Character
    Case\nFor all parts of the DNS that are part of the official protocol, all\ncomparisons
    between character strings (e.g., labels, domain names, etc.)\nare done in a case-insensitive
    manner.  At present, this rule is in\nforce throughout the domain system without
    exception.  However, future\nadditions beyond current usage may need to use the
    full binary octet\ncapabilities in names, so attempts to store domain names in
    7-bit ASCII\nor use of special bytes to terminate labels, etc., should be avoided.\nWhen
    data enters the domain system, its original case should be\npreserved whenever
    possible.  In certain circumstances this cannot be\ndone.  For example, if two
    RRs are stored in a database, one at x.y and\none at X.Y, they are actually stored
    at the same place in the database,\nand hence only one casing would be preserved.
    \ The basic rule is that\ncase can be discarded only when data is used to define
    structure in a\ndatabase, and two names are identical when compared in a case\ninsensitive
    manner.\nLoss of case sensitive data must be minimized.  Thus while data for x.y\nand
    X.Y may both be stored under a single location x.y or X.Y, data for\na.x and B.X
    would never be stored under A.x, A.X, b.x, or b.X.  In\ngeneral, this preserves
    the case of the first label of a domain name,\nbut forces standardization of interior
    node labels.\nSystems administrators who enter data into the domain database should\ntake
    care to represent the data they supply to the domain system in a\ncase-consistent
    manner if their system is case-sensitive.  The data\ndistribution system in the
    domain system will ensure that consistent\nrepresentations are preserved.\n2.3.4.
    Size limits\nVarious objects and parameters in the DNS have size limits.  They
    are\nlisted below.  Some could be easily changed, others are more\nfundamental.\nlabels
    \         63 octets or less\nnames           255 octets or less\nTTL             positive
    values of a signed 32 bit number.\nUDP messages    512 octets or less\n3. DOMAIN
    NAME SPACE AND RR DEFINITIONS\n3.1. Name space definitions\nDomain names in messages
    are expressed in terms of a sequence of labels.\nEach label is represented as
    a one octet length field followed by that\nnumber of octets.  Since every domain
    name ends with the null label of\nthe root, a domain name is terminated by a length
    byte of zero.  The\nhigh order two bits of every length octet must be zero, and
    the\nremaining six bits of the length field limit the label to 63 octets or\nless.\nTo
    simplify implementations, the total length of a domain name (i.e.,\nlabel octets
    and label length octets) is restricted to 255 octets or\nless.\nAlthough labels
    can contain any 8 bit values in octets that make up a\nlabel, it is strongly recommended
    that labels follow the preferred\nsyntax described elsewhere in this memo, which
    is compatible with\nexisting host naming conventions.  Name servers and resolvers
    must\ncompare labels in a case-insensitive manner (i.e., A=a), assuming ASCII\nwith
    zero parity.  Non-alphabetic codes must match exactly.\n3.2. RR definitions\n3.2.1.
    Format\nAll RRs have the same top level format shown below:\n                                    1
    \ 1  1  1  1  1\n      0  1  2  3  4  5  6  7  8  9  0  1  2  3  4  5\n    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n
    \   |                                               |\n    /                                               /\n
    \   /                      NAME                     /\n    |                                               |\n
    \   +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n    |                      TYPE
    \                    |\n    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n
    \   |                     CLASS                     |\n    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n
    \   |                      TTL                      |\n    |                                               |\n
    \   +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n    |                   RDLENGTH
    \                   |\n    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--|\n
    \   /                     RDATA                     /\n    /                                               /\n
    \   +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\nwhere:\nNAME            an
    owner name, i.e., the name of the node to which this\n                resource
    record pertains.\nTYPE            two octets containing one of the RR TYPE codes.\nCLASS
    \          two octets containing one of the RR CLASS codes.\nTTL             a
    32 bit signed integer that specifies the time interval\n                that the
    resource record may be cached before the source\n                of the information
    should again be consulted.  Zero\n                values are interpreted to mean
    that the RR can only be\n                used for the transaction in progress,
    and should not be\n                cached.  For example, SOA records are always
    distributed\n                with a zero TTL to prohibit caching.  Zero values
    can\n                also be used for extremely volatile data.\nRDLENGTH        an
    unsigned 16 bit integer that specifies the length in\n                octets of
    the RDATA field.\nRDATA           a variable length string of octets that describes
    the\n                resource.  The format of this information varies\n                according
    to the TYPE and CLASS of the resource record.\n3.2.2. TYPE values\nTYPE fields
    are used in resource records.  Note that these types are a\nsubset of QTYPEs.\nTYPE
    \           value and meaning\nA               1 a host address\nNS              2
    an authoritative name server\nMD              3 a mail destination (Obsolete -
    use MX)\nMF              4 a mail forwarder (Obsolete - use MX)\nCNAME           5
    the canonical name for an alias\nSOA             6 marks the start of a zone of
    authority\nMB              7 a mailbox domain name (EXPERIMENTAL)\nMG              8
    a mail group member (EXPERIMENTAL)\nMR              9 a mail rename domain name
    (EXPERIMENTAL)\nNULL            10 a null RR (EXPERIMENTAL)\nWKS             11
    a well known service description\nPTR             12 a domain name pointer\nHINFO
    \          13 host information\nMINFO           14 mailbox or mail list information\nMX
    \             15 mail exchange\nTXT             16 text strings\n3.2.3. QTYPE
    values\nQTYPE fields appear in the question part of a query.  QTYPES are a\nsuperset
    of TYPEs, hence all TYPEs are valid QTYPEs.  In addition, the\nfollowing QTYPEs
    are defined:\nAXFR            252 A request for a transfer of an entire zone\nMAILB
    \          253 A request for mailbox-related records (MB, MG or MR)\nMAILA           254
    A request for mail agent RRs (Obsolete - see MX)\n*               255 A request
    for all records\n3.2.4. CLASS values\nCLASS fields appear in resource records.
    \ The following CLASS mnemonics\nand values are defined:\nIN              1 the
    Internet\nCS              2 the CSNET class (Obsolete - used only for examples
    in\n                some obsolete RFCs)\nCH              3 the CHAOS class\nHS
    \             4 Hesiod [Dyer 87]\n3.2.5. QCLASS values\nQCLASS fields appear in
    the question section of a query.  QCLASS values\nare a superset of CLASS values;
    every CLASS is a valid QCLASS.  In\naddition to CLASS values, the following QCLASSes
    are defined:\n*               255 any class\n3.3. Standard RRs\nThe following
    RR definitions are expected to occur, at least\npotentially, in all classes.  In
    particular, NS, SOA, CNAME, and PTR\nwill be used in all classes, and have the
    same format in all classes.\nBecause their RDATA format is known, all domain names
    in the RDATA\nsection of these RRs may be compressed.\n<domain-name> is a domain
    name represented as a series of labels, and\nterminated by a label with zero length.
    \ <character-string> is a single\nlength octet followed by that number of characters.
    \ <character-string>\nis treated as binary information, and can be up to 256 characters
    in\nlength (including the length octet).\n3.3.1. CNAME RDATA format\n    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n
    \   /                     CNAME                     /\n    /                                               /\n
    \   +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\nwhere:\nCNAME           A
    <domain-name> which specifies the canonical or primary\n                name for
    the owner.  The owner name is an alias.\nCNAME RRs cause no additional section
    processing, but name servers may\nchoose to restart the query at the canonical
    name in certain cases.  See\nthe description of name server logic in [RFC-1034]
    for details.\n3.3.2. HINFO RDATA format\n    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n
    \   /                      CPU                      /\n    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n
    \   /                       OS                      /\n    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\nwhere:\nCPU
    \            A <character-string> which specifies the CPU type.\nOS              A
    <character-string> which specifies the operating\n                system type.\nStandard
    values for CPU and OS can be found in [RFC-1010].\nHINFO records are used to acquire
    general information about a host.  The\nmain use is for protocols such as FTP
    that can use special procedures\nwhen talking between machines or operating systems
    of the same type.\n3.3.3. MB RDATA format (EXPERIMENTAL)\n    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n
    \   /                   MADNAME                     /\n    /                                               /\n
    \   +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\nwhere:\nMADNAME         A
    <domain-name> which specifies a host which has the\n                specified
    mailbox.\nMB records cause additional section processing which looks up an A type\nRRs
    corresponding to MADNAME.\n3.3.4. MD RDATA format (Obsolete)\n    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n
    \   /                   MADNAME                     /\n    /                                               /\n
    \   +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\nwhere:\nMADNAME         A
    <domain-name> which specifies a host which has a mail\n                agent for
    the domain which should be able to deliver\n                mail for the domain.\nMD
    records cause additional section processing which looks up an A type\nrecord corresponding
    to MADNAME.\nMD is obsolete.  See the definition of MX and [RFC-974] for details
    of\nthe new scheme.  The recommended policy for dealing with MD RRs found in\na
    master file is to reject them, or to convert them to MX RRs with a\npreference
    of 0.\n3.3.5. MF RDATA format (Obsolete)\n    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n
    \   /                   MADNAME                     /\n    /                                               /\n
    \   +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\nwhere:\nMADNAME         A
    <domain-name> which specifies a host which has a mail\n                agent for
    the domain which will accept mail for\n                forwarding to the domain.\nMF
    records cause additional section processing which looks up an A type\nrecord corresponding
    to MADNAME.\nMF is obsolete.  See the definition of MX and [RFC-974] for details
    ofw\nthe new scheme.  The recommended policy for dealing with MD RRs found in\na
    master file is to reject them, or to convert them to MX RRs with a\npreference
    of 10.\n3.3.6. MG RDATA format (EXPERIMENTAL)\n    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n
    \   /                   MGMNAME                     /\n    /                                               /\n
    \   +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\nwhere:\nMGMNAME         A
    <domain-name> which specifies a mailbox which is a\n                member of
    the mail group specified by the domain name.\nMG records cause no additional section
    processing.\n3.3.7. MINFO RDATA format (EXPERIMENTAL)\n    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n
    \   /                    RMAILBX                    /\n    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n
    \   /                    EMAILBX                    /\n    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\nwhere:\nRMAILBX
    \        A <domain-name> which specifies a mailbox which is\n                responsible
    for the mailing list or mailbox.  If this\n                domain name names the
    root, the owner of the MINFO RR is\n                responsible for itself.  Note
    that many existing mailing\n                lists use a mailbox X-request for
    the RMAILBX field of\n                mailing list X, e.g., Msgroup-request for
    Msgroup.  This\n                field provides a more general mechanism.\nEMAILBX
    \        A <domain-name> which specifies a mailbox which is to\n                receive
    error messages related to the mailing list or\n                mailbox specified
    by the owner of the MINFO RR (similar\n                to the ERRORS-TO: field
    which has been proposed).  If\n                this domain name names the root,
    errors should be\n                returned to the sender of the message.\nMINFO
    records cause no additional section processing.  Although these\nrecords can be
    associated with a simple mailbox, they are usually used\nwith a mailing list.\n3.3.8.
    MR RDATA format (EXPERIMENTAL)\n    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n
    \   /                   NEWNAME                     /\n    /                                               /\n
    \   +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\nwhere:\nNEWNAME         A
    <domain-name> which specifies a mailbox which is the\n                proper rename
    of the specified mailbox.\nMR records cause no additional section processing.
    \ The main use for MR\nis as a forwarding entry for a user who has moved to a
    different\nmailbox.\n3.3.9. MX RDATA format\n    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n
    \   |                  PREFERENCE                   |\n    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n
    \   /                   EXCHANGE                    /\n    /                                               /\n
    \   +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\nwhere:\nPREFERENCE      A
    16 bit integer which specifies the preference given to\n                this RR
    among others at the same owner.  Lower values\n                are preferred.\nEXCHANGE
    \       A <domain-name> which specifies a host willing to act as\n                a
    mail exchange for the owner name.\nMX records cause type A additional section
    processing for the host\nspecified by EXCHANGE.  The use of MX RRs is explained
    in detail in\n[RFC-974].\n3.3.10. NULL RDATA format (EXPERIMENTAL)\n    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n
    \   /                  <anything>                   /\n    /                                               /\n
    \   +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\nAnything at all may be
    in the RDATA field so long as it is 65535 octets\nor less.\nNULL records cause
    no additional section processing.  NULL RRs are not\nallowed in master files.
    \ NULLs are used as placeholders in some\nexperimental extensions of the DNS.\n3.3.11.
    NS RDATA format\n    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n    /
    \                  NSDNAME                     /\n    /                                               /\n
    \   +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\nwhere:\nNSDNAME         A
    <domain-name> which specifies a host which should be\n                authoritative
    for the specified class and domain.\nNS records cause both the usual additional
    section processing to locate\na type A record, and, when used in a referral, a
    special search of the\nzone in which they reside for glue information.\nThe NS
    RR states that the named host should be expected to have a zone\nstarting at owner
    name of the specified class.  Note that the class may\nnot indicate the protocol
    family which should be used to communicate\nwith the host, although it is typically
    a strong hint.  For example,\nhosts which are name servers for either Internet
    (IN) or Hesiod (HS)\nclass information are normally queried using IN class protocols.\n3.3.12.
    PTR RDATA format\n    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n    /
    \                  PTRDNAME                    /\n    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\nwhere:\nPTRDNAME
    \       A <domain-name> which points to some location in the\n                domain
    name space.\nPTR records cause no additional section processing.  These RRs are
    used\nin special domains to point to some other location in the domain space.\nThese
    records are simple data, and don't imply any special processing\nsimilar to that
    performed by CNAME, which identifies aliases.  See the\ndescription of the IN-ADDR.ARPA
    domain for an example.\n3.3.13. SOA RDATA format\n    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n
    \   /                     MNAME                     /\n    /                                               /\n
    \   +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n    /                     RNAME
    \                    /\n    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n
    \   |                    SERIAL                     |\n    |                                               |\n
    \   +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n    |                    REFRESH
    \                   |\n    |                                               |\n
    \   +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n    |                     RETRY
    \                    |\n    |                                               |\n
    \   +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n    |                    EXPIRE
    \                    |\n    |                                               |\n
    \   +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n    |                    MINIMUM
    \                   |\n    |                                               |\n
    \   +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\nwhere:\nMNAME           The
    <domain-name> of the name server that was the\n                original or primary
    source of data for this zone.\nRNAME           A <domain-name> which specifies
    the mailbox of the\n                person responsible for this zone.\nSERIAL
    \         The unsigned 32 bit version number of the original copy\n                of
    the zone.  Zone transfers preserve this value.  This\n                value wraps
    and should be compared using sequence space\n                arithmetic.\nREFRESH
    \        A 32 bit time interval before the zone should be\n                refreshed.\nRETRY
    \          A 32 bit time interval that should elapse before a\n                failed
    refresh should be retried.\nEXPIRE          A 32 bit time value that specifies
    the upper limit on\n                the time interval that can elapse before the
    zone is no\n                longer authoritative.\nMINIMUM         The unsigned
    32 bit minimum TTL field that should be\n                exported with any RR
    from this zone.\nSOA records cause no additional section processing.\nAll times
    are in units of seconds.\nMost of these fields are pertinent only for name server
    maintenance\noperations.  However, MINIMUM is used in all query operations that\nretrieve
    RRs from a zone.  Whenever a RR is sent in a response to a\nquery, the TTL field
    is set to the maximum of the TTL field from the RR\nand the MINIMUM field in the
    appropriate SOA.  Thus MINIMUM is a lower\nbound on the TTL field for all RRs
    in a zone.  Note that this use of\nMINIMUM should occur when the RRs are copied
    into the response and not\nwhen the zone is loaded from a master file or via a
    zone transfer.  The\nreason for this provison is to allow future dynamic update
    facilities to\nchange the SOA RR with known semantics.\n3.3.14. TXT RDATA format\n
    \   +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n    /                   TXT-DATA
    \                   /\n    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\nwhere:\nTXT-DATA
    \       One or more <character-string>s.\nTXT RRs are used to hold descriptive
    text.  The semantics of the text\ndepends on the domain where it is found.\n3.4.
    Internet specific RRs\n3.4.1. A RDATA format\n    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n
    \   |                    ADDRESS                    |\n    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\nwhere:\nADDRESS
    \        A 32 bit Internet address.\nHosts that have multiple Internet addresses
    will have multiple A\nrecords.\nA records cause no additional section processing.
    \ The RDATA section of\nan A line in a master file is an Internet address expressed
    as four\ndecimal numbers separated by dots without any imbedded spaces (e.g.,\n\"10.2.0.52\"
    or \"192.0.5.6\").\n3.4.2. WKS RDATA format\n    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n
    \   |                    ADDRESS                    |\n    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n
    \   |       PROTOCOL        |                       |\n    +--+--+--+--+--+--+--+--+
    \                      |\n    |                                               |\n
    \   /                   <BIT MAP>                   /\n    /                                               /\n
    \   +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\nwhere:\nADDRESS         An
    32 bit Internet address\nPROTOCOL        An 8 bit IP protocol number\n<BIT MAP>
    \      A variable length bit map.  The bit map must be a\n                multiple
    of 8 bits long.\nThe WKS record is used to describe the well known services supported
    by\na particular protocol on a particular internet address.  The PROTOCOL\nfield
    specifies an IP protocol number, and the bit map has one bit per\nport of the
    specified protocol.  The first bit corresponds to port 0,\nthe second to port
    1, etc.  If the bit map does not include a bit for a\nprotocol of interest, that
    bit is assumed zero.  The appropriate values\nand mnemonics for ports and protocols
    are specified in [RFC-1010].\nFor example, if PROTOCOL=TCP (6), the 26th bit corresponds
    to TCP port\n25 (SMTP).  If this bit is set, a SMTP server should be listening
    on TCP\nport 25; if zero, SMTP service is not supported on the specified\naddress.\nThe
    purpose of WKS RRs is to provide availability information for\nservers for TCP
    and UDP.  If a server supports both TCP and UDP, or has\nmultiple Internet addresses,
    then multiple WKS RRs are used.\nWKS RRs cause no additional section processing.\nIn
    master files, both ports and protocols are expressed using mnemonics\nor decimal
    numbers.\n3.5. IN-ADDR.ARPA domain\nThe Internet uses a special domain to support
    gateway location and\nInternet address to host mapping.  Other classes may employ
    a similar\nstrategy in other domains.  The intent of this domain is to provide
    a\nguaranteed method to perform host address to host name mapping, and to\nfacilitate
    queries to locate all gateways on a particular network in the\nInternet.\nNote
    that both of these services are similar to functions that could be\nperformed
    by inverse queries; the difference is that this part of the\ndomain name space
    is structured according to address, and hence can\nguarantee that the appropriate
    data can be located without an exhaustive\nsearch of the domain space.\nThe domain
    begins at IN-ADDR.ARPA and has a substructure which follows\nthe Internet addressing
    structure.\nDomain names in the IN-ADDR.ARPA domain are defined to have up to
    four\nlabels in addition to the IN-ADDR.ARPA suffix.  Each label represents\none
    octet of an Internet address, and is expressed as a character string\nfor a decimal
    value in the range 0-255 (with leading zeros omitted\nexcept in the case of a
    zero octet which is represented by a single\nzero).\nHost addresses are represented
    by domain names that have all four labels\nspecified.  Thus data for Internet
    address 10.2.0.52 is located at\ndomain name 52.0.2.10.IN-ADDR.ARPA.  The reversal,
    though awkward to\nread, allows zones to be delegated which are exactly one network
    of\naddress space.  For example, 10.IN-ADDR.ARPA can be a zone containing\ndata
    for the ARPANET, while 26.IN-ADDR.ARPA can be a separate zone for\nMILNET.  Address
    nodes are used to hold pointers to primary host names\nin the normal domain space.\nNetwork
    numbers correspond to some non-terminal nodes at various depths\nin the IN-ADDR.ARPA
    domain, since Internet network numbers are either 1,\n2, or 3 octets.  Network
    nodes are used to hold pointers to the primary\nhost names of gateways attached
    to that network.  Since a gateway is, by\ndefinition, on more than one network,
    it will typically have two or more\nnetwork nodes which point at it.  Gateways
    will also have host level\npointers at their fully qualified addresses.\nBoth
    the gateway pointers at network nodes and the normal host pointers\nat full address
    nodes use the PTR RR to point back to the primary domain\nnames of the corresponding
    hosts.\nFor example, the IN-ADDR.ARPA domain will contain information about the\nISI
    gateway between net 10 and 26, an MIT gateway from net 10 to MIT's\nnet 18, and
    hosts A.ISI.EDU and MULTICS.MIT.EDU.  Assuming that ISI\ngateway has addresses
    10.2.0.22 and 26.0.0.103, and a name MILNET-\nGW.ISI.EDU, and the MIT gateway
    has addresses 10.0.0.77 and 18.10.0.4\nand a name GW.LCS.MIT.EDU, the domain database
    would contain:\n    10.IN-ADDR.ARPA.           PTR MILNET-GW.ISI.EDU.\n    10.IN-ADDR.ARPA.
    \          PTR GW.LCS.MIT.EDU.\n    18.IN-ADDR.ARPA.           PTR GW.LCS.MIT.EDU.\n
    \   26.IN-ADDR.ARPA.           PTR MILNET-GW.ISI.EDU.\n    22.0.2.10.IN-ADDR.ARPA.
    \   PTR MILNET-GW.ISI.EDU.\n    103.0.0.26.IN-ADDR.ARPA.   PTR MILNET-GW.ISI.EDU.\n
    \   77.0.0.10.IN-ADDR.ARPA.    PTR GW.LCS.MIT.EDU.\n    4.0.10.18.IN-ADDR.ARPA.
    \   PTR GW.LCS.MIT.EDU.\n    103.0.3.26.IN-ADDR.ARPA.   PTR A.ISI.EDU.\n    6.0.0.10.IN-ADDR.ARPA.
    \    PTR MULTICS.MIT.EDU.\nThus a program which wanted to locate gateways on net
    10 would originate\na query of the form QTYPE=PTR, QCLASS=IN, QNAME=10.IN-ADDR.ARPA.
    \ It\nwould receive two RRs in response:\n    10.IN-ADDR.ARPA.           PTR MILNET-GW.ISI.EDU.\n
    \   10.IN-ADDR.ARPA.           PTR GW.LCS.MIT.EDU.\nThe program could then originate
    QTYPE=A, QCLASS=IN queries for MILNET-\nGW.ISI.EDU. and GW.LCS.MIT.EDU. to discover
    the Internet addresses of\nthese gateways.\nA resolver which wanted to find the
    host name corresponding to Internet\nhost address 10.0.0.6 would pursue a query
    of the form QTYPE=PTR,\nQCLASS=IN, QNAME=6.0.0.10.IN-ADDR.ARPA, and would receive:\n
    \   6.0.0.10.IN-ADDR.ARPA.     PTR MULTICS.MIT.EDU.\nSeveral cautions apply to
    the use of these services:\n   - Since the IN-ADDR.ARPA special domain and the
    normal domain\n     for a particular host or gateway will be in different zones,\n
    \    the possibility exists that that the data may be inconsistent.\n   - Gateways
    will often have two names in separate domains, only\n     one of which can be
    primary.\n   - Systems that use the domain database to initialize their\n     routing
    tables must start with enough gateway information to\n     guarantee that they
    can access the appropriate name server.\n   - The gateway data only reflects the
    existence of a gateway in a\n     manner equivalent to the current HOSTS.TXT file.
    \ It doesn't\n     replace the dynamic availability information from GGP or EGP.\n3.6.
    Defining new types, classes, and special namespaces\nThe previously defined types
    and classes are the ones in use as of the\ndate of this memo.  New definitions
    should be expected.  This section\nmakes some recommendations to designers considering
    additions to the\nexisting facilities.  The mailing list NAMEDROPPERS@SRI-NIC.ARPA
    is the\nforum where general discussion of design issues takes place.\nIn general,
    a new type is appropriate when new information is to be\nadded to the database
    about an existing object, or we need new data\nformats for some totally new object.
    \ Designers should attempt to define\ntypes and their RDATA formats that are generally
    applicable to all\nclasses, and which avoid duplication of information.  New classes
    are\nappropriate when the DNS is to be used for a new protocol, etc which\nrequires
    new class-specific data formats, or when a copy of the existing\nname space is
    desired, but a separate management domain is necessary.\nNew types and classes
    need mnemonics for master files; the format of the\nmaster files requires that
    the mnemonics for type and class be disjoint.\nTYPE and CLASS values must be a
    proper subset of QTYPEs and QCLASSes\nrespectively.\nThe present system uses multiple
    RRs to represent multiple values of a\ntype rather than storing multiple values
    in the RDATA section of a\nsingle RR.  This is less efficient for most applications,
    but does keep\nRRs shorter.  The multiple RRs assumption is incorporated in some\nexperimental
    work on dynamic update methods.\nThe present system attempts to minimize the duplication
    of data in the\ndatabase in order to insure consistency.  Thus, in order to find
    the\naddress of the host for a mail exchange, you map the mail domain name to\na
    host name, then the host name to addresses, rather than a direct\nmapping to host
    address.  This approach is preferred because it avoids\nthe opportunity for inconsistency.\nIn
    defining a new type of data, multiple RR types should not be used to\ncreate an
    ordering between entries or express different formats for\nequivalent bindings,
    instead this information should be carried in the\nbody of the RR and a single
    type used.  This policy avoids problems with\ncaching multiple types and defining
    QTYPEs to match multiple types.\nFor example, the original form of mail exchange
    binding used two RR\ntypes one to represent a \"closer\" exchange (MD) and one
    to represent a\n\"less close\" exchange (MF).  The difficulty is that the presence
    of one\nRR type in a cache doesn't convey any information about the other\nbecause
    the query which acquired the cached information might have used\na QTYPE of MF,
    MD, or MAILA (which matched both).  The redesigned\nservice used a single type
    (MX) with a \"preference\" value in the RDATA\nsection which can order different
    RRs.  However, if any MX RRs are found\nin the cache, then all should be there.\n4.
    MESSAGES\n4.1. Format\nAll communications inside of the domain protocol are carried
    in a single\nformat called a message.  The top level format of message is divided\ninto
    5 sections (some of which are empty in certain cases) shown below:\n    +---------------------+\n
    \   |        Header       |\n    +---------------------+\n    |       Question
    \     | the question for the name server\n    +---------------------+\n    |        Answer
    \      | RRs answering the question\n    +---------------------+\n    |      Authority
    \     | RRs pointing toward an authority\n    +---------------------+\n    |      Additional
    \    | RRs holding additional information\n    +---------------------+\nThe header
    section is always present.  The header includes fields that\nspecify which of
    the remaining sections are present, and also specify\nwhether the message is a
    query or a response, a standard query or some\nother opcode, etc.\nThe names of
    the sections after the header are derived from their use in\nstandard queries.
    \ The question section contains fields that describe a\nquestion to a name server.
    \ These fields are a query type (QTYPE), a\nquery class (QCLASS), and a query
    domain name (QNAME).  The last three\nsections have the same format: a possibly
    empty list of concatenated\nresource records (RRs).  The answer section contains
    RRs that answer the\nquestion; the authority section contains RRs that point toward
    an\nauthoritative name server; the additional records section contains RRs\nwhich
    relate to the query, but are not strictly answers for the\nquestion.\n4.1.1. Header
    section format\nThe header contains the following fields:\n                                    1
    \ 1  1  1  1  1\n      0  1  2  3  4  5  6  7  8  9  0  1  2  3  4  5\n    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n
    \   |                      ID                       |\n    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n
    \   |QR|   Opcode  |AA|TC|RD|RA|   Z    |   RCODE   |\n    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n
    \   |                    QDCOUNT                    |\n    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n
    \   |                    ANCOUNT                    |\n    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n
    \   |                    NSCOUNT                    |\n    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n
    \   |                    ARCOUNT                    |\n    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\nwhere:\nID
    \             A 16 bit identifier assigned by the program that\n                generates
    any kind of query.  This identifier is copied\n                the corresponding
    reply and can be used by the requester\n                to match up replies to
    outstanding queries.\nQR              A one bit field that specifies whether this
    message is a\n                query (0), or a response (1).\nOPCODE          A
    four bit field that specifies kind of query in this\n                message.
    \ This value is set by the originator of a query\n                and copied into
    the response.  The values are:\n                0               a standard query
    (QUERY)\n                1               an inverse query (IQUERY)\n                2
    \              a server status request (STATUS)\n                3-15            reserved
    for future use\nAA              Authoritative Answer - this bit is valid in responses,\n
    \               and specifies that the responding name server is an\n                authority
    for the domain name in question section.\n                Note that the contents
    of the answer section may have\n                multiple owner names because of
    aliases.  The AA bit\n                corresponds to the name which matches the
    query name, or\n                the first owner name in the answer section.\nTC
    \             TrunCation - specifies that this message was truncated\n                due
    to length greater than that permitted on the\n                transmission channel.\nRD
    \             Recursion Desired - this bit may be set in a query and\n                is
    copied into the response.  If RD is set, it directs\n                the name
    server to pursue the query recursively.\n                Recursive query support
    is optional.\nRA              Recursion Available - this be is set or cleared
    in a\n                response, and denotes whether recursive query support is\n
    \               available in the name server.\nZ               Reserved for future
    use.  Must be zero in all queries\n                and responses.\nRCODE           Response
    code - this 4 bit field is set as part of\n                responses.  The values
    have the following\n                interpretation:\n                0               No
    error condition\n                1               Format error - The name server
    was\n                                unable to interpret the query.\n                2
    \              Server failure - The name server was\n                                unable
    to process this query due to a\n                                problem with the
    name server.\n                3               Name Error - Meaningful only for\n
    \                               responses from an authoritative name\n                                server,
    this code signifies that the\n                                domain name referenced
    in the query does\n                                not exist.\n                4
    \              Not Implemented - The name server does\n                                not
    support the requested kind of query.\n                5               Refused
    - The name server refuses to\n                                perform the specified
    operation for\n                                policy reasons.  For example, a
    name\n                                server may not wish to provide the\n                                information
    to the particular requester,\n                                or a name server
    may not wish to perform\n                                a particular operation
    (e.g., zone\n                                transfer) for particular data.\n
    \               6-15            Reserved for future use.\nQDCOUNT         an unsigned
    16 bit integer specifying the number of\n                entries in the question
    section.\nANCOUNT         an unsigned 16 bit integer specifying the number of\n
    \               resource records in the answer section.\nNSCOUNT         an unsigned
    16 bit integer specifying the number of name\n                server resource
    records in the authority records\n                section.\nARCOUNT         an
    unsigned 16 bit integer specifying the number of\n                resource records
    in the additional records section.\n4.1.2. Question section format\nThe question
    section is used to carry the \"question\" in most queries,\ni.e., the parameters
    that define what is being asked.  The section\ncontains QDCOUNT (usually 1) entries,
    each of the following format:\n                                    1  1  1  1
    \ 1  1\n      0  1  2  3  4  5  6  7  8  9  0  1  2  3  4  5\n    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n
    \   |                                               |\n    /                     QNAME
    \                    /\n    /                                               /\n
    \   +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n    |                     QTYPE
    \                    |\n    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n
    \   |                     QCLASS                    |\n    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\nwhere:\nQNAME
    \          a domain name represented as a sequence of labels, where\n                each
    label consists of a length octet followed by that\n                number of octets.
    \ The domain name terminates with the\n                zero length octet for the
    null label of the root.  Note\n                that this field may be an odd number
    of octets; no\n                padding is used.\nQTYPE           a two octet code
    which specifies the type of the query.\n                The values for this field
    include all codes valid for a\n                TYPE field, together with some
    more general codes which\n                can match more than one type of RR.\nQCLASS
    \         a two octet code that specifies the class of the query.\n                For
    example, the QCLASS field is IN for the Internet.\n4.1.3. Resource record format\nThe
    answer, authority, and additional sections all share the same\nformat: a variable
    number of resource records, where the number of\nrecords is specified in the corresponding
    count field in the header.\nEach resource record has the following format:\n                                    1
    \ 1  1  1  1  1\n      0  1  2  3  4  5  6  7  8  9  0  1  2  3  4  5\n    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n
    \   |                                               |\n    /                                               /\n
    \   /                      NAME                     /\n    |                                               |\n
    \   +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n    |                      TYPE
    \                    |\n    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n
    \   |                     CLASS                     |\n    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n
    \   |                      TTL                      |\n    |                                               |\n
    \   +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n    |                   RDLENGTH
    \                   |\n    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--|\n
    \   /                     RDATA                     /\n    /                                               /\n
    \   +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\nwhere:\nNAME            a
    domain name to which this resource record pertains.\nTYPE            two octets
    containing one of the RR type codes.  This\n                field specifies the
    meaning of the data in the RDATA\n                field.\nCLASS           two
    octets which specify the class of the data in the\n                RDATA field.\nTTL
    \            a 32 bit unsigned integer that specifies the time\n                interval
    (in seconds) that the resource record may be\n                cached before it
    should be discarded.  Zero values are\n                interpreted to mean that
    the RR can only be used for the\n                transaction in progress, and
    should not be cached.\nRDLENGTH        an unsigned 16 bit integer that specifies
    the length in\n                octets of the RDATA field.\nRDATA           a variable
    length string of octets that describes the\n                resource.  The format
    of this information varies\n                according to the TYPE and CLASS of
    the resource record.\n                For example, the if the TYPE is A and the
    CLASS is IN,\n                the RDATA field is a 4 octet ARPA Internet address.\n4.1.4.
    Message compression\nIn order to reduce the size of messages, the domain system
    utilizes a\ncompression scheme which eliminates the repetition of domain names
    in a\nmessage.  In this scheme, an entire domain name or a list of labels at\nthe
    end of a domain name is replaced with a pointer to a prior occurance\nof the same
    name.\nThe pointer takes the form of a two octet sequence:\n    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n
    \   | 1  1|                OFFSET                   |\n    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\nThe
    first two bits are ones.  This allows a pointer to be distinguished\nfrom a label,
    since the label must begin with two zero bits because\nlabels are restricted to
    63 octets or less.  (The 10 and 01 combinations\nare reserved for future use.)
    \ The OFFSET field specifies an offset from\nthe start of the message (i.e., the
    first octet of the ID field in the\ndomain header).  A zero offset specifies the
    first byte of the ID field,\netc.\nThe compression scheme allows a domain name
    in a message to be\nrepresented as either:\n   - a sequence of labels ending in
    a zero octet\n   - a pointer\n   - a sequence of labels ending with a pointer\nPointers
    can only be used for occurances of a domain name where the\nformat is not class
    specific.  If this were not the case, a name server\nor resolver would be required
    to know the format of all RRs it handled.\nAs yet, there are no such cases, but
    they may occur in future RDATA\nformats.\nIf a domain name is contained in a part
    of the message subject to a\nlength field (such as the RDATA section of an RR),
    and compression is\nused, the length of the compressed name is used in the length\ncalculation,
    rather than the length of the expanded name.\nPrograms are free to avoid using
    pointers in messages they generate,\nalthough this will reduce datagram capacity,
    and may cause truncation.\nHowever all programs are required to understand arriving
    messages that\ncontain pointers.\nFor example, a datagram might need to use the
    domain names F.ISI.ARPA,\nFOO.F.ISI.ARPA, ARPA, and the root.  Ignoring the other
    fields of the\nmessage, these domain names might be represented as:\n       +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n
    \   20 |           1           |           F           |\n       +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n
    \   22 |           3           |           I           |\n       +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n
    \   24 |           S           |           I           |\n       +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n
    \   26 |           4           |           A           |\n       +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n
    \   28 |           R           |           P           |\n       +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n
    \   30 |           A           |           0           |\n       +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n
    \      +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n    40 |           3
    \          |           F           |\n       +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n
    \   42 |           O           |           O           |\n       +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n
    \   44 | 1  1|                20                       |\n       +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n
    \      +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n    64 | 1  1|                26
    \                      |\n       +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n
    \      +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n    92 |           0
    \          |                       |\n       +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\nThe
    domain name for F.ISI.ARPA is shown at offset 20.  The domain name\nFOO.F.ISI.ARPA
    is shown at offset 40; this definition uses a pointer to\nconcatenate a label
    for FOO to the previously defined F.ISI.ARPA.  The\ndomain name ARPA is defined
    at offset 64 using a pointer to the ARPA\ncomponent of the name F.ISI.ARPA at
    20; note that this pointer relies on\nARPA being the last label in the string
    at 20.  The root domain name is\ndefined by a single octet of zeros at 92; the
    root domain name has no\nlabels.\n4.2. Transport\nThe DNS assumes that messages
    will be transmitted as datagrams or in a\nbyte stream carried by a virtual circuit.
    \ While virtual circuits can be\nused for any DNS activity, datagrams are preferred
    for queries due to\ntheir lower overhead and better performance.  Zone refresh
    activities\nmust use virtual circuits because of the need for reliable transfer.\nThe
    Internet supports name server access using TCP [RFC-793] on server\nport 53 (decimal)
    as well as datagram access using UDP [RFC-768] on UDP\nport 53 (decimal).\n4.2.1.
    UDP usage\nMessages sent using UDP user server port 53 (decimal).\nMessages carried
    by UDP are restricted to 512 bytes (not counting the IP\nor UDP headers).  Longer
    messages are truncated and the TC bit is set in\nthe header.\nUDP is not acceptable
    for zone transfers, but is the recommended method\nfor standard queries in the
    Internet.  Queries sent using UDP may be\nlost, and hence a retransmission strategy
    is required.  Queries or their\nresponses may be reordered by the network, or
    by processing in name\nservers, so resolvers should not depend on them being returned
    in order.\nThe optimal UDP retransmission policy will vary with performance of
    the\nInternet and the needs of the client, but the following are recommended:\n
    \  - The client should try other servers and server addresses\n     before repeating
    a query to a specific address of a server.\n   - The retransmission interval should
    be based on prior\n     statistics if possible.  Too aggressive retransmission
    can\n     easily slow responses for the community at large.  Depending\n     on
    how well connected the client is to its expected servers,\n     the minimum retransmission
    interval should be 2-5 seconds.\nMore suggestions on server selection and retransmission
    policy can be\nfound in the resolver section of this memo.\n4.2.2. TCP usage\nMessages
    sent over TCP connections use server port 53 (decimal).  The\nmessage is prefixed
    with a two byte length field which gives the message\nlength, excluding the two
    byte length field.  This length field allows\nthe low-level processing to assemble
    a complete message before beginning\nto parse it.\nSeveral connection management
    policies are recommended:\n   - The server should not block other activities waiting
    for TCP\n     data.\n   - The server should support multiple connections.\n   -
    The server should assume that the client will initiate\n     connection closing,
    and should delay closing its end of the\n     connection until all outstanding
    client requests have been\n     satisfied.\n   - If the server needs to close
    a dormant connection to reclaim\n     resources, it should wait until the connection
    has been idle\n     for a period on the order of two minutes.  In particular,
    the\n     server should allow the SOA and AXFR request sequence (which\n     begins
    a refresh operation) to be made on a single connection.\n     Since the server
    would be unable to answer queries anyway, a\n     unilateral close or reset may
    be used instead of a graceful\n     close.\n5. MASTER FILES\nMaster files are
    text files that contain RRs in text form.  Since the\ncontents of a zone can be
    expressed in the form of a list of RRs a\nmaster file is most often used to define
    a zone, though it can be used\nto list a cache's contents.  Hence, this section
    first discusses the\nformat of RRs in a master file, and then the special considerations
    when\na master file is used to create a zone in some name server.\n5.1. Format\nThe
    format of these files is a sequence of entries.  Entries are\npredominantly line-oriented,
    though parentheses can be used to continue\na list of items across a line boundary,
    and text literals can contain\nCRLF within the text.  Any combination of tabs
    and spaces act as a\ndelimiter between the separate items that make up an entry.
    \ The end of\nany line in the master file can end with a comment.  The comment
    starts\nwith a \";\" (semicolon).\nThe following entries are defined:\n    <blank>[<comment>]\n
    \   $ORIGIN <domain-name> [<comment>]\n    $INCLUDE <file-name> [<domain-name>]
    [<comment>]\n    <domain-name><rr> [<comment>]\n    <blank><rr> [<comment>]\nBlank
    lines, with or without comments, are allowed anywhere in the file.\nTwo control
    entries are defined: $ORIGIN and $INCLUDE.  $ORIGIN is\nfollowed by a domain name,
    and resets the current origin for relative\ndomain names to the stated name.  $INCLUDE
    inserts the named file into\nthe current file, and may optionally specify a domain
    name that sets the\nrelative domain name origin for the included file.  $INCLUDE
    may also\nhave a comment.  Note that a $INCLUDE entry never changes the relative\norigin
    of the parent file, regardless of changes to the relative origin\nmade within
    the included file.\nThe last two forms represent RRs.  If an entry for an RR begins
    with a\nblank, then the RR is assumed to be owned by the last stated owner.  If\nan
    RR entry begins with a <domain-name>, then the owner name is reset.\n<rr> contents
    take one of the following forms:\n    [<TTL>] [<class>] <type> <RDATA>\n    [<class>]
    [<TTL>] <type> <RDATA>\nThe RR begins with optional TTL and class fields, followed
    by a type and\nRDATA field appropriate to the type and class.  Class and type
    use the\nstandard mnemonics, TTL is a decimal integer.  Omitted class and TTL\nvalues
    are default to the last explicitly stated values.  Since type and\nclass mnemonics
    are disjoint, the parse is unique.  (Note that this\norder is different from the
    order used in examples and the order used in\nthe actual RRs; the given order
    allows easier parsing and defaulting.)\n<domain-name>s make up a large share of
    the data in the master file.\nThe labels in the domain name are expressed as character
    strings and\nseparated by dots.  Quoting conventions allow arbitrary characters
    to be\nstored in domain names.  Domain names that end in a dot are called\nabsolute,
    and are taken as complete.  Domain names which do not end in a\ndot are called
    relative; the actual domain name is the concatenation of\nthe relative part with
    an origin specified in a $ORIGIN, $INCLUDE, or as\nan argument to the master file
    loading routine.  A relative name is an\nerror when no origin is available.\n<character-string>
    is expressed in one or two ways: as a contiguous set\nof characters without interior
    spaces, or as a string beginning with a \"\nand ending with a \".  Inside a \"
    delimited string any character can\noccur, except for a \" itself, which must
    be quoted using \\ (back slash).\nBecause these files are text files several special
    encodings are\nnecessary to allow arbitrary data to be loaded.  In particular:\n
    \               of the root.\n@               A free standing @ is used to denote
    the current origin.\n\\X              where X is any character other than a digit
    (0-9), is\n                used to quote that character so that its special meaning\n
    \               does not apply.  For example, \"\\.\" can be used to place\n                a
    dot character in a label.\n\\DDD            where each D is a digit is the octet
    corresponding to\n                the decimal number described by DDD.  The resulting\n
    \               octet is assumed to be text and is not checked for\n                special
    meaning.\n( )             Parentheses are used to group data that crosses a line\n
    \               boundary.  In effect, line terminations are not\n                recognized
    within parentheses.\n;               Semicolon is used to start a comment; the
    remainder of\n                the line is ignored.\n5.2. Use of master files to
    define zones\nWhen a master file is used to load a zone, the operation should
    be\nsuppressed if any errors are encountered in the master file.  The\nrationale
    for this is that a single error can have widespread\nconsequences.  For example,
    suppose that the RRs defining a delegation\nhave syntax errors; then the server
    will return authoritative name\nerrors for all names in the subzone (except in
    the case where the\nsubzone is also present on the server).\nSeveral other validity
    checks that should be performed in addition to\ninsuring that the file is syntactically
    correct:\n   1. All RRs in the file should have the same class.\n   2. Exactly
    one SOA RR should be present at the top of the zone.\n   3. If delegations are
    present and glue information is required,\n      it should be present.\n   4.
    Information present outside of the authoritative nodes in the\n      zone should
    be glue information, rather than the result of an\n      origin or similar error.\n5.3.
    Master file example\nThe following is an example file which might be used to define
    the\nISI.EDU zone.and is loaded with an origin of ISI.EDU:\n@   IN  SOA     VENERA
    \     Action\\.domains (\n                                 20     ; SERIAL\n                                 7200
    \  ; REFRESH\n                                 600    ; RETRY\n                                 3600000;
    EXPIRE\n                                 60)    ; MINIMUM\n        NS      A.ISI.EDU.\n
    \       NS      VENERA\n        NS      VAXA\n        MX      10      VENERA\n
    \       MX      20      VAXA\nA       A       26.3.0.103\nVENERA  A       10.1.0.52\n
    \       A       128.9.0.32\nVAXA    A       10.2.0.27\n        A       128.9.0.33\n$INCLUDE
    <SUBSYS>ISI-MAILBOXES.TXT\nWhere the file <SUBSYS>ISI-MAILBOXES.TXT is:\n    MOE
    \    MB      A.ISI.EDU.\n    LARRY   MB      A.ISI.EDU.\n    CURLEY  MB      A.ISI.EDU.\n
    \   STOOGES MG      MOE\n            MG      LARRY\n            MG      CURLEY\nNote
    the use of the \\ character in the SOA RR to specify the responsible\nperson mailbox
    \"Action.domains@E.ISI.EDU\".\n6. NAME SERVER IMPLEMENTATION\n6.1. Architecture\nThe
    optimal structure for the name server will depend on the host\noperating system
    and whether the name server is integrated with resolver\noperations, either by
    supporting recursive service, or by sharing its\ndatabase with a resolver.  This
    section discusses implementation\nconsiderations for a name server which shares
    a database with a\nresolver, but most of these concerns are present in any name
    server.\n6.1.1. Control\nA name server must employ multiple concurrent activities,
    whether they\nare implemented as separate tasks in the host's OS or multiplexing\ninside
    a single name server program.  It is simply not acceptable for a\nname server
    to block the service of UDP requests while it waits for TCP\ndata for refreshing
    or query activities.  Similarly, a name server\nshould not attempt to provide
    recursive service without processing such\nrequests in parallel, though it may
    choose to serialize requests from a\nsingle client, or to regard identical requests
    from the same client as\nduplicates.  A name server should not substantially delay
    requests while\nit reloads a zone from master files or while it incorporates a
    newly\nrefreshed zone into its database.\n6.1.2. Database\nWhile name server implementations
    are free to use any internal data\nstructures they choose, the suggested structure
    consists of three major\nparts:\n   - A \"catalog\" data structure which lists
    the zones available to\n     this server, and a \"pointer\" to the zone data structure.
    \ The\n     main purpose of this structure is to find the nearest ancestor\n     zone,
    if any, for arriving standard queries.\n   - Separate data structures for each
    of the zones held by the\n     name server.\n   - A data structure for cached
    data. (or perhaps separate caches\n     for different classes)\nAll of these data
    structures can be implemented an identical tree\nstructure format, with different
    data chained off the nodes in different\nparts: in the catalog the data is pointers
    to zones, while in the zone\nand cache data structures, the data will be RRs.
    \ In designing the tree\nframework the designer should recognize that query processing
    will need\nto traverse the tree using case-insensitive label comparisons; and
    that\nin real data, a few nodes have a very high branching factor (100-1000 or\nmore),
    but the vast majority have a very low branching factor (0-1).\nOne way to solve
    the case problem is to store the labels for each node\nin two pieces: a standardized-case
    representation of the label where all\nASCII characters are in a single case,
    together with a bit mask that\ndenotes which characters are actually of a different
    case.  The\nbranching factor diversity can be handled using a simple linked list
    for\na node until the branching factor exceeds some threshold, and\ntransitioning
    to a hash structure after the threshold is exceeded.  In\nany case, hash structures
    used to store tree sections must insure that\nhash functions and procedures preserve
    the casing conventions of the\nDNS.\nThe use of separate structures for the different
    parts of the database\nis motivated by several factors:\n   - The catalog structure
    can be an almost static structure that\n     need change only when the system
    administrator changes the\n     zones supported by the server.  This structure
    can also be\n     used to store parameters used to control refreshing\n     activities.\n
    \  - The individual data structures for zones allow a zone to be\n     replaced
    simply by changing a pointer in the catalog.  Zone\n     refresh operations can
    build a new structure and, when\n     complete, splice it into the database via
    a simple pointer\n     replacement.  It is very important that when a zone is\n
    \    refreshed, queries should not use old and new data\n     simultaneously.\n
    \  - With the proper search procedures, authoritative data in zones\n     will
    always \"hide\", and hence take precedence over, cached\n     data.\n   - Errors
    in zone definitions that cause overlapping zones, etc.,\n     may cause erroneous
    responses to queries, but problem\n     determination is simplified, and the contents
    of one \"bad\"\n     zone can't corrupt another.\n   - Since the cache is most
    frequently updated, it is most\n     vulnerable to corruption during system restarts.
    \ It can also\n     become full of expired RR data.  In either case, it can easily\n
    \    be discarded without disturbing zone data.\nA major aspect of database design
    is selecting a structure which allows\nthe name server to deal with crashes of
    the name server's host.  State\ninformation which a name server should save across
    system crashes\nincludes the catalog structure (including the state of refreshing
    for\neach zone) and the zone data itself.\n6.1.3. Time\nBoth the TTL data for
    RRs and the timing data for refreshing activities\ndepends on 32 bit timers in
    units of seconds.  Inside the database,\nrefresh timers and TTLs for cached data
    conceptually \"count down\", while\ndata in the zone stays with constant TTLs.\nA
    recommended implementation strategy is to store time in two ways:  as\na relative
    increment and as an absolute time.  One way to do this is to\nuse positive 32
    bit numbers for one type and negative numbers for the\nother.  The RRs in zones
    use relative times; the refresh timers and\ncache data use absolute times.  Absolute
    numbers are taken with respect\nto some known origin and converted to relative
    values when placed in the\nresponse to a query.  When an absolute TTL is negative
    after conversion\nto relative, then the data is expired and should be ignored.\n6.2.
    Standard query processing\nThe major algorithm for standard query processing is
    presented in\n[RFC-1034].\nWhen processing queries with QCLASS=*, or some other
    QCLASS which\nmatches multiple classes, the response should never be authoritative\nunless
    the server can guarantee that the response covers all classes.\nWhen composing
    a response, RRs which are to be inserted in the\nadditional section, but duplicate
    RRs in the answer or authority\nsections, may be omitted from the additional section.\nWhen
    a response is so long that truncation is required, the truncation\nshould start
    at the end of the response and work forward in the\ndatagram.  Thus if there is
    any data for the authority section, the\nanswer section is guaranteed to be unique.\nThe
    MINIMUM value in the SOA should be used to set a floor on the TTL of\ndata distributed
    from a zone.  This floor function should be done when\nthe data is copied into
    a response.  This will allow future dynamic\nupdate protocols to change the SOA
    MINIMUM field without ambiguous\nsemantics.\n6.3. Zone refresh and reload processing\nIn
    spite of a server's best efforts, it may be unable to load zone data\nfrom a master
    file due to syntax errors, etc., or be unable to refresh a\nzone within the its
    expiration parameter.  In this case, the name server\nshould answer queries as
    if it were not supposed to possess the zone.\nIf a master is sending a zone out
    via AXFR, and a new version is created\nduring the transfer, the master should
    continue to send the old version\nif possible.  In any case, it should never send
    part of one version and\npart of another.  If completion is not possible, the
    master should reset\nthe connection on which the zone transfer is taking place.\n6.4.
    Inverse queries (Optional)\nInverse queries are an optional part of the DNS.  Name
    servers are not\nrequired to support any form of inverse queries.  If a name server\nreceives
    an inverse query that it does not support, it returns an error\nresponse with
    the \"Not Implemented\" error set in the header.  While\ninverse query support
    is optional, all name servers must be at least\nable to return the error response.\n6.4.1.
    The contents of inverse queries and responses          Inverse\nqueries reverse
    the mappings performed by standard query operations;\nwhile a standard query maps
    a domain name to a resource, an inverse\nquery maps a resource to a domain name.
    \ For example, a standard query\nmight bind a domain name to a host address; the
    corresponding inverse\nquery binds the host address to a domain name.\nInverse
    queries take the form of a single RR in the answer section of\nthe message, with
    an empty question section.  The owner name of the\nquery RR and its TTL are not
    significant.  The response carries\nquestions in the question section which identify
    all names possessing\nthe query RR WHICH THE NAME SERVER KNOWS.  Since no name
    server knows\nabout all of the domain name space, the response can never be assumed
    to\nbe complete.  Thus inverse queries are primarily useful for database\nmanagement
    and debugging activities.  Inverse queries are NOT an\nacceptable method of mapping
    host addresses to host names; use the IN-\nADDR.ARPA domain instead.\nWhere possible,
    name servers should provide case-insensitive comparisons\nfor inverse queries.
    \ Thus an inverse query asking for an MX RR of\n\"Venera.isi.edu\" should get
    the same response as a query for\n\"VENERA.ISI.EDU\"; an inverse query for HINFO
    RR \"IBM-PC UNIX\" should\nproduce the same result as an inverse query for \"IBM-pc
    unix\".  However,\nthis cannot be guaranteed because name servers may possess
    RRs that\ncontain character strings but the name server does not know that the\ndata
    is character.\nWhen a name server processes an inverse query, it either returns:\n
    \  1. zero, one, or multiple domain names for the specified\n      resource as
    QNAMEs in the question section\n   2. an error code indicating that the name server
    doesn't support\n      inverse mapping of the specified resource type.\nWhen the
    response to an inverse query contains one or more QNAMEs, the\nowner name and
    TTL of the RR in the answer section which defines the\ninverse query is modified
    to exactly match an RR found at the first\nQNAME.\nRRs returned in the inverse
    queries cannot be cached using the same\nmechanism as is used for the replies
    to standard queries.  One reason\nfor this is that a name might have multiple
    RRs of the same type, and\nonly one would appear.  For example, an inverse query
    for a single\naddress of a multiply homed host might create the impression that
    only\none address existed.\n6.4.2. Inverse query and response example          The
    overall structure\nof an inverse query for retrieving the domain name that corresponds
    to\nInternet address 10.1.0.52 is shown below:\n                         +-----------------------------------------+\n
    \          Header        |          OPCODE=IQUERY, ID=997          |\n                         +-----------------------------------------+\n
    \         Question       |                 <empty>                 |\n                         +-----------------------------------------+\n
    \          Answer        |        <anyname> A IN 10.1.0.52         |\n                         +-----------------------------------------+\n
    \         Authority      |                 <empty>                 |\n                         +-----------------------------------------+\n
    \        Additional      |                 <empty>                 |\n                         +-----------------------------------------+\nThis
    query asks for a question whose answer is the Internet style\naddress 10.1.0.52.
    \ Since the owner name is not known, any domain name\ncan be used as a placeholder
    (and is ignored).  A single octet of zero,\nsignifying the root, is usually used
    because it minimizes the length of\nthe message.  The TTL of the RR is not significant.
    \ The response to\nthis query might be:\n                         +-----------------------------------------+\n
    \          Header        |         OPCODE=RESPONSE, ID=997         |\n                         +-----------------------------------------+\n
    \         Question       |QTYPE=A, QCLASS=IN, QNAME=VENERA.ISI.EDU |\n                         +-----------------------------------------+\n
    \          Answer        |  VENERA.ISI.EDU  A IN 10.1.0.52         |\n                         +-----------------------------------------+\n
    \         Authority      |                 <empty>                 |\n                         +-----------------------------------------+\n
    \        Additional      |                 <empty>                 |\n                         +-----------------------------------------+\nNote
    that the QTYPE in a response to an inverse query is the same as the\nTYPE field
    in the answer section of the inverse query.  Responses to\ninverse queries may
    contain multiple questions when the inverse is not\nunique.  If the question section
    in the response is not empty, then the\nRR in the answer section is modified to
    correspond to be an exact copy\nof an RR at the first QNAME.\n6.4.3. Inverse query
    processing\nName servers that support inverse queries can support these operations\nthrough
    exhaustive searches of their databases, but this becomes\nimpractical as the size
    of the database increases.  An alternative\napproach is to invert the database
    according to the search key.\nFor name servers that support multiple zones and
    a large amount of data,\nthe recommended approach is separate inversions for each
    zone.  When a\nparticular zone is changed during a refresh, only its inversions
    need to\nbe redone.\nSupport for transfer of this type of inversion may be included
    in future\nversions of the domain system, but is not supported in this version.\n6.5.
    Completion queries and responses\nThe optional completion services described in
    RFC-882 and RFC-883 have\nbeen deleted.  Redesigned services may become available
    in the future.\n7. RESOLVER IMPLEMENTATION\nThe top levels of the recommended
    resolver algorithm are discussed in\n[RFC-1034].  This section discusses implementation
    details assuming the\ndatabase structure suggested in the name server implementation
    section\nof this memo.\n7.1. Transforming a user request into a query\nThe first
    step a resolver takes is to transform the client's request,\nstated in a format
    suitable to the local OS, into a search specification\nfor RRs at a specific name
    which match a specific QTYPE and QCLASS.\nWhere possible, the QTYPE and QCLASS
    should correspond to a single type\nand a single class, because this makes the
    use of cached data much\nsimpler.  The reason for this is that the presence of
    data of one type\nin a cache doesn't confirm the existence or non-existence of
    data of\nother types, hence the only way to be sure is to consult an\nauthoritative
    source.  If QCLASS=* is used, then authoritative answers\nwon't be available.\nSince
    a resolver must be able to multiplex multiple requests if it is to\nperform its
    function efficiently, each pending request is usually\nrepresented in some block
    of state information.  This state block will\ntypically contain:\n   - A timestamp
    indicating the time the request began.\n     The timestamp is used to decide whether
    RRs in the database\n     can be used or are out of date.  This timestamp uses
    the\n     absolute time format previously discussed for RR storage in\n     zones
    and caches.  Note that when an RRs TTL indicates a\n     relative time, the RR
    must be timely, since it is part of a\n     zone.  When the RR has an absolute
    time, it is part of a\n     cache, and the TTL of the RR is compared against the
    timestamp\n     for the start of the request.\n     Note that using the timestamp
    is superior to using a current\n     time, since it allows RRs with TTLs of zero
    to be entered in\n     the cache in the usual manner, but still used by the current\n
    \    request, even after intervals of many seconds due to system\n     load, query
    retransmission timeouts, etc.\n   - Some sort of parameters to limit the amount
    of work which will\n     be performed for this request.\n     The amount of work
    which a resolver will do in response to a\n     client request must be limited
    to guard against errors in the\n     database, such as circular CNAME references,
    and operational\n     problems, such as network partition which prevents the\n
    \    resolver from accessing the name servers it needs.  While\n     local limits
    on the number of times a resolver will retransmit\n     a particular query to
    a particular name server address are\n     essential, the resolver should have
    a global per-request\n     counter to limit work on a single request.  The counter
    should\n     be set to some initial value and decremented whenever the\n     resolver
    performs any action (retransmission timeout,\n     retransmission, etc.)  If the
    counter passes zero, the request\n     is terminated with a temporary error.\n
    \    Note that if the resolver structure allows one request to\n     start others
    in parallel, such as when the need to access a\n     name server for one request
    causes a parallel resolve for the\n     name server's addresses, the spawned request
    should be started\n     with a lower counter.  This prevents circular references
    in\n     the database from starting a chain reaction of resolver\n     activity.\n
    \  - The SLIST data structure discussed in [RFC-1034].\n     This structure keeps
    track of the state of a request if it\n     must wait for answers from foreign
    name servers.\n7.2. Sending the queries\nAs described in [RFC-1034], the basic
    task of the resolver is to\nformulate a query which will answer the client's request
    and direct that\nquery to name servers which can provide the information.  The
    resolver\nwill usually only have very strong hints about which servers to ask,
    in\nthe form of NS RRs, and may have to revise the query, in response to\nCNAMEs,
    or revise the set of name servers the resolver is asking, in\nresponse to delegation
    responses which point the resolver to name\nservers closer to the desired information.
    \ In addition to the\ninformation requested by the client, the resolver may have
    to call upon\nits own services to determine the address of name servers it wishes
    to\ncontact.\nIn any case, the model used in this memo assumes that the resolver
    is\nmultiplexing attention between multiple requests, some from the client,\nand
    some internally generated.  Each request is represented by some\nstate information,
    and the desired behavior is that the resolver\ntransmit queries to name servers
    in a way that maximizes the probability\nthat the request is answered, minimizes
    the time that the request takes,\nand avoids excessive transmissions.  The key
    algorithm uses the state\ninformation of the request to select the next name server
    address to\nquery, and also computes a timeout which will cause the next action\nshould
    a response not arrive.  The next action will usually be a\ntransmission to some
    other server, but may be a temporary error to the\nclient.\nThe resolver always
    starts with a list of server names to query (SLIST).\nThis list will be all NS
    RRs which correspond to the nearest ancestor\nzone that the resolver knows about.
    \ To avoid startup problems, the\nresolver should have a set of default servers
    which it will ask should\nit have no current NS RRs which are appropriate.  The
    resolver then adds\nto SLIST all of the known addresses for the name servers,
    and may start\nparallel requests to acquire the addresses of the servers when
    the\nresolver has the name, but no addresses, for the name servers.\nTo complete
    initialization of SLIST, the resolver attaches whatever\nhistory information it
    has to the each address in SLIST.  This will\nusually consist of some sort of
    weighted averages for the response time\nof the address, and the batting average
    of the address (i.e., how often\nthe address responded at all to the request).
    \ Note that this\ninformation should be kept on a per address basis, rather than
    on a per\nname server basis, because the response time and batting average of
    a\nparticular server may vary considerably from address to address.  Note\nalso
    that this information is actually specific to a resolver address /\nserver address
    pair, so a resolver with multiple addresses may wish to\nkeep separate histories
    for each of its addresses.  Part of this step\nmust deal with addresses which
    have no such history; in this case an\nexpected round trip time of 5-10 seconds
    should be the worst case, with\nlower estimates for the same local network, etc.\nNote
    that whenever a delegation is followed, the resolver algorithm\nreinitializes
    SLIST.\nThe information establishes a partial ranking of the available name\nserver
    addresses.  Each time an address is chosen and the state should\nbe altered to
    prevent its selection again until all other addresses have\nbeen tried.  The timeout
    for each transmission should be 50-100% greater\nthan the average predicted value
    to allow for variance in response.\nSome fine points:\n   - The resolver may encounter
    a situation where no addresses are\n     available for any of the name servers
    named in SLIST, and\n     where the servers in the list are precisely those which
    would\n     normally be used to look up their own addresses.  This\n     situation
    typically occurs when the glue address RRs have a\n     smaller TTL than the NS
    RRs marking delegation, or when the\n     resolver caches the result of a NS search.
    \ The resolver\n     should detect this condition and restart the search at the\n
    \    next ancestor zone, or alternatively at the root.\n   - If a resolver gets
    a server error or other bizarre response\n     from a name server, it should remove
    it from SLIST, and may\n     wish to schedule an immediate transmission to the
    next\n     candidate server address.\n7.3. Processing responses\nThe first step
    in processing arriving response datagrams is to parse the\nresponse.  This procedure
    should include:\n   - Check the header for reasonableness.  Discard datagrams
    which\n     are queries when responses are expected.\n   - Parse the sections
    of the message, and insure that all RRs are\n     correctly formatted.\n   - As
    an optional step, check the TTLs of arriving data looking\n     for RRs with excessively
    long TTLs.  If a RR has an\n     excessively long TTL, say greater than 1 week,
    either discard\n     the whole response, or limit all TTLs in the response to
    1\n     week.\nThe next step is to match the response to a current resolver request.\nThe
    recommended strategy is to do a preliminary matching using the ID\nfield in the
    domain header, and then to verify that the question section\ncorresponds to the
    information currently desired.  This requires that\nthe transmission algorithm
    devote several bits of the domain ID field to\na request identifier of some sort.
    \ This step has several fine points:\n   - Some name servers send their responses
    from different\n     addresses than the one used to receive the query.  That is,
    a\n     resolver cannot rely that a response will come from the same\n     address
    which it sent the corresponding query to.  This name\n     server bug is typically
    encountered in UNIX systems.\n   - If the resolver retransmits a particular request
    to a name\n     server it should be able to use a response from any of the\n     transmissions.
    \ However, if it is using the response to sample\n     the round trip time to
    access the name server, it must be able\n     to determine which transmission
    matches the response (and keep\n     transmission times for each outgoing message),
    or only\n     calculate round trip times based on initial transmissions.\n   -
    A name server will occasionally not have a current copy of a\n     zone which
    it should have according to some NS RRs.  The\n     resolver should simply remove
    the name server from the current\n     SLIST, and continue.\n7.4. Using the cache\nIn
    general, we expect a resolver to cache all data which it receives in\nresponses
    since it may be useful in answering future client requests.\nHowever, there are
    several types of data which should not be cached:\n   - When several RRs of the
    same type are available for a\n     particular owner name, the resolver should
    either cache them\n     all or none at all.  When a response is truncated, and
    a\n     resolver doesn't know whether it has a complete set, it should\n     not
    cache a possibly partial set of RRs.\n   - Cached data should never be used in
    preference to\n     authoritative data, so if caching would cause this to happen\n
    \    the data should not be cached.\n   - The results of an inverse query should
    not be cached.\n   - The results of standard queries where the QNAME contains
    \"*\"\n     labels if the data might be used to construct wildcards.  The\n     reason
    is that the cache does not necessarily contain existing\n     RRs or zone boundary
    information which is necessary to\n     restrict the application of the wildcard
    RRs.\n   - RR data in responses of dubious reliability.  When a resolver\n     receives
    unsolicited responses or RR data other than that\n     requested, it should discard
    it without caching it.  The basic\n     implication is that all sanity checks
    on a packet should be\n     performed before any of it is cached.\nIn a similar
    vein, when a resolver has a set of RRs for some name in a\nresponse, and wants
    to cache the RRs, it should check its cache for\nalready existing RRs.  Depending
    on the circumstances, either the data\nin the response or the cache is preferred,
    but the two should never be\ncombined.  If the data in the response is from authoritative
    data in the\nanswer section, it is always preferred.\n8. MAIL SUPPORT\nThe domain
    system defines a standard for mapping mailboxes into domain\nnames, and two methods
    for using the mailbox information to derive mail\nrouting information.  The first
    method is called mail exchange binding\nand the other method is mailbox binding.
    \ The mailbox encoding standard\nand mail exchange binding are part of the DNS
    official protocol, and are\nthe recommended method for mail routing in the Internet.
    \ Mailbox\nbinding is an experimental feature which is still under development
    and\nsubject to change.\nThe mailbox encoding standard assumes a mailbox name
    of the form\n\"<local-part>@<mail-domain>\".  While the syntax allowed in each
    of these\nsections varies substantially between the various mail internets, the\npreferred
    syntax for the ARPA Internet is given in [RFC-822].\nThe DNS encodes the <local-part>
    as a single label, and encodes the\n<mail-domain> as a domain name.  The single
    label from the <local-part>\nis prefaced to the domain name from <mail-domain>
    to form the domain\nname corresponding to the mailbox.  Thus the mailbox HOSTMASTER@SRI-\nNIC.ARPA
    is mapped into the domain name HOSTMASTER.SRI-NIC.ARPA.  If the\n<local-part>
    contains dots or other special characters, its\nrepresentation in a master file
    will require the use of backslash\nquoting to ensure that the domain name is properly
    encoded.  For\nexample, the mailbox Action.domains@ISI.EDU would be represented
    as\nAction\\.domains.ISI.EDU.\n8.1. Mail exchange binding\nMail exchange binding
    uses the <mail-domain> part of a mailbox\nspecification to determine where mail
    should be sent.  The <local-part>\nis not even consulted.  [RFC-974] specifies
    this method in detail, and\nshould be consulted before attempting to use mail
    exchange support.\nOne of the advantages of this method is that it decouples mail\ndestination
    naming from the hosts used to support mail service, at the\ncost of another layer
    of indirection in the lookup function.  However,\nthe addition layer should eliminate
    the need for complicated \"%\", \"!\",\netc encodings in <local-part>.\nThe essence
    of the method is that the <mail-domain> is used as a domain\nname to locate type
    MX RRs which list hosts willing to accept mail for\n<mail-domain>, together with
    preference values which rank the hosts\naccording to an order specified by the
    administrators for <mail-domain>.\nIn this memo, the <mail-domain> ISI.EDU is
    used in examples, together\nwith the hosts VENERA.ISI.EDU and VAXA.ISI.EDU as
    mail exchanges for\nISI.EDU.  If a mailer had a message for Mockapetris@ISI.EDU,
    it would\nroute it by looking up MX RRs for ISI.EDU.  The MX RRs at ISI.EDU name\nVENERA.ISI.EDU
    and VAXA.ISI.EDU, and type A queries can find the host\naddresses.\n8.2. Mailbox
    binding (Experimental)\nIn mailbox binding, the mailer uses the entire mail destination\nspecification
    to construct a domain name.  The encoded domain name for\nthe mailbox is used
    as the QNAME field in a QTYPE=MAILB query.\nSeveral outcomes are possible for
    this query:\n   1. The query can return a name error indicating that the mailbox\n
    \     does not exist as a domain name.\n      In the long term, this would indicate
    that the specified\n      mailbox doesn't exist.  However, until the use of mailbox\n
    \     binding is universal, this error condition should be\n      interpreted
    to mean that the organization identified by the\n      global part does not support
    mailbox binding.  The\n      appropriate procedure is to revert to exchange binding
    at\n      this point.\n   2. The query can return a Mail Rename (MR) RR.\n      The
    MR RR carries new mailbox specification in its RDATA\n      field.  The mailer
    should replace the old mailbox with the\n      new one and retry the operation.\n
    \  3. The query can return a MB RR.\n      The MB RR carries a domain name for
    a host in its RDATA\n      field.  The mailer should deliver the message to that
    host\n      via whatever protocol is applicable, e.g., b,SMTP.\n   4. The query
    can return one or more Mail Group (MG) RRs.\n      This condition means that the
    mailbox was actually a mailing\n      list or mail group, rather than a single
    mailbox.  Each MG RR\n      has a RDATA field that identifies a mailbox that is
    a member\n      of the group.  The mailer should deliver a copy of the\n      message
    to each member.\n   5. The query can return a MB RR as well as one or more MG
    RRs.\n      This condition means the the mailbox was actually a mailing\n      list.
    \ The mailer can either deliver the message to the host\n      specified by the
    MB RR, which will in turn do the delivery to\n      all members, or the mailer
    can use the MG RRs to do the\n      expansion itself.\nIn any of these cases,
    the response may include a Mail Information\n(MINFO) RR.  This RR is usually associated
    with a mail group, but is\nlegal with a MB.  The MINFO RR identifies two mailboxes.
    \ One of these\nidentifies a responsible person for the original mailbox name.
    \ This\nmailbox should be used for requests to be added to a mail group, etc.\nThe
    second mailbox name in the MINFO RR identifies a mailbox that should\nreceive
    error messages for mail failures.  This is particularly\nappropriate for mailing
    lists when errors in member names should be\nreported to a person other than the
    one who sends a message to the list.\nNew fields may be added to this RR in the
    future.\n9. REFERENCES and BIBLIOGRAPHY\n[Dyer 87]       S. Dyer, F. Hsu, \"Hesiod\",
    Project Athena\n                Technical Plan - Name Service, April 1987, version
    1.9.\n                Describes the fundamentals of the Hesiod name service.\n[IEN-116]
    \      J. Postel, \"Internet Name Server\", IEN-116,\n                USC/Information
    Sciences Institute, August 1979.\n                A name service obsoleted by
    the Domain Name System, but\n                still in use.\n[Quarterman 86] J.
    Quarterman, and J. Hoskins, \"Notable Computer Networks\",\n                Communications
    of the ACM, October 1986, volume 29, number\n                10.\n[RFC-742]       K.
    Harrenstien, \"NAME/FINGER\", RFC-742, Network\n                Information Center,
    SRI International, December 1977.\n[RFC-768]       J. Postel, \"User Datagram
    Protocol\", RFC-768,\n                USC/Information Sciences Institute, August
    1980.\n[RFC-793]       J. Postel, \"Transmission Control Protocol\", RFC-793,\n
    \               USC/Information Sciences Institute, September 1981.\n[RFC-799]
    \      D. Mills, \"Internet Name Domains\", RFC-799, COMSAT,\n                September
    1981.\n                Suggests introduction of a hierarchy in place of a flat\n
    \               name space for the Internet.\n[RFC-805]       J. Postel, \"Computer
    Mail Meeting Notes\", RFC-805,\n                USC/Information Sciences Institute,
    February 1982.\n[RFC-810]       E. Feinler, K. Harrenstien, Z. Su, and V. White,
    \"DOD\n                Internet Host Table Specification\", RFC-810, Network\n
    \               Information Center, SRI International, March 1982.\n                Obsolete.
    \ See RFC-952.\n[RFC-811]       K. Harrenstien, V. White, and E. Feinler, \"Hostnames\n
    \               Server\", RFC-811, Network Information Center, SRI\n                International,
    March 1982.\n                Obsolete.  See RFC-953.\n[RFC-812]       K. Harrenstien,
    and V. White, \"NICNAME/WHOIS\", RFC-812,\n                Network Information
    Center, SRI International, March\n                1982.\n[RFC-819]       Z. Su,
    and J. Postel, \"The Domain Naming Convention for\n                Internet User
    Applications\", RFC-819, Network\n                Information Center, SRI International,
    August 1982.\n                Early thoughts on the design of the domain system.\n
    \               Current implementation is completely different.\n[RFC-821]       J.
    Postel, \"Simple Mail Transfer Protocol\", RFC-821,\n                USC/Information
    Sciences Institute, August 1980.\n[RFC-830]       Z. Su, \"A Distributed System
    for Internet Name Service\",\n                RFC-830, Network Information Center,
    SRI International,\n                October 1982.\n                Early thoughts
    on the design of the domain system.\n                Current implementation is
    completely different.\n[RFC-882]       P. Mockapetris, \"Domain names - Concepts
    and\n                Facilities,\" RFC-882, USC/Information Sciences\n                Institute,
    November 1983.\n                Superceeded by this memo.\n[RFC-883]       P.
    Mockapetris, \"Domain names - Implementation and\n                Specification,\"
    RFC-883, USC/Information Sciences\n                Institute, November 1983.\n
    \               Superceeded by this memo.\n[RFC-920]       J. Postel and J. Reynolds,
    \"Domain Requirements\",\n                RFC-920, USC/Information Sciences Institute,\n
    \               October 1984.\n                Explains the naming scheme for
    top level domains.\n[RFC-952]       K. Harrenstien, M. Stahl, E. Feinler, \"DoD
    Internet Host\n                Table Specification\", RFC-952, SRI, October 1985.\n
    \               Specifies the format of HOSTS.TXT, the host/address\n                table
    replaced by the DNS.\n[RFC-953]       K. Harrenstien, M. Stahl, E. Feinler, \"HOSTNAME
    Server\",\n                RFC-953, SRI, October 1985.\n                This RFC
    contains the official specification of the\n                hostname server protocol,
    which is obsoleted by the DNS.\n                This TCP based protocol accesses
    information stored in\n                the RFC-952 format, and is used to obtain
    copies of the\n                host table.\n[RFC-973]       P. Mockapetris, \"Domain
    System Changes and\n                Observations\", RFC-973, USC/Information Sciences\n
    \               Institute, January 1986.\n                Describes changes to
    RFC-882 and RFC-883 and reasons for\n                them.\n[RFC-974]       C.
    Partridge, \"Mail routing and the domain system\",\n                RFC-974, CSNET
    CIC BBN Labs, January 1986.\n                Describes the transition from HOSTS.TXT
    based mail\n                addressing to the more powerful MX system used with
    the\n                domain system.\n[RFC-1001]      NetBIOS Working Group, \"Protocol
    standard for a NetBIOS\n                service on a TCP/UDP transport: Concepts
    and Methods\",\n                RFC-1001, March 1987.\n                This RFC
    and RFC-1002 are a preliminary design for\n                NETBIOS on top of TCP/IP
    which proposes to base NetBIOS\n                name service on top of the DNS.\n[RFC-1002]
    \     NetBIOS Working Group, \"Protocol standard for a NetBIOS\n                service
    on a TCP/UDP transport: Detailed\n                Specifications\", RFC-1002,
    March 1987.\n[RFC-1010]      J. Reynolds, and J. Postel, \"Assigned Numbers\",
    RFC-1010,\n                USC/Information Sciences Institute, May 1987.\n                Contains
    socket numbers and mnemonics for host names,\n                operating systems,
    etc.\n[RFC-1031]      W. Lazear, \"MILNET Name Domain Transition\", RFC-1031,\n
    \               November 1987.\n                Describes a plan for converting
    the MILNET to the DNS.\n[RFC-1032]      M. Stahl, \"Establishing a Domain - Guidelines
    for\n                Administrators\", RFC-1032, November 1987.\n                Describes
    the registration policies used by the NIC to\n                administer the top
    level domains and delegate subzones.\n[RFC-1033]      M. Lottor, \"Domain Administrators
    Operations Guide\",\n                RFC-1033, November 1987.\n                A
    cookbook for domain administrators.\n[Solomon 82]    M. Solomon, L. Landweber,
    and D. Neuhengen, \"The CSNET\n                Name Server\", Computer Networks,
    vol 6, nr 3, July 1982.\n                Describes a name service for CSNET which
    is independent\n                from the DNS and DNS use in the CSNET.\nIndex\n
    \         *   13\n          ;   33, 35\n          <character-string>   35\n          <domain-name>
    \  34\n          @   35\n          \\   35\n          A   12\n          Byte order
    \  8\n          CH   13\n          Character case   9\n          CLASS   11\n
    \         CNAME   12\n          Completion   42\n          CS   13\n          Hesiod
    \  13\n          HINFO   12\n          HS   13\n          IN   13\n          IN-ADDR.ARPA
    domain   22\n          Inverse queries   40\n          Mailbox names   47\n          MB
    \  12\n          MD   12\n          MF   12\n          MG   12\n          MINFO
    \  12\n          MINIMUM   20\n          MR   12\n          MX   12\n          NS
    \  12\n          NULL   12\n          Port numbers   32\n          Primary server
    \  5\n          PTR   12, 18\n          QCLASS   13\n          QTYPE   12\n          RDATA
    \  12\n          RDLENGTH  11\n          Secondary server   5\n          SOA   12\n
    \         Stub resolvers   7\n          TCP   32\n          TXT   12\n          TYPE
    \  11\n          UDP   32\n          WKS   12\n"
  title: __initial_text__
