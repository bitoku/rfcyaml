- title: __initial_text__
  contents:
  - '            The Multicast Address-Set Claim (MASC) Protocol

    '
- title: Status of this Memo
  contents:
  - "Status of this Memo\n   This memo defines an Experimental Protocol for the Internet\n\
    \   community.  It does not specify an Internet standard of any kind.\n   Discussion\
    \ and suggestions for improvement are requested.\n   Distribution of this memo\
    \ is unlimited.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (C) The Internet Society (2000).  All Rights Reserved.\n"
- title: Abstract
  contents:
  - "Abstract\n   This document describes the Multicast Address-Set Claim (MASC)\n\
    \   protocol which can be used for inter-domain multicast address set\n   allocation.\
    \  MASC is used by a node (typically a router) to claim and\n   allocate one or\
    \ more address prefixes to that node's domain.  While a\n   domain does not necessarily\
    \ need to allocate an address set for hosts\n   in that domain to be able to allocate\
    \ group addresses, allocating an\n   address set to the domain does ensure that\
    \ inter-domain group-\n   specific distribution trees will be locally-rooted,\
    \ and that traffic\n   will be sent outside the domain only when and where external\n\
    \   receivers exist.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1 Introduction ..................................................\
    \  4\n   1.1 Terminology .................................................  4\n\
    \   1.2 Definitions .................................................  4\n   2\
    \ Requirements for Inter-Domain Address Allocation ..............  5\n   3 Overall\
    \ Architecture ..........................................  5\n   3.1 Claim-Collide\
    \ vs. Query-Response Rationale ..................  6\n   4 MASC Topology .................................................\
    \  6\n   4.1 Managed vs Locally-Allocated Space ..........................  8\n\
    \   4.2 Prefix Lifetime .............................................  8\n   4.3\
    \ Active vs. Deprecated Prefixes ..............................  9\n   4.4 Multi-Parent\
    \ Sibling-to-Sibling and Internal Peering ........  9\n   4.5 Administratively-Scoped\
    \ Address Allocation ..................  9\n   5 Protocol Details ..............................................\
    \ 10\n   5.1 Claiming Space .............................................. 10\n\
    \   5.1.1 Claim Comparison Function ................................. 12\n   5.2\
    \ Renewing an Existing Claim .................................. 12\n   5.3 Expanding\
    \ an Existing Prefix ................................ 12\n   5.4 Releasing Allocated\
    \ Space ................................... 13\n   6 Constants .....................................................\
    \ 13\n   7 Message Formats ............................................... 14\n\
    \   7.1 Message Header Format ....................................... 14\n   7.2\
    \ OPEN Message Format ......................................... 15\n   7.3 UPDATE\
    \ Message Format ....................................... 17\n   7.4 KEEPALIVE\
    \ Message Format .................................... 21\n   7.5 NOTIFICATION\
    \ Message Format ................................. 21\n   8 MASC Error Handling\
    \ ........................................... 24\n   8.1 Message Header Error\
    \ Handling ............................... 24\n   8.2 OPEN Message Error Handling\
    \ ................................. 25\n   8.3 UPDATE Message Error Handling ...............................\
    \ 26\n   8.4 Hold Timer Expired Error Handling ........................... 28\n\
    \   8.5 Finite State Machine Error Handling ......................... 28\n   8.6\
    \ NOTIFICATION Message Error Handling ......................... 28\n   8.7 Cease\
    \ ....................................................... 29\n   8.8 Connection\
    \ Collision Detection .............................. 29\n   9 MASC Version Negotiation\
    \ ...................................... 30\n   10 MASC Finite State Machine ....................................\
    \ 30\n   10.1 Open/Close MASC Connection FSM ............................. 31\n\
    \   11 UPDATE Message Processing .................................... 35\n   11.1\
    \ Accept/Reject an UPDATE .................................... 36\n   11.2 PREFIX_IN_USE\
    \ Message Processing ........................... 38\n   11.2.1 PREFIX_IN_USE by\
    \ PARENT .................................. 38\n   11.2.2 PREFIX_IN_USE by SIBLING\
    \ ................................. 38\n   11.2.3 PREFIX_IN_USE by CHILD ...................................\
    \ 38\n   11.2.4 PREFIX_IN_USE by INTERNAL_PEER ........................... 38\n\
    \   11.3 CLAIM_DENIED Message Processing ............................ 39\n   11.3.1\
    \ CLAIM_DENIED by CHILD or SIBLING ......................... 39\n   11.3.2 CLAIM_DENIED\
    \ by INTERNAL_PEER ............................ 39\n   11.3.3 CLAIM_DENIED by\
    \ PARENT ................................... 39\n   11.4 CLAIM_TO_EXPAND Message\
    \ Processing ......................... 39\n   11.4.1 CLAIM_TO_EXPAND by PARENT\
    \ ................................ 39\n   11.4.2 CLAIM_TO_EXPAND by SIBLING ...............................\
    \ 40\n   11.4.3 CLAIM_TO_EXPAND by CHILD ................................. 40\n\
    \   11.4.4 CLAIM_TO_EXPAND by INTERNAL_PEER ......................... 40\n   11.5\
    \ NEW_CLAIM Message Processing ............................... 41\n   11.6 PREFIX_MANAGED\
    \ Message Processing.  ........................ 41\n   11.6.1 PREFIX_MANAGED by\
    \ PARENT ................................. 41\n   11.6.2 PREFIX_MANAGED by CHILD\
    \ or SIBLING ....................... 41\n   11.6.3 PREFIX_MANAGED by INTERNAL_PEER\
    \ .......................... 41\n   11.7 WITHDRAW Message Processing ................................\
    \ 42\n   11.7.1 WITHDRAW by CHILD ........................................ 42\n\
    \   11.7.2 WITHDRAW by SIBLING ...................................... 42\n   11.7.3\
    \ WITHDRAW by INTERNAL ..................................... 42\n   11.7.4 WITHDRAW\
    \ by PARENT ....................................... 43\n   11.8 UPDATE Message\
    \ Ordering .................................... 43\n   11.8.1 Parent to Child\
    \ .......................................... 43\n   11.8.2 Child to Parent ..........................................\
    \ 44\n   11.8.3 Sibling to Sibling ....................................... 44\n\
    \   11.8.4 Internal to Internal ..................................... 44\n   12\
    \ Operational Considerations ................................... 45\n   12.1 Bootup\
    \ Operations .......................................... 45\n   12.2 Leaf and Non-leaf\
    \ MASC Domain Operation .................... 45\n   12.3 Clock Skew Workaround\
    \ ...................................... 45\n   12.4 Clash Resolving Mechanism\
    \ .................................. 46\n   12.5 Changing Network Providers .................................\
    \ 47\n   12.6 Debugging .................................................. 47\n\
    \   12.6.1 Prefix-to-Domain Lookup .................................. 47\n   12.6.2\
    \ Domain-to-Prefix Lookup .................................. 47\n   13 MASC Storage\
    \ ................................................. 47\n   14 Security Considerations\
    \ ...................................... 48\n   15 IANA Considerations ..........................................\
    \ 48\n   16 Acknowledgments .............................................. 48\n\
    \   17 APPENDIX A: Sample Algorithms ................................ 49\n   17.1\
    \ Claim Size and Prefix Selection Algorithm .................. 49\n   17.1.1 Prefix\
    \ Expansion ......................................... 49\n   17.1.2 Reducing Allocation\
    \ Latency .............................. 50\n   17.1.3 Address Space Utilization\
    \ ................................ 50\n   17.1.4 Prefix Selection After Increase\
    \ of Demand ................ 50\n   17.1.5 Prefix Selection After Decrease of\
    \ Demand ................ 51\n   17.1.6 Lifetime Extension Algorithm .............................\
    \ 51\n   18 APPENDIX B: Strawman Deployment .............................. 51\n\
    \   19 Authors' Addresses ........................................... 52\n   20\
    \ References ................................................... 54\n   21 Full\
    \ Copyright Statement ..................................... 56\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   This document describes MASC, a protocol for inter-domain\
    \ multicast\n   address set allocation.  The MASC protocol (a Layer-3 protocol\
    \ in the\n   multicast address allocation architecture [MALLOC]) is used by a\
    \ node\n   (typically a router) to claim and allocate one or more address\n  \
    \ prefixes to that node's domain.  Each prefix has an associated\n   lifetime,\
    \ and is chosen out of a larger prefix with a lifetime at\n   least as long, in\
    \ a manner such that prefixes are aggregatable.  At\n   any time, each MASC node\
    \ (a Prefix Coordinator in [MALLOC]) will\n   typically advertise several prefixes\
    \ with different lifetimes and\n   scopes, allowing Multicast Address Allocation\
    \ Servers (MAAS's) in\n   that domain or child MASC domains to choose appropriate\
    \ addresses for\n   their clients.\n   The set of prefixes (\"address set\") associated\
    \ with a domain is\n   injected into an inter-domain routing protocol (e.g., BGP4+\
    \ [MBGP]),\n   where it can be used by an inter-domain multicast tree construction\n\
    \   protocol (e.g., BGMP [BGMP]) to construct inter-domain group-shared\n   trees.\n\
    \   Note that a domain does not need to allocate an address set for the\n   hosts\
    \ in that domain to be able to allocate group addresses, nor does\n   allocating\
    \ necessarily guarantee that hosts in other domains will not\n   use an address\
    \ in the set (since, for example, hosts are not forced\n   to contact a MAAS before\
    \ using a group address).  Allocating an\n   address set to a domain does, however,\
    \ ensure that inter-domain\n   group-specific multicast distribution trees for\
    \ any group in the\n   address set will be locally-rooted, and that traffic will\
    \ be sent\n   outside the given domain only when and where external receivers\n\
    \   exist.\n"
- title: 1.1.  Terminology
  contents:
  - "1.1.  Terminology\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"\
    SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\"\
    , and \"OPTIONAL\" in this\n   document are to be interpreted as described in\
    \ RFC 2119 [RFC2119].\n   Constants used by this protocol are shown as [NAME_OF_CONSTANT],\
    \ and\n   summarized in Section 6.\n"
- title: 1.2.  Definitions
  contents:
  - "1.2.  Definitions\n   This specification uses a number of terms that may not\
    \ be familiar to\n   the reader. This section defines some of these and refers\
    \ to other\n   documents for definitions of others.\n   MAAS (Multicast Address\
    \ Allocation Server)\n      A host providing multicast address allocation services\
    \ to end\n      users (e.g. via MADCAP [MADCAP]).\n   MASC server\n      A node\
    \ running MASC.\n   Peer\n      Other MASC speakers a node directly communicates\
    \ with.\n   Multicast\n      IP Multicast, as defined for IPv4 in [RFC1112] and\
    \ for IPv6 in\n      [RFC2460].\n   Multicast Address\n      An IP multicast address\
    \ or group address, as defined in [RFC1112]\n      and [RFC2373].  An identifier\
    \ for a group of nodes.\n"
- title: 2.  Requirements for Inter-Domain Address Allocation
  contents:
  - "2.  Requirements for Inter-Domain Address Allocation\n   The key design requirements\
    \ for the inter-domain address allocation\n   mechanism are:\n   o  Efficient\
    \ address space utilization when space is scare, which\n      naturally implies\
    \ that address allocations be based on the actual\n      address usage patterns,\
    \ and therefore that it be dynamic.\n   o  Address aggregation, that implies that\
    \ the address allocation\n      mechanism be hierarchical.\n   o  Minimize flux\
    \ in the allocated address sets (e.g. the address sets\n      should be reused\
    \ when possible).\n   o  Robustness, by using decentralized mechanisms.\n   The\
    \ timeliness in obtaining an address set is not a major design\n   constraint\
    \ as this is taken care of at a lower level [MALLOC].\n"
- title: 3.  Overall Architecture
  contents:
  - "3.  Overall Architecture\n   The Multicast Address Set Claim (MASC) protocol\
    \ is used by MASC\n   domains to claim and allocate address sets for use by Multicast\n\
    \   Address Allocation Servers (MAASs) within each domain.  Typically one\n  \
    \ or more border routers of each domain that requires multicast address\n   space\
    \ of its own would run MASC.  Throughout this document, the term\n   \"MASC domain\"\
    \ refers to a domain that has at least one node running\n   MASC; typically these\
    \ domains will be Autonomous Systems (AS's).  A\n   MASC node (on behalf of its\
    \ domain) chooses an address set to claim,\n   sends a claim to other MASC domains\
    \ in the network, and waits while\n   listening for any colliding claims. If there\
    \ is a collision, the\n   losing claimer gives up the colliding claim and claims\
    \ a different\n   address set.\n   After a sufficiently long collision-free waiting\
    \ period, the address\n   set chosen by a MASC node is considered allocated to\
    \ that node's\n   domain.  Three things may then happen:\n   a) The allocated\
    \ prefix can then be injected as a \"multicast route\"\n      into the inter-domain\
    \ routing protocol  (e.g., BGP4+ [MBGP]) as\n      \"G-RIB\" Network Layer Reachability\
    \ Information (NLRI), where it\n      may be used by an inter-domain multicast\
    \ routing protocol (e.g.,\n      BGMP [BGMP]) to construct group-shared trees.\
    \  To reduce the size\n      and slow the growth of the G-RIB, MASC nodes may\
    \ perform CIDR-like\n      aggregation [CIDR] of the multicast NLRI information.\
    \  This\n      motivates the need for an algorithm to select prefixes for domains\n\
    \      in such a way as to ensure good aggregation in addition to\n      achieving\
    \ good address space utilization.\n   b) The node's domain may assign to itself\
    \ a sub-prefix which can be\n      used by MAASs within the domain.\n   c) Sub-prefixes\
    \ may be allocated to child domains, if any.\n"
- title: 3.1.  Claim-Collide vs. Query-Response Rationale
  contents:
  - "3.1.  Claim-Collide vs. Query-Response Rationale\n   We choose a claim-collide\
    \ mechanism instead of a query-response\n   mechanism for the following reasons.\
    \  In a query-response mechanism,\n   replicas of the MASC node would be needed\
    \ in parent MASC domains in\n   order to make their responses be robust to failures.\
    \  This brings\n   about the associated problem of synchronization of the replicas\
    \ and\n   possibly additional fragmentation of the address space.  In addition,\n\
    \   even in this mechanism, address collisions would still need to be\n   handled.\
    \  We believe the proposed claim-collide mechanism is simpler\n   and more robust\
    \ than a query-response mechanism.\n"
- title: 4.  MASC Topology
  contents:
  - "4.  MASC Topology\n   The domain hierarchy used by MASC is congruent to the somewhat\n\
    \   hierarchical structure of the inter-domain topology, e.g., backbones\n   connected\
    \ to regionals, regionals connected to metropolitan\n   providers, etc.  As in\
    \ BGP, MASC connections are locally configured.\n   A MASC domain that is a customer\
    \ of other MASC domains will have one\n   or more of those provider domains as\
    \ its parent.  For example, a MASC\n   domain that is a regional provider will\
    \ choose one (or more) of its\n   backbone provider domains as its parent(s).\
    \  Children are configured\n   with their parent MASC domain, and parents are\
    \ configured with their\n   children domains.  At the top, a  number of Top-Level\
    \ Domains are\n   connected in a (sparse) mesh and share the global multicast\
    \ address\n   space.  To improve the robustness, a pair of children of the same\n\
    \   parent domain MAY be configured as siblings with regard to that\n   parent.\n\
    \   Figure 1 illustrates a sample topology.  Double-line links denote\n   intra-domain\
    \ TCP peering sessions, and single-line links denote\n   inter-domain TCP connections.\
    \ T1 and T2 are Top-Level Domains (e.g.,\n   backbone providers), containing MASC\
    \ speakers T1a and T2a,\n   respectively.  P3 and P4 are regional domains, containing\
    \ (P3a, P3b),\n   and (P4a, P4b) respectively.  P3 has a single customer (or \"\
    child\"),\n   C5, containing (C5a, C5b, C5c).  P4 has three children, C5, C6,\
    \ C7,\n   containing (C5a, C5b, C5c), (C6a, C6b), and (C7a) respectively.\n  \
    \                       T1a-----------T2a\n                          |       \
    \      |\n                          |             |\n                        \
    \  |             |\n                  P3a====P3b           P4a====P4b\n      \
    \             |      |           / |    / | \\\n                   |      |  \
    \ _______/  |   /  |  \\\n                   |      |  /          |  /   |   \\\
    ______\n                   |      | /           | /    |          \\\n       \
    \           C5a====C5b           C6a====C6b----------C7a\n                   \
    \ \\\\  //\n                     \\\\//\n                     C5c\n          \
    \        Figure 1: Example MASC Topology\n   All MASC communications use TCP.\
    \ Each MASC node is connected to and\n   communicates directly with other MASC\
    \ nodes.  The local node acts in\n   exactly one of the following four roles with\
    \ respect to each remote\n   note:\n   INTERNAL_PEER\n      The local and remote\
    \ nodes are both in the same MASC domain.  For\n      example, P4b is an INTERNAL_PEER\
    \ of P4a.\n   CHILD\n      A customer relationship exists whereby the local node\
    \ may obtain\n      address space from the remote node.  For example, C6a is a\
    \ CHILD\n      in its session with P4a.\n   PARENT\n      A provider relationship\
    \ exists whereby the remote node may obtain\n      address space from the local\
    \ node.  For example, T2a is a PARENT\n      in its session with P4a.  Whether\
    \ space is actually requested is\n      up to the implementation and local policy\
    \ configuration.\n   SIBLING\n      No customer-provider relationship exists.\
    \  For example, T2a is a\n      SIBLING in its session with T1a (Top-Level Domain\
    \ SIBLING\n      peering).  Also, C6b is a SIBLING in its session with C7a with\n\
    \      regard to their common parent P4.\n   A node's message will be propagated\
    \ to its parent, all siblings with\n   the same parent, and its children.  Since\
    \ a domain need not have a\n   direct peering session with every sibling, a MASC\
    \ domain must\n   propagate messages from a child domain to other children, can\n\
    \   propagate messages from a parent domain to other siblings, and, if a\n   Top-Level\
    \ Domain, it must propagate messages from a sibling to other\n   siblings, otherwise\
    \ may propagate messages from a sibling domain to\n   its parent and other siblings.\n"
- title: 4.1.  Managed vs Locally-Allocated Space
  contents:
  - "4.1.  Managed vs Locally-Allocated Space\n   Each domain has a \"Managed\" Address\
    \ Set, and a \"Locally-Allocated\"\n   Address Set.  The \"managed\" space includes\
    \ all address space which a\n   domain has successfully claimed via MASC.  The\
    \ \"locally-allocated\"\n   space, on the other hand, includes all address space\
    \ which MAASs\n   inside the domain may use.  Thus, the locally-allocated space\
    \ is a\n   subset of the managed space, and refers to the portion which a domain\n\
    \   allocates for its own use.\n   For leaf domains (ones with no children), these\
    \ two sets are\n   identical, since all claimed space is allocated for local use.\
    \  A\n   parent domain, on the other hand, \"manages\" all address space which\n\
    \   it has claimed via MASC, while sub-prefixes can be allocated to\n   itself\
    \ and to its children.\n"
- title: 4.2.  Prefix Lifetime
  contents:
  - "4.2.  Prefix Lifetime\n   Each prefix has an associated lifetime.  If a domain\
    \ wants to use a\n   prefix longer than its lifetime, that domain must \"renew\"\
    \ the prefix\n   BEFORE its lifetime expires (see Section 5.2).  If the lifetime\n\
    \   cannot be extended, then the domain should either retry later to\n   extend,\
    \ or should choose and claim another prefix.\n   After a prefix's lifetime expires,\
    \ MASC nodes in the domain that own\n   that prefix must stop using that prefix.\
    \  The corresponding entry\n   from the G-RIB database must be removed, and all\
    \ information\n   associated with the expired prefix may be deleted from the MASC\n\
    \   node's local memory.\n"
- title: 4.3.  Active vs. Deprecated Prefixes
  contents:
  - "4.3.  Active vs. Deprecated Prefixes\n   Each prefix advertised by a parent to\
    \ its children can be either\n   \"active\" or \"deprecated\".  A \"deprecated\"\
    \ prefix is a prefix that the\n   parent wishes to discontinue to use after its\
    \ lifetime expires.  The\n   \"active\" prefixes only are candidates for size\
    \ expansion or lifetime\n   extension.  Usually, this information will be used\
    \ by a child as a\n   hint to know which of the parent's prefixes might have their\
    \ lifetime\n   extended.\n"
- title: 4.4.  Multi-Parent Sibling-to-Sibling and Internal Peering
  contents:
  - "4.4.  Multi-Parent Sibling-to-Sibling and Internal Peering\n   Two sibling nodes\
    \ that have more than one common parent will create\n   and use between them a\
    \ number of transport-level connections, one per\n   each common parent.  The\
    \ information associated with a parent will be\n   sent over the connection that\
    \ corresponds to the same parent.\n   Internal peers do not need to open multiple\
    \ connections between them;\n   a single connection is used for all information.\n"
- title: 4.5.  Administratively-Scoped Address Allocation
  contents:
  - "4.5.  Administratively-Scoped Address Allocation\n   MASC can also be used for\
    \ sub-allocating prefixes of addresses within\n   an administrative scope zone\
    \ [SCOPE], but only if the scope is\n   \"divisible\" (as described in [MALLOC]\
    \ and [MZAP]).  A MASC node can\n   learn what scopes it resides within by listening\
    \ to MZAP [MZAP]\n   messages.\n   A \"Zone TLD\" is a domain which has no parent\
    \ domain within the scope\n   zone.  Zone TLDs act as TLDs for the prefix associated\
    \ with the\n   scope.  Figure 2 gives an example, where a scope boundary around\n\
    \   domains P3 and C5 has been added to Figure 1.  Domain P3 is a Zone\n   TLD,\
    \ since its only parent (T1) is outside the boundary.  Hence, P3\n   can claim\
    \ space directly out of the prefix associated with the scope\n   itself.  Domain\
    \ C5, on the other hand, has a parent within the scope\n   (namely, P3), and hence\
    \ is not a Zone TLD.\n                                 T1a-----------T2a\n   \
    \                               |             |\n                      ............|.......\
    \      |\n                      .           |      .      |\n                \
    \      .   P3a====P3b     .     P4a\n                      .    |      |     \
    \ .    /\n                      .    |      |   _______/\n                   \
    \   .    |      |  /   .\n                      .    |      | /    .\n       \
    \               .   C5a====C5b     .\n                      .     \\\\  //   \
    \    .\n                      .      \\\\//        .\n                      .\
    \      C5c         .\n                      .                  .\n           \
    \           . Admin Scope Zone .\n                      ....................\n\
    \                 Figure 2: Scope Zone Example\n   It is assumed that the role\
    \ of a node (as discussed in Section 4)\n   with respect to a given peering session\
    \ is the same for every scope\n   in which both ends are contained.  A peering\
    \ session that crosses a\n   scope boundary (such as the session between C5b and\
    \ P4a in Figure 2)\n   is ignored when propagating messages that pertain to the\
    \ given scope.\n   That is, such messages are not sent across such sessions.\n"
- title: 5.  Protocol Details
  contents:
  - '5.  Protocol Details

    '
- title: 5.1.  Claiming Space
  contents:
  - "5.1.  Claiming Space\n   When a MASC node, on behalf of a MASC domain, needs\
    \ more address\n   space, it decides locally the size and the value of the address\n\
    \   prefix(es) it will claim from one of its parents.  For example, the\n   decision\
    \ might be based on the knowledge this node has about its\n   parent's address\
    \ set, its siblings' claims and allocations, its own\n   address set, the claim\
    \ messages from its siblings, and/or the demand\n   pattern of its children and\
    \ the local domain.  A sample algorithm is\n   given in Appendix A.\n   A MASC\
    \ node which is not in a top-level domain can initiate a claim\n   toward a parent\
    \ MASC domain if and only if it currently has an\n   established connection with\
    \ at least one node in that parent domain.\n   After the prefix address and size\
    \ are decided, the claim proceeds as\n   follows:\n   a) The claim is scheduled\
    \ to be sent after a random delay in the\n      interval (0, [INITIATE_CLAIM_DELAY]).\
    \  If a claim originated by a\n      node from the same MASC domain is received,\
    \ and that claim\n      eliminates the need for the local claim, the local claim\
    \ is\n      canceled and no further action is taken.\n   b) The claim is sent\
    \ to one of the parents (if the domain is not a\n      top-level domain), all\
    \ known siblings with the same parent, and\n      all internal peers.  A Claim-Timer\
    \ is then started at\n      [WAITING_PERIOD], and the MASC node starts listening\
    \ for colliding\n      claims.\n   c) If a colliding claim is received while the\
    \ Claim-Timer is running,\n      that claim is compared with the locally initiated\
    \ claim using the\n      function described in Section 5.1.1.  If the local claim\
    \ is the\n      loser, a new prefix must be chosen to claim, and the loser claim's\n\
    \      Claim-Timer must be canceled.  The loser claim can be either\n      explicitly\
    \ withdrawn, or can be left to expire without taking\n      further actions. \
    \ If the winning claim was originated by a node\n      from the same MASC domain,\
    \ no new claim will be initiated.  If the\n      local claim is the winner, no\
    \ actions need to be taken.\n   d) If the Claim-Timer expires, the claimed prefix\
    \ becomes associated\n      with the claimer's domain, i.e. it is considered allocated\
    \ to that\n      domain and the following actions can be performed:\n      o \
    \ Advertise the prefix to its parent, and to all siblings with\n         the same\
    \ parent, by sending a PREFIX_IN_USE claim to them.\n      o  Inject the prefix\
    \ into the G-RIB of the inter-domain routing\n         protocol.\n      o  Send\
    \ a PREFIX_MANAGED message to all children and internal\n         peers, informing\
    \ them that they may issue claims within the\n         managed space.  A sub-prefix\
    \ may then be claimed for local\n         usage (see Section 12.2).\n   Each MASC\
    \ node receives all claims from its siblings and children.  A\n   received claim\
    \ must be evaluated against all claims saved in the\n   local cache using the\
    \ function described in Section 5.1.1.  The\n   output of the function will define\
    \ the further processing of that\n   claim (see Section 11).\n"
- title: 5.1.1.  Claim Comparison Function
  contents:
  - "5.1.1.  Claim Comparison Function\n   Each claim message includes:\n   o  a \"\
    type\", being one of: PREFIX_IN_USE, CLAIM_DENIED,\n      CLAIM_TO_EXPAND, or\
    \ NEW_CLAIM  (PREFIX_MANAGED and WITHDRAW are\n      not considered as claims\
    \ that have to be compared)\n   o  timestamp when the claim was initiated\n  \
    \ o  the claimed prefix and lifetime\n   o  MASC Identifier of the node that originated\
    \ the claim\n   When two claims are compared, first the type is compared based\
    \ on the\n   following precedence:\n   PREFIX_IN_USE > CLAIM_DENIED > CLAIM_TO_EXPAND\
    \ > NEW_CLAIM\n   If the type is the same, then the timestamps are used to compare\
    \ the\n   claims.  In practice, two claims will have the same type if the type\n\
    \   is either NEW_CLAIM (ordinary collision) or PREFIX_IN_USE (signal for\n  \
    \ a clash).  When the timestamps are compared, the claim with the\n   smallest,\
    \ i.e. earliest timestamp wins.  If the timestamps are the\n   same, then the\
    \ claim with the smallest Origin Node Identifier wins.\n"
- title: 5.2.  Renewing an Existing Claim
  contents:
  - "5.2.  Renewing an Existing Claim\n   The procedure for extending the lifetime\
    \ of prefixes already in use\n   is the same as claiming new space (see Section\
    \ 5.1), except that the\n   claim type must be CLAIM_TO_EXPAND, while the Address\
    \ and the Mask of\n   the claim (see Section 7.3) must be the same as the already\
    \ allocated\n   prefix.  If the Claim-Timer expires and there is no collision,\
    \ the\n   desired lifetime is assumed.\n"
- title: 5.3.  Expanding an Existing Prefix
  contents:
  - "5.3.  Expanding an Existing Prefix\n   The procedure for extending the lifetime\
    \ of prefixes already in use\n   is the same as claiming new space (see Section\
    \ 5.1), except that the\n   claim type must be CLAIM_TO_EXPAND, while the Address\
    \ and the Mask of\n   the claim (see Section 7.3) must be set to the desired values.\
    \  If\n   the Claim-Timer expires and there is no collision, the desired larger\n\
    \   prefix is associated with the local domain.\n"
- title: 5.4.  Releasing Allocated Space
  contents:
  - "5.4.  Releasing Allocated Space\n   If the lifetime of a prefix allocated to\
    \ the local domain expires and\n   the domain does not need to reuse it, all resources\
    \ associated with\n   this prefix are deleted and no further actions are taken.\
    \  If the\n   lifetime of the prefix has not expired, and if no subranges of that\n\
    \   prefix have being allocated for local usage or by some of the\n   children\
    \ domains, the space may be released by sending a withdraw\n   message to the\
    \ parent domain, all known siblings with the same\n   parent, and all internal\
    \ peers.\n"
- title: 6.  Constants
  contents:
  - "6.  Constants\n   MASC uses the following constants:\n   [PORT_NUMBER]\n    \
    \  2587.  The TCP port number used to listen for incoming MASC\n      connections,\
    \ as assigned by IANA.\n   [WAITING_PERIOD]\n      The amount of time (in seconds)\
    \ that must pass between a NEW_CLAIM\n      (or CLAIM_TO_EXPAND), and a PREFIX_IN_USE\
    \ for the same prefix.\n      This must be long enough to reasonably span any\
    \ single inter-\n      domain network partition.  Default: 172800 seconds (i.e.\
    \ 48\n      hours).\n   [INITIATE_CLAIM_DELAY]\n      The amount of time (in seconds)\
    \ a MASC node must wait before\n      initiating a new claim or a claim for space\
    \ expansion. This must\n      be a random value in the interval (0, [INITIATE_CLAIM_DELAY]).\n\
    \      Default value for [INITIATE_CLAIM_DELAY]: 600 seconds (i.e. 10\n      minutes).\n\
    \   [TLD_ID]\n      The Parent Domain Identifier used by a Top-Level Domain (which\
    \ has\n      no parent). Must be 0.\n   [HOLDTIME]\n      The amount of time (in\
    \ seconds) that must pass without any\n      messages received from a remote node\
    \ before considering the\n      connection is down.  Default: 240 seconds (i.e.\
    \ 4 minutes).\n"
- title: 7.  Message Formats
  contents:
  - "7.  Message Formats\n   This section describes message formats used by MASC.\n\
    \   Messages are sent over a reliable transport protocol connection.  A\n   message\
    \ is processed only after it is entirely received.  The maximum\n   message size\
    \ is 4096 octets.  All implementations are required to\n   support this maximum\
    \ message size.\n"
- title: 7.1.  Message Header Format
  contents:
  - "7.1.  Message Header Format\n   Each message has a fixed-size (4-octets) header.\
    \  There may or may\n   not be a data portion following the header, depending\
    \ on the message\n   type.  The layout of these fields is shown below:\n    0\
    \                   1                   2                   3\n    0 1 2 3 4 5\
    \ 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |          Length               |      Type     |   Reserved    |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   Length:\n      This 2-octet unsigned integer indicates the total length of\
    \ the\n      message, including the header, in octets.  Thus, e.g., it allows\n\
    \      one to locate in the transport-level stream the start of the next\n   \
    \   message.  The value of the Length field must always be at least 4\n      and\
    \ no greater than 4096, and may be further constrained,\n      depending on the\
    \ message type.  No \"padding\" of extra data after\n      the message is allowed,\
    \ so the Length field must have the smallest\n      value required given the rest\
    \ of the message.\n   Type:\n      This 1-octet unsigned integer indicates the\
    \ type code of the\n      message.  The following type codes are defined:\n  \
    \          1 - OPEN\n            2 - UPDATE\n            3 - NOTIFICATION\n  \
    \          4 - KEEPALIVE\n   Reserved:\n      This 1-octet field is reserved.\
    \  MUST be set to zero by the sender,\n      and MUST be ignored by the receiver.\n"
- title: 7.2.  OPEN Message Format
  contents:
  - "7.2.  OPEN Message Format\n   After a transport protocol connection is established,\
    \ the first\n   message sent by each side is an OPEN message.  If the OPEN message\
    \ is\n   acceptable, a KEEPALIVE message confirming the OPEN is sent back.\n \
    \  Once the OPEN is confirmed, UPDATE, KEEPALIVE, and NOTIFICATION\n   messages\
    \ may be exchanged.\n   The minimum length of the OPEN message is 20 octets (including\n\
    \   message header).  In addition to the fixed-size MASC header, the OPEN\n  \
    \ message contains the following fields:\n    0                   1          \
    \         2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0\
    \ 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |    Version    |R| AddrFam |Rol|           Hold Time           |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |         Sender Domain Identifier    (variable length)         |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |         Sender MASC Node Identifier (variable length)         |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |         Parent's Domain Identifier  (variable length)         |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                                                               |\n   +  \
    \                   (Optional Parameters)                     |\n   |        \
    \                                                       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   Version:\n      This 1-octet unsigned integer indicates the protocol version\n\
    \      number of the message.  The current MASC version number is 1.\n   R bit:\n\
    \      This 1-bit field is reserved.  MUST be set to zero by the sender,\n   \
    \   and MUST be ignored by the receiver.\n   AddrFam:\n      This 5-bit field\
    \ is the IANA-assigned address family number of the\n      encoded prefix [IANA].\
    \  These include (among others):\n      Number    Description\n      ------  \
    \  -----------\n         1      IP (IP version 4)\n         2      IPv6 (IP version\
    \ 6)\n   My Role (Rol):\n      This 2-bit field indicates the proposed relationship\
    \ of the\n      sending system to the receiving system:\n         00 = INTERNAL_PEER\
    \ (sent from one internal peer to another)\n         01 = CHILD (sent from a child\
    \ to its parent)\n         10 = SIBLING (sent from one sibling to another)\n \
    \        11 = PARENT (sent from a parent to its child)\n   Hold Time:\n      This\
    \ 2-octet unsigned integer indicates the number of seconds that\n      the sender\
    \ proposes for the value of the Hold Timer.  Upon receipt\n      of an OPEN message,\
    \ a MASC speaker MUST calculate the value of the\n      Hold Timer by using the\
    \ smaller of its configured Hold Time for\n      that peer and the Hold Time received\
    \ in the OPEN message.  The\n      Hold Time MUST be either zero or at least three\
    \ seconds.  An\n      implementation may reject connections on the basis of the\
    \ Hold\n      Time.  The calculated value indicates the maximum number of\n  \
    \    seconds that may elapse between the receipt of successive\n      KEEPALIVE\
    \ and/or UPDATE messages by the sender.  RECOMMENDED value\n      is [HOLDTIME]\
    \ seconds.\n   Sender Domain Identifier:\n      A globally unique identifier.\
    \  Its length is determined based on\n      the Address Family, and should be\
    \ treated as an unsigned integer\n      (e.g. a 4-octet integer for IPv4, or a\
    \ 16-octet integer for IPv6),\n      but must be at least 4 octets long.  It should\
    \ be set to the\n      Autonomous System number of the sender, but the network\
    \ unicast\n      prefix address is also acceptable.\n   Sender MASC Node Identifier:\n\
    \      This field's length and format are same as the Sender Domain\n      Identifier\
    \ field, and indicates the MASC Node Identifier of the\n      sender.  A given\
    \ MASC speaker sets the value of its MASC Node\n      Identifier to a globally-unique\
    \ value assigned to that MASC\n      speaker (e.g., an IPv4 or IPv6 address).\
    \  The value of the MASC\n      Node Identifier is determined on startup and is\
    \ the same for every\n      MASC session opened.\n   Parent's Domain Identifier:\n\
    \      This field's length and format are same as the Sender Domain\n      Identifier\
    \ field, and is set to the Domain Identifier of the\n      sender's parent (e.g.\
    \ the parent's Autonomous System number, or\n      network prefix address), or\
    \ is set to [TLD_ID] if the sender is a\n      TLD.  Used only when Rol is INTERNAL_PEER\
    \ or SIBLING, otherwise is\n      ignored.  This field is used to determine the\
    \ common parents\n      between siblings, to associate each sibling-to-sibling\
    \ connection\n      with a particular parent, and to discover TLD-related\n  \
    \    configuration problems among internal peers.  If a non-TLD node\n      does\
    \ not know yet the Domain ID of any of its parents, it can use\n      its own\
    \ Domain ID in the OPEN messages to its internal peers.\n   Optional Parameters:\n\
    \      This field may contain a list of optional parameters, where each\n    \
    \  parameter is encoded as a <Parameter Length, Parameter Type,\n      Parameter\
    \ Value> triplet.  The combined length of all optional\n      parameters can be\
    \ derived from the Length field in the message\n      header.\n       0      \
    \             1\n       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-...\n\
    \      |  Parm. Length |  Parm. Type   |  Parameter Value (variable)\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-...\n\
    \      Parameter Length is a one octet field that contains the length of\n   \
    \   the Parameter Value field in octets.  Parameter Type is a one\n      octet\
    \ field that unambiguously identifies individual parameters.\n      Parameter\
    \ Value is a variable length field that is interpreted\n      according to the\
    \ value of the Parameter Type field.  Unrecognized\n      optional parameters\
    \ MUST be silently ignored.\n      This document does not define any optional\
    \ parameters.\n"
- title: 7.3.  UPDATE Message Format
  contents:
  - "7.3.  UPDATE Message Format\n   UPDATE messages are used to transfer Claim/Collision/PrefixManaged\n\
    \   information between MASC speakers.  The UPDATE message always\n   includes\
    \ the fixed-size MASC header, and one or more attributes as\n   described below.\
    \  The minimum length of the UPDATE message is 40\n   octets (including the message\
    \ header).\n   Each attribute is of the form:\n    0                   1     \
    \              2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7\
    \ 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |              Length           |     Type      |   Reserved    |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |    Data ...                                                   |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   All attributes are 4-octets aligned.\n   Length:\n      The Length is the\
    \ length of the entire attribute, including the\n      length, type, and data\
    \ fields.  If other attributes are nested\n      within the data field, the length\
    \ includes the size of all such\n      nested attributes.\n   Type:\n      This\
    \ 1-octet unsigned integer indicates the type code of the\n      attribute.  The\
    \ following type codes are defined:\n         0 = PREFIX_IN_USE (prefix is being\
    \ used by the origin)\n         1 = CLAIM_DENIED (the claim is refused (probably\
    \ by the\n             origin's parent domain))\n         2 = CLAIM_TO_EXPAND\
    \ (origin is trying to expand the size of\n             an existing prefix)\n\
    \         3 = NEW_CLAIM (origin is trying to claim a new prefix)\n         4 =\
    \ PREFIX_MANAGED (parent is informing child of space\n             available)\n\
    \         5 = WITHDRAW (origin is withdrawing a previous claim)\n      Types 128-255\
    \ are reserved for \"optional\" attributes.  If a\n      required attribute is\
    \ unrecognized, a NOTIFICATION with UPDATE\n      Error Code and Unrecognized\
    \ Required Attribute subcode will be\n      sent.  Unrecognized optional attributes\
    \ are simply ignored.\n   Reserved:\n      This 1-octet field is reserved.  MUST\
    \ be set to zero by the\n      sender, and MUST be ignored by the receiver.\n\
    \   Types 0-3 are collectively called \"CLAIMs\".  The message format below\n\
    \   describes the encoding of a CLAIM, PREFIX_MANAGED and WITHDRAW.\n    0   \
    \                1                   2                   3\n    0 1 2 3 4 5 6\
    \ 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |   Reserved1   |D| AddrFam |Rol|           Reserved2           |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                    Claim Timestamp                            |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                    Claim Lifetime                             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                    Claim Holdtime                             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                    Origin Domain Identifier (variable length) |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                    Origin Node Identifier   (variable length) |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                    Address (variable length)                  |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                    Mask    (variable length)                  |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                                                               |\n   +  \
    \                   (Optional Parameters)                     |\n   |        \
    \                                                       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   Reserved1:\n      This 1-octet field is reserved.  MUST be set to zero by\
    \ the\n      sender, and MUST be ignored by the receiver.\n   D-bit:\n      DEPRECATED_PREFIX\
    \ bit. If set, indicates that the advertised\n      address prefix is Deprecated,\
    \ otherwise the prefix is Active (see\n      Section 4.3).\n   AddrFam:\n    \
    \  This 5-bit field is the IANA-assigned address family number of the\n      encoded\
    \ prefix [IANA].\n   Rol:\n      This 2-bit field indicates the relationship/role\
    \ of the Origin of\n      the message to the node sending that message:\n    \
    \     00 = INTERNAL (originated by the sender's domain)\n         01 = CHILD (originated\
    \ by a child of the sender's domain)\n         10 = SIBLING (originated by a sibling\
    \ of the sender's domain)\n         11 = PARENT (originated by a parent of the\
    \ sender's domain)\n   Reserved2:\n      This 2-octet field is reserved.  MUST\
    \ be set to zero by the\n      sender, and MUST be ignored by the receiver.\n\
    \   Claim Timestamp:\n      The timestamp of the claim when it was originated.\
    \ The timestamp\n      is expressed in number of seconds since midnight (0 hour),\
    \ January\n      1, 1970, Greenwich.\n   Claim Lifetime:\n      The time in seconds\
    \ between the Claim Timestamp, and the time at\n      which the prefix will become\
    \ free.\n   Claim Holdtime:\n      The time in seconds between the Claim Timestamp,\
    \ and the time at\n      which the claim should be deleted from the local cache.\
    \ For\n      PREFIX_IN_USE and PREFIX_MANAGED claims it should be equal to\n \
    \     Claim Lifetime; for CLAIM_TO_EXPAND, NEW_CLAIM, and CLAIM_DENIED\n     \
    \ it should be equal to [WAITING_PERIOD].\n   Origin Domain Identifier:\n    \
    \  The domain identifier of the claim originator.  Its length and\n      format\
    \ definition are same as the Sender Domain Identifier (see\n      Section 7.2).\n\
    \   Origin Node Identifier:\n      The MASC Node ID of the claim originator. \
    \ Its length and format\n      definition are same as the Sender MASC Node Identifier\
    \ (see\n      Section 7.2).\n   Address:\n      The address associated with the\
    \ given prefix to be encoded.  The\n      length is determined based on the Address\
    \ Family (e.g. 4 octets\n      for IPv4, 16 for IPv6)\n   Mask:\n      The mask\
    \ associated with the given prefix.  The length is the same\n      as the Address\
    \ field and is determined based on the Address\n      Family. The field contains\
    \ the full bitmask.\n   Optional Parameters:\n      This field may contain a list\
    \ of optional parameters, where each\n      parameter is encoded using same format\
    \ as the optional parameters\n      of an OPEN message (see Section 7.2).  Unrecognized\
    \ optional\n      parameters MUST be silently ignored.  This document does not\n\
    \      define any optional parameters.\n"
- title: 7.4.  KEEPALIVE Message Format
  contents:
  - "7.4.  KEEPALIVE Message Format\n   MASC does not use any transport protocol-based\
    \ keep-alive mechanism\n   to determine if peers are reachable.  Instead, KEEPALIVE\
    \ messages are\n   exchanged between peers often enough as not to cause the Hold\
    \ Timer\n   to expire.  A reasonable maximum time between the last KEEPALIVE or\n\
    \   UPDATE message sent, and the time at which a KEEPALIVE message is\n   sent,\
    \ would be one third of the Hold Time interval.  KEEPALIVE\n   messages MUST NOT\
    \ be sent more frequently than one per second.  An\n   implementation MAY adjust\
    \ the rate at which it sends KEEPALIVE\n   messages as a function of the Hold\
    \ Time interval.\n   If the negotiated Hold Time interval is zero, then periodic\
    \ KEEPALIVE\n   messages MUST NOT be sent.\n   A KEEPALIVE message consists of\
    \ only a message header, and has a\n   length of 4 octets.\n"
- title: 7.5.  NOTIFICATION Message Format
  contents:
  - "7.5.  NOTIFICATION Message Format\n   A NOTIFICATION message is sent when an\
    \ error condition is detected.\n   Depending on the error condition, the MASC\
    \ connection might or must\n   be closed immediately after sending the message.\
    \  If the sender of\n   the NOTIFICATION decides that the connection is to be\
    \ closed, it will\n   indicate this by zeroing the O-bit in the NOTIFICATION message\
    \ (see\n   below).\n   In addition to the fixed-size MASC header, the NOTIFICATION\
    \ message\n   contains the following fields:\n    0                   1      \
    \             2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8\
    \ 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |O| Error code  | Error subcode |           Data                |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\
    \                               +\n   |                                      \
    \                         |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   O-bit:\n      Open-bit.  If zero, it indicates that the sender will close\
    \ the\n      connection.  If '1', it indicates that the sender has chosen to\n\
    \      keep the connection open.\n   Error Code:\n      This 7-bit unsigned integer\
    \ indicates the type of NOTIFICATION.\n      The following Error Codes have been\
    \ defined:\n         Error Code       Symbolic Name               Reference\n\
    \           1         Message Header Error             Section 8.1\n         \
    \  2         OPEN Message Error               Section 8.2\n           3      \
    \   UPDATE Message Error             Section 8.3\n           4         Hold Timer\
    \ Expired               Section 8.4\n           5         Finite State Machine\
    \ Error       Section 8.5\n           6         NOTIFICATION Message Error   \
    \    Section 8.6\n           7         Cease                            Section\
    \ 8.7\n   Error subcode:\n      This 1-octet unsigned integer provides more specific\
    \ information\n      about the nature of the reported error.  Each Error Code\
    \ may have\n      one or more Error Subcodes associated with it.  If no appropriate\n\
    \      Error Subcode is defined, then a zero (Unspecific) value is used\n    \
    \  for the Error Subcode field, and the O-bit must be zero (i.e. the\n      connection\
    \ will be closed).  The notation used in the error\n      description below is:\
    \ MC = Must Close connection = O-bit is zero;\n      CC = Can Close connection\
    \ = O-bit might be zero.\n               Message Header Error subcodes:\n    \
    \                    0 - Unspecific                        (MC)\n            \
    \            1 - Bad Message Length                (MC)\n                    \
    \    2 - Bad Message Type                  (CC)\n               OPEN Message Error\
    \ subcodes:\n                        0 - Unspecific                        (MC)\n\
    \                        1 - Unsupported Version Number        (MC)\n        \
    \                2 - Bad Peer Domain ID                (MC)\n                \
    \        3 - Bad Peer MASC Node ID             (MC)\n                        6\
    \ - Unacceptable Hold Time            (MC)\n                        7 - Invalid\
    \ Parent Configuration      (MC)\n                        8 - Inconsistent Role\
    \                 (MC)\n                        9 - Bad Parent Domain ID     \
    \         (MC)\n                       10 - No Common Parent                 \
    \ (MC)\n                       13 - Unrecognized Address Family       (MC)\n \
    \              UPDATE Message Error subcodes:\n                        0 - Unspecific\
    \                        (MC)\n                        1 - Malformed Attribute\
    \ List          (MC)\n                        2 - Unrecognized Required Attribute\
    \   (CC)\n                        5 - Attribute Length Error            (MC)\n\
    \                       10 - Invalid Address field             (CC)\n        \
    \               11 - Invalid Mask field                (CC)\n                \
    \       12 - Non-Contiguous Mask               (CC)\n                       13\
    \ - Unrecognized Address Family       (MC)\n                       14 - Claim\
    \ Type Error                  (CC)\n                       15 - Origin Domain\
    \ ID Error            (CC)\n                       16 - Origin Node ID Error \
    \             (CC)\n                       17 - Claim Lifetime Too Short     \
    \     (CC)\n                       18 - Claim Lifetime Too Long           (CC)\n\
    \                       19 - Claim Timestamp Too Old           (CC)\n        \
    \               20 - Claim Timestamp Too New           (CC)\n                \
    \       21 - Claim Prefix Size Too Small       (CC)\n                       22\
    \ - Claim Prefix Size Too Large       (CC)\n                       23 - Illegal\
    \ Origin Role Error         (CC)\n                       24 - No Appropriate Parent\
    \ Prefix      (CC)\n                       25 - No Appropriate Child Prefix  \
    \     (CC)\n                       26 - No Appropriate Internal Prefix    (CC)\n\
    \                       27 - No Appropriate Sibling Prefix     (CC)\n        \
    \               28 - Claim Holdtime Too Short          (CC)\n                \
    \       29 - Claim Holdtime Too Long           (CC)\n         Hold Timer Expired\
    \ subcodes (the O-bit is always zero):\n                        0 - Unspecific\
    \                        (MC)\n               Finite State Machine Error subcodes:\n\
    \                        0 - Unspecific                        (MC)\n        \
    \                1 - Open/Close MASC Connection FSM Error (MC)\n             \
    \           2 - Unexpected Message Type FSM Error (MC)\n               Cease subcodes\
    \ (the O-bit is always zero):\n                        0 - Unspecific        \
    \                (MC)\n               NOTIFICATION subcodes (the O-bit is always\
    \ zero):\n                        0 - Unspecific                        (MC)\n\
    \   Data:\n      This variable-length field is used to diagnose the reason for\
    \ the\n      NOTIFICATION.  The contents of the Data field depend upon the\n \
    \     Error Code and Error Subcode.  See Section 8 for more details.\n      Note\
    \ that the length of the Data field can be determined from the\n      message\
    \ Length field by the formula:\n         Message Length = 6 + Data Length\n  \
    \    The minimum length of the NOTIFICATION message is 6 octets\n      (including\
    \ message header).\n"
- title: 8.  MASC Error Handling
  contents:
  - "8.  MASC Error Handling\n   This section describes actions to be taken when errors\
    \ are detected\n   while processing MASC messages.  MASC Error Handling is similar\
    \ to\n   that of BGP [BGP].\n   When any of the conditions described here are\
    \ detected, a\n   NOTIFICATION message with the indicated Error Code, Error Subcode,\n\
    \   and Data fields is sent.  In addition, the MASC connection might be\n   closed.\
    \  If no Error Subcode is specified, then a zero (Unspecific)\n   must be used.\n\
    \   The phrase \"the MASC connection is closed\" means that the transport\n  \
    \ protocol connection has been closed and that all resources for that\n   MASC\
    \ connection have been deallocated.\n   Unless specified explicitly, the Data\
    \ field of the NOTIFICATION\n   message is empty.\n"
- title: 8.1.  Message Header Error Handling
  contents:
  - "8.1.  Message Header Error Handling\n   All errors detected while processing\
    \ the Message Header are indicated\n   by sending the NOTIFICATION message with\
    \ Error Code Message Header\n   Error.  The Error Subcode elaborates on the specific\
    \ nature of the\n   error.  The Data field contains the erroneous Message (including\
    \ the\n   message header).\n   If the Length field of the message header is less\
    \ than 4 or greater\n   than 4096, or if the length of an OPEN message is less\
    \  than the\n   minimum length of the OPEN message, or if the length of an UPDATE\n\
    \   message is less than the minimum length of the UPDATE message, or if\n   the\
    \ length of a KEEPALIVE message is not equal to 4, then the Error\n   Subcode\
    \ is set to Bad Message Length.\n   If the Type field of the message header is\
    \ not recognized, then the\n   Error Subcode is set to Bad Message Type.\n"
- title: 8.2.  OPEN Message Error Handling
  contents:
  - "8.2.  OPEN Message Error Handling\n   All errors detected while processing the\
    \ OPEN message are indicated\n   by sending the NOTIFICATION message with Error\
    \ Code OPEN Message\n   Error.  The Error Subcode elaborates on the specific nature\
    \ of the\n   error.  The Data field contains the erroneous OPEN Message (excluding\n\
    \   the Message Header), unless stated otherwise.\n   If the version number contained\
    \ in the Version field of the received\n   OPEN message is not supported, then\
    \ the Error Subcode is set to\n   Unsupported Version Number.  The Data field\
    \ is a 1-octet unsigned\n   integer, which indicates the largest locally supported\
    \ version number\n   less than the version the remote MASC node bid (as indicated\
    \ in the\n   received OPEN message).\n   If the Sender Domain Identifier field\
    \ of the OPEN message is\n   unacceptable, then the Error Subcode is set to Bad\
    \ Peer Domain ID.\n   The determination of acceptable Domain IDs is outside the\
    \ scope of\n   this protocol.\n   If the Sender MASC Node Identifier field of\
    \ the OPEN message is\n   unacceptable, then the Error Subcode is set to Bad Peer\
    \ MASC Node ID.\n   The determination of acceptable Node IDs is outside the scope\
    \ of this\n   protocol.\n   If the Hold Time field of the OPEN message is unacceptable,\
    \ then the\n   Error Subcode MUST be set to Unacceptable Hold Time.  An\n   implementation\
    \ MUST reject Hold Time values of one or two seconds.\n   An implementation MAY\
    \ reject any proposed Hold Time.  An\n   implementation which accepts a Hold Time\
    \ MUST use the negotiated\n   value for the Hold Time.\n   If the remote system's\
    \ proposed Role is INTERNAL_PEER, and either\n   (but not both) the local system\
    \ or the remote system's Parent Domain\n   ID is [TLD_ID], then the Error Subcode\
    \ is set to Invalid Parent\n   Configuration.  The Data field must be filled with\
    \ all the local\n   system's Parent Domain IDs.\n   If the remote system's proposed\
    \ Role conflicts with its expected role\n   (based on the local system's configured\
    \ Role), then the Error Subcode\n   is set to Inconsistent Role.  The Data field\
    \ is 1-octet long, and\n   contains the local system's configured Role.\n   If\
    \ the remote system's Parent Domain ID is unacceptable, then the\n   Error Subcode\
    \ is set to Bad Parent Domain ID, and the Data field is\n   filled with the erroneous\
    \ Parent Domain ID.  The determination of\n   acceptable Parent Domain ID is outside\
    \ the scope of this protocol.\n   If the remote system is supposed to be a sibling,\
    \ but it does not\n   have a common parent with the local system (based on the\
    \ Parent\n   Domain ID information in the OPEN message), the Error Subcode is\
    \ set\n   to No Common Parent, and the Data field is filled with all Parent\n\
    \   Domain IDs of the local MASC domain.\n   If the Address Family is unrecognized,\
    \ then the Error Subcode is set\n   to Unrecognized Address Family.\n"
- title: 8.3.  UPDATE Message Error Handling
  contents:
  - "8.3.  UPDATE Message Error Handling\n   All errors detected while processing\
    \ the UPDATE message are indicated\n   by sending the NOTIFICATION message with\
    \ Error Code UPDATE Message\n   Error.  The error subcode elaborates on the specific\
    \ nature of the\n   error.  The Data field contains the erroneous UPDATE Message\n\
    \   (including the attribute header, but excluding the Message Header),\n   unless\
    \ stated otherwise.\n   If any recognized attribute has an Attribute Length that\
    \ conflicts\n   with the expected length (based on the attribute type code), then\
    \ the\n   Error Subcode is set to Attribute Length Error.\n   If any of the mandatory\
    \ well-known attributes are not recognized,\n   then the Error Subcode is set\
    \ to Unrecognized Required Attribute.\n   If the Address field includes an invalid\
    \ address (except 0), then the\n   Error Subcode is set to Invalid Address.\n\
    \   If the Mask field includes an invalid mask (for example, starting\n   with\
    \ 0), then the Error Subcode is set to Invalid Mask.\n   If the Mask field includes\
    \ a non-contiguous bitmask, and that MASC\n   server does not support, or is not\
    \ configured to use non-contiguous\n   masks, then the Error Subcode is set to\
    \ Non-Contiguous Mask.\n   If the Address Family is unrecognized, then the Error\
    \ Subcode is set\n   to Unrecognized Address Family.\n   If the Origin Role/Claim\
    \ Type combination is not one of the\n   following, then the Error Subcode is\
    \ set to Claim Type Error.\n      Origin  Claim\n      Role    Type\n      ICS\
    \     PREFIX_IN_USE   (0)\n      I  P    CLAIM_DENIED    (1)\n      ICS     CLAIM_TO_EXPAND\
    \ (2)\n      ICS     NEW_CLAIM       (3)\n      I  P    PREFIX_MANAGED  (4)\n\
    \      ICSP    WITHDRAW        (5)\n   If there is a reason to believe that the\
    \ Origin Domain ID is invalid,\n   then the Error Subcode is set to Origin Domain\
    \ ID Error.  The same\n   applies for Origin Node ID (the corresponding error\
    \ is Origin Node ID\n   Error).\n   If a node (usually a parent receiving a claim\
    \ from a child) decides\n   that the Claim Lifetime is too short (for example,\
    \ less than 172800,\n   i.e. 48 hours), it MAY send an UPDATE Message Error with\
    \ subcode\n   Claim Lifetime Too Short.\n   If a node (usually a parent receiving\
    \ a claim from a child) decides\n   that the Claim Lifetime is too long (for example,\
    \ more than\n   15,768,000, i.e. half year), then it MAY send an UPDATE Message\
    \ Error\n   with subcode Claim Lifetime Too Long.  Note that usually a parent\n\
    \   MASC node should send first CLAIM_DENIED collision messages with\n   Claim\
    \ Lifetime field filled with the longest acceptable lifetime.  If\n   the child\
    \ refuses to claim with shorter lifetime, then Claim Lifetime\n   Too Long should\
    \ be sent.\n   If a node (usually a parent receiving a claim from a child) decides\n\
    \   that the Claim Timestamp is too small, i.e. too old (for example, if\n   a\
    \ node is self-confident that its clock is quite accurate), then it\n   MUST send\
    \ an UPDATE Message Error with subcode Claim Timestamp Too\n   Old.  Claim Timestamp\
    \ Too New is defined similarly.\n   If a node (usually a parent receiving a claim\
    \ from a child) decides\n   that the prefix size implied by the Mask field is\
    \ too small (for\n   example, smaller than 16 addresses), then it MAY send an\
    \ UPDATE\n   Message Error with subcode Claim Prefix Size Too Small.\n   If a\
    \ node (usually a parent receiving a claim from a child) decides\n   that the\
    \ prefix size implied by the Mask field is too large, then it\n   MAY send an\
    \ UPDATE Message Error with subcode Claim Prefix Size Too\n   Large.  Note that\
    \ usually a parent MASC node should send first\n   CLAIM_DENIED collision messages\
    \ for some subrange of the child's\n   large claimed address range.  If the child\
    \ refuses to shrink the\n   claim size, then Claim Prefix Size Too Large should\
    \ be sent.\n   If the received UPDATE message's computed Updated Origin Role is\n\
    \   illegal (see Table 1 in Section 11.1), then the Error Subcode is set\n   to\
    \ Illegal Origin Role Error.\n   If the received UPDATE message needs to be associated\
    \ with a parent's\n   prefix, but the association is not successful, then the\
    \ Error Subcode\n   is set to No Appropriate Parent Prefix.  The No Appropriate\
    \ Child\n   Prefix, No Appropriate Internal Prefix, and No Appropriate Sibling\n\
    \   Prefix Error Subcodes are defined similarly.\n   If a node decides that the\
    \ Claim Holdtime is too short (for example,\n   just few seconds), it MAY send\
    \ an UPDATE Message Error with subcode\n   Claim Holdtime Too Short.\n   If a\
    \ node decides that the Claim Holdtime is too long (for example,\n   more than\
    \ 15,768,000, i.e. half year), then it SHOULD send an UPDATE\n   Message Error\
    \ with subcode Claim Holdtime Too Long.\n   If any other error is encountered\
    \ when processing attributes, then\n   the Error Subcode is set to Malformed Attribute\
    \ List, and the erratic\n   attribute is included in the data field.\n"
- title: 8.4.  Hold Timer Expired Error Handling
  contents:
  - "8.4.  Hold Timer Expired Error Handling\n   If a system does not receive successive\
    \ KEEPALIVE and/or UPDATE\n   and/or NOTIFICATION messages within the period specified\
    \ in the Hold\n   Time field of the OPEN message, then the NOTIFICATION message\
    \ with\n   Hold Timer Expired Error Code must be sent and the MASC connection\n\
    \   closed.\n"
- title: 8.5.  Finite State Machine Error Handling
  contents:
  - "8.5.  Finite State Machine Error Handling\n   Any error detected by the MASC\
    \ Finite State Machine (e.g., receipt of\n   an unexpected event) is indicated\
    \ by sending the NOTIFICATION message\n   with Error Code Finite State Machine\
    \ Error.  The Error Subcode\n   elaborates on the specific nature of the error.\n"
- title: 8.6.  NOTIFICATION Message Error Handling
  contents:
  - "8.6.  NOTIFICATION Message Error Handling\n   If a node sends a NOTIFICATION\
    \ message, and there is an error in that\n   message, and the O-bit of that message\
    \ is not zero, a NOTIFICATION\n   with O-bit zeroed, Error Code of NOTIFICATION\
    \ Error, and subcode\n   Unspecific must be sent.  In addition, the Data field\
    \ must include\n   the erratic NOTIFICATION message.  However, if the erratic\n\
    \   NOTIFICATION message had the O-bit zeroed, then any error, such as an\n  \
    \ unrecognized Error Code or Error Subcode, should be noticed, logged\n   locally,\
    \ and brought to the attention of the administrator of the\n   remote node.  The\
    \ means to do this, however, lies outside the scope\n   of this document.\n"
- title: 8.7.  Cease
  contents:
  - "8.7.  Cease\n   In absence of any fatal errors (that are indicated in this section),\n\
    \   a MASC node may choose at any given time to close its MASC connection\n  \
    \ by sending the NOTIFICATION message with Error Code Cease.  However,\n   the\
    \ Cease NOTIFICATION message must not be used when a fatal error\n   indicated\
    \ by this section does exist.\n"
- title: 8.8.  Connection Collision Detection
  contents:
  - "8.8.  Connection Collision Detection\n   If a pair of MASC speakers try simultaneously\
    \ to establish a TCP\n   connection to each other, then two parallel connections\
    \ between this\n   pair of speakers might well be formed.  We refer to this situation\
    \ as\n   connection collision.  Clearly, one of these connections must be\n  \
    \ closed.  Note that if the nodes were siblings, and each of those\n   connections\
    \ was associated with a different parent, then we do not\n   consider this situation\
    \ as collision (see Section 4.4).\n   Based on the value of the MASC Node Identifier\
    \ a convention is\n   established for detecting which MASC connection is to be\
    \ preserved\n   when a connection collision does occur.  The convention is to\
    \ compare\n   the MASC Node Identifiers of the remote nodes involved in the\n\
    \   collision and to retain only the connection initiated by the MASC\n   speaker\
    \ with the higher-valued MASC Node Identifier.\n   Upon receipt of an OPEN message,\
    \ the local system must examine all of\n   its connections that are in the OpenConfirm\
    \ state.  A MASC speaker\n   may also examine connections in an OpenSent state\
    \ if it knows the\n   MASC Node Identifier of the remote node by means outside\
    \ of the\n   protocol.  If among these connections there is a connection to a\n\
    \   remote MASC speaker whose MASC Node Identifier equals the one in the\n   OPEN\
    \ message, and, in case of a sibling-to-sibling connection, the\n   Parent Domain\
    \ ID of that connection equals the one in the OPEN\n   message, then the local\
    \ system performs the following connection\n   collision resolution procedure:\n\
    \   1. The MASC Node Identifier of the local system is compared to the\n     \
    \ MASC Node Identifier of the remote system (as specified in the\n      OPEN message).\
    \  Comparing MASC Node Identifiers is done by\n      treating them as unsigned\
    \ integers (e.g. 4-octets long for IPv4\n      and 16-octets long for IPv6).\n\
    \   2. If the value of the local MASC Node Identifier is less than the\n     \
    \ remote one, the local system closes MASC connection that already\n      exists\
    \ (the one that is already in the OpenConfirm state), and\n      accepts the MASC\
    \ connection initiated by the remote system.\n   3. Otherwise, the local system\
    \ closes the newly created MASC\n      connection (the one associated with the\
    \ newly received OPEN\n      message), and continues to use the existing one (the\
    \ one that is\n      already in the OpenConfirm state).\n   A connection collision\
    \ with an existing MASC connection that is in\n   the Established state causes\
    \ unconditional closing of the newly\n   created connection.  Note that a connection\
    \ collision cannot be\n   detected with connections that are in Idle, or Connect,\
    \ or Active\n   states (see Section 10).\n   Closing the MASC connection (that\
    \ results from the collision\n   resolution procedure) is accomplished by sending\
    \ the NOTIFICATION\n   message with the Error Code Cease.\n"
- title: 9.  MASC Version Negotiation
  contents:
  - "9.  MASC Version Negotiation\n   MASC speakers may negotiate the version of the\
    \ protocol by making\n   multiple attempts to open a MASC connection, starting\
    \ with the\n   highest version number each supports.  If an open attempt fails\
    \ with\n   an Error Code OPEN Message Error, and an Error Subcode Unsupported\n\
    \   Version Number, then the MASC speaker has available the version\n   number\
    \ it tried, the version number the remote node tried, the\n   version number passed\
    \ by the remote node in the NOTIFICATION message,\n   and the version numbers\
    \ that it supports.  If the two MASC speakers\n   do support one or more common\
    \ versions, then this will allow them to\n   rapidly determine the highest common\
    \ version. In order to support\n   MASC version negotiation, future versions of\
    \ MASC must retain the\n   format of the OPEN and NOTIFICATION messages.\n"
- title: 10.  MASC Finite State Machine
  contents:
  - "10.  MASC Finite State Machine\n   This section specifies MASC operation in terms\
    \ of a Finite State\n   Machine (FSM).  The FSM and the operations are peer peering\
    \ session.\n   Following is a brief summary and overview of MASC operations by\
    \ state\n   as determined by this FSM.\n   Initially the peering session is in\
    \ the Idle state.\n"
- title: 10.1.  Open/Close MASC Connection FSM
  contents:
  - "10.1.  Open/Close MASC Connection FSM\n   Idle state:\n      In this state MASC\
    \ refuses all incoming MASC connections from the\n      peer.  No resources are\
    \ allocated to the remote node.  In response\n      to the Start event (initiated\
    \ by either system or operator) the\n      local system initializes all MASC resources,\
    \ starts the\n      ConnectRetry timer, initiates a transport connection to the\
    \ remote\n      node, while listening for a connection that may be initiated by\n\
    \      the remote MASC node, and changes its state to Connect.  The exact\n  \
    \    value of the ConnectRetry timer is a local matter, but should be\n      sufficiently\
    \ large to allow TCP initialization.\n      If a MASC speaker detects an error,\
    \ it shuts down the connection\n      and changes its state to Idle. Getting out\
    \ of the Idle state\n      requires generation of the Start event.  If such an\
    \ event is\n      generated automatically, then persistent MASC errors may result\
    \ in\n      persistent flapping of the speaker.  To avoid such a condition it\n\
    \      is recommended that Start events should not be generated\n      immediately\
    \ for a node that was previously transitioned to Idle\n      due to an error.\
    \ For a node that was previously transitioned to\n      Idle due to an error,\
    \ the time between consecutive generation of\n      Start events, if such events\
    \ are generated automatically, shall\n      exponentially increase. The value\
    \ of the initial timer shall be 60\n      seconds. The time shall be doubled for\
    \ each consecutive retry, but\n      shall not be longer than 24 hours.\n    \
    \  Any other event received in the Idle state is ignored.\n   Connect state:\n\
    \      In this state MASC is waiting for the transport protocol\n      connection\
    \ to be completed.\n      If the transport protocol connection succeeds, the local\
    \ system\n      clears the ConnectRetry timer, completes initialization, sends\
    \ an\n      OPEN message to the remote node, and changes its state to\n      OpenSent.\
    \ If the transport protocol connect fails (e.g.,\n      retransmission timeout),\
    \ the local system restarts the\n      ConnectRetry timer, continues to listen\
    \ for a connection that may\n      be initiated by the remote MASC node, and changes\
    \ its state to\n      Active state.\n      In response to the ConnectRetry timer\
    \ expired event, the local\n      system restarts the ConnectRetry timer, initiates\
    \ a transport\n      connection to the other MASC node, continues to listen for\
    \ a\n      connection that may be initiated by the remote MASC node, and\n   \
    \   stays in the Connect state.\n      The Start event is ignored in the Connect\
    \ state.\n      In response to any other event (initiated by either system or\n\
    \      operator), the local system releases all MASC resources associated\n  \
    \    with this connection and changes its state to Idle.\n   Active state:\n \
    \     In this state MASC is trying to acquire a remote node by listening\n   \
    \   for a transport protocol connection initiated by the remote node.\n      If\
    \ the transport protocol connection succeeds, the local system\n      clears the\
    \ ConnectRetry timer, completes initialization, sends an\n      OPEN message to\
    \ the remote node, sets its Hold Timer to a large\n      value, and changes its\
    \ state to OpenSent.  A Hold Timer value of\n      [HOLDTIME] seconds is suggested.\n\
    \      In response to the ConnectRetry timer expired event, the local\n      system\
    \ restarts the ConnectRetry timer, initiates a transport\n      connection to\
    \ other MASC node, continues to listen for a\n      connection that may be initiated\
    \ by the remote MASC node, and\n      changes its state to Connect.\n      If\
    \ the local system detects that a remote node is trying to\n      establish a\
    \ MASC connection to it, and the IP address of the\n      remote node is not an\
    \ expected one, the local system restarts the\n      ConnectRetry timer, rejects\
    \ the attempted connection, continues to\n      listen for a connection that may\
    \ be initiated by the remote MASC\n      node, and stays in the Active state.\n\
    \      The Start event is ignored in the Active state.\n      In response to any\
    \ other event (initiated by either system or\n      operator), the local system\
    \ releases all MASC resources associated\n      with this connection and changes\
    \ its state to Idle.\n   OpenSent state:\n      In this state MASC waits for an\
    \ OPEN message from the remote node.\n      When an OPEN message is received,\
    \ all fields are checked for\n      correctness.  If the MASC message header checking\
    \ or OPEN message\n      checking detects an error (see Section 8.2), or a connection\n\
    \      collision (see Section 8.8) the local system sends a NOTIFICATION\n   \
    \   message and, if the connection is to be closed, it changes its\n      state\
    \ to Idle.\n      If the locally configured role is SIBLING and there is no parent\n\
    \      domain with Domain ID equal to the Parent Domain ID in the OPEN\n     \
    \ message, the local system sends a NOTIFICATION Open Message  Error\n      with\
    \ Error Subcode set to No Common Parent, the connection must be\n      closed,\
    \ and the state of the local system must be changed to Idle.\n      If there are\
    \ no errors in the OPEN message, MASC sends a KEEPALIVE\n      message and sets\
    \ a KeepAlive timer.  The Hold Timer, which was\n      originally set to a large\
    \ value (see above), is replaced with the\n      negotiated Hold Time value (see\
    \ Section 7.2).  If the negotiated\n      Hold Time value is zero, then the Hold\
    \ Time timer and KeepAlive\n      timers are not started.  If the value of the\
    \ MASC Domain ID field\n      is the same as the local MASC Domain ID, and if\
    \ the Role field of\n      the OPEN message is set to INTERNAL_PEER, then the\
    \ connection is\n      an \"internal\" connection; otherwise, it is \"external\"\
    .  Finally,\n      the state is changed to OpenConfirm.\n      If a disconnect\
    \ notification is received from the underlying\n      transport protocol, the\
    \ local system closes the MASC connection,\n      restarts the ConnectRetry timer,\
    \ while continue listening for\n      connection that may be initiated by the\
    \ remote MASC node, and goes\n      into the Active state.\n      If the Hold\
    \ Timer expires, the local system sends a NOTIFICATION\n      message with error\
    \ code Hold Timer Expired and changes its state\n      to Idle.\n      In response\
    \ to the Stop event (initiated by either system or\n      operator) the local\
    \ system sends a NOTIFICATION message with Error\n      Code Cease and changes\
    \ its state to Idle.\n      The Start event is ignored in the OpenSent state.\n\
    \      In response to any other event the local system sends a\n      NOTIFICATION\
    \ message with Error Code Finite State Machine Error\n      and Error Subcode\
    \ Open/Close MASC Connection FSM Error, and\n      changes its state to Idle.\n\
    \      Whenever MASC changes its state from OpenSent to Idle, it closes\n    \
    \  the MASC (and transport-level) connection and releases all\n      resources\
    \ associated with that connection.\n   OpenConfirm state:\n      In this state\
    \ MASC waits for a KEEPALIVE or NOTIFICATION message.\n      If the local system\
    \ receives a KEEPALIVE message, it changes its\n      state to Established.\n\
    \      If the Hold Timer expires before a KEEPALIVE message is received,\n   \
    \   the local system sends a NOTIFICATION message with error code Hold\n     \
    \ Timer Expired and changes its state to Idle.\n      If the local system receives\
    \ a NOTIFICATION message with the O-bit\n      zeroed, it changes its state to\
    \ Idle.\n      If the KeepAlive timer expires, the local system sends a KEEPALIVE\n\
    \      message and restarts its KeepAlive timer.\n      If a disconnect notification\
    \ is received from the underlying\n      transport protocol, the local system\
    \ changes its state to Idle.\n      In response to the Stop event (initiated by\
    \ either system or\n      operator) the local system sends a NOTIFICATION message\
    \ with Error\n      Code Cease and changes its state to Idle.\n      The Start\
    \ event is ignored in the OpenConfirm state.\n      In response to any other event\
    \ the local system sends a\n      NOTIFICATION message with Error Code Finite\
    \ State Machine Error\n      and Error Subcode Unspecific, and changes its state\
    \ to Idle.\n      Whenever MASC changes its state from OpenConfirm to Idle, it\n\
    \      closes the MASC (and transport-level) connection and releases all\n   \
    \   resources associated with that connection.\n   Established state:\n      In\
    \ the Established state MASC can exchange UPDATE, NOTIFICATION,\n      and KEEPALIVE\
    \ messages with the remote node.\n      If the local system receives an UPDATE,\
    \ or KEEPALIVE message, or\n      NOTIFICATION message with O-bit set, it restarts\
    \ its Hold Timer,\n      if the negotiated Hold Time value is non-zero.\n    \
    \  If the local system receives a NOTIFICATION message, with the O-\n      bit\
    \ zeroed, it changes its state to Idle.\n      If the local system receives an\
    \ UPDATE message and the UPDATE\n      message error handling procedure (see Section\
    \ 8.3) detects an\n      error, the local system sends a NOTIFICATION message\
    \ and, if the\n      O-bit was zeroed, changes its state to Idle.\n      If a\
    \ disconnect notification is received from the underlying\n      transport protocol,\
    \ the local system changes its state to Idle.\n      If the Hold Timer expires,\
    \ the local system sends a NOTIFICATION\n      message with Error Code Hold Timer\
    \ Expired and changes its state\n      to Idle.\n      If the KeepAlive timer\
    \ expires, the local system sends a KEEPALIVE\n      message and restarts its\
    \ KeepAlive timer.\n      Each time the local system sends a KEEPALIVE or UPDATE\
    \ message, it\n      restarts its KeepAlive timer, unless the negotiated Hold\
    \ Time\n      value is zero.\n      In response to the Stop event (initiated by\
    \ either system or\n      operator), the local system sends a NOTIFICATION message\
    \ with\n      Error Code Cease and changes its state to Idle.\n      The Start\
    \ event is ignored in the Established state.\n      After entering the Established\
    \ state, if the local system has\n      UPDATE messages that are to be sent to\
    \ the remote node, they must\n      be sent immediately (see Section 11.8).\n\
    \      In response to any other event, the local system sends a\n      NOTIFICATION\
    \ message with Error Code Finite State Machine Error\n      with the O-bit zeroed\
    \ and Error Subcode Unspecific, and changes\n      its state to Idle.\n      Whenever\
    \ MASC changes its state from Established to Idle, it\n      closes the MASC (and\
    \ transport-level) connection, releases all\n      resources associated with that\
    \ connection, and deletes all state\n      derived from that connection.\n"
- title: 11.  UPDATE Message Processing
  contents:
  - "11.  UPDATE Message Processing\n   The UPDATE message are accepted only when\
    \ the system is in the\n   Established state.\n   In the text below, a MASC domain\
    \ is considered a child of itself with\n   regard to the claims that are related\
    \ to the address space with local\n   usage purpose (i.e. to be used by the MAASs\
    \ within that domain).  For\n   example, a NEW_CLAIM initiated by a MASC node\
    \ to obtain more space\n   for local usage from a prefix managed by that domain\
    \ will have field\n   Role = CHILD.\n   If an UPDATE is to be propagated further,\
    \ it should not be sent back\n   to the node that UPDATE was received from, unless\
    \ there is an\n   indication that the connection to that node was down and then\n\
    \   restored.\n   If the local system receives an UPDATE message, and there is\
    \ no\n   indication for error, it checks whether to accept or reject the\n   message,\
    \ and if it is not rejected, the UPDATE is processed based on\n   its type.\n\
    \   If an UPDATE message must be associated with a parent domain, then\n   there\
    \ must be a PREFIX_MANAGED by some parent domain for a prefix\n   that covers\
    \ the prefix of the particular UPDATE.\n"
- title: 11.1.  Accept/Reject an UPDATE
  contents:
  - "11.1.  Accept/Reject an UPDATE\n   The Origin Role field is first compared against\
    \ the local system's\n   configured Role, according to Table 1, to determine the\
    \ relationship\n   of the origin to the local system, where Locally-Configured\
    \ Role is\n   the local configuration with regard to the peer-forwarder of the\n\
    \   message.  A result of \"---\" means that receiving such an UPDATE is\n   illegal\
    \ and should generate a NOTIFICATION.  Any other result is the\n   value to use\
    \ as the \"Updated\" Origin Role when propagating the UPDATE\n   to others.  This\
    \ is analogous to updating a metric upon receiving a\n   route, based on the metric\
    \ of the link.\n                       Locally-Configured Role\n   Origin\n  \
    \ Role     || INTERNAL_PEER | CHILD   | SIBLING | PARENT\n   =========++===============+=========+=========+=========\n\
    \   INTERNAL || INTERNAL_PEER | PARENT  | SIBLING | CHILD\n   CHILD    || CHILD\
    \         | SIBLING | ---     | ---\n   SIBLING  || SIBLING       | ---     |\
    \ SIBLING | CHILD\n   PARENT   || PARENT        | ---     | PARENT  | ---\n  \
    \              Table 1: Updated Origin Role Computation\n   After the Origin Role\
    \ is updated, the following additional processing\n   needs to be applied:\n \
    \  o  If the output from the Updated Origin Role Computation is SIBLING,\n   \
    \   but the Origin Domain ID is the same as the local MASC domain, the\n     \
    \ Updated Origin Role is changed to INTERNAL.  This is necessary in\n      case\
    \ a MASC node receives from a parent or sibling its own UPDATEs\n      after reboot,\
    \ or if because of internal partitioning, the\n      INTERNAL_PEERs are exchanging\
    \ UPDATEs via other MASC domains\n      (either parent or sibling(s)).\n   o \
    \ If both Locally-Configured Role, and Origin Role are equal to\n      PARENT,\
    \ and the Origin Domain ID is the same as the local MASC\n      domain, the Updated\
    \ Origin Role is changed to INTERNAL.  This is\n      necessary to allow a parent\
    \ to receive its own UPDATEs through its\n      own children, although the parent\
    \ might drop those UPDATEs if it\n      has a reason not to believe its children.\n\
    \   o  If both Locally-Configured Role, and Origin Role are equal to\n      PARENT,\
    \ and the Origin Domain ID is the same as the remote MASC\n      domain, and the\
    \ UPDATE type is CLAIM_DENIED, the Updated Origin\n      Role is changed to INTERNAL.\
    \  This is necessary to allow a parent\n      to receive the CLAIM_DENIED it has\
    \ originated through the child\n      whose claim was denied.  If the Origin Domain\
    \ ID is not same as\n      the remote MASC domain, but is same as some of the\
    \ other MASC\n      children domains, the Updated Origin Role still should be\
    \ changed\n      to INTERNAL, although the parent might drop this UPDATE if it\
    \ has\n      a reason not to believe a third party child.\n   If the Updated Origin\
    \ Role is INTERNAL, but the Origin Domain ID\n   differs from the local Domain\
    \ ID, a NOTIFICATION of <UPDATE Message\n   Error, Illegal Origin Role> must be\
    \ sent back, and the claim is\n   rejected.\n   If Claim Timestamp and Claim Holdtime\
    \ indicate that the claim has\n   expired (e.g. Timestamp + Claim Holdtime <=\
    \ CurrentTime), the UPDATE\n   is silently dropped and no further actions are\
    \ taken.\n   Each new arrival UPDATE is compared with all claims in the local\n\
    \   cache.  The following fields are compared, and if all of them are the\n  \
    \ same, the message is silently rejected and no further actions are\n   taken:\n\
    \   o  Role, D-bit, Type\n   o  AddrFam\n   o  Claim Timestamp\n   o  Claim Lifetime\n\
    \   o  Claim Holdtime\n   o  Origin Domain Identifier\n   o  Origin Node Identifier\n\
    \   o  Address\n   o  Mask\n   Further processing of an UPDATE is based on its\
    \ type and the Updated\n   Origin Role.\n"
- title: 11.2.  PREFIX_IN_USE Message Processing
  contents:
  - '11.2.  PREFIX_IN_USE Message Processing

    '
- title: 11.2.1.  PREFIX_IN_USE by PARENT
  contents:
  - "11.2.1.  PREFIX_IN_USE by PARENT\n   The claim is rejected, and a NOTIFICATION\
    \ of <UPDATE Message Error,\n   Illegal Origin Role> should be sent back.\n"
- title: 11.2.2.  PREFIX_IN_USE by SIBLING
  contents:
  - "11.2.2.  PREFIX_IN_USE by SIBLING\n   If the claim cannot be associated with\
    \ any parent's PREFIX_MANAGED,\n   the claim is dropped, a NOTIFICATION of <UPDATE\
    \ Message Error, No\n   Appropriate Parent Prefix> must be sent back and no further\
    \ actions\n   should be taken.\n   If the claim collides with some of the local\
    \ domain's pending claims,\n   the local claims must not be considered further,\
    \ and the Claim-Timer\n   of each of them must be canceled. If the received PREFIX_IN_USE\
    \ claim\n   clashes with and wins over some of the local domain's allocated\n\
    \   prefixes, resolve the clash according to Section 12.4. Finally, the\n   claim\
    \ must be propagated further to all INTERNAL_PEERs, all MASC\n   nodes from the\
    \ corresponding parent MASC domain and all known\n   siblings with the same parent\
    \ domain.\n"
- title: 11.2.3.  PREFIX_IN_USE by CHILD
  contents:
  - "11.2.3.  PREFIX_IN_USE by CHILD\n   If the claim's prefix is not a subrange of\
    \ any of the local domain's\n   PREFIX_MANAGED, the claim is dropped, a NOTIFICATION\
    \ of <UPDATE\n   Message Error, No Appropriate Parent Prefix> must be sent back\
    \ and no\n   further actions should be taken.  Otherwise, the claim must be\n\
    \   propagated further to all INTERNAL_PEERs and all MASC children\n   domains.\n"
- title: 11.2.4.  PREFIX_IN_USE by INTERNAL_PEER
  contents:
  - "11.2.4.  PREFIX_IN_USE by INTERNAL_PEER\n   If the MASC node decides that the\
    \ local domain does not need that\n   prefix any more, it may be withdrawn, otherwise,\
    \ the claim is\n   processed as PREFIX_MANAGED.\n"
- title: 11.3.  CLAIM_DENIED Message Processing
  contents:
  - '11.3.  CLAIM_DENIED Message Processing

    '
- title: 11.3.1.  CLAIM_DENIED by CHILD or SIBLING
  contents:
  - "11.3.1.  CLAIM_DENIED by CHILD or SIBLING\n   The message is rejected, and a\
    \ NOTIFICATION of <UPDATE Message Error,\n   Illegal Origin Role> should be sent\
    \ back.\n"
- title: 11.3.2.  CLAIM_DENIED by INTERNAL_PEER
  contents:
  - "11.3.2.  CLAIM_DENIED by INTERNAL_PEER\n   Propagate to all INTERNAL_PEERs and\
    \ all MASC children nodes.\n"
- title: 11.3.3.  CLAIM_DENIED by PARENT
  contents:
  - "11.3.3.  CLAIM_DENIED by PARENT\n   If the Origin Domain ID is not same as the\
    \ local domain ID, and the\n   UPDATE cannot be associated with any parent domain,\
    \ the message is\n   dropped, a NOTIFICATION of <UPDATE Message Error, No Appropriate\n\
    \   Parent Prefix> must be sent back and no further actions should be\n   taken.\n\
    \   If the Origin Domain ID is not same as the local domain ID, and the\n   UPDATE\
    \ can be associated with a parent domain, the message is\n   propagated to all\
    \ nodes from that parent domain, all INTERNAL_PEERs,\n   and all known SIBLINGs\
    \ with regard to that parent.\n   If the Origin Domain ID is same as the local\
    \ domain ID, and there is\n   no corresponding pending claim originated by the\
    \ local MASC domain\n   (i.e. a NEW_CLAIM or CLAIM_TO_EXPAND with same AddrFam,\
    \ Origin Domain\n   ID, Claim Timestamp, Address and Mask), a NOTIFICATION of\
    \ <UPDATE\n   Message Error, No Appropriate Internal Prefix> must be sent back\
    \ and\n   no further actions should be taken. Otherwise, the matching NEW_CLAIM\n\
    \   or CLAIM_TO_EXPAND's Claim-Timer must be canceled and the claim must\n   not\
    \ be considered further. Finally, the received CLAIM_DENIED must be\n   propagated\
    \ to all INTERNAL_PEERs, all MASC nodes from the\n   corresponding parent MASC\
    \ domain, and all known SIBLINGs with regard\n   to that parent.\n"
- title: 11.4.  CLAIM_TO_EXPAND Message Processing
  contents:
  - '11.4.  CLAIM_TO_EXPAND Message Processing

    '
- title: 11.4.1.  CLAIM_TO_EXPAND by PARENT
  contents:
  - "11.4.1.  CLAIM_TO_EXPAND by PARENT\n   The claim is rejected, and a NOTIFICATION\
    \ of <UPDATE Message Error,\n   Illegal Origin Role> should be sent back.\n"
- title: 11.4.2.  CLAIM_TO_EXPAND by SIBLING
  contents:
  - "11.4.2.  CLAIM_TO_EXPAND by SIBLING\n   If the claim cannot be associated with\
    \ any parent's PREFIX_MANAGED,\n   the claim is dropped, a NOTIFICATION of <UPDATE\
    \ Message Error, No\n   Appropriate Parent Prefix> must be sent back and no further\
    \ actions\n   should be taken.\n   If there is no overlapping PREFIX_IN_USE by\
    \ the same MASC domain, the\n   claim is dropped, a NOTIFICATION of <UPDATE Message\
    \ Error, No\n   Appropriate Sibling Prefix> must be sent back and no further actions\n\
    \   should be taken.\n   If the claim collides with and wins over some of the\
    \ local domain's\n   pending claims, the loser claims must not be considered further,\
    \ and\n   the Claim-Timer of the each of them must be canceled.  Also, the\n \
    \  received claim must be propagated further to all INTERNAL_PEERs, all\n   MASC\
    \ nodes from the corresponding parent MASC domain and all known\n   siblings with\
    \ the same parent domain.\n"
- title: 11.4.3.  CLAIM_TO_EXPAND by CHILD
  contents:
  - "11.4.3.  CLAIM_TO_EXPAND by CHILD\n   If the claim cannot be associated with\
    \ any of the local domain's\n   PREFIX_MANAGED, the claim is dropped, a NOTIFICATION\
    \ of <UPDATE\n   Message Error, No Appropriate Parent Prefix> must be sent back\
    \ and no\n   further actions should be taken.\n   If there is no overlapping PREFIX_IN_USE\
    \ by the same MASC domain, the\n   claim is dropped, a NOTIFICATION of <UPDATE\
    \ Message Error, No\n   Appropriate Child Prefix> must be sent back and no further\
    \ actions\n   should be taken.\n   Otherwise, the claim has to be propagated to\
    \ all INTERNAL_PEERs.  If\n   the lifetime of the claim is longer than the lifetime\
    \ of the\n   corresponding prefix managed by the local domain, or if there is\
    \ an\n   administratively configured reason to prevent the child from\n   succeeding\
    \ allocating the claimed prefix, a CLAIM_DENIED must be sent\n   to all MASC children\
    \ nodes that have same Domain ID as Origin Domain\n   ID in the received message.\
    \  The CLAIM_DENIED must be the same as the\n   received claim, except Rol=INTERNAL,\
    \ and Claim Lifetime should be set\n   to the maximum allowed lifetime.  Otherwise,\
    \ propagate the claim to\n   all children as well.\n"
- title: 11.4.4.  CLAIM_TO_EXPAND by INTERNAL_PEER
  contents:
  - "11.4.4.  CLAIM_TO_EXPAND by INTERNAL_PEER\n   If the claim cannot be associated\
    \ with any parent's PREFIX_MANAGED,\n   the claim is dropped, a NOTIFICATION of\
    \ <UPDATE Message Error, No\n   Appropriate Parent Prefix> must be sent back and\
    \ no further action\n   should be taken.\n   If there is no overlapping PREFIX_IN_USE\
    \ by the local MASC domain,\n   the claim is dropped, a NOTIFICATION of <UPDATE\
    \ Message Error, No\n   Appropriate Internal Prefix> must be sent back and no\
    \ further actions\n   should be taken.\n   If the MASC node decides that the local\
    \ domain does not need that\n   pending claim any more, it MAY be withdrawn. Otherwise,\
    \ the claim\n   must be propagated to all INTERNAL_PEERs and all MASC nodes from\
    \ the\n   corresponding parent MASC domain.\n"
- title: 11.5.  NEW_CLAIM Message Processing
  contents:
  - "11.5.  NEW_CLAIM Message Processing\n   If the claim's Address field is 0 (i.e.\
    \ a hint by a child to a parent\n   to obtain more space), the claim should be\
    \ propagated only among the\n   nodes that belong to the child Origin Domain and\
    \ the parent domain.\n   Otherwise, process like CLAIM_TO_EXPAND, except that\
    \ no check for\n   overlapping PREFIX_IN_USE needs to be performed.\n"
- title: 11.6.  PREFIX_MANAGED Message Processing.
  contents:
  - '11.6.  PREFIX_MANAGED Message Processing.

    '
- title: 11.6.1.  PREFIX_MANAGED by PARENT
  contents:
  - "11.6.1.  PREFIX_MANAGED by PARENT\n   If the Origin Domain ID matches one of\
    \ the parents' domain ID's, the\n   prefix is recorded, and can be used by the\
    \ address allocation\n   algorithm for allocating subranges.  Also, the message\
    \ is propagated\n   to all MASC nodes of the corresponding parent domain, all\n\
    \   INTERNAL_PEERs, and SIBLINGs with same parent.\n"
- title: 11.6.2.  PREFIX_MANAGED by CHILD or SIBLING
  contents:
  - "11.6.2.  PREFIX_MANAGED by CHILD or SIBLING\n   The message is rejected, and\
    \ a NOTIFICATION of <UPDATE Message Error,\n   Illegal Origin Role> should be\
    \ sent back.\n"
- title: 11.6.3.  PREFIX_MANAGED by INTERNAL_PEER
  contents:
  - "11.6.3.  PREFIX_MANAGED by INTERNAL_PEER\n   The prefix is recorded as allocated\
    \ to the local domain, propagated\n   to all INTERNAL_PEERs, and can be used for\
    \ (all items apply):\n   a) address ranges/prefixes advertisements to all MASC\
    \ children and\n      local domain's MAASs;\n   b) injection into G-RIB;\n   c)\
    \ further expansion by the address allocation algorithm (see\n      Appendix A);\n"
- title: 11.7.  WITHDRAW Message Processing
  contents:
  - '11.7.  WITHDRAW Message Processing

    '
- title: 11.7.1.  WITHDRAW by CHILD
  contents:
  - "11.7.1.  WITHDRAW by CHILD\n   If the WITHDRAW cannot be associated with any\
    \ of the child domain's\n   PREFIX_IN_USE (i.e. no child's PREFIX_IN_USE covers\
    \ WITHDRAW's\n   range), or if the WITHDRAW does not match any of the child domain's\n\
    \   NEW_CLAIM or CLAIM_TO_EXPAND (i.e. there is no child's claim with\n   same\
    \ Address, Mask and Timestamp), the message is dropped, a\n   NOTIFICATION of\
    \ <UPDATE Message Error, No Appropriate Child Prefix>\n   must be sent back and\
    \ no further actions should be taken. Otherwise,\n   propagate to all INTERNAL_PEERs\
    \ and children.\n"
- title: 11.7.2.  WITHDRAW by SIBLING
  contents:
  - "11.7.2.  WITHDRAW by SIBLING\n   If the WITHDRAW cannot be associated with any\
    \ of the siblings'\n   PREFIX_IN_USE (i.e. no sibling's PREFIX_IN_USE covers WITHDRAW's\n\
    \   range), or if the WITHDRAW does not match any of the sibling domain's\n  \
    \ NEW_CLAIM or CLAIM_TO_EXPAND (i.e. there is no sibling's claim with\n   same\
    \ Address, Mask and Timestamp), the message is dropped, a\n   NOTIFICATION of\
    \ <UPDATE Message Error, No Appropriate Sibling Prefix>\n   must be sent back\
    \ and no further actions should be taken. Otherwise,\n   propagate to all INTERNAL_PEERs,\
    \ all MASC nodes from the same parent\n   MASC domain and all known siblings with\
    \ the same parent domain.\n"
- title: 11.7.3.  WITHDRAW by INTERNAL
  contents:
  - "11.7.3.  WITHDRAW by INTERNAL\n   If the WITHDRAW cannot be associated with any\
    \ of the local domain's\n   PREFIX_IN_USE or PREFIX_MANAGED (i.e. no local domain's\
    \ prefix covers\n   WITHDRAW's range), or if the WITHDRAW does not match any of\
    \ the local\n   domain's NEW_CLAIM or CLAIM_TO_EXPAND (i.e. there is no local\n\
    \   domain's claim with same Address, Mask and Timestamp) the message is\n   dropped,\
    \ a NOTIFICATION of <UPDATE Message Error, No Appropriate\n   Internal Prefix>\
    \ must be sent back and no further actions should be\n   taken.\n   Otherwise,\
    \ propagate to all INTERNAL_PEERs, all MASC nodes of the\n   corresponding parent\
    \ domain of that prefix, all known siblings with\n   that parent domain, and all\
    \ children.  If the WITHDRAW can be\n   associated with some of local domain's\
    \ PREFIX_IN_USE or\n   PREFIX_MANAGED, stop advertising the WITHDRAW range to\
    \ the MAASs and\n   withdraw that range from the G-RIB database.  In the special\
    \ case\n   when there is an indication that the WITHDRAW has been originated by\n\
    \   the local domain because of a clash, and the range specified in\n   WITHDRAW\
    \ is a subrange of the local PREFIX_MANAGED, and the Claim\n   Holdtime of WITHDRAW\
    \ is shorter than the Claim Holdtime of\n   PREFIX_MANAGED, the WITHDRAW's range\
    \ should not be withdrawn from the\n   G-RIB.  If the WITHDRAW matches a local\
    \ domain's NEW_CLAIM or\n   CLAIM_TO_EXPAND, cancel the matching claim's Claim-Timer.\n"
- title: 11.7.4.  WITHDRAW by PARENT
  contents:
  - "11.7.4.  WITHDRAW by PARENT\n   If the WITHDRAW cannot be associated with any\
    \ parent domain, a\n   NOTIFICATION of <UPDATE Message Error, No Appropriate Parent\
    \ Prefix>\n   must be sent back and no further actions should be taken.\n   Otherwise,\
    \ propagate to all INTERNAL_PEERs and all known siblings\n   with the same parent\
    \ domain. Also, originate a WITHDRAW message for\n   each intersection of a locally\
    \ owned PREFIX_MANAGED/PREFIX_IN_USE and\n   the received WITHDRAW.  The locally\
    \ originated WITHDRAW message's\n   Claim Holdtime should be at least equal to\
    \ the Claim Holdtime in the\n   WITHDRAW message received from the parent; the\
    \ Origin Node ID should\n   be the same as the particular PREFIX_MANAGED/PREFIX_IN_USE.\n"
- title: 11.8.  UPDATE Message Ordering
  contents:
  - "11.8.  UPDATE Message Ordering\n   To simplify consistency and sanity check implementations,\
    \ if there is\n   more than one UPDATE message that needs to be send to a peer\
    \ (for\n   example, after a connection (re)establishment), some of the UPDATEs\n\
    \   must be sent before others.\n   The rules that always apply are:\n   o  PREFIX_IN_USE\
    \ must always be sent BEFORE CLAIM_TO_EXPAND,\n      NEW_CLAIM, and WITHDRAW by\
    \ the same MASC domain\n   o  WITHDRAW must always be sent AFTER PREFIX_IN_USE,\
    \ CLAIM_TO_EXPAND,\n      NEW_CLAIM, and PREFIX_MANAGED by the same MASC domain\n\
    \   Any further ordering is defined below by the roles of the sender and\n   the\
    \ receiver.\n"
- title: 11.8.1.  Parent to Child
  contents:
  - "11.8.1.  Parent to Child\n   Messages are sent in the following order:\n   1)\
    \ Parent's PREFIX_MANAGED and WITHDRAWs.\n   2) All children's PREFIX_IN_USE,\
    \ CLAIM_TO_EXPAND, and NEW_CLAIMs.\n      CLAIMs from third party children that\
    \ are hints for more space\n      (i.e. address = 0) should not be propagated;\
    \ if propagated, the\n      child should drop them.\n   3) Parent initiated CLAIM_DENIED\
    \ and children initiated WITHDRAWs.\n      CLAIM_DENIED regarding third party\
    \ children's claims/hints with\n      address = 0 should not be propagated; if\
    \ propagated, the child\n      should drop them.\n"
- title: 11.8.2.  Child to Parent
  contents:
  - "11.8.2.  Child to Parent\n   Messages are sent in the following order:\n   1)\
    \ Parent's PREFIX_MANAGED and WITHDRAWs.\n   2) All PREFIX_IN_USE, CLAIM_TO_EXPAND,\
    \ and NEW_CLAIMSs from that\n      parent's space, initiated by that child and\
    \ all its siblings.\n   3) Parent's initiated CLAIM_DENIED, and all WITHDRAWSs\
    \ that can be\n      associated with that parent's space and are initiated by\
    \ the local\n      domain or all known siblings with that parent.\n"
- title: 11.8.3.  Sibling to Sibling
  contents:
  - "11.8.3.  Sibling to Sibling\n   Messages are sent in the following order:\n \
    \  1) All common parent's PREFIX_MANAGED and WITHDRAWs.\n   2) PREFIX_IN_USE,\
    \ CLAIM_TO_EXPAND, and NEW_CLAIMs, initiated by\n      siblings.\n   3) CLAIM_DENIEDs\
    \ initiated by common parent, and WITHDRAWs initiated\n      by local domain and\
    \ all known siblings with that parent.\n"
- title: 11.8.4.  Internal to Internal
  contents:
  - "11.8.4.  Internal to Internal\n   Messages are sent in the following order:\n\
    \   1) All parents' PREFIX_MANAGED and WITHDRAWs.\n   2) Local domain's and all\
    \ siblings' PREFIX_IN_USE, CLAIM_TO_EXPAND,\n      and NEW_CLAIMs.  CLAIMs from\
    \ siblings that are hints for more\n      space (i.e. address = 0) should not\
    \ be propagated; if propagated,\n      the recipient should drop them.\n   3)\
    \ CLAIM_DENIEDs initiated by all parents, and WITHDRAWs initiated by\n      local\
    \ domain and all known siblings.\n   4) All children's PREFIX_IN_USE, CLAIM_TO_EXPAND,\
    \ and NEW_CLAIMs.\n   5) All local domain initiated CLAIM_DENIED regarding children\
    \ claims\n      and all children initiated WITHDRAWs.\n"
- title: 12.  Operational Considerations
  contents:
  - '12.  Operational Considerations

    '
- title: 12.1.  Bootup Operations
  contents:
  - "12.1.  Bootup Operations\n   To learn about its parent domains' IDs and prefixes,\
    \ a MASC node\n   SHOULD try to establish connections to its PARENT nodes before\n\
    \   initiating a connection to a SIBLING node.  To avoid learning about\n   its\
    \ own PREFIX_MANAGED from its children or siblings, a MASC node\n   SHOULD try\
    \ to establish connections to its PARENT nodes and\n   INTERNAL_PEER nodes before\
    \ initiating a connection to a CHILD or\n   SIBLING node.\n"
- title: 12.2.  Leaf and Non-leaf MASC Domain Operation
  contents:
  - "12.2.  Leaf and Non-leaf MASC Domain Operation\n   A non-leaf MASC domain (i.e.\
    \ a domain that has children domains)\n   should advertise its PREFIX_MANAGED\
    \ addresses to its children, and\n   should claim from that space the sub-ranges\
    \ that would be advertised\n   to the internal MAASs (the claim wait time SHOULD\
    \ be equal to\n   [WAITING_PERIOD]).  A MASC node that belongs to a non-leaf MASC\n\
    \   domain should perform dual functions by being a child of itself with\n   regard\
    \ to the claiming and management of the sub-ranges for local\n   usage.  A leaf\
    \ MASC domain should advertise all PREFIX_MANAGED\n   addresses to its MAASs without\
    \ explicitly claiming them for internal\n   usage.  A MASC node can assume that\
    \ it belongs to a leaf domain if it\n   simply does not have any UPDATEs by children\
    \ domains.  If an UPDATE\n   by a child is received, the domain MUST switch from\
    \ \"leaf\" to \"non-\n   leaf\" mode, and if it needs more addresses for internal\
    \ usage, it\n   MUST claim them from that domain's PREFIX_MANAGED.  After the\
    \ last\n   UPDATE originated by a child expires, the domain can switch back to\n\
    \   \"leaf\" mode.\n"
- title: 12.3.  Clock Skew Workaround
  contents:
  - "12.3.  Clock Skew Workaround\n   Each UPDATE has \"Claim Timestamp\" field that\
    \ is set to the absolute\n   time of the MASC node that originated that UPDATE.\
    \ The timestamp is\n   used for two purposes: to resolve collisions, and to define\
    \ how long\n   an UPDATE should be kept in the local cache of other MASC nodes.\
    \ A\n   skew in the clock could result in unfair collision decision such that\n\
    \   the claims originated by nodes that have their clock behind the real\n   time\
    \ will always win; however, because collisions are presumably\n   rare, this will\
    \ not be an issue.  Skew in the clock however might\n   result in expiring an\
    \ UPDATE earlier than it really should be\n   expired, and a node might assume\
    \ too early that the expired\n   UPDATE/prefix is free for allocation. To compensate\
    \ for the clock\n   skew, an UPDATE message should be kept longer than the amount\
    \ of time\n   specified in the Claim Holdtime. For example, keeping UPDATEs for\
    \ an\n   additional 24 hours will compensate for clock skew for up to 24\n   hours.\n"
- title: 12.4.  Clash Resolving Mechanism
  contents:
  - "12.4.  Clash Resolving Mechanism\n   If a MASC node receives a PREFIX_IN_USE\
    \ claim originated by a sibling\n   and the claim overlaps with some of the local\
    \ prefixes, the clash\n   must be resolved.  Two MASC domains should not manage\
    \ overlapping\n   address ranges, unless the domains have an ancestor-descendant\
    \ (e.g.\n   parent-child) relationship in the MASC hierarchy.  Also, two MASC\n\
    \   domains should not have locally-allocated overlapping address ranges.\n  \
    \ The clashed address ranges should not be advertised to the MAASs and\n   allocated\
    \ to multicast applications/sessions.  If a clashed address\n   has being allocated\
    \ to an application, the application should be\n   informed to stop using that\
    \ address and switch to a new one.\n   The G-RIB database must be consistent,\
    \ such that it does not have\n   ambiguous entries.  \"Ambiguous G-RIB entries\"\
    \ are those entries that\n   might cause the multicast routing protocol to loop\
    \ or lose\n   connectivity.  In MASC the WITHDRAW message is used to solve this\n\
    \   problem.  When a clashing PREFIX_IN_USE is received, it is compared\n   (using\
    \ the function describe in Section 5.1.1) against all prefixes\n   allocated to\
    \ the local domain.  If the local PREFIX_IN_USE is the\n   winner, no further\
    \ actions are taken.  If the local PREFIX_IN_USE is\n   the loser, the clashing\
    \ address range must be withdrawn by initiating\n   a WITHDRAW message. The message\
    \ must have Role = INTERNAL, Origin\n   Node ID and Origin Domain ID must be the\
    \ same as the corresponding\n   local PREFIX_IN_USE message, while Claim Timestamp,\
    \ Claim Lifetime,\n   Claim Holdtime, Address and Mask must be the same as the\
    \ received\n   winning PREFIX_IN_USE.  The initiated WITHDRAW message must be\n\
    \   processed as described in Section 11.7.\n   If a cached WITHDRAW times out\
    \ and the local MASC domain owns an\n   overlapping PREFIX_MANAGED or PREFIX_IN_USE,\
    \ the overlapping prefix\n   ranges can be injected back into the G-RIB database.\
    \  Similarly, the\n   address ranges that were not advertised to the local domain's\
    \ MAASs\n   due to the WITHDRAW, can now be advertised again.\n   In addition\
    \ to the automatic resolving of clashes, a MASC\n   implementation should support\
    \ manual resolving of clashes.  For\n   example, after a clash is detected, the\
    \ network administrator should\n   be informed that a clash has occurred.  The\
    \ specific manual\n   mechanisms are outside the scope of this protocol.\n   A\
    \ MASC node must be configured to operate using either manual or\n   automatic\
    \ clash resolution mechanisms.\n"
- title: 12.5.  Changing Network Providers
  contents:
  - "12.5.  Changing Network Providers\n   If a MASC domain changes a network provider,\
    \ such that the old\n   provider cannot be used to provide connectivity, any traffic\
    \ for\n   sessions that are in progress and use that MASC domain as the root of\n\
    \   multicast distribution trees will not be able to reach that domain.\n   If\
    \ the new network provider is willing to carry the traffic for the\n   old sessions\
    \ rooted at the customer domain, then it must propagate\n   the customer's old\
    \ prefixes through the G-RIB.  However, at least one\n   MASC node in the customer\
    \ domain must maintain a TCP connection to\n   one of the old network provider's\
    \ MASC nodes.  Thus, it can continue\n   to \"defend\" the customer's prefixes,\
    \ and should continue until the\n   old prefixes' lifetimes expire.\n   If the\
    \ new network provider is not willing to propagate the old\n   prefixes, then\
    \ the customer should remove its prefixes from the G-\n   RIB.  If BGMP is in\
    \ use, the old network provider's domain will\n   automatically become the Root\
    \ Domain for the customer's old groups\n   due to the lack of a more specific\
    \ group route.  MASC nodes in the\n   customer domain MAY still connect with the\
    \ old provider's MASC nodes\n   to defend their allocation.\n"
- title: 12.6.  Debugging
  contents:
  - '12.6.  Debugging

    '
- title: 12.6.1.  Prefix-to-Domain Lookup
  contents:
  - "12.6.1.  Prefix-to-Domain Lookup\n   Use mtrace [MTRACE] to find the BGMP/MASC\
    \ root domain for a group\n   address chosen from that prefix.\n"
- title: 12.6.2.  Domain-to-Prefix Lookup
  contents:
  - "12.6.2.  Domain-to-Prefix Lookup\n   We can find the address space allocated\
    \ to a particular MASC domain\n   by directly querying one of the MASC servers\
    \ within that domain, by\n   observing the state in parents, siblings, or children\
    \ MASC domains,\n   or by observing the G-RIB information originated by that domain.\n\
    \   From those three methods, the first method can provide the most\n   detailed\
    \ information. Finding the address of one of the MASC nodes\n   within a particular\
    \ domain is outside the scope of MASC.\n"
- title: 13.  MASC Storage
  contents:
  - "13.  MASC Storage\n   In general, MASC will be run by a border routers, which,\
    \ in general\n   do not have stable storage.  In this case, MASC must use the\
    \ Layer 2\n   protocol/mechanism (e.g., ([AAP]) as described in [MALLOC] to store\n\
    \   the important information (the prefixes allocated by the local\n   domain)\
    \ in the domain's MAASs who should have stable storage.  If the\n   MASC speaker\
    \ has local storage, it should use it instead of the Layer\n   2 protocol/mechanism.\
    \  Claims that are in progress do not have to be\n   saved by using the Layer\
    \ 2 protocol/mechanism.\n"
- title: 14.  Security Considerations
  contents:
  - "14.  Security Considerations\n   IPsec [IPSEC] can be used to address security\
    \ concerns between two\n   MASC peering nodes.  However, because of the store-and-forward\
    \ nature\n   of the UPDATE messages, it is possible that if a non-trustworthy\
    \ MASC\n   node can connect to some point of the MASC topology, then this node\n\
    \   can undetectably inject malicious UPDATEs that may disturb the normal\n  \
    \ operation of other MASC nodes.  To address this problem, each MASC\n   node\
    \ should allow peering only with trustworthy nodes.\n   After a reboot, a MASC\
    \ node/domain can restore its state from its\n   neighbors (internal peers, parents,\
    \ siblings, children). Typically,\n   the state received from a parent or internal\
    \ peer will be\n   trustworthy, but a node may choose to drop its own UPDATEs\
    \ that were\n   received through a sibling or a child.\n   A misbehaving node\
    \ may attempt a Denial of Service attack by sending\n   a large number of colliding\
    \ messages that would prevent any of its\n   siblings from allocating more addresses.\
    \  A single mis-behaving node\n   can easily be identified by all of its siblings,\
    \ and all of its\n   UPDATEs can be ignored.  A Denial of Service attack that\
    \ uses\n   multiple origin addresses can be prevented if a third-party UPDATE\n\
    \   (e.g. by a non-directly connected sibling) is accepted only if it is\n   sent\
    \ via the common parent domain, and the MASC nodes in the parent\n   domain accept\
    \ children UPDATEs only if they come via an internal\n   peer, or come directly\
    \ from a child node that is same as the Origin\n   Node ID.\n"
- title: 15.  IANA Considerations
  contents:
  - "15.  IANA Considerations\n   This document defines several number spaces (MASC\
    \ message types, MASC\n   OPEN message optional parameters types, MASC UPDATE\
    \ message attribute\n   types, MASC UPDATE message optional parameters types,\
    \ and MASC\n   NOTIFICATION message error codes and subcodes).  For all of these\n\
    \   number spaces, certain values are defined in this specification.  New\n  \
    \ values may only be defined by IETF Consensus, as described in [IANA-\n   CONSIDERATIONS].\
    \  Basically, this means that they are defined by RFCs\n   approved by the IESG.\n"
- title: 16.  Acknowledgments
  contents:
  - "16.  Acknowledgments\n   The authors would like to thank the participants of\
    \ the IETF for\n   their assistance with this protocol.\n"
- title: '17.  APPENDIX A: Sample Algorithms'
  contents:
  - "17.  APPENDIX A: Sample Algorithms\n   DISCLAIMER: This section describes some\
    \ preliminary suggestions by\n   various people for algorithms which could be\
    \ used with MASC.\n"
- title: 17.1.  Claim Size and Prefix Selection Algorithm
  contents:
  - "17.1.  Claim Size and Prefix Selection Algorithm\n   This section covers the\
    \ algorithms used by a MASC node (on behalf of\n   a MASC domain) to satisfy the\
    \ demand for multicast addresses.  The\n   allocated addresses should be aggregatable,\
    \ the address utilization\n   should be reasonably high, and the allocation latency\
    \ to the MAASs\n   should be shorter than [WAITING_PERIOD] whenever possible.\n"
- title: 17.1.1.  Prefix Expansion
  contents:
  - "17.1.1.  Prefix Expansion\n   For ease of implementation and troubleshooting,\
    \ MASC should use\n   contiguous masks to specify the address ranges, i.e. prefixes.\n\
    \   (Research indicates that sufficiently good results can be achieved\n   using\
    \ contiguous masks only.)  The chosen prefixes should be as\n   expandable as\
    \ possible.  The method used to choose the children sub-\n   prefixes from the\
    \ parent's prefix is the so called Reverse Bit\n   Ordering (idea by Dave Thaler;\
    \ inspired by Kampai [KAMPAI]).  For\n   example, if the parent's prefix width\
    \ is four bits, the addresses of\n   the sub-prefixes are chosen in the following\
    \ order:\n   Parent:       xxxx\n   Child A:      0000\n   Child B:      1000\n\
    \   Child C:      0100\n   Child D:      1100\n   If some of the children need\
    \ to expand their sub-prefix, they try to\n   double the corresponding sub-prefix\
    \ starting from the right:\n   Child A:      000x\n   Child A:      00xx\n   Child\
    \ D:      110x\n   Child D:      11xx\n   and so on.\n   However, because the\
    \ address ordering is very strict, to reduce the\n   probability for collision,\
    \ when a new sub-prefix has to be chosen,\n   the choice should be random among\
    \ all candidates with the same\n   potential for expandability.  For example,\
    \ if the free sub-prefixes\n   are 01xx, 10xx, 110x, then the new prefix to claim\
    \ should be chosen\n   with probability of 50% for 01xx and 50% for 10xx for example.\n"
- title: 17.1.2.  Reducing Allocation Latency
  contents:
  - "17.1.2.  Reducing Allocation Latency\n   To reduce the allocation latency, a\
    \ MASC node uses pre-allocation.\n   It constantly monitors the demand for addresses\
    \ from its children (or\n   MAASs), and predicts what would be the address usage\
    \ after\n   [WAITING_PERIOD].  Only if the available addresses will be used up\n\
    \   within [WAITING_PERIOD], a MASC node claims more addresses in\n   advance.\n"
- title: 17.1.3.  Address Space Utilization
  contents:
  - "17.1.3.  Address Space Utilization\n   Because every prefix size is a power of\
    \ two, if a node tries to\n   allocate just a single prefix, the utilization at\
    \ that node (i.e. at\n   that node's domain) can be as low as 50%.  To improve\
    \ the\n   utilization, a MASC node can have more than one prefix allocated at\
    \ a\n   time (typically, each of them with different size).  By using a pre-\n\
    \   allocation and allocating several prefixes of different size (see\n   below),\
    \ a MASC node should try to keep its address utilization in the\n   range 70-90%.\n"
- title: 17.1.4.  Prefix Selection After Increase of Demand
  contents:
  - "17.1.4.  Prefix Selection After Increase of Demand\n   To additionally reduce\
    \ the allocation latency by reducing the\n   probability for collision, and to\
    \ improve the aggregability of the\n   allocated addresses, a MASC node carefully\
    \ chooses the prefixes to\n   claim. The first prefix is chosen at random among\
    \ all reasonably\n   expandable candidates.  If a node chooses to allocate another,\n\
    \   smaller prefix, then, instead of doubling the size of the first one\n   which\
    \ might reduce significantly the address utilization, a second\n   \"neighbor\"\
    \ prefix is chosen.  For example, if prefix 224.0/16 was\n   already allocated,\
    \ and the MASC domain needs 256 more addresses, the\n   second prefix to claim\
    \ will be 224.1.0/24. If the domain needs more\n   addresses, the second prefix\
    \ will eventually grow to 224.1/16, and\n   then both prefixes can be automatically\
    \ aggregated into 224.0/15.\n   Only if 224.0.1/24 could not be allocated, a MASC\
    \ node will choose\n   another prefix (eventually random among the unused prefixes).\n\
    \   If the number of allocated prefixes increases above some threshold,\n   and\
    \ none of them can be extended when more addresses are needed,\n   then, to reduce\
    \ the amount of state, a MASC node should claim a new\n   larger prefix and should\
    \ stop re-claiming the older non-expandable\n   prefixes.  Research results show\
    \ that up to three prefixes per MASC\n   domain is a reasonable threshold, such\
    \ that the address utilization\n   can be in the range 70-90%, and at the same\
    \ time the prefix flux will\n   be reasonably low.\n"
- title: 17.1.5.  Prefix Selection After Decrease of Demand
  contents:
  - "17.1.5.  Prefix Selection After Decrease of Demand\n   If the demand for addresses\
    \ decreases, such that its address space is\n   under-utilized, a MASC node implicitly\
    \ returns the unused prefixes\n   after their lifetimes expire, or re-claims some\
    \ smaller sub-prefixes.\n   For example, if prefix 224.0/15 is 50% used by the\
    \ MAASs and/or\n   children MASC domains, and the overall utilization is such\
    \ that\n   approximately 2^16 (64K) addresses should be returned, a MASC node\n\
    \   should stop reclaiming 224.0/15 and should start reclaiming either\n   224.0/16\
    \ or 224.1/16 (whichever sub-prefix utilization is higher).\n"
- title: 17.1.6.  Lifetime Extension Algorithm
  contents:
  - "17.1.6.  Lifetime Extension Algorithm\n   If the demand for addresses did not\
    \ decrease, then a MASC node re-\n   claims the prefixes it has allocated before\
    \ their lifetime expires.\n   Each prefix (or sub-prefix if the demand has decreased)\
    \ should be\n   re-claimed every 48 hours.\n"
- title: '18.  APPENDIX B: Strawman Deployment'
  contents:
  - "18.  APPENDIX B: Strawman Deployment\n   At the moment of writing, 225.0.0.0-225.255.255.255\
    \ is temporarily\n   allocated to MALLOC.  Presumably this block of addresses\
    \ will be used\n   for experimental deployment and testing.\n   If MASC were widely\
    \ deployed on the Internet, we might expect numbers\n   similar to the following:\n\
    \   o  Initially will have approximately 128 Top-Level Domains\n   o  Assume initially\
    \ approximately 8192 level-2 MASC domains; on\n      average, a TLD will have\
    \ approximately 64 children domains.\n   o  MASC managed global addresses:\n \
    \     The following (large) ranges are not allocated yet (2^N represents\n   \
    \   the size of the contiguous mask prefixes):\n       225.0.0.0 - 231.255.255.255\
    \ = 2^26 + 2^25 + 2^24\n       234.0.0.0 - 238.255.255.255 = 2^25 + 2^25 + 2^24\n\
    \       ---------------------------\n       Total:   12*2^24 addresses\n     \
    \ Initially, the range 228.0.0.0 - 231.255.255.255 (4*2^24 = 2^26 =\n      64M)\
    \ could be used by MASC as the global addresses pool. The rest\n      (8*2^24)\
    \ should be reserved.  Part of it could be added later to\n      MASC, or can\
    \ be used to enlarge the pool of administratively\n      scoped addresses (currently\
    \ 239.X.X.X), or the pool for static\n      allocation (233.X.X.X).\n   o  If\
    \ the multicast addresses are evenly distributed, each TLD would\n      have a\
    \ maximum of 2^19 (512K) addresses, while each level-2 MASC\n      domain would\
    \ have 8192 addresses.\n   o  Initial claim size: 256 addresses/MASC domain\n\
    \   o  Could use soft and hard thresholds to specify the maximum amount\n    \
    \  of claimed+allocated addresses per domain.  For example, trigger a\n      warning\
    \ message if claimed+allocated addresses by a domain is >=\n      1.0*average_assumed_per_domain\
    \ (a strawman default soft\n      threshold):\n         * if a TLD claim+allocation\
    \ >= 512K\n         * if a second level MASC domain claim+allocation >= 8K\n \
    \     The hard threshold (for example, 2.0*average_assumed_per_domain)\n     \
    \ can be enforced by sending an explicit DENIED message.\n      The TLDs thresholds\
    \ (with regard to the claims by the second level\n      MASC domains) is a private\
    \ matter and is a part of the particular\n      TLD policy: the thresholds could\
    \ be per customer, and the warnings\n      to the administrators could be a signal\
    \ that it is time to change\n      the policy.\n   o  Initial claim lifetime is\
    \ of the order of 30 days.  Prefix\n      lifetime is periodically (every 48 hours)\
    \ reclaimed/extended,\n      unless the prefix is under-utilized (see APPENDIX\
    \ A).  Because the\n      allocation is demand-driven, the allocated prefix lifetime\
    \ will be\n      automatically extended if the MAASs need longer prefix lifetime\n\
    \      (e.g. 3-6 months).\n   o  A level-2 MASC domain could have children (i.e.\
    \ level-3) MASC\n      domains.\n   o  If a level-2 or level-3 MASC domain uses\
    \ less than 128 addresses,\n      a Layer 2 protocol/mechanism (e.g. AAP) should\
    \ be run among that\n      domain and its parent MASC domain.\n"
- title: 19.  Authors' Addresses
  contents:
  - "19.  Authors' Addresses\n   Pavlin Radoslavov\n   Computer Science Department\n\
    \   University of Southern California/ISI\n   Los Angeles, CA 90089\n   USA\n\
    \   EMail: pavlin@catarina.usc.edu\n   Deborah Estrin\n   Computer Science Department\n\
    \   University of Southern California/ISI\n   Los Angeles, CA 90089\n   USA\n\
    \   EMail: estrin@isi.edu\n   Ramesh Govindan\n   University of Southern California/ISI\n\
    \   4676 Admiralty Way\n   Marina Del Rey, CA 90292\n   USA\n   EMail: govindan@isi.edu\n\
    \   Mark Handley\n   AT&T Center for Internet Research at ISCI (ACIRI)\n   1947\
    \ Center St., Suite 600\n   Berkeley, CA 94704\n   USA\n   EMail: mjh@aciri.org\n\
    \   Satish Kumar\n   Computer Science Department\n   University of Southern California/ISI\n\
    \   Los Angeles, CA 90089\n   USA\n   EMail: kkumar@usc.edu\n   David Thaler\n\
    \   Microsoft\n   One Microsoft Way\n   Redmond, WA 98052\n   USA\n   EMail: dthaler@microsoft.com\n"
- title: 20.  References
  contents:
  - "20.  References\n   [AAP]                 Handley, M. and S. Hanna, \"Multicast\
    \ Address\n                         Allocation Protocol (AAP)\", Work in Progress.\n\
    \   [API]                 Finlayson, R., \"An Abstract API for Multicast\n   \
    \                      Address Allocation\", RFC 2771, February 2000.\n   [BGMP]\
    \                Thaler, D., Estrin, D. and D. Meyer, \"Border\n             \
    \            Gateway Multicast Protocol (BGMP): Protocol\n                   \
    \      Specification\", Work in Progress.\n   [BGP]                 Rekhter, Y.\
    \ and T. Li, \"A Border Gateway\n                         Protocol 4 (BGP-4)\"\
    , RFC 1771, March 1995.\n   [CIDR]                Rekhter, Y. and C. Topolcic,\
    \ \"Exchanging\n                         Routing Information Across Provider Boundaries\n\
    \                         in the CIDR Environment\", RFC 1520, September\n   \
    \                      1993.\n   [IANA]                Reynolds, J. and J. Postel,\
    \ \"Assigned Numbers\",\n                         STD 2, RFC 1700, October 1994.\n\
    \   [IANA-CONSIDERATIONS] Alvestrand, H. and T. Narten, \"Guidelines for\n   \
    \                      Writing an IANA Considerations Section in\n           \
    \              RFCs\", BCP 26, RFC 2434, October 1998.\n   [IPSEC]           \
    \    Kent, S. and R. Atkinson, \"Security\n                         Architecture\
    \ for the Internet Protocol\", RFC\n                         2401, November 1998.\n\
    \   [KAMPAI]              Tsuchiya, P., \"Efficient and Flexible\n           \
    \              Hierarchical Address Assignment\", INET92, June\n             \
    \            1992, pp. 441--450.\n   [MADCAP]              Hanna, S., Patel, B.\
    \ and M. Shah, \"Multicast\n                         Address Dynamic Client Allocation\
    \ Protocol\n                         (MADCAP)\", RFC 2730, December 1999.\n  \
    \ [MALLOC]              Thaler, D., Handley, M. and D. Estrin, \"The\n       \
    \                  Internet Multicast Address Allocation\n                   \
    \      Architecture\", RFC 2908, September 2000.\n   [MBGP]                Bates,\
    \ T., Chandra, R., Katz, D. and Y.\n                         Rekhter, \"Multiprotocol\
    \ Extensions for BGP-4\",\n                         RFC 2283, September 1997.\n\
    \   [MTRACE]              Fenner, W., and S. Casner, \"A `traceroute'\n      \
    \                   facility for IP Multicast\", Work in Progress.\n   [MZAP]\
    \                Handley, M, Thaler, D. and R. Kermode\n                     \
    \    \"Multicast-Scope Zone Announcement Protocol\n                         (MZAP)\"\
    , RFC 2776, February 2000.\n   [RFC1112]             Deering, S., \"Host Extensions\
    \ for IP\n                         Multicasting\", STD 5, RFC 1112, August 1989.\n\
    \   [RFC2119]             Bradner, S., \"Key words for use in RFCs to\n      \
    \                   Indicate Requirement Levels\", BCP 14, RFC 2119,\n       \
    \                  March 1997.\n   [RFC2373]             Hinden, R. and S. Deering,\
    \ \"IP Version 6\n                         Addressing Architecture\", RFC 2373,\
    \ July 1998.\n   [RFC2460]             Deering, S. and R. Hinden, \"Internet Protocol,\n\
    \                         Version 6 (IPv6) Specification\", RFC 2460,\n      \
    \                   December 1998.\n   [SCOPE]               Meyer, D., \"Administratively\
    \ Scoped IP\n                         Multicast\", RFC 2365, July 1998.\n"
- title: 21.  Full Copyright Statement
  contents:
  - "21.  Full Copyright Statement\n   Copyright (C) The Internet Society (2000).\
    \  All Rights Reserved.\n   This document and translations of it may be copied\
    \ and furnished to\n   others, and derivative works that comment on or otherwise\
    \ explain it\n   or assist in its implementation may be prepared, copied, published\n\
    \   and distributed, in whole or in part, without restriction of any\n   kind,\
    \ provided that the above copyright notice and this paragraph are\n   included\
    \ on all such copies and derivative works.  However, this\n   document itself\
    \ may not be modified in any way, such as by removing\n   the copyright notice\
    \ or references to the Internet Society or other\n   Internet organizations, except\
    \ as needed for the purpose of\n   developing Internet standards in which case\
    \ the procedures for\n   copyrights defined in the Internet Standards process\
    \ must be\n   followed, or as required to translate it into languages other than\n\
    \   English.\n   The limited permissions granted above are perpetual and will\
    \ not be\n   revoked by the Internet Society or its successors or assigns.\n \
    \  This document and the information contained herein is provided on an\n   \"\
    AS IS\" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING\n   TASK FORCE\
    \ DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING\n   BUT NOT LIMITED\
    \ TO ANY WARRANTY THAT THE USE OF THE INFORMATION\n   HEREIN WILL NOT INFRINGE\
    \ ANY RIGHTS OR ANY IMPLIED WARRANTIES OF\n   MERCHANTABILITY OR FITNESS FOR A\
    \ PARTICULAR PURPOSE.\n"
- title: Acknowledgement
  contents:
  - "Acknowledgement\n   Funding for the RFC Editor function is currently provided\
    \ by the\n   Internet Society.\n"
