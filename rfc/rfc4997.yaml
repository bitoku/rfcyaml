- title: __initial_text__
  contents:
  - '        Formal Notation for RObust Header Compression (ROHC-FN)

    '
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This document specifies an Internet standards track protocol\
    \ for the\n   Internet community, and requests discussion and suggestions for\n\
    \   improvements.  Please refer to the current edition of the \"Internet\n   Official\
    \ Protocol Standards\" (STD 1) for the standardization state\n   and status of\
    \ this protocol.  Distribution of this memo is unlimited.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (C) The IETF Trust (2007).\n"
- title: Abstract
  contents:
  - "Abstract\n   This document defines Robust Header Compression - Formal Notation\n\
    \   (ROHC-FN), a formal notation to specify field encodings for\n   compressed\
    \ formats when defining new profiles within the ROHC\n   framework.  ROHC-FN offers\
    \ a library of encoding methods that are\n   often used in ROHC profiles and can\
    \ thereby help to simplify future\n   profile development work.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1.  Introduction . . . . . . . . . . . . . . . . . . .\
    \ . . . . . .  4\n   2.  Terminology  . . . . . . . . . . . . . . . . . . . .\
    \ . . . . .  4\n   3.  Overview of ROHC-FN  . . . . . . . . . . . . . . . . .\
    \ . . . .  5\n     3.1.  Scope of the Formal Notation . . . . . . . . . . . .\
    \ . . .  6\n     3.2.  Fundamentals of the Formal Notation  . . . . . . . . .\
    \ . .  7\n       3.2.1.  Fields and Encodings . . . . . . . . . . . . . . . .\
    \ .  7\n       3.2.2.  Formats and Encoding Methods . . . . . . . . . . . . .\
    \  9\n     3.3.  Example Using IPv4 . . . . . . . . . . . . . . . . . . . . 11\n\
    \   4.  Normative Definition of ROHC-FN  . . . . . . . . . . . . . . . 13\n  \
    \   4.1.  Structure of a Specification . . . . . . . . . . . . . . . 13\n    \
    \ 4.2.  Identifiers  . . . . . . . . . . . . . . . . . . . . . . . 14\n     4.3.\
    \  Constant Definitions . . . . . . . . . . . . . . . . . . . 15\n     4.4.  Fields\
    \ . . . . . . . . . . . . . . . . . . . . . . . . . . 16\n       4.4.1.  Attribute\
    \ References . . . . . . . . . . . . . . . . . 17\n       4.4.2.  Representation\
    \ of Field Values . . . . . . . . . . . . 17\n     4.5.  Grouping of Fields .\
    \ . . . . . . . . . . . . . . . . . . . 17\n     4.6.  \"THIS\" . . . . . . .\
    \ . . . . . . . . . . . . . . . . . . . 18\n     4.7.  Expressions  . . . . .\
    \ . . . . . . . . . . . . . . . . . . 19\n       4.7.1.  Integer Literals . .\
    \ . . . . . . . . . . . . . . . . . 20\n       4.7.2.  Integer Operators  . .\
    \ . . . . . . . . . . . . . . . . 20\n       4.7.3.  Boolean Literals . . . .\
    \ . . . . . . . . . . . . . . . 20\n       4.7.4.  Boolean Operators  . . . .\
    \ . . . . . . . . . . . . . . 20\n       4.7.5.  Comparison Operators . . . .\
    \ . . . . . . . . . . . . . 21\n     4.8.  Comments . . . . . . . . . . . . .\
    \ . . . . . . . . . . . . 21\n     4.9.  \"ENFORCE\" Statements . . . . . . .\
    \ . . . . . . . . . . . . 22\n     4.10. Formal Specification of Field Lengths\
    \  . . . . . . . . . . 23\n     4.11. Library of Encoding Methods  . . . . . .\
    \ . . . . . . . . . 24\n       4.11.1. uncompressed_value . . . . . . . . . .\
    \ . . . . . . . . 24\n       4.11.2. compressed_value . . . . . . . . . . . .\
    \ . . . . . . . 25\n       4.11.3. irregular  . . . . . . . . . . . . . . . .\
    \ . . . . . . 26\n       4.11.4. static . . . . . . . . . . . . . . . . . . .\
    \ . . . . . 27\n       4.11.5. lsb  . . . . . . . . . . . . . . . . . . . . .\
    \ . . . . 27\n       4.11.6. crc  . . . . . . . . . . . . . . . . . . . . . .\
    \ . . . 29\n     4.12. Definition of Encoding Methods . . . . . . . . . . . .\
    \ . . 29\n       4.12.1. Structure  . . . . . . . . . . . . . . . . . . . . .\
    \ . 30\n       4.12.2. Arguments  . . . . . . . . . . . . . . . . . . . . . .\
    \ 37\n       4.12.3. Multiple Formats . . . . . . . . . . . . . . . . . . . 38\n\
    \     4.13. Profile-Specific Encoding Methods  . . . . . . . . . . . . 40\n  \
    \ 5.  Security Considerations  . . . . . . . . . . . . . . . . . . . 41\n   6.\
    \  Contributors . . . . . . . . . . . . . . . . . . . . . . . . . 41\n   7.  Acknowledgements\
    \ . . . . . . . . . . . . . . . . . . . . . . . 41\n   8.  References . . . .\
    \ . . . . . . . . . . . . . . . . . . . . . . 42\n     8.1.  Normative References\
    \ . . . . . . . . . . . . . . . . . . . 42\n     8.2.  Informative References\
    \ . . . . . . . . . . . . . . . . . . 42\n   Appendix A.  Formal Syntax of ROHC-FN\
    \  . . . . . . . . . . . . . . 43\n   Appendix B.  Bit-level Worked Example  .\
    \ . . . . . . . . . . . . . 45\n     B.1.  Example Packet Format  . . . . . .\
    \ . . . . . . . . . . . . 45\n     B.2.  Initial Encoding . . . . . . . . . .\
    \ . . . . . . . . . . . 46\n     B.3.  Basic Compression  . . . . . . . . . .\
    \ . . . . . . . . . . 47\n     B.4.  Inter-Packet Compression . . . . . . . .\
    \ . . . . . . . . . 48\n     B.5.  Specifying Initial Values  . . . . . . . .\
    \ . . . . . . . . 50\n     B.6.  Multiple Packet Formats  . . . . . . . . . .\
    \ . . . . . . . 51\n     B.7.  Variable Length Discriminators . . . . . . . .\
    \ . . . . . . 53\n     B.8.  Default Encoding . . . . . . . . . . . . . . . .\
    \ . . . . . 55\n     B.9.  Control Fields . . . . . . . . . . . . . . . . . .\
    \ . . . . 56\n     B.10. Use of \"ENFORCE\" Statements as Conditionals  . . .\
    \ . . . . 59\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   Robust Header Compression - Formal Notation (ROHC-FN) is\
    \ a formal\n   notation designed to help with the definition of ROHC [RFC4995]\n\
    \   header compression profiles.  Previous header compression profiles\n   have\
    \ been so far specified using a combination of English text\n   together with\
    \ ASCII Box notation.  Unfortunately, this was sometimes\n   unclear and ambiguous,\
    \ revealing the limitations of defining complex\n   structures and encodings for\
    \ compressed formats this way.  The\n   primary objective of the Formal Notation\
    \ is to provide a more\n   rigorous means to define header formats -- compressed\
    \ and\n   uncompressed -- as well as the relationships between them.  No other\n\
    \   formal notation exists that meets these requirements, so ROHC-FN aims\n  \
    \ to meet them.\n   In addition, ROHC-FN offers a library of encoding methods\
    \ that are\n   often used in ROHC profiles, so that the specification of new\n\
    \   profiles using the formal notation can be achieved without having to\n   redefine\
    \ this library from scratch.  Informally, an encoding method\n   defines a two-way\
    \ mapping between uncompressed data and compressed\n   data.\n"
- title: 2.  Terminology
  contents:
  - "2.  Terminology\n   o  Compressed format\n      A compressed format consists\
    \ of a list of fields that provides\n      bindings between encodings and the\
    \ fields it compresses.  One or\n      more compressed formats can be combined\
    \ to represent an entire\n      compressed header format.\n   o  Context\n   \
    \   Context is information about the current (de)compression state of\n      the\
    \ flow.  Specifically, a context for a specific field can be\n      either uninitialised,\
    \ or it can include a set of one or more\n      values for the field's attributes\
    \ defined by the compression\n      algorithm, where a value may come from the\
    \ field's attributes\n      corresponding to a previous packet.  See also a more\
    \ generalized\n      definition in Section 2.2 of [RFC4995].\n   o  Control field\n\
    \      Control fields are transmitted from a ROHC compressor to a ROHC\n     \
    \ decompressor, but are not part of the uncompressed header itself.\n   o  Encoding\
    \ method, encodings\n      Encoding methods are two-way relations that can be\
    \ applied to\n      compress and decompress fields of a protocol header.\n   o\
    \  Field\n      The protocol header is divided into a set of contiguous bit\n\
    \      patterns known as fields.  Each field is defined by a collection\n    \
    \  of attributes that indicate its value and length in bits for both\n      the\
    \ compressed and uncompressed headers.  The way the header is\n      divided into\
    \ fields is specific to the definition of a profile,\n      and it is not necessary\
    \ for the field divisions to be identical to\n      the ones given by the specification(s)\
    \ for the protocol header\n      being compressed.\n   o  Library of encoding\
    \ methods\n      The library of encoding methods contains a number of commonly\
    \ used\n      encoding methods for compressing header fields.\n   o  Profile\n\
    \      A ROHC [RFC4995] profile is a description of how to compress a\n      certain\
    \ protocol stack.  Each profile consists of a set of formats\n      (for example,\
    \ uncompressed and compressed formats) along with a\n      set of rules that control\
    \ compressor and decompressor behaviour.\n   o  ROHC-FN specification\n      The\
    \ specification of the set of formats of a ROHC profile using\n      ROHC-FN.\n\
    \   o  Uncompressed format\n      An uncompressed format consists of a list of\
    \ fields that provides\n      the order of the fields to be compressed for a contiguous\
    \ set of\n      bits whose bit layout corresponds to the protocol header being\n\
    \      compressed.\n"
- title: 3.  Overview of ROHC-FN
  contents:
  - "3.  Overview of ROHC-FN\n   This section gives an overview of ROHC-FN.  It also\
    \ explains how\n   ROHC-FN can be used to specify the compression of header fields\
    \ as\n   part of a ROHC profile.\n"
- title: 3.1.  Scope of the Formal Notation
  contents:
  - "3.1.  Scope of the Formal Notation\n   This section explains how the formal notation\
    \ relates to the ROHC\n   framework and to specifications of ROHC profiles.\n\
    \   The ROHC framework [RFC4995] provides the general principles for\n   performing\
    \ robust header compression.  It defines the concept of a\n   profile, which makes\
    \ ROHC a general platform for different\n   compression schemes.  It sets link\
    \ layer requirements, and in\n   particular negotiation requirements, for all\
    \ ROHC profiles.  It\n   defines a set of common functions such as Context Identifiers\
    \ (CIDs),\n   padding, and segmentation.  It also defines common formats (IR,\
    \ IR-\n   DYN, Feedback, Add-CID, etc.), and finally it defines a generic,\n \
    \  profile independent, feedback mechanism.\n   A ROHC profile is a description\
    \ of how to compress a certain protocol\n   stack.  For example, ROHC profiles\
    \ are available for RTP/UDP/IP and\n   many other protocol stacks.\n   At a high\
    \ level, each ROHC profile consists of a set of formats\n   (defining the bits\
    \ to be transmitted) along with a set of rules that\n   control compressor and\
    \ decompressor behaviour.  The purpose of the\n   formats is to define how to\
    \ compress and decompress headers.  The\n   formats define one or more compressed\
    \ versions of each uncompressed\n   header, and simultaneously define the inverse:\
    \ how to relate a\n   compressed header back to the original uncompressed header.\n\
    \   The set of formats will typically define compression of headers\n   relative\
    \ to a context of field values from previous headers in a\n   flow, improving\
    \ the overall compression by taking into account\n   redundancies between headers\
    \ of successive packets.  Therefore, in\n   addition to defining the formats,\
    \ a profile has to:\n   o  specify how to manage the context for both the compressor\
    \ and the\n      decompressor,\n   o  define when and what to send in feedback\
    \ messages, if any, from\n      decompressor to compressor,\n   o  outline compression\
    \ principles to make the profile robust against\n      bit errors and dropped\
    \ packets.\n   All this is needed to ensure that the compressor and decompressor\n\
    \   contexts are kept consistent with each other, while still\n   facilitating\
    \ the best possible compression performance.\n   The ROHC-FN is designed to help\
    \ in the specification of compressed\n   formats that, when put together based\
    \ on the profile definition, make\n   up the formats used in a ROHC profile. \
    \ It offers a library of\n   encoding methods for compressing fields, and a mechanism\
    \ for\n   combining these encoding methods to create compressed formats\n   tailored\
    \ to a specific protocol stack.\n   The scope of ROHC-FN is limited to specifying\
    \ the relationship\n   between the compressed and uncompressed formats.  To form\
    \ a complete\n   profile specification, the control logic for the profile behaviour\n\
    \   needs to be defined by other means.\n"
- title: 3.2.  Fundamentals of the Formal Notation
  contents:
  - "3.2.  Fundamentals of the Formal Notation\n   There are two fundamental elements\
    \ to the formal notation:\n   1.  Fields and their encodings, which define the\
    \ mapping between a\n       header's uncompressed and compressed forms.\n   2.\
    \  Encoding methods, which define the way headers are broken down\n       into\
    \ fields.  Encoding methods define lists of uncompressed\n       fields and the\
    \ lists of compressed fields they map onto.\n   These two fundamental elements\
    \ are at the core of the notation and\n   are outlined below.\n"
- title: 3.2.1.  Fields and Encodings
  contents:
  - "3.2.1.  Fields and Encodings\n   Headers are made up of fields.  For example,\
    \ version number, header\n   length, and sequence number are all fields used in\
    \ real protocols.\n   Fields have attributes.  Attributes describe various things\
    \ about the\n   field.  For example:\n     field.ULENGTH\n   The above indicates\
    \ the uncompressed length of the field.  A field is\n   said to have a value attribute,\
    \ i.e., a compressed value or an\n   uncompressed value, if the corresponding\
    \ length attribute is greater\n   than zero.  See Section 4.4 for more details\
    \ on field attributes.\n   The relationship between the compressed and uncompressed\
    \ attributes\n   of a field are specified with encoding methods, using the following\n\
    \   notation:\n     field   =:=   encoding_method;\n   In the field definition\
    \ above, the symbol \"=:=\" means \"is encoded\n   by\".  This field definition\
    \ does not represent an assignment\n   operation from the right hand side to the\
    \ left side.  Instead, it is\n   a two-way mapping between the compressed and\
    \ uncompressed attributes\n   of the field.  It both represents the compression\
    \ and the\n   decompression operation in a single field definition, through a\n\
    \   process of two-way matching.\n   Two-way matching is a binary operation that\
    \ attempts to make the\n   operands (i.e., the compressed and uncompressed attributes)\
    \ match.\n   This is similar to the unification process in logic.  The operands\n\
    \   represent one unspecified data object and one specified object.\n   Values\
    \ can be matched from either operand.\n   During compression, the uncompressed\
    \ attributes of the field are\n   already defined.  The given encoding matches\
    \ the compressed\n   attributes against them.  During decompression, the compressed\n\
    \   attributes of the field are already defined, so the uncompressed\n   attributes\
    \ are matched to the compressed attributes using the given\n   encoding method.\
    \  Thus, both compression and decompression are\n   defined by a single field\
    \ definition.\n   Therefore, an encoding method (including any parameters specified)\n\
    \   creates a reversible binding between the attributes of a field.  At\n   the\
    \ compressor, a format can be used if a set of bindings that is\n   successful\
    \ for all the attributes in all its fields can be found.  At\n   the decompressor,\
    \ the operation is reversed using the same bindings\n   and the attributes in\
    \ each field are filled according to the\n   specified bindings; decoding fails\
    \ if the binding for an attribute\n   fails.\n   For example, the \"static\" encoding\
    \ method creates a binding between\n   the attribute corresponding to the uncompressed\
    \ value of the field\n   and the corresponding value of the field in the context.\n\
    \   o  For the compressor, the \"static\" binding is successful when both\n  \
    \    the context value and the uncompressed value are the same.  If the\n    \
    \  two values differ then the binding fails.\n   o  For the decompressor, the\
    \ \"static\" binding succeeds only if a\n      valid context entry containing\
    \ the value of the uncompressed field\n      exists.  Otherwise, the binding will\
    \ fail.\n   Both the compressed and uncompressed forms of each field are\n   represented\
    \ as a string of bits; the most significant bit first, of\n   the length specified\
    \ by the length attribute.  The bit string is the\n   binary representation of\
    \ the value attribute of the field, modulo\n   \"2^length\", where \"length\"\
    \ is the length attribute of the field.\n   However, this is only the representation\
    \ of the bits exchanged\n   between the compressor and the decompressor, designed\
    \ to allow\n   maximum compression efficiency.  The FN itself uses the full range\
    \ of\n   integers.  See Section 4.4.2 for further details.\n"
- title: 3.2.2.  Formats and Encoding Methods
  contents:
  - "3.2.2.  Formats and Encoding Methods\n   The ROHC-FN provides a library of commonly\
    \ used encoding methods.\n   Encoding methods can be defined using plain English,\
    \ or using a\n   formal definition consisting of, for example, a collection of\n\
    \   expressions (Section 4.7) and \"ENFORCE\" statements (Section 4.9).\n   ROHC-FN\
    \ also provides mechanisms for combining fields and their\n   encoding methods\
    \ into higher level encoding methods following a well-\n   defined structure.\
    \  This is similar to the definition of functions\n   and procedures in an ordinary\
    \ programming language.  It allows\n   complexity to be handled by being broken\
    \ down into manageable parts.\n   New encoding methods are defined at the top\
    \ level of a profile.\n   These can then be used in the definition of other higher\
    \ level\n   encoding methods, and so on.\n   new_encoding_method         // This\
    \ block is an encoding method\n   {\n     UNCOMPRESSED {            // This block\
    \ is an uncompressed format\n       field_1   [ 16 ];\n       field_2   [ 32 ];\n\
    \       field_3   [ 48 ];\n     }\n     CONTROL {                 // This block\
    \ defines control fields\n       ctrl_field_1;\n       ctrl_field_2;\n     }\n\
    \     DEFAULT {                 // This block defines default encodings\n    \
    \                           // for specified fields\n       ctrl_field_2 =:= encoding_method_2;\n\
    \       field_1      =:= encoding_method_1;\n     }\n     COMPRESSED format_0\
    \ {     // This block is a compressed format\n       field_1;\n       field_2\
    \      =:= encoding_method_2;\n       field_3      =:= encoding_method_3;\n  \
    \     ctrl_field_1 =:= encoding_method_4;\n       ctrl_field_2;\n     }\n    \
    \ COMPRESSED format_1 {     // This block is a compressed format\n       field_1;\n\
    \       field_2      =:= encoding_method_3;\n       field_3      =:= encoding_method_4;\n\
    \       ctrl_field_2 =:= encoding_method_5;\n       ctrl_field_3 =:= encoding_method_6;\
    \ // This is a control field\n                                           // with\
    \ no uncompressed value\n     }\n   }\n   In the example above, the encoding method\
    \ being defined is called\n   \"new_encoding_method\".  The section headed \"\
    UNCOMPRESSED\" indicates\n   the order of fields in the uncompressed header, i.e.,\
    \ the\n   uncompressed header format.  The number of bits in each of the fields\n\
    \   is indicated in square brackets.  After this is another section,\n   \"CONTROL\"\
    , which defines two control fields.  Following this is the\n   \"DEFAULT\" section\
    \ which defines default encoding methods for two of\n   the fields (see below).\
    \  Finally, two alternative compressed formats\n   follow, each defined in sections\
    \ headed \"COMPRESSED\".  The fields\n   that occur in the compressed formats\
    \ are either:\n   o  fields that occur in the uncompressed format; or\n   o  control\
    \ fields that have an uncompressed value and that occur in\n      the CONTROL\
    \ section; or\n   o  control fields that do not have an uncompressed value and\
    \ thus are\n      defined as part of the compressed format.\n   Central to each\
    \ of these formats is a \"field list\", which defines the\n   fields contained\
    \ in the format and also the order that those fields\n   appear in that format.\
    \  For the \"DEFAULT\" and \"CONTROL\" sections, the\n   field order is not significant.\n\
    \   In addition to specifying field order, the field list may also\n   specify\
    \ bindings for any or all of the fields it contains.  Fields\n   that have no\
    \ bindings defined for them are bound using the default\n   bindings specified\
    \ in the \"DEFAULT\" section (see Section 4.12.1.5).\n   Fields from the compressed\
    \ format have the same name as they do in\n   the uncompressed format.  If there\
    \ are any fields that are present\n   exclusively in the compressed format, but\
    \ that do have an\n   uncompressed value, they must be declared in the \"CONTROL\"\
    \ section of\n   the definition of the encoding method (see Section 4.12.1.3 for\
    \ more\n   details on defining control fields).\n   Fields that have no uncompressed\
    \ value do not appear in an\n   \"UNCOMPRESSED\" field list and do not have to\
    \ appear in the \"CONTROL\"\n   field list either.  Instead, they are only declared\
    \ in the compressed\n   field lists where they are used.\n   In the example above,\
    \ all the fields that appear in the compressed\n   format are also found in the\
    \ uncompressed format, or the control\n   field list, except for ctrl_field_3;\
    \ this is possible because\n   ctrl_field_3 has no \"uncompressed\" value at all.\
    \  Fields such as a\n   checksum on the compressed information fall into this\
    \ category.\n"
- title: 3.3.  Example Using IPv4
  contents:
  - "3.3.  Example Using IPv4\n   This section gives an overview of how the notation\
    \ is used by means\n   of an example.  The example will develop the formal notation\
    \ for an\n   encoding method capable of compressing a single, well-known header:\n\
    \   the IPv4 header [RFC791].\n   The first step is to specify the overall structure\
    \ of the IPv4\n   header.  To do this, we use an encoding method that we will\
    \ call\n   \"ipv4_header\".  More details on definitions of encoding methods can\n\
    \   be found in Section 4.12.  This is notated as follows:\n     ipv4_header\n\
    \     {\n   The fragment of notation above declares the encoding method\n   \"\
    ipv4_header\", the definition follows the opening brace (see\n   Section 4.12).\n\
    \   Definitions within the pair of braces are local to \"ipv4_header\".\n   This\
    \ scoping mechanism helps to clarify which fields belong to which\n   formats;\
    \ it is also useful when compressing complex protocol stacks\n   with several\
    \ headers, often with the same field names occurring in\n   multiple headers (see\
    \ Section 4.2).\n   The next step is to specify the fields contained in the uncompressed\n\
    \   IPv4 header to represent the uncompressed format for which the\n   encoding\
    \ method will define one or more compressed formats.  This is\n   accomplished\
    \ using ROHC-FN as follows:\n       UNCOMPRESSED {\n         version         [\
    \  4 ];\n         header_length   [  4 ];\n         dscp            [  6 ];\n\
    \         ecn             [  2 ];\n         length          [ 16 ];\n        \
    \ id              [ 16 ];\n         reserved        [  1 ];\n         dont_frag\
    \       [  1 ];\n         more_fragments  [  1 ];\n         offset          [\
    \ 13 ];\n         ttl             [  8 ];\n         protocol        [  8 ];\n\
    \         checksum        [ 16 ];\n         src_addr        [ 32 ];\n        \
    \ dest_addr       [ 32 ];\n       }\n   The width of each field is indicated in\
    \ square brackets.  This part\n   of the notation is used in the example for illustration\
    \ to help the\n   reader's understanding.  However, indicating the field lengths\
    \ in\n   this way is optional since the width of each field can also normally\n\
    \   be derived from the encoding that is used to compress/decompress it\n   for\
    \ a specific format.  This part of the notation is formally defined\n   in Section\
    \ 4.10.\n   The next step is to specify the compressed format.  This includes\
    \ the\n   encodings for each field that map between the compressed and\n   uncompressed\
    \ forms of the field.  In the example, these encoding\n   methods are mainly taken\
    \ from the ROHC-FN library (see Section 4.11).\n   Since the intention here is\
    \ to illustrate the use of the notation,\n   rather than to describe the optimum\
    \ method of compressing IPv4\n   headers, this example uses only three encoding\
    \ methods.\n   The \"uncompressed_value\" encoding method (defined in Section\
    \ 4.11.1)\n   can compress any field whose uncompressed length and value are fixed,\n\
    \   or can be calculated using an expression.  No compressed bits need to\n  \
    \ be sent because the uncompressed field can be reconstructed using its\n   known\
    \ size and value.  The \"uncompressed_value\" encoding method is\n   used to compress\
    \ five fields in the IPv4 header, as described below:\n       COMPRESSED {\n \
    \        header_length  =:= uncompressed_value(4, 5);\n         version      \
    \  =:= uncompressed_value(4, 4);\n         reserved       =:= uncompressed_value(1,\
    \ 0);\n         offset         =:= uncompressed_value(13, 0);\n         more_fragments\
    \ =:= uncompressed_value(1, 0);\n   The first parameter indicates the length of\
    \ the uncompressed field in\n   bits, and the second parameter gives its integer\
    \ value.\n   Note that the order of the fields in the compressed format is\n \
    \  independent of the order of the fields in the uncompressed format.\n   The\
    \ \"irregular\" encoding method (defined in Section 4.11.3) can be\n   used to\
    \ encode any field for which both uncompressed attributes\n   (ULENGTH and UVALUE)\
    \ are defined, and whose ULENGTH attribute is\n   either fixed or can be calculated\
    \ using an expression.  It is a fail-\n   safe encoding method that can be used\
    \ for such fields in the case\n   where no other encoding method applies.  All\
    \ of the bits in the\n   uncompressed form of the field are present in the compressed\
    \ form as\n   well; hence this encoding does not achieve any compression.\n  \
    \       src_addr       =:= irregular(32);\n         dest_addr      =:= irregular(32);\n\
    \         length         =:= irregular(16);\n         id             =:= irregular(16);\n\
    \         ttl            =:= irregular(8);\n         protocol       =:= irregular(8);\n\
    \         dscp           =:= irregular(6);\n         ecn            =:= irregular(2);\n\
    \         dont_frag      =:= irregular(1);\n   Finally, the third encoding method\
    \ is specific only to the\n   uncompressed format defined above for the IPv4 header,\n\
    \   \"inferred_ip_v4_header_checksum\":\n         checksum       =:= inferred_ip_v4_header_checksum\
    \ [ 0 ];\n       }\n     }\n   The \"inferred_ip_v4_header_checksum\" encoding\
    \ method is different\n   from the other two encoding methods in that it is not\
    \ defined in the\n   ROHC-FN library of encoding methods.  Its definition could\
    \ be given\n   either by using the formal notation as part of the profile definition\n\
    \   itself (see Section 4.12) or by using plain English text (see\n   Section\
    \ 4.13).\n   In our example, the \"inferred_ip_v4_header_checksum\" is a specific\n\
    \   encoding method that calculates the IP checksum from the rest of the\n   header\
    \ values.  Like the \"uncompressed_value\" encoding method, no\n   compressed\
    \ bits need to be sent, since the field value can be\n   reconstructed at the\
    \ decompressor.  This is notated explicitly by\n   specifying, in square brackets,\
    \ a length of 0 for the checksum field\n   in the compressed format.  Again, this\
    \ notation is optional since the\n   encoding method itself would be defined as\
    \ sending zero compressed\n   bits, however it is useful to the reader to include\
    \ such notation\n   (see Section 4.10 for details on this part of the notation).\n\
    \   Finally the definition of the format is terminated with a closing\n   brace.\
    \  At this point, the above example has defined a compressed\n   format that can\
    \ be used to represent the entire compressed IPv4\n   header, and provides enough\
    \ information to allow an implementation to\n   construct the compressed format\
    \ from an uncompressed format\n   (compression) and vice versa (decompression).\n"
- title: 4.  Normative Definition of ROHC-FN
  contents:
  - "4.  Normative Definition of ROHC-FN\n   This section gives the normative definition\
    \ of ROHC-FN.  ROHC-FN is a\n   declarative language that is referentially transparent,\
    \ with no side\n   effects.  This means that whenever an expression is evaluated,\
    \ there\n   are no other effects from obtaining the value of the expression; the\n\
    \   same expression is thus guaranteed to have the same value wherever it\n  \
    \ appears in the notation, and it can always be interchanged with its\n   value\
    \ in any of the formats it appears in (subject to the scope rules\n   of identifiers\
    \ of Section 4.2).\n   The formal notation describes the structure of the formats\
    \ and the\n   relationships between their uncompressed and compressed forms, rather\n\
    \   than describing how compression and decompression is performed.\n   In various\
    \ places within this section, text inside angle brackets has\n   been used as\
    \ a descriptive placeholder.  The use of angle brackets in\n   this way is solely\
    \ for the benefit of the reader of this document.\n   Neither the angle brackets,\
    \ nor their contents form a part of the\n   notation.\n"
- title: 4.1.  Structure of a Specification
  contents:
  - "4.1.  Structure of a Specification\n   The specification of the compressed formats\
    \ of a ROHC profile using\n   ROHC-FN is called a ROHC-FN specification.  ROHC-FN\
    \ specifications\n   are case sensitive and are written in the 7-bit ASCII character\
    \ set\n   (as defined in [RFC2822]) and consist of a sequence of zero or more\n\
    \   constant definitions (Section 4.3), an optional global control field\n   list\
    \ (Section 4.12.1.3) and one or more encoding method definitions\n   (Section\
    \ 4.12).\n   Encoding methods can be defined using the formal notation or can\
    \ be\n   predefined encoding methods.\n   Encoding methods are defined using the\
    \ formal notation by giving one\n   or more uncompressed formats to represent\
    \ the uncompressed header and\n   one or more compressed formats.  These formats\
    \ are related to each\n   other by \"fields\", each of which describes a certain\
    \ part of an\n   uncompressed and/or a compressed header.  In addition to the\
    \ formats,\n   each encoding method may contain control fields, initial values,\
    \ and\n   default field encodings sections.  The attributes of a field are\n \
    \  bound by using an encoding method for it and/or by using \"ENFORCE\"\n   statements\
    \ (Section 4.9) within the formats.  Each of these are\n   terminated by a semi-colon.\n\
    \   Predefined encoding methods are not defined in the formal notation.\n   Instead\
    \ they are defined by giving a short textual reference\n   explaining where the\
    \ encoding method is defined.  It is not necessary\n   to define the library of\
    \ encoding methods contained in this document\n   in this way, their definition\
    \ is implicit to the usage of the formal\n   notation.\n"
- title: 4.2.  Identifiers
  contents:
  - "4.2.  Identifiers\n   In ROHC-FN, identifiers are used for any of the following:\n\
    \   o  encoding methods\n   o  formats\n   o  fields\n   o  parameters\n   o \
    \ constants\n   All identifiers may be of any length and may contain any combination\n\
    \   of alphanumeric characters and underscores, within the restrictions\n   defined\
    \ in this section.\n   All identifiers must start with an alphabetic character.\n\
    \   It is illegal to have two or more identifiers that differ from each\n   other\
    \ only in capitalisation, in the same scope.\n   All letters in identifiers for\
    \ constants must be upper case.\n   It is illegal to use any of the following\
    \ as identifiers (including\n   alternative capitalisations):\n   o  \"false\"\
    , \"true\"\n   o  \"ENFORCE\", \"THIS\", \"VARIABLE\"\n   o  \"ULENGTH\", \"UVALUE\"\
    \n   o  \"CLENGTH\", \"CVALUE\"\n   o  \"UNCOMPRESSED\", \"COMPRESSED\", \"CONTROL\"\
    , \"INITIAL\", or \"DEFAULT\"\n   Format names cannot be referred to in the notation,\
    \ although they are\n   considered to be identifiers.  (See Section 4.12.3.1 for\
    \ more details\n   on format names.)\n   All identifiers used in ROHC-FN have\
    \ a \"scope\".  The scope of an\n   identifier defines the parts of the specification\
    \ where that\n   identifier applies and from which it can be referred to.  If\
    \ an\n   identifier has a \"global\" scope, then it applies throughout the\n \
    \  specification that contains it and can be referred to from anywhere\n   within\
    \ it.  If an identifier has a \"local\" scope, then it only\n   applies to the\
    \ encoding method in which it is defined, it cannot be\n   referenced from outside\
    \ the local scope of that encoding method.  If\n   an identifier has a local scope,\
    \ that identifier can therefore be\n   used in multiple different local scopes\
    \ to refer to different items.\n   All instances of an identifier within its scope\
    \ refer to the same\n   item.  It is not possible to have different items referred\
    \ to by a\n   single identifier within any given scope.  For this reason, if there\n\
    \   is an identifier that has global scope it cannot be used separately\n   in\
    \ a local scope, since a globally-scoped identifier is already\n   applicable\
    \ in all local scopes.\n   The identifiers for each encoding method and each constant\
    \ all have a\n   global scope.  Each format and field also has an identifier.\
    \  The\n   scope of format and field identifiers is local, with the exception\
    \ of\n   global control fields, which have a global scope.  Therefore it is\n\
    \   illegal for a format or field to have the same identifier as another\n   format\
    \ or field within the same scope, or as an encoding method or a\n   constant (since\
    \ they have global scope).\n   Note that although format names (see Section 4.12.3.1)\
    \ are considered\n   to be identifiers, they are not referred to in the notation,\
    \ but are\n   primarily for the benefit of the reader.\n"
- title: 4.3.  Constant Definitions
  contents:
  - "4.3.  Constant Definitions\n   Constant values can be defined using the \"=\"\
    \ operator.  Identifiers\n   for constants must be all upper case.  For example:\n\
    \      SOME_CONSTANT = 3;\n   Constants are defined by an expression (see Section\
    \ 4.7) on the\n   right-hand side of the \"=\" operator.  The expression must\
    \ yield a\n   constant value.  That is, the expression must be one whose terms\
    \ are\n   all either constants or literals and must not vary depending on the\n\
    \   header being compressed.\n   Constants have a global scope.  Constants must\
    \ be defined at the top\n   level, outside any encoding method definition.  Constants\
    \ are\n   entirely equivalent to the value they refer to, and are completely\n\
    \   interchangeable with that value.  Unlike field attributes, which may\n   change\
    \ from packet to packet, constants have the same value for all\n   packets.\n"
- title: 4.4.  Fields
  contents:
  - "4.4.  Fields\n   Fields are the basic building blocks of a ROHC-FN specification.\n\
    \   Fields are the units into which headers are divided.  Each field may\n   have\
    \ two forms: a compressed form and an uncompressed form.  Both\n   forms are represented\
    \ as bits exchanged between the compressor and\n   the decompressor in the same\
    \ way, as an unsigned string of bits; the\n   most significant bit first.\n  \
    \ The properties of the compressed form of a field are defined by an\n   encoding\
    \ method and/or \"ENFORCE\" statements.  This entirely\n   characterises the relationship\
    \ between the uncompressed and\n   compressed forms of that field.  This is achieved\
    \ by specifying the\n   relationships between the field's attributes.\n   The\
    \ notation defines four field attributes, two for the uncompressed\n   form and\
    \ a corresponding two for the compressed form.  The attributes\n   available for\
    \ each field are:\n   uncompressed attributes of a field:\n   o  \"UVALUE\" and\
    \ \"ULENGTH\",\n   compressed attributes of a field:\n   o  \"CVALUE\" and \"\
    CLENGTH\".\n   The two value attributes contain the respective numerical values\
    \ of\n   the field, i.e., \"UVALUE\" gives the numerical value of the\n   uncompressed\
    \ form of the field, and the attribute \"CVALUE\" gives the\n   numerical value\
    \ of the compressed form of the field.  The numerical\n   values are derived by\
    \ interpreting the bit-string representations of\n   the field as bit strings;\
    \ the most significant bit first.\n   The two length attributes indicate the length\
    \ in bits of the\n   associated bit string; \"ULENGTH\" for the uncompressed form,\
    \ and\n   \"CLENGTH\" for the compressed form.\n   Attributes are undefined unless\
    \ they are bound to a value, in which\n   case they become defined.  If two conflicting\
    \ bindings are given for\n   a field attribute then the bindings fail along with\
    \ the (combination\n   of) formats in which those bindings were defined.\n   Uncompressed\
    \ attributes do not always reflect an aspect of the\n   uncompressed header. \
    \ Some fields do not originate from the\n   uncompressed header, but are control\
    \ fields.\n"
- title: 4.4.1.  Attribute References
  contents:
  - "4.4.1.  Attribute References\n   Attributes of a particular field are formally\
    \ referred to by using\n   the field's name followed by a \".\" and the attribute's\
    \ identifier.\n   For example:\n     rtp_seq_number.UVALUE\n   The above gives\
    \ the uncompressed value of the rtp_seq_number field.\n   The primary reason for\
    \ referencing attributes is for use in\n   expressions, which are explained in\
    \ Section 4.7.\n"
- title: 4.4.2.  Representation of Field Values
  contents:
  - "4.4.2.  Representation of Field Values\n   Fields are represented as bit strings.\
    \  The bit string is calculated\n   using the value attribute (\"val\") and the\
    \ length attribute (\"len\").\n   The bit string is the binary representation\
    \ of \"val % (2 ^ len)\".\n   For example, if a field's \"CLENGTH\" attribute\
    \ was 8, and its \"CVALUE\"\n   attribute was -1, the compressed representation\
    \ of the field would be\n   \"-1 % (2 ^ 8)\", which equals \"-1 % 256\", which\
    \ equals 255, 11111111\n   in binary.\n   ROHC-FN supports the full range of integers\
    \ for use in expressions\n   (see Section 4.7), but the representation of the\
    \ formats (i.e., the\n   bits exchanged between the compressor and the decompressor)\
    \ is in the\n   above form.\n"
- title: 4.5.  Grouping of Fields
  contents:
  - "4.5.  Grouping of Fields\n   Since the order of fields in a \"COMPRESSED\" field\
    \ list\n   (Section 4.12.1.2) do not have to be the same as the order of fields\n\
    \   in an \"UNCOMPRESSED\" field list (Section 4.12.1.1), it is possible to\n\
    \   group together any number of fields that are contiguous in a\n   \"COMPRESSED\"\
    \ format, to allow them all to be encoded using a single\n   encoding method.\
    \  The group of fields is specified immediately to the\n   left of \"=:=\" in\
    \ place of a single field name.\n   The group is notated by giving a colon-separated\
    \ list of the fields\n   to be grouped together.  For example there may be two\
    \ non-contiguous\n   fields in an uncompressed header that are two halves of what\
    \ is\n   effectively a single sequence number:\n     grouping_example\n     {\n\
    \       UNCOMPRESSED {\n         minor_seq_num;  // 12 bits\n         other_field;\
    \    //  8 bits\n         major_seq_num;  //  4 bits\n       }\n       COMPRESSED\
    \ {\n         other_field     =:= irregular(8);\n         major_seq_num\n    \
    \     : minor_seq_num =:= lsb(3, 0);\n       }\n     }\n   The group of fields\
    \ is presented to the encoding method as a\n   contiguous group of bits, assembled\
    \ by the concatenation of the\n   fields in the order they are given in the group.\
    \  The most\n   significant bit of the combined field is the most significant\
    \ bit of\n   the first field in the list, and the least significant bit of the\n\
    \   combined field is the least significant bit of the last field in the\n   list.\n\
    \   Finally, the length attributes of the combined field are equal to the\n  \
    \ sum of the corresponding length attributes for all the fields in the\n   group.\n"
- title: 4.6.  "THIS"
  contents:
  - "4.6.  \"THIS\"\n   Within the definition of an encoding method, it is possible\
    \ to refer\n   to the field (i.e., the group of contiguous bits) the method is\n\
    \   encoding, using the keyword \"THIS\".\n   This is useful for gaining access\
    \ to the attributes of the field\n   being encoded.  For example it is often useful\
    \ to know the total\n   uncompressed length of the uncompressed format that is\
    \ being encoded:\n       THIS.ULENGTH\n"
- title: 4.7.  Expressions
  contents:
  - "4.7.  Expressions\n   ROHC-FN includes the usual infix style of expressions,\
    \ with\n   parentheses \"(\" and \")\" used for grouping.  Expressions can be\
    \ made\n   up of any of the components described in the following subsections.\n\
    \   The semantics of expressions are generally similar to the expressions\n  \
    \ in the ANSI-C programming language [C90].  The definitive list of\n   expressions\
    \ in ROHC-FN follows in the next subsections; the list\n   below provides some\
    \ examples of the difference between expressions in\n   ANSI-C and expressions\
    \ in ROHC-FN:\n   o  There is no limit on the range of integers.\n   o  \"x ^\
    \ y\" evaluates to x raised to the power of y.  This has a\n      precedence higher\
    \ than *, / and %, but lower than unary - and is\n      right to left associative.\n\
    \   o  There is no comma operator.\n   o  There are no \"modify\" operators (no\
    \ assignment operators and no\n      increment or decrement).\n   o  There are\
    \ no bitwise operators.\n   Expressions may refer to any of the attributes of\
    \ a field (as\n   described in Section 4.4), to any defined constant (see Section\
    \ 4.3)\n   and also to encoding method parameters, if any are in scope (see\n\
    \   Section 4.12).\n   If any of the attributes, constants, or parameters used\
    \ in the\n   expression are undefined, the value of the expression is undefined.\n\
    \   Undefined expressions cause the environment (for example, the\n   compressed\
    \ format) in which they are used to fail if a defined value\n   is required. \
    \ Defined values are required for all compressed\n   attributes of fields that\
    \ appear in the compressed format.  Defined\n   values are not required for all\
    \ uncompressed attributes of fields\n   which appear in the uncompressed format.\
    \  It is up to the profile\n   creator to define what happens to the unbound field\
    \ attributes in\n   this case.  It should be noted that in such a case, transparency\
    \ of\n   the compression process will be lost; i.e., it will not be possible\n\
    \   for the decompressor to reproduce the original header.\n   Expressions cannot\
    \ be used as encoding methods directly because they\n   do not completely characterise\
    \ a field.  Expressions only specify a\n   single value whereas a field is made\
    \ up of several values: its\n   attributes.  For example, the following is illegal:\n\
    \      tcp_list_length =:= (data_offset + 20) / 4;\n   There is only enough information\
    \ here to define a single attribute of\n   \"tcp_list_length\".  Although this\
    \ makes no sense formally, this could\n   intuitively be read as defining the\
    \ \"UVALUE\" attribute.  However,\n   that would still leave the length of the\
    \ uncompressed field undefined\n   at the decompressor.  Such usage is therefore\
    \ prohibited.\n"
- title: 4.7.1.  Integer Literals
  contents:
  - "4.7.1.  Integer Literals\n   Integers can be expressed as decimal values, binary\
    \ values (prefixed\n   by \"0b\"), or hexadecimal values (prefixed by \"0x\").\
    \  Negative\n   integers are prefixed by a \"-\" sign.  For example \"10\", \"\
    0b1010\", and\n   \"-0x0a\" are all valid integer literals, having the values\
    \ 10, 10, and\n   -10 respectively.\n"
- title: 4.7.2.  Integer Operators
  contents:
  - "4.7.2.  Integer Operators\n   The following \"integer\" operators are available,\
    \ which take integer\n   arguments and return an integer result:\n   o  ^, for\
    \ exponentiation. \"x ^ y\" returns the value of \"x\" to the\n      power of\
    \ \"y\".\n   o  *, / for multiplication and division. \"x * y\" returns the product\n\
    \      of \"x\" and \"y\". \"x / y\" returns the quotient, rounded down to the\n\
    \      next integer (the next one towards negative infinity).\n   o  +, - for\
    \ addition and subtraction. \"x + y\" returns the sum of \"x\"\n      and \"y\"\
    . \"x - y\" returns the difference.\n   o  % for modulo. \"x % y\" returns \"\
    x\" modulo \"y\"; x - y * (x / y).\n"
- title: 4.7.3.  Boolean Literals
  contents:
  - "4.7.3.  Boolean Literals\n   The boolean literals are \"false\", and \"true\"\
    .\n"
- title: 4.7.4.  Boolean Operators
  contents:
  - "4.7.4.  Boolean Operators\n   The following \"boolean\" operators are available,\
    \ which take boolean\n   arguments and return a boolean result:\n   o  &&, for\
    \ logical \"and\".  Returns true if both arguments are true.\n      Returns false\
    \ otherwise.\n   o  ||, for logical \"or\".  Returns true if at least one argument\
    \ is\n      true.  Returns false otherwise.\n   o  !, for logical \"not\".  Returns\
    \ true if its argument is false.\n      Returns false otherwise.\n"
- title: 4.7.5.  Comparison Operators
  contents:
  - "4.7.5.  Comparison Operators\n   The following \"comparison\" operators are available,\
    \ which take\n   integer arguments and return a boolean result:\n   o  ==, !=,\
    \ for equality and its negative. \"x == y\" returns true if x\n      is equal\
    \ to y.  Returns false otherwise. \"x != y\" returns true if\n      x is not equal\
    \ to y.  Returns false otherwise.\n   o  <, >, for less than and greater than.\
    \ \"x < y\" returns true if x is\n      less than y.  Returns false otherwise.\
    \ \"x > y\" returns true if x\n      is greater than y.  Returns false otherwise.\n\
    \   o  >=, <=, for greater than or equal and less than or equal, the\n      inverse\
    \ functions of <, >. \"x >= y\" returns false if x is less\n      than y.  Returns\
    \ true otherwise. \"x <= y\" returns false if x is\n      greater than y.  Returns\
    \ true otherwise.\n"
- title: 4.8.  Comments
  contents:
  - "4.8.  Comments\n   Free English text can be inserted into a ROHC-FN specification\
    \ to\n   explain why something has been done a particular way, to clarify the\n\
    \   intended meaning of the notation, or to elaborate on some point.\n   The FN\
    \ uses an end of line comment style, which makes use of the \"//\"\n   comment\
    \ marker.  Any text between the \"//\" marker and the end of the\n   line has\
    \ no formal meaning.  For example:\n     //-----------------------------------------------------------------\n\
    \     //    IR-REPLICATE header formats\n     //-----------------------------------------------------------------\n\
    \     // The following fields are included in all of the IR-REPLICATE\n     //\
    \ header formats:\n     //\n     UNCOMPRESSED {\n       discriminator;    // \
    \ 8 bits\n       tcp_seq_number;   // 32 bits\n       tcp_flags_ecn;    //  2\
    \ bits\n   Comments do not affect the formal meaning of what is notated, but can\n\
    \   be used to improve readability.  Their use is optional.\n   Comments may help\
    \ to provide clarifications to the reader, and serve\n   different purposes to\
    \ implementers.  Comments should thus not be\n   considered of lesser importance\
    \ when inserting them into a ROHC-FN\n   specification; they should be consistent\
    \ with the normative part of\n   the specification.\n"
- title: 4.9.  "ENFORCE" Statements
  contents:
  - "4.9.  \"ENFORCE\" Statements\n   The \"ENFORCE\" statement provides a way to\
    \ add predicates to a format,\n   all of which must be fulfilled for the format\
    \ to succeed.  An\n   \"ENFORCE\" statement shares some similarities with an encoding\
    \ method.\n   Specifically, whereas an encoding method binds several field\n \
    \  attributes at once, an \"ENFORCE\" statement typically binds just one\n   of\
    \ them.  In fact, all the bindings that encoding methods create can\n   be expressed\
    \ in terms of a collection of \"ENFORCE\" statements.  Here\n   is an example\
    \ \"ENFORCE\" statement which binds the \"UVALUE\" attribute\n   of a field to\
    \ 5.\n     ENFORCE(field.UVALUE == 5);\n   An \"ENFORCE\" statement must only\
    \ be used inside a field list (see\n   Section 4.12).  It attempts to force the\
    \ expression given to be true\n   for the format that it belongs to.\n   An abbreviated\
    \ form of an \"ENFORCE\" statement is available for\n   binding length attributes\
    \ using \"[\" and \"]\", see Section 4.10.\n   Like an encoding method, an \"\
    ENFORCE\" statement can only be\n   successfully used in a format if the binding\
    \ it describes is\n   achievable.  A format containing the example \"ENFORCE\"\
    \ statement\n   above would not be usable if the field had also been bound within\n\
    \   that same format with \"uncompressed_value\" encoding, which gave it a\n \
    \  \"UVALUE\" other than 5.\n   An \"ENFORCE\" statement takes a boolean expression\
    \ as a parameter.  It\n   can be used to assert that the expression is true, in\
    \ order to choose\n   a particular format from a list of possible formats specified\
    \ in an\n   encoding method (see Section 4.12), or just to bind an expression\
    \ as\n   in the example above.  The general form of an \"ENFORCE\" statement is\n\
    \   therefore:\n     ENFORCE(<boolean expression>);\n   There are three possible\
    \ conditions that the expression may be in:\n   1.  The boolean expression evaluates\
    \ to false, in which case the\n       local scope of the format that contains\
    \ the \"ENFORCE\" statement\n       cannot be used.\n   2.  The boolean expression\
    \ evaluates to true, in which case the\n       binding is created and successful.\n\
    \   3.  The value of the boolean expression is undefined.  In this case,\n   \
    \    the binding is also created and successful.\n   In all three cases, any undefined\
    \ term becomes bound by the\n   expression.  Generally speaking, an \"ENFORCE\"\
    \ statement is either\n   being used as an assignment (condition 3 above) or being\
    \ used to test\n   if a particular format is usable, as is the case with conditions\
    \ 1\n   and 2.\n"
- title: 4.10.  Formal Specification of Field Lengths
  contents:
  - "4.10.  Formal Specification of Field Lengths\n   In many of the examples each\
    \ field has been followed by a comment\n   indicating the length of the field.\
    \  Indicating the length of a field\n   like this is optional, but can be very\
    \ helpful for the reader.\n   However, whilst useful to the reader, comments have\
    \ no formal\n   meaning.\n   One of the most common uses for \"ENFORCE\" statements\
    \ (see\n   Section 4.9) is to explicitly define the length of a field within a\n\
    \   header.  Using \"ENFORCE\" statements for this purpose has formal\n   meaning\
    \ but is not so easy to read.  Therefore, an abbreviated form\n   is provided\
    \ for this use of \"ENFORCE\", which is both easy to read and\n   has formal meaning.\n\
    \   An expression defining the length of a field can be specified in\n   square\
    \ brackets after the appearance of that field in a format.  If\n   the field can\
    \ take several alternative lengths, then the expressions\n   defining those lengths\
    \ can be enumerated as a comma separated list\n   within the square brackets.\
    \  For example:\n     field_1                  [ 4 ];\n     field_2          \
    \        [ a+b, 2 ];\n     field_3 =:= lsb(16, 16)  [ 26 ];\n   The actual length\
    \ attribute, which is bound by this notation, depends\n   on whether it appears\
    \ in a \"COMPRESSED\", \"UNCOMPRESSED\", or \"CONTROL\"\n   field list (see Section\
    \ 4.12.1 and its subsections).  In a\n   \"COMPRESSED\" field list, the field's\
    \ \"CLENGTH\" attribute is bound.\n   In \"UNCOMPRESSED\" and \"CONTROL\" field\
    \ lists, the field's \"ULENGTH\"\n   attribute is bound.  Abbreviated \"ENFORCE\"\
    \ statements are not allowed\n   in \"DEFAULT\" sections (see Section 4.12.1.5).\
    \  Therefore, the above\n   notation would not be allowed to appear in a \"DEFAULT\"\
    \ section.\n   However, if the above appeared in an \"UNCOMPRESSED\" or \"CONTROL\"\
    \n   section, it would be equivalent to:\n     field_1;                 ENFORCE(field_1.ULENGTH\
    \ == 4);\n     field_2;                 ENFORCE((field_2.ULENGTH == 2)\n     \
    \                              || (field_2.ULENGTH == a+b));\n     field_3 =:=\
    \ lsb(16, 16); ENFORCE(field_3.ULENGTH == 26);\n   A special case exists for fields\
    \ that have a variable length that the\n   notator does not wish, or is not able\
    \ to, define using an expression.\n   The keyword \"VARIABLE\" can be used in\
    \ the following case:\n     variable_length_field  [ VARIABLE ];\n   Formally,\
    \ this provides no restrictions on the field length, but maps\n   onto any positive\
    \ integer or to a value of zero.  It will therefore\n   be necessary to define\
    \ the length of the field elsewhere (see the\n   final paragraphs of Section 4.12.1.1\
    \ and Section 4.12.1.2).  This may\n   either be in the notation or in the English\
    \ text of the profile\n   within which the FN is contained.  Within the square\
    \ brackets, the\n   keyword \"VARIABLE\" may be used as a term in an expression,\
    \ just like\n   any other term that normally appears in an expression.  For example:\n\
    \         field  [ 8 * (5 + VARIABLE) ];\n   This defines a field whose length\
    \ is a whole number of octets and at\n   least 40 bits (5 octets).\n"
- title: 4.11.  Library of Encoding Methods
  contents:
  - "4.11.  Library of Encoding Methods\n   A number of common techniques for compressing\
    \ header fields are\n   defined as part of the ROHC-FN library so that they can\
    \ be reused\n   when creating new ROHC-FN specifications.  Their notation is\n\
    \   described below.\n   As an alternative, or a complement, to this library of\
    \ encoding\n   methods, a ROHC-FN specification can define its own set of encoding\n\
    \   methods, using the formal notation (see Section 4.12) or using a\n   textual\
    \ definition (see Section 4.13).\n"
- title: 4.11.1.  uncompressed_value
  contents:
  - "4.11.1.  uncompressed_value\n   The \"uncompressed_value\" encoding method is\
    \ used to encode header\n   fields for which the uncompressed value can be defined\
    \ using a\n   mathematical expression (including constant values).  This encoding\n\
    \   method is defined as follows:\n     uncompressed_value(len, val) {\n     \
    \  UNCOMPRESSED {\n         field;\n         ENFORCE(field.ULENGTH == len);\n\
    \         ENFORCE(field.UVALUE == val);\n       }\n       COMPRESSED {\n     \
    \    field;\n         ENFORCE(field.CLENGTH == 0);\n       }\n     }\n   To exemplify\
    \ the usage of \"uncompressed_value\" encoding, the IPv6\n   header version number\
    \ is a 4-bit field that always has the value 6:\n     version   =:=   uncompressed_value(4,\
    \ 6);\n   Here is another example of value encoding, using an expression to\n\
    \   calculate the length:\n     padding =:= uncompressed_value(nbits - 8, 0);\n\
    \   The expression above uses an encoding method parameter, \"nbits\", that\n\
    \   in this example specifies how many significant bits there are in the\n   data\
    \ to calculate how many pad bits to use.  See Section 4.12.2 for\n   more information\
    \ on encoding method parameters.\n"
- title: 4.11.2.  compressed_value
  contents:
  - "4.11.2.  compressed_value\n   The \"compressed_value\" encoding method is used\
    \ to define fields in\n   compressed formats for which there is no counterpart\
    \ in the\n   uncompressed format (i.e., control fields).  It can be used to\n\
    \   specify compressed fields whose value can be defined using a\n   mathematical\
    \ expression (including constant values).  This encoding\n   method is defined\
    \ as follows:\n     compressed_value(len, val) {\n       UNCOMPRESSED {\n    \
    \     field;\n         ENFORCE(field.ULENGTH == 0);\n       }\n       COMPRESSED\
    \ {\n         field;\n         ENFORCE(field.CLENGTH == len);\n         ENFORCE(field.CVALUE\
    \ == val);\n       }\n     }\n   One possible use of this encoding method is to\
    \ define padding in a\n   compressed format:\n     pad_to_octet_boundary     \
    \ =:=   compressed_value(3, 0);\n   A more common use is to define a discriminator\
    \ field to make it\n   possible to differentiate between different compressed\
    \ formats within\n   an encoding method (see Section 4.12).  For convenience,\
    \ the notation\n   provides syntax for specifying \"compressed_value\" encoding\
    \ in the\n   form of a binary string.  The binary string to be encoded is simply\n\
    \   given in single quotes; the \"CLENGTH\" attribute of the field binds\n   with\
    \ the number of bits in the string, while its \"CVALUE\" attribute\n   binds with\
    \ the value given by the string.  For example:\n     discriminator     =:=   '01101';\n\
    \   This has exactly the same meaning as:\n     discriminator     =:=   compressed_value(5,\
    \ 13);\n"
- title: 4.11.3.  irregular
  contents:
  - "4.11.3.  irregular\n   The \"irregular\" encoding method is used to encode a\
    \ field in the\n   compressed format with a bit pattern identical to the uncompressed\n\
    \   field.  This encoding method is defined as follows:\n     irregular(len) {\n\
    \       UNCOMPRESSED {\n         field;\n         ENFORCE(field.ULENGTH == len);\n\
    \       }\n       COMPRESSED {\n         field;\n         ENFORCE(field.CLENGTH\
    \ == len);\n         ENFORCE(field.CVALUE == field.UVALUE);\n       }\n     }\n\
    \   For example, the checksum field of the TCP header is a 16-bit field\n   that\
    \ does not follow any predictable pattern from one header to\n   another (and\
    \ so it cannot be compressed):\n     tcp_checksum  =:=   irregular(16);\n   Note\
    \ that the length does not have to be constant, for example, an\n   expression\
    \ can be used to derive the length of the field from the\n   value of another\
    \ field.\n"
- title: 4.11.4.  static
  contents:
  - "4.11.4.  static\n   The \"static\" encoding method compresses a field whose length\
    \ and\n   value are the same as for a previous header in the flow, i.e., where\n\
    \   the field completely matches an existing entry in the context:\n     field\
    \            =:=   static;\n   The field's \"UVALUE\" and \"ULENGTH\" attributes\
    \ bind with their\n   respective values in the context and the \"CLENGTH\" attribute\
    \ is bound\n   to zero.\n   Since the field value is the same as a previous field\
    \ value, the\n   entire field can be reconstructed from the context, so it is\n\
    \   compressed to zero bits and does not appear in the compressed format.\n  \
    \ For example, the source port of the TCP header is a field whose value\n   does\
    \ not change from one packet to the next for a given flow:\n     src_port  =:=\
    \   static;\n"
- title: 4.11.5.  lsb
  contents:
  - "4.11.5.  lsb\n   The least significant bits encoding method, \"lsb\", compresses\
    \ a field\n   whose value differs by a small amount from the value stored in the\n\
    \   context.  The least significant bits of the field value are\n   transmitted\
    \ instead of the original field value.\n     field  =:=   lsb(<num_lsbs_param>,\
    \ <offset_param>);\n   Here, \"num_lsbs_param\" is the number of least significant\
    \ bits to\n   use, and \"offset_param\" is the interpretation interval offset\
    \ as\n   defined below.\n   The parameter \"num_lsbs_param\" binds with the \"\
    CLENGTH\" attribute,\n   the \"UVALUE\" attribute binds to the value within the\
    \ interval whose\n   least significant bits match the \"CVALUE\" attribute.  The\
    \ value of\n   the \"ULENGTH\" can be derived from the information stored in the\n\
    \   context.\n   For example, the TCP sequence number:\n     tcp_sequence_number\
    \   =:=   lsb(14, 8192);\n   This takes up 14 bits, and can communicate any value\
    \ that is between\n   8192 lower than the value of the field stored in context\
    \ and 8191\n   above it.\n   The interpretation interval can be described as a\
    \ function of a value\n   stored in the context, ref_value, and of num_lsbs_param:\n\
    \     f(context_value, num_lsbs_param) = [ref_value - offset_param,\n        \
    \        ref_value + (2^num_lsbs_param - 1) - offset_param]\n   where offset_param\
    \ is an integer.\n          <-- interpretation interval (size is 2^num_lsbs_param)\
    \ -->\n          |---------------------------+----------------------------|\n\
    \        lower                     ref_value                      upper\n    \
    \    bound                                                    bound\n   where:\n\
    \        lower bound = ref_value - offset_param\n        upper bound = ref_value\
    \ + (2^num_lsbs_param-1) - offset_param\n   The \"lsb\" encoding method can therefore\
    \ compress a field whose value\n   lies between the lower and the upper bounds,\
    \ inclusively, of the\n   interpretation interval.  In particular, if offset_param\
    \ = 0, then\n   the field value can only stay the same or increase relative to\
    \ the\n   reference value ref_value.  If offset_param = -1, then it can only\n\
    \   increase, whereas if offset_param = 2^num_lsbs_param, then it can\n   only\
    \ decrease.\n   The compressed field takes up the specified number of bits in\
    \ the\n   compressed format (i.e., num_lsbs_param).\n   The compressor may not\
    \ be able to determine the exact reference value\n   stored in the decompressor\
    \ context and that will be used by the\n   decompressor, since some packets that\
    \ would have updated the context\n   may have been lost or damaged.  However,\
    \ from feedback received or by\n   making assumptions, the compressor can limit\
    \ the candidate set of\n   values.  The compressor can then select a format that\
    \ uses \"lsb\"\n   encoding, defined with suitable values for its parameters\n\
    \   num_lsbs_param and offset_param, such that no matter which context\n   value\
    \ in the candidate set the decompressor uses, the resulting\n   decompression\
    \ is correct.  If that is not possible, the \"lsb\"\n   encoding method fails\
    \ (which typically results in a less efficient\n   compressed format being chosen\
    \ by the compressor).  How the\n   compressor determines what reference values\
    \ it stores and maintains\n   in its set of candidate references is outside the\
    \ scope of the\n   notation.\n"
- title: 4.11.6.  crc
  contents:
  - "4.11.6.  crc\n   The \"crc\" encoding method provides a CRC calculated over a\
    \ block of\n   data.  The algorithm used to calculate the CRC is the one specified\n\
    \   in [RFC4995].  The \"crc\" method takes a number of parameters:\n   o  the\
    \ number of bits for the CRC (crc_bits),\n   o  the bit-pattern for the polynomial\
    \ (bit_pattern),\n   o  the initial value for the CRC register (initial_value),\n\
    \   o  the value of the block of data, represented using either the\n      \"\
    UVALUE\" or \"CVALUE\" attribute of a field (block_data_value); and\n   o  the\
    \ size in octets of the block of data (block_data_length).\n   That is:\n    \
    \ field   =:=   crc(<num_bits>, <bit_pattern>, <initial_value>,\n            \
    \           <block_data_value>, <block_data_length>);\n   When specifying the\
    \ bit pattern for the polynomial, each bit\n   represents the coefficient for\
    \ the corresponding term in the\n   polynomial.  Note that the highest order term\
    \ is always present (by\n   definition) and therefore does not need specifying\
    \ in the bit\n   pattern.  Therefore, a CRC polynomial with n terms in it is\n\
    \   represented by a bit pattern with n-1 bits set.\n   The CRC is calculated\
    \ in least significant bit (LSB) order.\n   For example:\n     // 3 bit CRC, C(x)\
    \ = x^0 + x^1 + x^3\n     crc_field =:= crc(3, 0x6, 0xF, THIS.CVALUE, THIS.CLENGTH);\n\
    \   Usage of the \"THIS\" keyword (see Section 4.6) as shown above, is\n   typical\
    \ when using \"crc\" encoding.  For example, when used in the\n   encoding method\
    \ for an entire header, it causes the CRC to be\n   calculated over all fields\
    \ in the header.\n"
- title: 4.12.  Definition of Encoding Methods
  contents:
  - "4.12.  Definition of Encoding Methods\n   New encoding methods can be defined\
    \ in a formal specification.  These\n   compose groups of individual fields into\
    \ a contiguous block.\n   Encoding methods have names and may have parameters;\
    \ they can also be\n   used in the same way as any other encoding method from\
    \ the library of\n   encoding methods.  Since they can contain references to other\n\
    \   encoding methods, complicated formats can be broken down into\n   manageable\
    \ pieces in a hierarchical fashion.\n   This section describes the various features\
    \ used to define new\n   encoding methods.\n"
- title: 4.12.1.  Structure
  contents:
  - "4.12.1.  Structure\n   This simplest form of defining an encoding method is to\
    \ specify a\n   single encoding.  For example:\n     compound_encoding_method\n\
    \     {\n       UNCOMPRESSED {\n         field_1;  //  4 bits\n         field_2;\
    \  // 12 bits\n       }\n       COMPRESSED {\n         field_2 =:= uncompressed_value(12,\
    \ 9); //  0 bits\n         field_1 =:= irregular(4);              //  4 bits\n\
    \       }\n     }\n   The above begins with the new method's identifier,\n   \"\
    compound_encoding_method\".  The definition of the method then\n   follows inside\
    \ curly brackets, \"{\" and \"}\".  The first item in the\n   definition is the\
    \ \"UNCOMPRESSED\" field list, which gives the order of\n   the fields in the\
    \ uncompressed format.  This is followed by the\n   compressed format field list\
    \ (\"COMPRESSED\").  This list gives the\n   order of fields in the compressed\
    \ format and also gives the encoding\n   method for each field.\n   In the example,\
    \ both the formats list each field exactly once.\n   However, sometimes it is\
    \ necessary to specify more than one binding\n   for a given field, which means\
    \ it appears more than once in the field\n   list.  In this case, it is the first\
    \ occurrence of the field in the\n   list that indicates its position in the field\
    \ order.  The subsequent\n   occurrences of the field only specify binding information,\
    \ not field\n   order information.\n   The different components of this example\
    \ are described in more detail\n   below.  Other components that can be used in\
    \ the definition of\n   encoding methods are also defined thereafter.\n"
- title: 4.12.1.1.  Uncompressed Format - "UNCOMPRESSED"
  contents:
  - "4.12.1.1.  Uncompressed Format - \"UNCOMPRESSED\"\n   The uncompressed field\
    \ list is defined by \"UNCOMPRESSED\", which\n   specifies the fields of the uncompressed\
    \ format in the order that\n   they appear in the uncompressed header.  The sum\
    \ of the lengths of\n   each individual uncompressed field in the list must be\
    \ equal to the\n   length of the field being encoded.  Finally, the representation\
    \ of\n   the uncompressed format described using the list of fields in the\n \
    \  \"UNCOMPRESSED\" section, for which compressed formats are being\n   defined,\
    \ always consists of one single contiguous block of bits.\n   In the example above\
    \ in Section 4.12.1, the uncompressed field list\n   is \"field_1\", followed\
    \ by \"field_2\".  This means that a field being\n   encoded by this method is\
    \ divided into two subfields, \"field_1\" and\n   \"field_2\".  The total uncompressed\
    \ length of these two fields\n   therefore equals the length of the field being\
    \ encoded:\n     field_1.ULENGTH + field_2.ULENGTH == THIS.ULENGTH\n   In the\
    \ example, there are only two fields, but any number of fields\n   may be used.\
    \  This relationship applies to however many fields are\n   actually used.  Any\
    \ arrangement of fields that efficiently describes\n   the content of the uncompressed\
    \ header may be chosen -- this need not\n   be the same as the one described in\
    \ the specifications for the\n   protocol header being compressed.\n   For example,\
    \ there may be a protocol whose header contains a 16-bit\n   sequence number,\
    \ but whose sessions tend to be short-lived.  This\n   would mean that the high\
    \ bits of the sequence number are almost\n   always constant.  The \"UNCOMPRESSED\"\
    \ format could reflect this by\n   splitting the original uncompressed field into\
    \ two fields, one field\n   to represent the almost-always-zero part of the sequence\
    \ number, and\n   a second field to represent the salient part.\n   An \"UNCOMPRESSED\"\
    \ field list may specify encoding methods in the same\n   way as the \"COMPRESSED\"\
    \ field list in the example.  Encoding methods\n   specified therein are used\
    \ whenever a packet with that uncompressed\n   format is being encoded.  The encoding\
    \ of a packet with a given\n   uncompressed format can only succeed if all of\
    \ its encoding methods\n   and \"ENFORCE\" statements succeed (see Section 4.9).\n\
    \   The total length of each uncompressed format must always be defined.\n   The\
    \ length of each of the fields in an uncompressed format must also\n   be defined.\
    \  This means that the bindings in the \"UNCOMPRESSED\",\n   \"COMPRESSED\" (see\
    \ Section 4.12.1.2 below), \"CONTROL\" (see\n   Section 4.12.1.3 below), \"INITIAL\"\
    \ (see Section 4.12.1.4 below), and\n   \"DEFAULT\" (see Section 4.12.1.5 below)\
    \ field lists must, between\n   them, define the \"ULENGTH\" attribute of every\
    \ field in an\n   uncompressed format so that there is an unambiguous mapping\
    \ from the\n   bits in the uncompressed format to the fields listed in the\n \
    \  \"UNCOMPRESSED\" field list.\n"
- title: 4.12.1.2.  Compressed Format - "COMPRESSED"
  contents:
  - "4.12.1.2.  Compressed Format - \"COMPRESSED\"\n   Similar to the uncompressed\
    \ field list, the fields in the compressed\n   header will appear in the order\
    \ specified by the compressed field\n   list given for a compressed format.  Each\
    \ individual field is encoded\n   in the manner given for that field.  The total\
    \ length of the\n   compressed data will be the sum of the compressed lengths\
    \ of all the\n   individual fields.  In the example from Section 4.12.1, the encoding\n\
    \   methods used for these fields indicate that they are zero and 4 bits\n   long,\
    \ making a total of 4 bits.\n   The order of the fields specified in a \"COMPRESSED\"\
    \ field list does\n   not have to match the order they appear in the \"UNCOMPRESSED\"\
    \ field\n   list.  It may be desirable to reorder the fields in the compressed\n\
    \   format to align the compressed header to the octet boundary, or for\n   other\
    \ reasons.  In the above example, the order is in fact the\n   opposite of that\
    \ in the uncompressed format.\n   The compressed field list specifies that the\
    \ encoding for \"field_1\"\n   is \"irregular\", and takes up 4 bits in both the\
    \ compressed format and\n   uncompressed format.  The encoding for \"field_2\"\
    \ is\n   \"uncompressed_value\", which means that the field has a fixed value,\n\
    \   so it can be compressed to zero bits.  The value it takes is 9, and\n   it\
    \ is 12 bits wide in the uncompressed format.\n   Fields like \"field_2\", which\
    \ compress to zero bits in length, may\n   appear anywhere in the field list without\
    \ changing the compressed\n   format because their position in the list is not\
    \ significant.  In\n   fact, if the encoding method for this field were defined\
    \ elsewhere\n   (for example, in the \"UNCOMPRESSED\" section), this field could\
    \ be\n   omitted from the \"COMPRESSED\" section altogether:\n     compound_encoding_method\n\
    \     {\n       UNCOMPRESSED {\n         field_1;                            \
    \    //  4 bits\n         field_2 =:= uncompressed_value(12, 9);  // 12 bits\n\
    \       }\n       COMPRESSED {\n         field_1 =:= irregular(4);           \
    \    //  4 bits\n       }\n     }\n   The total length of each compressed format\
    \ must always be defined.\n   The length of each of the fields in a compressed\
    \ format must also be\n   defined.  This means that the bindings in the \"UNCOMPRESSED\"\
    ,\n   \"COMPRESSED\", \"CONTROL\" (see Section 4.12.1.3 below), \"INITIAL\" (see\n\
    \   Section 4.12.1.4 below), and \"DEFAULT\" (see Section 4.12.1.5 below)\n  \
    \ field lists must between them define the \"CLENGTH\" attribute of every\n  \
    \ field in a compressed format so that there is an unambiguous mapping\n   from\
    \ the bits in the compressed format to the fields listed in the\n   \"COMPRESSED\"\
    \ field list.\n"
- title: 4.12.1.3.  Control Fields - "CONTROL"
  contents:
  - "4.12.1.3.  Control Fields - \"CONTROL\"\n   Control fields are defined using\
    \ the \"CONTROL\" field list.  The\n   control field list specifies all fields\
    \ that do not appear in the\n   uncompressed format, but that have an uncompressed\
    \ value\n   (specifically those with an \"ULENGTH\" greater than zero).  Such\n\
    \   fields may be used to help compress fields from the uncompressed\n   format\
    \ more efficiently.  A control field could be used to improve\n   efficiency by\
    \ representing some commonality between a number of the\n   uncompressed fields,\
    \ or by representing some information about the\n   flow that is not explicitly\
    \ contained in the protocol headers.\n   For example in IPv4, the behaviour of\
    \ the IP-ID field in a flow\n   varies depending on how the endpoints handle IP-IDs.\
    \  Sometimes the\n   behaviour is effectively random and sometimes the IP-ID follows\
    \ a\n   predictable sequence.  The type of IP-ID behaviour is information\n  \
    \ that is never communicated explicitly in the uncompressed header.\n   However,\
    \ a profile can still be designed to identify the behaviour\n   and adjust the\
    \ compression strategy according to the identified\n   behaviour, thereby improving\
    \ the compression performance.  To do so,\n   the ROHC-FN specification can introduce\
    \ an explicit field to\n   communicate the IP-ID behaviour in compressed format\
    \ -- this is done\n   by introducing a control field:\n     ipv4\n     {\n   \
    \    UNCOMPRESSED {\n         version;       // 4 bits\n         hdr_length; \
    \   // 4 bits\n         protocol;      // 8 bits\n         dscp;          // 6\
    \ bits\n         ip_ecn_flags;  // 2 bits\n         ttl_hopl;      // 8 bits\n\
    \         df;            // 1 bit\n         mf;            // 1 bit\n        \
    \ rf;            // 1 bit\n         frag_offset;   // 13 bits\n         ip_id;\
    \         // 16 bits\n         src_addr;      // 32 bits\n         dst_addr; \
    \     // 32 bits\n         checksum;      // 16 bits\n         length;       \
    \ // 16 bits\n       }\n       CONTROL {\n         ip_id_behavior; // 1 bit\n\
    \            :\n            :\n   The \"CONTROL\" field list is equivalent to\
    \ the \"UNCOMPRESSED\" field\n   list for fields that do not appear in the uncompressed\
    \ format.  It\n   defines a field that has the same properties (the same defined\n\
    \   attributes, etc.) as fields appearing in the uncompressed format.\n   Control\
    \ fields are initialised by using the appropriate encoding\n   methods and/or\
    \ by using \"ENFORCE\" statements.  This may be done\n   inside the \"CONTROL\"\
    \ field list.\n   For example:\n     example_encoding_method_definition\n    \
    \ {\n       UNCOMPRESSED {\n         field_1 =:= some_encoding;\n       }\n  \
    \     CONTROL {\n         scaled_field;\n         ENFORCE(scaled_field.UVALUE\
    \ == field_1.UVALUE / 8);\n         ENFORCE(scaled_field.ULENGTH == field_1.ULENGTH\
    \ - 3);\n       }\n       COMPRESSED {\n         scaled_field =:= lsb(4, 0);\n\
    \       }\n     }\n   This control field is used to scale down a field in the\
    \ uncompressed\n   format by a factor of 8 before encoding it with the \"lsb\"\
    \ encoding\n   method.  Scaling it down makes the \"lsb\" encoding more efficient.\n\
    \   Control fields may also be used with a global scope.  In this case,\n   their\
    \ declaration must be outside of any encoding method definition.\n   They are\
    \ then visible within any encoding method, thus allowing\n   information to be\
    \ shared between encoding methods directly.\n"
- title: 4.12.1.4.  Initial Values - "INITIAL"
  contents:
  - "4.12.1.4.  Initial Values - \"INITIAL\"\n   In order to allow fields in the very\
    \ first usage of a specific format\n   to be compressed with \"static\", \"lsb\"\
    , or other encoding methods that\n   depend on the context, it is possible to\
    \ specify initial bindings for\n   such fields.  This is done using \"INITIAL\"\
    , for example:\n     INITIAL {\n        field =:= uncompressed_value(4, 6);\n\
    \     }\n   This initialises the \"UVALUE\" of \"field\" to 6 and initialises\
    \ its\n   \"ULENGTH\" to 4.  Unlike all other bindings specified in the formal\n\
    \   notation, these bindings are applied to the context of the field, if\n   the\
    \ field's context is undefined.  This is particularly useful when\n   using encoding\
    \ methods that rely on context being present, such as\n   \"static\" or \"lsb\"\
    , with the first packet in a flow.\n   Because the \"INITIAL\" field list is used\
    \ to bind the context alone,\n   it makes no sense to specify initial bindings\
    \ that themselves rely on\n   the context, for example, \"lsb\".  Such usage is\
    \ not allowed.\n"
- title: 4.12.1.5.  Default Field Bindings - "DEFAULT"
  contents:
  - "4.12.1.5.  Default Field Bindings - \"DEFAULT\"\n   Default bindings may be specified\
    \ for each field or attribute.  The\n   default encoding methods specify the encoding\
    \ method to use for a\n   field if no binding is given elsewhere for the value\
    \ of that field.\n   This is helpful to keep the definition of the formats concise,\
    \ as the\n   same encoding method need not be repeated for every format, when\n\
    \   defining multiple formats (see Section 4.12.3).\n   Default bindings are optional\
    \ and may be given for any combination of\n   fields and attributes which are\
    \ in scope.\n   The syntax for specifying default bindings is similar to that\
    \ used to\n   specify a compressed or uncompressed format.  However, the order\
    \ of\n   the fields in the field list does not affect the order of the fields\n\
    \   in either the compressed or uncompressed format.  This is because the\n  \
    \ field order is specified individually for each \"COMPRESSED\" format\n   and\
    \ \"UNCOMPRESSED\" format.\n   Here is an example:\n       DEFAULT {\n       \
    \  field_1 =:= uncompressed_value(4, 1);\n         field_2 =:= uncompressed_value(4,\
    \ 2);\n         field_3 =:= lsb(3, -1);\n         ENFORCE(field_4.ULENGTH == 4);\n\
    \       }\n   Here default bindings are specified for fields 1 to 3.  A default\n\
    \   binding for the \"ULENGTH\" attribute of field_4 is also specified.\n   Fields\
    \ for which there is a default encoding method do not need their\n   bindings\
    \ to be specified in the field list of any format that uses\n   the default encoding\
    \ method for that field.  Any format that does not\n   use the default encoding\
    \ method must explicitly specify a binding for\n   the value of that field's attributes.\n\
    \   If elsewhere a binding is not specified for the attributes of a\n   field,\
    \ the default encoding method is used.  If the default encoding\n   method always\
    \ compresses the field down to zero bits, the field can\n   be omitted from the\
    \ compressed format's field list.  Like any other\n   zero-bit field, its position\
    \ in the field list is not significant.\n   The \"DEFAULT\" field list may contain\
    \ default bindings for individual\n   attributes by using \"ENFORCE\" statements.\
    \  A default binding for an\n   individual attribute will only be used if elsewhere\
    \ there is no\n   binding given for that attribute or the field to which it belongs.\n\
    \   If elsewhere there is an \"ENFORCE\" statement binding that attribute,\n \
    \  or an encoding method binding the field to which it belongs, the\n   default\
    \ binding for the attribute will not be used.  This applies\n   even if the specified\
    \ encoding method does not bind the particular\n   attribute given in the \"DEFAULT\"\
    \ section.  However, an \"ENFORCE\"\n   statement elsewhere that only binds the\
    \ length of the field still\n   allows the default bindings to be used, except\
    \ for default \"ENFORCE\"\n   statements which bind nothing but the field's length.\n\
    \   To clarify, assuming the default bindings given in the example above,\n  \
    \ the first three of the following four compressed formats would not\n   use the\
    \ default binding for \"field_4.ULENGTH\":\n       COMPRESSED format1 {\n    \
    \     ENFORCE(field_4.ULENGTH == 3); // set ULENGTH to 3\n         ENFORCE(field_4.UVALUE\
    \ == 7);  // set UVALUE to 7\n       }\n       COMPRESSED format2 {\n        \
    \ field_4 =:= irregular(3);      // set ULENGTH to 3\n       }\n       COMPRESSED\
    \ format3 {\n         field_4 =:= '1010';            // set ULENGTH to zero\n\
    \       }\n       COMPRESSED format4 {\n         ENFORCE(field_4.UVALUE == 12);\
    \ // use default ULENGTH\n       }\n   The fourth format is the only one that\
    \ uses the default binding for\n   \"field_4.ULENGTH\".\n   In summary, the default\
    \ bindings of an encoding method are only used\n   for formats that do not already\
    \ specify a binding for the value of\n   all of their fields.  For the formats\
    \ that do use default bindings,\n   only those fields and attributes whose bindings\
    \ are not specified are\n   looked up in the \"DEFAULT\" field list.\n"
- title: 4.12.2.  Arguments
  contents:
  - "4.12.2.  Arguments\n   Encoding methods may take arguments that control the mapping\
    \ between\n   compressed and uncompressed fields.  These are specified immediately\n\
    \   after the method's name, in parentheses, as a comma-separated list.\n   For\
    \ example:\n     poor_mans_lsb(variable_length)\n     {\n       UNCOMPRESSED {\n\
    \         constant_bits;\n         variable_bits;\n       }\n       COMPRESSED\
    \ {\n         variable_bits =:= irregular(variable_length);\n         constant_bits\
    \ =:= static;\n       }\n     }\n   As with any encoding method, all arguments\
    \ take individual values,\n   such as an integer literal or a field attribute,\
    \ rather than entire\n   fields.  Although entire fields cannot be passed as arguments,\
    \ it is\n   possible to pass each of their attributes instead, which is\n   equivalent.\n\
    \   Recall that all bindings are two-way, so that rather than the\n   arguments\
    \ acting as \"inputs\" to the encoding method, the result of an\n   encoding method\
    \ may be to bind the parameters passed to it.\n   For example:\n     set_to_double(arg1,\
    \ arg2)\n     {\n       CONTROL {\n         ENFORCE(arg1 == 2 * arg2);\n     \
    \  }\n     }\n   This encoding method will attempt to bind the first argument\
    \ to twice\n   the value of the second.  In fact this \"encoding\" method is\n\
    \   pathological.  Since it defines no fields, it does not do any actual\n   encoding\
    \ at all.  \"CONTROL\" sections are more appropriate to use for\n   this purpose\
    \ than \"UNCOMPRESSED\".\n"
- title: 4.12.3.  Multiple Formats
  contents:
  - "4.12.3.  Multiple Formats\n   Encoding methods can also define multiple formats\
    \ for a given header.\n   This allows different compression methods to be used\
    \ depending on\n   what is the most efficient way of compressing a particular\
    \ header.\n   For example, a field may have a fixed value most of the time, but\
    \ the\n   value may occasionally change.  Using a single format for the\n   encoding,\
    \ this field would have to be encoded using \"irregular\" (see\n   Section 4.11.3),\
    \ even though the value only changes rarely.  However,\n   by defining multiple\
    \ formats, we can provide two alternative\n   encodings: one for when the value\
    \ remains fixed and another for when\n   the value changes.\n   This is the topic\
    \ of the following sub-sections.\n"
- title: 4.12.3.1.  Naming Convention
  contents:
  - "4.12.3.1.  Naming Convention\n   When compressed formats are defined, they must\
    \ be defined using the\n   reserved word \"COMPRESSED\".  Similarly, uncompressed\
    \ formats must be\n   defined using the reserved word \"UNCOMPRESSED\".  After\
    \ each of these\n   keywords, a name may be given for the format.  If no name\
    \ is given to\n   the format, the name of the format is empty.\n   Format names,\
    \ except for the case where the name is empty, follow the\n   syntactic rules\
    \ of identifiers as described in Section 4.2.\n   Format names must be unique\
    \ within the scope of the encoding method\n   to which they belong, except for\
    \ the empty name, which may be used\n   for one \"COMPRESSED\" and one \"UNCOMPRESSED\"\
    \ format.\n"
- title: 4.12.3.2.  Format Discrimination
  contents:
  - "4.12.3.2.  Format Discrimination\n   Each of the compressed formats has its own\
    \ field list.  A compressor\n   may pick any of these alternative formats to compress\
    \ a header, as\n   long as the field bindings it employs can be used with the\n\
    \   uncompressed format.  For example, the compressor could not choose to\n  \
    \ use a compressed format that had a \"static\" encoding for a field\n   whose\
    \ \"UVALUE\" attribute differs from its corresponding value in the\n   context.\n\
    \   More formally, the compressor can choose any combination of an\n   uncompressed\
    \ format and a compressed format for which no binding for\n   any of the field's\
    \ attributes \"fail\", i.e., the encoding methods and\n   \"ENFORCE\" statements\
    \ (see Section 4.9) that bind their compressed\n   attributes succeed.  If there\
    \ are multiple successful combinations,\n   the compressor can choose any one.\
    \  Otherwise if there are no\n   successful combinations, the encoding method\
    \ \"fails\".  A format will\n   never fail due to it not defining the \"UVALUE\"\
    \ attribute of a field.\n   A format only fails if it fails to define one of the\
    \ compressed\n   attributes of one of the fields in the compressed format, or\
    \ leaves\n   the length of the uncompressed format undefined.\n   Because the\
    \ compressor has a choice, it must be possible for the\n   decompressor to discriminate\
    \ between the different compressed formats\n   that the compressor could have\
    \ chosen.  A simple approach to this\n   problem is for each compressed format\
    \ to include a \"discriminator\"\n   that uniquely identifies that particular\
    \ \"COMPRESSED\" format.  A\n   discriminator is a control field; it is not derived\
    \ from any of the\n   uncompressed field values (see Section 4.11.2).\n"
- title: 4.12.3.3.  Example of Multiple Formats
  contents:
  - "4.12.3.3.  Example of Multiple Formats\n   Putting this all together, here is\
    \ a complete example of the\n   definition of an encoding method with multiple\
    \ compressed formats:\n     example_multiple_formats\n     {\n       UNCOMPRESSED\
    \ {\n         field_1;  //  4 bits\n         field_2;  //  4 bits\n         field_3;\
    \  // 24 bits\n       }\n       DEFAULT {\n         field_1 =:= static;\n    \
    \     field_2 =:= uncompressed_value(4, 2);\n         field_3 =:= lsb(4, 0);\n\
    \       }\n       COMPRESSED format0 {\n         discriminator =:= '0'; // 1 bit\n\
    \         field_3;               // 4 bits\n       }\n       COMPRESSED format1\
    \ {\n         discriminator =:= '1';           //  1 bit\n         field_1   \
    \    =:= irregular(4);  //  4 bits\n         field_3       =:= irregular(24);\
    \ // 24 bits\n       }\n     }\n   Note the following:\n   o  \"field_1\" and\
    \ \"field_3\" both have default encoding methods\n      specified for them, which\
    \ are used in \"format0\", but are\n      overridden in \"format1\"; the default\
    \ encoding method of \"field_2\"\n      however, is not overridden.\n   o  \"\
    field_1\" and \"field_2\" have default encoding methods that\n      compress to\
    \ zero bits.  When these are used in \"format0\", the\n      field names do not\
    \ appear in the field list.\n   o  \"field_3\" has an encoding method that does\
    \ not compress to zero\n      bits, so whilst \"field_3\" has no encoding specified\
    \ for it in the\n      field list of \"format0\", it still needs to appear in\
    \ the field\n      list to specify where it goes in the compressed format.\n \
    \  o  In the example, all the fields in the uncompressed format have\n      default\
    \ encoding methods specified for them, but this is not a\n      requirement. \
    \ Default encodings can be specified for only some or\n      even none of the\
    \ fields of the uncompressed format.\n   o  In the example, all the default encoding\
    \ methods are on fields\n      from the uncompressed format, but this is not a\
    \ requirement.\n      Default encoding methods can be specified for control fields.\n"
- title: 4.13.  Profile-Specific Encoding Methods
  contents:
  - "4.13.  Profile-Specific Encoding Methods\n   The library of encoding methods\
    \ defined by ROHC-FN in Section 4.11\n   provides a basic and generic set of field\
    \ encoding methods.  When\n   using a ROHC-FN specification in a ROHC profile,\
    \ some additional\n   encodings specific to the particular protocol header being\
    \ compressed\n   may, however, be needed, such as methods that infer the value\
    \ of a\n   field from other values.\n   These methods are specific to the properties\
    \ of the protocol being\n   compressed and will thus have to be defined within\
    \ the profile\n   specification itself.  Such profile-specific encoding methods,\n\
    \   defined either in ROHC-FN syntax or rigorously in plain text, can be\n   referred\
    \ to in the ROHC-FN specification of the profile's formats in\n   the same way\
    \ as any method in the ROHC-FN library.\n   Encoding methods that are not defined\
    \ in the formal notation are\n   specified by giving their name, followed by a\
    \ short description of\n   where they are defined, in double quotes, and a semi-colon.\n\
    \   For example:\n     inferred_ip_v4_header_checksum \"defined in RFCxxxx Section\
    \ 6.4.1\";\n"
- title: 5.  Security Considerations
  contents:
  - "5.  Security Considerations\n   This document describes a formal notation similar\
    \ to ABNF [RFC4234],\n   and hence is not believed to raise any security issues\
    \ (note that\n   ABNF has a completely separate purpose to the ROHC formal notation).\n"
- title: 6.  Contributors
  contents:
  - "6.  Contributors\n   Richard Price did much of the foundational work on the formal\n\
    \   notation.  He authored the initial document describing a formal\n   notation\
    \ on which this document is based.\n   Kristofer Sandlund contributed to this\
    \ work by applying new ideas to\n   the ROHC-TCP profile, by providing feedback,\
    \ and by helping resolve\n   different issues during the entire development of\
    \ the notation.\n   Carsten Bormann provided the translation of the formal notation\n\
    \   syntax using ABNF in Appendix A, and also contributed with feedback\n   and\
    \ reviews to validate the completeness and correctness of the\n   notation.\n"
- title: 7.  Acknowledgements
  contents:
  - "7.  Acknowledgements\n   A number of important concepts and ideas have been borrowed\
    \ from ROHC\n   [RFC3095].\n   Thanks to Mark West, Eilert Brinkmann, Alan Ford,\
    \ and Lars-Erik\n   Jonsson for their contributions, reviews, and feedback that\
    \ led to\n   significant improvements to the readability, completeness, and\n\
    \   overall quality of the notation.\n   Thanks to Stewart Sadler, Caroline Daniels,\
    \ Alan Finney, and David\n   Findlay for their reviews and comments.  Thanks to\
    \ Rob Hancock and\n   Stephen McCann for their early work on the formal notation.\
    \  The\n   authors would also like to thank Christian Schmidt, Qian Zhang,\n \
    \  Hongbin Liao, and Max Riegel for their comments and valuable input.\n   Additional\
    \ thanks: this document was reviewed during working group\n   last-call by committed\
    \ reviewers Mark West, Carsten Bormann, and Joe\n   Touch, as well as by Sally\
    \ Floyd who provided a review at the request\n   of the Transport Area Directors.\
    \  Thanks also to Magnus Westerlund\n   for his feedback in preparation for the\
    \ IESG review.\n"
- title: 8.  References
  contents:
  - '8.  References

    '
- title: 8.1.  Normative References
  contents:
  - "8.1.  Normative References\n   [C90]      ISO/IEC, \"ISO/IEC 9899:1990 Information\
    \ technology --\n              Programming Language C\", ISO 9899:1990, April\
    \ 1990.\n   [RFC2822]  Resnick, P., Ed., \"STANDARD FOR THE FORMAT OF ARPA\n \
    \             INTERNET TEXT MESSAGES\", RFC 2822, April 2001.\n   [RFC4234]  Crocker,\
    \ D., Ed. and P. Overell, \"Augmented BNF for Syntax\n              Specifications:\
    \ ABNF\", RFC 4234, October 2005.\n   [RFC4995]  Jonsson, L-E., Pelletier, G.,\
    \ and K. Sandlund, \"The RObust\n              Header Compression (ROHC) Framework\"\
    , RFC 4995, July 2007.\n"
- title: 8.2.  Informative References
  contents:
  - "8.2.  Informative References\n   [RFC3095]  Bormann, C., Burmeister, C., Degermark,\
    \ M., Fukushima, H.,\n              Hannu, H., Jonsson, L-E., Hakenberg, R., Koren,\
    \ T., Le,\n              K., Liu, Z., Martensson, A., Miyazaki, A., Svanbro, K.,\n\
    \              Wiebke, T., Yoshimura, T., and H. Zheng, \"RObust Header\n    \
    \          Compression (ROHC): Framework and four profiles: RTP, UDP,\n      \
    \        ESP, and uncompressed\", RFC 3095, July 2001.\n   [RFC791]   University\
    \ of Southern California, \"DARPA INTERNET PROGRAM\n              PROTOCOL SPECIFICATION\"\
    , RFC 791, September 1981.\n"
- title: Appendix A.  Formal Syntax of ROHC-FN
  contents:
  - "Appendix A.  Formal Syntax of ROHC-FN\n   This section gives a definition of\
    \ the syntax of ROHC-FN in ABNF\n   [RFC4234], using \"fnspec\" as the start rule.\n\
    \   ; overall structure\n   fnspec     = S *(constdef S) [globctl S] 1*(methdef\
    \ S)\n   constdef   = constname S \"=\" S expn S \";\"\n   globctl    = CONTROL\
    \ S formbody\n   methdef    = id S [parmlist S] \"{\" S 1*(formatdef S) \"}\"\n\
    \              / id S [parmlist S] STRQ *STRCHAR STRQ S \";\"\n   parmlist   =\
    \ \"(\" S id S *( \",\" S id S ) \")\"\n   formatdef  = formhead S formbody\n\
    \   formhead   = UNCOMPRESSED [ 1*WS id ]\n              / COMPRESSED [ 1*WS id\
    \ ]\n              / CONTROL / INITIAL / DEFAULT\n   formbody   = \"{\" S *((fielddef/enforcer)\
    \ S) \"}\"\n   fielddef   = fieldgroup S [\"=:=\" S encspec S] [lenspec S] \"\
    ;\"\n   fieldgroup = fieldname *( S \":\" S fieldname )\n   fieldname  = id\n\
    \   encspec    = \"'\" *(\"0\"/\"1\") \"'\"\n              / id [ S \"(\" S expn\
    \ S *( \",\" S expn S ) \")\"]\n   lenspec    = \"[\" S expn S *(\",\" S expn\
    \ S) \"]\"\n   enforcer   = ENFORCE S \"(\" S expn S \")\" S \";\"\n   ; expressions\n\
    \   expn  = *(expnb S \"||\" S) expnb\n   expnb = *(expna S \"&&\" S) expna\n\
    \   expna = *(expn7 S (\"==\"/\"!=\") S) expn7\n   expn7 = *(expn6 S (\"<\"/\"\
    <=\"/\">\"/\">=\") S) expn6\n   expn6 = *(expn4 S (\"+\"/\"-\") S) expn4\n   expn4\
    \ = *(expn3 S (\"*\"/\"/\"/\"%\") S) expn3\n   expn3 = expn2 [S \"^\" S expn3]\n\
    \   expn2 = [\"!\" S] expn1\n   expn1 = expn0 / attref / constname / litval /\
    \ id\n   expn0 = \"(\" S expn S \")\" / VARIABLE\n   attref       = fieldnameref\
    \ \".\" attname\n   fieldnameref = fieldname / THIS\n   attname      = ( U / C\
    \ ) ( LENGTH / VALUE )\n   litval       = [\"-\"] \"0b\" 1*(\"0\"/\"1\")\n   \
    \             / [\"-\"] \"0x\" 1*(DIGIT/\"a\"/\"b\"/\"c\"/\"d\"/\"e\"/\"f\")\n\
    \                / [\"-\"] 1*DIGIT\n                / false / true\n   ; lexical\
    \ categories\n   constname = UPCASE *(UPCASE / DIGIT / \"_\")\n   id        =\
    \ ALPHA *(ALPHA / DIGIT / \"_\")\n   ALPHA     = %x41-5A / %x61-7A\n   UPCASE\
    \    = %x41-5A\n   DIGIT     = %x30-39\n   COMMENT   = \"//\" *(SP / HTAB / VCHAR)\
    \ CRLF\n   SP        = %x20\n   HTAB      = %x09\n   VCHAR     = %x21-7E\n   CRLF\
    \      = %x0A / %x0D.0A\n   NL        = COMMENT / CRLF\n   WS        = SP / HTAB\
    \ / NL\n   S         = *WS\n   STRCHAR   = SP / HTAB / %x21 / %x23-7E\n   STRQ\
    \      = %x22\n   ; case-sensitive literals\n   C            = %d67\n   COMPRESSED\
    \   = %d67.79.77.80.82.69.83.83.69.68\n   CONTROL      = %d67.79.78.84.82.79.76\n\
    \   DEFAULT      = %d68.69.70.65.85.76.84\n   ENFORCE      = %d69.78.70.79.82.67.69\n\
    \   INITIAL      = %d73.78.73.84.73.65.76\n   LENGTH       = %d76.69.78.71.84.72\n\
    \   THIS         = %d84.72.73.83\n   U            = %d85\n   UNCOMPRESSED = %d85.78.67.79.77.80.82.69.83.83.69.68\n\
    \   VALUE        = %d86.65.76.85.69\n   VARIABLE     = %d86.65.82.73.65.66.76.69\n\
    \   false        = %d102.97.108.115.101\n   true         = %d116.114.117.101\n"
- title: Appendix B.  Bit-level Worked Example
  contents:
  - "Appendix B.  Bit-level Worked Example\n   This section gives a worked example\
    \ at the bit level, showing how a\n   simple ROHC-FN specification describes the\
    \ compression of real data\n   from an imaginary protocol header.  The example\
    \ used has been kept\n   fairly simple, whilst still aiming to illustrate some\
    \ of the\n   intricacies that arise in use of the notation.  In particular, fields\n\
    \   have been kept short to make it possible to read the binary\n   representation\
    \ of the headers without too much difficulty.\n"
- title: B.1.  Example Packet Format
  contents:
  - "B.1.  Example Packet Format\n   Our imaginary header is just 16 bits long, and\
    \ consists of the\n   following fields:\n   1.  version number -- 2 bits\n   2.\
    \  type -- 2 bits\n   3.  flow id -- 4 bits\n   4.  sequence number -- 4 bits\n\
    \   5.  flag bits -- 4 bits\n   So for example 0101000100010000 indicates a header\
    \ with a version\n   number of one, a type of one, a flow id of one, a sequence\
    \ number of\n   one, and all flag bits set to zero.\n   Here is an ASCII box notation\
    \ diagram of the imaginary header:\n     0   1   2   3   4   5   6   7\n   +---+---+---+---+---+---+---+---+\n\
    \   |version| type  |    flow_id    |\n   +---+---+---+---+---+---+---+---+\n\
    \   |  sequence_no  |   flag_bits   |\n   +---+---+---+---+---+---+---+---+\n"
- title: B.2.  Initial Encoding
  contents:
  - "B.2.  Initial Encoding\n   An initial definition based solely on the above information\
    \ is as\n   follows:\n     eg_header\n     {\n       UNCOMPRESSED {\n        \
    \ version_no   [ 2 ];\n         type         [ 2 ];\n         flow_id      [ 4\
    \ ];\n         sequence_no  [ 4 ];\n         flag_bits    [ 4 ];\n       }\n \
    \      COMPRESSED initial_definition {\n         version_no  =:= irregular(2);\n\
    \         type        =:= irregular(2);\n         flow_id     =:= irregular(4);\n\
    \         sequence_no =:= irregular(4);\n         flag_bits   =:= irregular(4);\n\
    \       }\n     }\n   This defines the format nicely, but doesn't actually offer\
    \ any\n   compression.  If we use it to encode the above header, we get:\n   \
    \  Uncompressed header: 0101000100010000\n     Compressed header:   0101000100010000\n\
    \   This is because we have stated that all fields are \"irregular\" --\n   i.e.,\
    \ we haven't specified anything about their behaviour.\n   Note that since we\
    \ have only one compressed format and one\n   uncompressed format, it makes no\
    \ difference whether the encoding\n   methods for each field are specified in\
    \ the compressed or\n   uncompressed format.  It would make no difference at all\
    \ if we wrote\n   the following instead:\n     eg_header\n     {\n       UNCOMPRESSED\
    \ {\n         version_no  =:= irregular(2);\n         type        =:= irregular(2);\n\
    \         flow_id     =:= irregular(4);\n         sequence_no =:= irregular(4);\n\
    \         flag_bits   =:= irregular(4);\n       }\n       COMPRESSED initial_definition\
    \ {\n         version_no   [ 2 ];\n         type         [ 2 ];\n         flow_id\
    \      [ 4 ];\n         sequence_no  [ 4 ];\n         flag_bits    [ 4 ];\n  \
    \     }\n     }\n"
- title: B.3.  Basic Compression
  contents:
  - "B.3.  Basic Compression\n   In order to achieve any compression we need to notate\
    \ more knowledge\n   about the header and its behaviour in a flow.  For example,\
    \ we may\n   know the following facts about the header:\n   1.  version number\
    \ -- indicates which version of the protocol this\n       is: always one for this\
    \ version of the protocol.\n   2.  type -- may take any value.\n   3.  flow id\
    \ -- may take any value.\n   4.  sequence number -- make take any value.\n   5.\
    \  flag bits -- contains three flags, a, b, and c, each of which may\n       be\
    \ set or clear, and a reserved flag bit, which is always clear\n       (i.e.,\
    \ zero).\n   We could notate this knowledge as follows:\n     eg_header\n    \
    \ {\n       UNCOMPRESSED {\n         version_no     [ 2 ];\n         type    \
    \       [ 2 ];\n         flow_id        [ 4 ];\n         sequence_no    [ 4 ];\n\
    \         abc_flag_bits  [ 3 ];\n         reserved_flag  [ 1 ];\n       }\n  \
    \     COMPRESSED basic {\n         version_no    =:= uncompressed_value(2, 1)\
    \  [ 0 ];\n         type          =:= irregular(2)              [ 2 ];\n     \
    \    flow_id       =:= irregular(4)              [ 4 ];\n         sequence_no\
    \   =:= irregular(4)              [ 4 ];\n         abc_flag_bits =:= irregular(3)\
    \              [ 3 ];\n         reserved_flag =:= uncompressed_value(1, 0)  [\
    \ 0 ];\n       }\n     }\n   Using this simple scheme, we have successfully encoded\
    \ the fact that\n   one of the fields has a permanently fixed value of one, and\
    \ therefore\n   contains no useful information.  We have also encoded the fact\
    \ that\n   the final flag bit is always zero, which again contains no useful\n\
    \   information.  Both of these facts have been notated using the\n   \"uncompressed_value\"\
    \ encoding method (see Section 4.11.1).\n   Using this new encoding on the above\
    \ header, we get:\n     Uncompressed header: 0101000100010000\n     Compressed\
    \ header:   0100010001000\n   This reduces the amount of data we need to transmit\
    \ by roughly 20%.\n   However, this encoding fails to take advantage of relationships\n\
    \   between values of a field in one packet and its value in subsequent\n   packets.\
    \  For example, every header in the following sequence is\n   compressed by the\
    \ same amount despite the similarities between them:\n     Uncompressed header:\
    \ 0101000100010000\n     Compressed header:   0100010001000\n     Uncompressed\
    \ header: 0101000101000000\n     Compressed header:   0100010100000\n     Uncompressed\
    \ header: 0110000101110000\n     Compressed header:   1000010111000\n"
- title: B.4.  Inter-Packet Compression
  contents:
  - "B.4.  Inter-Packet Compression\n   The profile we have defined so far has not\
    \ compressed the sequence\n   number or flow ID fields at all, since they can\
    \ take any value.\n   However the value of each of these fields in one header\
    \ has a very\n   simple relationship to their values in previous headers:\n  \
    \ o  the sequence number is unusual -- it increases by three each time,\n   o\
    \  the flow_id stays the same -- it always has the same value that it\n      did\
    \ in the previous header in the flow,\n   o  the abc_flag_bits stay the same most\
    \ of the time -- they usually\n      have the same value that they did in the\
    \ previous header in the\n      flow.\n   An obvious way of notating this is as\
    \ follows:\n     // This obvious encoding will not work (correct encoding below)\n\
    \     eg_header\n     {\n       UNCOMPRESSED {\n         version_no     [ 2 ];\n\
    \         type           [ 2 ];\n         flow_id        [ 4 ];\n         sequence_no\
    \    [ 4 ];\n         abc_flag_bits  [ 3 ];\n         reserved_flag  [ 1 ];\n\
    \       }\n       COMPRESSED obvious {\n         version_no    =:= uncompressed_value(2,\
    \ 1);\n         type          =:= irregular(2);\n         flow_id       =:= static;\n\
    \         sequence_no   =:= lsb(0, -3);\n         abc_flag_bits =:= irregular(3);\n\
    \         reserved_flag =:= uncompressed_value(1, 0);\n       }\n     }\n   The\
    \ dependency on previous packets is notated using the \"static\" and\n   \"lsb\"\
    \ encoding methods (see Section 4.11.4 and Section 4.11.5\n   respectively). \
    \ However there are a few problems with the above\n   notation.\n   Firstly, and\
    \ most importantly, the \"flow_id\" field is notated as\n   \"static\", which\
    \ means that it doesn't change from packet to packet.\n   However, the notation\
    \ does not indicate how to communicate the value\n   of the field initially. \
    \ There is no point saying \"it's the same\n   value as last time\" if there has\
    \ not been a first time where we\n   define what that value is, so that it can\
    \ be referred back to.  The\n   above notation provides no way of communicating\
    \ that.  Similarly with\n   the sequence number -- there needs to be a way of\
    \ communicating its\n   initial value.  In fact, except for the explicit notation\
    \ indicating\n   their lengths, even the lengths of these two fields would be\
    \ left\n   undefined.  This problem will be solved below, in Appendix B.5.\n \
    \  Secondly, the sequence number field is communicated very efficiently\n   in\
    \ zero bits, but it is not at all robust against packet loss.  If a\n   packet\
    \ is lost then there is no way to handle the missing sequence\n   number.  When\
    \ communicating sequence numbers, or any other field\n   encoded with \"lsb\"\
    \ encoding, a very important consideration for the\n   notator is how robust against\
    \ packet loss the compressed protocol\n   should be.  This will vary a lot from\
    \ protocol stack to protocol\n   stack.  For the example protocol we'll assume\
    \ short, low overhead\n   flows and say we need to be robust to the loss of just\
    \ one packet,\n   which we can achieve with two bits of \"lsb\" encoding (one\
    \ bit isn't\n   enough since the sequence number increases by three each time\
    \ -- see\n   Section 4.11.5).  This will be addressed below in Appendix B.5.\n\
    \   Finally, although the flag bits are usually the same as in the\n   previous\
    \ header in the flow, the profile doesn't make any use of this\n   fact; since\
    \ they are sometimes not the same as those in the previous\n   header, it is not\
    \ safe to say that they are always the same, so\n   \"static\" encoding can't\
    \ be used exclusively.  This problem will be\n   solved later through the use\
    \ of multiple formats in Appendix B.6.\n"
- title: B.5.  Specifying Initial Values
  contents:
  - "B.5.  Specifying Initial Values\n   To communicate initial values for fields\
    \ compressed with a context\n   dependent encoding such as \"static\" or \"lsb\"\
    \ we use an \"INITIAL\"\n   field list.  This can help with fields whose start\
    \ value is fixed and\n   known.  For example, if we knew that at the start of\
    \ the flow that\n   \"flow_id\" would always be 1 and \"sequence_no\" would always\
    \ be 0, we\n   could notate that like this:\n     // This encoding will not work\
    \ either (correct encoding below)\n     eg_header\n     {\n       UNCOMPRESSED\
    \ {\n         version_no     [ 2 ];\n         type           [ 2 ];\n        \
    \ flow_id        [ 4 ];\n         sequence_no    [ 4 ];\n         abc_flag_bits\
    \  [ 3 ];\n         reserved_flag  [ 1 ];\n       }\n       INITIAL {\n      \
    \   // set initial values of fields before flow starts\n         flow_id     =:=\
    \ uncompressed_value(4, 1);\n         sequence_no =:= uncompressed_value(4, 0);\n\
    \       }\n       COMPRESSED obvious {\n         version_no    =:= uncompressed_value(2,\
    \ 1);\n         type          =:= irregular(2);\n         flow_id       =:= static;\n\
    \         sequence_no   =:= lsb(2, -3);\n         abc_flag_bits =:= irregular(3);\n\
    \         reserved_flag =:= uncompressed_value(1, 0);\n       }\n     }\n   However,\
    \ this use of \"INITIAL\" is no good since the initial values of\n   both \"flow_id\"\
    \ and \"sequence_no\" vary from flow to flow.  \"INITIAL\"\n   is only applicable\
    \ where the initial value of a field is fixed, as is\n   often the case with control\
    \ fields.\n"
- title: B.6.  Multiple Packet Formats
  contents:
  - "B.6.  Multiple Packet Formats\n   To communicate initial values for the sequence\
    \ number and flow ID\n   fields correctly, and to take advantage of the fact that\
    \ the flag\n   bits are usually the same as in the previous header, we need to\n\
    \   depart from the single format encoding we are currently using and\n   instead\
    \ use multiple formats.  Here, we have expressed the encodings\n   for two of\
    \ the fields in the uncompressed format, since they will\n   always be true for\
    \ uncompressed headers of that format.  The\n   remaining fields, whose encoding\
    \ method may depend on exactly how the\n   header is being compressed, have their\
    \ encodings specified in the\n   compressed formats.\n     eg_header\n     {\n\
    \       UNCOMPRESSED {\n         version_no    =:= uncompressed_value(2, 1) [\
    \ 2 ];\n         type                                       [ 2 ];\n         flow_id\
    \                                    [ 4 ];\n         sequence_no            \
    \                    [ 4 ];\n         abc_flag_bits                          \
    \    [ 3 ];\n         reserved_flag =:= uncompressed_value(1, 0) [ 1 ];\n    \
    \   }\n       COMPRESSED irregular_format {\n         discriminator =:= '0'  \
    \        [ 1 ];\n         version_no                     [ 0 ];\n         type\
    \          =:= irregular(2) [ 2 ];\n         flow_id       =:= irregular(4) [\
    \ 4 ];\n         sequence_no   =:= irregular(4) [ 4 ];\n         abc_flag_bits\
    \ =:= irregular(3) [ 3 ];\n         reserved_flag                  [ 0 ];\n  \
    \     }\n       COMPRESSED compressed_format {\n         discriminator =:= '1'\
    \          [ 1 ];\n         version_no                     [ 0 ];\n         type\
    \          =:= irregular(2) [ 2 ];\n         flow_id       =:= static       [\
    \ 0 ];\n         sequence_no   =:= lsb(2, -3)   [ 2 ];\n         abc_flag_bits\
    \ =:= static       [ 0 ];\n         reserved_flag                  [ 0 ];\n  \
    \     }\n     }\n   Note that we have added a discriminator field, so that the\n\
    \   decompressor can tell which format has been used by the compressor.\n   The\
    \ format with a \"static\" flow ID and \"lsb\" encoded sequence number\n   is\
    \ now 5 bits long.  Note that despite having to add the\n   discriminator field,\
    \ this format is still the same size as the\n   original incorrect \"obvious\"\
    \ format because it takes advantage of the\n   fact that the abc flag bits rarely\
    \ change.\n   However, the original \"basic\" format has also grown by one bit\
    \ due to\n   the addition of the discriminator (\"irregular_format\").  An important\n\
    \   consideration when creating multiple formats is whether each format\n   occurs\
    \ frequently enough that the average compressed header length is\n   shorter as\
    \ a result of its usage.  For example, if in fact the flag\n   bits always changed\
    \ between packets, the \"compressed_format\" encoding\n   could never be used;\
    \ all we would have achieved is lengthening the\n   \"basic\" format by one bit.\n\
    \   Using the above notation, we now get:\n     Uncompressed header: 0101000100010000\n\
    \     Compressed header:   00100010001000\n     Uncompressed header: 0101000101000000\n\
    \     Compressed header:   10100 ; 00100010100000\n     Uncompressed header: 0110000101110000\n\
    \     Compressed header:   11011 ; 01000010111000\n   The first header in the\
    \ stream is compressed the same way as before,\n   except that it now has the\
    \ extra 1-bit discriminator at the start\n   (0).  When a second header arrives\
    \ with the same flow ID as the first\n   and its sequence number three higher,\
    \ it can be compressed in two\n   possible ways: either by using \"compressed_format\"\
    \ or, in the same\n   way as previously, by using \"irregular_format\".\n   Note\
    \ that we show all theoretically possible encodings of a header as\n   defined\
    \ by the ROHC-FN specification, separated by semi-colons.\n   Either of the above\
    \ encodings for each header could be produced by a\n   valid implementation, although\
    \ a good implementation would always aim\n   to pick the encoding that leads to\
    \ the best compression.  A good\n   implementation would also take robustness\
    \ into account and therefore\n   probably wouldn't assume on the second packet\
    \ that the decompressor\n   had available the context necessary to decompress\
    \ the shorter\n   \"compressed_format\" form.\n   Finally, note that the fields\
    \ whose encoding methods are specified in\n   the uncompressed format have zero\
    \ length when compressed.  This means\n   their position in the compressed format\
    \ is not significant.  In this\n   case, there is no need to notate them when\
    \ defining the compressed\n   formats.  In the next part of the example we will\
    \ see that they have\n   been removed from the compressed formats altogether.\n"
- title: B.7.  Variable Length Discriminators
  contents:
  - "B.7.  Variable Length Discriminators\n   Suppose we do some analysis on flows\
    \ of our example protocol and\n   discover that whilst it is usual for successive\
    \ packets to have the\n   same flags, on the occasions when they don't, the packet\
    \ is almost\n   always a \"flags set\" packet in which all three of the abc flags\
    \ are\n   set.  To encode the flow more efficiently a format needs to be\n   written\
    \ to reflect this.\n   This now gives a total of three formats, which means we\
    \ need three\n   discriminators to differentiate between them.  The obvious solution\n\
    \   here is to increase the number of bits in the discriminator from one\n   to\
    \ two and use discriminators 00, 01, and 10 for example.  However we\n   can do\
    \ slightly better than this.\n   Any uniquely identifiable discriminator will\
    \ suffice, so we can use\n   00, 01, and 1.  If the discriminator starts with\
    \ 1, that's the whole\n   thing.  If it starts with 0, the decompressor knows\
    \ it has to check\n   one more bit to determine the kind of format.\n   Note that\
    \ care must be taken when using variable length\n   discriminators.  For example,\
    \ it would be erroneous to use 0, 01, and\n   10 as discriminators since after\
    \ reading an initial 0, the\n   decompressor would have no way of knowing if the\
    \ next bit was a\n   second bit of discriminator, or the first bit of the next\
    \ field in\n   the format.  However, 0, 10, and 11 would be correct, as the first\n\
    \   bit again indicates whether or not there are further discriminator\n   bits\
    \ to follow.\n   This gives us the following:\n     eg_header\n     {\n      \
    \ UNCOMPRESSED {\n         version_no    =:= uncompressed_value(2, 1) [ 2 ];\n\
    \         type                                       [ 2 ];\n         flow_id\
    \                                    [ 4 ];\n         sequence_no            \
    \                    [ 4 ];\n         abc_flag_bits                          \
    \    [ 3 ];\n         reserved_flag =:= uncompressed_value(1, 0) [ 1 ];\n    \
    \   }\n       COMPRESSED irregular_format {\n         discriminator =:= '00' \
    \        [ 2 ];\n         type          =:= irregular(2) [ 2 ];\n         flow_id\
    \       =:= irregular(4) [ 4 ];\n         sequence_no   =:= irregular(4) [ 4 ];\n\
    \         abc_flag_bits =:= irregular(3) [ 3 ];\n       }\n       COMPRESSED flags_set\
    \ {\n         discriminator =:= '01'                     [ 2 ];\n         type\
    \          =:= irregular(2)             [ 2 ];\n         flow_id       =:= static\
    \                   [ 0 ];\n         sequence_no   =:= lsb(2, -3)            \
    \   [ 2 ];\n         abc_flag_bits =:= uncompressed_value(3, 7) [ 0 ];\n     \
    \  }\n       COMPRESSED flags_static {\n         discriminator =:= '1'       \
    \   [ 1 ];\n         type          =:= irregular(2) [ 2 ];\n         flow_id \
    \      =:= static       [ 0 ];\n         sequence_no   =:= lsb(2, -3)   [ 2 ];\n\
    \         abc_flag_bits =:= static       [ 0 ];\n       }\n     }\n   Here is\
    \ some example output:\n     Uncompressed header: 0101000100010000\n     Compressed\
    \ header:   000100010001000\n     Uncompressed header: 0101000101000000\n    \
    \ Compressed header:   10100 ; 000100010100000\n     Uncompressed header: 0110000101110000\n\
    \     Compressed header:   11011 ; 001000010111000\n     Uncompressed header:\
    \ 0111000110101110\n     Compressed header:   011110 ; 001100011010111\n   Here\
    \ we have a very similar sequence to last time, except that there\n   is now an\
    \ extra message on the end that has the flag bits set.  The\n   encoding for the\
    \ first message in the stream is now one bit larger,\n   the encoding for the\
    \ next two messages is the same as before, since\n   that format has not grown;\
    \ thanks to the use of variable length\n   discriminators.  Finally, the packet\
    \ that comes through with all the\n   flag bits set can be encoded in just six\
    \ bits, only one bit more than\n   the most common format.  Without the extra\
    \ format, this last packet\n   would have to be encoded using the longest format\
    \ and would have\n   taken up 14 bits.\n"
- title: B.8.  Default Encoding
  contents:
  - "B.8.  Default Encoding\n   Some of the common encoding methods used so far have\
    \ been \"factored\n   out\" into the definition of the uncompressed format, meaning\
    \ that\n   they don't need to be defined for every compressed format.  However,\n\
    \   there is still some redundancy in the notation.  For a number of\n   fields,\
    \ the same encoding method is used several times in different\n   formats (though\
    \ not necessarily in all of them), but the field\n   encoding is redefined explicitly\
    \ each time.  If the encoding for any\n   of these fields changed in the future,\
    \ then every format that uses\n   that encoding would have to be modified to reflect\
    \ this change.\n   This problem can be avoided by specifying default encoding\
    \ methods\n   for these fields.  Doing so can also lead to a more concisely notated\n\
    \   profile:\n     eg_header\n     {\n       UNCOMPRESSED {\n         version_no\
    \    =:= uncompressed_value(2, 1) [ 2 ];\n         type                      \
    \                 [ 2 ];\n         flow_id                                   \
    \ [ 4 ];\n         sequence_no                                [ 4 ];\n       \
    \  abc_flag_bits                              [ 3 ];\n         reserved_flag =:=\
    \ uncompressed_value(1, 0) [ 1 ];\n       }\n       DEFAULT {\n         type \
    \         =:= irregular(2);\n         flow_id       =:= static;\n         sequence_no\
    \   =:= lsb(2, -3);\n       }\n       COMPRESSED irregular_format {\n        \
    \ discriminator =:= '00'         [ 2 ];\n         type                       \
    \    [ 2 ]; // Uses default\n         flow_id       =:= irregular(4) [ 4 ]; //\
    \ Overrides default\n         sequence_no   =:= irregular(4) [ 4 ]; // Overrides\
    \ default\n         abc_flag_bits =:= irregular(3) [ 3 ];\n       }\n       COMPRESSED\
    \ flags_set {\n         discriminator =:= '01' [ 2 ];\n         type         \
    \          [ 2 ]; // Uses default\n         sequence_no            [ 2 ]; // Uses\
    \ default\n         abc_flag_bits =:= uncompressed_value(3, 7);\n       }\n  \
    \     COMPRESSED flags_static {\n         discriminator =:= '1' [ 1 ];\n     \
    \    type                  [ 2 ]; // Uses default\n         sequence_no      \
    \     [ 2 ]; // Uses default\n         abc_flag_bits =:= static;\n       }\n \
    \    }\n   The above profile behaves in exactly the same way as the one notated\n\
    \   previously, since it has the same meaning.  Note that the purpose\n   behind\
    \ the different formats becomes clearer with the default\n   encoding methods\
    \ factored out: all that remains are the encodings\n   that are specific to each\
    \ format.  Note also that default encoding\n   methods that compress down to zero\
    \ bits have become completely\n   implicit.  For example the compressed formats\
    \ using the default\n   encoding for \"flow_id\" don't mention it (the default\
    \ is \"static\"\n   encoding that compresses to zero bits).\n"
- title: B.9.  Control Fields
  contents:
  - "B.9.  Control Fields\n   One inefficiency in the compression scheme we have produced\
    \ thus far\n   is that it uses two bits to provide the \"lsb\" encoded sequence\
    \ number\n   with robustness for the loss of just one packet.  In theory, only\
    \ one\n   bit should be needed.  The root of the problem is the unusual\n   sequence\
    \ number that the protocol uses -- it counts up in increments\n   of three.  In\
    \ order to encode it at maximum efficiency we need to\n   translate this into\
    \ a field that increments by one each time.  We do\n   this using a control field.\n\
    \   A control field is extra data that is communicated in the compressed\n   format,\
    \ but which is not a direct encoding of part of the\n   uncompressed header. \
    \ Control fields can be used to communicate extra\n   information in the compressed\
    \ format, that allows other fields to be\n   compressed more efficiently.\n  \
    \ The control field that we introduce scales the sequence number down\n   by a\
    \ factor of three.  Instead of encoding the original sequence\n   number in the\
    \ compressed packet, we encode the scaled sequence\n   number, allowing us to\
    \ have robustness to the loss of one packet by\n   using just one bit of \"lsb\"\
    \ encoding:\n     eg_header\n     {\n       UNCOMPRESSED {\n         version_no\
    \    =:= uncompressed_value(2, 1) [ 2 ];\n         type                      \
    \                 [ 2 ];\n         flow_id                                   \
    \ [ 4 ];\n         sequence_no                                [ 4 ];\n       \
    \  abc_flag_bits                              [ 3 ];\n         reserved_flag =:=\
    \ uncompressed_value(1, 0) [ 1 ];\n       }\n       CONTROL {\n         // need\
    \ modulo maths to calculate scaling correctly,\n         // due to 4 bit wrap\
    \ around\n         scaled_seq_no   [ 4 ];\n         ENFORCE(sequence_no.UVALUE\n\
    \                   == (scaled_seq_no.UVALUE * 3) % 16);\n       }\n       DEFAULT\
    \ {\n         type          =:= irregular(2);\n         flow_id       =:= static;\n\
    \         scaled_seq_no =:= lsb(1, -1);\n       }\n       COMPRESSED irregular_format\
    \ {\n         discriminator =:= '00'         [ 2 ];\n         type           \
    \                [ 2 ];\n         flow_id       =:= irregular(4) [ 4 ];\n    \
    \     scaled_seq_no =:= irregular(4) [ 4 ]; // Overrides default\n         abc_flag_bits\
    \ =:= irregular(3) [ 3 ];\n       }\n       COMPRESSED flags_set {\n         discriminator\
    \ =:= '01' [ 2 ];\n         type                   [ 2 ];\n         scaled_seq_no\
    \          [ 1 ]; // Uses default\n         abc_flag_bits =:= uncompressed_value(3,\
    \ 7);\n       }\n       COMPRESSED flags_static {\n         discriminator =:=\
    \ '1' [ 1 ];\n         type                  [ 2 ];\n         scaled_seq_no  \
    \       [ 1 ]; // Uses default\n         abc_flag_bits =:= static;\n       }\n\
    \     }\n   Normally, the encoding method(s) used to encode a field specifies\
    \ the\n   length of the field.  In the above notation, since there is no\n   encoding\
    \ method using \"sequence_no\" directly, its length needs to be\n   defined explicitly\
    \ using an \"ENFORCE\" statement.  This is done using\n   the abbreviated syntax,\
    \ both for consistency and also for ease of\n   readability.  Note that this is\
    \ unusual: whereas the majority of\n   field length indications are redundant\
    \ (and thus optional), this one\n   isn't.  If it was removed from the above notation,\
    \ the length of the\n   \"sequence_no\" field would be undefined.\n   Here is\
    \ some example output:\n     Uncompressed header: 0101000100010000\n     Compressed\
    \ header:   000100011011000\n     Uncompressed header: 0101000101000000\n    \
    \ Compressed header:   1010 ; 000100011100000\n     Uncompressed header: 0110000101110000\n\
    \     Compressed header:   1101 ; 001000011101000\n     Uncompressed header: 0111000110101110\n\
    \     Compressed header:   01110 ; 001100011110111\n   In this form, we see that\
    \ this gives us a saving of a further bit in\n   most packets.  Assuming the bulk\
    \ of a flow is made up of\n   \"flags_static\" headers, the mean size of the headers\
    \ in a compressed\n   flow is now just over a quarter of their size in an uncompressed\n\
    \   flow.\n"
- title: B.10.  Use of "ENFORCE" Statements as Conditionals
  contents:
  - "B.10.  Use of \"ENFORCE\" Statements as Conditionals\n   Earlier, we created\
    \ a new format \"flags_set\" to handle packets with\n   all three of the flag\
    \ bits set.  As it happens, these three flags are\n   always all set for \"type\
    \ 3\" packets, and are never all set for other\n   packet types (a \"type 3\"\
    \ packet is one where the type field is set to\n   three).\n   This allows extra\
    \ efficiency in encoding such packets.  We know the\n   type is three, so we don't\
    \ need to encode the type field in the\n   compressed header.  The type field\
    \ was previously encoded as\n   \"irregular(2)\", which is two bits long.  Removing\
    \ this reduces the\n   size of the \"flags_set\" format from five bits to three,\
    \ making it the\n   smallest format in the encoding method definition.\n   In\
    \ order to notate that the \"flags_set\" format should only be used\n   for \"\
    type 3\" headers, and the \"flags_static\" format only when the\n   type isn't\
    \ three, it is necessary to state these conditions inside\n   each format.  This\
    \ can be done with an \"ENFORCE\" statement:\n     eg_header\n     {\n       UNCOMPRESSED\
    \ {\n         version_no    =:= uncompressed_value(2, 1) [ 2 ];\n         type\
    \                                       [ 2 ];\n         flow_id             \
    \                       [ 4 ];\n         sequence_no                         \
    \       [ 4 ];\n         abc_flag_bits                              [ 3 ];\n \
    \        reserved_flag =:= uncompressed_value(1, 0) [ 1 ];\n       }\n       CONTROL\
    \ {\n         // need modulo maths to calculate scaling correctly,\n         //\
    \ due to 4 bit wrap around\n         scaled_seq_no   [ 4 ];\n         ENFORCE(sequence_no.UVALUE\n\
    \                   == (scaled_seq_no.UVALUE * 3) % 16);\n       }\n       DEFAULT\
    \ {\n         type          =:= irregular(2);\n         scaled_seq_no =:= lsb(1,\
    \ -1);\n         flow_id       =:= static;\n       }\n       COMPRESSED irregular_format\
    \ {\n         discriminator =:= '00'         [ 2 ];\n         type           \
    \                [ 2 ];\n         flow_id       =:= irregular(4) [ 4 ];\n    \
    \     scaled_seq_no =:= irregular(4) [ 4 ];\n         abc_flag_bits =:= irregular(3)\
    \ [ 3 ];\n       }\n       COMPRESSED flags_set {\n         ENFORCE(type.UVALUE\
    \ == 3); // redundant condition\n         discriminator =:= '01'             \
    \         [ 2 ];\n         type          =:= uncompressed_value(2, 3)  [ 0 ];\n\
    \         scaled_seq_no                               [ 1 ];\n         abc_flag_bits\
    \ =:= uncompressed_value(3, 7)  [ 0 ];\n       }\n       COMPRESSED flags_static\
    \ {\n         ENFORCE(type.UVALUE != 3);\n         discriminator =:= '1'    [\
    \ 1 ];\n         type                     [ 2 ];\n         scaled_seq_no     \
    \       [ 1 ];\n         abc_flag_bits =:= static [ 0 ];\n       }\n     }\n \
    \  The two \"ENFORCE\" statements in the last two formats act as \"guards\".\n\
    \   Guards prevent formats from being used under the wrong circumstances.\n  \
    \ In fact, the \"ENFORCE\" statement in \"flags_set\" is redundant.  The\n   condition\
    \ it guards for is already enforced by the new encoding\n   method used for the\
    \ \"type\" field.  The encoding method\n   \"uncompressed_value(2,3)\" binds the\
    \ \"UVALUE\" attribute to three.\n   This is exactly what the \"ENFORCE\" statement\
    \ does, so it can be\n   removed without any change in meaning.  The \"uncompressed_value\"\
    \n   encoding method on the other hand is not redundant.  It specifies\n   other\
    \ bindings on the type field in addition to the one that the\n   \"ENFORCE\" statement\
    \ specifies.  Therefore it would not be possible to\n   remove the encoding method\
    \ and leave just the \"ENFORCE\" statement.\n   Note that a guard is solely preventative.\
    \  A guard can never force a\n   format to be chosen by the compressor.  A format\
    \ can only be\n   guaranteed to be chosen in a given situation if there are no\
    \ other\n   formats that can be used instead.  This is demonstrated in the\n \
    \  example output below.  The compressor can still choose the\n   \"irregular\"\
    \ format if it wishes:\n     Uncompressed header: 0101000100010000\n     Compressed\
    \ header:   000100011011000\n     Uncompressed header: 0101000101000000\n    \
    \ Compressed header:   1010 ; 000100011100000\n     Uncompressed header: 0110000101110000\n\
    \     Compressed header:   1101 ; 001000011101000\n     Uncompressed header: 0111000110101110\n\
    \     Compressed header:   010 ; 001100011110111\n   This saves just two extra\
    \ bits (a 7% saving) in the example flow.\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Robert Finking\n   Siemens/Roke Manor Research\n   Old\
    \ Salisbury Lane\n   Romsey, Hampshire  SO51 0ZN\n   UK\n   Phone: +44 (0)1794\
    \ 833189\n   EMail: robert.finking@roke.co.uk\n   URI:   http://www.roke.co.uk\n\
    \   Ghyslain Pelletier\n   Ericsson\n   Box 920\n   Lulea  SE-971 28\n   Sweden\n\
    \   Phone: +46 (0) 8 404 29 43\n   EMail: ghyslain.pelletier@ericsson.com\n"
- title: Full Copyright Statement
  contents:
  - "Full Copyright Statement\n   Copyright (C) The IETF Trust (2007).\n   This document\
    \ is subject to the rights, licenses and restrictions\n   contained in BCP 78,\
    \ and except as set forth therein, the authors\n   retain all their rights.\n\
    \   This document and the information contained herein are provided on an\n  \
    \ \"AS IS\" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS\n  \
    \ OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY, THE IETF TRUST AND\n   THE\
    \ INTERNET ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS\n   OR IMPLIED,\
    \ INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF\n   THE INFORMATION\
    \ HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED\n   WARRANTIES OF MERCHANTABILITY\
    \ OR FITNESS FOR A PARTICULAR PURPOSE.\n"
- title: Intellectual Property
  contents:
  - "Intellectual Property\n   The IETF takes no position regarding the validity or\
    \ scope of any\n   Intellectual Property Rights or other rights that might be\
    \ claimed to\n   pertain to the implementation or use of the technology described\
    \ in\n   this document or the extent to which any license under such rights\n\
    \   might or might not be available; nor does it represent that it has\n   made\
    \ any independent effort to identify any such rights.  Information\n   on the\
    \ procedures with respect to rights in RFC documents can be\n   found in BCP 78\
    \ and BCP 79.\n   Copies of IPR disclosures made to the IETF Secretariat and any\n\
    \   assurances of licenses to be made available, or the result of an\n   attempt\
    \ made to obtain a general license or permission for the use of\n   such proprietary\
    \ rights by implementers or users of this\n   specification can be obtained from\
    \ the IETF on-line IPR repository at\n   http://www.ietf.org/ipr.\n   The IETF\
    \ invites any interested party to bring to its attention any\n   copyrights, patents\
    \ or patent applications, or other proprietary\n   rights that may cover technology\
    \ that may be required to implement\n   this standard.  Please address the information\
    \ to the IETF at\n   ietf-ipr@ietf.org.\n"
- title: Acknowledgement
  contents:
  - "Acknowledgement\n   Funding for the RFC Editor function is currently provided\
    \ by the\n   Internet Society.\n"
