- title: __initial_text__
  contents:
  - "                Self-Tuning Distributed Hash Table (DHT)\n              for REsource\
    \ LOcation And Discovery (RELOAD)\n"
- title: Abstract
  contents:
  - "Abstract\n   REsource LOcation And Discovery (RELOAD) is a peer-to-peer (P2P)\n\
    \   signaling protocol that provides an overlay network service.  Peers\n   in\
    \ a RELOAD overlay network collectively run an overlay algorithm to\n   organize\
    \ the overlay and to store and retrieve data.  This document\n   describes how\
    \ the default topology plugin of RELOAD can be extended\n   to support self-tuning,\
    \ that is, to adapt to changing operating\n   conditions such as churn and network\
    \ size.\n"
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This is an Internet Standards Track document.\n   This\
    \ document is a product of the Internet Engineering Task Force\n   (IETF).  It\
    \ represents the consensus of the IETF community.  It has\n   received public\
    \ review and has been approved for publication by the\n   Internet Engineering\
    \ Steering Group (IESG).  Further information on\n   Internet Standards is available\
    \ in Section 2 of RFC 5741.\n   Information about the current status of this document,\
    \ any errata,\n   and how to provide feedback on it may be obtained at\n   http://www.rfc-editor.org/info/rfc7363.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (c) 2014 IETF Trust and the persons identified\
    \ as the\n   document authors.  All rights reserved.\n   This document is subject\
    \ to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n\
    \   (http://trustee.ietf.org/license-info) in effect on the date of\n   publication\
    \ of this document.  Please review these documents\n   carefully, as they describe\
    \ your rights and restrictions with respect\n   to this document.  Code Components\
    \ extracted from this document must\n   include Simplified BSD License text as\
    \ described in Section 4.e of\n   the Trust Legal Provisions and are provided\
    \ without warranty as\n   described in the Simplified BSD License.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1. Introduction ....................................................2\n\
    \   2. Terminology .....................................................3\n  \
    \ 3. Introduction to Stabilization in DHTs ...........................5\n    \
    \  3.1. Reactive versus Periodic Stabilization .....................5\n      3.2.\
    \ Configuring Periodic Stabilization .........................6\n      3.3. Adaptive\
    \ Stabilization .....................................7\n   4. Introduction to\
    \ Chord ...........................................7\n   5. Extending Chord-Reload\
    \ to Support Self-Tuning ...................9\n      5.1. Update Requests ............................................9\n\
    \      5.2. Neighbor Stabilization ....................................10\n  \
    \    5.3. Finger Stabilization ......................................11\n    \
    \  5.4. Adjusting Finger Table Size ...............................11\n      5.5.\
    \ Detecting Partitioning ....................................11\n      5.6. Leaving\
    \ the Overlay .......................................11\n   6. Self-Tuning Chord\
    \ Parameters ...................................12\n      6.1. Estimating Overlay\
    \ Size ...................................12\n      6.2. Determining Routing Table\
    \ Size ............................13\n      6.3. Estimating Failure Rate ...................................13\n\
    \           6.3.1. Detecting Failures .................................14\n  \
    \    6.4. Estimating Join Rate ......................................14\n    \
    \  6.5. Estimate Sharing ..........................................15\n      6.6.\
    \ Calculating the Stabilization Interval ....................17\n   7. Overlay\
    \ Configuration Document Extension .......................17\n   8. Security Considerations\
    \ ........................................18\n   9. IANA Considerations ............................................18\n\
    \      9.1. Message Extensions ........................................18\n  \
    \    9.2. New Overlay Algorithm Type ................................19\n    \
    \  9.3. A New IETF XML Registry ...................................19\n   10.\
    \ Acknowledgments ...............................................19\n   11. References\
    \ ....................................................19\n      11.1. Normative\
    \ References .....................................19\n      11.2. Informative\
    \ References ...................................20\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   REsource LOcation And Discovery (RELOAD) [RFC6940] is a\
    \ peer-to-peer\n   signaling protocol that can be used to maintain an overlay\
    \ network\n   and to store data in and retrieve data from the overlay.  For\n\
    \   interoperability reasons, RELOAD specifies one overlay algorithm,\n   called\
    \ \"chord-reload\", that is mandatory to implement.  This document\n   extends\
    \ the chord-reload algorithm by introducing self-tuning\n   behavior.\n   DHT-based\
    \ overlay networks are self-organizing, scalable, and\n   reliable.  However,\
    \ these features come at a cost: peers in the\n   overlay network need to consume\
    \ network bandwidth to maintain routing\n   state.  Most DHTs use a periodic stabilization\
    \ routine to counter the\n   undesirable effects of churn on routing.  To configure\
    \ the parameters\n   of a DHT, some characteristics such as churn rate and network\
    \ size\n   need to be known in advance.  These characteristics are then used to\n\
    \   configure the DHT in a static fashion by using fixed values for\n   parameters\
    \ such as the size of the successor set, size of the routing\n   table, and rate\
    \ of maintenance messages.  The problem with this\n   approach is that it is not\
    \ possible to achieve a low failure rate and\n   a low communication overhead\
    \ by using fixed parameters.  Instead, a\n   better approach is to allow the system\
    \ to take into account the\n   evolution of network conditions and adapt to them.\n\
    \   This document extends the mandatory-to-implement chord-reload\n   algorithm\
    \ by making it self-tuning.  The use of the self-tuning\n   feature is optional.\
    \  However, when used, it needs to be supported by\n   all peers in the RELOAD\
    \ overlay network.  The fact that a RELOAD\n   overlay uses the self-tuning feature\
    \ is indicated in the RELOAD\n   overlay configuration document using the CHORD-SELF-TUNING\
    \ algorithm\n   name specified in Section 9.2 in the topology-plugin element.\
    \  Two\n   main advantages of self-tuning are that users no longer need to tune\n\
    \   every DHT parameter correctly for a given operating environment and\n   that\
    \ the system adapts to changing operating conditions.\n   The remainder of this\
    \ document is structured as follows: Section 2\n   provides definitions of terms\
    \ used in this document.  Section 3\n   discusses alternative approaches to stabilization\
    \ operations in DHTs,\n   including reactive stabilization, periodic stabilization,\
    \ and\n   adaptive stabilization.  Section 4 gives an introduction to the Chord\n\
    \   DHT algorithm.  Section 5 describes how this document extends the\n   stabilization\
    \ routine of the chord-reload algorithm.  Section 6\n   describes how the stabilization\
    \ rate and routing table size are\n   calculated in an adaptive fashion.\n"
- title: 2.  Terminology
  contents:
  - "2.  Terminology\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\"\
    , \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"NOT RECOMMENDED\"\
    , \"MAY\", and\n   \"OPTIONAL\" in this document are to be interpreted as described\
    \ in\n   [RFC2119].\n   This document uses terminology and definitions from the\
    \ RELOAD base\n   specification [RFC6940].\n   numBitsInNodeId:  Specifies the\
    \ number of bits in a RELOAD Node-ID.\n   DHT:  Distributed Hash Tables are a\
    \ class of decentralized\n      distributed systems that provide a lookup service\
    \ similar to a\n      regular hash table.  Given a key, any peer participating\
    \ in the\n      system can retrieve the value associated with that key.  The\n\
    \      responsibility for maintaining the mapping from keys to values is\n   \
    \   distributed among the peers.\n   Chord Ring:  The Chord DHT uses ring topology\
    \ and orders identifiers\n      on an identifier circle of size 2^numBitsInNodeId.\
    \  This\n      identifier circle is called the Chord ring.  On the Chord ring,\n\
    \      the responsibility for a key k is assigned to the node whose\n      identifier\
    \ equals to or immediately follows k.\n   Finger Table:  A data structure with\
    \ up to (but typically less than)\n      numBitsInNodeId entries maintained by\
    \ each peer in a Chord-based\n      overlay.  The ith entry in the finger table\
    \ of peer n contains the\n      identity of the first peer that succeeds n by\
    \ at least\n      2^(numBitsInNodeId-i) on the Chord ring.  This peer is called\
    \ the\n      ith finger of peer n.  As an example, the first entry in the\n  \
    \    finger table of peer n contains a peer halfway around the Chord\n      ring\
    \ from peer n.  The purpose of the finger table is to\n      accelerate lookups.\n\
    \   n.id:  In this document, this abbreviation is used to refer to the\n     \
    \ Node-ID of peer n.\n   O(g(n)):  Informally, saying that some equation f(n)\
    \ = O(g(n)) means\n      that f(n) is less than some constant multiple of g(n).\
    \  For the\n      formal definition, please refer to [Weiss1998].\n   Omega(g(n)):\
    \  Informally, saying that some equation f(n) =\n      Omega(g(n)) means that\
    \ f(n) is more than some constant multiple of\n      g(n).  For the formal definition,\
    \ please refer to [Weiss1998].\n   Percentile:  The Pth (0<=P<=100) percentile\
    \ of N values arranged in\n      ascending order is obtained by first calculating\
    \ the (ordinal)\n      rank n=(P/100)*N, rounding the result to the nearest integer\
    \ and\n      then taking the value corresponding to that rank.\n   Predecessor\
    \ List:  A data structure containing the first r\n      predecessors of a peer\
    \ on the Chord ring.\n   Successor List:  A data structure containing the first\
    \ r successors\n      of a peer on the Chord ring.\n   Neighborhood Set:  A term\
    \ used to refer to the set of peers included\n      in the successor and predecessor\
    \ lists of a given peer.\n   Routing Table:  Contents of a given peer's routing\
    \ table include the\n      set of peers that the peer can use to route overlay\
    \ messages.  The\n      routing table is made up of the finger table, successor\
    \ list, and\n      predecessor list.\n"
- title: 3.  Introduction to Stabilization in DHTs
  contents:
  - "3.  Introduction to Stabilization in DHTs\n   DHTs use stabilization routines\
    \ to counter the undesirable effects of\n   churn on routing.  The purpose of\
    \ stabilization is to keep the\n   routing information of each peer in the overlay\
    \ consistent with the\n   constantly changing overlay topology.  There are two\
    \ alternative\n   approaches to stabilization: periodic and reactive [Rhea2004].\n\
    \   Periodic stabilization can either use a fixed stabilization rate or\n   calculate\
    \ the stabilization rate in an adaptive fashion.\n"
- title: 3.1.  Reactive versus Periodic Stabilization
  contents:
  - "3.1.  Reactive versus Periodic Stabilization\n   In reactive stabilization, a\
    \ peer reacts to the loss of a peer in its\n   neighborhood set or to the appearance\
    \ of a new peer that should be\n   added to its neighborhood set by sending a\
    \ copy of its neighbor table\n   to all peers in the neighborhood set.  Periodic\
    \ recovery, in\n   contrast, takes place independently of changes in the neighborhood\n\
    \   set.  In periodic recovery, a peer periodically shares its\n   neighborhood\
    \ set with each or a subset of the members of that set.\n   The chord-reload algorithm\
    \ [RFC6940] supports both reactive and\n   periodic stabilization.  It has been\
    \ shown in [Rhea2004] that\n   reactive stabilization works well for small neighborhood\
    \ sets (i.e.,\n   small overlays) and moderate churn.  However, in large-scale\
    \ (e.g.,\n   1000 peers or more [Rhea2004]) or high-churn overlays, reactive\n\
    \   stabilization runs the risk of creating a positive feedback cycle,\n   which\
    \ can eventually result in congestion collapse.  In [Rhea2004],\n   it is shown\
    \ that a 1000-peer overlay under churn uses significantly\n   less bandwidth and\
    \ has lower latencies when periodic stabilization is\n   used than when reactive\
    \ stabilization is used.  Although in the\n   experiments carried out in [Rhea2004],\
    \ reactive stabilization\n   performed well when there was no churn, its bandwidth\
    \ use was\n   observed to jump dramatically under churn.  At higher churn rates\
    \ and\n   larger scale overlays, periodic stabilization uses less bandwidth and\n\
    \   the resulting lower contention for the network leads to lower\n   latencies.\
    \  For this reason, most DHTs, such as CAN [CAN], Chord\n   [Chord], Pastry [Pastry],\
    \ and Bamboo [Rhea2004], use periodic\n   stabilization [Ghinita2006].  As an\
    \ example, the first version of\n   Bamboo used reactive stabilization, which\
    \ caused Bamboo to suffer\n   from degradation in performance under churn.  To\
    \ fix this problem,\n   Bamboo was modified to use periodic stabilization.\n \
    \  In Chord, periodic stabilization is typically done both for\n   successors\
    \ and fingers.  An alternative strategy is analyzed in\n   [Krishnamurthy2008].\
    \  In this strategy, called the \"correction-on-\n   change maintenance strategy\"\
    , a peer periodically stabilizes its\n   successors but does not do so for its\
    \ fingers.  Instead, finger\n   pointers are stabilized in a reactive fashion.\
    \  The results obtained\n   in [Krishnamurthy2008] imply that although the correction-on-change\n\
    \   strategy works well when churn is low, periodic stabilization\n   outperforms\
    \ the correction-on-change strategy when churn is high.\n"
- title: 3.2.  Configuring Periodic Stabilization
  contents:
  - "3.2.  Configuring Periodic Stabilization\n   When periodic stabilization is used,\
    \ one faces the problem of\n   selecting an appropriate execution rate for the\
    \ stabilization\n   procedure.  If the execution rate of periodic stabilization\
    \ is high,\n   changes in the system can be quickly detected, but at the\n   disadvantage\
    \ of increased communication overhead.  Alternatively, if\n   the stabilization\
    \ rate is low and the churn rate is high, routing\n   tables become inaccurate\
    \ and DHT performance deteriorates.  Thus, the\n   problem is setting the parameters\
    \ so that the overlay achieves the\n   desired reliability and performance even\
    \ in challenging conditions,\n   such as under heavy churn.  This naturally results\
    \ in high cost\n   during periods when the churn level is lower than expected,\
    \ or\n   alternatively, poor performance or even network partitioning in worse\n\
    \   than expected conditions.\n   In addition to selecting an appropriate stabilization\
    \ interval,\n   regardless of whether or not periodic stabilization is used, an\n\
    \   appropriate size needs to be selected for the neighborhood set and\n   for\
    \ the finger table.\n   The current approach is to configure overlays statically.\
    \  This works\n   in situations where perfect information about the future is\n\
    \   available.  In situations where the operating conditions of the\n   network\
    \ are known in advance and remain static throughout the\n   lifetime of the system,\
    \ it is possible to choose fixed optimal values\n   for parameters such as stabilization\
    \ rate, neighborhood set size and\n   routing table size.  However, if the operating\
    \ conditions (e.g., the\n   size of the overlay and its churn rate) do not remain\
    \ static but\n   evolve with time, it is not possible to achieve both a low lookup\n\
    \   failure rate and a low communication overhead by using fixed\n   parameters\
    \ [Ghinita2006].\n   As an example, to configure the Chord DHT algorithm, one\
    \ needs to\n   select values for the following parameters: size of successor list,\n\
    \   stabilization interval, and size of the finger table.  To select an\n   appropriate\
    \ value for the stabilization interval, one needs to know\n   the expected churn\
    \ rate and overlay size.  According to\n   [Liben-Nowell2002], a Chord network\
    \ in a ring-like state remains in a\n   ring-like state as long as peers send\
    \ Omega(square(log(N))) messages\n   before N new peers join or N/2 peers fail.\
    \  Thus, in a 500-peer\n   overlay churning at a rate such that one peer joins\
    \ and one peer\n   leaves the network every 30 seconds, an appropriate stabilization\n\
    \   interval would be on the order of 93 s.  According to [Chord], the\n   size\
    \ of the successor list and finger table should be on the order of\n   log(N).\
    \  Already a successor list of a modest size (e.g., log2(N) or\n   2*log2(N),\
    \ which is the successor list size used in [Chord]) makes it\n   very unlikely\
    \ that a peer will lose all of its successors, which\n   would cause the Chord\
    \ ring to become disconnected.  Thus, in a\n   500-peer network each peer should\
    \ maintain on the order of nine\n   successors and fingers.  However, if the churn\
    \ rate doubles and the\n   network size remains unchanged, the stabilization rate\
    \ should double\n   as well.  That is, the appropriate maintenance interval would\
    \ now be\n   on the order of 46 s.  On the other hand, if the churn rate becomes,\n\
    \   e.g., six-fold and the size of the network grows to 2000 peers, on\n   the\
    \ order of 11 fingers and successors should be maintained and the\n   stabilization\
    \ interval should be on the order of 42 s.  If one\n   continued using the old\
    \ values, this could result in inaccurate\n   routing tables, network partitioning,\
    \ and deteriorating performance.\n"
- title: 3.3.  Adaptive Stabilization
  contents:
  - "3.3.  Adaptive Stabilization\n   A self-tuning DHT takes into consideration the\
    \ continuous evolution\n   of network conditions and adapts to them.  In a self-tuning\
    \ DHT, each\n   peer collects statistical data about the network and dynamically\n\
    \   adjusts its stabilization rate, neighborhood set size, and finger\n   table\
    \ size based on the analysis of the data [Ghinita2006].\n   Reference [Mahajan2003]\
    \ shows that by using self-tuning, it is\n   possible to achieve high reliability\
    \ and performance even in adverse\n   conditions with low maintenance cost.  Adaptive\
    \ stabilization has\n   been shown to outperform periodic stabilization in terms\
    \ of both\n   lookup failures and communication overhead [Ghinita2006].\n"
- title: 4.  Introduction to Chord
  contents:
  - "4.  Introduction to Chord\n   Chord [Chord] is a structured P2P algorithm that\
    \ uses consistent\n   hashing to build a DHT out of several independent peers.\
    \  Consistent\n   hashing assigns each peer and resource a fixed-length identifier.\n\
    \   Peers use SHA-1 as the base hash function to generate the\n   identifiers.\
    \  As specified in RELOAD base [RFC6940], the length of\n   the identifiers is\
    \ numBitsInNodeId=128 bits.  The identifiers are\n   ordered on an identifier\
    \ circle of size 2^numBitsInNodeId.  On the\n   identifier circle, key k is assigned\
    \ to the first peer whose\n   identifier equals or follows the identifier of k\
    \ in the identifier\n   space.  The identifier circle is called the Chord ring.\n\
    \   Different DHTs differ significantly in performance when bandwidth is\n   limited.\
    \  It has been shown that when compared to other DHTs, the\n   advantages of Chord\
    \ include that it uses bandwidth efficiently and\n   can achieve low lookup latencies\
    \ at little cost [Li2004].\n   A simple lookup mechanism could be implemented\
    \ on a Chord ring by\n   requiring each peer to only know how to contact its current\
    \ successor\n   on the identifier circle.  Queries for a given identifier could\
    \ then\n   be passed around the circle via the successor pointers until they\n\
    \   encounter the first peer whose identifier is equal to or larger than\n   the\
    \ desired identifier.  Such a lookup scheme uses a number of\n   messages that\
    \ grows linearly with the number of peers.  To reduce the\n   cost of lookups,\
    \ Chord maintains also additional routing information;\n   each peer n maintains\
    \ a data structure with up to numBitsInNodeId\n   entries, called the finger table.\
    \  The first entry in the finger\n   table of peer n contains the peer halfway\
    \ around the ring from peer\n   n.  The second entry contains the peer that is\
    \ 1/4th of the way\n   around, the third entry the peer that is 1/8th of the way\
    \ around,\n   etc.  In other words, the ith entry in the finger table at peer\
    \ n\n   contains the identity of the first peer s that succeeds n by at least\n\
    \   2^(numBitsInNodeId-i) on the Chord ring.  This peer is called the ith\n  \
    \ finger of peer n.  The interval between two consecutive fingers is\n   called\
    \ a finger interval.  The ith finger interval of peer n covers\n   the range [n.id\
    \ + 2^(numBitsInNodeId-i), n.id + 2^(numBitsInNodeId-\n   i+1)) on the Chord ring.\
    \  In an N-peer network, each peer maintains\n   information about O(log(N)) other\
    \ peers in its finger table.  As an\n   example, if N=100000, it is sufficient\
    \ to maintain 17 fingers.\n   Chord needs all peers' successor pointers to be\
    \ up to date in order\n   to ensure that lookups produce correct results as the\
    \ set of\n   participating peers changes.  To achieve this, peers run a\n   stabilization\
    \ protocol periodically in the background.  The\n   stabilization protocol of\
    \ the original Chord algorithm uses two\n   operations: successor stabilization\
    \ and finger stabilization.\n   However, the Chord algorithm of RELOAD base defines\
    \ two additional\n   stabilization components, as will be discussed below.\n \
    \  To increase robustness in the event of peer failures, each Chord peer\n   maintains\
    \ a successor list of size r, containing the peer's first r\n   successors.  The\
    \ benefit of successor lists is that if each peer\n   fails independently with\
    \ probability p, the probability that all r\n   successors fail simultaneously\
    \ is only p^r.\n   The original Chord algorithm maintains only a single predecessor\n\
    \   pointer.  However, multiple predecessor pointers (i.e., a predecessor\n  \
    \ list) can be maintained to speed up recovery from predecessor\n   failures.\
    \  The routing table of a peer consists of the successor\n   list, finger table,\
    \ and predecessor list.\n"
- title: 5.  Extending Chord-Reload to Support Self-Tuning
  contents:
  - "5.  Extending Chord-Reload to Support Self-Tuning\n   This section describes\
    \ how the mandatory-to-implement chord-reload\n   algorithm defined in RELOAD\
    \ base [RFC6940] can be extended to support\n   self-tuning.\n   The chord-reload\
    \ algorithm supports both reactive and periodic\n   recovery strategies.  When\
    \ the self-tuning mechanisms defined in this\n   document are used, the periodic\
    \ recovery strategy is used.  Further,\n   chord-reload specifies that at least\
    \ three predecessors and three\n   successors need to be maintained.  When the\
    \ self-tuning mechanisms\n   are used, the appropriate sizes of the successor\
    \ list and predecessor\n   list are determined in an adaptive fashion based on\
    \ the estimated\n   network size, as will be described in Section 6.\n   As specified\
    \ in RELOAD base [RFC6940], each peer maintains a\n   stabilization timer.  When\
    \ the stabilization timer fires, the peer\n   restarts the timer and carries out\
    \ the overlay stabilization routine.\n   Overlay stabilization has four components\
    \ in chord-reload:\n   1.  Update the neighbor table.  We refer to this as \"\
    neighbor\n       stabilization\".\n   2.  Refreshing the finger table.  We refer\
    \ to this as \"finger\n       stabilization\".\n   3.  Adjusting finger table\
    \ size.\n   4.  Detecting partitioning.  We refer to this as \"strong\n      \
    \ stabilization\".\n   As specified in RELOAD base [RFC6940], a peer sends periodic\
    \ messages\n   as part of the neighbor stabilization, finger stabilization, and\n\
    \   strong stabilization routines.  In neighbor stabilization, a peer\n   periodically\
    \ sends an Update request to every peer in its connection\n   table.  The default\
    \ time is every ten minutes.  In finger\n   stabilization, a peer periodically\
    \ searches for new peers to include\n   in its finger table.  This time defaults\
    \ to one hour.  This document\n   specifies how the neighbor stabilization and\
    \ finger stabilization\n   intervals can be determined in an adaptive fashion\
    \ based on the\n   operating conditions of the overlay.  The subsections below\
    \ describe\n   how this document extends the four components of stabilization.\n"
- title: 5.1.  Update Requests
  contents:
  - "5.1.  Update Requests\n   As described in RELOAD base [RFC6940], the neighbor\
    \ and finger\n   stabilization procedures are implemented using Update requests.\n\
    \   RELOAD base defines three types of Update requests: 'peer_ready',\n   'neighbors',\
    \ and 'full'.  Regardless of the type, all Update requests\n   include an 'uptime'\
    \ field.  The self-tuning extensions require\n   information on the uptimes of\
    \ peers in the routing table.  The sender\n   of an Update request includes its\
    \ current uptime (in seconds) in the\n   'uptime' field.  Regardless of the type,\
    \ all Update requests MUST\n   include an 'uptime' field.\n   When self-tuning\
    \ is used, each peer decides independently the\n   appropriate size for the successor\
    \ list, predecessor list, and finger\n   table.  Thus, the 'predecessors', 'successors',\
    \ and 'fingers' fields\n   included in RELOAD Update requests are of variable\
    \ length.  As\n   specified in RELOAD [RFC6940], variable-length fields are on\
    \ the wire\n   preceded by length bytes.  In the case of the successor list,\n\
    \   predecessor list, and finger table, there are two length bytes\n   (allowing\
    \ lengths up to 2^16-1).  The number of NodeId structures\n   included in each\
    \ field can be calculated based on the length bytes\n   since the size of a single\
    \ NodeId structure is 16 bytes.  If a peer\n   receives more entries than fit\
    \ into its successor list, predecessor\n   list, or finger table, the peer MUST\
    \ ignore the extra entries.  A\n   peer may also receive less entries than it\
    \ currently has in its own\n   data structure.  In that case, it uses the received\
    \ entries to update\n   only a subset of the entries in its data structure.  As\
    \ an example, a\n   peer that has a successor list of size 8 may receive a successor\
    \ list\n   of size 4 from its immediate successor.  In that case, the received\n\
    \   successor list can only be used to update the first few successors on\n  \
    \ the peer's successor list.  The rest of the successors will remain\n   intact.\n"
- title: 5.2.  Neighbor Stabilization
  contents:
  - "5.2.  Neighbor Stabilization\n   In the neighbor stabilization operation of chord-reload,\
    \ a peer\n   periodically sends an Update request to every peer in its connection\n\
    \   table.  In a small, low-churn overlay, the amount of traffic this\n   process\
    \ generates is typically acceptable.  However, in a large-scale\n   overlay churning\
    \ at a moderate or high churn rate, the traffic load\n   may no longer be acceptable\
    \ since the size of the connection table is\n   large and the stabilization interval\
    \ relatively short.  The self-\n   tuning mechanisms described in this document\
    \ are especially designed\n   for overlays of the latter type.  Therefore, when\
    \ the self-tuning\n   mechanisms are used, each peer only sends a periodic Update\
    \ request\n   to its first predecessor and first successor on the Chord ring;\
    \ it\n   MUST NOT send Update requests to others.\n   The neighbor stabilization\
    \ routine is executed when the stabilization\n   timer fires.  To begin the neighbor\
    \ stabilization routine, a peer\n   sends an Update request to its first successor\
    \ and its first\n   predecessor.  The type of the Update request MUST be 'neighbors'.\n\
    \   The Update request includes the successor and predecessor lists of\n   the\
    \ sender.  If a peer receiving such an Update request learns from\n   the predecessor\
    \ and successor lists included in the request that new\n   peers can be included\
    \ in its neighborhood set, it sends Attach\n   requests to the new peers.\n  \
    \ After a new peer has been added to the predecessor or successor list,\n   an\
    \ Update request of type 'peer_ready' is sent to the new peer.  This\n   allows\
    \ the new peer to insert the sender into its neighborhood set.\n"
- title: 5.3.  Finger Stabilization
  contents:
  - "5.3.  Finger Stabilization\n   Chord-reload specifies two alternative methods\
    \ for searching for new\n   peers to the finger table.  Both of the alternatives\
    \ can be used with\n   the self-tuning extensions defined in this document.\n\
    \   Immediately after a new peer has been added to the finger table, a\n   Probe\
    \ request is sent to the new peer to fetch its uptime.  The\n   'requested_info'\
    \ field of the Probe request MUST be set to contain\n   the ProbeInformationType\
    \ 'uptime' defined in RELOAD base [RFC6940].\n"
- title: 5.4.  Adjusting Finger Table Size
  contents:
  - "5.4.  Adjusting Finger Table Size\n   The chord-reload algorithm defines how\
    \ a peer can make sure that the\n   finger table is appropriately sized to allow\
    \ for efficient routing.\n   Since the self-tuning mechanisms specified in this\
    \ document produce a\n   network size estimate, this estimate can be directly\
    \ used to\n   calculate the optimal size for the finger table.  This mechanism\
    \ is\n   used instead of the one specified by chord-reload.  A peer uses the\n\
    \   network size estimate to determine whether it needs to adjust the\n   size\
    \ of its finger table each time when the stabilization timer\n   fires.  The way\
    \ this is done is explained in Section 6.2.\n"
- title: 5.5.  Detecting Partitioning
  contents:
  - "5.5.  Detecting Partitioning\n   This document does not require any changes to\
    \ the mechanism chord-\n   reload uses to detect network partitioning.\n"
- title: 5.6.  Leaving the Overlay
  contents:
  - "5.6.  Leaving the Overlay\n   As specified in RELOAD base [RFC6940], a leaving\
    \ peer SHOULD send a\n   Leave request to all members of its neighbor table prior\
    \ to leaving\n   the overlay.  The 'overlay_specific_data' field MUST contain\
    \ the\n   ChordLeaveData structure.  The Leave requests that are sent to\n   successors\
    \ contain the predecessor list of the leaving peer.  The\n   Leave requests that\
    \ are sent to the predecessors contain the\n   successor list of the leaving peer.\
    \  If a given successor can\n   identify better predecessors (that is, predecessors\
    \ that are closer\n   to it on the Chord ring than its existing predecessors)\
    \ than are\n   already included in its predecessor lists by investigating the\n\
    \   predecessor list it receives from the leaving peer, it sends Attach\n   requests\
    \ to them.  Similarly, if a given predecessor identifies\n   better successors\
    \ by investigating the successor list it receives\n   from the leaving peer, it\
    \ sends Attach requests to them.\n"
- title: 6.  Self-Tuning Chord Parameters
  contents:
  - "6.  Self-Tuning Chord Parameters\n   This section specifies how to determine\
    \ an appropriate stabilization\n   rate and routing table size in an adaptive\
    \ fashion.  The proposed\n   mechanism is based on [Mahajan2003], [Liben-Nowell2002],\
    \ and\n   [Ghinita2006].  To calculate an appropriate stabilization rate, the\n\
    \   values of three parameters must be estimated: overlay size N, failure\n  \
    \ rate U, and join rate L.  To calculate an appropriate routing table\n   size,\
    \ the estimated network size N can be used.  Peers in the overlay\n   MUST recalculate\
    \ the values of the parameters to self-tune the chord-\n   reload algorithm at\
    \ the end of each stabilization period before\n   restarting the stabilization\
    \ timer.\n"
- title: 6.1.  Estimating Overlay Size
  contents:
  - "6.1.  Estimating Overlay Size\n   Techniques for estimating the size of an overlay\
    \ network have been\n   proposed, for instance, in [Mahajan2003], [Horowitz2003],\n\
    \   [Kostoulas2005], [Binzenhofer2006], and [Ghinita2006].  In Chord, the\n  \
    \ density of peer identifiers in the neighborhood set can be used to\n   produce\
    \ an estimate of the size of the overlay, N [Mahajan2003].\n   Since peer identifiers\
    \ are picked randomly with uniform probability\n   from the numBitsInNodeId-bit\
    \ identifier space, the average distance\n   between peer identifiers in the successor\
    \ set is\n   (2^numBitsInNodeId)/N.\n   To estimate the overlay network size,\
    \ a peer computes the average\n   inter-peer distance d between the successive\
    \ peers starting from the\n   most distant predecessor and ending to the most\
    \ distant successor in\n   the successor list.  The estimated network size is\
    \ calculated as:\n                         2^numBitsInNodeId\n               \
    \     N = -------------------\n                                d\n   This estimate\
    \ has been found to be accurate within 15% of the real\n   network size [Ghinita2006].\
    \  Of course, the size of the neighborhood\n   set affects the accuracy of the\
    \ estimate.\n   During the join process, a joining peer fills its routing table\
    \ by\n   sending a series of Ping and Attach requests, as specified in RELOAD\n\
    \   base [RFC6940].  Thus, a joining peer immediately has enough\n   information\
    \ at its disposal to calculate an estimate of the network\n   size.\n"
- title: 6.2.  Determining Routing Table Size
  contents:
  - "6.2.  Determining Routing Table Size\n   As specified in RELOAD base [RFC6940],\
    \ the finger table must contain\n   at least 16 entries.  When the self-tuning\
    \ mechanisms are used, the\n   size of the finger table MUST be set to max(ceiling(log2(N)),\
    \ 16)\n   using the estimated network size N.\n   The size of the successor list\
    \ MUST be set to a maximum of\n   ceiling(log2(N)).  An implementation can place\
    \ a lower limit on the\n   size of the successor list.  As an example, the implementation\
    \ might\n   require the size of the successor list to be always at least three.\n\
    \   The size of the predecessor list MUST be set to ceiling(log2(N)).\n"
- title: 6.3.  Estimating Failure Rate
  contents:
  - "6.3.  Estimating Failure Rate\n   A typical approach is to assume that peers\
    \ join the overlay according\n   to a Poisson process with rate L and leave according\
    \ to a Poisson\n   process with rate parameter U [Mahajan2003].  The value of\
    \ U can be\n   estimated using peer failures in the finger table and neighborhood\n\
    \   set [Mahajan2003].  If peers fail with rate U, a peer with M unique\n   peer\
    \ identifiers in its routing table should observe K failures in\n   time K/(M*U).\
    \  Every peer in the overlay maintains a history of the\n   last K failures. \
    \ The current time is inserted into the history when\n   the peer joins the overlay.\
    \  The estimate of U is calculated as:\n                             k\n     \
    \                U = --------,\n                          M * Tk\n   where M is\
    \ the number of unique peer identifiers in the routing\n   table, Tk is the time\
    \ between the first and the last failure in the\n   history, and k is the number\
    \ of failures in the history.  If k is\n   smaller than K, the estimate is computed\
    \ as if there was a failure at\n   the current time.  It has been shown that an\
    \ estimate calculated in a\n   similar manner is accurate within 17% of the real\
    \ value of U\n   [Ghinita2006].\n   The size of the failure history K affects\
    \ the accuracy of the\n   estimate of U.  One can increase the accuracy by increasing\
    \ K.\n   However, this has the side effect of decreasing responsiveness to\n \
    \  changes in the failure rate.  On the other hand, a small history size\n   may\
    \ cause a peer to overreact each time a new failure occurs.  In\n   [Ghinita2006],\
    \ K is set to 25% of the routing table size.  Use of\n   this value is RECOMMENDED.\n"
- title: 6.3.1.  Detecting Failures
  contents:
  - "6.3.1.  Detecting Failures\n   A new failure is inserted to the failure history\
    \ in the following\n   cases:\n   1.  A Leave request is received from a neighbor.\n\
    \   2.  A peer fails to reply to a Ping request sent in the situation\n      \
    \ explained below.  If no packets have been received on a\n       connection during\
    \ the past 2*Tr seconds (where Tr is the\n       inactivity timer defined by Interactive\
    \ Connectivity\n       Establishment (ICE) [RFC5245]), a RELOAD Ping request MUST\
    \ be\n       sent to the remote peer.  RELOAD mandates the use of Session\n  \
    \     Traversal Utilities for NAT (STUN) [RFC5389] for keepalives.\n       STUN\
    \ keepalives take the form of STUN Binding Indication\n       transactions.  As\
    \ specified in ICE [RFC5245], a peer sends a STUN\n       Binding Indication if\
    \ there has been no packet sent on a\n       connection for Tr seconds.  Tr is\
    \ configurable and has a default\n       of 15 seconds.  Although STUN Binding\
    \ Indications do not generate\n       a response, the fact that a peer has failed\
    \ can be learned from\n       the lack of packets (Binding Indications or application\
    \ protocol\n       packets) received from the peer.  If the remote peer fails\
    \ to\n       reply to the Ping request, the sender should consider the remote\n\
    \       peer to have failed.\n   As an alternative to relying on STUN keepalives\
    \ to detect peer\n   failure, a peer could send additional, frequent RELOAD messages\
    \ to\n   every peer in its connection table.  These messages could be Update\n\
    \   requests, in which case they would serve two purposes: detecting peer\n  \
    \ failure and stabilization.  However, as the cost of this approach can\n   be\
    \ very high in terms of bandwidth consumption and traffic load,\n   especially\
    \ in large-scale overlays experiencing churn, its use is NOT\n   RECOMMENDED.\n"
- title: 6.4.  Estimating Join Rate
  contents:
  - "6.4.  Estimating Join Rate\n   Reference [Ghinita2006] proposes that a peer can\
    \ estimate the join\n   rate based on the uptime of the peers in its routing table.\
    \  An\n   increase in peer join rate will be reflected by a decrease in the\n\
    \   average age of peers in the routing table.  Thus, each peer\n   maintained\
    \ an array of the ages of the peers in its routing table\n   sorted in increasing\
    \ order.  Using this information, an estimate of\n   the global peer join rate\
    \ L is calculated as:\n                                  N\n                 \
    \   L = ----------------------,\n                         Ages[floor(rsize/2)]\n\
    \   where Ages is an array containing the ages of the peers in the\n   routing\
    \ table sorted in increasing order and rsize is the size of the\n   routing table.\
    \  It has been shown that the estimate obtained by using\n   this method is accurate\
    \ within 22% of the real join rate\n   [Ghinita2006].  Of course, the size of\
    \ the routing table affects the\n   accuracy.\n   In order for this mechanism\
    \ to work, peers need to exchange\n   information about the time they have been\
    \ present in the overlay.\n   Peers receive the uptimes of their successors and\
    \ predecessors during\n   the stabilization operations since all Update requests\
    \ carry uptime\n   values.  A joining peer learns the uptime of the admitting\
    \ peer since\n   it receives an Update from the admitting peer during the join\n\
    \   procedure.  Peers learn the uptimes of new fingers since they can\n   fetch\
    \ the uptime using a Probe request after having attached to the\n   new finger.\n"
- title: 6.5.  Estimate Sharing
  contents:
  - "6.5.  Estimate Sharing\n   To improve the accuracy of network size, join rate,\
    \ and leave rate\n   estimates, peers share their estimates.  When the stabilization\
    \ timer\n   fires, a peer selects number-of-peers-to-probe random peers from its\n\
    \   finger table and send each of them a Probe request.  The targets of\n   Probe\
    \ requests are selected from the finger table rather than from\n   the neighbor\
    \ table since neighbors are likely to make similar errors\n   when calculating\
    \ their estimates.  The number-of-peers-to-probe is a\n   new element in the overlay\
    \ configuration document.  It is defined in\n   Section 7.  Both the Probe request\
    \ and the answer returned by the\n   target peer MUST contain a new message extension\
    \ whose\n   MessageExtensionType is 'self_tuning_data'.  This extension type is\n\
    \   defined in Section 9.1.  The 'extension_contents' field of the\n   MessageExtension\
    \ structure MUST contain a SelfTuningData structure:\n               struct {\n\
    \                 uint32                   network_size;\n                 uint32\
    \                   join_rate;\n                 uint32                   leave_rate;\n\
    \               } SelfTuningData;\n   The contents of the SelfTuningData structure\
    \ are as follows:\n   network_size\n      The latest network size estimate calculated\
    \ by the sender.\n   join_rate\n      The latest join rate estimate calculated\
    \ by the sender.\n   leave_rate\n      The latest leave rate estimate calculated\
    \ by the sender.\n   The join and leave rates are expressed as joins or failures\
    \ per 24\n   hours.  As an example, if the global join rate estimate a peer has\n\
    \   calculated is 0.123 peers/s, it would include in the 'join_rate'\n   field\
    \ the ceiling of the value 10627.2 (24*60*60*0.123 = 10627.2),\n   that is, the\
    \ value 10628.\n   The 'type' field of the MessageExtension structure MUST be\
    \ set to\n   contain the value 'self_tuning_data'.  The 'critical' field of the\n\
    \   structure MUST be set to False.\n   A peer stores all estimates it receives\
    \ in Probe requests and answers\n   during a stabilization interval.  When the\
    \ stabilization timer fires,\n   the peer calculates the estimates to be used\
    \ during the next\n   stabilization interval by taking the 75th percentile (i.e.,\
    \ third\n   quartile) of a data set containing its own estimate and the received\n\
    \   estimates.\n   The default value for number-of-peers-to-probe is 4.  This\
    \ default\n   value is recommended to allow a peer to receive a sufficiently large\n\
    \   set of estimates from other peers.  With a value of 4, a peer\n   receives\
    \ four estimates in Probe answers.  On the average, each peer\n   also receives\
    \ four Probe requests each carrying an estimate.  Thus,\n   on the average, each\
    \ peer has nine estimates (including its own) that\n   it can use at the end of\
    \ the stabilization interval.  A value smaller\n   than 4 is NOT RECOMMENDED to\
    \ keep the number of received estimates\n   high enough.  As an example, if the\
    \ value were 2, there would be\n   peers in the overlay that would only receive\
    \ two estimates during a\n   stabilization interval.  Such peers would only have\
    \ three estimates\n   available at the end of the interval, which may not be reliable\n\
    \   enough since even a single exceptionally high or low estimate can\n   have\
    \ a large impact.\n"
- title: 6.6.  Calculating the Stabilization Interval
  contents:
  - "6.6.  Calculating the Stabilization Interval\n   According to [Liben-Nowell2002],\
    \ a Chord network in a ring-like state\n   remains in a ring-like state as long\
    \ as peers send\n   Omega(square(log(N))) messages before N new peers join or\
    \ N/2 peers\n   fail.  We can use the estimate of peer failure rate, U, to calculate\n\
    \   the time Tf in which N/2 peers fail:\n                                  1\n\
    \                           Tf = ------\n                                 2*U\n\
    \   Based on this estimate, a stabilization interval Tstab-1 is\n   calculated\
    \ as:\n                                           Tf\n                       \
    \    Tstab-1 = -----------------\n                                      square(log2(N))\n\
    \   On the other hand, the estimated join rate L can be used to calculate\n  \
    \ the time in which N new peers join the overlay.  Based on the\n   estimate of\
    \ L, a stabilization interval Tstab-2 is calculated as:\n                    \
    \                           N\n                            Tstab-2 = ---------------------\n\
    \                                       L * square(log2(N))\n   Finally, the actual\
    \ stabilization interval Tstab that is used can be\n   obtained by taking the\
    \ minimum of Tstab-1 and Tstab-2.\n   The results obtained in [Maenpaa2009] indicate\
    \ that making the\n   stabilization interval too small has the effect of making\
    \ the overlay\n   less stable (e.g., in terms of detected loops and path failures).\n\
    \   Thus, a lower limit should be used for the stabilization period.\n   Based\
    \ on the results in [Maenpaa2009], a lower limit of 15 s is\n   RECOMMENDED, since\
    \ using a stabilization period smaller than this\n   will with a high probability\
    \ cause too much traffic in the overlay.\n"
- title: 7.  Overlay Configuration Document Extension
  contents:
  - "7.  Overlay Configuration Document Extension\n   This document extends the RELOAD\
    \ overlay configuration document by\n   adding one new element, \"number-of-peers-to-probe\"\
    , inside each\n   \"configuration\" element.\n   self-tuning:number-of-peers-to-probe:\
    \  The number of fingers to which\n      Probe requests are sent to obtain their\
    \ network size, join rate,\n      and leave rate estimates.  The default value\
    \ is 4.\n   The RELAX NG grammar for this element is:\n   namespace self-tuning\
    \ = \"urn:ietf:params:xml:ns:p2p:self-tuning\"\n   parameter &= element self-tuning:number-of-peers-to-probe\
    \ {\n   xsd:unsignedInt }?\n   This namespace is added into the <mandatory-extension>\
    \ element in the\n   overlay configuration file.\n"
- title: 8.  Security Considerations
  contents:
  - "8.  Security Considerations\n   In the same way as malicious or compromised peers\
    \ implementing the\n   RELOAD base protocol [RFC6940] can advertise false network\
    \ metrics or\n   distribute false routing table information for instance in RELOAD\n\
    \   Update messages, malicious peers implementing this specification may\n   share\
    \ false join rate, leave rate, and network size estimates.  For\n   such attacks,\
    \ the same security concerns apply as in the RELOAD base\n   specification.  In\
    \ addition, as long as the amount of malicious peers\n   in the overlay remains\
    \ modest, the statistical mechanisms applied in\n   Section 6.5 (i.e., the use\
    \ of 75th percentiles) to process the shared\n   estimates a peer obtains help\
    \ ensure that estimates that are clearly\n   different from (i.e., larger or smaller\
    \ than) other received\n   estimates will not significantly influence the process\
    \ of adapting\n   the stabilization interval and routing table size.  However,\
    \ it\n   should be noted that if an attacker is able to impersonate a high\n \
    \  number of other peers in the overlay in strategic locations, it may\n   be\
    \ able to send a high enough number of false estimates to a victim\n   and therefore\
    \ influence the victim's choice of a stabilization\n   interval.\n"
- title: 9.  IANA Considerations
  contents:
  - '9.  IANA Considerations

    '
- title: 9.1.  Message Extensions
  contents:
  - "9.1.  Message Extensions\n   This document introduces one additional extension\
    \ to the \"RELOAD\n   Extensions Registry\":\n                  +------------------+-------+---------------+\n\
    \                  | Extension Name   |  Code | Specification |\n            \
    \      +------------------+-------+---------------+\n                  | self_tuning_data\
    \ |   0x3 |      RFC 7363 |\n                  +------------------+-------+---------------+\n\
    \   The contents of the extension are defined in Section 6.5.\n"
- title: 9.2.  New Overlay Algorithm Type
  contents:
  - "9.2.  New Overlay Algorithm Type\n   This document introduces one additional\
    \ overlay algorithm type to the\n   \"RELOAD Overlay Algorithm Types\" registry:\n\
    \                  +-------------------+-----------+\n                  | Algorithm\
    \ Name    | Reference |\n                  +-------------------+-----------+\n\
    \                  | CHORD-SELF-TUNING | RFC 7363  |\n                  +-------------------+-----------+\n"
- title: 9.3.  A New IETF XML Registry
  contents:
  - "9.3.  A New IETF XML Registry\n   This document registers one new URI for the\
    \ self-tuning namespace in\n   the \"ns\" subregistry of the IETF XML registry\
    \ defined in [RFC3688].\n   URI: urn:ietf:params:xml:ns:p2p:self-tuning\n   Registrant\
    \ Contact: The IESG\n   XML: N/A, the requested URI is an XML namespace\n"
- title: 10.  Acknowledgments
  contents:
  - "10.  Acknowledgments\n   The authors would like to thank Jani Hautakorpi for\
    \ his contributions\n   to the document.  The authors would also like to thank\
    \ Carlos\n   Bernardos, Martin Durst, Alissa Cooper, Tobias Gondrom, and Barry\n\
    \   Leiba for their comments on the document.\n"
- title: 11.  References
  contents:
  - '11.  References

    '
- title: 11.1.  Normative References
  contents:
  - "11.1.  Normative References\n   [RFC2119]  Bradner, S., \"Key words for use in\
    \ RFCs to Indicate\n              Requirement Levels\", BCP 14, RFC 2119, March\
    \ 1997.\n   [RFC5245]  Rosenberg, J., \"Interactive Connectivity Establishment\n\
    \              (ICE): A Protocol for Network Address Translator (NAT)\n      \
    \        Traversal for Offer/Answer Protocols\", RFC 5245, April\n           \
    \   2010.\n   [RFC5389]  Rosenberg, J., Mahy, R., Matthews, P., and D. Wing,\n\
    \              \"Session Traversal Utilities for NAT (STUN)\", RFC 5389,\n   \
    \           October 2008.\n   [RFC6940]  Jennings, C., Lowekamp, B., Rescorla,\
    \ E., Baset, S., and\n              H. Schulzrinne, \"REsource LOcation And Discovery\
    \ (RELOAD)\n              Base Protocol\", RFC 6940, January 2014.\n"
- title: 11.2.  Informative References
  contents:
  - "11.2.  Informative References\n   [Binzenhofer2006]\n              Binzenhofer,\
    \ A., Kunzmann, G., and R. Henjes, \"A Scalable\n              Algorithm to Monitor\
    \ Chord-Based P2P Systems at Runtime\",\n              In Proceedings of the 20th\
    \ IEEE International Parallel and\n              Distributed Processing Symposium\
    \ (IPDPS), pp. 1-8, April\n              2006.\n   [CAN]      Ratnasamy, S., Francis,\
    \ P., Handley, M., Karp, R., and S.\n              Schenker, \"A Scalable Content-Addressable\
    \ Network\", In\n              Proceedings of the 2001 Conference on Applications,\n\
    \              Technologies, Architectures and Protocols for Computer\n      \
    \        Communications, pp. 161-172, August 2001.\n   [Chord]    Stoica, I.,\
    \ Morris, R., Liben-Nowell, D., Karger, D.,\n              Kaashoek, M., Dabek,\
    \ F., and H. Balakrishnan, \"Chord: A\n              Scalable Peer-to-peer Lookup\
    \ Service for Internet\n              Applications\", IEEE/ACM Transactions on\
    \ Networking, Volume\n              11, Issue 1, pp. 17-32, February 2003.\n \
    \  [Ghinita2006]\n              Ghinita, G. and Y. Teo, \"An Adaptive Stabilization\n\
    \              Framework for Distributed Hash Tables\", In Proceedings of\n  \
    \            the 20th IEEE International Parallel and Distributed\n          \
    \    Processing Symposium (IPDPS), pp. 29-38, April 2006.\n   [Horowitz2003]\n\
    \              Horowitz, K. and D. Malkhi, \"Estimating Network Size from\n  \
    \            Local Information\", Information Processing Letters, Volume\n   \
    \           88, Issue 5, pp. 237-243, December 2003.\n   [Kostoulas2005]\n   \
    \           Kostoulas, D., Psaltoulis, D., Gupta, I., Birman, K., and\n      \
    \        A. Demers, \"Decentralized Schemes for Size Estimation in\n         \
    \     Large and Dynamic Groups\", In Proceedings of the 4th IEEE\n           \
    \   International Symposium on Network Computing and\n              Applications,\
    \ pp. 41-48, July 2005.\n   [Krishnamurthy2008]\n              Krishnamurthy,\
    \ S., El-Ansary, S., Aurell, E., and S.\n              Haridi, \"Comparing Maintenance\
    \ Strategies for Overlays\",\n              In Proceedings of the 16th Euromicro\
    \ Conference on\n              Parallel, Distributed and Network-Based Processing,\
    \ pp.\n              473-482, February 2008.\n   [Li2004]   Li, J., Strinbling,\
    \ J., Gil, T., Morris, R., and M.\n              Kaashoek, \"Comparing the Performance\
    \ of Distributed Hash\n              Tables Under Churn\", Peer-to-Peer Systems\
    \ III, Volume 3279\n              of Lecture Notes in Computer Science, Springer,\
    \ pp. 87-99,\n              February 2005.\n   [Liben-Nowell2002]\n          \
    \    Liben-Nowell, D., Balakrishnan, H., and D. Karger,\n              \"Observations\
    \ on the Dynamic Evolution of Peer-to-Peer\n              Networks\", In Proceedings\
    \ of the 1st International\n              Workshop on Peer-to-Peer Systems (IPTPS),\
    \ pp. 22-33, March\n              2002.\n   [Maenpaa2009]\n              Maenpaa,\
    \ J. and G. Camarillo, \"A Study on Maintenance\n              Operations in a\
    \ Chord-Based Peer-to-Peer Session\n              Initiation Protocol Overlay\
    \ Network\", In Proceedings of\n              the 23rd IEEE International Parallel\
    \ and Distributed\n              Processing Symposium (IPDPS), pp. 1-9, May 2009.\n\
    \   [Mahajan2003]\n              Mahajan, R., Castro, M., and A. Rowstron, \"\
    Controlling the\n              Cost of Reliability in Peer-to-Peer Overlays\"\
    , In\n              Proceedings of the 2nd International Workshop on Peer-to-\n\
    \              Peer Systems (IPTPS), pp. 21-32, February 2003.\n   [Pastry]  \
    \ Rowstron, A. and P. Druschel, \"Pastry: Scalable,\n              Decentralized\
    \ Object Location and Routing for Large-Scale\n              Peer-to-Peer Systems\"\
    , In Proceedings of the IFIP/ACM\n              International Conference on Distributed\
    \ Systems Platforms,\n              pp. 329-350, November 2001.\n   [RFC3688]\
    \  Mealling, M., \"The IETF XML Registry\", BCP 81, RFC 3688,\n              January\
    \ 2004.\n   [Rhea2004]\n              Rhea, S., Geels, D., Roscoe, T., and J.\
    \ Kubiatowicz,\n              \"Handling Churn in a DHT\", In Proceedings of the\
    \ USENIX\n              Annual Technical Conference, pp. 127-140, June 2004.\n\
    \   [Weiss1998]\n              Weiss, M., \"Data Structures and Algorithm Analysis\
    \ in\n              C++\", Addison-Wesley Longman Publishing Co., Inc., 2nd\n\
    \              Edition, ISBN 0201361221, 1998.\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Jouni Maenpaa\n   Ericsson\n   Hirsalantie 11\n   Jorvas\
    \  02420\n   Finland\n   EMail: Jouni.Maenpaa@ericsson.com\n   Gonzalo Camarillo\n\
    \   Ericsson\n   Hirsalantie 11\n   Jorvas  02420\n   Finland\n   EMail: Gonzalo.Camarillo@ericsson.com\n"
