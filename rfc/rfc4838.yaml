- title: __initial_text__
  contents:
  - '                Delay-Tolerant Networking Architecture

    '
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This memo provides information for the Internet community.\
    \  It does\n   not specify an Internet standard of any kind.  Distribution of\
    \ this\n   memo is unlimited.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (C) The IETF Trust (2007).\n"
- title: IESG Note
  contents:
  - "IESG Note\n   This RFC is a product of the Internet Research Task Force and is\
    \ not\n   a candidate for any level of Internet Standard.  The IRTF publishes\n\
    \   the results of Internet-related research and development activities.\n   These\
    \ results might not be suitable for deployment on the public\n   Internet.\n"
- title: Abstract
  contents:
  - "Abstract\n   This document describes an architecture for delay-tolerant and\n\
    \   disruption-tolerant networks, and is an evolution of the architecture\n  \
    \ originally designed for the Interplanetary Internet, a communication\n   system\
    \ envisioned to provide Internet-like services across\n   interplanetary distances\
    \ in support of deep space exploration.  This\n   document describes an architecture\
    \ that addresses a variety of\n   problems with internetworks having operational\
    \ and performance\n   characteristics that make conventional (Internet-like) networking\n\
    \   approaches either unworkable or impractical.  We define a message-\n   oriented\
    \ overlay that exists above the transport (or other) layers of\n   the networks\
    \ it interconnects.  The document presents a motivation\n   for the architecture,\
    \ an architectural overview, review of state\n   management required for its operation,\
    \ and a discussion of\n   application design issues.  This document represents\
    \ the consensus of\n   the IRTF DTN research group and has been widely reviewed\
    \ by that\n   group.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1. Introduction ....................................................3\n\
    \   2. Why an Architecture for Delay-Tolerant Networking? ..............4\n  \
    \ 3. DTN Architectural Description ...................................5\n    \
    \  3.1. Virtual Message Switching Using Store-and-Forward\n           Operation\
    \ ..................................................5\n      3.2. Nodes and Endpoints\
    \ ........................................7\n      3.3. Endpoint Identifiers (EIDs)\
    \ and Registrations ..............8\n      3.4. Anycast and Multicast .....................................10\n\
    \      3.5. Priority Classes ..........................................10\n  \
    \    3.6. Postal-Style Delivery Options and Administrative Records ..11\n    \
    \  3.7. Primary Bundle Fields .....................................15\n      3.8.\
    \ Routing and Forwarding ....................................16\n      3.9. Fragmentation\
    \ and Reassembly ..............................18\n      3.10. Reliability and\
    \ Custody Transfer .........................19\n      3.11. DTN Support for Proxies\
    \ and Application Layer Gateways ...21\n      3.12. Timestamps and Time Synchronization\
    \ ......................22\n      3.13. Congestion and Flow Control at the Bundle\
    \ Layer ..........22\n      3.14. Security .................................................23\n\
    \   4. State Management Considerations ................................25\n  \
    \    4.1. Application Registration State ............................25\n    \
    \  4.2. Custody Transfer State ....................................26\n      4.3.\
    \ Bundle Routing and Forwarding State .......................26\n      4.4. Security-Related\
    \ State ....................................27\n      4.5. Policy and Configuration\
    \ State ............................27\n   5. Application Structuring Issues .................................28\n\
    \   6. Convergence Layer Considerations for Use of Underlying\n      Protocols\
    \ ......................................................28\n   7. Summary ........................................................29\n\
    \   8. Security Considerations ........................................29\n  \
    \ 9. IANA Considerations ............................................30\n   10.\
    \ Normative References ..........................................30\n   11. Informative\
    \ References ........................................30\n   12. Acknowledgments\
    \ ...............................................32\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   This document describes an architecture for delay and disruption-\n\
    \   tolerant interoperable networking (DTN).  The architecture embraces\n   the\
    \ concepts of occasionally-connected networks that may suffer from\n   frequent\
    \ partitions and that may be comprised of more than one\n   divergent set of protocols\
    \ or protocol families.  The basis for this\n   architecture lies with that of\
    \ the Interplanetary Internet, which\n   focused primarily on the issue of deep\
    \ space communication in high-\n   delay environments.  We expect the DTN architecture\
    \ described here to\n   be utilized in various operational environments, including\
    \ those\n   subject to disruption and disconnection and those with high-delay;\n\
    \   the case of deep space is one specialized example of these, and is\n   being\
    \ pursued as a specialization of this architecture (See [IPN01]\n   and [SB03]\
    \ for more details).\n   Other networks to which we believe this architecture\
    \ applies include\n   sensor-based networks using scheduled intermittent connectivity,\n\
    \   terrestrial wireless networks that cannot ordinarily maintain end-to-\n  \
    \ end connectivity, satellite networks with moderate delays and\n   periodic connectivity,\
    \ and underwater acoustic networks with moderate\n   delays and frequent interruptions\
    \ due to environmental factors.  A\n   DTN tutorial [FW03], aimed at introducing\
    \ DTN and the types of\n   networks for which it is designed, is available to\
    \ introduce new\n   readers to the fundamental concepts and motivation.  More\
    \ technical\n   descriptions may be found in [KF03], [JFP04], [JDPF05], and [WJMF05].\n\
    \   We define an end-to-end message-oriented overlay called the \"bundle\n   layer\"\
    \ that exists at a layer above the transport (or other) layers\n   of the networks\
    \ on which it is hosted and below applications.\n   Devices implementing the bundle\
    \ layer are called DTN nodes.  The\n   bundle layer forms an overlay that employs\
    \ persistent storage to help\n   combat network interruption.  It includes a hop-by-hop\
    \ transfer of\n   reliable delivery responsibility and optional end-to-end\n \
    \  acknowledgement.  It also includes a number of diagnostic and\n   management\
    \ features.  For interoperability, it uses a flexible naming\n   scheme (based\
    \ on Uniform Resource Identifiers [RFC3986]) capable of\n   encapsulating different\
    \ naming and addressing schemes in the same\n   overall naming syntax.  It also\
    \ has a basic security model,\n   optionally enabled, aimed at protecting infrastructure\
    \ from\n   unauthorized use.\n   The bundle layer provides functionality similar\
    \ to the internet layer\n   of gateways described in the original ARPANET/Internet\
    \ designs\n   [CK74].  It differs from ARPANET gateways, however, because it is\n\
    \   layer-agnostic and is focused on virtual message forwarding rather\n   than\
    \ packet switching.  However, both generally provide\n   interoperability between\
    \ underlying protocols specific to one\n   environment and those protocols specific\
    \ to another, and both provide\n   a store-and-forward forwarding service (with\
    \ the bundle layer\n   employing persistent storage for its store and forward\
    \ function).\n   In a sense, the DTN architecture provides a common method for\n\
    \   interconnecting heterogeneous gateways or proxies that employ store-\n   and-forward\
    \ message routing to overcome communication disruptions.\n   It provides services\
    \ similar to electronic mail, but with enhanced\n   naming, routing, and security\
    \ capabilities.  Nodes unable to support\n   the full capabilities required by\
    \ this architecture may be supported\n   by application-layer proxies acting as\
    \ DTN applications.\n"
- title: 2.  Why an Architecture for Delay-Tolerant Networking?
  contents:
  - "2.  Why an Architecture for Delay-Tolerant Networking?\n   Our motivation for\
    \ pursuing an architecture for delay tolerant\n   networking stems from several\
    \ factors.  These factors are summarized\n   below; much more detail on their\
    \ rationale can be explored in [SB03],\n   [KF03], and [DFS02].\n   The existing\
    \ Internet protocols do not work well for some\n   environments, due to some fundamental\
    \ assumptions built into the\n   Internet architecture:\n   - that an end-to-end\
    \ path between source and destination exists for\n     the duration of a communication\
    \ session\n   - (for reliable communication) that retransmissions based on timely\n\
    \     and stable feedback from data receivers is an effective means for\n    \
    \ repairing errors\n   - that end-to-end loss is relatively small\n   - that all\
    \ routers and end stations support the TCP/IP protocols\n   - that applications\
    \ need not worry about communication performance\n   - that endpoint-based security\
    \ mechanisms are sufficient for meeting\n     most security concerns\n   - that\
    \ packet switching is the most appropriate abstraction for\n     interoperability\
    \ and performance\n   - that selecting a single route between sender and receiver\
    \ is\n     sufficient for achieving acceptable communication performance\n   The\
    \ DTN architecture is conceived to relax most of these assumptions,\n   based\
    \ on a number of design principles that are summarized here (and\n   further discussed\
    \ in [KF03]):\n   - Use variable-length (possibly long) messages (not streams\
    \ or\n     limited-sized packets) as the communication abstraction to help\n \
    \    enhance the ability of the network to make good scheduling/path\n     selection\
    \ decisions when possible.\n   - Use a naming syntax that supports a wide range\
    \ of naming and\n     addressing conventions to enhance interoperability.\n  \
    \ - Use storage within the network to support store-and-forward\n     operation\
    \ over multiple paths, and over potentially long timescales\n     (i.e., to support\
    \ operation in environments where many and/or no\n     end-to-end paths may ever\
    \ exist); do not require end-to-end\n     reliability.\n   - Provide security\
    \ mechanisms that protect the infrastructure from\n     unauthorized use by discarding\
    \ traffic as quickly as possible.\n   - Provide coarse-grained classes of service,\
    \ delivery options, and a\n     way to express the useful lifetime of data to\
    \ allow the network to\n     better deliver data in serving the needs of applications.\n\
    \   The use of the bundle layer is guided not only by its own design\n   principles,\
    \ but also by a few application design principles:\n   - Applications should minimize\
    \ the number of round-trip exchanges.\n   - Applications should cope with restarts\
    \ after failure while network\n     transactions remain pending.\n   - Applications\
    \ should inform the network of the useful life and\n     relative importance of\
    \ data to be delivered.\n   These issues are discussed in further detail in Section\
    \ 5.\n"
- title: 3.  DTN Architectural Description
  contents:
  - "3.  DTN Architectural Description\n   The previous section summarized the design\
    \ principles that guide the\n   definition of the DTN architecture.  This section\
    \ presents a\n   description of the major features of the architecture resulting\
    \ from\n   design decisions guided by the aforementioned design principles.\n"
- title: 3.1.  Virtual Message Switching Using Store-and-Forward Operation
  contents:
  - "3.1.  Virtual Message Switching Using Store-and-Forward Operation\n   A DTN-enabled\
    \ application sends messages of arbitrary length, also\n   called Application\
    \ Data Units or ADUs [CT90], which are subject to\n   any implementation limitations.\
    \  The relative order of ADUs might not\n   be preserved.  ADUs are typically\
    \ sent by and delivered to\n   applications in complete units, although a system\
    \ interface that\n   behaves differently is not precluded.\n   ADUs are transformed\
    \ by the bundle layer into one or more protocol\n   data units called \"bundles\"\
    , which are forwarded by DTN nodes.\n   Bundles have a defined format containing\
    \ two or more \"blocks\" of\n   data.  Each block may contain either application\
    \ data or other\n   information used to deliver the containing bundle to its\n\
    \   destination(s).  Blocks serve the purpose of holding information\n   typically\
    \ found in the header or payload portion of protocol data\n   units in other protocol\
    \ architectures.  The term \"block\" is used\n   instead of \"header\" because\
    \ blocks may not appear at the beginning of\n   a bundle due to particular processing\
    \ requirements (e.g., digital\n   signatures).\n   Bundles may be split up (\"\
    fragmented\") into multiple constituent\n   bundles (also called \"fragments\"\
    \ or \"bundle fragments\") during\n   transmission.  Fragments are themselves\
    \ bundles, and may be further\n   fragmented.  Two or more fragments may be reassembled\
    \ anywhere in the\n   network, forming a new bundle.\n   Bundle sources and destinations\
    \ are identified by (variable-length)\n   Endpoint Identifiers (EIDs, described\
    \ below), which identify the\n   original sender and final destination(s) of bundles,\
    \ respectively.\n   Bundles also contain a \"report-to\" EID used when special\
    \ operations\n   are requested to direct diagnostic output to an arbitrary entity\n\
    \   (e.g., other than the source).  An EID may refer to one or more DTN\n   nodes\
    \ (i.e., for multicast destinations or \"report-to\" destinations).\n   While\
    \ IP networks are based on \"store-and-forward\" operation, there\n   is an assumption\
    \ that the \"storing\" will not persist for more than a\n   modest amount of time,\
    \ on the order of the queuing and transmission\n   delay.  In contrast, the DTN\
    \ architecture does not expect that\n   network links are always available or\
    \ reliable, and instead expects\n   that nodes may choose to store bundles for\
    \ some time.  We anticipate\n   that most DTN nodes will use some form of persistent\
    \ storage for this\n   -- disk, flash memory, etc. -- and that stored bundles\
    \ will survive\n   system restarts.\n   Bundles contain an originating timestamp,\
    \ useful life indicator, a\n   class of service designator, and a length.  This\
    \ information provides\n   bundle-layer routing with a priori knowledge of the\
    \ size and\n   performance requirements of requested data transfers.  When there\
    \ is\n   a significant amount of queuing that can occur in the network (as is\n\
    \   the case in the DTN version of store-and-forward), the advantage\n   provided\
    \ by knowing this information may be significant for making\n   scheduling and\
    \ path selection decisions [JFP04].  An alternative\n   abstraction (i.e., of\
    \ stream-based delivery based on packets) would\n   make such scheduling much\
    \ more difficult.  Although packets provide\n   some of the same benefits as bundles,\
    \ larger aggregates provide a way\n   for the network to apply scheduling and\
    \ buffer management to units of\n   data that are more useful to applications.\n\
    \   An essential element of the bundle-based style of forwarding is that\n   bundles\
    \ have a place to wait in a queue until a communication\n   opportunity (\"contact\"\
    ) is available.  This highlights the following\n   assumptions:\n   1. that storage\
    \ is available and well-distributed throughout the\n      network,\n   2. that\
    \ storage is sufficiently persistent and robust to store\n      bundles until\
    \ forwarding can occur, and\n   3. (implicitly) that this \"store-and-forward\"\
    \ model is a better\n      choice than attempting to effect continuous connectivity\
    \ or other\n      alternatives.\n   For a network to effectively support the DTN\
    \ architecture, these\n   assumptions must be considered and must be found to\
    \ hold.  Even so,\n   the inclusion of long-term storage as a fundamental aspect\
    \ of the DTN\n   architecture poses new problems, especially with respect to\n\
    \   congestion management and denial-of-service mitigation.  Node storage\n  \
    \ in essence represents a new resource that must be managed and\n   protected.\
    \  Much of the research in DTN revolves around exploring\n   these issues.  Congestion\
    \ is discussed in Section 3.13, and security\n   mechanisms, including methods\
    \ for DTN nodes to protect themselves\n   from handling unauthorized traffic from\
    \ other nodes, are discussed in\n   [DTNSEC] and [DTNSOV].\n"
- title: 3.2.  Nodes and Endpoints
  contents:
  - "3.2.  Nodes and Endpoints\n   A DTN node (or simply \"node\" in this document)\
    \ is an engine for\n   sending and receiving bundles -- an implementation of the\
    \ bundle\n   layer.  Applications utilize DTN nodes to send or receive ADUs\n\
    \   carried in bundles (applications also use DTN nodes when acting as\n   report-to\
    \ destinations for diagnostic information carried in\n   bundles).  Nodes may\
    \ be members of groups called \"DTN endpoints\".  A\n   DTN endpoint is therefore\
    \ a set of DTN nodes.  A bundle is considered\n   to have been successfully delivered\
    \ to a DTN endpoint when some\n   minimum subset of the nodes in the endpoint\
    \ has received the bundle\n   without error.  This subset is called the \"minimum\
    \ reception group\"\n   (MRG) of the endpoint.  The MRG of an endpoint may refer\
    \ to one node\n   (unicast), one of a group of nodes (anycast), or all of a group\
    \ of\n   nodes (multicast and broadcast).  A single node may be in the MRG of\n\
    \   multiple endpoints.\n"
- title: 3.3.  Endpoint Identifiers (EIDs) and Registrations
  contents:
  - "3.3.  Endpoint Identifiers (EIDs) and Registrations\n   An Endpoint Identifier\
    \ (EID) is a name, expressed using the general\n   syntax of URIs (see below),\
    \ that identifies a DTN endpoint.  Using an\n   EID, a node is able to determine\
    \ the MRG of the DTN endpoint named by\n   the EID.  Each node is also required\
    \ to have at least one EID that\n   uniquely identifies it.\n   Applications send\
    \ ADUs destined for an EID, and may arrange for ADUs\n   sent to a particular\
    \ EID to be delivered to them.  Depending on the\n   construction of the EID being\
    \ used (see below), there may be a\n   provision for wildcarding some portion\
    \ of an EID, which is often\n   useful for diagnostic and routing purposes.\n\
    \   An application's desire to receive ADUs destined for a particular EID\n  \
    \ is called a \"registration\", and in general is maintained persistently\n  \
    \ by a DTN node.  This allows application registration information to\n   survive\
    \ application and operating system restarts.\n   An application's attempt to establish\
    \ a registration is not\n   guaranteed to succeed.  For example, an application\
    \ could request to\n   register itself to receive ADUs by specifying an Endpoint\
    \ ID that is\n   uninterpretable or unavailable to the DTN node servicing the\
    \ request.\n   Such requests are likely to fail.\n"
- title: 3.3.1.  URI Schemes
  contents:
  - "3.3.1.  URI Schemes\n   Each Endpoint ID is expressed syntactically as a Uniform\
    \ Resource\n   Identifier (URI) [RFC3986].  The URI syntax has been designed as\
    \ a\n   way to express names or addresses for a wide range of purposes, and\n\
    \   is therefore useful for constructing names for DTN endpoints.\n   In URI terminology,\
    \ each URI begins with a scheme name.  The scheme\n   name is an element of the\
    \ set of globally-managed scheme names\n   maintained by IANA [ISCHEMES].  Lexically\
    \ following the scheme name\n   in a URI is a series of characters constrained\
    \ by the syntax defined\n   by the scheme.  This portion of the URI is called\
    \ the scheme-specific\n   part (SSP), and can be quite general.  (See, as one\
    \ example, the URI\n   scheme for SNMP [RFC4088]).  Note that scheme-specific\
    \ syntactical\n   and semantic restrictions may be more constraining than the\
    \ basic\n   rules of RFC 3986.  Section 3.1 of RFC 3986 provides guidance on the\n\
    \   syntax of scheme names.\n   URI schemes are a key concept in the DTN architecture,\
    \ and evolved\n   from an earlier concept called regions, which were tied more\
    \ closely\n   to assumptions of the network topology.  Using URIs, significant\n\
    \   flexibility is attained in the structuring of EIDs.  They might, for\n   example,\
    \ be constructed based on DNS names, or might look like\n   \"expressions of interest\"\
    \ or forms of database-like queries as in a\n   directed diffusion-routed network\
    \ [IGE00] or in intentional naming\n   [WSBL99].  As names, EIDs are not required\
    \ to be related to routing\n   or topological organization.  Such a relationship\
    \ is not prohibited,\n   however, and in some environments using EIDs this way\
    \ may be\n   advantageous.\n   A single EID may refer to an endpoint containing\
    \ more than one DTN\n   node, as suggested above.  It is the responsibility of\
    \ a scheme\n   designer to define how to interpret the SSP of an EID so as to\n\
    \   determine whether it refers to a unicast, multicast, or anycast set\n   of\
    \ nodes.  See Section 3.4 for more details.\n   URIs are constructed based on\
    \ rules specified in RFC 3986, using the\n   US-ASCII character set.  However,\
    \ note this excerpt from RFC 3986,\n   Section 1.2.1, on dealing with characters\
    \ that cannot be represented\n   by US-ASCII:  \"Percent-encoded octets (Section\
    \ 2.1) may be used\n   within a URI to represent characters outside the range\
    \ of the US-\n   ASCII coded character set if this representation is allowed by\
    \ the\n   scheme or by the protocol element in which the URI is referenced.\n\
    \   Such a definition should specify the character encoding used to map\n   those\
    \ characters to octets prior to being percent-encoded for the\n   URI\".\n"
- title: 3.3.2.  Late Binding
  contents:
  - "3.3.2.  Late Binding\n   Binding means interpreting the SSP of an EID for the\
    \ purpose of\n   carrying an associated message towards a destination.  For example,\n\
    \   binding might require mapping an EID to a next-hop EID or to a lower-\n  \
    \ layer address for transmission.  \"Late binding\" means that the\n   binding\
    \ of a bundle's destination to a particular set of destination\n   identifiers\
    \ or addresses does not necessarily happen at the bundle\n   source.  Because\
    \ the destination EID is potentially re-interpreted at\n   each hop, the binding\
    \ may occur at the source, during transit, or\n   possibly at the destination(s).\
    \  This contrasts with the name-to-\n   address binding of Internet communications\
    \ where a DNS lookup at the\n   source fixes the IP address of the destination\
    \ node before data is\n   sent.  Such a circumstance would be considered \"early\
    \ binding\"\n   because the name-to-address translation is performed prior to\
    \ data\n   being sent into the network.\n   In a frequently-disconnected network,\
    \ late binding may be\n   advantageous because the transit time of a message may\
    \ exceed the\n   validity time of a binding, making binding at the source impossible\n\
    \   or invalid.  Furthermore, use of name-based routing with late binding\n  \
    \ may reduce the amount of administrative (mapping) information that\n   must\
    \ propagate through the network, and may also limit the scope of\n   mapping synchronization\
    \ requirements to a local topological\n   neighborhood where changes are made.\n"
- title: 3.4.  Anycast and Multicast
  contents:
  - "3.4.  Anycast and Multicast\n   As mentioned above, an EID may refer to an endpoint\
    \ containing one or\n   more DTN nodes.  When referring to a group of size greater\
    \ than one,\n   the delivery semantics may be of either the anycast or multicast\n\
    \   variety (broadcast is considered to be of the multicast variety).\n   For\
    \ anycast group delivery, a bundle is delivered to one node among a\n   group\
    \ of potentially many nodes, and for multicast delivery it is\n   intended to\
    \ be delivered to all of them, subject to the normal DTN\n   class of service\
    \ and maximum useful lifetime semantics.\n   Multicast group delivery in a DTN\
    \ presents an unfamiliar issue with\n   respect to group membership.  In relatively\
    \ low-delay networks, such\n   as the Internet, nodes may be considered to be\
    \ part of the group if\n   they have expressed interest to join it \"recently\"\
    .  In a DTN,\n   however, nodes may wish to receive data sent to a group during\
    \ an\n   interval of time earlier than when they are actually able to receive\n\
    \   it [ZAZ05].  More precisely, an application expresses its desire to\n   receive\
    \ data sent to EID e at time t.  Prior to this, during the\n   interval [t0, t1],\
    \ t > t1, data may have been generated for group e.\n   For the application to\
    \ receive any of this data, the data must be\n   available a potentially long\
    \ time after senders have ceased sending\n   to the group.  Thus, the data may\
    \ need to be stored within the\n   network in order to support temporal group\
    \ semantics of this kind.\n   How to design and implement this remains a research\
    \ issue, as it is\n   likely to be at least as hard as problems related to reliable\n\
    \   multicast.\n"
- title: 3.5.  Priority Classes
  contents:
  - "3.5.  Priority Classes\n   The DTN architecture offers *relative* measures of\
    \ priority (low,\n   medium, high) for delivering ADUs.  These priorities differentiate\n\
    \   traffic based upon an application's desire to affect the delivery\n   urgency\
    \ for ADUs, and are carried in bundle blocks generated by the\n   bundle layer\
    \ based on information specified by the application.\n   The (U.S. or similar)\
    \ Postal Service provides a strong metaphor for\n   the priority classes offered\
    \ by the forwarding abstraction offered by\n   the DTN architecture.  Traffic\
    \ is generally not interactive and is\n   often one-way.  There are generally\
    \ no strong guarantees of timely\n   delivery, yet there are some forms of class\
    \ of service, reliability,\n   and security.\n   We have defined three relative\
    \ priority classes to date.  These\n   priority classes typically imply some relative\
    \ scheduling\n   prioritization among bundles in queue at a sender:\n   - Bulk\
    \ - Bulk bundles are shipped on a \"least effort\" basis.  No\n     bundles of\
    \ this class will be shipped until all bundles of other\n     classes bound for\
    \ the same destination and originating from the\n     same source have been shipped.\n\
    \   - Normal - Normal-class bundles are shipped prior to any bulk-class\n    \
    \ bundles and are otherwise the same as bulk bundles.\n   - Expedited - Expedited\
    \ bundles, in general, are shipped prior to\n     bundles of other classes and\
    \ are otherwise the same.\n   Applications specify their requested priority class\
    \ and data lifetime\n   (see below) for each ADU they send.  This information,\
    \ coupled with\n   policy applied at DTN nodes that select how messages are forwarded\n\
    \   and which routing algorithms are in use, affects the overall\n   likelihood\
    \ and timeliness of ADU delivery.\n   The priority class of a bundle is only required\
    \ to relate to other\n   bundles from the same source.  This means that a high\
    \ priority bundle\n   from one source may not be delivered faster (or with some\
    \ other\n   superior quality of service) than a medium priority bundle from a\n\
    \   different source.  It does mean that a high priority bundle from one\n   source\
    \ will be handled preferentially to a lower priority bundle sent\n   from the\
    \ same source.\n   Depending on a particular DTN node's forwarding/scheduling\
    \ policy,\n   priority may or may not be enforced across different sources.  That\n\
    \   is, in some DTN nodes, expedited bundles might always be sent prior\n   to\
    \ any bulk bundles, irrespective of source.  Many variations are\n   possible.\n"
- title: 3.6.  Postal-Style Delivery Options and Administrative Records
  contents:
  - "3.6.  Postal-Style Delivery Options and Administrative Records\n   Continuing\
    \ with the postal analogy, the DTN architecture supports\n   several delivery\
    \ options that may be selected by an application when\n   it requests the transmission\
    \ of an ADU.  In addition, the\n   architecture defines two types of administrative\
    \ records: \"status\n   reports\" and \"signals\".  These records are bundles\
    \ that provide\n   information about the delivery of other bundles, and are used\
    \ in\n   conjunction with the delivery options.\n"
- title: 3.6.1.  Delivery Options
  contents:
  - "3.6.1.  Delivery Options\n   We have defined eight delivery options.  Applications\
    \ sending an ADU\n   (the \"subject ADU\") may request any combination of the\
    \ following,\n   which are carried in each of the bundles produced (\"sent bundles\"\
    ) by\n   the bundle layer resulting from the application's request to send the\n\
    \   subject ADU:\n   - Custody Transfer Requested - requests sent bundles be delivered\n\
    \     with enhanced reliability using custody transfer procedures.  Sent\n   \
    \  bundles will be transmitted by the bundle layer using reliable\n     transfer\
    \ protocols (if available), and the responsibility for\n     reliable delivery\
    \ of the bundle to its destination(s) may move\n     among one or more \"custodians\"\
    \ in the network.  This capability is\n     described in more detail in Section\
    \ 3.10.\n   - Source Node Custody Acceptance Required - requires the source DTN\n\
    \     node to provide custody transfer for the sent bundles.  If custody\n   \
    \  transfer is not available at the source when this delivery option\n     is\
    \ requested, the requested transmission fails.  This provides a\n     means for\
    \ applications to insist that the source DTN node take\n     custody of the sent\
    \ bundles (e.g., by storing them in persistent\n     storage).\n   - Report When\
    \ Bundle Delivered - requests a (single) Bundle Delivery\n     Status Report be\
    \ generated when the subject ADU is delivered to its\n     intended recipient(s).\
    \  This request is also known as \"return-\n     receipt\".\n   - Report When\
    \ Bundle Acknowledged by Application - requests an\n     Acknowledgement Status\
    \ Report be generated when the subject ADU is\n     acknowledged by a receiving\
    \ application.  This only happens by\n     action of the receiving application,\
    \ and differs from the Bundle\n     Delivery Status Report.  It is intended for\
    \ cases where the\n     application may be acting as a form of application layer\
    \ gateway\n     and wishes to indicate the status of a protocol operation external\n\
    \     to DTN back to the requesting source.  See Section 11 for more\n     details.\n\
    \   - Report When Bundle Received - requests a Bundle Reception Status\n     Report\
    \ be generated when each sent bundle arrives at a DTN node.\n     This is designed\
    \ primarily for diagnostic purposes.\n   - Report When Bundle Custody Accepted\
    \  - requests a Custody\n     Acceptance Status Report be generated when each\
    \ sent bundle has\n     been accepted using custody transfer.  This is designed\
    \ primarily\n     for diagnostic purposes.\n   - Report When Bundle Forwarded\
    \ - requests a Bundle Forwarding Status\n     Report be generated when each sent\
    \ bundle departs a DTN node after\n     forwarding.  This is designed primarily\
    \ for diagnostic purposes.\n   - Report When Bundle Deleted - requests a Bundle\
    \ Deletion Status\n     Report be generated when each sent bundle is deleted at\
    \ a DTN node.\n     This is designed primarily for diagnostic purposes.\n   The\
    \ first four delivery options are designed for ordinary use by\n   applications.\
    \  The last four are designed primarily for diagnostic\n   purposes and their\
    \ use may be restricted or limited in environments\n   subject to congestion or\
    \ attack.\n   If the security procedures defined in [DTNSEC] are also enabled,\
    \ then\n   three additional delivery options become available:\n   - Confidentiality\
    \ Required - requires the subject ADU be made secret\n     from parties other\
    \ than the source and the members of the\n     destination EID.\n   - Authentication\
    \ Required - requires all non-mutable fields in the\n     bundle blocks of the\
    \ sent bundles (i.e., those which do not change\n     as the bundle is forwarded)\
    \ be made strongly verifiable (i.e.,\n     cryptographically strong).  This protects\
    \ several fields, including\n     the source and destination EIDs and the bundle's\
    \ data.  See Section\n     3.7 and [BSPEC] for more details.\n   - Error Detection\
    \ Required - requires modifications to the non-\n     mutable fields of each sent\
    \ bundle be made detectable with high\n     probability at each destination.\n"
- title: '3.6.2.  Administrative Records: Bundle Status Reports and Custody'
  contents:
  - "3.6.2.  Administrative Records: Bundle Status Reports and Custody\n        Signals\n\
    \   Administrative records are used to report status information or error\n  \
    \ conditions related to the bundle layer.  There are two types of\n   administrative\
    \ records defined:  bundle status reports (BSRs) and\n   custody signals.  Administrative\
    \ records correspond (approximately)\n   to messages in the ICMP protocol in IP\
    \ [RFC792].  In ICMP, however,\n   messages are returned to the source.  In DTN,\
    \ they are instead\n   directed to the report-to EID for BSRs and the EID of the\
    \ current\n   custodian for custody signals, which might differ from the source's\n\
    \   EID.  Administrative records are sent as bundles with a source EID\n   set\
    \ to one of the EIDs associated with the DTN node generating the\n   administrative\
    \ record.  In some cases, arrival of a single bundle or\n   bundle fragment may\
    \ elicit multiple administrative records (e.g., in\n   the case where a bundle\
    \ is replicated for multicast forwarding).\n   The following BSRs are currently\
    \ defined (also see [BSPEC] for more\n   details):\n   - Bundle Reception - sent\
    \ when a bundle arrives at a DTN node.\n     Generation of this message may be\
    \ limited by local policy.\n   - Custody Acceptance - sent when a node has accepted\
    \ custody of a\n     bundle with the Custody Transfer Requested option set.  Generation\n\
    \     of this message may be limited by local policy.\n   - Bundle Forwarded -\
    \ sent when a bundle containing a Report When\n     Bundle Forwarded option departs\
    \ from a DTN node after having been\n     forwarded.  Generation of this message\
    \ may be limited by local\n     policy.\n   - Bundle Deletion - sent from a DTN\
    \ node when a bundle containing a\n     Report When Bundle Deleted option is discarded.\
    \  This can happen\n     for several reasons, such as expiration.  Generation\
    \ of this\n     message may be limited by local policy but is required in cases\n\
    \     where the deletion is performed by a bundle's current custodian.\n   - Bundle\
    \ Delivery - sent from a final recipient's (destination) node\n     when a complete\
    \ ADU comprising sent bundles containing Report When\n     Bundle Delivered options\
    \ is consumed by an application.\n   - Acknowledged by application - sent from\
    \ a final recipient's\n     (destination) node when a complete ADU comprising\
    \ sent bundles\n     containing Application Acknowledgment options has been processed\
    \ by\n     an application.  This generally involves specific action on the\n \
    \    receiving application's part.\n   In addition to the status reports, the\
    \ custody signal is currently\n   defined to indicate the status of a custody\
    \ transfer.  These are sent\n   to the current-custodian EID contained in an arriving\
    \ bundle:\n   - Custody Signal - indicates that custody has been successfully\n\
    \     transferred.  This signal appears as a Boolean indicator, and may\n    \
    \ therefore indicate either a successful or a failed custody transfer\n     attempt.\n\
    \   Administrative records must reference a received bundle.  This is\n   accomplished\
    \ by a method for uniquely identifying bundles based on a\n   transmission timestamp\
    \ and sequence number discussed in Section 3.12.\n"
- title: 3.7.  Primary Bundle Fields
  contents:
  - "3.7.  Primary Bundle Fields\n   The bundles carried between and among DTN nodes\
    \ obey a standard\n   bundle protocol specified in [BSPEC].  Here we provide an\
    \ overview of\n   most of the fields carried with every bundle.  The protocol\
    \ is\n   designed with a mandatory primary block, an optional payload block\n\
    \   (which contains the ADU data itself), and a set of optional extension\n  \
    \ blocks.  Blocks may be cascaded in a way similar to extension headers\n   in\
    \ IPv6.  The following selected fields are all present in the\n   primary block,\
    \ and therefore are present for every bundle and\n   fragment:\n   - Creation\
    \ Timestamp - a concatenation of the bundle's creation time\n     and a monotonically\
    \ increasing sequence number such that the\n     creation timestamp is guaranteed\
    \ to be unique for each ADU\n     originating from the same source.  The creation\
    \ timestamp is based\n     on the time-of-day an application requested an ADU\
    \ to be sent (not\n     when the corresponding bundle(s) are sent into the network).\
    \  DTN\n     nodes are assumed to have a basic time synchronization capability\n\
    \     (see Section 3.12).\n   - Lifespan - the time-of-day at which the message\
    \ is no longer\n     useful.  If a bundle is stored in the network (including\
    \ the\n     source's DTN node) when its lifespan is reached, it may be\n     discarded.\
    \  The lifespan of a bundle is expressed as an offset\n     relative to its creation\
    \ time.\n   - Class of Service Flags - indicates the delivery options and\n  \
    \   priority class for the bundle.  Priority classes may be one of\n     bulk,\
    \ normal, or expedited.  See Section 3.6.1.\n   - Source EID - EID of the source\
    \ (the first sender).\n   - Destination EID - EID of the destination (the final\
    \ intended\n     recipient(s)).\n   - Report-To Endpoint ID - an EID identifying\
    \ where reports (return-\n     receipt, route-tracing functions) should be sent.\
    \  This may or may\n     not identify the same endpoint as the Source EID.\n \
    \  - Custodian EID - EID of the current custodian of a bundle (if any).\n   The\
    \ payload block indicates information about the contained payload\n   (e.g., its\
    \ length) and the payload itself.  In addition to the fields\n   found in the\
    \ primary and payload blocks, each bundle may have fields\n   in additional blocks\
    \ carried with each bundle.  See [BSPEC] for\n   additional details.\n"
- title: 3.8.  Routing and Forwarding
  contents:
  - "3.8.  Routing and Forwarding\n   The DTN architecture provides a framework for\
    \ routing and forwarding\n   at the bundle layer for unicast, anycast, and multicast\
    \ messages.\n   Because nodes in a DTN network might be interconnected using more\n\
    \   than one type of underlying network technology, a DTN network is best\n  \
    \ described abstractly using a *multigraph* (a graph where vertices may\n   be\
    \ interconnected with more than one edge).  Edges in this graph are,\n   in general,\
    \ time-varying with respect to their delay and capacity and\n   directional because\
    \ of the possibility of one-way connectivity.  When\n   an edge has zero capacity,\
    \ it is considered to not be connected.\n   Because edges in a DTN graph may have\
    \ significant delay, it is\n   important to distinguish where time is measured\
    \ when expressing an\n   edge's capacity or delay.  We adopt the convention of\
    \ expressing\n   capacity and delay as functions of time where time is measured\
    \ at the\n   point where data is inserted into a network edge.  For example,\n\
    \   consider an edge having capacity C(t) and delay D(t) at time t.  If B\n  \
    \ bits are placed in this edge at time t, they completely arrive by\n   time t\
    \ + D(t) + (1/C(t))*B.  We assume C(t) and D(t) do not change\n   significantly\
    \ during the interval [t, t+D(t)+(1/C(t))*B].\n   Because edges may vary between\
    \ positive and zero capacity, it is\n   possible to describe a period of time\
    \ (interval) during which the\n   capacity is strictly positive, and the delay\
    \ and capacity can be\n   considered to be constant [AF03].  This period of time\
    \ is called a\n   \"contact\".  In addition, the product of the capacity and the\
    \ interval\n   is known as a contact's \"volume\".  If contacts and their volumes\
    \ are\n   known ahead of time, intelligent routing and forwarding decisions can\n\
    \   be made (optimally for small networks) [JFP04].  Optimally using a\n   contact's\
    \ volume, however, requires the ability to divide large ADUs\n   and bundles into\
    \ smaller routable units.  This is provided by DTN\n   fragmentation (see Section\
    \ 3.9).\n   When delivery paths through a DTN graph are lossy or contact\n   intervals\
    \ and volumes are not known precisely ahead of time, routing\n   computations\
    \ become especially challenging.  How to handle these\n   situations is an active\
    \ area of work in the (emerging) research area\n   of delay tolerant networking.\n"
- title: 3.8.1.  Types of Contacts
  contents:
  - "3.8.1.  Types of Contacts\n   Contacts typically fall into one of several categories,\
    \ based largely\n   on the predictability of their performance characteristics\
    \ and\n   whether some action is required to bring them into existence.  To\n\
    \   date, the following major types of contacts have been defined:\n   Persistent\
    \ Contacts\n      Persistent contacts are always available (i.e., no connection-\n\
    \      initiation action is required to instantiate a persistent\n      contact).\
    \  An 'always-on' Internet connection such as a DSL or\n      Cable Modem connection\
    \ would be a representative of this class.\n   On-Demand Contacts\n      On-Demand\
    \ contacts require some action in order to instantiate,\n      but then function\
    \ as persistent contacts until terminated.  A\n      dial-up connection is an\
    \ example of an On-Demand contact (at\n      least, from the viewpoint of the\
    \ dialer; it may be viewed as an\n      Opportunistic Contact, below, from the\
    \ viewpoint of the dial-up\n      service provider).\n   Intermittent - Scheduled\
    \ Contacts\n      A scheduled contact is an agreement to establish a contact at\
    \ a\n      particular time, for a particular duration.  An example of a\n    \
    \  scheduled contact is a link with a low-earth orbiting satellite.\n      A node's\
    \ list of contacts with the satellite can be constructed\n      from the satellite's\
    \ schedule of view times, capacities, and\n      latencies.  Note that for networks\
    \ with substantial delays, the\n      notion of the \"particular time\" is delay-dependent.\
    \  For example,\n      a single scheduled contact between Earth and Mars would\
    \ not be at\n      the same instant in each location, but would instead be offset\
    \ by\n      the (non-negligible) propagation delay.\n   Intermittent - Opportunistic\
    \ Contacts\n      Opportunistic contacts are not scheduled, but rather present\n\
    \      themselves unexpectedly.  For example, an unscheduled aircraft\n      flying\
    \ overhead and beaconing, advertising its availability for\n      communication,\
    \ would present an opportunistic contact.  Another\n      type of opportunistic\
    \ contact might be via an infrared or\n      Bluetooth communication link between\
    \ a personal digital assistant\n      (PDA) and a kiosk in an airport concourse.\
    \  The opportunistic\n      contact begins as the PDA is brought near the kiosk,\
    \ lasting an\n      undetermined amount of time (i.e., until the link is lost\
    \ or\n      terminated).\n   Intermittent - Predicted Contacts\n      Predicted\
    \ contacts are based on no fixed schedule, but rather are\n      predictions of\
    \ likely contact times and durations based on a\n      history of previously observed\
    \ contacts or some other information.\n      Given a great enough confidence in\
    \ a predicted contact, routes may\n      be chosen based on this information.\
    \  This is an active research\n      area, and a few approaches having been proposed\
    \ [LFC05].\n"
- title: 3.9.  Fragmentation and Reassembly
  contents:
  - "3.9.  Fragmentation and Reassembly\n   DTN fragmentation and reassembly are designed\
    \ to improve the\n   efficiency of bundle transfers by ensuring that contact volumes\
    \ are\n   fully utilized and by avoiding retransmission of partially-forwarded\n\
    \   bundles.  There are two forms of DTN fragmentation/reassembly:\n   Proactive\
    \ Fragmentation\n      A DTN node may divide a block of application data into\
    \ multiple\n      smaller blocks and transmit each such block as an independent\n\
    \      bundle.  In this case, the *final destination(s)* are responsible\n   \
    \   for extracting the smaller blocks from incoming bundles and\n      reassembling\
    \ them into the original larger bundle and, ultimately,\n      ADU.  This approach\
    \ is called proactive fragmentation because it\n      is used primarily when contact\
    \ volumes are known (or predicted) in\n      advance.\n   Reactive Fragmentation\n\
    \      DTN nodes sharing an edge in the DTN graph may fragment a bundle\n    \
    \  cooperatively when a bundle is only partially transferred.  In\n      this\
    \ case, the receiving bundle layer modifies the incoming bundle\n      to indicate\
    \ it is a fragment, and forwards it normally.  The\n      previous- hop sender\
    \ may learn (via convergence-layer protocols,\n      see Section 6) that only\
    \ a portion of the bundle was delivered to\n      the next hop, and send the remaining\
    \ portion(s) when subsequent\n      contacts become available (possibly to different\
    \ next-hops if\n      routing changes).  This is called reactive fragmentation\
    \ because\n      the fragmentation process occurs after an attempted transmission\n\
    \      has taken place.\n      As an example, consider a ground station G, and\
    \ two store-and-\n      forward satellites S1 and S2, in opposite low-earth orbit.\
    \  While\n      G is transmitting a large bundle to S1, a reliable transport layer\n\
    \      protocol below the bundle layer at each indicates the transmission\n  \
    \    has terminated, but that half the transfer has completed\n      successfully.\
    \  In this case, G can form a smaller bundle fragment\n      consisting of the\
    \ second half of the original bundle and forward\n      it to S2 when available.\
    \  In addition, S1 (now out of range of G)\n      can form a new bundle consisting\
    \ of the first half of the original\n      bundle and forward it to whatever next\
    \ hop(s) it deems\n      appropriate.\n   The reactive fragmentation capability\
    \ is not required to be available\n   in every DTN implementation, as it requires\
    \ a certain level of\n   support from underlying protocols that may not be present,\
    \ and\n   presents significant challenges with respect to handling digital\n \
    \  signatures and authentication codes on messages.  When a signed\n   message\
    \ is only partially received, most message authentication codes\n   will fail.\
    \  When DTN security is present and enabled, it may\n   therefore be necessary\
    \ to proactively fragment large bundles into\n   smaller units that are more convenient\
    \ for digital signatures.\n   Even if reactive fragmentation is not present in\
    \ an implementation,\n   the ability to reassemble fragments at a destination\
    \ is required in\n   order to support DTN fragmentation.  Furthermore, for contacts\
    \ with\n   volumes that are small compared to typical bundle sizes, some\n   incremental\
    \ delivery approach must be used (e.g., checkpoint/restart)\n   to prevent data\
    \ delivery livelock.  Reactive fragmentation is one\n   such approach, but other\
    \ protocol layers could potentially handle\n   this issue as well.\n"
- title: 3.10.  Reliability and Custody Transfer
  contents:
  - "3.10.  Reliability and Custody Transfer\n   The most basic service provided by\
    \ the bundle layer is\n   unacknowledged, prioritized (but not guaranteed) unicast\
    \ message\n   delivery.  It also provides two options for enhancing delivery\n\
    \   reliability:  end-to-end acknowledgments and custody transfer.\n   Applications\
    \ wishing to implement their own end-to-end message\n   reliability mechanisms\
    \ are free to utilize the acknowledgment.  The\n   custody transfer feature of\
    \ the DTN architecture only specifies a\n   coarse-grained retransmission capability,\
    \ described next.\n   Transmission of bundles with the Custody Transfer Requested\
    \ option\n   specified generally involves moving the responsibility for reliable\n\
    \   delivery of an ADU's bundles among different DTN nodes in the\n   network.\
    \  For unicast delivery, this will typically involve moving\n   bundles \"closer\"\
    \ (in terms of some routing metric) to their ultimate\n   destination(s), and\
    \ retransmitting when necessary.  The nodes\n   receiving these bundles along\
    \ the way (and agreeing to accept the\n   reliable delivery responsibility) are\
    \ called \"custodians\".  The\n   movement of a bundle (and its delivery responsibility)\
    \ from one node\n   to another is called a \"custody transfer\".  It is analogous\
    \ to a\n   database commit transaction [FHM03].  The exact meaning and design\
    \ of\n   custody transfer for multicast and anycast delivery remains to be\n \
    \  fully explored.\n   Custody transfer allows the source to delegate retransmission\n\
    \   responsibility and recover its retransmission-related resources\n   relatively\
    \ soon after sending a bundle (on the order of the minimum\n   round-trip time\
    \ to the first bundle hop(s)).  Not all nodes in a DTN\n   are required by the\
    \ DTN architecture to accept custody transfers, so\n   it is not a true 'hop-by-hop'\
    \ mechanism.  For example, some nodes may\n   have sufficient storage resources\
    \ to sometimes act as custodians, but\n   may elect to not offer such services\
    \ when congested or running low on\n   power.\n   The existence of custodians\
    \ can alter the way DTN routing is\n   performed.  In some circumstances, it may\
    \ be beneficial to move a\n   bundle to a custodian as quickly as possible even\
    \ if the custodian is\n   further away (in terms of distance, time or some routing\
    \ metric) from\n   the bundle's final destination(s) than some other reachable\
    \ node.\n   Designing a system with this capability involves constructing more\n\
    \   than one routing graph, and is an area of continued research.\n   Custody\
    \ transfer in DTN not only provides a method for tracking\n   bundles that require\
    \ special handling and identifying DTN nodes that\n   participate in custody transfer,\
    \ it also provides a (weak) mechanism\n   for enhancing the reliability of message\
    \ delivery.  Generally\n   speaking, custody transfer relies on underlying reliable\
    \ delivery\n   protocols of the networks that it operates over to provide the\n\
    \   primary means of reliable transfer from one bundle node to the next\n   (set).\
    \  However, when custody transfer is requested, the bundle layer\n   provides\
    \ an additional coarse-grained timeout and retransmission\n   mechanism and an\
    \ accompanying (bundle-layer) custodian-to-custodian\n   acknowledgment signaling\
    \ mechanism.  When an application does *not*\n   request custody transfer, this\
    \ bundle layer timeout and\n   retransmission mechanism is typically not employed,\
    \ and successful\n   bundle layer delivery depends solely on the reliability mechanisms\
    \ of\n   the underlying protocols.\n   When a node accepts custody for a bundle\
    \ that contains the Custody\n   Transfer Requested option, a Custody Transfer\
    \ Accepted Signal is sent\n   by the bundle layer to the Current Custodian EID\
    \ contained in the\n   primary bundle block.  In addition, the Current Custodian\
    \ EID is\n   updated to contain one of the forwarding node's (unicast) EIDs before\n\
    \   the bundle is forwarded.\n   When an application requests an ADU to be delivered\
    \ with custody\n   transfer, the request is advisory.  In some circumstances,\
    \ a source\n   of a bundle for which custody transfer has been requested may not\
    \ be\n   able to provide this service.  In such circumstances, the subject\n \
    \  bundle may traverse multiple DTN nodes before it obtains a custodian.\n   Bundles\
    \ in this condition are specially marked with their Current\n   Custodian EID\
    \ field set to a null endpoint.  In cases where\n   applications wish to require\
    \ the source to take custody of the\n   bundle, they may supply the Source Node\
    \ Custody Acceptance Required\n   delivery option.  This may be useful to applications\
    \ that desire a\n   continuous \"chain\" of custody or that wish to exit after\
    \ being\n   ensured their data is safely held in a custodian.\n   In a DTN network\
    \ where one or more custodian-to-custodian hops are\n   strictly one directional\
    \ (and cannot be reversed), the DTN custody\n   transfer mechanism will be affected\
    \ over such hops due to the lack of\n   any way to receive a custody signal (or\
    \ any other information) back\n   across the path, resulting in the expiration\
    \ of the bundle at the\n   ingress to the one-way hop.  This situation does not\
    \ necessarily mean\n   the bundle has been lost; nodes on the other side of the\
    \ hop may\n   continue to transfer custody, and the bundle may be delivered\n\
    \   successfully to its destination(s).  However, in this circumstance a\n   source\
    \ that has requested to receive expiration BSRs for this bundle\n   will receive\
    \ an expiration report for the bundle, and possibly\n   conclude (incorrectly)\
    \ that the bundle has been discarded and not\n   delivered.  Although this problem\
    \ cannot be fully solved in this\n   situation, a mechanism is provided to help\
    \ ameliorate the seemingly\n   incorrect information that may be reported when\
    \ the bundle expires\n   after having been transferred over a one-way hop.  This\
    \ is\n   accomplished by the node at the ingress to the one-way hop reporting\n\
    \   the existence of a known one-way path using a variant of a bundle\n   status\
    \ report.  These types of reports are provided if the subject\n   bundle requests\
    \ the report using the 'Report When Bundle Forwarded'\n   delivery option.\n"
- title: 3.11.  DTN Support for Proxies and Application Layer Gateways
  contents:
  - "3.11.  DTN Support for Proxies and Application Layer Gateways\n   One of the\
    \ aims of DTN is to provide a common method for\n   interconnecting application\
    \ layer gateways and proxies.  In cases\n   where existing Internet applications\
    \ can be made to tolerate delays,\n   local proxies can be constructed to benefit\
    \ from the existing\n   communication capabilities provided by DTN [S05, T02].\
    \  Making such\n   proxies compatible with DTN reduces the burden on the proxy\
    \ author\n   from being concerned with how to implement routing and reliability\n\
    \   management and allows existing TCP/IP-based applications to operate\n   unmodified\
    \ over a DTN-based network.\n   When DTN is used to provide a form of tunnel encapsulation\
    \ for other\n   protocols, it can be used in constructing overlay networks comprised\n\
    \   of application layer gateways.  The application acknowledgment\n   capability\
    \ is designed for such circumstances.  This provides a\n   common way for remote\
    \ application layer gateways to signal the\n   success or failure of non-DTN protocol\
    \ operations initiated as a\n   result of receiving DTN ADUs.  Without this capability,\
    \ such\n   indicators would have to be implemented by applications themselves\
    \ in\n   non-standard ways.\n"
- title: 3.12.  Timestamps and Time Synchronization
  contents:
  - "3.12.  Timestamps and Time Synchronization\n   The DTN architecture depends on\
    \ time synchronization among DTN nodes\n   (supported by external, non-DTN protocols)\
    \ for four primary purposes:\n   bundle and fragment identification, routing with\
    \ scheduled or\n   predicted contacts, bundle expiration time computations, and\n\
    \   application registration expiration.\n   Bundle identification and expiration\
    \ are supported by placing a\n   creation timestamp and an explicit expiration\
    \ field (expressed in\n   seconds after the source timestamp) in each bundle.\
    \  The origination\n   timestamps on arriving bundles are made available to consuming\n\
    \   applications in ADUs they receive by some system interface function.\n   Each\
    \ set of bundles corresponding to an ADU is required to contain a\n   timestamp\
    \ unique to the sender's EID.  The EID, timestamp, and data\n   offset/length\
    \ information together uniquely identify a bundle.\n   Unique bundle identification\
    \ is used for a number of purposes,\n   including custody transfer and reassembly\
    \ of bundle fragments.\n   Time is also used in conjunction with application registrations.\n\
    \   When an application expresses its desire to receive ADUs destined for\n  \
    \ a particular EID, this registration is only maintained for a finite\n   period\
    \ of time, and may be specified by the application.  For\n   multicast registrations,\
    \ an application may also specify a time range\n   or \"interest interval\" for\
    \ its registration.  In this case, traffic\n   sent to the specified EID any time\
    \ during the specified interval will\n   eventually be delivered to the application\
    \ (unless such traffic has\n   expired due to the expiration time provided by\
    \ the application at the\n   source or some other reason prevents such delivery).\n"
- title: 3.13.  Congestion and Flow Control at the Bundle Layer
  contents:
  - "3.13.  Congestion and Flow Control at the Bundle Layer\n   The subject of congestion\
    \ control and flow control at the bundle\n   layer is one on which the authors\
    \ of this document have not yet\n   reached complete consensus.  We have unresolved\
    \ concerns about the\n   efficiency and efficacy of congestion and flow control\
    \ schemes\n   implemented across long and/or highly variable delay environments,\n\
    \   especially with the custody transfer mechanism that may require nodes\n  \
    \ to retain bundles for long periods of time.\n   For the purposes of this document,\
    \ we define \"flow control\" as a\n   means of assuring that the average rate\
    \ at which a sending node\n   transmits data to a receiving node does not exceed\
    \ the average rate\n   at which the receiving node is prepared to receive data\
    \ from that\n   sender. (Note that this is a generalized notion of flow control,\n\
    \   rather than one that applies only to end-to-end communication.)  We\n   define\
    \ \"congestion control\" as a means of assuring that the aggregate\n   rate at\
    \ which all traffic sources inject data into a network does not\n   exceed the\
    \ maximum aggregate rate at which the network can deliver\n   data to destination\
    \ nodes over time.  If flow control is propagated\n   backward from congested\
    \ nodes toward traffic sources, then the flow\n   control mechanism can be used\
    \ as at least a partial solution to the\n   problem of congestion as well.\n \
    \  DTN flow control decisions must be made within the bundle layer\n   itself\
    \ based on information about resources (in this case, primarily\n   persistent\
    \ storage) available within the bundle node.  When storage\n   resources become\
    \ scarce, a DTN node has only a certain degree of\n   freedom in handling the\
    \ situation.  It can always discard bundles\n   which have expired -- an activity\
    \ DTN nodes should perform regularly\n   in any case.  If it ordinarily is willing\
    \ to accept custody for\n   bundles, it can cease doing so.  If storage resources\
    \ are available\n   elsewhere in the network, it may be able to make use of them\
    \ in some\n   way for bundle storage.  It can also discard bundles which have\
    \ not\n   expired but for which it has not accepted custody.  A node must avoid\n\
    \   discarding bundles for which it has accepted custody, and do so only\n   as\
    \ a last resort.  Determining when a node should engage in or cease\n   to engage\
    \ in custody transfers is a resource allocation and\n   scheduling problem of\
    \ current research interest.\n   In addition to the bundle layer mechanisms described\
    \ above, a DTN\n   node may be able to avail itself of support from lower-layer\n\
    \   protocols in affecting its own resource utilization.  For example, a\n   DTN\
    \ node receiving a bundle using TCP/IP might intentionally slow\n   down its receiving\
    \ rate by performing read operations less frequently\n   in order to reduce its\
    \ offered load.  This is possible because TCP\n   provides its own flow control,\
    \ so reducing the application data\n   consumption rate could effectively implement\
    \ a form of hop-by-hop\n   flow control.  Unfortunately, it may also lead to head-of-line\n\
    \   blocking issues, depending on the nature of bundle multiplexing\n   within\
    \ a TCP connection.  A protocol with more relaxed ordering\n   constraints (e.g.\
    \ SCTP [RFC2960]) might be preferable in such\n   circumstances.\n   Congestion\
    \ control is an ongoing research topic.\n"
- title: 3.14.  Security
  contents:
  - "3.14.  Security\n   The possibility of severe resource scarcity in some delay-tolerant\n\
    \   networks dictates that some form of authentication and access control\n  \
    \ to the network itself is required in many circumstances.  It is not\n   acceptable\
    \ for an unauthorized user to flood the network with traffic\n   easily, possibly\
    \ denying service to authorized users.  In many cases\n   it is also not acceptable\
    \ for unauthorized traffic to be forwarded\n   over certain network links at all.\
    \  This is especially true for\n   exotic, mission-critical links.  In light of\
    \ these considerations,\n   several goals are established for the security component\
    \ of the DTN\n   architecture:\n   - Promptly prevent unauthorized applications\
    \ from having their data\n     carried through or stored in the DTN.\n   - Prevent\
    \ unauthorized applications from asserting control over the\n     DTN infrastructure.\n\
    \   - Prevent otherwise authorized applications from sending bundles at a\n  \
    \   rate or class of service for which they lack permission.\n   - Promptly discard\
    \ bundles that are damaged or improperly modified in\n     transit.\n   - Promptly\
    \ detect and de-authorize compromised entities.\n   Many existing authentication\
    \ and access control protocols designed\n   for operation in low-delay, connected\
    \ environments may not perform\n   well in DTNs.  In particular, updating access\
    \ control lists and\n   revoking (\"blacklisting\") credentials may be especially\
    \ difficult.\n   Also, approaches that require frequent access to centralized\
    \ servers\n   to complete an authentication or authorization transaction are not\n\
    \   attractive.  The consequences of these difficulties include delays in\n  \
    \ the onset of communication, delays in detecting and recovering from\n   system\
    \ compromise, and delays in completing transactions due to\n   inappropriate access\
    \ control or authentication settings.\n   To help satisfy these security requirements\
    \ in light of the\n   challenges, the DTN architecture adopts a standard but optionally\n\
    \   deployed security architecture [DTNSEC] that utilizes hop-by-hop and\n   end-to-end\
    \ authentication and integrity mechanisms.  The purpose of\n   using both approaches\
    \ is to be able to handle access control for data\n   forwarding and storage separately\
    \ from application-layer data\n   integrity.  While the end-to-end mechanism provides\
    \ authentication\n   for a principal such as a user (of which there may be many),\
    \ the hop-\n   by-hop mechanism is intended to authenticate DTN nodes as legitimate\n\
    \   transceivers of bundles to each-other.  Note that it is conceivable\n   to\
    \ construct a DTN in which only a subset of the nodes participate in\n   the security\
    \ mechanisms, resulting in a secure DTN overlay existing\n   atop an insecure\
    \ DTN overlay.  This idea is relatively new and is\n   still being explored.\n\
    \   In accordance with the goals listed above, DTN nodes discard traffic\n   as\
    \ early as possible if authentication or access control checks fail.\n   This\
    \ approach meets the goals of removing unwanted traffic from being\n   forwarded\
    \ over specific high-value links, but also has the associated\n   benefit of making\
    \ denial-of-service attacks considerably harder to\n   mount more generally, as\
    \ compared with conventional Internet routers.\n   However, the obvious cost for\
    \ this capability is potentially larger\n   computation and credential storage\
    \ overhead required at DTN nodes.\n   For more detailed information on DTN security\
    \ provisions, refer to\n   [DTNSEC] and [DTNSOV].\n"
- title: 4.  State Management Considerations
  contents:
  - "4.  State Management Considerations\n   An important aspect of any networking\
    \ architecture is its management\n   of state.  This section describes the state\
    \ managed at the bundle\n   layer and discusses how it is established and removed.\n"
- title: 4.1.  Application Registration State
  contents:
  - "4.1.  Application Registration State\n   In long/variable delay environments,\
    \ an asynchronous application\n   interface seems most appropriate.  Such interfaces\
    \ typically include\n   methods for applications to register callback actions\
    \ when certain\n   triggering events occur (e.g., when ADUs arrive).  These\n\
    \   registrations create state information called application\n   registration\
    \ state.\n   Application registration state is typically created by explicit\n\
    \   request of the application, and is removed by a separate explicit\n   request,\
    \ but may also be removed by an application-specified timer\n   (it is thus \"\
    firm\" state).  In most cases, there must be a provision\n   for retaining this\
    \ state across application and operating system\n   termination/restart conditions\
    \ because a client/server bundle round-\n   trip time may exceed the requesting\
    \ application's execution time (or\n   hosting system's uptime).  In cases where\
    \ applications are not\n   automatically restarted but application registration\
    \ state remains\n   persistent, a method must be provided to indicate to the system\
    \ what\n   action to perform when the triggering event occurs (e.g., restarting\n\
    \   some application, ignoring the event, etc.).\n   To initiate a registration\
    \ and thereby establish application\n   registration state, an application specifies\
    \ an Endpoint ID for which\n   it wishes to receive ADUs, along with an optional\
    \ time value\n   indicating how long the registration should remain active.  This\n\
    \   operation is somewhat analogous to the bind() operation in the common\n  \
    \ sockets API.\n   For registrations to groups (i.e., joins), a time interval\
    \ may also\n   be specified.  The time interval refers to the range of origination\n\
    \   times of ADUs sent to the specified EID.  See Section 3.4 above for\n   more\
    \ details.\n"
- title: 4.2.  Custody Transfer State
  contents:
  - "4.2.  Custody Transfer State\n   Custody transfer state includes information\
    \ required to keep account\n   of bundles for which a node has taken custody,\
    \ as well as the\n   protocol state related to transferring custody for one or\
    \ more of\n   them.  The accounting-related state is created when a bundle is\n\
    \   received.  Custody transfer retransmission state is created when a\n   transfer\
    \ of custody is initiated by forwarding a bundle with the\n   custody transfer\
    \ requested delivery option specified.  Retransmission\n   state and accounting\
    \ state may be released upon receipt of one or\n   more Custody Transfer Succeeded\
    \ signals, indicating custody has been\n   moved.  In addition, the bundle's expiration\
    \ time (possibly mitigated\n   by local policy) provides an upper bound on the\
    \ time when this state\n   is purged from the system in the event that it is not\
    \ purged\n   explicitly due to receipt of a signal.\n"
- title: 4.3.  Bundle Routing and Forwarding State
  contents:
  - "4.3.  Bundle Routing and Forwarding State\n   As with the Internet architecture,\
    \ we distinguish between routing and\n   forwarding.  Routing refers to the execution\
    \ of a (possibly\n   distributed) algorithm for computing routing paths according\
    \ to some\n   objective function (see [JFP04], for example).  Forwarding refers\
    \ to\n   the act of moving a bundle from one DTN node to another.  Routing\n \
    \  makes use of routing state (the RIB, or routing information base),\n   while\
    \ forwarding makes use of state derived from routing, and is\n   maintained as\
    \ forwarding state (the FIB, or forwarding information\n   base).  The structure\
    \ of the FIB and the rules for maintaining it are\n   implementation choices.\
    \  In some DTNs, exchange of information used\n   to update state in the RIB may\
    \ take place on network paths distinct\n   from those where exchange of application\
    \ data takes place.\n   The maintenance of state in the RIB is dependent on the\
    \ type of\n   routing algorithm being used.  A routing algorithm may consider\n\
    \   requested class of service and the location of potential custodians\n   (for\
    \ custody transfer, see section 3.10), and this information will\n   tend to increase\
    \ the size of the RIB.  The separation between FIB and\n   RIB is not required\
    \ by this document, as these are implementation\n   details to be decided by system\
    \ implementers.  The choice of routing\n   algorithms is still under study.\n\
    \   Bundles may occupy queues in nodes for a considerable amount of time.\n  \
    \ For unicast or anycast delivery, the amount of time is likely to be\n   the\
    \ interval between when a bundle arrives at a node and when it can\n   be forwarded\
    \ to its next hop.  For multicast delivery of bundles,\n   this could be significantly\
    \ longer, up to a bundle's expiration time.\n   This situation occurs when multicast\
    \ delivery is utilized in such a\n   way that nodes joining a group can obtain\
    \ information previously sent\n   to the group.  In such cases, some nodes may\
    \ act as \"archivers\" that\n   provide copies of bundles to new participants\
    \ that have already been\n   delivered to other participants.\n"
- title: 4.4.  Security-Related State
  contents:
  - "4.4.  Security-Related State\n   The DTN security approach described in [DTNSEC],\
    \ when used, requires\n   maintenance of state in all DTN nodes that use it. \
    \ All such nodes\n   are required to store their own private information (including\
    \ their\n   own policy and authentication material) and a block of information\n\
    \   used to verify credentials.  Furthermore, in most cases, DTN nodes\n   will\
    \ cache some public information (and possibly the credentials) of\n   their next-hop\
    \ (bundle) neighbors.  All cached information has\n   expiration times, and nodes\
    \ are responsible for acquiring and\n   distributing updates of public information\
    \ and credentials prior to\n   the expiration of the old set (in order to avoid\
    \ a disruption in\n   network service).\n   In addition to basic end-to-end and\
    \ hop-by-hop authentication, access\n   control may be used in a DTN by one or\
    \ more mechanisms such as\n   capabilities or access control lists (ACLs).  ACLs\
    \ would represent\n   another block of state present in any node that wishes to\
    \ enforce\n   security policy.  ACLs are typically initialized at node\n   configuration\
    \ time and may be updated dynamically by DTN bundles or\n   by some out of band\
    \ technique.  Capabilities or credentials may be\n   revoked, requiring the maintenance\
    \ of a revocation list (\"black\n   list\", another form of state) to check for\
    \ invalid authentication\n   material that has already been distributed.\n   Some\
    \ DTNs may implement security boundaries enforced by selected\n   nodes in the\
    \ network, where end-to-end credentials may be checked in\n   addition to checking\
    \ the hop-by-hop credentials.  (Doing so may\n   require routing to be adjusted\
    \ to ensure all bundles comprising each\n   ADU pass through these points.)  Public\
    \ information used to verify\n   end-to-end authentication will typically be cached\
    \ at these points.\n"
- title: 4.5.  Policy and Configuration State
  contents:
  - "4.5.  Policy and Configuration State\n   DTN nodes will contain some amount of\
    \ configuration and policy\n   information.  Such information may alter the behavior\
    \ of bundle\n   forwarding.  Examples of policy state include the types of\n \
    \  cryptographic algorithms and access control procedures to use if DTN\n   security\
    \ is employed, whether nodes may become custodians, what types\n   of convergence\
    \ layer (see Section 6) and routing protocols are in\n   use, how bundles of differing\
    \ priorities should be scheduled, where\n   and for how long bundles and other\
    \ data is stored, what status\n   reports may be generated or at what rate, etc.\n"
- title: 5.  Application Structuring Issues
  contents:
  - "5.  Application Structuring Issues\n   DTN bundle delivery is intended to operate\
    \ in a delay-tolerant\n   fashion over a broad range of network types.  This does\
    \ not mean\n   there *must* be large delays in the network; it means there *may*\
    \ be\n   very significant delays (including extended periods of disconnection\n\
    \   between sender and intended recipient(s)).  The DTN protocols are\n   delay\
    \ tolerant, so applications using them must also be delay\n   tolerant in order\
    \ to operate effectively in environments subject to\n   significant delay or disruption.\n\
    \   The communication primitives provided by the DTN architecture are\n   based\
    \ on asynchronous, message-oriented communication which differs\n   from conversational\
    \ request/response communication.  In general,\n   applications should attempt\
    \ to include enough information in an ADU\n   so that it may be treated as an\
    \ independent unit of work by the\n   network and receiver(s).  The goal is to\
    \ minimize synchronous\n   interchanges between applications that are separated\
    \ by a network\n   characterized by long and possibly highly variable delays.\
    \  A single\n   file transfer request message, for example, might include\n  \
    \ authentication information, file location information, and requested\n   file\
    \ operation (thus \"bundling\" this information together).\n   Comparing this\
    \ style of operation to a classic FTP transfer, one sees\n   that the bundled\
    \ model can complete in one round trip, whereas an FTP\n   file \"put\" operation\
    \ can take as many as eight round trips to get to\n   a point where file data\
    \ can flow [DFS02].\n   Delay-tolerant applications must consider additional factors\
    \ beyond\n   the conversational implications of long delay paths.  For example,\
    \ an\n   application may terminate (voluntarily or not) between the time it\n\
    \   sends a message and the time it expects a response.  If this\n   possibility\
    \ has been anticipated, the application can be \"re-\n   instantiated\" with state\
    \ information saved in persistent storage.\n   This is an implementation issue,\
    \ but also an application design\n   consideration.\n   Some consideration of\
    \ delay-tolerant application design can result in\n   applications that work reasonably\
    \ well in low-delay environments, and\n   that do not suffer extraordinarily in\
    \ high or highly-variable delay\n   environments.\n"
- title: 6.  Convergence Layer Considerations for Use of Underlying Protocols
  contents:
  - "6.  Convergence Layer Considerations for Use of Underlying Protocols\n   Implementation\
    \ experience with the DTN architecture has revealed an\n   important architectural\
    \ construct and interface for DTN nodes\n   [DBFJHP04].  Not all underlying protocols\
    \ in different protocol\n   families provide the same exact functionality, so\
    \ some additional\n   adaptation or augmentation on a per-protocol or per-protocol-family\n\
    \   basis may be required.  This adaptation is accomplished by a set of\n   convergence\
    \ layers placed between the bundle layer and underlying\n   protocols.  The convergence\
    \ layers manage the protocol-specific\n   details of interfacing with particular\
    \ underlying protocols and\n   present a consistent interface to the bundle layer.\n\
    \   The complexity of one convergence layer may vary substantially from\n   another,\
    \ depending on the type of underlying protocol it adapts.  For\n   example, a\
    \ TCP/IP convergence layer for use in the Internet might\n   only have to add\
    \ message boundaries to TCP streams, whereas a\n   convergence layer for some\
    \ network where no reliable transport\n   protocol exists might be considerably\
    \ more complex (e.g., it might\n   have to implement reliability, fragmentation,\
    \ flow-control, etc.) if\n   reliable delivery is to be offered to the bundle\
    \ layer.\n   As convergence layers implement protocols above and beyond the basic\n\
    \   bundle protocol specified in [BSPEC], they will be defined in their\n   own\
    \ documents (in a fashion similar to the way encapsulations for IP\n   datagrams\
    \ are specified on a per-underlying-protocol basis, such as\n   in RFC 894 [RFC894]).\n"
- title: 7.  Summary
  contents:
  - "7.  Summary\n   The DTN architecture addresses many of the problems of heterogeneous\n\
    \   networks that must operate in environments subject to long delays and\n  \
    \ discontinuous end-to-end connectivity.  It is based on asynchronous\n   messaging\
    \ and uses postal mail as a model of service classes and\n   delivery semantics.\
    \  It accommodates many different forms of\n   connectivity, including scheduled,\
    \ predicted, and opportunistically\n   connected delivery paths.  It introduces\
    \ a novel approach to end-to-\n   end reliability across frequently partitioned\
    \ and unreliable\n   networks.  It also proposes a model for securing the network\n\
    \   infrastructure against unauthorized access.\n   It is our belief that this\
    \ architecture is applicable to many\n   different types of challenged environments.\n"
- title: 8.  Security Considerations
  contents:
  - "8.  Security Considerations\n   Security is an integral concern for the design\
    \ of the Delay Tolerant\n   Network Architecture, but its use is optional.  Sections\
    \ 3.6.1, 3.14,\n   and 4.4 of this document present some factors to consider for\n\
    \   securing the DTN architecture, but separate documents [DTNSOV] and\n   [DTNSEC]\
    \ define the security architecture in much more detail.\n"
- title: 9.  IANA Considerations
  contents:
  - "9.  IANA Considerations\n   This document specifies the architecture for Delay\
    \ Tolerant\n   Networking, which uses Internet-standard URIs for its Endpoint\n\
    \   Identifiers.  URIs intended for use with DTN should be compliant with\n  \
    \ the guidelines given in [RFC3986].\n"
- title: 10.  Normative References
  contents:
  - "10.  Normative References\n   [RFC3986]   Berners-Lee, T., Fielding, R., and\
    \ L. Masinter, \"Uniform\n               Resource Identifier (URI): Generic Syntax\"\
    , STD 66, RFC\n               3986, January 2005.\n"
- title: 11.  Informative References
  contents:
  - "11.  Informative References\n   [IPN01]     InterPlaNetary Internet Project,\
    \ Internet Society IPN\n               Special Interest Group, http://www.ipnsig.org.\n\
    \   [SB03]      S. Burleigh, et al., \"Delay-Tolerant Networking - An\n      \
    \         Approach to Interplanetary Internet\", IEEE Communications\n       \
    \        Magazine, July 2003.\n   [FW03]      F. Warthman, \"Delay-Tolerant Networks\
    \ (DTNs): A Tutorial\n               v1.1\", Wartham Associates, 2003.  Available\
    \ from\n               http://www.dtnrg.org.\n   [KF03]      K. Fall, \"A Delay-Tolerant\
    \ Network Architecture for\n               Challenged Internets\", Proceedings\
    \ SIGCOMM, Aug 2003.\n   [JFP04]     S. Jain, K. Fall, R. Patra, \"Routing in\
    \ a Delay Tolerant\n               Network\", Proceedings SIGCOMM, Aug/Sep 2004.\n\
    \   [DFS02]     R. Durst, P. Feighery, K. Scott, \"Why not use the\n         \
    \      Standard Internet Suite for the Interplanetary\n               Internet?\"\
    , MITRE White Paper, 2002.  Available from\n               http://www.ipnsig.org/reports/TCP_IP.pdf.\n\
    \   [CK74]      V. Cerf, R. Kahn, \"A  Protocol for Packet Network\n         \
    \      Intercommunication\", IEEE Trans. on Comm., COM-22(5), May\n          \
    \     1974.\n   [IGE00]     C. Intanagonwiwat, R. Govindan, D. Estrin, \"Directed\n\
    \               Diffusion: A Scalable and Robust Communication Paradigm\n    \
    \           for Sensor Networks\", Proceedings MobiCOM, Aug 2000.\n   [WSBL99]\
    \    W. Adjie-Winoto, E. Schwartz, H. Balakrishnan, J. Lilley,\n             \
    \  \"The Design and Implementation of an Intentional Naming\n               System\"\
    , Proc. 17th ACM SOSP, Kiawah Island, SC, Dec.\n               1999.\n   [CT90]\
    \      D. Clark, D. Tennenhouse, \"Architectural Considerations\n            \
    \   for a New Generation of Protocols\", Proceedings SIGCOMM,\n              \
    \ 1990.\n   [ISCHEMES]  IANA, Uniform Resource Identifer (URI) Schemes,\n    \
    \           http://www.iana.org/assignments/uri-schemes.html.\n   [JDPF05]   \
    \ S. Jain, M. Demmer, R. Patra, K. Fall, \"Using Redundancy\n               to\
    \ Cope with Failures in a Delay Tolerant Network\",\n               Proceedings\
    \ SIGCOMM, 2005.\n   [WJMF05]    Y. Wang, S. Jain, M. Martonosi, K. Fall, \"Erasure\
    \ Coding\n               Based Routing in Opportunistic Networks\", Proceedings\n\
    \               SIGCOMM Workshop on Delay Tolerant Networks, 2005.\n   [ZAZ05]\
    \     W. Zhao, M. Ammar, E. Zegura, \"Multicast in Delay\n               Tolerant\
    \ Networks\", Proceedings SIGCOMM Workshop on Delay\n               Tolerant Networks,\
    \ 2005.\n   [LFC05]     J. Leguay, T. Friedman, V. Conan, \"DTN Routing in a\n\
    \               Mobility Pattern Space\", Proceedings SIGCOMM Workshop on\n  \
    \             Delay Tolerant Networks, 2005.\n   [AF03]      J. Alonso, K. Fall,\
    \ \"A Linear Programming Formulation of\n               Flows over Time with Piecewise\
    \ Constant Capacity and\n               Transit Times\", Intel Research Technical\
    \ Report IRB-TR-\n               03-007, June 2003.\n   [FHM03]     K. Fall, W.\
    \ Hong, S. Madden, \"Custody Transfer for\n               Reliable Delivery in\
    \ Delay Tolerant Networks\", Intel\n               Research Technical Report IRB-TR-03-030,\
    \ July 2003.\n   [BSPEC]     K. Scott, S. Burleigh, \"Bundle Protocol Specification\"\
    ,\n               Work in Progress, December 2006.\n   [DTNSEC]    S. Symington,\
    \ S. Farrell, H. Weiss, \"Bundle Security\n               Protocol Specification\"\
    , Work in Progress, October 2006.\n   [DTNSOV]    S. Farrell, S. Symington, H.\
    \ Weiss, \"Delay-Tolerant\n               Networking Security Overview\", Work\
    \ in Progress, October\n               2006.\n   [DBFJHP04]  M. Demmer, E. Brewer,\
    \ K. Fall, S. Jain, M. Ho, R. Patra,\n               \"Implementing Delay Tolerant\
    \ Networking\", Intel Research\n               Technical Report IRB-TR-04-020,\
    \ Dec. 2004.\n   [RFC792]    Postel, J., \"Internet Control Message Protocol\"\
    , STD 5,\n               RFC 792, September 1981.\n   [RFC894]    Hornig, C.,\
    \ \"A Standard for the Transmission of IP\n               Datagrams over Ethernet\
    \ Networks\", STD 41, RFC 894, April\n               1 1984.\n   [RFC2960]   Stewart,\
    \ R., Xie, Q., Morneault, K., Sharp, C.,\n               Schwarzbauer, H., Taylor,\
    \ T., Rytina, I., Kalla, M.,\n               Zhang, L., and V. Paxson, \"Stream\
    \ Control Transmission\n               Protocol\", RFC 2960, October 2000.\n \
    \  [RFC4088]   Black, D., McCloghrie, K., and J. Schoenwaelder, \"Uniform\n  \
    \             Resource Identifier (URI) Scheme for the Simple Network\n      \
    \         Management Protocol (SNMP)\", RFC 4088, June 2005.\n   [S05]       K.\
    \ Scott, \"Disruption Tolerant Networking Proxies for\n               On-the-Move\
    \ Tactical Networks\", Proc. MILCOM 2005\n               (unclassified track),\
    \ Oct. 2005.\n   [T02]       W. Thies, et al., \"Searching the World Wide Web\
    \ in Low-\n               Connectivity Communities\", Proc. WWW Conference (Global\n\
    \               Community track), May 2002.\n"
- title: 12.  Acknowledgments
  contents:
  - "12.  Acknowledgments\n   John Wroclawski, David Mills, Greg Miller, James P.\
    \ G. Sterbenz, Joe\n   Touch, Steven Low, Lloyd Wood, Robert Braden, Deborah Estrin,\
    \ Stephen\n   Farrell, Melissa Ho, Ting Liu, Mike Demmer, Jakob Ericsson, Susan\n\
    \   Symington, Andrei Gurtov, Avri Doria, Tom Henderson, Mark Allman,\n   Michael\
    \ Welzl, and Craig Partridge all contributed useful thoughts\n   and criticisms\
    \ to versions of this document.  We are grateful for\n   their time and participation.\n\
    \   This work was performed in part under DOD Contract DAA-B07-00-CC201,\n   DARPA\
    \ AO H912; JPL Task Plan No. 80-5045, DARPA AO H870; and NASA\n   Contract NAS7-1407.\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Dr. Vinton G. Cerf\n   Google Corporation\n   Suite 384\n\
    \   13800 Coppermine Rd.\n   Herndon, VA 20171\n   Phone: +1 (703) 234-1823\n\
    \   Fax:   +1 (703) 848-0727\n   EMail: vint@google.com\n   Scott C. Burleigh\n\
    \   Jet Propulsion Laboratory\n   4800 Oak Grove Drive\n   M/S: 179-206\n   Pasadena,\
    \ CA 91109-8099\n   Phone: +1 (818) 393-3353\n   Fax:   +1 (818) 354-1075\n  \
    \ EMail: Scott.Burleigh@jpl.nasa.gov\n   Robert C. Durst\n   The MITRE Corporation\n\
    \   7515 Colshire Blvd., M/S H440\n   McLean, VA 22102\n   Phone: +1 (703) 983-7535\n\
    \   Fax:   +1 (703) 983-7142\n   EMail: durst@mitre.org\n   Dr. Kevin Fall\n \
    \  Intel Research, Berkeley\n   2150 Shattuck Ave., #1300\n   Berkeley, CA 94704\n\
    \   Phone: +1 (510) 495-3014\n   Fax:   +1 (510) 495-3049\n   EMail: kfall@intel.com\n\
    \   Adrian J. Hooke\n   Jet Propulsion Laboratory\n   4800 Oak Grove Drive\n \
    \  M/S: 303-400\n   Pasadena, CA 91109-8099\n   Phone: +1 (818) 354-3063\n   Fax:\
    \   +1 (818) 393-3575\n   EMail: Adrian.Hooke@jpl.nasa.gov\n   Dr. Keith L. Scott\n\
    \   The MITRE Corporation\n   7515 Colshire Blvd., M/S H440\n   McLean, VA 22102\n\
    \   Phone: +1 (703) 983-6547\n   Fax:   +1 (703) 983-7142\n   EMail: kscott@mitre.org\n\
    \   Leigh Torgerson\n   Jet Propulsion Laboratory\n   4800 Oak Grove Drive\n \
    \  M/S: 238-412\n   Pasadena, CA 91109-8099\n   Phone: +1 (818) 393-0695\n   Fax:\
    \   +1 (818) 354-6825\n   EMail: ltorgerson@jpl.nasa.gov\n   Howard S. Weiss\n\
    \   SPARTA, Inc.\n   7075 Samuel Morse Drive\n   Columbia, MD 21046\n   Phone:\
    \ +1 (410) 872-1515 x201\n   Fax:   +1 (410) 872-8079\n   EMail: howard.weiss@sparta.com\n\
    \   Please refer comments to dtn-interest@mailman.dtnrg.org.  The Delay\n   Tolerant\
    \ Networking Research Group (DTNRG) web site is located at\n   http://www.dtnrg.org.\n"
- title: Full Copyright Statement
  contents:
  - "Full Copyright Statement\n   Copyright (C) The IETF Trust (2007).\n   This document\
    \ is subject to the rights, licenses and restrictions\n   contained in BCP 78,\
    \ and except as set forth therein, the authors\n   retain all their rights.\n\
    \   This document and the information contained herein are provided on an\n  \
    \ \"AS IS\" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS\n  \
    \ OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY, THE IETF TRUST AND\n   THE\
    \ INTERNET ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS\n   OR IMPLIED,\
    \ INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF\n   THE INFORMATION\
    \ HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED\n   WARRANTIES OF MERCHANTABILITY\
    \ OR FITNESS FOR A PARTICULAR PURPOSE.\n"
- title: Intellectual Property
  contents:
  - "Intellectual Property\n   The IETF takes no position regarding the validity or\
    \ scope of any\n   Intellectual Property Rights or other rights that might be\
    \ claimed to\n   pertain to the implementation or use of the technology described\
    \ in\n   this document or the extent to which any license under such rights\n\
    \   might or might not be available; nor does it represent that it has\n   made\
    \ any independent effort to identify any such rights.  Information\n   on the\
    \ procedures with respect to rights in RFC documents can be\n   found in BCP 78\
    \ and BCP 79.\n   Copies of IPR disclosures made to the IETF Secretariat and any\n\
    \   assurances of licenses to be made available, or the result of an\n   attempt\
    \ made to obtain a general license or permission for the use of\n   such proprietary\
    \ rights by implementers or users of this\n   specification can be obtained from\
    \ the IETF on-line IPR repository at\n   http://www.ietf.org/ipr.\n   The IETF\
    \ invites any interested party to bring to its attention any\n   copyrights, patents\
    \ or patent applications, or other proprietary\n   rights that may cover technology\
    \ that may be required to implement\n   this standard.  Please address the information\
    \ to the IETF at\n   ietf-ipr@ietf.org.\n"
- title: Acknowledgement
  contents:
  - "Acknowledgement\n   Funding for the RFC Editor function is currently provided\
    \ by the\n   Internet Society.\n"
