Abstract This specification defines a lossless compressed data format that compresses data using a combination of the LZ77 algorithm and Huffman coding, with efficiency comparable to the best currently available general purpose compression methods.
can be produced or consumed, even for an arbitrarily long, sequentially presented input data stream, using only an a priori bounded amount of intermediate storage; hence, it can be used in data communications or similar structures, such as Unix filters.
compresses data with a compression ratio comparable to the best currently available general purpose compression methods, in particular, considerably better than the gzip program.
decompresses much faster than current LZMA implementations.
compress specialized data (e.g., raster graphics) as densely as the best currently available specialized algorithms.
This document is the authoritative specification of the brotli compressed data format.
It defines the set of valid brotli compressed data streams and a decoder algorithm that produces the uncompressed data stream from a valid brotli compressed data stream.
This specification is intended for use by software implementers to compress data into and/or decompress data from the brotli format.
The text of the specification assumes a basic background in programming at the level of bits and other primitive data representations.
Familiarity with the technique of Huffman coding is helpful but not required.
the notations and terminology introduced in the DEFLATE format specification [RFC1951].
For the sake of completeness, we always include the whole text of the relevant parts of RFC 1951; therefore, familiarity with the DEFLATE format is helpful but not required.
The compressed data format defined in this specification is an integral part of the WOFF File Format 2.0 [WOFF2]; therefore, this specification is also intended for implementers of WOFF 2.0 compressors and decompressors.
This document specifies a method for representing a sequence of bytes as a (usually shorter) sequence of bits and a method for packing the latter bit sequence into bytes.
Unless otherwise indicated below, a compliant decompressor must be able to accept and decompress any data set that conforms to all the specifications presented here.
A compliant compressor must produce data sets that conform to all the specifications presented here.
Definitions of Terms and Conventions Used Byte: 8 bits stored or transmitted as a unit (same as an octet).
For this specification, a byte is exactly 8 bits, even on machines that store a character on a number of bits different from eight.
See below for the numbering of bits within a byte.
String: a sequence of arbitrary bytes.
Bytes stored within a computer do not have a "bit order", since they are always treated as a unit.
However, a byte considered as an integer between 0 and 255 does have a most and least significant bit (lsb), and since we write numbers with the most significant digit on the left, we also write bytes with the most significant bit (msb) on the left.
In the diagrams below, we number the bits of a byte so that bit 0 is the least significant bit
Within a computer, a number may occupy multiple bytes.
All multi  byte numbers in the format described here are stored with the least significant byte first (at the lower memory address).
less significant byte   8 1.5.1.
This document does not address the issue of the order in which bits of a byte are transmitted on a bit sequential medium, since the final data format described here is byte rather than bit oriented.
However, we describe the compressed block format below as a sequence of data elements of various bit lengths, not a sequence of bytes.
Data elements other than prefix codes are packed starting with the least significant bit of the data element.
These are referred to here as "integer values" and are considered unsigned.
Prefix codes are packed starting with the most significant bit of the code.
In other words, if one were to print out the compressed data as a sequence of bytes, starting with the first byte at the  right  margin and proceeding to the  left , with the most significant bit of each byte on the left as usual, one would be able to parse the result from right to left, with fixed width elements in the correct msb to lsb order and prefix codes in bit reversed order (i.e., with the first bit of the code in the relative lsb position).
As an example, consider packing the following data elements into a sequence of 3 bytes: 3 bit integer value 6, 4 bit integer value 2, prefix code 110, prefix code 10, 12 bit integer value 3628.
byte 2   byte 1   byte 0    11100010 11000101 10010110
A compressed data set consists of a header and a series of meta  blocks.
Each meta block decompresses to a sequence of 0 to 16,777,216 (16 MiB) uncompressed bytes.
The final uncompressed data is the concatenation of the uncompressed sequences from each meta  block.
The header contains the size of the sliding window that was used during compression.
The decompressor must retain at least that amount of uncompressed data prior to the current position in the stream, in order to be able to decompress what follows.
The sliding window size is a power of two, minus 16, where the power is in the range of 10 to 24.
The possible sliding window sizes range from 1 KiB 16 B to 16 MiB 16 B.
Each meta block is compressed using a combination of the LZ77 algorithm (Lempel Ziv 1977, [LZ77]) and Huffman coding.
The result of Huffman coding is referred to here as a "prefix code".
The prefix codes for each meta block are independent of those for previous or subsequent meta blocks; the LZ77 algorithm may use a reference to a duplicated string occurring in a previous meta block, up to the sliding window size of uncompressed bytes before.
In addition, in the brotli format, a string reference may instead refer to a static dictionary entry.
Each meta block consists of two parts: a meta block header that describes the representation of the compressed data part and a compressed data part.
The compressed data consists of a series of commands.
Each command consists of two parts: a sequence of literal bytes (of strings that have not been detected as duplicated within the sliding window) and a pointer to a duplicated string, which is represented as a pair <length, backward distance
There can be zero literal bytes in the command.
The minimum length of the string to be duplicated is two, but the last command in the meta block is permitted to have only literals and no pointer to a string to duplicate.
Each command in the compressed data is represented using three categories of prefix codes: 1)
One set of prefix codes are for the literal sequence lengths (also referred to as literal insertion lengths) and backward copy lengths.
That is, a single code word represents two lengths: one of the literal sequence and one of the backward copy.
One set of prefix codes are for literals.
One set of prefix codes are for distances.
The prefix code descriptions for each meta block appear in a compact form just before the compressed data in the meta block header.
The insert and copy length and distance prefix codes may be followed by extra bits that are added to the base values determined by the codes.
The number of extra bits is determined by the code.
One meta block command then appears as a sequence of prefix codes:
The insertion length determines the number of literals that immediately follow.
The distance defines how far back to go for the copy and the copy length determines the number of bytes to copy.
(The number of bytes copied for a static dictionary entry can vary from the copy length.)
The last command in the meta block may end with the last literal if the total uncompressed length of the meta block has been satisfied.
In that case, there is no distance in the last command, and the copy length is ignored.
There can be more than one prefix code for each category, where the prefix code to use for the next element of that category is determined by the context of the compressed stream that precedes that element.
Part of that context is three current block types, one for each category.
A block type is in the range of 0..255.
For each category there is a count of how many elements of that category remain to be decoded using the current block type.
Once that count is expended, a new block type and block count is read from the stream immediately preceding the next element of that category, which will use the new block type.
The insert and copy block type directly determines which prefix code to use for the next insert and copy length.
For the literal and distance elements, the respective block type is used in combination with other context information to determine which prefix code to use for the next element.
Consider the following example: (IaC0, L0, L1, L2, D0)(IaC1, D1)(IaC2, L3, L4, D2)(IaC3, L5, D3)
The meta block here has four commands, contained in parentheses for clarity, where each of the three categories of symbols within these commands can be interpreted using different block types.
Here we separate out each category as its own sequence to show an example of block types assigned to those elements.
Each square bracketed group is a block that uses the same block type: [IaC0, IaC1][IaC2, IaC3]
insert and copy: block types 0 and 1 [L0, L1][L2, L3, L4][L5]
literals: block types 0, 1, and 0
block types 0 and 1
The subsequent blocks within each block category must have different block types, but we see that block types can be reused later in the meta block.
The block types are numbered from 0 to the maximum block type number of 255, and the first block of each block category is type 0.
The block structure of a meta block is represented by the sequence of block switch commands for each block category, where a block switch command is a pair <block type, block count
The block  switch commands are represented in the compressed data before the start of each new block using a prefix code for block types and a separate prefix code for block counts for each block category.
For the above example, the physical layout of the meta block is then: IaC0 L0 L1 LBlockSwitch(1, 3)
L2 D0 IaC1 DBlockSwitch(1, 3) D1 IaCBlockSwitch(1, 2)
IaC2 L3 L4 D2 IaC3
L5 D3 where xBlockSwitch(t, n) switches to block type t for a count of n elements.
In this example, note that DBlockSwitch(1, 3) immediately precedes the next required distance, D1.
It does not follow the last distance of the previous block, D0.
Whenever an element of a category is needed, and the block count for that category has reached zero, then a new block type and count are read from the stream just before reading that next element.
The block switch commands for the first blocks of each category are not part of the meta block compressed data.
Instead, the first block type is defined to be 0, and the first block count for each category is encoded in the meta block header.
The prefix codes for the block types and counts, a total of six prefix codes over the three categories, are defined in a compact form in the meta block header.
Each category of value (insert and copy lengths, literals, and distances) can be encoded with any prefix code from a collection of prefix codes belonging to the same category appearing in the meta  block header.
The particular prefix code used can depend on two factors: the block type of the block the value appears in and the context of the value.
In the case of the literals, the context is the previous two bytes in the uncompressed data; and in the case of distances, the context is the copy length from the same command.
For insert and copy lengths, no context is used and the prefix code depends only on the block type.
In the case of literals and distances, the context is mapped to a context ID in the range 0..63 for literals and 0..3 for distances.
The matrix of the prefix code indexes for each block type and context ID, called the context map, is encoded in a compact form in the meta block header.
For example, the prefix code to use to decode L2 depends on the block type (1), and the literal context ID determined by the two uncompressed bytes that were decoded from L0 and L1.
Similarly, the prefix code to use to decode D0 depends on the block type (0) and the distance context ID determined by the copy length decoded from IaC0.
The prefix code to use to decode IaC3 depends only on the block type (1).
In addition to the parts listed above (prefix code for insert and  copy lengths, literals, distances, block types, block counts, and the context map), the meta block header contains the number of uncompressed bytes coded in the meta block and two additional parameters used in the representation of match distances: the number of postfix bits and the number of direct distance codes.
A compressed meta block may be marked in the header as the last meta  block, which terminates the compressed stream.
A meta block may, instead, simply store the uncompressed data directly as bytes on byte boundaries with no coding or matching strings.
In this case, the meta block header information only contains the number of uncompressed bytes and the indication that the meta block is uncompressed.
An uncompressed meta block cannot be the last meta block.
A meta block may also be empty, which generates no uncompressed data at all.
An empty meta block may contain metadata information as bytes starting on byte boundaries, which are not part of either the sliding window or the uncompressed data.
Thus, these metadata bytes cannot be used to create matching strings in subsequent meta blocks and are not used as context bytes for literals.
Compressed Representation of Prefix Codes 3.1.
Introduction to Prefix Coding Prefix coding represents symbols from an a priori known alphabet by bit sequences (codes), one code for each symbol, in a manner such that different symbols may be represented by bit sequences of different lengths, but a parser can always parse an encoded string unambiguously symbol by symbol.
We define a prefix code in terms of a binary tree in which the two edges descending from each non leaf node are labeled 0 and 1, and in which the leaf nodes correspond one for one with (are labeled with) the symbols of the alphabet.
The code for a symbol is the sequence of 0's and 1's on the edges leading from the root to the leaf labeled with that symbol.
C A parser can decode the next symbol from the compressed stream by walking down the tree from the root, at each step choosing the edge corresponding to the next compressed data bit.
Given an alphabet with known symbol frequencies, the Huffman algorithm allows the construction of an optimal prefix code (one that represents strings with those symbol frequencies using the fewest bits of any possible prefix codes for that alphabet).
Such a prefix code is called a Huffman code.
(See [HUFFMAN] for additional information on Huffman codes.)
In the brotli format, note that the prefix codes for the various alphabets must not exceed certain maximum code lengths.
This constraint complicates the algorithm for computing code lengths from symbol frequencies.
Again, see [HUFFMAN] for details.
Use of Prefix Coding in the Brotli Format
The prefix codes used for each alphabet in the brotli format are canonical prefix codes, which have two additional rules:
That is, 0 precedes 10, which precedes 11x, and 110 and 111 are lexicographically consecutive.
Given this rule, we can define the canonical prefix code for an alphabet just by giving the bit lengths of the codes for each symbol of the alphabet in order; this is sufficient to determine the actual codes.
In our example, the code is completely defined by the sequence of bit lengths (2, 1, 3, 3).
The following algorithm generates the codes as integers, intended to be read from most to least significant bit.
The code lengths are initially in tree[I].Len; the codes are produced in tree[I].Code.
Count the number of codes for each code length.
Let bl count[N] be the number of codes of length N, N
1. 2) Find the numerical value of the smallest code for each code length:
<< 1; next code[bits]   code; } 3)
Assign numerical values to all codes, using consecutive values for all codes of the same length with the base values determined at step 2.
Codes that are never used (which have a bit length of zero) must not be assigned a value.
for (n   0; n <  max code; n )
After step 1, we have:
Alphabet Sizes Prefix codes are used for different purposes in the brotli format, and each purpose has a different alphabet size.
For literal codes, the alphabet size is 256.
For insert and copy length codes, the alphabet size is 704.
For block count codes, the alphabet size is 26.
For distance codes, block type codes, and the prefix codes used in compressing the context map, the alphabet size is dynamic and is based on parameters defined in later sections.
The following table summarizes the alphabet sizes for the various prefix codes and the sections of this document in which they are defined.
The first two bits of the compressed representation of each prefix code distinguish between simple and complex prefix codes.
If this value is 1, then a simple prefix code follows as described in this section.
Otherwise, a complex prefix code follows as described in Section 3.5.
A simple prefix code can have up to four symbols with non zero code length.
The format of the simple prefix code is as follows: 2 bits:
value of 1 indicates a simple prefix code 2 bits: NSYM 1, where NSYM   number of symbols coded NSYM symbols, each encoded using ALPHABET BITS bits 1 bit:  tree select, present only for NSYM   4
The value of ALPHABET BITS depends on the alphabet of the prefix code: it is the smallest number of bits that can represent all symbols in the alphabet.
For example, for the alphabet of literal bytes, ALPHABET BITS is 8.
The value of each of the NSYM symbols above is the value of the ALPHABET BITS width integer value.
If the integer value is greater than or equal to the alphabet size, or the value is identical to a previous value, then the stream should be rejected as invalid.
Note that the NSYM symbols may not be presented in sorted order.
Prefix codes of the same bit length must be assigned to the symbols in sorted order.
Similarly, when decoding a symbol using this prefix code, no bits are read and the one symbol is returned.
if NSYM   2, both symbols have code length 1.
if NSYM   3, the code lengths for the symbols are 1, 2, 2 in the order they appear in the representation of the simple prefix code.
if NSYM   4, the code lengths (in order of symbols decoded) depend on the tree select bit: 2, 2, 2, 2 (tree select bit 0), or 1, 2, 3, 3 (tree select bit 1).
A complex prefix code is a canonical prefix code, defined by the sequence of code lengths, as discussed in Section 3.2.
For even greater compactness, the code length sequences themselves are compressed using a prefix code.
The alphabet for code lengths is as follows: 0
Represent code lengths of 0
: Copy the previous non zero code length 3..6 times.
If this is the first code length, or all previous code lengths are zero, a code length of 8 is repeated 3..6 times.
A repeated code length code of 16 modifies the repeat count of the previous one as follows: repeat count
(3..6 on the next 2 bits)
Example:  Codes 7, 16 ( 2 bits 11), 16 ( 2 bits 10) will expand to 22 code lengths of 7 (1   4   (6 2)   5)
Repeat a code length of 0 for 3..10 times.
The next 3 bits indicate repeat length (0
A repeated code length code of 17 modifies the repeat count of the previous one as follows: repeat count
(3..10 on the next 3 bits)
Note that a code of 16 that follows an immediately preceding 16 modifies the previous repeat count, which becomes the new repeat count.
The same is true for a 17 following a 17.
A sequence of three or more 16 codes in a row or three of more 17 codes in a row is possible, modifying the count each time.
Only the final repeat count is used.
The modification only applies if the same code follows.
A 16 repeat does not modify an immediately preceding 17 count nor vice versa.
A code length of 0 indicates that the corresponding symbol in the alphabet will not occur in the compressed data, and it should not participate in the prefix code construction algorithm given earlier.
A complex prefix code must have at least two non zero code lengths.
The bit lengths of the prefix code over the code length alphabet are compressed with the following variable length code (as it appears in the compressed data, where the bits are parsed from right to left):
We can now define the format of the complex prefix code as follows:  2 bits:
HSKIP, the number of skipped code lengths, can have values of 0, 2, or 3.
The skipped lengths are taken to be zero.
(An HSKIP of 1 indicates a Simple prefix code.)
Code lengths for symbols in the code length alphabet given just above, in the order: 1, 2, 3, 4, 0, 5, 17, 6, 16, 7, 8, 9, 10, 11, 12, 13, 14, 15.
If HSKIP is 2, then the code lengths for symbols 1 and 2 are zero, and the first code length is for symbol 3.
If HSKIP is 3, then the code length for symbol 3 is also zero, and the first code length is for symbol 4.
The code lengths of code length symbols are between 0 and 5, and they are represented with 2..4 bits according to the variable  length code above.
A code length of 0 means the corresponding code length symbol is not used.
If HSKIP is 2 or 3, a respective number of leading code lengths are implicit zeros and are not present in the code length sequence above.
If there are at least two non zero code lengths, any trailing zero code lengths are omitted, i.e., the last code length in the sequence must be non zero.
In this case, the sum of (32 >> code length) over all the non zero code lengths must equal to 32.
If the lengths have been read for the entire code length alphabet and there was only one non zero code length, then the prefix code has one symbol whose code has zero length.
In this case, that symbol results in no bits being emitted by the compressor and no bits consumed by the decompressor.
That single symbol is immediately returned when this code is decoded.
An example of where this occurs is if the entire code to be represented has symbols of length 8.
For example, a literal code that represents all literal values with equal probability.
In this case the single symbol is 16, which repeats the previous length.
The previous length is taken to be 8 before any code length code lengths are read.
Sequence of code length symbols, which is at most the size of the alphabet, encoded using the code length prefix code.
Any trailing 0 or 17 must be omitted, i.e., the last encoded code length symbol must be between 1 and 16.
The sum of (32768 >> code length) over all the non zero code lengths in the alphabet, including those encoded using repeat code(s) of 16, must be equal to 32768.
If the number of times to repeat the previous length or repeat a zero length would result in more lengths in total than the number of symbols in the alphabet, then the stream should be rejected as invalid.
Encoding of Distances As described in Section 2, one component of a compressed meta block is a sequence of backward distances.
In this section, we provide the details to the encoding of distances.
Each distance in the compressed data part of a meta block is represented with a pair <distance code, extra bits
The distance code and the extra bits are encoded back to back, the distance code is encoded using a prefix code over the distance alphabet, while the extra bits value is encoded as a fixed width integer value.
The number of extra bits can be 0..24, and it is dependent on the distance code.
To convert a distance code and associated extra bits to a backward distance, we need the sequence of past distances and two additional parameters: the number of "postfix bits", denoted by NPOSTFIX (0..3), and the number of direct distance codes, denoted by NDIRECT (0..120).
Both of these parameters are encoded in the meta block header.
We will also use the following derived parameter: POSTFIX MASK   (1 << NPOSTFIX) 1
The first 16 distance symbols are special symbols that reference past distances as follows: 0:
last distance 1: second to last distance 2: third to last distance 3: fourth to last distance 4: last distance 1 5: last distance   1 6: last distance 2 7: last distance   2 8: last distance 3 9: last distance   3 10: second to last distance 1 11: second to last distance   1 12: second to last distance 2 13: second to last distance   2 14: second to last distance 3 15: second to last distance   3
The ring buffer of the four last distances is initialized by the values 16, 15, 11, and 4 (i.e., the fourth to last is set to 16, the third to last to 15, the second to last to 11, and the last distance to 4) at the beginning of the  stream  (as opposed to the beginning of the meta block), and it is not reset at meta block boundaries.
When a distance symbol 0 appears, the distance it represents (i.e., the last distance in the sequence of distances) is not pushed to the ring buffer of last distances; in other words, the expression "second to last distance" means the second to last distance that was not represented by a 0 distance symbol (and similar for "third to  last distance" and "fourth to last distance").
Similarly, distances that represent static dictionary words (see Section 8) are not pushed to the ring buffer of last distances.
If a special distance symbol resolves to a zero or negative value, the stream should be rejected as invalid.
If NDIRECT is greater than zero, then the next NDIRECT distance symbols, from 16 to 15   NDIRECT, represent distances from 1 to NDIRECT.
Neither the special distance symbols nor the NDIRECT direct distance symbols are followed by any extra bits.
Distance symbols 16   NDIRECT and greater all have extra bits, where the number of extra bits for a distance symbol "dcode" is given by the following formula: ndistbits
The maximum number of extra bits is 24; therefore, the size of the distance symbol alphabet is (16   NDIRECT
(dcode NDIRECT 16) & POSTFIX MASK offset
Encoding of Literal Insertion Lengths and Copy Lengths
As described in Section 2, the literal insertion lengths and backward copy lengths are encoded using a single prefix code.
This section provides the details to this encoding.
Each <insertion length, copy length
> pair in the compressed data part of a meta block is represented with the following triplet: <insert and copy length code, insert extra bits, copy extra bits
The insert and copy length code, the insert extra bits, and the copy extra bits are encoded back to back, the insert and copy length code is encoded using a prefix code over the insert and copy length code alphabet, while the extra bits values are encoded as fixed width integer values.
The number of insert and copy extra bits can be 0..24, and they are dependent on the insert and copy length code.
Some of the insert and copy length codes also express the fact that the distance symbol of the distance in the same command is 0, i.e., the distance component of the command is the same as that of the previous command.
In this case, the distance code and extra bits for the distance are omitted from the compressed data stream.
We describe the insert and copy length code alphabet in terms of the (not directly used)
insert length code and copy length code alphabets.
The symbols of the insert length code alphabet, along with the number of insert extra bits, and the range of the insert lengths are as follows:
The symbols of the copy length code alphabet, along with the number of copy extra bits, and the range of copy lengths are as follows:
To convert an insert and copy length code to an insert length code and a copy length code, the following table can be used:
First, look up the cell with the 64 value range containing the insert and copy length code; this gives the insert length code and the copy length code ranges, both 8 values long.
The copy length code within its range is determined by bits 0..2 (counted from the lsb) of the insert and copy length code.
The insert length code within its range is determined by bits 3..5 (counted from the lsb) of the insert and copy length code.
Given the insert length and copy length codes, the actual insert and copy lengths can be obtained by reading the number of extra bits given by the tables above.
If the insert and copy length code is between 0 and 127, the distance code of the command is set to zero (the last distance reused).
Encoding of Block Switch Commands As described in Section 2, a block switch command is a pair <block type, block count
These are encoded in the compressed data part of the meta block, right before the start of each new block of a particular block category.
Each block type in the compressed data is represented with a block type code, encoded using a prefix code over the block type code alphabet.
A block type symbol 0 means that the new block type is the same as the type of the previous block from the same block category, i.e., the block type that preceded the current type, while a block type symbol 1 means that the new block type equals the current block type plus one.
If the current block type is the maximal possible, then a block type symbol of 1 results in wrapping to a new block type of 0.
Block type symbols 2..257 represent block types 0..255, respectively.
The previous and current block types are initialized to 1 and 0, respectively, at the end of the meta block header.
Since the first block type of each block category is 0, the block type of the first block switch command is not encoded in the compressed data.
If a block category has only one block type, the block count of the first block switch command is also omitted from the compressed data; otherwise, it is encoded in the meta block header.
Since the end of the meta block is detected by the number of uncompressed bytes produced, the block counts for any of the three categories need not count down to exactly zero at the end of the meta block.
The number of different block types in each block category, denoted by NBLTYPESL, NBLTYPESI, and NBLTYPESD for literals, insert and copy lengths, and distances, respectively, is encoded in the meta block header, and it must equal to the largest block type plus one in that block category.
In other words, the set of literal, insert and copy length, and distance block types must be [0..NBLTYPESL 1], [0..NBLTYPESI 1], and [0..NBLTYPESD 1], respectively.
From this it follows that the alphabet size of literal, insert and copy length, and distance block type codes is NBLTYPESL   2, NBLTYPESI   2, and NBLTYPESD   2, respectively.
Each block count in the compressed data is represented with a pair <block count code,
The block count code and the extra bits are encoded back to back, the block count code is encoded using a prefix code over the block count code alphabet, while the extra bits value is encoded as a fixed width integer value.
The number of extra bits can be 0..24, and it is dependent on the block count code.
The symbols of the block count code alphabet along with the number of extra bits and the range of block counts are as follows:
The first block switch command of each block category is special in the sense that it is encoded in the meta block header, and as described earlier, the block type code is omitted since it is an implicit zero.
As described in Section 2, the prefix tree used to encode a literal byte or a distance code
depends on the block type and the context ID.
This section specifies how to compute the context ID for a particular literal and distance code and how to encode the context map that maps a <block type, context ID
> pair to the index of a prefix code in the array of literal and distance prefix codes.
Context Modes and Context ID Lookup for Literals
The context for encoding the next literal is defined by the last two bytes in the stream (p1, p2, where p1 is the most recent byte), regardless of whether these bytes are produced by uncompressed meta  blocks, backward references, static dictionary references, or by literal insertions.
At the start of the stream, p1 and p2 are initialized to zero.
Signed, where Context ID is a complex function of p1, p2, optimized for compressing sequences of signed integers.
The Context ID for the UTF8 and Signed context modes is computed using the following lookup tables Lut0, Lut1, and Lut2.
Lut0 :  0,  0,  0,  0,  0,  0,  0,  0,  0,  4,  4,  0,  0,  4,  0,  0, 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 8, 12, 16, 12, 12, 20, 12, 16, 24, 28, 12, 12, 32, 12, 36, 12, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 32, 32, 24, 40, 28, 12, 12, 48, 52, 52, 52, 48, 52, 52, 52, 48, 52, 52, 52, 52, 52, 48, 52, 52, 52, 52, 52, 48, 52, 52, 52, 52, 52, 24, 12, 28, 12, 12, 12, 56, 60, 60, 60, 56, 60, 60, 60, 56, 60, 60, 60, 60, 60, 56, 60, 60, 60, 60, 60, 56, 60, 60, 60, 60, 60, 24, 12, 28, 12,  0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3 Lut1 :  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2 Lut2 :  0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7
The lengths and the CRC 32 check values (see Appendix C) of each of these tables as a sequence of bytes are as follows:
the last uncompressed byte and p2 is the second to last uncompressed byte, the context IDs can be computed as follows:
Context ID   p1 & 0x3f
For Signed:  Context ID   (Lut2[p1]
From the lookup tables defined above and the operations to compute the context IDs, we can see that context IDs for literals are in the range of 0..63.
The context modes LSB6, MSB6, UTF8, and Signed are denoted by integers 0, 1, 2, 3.
A context mode is defined for each literal block type and they are stored in a consecutive array of bits in the meta block header, always two bits per block type.
The context for encoding a distance code is defined by the copy length corresponding to the distance.
The context IDs are 0, 1, 2, and 3 for copy lengths 2, 3, 4, and more than 4, respectively.
Encoding of the Context Map
There are two context maps, one for literals and one for distances.
The size of the context map is 64   NBLTYPESL for literals, and 4   NBLTYPESD for distances.
Each value in the context map is an integer between 0 and 255, indicating the index of the prefix code to be used when encoding the next literal or distance.
The context maps are two dimensional matrices, encoded as one  dimensional arrays: CMAPL[0..
The index of the prefix code for encoding a literal or distance code with block type, BTYPE x, and context ID, CIDx, is: index of literal prefix code
BTYPE L   CIDL] index of distance prefix code
The values of the context map are encoded with the combination of run length encoding for zero values and prefix coding.
Let RLEMAX denote the number of run length codes and NTREES denote the maximum value in the context map plus one.
NTREES must equal the number of different values in the context map; in other words, the different values in the context map must be the [0..NTREES 1] interval.
The alphabet of the prefix code has the following RLEMAX   NTREES symbols:
0: value zero 1: repeat a zero 2 to 3 times, read 1 bit for repeat length 2:
repeat a zero 4 to 7 times, read 2 bits for repeat length ...
1 times, read RLEMAX bits for repeat length RLEMAX   1
NTREES 1: value NTREES 1
If RLEMAX   0, the run length coding is not used and the symbols of the alphabet are directly the values in the context map.
We can now define the format of the context map (the same format is used for literal and distance context maps)
: 1..5 bits: RLEMAX, 0 is encoded with one 0 bit, and values
1..16 are encoded with bit pattern xxxx1 (so 01001 is 5)
Prefix code with alphabet size NTREES
RLEMAX Context map size values encoded with the above prefix code and run length coding for zero values.
If a run length would result in more lengths in total than the size of the context map, then the stream should be rejected as invalid.
IMTF bit, if set, we do an inverse move to front transform on the values in the context map to get the prefix code indexes.
Note that RLEMAX may be larger than the value necessary to represent the longest sequence of zero values.
Also, the NTREES value is encoded right before the context map as described in Section 9.2.
We define the inverse move to front transform used in this specification by the following C language function: void InverseMoveToFrontTransform(uint8 t  v, int v len) { uint8 t mtf[256]; int i;
At any given point during decoding the compressed data, a reference to a duplicated string in the uncompressed data produced so far has a maximum backward distance value, which is the minimum of the window size and the number of uncompressed bytes produced.
However, decoding a distance from the compressed stream, as described in Section 4, can produce distances that are greater than this maximum allowed value.
In this case, the distance is treated as a reference to a word in the static dictionary given in Appendix A.
The copy length for a static dictionary reference must be between 4 and 24.
The static dictionary has three parts:
DICT[0..DICTSIZE], an array of bytes
..24], an array of byte offset values for each length   NDBITS[0..24], an array of bit depth values for each length
The number of static dictionary words for a given length is: NWORDS[length]   0
(if length >  4) DOFFSET and DICTSIZE are defined by the following recursion:
The offset of a word within the DICT array for a given length and index is: offset(length, index)
Each static dictionary word has 121 different forms, given by applying a word transformation to a base word in the DICT array.
The list of word transformations is given in Appendix B.
The static dictionary word for a <length, distance> pair can be reconstructed as follows: word id   distance (max allowed
index   word id % NWORDS[length] base word   DICT[offset(length, index)..offset(length, index 1) 1] transform i
The string copied to the uncompressed stream is computed by applying the transformation to the base dictionary word.
If transform id is greater than 120, or the length is smaller than 4 or greater than 24, then the compressed stream should be rejected as invalid.
Each word transformation has the following form: transform i(word)
suffix i where the  i subscript denotes the transform
The form of these elementary transforms is as follows: Identity(word)
the last (length(word) k) bytes of word, or empty string if length(word)
the first (length(word) k) bytes of word, or empty string if length(word)
k We define the FermentFirst and FermentAll transforms used in this specification by the following C language functions: int Ferment(uint8 t  word, int word len, int pos) { if (word[pos]
< 192) { if (word[pos]
; } return 1; } else if (word[pos]
if (pos   1 < word len) { word[pos   1]   word[pos   1] ^ 32; } return 2; } else { if
(pos   2 < word len) { word[pos
i   0; while (i < word len) {
Note that the OmitFirst8 elementary transform is not used in the list of transformations.
The strings in Appendix B are in C string format with respect to escape (backslash) characters.
The maximum number of additional bytes that a transform may add to a base word is 13.
Since the largest base word is 24 bytes long, a buffer of 38 bytes is sufficient to store any transformed words (counting a terminating zero byte).
In this section, we describe the format of the compressed data set in terms of the format of the individual data items described in the previous sections.
Format of the Stream Header
The stream header has only the following one field: 1..7 bits: WBITS, a value in the range 10..24, encoded with the following variable length code (as it appears in the compressed data, where the bits are parsed from right to left):
The size of the sliding window, which is the maximum value of any non dictionary reference backward distance, is given by the following formula: window size   (1 << WBITS)
Format of the Meta Block Header A compliant compressed data set has at least one meta block.
Each meta block contains a header with information about the uncompressed length of the meta block, and a bit signaling if the meta block is the last one.
The format of the meta block header is the following: 1 bit:  ISLAST, set to 1 if this is the last meta block 1 bit:  ISLASTEMPTY, if set to 1, the meta block is empty; this field is only present if ISLAST bit is set   if it is 1, then the meta block and the brotli stream ends at that bit, with any remaining bits in the last byte of the compressed stream filled with zeros (if the fill bits are not zero, then the stream should be rejected as invalid)
2 bits: MNIBBLES, number of nibbles to represent the uncompressed length, encoded with the following fixed length code:
If MNIBBLES is 0, the meta block is empty, i.e., it does not generate any uncompressed data.
In this case, the rest of the meta block has the following format: 1 bit:  reserved, must be zero 2 bits: MSKIPBYTES, number of bytes to represent metadata length MSKIPBYTES
8 bits: MSKIPLEN 1, where MSKIPLEN is the number of metadata bytes
; this field is only present if MSKIPBYTES is positive; otherwise, MSKIPLEN is 0 (if MSKIPBYTES is greater than 1, and the last byte is all zeros, then the stream should be rejected as invalid) 0
..7 bits: fill bits until the next byte boundary, must be all zeros MSKIPLEN bytes of metadata, not part of the uncompressed data or the sliding window MNIBBLES   4 bits: MLEN 1, where MLEN is the length of the meta  block uncompressed data in bytes (if MNIBBLES is greater than 4, and the last nibble is all zeros, then the stream should be rejected as invalid)
ISUNCOMPRESSED, if set to 1, any bits of compressed data up to the next byte boundary are ignored, and the rest of the meta block contains MLEN bytes of literal data; this field is only present if the ISLAST bit is not set (if the ignored bits are not all zeros, the stream should be rejected as invalid)
1..11 bits: NBLTYPESL, number of literal block types,
encoded with the following variable length code (as it appears in the compressed data, where the bits are parsed from right to left, so 0110111 has the value 12)
xxxxxxx1111 Prefix code over the block type code alphabet for literal block types, appears only if NBLTYPESL >  2 Prefix code over the block count code alphabet for literal block counts, appears only if NBLTYPESL >  2 Block count code   extra bits for first literal block count, appears only if NBLTYPESL
NBLTYPESI, number of insert and copy block types, encoded with the same variable length code as above Prefix code over the block type code alphabet for insert and  copy block types, appears only if NBLTYPESI >  2 Prefix code over the block count code alphabet for insert and  copy block counts, appears only if NBLTYPESI >  2 Block count code   extra bits for first insert and copy block count, appears only if NBLTYPESI
NBLTYPESD, number of distance block types, encoded with the same variable length code as above Prefix code over the block type code alphabet for distance block types, appears only if NBLTYPESD >  2 Prefix code over the block count code alphabet for distance block counts, appears only if NBLTYPESD >  2 Block count code   extra bits for first distance block count, appears only if NBLTYPESD >  2 2 bits: NPOSTFIX, parameter used in the distance coding 4 bits: four most significant bits of NDIRECT, to get the actual value of the parameter NDIRECT, left shift this four bit number by NPOSTFIX bits NBLTYPESL   2 bits: context mode for each literal block type
NTREESL, number of literal prefix trees, encoded with the same variable length code as NBLTYPESL Literal context map, encoded as described in Section 7.3, appears only if NTREESL >  2; otherwise, the context map has only zero values 1..11 bits: NTREESD, number of distance prefix trees, encoded with the same variable length code as NBLTYPESD Distance context map, encoded as described in Section 7.3, appears only if NTREESD
; otherwise, the context map has only zero values NTREESL prefix codes for literals NBLTYPESI prefix codes for insert and copy lengths NTREESD prefix codes for distances 9.3.
Format of the Meta Block Data
The compressed data part of a meta block consists of a series of commands.
Each command has the following format: Block type code for next insert and copy block type, appears only if NBLTYPESI >  2 and the previous insert and copy block count is zero Block count code   extra bits for next insert and copy block count, appears only if NBLTYPESI >  2 and the previous insert  and copy block count is zero Insert and copy length, encoded as in Section 5, using the insert  and copy length prefix code with the current insert and copy block type index Insert length number of literals, with the following format: Block type code for next literal block type, appears only if NBLTYPESL
and the previous literal block count is zero Block count code   extra bits for next literal block count, appears only if NBLTYPESL >  2 and the previous literal block count is zero Next byte of the uncompressed data, encoded with the literal prefix code with the index determined by the previous two bytes of the uncompressed data, the current literal block type, and the context map, as described in Section 7.3 Block type code for next distance block type, appears only if NBLTYPESD >  2 and the previous distance block count is zero Block count code   extra bits for next distance block count, appears only if NBLTYPESD >  2 and the previous distance block count is zero Distance code, encoded as in Section 4, using the distance prefix code with the index determined by the copy length, the current distance block type, and the distance context map, as described in Section 7.3, appears only if the distance code is not an implicit 0, as indicated by the insert and copy length code
The number of commands in the meta block is such that the sum of the uncompressed bytes produced (i.e., the number of literals inserted plus the number of bytes copied from past data or generated from the static dictionary) over all the commands gives the uncompressed length, MLEN encoded in the meta block header.
If the total number of uncompressed bytes produced after the insert part of the last command equals MLEN, then the copy length of the last command is ignored and will not produce any uncompressed output.
In this case, the copy length of the last command can have any value.
In any other case, if the number of literals to insert, the copy length, or the resulting dictionary word length would cause MLEN to be exceeded, then the stream should be rejected as invalid.
If the last command of the last non empty meta block does not end on a byte boundary, the unused bits in the last byte must be zeros.
The decoding algorithm that produces the uncompressed data is as follows:
read window size do read ISLAST bit if ISLAST read ISLASTEMPTY bit if ISLASTEMPTY break from loop read MNIBBLES if MNIBBLES is zero verify reserved bit
is zero read MSKIPLEN skip any bits up to the next byte boundary skip
MSKIPLEN bytes continue to the next meta block else read MLEN if not ISLAST read ISUNCOMPRESSED bit if ISUNCOMPRESSED skip any bits up to the next byte boundary copy MLEN bytes of compressed data as literals continue to the next meta block loop for each three block categories (i   L, I, D) read NBLTYPESi if NBLTYPESi >  2 read prefix code for block types, HTREE BTYPE
i read prefix code for block counts, HTREE BLEN
i read block count, BLEN i set block type, BTYPE i to 0 initialize second to last and last block types to 0 and 1 else set block type,
BTYPE i to 0 set block count
, BLEN i to 16777216 read NPOSTFIX and NDIRECT read array of literal context modes, CMODE
[] read NTREESL if NTREESL
2 read literal context map, CMAPL[] else fill CMAPL[] with
zeros read NTREESD if NTREESD
2 read distance context map, CMAPD[]
zeros read array of literal prefix codes, HTREEL[] read array of insert and copy length prefix codes, HTREEI[] read array of distance prefix codes, HTREED
[] do if BLEN I is zero read block type using HTREE BTYPE I and set BTYPE I save previous block type read block count using HTREE BLEN I and set BLEN
I read insert and copy length symbol using HTREEI[BTYPE I] compute insert length, ILEN, and copy length, CLEN loop for ILEN if BLEN L is zero read block type using HTREE BTYPE L and set
BTYPE L save previous block type read block count using HTREE BLEN L and set BLEN L decrement
BLEN L look up context mode CMODE[BTYPE L] compute context ID, CIDL from last two uncompressed bytes read literal using HTREEL[CMAPL[64 BTYPE L   CIDL]]
write literal to uncompressed stream if number of uncompressed bytes produced in the loop for this meta block is MLEN, then break from loop (in this case the copy length is ignored and can have any value) if distance code is implicit zero from insert and copy code set backward distance to the last distance else
if BLEN D is zero read block type using HTREE BTYPE D and set BTYPE D save previous block type read block count using HTREE BLEN D and set BLEN D decrement
BLEN D compute context ID, CIDD from CLEN read distance code using HTREED[CMAPD[4 BTYPE D   CIDD]]
compute distance by distance short code substitution if distance code is not zero, and distance is not a static dictionary reference, push distance to the ring buffer of last distances if distance is less than the max allowed distance plus one move backwards distance bytes in the uncompressed data, and copy CLEN bytes from this position to the uncompressed stream else look up the static dictionary word, transform the word as directed, and copy the result to the uncompressed stream while number of uncompressed bytes for this meta block < MLEN while not ISLAST If the stream ends before the completion of the last meta block, then the stream should be rejected as invalid.
Note that a duplicated string reference may refer to a string in a previous meta block, i.e., the backward distance may cross one or more meta block boundaries.
However, a backward copy distance will not refer past the beginning of the uncompressed stream or the window size; any such distance is interpreted as a reference to a static dictionary word.
Also, note that the referenced string may overlap the current position, for example, if the last 2 bytes decoded have values X and Y, a string reference with <length
> adds X,Y,X,Y,X to the uncompressed stream.
Since the intent of this document is to define the brotli compressed data format without reference to any particular compression algorithm, the material in this section is not part of the definition of the format, and a compressor need not follow it in order to be compliant.
In this section, we present a very simple algorithm that produces a valid brotli stream representing an arbitrary sequence of uncompressed bytes in the form of the following C  language function.
; i   65535 < u.size
(N >> 16)   5) bytes.
Aligning Compressed Meta Blocks to Byte Boundaries As described in Section 9, only those meta blocks that immediately follow an uncompressed meta block or a metadata meta block are guaranteed to start on a byte boundary.
In some applications, it might be required that every non metadata meta block starts on a byte boundary.
This can be achieved by appending an empty metadata meta  block after every non metadata meta block that does not end on a byte boundary.
Creating Self Contained Parts within the Compressed Data
In some encoder implementations, it might be required to make a sequence of bytes within a brotli stream self contained, that is, such that they can be decompressed independently from previous parts of the compressed data.
This is a useful feature for three reasons.
First, if a large compressed file is damaged, it is possible to recover some of the file after the damage.
Second, it is useful when doing differential transfer of compressed data.
If a sequence of uncompressed bytes is unchanged and compressed independently from previous data, then the compressed representation may also be unchanged and can therefore be transferred very cheaply.
Third, if sequences of uncompressed bytes are compressed independently, it allows for parallel compression of these byte sequences within the same file, in addition to parallel compression of multiple files.
Given two sequences of uncompressed bytes, U0 and U1, we will now describe how to create two sequences of compressed bytes, C0 and C1, such that the concatenation of C0 and C1 is a valid brotli stream, and that C0 and C1 (together with the first byte of C0 that contains the window size) can be decompressed independently from each other to U0 and U1.
When compressing the byte sequence U0 to produce C0, we can use any compressor that works on the complete set of uncompressed bytes U0, with the following two changes.
First, the ISLAST bit of the last meta block of C0 must not be set.
Second, C0 must end at a byte  boundary, which can be ensured by appending an empty metadata meta  block to it, as in Section 11.2.
When compressing the byte sequence U1 to produce C1, we can use any compressor that starts a new meta block at the beginning of U1 within the U0 U1 input stream, with the following two changes.
First, backward distances in C1 must not refer to static dictionary words or uncompressed bytes in U0.
Even if a sequence of bytes in U1 would match a static dictionary word, or a sequence of bytes that overlaps U0, the compressor must represent this sequence of bytes with a combination of literal insertions and backward references to bytes in U1 instead.
Second, the ring buffer of last four distances must be replenished first with distances in C1 before using it to encode other distances in C1.
Note that both compressors producing C0 and C1 have to use the same window size, but the stream header is emitted only by the compressor that produces C0.
Note that this method can be easily generalized to more than two sequences of uncompressed bytes.
As with any compressed file formats, decompressor implementations should handle all compressed data byte sequences, not only those that conform to this specification, where non conformant compressed data sequences should be rejected as invalid.
A possible attack against a system containing a decompressor implementation (e.g., a web browser) is to exploit a buffer overflow triggered by invalid compressed data.
Therefore, decompressor implementations should perform bounds checking for each memory access that result from values decoded from the compressed stream and derivatives thereof.
Another possible attack against a system containing a decompressor implementation is to provide it (either valid or invalid)
compressed data that can make the decompressor system's resource consumption (CPU, memory, or storage) to be disproportionately large compared to the size of the compressed data.
In addition to the size of the compressed data, the amount of CPU, memory, and storage required to decompress a single compressed meta block within a brotli stream is controlled by the following two parameters: the size of the uncompressed meta block, which is encoded at the start of the compressed meta block, and the size of the sliding window, which is encoded at the start of the brotli stream.
Decompressor implementations in systems where memory or storage is constrained should perform a sanity check on these two parameters.
The uncompressed meta block size that was decoded from the compressed stream should be compared against either a hard limit, given by the system's constraints or some expectation about the uncompressed data, or against a certain multiple of the size of the compressed data.
If the uncompressed meta block size is determined to be too high, the compressed data should be rejected.
Likewise, when the complete uncompressed stream is kept in the system containing the decompressor implementation, the total uncompressed size of the stream should be checked before decompressing each additional meta block.
If the size of the sliding window that was decoded from the start of the compressed stream is greater than a certain soft limit, then the decompressor implementation should, at first, allocate a smaller sliding window that fits the first uncompressed meta block, and afterwards, before decompressing each additional meta block, it should increase the size of the sliding window until the sliding window size specified in the compressed data is reached.
Correspondingly, possible attacks against a system containing a compressor implementation (e.g., a web server) are to exploit a buffer overflow or cause disproportionately large resource consumption by providing, e.g., uncompressible data.
As described in Section 11.1, an output buffer of S(N)
(N >> 16)   5) bytes is sufficient to hold a valid compressed brotli stream representing an arbitrary sequence of N uncompressed bytes.
Therefore, compressor implementations should allocate at least S(N) bytes of output buffer before compressing N bytes of data with unknown compressibility and should perform bounds checking for each write into this output buffer.
If their output buffer is full, compressor implementations should revert to the trivial compression algorithm described in Section 11.1.
The resource consumption of a compressor implementation for a particular input data depends mostly on the algorithm used to find backward matches and on the algorithm used to construct context maps and prefix codes and only to a lesser extent on the input data itself.
If the system containing a compressor implementation is overloaded, a possible way to reduce resource usage is to switch to more simple algorithms for backward reference search and prefix code construction, or to fall back to the trivial compression algorithm described in Section 11.1.
A possible attack against a system that sends compressed data over an encrypted channel is the following.
An attacker who can repeatedly mix arbitrary (attacker supplied) data with secret data (passwords, cookies) and observe the length of the ciphertext can potentially reconstruct the secret data.
To protect against this kind of attack, applications should not mix sensitive data with non sensitive, potentially attacker supplied data in the same compressed stream.
The "HTTP Content Coding Registry" has been updated with the registration below:
The hexadecimal form of the DICT array is the following, where the length is 122,784 bytes and the CRC 32 of the byte sequence is 0x5136cb04.
706173746373733f677261796d65616e2667743b7269646573686f746c617465 73616964726f6164766172206665656c6a6f686e7269636b706f727466617374 2755412d646561643c2f623e706f6f7262696c6c74797065552e532e776f6f64 6d7573743270783b496e666f72616e6b7769646577616e7477616c6c6c656164 5b305d3b7061756c776176657375726524282723776169746d61737361726d73
6665657361643e0d733a2f2f205b5d3b746f6c6c706c756728297b0a7b0d0a20 2e6a7327323030706475616c626f61742e4a5047293b0a7d71756f74293b0a0a 27293b0a0d0a7d0d323031343230313532303136323031373230313832303139 3230323032303231323032323230323332303234323032353230323632303237 3230323832303239323033303230333132303332323033333230333432303335 3230333632303337323031333230313232303131323031303230303932303038 3230303732303036323030353230303432303033323030323230303132303030
d0a2d18bd183d0b6d981d98ad8a3d986d985d8a7d985d8b9d983d984d8a3d988 d8b1d8afd98ad8a7d981d989d987d988d984d985d984d983d8a7d988d984d987 d8a8d8b3d8a7d984d8a5d986d987d98ad8a3d98ad982d8afd987d984d8abd985 d8a8d987d984d988d984d98ad8a8d984d8a7d98ad8a8d983d8b4d98ad8a7d985 d8a3d985d986d8aad8a8d98ad984d986d8add8a8d987d985d985d8b4d988d8b4 6669727374766964656f6c69676874776f726c646d656469617768697465636c
6368616e6765726573756c747075626c696373637265656e63686f6f73656e6f 726d616c74726176656c697373756573736f7572636574617267657473707269 6e676d6f64756c656d6f62696c6573776974636870686f746f73626f72646572 726567696f6e697473656c66736f6369616c616374697665636f6c756d6e7265 636f7264666f6c6c6f777469746c653e6569746865726c656e67746866616d69 6c79667269656e646c61796f7574617574686f72637265617465726576696577
3c2f666f6f7465726c6f67696e2e6661737465726167656e74733c626f647920 313070782030707261676d616672696461796a756e696f72646f6c6c6172706c 61636564636f76657273706c7567696e352c3030302070616765223e626f7374 6f6e2e74657374286176617461727465737465645f636f756e74666f72756d73 736368656d61696e6465782c66696c6c6564736861726573726561646572616c
a681e79baee5898de8b584e8aeafe59f8ee5b882e696b9e6b395e794b5e5bdb1 e68b9be88198e5a3b0e6988ee4bbbbe4bd95e581a5e5bab7e695b0e68daee7be 8ee59bbde6b1bde8bda6e4bb8be7bb8de4bd86e698afe4baa4e6b581e7949fe4 baa7e68980e4bba5e794b5e8af9de698bee7a4bae4b880e4ba9be58d95e4bd8d e4babae59198e58886e69e90e59cb0e59bbee69785e6b8b8e5b7a5e585b7e5ad
92e4bd93e58c85e68bace982a3e4b988e4b880e6a0b7e59bbde58685e698afe5 90a6e6a0b9e68daee794b5e8a786e5ada6e999a2e585b7e69c89e8bf87e7a88b e794b1e4ba8ee4babae6898de587bae69da5e4b88de8bf87e6ada3e59ca8e698 8ee6989fe69585e4ba8be585b3e7b3bbe6a087e9a298e59586e58aa1e8be93e5 85a5e4b880e79bb4e59fbae7a180e69599e5ada6e4ba86e8a7a3e5bbbae7ad91
bd9ce9a38ee6a0bce4b880e8b5b7e7a791e5ada6e4bd93e882b2e79fade4bfa1 e69da1e4bbb6e6b2bbe79697e8bf90e58aa8e4baa7e4b89ae4bc9ae8aeaee5af bce888aae58588e7949fe88194e79b9fe58fafe698afe5958fe9a18ce7bb93e6 9e84e4bd9ce794a8e8b083e69fa5e8b387e69699e887aae58aa8e8b49fe8b4a3 e5869ce4b89ae8aebfe997aee5ae9ee696bde68ea5e58f97e8aea8e8aebae982 a3e4b8aae58f8de9a688e58aa0e5bcbae5a5b3e680a7e88c83e59bb4e69c8de5 8b99e4bc91e997b2e4bb8ae697a5e5aea2e69c8de8a780e79c8be58f82e58aa0
a49ae6b395e8a784e5aeb6e5b185e4b9a6e5ba97e8bf9ee68ea5e7ab8be58db3 e4b8bee68aa5e68a80e5b7a7e5a5a5e8bf90e799bbe585a5e4bba5e69da5e790 86e8aebae4ba8be4bbb6e887aae794b1e4b8ade58d8ee58a9ee585ace5a688e5 a688e79c9fe6ada3e4b88de99499e585a8e69687e59088e5908ce4bbb7e580bc e588abe4babae79b91e79da3e585b7e4bd93e4b896e7baaae59ba2e9989fe588 9be4b89ae689bfe68b85e5a29ee995bfe69c89e4babae4bf9de68c81e59586e5 aeb6e7bbb4e4bfaee58fb0e6b9bee5b7a6e58fb3e882a1e4bbbde7ad94e6a188
afe4bb98e68ea8e587bae7ab99e995bfe69dade5b79ee689a7e8a18ce588b6e9 80a0e4b98be4b880e68ea8e5b9bfe78eb0e59cbae68f8fe8bfb0e58f98e58c96 e4bca0e7bb9fe6ad8ce6898be4bf9de999a9e8afbee7a88be58cbbe79697e7bb 8fe8bf87e8bf87e58ebbe4b98be5898de694b6e585a5e5b9b4e5baa6e69d82e5 bf97e7be8ee4b8bde69c80e9ab98e799bbe99986e69caae69da5e58aa0e5b7a5
e5858de8b4a3e69599e7a88be78988e59d97e8baabe4bd93e9878de5ba86e587 bae594aee68890e69cace5bda2e5bc8fe59c9fe8b186e587bae583b9e4b89ce6 96b9e982aee7aeb1e58d97e4baace6b182e8818ce58f96e5be97e8818ce4bd8d e79bb8e4bfa1e9a1b5e99da2e58886e9929fe7bd91e9a1b5e7a1aee5ae9ae59b bee4be8be7bd91e59d80e7a7afe69e81e99499e8afafe79baee79a84e5ae9de8 b49de69cbae585b3e9a38ee999a9e68e88e69d83e79785e6af92e5aea0e789a9 e999a4e4ba86e8a995e8ab96e796bee79785e58f8ae697b6e6b182e8b4ade7ab
b8aae5a4a9e6b4a5e5ad97e4bd93e58fb0e781a3e7bbb4e68aa4e69cace9a1b5 e4b8aae680a7e5ae98e696b9e5b8b8e8a781e79bb8e69cbae68898e795a5e5ba 94e5bd93e5be8be5b888e696b9e4bebfe6a0a1e59bade882a1e5b882e688bfe5 b18be6a08fe79baee59198e5b7a5e5afbce887b4e7aa81e784b6e98193e585b7 e69cace7bd91e7bb93e59088e6a1a3e6a188e58ab3e58aa8e58fa6e5a496e7be 8ee58583e5bc95e8b5b7e694b9e58f98e7acace59b9be4bc9ae8aea1e8aaaae6 988ee99a90e7a781e5ae9de5ae9de8a784e88c83e6b688e8b4b9e585b1e5908c
e5bf98e8aeb0e4bd93e7b3bbe5b8a6e69da5e5908de5ad97e799bce8a1a8e5bc 80e694bee58aa0e79b9fe58f97e588b0e4ba8ce6898be5a4a7e9878fe68890e4 babae695b0e9878fe585b1e4baabe58cbae59f9fe5a5b3e5ada9e58e9fe58899 e68980e59ca8e7bb93e69d9fe9809ae4bfa1e8b685e7baa7e9858de7bdaee5bd 93e697b6e4bc98e7a780e680a7e6849fe688bfe4baa7e9818ae688b2e587bae5
8fa3e68f90e4baa4e5b0b1e4b89ae4bf9de581a5e7a88be5baa6e58f82e695b0 e4ba8be4b89ae695b4e4b8aae5b1b1e4b89ce68385e6849fe789b9e6ae8ae588 86e9a19ee6909ce5b08be5b19ee4ba8ee997a8e688b7e8b4a2e58aa1e5a3b0e9 9fb3e58f8ae585b6e8b4a2e7bb8fe59d9ae68c81e5b9b2e983a8e68890e7ab8b e588a9e79b8ae88083e89991e68890e983bde58c85e8a385e794a8e688b6e6af
6963656368617074657276696374696d7354686f6d6173206d6f7a696c6c6170 726f6d6973657061727469657365646974696f6e6f7574736964653a66616c73 652c68756e647265644f6c796d7069635f627574746f6e617574686f72737265 61636865646368726f6e696364656d616e64737365636f6e647370726f746563 7461646f70746564707265706172656e65697468657267726561746c79677265
6c7769746e6573736a75737469636547656f7267652042656c6769756d2e2e2e 3c2f613e747769747465726e6f7461626c7977616974696e6777617266617265 204f746865722072616e6b696e67706872617365736d656e74696f6e73757276 6976657363686f6c61723c2f703e0d0a20436f756e74727969676e6f7265646c 6f7373206f666a75737420617347656f72676961737472616e67653c68656164 3e3c73746f7070656431275d293b0d0a69736c616e64736e6f7461626c65626f 726465723a6c697374206f66636172726965643130302c3030303c2f68333e0a 207365766572616c6265636f6d657373656c6563742077656464696e6730302e
6c756d6e73686f7573696e67736372697074736e65787420746f62656172696e 676d617070696e67726576697365646a5175657279282d77696474683a746974 6c65223e746f6f6c74697053656374696f6e64657369676e735475726b697368 796f756e6765722e6d61746368287d2928293b0a0a6275726e696e676f706572 61746564656772656573736f757263653d52696368617264636c6f73656c7970 6c6173746963656e74726965733c2f74723e0d0a636f6c6f723a23756c206964 3d22706f7373657373726f6c6c696e67706879736963736661696c696e676578 6563757465636f6e746573746c696e6b20746f44656661756c743c6272202f3e 0a3a20747275652c63686172746572746f757269736d636c617373696370726f
6e7370656c6c6564676f6464657373546167202d2d3e416464696e673a627574 20776173526563656e742070617469656e746261636b20696e3d66616c736526 4c696e636f6c6e7765206b6e6f77436f756e7465724a75646169736d73637269 707420616c7465726564275d293b0a202068617320746865756e636c65617245 76656e74272c626f746820696e6e6f7420616c6c0a0a3c212d2d20706c616369
6f727364656c6179656443616e6f6e69636861642074686570757368696e6763 6c6173733d22627574206172657061727469616c426162796c6f6e626f74746f 6d2063617272696572436f6d6d616e646974732075736541732077697468636f 75727365736120746869726464656e6f746573616c736f20696e486f7573746f 6e323070783b223e61636375736564646f75626c6520676f616c206f6646616d 6f757320292e62696e642870726965737473204f6e6c696e65696e204a756c79
275d293b0d0a20206d61726b657477686f206973202822444f4d436f6d616e61 6765646f6e6520666f72747970656f66204b696e67646f6d70726f6669747370 726f706f7365746f2073686f7763656e7465723b6d6164652069746472657373 65647765726520696e6d6978747572657072656369736561726973696e677372 63203d20276d616b652061207365637572656442617074697374766f74696e67 200a0909766172204d61726368203267726577207570436c696d6174652e7265
7973637261556e69636f64656272202f3e0d0a41746c616e74616e75636c6575 73436f756e74792c707572656c7920636f756e74223e656173696c7920627569 6c6420616f6e636c69636b6120676976656e706f696e746572682671756f743b 6576656e747320656c7365207b0a646974696f6e736e6f77207468652c207769 7468206d616e2077686f6f72672f5765626f6e6520616e64636176616c727948
3b72652073697a653d223c2f613e3c2f686120636c6173737061737369766548 6f7374203d205768657468657266657274696c65566172696f75733d5b5d3b28 667563616d657261732f3e3c2f74643e61637473206173496e20736f6d653e0d 0a0d0a3c216f7267616e6973203c6272202f3e4265696a696e67636174616cc3 a0646575747363686575726f7065756575736b617261676165696c6765737665
4c697374206f6620486561646572223e22206e616d653d2220282671756f743b 67726164756174653c2f686561643e0a636f6d6d657263656d616c6179736961 6469726563746f726d61696e7461696e3b6865696768743a7363686564756c65 6368616e67696e676261636b20746f20636174686f6c69637061747465726e73 636f6c6f723a20236772656174657374737570706c69657372656c6961626c65
7375626a656374735269636861726420776861746576657270726f6261626c79 7265636f766572796261736562616c6c6a7564676d656e74636f6e6e6563742e 2e63737322202f3e20776562736974657265706f7274656464656661756c7422 2f3e3c2f613e0d0a656c65637472696373636f746c616e646372656174696f6e 7175616e746974792e204953424e2030646964206e6f7420696e7374616e6365
7265766973746173636f6e7469656e65736563746f7265736d6f6d656e746f73 666163756c7461646372c3a96469746f6469766572736173737570756573746f 666163746f726573736567756e646f737065717565c3b161d0b3d0bed0b4d0b0 d0b5d181d0bbd0b8d0b5d181d182d18cd0b1d18bd0bbd0bed0b1d18bd182d18c d18dd182d0bed0bcd095d181d0bbd0b8d182d0bed0b3d0bed0bcd0b5d0bdd18f
d0b2d0b5d0b4d18cd182d0b5d0bcd0b5d0b2d0bed0b4d18bd182d0b5d0b1d0b5 d0b2d18bd188d0b5d0bdd0b0d0bcd0b8d182d0b8d0bfd0b0d182d0bed0bcd183 d0bfd180d0b0d0b2d0bbd0b8d186d0b0d0bed0b4d0bdd0b0d0b3d0bed0b4d18b d0b7d0bdd0b0d18ed0bcd0bed0b3d183d0b4d180d183d0b3d0b2d181d0b5d0b9 d0b8d0b4d0b5d182d0bad0b8d0bdd0bed0bed0b4d0bdd0bed0b4d0b5d0bbd0b0 d0b4d0b5d0bbd0b5d181d180d0bed0bad0b8d18ed0bdd18fd0b2d0b5d181d18c d095d181d182d18cd180d0b0d0b7d0b0d0bdd0b0d188d0b8d8a7d984d984d987 d8a7d984d8aad98ad8acd985d98ad8b9d8aed8a7d8b5d8a9d8a7d984d8b0d98a d8b9d984d98ad987d8acd8afd98ad8afd8a7d984d8a2d986d8a7d984d8b1d8af
d8b7d8b1d98ad982d8b4d8a7d8b1d983d8acd988d8a7d984d8a3d8aed8b1d989 d985d8b9d986d8a7d8a7d8a8d8add8abd8b9d8b1d988d8b6d8a8d8b4d983d984 d985d8b3d8acd984d8a8d986d8a7d986d8aed8a7d984d8afd983d8aad8a7d8a8 d983d984d98ad8a9d8a8d8afd988d986d8a3d98ad8b6d8a7d98ad988d8acd8af d981d8b1d98ad982d983d8aad8a8d8aad8a3d981d8b6d984d985d8b7d8a8d8ae d8a7d983d8abd8b1d8a8d8a7d8b1d983d8a7d981d8b6d984d8a7d8add984d989
d986d981d8b3d987d8a3d98ad8a7d985d8b1d8afd988d8afd8a3d986d987d8a7 d8afd98ad986d8a7d8a7d984d8a7d986d985d8b9d8b1d8b6d8aad8b9d984d985 d8afd8a7d8aed984d985d985d983d98600000000000000000100010001000100 0200020002000200040004000400040000010203040506070706050403020100 08090a0b0c0d0e0f0f0e0d0c0b0a090810111213141516171716151413121110
73736b6579636f6e64656d6e6564616c736f206861766573657276696365732c 66616d696c79206f665363686f6f6c206f66636f6e7665727465646e61747572 65206f66206c616e67756167656d696e6973746572733c2f6f626a6563743e74 68657265206973206120706f70756c617273657175656e6365736164766f6361 746564546865792077657265616e79206f746865726c6f636174696f6e3d656e 746572207468656d756368206d6f72657265666c6563746564776173206e616d 65646f726967696e616c2061207479706963616c7768656e2074686579656e67
223e70616464696e673a30766965772074686174746f6765746865722c746865 206d6f73742077617320666f756e64737562736574206f6661747461636b206f 6e6368696c6472656e2c706f696e7473206f66706572736f6e616c20706f7369 74696f6e3a616c6c656765646c79436c6576656c616e64776173206c61746572 616e6420616674657261726520676976656e776173207374696c6c7363726f6c
a1e7ae97e69cbae7ac94e8aeb0e69cace8a88ee8ab96e58d80e69c8de58aa1e5 99a8e4ba92e88194e7bd91e688bfe59cb0e4baa7e4bfb1e4b990e983a8e587ba e78988e7a4bee68e92e8a18ce6a69ce983a8e890bde6a0bce8bf9be4b880e6ad a5e694afe4bb98e5ae9de9aa8ce8af81e7a081e5a794e59198e4bc9ae695b0e6 8daee5ba93e6b688e8b4b9e88085e58a9ee585ace5aea4e8aea8e8aebae58cba
a4b9e0a580e0a4b6e0a4b9e0a4b0e0a485e0a4b2e0a497e0a495e0a4ade0a580 e0a4a8e0a497e0a4b0e0a4aae0a4bee0a4b8e0a4b0e0a4bee0a4a4e0a495e0a4 bfe0a48fe0a489e0a4b8e0a587e0a497e0a4afe0a580e0a4b9e0a582e0a481e0 a486e0a497e0a587e0a49fe0a580e0a4aee0a496e0a58be0a49ce0a495e0a4be e0a4b0e0a485e0a4ade0a580e0a497e0a4afe0a587e0a4a4e0a581e0a4aee0a4 b5e0a58be0a49fe0a4a6e0a587e0a482e0a485e0a497e0a4b0e0a490e0a4b8e0
e0a4aae0a4b0e0a49ae0a4bee0a4b0e0a490e0a4b8e0a4bee0a4a6e0a587e0a4 b0e0a49ce0a4bfe0a4b8e0a4a6e0a4bfe0a4b2e0a4ace0a482e0a4a6e0a4ace0 a4a8e0a4bee0a4b9e0a582e0a482e0a4b2e0a4bee0a496e0a49ce0a580e0a4a4 e0a4ace0a49fe0a4a8e0a4aee0a4bfe0a4b2e0a487e0a4b8e0a587e0a486e0a4 a8e0a587e0a4a8e0a4afe0a4bee0a495e0a581e0a4b2e0a4b2e0a589e0a497e0 a4ade0a4bee0a497e0a4b0e0a587e0a4b2e0a49ce0a497e0a4b9e0a4b0e0a4be
6576616c756174696f6e656d70686173697a656461636365737369626c653c2f 73656374696f6e3e73756363657373696f6e616c6f6e6720776974684d65616e 7768696c652c696e64757374726965733c2f613e3c6272202f3e686173206265 636f6d6561737065637473206f6654656c65766973696f6e7375666669636965 6e746261736b657462616c6c626f7468207369646573636f6e74696e75696e67 616e2061727469636c653c696d6720616c743d22616476656e74757265736869 73206d6f746865726d616e636865737465727072696e6369706c657370617274
74c3ad63756c6f736469666572656e7465737369677569656e746573726570c3 ba626c69636173697475616369c3b36e6d696e6973746572696f707269766163 696461646469726563746f72696f666f726d616369c3b36e706f626c616369c3 b36e707265736964656e7465636f6e74656e69646f7361636365736f72696f73 746563686e6f72617469706572736f6e616c657363617465676f72c3ad616573
6e7465737065726d616e656e7465746f74616c6d656e7465d0bcd0bed0b6d0bd d0bed0b1d183d0b4d0b5d182d0bcd0bed0b6d0b5d182d0b2d180d0b5d0bcd18f d182d0b0d0bad0b6d0b5d187d182d0bed0b1d18bd0b1d0bed0bbd0b5d0b5d0be d187d0b5d0bdd18cd18dd182d0bed0b3d0bed0bad0bed0b3d0b4d0b0d0bfd0be d181d0bbd0b5d0b2d181d0b5d0b3d0bed181d0b0d0b9d182d0b5d187d0b5d180
d0b5d0b7d0bcd0bed0b3d183d182d181d0b0d0b9d182d0b0d0b6d0b8d0b7d0bd d0b8d0bcd0b5d0b6d0b4d183d0b1d183d0b4d183d182d09fd0bed0b8d181d0ba d0b7d0b4d0b5d181d18cd0b2d0b8d0b4d0b5d0bed181d0b2d18fd0b7d0b8d0bd d183d0b6d0bdd0bed181d0b2d0bed0b5d0b9d0bbd18ed0b4d0b5d0b9d0bfd0be d180d0bdd0bed0bcd0bdd0bed0b3d0bed0b4d0b5d182d0b5d0b9d181d0b2d0be
d0bbd183d187d188d0b5d0bfd0b5d180d0b5d0b4d187d0b0d181d182d0b8d187 d0b0d181d182d18cd180d0b0d0b1d0bed182d0bdd0bed0b2d18bd185d0bfd180 d0b0d0b2d0bed181d0bed0b1d0bed0b9d0bfd0bed182d0bed0bcd0bcd0b5d0bd d0b5d0b5d187d0b8d181d0bbd0b5d0bdd0bed0b2d18bd0b5d183d181d0bbd183 d0b3d0bed0bad0bed0bbd0bed0bdd0b0d0b7d0b0d0b4d182d0b0d0bad0bed0b5
67207372633d222f3c683120636c6173733d227075626c69636174696f6e6d61 7920616c736f2062657370656369616c697a65643c2f6669656c647365743e70 726f67726573736976656d696c6c696f6e73206f667374617465732074686174 656e666f7263656d656e7461726f756e6420746865206f6e6520616e6f746865 722e706172656e744e6f64656167726963756c74757265416c7465726e617469 76657265736561726368657273746f7761726473207468654d6f7374206f6620
3d22696d6167652f6d616e79206f662074686520666c6f773a68696464656e3b 617661696c61626c6520696e6465736372696265207468656578697374656e63 65206f66616c6c206f7665722074686574686520496e7465726e6574093c756c 20636c6173733d22696e7374616c6c6174696f6e6e65696768626f72686f6f64 61726d656420666f726365737265647563696e6720746865636f6e74696e7565
d0bdd0bdd18bd185d0b4d0bed0bbd0b6d0bdd18bd0b8d0bcd0b5d0bdd0bdd0be d09cd0bed181d0bad0b2d18bd180d183d0b1d0bbd0b5d0b9d09cd0bed181d0ba d0b2d0b0d181d182d180d0b0d0bdd18bd0bdd0b8d187d0b5d0b3d0bed180d0b0 d0b1d0bed182d0b5d0b4d0bed0bbd0b6d0b5d0bdd183d181d0bbd183d0b3d0b8 d182d0b5d0bfd0b5d180d18cd09ed0b4d0bdd0b0d0bad0bed0bfd0bed182d0be d0bcd183d180d0b0d0b1d0bed182d183d0b0d0bfd180d0b5d0bbd18fd0b2d0be d0bed0b1d189d0b5d0bed0b4d0bdd0bed0b3d0bed181d0b2d0bed0b5d0b3d0be d181d182d0b0d182d18cd0b8d0b4d180d183d0b3d0bed0b9d184d0bed180d183 d0bcd0b5d185d0bed180d0bed188d0bed0bfd180d0bed182d0b8d0b2d181d181 d18bd0bbd0bad0b0d0bad0b0d0b6d0b4d18bd0b9d0b2d0bbd0b0d181d182d0b8 d0b3d180d183d0bfd0bfd18bd0b2d0bcd0b5d181d182d0b5d180d0b0d0b1d0be d182d0b0d181d0bad0b0d0b7d0b0d0bbd0bfd0b5d180d0b2d18bd0b9d0b4d0b5 d0bbd0b0d182d18cd0b4d0b5d0bdd18cd0b3d0b8d0bfd0b5d180d0b8d0bed0b4
d0bed0b2d0bfd0bed187d0b5d0bcd183d0bfd0bed0bcd0bed189d18cd0b4d0be d0bbd0b6d0bdd0bed181d181d18bd0bbd0bad0b8d0b1d18bd181d182d180d0be d0b4d0b0d0bdd0bdd18bd0b5d0bcd0bdd0bed0b3d0b8d0b5d0bfd180d0bed0b5 d0bad182d0a1d0b5d0b9d187d0b0d181d0bcd0bed0b4d0b5d0bbd0b8d182d0b0 d0bad0bed0b3d0bed0bed0bdd0bbd0b0d0b9d0bdd0b3d0bed180d0bed0b4d0b5 d0b2d0b5d180d181d0b8d18fd181d182d180d0b0d0bdd0b5d184d0b8d0bbd18c d0bcd18bd183d180d0bed0b2d0bdd18fd180d0b0d0b7d0bdd18bd185d0b8d181 d0bad0b0d182d18cd0bdd0b5d0b4d0b5d0bbd18ed18fd0bdd0b2d0b0d180d18f
d0bcd0b5d0bdd18cd188d0b5d0bcd0bdd0bed0b3d0b8d185d0b4d0b0d0bdd0bd d0bed0b9d0b7d0bdd0b0d187d0b8d182d0bdd0b5d0bbd18cd0b7d18fd184d0be d180d183d0bcd0b0d0a2d0b5d0bfd0b5d180d18cd0bcd0b5d181d18fd186d0b0 d0b7d0b0d189d0b8d182d18bd09bd183d187d188d0b8d0b5e0a4a8e0a4b9e0a5 80e0a482e0a495e0a4b0e0a4a8e0a587e0a485e0a4aae0a4a8e0a587e0a495e0 a4bfe0a4afe0a4bee0a495e0a4b0e0a587e0a482e0a485e0a4a8e0a58de0a4af
e0a495e0a58de0a4afe0a4bee0a497e0a4bee0a487e0a4a1e0a4ace0a4bee0a4 b0e0a587e0a495e0a4bfe0a4b8e0a580e0a4a6e0a4bfe0a4afe0a4bee0a4aae0 a4b9e0a4b2e0a587e0a4b8e0a4bfe0a482e0a4b9e0a4ade0a4bee0a4b0e0a4a4 e0a485e0a4aae0a4a8e0a580e0a4b5e0a4bee0a4b2e0a587e0a4b8e0a587e0a4 b5e0a4bee0a495e0a4b0e0a4a4e0a587e0a4aee0a587e0a4b0e0a587e0a4b9e0
a58be0a4a8e0a587e0a4b8e0a495e0a4a4e0a587e0a4ace0a4b9e0a581e0a4a4 e0a4b8e0a4bee0a487e0a49fe0a4b9e0a58be0a497e0a4bee0a49ce0a4bee0a4 a8e0a587e0a4aee0a4bfe0a4a8e0a49fe0a495e0a4b0e0a4a4e0a4bee0a495e0 a4b0e0a4a8e0a4bee0a489e0a4a8e0a495e0a587e0a4afe0a4b9e0a4bee0a481 e0a4b8e0a4ace0a4b8e0a587e0a4ade0a4bee0a4b7e0a4bee0a486e0a4aae0a4
e0a496e0a4bee0a4a4e0a4bee0a495e0a4b0e0a580e0a4ace0a489e0a4a8e0a4 95e0a4bee0a49ce0a4b5e0a4bee0a4ace0a4aae0a582e0a4b0e0a4bee0a4ace0 a4a1e0a4bce0a4bee0a4b8e0a58ce0a4a6e0a4bee0a4b6e0a587e0a4afe0a4b0 e0a495e0a4bfe0a4afe0a587e0a495e0a4b9e0a4bee0a482e0a485e0a495e0a4 b8e0a4b0e0a4ace0a4a8e0a4bee0a48fe0a4b5e0a4b9e0a4bee0a482e0a4b8e0 a58de0a4a5e0a4b2e0a4aee0a4bfe0a4b2e0a587e0a4b2e0a587e0a496e0a495 e0a4b5e0a4bfe0a4b7e0a4afe0a495e0a58de0a4b0e0a482e0a4b8e0a4aee0a5 82e0a4b9e0a4a5e0a4bee0a4a8e0a4bed8aad8b3d8aad8b7d98ad8b9d985d8b4 d8a7d8b1d983d8a9d8a8d988d8a7d8b3d8b7d8a9d8a7d984d8b5d981d8add8a9 d985d988d8a7d8b6d98ad8b9d8a7d984d8aed8a7d8b5d8a9d8a7d984d985d8b2 d98ad8afd8a7d984d8b9d8a7d985d8a9d8a7d984d983d8a7d8aad8a8d8a7d984
d8a7d984d983d8b1d98ad985d8a7d984d8b9d8b1d8a7d982d985d8add981d988 d8b8d8a9d8a7d984d8abd8a7d986d98ad985d8b4d8a7d987d8afd8a9d8a7d984 d985d8b1d8a3d8a9d8a7d984d982d8b1d8a2d986d8a7d984d8b4d8a8d8a7d8a8 d8a7d984d8add988d8a7d8b1d8a7d984d8acd8afd98ad8afd8a7d984d8a3d8b3 d8b1d8a9d8a7d984d8b9d984d988d985d985d8acd985d988d8b9d8a9d8a7d984 d8b1d8add985d986d8a7d984d986d982d8a7d8b7d981d984d8b3d8b7d98ad986 d8a7d984d983d988d98ad8aad8a7d984d8afd986d98ad8a7d8a8d8b1d983d8a7
d8b5d98ad8b3d98ad8a7d8b1d8a7d8aad8a7d984d8abd8a7d984d8abd8a7d984 d8b5d984d8a7d8a9d8a7d984d8add8afd98ad8abd8a7d984d8b2d988d8a7d8b1 d8a7d984d8aed984d98ad8acd8a7d984d8acd985d98ad8b9d8a7d984d8b9d8a7 d985d987d8a7d984d8acd985d8a7d984d8a7d984d8b3d8a7d8b9d8a9d985d8b4 d8a7d987d8afd987d8a7d984d8b1d8a6d98ad8b3d8a7d984d8afd8aed988d984 d8a7d984d981d986d98ad8a9d8a7d984d983d8aad8a7d8a8d8a7d984d8afd988
74696f6e66617669636f6e2e69636f22206d617267696e2d72696768743a6261 736564206f6e20746865204d6173736163687573657474737461626c6520626f 726465723d696e7465726e6174696f6e616c616c736f206b6e6f776e20617370 726f6e756e63696174696f6e6261636b67726f756e643a236670616464696e67 2d6c6566743a466f72206578616d706c652c206d697363656c6c616e656f7573 266c743b2f6d6174682667743b70737963686f6c6f676963616c696e20706172
696f6e616c6c79204164646974696f6e616c6c792c4e6f72746820416d657269 636170783b6261636b67726f756e646f70706f7274756e6974696573456e7465 727461696e6d656e742e746f4c6f77657243617365286d616e75666163747572 696e6770726f66657373696f6e616c20636f6d62696e65642077697468466f72 20696e7374616e63652c636f6e73697374696e67206f6622206d61786c656e67
6173093c6c693e3c6120687265663d223e3c696e707574206e616d653d227365 706172617465642066726f6d726566657272656420746f2061732076616c6967 6e3d22746f70223e666f756e646572206f6620746865617474656d7074696e67 20746f20636172626f6e2064696f786964650a0a3c64697620636c6173733d22 636c6173733d227365617263682d2f626f64793e0a3c2f68746d6c3e6f70706f 7274756e69747920746f636f6d6d756e69636174696f6e733c2f686561643e0d 0a3c626f6479207374796c653d2277696474683a5469e1babf6e67205669e1bb
313170786578706c616e6174696f6e206f6674686520636f6e63657074206f66 7772697474656e20696e20746865093c7370616e20636c6173733d226973206f 6e65206f662074686520726573656d626c616e636520746f6f6e207468652067 726f756e6473776869636820636f6e7461696e73696e636c7564696e67207468 6520646566696e6564206279207468657075626c69636174696f6e206f666d65
7468617461677265656d656e742077697468636f6e7461696e696e6720746865 617265206672657175656e746c79696e666f726d6174696f6e206f6e6578616d 706c6520697320746865726573756c74696e6720696e20613c2f613e3c2f6c69 3e3c2f756c3e20636c6173733d22666f6f746572616e6420657370656369616c 6c79747970653d22627574746f6e22203c2f7370616e3e3c2f7370616e3e7768 69636820696e636c756465643e0a3c6d657461206e616d653d22636f6e736964
d181d0bad0b0d187d0b0d182d18cd0bdd0bed0b2d0bed181d182d0b8d0a3d0ba d180d0b0d0b8d0bdd18bd0b2d0bed0bfd180d0bed181d18bd0bad0bed182d0be d180d0bed0b9d181d0b4d0b5d0bbd0b0d182d18cd0bfd0bed0bcd0bed189d18c d18ed181d180d0b5d0b4d181d182d0b2d0bed0b1d180d0b0d0b7d0bed0bcd181 d182d0bed180d0bed0bdd18bd183d187d0b0d181d182d0b8d0b5d182d0b5d187 d0b5d0bdd0b8d0b5d093d0bbd0b0d0b2d0bdd0b0d18fd0b8d181d182d0bed180 d0b8d0b8d181d0b8d181d182d0b5d0bcd0b0d180d0b5d188d0b5d0bdd0b8d18f
d984d8a3d982d8b3d8a7d985d8a7d984d8b6d8bad8b7d8a7d8aad8a7d984d981 d98ad8afd98ad988d8a7d984d8aad8b1d8add98ad8a8d8a7d984d8acd8afd98a d8afd8a9d8a7d984d8aad8b9d984d98ad985d8a7d984d8a3d8aed8a8d8a7d8b1 d8a7d984d8a7d981d984d8a7d985d8a7d984d8a3d981d984d8a7d985d8a7d984 d8aad8a7d8b1d98ad8aed8a7d984d8aad982d986d98ad8a9d8a7d984d8a7d984
e0a482e0a49ae0a581e0a4a8e0a4bee0a4b5e0a4b2e0a587e0a495e0a4bfe0a4 a8e0a4b8e0a4b0e0a495e0a4bee0a4b0e0a4aae0a581e0a4b2e0a4bfe0a4b8e0 a496e0a58be0a49ce0a587e0a482e0a49ae0a4bee0a4b9e0a4bfe0a48fe0a4ad e0a587e0a49ce0a587e0a482e0a4b6e0a4bee0a4aee0a4bfe0a4b2e0a4b9e0a4 aee0a4bee0a4b0e0a580e0a49ce0a4bee0a497e0a4b0e0a4a3e0a4ace0a4a8e0 a4bee0a4a8e0a587e0a495e0a581e0a4aee0a4bee0a4b0e0a4ace0a58de0a4b2
a6e0a58ce0a4b0e0a4bee0a4a8e0a4aee0a4bee0a4aee0a4b2e0a587e0a4aee0 a4a4e0a4a6e0a4bee0a4a8e0a4ace0a4bee0a49ce0a4bee0a4b0e0a4b5e0a4bf e0a495e0a4bee0a4b8e0a495e0a58de0a4afe0a58be0a482e0a49ae0a4bee0a4 b9e0a4a4e0a587e0a4aae0a4b9e0a581e0a481e0a49ae0a4ace0a4a4e0a4bee0 a4afe0a4bee0a4b8e0a482e0a4b5e0a4bee0a4a6e0a4a6e0a587e0a496e0a4a8
a4bee0a4a4e0a587e0a482e0a4a6e0a588e0a49fe0a58de0a4b8e0a4a8e0a495 e0a58de0a4b6e0a4bee0a4b8e0a4bee0a4aee0a4a8e0a587e0a485e0a4a6e0a4 bee0a4b2e0a4a4e0a4ace0a4bfe0a49ce0a4b2e0a580e0a4aae0a581e0a4b0e0 a582e0a4b7e0a4b9e0a4bfe0a482e0a4a6e0a580e0a4aee0a4bfe0a4a4e0a58d e0a4b0e0a495e0a4b5e0a4bfe0a4a4e0a4bee0a4b0e0a581e0a4aae0a4afe0a5 87e0a4b8e0a58de0a4a5e0a4bee0a4a8e0a495e0a4b0e0a58be0a4a1e0a4bce0
a49ae0a4bee0a4b0e0a4b8e0a582e0a49ae0a4a8e0a4bee0a4aee0a582e0a4b2 e0a58de0a4afe0a4a6e0a587e0a496e0a587e0a482e0a4b9e0a4aee0a587e0a4 b6e0a4bee0a4b8e0a58de0a495e0a582e0a4b2e0a4aee0a588e0a482e0a4a8e0 a587e0a4a4e0a588e0a4afe0a4bee0a4b0e0a49ce0a4bfe0a4b8e0a495e0a587 7273732b786d6c22207469746c653d222d747970652220636f6e74656e743d22
466f72207468697320726561736f6e2c2e6a73223e3c2f7363726970743e0a09 7342795461674e616d652873295b305d6a73223e3c2f7363726970743e0d0a3c 2e6a73223e3c2f7363726970743e0d0a6c696e6b2072656c3d2269636f6e2220 2720616c743d272720636c6173733d27666f726d6174696f6e206f6620746865 76657273696f6e73206f6620746865203c2f613e3c2f6469763e3c2f6469763e
70743e0d0a3c6c6f636174696f6e2e70726f746f636f6c6672616d65626f7264 65723d223022207322202f3e0a3c6d657461206e616d653d223c2f613e3c2f64 69763e3c2f6469763e3c666f6e742d7765696768743a626f6c643b2671756f74 3b20616e64202671756f743b646570656e64696e67206f6e20746865206d6172 67696e3a303b70616464696e673a222072656c3d226e6f666f6c6c6f77222050
68746c7920646966666572656e74696e206163636f7264616e63652077697468 74656c65636f6d6d756e69636174696f6e73696e646963617465732074686174 2074686573686f72746c792074686572656166746572657370656369616c6c79 20696e20746865204575726f7065616e20636f756e7472696573486f77657665 722c207468657265206172657372633d22687474703a2f2f7374617469637375 6767657374656420746861742074686522207372633d22687474703a2f2f7777
6c207075626c6963697320616c6d6f737420656e746972656c79706173736573 207468726f75676820746865686173206265656e20737567676573746564636f 6d707574657220616e6420766964656f4765726d616e6963206c616e67756167 6573206163636f7264696e6720746f2074686520646966666572656e74206672 6f6d2074686573686f72746c792061667465727761726473687265663d226874 7470733a2f2f7777772e726563656e7420646576656c6f706d656e74426f6172 64206f66204469726563746f72733c64697620636c6173733d22736561726368
a1e0a4bfe0a4afe0a58be0a49ae0a4bfe0a49fe0a58de0a4a0e0a587e0a4b8e0 a4aee0a4bee0a49ae0a4bee0a4b0e0a49ce0a482e0a495e0a58de0a4b6e0a4a8 e0a4a6e0a581e0a4a8e0a4bfe0a4afe0a4bee0a4aae0a58de0a4b0e0a4afe0a5 8be0a497e0a485e0a4a8e0a581e0a4b8e0a4bee0a4b0e0a491e0a4a8e0a4b2e0 a4bee0a487e0a4a8e0a4aae0a4bee0a4b0e0a58de0a49fe0a580e0a4b6e0a4b0 e0a58de0a4a4e0a58be0a482e0a4b2e0a58be0a495e0a4b8e0a4ade0a4bee0a4
7468617473696d696c617220746f2074686174206f66206361706162696c6974 696573206f66207468656163636f7264616e6365207769746820746865706172 7469636970616e747320696e207468656675727468657220646576656c6f706d 656e74756e6465722074686520646972656374696f6e6973206f6674656e2063 6f6e7369646572656468697320796f756e6765722062726f746865723c2f7464
d0b8d18fd0bdd0b5d0bed0b1d185d0bed0b4d0b8d0bcd0bed0b8d0bdd184d0be d180d0bcd0b0d186d0b8d18fd098d0bdd184d0bed180d0bcd0b0d186d0b8d18f d0a0d0b5d181d0bfd183d0b1d0bbd0b8d0bad0b8d0bad0bed0bbd0b8d187d0b5 d181d182d0b2d0bed0b8d0bdd184d0bed180d0bcd0b0d186d0b8d18ed182d0b5 d180d180d0b8d182d0bed180d0b8d0b8d0b4d0bed181d182d0b0d182d0bed187 d0bdd0bed8a7d984d985d8aad988d8a7d8acd8afd988d986d8a7d984d8a7d8b4 d8aad8b1d8a7d983d8a7d8aad8a7d984d8a7d982d8aad8b1d8a7d8add8a7d8aa 68746d6c3b20636861727365743d5554462d38222073657454696d656f757428 66756e6374696f6e2829646973706c61793a696e6c696e652d626c6f636b3b3c 696e70757420747970653d227375626d6974222074797065203d202774657874
e0a4b0e0a4a3e0a4b8e0a4bee0a4aee0a497e0a58de0a4b0e0a580e0a49ae0a4 bfe0a49fe0a58de0a4a0e0a58be0a482e0a4b5e0a4bfe0a49ce0a58de0a49ee0 a4bee0a4a8e0a485e0a4aee0a587e0a4b0e0a4bfe0a495e0a4bee0a4b5e0a4bf e0a4ade0a4bfe0a4a8e0a58de0a4a8e0a497e0a4bee0a4a1e0a4bfe0a4afe0a4 bee0a481e0a495e0a58de0a4afe0a58be0a482e0a495e0a4bfe0a4b8e0a581e0 a4b0e0a495e0a58de0a4b7e0a4bee0a4aae0a4b9e0a581e0a481e0a49ae0a4a4
6c656d656e747342696e70757420747970653d227465787422206e616d653d61 2e74797065203d2027746578742f6a617661736372696e70757420747970653d 2268696464656e22206e616d6568746d6c3b20636861727365743d7574662d38 22202f3e647464223e0a3c68746d6c20786d6c6e733d22687474702d2f2f5733 432f2f4454442048544d4c20342e30312054656e747342795461674e616d6528 277363726970742729696e70757420747970653d2268696464656e22206e616d 3c73637269707420747970653d22746578742f6a6176617322207374796c653d
The string literals are in C format, with respect to the use of backslash escape characters.
In order to generate a length and check value, the transforms can be converted to a series of bytes, where each transform is the prefix sequence of bytes plus a terminating zero byte, a single byte value identifying the transform, and the suffix sequence of bytes plus a terminating zero.
The value for the transforms are 0 for Identity, 1 for FermentFirst, 2 for FermentAll, 3 to 11 for OmitFirst1 to OmitFirst9, and 12 to 20 for OmitLast1 to OmitLast9.
The byte sequences that represent the 121 transforms are then concatenated to a single sequence of bytes.
The length of that sequence is 648 bytes, and the CRC 32 is 0x3d965f81.
, we define the CRC 32 check value of a byte sequence with the following C language function: uint32 t CRC32(const uint8
t  v, const int len)
{ const uint32 t poly   0xedb88320UL; uint32 t crc, c; int i, k; crc
: c >> 1; crc   c
; } return crc ^ 0xffffffffUL; } Appendix D. Source Code Source code for a C language implementation of a brotli compliant compressor and decompressor is available in the brotli open source project <https://github.com/google/brotli
