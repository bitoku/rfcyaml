- title: __initial_text__
  contents:
  - '        TCP Friendly Rate Control (TFRC): Protocol Specification

    '
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This document specifies an Internet standards track protocol\
    \ for the\n   Internet community, and requests discussion and suggestions for\n\
    \   improvements.  Please refer to the current edition of the \"Internet\n   Official\
    \ Protocol Standards\" (STD 1) for the standardization state\n   and status of\
    \ this protocol.  Distribution of this memo is unlimited.\n"
- title: Abstract
  contents:
  - "Abstract\n   This document specifies TCP Friendly Rate Control (TFRC).  TFRC\
    \ is a\n   congestion control mechanism for unicast flows operating in a best-\n\
    \   effort Internet environment.  It is reasonably fair when competing\n   for\
    \ bandwidth with TCP flows, but has a much lower variation of\n   throughput over\
    \ time compared with TCP, making it more suitable for\n   applications such as\
    \ streaming media where a relatively smooth\n   sending rate is of importance.\n\
    \   This document obsoletes RFC 3448 and updates RFC 4342.\n"
- title: Table of Contents
  contents:
  - 'Table of Contents

    '
- title: 1. Introduction ....................................................3
  contents:
  - '1. Introduction ....................................................3

    '
- title: 2. Conventions .....................................................4
  contents:
  - '2. Conventions .....................................................4

    '
- title: 3. Protocol Mechanism ..............................................4
  contents:
  - "3. Protocol Mechanism ..............................................4\n   3.1.\
    \ TCP Throughput Equation ....................................5\n   3.2. Packet\
    \ Contents ............................................7\n        3.2.1. Data\
    \ Packets ........................................7\n        3.2.2. Feedback Packets\
    \ ....................................8\n"
- title: 4. Data Sender Protocol ............................................8
  contents:
  - "4. Data Sender Protocol ............................................8\n   4.1.\
    \ Measuring the Segment Size .................................9\n   4.2. Sender\
    \ Initialization .....................................10\n   4.3. Sender Behavior\
    \ When a Feedback Packet Is Received ........10\n   4.4. Expiration of Nofeedback\
    \ Timer ............................15\n   4.5. Reducing Oscillations .....................................17\n\
    \   4.6. Scheduling of Packet Transmissions ........................18\n"
- title: 5. Calculation of the Loss Event Rate (p) .........................19
  contents:
  - "5. Calculation of the Loss Event Rate (p) .........................19\n   5.1.\
    \ Detection of Lost or Marked Packets .......................19\n   5.2. Translation\
    \ from Loss History to Loss Events ..............20\n   5.3. The Size of a Loss\
    \ Interval ...............................22\n   5.4. Average Loss Interval .....................................22\n\
    \   5.5. History Discounting .......................................24\n"
- title: 6. Data Receiver Protocol .........................................26
  contents:
  - "6. Data Receiver Protocol .........................................26\n   6.1.\
    \ Receiver Behavior When a Data Packet Is Received ..........27\n   6.2. Expiration\
    \ of Feedback Timer ..............................27\n   6.3. Receiver Initialization\
    \ ...................................28\n        6.3.1. Initializing the Loss\
    \ History after the\n               First Loss Event ...................................29\n"
- title: 7. Sender-Based Variants ..........................................30
  contents:
  - '7. Sender-Based Variants ..........................................30

    '
- title: 8. Implementation Issues ..........................................31
  contents:
  - "8. Implementation Issues ..........................................31\n   8.1.\
    \ Computing the Throughput Equation .........................31\n   8.2. Sender\
    \ Behavior When a Feedback Packet Is Received ........32\n        8.2.1. Determining\
    \ If an Interval Was a\n               Data-Limited Interval ..............................32\n\
    \        8.2.2. Maintaining X_recv_set .............................34\n   8.3.\
    \ Sending Packets before Their Nominal Send Time ............34\n   8.4. Calculation\
    \ of the Average Loss Interval ..................36\n   8.5. The Optional History\
    \ Discounting Mechanism ................36\n"
- title: 9. Changes from RFC 3448 ..........................................36
  contents:
  - "9. Changes from RFC 3448 ..........................................36\n   9.1.\
    \ Overview of Changes .......................................36\n   9.2. Changes\
    \ in Each Section ...................................37\n"
- title: 10. Security Considerations .......................................39
  contents:
  - "10. Security Considerations .......................................39\n   10.1.\
    \ Security Considerations for TFRC in DCCP .................40\n"
- title: 11. Acknowledgments ...............................................40
  contents:
  - '11. Acknowledgments ...............................................40

    '
- title: Appendix A. Terminology ...........................................41
  contents:
  - 'Appendix A. Terminology ...........................................41

    '
- title: Appendix B. The Initial Value of the Nofeedback Timer .............43
  contents:
  - 'Appendix B. The Initial Value of the Nofeedback Timer .............43

    '
- title: Appendix C. Response to Idle or Data-Limited Periods ..............44
  contents:
  - "Appendix C. Response to Idle or Data-Limited Periods ..............44\n   C.1.\
    \  Long Idle or Data-Limited Periods ........................45\n   C.2.  Short\
    \ Idle or Data-Limited Periods .......................48\n   C.3.  Moderate Idle\
    \ or Data-Limited Periods ....................49\n   C.4.  Losses During Data-Limited\
    \ Periods .......................50\n   C.5.  Other Patterns ...........................................53\n\
    \   C.6.  Evaluating TFRC's Response to Idle Periods ...............53\n"
- title: References ........................................................54
  contents:
  - "References ........................................................54\n   Normative\
    \ References ...........................................54\n   Informative References\
    \ .........................................54\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   This document specifies TCP Friendly Rate Control (TFRC).\
    \  TFRC is a\n   congestion control mechanism designed for unicast flows operating\
    \ in\n   an Internet environment and competing with TCP traffic [FHPW00].\n  \
    \ Instead of specifying a complete protocol, this document simply\n   specifies\
    \ a congestion control mechanism that could be used in a\n   transport protocol\
    \ such as DCCP (Datagram Congestion Control\n   Protocol) [RFC4340], in an application\
    \ incorporating end-to-end\n   congestion control at the application level, or\
    \ in the context of\n   endpoint congestion management [BRS99].  This document\
    \ does not\n   discuss packet formats or reliability.  Implementation-related\
    \ issues\n   are discussed only briefly, in Section 8.\n   TFRC is designed to\
    \ be reasonably fair when competing for bandwidth\n   with TCP flows, where we\
    \ call a flow \"reasonably fair\" if its sending\n   rate is generally within\
    \ a factor of two of the sending rate of a TCP\n   flow under the same conditions.\
    \  However, TFRC has a much lower\n   variation of throughput over time compared\
    \ with TCP, which makes it\n   more suitable for applications such as telephony\
    \ or streaming media\n   where a relatively smooth sending rate is of importance.\n\
    \   The penalty of having smoother throughput than TCP while competing\n   fairly\
    \ for bandwidth is that TFRC responds slower than TCP to changes\n   in available\
    \ bandwidth.  Thus, TFRC should only be used when the\n   application has a requirement\
    \ for smooth throughput, in particular,\n   avoiding TCP's halving of the sending\
    \ rate in response to a single\n   packet drop.  For applications that simply\
    \ need to transfer as much\n   data as possible in as short a time as possible,\
    \ we recommend using\n   TCP, or if reliability is not required, using an Additive-Increase,\n\
    \   Multiplicative-Decrease (AIMD) congestion control scheme with similar\n  \
    \ parameters to those used by TCP.\n   TFRC is designed for best performance with\
    \ applications that use a\n   fixed segment size, and vary their sending rate\
    \ in packets per second\n   in response to congestion.  TFRC can also be used,\
    \ perhaps with less\n   optimal performance, with applications that do not have\
    \ a fixed\n   segment size, but where the segment size varies according to the\n\
    \   needs of the application (e.g., video applications).\n   Some applications\
    \ (e.g., some audio applications) require a fixed\n   interval of time between\
    \ packets and vary their segment size instead\n   of their packet rate in response\
    \ to congestion.  The congestion\n   control mechanism in this document is not\
    \ designed for those\n   applications; TFRC-SP (Small-Packet TFRC) is a variant\
    \ of TFRC for\n   applications that have a fixed sending rate in packets per second\
    \ but\n   either use small packets or vary their packet size in response to\n\
    \   congestion.  TFRC-SP is specified in a separate document [RFC4828].\n   This\
    \ document specifies TFRC as a receiver-based mechanism, with the\n   calculation\
    \ of the congestion control information (i.e., the loss\n   event rate) in the\
    \ data receiver rather in the data sender.  This is\n   well-suited to an application\
    \ where the sender is a large server\n   handling many concurrent connections,\
    \ and the receiver has more\n   memory and CPU cycles available for computation.\
    \  In addition, a\n   receiver-based mechanism is more suitable as a building\
    \ block for\n   multicast congestion control.  However, it is also possible to\n\
    \   implement TFRC in sender-based variants, as allowed in DCCP's\n   Congestion\
    \ Control ID 3 (CCID 3) [RFC4342].\n   This document obsoletes RFC 3448.  In the\
    \ transport protocol DCCP\n   (Datagram Congestion Control Protocol) [RFC4340],\
    \ the Congestion\n   Control ID Profiles CCID-3 [RFC4342] and CCID-4 [CCID-4]\
    \ both specify\n   the use of TFRC from RFC 3448.  CCID-3 and CCID-4 implementations\n\
    \   SHOULD use this document instead of RFC 3448 for the specification of\n  \
    \ TFRC.\n   The normative specification of TFRC is in Sections 3-6.  Section 7\n\
    \   discusses sender-based variants, Section 8 discusses implementation\n   issues,\
    \ and Section 9 gives a non-normative overview of differences\n   with RFC 3448.\n"
- title: 2.  Conventions
  contents:
  - "2.  Conventions\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\"\
    , \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and\
    \ \"OPTIONAL\" in this\n   document are to be interpreted as described in [RFC2119].\n\
    \   Appendix A gives a list of technical terms used in this document.\n"
- title: 3.  Protocol Mechanism
  contents:
  - "3.  Protocol Mechanism\n   For its congestion control mechanism, TFRC directly\
    \ uses a throughput\n   equation for the allowed sending rate as a function of\
    \ the loss event\n   rate and round-trip time.  In order to compete fairly with\
    \ TCP, TFRC\n   uses the TCP throughput equation, which roughly describes TCP's\n\
    \   sending rate as a function of the loss event rate, round-trip time,\n   and\
    \ segment size.  We define a loss event as one or more lost or\n   marked packets\
    \ from a window of data, where a marked packet refers to\n   a congestion indication\
    \ from Explicit Congestion Notification (ECN)\n   [RFC3168].\n   Generally speaking,\
    \ TFRC's congestion control mechanism works as\n   follows:\n   o   The receiver\
    \ measures the loss event rate and feeds this\n       information back to the\
    \ sender.\n   o   The sender also uses these feedback messages to measure the\n\
    \       round-trip time (RTT).\n   o   The loss event rate and RTT are then fed\
    \ into TFRC's throughput\n       equation, and the resulting sending rate is limited\
    \ to at most\n       twice the receive rate to give the allowed transmit rate\
    \ X.\n   o   The sender then adjusts its transmit rate to match the allowed\n\
    \       transmit rate X.\n   The dynamics of TFRC are sensitive to how the measurements\
    \ are\n   performed and applied.  We recommend specific mechanisms below to\n\
    \   perform and apply these measurements.  Other mechanisms are possible,\n  \
    \ but it is important to understand how the interactions between\n   mechanisms\
    \ affect the dynamics of TFRC.\n"
- title: 3.1.  TCP Throughput Equation
  contents:
  - "3.1.  TCP Throughput Equation\n   Any realistic equation giving TCP throughput\
    \ as a function of loss\n   event rate and RTT should be suitable for use in TFRC.\
    \  However, we\n   note that the TCP throughput equation used must reflect TCP's\n\
    \   retransmit timeout behavior, as this dominates TCP throughput at\n   higher\
    \ loss rates.  We also note that the assumptions implicit in the\n   throughput\
    \ equation about the loss event rate parameter have to be a\n   reasonable match\
    \ to how the loss rate or loss event rate is actually\n   measured.  While this\
    \ match is not perfect for the throughput\n   equation and loss rate measurement\
    \ mechanisms given below, in\n   practice the assumptions turn out to be close\
    \ enough.\n   The throughput equation currently REQUIRED for TFRC is a slightly\n\
    \   simplified version of the throughput equation for Reno TCP from\n   [PFTK98].\
    \  Ideally, we would prefer a throughput equation based on\n   selective acknowledgment\
    \ (SACK) TCP, but no one has yet derived the\n   throughput equation for SACK\
    \ TCP, and simulations and experiments\n   suggest that the differences between\
    \ the two equations would be\n   relatively minor [FF99] (Appendix B).\n   The\
    \ throughput equation for X_Bps, TCP's average sending rate in\n   bytes per second,\
    \ is:\n                                s\n   X_Bps = ----------------------------------------------------------\n\
    \           R*sqrt(2*b*p/3) + (t_RTO * (3*sqrt(3*b*p/8)*p*(1+32*p^2)))\n   Where:\n\
    \      X_Bps is TCP's average transmit rate in bytes per second.  (X_Bps\n   \
    \   is the same as X_calc in RFC 3448.)\n      s is the segment size in bytes\
    \ (excluding IP and transport\n      protocol headers).\n      R is the round-trip\
    \ time in seconds.\n      p is the loss event rate, between 0 and 1.0, of the\
    \ number of loss\n      events as a fraction of the number of packets transmitted.\n\
    \      t_RTO is the TCP retransmission timeout value in seconds.\n      b is the\
    \ maximum number of packets acknowledged by a single TCP\n      acknowledgement.\n\
    \   Setting the TCP retransmission timeout value t_RTO:\n   Implementations SHOULD\
    \ set t_RTO = 4*R.  Implementations MAY choose\n   to implement a more accurate\
    \ calculation of t_RTO.  Implementations\n   MAY also set t_RTO to max(4*R, one\
    \ second), to match the recommended\n   minimum of one second on the RTO [RFC2988].\n\
    \   Setting the parameter b for delayed acknowledgements:\n   Some current TCP\
    \ connections use delayed acknowledgements, sending an\n   acknowledgement for\
    \ every two data packets received.  However, TCP is\n   also allowed to send an\
    \ acknowledgement for every data packet.  For\n   the revised TCP congestion control\
    \ mechanisms, [RFC2581bis] currently\n   specifies that the delayed acknowledgement\
    \ algorithm should be used\n   with TCP.  However, [RFC2581bis] recommends increasing\
    \ the congestion\n   window during congestion avoidance by one segment per RTT\
    \ even in the\n   face of delayed acknowledgements, consistent with a TCP throughput\n\
    \   equation with b = 1.  On an experimental basis, [RFC2581bis] allows\n   for\
    \ increases of the congestion window during slow-start that are\n   also consistent\
    \ with a TCP throughput equation with b = 1.  Thus, the\n   use of b = 1 is consistent\
    \ with [RFC2581bis].  The use of b = 1 is\n   RECOMMENDED.\n   With t_RTO=4*R\
    \ and b=1, the throughput equation for X_Bps, the TCP\n   sending rate in bytes\
    \ per second, can be simplified as:\n                                s\n   X_Bps\
    \ = -----------------------------------------------\n           R * (sqrt(2*p/3)\
    \ + 12*sqrt(3*p/8)*p*(1+32*p^2))\n   In the future, updates to this document could\
    \ specify different TCP\n   equations to be substituted for this equation.  The\
    \ requirement is\n   that the throughput equation be a reasonable approximation\
    \ of the\n   sending rate of TCP for conformant TCP congestion control.\n   The\
    \ throughput equation can also be expressed in terms of X_pps, the\n   sending\
    \ rate in packets per second, with\n      X_pps =  X_Bps / s .\n   The parameters\
    \ s (segment size), p (loss event rate), and R (RTT)\n   need to be measured or\
    \ calculated by a TFRC implementation.  The\n   measurement of s is specified\
    \ in Section 4.1, the measurement of R is\n   specified in Section 4.3, and the\
    \ measurement of p is specified in\n   Section 5.  In the rest of this document,\
    \ data rates are measured in\n   bytes per second unless otherwise specified.\n"
- title: 3.2.  Packet Contents
  contents:
  - "3.2.  Packet Contents\n   Before specifying the sender and receiver functionality,\
    \ we describe\n   the contents of the data packets sent by the sender and feedback\n\
    \   packets sent by the receiver.  As TFRC will be used along with a\n   transport\
    \ protocol, we do not specify packet formats, as these depend\n   on the details\
    \ of the transport protocol used.\n"
- title: 3.2.1.  Data Packets
  contents:
  - "3.2.1.  Data Packets\n   Each data packet sent by the data sender contains the\
    \ following\n   information:\n   o   A sequence number. This number MUST be incremented\
    \ by one for\n       each data packet transmitted.  The field must be sufficiently\n\
    \       large that it does not wrap causing two different packets with\n     \
    \  the same sequence number to be in the receiver's recent packet\n       history\
    \ at the same time.\n   o   A timestamp indicating when the packet is sent.  We\
    \ denote by\n       ts_i the timestamp of the packet with sequence number i. \
    \ The\n       resolution of the timestamp SHOULD typically be measured in\n  \
    \     milliseconds.\n       This timestamp is used by the receiver to determine\
    \ which losses\n       belong to the same loss event.  The timestamp is also echoed\
    \ by\n       the receiver to enable the sender to estimate the round-trip\n  \
    \     time, for senders that do not save timestamps of transmitted data\n    \
    \   packets.\n       We note that, as an alternative to a timestamp incremented\
    \ in\n       milliseconds, a \"timestamp\" that increments every quarter of a\n\
    \       round-trip time MAY be used for determining when losses belong to\n  \
    \     the same loss event, in the context of a protocol where this is\n      \
    \ understood by both sender and receiver and where the sender saves\n       the\
    \ timestamps of transmitted data packets.\n   o   The sender's current estimate\
    \ of the round-trip time. The\n       estimate reported in packet i is denoted\
    \ by R_i.  The round-trip\n       time estimate is used by the receiver, along\
    \ with the timestamp,\n       to determine when multiple losses belong to the\
    \ same loss event.\n       The round-trip time estimate is also used by the receiver\
    \ to\n       determine the interval to use for calculating the receive rate\n\
    \       and to determine when to send feedback packets.\n       If the sender\
    \ sends a coarse-grained \"timestamp\" that increments\n       every quarter of\
    \ a round-trip time, as discussed above, then the\n       sender is not required\
    \ to send its current estimate of the round\n       trip time.\n"
- title: 3.2.2.  Feedback Packets
  contents:
  - "3.2.2.  Feedback Packets\n   Each feedback packet sent by the data receiver contains\
    \ the following\n   information:\n   o   The timestamp of the last data packet\
    \ received. We denote this by\n       t_recvdata.  If the last packet received\
    \ at the receiver has\n       sequence number i, then t_recvdata = ts_i.  This\
    \ timestamp is\n       used by the sender to estimate the round-trip time, and\
    \ is only\n       needed if the sender does not save the timestamps of transmitted\n\
    \       data packets.\n   o   The amount of time elapsed between the receipt of\
    \ the last data\n       packet at the receiver and the generation of this feedback\n\
    \       report.  We denote this by t_delay.\n   o   The rate at which the receiver\
    \ estimates that data was received\n       in the previous round-trip time.  We\
    \ denote this by X_recv.\n   o   The receiver's current estimate of the loss event\
    \ rate p.\n"
- title: 4.  Data Sender Protocol
  contents:
  - "4.  Data Sender Protocol\n   The data sender sends a stream of data packets to\
    \ the data receiver\n   at a controlled rate.  When a feedback packet is received\
    \ from the\n   data receiver, the data sender changes its sending rate based on\
    \ the\n   information contained in the feedback report.  If the sender does not\n\
    \   receive a feedback report for four round-trip times, then the sender\n   cuts\
    \ its sending rate in half.  This is achieved by means of a timer\n   called the\
    \ nofeedback timer.\n   We specify the sender-side protocol in the following steps:\n\
    \   o   Measurement of the mean segment size being sent.\n   o   Sender initialization.\n\
    \   o   The sender behavior when a feedback packet is received.\n   o   The sender\
    \ behavior when the nofeedback timer expires.\n   o   Oscillation prevention (optional).\n\
    \   o   Scheduling of packet transmission and allowed burstiness.\n"
- title: 4.1.  Measuring the Segment Size
  contents:
  - "4.1.  Measuring the Segment Size\n   The TFRC sender uses the segment size, s,\
    \ in the throughput equation,\n   in the setting of the maximum receive rate,\
    \ the setting of the\n   minimum and initial sending rates, and the setting of\
    \ the nofeedback\n   timer.  The TFRC receiver MAY use the average segment size,\
    \ s, in\n   initializing the loss history after the first loss event.  As\n  \
    \ specified in Section 6.3.1, if the TFRC receiver does not know the\n   segment\
    \ size, s, used by the sender, the TFRC receiver MAY instead\n   use the arrival\
    \ rate in packets per second in initializing the loss\n   history.\n   The segment\
    \ size is normally known to an application.  This may not\n   be so in two cases:\n\
    \   1)  The segment size naturally varies depending on the data.  In this\n  \
    \     case, although the segment size varies, that variation is not\n       coupled\
    \ to the transmit rate.  The TFRC sender can either compute\n       the average\
    \ segment size or use the maximum segment size for the\n       segment size, s.\n\
    \   2)  The application needs to change the segment size rather than the\n   \
    \    number of segments per second to perform congestion control.\n       This\
    \ would normally be the case with packet audio applications\n       where a fixed\
    \ interval of time needs to be represented by each\n       packet.  Such applications\
    \ need to have a completely different\n       way of measuring parameters.\n \
    \  For the first class of applications where the segment size varies\n   depending\
    \ on the data, the sender SHOULD estimate the segment size,\n   s, as the average\
    \ segment size over the last four loss intervals.\n   The sender MAY estimate\
    \ the average segment size over longer time\n   intervals, if so desired.\n  \
    \ The second class of applications are discussed separately in a\n   separate\
    \ document on TFRC-SP [RFC4828].  For the remainder of this\n   section we assume\
    \ the sender can estimate the segment size and that\n   congestion control is\
    \ performed by adjusting the number of packets\n   sent per second.\n"
- title: 4.2.  Sender Initialization
  contents:
  - "4.2.  Sender Initialization\n   The initial values for X (the allowed sending\
    \ rate in bytes per\n   second) and tld (the Time Last Doubled during slow-start,\
    \ in seconds)\n   are undefined until they are set as described below.  If the\
    \ sender\n   is ready to send data when it does not yet have a round-trip sample,\n\
    \   the value of X is set to s bytes per second, for segment size s, the\n   nofeedback\
    \ timer is set to expire after two seconds, and tld is set\n   to 0 (or to -1,\
    \ either one is okay).  Upon receiving the first\n   round-trip time measurement\
    \ (e.g., after the first feedback packet or\n   the SYN exchange from the connection\
    \ setup, or from a previous\n   connection [RFC2140]), tld is set to the current\
    \ time, and the\n   allowed transmit rate, X, is set to the initial_rate, specified\
    \ as\n   W_init/R, for W_init based on [RFC3390]:\n      initial_rate = W_init/R;\
    \ W_init = min(4*MSS, max(2*MSS, 4380)).\n   In computing W_init, instead of using\
    \ Maximum Segment Size (MSS), the\n   TFRC sender SHOULD use the maximum segment\
    \ size to be used for the\n   initial round-trip time of data, if that is known\
    \ by the TFRC sender\n   when X is initialized.\n   For responding to the initial\
    \ feedback packet, this replaces step (4)\n   of Section 4.3 below.\n   Appendix\
    \ B explains why the initial value of TFRC's nofeedback timer\n   is set to two\
    \ seconds, instead of the recommended initial value of\n   three seconds for TCP's\
    \ retransmit timer from [RFC2988].\n"
- title: 4.3.  Sender Behavior When a Feedback Packet Is Received
  contents:
  - "4.3.  Sender Behavior When a Feedback Packet Is Received\n   The sender knows\
    \ its current allowed sending rate, X, and maintains\n   an estimate of the current\
    \ round-trip time R.  The sender also\n   maintains X_recv_set as a small set\
    \ of recent X_recv values\n   (typically only two values).\n   Initialization:\
    \ X_recv_set is first initialized to contain a single\n   item, with value Infinity.\
    \  (As an implementation-specific issue,\n   X_recv_set MAY be initialized to\
    \ a large number instead of to\n   Infinity, e.g., to the largest integer that\
    \ is easily representable.)\n   When a feedback packet is received by the sender\
    \ at time t_now, the\n   current time in seconds, the following actions MUST be\
    \ performed.\n   1)  Calculate a new round-trip sample:\n      R_sample = (t_now\
    \ - t_recvdata) - t_delay.\n   As described in Section 3.2.2, t_delay gives the\
    \ elapsed time at the\n   receiver.\n   2)  Update the round-trip time estimate:\n\
    \      If no feedback has been received before {\n          R = R_sample;\n  \
    \    } Else {\n          R = q*R + (1-q)*R_sample;\n      }\n   TFRC is not sensitive\
    \ to the precise value for the filter constant q,\n   but a default value of 0.9\
    \ is RECOMMENDED.\n   3)  Update the timeout interval:\n      RTO = max(4*R, 2*s/X)\n\
    \   4)  Update the allowed sending rate as follows.  This procedure uses\n   \
    \    the variables t_mbi and recv_limit:\n      t_mbi: the maximum backoff interval\
    \ of 64 seconds.\n      recv_limit: the limit on the sending rate computed from\n\
    \                       X_recv_set.\n   This procedure also uses the procedures\
    \ Maximize X_recv_set() and\n   Update X_recv_set(), which are defined below.\n\
    \   The procedure for updating the allowed sending rate:\n      If (the entire\
    \ interval covered by the feedback packet\n            was a data-limited interval)\
    \ {\n          If (the feedback packet reports a new loss event or an\n      \
    \                 increase in the loss event rate p) {\n              Halve entries\
    \ in X_recv_set;\n              X_recv = 0.85 * X_recv;\n              Maximize\
    \ X_recv_set();\n              recv_limit = max (X_recv_set);\n          } Else\
    \ {\n              Maximize X_recv_set();\n              recv_limit = 2 * max\
    \ (X_recv_set);\n          }\n      } Else {                      // typical behavior\n\
    \          Update X_recv_set();\n          recv_limit = 2 * max (X_recv_set);\n\
    \      }\n      If (p > 0) {          // congestion avoidance phase\n        \
    \  Calculate X_Bps using the TCP throughput equation.\n          X = max(min(X_Bps,\
    \ recv_limit), s/t_mbi);\n      } Else if (t_now - tld >= R) {\n          // initial\
    \ slow-start\n          X = max(min(2*X, recv_limit), initial_rate);\n       \
    \   tld = t_now;\n      }\n   5)  If oscillation reduction is used, calculate\
    \ the instantaneous\n       transmit rate, X_inst, following Section 4.5.\n  \
    \ 6)  Reset the nofeedback timer to expire after RTO seconds.\n   The procedure\
    \ for maximizing X_recv_set keeps a single value, the\n   largest value from X_recv_set\
    \ and the new X_recv.\n      Maximize X_recv_set():\n          Add X_recv to X_recv_set;\n\
    \          Delete initial value Infinity from X_recv_set,\n             if it\
    \ is still a member.\n          Set the timestamp of the largest item to the current\
    \ time;\n          Delete all other items.\n   The procedure for updating X_recv_set\
    \ keeps a set of X_recv values\n   with timestamps from the two most recent round-trip\
    \ times.\n      Update X_recv_set():\n          Add X_recv to X_recv_set;\n  \
    \        Delete from X_recv_set values older than\n              two round-trip\
    \ times.\n   Definition of a data-limited interval:\n   We define a sender as\
    \ data-limited any time it is not sending as much\n   as it is allowed to send.\
    \  We define an interval as a 'data-limited\n   interval' if the sender was data-limited\
    \ over the *entire* interval;\n   Section 8.2.1 discusses implementation issues\
    \ for a sender in\n   determining if an interval was a data-limited interval.\
    \  The term\n   'data-limited interval' is used in the first \"if\" condition\
    \ in step\n   (4), which prevents a sender from having to reduce its sending rate\n\
    \   as a result of a feedback packet reporting the receive rate from a\n   data-limited\
    \ period.\n   As an example, consider a sender that is sending at its full allowed\n\
    \   rate, except that it is sending packets in pairs, rather than sending\n  \
    \ each packet as soon as it can.  Such a sender is considered data-\n   limited\
    \ part of the time, because it is not always sending packets as\n   soon as it\
    \ can.  However, consider an interval that covers this\n   sender's transmission\
    \ of at least two data packets; such an interval\n   does not meet the definition\
    \ of a data-limited interval because the\n   sender was not data-limited *over\
    \ the entire interval*.\n   If the feedback packet reports a receive rate X_recv\
    \ of zero (i.e.,\n   the first feedback packet), the sender does not consider\
    \ that the\n   entire interval covered by the feedback packet was a data-limited\n\
    \   interval.\n   X_recv_set and the first feedback packet:\n   Because X_recv_set\
    \ is initialized with a single item, with value\n   Infinity, recv_limit is set\
    \ to Infinity for the first two round-trip\n   times of the connection.  As a\
    \ result, the sending rate is not\n   limited by the receive rate during that\
    \ period.  This avoids the\n   problem of the sending rate being limited by the\
    \ value of X_recv from\n   the first feedback packet.\n   The interval covered\
    \ by a feedback packet:\n   How does the sender determine the period covered by\
    \ a feedback\n   packet?  This is discussed in more detail in Section 8.2.  In\n\
    \   general, the receiver will be sending a feedback packet once per\n   round-trip\
    \ time; so typically, the sender will be able to determine\n   exactly the period\
    \ covered by the current feedback packet from the\n   previous feedback packet.\
    \  However, in cases when the previous\n   feedback packet was lost, or when the\
    \ receiver sends a feedback\n   packet early because it detected a lost or ECN-marked\
    \ packet, the\n   sender will have to estimate the interval covered by the feedback\n\
    \   packet.  As specified in Section 6.2, each feedback packet sent by\n   the\
    \ receiver covers a round-trip time, for the round-trip time\n   estimate R_m\
    \ maintained by the receiver R_m seconds before the\n   feedback packet was sent.\n\
    \   The response to a loss during a data-limited interval:\n   In TFRC, after\
    \ the initial slow-start, the sender always updates the\n   calculated transmit\
    \ rate, X_Bps, after a feedback packet is received,\n   and the allowed sending\
    \ rate, X, is always limited by X_Bps.\n   However, during a data-limited interval,\
    \ when the actual sending rate\n   is usually below X_Bps, the sending rate is\
    \ still limited by\n   recv_limit, derived from X_recv_set.  If the sender is\
    \ data-limited,\n   possibly with a varying sending rate from one round-trip time\
    \ to the\n   next, and is experiencing losses, then we decrease the entry in\n\
    \   X_recv_set in order to reduce the allowed sending rate.\n   The sender can\
    \ detect a loss event during a data-limited period\n   either from explicit feedback\
    \ from the receiver, or from a reported\n   increase in the loss event rate. \
    \ When the sender receives a feedback\n   packet reporting such a loss event in\
    \ a data-limited interval, the\n   sender limits the allowed increases in the\
    \ sending rate during the\n   data-limited interval.\n   The initial slow-start\
    \ phase:\n   Note that when p=0, the sender has not yet learned of any loss\n\
    \   events, and the sender is in the initial slow-start phase.  In this\n   initial\
    \ slow-start phase, the sender can approximately double the\n   sending rate each\
    \ round-trip time until a loss occurs.  The\n   initial_rate term in step (4)\
    \ gives a minimum allowed sending rate\n   during slow-start of the initial allowed\
    \ sending rate.\n   We note that if the sender is data-limited during slow-start,\
    \ or if\n   the connection is limited by the path bandwidth, then the sender is\n\
    \   not necessarily able to double its sending rate each round-trip time;\n  \
    \ the sender's sending rate is limited to at most twice the past\n   receive rate,\
    \ or at most initial_rate, whichever is larger.  This is\n   similar to TCP's\
    \ behavior, where the sending rate is limited by the\n   rate of incoming acknowledgement\
    \ packets as well as by the congestion\n   window.  Thus, in TCP's slow-start,\
    \ for the most aggressive case of\n   the TCP receiver acknowledging every data\
    \ packet, the TCP sender's\n   sending rate is limited to at most twice the rate\
    \ of these incoming\n   acknowledgment packets.\n   The minimum allowed sending\
    \ rate:\n   The term s/t_mbi ensures that when p > 0, the sender is allowed to\n\
    \   send at least one packet every 64 seconds.\n"
- title: 4.4.  Expiration of Nofeedback Timer
  contents:
  - "4.4.  Expiration of Nofeedback Timer\n   This section specifies the sender's\
    \ response to a nofeedback timer.\n   The nofeedback timer could expire because\
    \ of an idle period or\n   because of data or feedback packets dropped in the\
    \ network.\n   This section uses the variable recover_rate.  If the TFRC sender\
    \ has\n   been idle ever since the nofeedback timer was set, the allowed\n   sending\
    \ rate is not reduced below the recover_rate.  For this\n   document, the recover_rate\
    \ is set to the initial_rate (specified in\n   Section 4.2).  Future updates to\
    \ this specification may explore other\n   possible values for the recover_rate.\n\
    \   If the nofeedback timer expires, the sender MUST perform the\n   following\
    \ actions:\n   1)  Cut the allowed sending rate in half.\n      If the nofeedback\
    \ timer expires when the sender has had at least\n      one RTT measurement, the\
    \ allowed sending rate is reduced by\n      modifying X_recv_set as described\
    \ in the pseudocode below\n      (including item (2)).  In the general case, the\
    \ sending rate is\n      limited to at most twice X_recv.  Modifying X_recv_set\
    \ limits the\n      sending rate, but still allows the sender to slow-start, doubling\n\
    \      its sending rate each RTT, if feedback messages resume reporting\n    \
    \  no losses.\n      If the sender has been idle since this nofeedback timer was\
    \ set\n      and X_recv is less than the recover_rate, then the allowed sending\n\
    \      rate is not halved, and X_recv_set is not changed.  This ensures\n    \
    \  that the allowed sending rate is not reduced to less than half the\n      recover_rate\
    \ as a result of an idle period.\n      In the general case, the allowed sending\
    \ rate is halved in\n      response to the expiration of the nofeedback timer.\
    \  The details,\n      in the pseudocode below, depend on whether the sender is\
    \ in slow-\n      start, is in congestion avoidance limited by X_recv, or is in\n\
    \      congestion avoidance limited by the throughput equation.\n      X_recv\
    \ = max (X_recv_set);\n      If (sender does not have an RTT sample,\n       \
    \   has not received any feedback from receiver,\n          and has not been idle\
    \ ever since the nofeedback timer\n          was set) {\n          // We do not\
    \ have X_Bps or recover_rate yet.\n          // Halve the allowed sending rate.\n\
    \          X = max(X/2, s/t_mbi);\n      } Else if (((p>0 && X_recv < recover_rate)\
    \ or\n            (p==0 && X < 2 * recover_rate)), and\n             sender has\
    \ been idle ever\n             since nofeedback timer was set) {\n          //\
    \ Don't halve the allowed sending rate.\n          Do nothing;\n      } Else if\
    \ (p==0) {\n          // We do not have X_Bps yet.\n          // Halve the allowed\
    \ sending rate.\n          X = max(X/2, s/t_mbi);\n      } Else if (X_Bps > 2*X_recv))\
    \ {\n          // 2*X_recv was already limiting the sending rate.\n          //\
    \ Halve the allowed sending rate.\n          Update_Limits(X_recv;)\n      } Else\
    \ {\n          // The sending rate was limited by X_Bps, not by X_recv.\n    \
    \      // Halve the allowed sending rate.\n          Update_Limits(X_Bps/2);\n\
    \      }\n      The term s/t_mbi limits the backoff to one packet every 64\n \
    \     seconds.\n      The procedure Update_Limits() uses the variable timer_limit\
    \ for\n      the limit on the sending rate computed from the expiration of the\n\
    \      nofeedback timer, as follows:\n      Update_Limits(timer_limit):\n    \
    \      If (timer_limit < s/t_mbi)\n              timer_limit = s/t_mbi;\n    \
    \      Replace X_recv_set contents with the single item\n               timer_limit/2;\n\
    \          Recalculate X as in step (4) of Section 4.3;\n   2)  Restart the nofeedback\
    \ timer to expire after max(4*R, 2*s/X)\n       seconds.\n   If the sender has\
    \ been data-limited but not idle since the nofeedback\n   timer was set, it is\
    \ possible that the nofeedback timer expired\n   because data or feedback packets\
    \ were dropped in the network.  In\n   this case, the nofeedback timer is the\
    \ backup mechanism for the\n   sender to detect these losses, similar to the retransmit\
    \ timer in\n   TCP.\n   Note that when the sender stops sending data for a period\
    \ of time,\n   the receiver will stop sending feedback.  When the sender's\n \
    \  nofeedback timer expires, the sender could use the procedure above to\n   limit\
    \ the sending rate.  If the sender subsequently starts to send\n   again, X_recv_set\
    \ will be used to limit the transmit rate, and slow-\n   start behavior will occur\
    \ until the transmit rate reaches X_Bps.\n   The TFRC sender's reduction of the\
    \ allowed sending rate after the\n   nofeedback timer expires is similar to TCP's\
    \ reduction of the\n   congestion window, cwnd, after each RTO seconds of an idle\
    \ period,\n   for TCP with Congestion Window Validation [RFC2861].\n"
- title: 4.5.  Reducing Oscillations
  contents:
  - "4.5.  Reducing Oscillations\n   To reduce oscillations in queueing delay and\
    \ sending rate in\n   environments with a low degree of statistical multiplexing\
    \ at the\n   congested link, it is RECOMMENDED that the sender reduce the transmit\n\
    \   rate as the queueing delay (and hence RTT) increases.  To do this,\n   the\
    \ sender maintains R_sqmean, a long-term estimate of the square\n   root of the\
    \ RTT, and modifies its sending rate depending on how the\n   square root of R_sample,\
    \ the most recent sample of the RTT, differs\n   from the long-term estimate.\
    \  The long-term estimate R_sqmean is set\n   as follows:\n      If no feedback\
    \ has been received before {\n          R_sqmean = sqrt(R_sample);\n      } Else\
    \ {\n          R_sqmean = q2*R_sqmean + (1-q2)*sqrt(R_sample);\n      }\n   Thus,\
    \ R_sqmean gives the exponentially weighted moving average of the\n   square root\
    \ of the RTT samples.  The constant q2 should be set\n   similarly to q, the constant\
    \ used in the round-trip time estimate R.\n   A value of 0.9 as the default for\
    \ q2 is RECOMMENDED.\n   When sqrt(R_sample) is greater than R_sqmean, then the\
    \ current\n   round-trip time is greater than the long-term average, implying\
    \ that\n   queueing delay is probably increasing.  In this case, the transmit\n\
    \   rate is decreased to minimize oscillations in queueing delay.\n   The sender\
    \ obtains the base allowed transmit rate, X, as described in\n   step (4) of Section\
    \ 4.3 above.  It then calculates a modified\n   instantaneous transmit rate X_inst,\
    \ as follows:\n      X_inst = X * R_sqmean / sqrt(R_sample);\n      If (X_inst\
    \ < s/t_mbi)\n          X_inst = s/t_mbi;\n   Because we are using square roots,\
    \ there is generally only a moderate\n   difference between the instantaneous\
    \ transmit rate X_inst and the\n   allowed transmit rate X.  For example, in a\
    \ somewhat extreme case\n   when the current RTT sample R_sample is twice as large\
    \ as the long-\n   term average, then sqrt(R_sample) will be roughly 1.44 times\n\
    \   R_sqmean, and the allowed transmit rate will be reduced by a factor\n   of\
    \ roughly 0.7.\n   We note that this modification for reducing oscillatory behavior\
    \ is\n   not always needed, especially if the degree of statistical\n   multiplexing\
    \ in the network is high.  We also note that the\n   modification for reducing\
    \ oscillatory behavior could cause problems\n   for connections where the round-trip\
    \ time is not strongly correlated\n   with the queueing delay (e.g., in some wireless\
    \ links, over paths\n   with frequent routing changes, etc.).  However, this modification\n\
    \   SHOULD be implemented because it makes TFRC behave better in some\n   environments\
    \ with a low level of statistical multiplexing.  The\n   performance of this modification\
    \ is illustrated in Section 3.1.3 of\n   [FHPW00].  If it is not implemented,\
    \ implementations SHOULD use a\n   very low value of the weight q for the average\
    \ round-trip time.\n"
- title: 4.6.  Scheduling of Packet Transmissions
  contents:
  - "4.6.  Scheduling of Packet Transmissions\n   As TFRC is rate-based, and as operating\
    \ systems typically cannot\n   schedule events precisely, it is necessary to be\
    \ opportunistic about\n   sending data packets so that the correct average rate\
    \ is maintained\n   despite the coarse-grain or irregular scheduling of the operating\n\
    \   system.  To help maintain the correct average sending rate, the TFRC\n   sender\
    \ MAY send some packets before their nominal send time.\n   In addition, the scheduling\
    \ of packet transmissions controls the\n   allowed burstiness of senders after\
    \ an idle or data-limited period.\n   The TFRC sender MAY accumulate sending 'credits'\
    \ for past unused send\n   times; this allows the TFRC sender to send a burst\
    \ of data after an\n   idle or data-limited period.  To compare with TCP, TCP\
    \ may send up to\n   a round-trip time's worth of packets in a single burst, but\
    \ never\n   more.  As examples, packet bursts can be sent by TCP when an ACK\n\
    \   arrives acknowledging a window of data, or when a data-limited sender\n  \
    \ suddenly has a window of data to send after a delay of nearly a\n   round-trip\
    \ time.\n   To limit burstiness, a TFRC implementation MUST prevent bursts of\n\
    \   arbitrary size.  This limit MUST be less than or equal to one round-\n   trip\
    \ time's worth of packets.  A TFRC implementation MAY limit bursts\n   to less\
    \ than a round-trip time's worth of packets.  In addition, a\n   TFRC implementation\
    \ MAY use rate-based pacing to smooth bursts.\n   As an implementation-specific\
    \ example, a sending loop could calculate\n   the correct inter-packet interval,\
    \ t_ipi, as follows:\n      t_ipi = s/X_inst;\n   Let t_now be the current time\
    \ and i be a natural number, i = 0, 1,\n   ..., with t_i the nominal send time\
    \ for the i-th packet.  Then, the\n   nominal send time t_(i+1) would derive recursively\
    \ as:\n      t_0 = t_now,\n      t_(i+1) = t_i + t_ipi.\n   For TFRC senders allowed\
    \ to accumulate sending credits for unused\n   send time over the last T seconds,\
    \ the sender would be allowed to use\n   unused nominal send times t_j for t_j\
    \ < now - T, for T set to the\n   round-trip time.\n"
- title: 5.  Calculation of the Loss Event Rate (p)
  contents:
  - "5.  Calculation of the Loss Event Rate (p)\n   Obtaining an accurate and stable\
    \ measurement of the loss event rate\n   is of primary importance for TFRC.  Loss\
    \ rate measurement is\n   performed at the receiver, based on the detection of\
    \ lost or marked\n   packets from the sequence numbers of arriving packets.  We\
    \ describe\n   this process before describing the rest of the receiver protocol.\
    \  If\n   the receiver has not yet detected a lost or marked packet, then the\n\
    \   receiver does not calculate the loss event rate, but reports a loss\n   event\
    \ rate of zero.\n"
- title: 5.1.  Detection of Lost or Marked Packets
  contents:
  - "5.1.  Detection of Lost or Marked Packets\n   TFRC assumes that all packets contain\
    \ a sequence number that is\n   incremented by one for each packet that is sent.\
    \  For the purposes of\n   this specification, it is REQUIRED that if a lost packet\
    \ is\n   retransmitted, the retransmission is given a new sequence number that\n\
    \   is the latest in the transmission sequence, and not the same sequence\n  \
    \ number as the packet that was lost.  If a transport protocol has the\n   requirement\
    \ that it must retransmit with the original sequence\n   number, then the transport\
    \ protocol designer must figure out how to\n   distinguish delayed from retransmitted\
    \ packets and how to detect lost\n   retransmissions.\n   The receiver maintains\
    \ a data structure that keeps track of which\n   packets have arrived and which\
    \ are missing.  For the purposes of this\n   specification, we assume that the\
    \ data structure consists of a list\n   of packets that have arrived along with\
    \ the receiver timestamp when\n   each packet was received.  In practice, this\
    \ data structure will\n   normally be stored in a more compact representation,\
    \ but this is\n   implementation-specific.\n   The loss of a packet is detected\
    \ by the arrival of at least NDUPACK\n   packets with a higher sequence number\
    \ than the lost packet, for\n   NDUPACK set to 3.  The requirement for NDUPACK\
    \ subsequent packets is\n   the same as with TCP, and is to make TFRC more robust\
    \ in the presence\n   of reordering.  In contrast to TCP, if a packet arrives\
    \ late (after\n   NDUPACK subsequent packets arrived) in TFRC, the late packet\
    \ can fill\n   the hole in TFRC's reception record, and the receiver can recalculate\n\
    \   the loss event rate.  Future versions of TFRC might make the\n   requirement\
    \ for NDUPACK subsequent packets adaptive based on\n   experienced packet reordering,\
    \ but such a mechanism is not part of\n   the current specification.\n   For an\
    \ ECN-capable connection, a marked packet is detected as a\n   congestion event\
    \ as soon as it arrives, without having to wait for\n   the arrival of subsequent\
    \ packets.\n   If an ECN-marked packet is preceded by a possibly-lost packet,\
    \ then\n   the first detected congestion event begins with the lost packet.  For\n\
    \   example, if the receiver receives a data packet with sequence number\n   n-1,\
    \ followed by an unmarked data packet with sequence number n+1,\n   and a marked\
    \ data packet with sequence number n+2, then the receiver\n   detects a congestion\
    \ event when it receives the marked packet n+2.\n   The first congestion event\
    \ detected begins with the lost packet n.\n   The guidelines in Section 5.2 below\
    \ are used to determine whether the\n   lost and marked packets belong to the\
    \ same loss event or to separate\n   loss events.\n"
- title: 5.2.  Translation from Loss History to Loss Events
  contents:
  - "5.2.  Translation from Loss History to Loss Events\n   TFRC requires that the\
    \ loss fraction be robust to several consecutive\n   packets lost or marked in\
    \ the same loss event.  This is similar to\n   TCP, which (typically) only performs\
    \ one halving of the congestion\n   window during any single RTT.  Thus, the receiver\
    \ needs to map the\n   packet loss history into a loss event record, where a loss\
    \ event is\n   one or more packets lost or marked in an RTT.  To perform this\n\
    \   mapping, the receiver needs to know the RTT to use, and this is\n   supplied\
    \ periodically by the sender, typically as control information\n   piggy-backed\
    \ onto a data packet.  TFRC is not sensitive to how the\n   RTT measurement sent\
    \ to the receiver is made, but it is RECOMMENDED\n   to use the sender's calculated\
    \ RTT, R, (see Section 4.3) for this\n   purpose.\n   To determine whether a lost\
    \ or marked packet should start a new loss\n   event or be counted as part of\
    \ an existing loss event, we need to\n   compare the sequence numbers and timestamps\
    \ of the packets that\n   arrived at the receiver.  For a marked packet, S_new,\
    \ its reception\n   time, T_new, can be noted directly.  For a lost packet, we\
    \ can\n   interpolate to infer the nominal \"arrival time\".  Assume:\n      S_loss\
    \ is the sequence number of a lost packet.\n      S_before is the sequence number\
    \ of the last packet to arrive,\n      before any packet arrivals with a sequence\
    \ number above S_loss,\n      with a sequence number below S_loss.\n      S_after\
    \ is the sequence number of the first packet to arrive after\n      S_before with\
    \ a sequence number above S_loss.\n      S_max is the largest sequence number.\n\
    \   Therefore, S_before < S_loss < S_after <= S_max.\n      T_loss is the nominal\
    \ estimated arrival time for the lost packet.\n      T_before is the reception\
    \ time of S_before.\n      T_after is the reception time of S_after.\n   Note\
    \ that T_before < T_after.\n   For a lost packet, S_loss, we can interpolate its\
    \ nominal \"arrival\n   time\" at the receiver from the arrival times of S_before\
    \ and S_after.\n   Thus:\n      T_loss = T_before + ( (T_after - T_before)\n \
    \                 * (S_loss - S_before)/(S_after - S_before) );\n   To address\
    \ sequence number wrapping, let S_MAX = 2^b, where b is the\n   bit-length of\
    \ sequence numbers in a given implementation.  In this\n   case, we can interpolate\
    \ the arrival time T_loss as follows:\n      T_loss = T_before +  (T_after - T_before)\n\
    \                  * Dist(S_loss, S_before)/Dist(S_after, S_before)\n   where\n\
    \      Dist(S_A, S_B) = (S_A + S_MAX - S_B) % S_MAX\n   If the lost packet S_old\
    \ was determined to have started the previous\n   loss event, and we have just\
    \ determined that S_new has been lost,\n   then we interpolate the nominal arrival\
    \ times of S_old and S_new,\n   called T_old and T_new, respectively.\n   If T_old\
    \ + R >= T_new, then S_new is part of the existing loss event.\n   Otherwise,\
    \ S_new is the first packet in a new loss event.\n"
- title: 5.3.  The Size of a Loss Interval
  contents:
  - "5.3.  The Size of a Loss Interval\n   After the detection of the first loss event,\
    \ the receiver divides the\n   sequence space into loss intervals.  If a loss\
    \ interval, A, is\n   determined to have started with packet sequence number S_A\
    \ and the\n   next loss interval, B, started with packet sequence number S_B,\
    \ then\n   the number of packets in loss interval A is given by (S_B - S_A).\n\
    \   Thus, loss interval A contains all of the packets transmitted by the\n   sender\
    \ starting with the first packet transmitted in loss interval A\n   and ending\
    \ with but not including the first packet transmitted in\n   loss interval B.\n\
    \   The current loss interval I_0 is defined as the loss interval\n   containing\
    \ the most recent loss event.  If that loss event started\n   with packet sequence\
    \ number S_A, and S_C is the highest received\n   sequence number so far, then\
    \ the size of I_0 is S_C - S_A + 1.  As an\n   example, if the current loss interval\
    \ consists of a single ECN-\n   marked packet, then S_A == S_C, and the size of\
    \ the loss interval is\n   one.\n"
- title: 5.4.  Average Loss Interval
  contents:
  - "5.4.  Average Loss Interval\n   To calculate the loss event rate, p, we first\
    \ calculate the average\n   loss interval.  This is done using a filter that weights\
    \ the n most\n   recent loss event intervals in such a way that the measured loss\n\
    \   event rate changes smoothly.  If the receiver has not yet seen a lost\n  \
    \ or marked packet, then the receiver does not calculate the average\n   loss\
    \ interval.\n   Weights w_0 to w_(n-1) are calculated as:\n        If (i < n/2)\
    \ {\n            w_i = 1;\n        } Else {\n            w_i = 2 * (n-i)/(n+2);\n\
    \        }\n   Thus, if n=8, the values of w_0 to w_7 are:\n      1.0, 1.0, 1.0,\
    \ 1.0, 0.8, 0.6, 0.4, 0.2\n   The value n for the number of loss intervals used\
    \ in calculating the\n   loss event rate determines TFRC's speed in responding\
    \ to changes in\n   the level of congestion.  It is RECOMMENDED to set the value\
    \ n to 8.\n   TFRC SHOULD NOT use values of n greater than 8 for traffic that\
    \ might\n   compete in the global Internet with TCP.  At the very least, safe\n\
    \   operation with values of n greater than 8 would require a slight\n   change\
    \ to TFRC's mechanisms to include a more severe response to two\n   or more round-trip\
    \ times with heavy packet loss.\n   When calculating the average loss interval,\
    \ we need to decide whether\n   to include the current loss interval.  We only\
    \ include the current\n   loss interval if it is sufficiently large to increase\
    \ the average\n   loss interval.\n   Let the most recent loss intervals be I_0\
    \ to I_k, where I_0 is the\n   current loss interval.  If there have been at least\
    \ n loss intervals,\n   then k is set to n; otherwise, k is the maximum number\
    \ of loss\n   intervals seen so far.  We calculate the average loss interval I_mean\n\
    \   as follows:\n      I_tot0 = 0;\n      I_tot1 = 0;\n      W_tot = 0;\n    \
    \  for (i = 0 to k-1) {\n          I_tot0 = I_tot0 + (I_i * w_i);\n          W_tot\
    \ = W_tot + w_i;\n      }\n      for (i = 1 to k) {\n          I_tot1 = I_tot1\
    \ + (I_i * w_(i-1));\n      }\n      I_tot = max(I_tot0, I_tot1);\n      I_mean\
    \ = I_tot/W_tot;\n   The loss event rate, p is simply:\n      p = 1 / I_mean;\n"
- title: 5.5.  History Discounting
  contents:
  - "5.5.  History Discounting\n   As described in Section 5.4, when there have been\
    \ at least n loss\n   intervals, the most recent loss interval is only assigned\
    \ 1/(0.75*n)\n   of the total weight in calculating the average loss interval,\n\
    \   regardless of the size of the most recent loss interval.  This\n   section\
    \ describes an OPTIONAL history discounting mechanism,\n   discussed further in\
    \ [FHPW00a] and [W00], that allows the TFRC\n   receiver to adjust the weights,\
    \ concentrating more of the relative\n   weight on the most recent loss interval,\
    \ when the most recent loss\n   interval is more than twice as large as the computed\
    \ average loss\n   interval.\n   To carry out history discounting, we associate\
    \ a discount factor,\n   DF_i, with each loss interval, L_i, for i > 0, where\
    \ each discount\n   factor is a floating point number.  The discount array maintains\
    \ the\n   cumulative history of discounting for each loss interval.  At the\n\
    \   beginning, the values of DF_i in the discount array are initialized\n   to\
    \ 1:\n      for (i = 0 to n) {\n          DF_i = 1;\n      }\n   History discounting\
    \ also uses a general discount factor, DF, also a\n   floating point number, that\
    \ is also initialized to 1.  First, we show\n   how the discount factors are used\
    \ in calculating the average loss\n   interval, and then we describe, later in\
    \ this section, how the\n   discount factors are modified over time.\n   As described\
    \ in Section 5.4, the average loss interval is calculated\n   using the n previous\
    \ loss intervals I_1, ..., I_n and the current\n   loss interval I_0.  The computation\
    \ of the average loss interval\n   using the discount factors is a simple modification\
    \ of the procedure\n   in Section 5.4, as follows:\n      I_tot0 = I_0 * w_0;\n\
    \      I_tot1 = 0;\n      W_tot0 = w_0;\n      W_tot1 = 0;\n      for (i = 1 to\
    \ n-1) {\n          I_tot0 = I_tot0 + (I_i * w_i * DF_i * DF);\n          W_tot0\
    \ = W_tot0 + w_i * DF_i * DF;\n      }\n      for (i = 1 to n) {\n          I_tot1\
    \ = I_tot1 + (I_i * w_(i-1) * DF_i);\n          W_tot1 = W_tot1 + w_(i-1) * DF_i;\n\
    \      }\n      p = min(W_tot0/I_tot0, W_tot1/I_tot1);\n   The general discounting\
    \ factor, DF, is updated on every packet\n   arrival as follows.  First, the receiver\
    \ computes the weighted\n   average I_mean of the loss intervals I_1, ..., I_n:\n\
    \      I_tot = 0;\n      W_tot = 0;\n      for (i = 1 to n) {\n          W_tot\
    \ = W_tot + w_(i-1) * DF_i;\n          I_tot = I_tot + (I_i * w_(i-1) * DF_i);\n\
    \      }\n      I_mean = I_tot / W_tot;\n   This weighted average I_mean is compared\
    \ to I_0, the size of current\n   loss interval.  If I_0 is greater than twice\
    \ I_mean, then the new\n   loss interval is considerably larger than the old ones,\
    \ and the\n   general discount factor, DF, is updated to decrease the relative\n\
    \   weight on the older intervals, as follows:\n      if (I_0 > 2 * I_mean) {\n\
    \          DF = 2 * I_mean/I_0;\n          if (DF < THRESHOLD) {\n           \
    \   DF = THRESHOLD;\n          }\n      } else {\n          DF = 1;\n      }\n\
    \   A nonzero value for THRESHOLD ensures that older loss intervals from\n   an\
    \ earlier time of high congestion are not discounted entirely.  We\n   recommend\
    \ a THRESHOLD of 0.25.  Note that with each new packet\n   arrival, I_0 will increase\
    \ further, and the discount factor DF will\n   be updated.\n   When a new loss\
    \ event occurs, the current interval shifts from I_0 to\n   I_1, loss interval\
    \ I_i shifts to interval I_(i+1), and the loss\n   interval I_n is forgotten.\
    \  The previous discount factor DF has to be\n   incorporated into the discount\
    \ array.  Because DF_i carries the\n   discount factor associated with loss interval\
    \ I_i, the DF_i array has\n   to be shifted as well.  This is done as follows:\n\
    \      for (i = 1 to n) {\n          DF_i = DF * DF_i;\n      }\n      for (i\
    \ = n-1 to 0 step -1) {\n          DF_(i+1) = DF_i;\n      }\n      I_0 = 1;\n\
    \      DF_0 = 1;\n      DF = 1;\n   This completes the description of the optional\
    \ history discounting\n   mechanism.  We emphasize that this is an OPTIONAL mechanism\
    \ whose\n   sole purpose is to allow TFRC to respond somewhat more quickly to\
    \ the\n   sudden absence of congestion, as represented by a long current loss\n\
    \   interval.\n"
- title: 6.  Data Receiver Protocol
  contents:
  - "6.  Data Receiver Protocol\n   The receiver periodically sends feedback messages\
    \ to the sender.\n   Feedback packets SHOULD normally be sent at least once per\
    \ RTT,\n   unless the sender is sending at a rate of less than one packet per\n\
    \   RTT, in which case a feedback packet SHOULD be sent for every data\n   packet\
    \ received.  A feedback packet SHOULD also be sent whenever a\n   new loss event\
    \ is detected without waiting for the end of an RTT, and\n   whenever an out-of-order\
    \ data packet is received that removes a loss\n   event from the history.\n  \
    \ If the sender is transmitting at a high rate (many packets per RTT),\n   there\
    \ may be some advantages to sending periodic feedback messages\n   more than once\
    \ per RTT as this allows faster response to changing RTT\n   measurements and\
    \ more resilience to feedback packet loss.\n   If the receiver was sending k feedback\
    \ packets per RTT, for k>1, step\n   (4) of Section 6.2 would be modified to set\
    \ the feedback timer to\n   expire after R_m/k seconds.  However, each feedback\
    \ packet would\n   still report the receiver rate over the last RTT, not over\
    \ a fraction\n   of an RTT.  In this document, we do not specify the modifications\n\
    \   that might be required for a receiver sending more than one feedback\n   packet\
    \ per RTT.  We note that there is little gain from sending a\n   large number\
    \ of feedback messages per RTT.\n"
- title: 6.1.  Receiver Behavior When a Data Packet Is Received
  contents:
  - "6.1.  Receiver Behavior When a Data Packet Is Received\n   When a data packet\
    \ is received, the receiver performs the following\n   steps:\n   1)  Add the\
    \ packet to the packet history.\n   2)  Check if done: If the new packet results\
    \ in the detection of a\n       new loss event, or if no feedback packet was sent\
    \ when the\n       feedback timer last expired, go to step 3.  Otherwise, no action\n\
    \       need be performed (unless the optimization in the next paragraph\n   \
    \    is used), so exit the procedure.\n       An OPTIONAL optimization might check\
    \ to see if the arrival of the\n       packet caused a hole in the packet history\
    \ to be filled, and\n       consequently, two loss intervals were merged into\
    \ one.  If this\n       is the case, the receiver might also send feedback immediately.\n\
    \       The effects of such an optimization are normally expected to be\n    \
    \   small.\n   3)  Calculate p: Let the previous value of p be p_prev.  Calculate\n\
    \       the new value of p as described in Section 5.\n   4)  Expire feedback\
    \ timer: If p > p_prev, cause the feedback timer to\n       expire and perform\
    \ the actions described in Section 6.2.\n       If p <= p_prev and no feedback\
    \ packet was sent when the feedback\n       timer last expired, cause the feedback\
    \ timer to expire and\n       perform the actions described in Section 6.2.  If\
    \ p <= p_prev and\n       a feedback packet was sent when the feedback timer last\
    \ expired,\n       no action need be performed.\n"
- title: 6.2.  Expiration of Feedback Timer
  contents:
  - "6.2.  Expiration of Feedback Timer\n   When the feedback timer at the receiver\
    \ expires, the action to be\n   taken depends on whether data packets have been\
    \ received since the\n   last feedback was sent.\n   For the m-th expiration of\
    \ the feedback timer, let the maximum\n   sequence number of a packet at the receiver,\
    \ so far, be S_m and the\n   value of the RTT measurement included in packet S_m\
    \ be R_m.  As\n   described in Section 3.2.1, R_m is the sender's most recent\
    \ estimate\n   of the round-trip time, as reported in data packets.  If data packets\n\
    \   have been received since the previous feedback was sent, the receiver\n  \
    \ performs the following steps:\n   1)  Calculate the average loss event rate\
    \ using the algorithm\n       described in Section 5.\n   2)  Calculate the measured\
    \ receive rate, X_recv, based on the packets\n       received within the previous\
    \ R_(m-1) seconds.  This is performed\n       whether the feedback timer expired\
    \ at its normal time or expired\n       early due to a new lost or marked packet\
    \ (i.e., step (3) in\n       Section 6.1).\n       In the typical case, when the\
    \ receiver is sending only one\n       feedback packet per round-trip time and\
    \ the feedback timer did\n       not expire early due to a new lost packet, then\
    \ the time interval\n       since the feedback timer last expired would be R_(m-1)\
    \ seconds.\n       We note that when the feedback timer expires early due to a\
    \ new\n       lost or marked packet, the time interval since the feedback timer\n\
    \       last expired is likely to be smaller than R_(m-1) seconds.\n       For\
    \ ease of implementation, if the time interval since the\n       feedback timer\
    \ last expired is not R_(m-1) seconds, the receive\n       rate MAY be calculated\
    \ over a longer time interval, the time\n       interval going back to the most\
    \ recent feedback timer expiration\n       that was at least R_(m-1) seconds ago.\n\
    \   3)  Prepare and send a feedback packet containing the information\n      \
    \ described in Section 3.2.2.\n   4)  Restart the feedback timer to expire after\
    \ R_m seconds.\n   Note that rule 2) above gives a minimum value for the measured\n\
    \   receive rate X_recv of one packet per round-trip time.  If the sender\n  \
    \ is limited to a sending rate of less than one packet per round-trip\n   time,\
    \ this will be due to the loss event rate, not from a limit\n   imposed by the\
    \ measured receive rate at the receiver.\n   If no data packets have been received\
    \ since the last feedback was\n   sent, then no feedback packet is sent, and the\
    \ feedback timer is\n   restarted to expire after R_m seconds.\n"
- title: 6.3.  Receiver Initialization
  contents:
  - "6.3.  Receiver Initialization\n   The receiver is initialized by the first data\
    \ packet that arrives at\n   the receiver.  Let the sequence number of this packet\
    \ be i.\n   When the first packet is received:\n   o   Set p = 0.\n   o   Set\
    \ X_recv = 0.\n   o   Prepare and send a feedback packet.\n   o   Set the feedback\
    \ timer to expire after R_i seconds.\n   If the first data packet does not contain\
    \ an estimate R_i of the\n   round-trip time, then the receiver sends a feedback\
    \ packet for every\n   arriving data packet until a data packet arrives containing\
    \ an\n   estimate of the round-trip time.\n   If the sender is using a coarse-grained\
    \ timestamp that increments\n   every quarter of a round-trip time, then a feedback\
    \ timer is not\n   needed, and the following procedure from RFC 4342 is used to\n\
    \   determine when to send feedback messages.\n   o   Whenever the receiver sends\
    \ a feedback message, the receiver sets\n       a local variable last_counter\
    \ to the greatest received value of\n       the window counter since the last\
    \ feedback message was sent, if\n       any data packets have been received since\
    \ the last feedback\n       message was sent.\n   o   If the receiver receives\
    \ a data packet with a window counter\n       value greater than or equal to last_counter\
    \ + 4, then the\n       receiver sends a new feedback packet.  (\"Greater\" and\
    \ \"greatest\"\n       are measured in circular window counter space.)\n"
- title: 6.3.1.  Initializing the Loss History after the First Loss Event
  contents:
  - "6.3.1.  Initializing the Loss History after the First Loss Event\n   This section\
    \ describes the procedure that MUST be used for\n   initializing the loss history\
    \ after the first loss event.\n   The number of packets until the first loss cannot\
    \ be used to compute\n   the allowed sending rate directly, as the sending rate\
    \ changes\n   rapidly during this time.  TFRC assumes that the correct data rate\n\
    \   after the first loss is half of the maximum sending rate before the\n   loss\
    \ occurred.  TFRC approximates this target rate, X_target, by the\n   maximum\
    \ value of X_recv so far.  (For slow-start, for a particular\n   round-trip time,\
    \ the sender's sending rate is generally twice the\n   receiver's receive rate\
    \ for data sent over the previous round-trip\n   time.)\n   After the first loss,\
    \ instead of initializing the first loss interval\n   to the number of packets\
    \ sent until the first loss, the TFRC receiver\n   calculates the loss interval\
    \ that would be required to produce the\n   data rate X_target, and uses this\
    \ synthetic loss interval to seed the\n   loss history mechanism.\n   TFRC does\
    \ this by finding some value, p, for which the throughput\n   equation in Section\
    \ 3.1 gives a sending rate within 5% of X_target,\n   given the round-trip time\
    \ R, and the first loss interval is then set\n   to 1/p.  If the receiver knows\
    \ the segment size, s, used by the\n   sender, then the receiver MAY use the throughput\
    \ equation for X;\n   otherwise, the receiver MAY measure the receive rate in\
    \ packets per\n   second instead of bytes per second for this purpose, and use\
    \ the\n   throughput equation for X_pps.  (The 5% tolerance is introduced\n  \
    \ simply because the throughput equation is difficult to invert, and we\n   want\
    \ to reduce the costs of calculating p numerically.)\n   Special care is needed\
    \ for initializing the first loss interval when\n   the first data packet is lost\
    \ or marked.  When the first data packet\n   is lost in TCP, the TCP sender retransmits\
    \ the packet after the\n   retransmit timer expires.  If TCP's first data packet\
    \ is ECN-marked,\n   the TCP sender resets the retransmit timer, and sends a new\
    \ data\n   packet only when the retransmit timer expires [RFC3168] (Section\n\
    \   6.1.2).  For TFRC, if the first data packet is lost or ECN-marked,\n   then\
    \ the first loss interval consists of the null interval with no\n   data packets.\
    \  In this case, the loss interval length for this (null)\n   loss interval SHOULD\
    \ be set to give a similar sending rate to that of\n   TCP, as specified in the\
    \ paragraph below.\n   When the first TFRC loss interval is null, meaning that\
    \ the first\n   data packet is lost or ECN-marked, in order to follow the behavior\
    \ of\n   TCP, TFRC wants the allowed sending rate to be 1 packet every two\n \
    \  round-trip times, or equivalently, 0.5 packets per RTT.  Thus, the\n   TFRC\
    \ receiver calculates the loss interval that would be required to\n   produce\
    \ the target rate X_target of 0.5/R packets per second, for the\n   round-trip\
    \ time R, and uses this synthetic loss interval for the\n   first loss interval.\
    \  The TFRC receiver uses 0.5/R packets per second\n   as the minimum value for\
    \ X_target when initializing the first loss\n   interval.\n   We note that even\
    \ though the TFRC receiver reports a synthetic loss\n   interval after the first\
    \ loss event, the TFRC receiver still reports\n   the measured receive rate X_recv,\
    \ as specified in Section 6.2 above.\n"
- title: 7.  Sender-Based Variants
  contents:
  - "7.  Sender-Based Variants\n   In a sender-based variant of TFRC, the receiver\
    \ uses reliable\n   delivery to send information about packet losses to the sender,\
    \ and\n   the sender computes the packet loss rate and the acceptable transmit\n\
    \   rate.\n   The main advantage of a sender-based variant of TFRC is that the\n\
    \   sender does not have to trust the receiver's calculation of the\n   packet\
    \ loss rate.  However, with the requirement of reliable delivery\n   of loss information\
    \ from the receiver to the sender, a sender-based\n   TFRC would have much tighter\
    \ constraints on the transport protocol in\n   which it is embedded.\n   In contrast,\
    \ the receiver-based variant of TFRC specified in this\n   document is robust\
    \ to the loss of feedback packets, and therefore\n   does not require the reliable\
    \ delivery of feedback packets.  It is\n   also better suited for applications\
    \ where it is desirable to offload\n   work from the server to the client as much\
    \ as possible.\n   RFC 4340 and RFC 4342 together specify DCCP's CCID 3, which\
    \ can be\n   used as a sender-based variant of TFRC.  In CCID 3, each feedback\n\
    \   packet from the receiver contains a Loss Intervals option, reporting\n   the\
    \ lengths of the most recent loss intervals.  Feedback packets may\n   also include\
    \ the Ack Vector option, allowing the sender to determine\n   exactly which packets\
    \ were dropped or marked and to check the\n   information reported in the Loss\
    \ Intervals options.  The Ack Vector\n   option can also include ECN Nonce Echoes,\
    \ allowing the sender to\n   verify the receiver's report of having received an\
    \ unmarked data\n   packet.  The Ack Vector option allows the sender to see for\
    \ itself\n   which data packets were lost or ECN-marked, to determine loss\n \
    \  intervals, and to calculate the loss event rate.  Section 9 of RFC\n   4342\
    \ discusses issues in the sender verifying information reported by\n   the receiver.\n"
- title: 8.  Implementation Issues
  contents:
  - "8.  Implementation Issues\n   This document has specified the TFRC congestion\
    \ control mechanism,\n   for use by applications and transport protocols.  This\
    \ section\n   mentions briefly some of the implementation issues.\n"
- title: 8.1.  Computing the Throughput Equation
  contents:
  - "8.1.  Computing the Throughput Equation\n   For t_RTO = 4*R and b = 1, the throughput\
    \ equation in Section 3.1 can\n   be expressed as follows:\n                 \
    \ s\n      X_Bps =  --------\n               R * f(p)\n   for\n      f(p) =  sqrt(2*p/3)\
    \ + (12*sqrt(3*p/8) * p * (1+32*p^2)).\n   A table lookup could be used for the\
    \ function f(p).\n   Many of the multiplications (e.g., q and 1-q for the round-trip\
    \ time\n   average, a factor of 4 for the timeout interval) are or could be by\n\
    \   powers of two, and therefore could be implemented as simple shift\n   operations.\n"
- title: 8.2.  Sender Behavior When a Feedback Packet Is Received
  contents:
  - "8.2.  Sender Behavior When a Feedback Packet Is Received\n   This section discusses\
    \ implementation issues for sender behavior when\n   a feedback packet is received,\
    \ from Section 4.3.\n"
- title: 8.2.1.  Determining If an Interval Was a Data-Limited Interval
  contents:
  - "8.2.1.  Determining If an Interval Was a Data-Limited Interval\n   When a feedback\
    \ packet is received, the sender has to determine if\n   the entire interval covered\
    \ by that feedback packet was a data-\n   limited period.  This section discusses\
    \ one possible implementation\n   for the sender to determine if the interval\
    \ covered by a feedback\n   packet was a data-limited period.\n   If the feedback\
    \ packets all report the timestamp of the last data\n   packet received, then\
    \ let t_new be the timestamp reported by this\n   feedback packet.  Because all\
    \ feedback packets cover an interval of\n   at least a round-trip time, it is\
    \ sufficient for the sender to\n   determine if there was any time in the period\
    \ (t_old, t_new] when the\n   sender was not data-limited, for R the sender's\
    \ estimate of the\n   round-trip time, and for t_old set to t_new - R.  (This\
    \ procedure\n   estimates the interval covered by the feedback packet, rather\
    \ than\n   computing it exactly.  This seems fine to us.)\n   The pseudocode for\
    \ determining if the sender was data-limited over\n   the entire interval covered\
    \ in a feedback packet is given below.  The\n   variables NotLimited1 and NotLimited2\
    \ both represent times when the\n   sender was *not* data-limited.\n   Initialization:\n\
    \       NotLimited1 = NotLimited2 = t_new = t_next = 0;\n       t_now = current\
    \ time;\n   After sending a segment:\n       If (sender has sent all it is allowed\
    \ to send) {\n           // Sender is not data-limited at this instant.\n    \
    \       If NotLimited1 <= t_new\n               // Goal: NotLimited1 > t_new.\n\
    \               NotLimited1 = t_now;\n           Else if (NotLimited2 <= t_next)\n\
    \               // Goal: NotLimited2 > t_next.\n               NotLimited2 = t_now;\n\
    \       }\n   When a feedback packet is received, is this interval data-limited:\n\
    \       t_new = timestamp reported in feedback packet.\n       t_old = t_new -\
    \ R.                         // local variable\n       t_next = t_now;\n     \
    \  If ((t_old < NotLimited1 <= t_new) or\n           (t_old < NotLimited2 <= t_new))\n\
    \           This was not a data-limited interval;\n       Else\n           This\
    \ was a data-limited interval.\n       If (NotLimited1 <= t_new && NotLimited2\
    \ > t_new)\n           NotLimited1 = NotLimited2;\n   Transmission times refer\
    \ to transmission of a segment or segments to\n   the layer below.\n   Between\
    \ feedback packets, (t_old, t_new] gives the transmission time\n   interval estimated\
    \ to be covered by the most recent feedback packet,\n   and t_next gives a time\
    \ at least a round-trip time greater than\n   t_new.  The next feedback packet\
    \ can be expected to cover roughly the\n   interval (t_new, t_next] (unless the\
    \ receiver sends the feedback\n   packet early because it is reporting a new loss\
    \ event).  The goal is\n   for NotLimited1 to save a non-data-limited time in\
    \ (t_new, t_next],\n   if there was one, and for NotLimited2 to save a non-data-limited\
    \ time\n   after t_next.\n   When a feedback packet was received, if either NotLimited1\
    \ or\n   NotLimited2 is in the time interval covered by the feedback packet,\n\
    \   then the interval is not a data-limited interval; the sender was not\n   data-limited\
    \ at least once during that time interval.  If neither\n   NotLimited1 nor NotLimited2\
    \ is in the time interval covered by a\n   feedback packet, then the sender is\
    \ assumed to have been data-limited\n   over that time interval.\n   We note that\
    \ this procedure is a heuristic, and in some cases the\n   sender might not determine\
    \ correctly if the sender was data-limited\n   over the entire interval covered\
    \ by the feedback packet.  This\n   heuristic does not address the possible complications\
    \ of reordering.\n   That seems acceptable to us.  In order to improve its accuracy\
    \ in\n   identifying if the entire interval covered by a feedback packet was a\n\
    \   data-limited interval, the sender could save more NotLimited times.\n   In\
    \ some implementations of TFRC, the sender sends coarse-grained\n   timestamps\
    \ that increment every quarter of a round-trip time, and the\n   feedback packet\
    \ reports the greatest valid sequence number received\n   so far instead of reporting\
    \ the timestamp of the last packet\n   received.  In this case, the sender can\
    \ maintain per-packet state to\n   determine t_new (the time that the acknowledged\
    \ packet was sent), or\n   the sender can estimate t_new from its estimate of\
    \ the round-trip\n   time and the elapsed time t_delay reported by the feedback\
    \ packet.\n"
- title: 8.2.2.  Maintaining X_recv_set
  contents:
  - "8.2.2.  Maintaining X_recv_set\n   To reduce the complexity of maintaining X_recv_set,\
    \ it is sufficient\n   to limit X_recv_set to at most N=3 elements.  In this case,\
    \ the\n   procedure Update X_recv_set() would be modified as follows:\n      Update\
    \ X_recv_set():\n          Add X_recv to X_recv_set;\n          Delete from X_recv_set\
    \ values older than\n              two round-trip times.\n          Keep only\
    \ the most recent N values.\n   Maintaining at most *two* elements in X_recv_set\
    \ would be sufficient\n   for the sender to save an old value of X_recv from before\
    \ a data-\n   limited period, and to allow the sender not to be limited by the\n\
    \   first feedback packet after an idle period (reporting a receive rate\n   of\
    \ one packet per round-trip time).  However, it is *possible* that\n   maintaining\
    \ at most two elements in X_recv_set would not give quite\n   as good performance\
    \ as maintaining at most three elements.\n   Maintaining three elements in X_recv_set\
    \ would allow X_recv_set to\n   contain X_recv values from two successive feedback\
    \ packets, plus a\n   more recent X_recv value from a loss event.\n"
- title: 8.3.  Sending Packets before Their Nominal Send Time
  contents:
  - "8.3.  Sending Packets before Their Nominal Send Time\n   This section discusses\
    \ one possible scheduling mechanism for a sender\n   in an operating system with\
    \ a coarse-grained timing granularity (from\n   Section 4.6).\n   Let t_gran be\
    \ the scheduling timer granularity of the operating\n   system.  Let t_ipi be\
    \ the inter-packet interval, as specified in\n   Section 4.6.  If the operating\
    \ system has a coarse timer granularity\n   or otherwise cannot support short\
    \ t_ipi intervals, then either the\n   TFRC sender will be restricted to a sending\
    \ rate of at most 1 packet\n   every t_gran seconds, or the TFRC sender must be\
    \ allowed to send\n   short bursts of packets.  In addition to allowing the sender\
    \ to\n   accumulate sending credits for past unused send times, it can be\n  \
    \ useful to allow the sender to send a packet before its scheduled send\n   time,\
    \ as described in the section below.\n   A parameter, t_delta, may be used to\
    \ allow a packet to be sent before\n   its nominal send time.  Consider an application\
    \ that becomes idle and\n   requests re-scheduling for time t_i = t_(i-1) + t_ipi,\
    \ for t_(i-1)\n   the send time for the previous packet.  When the application\
    \ is\n   rescheduled, it checks the current time, t_now.  If\n   (t_now > t_i\
    \ - t_delta), then packet i is sent.  When the nominal\n   send time, t_i, of\
    \ the next packet is calculated, it may already be\n   the case that t_now > t_i\
    \ - t_delta.  In such a case, the packet\n   would be sent immediately.\n   In\
    \ order to send at most one packet before its nominal send time, and\n   never\
    \ to send a packet more than a round-trip time before its nominal\n   send time,\
    \ the parameter t_delta would be set as follows:\n      t_delta = min(t_ipi, t_gran,\
    \ rtt)/2;\n   (The scheduling granularity t_gran is 10 ms on some older Unix\n\
    \   systems.)\n   As an example, consider a TFRC flow with an allowed sending\
    \ rate X of\n   10 packets per round-trip time (PPR), a round-trip time of 100\
    \ ms, a\n   system with a scheduling granularity t_gran of 10 ms, and the ability\n\
    \   to accumulate unused sending credits for a round-trip time.  In this\n   case,\
    \ t_ipi is 1 ms.  The TFRC sender would be allowed to send\n   packets 0.5 ms\
    \ before their nominal sending time, and would be\n   allowed to save unused sending\
    \ credits for 100 ms.  The scheduling\n   granularity of 10 ms would not significantly\
    \ affect the performance\n   of the connection.\n   As a different example, consider\
    \ a TFRC flow with a scheduling\n   granularity greater than the round-trip time,\
    \ for example, with a\n   round-trip time of 0.1 ms and a system with a scheduling\
    \ granularity\n   of 1 ms, and with the ability to accumulate unused sending credits\n\
    \   for a round-trip time.  The TFRC sender would be allowed to save\n   unused\
    \ sending credits for 0.1 ms.  If the scheduling granularity\n   *did not* affect\
    \ the sender's response to an incoming feedback\n   packet, then the TFRC sender\
    \ would be able to send an RTT of data (as\n   determined by the allowed sending\
    \ rate) each RTT, in response to\n   incoming feedback packets.  In this case,\
    \ the coarse scheduling\n   granularity would not significantly reduce the sending\
    \ rate, but the\n   sending rate would be bursty, with a round-trip time of data\
    \ sent in\n   response to each feedback packet.\n   However, performance would\
    \ be different, in this case, if the\n   operating system scheduling granularity\
    \ affected the sender's\n   response to feedback packets as well as the general\
    \ scheduling of the\n   sender.  In this case, the sender's performance would\
    \ be severely\n   limited by the scheduling granularity being greater than the\
    \ round-\n   trip time, with the sender able to send an RTT of data, at the\n\
    \   allowed sending rate, at most once every 1 ms.  This restriction of\n   the\
    \ sending rate is an unavoidable consequence of allowing burstiness\n   of at\
    \ most a round-trip time of data.\n"
- title: 8.4.  Calculation of the Average Loss Interval
  contents:
  - "8.4.  Calculation of the Average Loss Interval\n   The calculation of the average\
    \ loss interval in Section 5.4 involves\n   multiplications by the weights w_0\
    \ to w_(n-1), which for n=8 are:\n      1.0, 1.0, 1.0, 1.0, 0.8, 0.6, 0.4, 0.2.\n\
    \   With a minor loss of smoothness, it would be possible to use weights\n   that\
    \ were powers of two or sums of powers of two, e.g.,\n      1.0, 1.0, 1.0, 1.0,\
    \ 0.75, 0.5, 0.25, 0.25.\n"
- title: 8.5.  The Optional History Discounting Mechanism
  contents:
  - "8.5.  The Optional History Discounting Mechanism\n   The optional history discounting\
    \ mechanism described in Section 5.5\n   is used in the calculation of the average\
    \ loss rate.  The history\n   discounting mechanism is invoked only when there\
    \ has been an\n   unusually long interval with no packet losses.  For a more efficient\n\
    \   operation, the discount factor, DF_i, could be restricted to be a\n   power\
    \ of two.\n"
- title: 9.  Changes from RFC 3448
  contents:
  - '9.  Changes from RFC 3448

    '
- title: 9.1.  Overview of Changes
  contents:
  - "9.1.  Overview of Changes\n   This section summarizes the changes from RFC 3448.\
    \  At a high level,\n   the main change is to add mechanisms to address the case\
    \ of a data-\n   limited sender.  This document also explicitly allows the TFRC\
    \ sender\n   to accumulate up to a round-trip time of unused send credits, and\
    \ as\n   a result to send a burst of packets if data arrives from the\n   application\
    \ in a burst after a data-limited period.  This issue was\n   not explicitly addressed\
    \ in RFC 3448.\n   This document changes RFC 3448 to incorporate TCP's higher\
    \ initial\n   sending rates from RFC 3390.  This document also changes RFC 3448\
    \ to\n   allow RFC 4342's use of a coarse-grained timestamp on data packets\n\
    \   instead of a more fine-grained timestamp.\n   Other changes address corner\
    \ cases involving slow-start, the response\n   when the first data packet is dropped,\
    \ and the like.  This document\n   also incorporates the items in the RFC 3448\
    \ Errata.\n   This section is non-normative;  the normative text is in the cited\n\
    \   sections.\n"
- title: 9.2.  Changes in Each Section
  contents:
  - "9.2.  Changes in Each Section\n   Section 4.1, estimating the average segment\
    \ size: Section 4.1 was\n   modified to give a specific algorithm that could be\
    \ used for\n   estimating the average segment size.\n   Section 4.2, update to\
    \ the initial sending rate: In RFC 3448, the\n   initial sending rate was two\
    \ packets per round-trip time.  In this\n   document, the initial sending rate\
    \ can be as high as four packets per\n   round-trip time, following RFC 3390.\
    \  The initial sending rate was\n   changed to be in terms of the segment size\
    \ s, not in terms of the\n   MSS.\n   Section 4.2 now says that tld, the Time\
    \ Last Doubled during slow-\n   start, can be initialized to either 0 or to -1.\
    \  Section 4.2 was also\n   clarified to say that RTT measurements do not only\
    \ come from feedback\n   packets; they could also come from other places, such\
    \ as the SYN\n   exchange.\n   Section 4.3, response to feedback packets: Section\
    \ 4.3 was modified\n   to change the way that the receive rate is used in limiting\
    \ the\n   sender's allowed sending rate, by using the set of receive rate\n  \
    \ values of the last two round-trip times, and initializing the set of\n   receive\
    \ rate values by a large value.\n   The larger initial sending rate in Section\
    \ 4.2 is of little use if\n   the receiver sends a feedback packet after the first\
    \ packet is\n   received, and the sender, in response, reduces the allowed sending\n\
    \   rate to at most two packets per RTT, which would be twice the receive\n  \
    \ rate.  Because of the change in the sender's processing of the\n   receive rate,\
    \ the sender now does not reduce the allowed sending rate\n   to twice the reported\
    \ receive rate in response to the first feedback\n   packet.\n   During a data-limited\
    \ period, the sender saves the receive rate\n   reported from just before the\
    \ data-limited period, if it is larger\n   than the receive rate during the data-limited\
    \ period.  The sender\n   also reduces the saved values in X_recv_set in response\
    \ to a loss\n   during a data-limited period.  Appendix C discusses this response\n\
    \   further.\n   Section 4.4, response to an idle period: Following Section 5.1\
    \ from\n   [RFC4342], this document specifies that when the sending rate is\n\
    \   reduced after an idle period that covers the period since the\n   nofeedback\
    \ timer was set, the allowed sending rate is not reduced\n   below the initial\
    \ sending rate.  (In Section 4.4, the variable\n   recover_rate is set to the\
    \ initial sending rate.)\n   Section 4.4, correction from [RFC3448Err].  RFC 3448\
    \ had\n   contradictory text about whether the sender halved its sending rate\n\
    \   after *two* round-trip times without receiving a feedback report, or\n   after\
    \ *four* round-trip times.  This document clarifies that the\n   sender halves\
    \ its sending rate after four round-trip times without\n   receiving a feedback\
    \ report [RFC3448Err].\n   Section 4.4, clarification for slow-start: Section\
    \ 4.4 was clarified\n   to specify that on the expiration of the nofeedback timer,\
    \ if p = 0,\n   X_Bps cannot be used, because the sender does not yet have a value\n\
    \   for X_Bps.  Section 4.4 was also clarified to check the case when the\n  \
    \ sender does not yet have an RTT sample, but has sent a packet since\n   the\
    \ nofeedback timer was set.\n   Section 4.6: credits for unused send time:\n \
    \  Section 4.6 has been clarified to say that the TFRC sender gets to\n   accumulate\
    \ up to an RTT of credits for unused send time.  Section 4.6\n   was also rewritten\
    \ to clarify what is specification and what is\n   implementation.\n   Section\
    \ 5.4, clarification: Section 5.4 was modified to clarify the\n   receiver's calculation\
    \ of the average loss interval when the receiver\n   has not yet seen n loss intervals.\n\
    \   Section 5.5, correction: Section 5.5 was corrected to say that the\n   loss\
    \ interval I_0 includes all transmitted packets, including lost\n   and marked\
    \ packets (as defined in Section 5.3 in the general\n   definition of loss intervals).\n\
    \   Section 5.5, correction from [RFC3448Err]: A line in Section 5.5 was\n   changed\
    \ from\n      for (i = 1 to n) { DF_i = 1; }\n   to\n      for (i = 0 to n) {\
    \ DF_i = 1; }\n   [RFC3448Err].\n   Section 5.5, history discounting: THRESHOLD,\
    \ the lower bound on the\n   history discounting parameter DF, has been changed\
    \ from 0.5 to 0.25,\n   to allow more history discounting when the current interval\
    \ is long.\n   Section 6, multiple feedback packets: Section 6 now contains more\n\
    \   discussion of procedures if the receiver sends multiple feedback\n   packets\
    \ each round-trip time.\n   Section 6.3, initialization of the feedback timer:\
    \ Section 6.3 now\n   specifies the receiver's initialization of the feedback\
    \ timer if the\n   first data packet received does not have an estimate of the\
    \ round-\n   trip time.\n   Section 6.3, a coarse-grained timestamp: Section 6.3\
    \ was modified to\n   incorporate, as an option, a coarse-grained timestamp from\
    \ the sender\n   that increments every quarter of a round-trip time, instead of\
    \ a more\n   fine-grained timestamp.  This follows RFC 4342.\n   Section 6.3.1,\
    \ after the first loss event: Section 6.3.1 now says\n   that for initializing\
    \ the loss history after the first loss event,\n   the receiver uses the maximum\
    \ receive rate so far, instead of the\n   receive rate in the last round-trip\
    \ time.\n   Section 6.3.1, if the first data packet is dropped: Section 6.3.1\
    \ now\n   contains a specification for initializing the loss history if the\n\
    \   first data packet sent is lost or ECN-marked.\n   Section 7, sender-based\
    \ variants: Section 7's discussion of sender-\n   based variants has been expanded,\
    \ with reference to RFC 4342.\n"
- title: 10.  Security Considerations
  contents:
  - "10.  Security Considerations\n   TFRC is not a transport protocol in its own\
    \ right, but a congestion\n   control mechanism that is intended to be used in\
    \ conjunction with a\n   transport protocol.  Therefore, security primarily needs\
    \ to be\n   considered in the context of a specific transport protocol and its\n\
    \   authentication mechanisms.\n   Congestion control mechanisms can potentially\
    \ be exploited to create\n   denial of service.  This may occur through spoofed\
    \ feedback.  Thus,\n   any transport protocol that uses TFRC should take care\
    \ to ensure that\n   feedback is only accepted from the receiver of the data.\
    \  The precise\n   mechanism to achieve this will however depend on the transport\n\
    \   protocol itself.\n   In addition, congestion control mechanisms may potentially\
    \ be\n   manipulated by a greedy receiver that wishes to receive more than its\n\
    \   fair share of network bandwidth.  A receiver might do this by\n   claiming\
    \ to have received packets that, in fact, were lost due to\n   congestion.  Possible\
    \ defenses against such a receiver would normally\n   include some form of nonce\
    \ that the receiver must feed back to the\n   sender to prove receipt.  However,\
    \ the details of such a nonce would\n   depend on the transport protocol, and\
    \ in particular on whether the\n   transport protocol is reliable or unreliable.\n\
    \   We expect that protocols incorporating ECN with TFRC will also want\n   to\
    \ incorporate feedback from the receiver to the sender using the ECN\n   nonce\
    \ [RFC3540].  The ECN nonce is a modification to ECN that\n   protects the sender\
    \ from the accidental or malicious concealment of\n   marked packets.  Again,\
    \ the details of such a nonce would depend on\n   the transport protocol, and\
    \ are not addressed in this document.\n"
- title: 10.1.  Security Considerations for TFRC in DCCP
  contents:
  - "10.1.  Security Considerations for TFRC in DCCP\n   TFRC is currently used in\
    \ Congestion Control ID 3 (CCID 3) [RFC4342]\n   of the Datagram Congestion Control\
    \ Protocol (DCCP) [RFC4340].  The\n   Security Considerations section of RFC 4340\
    \ [RFC4340] (Section 18)\n   discusses some of the security issues of DCCP, including\
    \ sequence\n   number validity checks to protect against hijacked connections.\n\
    \   Section 18 of RFC 4340 also discusses mechanisms in DCCP to limit the\n  \
    \ potential impact of denial-of-service attacks.\n   RFC 4342 specifies the use\
    \ of TFRC in CCID 3.  RFC 4342 includes\n   extensive discussions of the mechanisms\
    \ the sender can use to verify\n   the information sent by the receiver.  When\
    \ ECN is used with CCID 3,\n   the receiver returns ECN Nonce information to the\
    \ sender, to allow\n   the sender to verify information sent by the receiver.\
    \  When ECN is\n   not used, Section 9 of RFC 4342 discusses how the sender could\
    \ still\n   use various techniques that might catch the receiver in an error in\n\
    \   reporting congestion.  However, as stated in RFC 4342, this is not as\n  \
    \ robust or non-intrusive as the verification provided by the ECN\n   Nonce.\n"
- title: 11.  Acknowledgments
  contents:
  - "11.  Acknowledgments\n   We would like to acknowledge feedback and discussions\
    \ on equation-\n   based congestion control with a wide range of people, including\n\
    \   members of the Reliable Multicast Research Group, the Reliable\n   Multicast\
    \ Transport Working Group, and the End-to-End Research Group.\n   We would like\
    \ to thank Dado Colussi, Gorry Fairhurst, Ladan Gharai,\n   Wim Heirman, Eddie\
    \ Kohler, Ken Lofgren, Mike Luby, Ian McDonald,\n   Vladimir Moltchanov, Colin\
    \ Perkins, Michele R., Gerrit Renker, Arjuna\n   Sathiaseelan, Vladica Stanisic,\
    \ Randall Stewart, Eduardo Urzaiz,\n   Shushan Wen, and Wendy Lee (lhh@zsu.edu.cn)\
    \ for feedback on earlier\n   versions of this document, and to thank Mark Allman\
    \ for his extensive\n   feedback from using [RFC3448] to produce a working implementation.\n"
- title: Appendix A.  Terminology
  contents:
  - "Appendix A.  Terminology\n   This document uses the following terms.  Timer variables\
    \ (e.g.,\n   t_now, tld) are assumed to be in seconds, with a timer resolution\
    \ of\n   at least a millisecond.\n   data-limited interval:\n      An interval\
    \ where the sender is data-limited (not sending as much\n      as it is allowed\
    \ to send) over the entire interval (Section 4.3).\n   DF: Discount factor for\
    \ a loss interval (Section 5.5).\n   initial_rate:\n      Allowed initial sending\
    \ rate.\n   last_counter:\n      Greatest received value of the window counter\
    \ (Section 6.3).\n   n:  Number of loss intervals.\n   NDUPACK:\n      Number\
    \ of dupacks for inferring loss (constant) (Section 5.1).\n   nofeedback timer:\n\
    \      Sender-side timer (Section 4).\n   p:  Estimated Loss Event Rate.\n   p_prev:\n\
    \      Previous value of p (Section 6.1).\n   q:  Filter constant for RTT (constant)\
    \ (Section 4.3).\n   q2: Filter constant for long-term RTT (constant) (Section\
    \ 4.6).\n   R:  Estimated path round-trip time.\n   R_m:\n      A specific estimate\
    \ of the path round-trip time (Sections 4.3, 6).\n   R_sample:\n      Measured\
    \ path RTT (Section 4.3).\n   R_sqmean:\n      Long-term estimate of the square\
    \ root of the RTT (Section 4.6).\n   recover_rate:\n      Allowed rate for resuming\
    \ after an idle period (Section 4.4).\n   recv_limit;\n      Limit on sending\
    \ rate computed from X_recv_set (Section 4.3).\n   s:  Nominal packet size in\
    \ bytes.\n   S:  Sequence number.\n   t_delay:\n      Reported time delay between\
    \ receipt of the last packet at the\n      receiver and the generation of the\
    \ feedback packet (Section\n      3.2.2).\n   t_delta:\n      Parameter for flexibility\
    \ in send time (Section 8.3).\n   t_gran:\n      Scheduling timer granularity\
    \ of the operating system (constant)\n      (Section 8.3).\n   t_ipi:\n      Inter-packet\
    \ interval for sending packets (Section 4.6).\n   t_mbi:\n      Maximum RTO value\
    \ of TCP (constant) (Section 4.3).\n   t_recvdata:\n      Timestamp of the last\
    \ data packet received (Section 3.2.2).\n   timer_limit:\n      Limit on the sending\
    \ rate from the expiration of the nofeedback\n      timer (Section 4.4).\n   tld:\n\
    \      Time Last Doubled (Section 4.2).\n   t_now:\n      Current time (Section\
    \ 4.3).\n   t_RTO:\n      Estimated RTO of TCP (Section 4.3).\n   X:  Allowed\
    \ transmit rate, as limited by the receive rate.\n   X_Bps:\n      Calculated\
    \ sending rate in bytes per second (Section 3.1).\n   X_pps:\n      Calculated\
    \ sending rate in packets per second (Section 3.1).\n   X_inst:\n      Instantaneous\
    \ allowed transmit rate (Section 4.6).\n   X_recv:\n      Estimated receive rate\
    \ at the receiver (Section 3.2.2).\n   X_recv_set:\n      A small set of recent\
    \ X_recv values (Section 4.3).\n   X_target:\n      The target sending rate after\
    \ the first loss event (Section\n      6.3.1).\n   W_init:\n      TCP initial\
    \ window (constant) (Section 4.2).\n"
- title: Appendix B.  The Initial Value of the Nofeedback Timer
  contents:
  - "Appendix B.  The Initial Value of the Nofeedback Timer\n   Why is the initial\
    \ value of TFRC's nofeedback timer set to two\n   seconds, instead of the recommended\
    \ initial value of three seconds\n   for TCP's retransmit timer, from [RFC2988]?\
    \  There is not any\n   particular reason why TFRC's nofeedback timer should have\
    \ the same\n   initial value as TCP's retransmit timer.  TCP's retransmit timer\
    \ is\n   used not only to reduce the sending rate in response to congestion,\n\
    \   but also to retransmit a packet that is assumed to have been dropped\n   in\
    \ the network.  In contrast, TFRC's nofeedback timer is only used to\n   reduce\
    \ the allowed sending rate, not to trigger the sending of a new\n   packet.  As\
    \ a result, there is no danger to the network for the\n   initial value of TFRC's\
    \ nofeedback timer to be smaller than the\n   recommended initial value for TCP's\
    \ retransmit timer.\n   Further, when the nofeedback timer has not yet expired,\
    \ TFRC has a\n   more slowly responding congestion control mechanism than TCP,\
    \ and\n   TFRC's use of the receive rate for limiting the sending rate is\n  \
    \ somewhat less precise than TCP's use of windows and ack-clocking, so\n   the\
    \ nofeedback timer is a particularly important safety mechanism for\n   TFRC.\
    \  For all of these reasons, it is perfectly reasonable for\n   TFRC's nofeedback\
    \ timer to have a smaller initial value than that of\n   TCP's retransmit timer.\n"
- title: Appendix C.  Response to Idle or Data-Limited Periods
  contents:
  - "Appendix C.  Response to Idle or Data-Limited Periods\n   Future work could explore\
    \ alternate responses to using the receive\n   rate during a data-limited period,\
    \ and to responding to a loss event\n   during a data-limited period.\n   In particular,\
    \ an Experimental RFC [RFC2861] specifies Congestion\n   Window Validation (CWV)\
    \ for TCP.  For this discussion, we use the\n   term \"Standard TCP\" to refer\
    \ to the TCP congestion control mechanisms\n   in [RFC2581] and [RFC2581bis].\
    \  [RFC2861] specifies a different\n   response to idle or data-limited periods\
    \ than those of Standard TCP.\n   With CWV, the TCP sender halves the congestion\
    \ window after each RTO\n   during an idle period, down to the initial window.\
    \  Similarly, with\n   CWV the TCP sender halves the congestion window half-way\
    \ down to the\n   flight size after each RTO during a data-limited period.\n \
    \  This document already specifies a TFRC response to idle periods that\n   is\
    \ similar to that of TCP with Congestion Window Validation.\n   However, this\
    \ document does not specify a TFRC response to data-\n   limited periods similar\
    \ to that of CWV.  Adding such a mechanism to\n   TFRC would require a one-line\
    \ change to step (4) of Section 4.3.  In\n   particular, the sender's response\
    \ to a feedback packet could be\n   changed from:\n      If (the entire interval\
    \ covered by the feedback packet\n            was a data-limited interval) {\n\
    \          If (the feedback packet reports a new loss event or an\n          \
    \             increase in the loss event rate p) {\n              Halve entries\
    \ in X_recv_set;\n              X_recv = 0.85 * X_recv;\n              Maximize\
    \ X_recv_set();\n              recv_limit = max (X_recv_set);\n          } Else\
    \ {\n              Maximize X_recv_set();\n              recv_limit = 2 * max\
    \ (X_recv_set);\n          }\n      }\n   to:\n      If (the entire interval covered\
    \ by the feedback packet\n            was a data-limited interval) {\n       \
    \   Multiply old entries in X_recv_set by 0.85;\n          If (the feedback packet\
    \ reports a new loss event or an\n                       increase in the loss\
    \ event rate p) {\n              Multiply new value X_recv by 0.85.\n        \
    \  }\n          Maximize X_recv_set();\n          recv_limit = 2 * max (X_recv_set);\n\
    \      }\n   In particular, if the receive rate from before a data-limited period\n\
    \   is saved in X_recv_set, then the change in step (4) above would\n   multiply\
    \ that receive rate by 0.85 each time that a feedback packet\n   is received and\
    \ the above code is executed.  As a result, after four\n   successive round-trip\
    \ times of data-limited intervals, the receive\n   rate from before the data-limited\
    \ period would be reduced by 0.85^4 =\n   0.52.  Thus, this one-line change to\
    \ step (4) of Section 4.3 would\n   result in the allowed sending rate being halved\
    \ for each four\n   roundtrip times in which the sender was data-limited.  Because\
    \ of the\n   nature of X_recv_set, this mechanism would never reduce the allowed\n\
    \   sending rate below twice the most recent receive rate.\n   We note that in\
    \ the suggested code above, with CWV-style behavior in\n   response to data-limited\
    \ intervals, we keep\n      recv_limit = 2 * max (X_recv_set);\n   instead of\
    \ using\n      recv_limit = max (X_recv_set);\n   following loss events in data-limited\
    \ intervals.  This relaxed\n   response to a loss event is allowed because the\
    \ CWV-style behavior\n   itself limits rapid fluctuations in the sending rate\
    \ during data-\n   limited periods.\n"
- title: C.1.  Long Idle or Data-Limited Periods
  contents:
  - "C.1.  Long Idle or Data-Limited Periods\n   Table 1 summarizes the response of\
    \ Standard TCP [RFC2581], TCP with\n   Congestion Window Validation [RFC2861],\
    \ Standard TFRC [RFC3448], and\n   Revised TFRC (this document) in response to\
    \ long idle or data-limited\n   periods.  For the purposes of this section, we\
    \ define a long period\n   as a period of at least an RTO.\n     Protocol    \
    \     Long idle periods      Long data-limited periods\n   --------------   --------------------\
    \     ----------------------\n   Standard TCP:       Window -> initial.     Window\
    \ increases for\n                                              each cwnd of data.\n\
    \   TCP with CWV:         Halve window         Reduce window half way\n      \
    \             (not below initial cwnd).    to used window.\n   Standard TFRC:\
    \        Halve rate            Rate limited to\n                    (not below\
    \ 2 pkts/rtt).      twice receive rate.\n                    One RTT after sending\
    \ pkt,\n                    rate is limited by X_recv.\n   Revised TFRC:     \
    \    Halve rate             Rate limited to twice\n                    (not below\
    \ initial rate).     max (current X_recv,\n                                  \
    \                receive rate before\n                                       \
    \           data-limited period).\n     Table 1: Response to Long Idle or Data-Limited\
    \ Periods\n   Standard TCP after long idle periods: For Standard TCP, [RFC2581]\n\
    \   specifies that TCP SHOULD set the congestion window to no more than\n   the\
    \ initial window after an idle period of at least an RTO.  (To be\n   precise,\
    \ RFC 2581 specifies that the TCP sender should set cwnd to\n   the initial window\
    \ if the sender has not sent data in an interval\n   exceeding the retransmission\
    \ timeout.)\n   Standard TCP after long data-limited periods: Standard TCP [RFC2581]\n\
    \   does not reduce TCP's congestion window after a data-limited period,\n   when\
    \ the congestion window is not fully used.  Standard TCP in\n   [RFC2581] uses\
    \ the FlightSize, the amount of outstanding data in the\n   network, only in setting\
    \ the slow-start threshold after a retransmit\n   timeout.  Standard TCP is not\
    \ limited by TCP's ack-clocking mechanism\n   during a data-limited period.\n\
    \   Standard TCP's lax response to a data-limited period is quite\n   different\
    \ from its stringent response to an idle period.\n   TCP with Congestion Window\
    \ Validation (CWV) after long idle periods:\n   As an experimental alternative,\
    \ [RFC2861] specifies a more moderate\n   response to an idle period than that\
    \ of Standard TCP, where during an\n   idle period the TCP sender halves cwnd\
    \ after each RTO, down to the\n   initial cwnd.\n   TCP with Congestion Window\
    \ Validation after long data-limited\n   periods: As an experimental alternative,\
    \ [RFC2861] specifies a more\n   stringent response to a data-limited period than\
    \ that of Standard\n   TCP, where after each RTO seconds of a data-limited period,\
    \ the\n   congestion window is reduced half way down to the window that is\n \
    \  actually used.\n   The response of TCP with CWV to an idle period is similar\
    \ to its\n   response to a data-limited period.  TCP with CWV is less restrictive\n\
    \   than Standard TCP in response to an idle period, and more restrictive\n  \
    \ than Standard TCP in response to a data-limited period.\n   Standard TFRC after\
    \ long idle periods: For Standard TFRC, [RFC3448]\n   specifies that the allowed\
    \ sending rate is halved after each RTO\n   seconds of an idle period.  The allowed\
    \ sending rate is not reduced\n   below two packets per RTT after idle periods.\
    \  After an idle period,\n   the first feedback packet received reports a receive\
    \ rate of one\n   packet per round-trip time, and this receive rate is used to\
    \ limit\n   the sending rate.  Standard TFRC effectively slow-starts up from this\n\
    \   allowed sending rate.\n   Standard TFRC after long data-limited periods: [RFC3448]\
    \ does not\n   distinguish between data-limited and non-data-limited periods.\
    \  As a\n   consequence, the allowed sending rate is limited to at most twice\
    \ the\n   receive rate during and after a data-limited period.  This is a very\n\
    \   restrictive response, more restrictive than that of either Standard\n   TCP\
    \ or of TCP with CWV.\n   Revised TFRC after long idle periods: For Revised TFRC,\
    \ this document\n   specifies that the allowed sending rate is halved after each\
    \ RTO\n   seconds of an idle period.  The allowed sending rate is not reduced\n\
    \   below the initial sending rate as the result of an idle period.  The\n   first\
    \ feedback packet received after the idle period reports a\n   receive rate of\
    \ one packet per round-trip time.  However, the Revised\n   TFRC sender does not\
    \ use this receive rate for limiting the sending\n   rate.  Thus, Revised TFRC\
    \ differs from Standard TFRC in the lower\n   limit used in the reduction of the\
    \ sending rate, and in the better\n   response to the first feedback packet received\
    \ after the idle period.\n   Revised TFRC after long data-limited periods: For\
    \ Revised TFRC, this\n   document distinguishes between data-limited and non-data-limited\n\
    \   periods.  As specified in Section 4.3, during a data-limited period\n   Revised\
    \ TFRC remembers the receive rate before the data-limited\n   period began, and\
    \ does not reduce the allowed sending rate below\n   twice that receive rate.\
    \  This is somewhat similar to the response of\n   Standard TCP, and is quite\
    \ different from the very restrictive\n   response of Standard TFRC to a data-limited\
    \ period.  However, the\n   response of Revised TFRC is not as conservative as\
    \ the response of\n   TCP with Congestion Window Validation, where the congestion\
    \ window is\n   gradually reduced down to the window actually used during a data-\n\
    \   limited period.\n   We note that for current TCP implementations, the congestion\
    \ window\n   is generally not increased during a data-limited period (when the\n\
    \   current congestion window is not being fully used) [MAF05] (Section\n   5.7).\
    \  We note that there is no mechanism comparable to this in\n   Revised TFRC.\n\
    \   Recovery after idle or data-limited periods: When TCP reduces the\n   congestion\
    \ window after an idle or data-utilized period, TCP can set\n   the slow-start\
    \ threshold, ssthresh, to allow the TCP sender to slow-\n   start back up towards\
    \ its old sending rate when the idle or data-\n   limited period is over.  However,\
    \ in TFRC, even when the TFRC\n   sender's sending rate is restricted by twice\
    \ the previous receive\n   rate, this results in the sender being able to double\
    \ the sending\n   rate from one round-trip time to the next, if permitted by the\n\
    \   throughput equation.  Thus, TFRC does not need a mechanism such as\n   TCP's\
    \ setting of ssthresh to allow a slow-start after an idle or\n   data-limited\
    \ period.\n   For future work, one avenue to explore would be the addition of\n\
    \   Congestion Window Validation mechanisms for TFRC's response to data-\n   limited\
    \ periods.  Currently, following Standard TCP, during data-\n   limited periods\
    \ Revised TFRC does not limit its allowed sending rate\n   as a function of the\
    \ receive rate.\n"
- title: C.2.  Short Idle or Data-Limited Periods
  contents:
  - "C.2.  Short Idle or Data-Limited Periods\n   Table 2 summarizes the response\
    \ of Standard TCP [RFC2581], TCP with\n   Congestion Window Validation [RFC2861],\
    \ Standard TFRC [RFC3448], and\n   Revised TFRC (this document) in response to\
    \ short idle or data-\n   limited periods.  For the purposes of this section,\
    \ we define a short\n   period as a period of less than an RTT.\n     Protocol\
    \         Short idle periods   Short data-limited periods\n   -------------- \
    \  --------------------     ----------------------\n   Standard TCP:    Send a\
    \ burst up to cwnd.  Send a burst up to cwnd.\n   TCP with CWV:    Send a burst\
    \ up to cwnd.  Send a burst up to cwnd.\n   Standard TFRC:             ?     \
    \                    ?\n   Revised TFRC:         Send a burst               Send\
    \ a burst\n                        (up to an RTT of           (up to an RTT of\n\
    \                      unused send credits).      unused send credits).\n    \
    \ Table 2: Response to Short Idle or Data-Limited Periods\n   Table 2 shows that\
    \ Revised TFRC has a similar response to that of\n   Standard TCP and of TCP with\
    \ CWV to a short idle or data-limited\n   period.  For a short idle or data-limited\
    \ period, TCP is limited only\n   by the size of the unused congestion window,\
    \ and Revised TFRC is\n   limited only by the number of unused send credits (up\
    \ to an RTT's\n   worth).  For Standard TFRC, [RFC3448] did not explicitly specify\
    \ the\n   behavior with respect to unused send credits.\n"
- title: C.3.  Moderate Idle or Data-Limited Periods
  contents:
  - "C.3.  Moderate Idle or Data-Limited Periods\n   Table 3 summarizes the response\
    \ of Standard TCP [RFC2581], TCP with\n   Congestion Window Validation [RFC2861],\
    \ Standard TFRC [RFC3448], and\n   Revised TFRC (this document) in response to\
    \ moderate idle or data-\n   limited periods.  For the purposes of this section,\
    \ we define a\n   moderate period as a period greater than an RTT, but less than\
    \ an\n   RTO.\n     Protocol      Moderate idle periods  Moderate data-limited\
    \ periods\n   -------------   ---------------------      -------------------------\n\
    \   Standard TCP:    Send a burst up to cwnd.  Send a burst up to cwnd.\n   TCP\
    \ with CWV:    Send a burst up to cwnd.  Send a burst up to cwnd.\n   Standard\
    \ TFRC:             ?                   Limited by X_recv.\n   Revised TFRC: \
    \        Send a burst               Send a burst\n                        (up\
    \ to an RTT of           (up to an RTT of\n                      unused send credits).\
    \      unused send credits).\n     Table 3: Response to Moderate Idle or Data-Limited\
    \ Periods\n   Table 3 shows that Revised TFRC has a similar response to that of\n\
    \   Standard TCP and of TCP with CWV to a moderate idle or data-limited\n   period.\
    \  For a moderate idle or data-limited period, TCP is limited\n   only by the\
    \ size of the unused congestion window.  For a moderate\n   idle period, Revised\
    \ TFRC is limited only by the number of unused\n   send credits (up to an RTT's\
    \ worth).  For a moderate data-limited\n   period, Standard TFRC would be limited\
    \ by X_recv from the most recent\n   feedback packet.  In contrast, Revised TFRC\
    \ is not limited by the\n   receive rate from data-limited periods that cover\
    \ an entire feedback\n   period of a round-trip time.  For Standard TFRC, [RFC3448]\
    \ did not\n   explicitly specify the behavior with respect to unused send credits.\n"
- title: C.4.  Losses During Data-Limited Periods
  contents:
  - "C.4.  Losses During Data-Limited Periods\n   This section discusses the response\
    \ to a loss during a data-limited\n   period.\n     Protocol      Response to\
    \ a loss during a data-limited period\n   -------------   -----------------------------------------------\n\
    \   Standard TCP:   Set ssthresh, cwnd to FlightSize/2.\n   TCP with CWV:   Same\
    \ as Standard TCP.\n   Standard TFRC:  Calculate X_Bps, send at most 2*X_recv.\n\
    \   Revised TFRC:   Calculate X_Bps, send at most recv_limit.\n              \
    \     In addition, modify X_recv_set.\n     Table 4: Response to a Loss during\
    \ a Data-Limited Period\n   In TCP [RFC2581], the response to a loss during a\
    \ data-limited period\n   is the same as the response to a loss at any other time\
    \ in TCP.  This\n   response is to set the congestion window to half of the FlightSize,\n\
    \   where the FlightSize is the actual amount of unacknowledged data.\n   Thus,\
    \ after a loss during a data-limited period, the TCP sender must\n   halve its\
    \ allowed sending rate, as it normally does in response to a\n   loss.\n   In\
    \ Standard TFRC, the response to a loss during a data-limited period\n   is also\
    \ the same as the response to a loss at any other time in\n   Standard TFRC. \
    \ The sending rate is limited by X_Bps, from the\n   throughput equation, and\
    \ the sending rate is also limited by twice\n   X_recv, the most recent receive\
    \ rate.  As a result, after a loss in a\n   data-limited period, the sender can\
    \ at most double its sending rate\n   to twice X_recv, even if the throughput\
    \ equation X_Bps would allow a\n   sending rate much higher than that.\n   In\
    \ Revised TFRC, there have been changes to the use of the receive\n   rate X_recv\
    \ during data-limited intervals; the sender is limited to\n   sending at most\
    \ recv_limit, where the sender can remember the receive\n   rate X_recv from just\
    \ before the data-limited period.  This allows\n   the sender to more than double\
    \ its sending rate during data-limited\n   periods, up to the receive rate from\
    \ before the data-limited period\n   (if allowed by the throughput equation as\
    \ given in X_Bps).  This is\n   similar to Standard TCP's practice of not reducing\
    \ the window during\n   data-limited periods (in the absence of loss).\n   As\
    \ with Standard TFRC, during a data-limited period the Revised TFRC\n   sender\
    \ is sending less than is allowed by the throughput equation\n   X_Bps.  After\
    \ the loss event, the sender still might not want to be\n   sending as much as\
    \ allowed by the recalculated value of X_Bps that\n   takes into account the new\
    \ loss event.  Revised TFRC adds an\n   additional mechanism to gradually limit\
    \ the sender's sending rate\n   after losses during data-limited periods.  Unlike\
    \ TCP's response of\n   setting cwnd to half the FlightSize, this additional mechanism\
    \ in\n   Revised TFRC uses TFRC's practice of using slowly-responding changes\n\
    \   for both increases and decreases in the allowed sending rate.\n   This is\
    \ done in Revised TFRC (in step (4) of Section 4.3) by\n   decreasing the entry\
    \ in X_recv_set after a loss in a data-limited\n   interval, and by allowing the\
    \ sender to send at most max\n   (X_recv_set), instead of at most twice max (X_recv_set),\
    \ in the\n   immediate round-trip time following the reported loss.  Thus, the\n\
    \   'price' for allowing the sender to send more than twice the most\n   immediately\
    \ reported value of X_recv during a data-limited interval\n   is the introduction\
    \ of an additional mechanism to reduce this allowed\n   sending rate following\
    \ losses in data-limited periods.\n   In TFRC's response to a loss in a data-limited\
    \ interval, we have\n   considered the following examples.\n   Example 1, Losses\
    \ *after* a Data-Limited Period: This example shows\n   that losses after a data-limited\
    \ period has ended are addressed by\n   the throughput equation X_Bps.\n   -------------------------------------------------------------------\n\
    \   Stage 1: Not data-limited.\n            Sending 100 packets per round-trip\
    \ time (PPR).\n   Stage 2: Data-limited, sending 10 PPR.\n   Stage 3: Not data-limited.\n\
    \            Sending 100 PPR again, as allowed by X_Bps.\n            A packet\
    \ loss in the first RTT of Stage 3.\n            X_Bps is updated,\n   Response\
    \ of Revised TFRC: a slight reduction in the allowed sending\n     rate, depending\
    \ on the number of packets since the last loss event.\n   -------------------------------------------------------------------\n\
    \      Table 5:  Example 1, Losses after a Data-Limited Period\n   For example\
    \ 1, when there is a packet loss in the first RTT of Stage\n   3, this will be\
    \ reflected in a modified value of X_Bps, and future\n   loss events would result\
    \ in future reductions of the throughput\n   equation X_Bps.  In particular, following\
    \ TFRC's standard use of the\n   throughput equation [FHPW00] (Section A.2), the\
    \ allowed TFRC sending\n   rate would be halved after something like five successive\
    \ round-trip\n   times with loss.\n   Example 2, a Mildly Data-Limited Sender:\
    \ This example considers\n   losses in a data-limited period when, during the\
    \ data-limited period,\n   the sender is sending *almost* as much as it is allowed\
    \ to send.\n   -------------------------------------------------------------------\n\
    \   Stage 1: Not data-limited.  Sending 100 PPR.\n   Stage 2: Data-limited, sending\
    \ 99 PPR.\n            A packet loss in Stage 2.\n   Response of Revised TFRC:\
    \ a slight reduction in the allowed sending\n     rate, down to 85 PPR or less,\
    \ depending on the number of packets\n     since the last loss event.\n   -------------------------------------------------------------------\n\
    \      Table 6:  Example 2, a Mildly Data-Limited Sender\n   Consider a Revised\
    \ TFRC connection where the sender has been sending\n   a hundred PPR and then\
    \ enters a data-limited period of sending only\n   99 PPR because of data limitations\
    \ from the application.  (That is,\n   at every instance of time during the data-limited\
    \ period, the sender\n   could have sent one more packet.)  If there are losses\
    \ in the data-\n   limited period, the allowed sending rate is reduced to min(X_Bps,\n\
    \   recv_limit), where both the throughput equation X_Bps and the limit\n   recv_limit\
    \ force a slight reduction in the allowed sending rate.\n   Example 3, a Single\
    \ Packet Loss during a Data-Limited Period.  This\n   example considers the loss\
    \ of a single packet during a data-limited\n   period, after the sender has not\
    \ sent a packet for two RTTs.\n   -------------------------------------------------------------------\n\
    \   Stage 1: Not data-limited.  Sending 100 PPR.\n   Stage 2: Data-limited, sending\
    \ 10 PPR.\n   Stage 3: Data-limited, sending no data for two RTTs.\n   Stage 4:\
    \ Data-limited, sending one packet, which is ECN-marked.\n   Response of Revised\
    \ TFRC: a reduction in the allowed sending\n     rate, down to 50 PPR or less.\
    \  For each loss event during\n     the data-limited period, the 'remembered'\
    \ X_recv from before\n     the data-limited period is effectively halved.\n  \
    \ -------------------------------------------------------------------\n      Table\
    \ 7:  Example 3, a Single Packet Loss\n   Consider a Revised TFRC connection where\
    \ the sender has been sending\n   a hundred PPR, and then enters a data-limited\
    \ period of sending only\n   ten PPR, and then does not send any packets for two\
    \ RTTs, and then\n   sends a single packet, which is ECN-marked.  In this case,\
    \ with\n   Revised TFRC, for each loss event during the data-limited period, the\n\
    \   sender halves its 'remembered' X_recv from before the data-limited\n   period\n\
    \   Example 4, Losses after Increasing the Sending Rate during a Data-\n   Limited\
    \ Period.  This example considers losses when the sender\n   significantly increases\
    \ its sending rate during a data-limited\n   period.\n   -------------------------------------------------------------------\n\
    \   Stage 1: Not data-limited.  Sending 100 PPR.\n   Stage 2: Data-limited, sending\
    \ 1 PPR.\n   Stage 3: Data-limited, sending 20 PPR.\n            Several packets\
    \ are lost in each RTT of Stage 3.\n            During Stage 3, the sender would\
    \ *like* to send 20 PPR.\n   Response of Revised TFRC:  For each loss event during\n\
    \     the data-limited period, the 'remembered' X_recv from before\n     the data-limited\
    \ period is effectively halved, and the most\n     recent X_recv is reduced by\
    \ 0.85.\n   -------------------------------------------------------------------\n\
    \      Table 8:  Example 4, Losses after Increasing the Sending Rate\n   Consider\
    \ a Revised TFRC connection where the sender has been sending\n   a hundred PPR,\
    \ and then enters a data-limited period of sending only\n   one PPR, and then,\
    \ while still data-limited, increases its sending\n   rate to twenty PPR, where\
    \ it experiences a number of successive loss\n   events.\n   In this case, with\
    \ Revised TFRC, for each loss event during the\n   data-limited period, the sender\
    \ halves its 'remembered' X_recv from\n   before the data-limited period, and\
    \ the most recent X_recv is reduced\n   by 0.85.\n"
- title: C.5.  Other Patterns
  contents:
  - "C.5.  Other Patterns\n   Other possible patterns to consider in evaluating Revised\
    \ TFRC would\n   be to compare the behavior of TCP, Standard TFRC, and Revised\
    \ TFRC\n   for connections with alternating busy and idle periods, alternating\n\
    \   idle and data-limited periods, or with idle or data-limited periods\n   during\
    \ slow-start.\n"
- title: C.6.  Evaluating TFRC's Response to Idle Periods
  contents:
  - "C.6.  Evaluating TFRC's Response to Idle Periods\n   In this section we focus\
    \ on evaluating Revised TFRC's response to\n   idle or data-limited periods.\n\
    \   One drawback to Standard TFRC's strict response to idle or data-\n   limited\
    \ periods is that it could be seen as encouraging applications\n   to pad their\
    \ sending rate during idle or data-limited periods, by\n   sending dummy data\
    \ when there was no other data to send.  Because\n   Revised TFRC has a less strict\
    \ response to data-limited periods than\n   that of Standard TFRC, Revised TFRC\
    \ also could be seen as giving\n   applications less of an incentive to pad their\
    \ sending rates during\n   data-limited periods.  Work in progress, such as Faster\
    \ Restart\n   [KFS07], can also decrease an application's incentive to pad its\n\
    \   sending rate, by allowing faster start-up after idle periods.\n   Further\
    \ research would be useful to understand, in more detail, the\n   interaction\
    \ between TCP or TFRC's congestion control mechanisms, and\n   an application's\
    \ incentive to pad its sending rate during idle or\n   data-limited periods.\n\
    \   TCP Congestion Window Validation, described in Appendix C.1 above, is\n  \
    \ an Experimental standard specifying that the TCP sender slowly\n   reduces the\
    \ congestion window during an idle or data-limited period\n   [RFC2861].  While\
    \ TFRC and Revised TFRC's responses to idle periods\n   are roughly similar to\
    \ those of TCP with Congestion Window\n   Validation, Revised TFRC's response\
    \ to data-limited periods is less\n   conservative than those of TCP with Congestion\
    \ Window Validation (and\n   Standard TFRC's response to data-limited periods\
    \ was considerably\n   *more* conservative than those of Congestion Window Validation).\n\
    \   Future work could include modifications to this document so that the\n   response\
    \ of Revised TFRC to a data-limited period includes a slow\n   reduction of the\
    \ allowed sending rate; Section C specifies a possible\n   mechanism for this.\
    \  Such a modification would be particularly\n   compelling if Congestion Window\
    \ Validation became a Proposed Standard\n   in the IETF for TCP.\n"
- title: References
  contents:
  - 'References

    '
- title: Normative References
  contents:
  - "Normative References\n   [RFC2119]    Bradner, S., \"Key words for use in RFCs\
    \ to Indicate\n                Requirement Levels\", BCP 14, RFC 2119, March 1997.\n\
    \   [RFC3448]    Handley, M., Floyd, S., Padhye, J., and J. Widmer, \"TCP\n  \
    \              Friendly Rate Control (TFRC): Protocol Specification\",\n     \
    \           RFC 3448, January 2003.\n"
- title: Informative References
  contents:
  - "Informative References\n   [BRS99]      Balakrishnan, H., Rahul, H., and Seshan,\
    \ S., \"An\n                Integrated Congestion Management Architecture for\n\
    \                Internet Hosts,\" Proc. ACM SIGCOMM, Cambridge, MA,\n       \
    \         September 1999.\n   [CCID-4]     Floyd, S., and E. Kohler, \"Profile\
    \ for DCCP Congestion\n                Control ID 4: the Small-Packet Variant\
    \ of TFRC\n                Congestion Control\", Work in Progress, February 2008.\n\
    \   [FHPW00]     S. Floyd, M. Handley, J. Padhye, and J. Widmer,\n           \
    \     \"Equation-Based Congestion Control for Unicast\n                Applications\"\
    , August 2000, Proc SIGCOMM 2000.\n   [FHPW00a]    S. Floyd, M. Handley, J. Padhye,\
    \ and J. Widmer,\n                \"Equation-Based Congestion Control for Unicast\n\
    \                Applications: the Extended Version\", ICSI tech report\n    \
    \            TR-00-03, March 2000.\n   [FF99]       Floyd, S., and K. Fall, Promoting\
    \ the Use of End-to-End\n                Congestion Control in the Internet, IEEE/ACM\n\
    \                Transactions on Networking, August 1999.\n   [KFS07]      E.\
    \ Kohler, S. Floyd, and A. Sathiaseelan, \"Faster\n                Restart for\
    \ TCP Friendly Rate Control (TFRC)\", Work in\n                Progress, November\
    \ 2007.\n   [MAF05]      A. Medina, M. Allman, and S. Floyd, \"Measuring the\n\
    \                Evolution of Transport Protocols in the Internet\", ACM\n   \
    \             Computer Communications Review, April 2005.\n   [PFTK98]     Padhye,\
    \ J. and  Firoiu, V. and Towsley, D. and Kurose,\n                J., \"Modeling\
    \ TCP Throughput: A Simple Model and its\n                Empirical Validation\"\
    , Proc ACM SIGCOMM 1998.\n   [RFC2140]    Touch, J., \"TCP Control Block Interdependence\"\
    , RFC\n                2140, April 1997.\n   [RFC2581]    Allman, M., Paxson,\
    \ V., and W. Stevens, \"TCP Congestion\n                Control\", RFC 2581, April\
    \ 1999.\n   [RFC2581bis] Allman, M., Paxson, V., and W. Stevens, \"TCP Congestion\n\
    \                Control\", Work in Progress, April 2008.\n   [RFC2861]    Handley,\
    \ M., Padhye, J., and S. Floyd, \"TCP Congestion\n                Window Validation\"\
    , RFC 2861, June 2000.\n   [RFC2988]    Paxson, V. and M. Allman, \"Computing\
    \ TCP's\n                Retransmission Timer\", RFC 2988, November 2000.\n  \
    \ [RFC3168]    Ramakrishnan, K., Floyd, S., and D. Black, \"The Addition\n   \
    \             of Explicit Congestion Notification (ECN) to IP\", RFC\n       \
    \         3168, September 2001.\n   [RFC3390]    Allman, M., Floyd, S., and C.\
    \ Partridge, \"Increasing\n                TCP's Initial Window\", RFC 3390, October\
    \ 2002.\n   [RFC3448Err] RFC 3448 Errata,\n                <http://www.rfc-editor.org/errata_search.php?rfc=3448>.\n\
    \   [RFC3540]    Spring, N., Wetherall, D., and D. Ely, \"Robust Explicit\n  \
    \              Congestion Notification (ECN) Signaling with Nonces\",\n      \
    \          RFC 3540, June 2003.\n   [RFC4340]    Kohler, E., Handley, M., and\
    \ S. Floyd, \"Datagram\n                Congestion Control Protocol (DCCP)\",\
    \ RFC 4340, March\n                2006.\n   [RFC4342]    Floyd, S., Kohler, E.,\
    \ and J. Padhye, \"Profile for\n                Datagram Congestion Control Protocol\
    \ (DCCP) Congestion\n                Control ID 3: TCP-Friendly Rate Control (TFRC)\"\
    , RFC\n                4342, March 2006.\n   [RFC4828]    Floyd, S. and E. Kohler,\
    \ \"TCP Friendly Rate Control\n                (TFRC): The Small-Packet (SP) Variant\"\
    , RFC 4828, April\n                2007.\n   [W00]        Widmer, J., \"Equation-Based\
    \ Congestion Control\", Diploma\n                Thesis, University of Mannheim,\
    \ February 2000,\n                <http://www.icir.org/tfrc/>.\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Sally Floyd\n   ICSI\n   1947 Center St, Suite 600\n \
    \  Berkeley, CA 94708\n   EMail: floyd@icir.org\n   Mark Handley,\n   Department\
    \ of Computer Science\n   University College London\n   Gower Street\n   London\
    \ WC1E 6BT\n   UK\n   EMail: M.Handley@cs.ucl.ac.uk\n   Jitendra Padhye\n   Microsoft\
    \ Research\n   EMail: padhye@microsoft.com\n   Joerg Widmer\n   DoCoMo Euro-Labs\n\
    \   Landsberger Strasse 312\n   80687 Munich\n   Germany\n   EMail: widmer@acm.org\n"
- title: Full Copyright Statement
  contents:
  - "Full Copyright Statement\n   Copyright (C) The IETF Trust (2008).\n   This document\
    \ is subject to the rights, licenses and restrictions\n   contained in BCP 78,\
    \ and except as set forth therein, the authors\n   retain all their rights.\n\
    \   This document and the information contained herein are provided on an\n  \
    \ \"AS IS\" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS\n  \
    \ OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY, THE IETF TRUST AND\n   THE\
    \ INTERNET ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS\n   OR IMPLIED,\
    \ INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF\n   THE INFORMATION\
    \ HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED\n   WARRANTIES OF MERCHANTABILITY\
    \ OR FITNESS FOR A PARTICULAR PURPOSE.\n"
- title: Intellectual Property
  contents:
  - "Intellectual Property\n   The IETF takes no position regarding the validity or\
    \ scope of any\n   Intellectual Property Rights or other rights that might be\
    \ claimed to\n   pertain to the implementation or use of the technology described\
    \ in\n   this document or the extent to which any license under such rights\n\
    \   might or might not be available; nor does it represent that it has\n   made\
    \ any independent effort to identify any such rights.  Information\n   on the\
    \ procedures with respect to rights in RFC documents can be\n   found in BCP 78\
    \ and BCP 79.\n   Copies of IPR disclosures made to the IETF Secretariat and any\n\
    \   assurances of licenses to be made available, or the result of an\n   attempt\
    \ made to obtain a general license or permission for the use of\n   such proprietary\
    \ rights by implementers or users of this\n   specification can be obtained from\
    \ the IETF on-line IPR repository at\n   http://www.ietf.org/ipr.\n   The IETF\
    \ invites any interested party to bring to its attention any\n   copyrights, patents\
    \ or patent applications, or other proprietary\n   rights that may cover technology\
    \ that may be required to implement\n   this standard.  Please address the information\
    \ to the IETF at\n   ietf-ipr@ietf.org.\n"
