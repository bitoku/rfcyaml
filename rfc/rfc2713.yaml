- title: __initial_text__
  contents:
  - '     Schema for Representing Java(tm) Objects in an LDAP Directory

    '
- title: Status of this Memo
  contents:
  - "Status of this Memo\n   This memo provides information for the Internet community.\
    \  It does\n   not specify an Internet standard of any kind.  Distribution of\
    \ this\n   memo is unlimited.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (C) The Internet Society (1999).  All Rights Reserved.\n"
- title: Abstract
  contents:
  - "Abstract\n   This document defines the schema for representing Java(tm) objects\
    \ in\n   an LDAP directory [LDAPv3].  It defines schema elements to represent\n\
    \   a Java serialized object [Serial], a Java marshalled object [RMI], a\n   Java\
    \ remote object [RMI], and a JNDI reference [JNDI].\n"
- title: 1. Introduction
  contents:
  - "1. Introduction\n   This document assumes that the reader has a general knowledge\
    \ of the\n   Java programming language [Java].  For brevity we use the term \"\
    Java\n   object\" in place of \"object in the Java programming language\"\n  \
    \ throughout this text.\n   Traditionally, LDAP directories have been used to\
    \ store data. Users\n   and programmers think of the directory as a hierarchy\
    \ of directory\n   entries, each containing a set of attributes.  You look up\
    \ an entry\n   from the directory and extract the attribute(s) of interest.  For\n\
    \   example, you can look up a person's telephone number from the\n   directory.\
    \  Alternatively, you can search the directory for entries\n   with a particular\
    \ set of attributes.  For example, you can search for\n   all persons in the directory\
    \ with the surname \"Smith\".\n   For applications written in the Java programming\
    \ language, a kind of\n   data that is typically shared are Java objects themselves.\
    \  For such\n   applications, it makes sense to be able to use the directory as\
    \ a\n   repository for Java objects.  The directory provides a centrally\n   administered,\
    \ and possibly replicated, service for use by Java\n   applications distributed\
    \ across the network.\n   For example, an application server might use the directory\
    \ for\n   \"registering\" objects representing the services that it manages, so\n\
    \   that a client can later search the directory to locate those services\n  \
    \ as it needs.\n   The motivation for this document is to define a common way\
    \ for\n   applications to store and retrieve Java objects from the directory.\n\
    \   Using this common schema, any Java application that needs to read or\n   store\
    \ Java objects in the directory can do so in an interoperable\n   way.\n"
- title: 2 Representation of Java Objects
  contents:
  - "2 Representation of Java Objects\n   This document defines schema elements to\
    \ represent three types of\n   Java objects:  a Java serialized object, a Java\
    \ marshalled object,\n   and a JNDI reference. A Java remote object is stored\
    \ as either a Java\n   marshalled object or a JNDI reference.\n"
- title: 2.1 Common Representations
  contents:
  - "2.1 Common Representations\n   A Java object is stored in the LDAP directory\
    \ by using the object\n   class javaObject. This is the base class from which\
    \ other Java object\n   related classes derive: javaSerializedObject, javaMarshalledObject,\n\
    \   and javaNamingReference.  javaObject is an abstract object class,\n   which\
    \ means that a javaObject cannot exist by itself in the\n   directory; only auxiliary\
    \ or structural subclasses of it can exist in\n   the directory.\n   The object\
    \ class javaContainer represents a directory entry dedicated\n   to storing a\
    \ Java object. It is a structural object class.  In cases\n   where a subclass\
    \ of javaObject is mixed in with another structural\n   object class, javaContainer\
    \ is not required.\n   The definitions for the object classes javaObject and javaContainer\n\
    \   are presented in Section 4.\n   The javaObject class has one mandatory attribute\
    \ (javaClassName) and\n   four optional attributes (javaClassNames, javaCodebase,\
    \ javaDoc,\n   description).  javaClassName is a single valued attribute that\
    \ is\n   used to store the fully qualified name of the object's Java class\n \
    \  (for example, \"java.lang.String\").  This may be the object's most\n   derived\
    \ class's name, but does not have to be; that of a superclass\n   or interface\
    \ in some cases might be most appropriate.  This attribute\n   is intended for\
    \ storing the name of the object's \"distinguished\"\n   class, that is, the class\
    \ or interface with which the object should\n   be identified.\n   javaClassNames\
    \ is a multivalued attribute that is used to store the\n   fully qualified names\
    \ of the object's Java classes and interfaces\n   (for example, \"java.lang.Byte\"\
    ). Like all multivalued attributes, the\n   javaClassNames attribute's values\
    \ are unordered and so no one value\n   is more \"distinguished\" than the others.\
    \ This attribute is intended\n   for storing an object's class and interface names\
    \ and those of its\n   ancestor classes and interfaces, although the list of values\
    \ does not\n   have to be complete.  If the javaClassNames attribute is present,\
    \ it\n   should include the value of javaClassName.\n   For example, suppose an\
    \ object is stored in the directory with a\n   javaClassName attribute of \"java.io.FilePermission\"\
    , and a\n   javaClassNames attribute of {\"java.security.Permission\",\n   \"\
    java.io.FilePermission\", \"java.security.Guard\",\n   \"java.io.Serializable\"\
    }. An application searching a directory for\n   Java objects might use javaClassName\
    \ to produce a summary of the\n   names and types of Java objects in that directory.\
    \  Another\n   application might use the javaClassNames attribute to find, for\n\
    \   example, all java.security.Permission objects.\n   javaCodebase is a multivalued\
    \ attribute that is used to store the\n   location(s) of the object's class definition.\
    \  javaDoc is used to\n   store a pointer (URL) to the Java documentation for\
    \ the class.\n   description is used to store a textual description of a Java\
    \ object\n   and is defined in [v3Schema]. The definitions of these attributes\
    \ are\n   presented in Section 3.\n"
- title: 2.2 Serialized Objects
  contents:
  - "2.2 Serialized Objects\n   To \"serialize\" an object means to convert its state\
    \ into a byte\n   stream in such a way that the byte stream can be converted back\
    \ into\n   a copy of the object.  A Java object is \"serializable\" if its class\n\
    \   or any of its superclasses implements either the java.io.Serializable\n  \
    \ interface or its subinterface java.io.Externalizable.\n   \"Deserialization\"\
    \ is the process of converting the serialized form of\n   an object back into\
    \ a copy of the object.  When an object is\n   serialized, the entire tree of\
    \ objects rooted at the object is also\n   serialized. When it is deserialized,\
    \ the tree is reconstructed. For\n   example, suppose a serializable Book object\
    \ contains (a serializable\n   field of) an array of Page objects.  When a Book\
    \ object is\n   serialized, so is the array of Page objects.\n   The Java platform\
    \ specifies a default algorithm by which serializable\n   objects are serialized.\
    \ A Java class can also override this default\n   serialization with its own algorithm.\
    \  [Serial] describes object\n   serialization in detail.\n   When an object is\
    \ serialized, information that identifies its class\n   is recorded in the serialized\
    \ stream. However, the class's definition\n   (\"class file\") itself is not recorded.\
    \ It is the responsibility of\n   the system that is deserializing the object\
    \ to determine the\n   mechanism to use for locating and loading the associated\
    \ class\n   definitions. For example, the Java application might include in its\n\
    \   classpath a JAR file containing the class definitions of the\n   serialized\
    \ object, or load the class definitions using information\n   from the directory,\
    \ as explained below.\n"
- title: 2.2.1 Representation in the Directory
  contents:
  - "2.2.1 Representation in the Directory\n   A serialized object is represented\
    \ in the directory by the attributes\n   javaClassName, javaClassNames, javaCodebase,\
    \ and javaSerializedData,\n   as defined in Section 3.  The mandatory attribute,\n\
    \   javaSerializedData, contains the serialized form of the object.\n   Although\
    \ the serialized form already contains the class name, the\n   mandatory javaClassName\
    \ attribute also records the class name of the\n   serialized object so that applications\
    \ can determined class\n   information without having to first deserialize the\
    \ object.  The\n   optional javaClassNames attribute is used to record additional\
    \ class\n   information about the serialized object.  The optional javaCodebase\n\
    \   attribute is used to record the locations of the class definitions\n   needed\
    \ to deserialize the serialized object.\n   A directory entry that contains a\
    \ serialized object is represented by\n   the object class javaSerializedObject,\
    \ which is a subclass of\n   javaObject.  javaSerializedObject is an auxiliary\
    \ object class, which\n   means that it needs to be mixed in with a structural\
    \ object class.\n   javaSerializedObject's definition is given in Section 4.\n"
- title: 2.3 Marshalled Objects
  contents:
  - "2.3 Marshalled Objects\n   To \"marshal\" an object means to record its state\
    \ and codebase(s) in\n   such a way that when the marshalled object is \"unmarshalled,\"\
    \ a copy\n   of the original object is obtained, possibly by automatically loading\n\
    \   the class definitions of the object.  You can marshal any object that\n  \
    \ is serializable or remote (that is, implements the java.rmi.Remote\n   interface).\
    \  Marshalling is like serialization, except marshalling\n   also records codebases.\
    \ Marshalling is different from serialization\n   in that marshalling treats remote\
    \ objects specially. If an object is\n   a java.rmi.Remote object, marshalling\
    \ records the remote object's\n   \"stub\" (see Section 2.5), instead of the remote\
    \ object itself.  Like\n   serialization, when an object is marshalled, the entire\
    \ tree of\n   objects rooted at the object is marshalled. When it is unmarshalled,\n\
    \   the tree is reconstructed.\n   A \"marshalled\" object is the represented\
    \ by the\n   java.rmi.MarshalledObject class. Here's an example of how to create\n\
    \   MarshalledObjects for serializable and remote objects:\n       java.io.Serializable\
    \ sobj = ...;\n       java.rmi.MarshalledObject mobj1 =\n           new java.rmi.MarshalledObject(sobj);\n\
    \       java.rmi.Remote robj = ...;\n       java.rmi.MarshalledObject mobj2 =\n\
    \           new java.rmi.MarshalledObject(robj);\n   Then, to retrieve the original\
    \ objects from the MarshalledObjects, do\n   as follows:\n       java.io.Serializable\
    \ sobj = (java.io.Serializable) mobj1.get();\n       java.io.Remote rstub = (java.io.Remote)\
    \ mobj2.get();\n   MarshalledObject is available only on the Java 2 Platform,\
    \ Standard\n   Edition, v1.2, and higher releases.\n"
- title: 2.3.1 Representation in the Directory
  contents:
  - "2.3.1 Representation in the Directory\n   A marshalled object is represented\
    \ in the directory by the attributes\n   javaClassName, javaClassNames, and javaSerializedData,\
    \ as defined in\n   Section 3.  The mandatory attribute, javaSerializedData, contains\
    \ the\n   serialized form of the marshalled object (that is, the serialized\n\
    \   form of a MarshalledObject instance).  The mandatory javaClassName\n   attribute\
    \ records the distinguished class name of the object before\n   it has been marshalled.\
    \  The optional javaClassNames attribute is\n   used to record additional class\
    \ information about the object before\n   it has been marshalled.\n   A directory\
    \ entry that contains a marshalled object is represented by\n   the object class\
    \ javaMarshalledObject, which is a subclass of\n   javaObject.  javaMarshalledObject\
    \ is an auxiliary object class, which\n   means that it needs to be mixed in with\
    \ a structural object class.\n   javaMarshalledObject's definition is given in\
    \ Section 4.\n   As evident in this description, a javaMarshalledObject differs\
    \ from a\n   javaSerializedObject only in the interpretation of the javaClassName\n\
    \   and javaClassNames attributes.\n"
- title: 2.4 JNDI References
  contents:
  - "2.4 JNDI References\n   Java Naming and Directory Interface(tm) (JNDI) is a directory\
    \ access\n   API specified in the Java programming language [JNDI].  It provides\n\
    \   an object-oriented view of the directory, allowing Java objects to be\n  \
    \ added to and retrieved from the directory without requiring the\n   client to\
    \ manage data representation issues.\n   JNDI defines the notion of a \"reference\"\
    \ for use when an object\n   cannot be stored in the directory directly, or when\
    \ it is\n   inappropriate or undesirable to do so.  An object with an associated\n\
    \   reference is stored in the directory indirectly, by storing its\n   reference\
    \ instead.\n"
- title: 2.4.1 Contents of a Reference
  contents:
  - "2.4.1 Contents of a Reference\n   A JNDI reference is a Java object of class\
    \ javax.naming.Reference.\n   It consists of class information about the object\
    \ being referenced\n   and an ordered list of addresses.  An address is a Java\
    \ object of\n   class javax.naming.RefAddr.  Each address contains information\
    \ on how\n   to construct the object.\n   A common use for JNDI references is\
    \ to represent connections to a\n   network service such as a database, directory,\
    \ or file system.  Each\n   address may then identify a \"communications endpoint\"\
    \ for that\n   service, containing information on how to contact the service.\n\
    \   Multiple addresses may arise for various reasons, such as replication\n  \
    \ or the object offering interfaces over more than one communication\n   mechanism.\n\
    \   A reference also contains information to assist in the creation of an\n  \
    \ instance of the object to which the reference refers.  It contains\n   the Java\
    \ class name of that object, and the class name and location\n   of the object\
    \ factory to be used to create the object.  The\n   procedures for creating an\
    \ object given its reference and the reverse\n   are described in [JNDI].\n"
- title: 2.4.2 Representation in the Directory
  contents:
  - "2.4.2 Representation in the Directory\n   A JNDI reference is stored in the directory\
    \ by using the attributes\n   javaClassName, javaClassNames, javaCodebase, javaReferenceAddress,\n\
    \   and javaFactory, defined in Section 3.  These attributes store\n   information\
    \ corresponding to the contents of a reference described\n   above.  javaReferenceAddress\
    \ is a multivalued optional attribute for\n   storing reference addresses.  javaFactory\
    \ is the optional attribute\n   for storing the object factory's fully qualified\
    \ class name.  The\n   mandatory javaClassName attribute is used to store the\
    \ name of the\n   distinguished class of the object.  The optional javaClassNames\n\
    \   attribute is used to record additional class and interface names.\n   The\
    \ optional javaCodebase attribute is used to store the locations of\n   the object\
    \ factory's and the object's class definitions.\n   A directory entry containing\
    \ a JNDI reference is represented by the\n   object class javaNamingReference,\
    \ which is a subclass of javaObject.\n   javaNamingReference is an auxiliary object\
    \ class, which means that it\n   needs to be mixed in with a structural object\
    \ class.\n   javaNamingReference's definition is given in Section 4.\n"
- title: 2.5 Remote Objects
  contents:
  - "2.5 Remote Objects\n   The Java Remote Method Invocation (RMI) system [RMI] is\
    \ a mechanism\n   that enables an object on one Java virtual machine to invoke\
    \ methods\n   on an object in another Java virtual machine. Any object whose\n\
    \   methods can be invoked in this way must implement the java.rmi.Remote\n  \
    \ interface.  When such an object is invoked, its arguments are\n   marshalled\
    \ and sent from the local virtual machine to the remote one,\n   where the arguments\
    \ are unmarshalled and used.  When the method\n   terminates, the results are\
    \ marshalled from the remote machine and\n   sent to the caller's virtual machine.\n\
    \   To make a remote object accessible to other virtual machines, a\n   program\
    \ typically registers it with the RMI registry.  The program\n   supplies to the\
    \ RMI registry the string name of the remote object and\n   the remote object\
    \ itself.  When a program wants to access a remote\n   object, it supplies the\
    \ object's string name to the RMI registry on\n   the same machine as the remote\
    \ object.  The RMI registry returns to\n   the caller a reference (called \"stub\"\
    ) to the remote object.  When\n   the program receives the stub for the remote\
    \ object, it can invoke\n   methods on the remote object (through the stub). \
    \ A program can also\n   obtain references to remote objects as a result of remote\
    \ calls to\n   other remote objects or from other naming services.  For example,\
    \ the\n   program can look up a reference to a remote object from an LDAP\n  \
    \ server that supports the schema defined in this document.\n   The string name\
    \ accepted by the RMI registry has the syntax\n   \"rmi://hostname:port/remoteObjectName\"\
    , where \"hostname\" and \"port\"\n   identify the machine and port on which the\
    \ RMI registry is running,\n   respectively, and \"remoteObjectName\" is the string\
    \ name of the remote\n   object.  \"hostname\", \"port\", and the prefix, \"rmi:\"\
    , are optional. If\n   \"hostname\" is not specified, it defaults to the local\
    \ host.  If\n   \"port\" is not specified, it defaults to 1099.  If \"remoteObjectName\"\
    \n   is not specified, then the object being named is the RMI registry\n   itself.\
    \  See [RMI] for details.\n   RMI can be supported using different protocols:\
    \ the Java Remote\n   Method Protocol (JRMP) and the Internet Inter-ORB Protocol\
    \ (IIOP).\n   The JRMP is a specialized protocol designed for RMI; the IIOP is\
    \ the\n   standard protocol for communication between CORBA objects [CORBA].\n\
    \   RMI over IIOP allows Java remote objects to communicate with CORBA\n   objects\
    \ which might be written in a non-Java programming language\n   [RMI-IIOP].\n"
- title: 2.5.1 Representation in the Directory
  contents:
  - "2.5.1 Representation in the Directory\n   Remote objects that use the IIOP are\
    \ represented in the directory as\n   CORBA object references [CORBA-LDAP].  Remote\
    \ objects that use the\n   JRMP are represented in the directory in one of two\
    \ ways: as a\n   marshalled object, or as a JNDI reference.\n   A marshalled object\
    \ records the codebases of the remote object's stub\n   and any serializable or\
    \ remote objects that it references, and\n   replaces remote objects with their\
    \ stubs.  To store a Remote object\n   as a marshalled object (java.rmi.MarshalledObject),\
    \ you first create\n   a java.rmi.MarshalledObject instance for it.\n       java.rmi.Remote\
    \ robj = ...;\n       java.rmi.MarshalledObject mobj =\n           new java.rmi.MarshalledObject(robj);\n\
    \   You can then store the MarshalledObject instance as a\n   javaMarshalledObject.\
    \  The javaClassName attribute should contain the\n   fully qualified name of\
    \ the distinguished class of the remote object.\n   The javaClassNames attribute\
    \ should contain the names of the classes\n   and interfaces of the remote object.\
    \  To read the remote object back\n   from the directory, first deserialize the\
    \ contents of the\n   javaSerializedData to get a MarshalledObject (mobj), then\
    \ retrieve it\n   from the MarshalledObject as follows:\n       java.rmi.Remote\
    \ robj = (java.rmi.Remote)mobj.get();\n   This returns the remote stub, which\
    \ you can then use to invoke remote\n   methods.\n   MarshalledObject is available\
    \ only on the Java 2 Platform, Standard\n   Edition, v1.2 and higher releases.\
    \ Therefore, a remote object stored\n   as a MarshalledObject can only be read\
    \ by clients using the the Java\n   2 Platform, Standard Edition, v1.2 or higher\
    \ releases.\n   To store a remote object as a JNDI reference, you first create\
    \ a\n   javax.naming.Reference object instance for it using the remote\n   object's\
    \ string name as it has been, or will be, recorded with the\n   RMI registry,\
    \ with the additional restriction that the \"rmi:\" prefix\n   must be present.\
    \ Here's an example:\n       javax.naming.Reference ref = new javax.naming.Reference(\n\
    \         obj.getClass().getName(),\n         new javax.naming.StringRefAddr(\"\
    URL\",\n             \"rmi://rserver/AppRemoteObjectX\"));\n   You then store\
    \ the javax.naming.Reference instance as a\n   javaNamingReference.  The advantage\
    \ of using a JNDI reference is that\n   this can be done without a reference to\
    \ the remote object. In fact,\n   the remote object does not have to exist at\
    \ the time that this\n   recording in the directory is made.  The remote object\
    \ needs to exist\n   and be bound with the RMI registry when the object is looked\
    \ up from\n   the directory.\n"
- title: 2.6  Serialized Objects Vs. Marshalled Objects Vs. References
  contents:
  - "2.6  Serialized Objects Vs. Marshalled Objects Vs. References\n   The object\
    \ classes defined in this document store different aspects\n   of the Java objects.\n\
    \   A javaSerializedObject or a serializable object stored as a\n   javaMarshalledObject\
    \ represents the object itself, while a\n   javaNamingReference or a remote object\
    \ stored as a\n   javaMarshalledObject represents a \"pointer\" to the object.\n\
    \   When storing a serializable object in the directory, you have a\n   choice\
    \ of storing it as a javaSerializedObject or a\n   javaMarshalledObject.  The\
    \ javaSerializedObject object class provides\n   the basic way in which to store\
    \ serializable objects. When you create\n   an LDAP entry using the javaSerializableObject\
    \ object class, you must\n   explicitly set the javaCodebase attribute if you\
    \ want readers of that\n   entry to know where to load the class definitions of\
    \ the object. When\n   you create an LDAP entry using the javaMarshalledObject\
    \ object class,\n   you use the MarshalledObject class.  The MarshalledObject\
    \ class uses\n   the RMI infrastructure available on the Java platform to automate\
    \ how\n   codebase information is gathered and recorded, thus freeing you from\n\
    \   having to set the javaCodebase attribute. On the other hand, the\n   javaCodebase\
    \ attribute is human-readable and can be updated easily by\n   using text-based\
    \ tools without having to change other parts of the\n   entry.  This allows you,\
    \ for instance, to move the class definitions\n   to another location and then\
    \ update the javaCodebase attribute to\n   reflect the move without having to\
    \ update the serialized object\n   itself.\n   A javaNamingReference provides\
    \ a way of recording address information\n   about an object which itself is not\
    \ directly stored in the directory.\n   A remote object stored as a javaMarshalledObject\
    \ also records address\n   information (the object's \"stub\") of an object which\
    \ itself is not\n   directory stored in the directory.  In other words, you can\
    \ think of\n   these as compact representations of the information required to\n\
    \   access the object.\n   A javaNamingReference typically consists of a small\
    \ number of human-\n   readable strings.  Standard text-based tools for directory\n\
    \   administration may therefore be used to add, read, or modify\n   reference\
    \ entries -- if so desired -- quite easily.  Serialized and\n   marshalled objects\
    \ are not intended to be read or manipulated\n   directly by humans.\n"
- title: 3 Attribute Type Definitions
  contents:
  - "3 Attribute Type Definitions\n   The following attribute types are defined in\
    \ this document:\n       javaClassName\n       javaClassNames\n       javaCodebase\n\
    \       javaSerializedData\n       javaFactory\n       javaReferenceAddress\n\
    \       javaDoc\n"
- title: 3.1 javaClassName
  contents:
  - "3.1 javaClassName\n   This attribute stores the fully qualified name of the Java\
    \ object's\n   \"distinguished\" class or interface (for example, \"java.lang.String\"\
    ).\n   It is a single-valued attribute. This attribute's syntax is '\n   Directory\
    \ String' and its case is significant.\n       ( 1.3.6.1.4.1.42.2.27.4.1.6\n \
    \        NAME 'javaClassName'\n         DESC 'Fully qualified name of distinguished\
    \ Java class or\n               interface'\n         EQUALITY caseExactMatch\n\
    \         SYNTAX 1.3.6.1.4.1.1466.115.121.1.15\n         SINGLE-VALUE\n      \
    \ )\n"
- title: 3.2 javaCodebase
  contents:
  - "3.2 javaCodebase\n   This attribute stores the Java class definition's locations.\
    \  It\n   specifies the locations from which to load the class definition for\n\
    \   the class specified by the javaClassName attribute.  Each value of\n   the\
    \ attribute contains an ordered list of URLs, separated by spaces.\n   For example,\
    \ a value of \"url1 url2 url3\" means that the three\n   (possibly interdependent)\
    \ URLs (url1, url2, and url3) form the\n   codebase for loading in the Java class\
    \ definition.\n   If the javaCodebase attribute contains more than one value,\
    \ each\n   value is an independent codebase. That is, there is no relationship\n\
    \   between the URLs in one value and those in another; each value can be\n  \
    \ viewed as an alternate source for loading the Java class definition.\n   See\
    \ [Java] for information regarding class loading.\n   This attribute's syntax\
    \ is 'IA5 String' and its case is significant.\n       ( 1.3.6.1.4.1.42.2.27.4.1.7\n\
    \         NAME 'javaCodebase'\n         DESC 'URL(s) specifying the location of\
    \ class definition'\n         EQUALITY caseExactIA5Match\n         SYNTAX 1.3.6.1.4.1.1466.115.121.1.26\n\
    \       )\n"
- title: 3.3 javaClassNames
  contents:
  - "3.3 javaClassNames\n   This attribute stores the Java object's fully qualified\
    \ class or\n   interface names (for example, \"java.lang.String\").  It is a\n\
    \   multivalued attribute. When more than one value is present, each is\n   the\
    \ name of a class or interface, or ancestor class or interface, of\n   this object.\n\
    \   This attribute's syntax is 'Directory String' and its case is\n   significant.\n\
    \       ( 1.3.6.1.4.1.42.2.27.4.1.13\n         NAME 'javaClassNames'\n       \
    \  DESC 'Fully qualified Java class or interface name'\n         EQUALITY caseExactMatch\n\
    \         SYNTAX 1.3.6.1.4.1.1466.115.121.1.15\n       )\n"
- title: 3.4 javaSerializedData
  contents:
  - "3.4 javaSerializedData\n   This attribute stores the serialized form of a Java\
    \ object.  The\n   serialized form is described in [Serial].\n   This attribute's\
    \ syntax is 'Octet String'.\n       ( 1.3.6.1.4.1.42.2.27.4.1.8\n         NAME\
    \ 'javaSerializedData\n         DESC 'Serialized form of a Java object'\n    \
    \     SYNTAX 1.3.6.1.4.1.1466.115.121.1.40\n         SINGLE-VALUE\n       )\n"
- title: 3.5 javaFactory
  contents:
  - "3.5 javaFactory\n   This attribute stores the fully qualified class name of the\
    \ object\n   factory (for example, \"com.wiz.jndi.WizObjectFactory\") that can\
    \ be\n   used to create an instance of the object identified by the\n   javaClassName\
    \ attribute.\n   This attribute's syntax is 'Directory String' and its case is\n\
    \   significant.\n       ( 1.3.6.1.4.1.42.2.27.4.1.10\n         NAME 'javaFactory'\n\
    \         DESC 'Fully qualified Java class name of a JNDI object factory'\n  \
    \       EQUALITY caseExactMatch\n         SYNTAX 1.3.6.1.4.1.1466.115.121.1.15\n\
    \         SINGLE-VALUE\n       )\n"
- title: 3.6 javaReferenceAddress
  contents:
  - "3.6 javaReferenceAddress\n   This attribute represents the sequence of addresses\
    \ of a JNDI\n   reference.  Each of its values represents one address, a Java\
    \ object\n   of type javax.naming.RefAddr.  Its value is a concatenation of the\n\
    \   address type and address contents, preceded by a sequence number (the\n  \
    \ order of addresses in a JNDI reference is significant).  For example:\n    \
    \   #0#TypeA#ValA\n       #1#TypeB#ValB\n       #2#TypeC##rO0ABXNyABpq...\n  \
    \ In more detail, the value is encoded as follows:\n   The delimiter is the first\
    \ character of the value.  For readability\n   the character '#' is recommended\
    \ when it is not otherwise used\n   anywhere in the value, but any character may\
    \ be used subject to\n   restrictions given below.\n   The first delimiter is\
    \ followed by the sequence number.  The sequence\n   number of an address is its\
    \ position in the JNDI reference, with the\n   first address being numbered 0.\
    \  It is represented by its shortest\n   string form, in decimal notation.\n \
    \  The sequence number is followed by a delimiter, then by the address\n   type,\
    \ and then by another delimiter.  If the address is of Java class\n   javax.naming.StringRefAddr,\
    \ then this delimiter is followed by the\n   value of the address contents (which\
    \ is a string).  Otherwise, this\n   delimiter is followed immediately by another\
    \ delimiter, and then by\n   the Base64 encoding of the serialized form of the\
    \ entire address.\n   The delimiter may be any character other than a digit or\
    \ a character\n   contained in the address type.  In addition, if the address\
    \ contents\n   is a string, the delimiter may not be the first character of that\n\
    \   string.\n   This attribute's syntax is 'Directory String' and its case is\n\
    \   significant.  It can contain multiple values.\n       ( 1.3.6.1.4.1.42.2.27.4.1.11\n\
    \         NAME 'javaReferenceAddress'\n         DESC 'Addresses associated with\
    \ a JNDI Reference'\n         EQUALITY caseExactMatch\n         SYNTAX 1.3.6.1.4.1.1466.115.121.1.15\n\
    \       )\n"
- title: 3.7 javaDoc
  contents:
  - "3.7 javaDoc\n   This attribute stores a pointer to the Java documentation for\
    \ the\n   class.  It's value is a URL. For example, the following URL points to\n\
    \   the specification of the java.lang.String class:\n   http://java.sun.com/products/jdk/1.2/docs/api/java/lang/String.html\n\
    \   This attribute's syntax is 'IA5 String' and its case is significant.\n   \
    \    ( 1.3.6.1.4.1.42.2.27.4.1.12\n         NAME 'javaDoc'\n         DESC 'The\
    \ Java documentation for the class'\n         EQUALITY caseExactIA5Match\n   \
    \      SYNTAX 1.3.6.1.4.1.1466.115.121.1.26\n       )\n"
- title: 4 Object Class Definitions
  contents:
  - "4 Object Class Definitions\n   The following object classes are defined in this\
    \ document:\n       javaContainer\n       javaObject\n       javaSerializedObject\n\
    \       javaMarshalledObject\n       javaNamingReference\n"
- title: 4.1 javaContainer
  contents:
  - "4.1 javaContainer\n   This structural object class represents a container for\
    \ a Java\n   object.\n       ( 1.3.6.1.4.1.42.2.27.4.2.1\n         NAME 'javaContainer'\n\
    \         DESC 'Container for a Java object'\n         SUP top\n         STRUCTURAL\n\
    \         MUST ( cn )\n       )\n"
- title: 4.2 javaObject
  contents:
  - "4.2 javaObject\n   This abstract object class represents a Java object.  A javaObject\n\
    \   cannot exist in the directory; only auxiliary or structural\n   subclasses\
    \ of it can exist in the directory.\n       ( 1.3.6.1.4.1.42.2.27.4.2.4\n    \
    \     NAME 'javaObject'\n         DESC 'Java object representation'\n        \
    \ SUP top\n         ABSTRACT\n         MUST ( javaClassName )\n         MAY (\
    \ javaClassNames $\n               javaCodebase $\n               javaDoc $\n\
    \               description )\n       )\n"
- title: 4.3 javaSerializedObject
  contents:
  - "4.3 javaSerializedObject\n   This auxiliary object class represents a Java serialized\
    \ object.  It\n   must be mixed in with a structural object class.\n       ( 1.3.6.1.4.1.42.2.27.4.2.5\n\
    \         NAME 'javaSerializedObject'\n         DESC 'Java serialized object'\n\
    \         SUP javaObject\n         AUXILIARY\n         MUST ( javaSerializedData\
    \ )\n       )\n"
- title: 4.4 javaMarshalledObject
  contents:
  - "4.4 javaMarshalledObject\n   This auxiliary object class represents a Java marshalled\
    \ object.  It\n   must be mixed in with a structural object class.\n       ( 1.3.6.1.4.1.42.2.27.4.2.8\n\
    \         NAME 'javaMarshalledObject'\n         DESC 'Java marshalled object'\n\
    \         SUP javaObject\n         AUXILIARY\n         MUST ( javaSerializedData\
    \ )\n       )\n"
- title: 4.5 javaNamingReference
  contents:
  - "4.5 javaNamingReference\n   This auxiliary object class represents a JNDI reference.\
    \  It must be\n   mixed in with a structural object class.\n       ( 1.3.6.1.4.1.42.2.27.4.2.7\n\
    \         NAME 'javaNamingReference'\n         DESC 'JNDI reference'\n       \
    \  SUP javaObject\n         AUXILIARY\n         MAY ( javaReferenceAddress $\n\
    \               javaFactory )\n       )\n"
- title: 5. Security Considerations
  contents:
  - "5. Security Considerations\n   Serializing an object and storing it into the\
    \ directory enables (a\n   copy of) the object to be examined and used outside\
    \ the environment\n   in which it was originally created.  The directory entry\
    \ containing\n   the serialized object could be read and modified within the\n\
    \   constraints imposed by the access control mechanisms of the\n   directory.\
    \  If an object contains sensitive information or\n   information that could be\
    \ misused outside of the context in which it\n   was created, the object should\
    \ not be stored in the directory.  For\n   more details on security issues relating\
    \ to serialization in general,\n   see [Serial].\n"
- title: 6. Acknowledgements
  contents:
  - "6. Acknowledgements\n   We would like to thank Joseph Fialli, Peter Jones, Roger\
    \ Riggs, Bob\n   Scheifler, and Ann Wollrath of Sun Microsystems for their comments\n\
    \   and suggestions.\n"
- title: 7. References
  contents:
  - "7. References\n   [CORBA]      The Object Management Group, \"Common Object Request\n\
    \                Broker Architecture Specification 2.0,\"\n                http://www.omg.org\n\
    \   [CORBA-LDAP] Ryan, V., Lee, R. and S. Seligman, \"Schema for\n           \
    \     Representing CORBA Object References in an LDAP\n                Directory\"\
    , RFC 2714, October 1999.\n   [Java]       Ken Arnold and James Gosling, \"The\
    \ Java(tm) Programming\n                Language,\" Second Edition, ISBN 0-201-31006-6.\n\
    \   [JNDI]       Java Software, Sun Microsystems, Inc., \"The Java(tm)\n     \
    \           Naming and Directory Interface (tm) Specification,\"\n           \
    \     February 1998.  http://java.sun.com/products/jndi/\n   [LDAPv3]     Wahl,\
    \ M., Howes, T. and  S. Kille, \"Lightweight\n                Directory Access\
    \ Protocol (v3)\", RFC 2251, December\n                1997.\n   [RMI]       \
    \ Java Software, Sun Microsystems, Inc., \"Remote Method\n                Invocation,\"\
    \ November 1998.\n                http://java.sun.com/products/jdk/1.2/docs/guide/rmi\n\
    \   [RMI-IIOP]   IBM and Java Software, Sun Microsystems, Inc., \"RMI over\n \
    \               IIOP\", June 1999.\n                http://java.sun.com/products/rmi-iiop/\n\
    \   [Serial]     Java Software, Sun Microsystems, Inc., \"Object\n           \
    \     Serialization Specification,\" November 1998.\n                http://java.sun.com/products/jdk/1.2/docs/guide/\n\
    \                serialization\n   [v3Schema]   Wahl, M., \"A Summary of the X.500(96)\
    \ User Schema for\n                use with LDAPv3\", RFC 2256, December 1997.\n"
- title: 8. Authors' Addresses
  contents:
  - "8. Authors' Addresses\n   Vincent Ryan\n   Sun Microsystems, Inc.\n   Mail Stop\
    \ EDUB03\n   901 San Antonio Road\n   Palo Alto, CA 94303\n   USA\n   Phone: +353\
    \ 1 819 9151\n   EMail: vincent.ryan@ireland.sun.com\n   Scott Seligman\n   Sun\
    \ Microsystems, Inc.\n   Mail Stop UCUP02-209\n   901 San Antonio Road\n   Palo\
    \ Alto, CA 94303\n   USA\n   Phone: +1 408 863 3222\n   EMail: scott.seligman@eng.sun.com\n\
    \   Rosanna Lee\n   Sun Microsystems, Inc.\n   Mail Stop UCUP02-206\n   901 San\
    \ Antonio Road\n   Palo Alto, CA 94303\n   USA\n   Phone: +1 408 863 3221\n  \
    \ EMail: rosanna.lee@eng.sun.com\n"
- title: Appendix - LDAP Schema
  contents:
  - "Appendix - LDAP Schema\n  -- Attribute types --\n  ( 1.3.6.1.4.1.42.2.27.4.1.6\n\
    \    NAME 'javaClassName'\n    DESC 'Fully qualified name of distinguished Java\
    \ class or interface'\n    EQUALITY caseExactMatch\n    SYNTAX 1.3.6.1.4.1.1466.115.121.1.15\n\
    \    SINGLE-VALUE\n  )\n  ( 1.3.6.1.4.1.42.2.27.4.1.7\n    NAME 'javaCodebase'\n\
    \    DESC 'URL(s) specifying the location of class definition'\n    EQUALITY caseExactIA5Match\n\
    \    SYNTAX 1.3.6.1.4.1.1466.115.121.1.26\n  )\n  ( 1.3.6.1.4.1.42.2.27.4.1.8\n\
    \    NAME 'javaSerializedData'\n    DESC 'Serialized form of a Java object'\n\
    \    SYNTAX 1.3.6.1.4.1.1466.115.121.1.40\n    SINGLE-VALUE\n  )\n  ( 1.3.6.1.4.1.42.2.27.4.1.10\n\
    \    NAME 'javaFactory'\n    DESC 'Fully qualified Java class name of a JNDI object\
    \ factory'\n    EQUALITY caseExactMatch\n    SYNTAX 1.3.6.1.4.1.1466.115.121.1.15\n\
    \    SINGLE-VALUE\n  )\n  ( 1.3.6.1.4.1.42.2.27.4.1.11\n    NAME 'javaReferenceAddress'\n\
    \    DESC 'Addresses associated with a JNDI Reference'\n    EQUALITY caseExactMatch\n\
    \    SYNTAX 1.3.6.1.4.1.1466.115.121.1.15\n  )\n  ( 1.3.6.1.4.1.42.2.27.4.1.12\n\
    \    NAME 'javaDoc'\n    DESC 'The Java documentation for the class'\n    EQUALITY\
    \ caseExactIA5Match\n    SYNTAX 1.3.6.1.4.1.1466.115.121.1.26\n  )\n  ( 1.3.6.1.4.1.42.2.27.4.1.13\n\
    \    NAME 'javaClassNames'\n    DESC 'Fully qualified Java class or interface\
    \ name'\n    EQUALITY caseExactMatch\n    SYNTAX 1.3.6.1.4.1.1466.115.121.1.15\n\
    \  )\n  -- from RFC-2256 --\n  ( 2.5.4.13\n    NAME 'description'\n    EQUALITY\
    \ caseIgnoreMatch\n    SUBSTR caseIgnoreSubstringsMatch\n    SYNTAX 1.3.6.1.4.1.1466.115.121.1.15{1024}\n\
    \  )\n  -- Object classes --\n  ( 1.3.6.1.4.1.42.2.27.4.2.1\n    NAME 'javaContainer'\n\
    \    DESC 'Container for a Java object'\n    SUP top\n    STRUCTURAL\n    MUST\
    \ ( cn )\n  )\n  ( 1.3.6.1.4.1.42.2.27.4.2.4\n    NAME 'javaObject'\n    DESC\
    \ 'Java object representation'\n    SUP top\n    ABSTRACT\n    MUST ( javaClassName\
    \ )\n    MAY ( javaClassNames $ javaCodebase $ javaDoc $ description )\n  )\n\
    \  ( 1.3.6.1.4.1.42.2.27.4.2.5\n    NAME 'javaSerializedObject'\n    DESC 'Java\
    \ serialized object'\n    SUP javaObject\n    AUXILIARY\n    MUST ( javaSerializedData\
    \ )\n  )\n  ( 1.3.6.1.4.1.42.2.27.4.2.7\n    NAME 'javaNamingReference'\n    DESC\
    \ 'JNDI reference'\n    SUP javaObject\n    AUXILIARY\n    MAY ( javaReferenceAddress\
    \ $ javaFactory )\n  )\n  ( 1.3.6.1.4.1.42.2.27.4.2.8\n    NAME 'javaMarshalledObject'\n\
    \    DESC 'Java marshalled object'\n    SUP javaObject\n    AUXILIARY\n    MUST\
    \ ( javaSerializedData )\n  )\n  -- Matching rule from ISO X.520 --\n  ( 2.5.13.5\n\
    \    NAME 'caseExactMatch'\n    SYNTAX 1.3.6.1.4.1.1466.115.121.1.15\n  )\n"
- title: Full Copyright Statement
  contents:
  - "Full Copyright Statement\n   Copyright (C) The Internet Society (1999).  All\
    \ Rights Reserved.\n   This document and translations of it may be copied and\
    \ furnished to\n   others, and derivative works that comment on or otherwise explain\
    \ it\n   or assist in its implementation may be prepared, copied, published\n\
    \   and distributed, in whole or in part, without restriction of any\n   kind,\
    \ provided that the above copyright notice and this paragraph are\n   included\
    \ on all such copies and derivative works.  However, this\n   document itself\
    \ may not be modified in any way, such as by removing\n   the copyright notice\
    \ or references to the Internet Society or other\n   Internet organizations, except\
    \ as needed for the purpose of\n   developing Internet standards in which case\
    \ the procedures for\n   copyrights defined in the Internet Standards process\
    \ must be\n   followed, or as required to translate it into languages other than\n\
    \   English.\n   The limited permissions granted above are perpetual and will\
    \ not be\n   revoked by the Internet Society or its successors or assigns.\n \
    \  This document and the information contained herein is provided on an\n   \"\
    AS IS\" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING\n   TASK FORCE\
    \ DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING\n   BUT NOT LIMITED\
    \ TO ANY WARRANTY THAT THE USE OF THE INFORMATION\n   HEREIN WILL NOT INFRINGE\
    \ ANY RIGHTS OR ANY IMPLIED WARRANTIES OF\n   MERCHANTABILITY OR FITNESS FOR A\
    \ PARTICULAR PURPOSE.\n"
- title: Acknowledgement
  contents:
  - "Acknowledgement\n   Funding for the RFC Editor function is currently provided\
    \ by the\n   Internet Society.\n"
