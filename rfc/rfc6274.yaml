- title: __initial_text__
  contents:
  - '         Security Assessment of the Internet Protocol Version 4

    '
- title: Abstract
  contents:
  - "Abstract\n   This document contains a security assessment of the IETF\n   specifications\
    \ of the Internet Protocol version 4 and of a number of\n   mechanisms and policies\
    \ in use by popular IPv4 implementations.  It\n   is based on the results of a\
    \ project carried out by the UK's Centre\n   for the Protection of National Infrastructure\
    \ (CPNI).\n"
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This document is not an Internet Standards Track specification;\
    \ it is\n   published for informational purposes.\n   This document is a product\
    \ of the Internet Engineering Task Force\n   (IETF).  It represents the consensus\
    \ of the IETF community.  It has\n   received public review and has been approved\
    \ for publication by the\n   Internet Engineering Steering Group (IESG).  Not\
    \ all documents\n   approved by the IESG are a candidate for any level of Internet\n\
    \   Standard; see Section 2 of RFC 5741.\n   Information about the current status\
    \ of this document, any errata,\n   and how to provide feedback on it may be obtained\
    \ at\n   http://www.rfc-editor.org/info/rfc6274.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (c) 2011 IETF Trust and the persons identified\
    \ as the\n   document authors.  All rights reserved.\n   This document is subject\
    \ to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n\
    \   (http://trustee.ietf.org/license-info) in effect on the date of\n   publication\
    \ of this document.  Please review these documents\n   carefully, as they describe\
    \ your rights and restrictions with respect\n   to this document.  Code Components\
    \ extracted from this document must\n   include Simplified BSD License text as\
    \ described in Section 4.e of\n   the Trust Legal Provisions and are provided\
    \ without warranty as\n   described in the Simplified BSD License.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1. Preface .........................................................4\n\
    \      1.1. Introduction ...............................................4\n  \
    \    1.2. Scope of This Document .....................................6\n    \
    \  1.3. Organization of This Document ..............................7\n   2. The\
    \ Internet Protocol ...........................................7\n   3. Internet\
    \ Protocol Header Fields .................................8\n      3.1. Version\
    \ ....................................................9\n      3.2. IHL (Internet\
    \ Header Length) ..............................10\n      3.3. Type of Service\
    \ (TOS) .....................................10\n           3.3.1. Original Interpretation\
    \ ............................10\n           3.3.2. Standard Interpretation ............................12\n\
    \                  3.3.2.1. Differentiated Services Field .............12\n  \
    \                3.3.2.2. Explicit Congestion Notification (ECN) ....13\n    \
    \  3.4. Total Length ..............................................14\n      3.5.\
    \ Identification (ID) .......................................15\n           3.5.1.\
    \ Some Workarounds Implemented by the Industry .......16\n           3.5.2. Possible\
    \ Security Improvements .....................17\n                  3.5.2.1. Connection-Oriented\
    \ Transport Protocols ...17\n                  3.5.2.2. Connectionless Transport\
    \ Protocols ........18\n      3.6. Flags .....................................................19\n\
    \      3.7. Fragment Offset ...........................................21\n  \
    \    3.8. Time to Live (TTL) ........................................22\n    \
    \       3.8.1. Fingerprinting the Operating System in Use\n                  by\
    \ the Source Host .................................24\n           3.8.2. Fingerprinting\
    \ the Physical Device from\n                  which the Packets Originate ........................24\n\
    \           3.8.3. Mapping the Network Topology .......................24\n  \
    \         3.8.4. Locating the Source Host in the Network Topology ...25\n    \
    \       3.8.5. Evading Network Intrusion Detection Systems ........26\n      \
    \     3.8.6. Improving the Security of Applications That\n                  Make\
    \ Use of the Internet Protocol (IP) .............27\n           3.8.7. Limiting\
    \ Spread ....................................28\n      3.9. Protocol ..................................................28\n\
    \      3.10. Header Checksum ..........................................28\n  \
    \    3.11. Source Address ...........................................29\n    \
    \  3.12. Destination Address ......................................30\n      3.13.\
    \ Options ..................................................30\n           3.13.1.\
    \ General Issues with IP Options ....................31\n                  3.13.1.1.\
    \ Processing Requirements ..................31\n                  3.13.1.2. Processing\
    \ of the Options by the\n                            Upper-Layer Protocol .....................32\n\
    \                  3.13.1.3. General Sanity Checks on IP Options ......32\n  \
    \         3.13.2. Issues with Specific Options ......................34\n    \
    \              3.13.2.1. End of Option List (Type=0) ..............34\n      \
    \            3.13.2.2. No Operation (Type=1) ....................34\n        \
    \          3.13.2.3. Loose Source and Record Route\n                         \
    \   (LSRR) (Type=131) ........................34\n                  3.13.2.4.\
    \ Strict Source and Record Route\n                            (SSRR) (Type=137)\
    \ ........................37\n                  3.13.2.5. Record Route (Type=7)\
    \ ....................39\n                  3.13.2.6. Stream Identifier (Type=136)\
    \ .............40\n                  3.13.2.7. Internet Timestamp (Type=68) .............40\n\
    \                  3.13.2.8. Router Alert (Type=148) ..................43\n  \
    \                3.13.2.9. Probe MTU (Type=11) (Obsolete) ...........44\n    \
    \              3.13.2.10. Reply MTU (Type=12) (Obsolete) ..........44\n      \
    \            3.13.2.11. Traceroute (Type=82) ....................44\n        \
    \          3.13.2.12. Department of Defense (DoD)\n                          \
    \   Basic Security Option (Type=130) ........45\n                  3.13.2.13.\
    \ DoD Extended Security Option\n                             (Type=133) ..............................46\n\
    \                  3.13.2.14. Commercial IP Security Option\n                \
    \             (CIPSO) (Type=134) ......................47\n                  3.13.2.15.\
    \ Sender Directed\n                             Multi-Destination Delivery (Type=149)\
    \ ...47\n   4. Internet Protocol Mechanisms ...................................48\n\
    \      4.1. Fragment Reassembly .......................................48\n  \
    \         4.1.1. Security Implications of Fragment Reassembly .......49\n    \
    \              4.1.1.1. Problems Related to Memory Allocation .....49\n      \
    \            4.1.1.2. Problems That Arise from the\n                         \
    \  Length of the IP Identification Field .....51\n                  4.1.1.3. Problems\
    \ That Arise from the\n                           Complexity of the Reassembly\
    \ Algorithm ....52\n                  4.1.1.4. Problems That Arise from the\n\
    \                           Ambiguity of the Reassembly Process .......52\n  \
    \                4.1.1.5. Problems That Arise from the Size\n                \
    \           of the IP Fragments .......................53\n           4.1.2. Possible\
    \ Security Improvements .....................53\n                  4.1.2.1. Memory\
    \ Allocation for Fragment\n                           Reassembly ................................53\n\
    \                  4.1.2.2. Flushing the Fragment Buffer ..............54\n  \
    \                4.1.2.3. A More Selective Fragment Buffer\n                 \
    \          Flushing Strategy .........................55\n                  4.1.2.4.\
    \ Reducing the Fragment Timeout .............57\n                  4.1.2.5. Countermeasure\
    \ for Some NIDS\n                           Evasion Techniques ........................58\n\
    \                  4.1.2.6. Countermeasure for Firewall-Rules\n              \
    \             Bypassing .................................58\n      4.2. Forwarding\
    \ ................................................58\n           4.2.1. Precedence-Ordered\
    \ Queue Service ...................58\n           4.2.2. Weak Type of Service\
    \ ...............................59\n           4.2.3. Impact of Address Resolution\
    \ on Buffer Management ..60\n           4.2.4. Dropping Packets ...................................61\n\
    \      4.3. Addressing ................................................61\n  \
    \         4.3.1. Unreachable Addresses ..............................61\n    \
    \       4.3.2. Private Address Space ..............................61\n      \
    \     4.3.3. Former Class D Addresses (224/4 Address Block) .....62\n        \
    \   4.3.4. Former Class E Addresses (240/4 Address Block) .....62\n          \
    \ 4.3.5. Broadcast/Multicast Addresses and\n                  Connection-Oriented\
    \ Protocols ......................62\n           4.3.6. Broadcast and Network\
    \ Addresses ....................63\n           4.3.7. Special Internet Addresses\
    \ .........................63\n   5. Security Considerations ........................................65\n\
    \   6. Acknowledgements ...............................................65\n  \
    \ 7. References .....................................................66\n    \
    \  7.1. Normative References ......................................66\n      7.2.\
    \ Informative References ....................................68\n"
- title: 1.  Preface
  contents:
  - '1.  Preface

    '
- title: 1.1.  Introduction
  contents:
  - "1.1.  Introduction\n   The TCP/IP protocols were conceived in an environment\
    \ that was quite\n   different from the hostile environment in which they currently\n\
    \   operate.  However, the effectiveness of the protocols led to their\n   early\
    \ adoption in production environments, to the point that, to some\n   extent,\
    \ the current world's economy depends on them.\n   While many textbooks and articles\
    \ have created the myth that the\n   Internet protocols were designed for warfare\
    \ environments, the top\n   level goal for the Defense Advanced Research Projects\
    \ Agency (DARPA)\n   Internet Program was the sharing of large service machines\
    \ on the\n   ARPANET [Clark1988].  As a result, many protocol specifications focus\n\
    \   only on the operational aspects of the protocols they specify and\n   overlook\
    \ their security implications.\n   While the Internet technology evolved since\
    \ its inception, the\n   Internet's building blocks are basically the same core\
    \ protocols\n   adopted by the ARPANET more than two decades ago.  During the\
    \ last\n   twenty years, many vulnerabilities have been identified in the TCP/IP\n\
    \   stacks of a number of systems.  Some of them were based on flaws in\n   some\
    \ protocol implementations, affecting only a reduced number of\n   systems, while\
    \ others were based on flaws in the protocols\n   themselves, affecting virtually\
    \ every existing implementation\n   [Bellovin1989].  Even in the last couple of\
    \ years, researchers were\n   still working on security problems in the core protocols\
    \ [RFC5927]\n   [Watson2004] [NISCC2004] [NISCC2005].\n   The discovery of vulnerabilities\
    \ in the TCP/IP protocols led to\n   reports being published by a number of CSIRTs\
    \ (Computer Security\n   Incident Response Teams) and vendors, which helped to\
    \ raise awareness\n   about the threats and the best mitigations known at the\
    \ time the\n   reports were published.  Unfortunately, this also led to the\n\
    \   documentation of the discovered protocol vulnerabilities being spread\n  \
    \ among a large number of documents, which are sometimes difficult to\n   identify.\n\
    \   For some reason, much of the effort of the security community on the\n   Internet\
    \ protocols did not result in official documents (RFCs) being\n   issued by the\
    \ IETF (Internet Engineering Task Force).  This basically\n   led to a situation\
    \ in which \"known\" security problems have not always\n   been addressed by all\
    \ vendors.  In addition, in many cases, vendors\n   have implemented quick \"\
    fixes\" to protocol flaws without a careful\n   analysis of their effectiveness\
    \ and their impact on interoperability\n   [Silbersack2005].\n   The lack of adoption\
    \ of these fixes by the IETF means that any system\n   built in the future according\
    \ to the official TCP/IP specifications\n   will reincarnate security flaws that\
    \ have already hit our\n   communication systems in the past.\n   Nowadays, producing\
    \ a secure TCP/IP implementation is a very\n   difficult task, in part because\
    \ of the lack of a single document that\n   serves as a security roadmap for the\
    \ protocols.  Implementers are\n   faced with the hard task of identifying relevant\
    \ documentation and\n   differentiating between that which provides correct advisory\
    \ and that\n   which provides misleading advisory based on inaccurate or wrong\n\
    \   assumptions.\n   There is a clear need for a companion document to the IETF\n\
    \   specifications; one that discusses the security aspects and\n   implications\
    \ of the protocols, identifies the possible threats,\n   discusses the possible\
    \ countermeasures, and analyzes their respective\n   effectiveness.\n   This document\
    \ is the result of an assessment of the IETF\n   specifications of the Internet\
    \ Protocol version 4 (IPv4), from a\n   security point of view.  Possible threats\
    \ were identified and, where\n   possible, countermeasures were proposed.  Additionally,\
    \ many\n   implementation flaws that have led to security vulnerabilities have\n\
    \   been referenced in the hope that future implementations will not\n   incur\
    \ the same problems.  Furthermore, this document does not limit\n   itself to\
    \ performing a security assessment of the relevant IETF\n   specifications, but\
    \ also provides an assessment of common\n   implementation strategies found in\
    \ the real world.\n   Many IP implementations have also been subject of the so-called\n\
    \   \"packet-of-death\" vulnerabilities, in which a single specially\n   crafted\
    \ packet causes the IP implementation to crash or otherwise\n   misbehave.  In\
    \ most cases, the attack packet is simply malformed; in\n   other cases, the attack\
    \ packet is well-formed, but exercises a little\n   used path through the IP stack.\
    \  Well-designed IP implementations\n   should protect against these attacks,\
    \ and therefore this document\n   describes a number of sanity checks that are\
    \ expected to prevent most\n   of the aforementioned \"packet-of-death\" attack\
    \ vectors.  We note that\n   if an IP implementation is found to be vulnerable\
    \ to one of these\n   attacks, administrators must resort to mitigating them by\
    \ packet\n   filtering.\n   Additionally, this document analyzes the security\
    \ implications from\n   changes in the operational environment since the Internet\
    \ Protocol\n   was designed.  For example, it analyzes how the Internet Protocol\n\
    \   could be exploited to evade Network Intrusion Detection Systems\n   (NIDSs)\
    \ or to circumvent firewalls.\n   This document does not aim to be the final word\
    \ on the security of\n   the Internet Protocol (IP).  On the contrary, it aims\
    \ to raise\n   awareness about many security threats based on the IP protocol\
    \ that\n   have been faced in the past, those that we are currently facing, and\n\
    \   those we may still have to deal with in the future.  It provides\n   advice\
    \ for the secure implementation of the Internet Protocol (IP),\n   but also provides\
    \ insights about the security aspects of the Internet\n   Protocol that may be\
    \ of help to the Internet operations community.\n   Feedback from the community\
    \ is more than encouraged to help this\n   document be as accurate as possible\
    \ and to keep it updated as new\n   threats are discovered.\n   This document\
    \ is heavily based on the \"Security Assessment of the\n   Internet Protocol\"\
    \ [CPNI2008] released by the UK Centre for the\n   Protection of National Infrastructure\
    \ (CPNI), available at\n   http://www.cpni.gov.uk/Products/technicalnotes/3677.aspx.\n\
    \   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\"\
    ,\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in\
    \ this\n   document are to be interpreted as described in RFC 2119 [RFC2119].\n"
- title: 1.2.  Scope of This Document
  contents:
  - "1.2.  Scope of This Document\n   While there are a number of protocols that affect\
    \ the way in which IP\n   systems operate, this document focuses only on the specifications\
    \ of\n   the Internet Protocol (IP).  For example, routing and bootstrapping\n\
    \   protocols are considered out of the scope of this project.\n   The following\
    \ IETF RFCs were selected as the primary sources for the\n   assessment as part\
    \ of this work:\n   o  RFC 791, \"INTERNET PROTOCOL DARPA INTERNET PROGRAM PROTOCOL\n\
    \      SPECIFICATION\" (45 pages).\n   o  RFC 815, \"IP DATAGRAM REASSEMBLY ALGORITHMS\"\
    \ (9 pages).\n   o  RFC 919, \"BROADCASTING INTERNET DATAGRAMS\" (8 pages).\n\
    \   o  RFC 950, \"Internet Standard Subnetting Procedure\" (18 pages)\n   o  RFC\
    \ 1112, \"Host Extensions for IP Multicasting\" (17 pages)\n   o  RFC 1122, \"\
    Requirements for Internet Hosts -- Communication\n      Layers\" (116 pages).\n\
    \   o  RFC 1812, \"Requirements for IP Version 4 Routers\" (175 pages).\n   o\
    \  RFC 2474, \"Definition of the Differentiated Services Field (DS\n      Field)\
    \ in the IPv4 and IPv6 Headers\" (20 pages).\n   o  RFC 2475, \"An Architecture\
    \ for Differentiated Services\" (36\n      pages).\n   o  RFC 3168, \"The Addition\
    \ of Explicit Congestion Notification (ECN)\n      to IP\" (63 pages).\n   o \
    \ RFC 4632, \"Classless Inter-domain Routing (CIDR): The Internet\n      Address\
    \ Assignment and Aggregation Plan\" (27 pages).\n"
- title: 1.3.  Organization of This Document
  contents:
  - "1.3.  Organization of This Document\n   This document is basically organized\
    \ in two parts: \"Internet Protocol\n   header fields\" and \"Internet Protocol\
    \ mechanisms\".  The former\n   contains an analysis of each of the fields of\
    \ the Internet Protocol\n   header, identifies their security implications, and\
    \ discusses\n   possible countermeasures for the identified threats.  The latter\n\
    \   contains an analysis of the security implications of the mechanisms\n   implemented\
    \ by the Internet Protocol.\n"
- title: 2.  The Internet Protocol
  contents:
  - "2.  The Internet Protocol\n   The Internet Protocol (IP) provides a basic data\
    \ transfer function\n   for passing data blocks called \"datagrams\" from a source\
    \ host to a\n   destination host, across the possible intervening networks.\n\
    \   Additionally, it provides some functions that are useful for the\n   interconnection\
    \ of heterogeneous networks, such as fragmentation and\n   reassembly.\n   The\
    \ \"datagram\" has a number of characteristics that makes it\n   convenient for\
    \ interconnecting systems [Clark1988]:\n   o  It eliminates the need of connection\
    \ state within the network,\n      which improves the survivability characteristics\
    \ of the network.\n   o  It provides a basic service of data transport that can\
    \ be used as\n      a building block for other transport services (reliable data\n\
    \      transport services, etc.).\n   o  It represents the minimum network service\
    \ assumption, which\n      enables IP to be run over virtually any network technology.\n"
- title: 3.  Internet Protocol Header Fields
  contents:
  - "3.  Internet Protocol Header Fields\n   The IETF specifications of the Internet\
    \ Protocol define the syntax of\n   the protocol header, along with the semantics\
    \ of each of its fields.\n   Figure 1 shows the format of an IP datagram, as specified\
    \ in\n   [RFC0791].\n      0                   1                   2         \
    \          3\n      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8\
    \ 9 0 1\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |Version|  IHL  |Type of Service|          Total Length         |\n    \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     |  \
    \       Identification        |Flags|      Fragment Offset    |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |  Time to Live |    Protocol   |         Header Checksum       |\n    \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     |  \
    \                     Source Address                          |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |                    Destination Address                        |\n    \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     |  \
    \                [ Options ]                  |  [ Padding ]  |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                 Figure 1: Internet Protocol Header Format\n   Even though the\
    \ minimum IP header size is 20 bytes, an IP module\n   might be handed an (illegitimate)\
    \ \"datagram\" of less than 20 bytes.\n   Therefore, before doing any processing\
    \ of the IP header fields, the\n   following check should be performed by the\
    \ IP module on the packets\n   handed by the link layer:\n                   \
    \     LinkLayer.PayloadSize >= 20\n   where LinkLayer.PayloadSize is the length\
    \ (in octets) of the datagram\n   passed from the link layer to the IP layer.\n\
    \   If the packet does not pass this check, it should be dropped, and\n   this\
    \ event should be logged (e.g., a counter could be incremented\n   reflecting\
    \ the packet drop).\n   The following subsections contain further sanity checks\
    \ that should\n   be performed on IP packets.\n"
- title: 3.1.  Version
  contents:
  - "3.1.  Version\n   This is a 4-bit field that indicates the version of the Internet\n\
    \   Protocol (IP), and thus the syntax of the packet.  For IPv4, this\n   field\
    \ must be 4.\n   When a link-layer protocol de-multiplexes a packet to an Internet\n\
    \   module, it does so based on a Protocol Type field in the data-link\n   packet\
    \ header.\n   In theory, different versions of IP could coexist on a network by\n\
    \   using the same Protocol Type at the link layer, but a different value\n  \
    \ in the Version field of the IP header.  Thus, a single IP module\n   could handle\
    \ all versions of the Internet Protocol, differentiating\n   them by means of\
    \ this field.\n   However, in practice different versions of IP are identified\
    \ by a\n   different Protocol Type (e.g., EtherType in the case of Ethernet)\n\
    \   number in the link-layer protocol header.  For example, IPv4\n   datagrams\
    \ are encapsulated in Ethernet frames using an EtherType of\n   0x0800, while\
    \ IPv6 datagrams are encapsulated in Ethernet frames\n   using an EtherType of\
    \ 0x86DD [IANA_ET].\n   Therefore, if an IPv4 module receives a packet, the Version\
    \ field\n   must be checked to be 4.  If this check fails, the packet should be\n\
    \   silently dropped, and this event should be logged (e.g., a counter\n   could\
    \ be incremented reflecting the packet drop).  If an\n   implementation does not\
    \ perform this check, an attacker could use a\n   different value for the Version\
    \ field, possibly evading NIDSs that\n   decide which pattern-matching rules to\
    \ apply based on the Version\n   field.\n   If the link-layer protocol employs\
    \ a specific \"Protocol Type\" value\n   for encapsulating IPv4 packets (e.g.,\
    \ as is the case of Ethernet), a\n   node should check that IPv4 packets are de-multiplexed\
    \ to the IPv4\n   module when such value was used for the Protocol Type field\
    \ of the\n   link-layer protocol.  If a packet does not pass this check, it should\n\
    \   be silently dropped.\n      An attacker could encapsulate IPv4 packets using\
    \ other link-layer\n      \"Protocol Type\" values to try to subvert link-layer\
    \ Access Control\n      Lists (ACLs) and/or for tampering with NIDSs.\n"
- title: 3.2.  IHL (Internet Header Length)
  contents:
  - "3.2.  IHL (Internet Header Length)\n   The IHL (Internet Header Length) field\
    \ indicates the length of the\n   Internet header in 32-bit words (4 bytes). \
    \ The following paragraphs\n   describe a number of sanity checks to be performed\
    \ on the IHL field,\n   such that possible packet-of-death vulnerabilities are\
    \ avoided.\n   As the minimum datagram size is 20 bytes, the minimum legal value\
    \ for\n   this field is 5.  Therefore, the following check should be enforced:\n\
    \                                  IHL >= 5\n   If the packet does not pass this\
    \ check, it should be dropped, and\n   this event should be logged (e.g., a counter\
    \ could be incremented\n   reflecting the packet drop).\n   For obvious reasons,\
    \ the Internet header cannot be larger than the\n   whole Internet datagram of\
    \ which it is part.  Therefore, the\n   following check should be enforced:\n\
    \                          IHL * 4 <= Total Length\n      This needs to refer\
    \ to the size of the datagram as specified by\n      the sender in the Total Length\
    \ field, since link layers might have\n      added some padding (see Section 3.4).\n\
    \   If the packet does not pass this check, it should be dropped, and\n   this\
    \ event should be logged (e.g., a counter could be incremented\n   reflecting\
    \ the packet drop).\n   The above check allows for Internet datagrams with no\
    \ data bytes in\n   the payload that, while nonsensical for virtually every protocol\
    \ that\n   runs over IP, are still legal.\n"
- title: 3.3.  Type of Service (TOS)
  contents:
  - '3.3.  Type of Service (TOS)

    '
- title: 3.3.1.  Original Interpretation
  contents:
  - "3.3.1.  Original Interpretation\n   Figure 2 shows the original syntax of the\
    \ Type of Service field, as\n   defined by RFC 791 [RFC0791] and updated by RFC\
    \ 1349 [RFC1349].  This\n   definition has been superseded long ago (see Sections\
    \ 3.3.2.1 and\n   3.3.2.2), but it is still assumed by some deployed implementations.\n\
    \                0     1     2     3     4     5     6     7\n             +-----+-----+-----+-----+-----+-----+-----+-----+\n\
    \             |   PRECEDENCE    |  D  |  T  |  R  |  C  |  0  |\n            \
    \ +-----+-----+-----+-----+-----+-----+-----+-----+\n         Figure 2: Type of\
    \ Service Field (Original Interpretation)\n        +----------+----------------------------------------------+\n\
    \        | Bits 0-2 |                  Precedence                  |\n       \
    \ +----------+----------------------------------------------+\n        | Bit 3\
    \    |        0 = Normal Delay, 1 = Low Delay       |\n        +----------+----------------------------------------------+\n\
    \        | Bit 4    |  0 = Normal Throughput, 1 = High Throughput  |\n       \
    \ +----------+----------------------------------------------+\n        | Bit 5\
    \    | 0 = Normal Reliability, 1 = High Reliability |\n        +----------+----------------------------------------------+\n\
    \        | Bit 6    |  0 = Normal Cost, 1 = Minimize Monetary Cost |\n       \
    \ +----------+----------------------------------------------+\n        | Bits\
    \ 7   |    Reserved for Future Use (must be zero)    |\n        +----------+----------------------------------------------+\n\
    \                    Table 1: Semantics of the TOS Bits\n                    \
    \     +-----+-----------------+\n                         | 111 | Network Control\
    \ |\n                         +-----+-----------------+\n                    \
    \     | 110 |   Internetwork  |\n                         +-----+-----------------+\n\
    \                         | 101 |    CRITIC/ECP   |\n                        \
    \ +-----+-----------------+\n                         | 100 |  Flash Override\
    \ |\n                         +-----+-----------------+\n                    \
    \     | 011 |      Flash      |\n                         +-----+-----------------+\n\
    \                         | 010 |    Immediate    |\n                        \
    \ +-----+-----------------+\n                         | 001 |     Priority   \
    \ |\n                         +-----+-----------------+\n                    \
    \     | 000 |     Routine     |\n                         +-----+-----------------+\n\
    \        Table 2: Semantics of the Possible Precedence Field Values\n   The Type\
    \ of Service field can be used to affect the way in which the\n   packet is treated\
    \ by the systems of a network that process it.\n   Section 4.2.1 (\"Precedence-Ordered\
    \ Queue Service\") and Section 4.2.2\n   (\"Weak Type of Service\") of this document\
    \ describe the security\n   implications of the Type of Service field in the forwarding\
    \ of\n   packets.\n"
- title: 3.3.2.  Standard Interpretation
  contents:
  - '3.3.2.  Standard Interpretation

    '
- title: 3.3.2.1.  Differentiated Services Field
  contents:
  - "3.3.2.1.  Differentiated Services Field\n   The Differentiated Services Architecture\
    \ is intended to enable\n   scalable service discrimination in the Internet without\
    \ the need for\n   per-flow state and signaling at every hop [RFC2475].  RFC 2474\n\
    \   [RFC2474] redefined the IP \"Type of Service\" octet, introducing a\n   Differentiated\
    \ Services Field (DS Field).  Figure 3 shows the format\n   of the field.\n  \
    \                     0   1   2   3   4   5   6   7\n                     +---+---+---+---+---+---+---+---+\n\
    \                     |         DSCP          |  CU   |\n                    \
    \ +---+---+---+---+---+---+---+---+\n    Figure 3: Revised Structure of the Type\
    \ of Service Field (RFC 2474)\n   The DSCP (\"Differentiated Services CodePoint\"\
    ) is used to select the\n   treatment the packet is to receive within the Differentiated\
    \ Services\n   Domain.  The CU (\"Currently Unused\") field was, at the time the\n\
    \   specification was issued, reserved for future use.  The DSCP field is\n  \
    \ used to select a PHB (Per-Hop Behavior), by matching against the\n   entire\
    \ 6-bit field.\n   Considering that the DSCP field determines how a packet is\
    \ treated\n   within a Differentiated Services (DS) domain, an attacker could\
    \ send\n   packets with a forged DSCP field to perform a theft of service or\n\
    \   even a Denial-of-Service (DoS) attack.  In particular, an attacker\n   could\
    \ forge packets with a codepoint of the type '11x000' which,\n   according to\
    \ Section 4.2.2.2 of RFC 2474 [RFC2474], would give the\n   packets preferential\
    \ forwarding treatment when compared with the PHB\n   selected by the codepoint\
    \ '000000'.  If strict priority queuing were\n   utilized, a continuous stream\
    \ of such packets could cause a DoS to\n   other flows that have a DSCP of lower\
    \ relative order.\n   As the DS field is incompatible with the original Type of\
    \ Service\n   field, both DS domains and networks using the original Type of\n\
    \   Service field should protect themselves by remarking the\n   corresponding\
    \ field where appropriate, probably deploying remarking\n   boundary nodes.  Nevertheless,\
    \ care must be taken so that packets\n   received with an unrecognized DSCP do\
    \ not cause the handling system\n   to malfunction.\n"
- title: 3.3.2.2.  Explicit Congestion Notification (ECN)
  contents:
  - "3.3.2.2.  Explicit Congestion Notification (ECN)\n   RFC 3168 [RFC3168] specifies\
    \ a mechanism for routers to signal\n   congestion to hosts exchanging IP packets,\
    \ by marking the offending\n   packets rather than discarding them.  RFC 3168\
    \ defines the ECN field,\n   which utilizes the CU field defined in RFC 2474 [RFC2474].\
    \  Figure 4\n   shows the current syntax of the IP Type of Service field, with\
    \ the\n   DSCP field used for Differentiated Services and the ECN field.\n   \
    \             0     1     2     3     4     5     6     7\n             +-----+-----+-----+-----+-----+-----+-----+-----+\n\
    \             |          DS FIELD, DSCP           | ECN FIELD |\n            \
    \ +-----+-----+-----+-----+-----+-----+-----+-----+\n        Figure 4: The Differentiated\
    \ Services and ECN Fields in IP\n   As such, the ECN field defines four codepoints:\n\
    \                         +-----------+-----------+\n                        \
    \ | ECN field | Codepoint |\n                         +-----------+-----------+\n\
    \                         |     00    |  Not-ECT  |\n                        \
    \ +-----------+-----------+\n                         |     01    |   ECT(1) \
    \ |\n                         +-----------+-----------+\n                    \
    \     |     10    |   ECT(0)  |\n                         +-----------+-----------+\n\
    \                         |     11    |     CE    |\n                        \
    \ +-----------+-----------+\n                          Table 3: ECN Codepoints\n\
    \   ECN is an end-to-end transport protocol mechanism based on\n   notifications\
    \ by routers through which a packet flow passes.  To\n   allow this interaction\
    \ to happen on the fast path of routers, the ECN\n   field is located at a fixed\
    \ location in the IP header.  However, its\n   use must be negotiated at the transport\
    \ layer, and the accumulated\n   congestion notifications must be communicated\
    \ back to the sending\n   node using transport protocol means.  Thus, ECN support\
    \ must be\n   specified per transport protocol.\n      [RFC6040] specifies how\
    \ the Explicit Congestion Notification (ECN)\n      field of the IP header should\
    \ be constructed on entry to and exit\n      from any IP-in-IP tunnel.\n   The\
    \ security implications of ECN are discussed in detail in a number\n   of Sections\
    \ of RFC 3168.  Of the possible threats discussed in the\n   ECN specification,\
    \ we believe that one that can be easily exploited\n   is that of a host falsely\
    \ indicating ECN-Capability.\n   An attacker could set the ECT codepoint in the\
    \ packets it sends, to\n   signal the network that the endpoints of the transport\
    \ protocol are\n   ECN-capable.  Consequently, when experiencing moderate congestion,\n\
    \   routers using active queue management based on Random Early Detection\n  \
    \ (RED) would mark the packets (with the CE codepoint) rather than\n   discard\
    \ them.  In this same scenario, packets of competing flows that\n   do not have\
    \ the ECT codepoint set would be dropped.  Therefore, an\n   attacker would get\
    \ better network service than the competing flows.\n   However, if this moderate\
    \ congestion turned into heavy congestion,\n   routers should switch to drop packets,\
    \ regardless of whether or not\n   the packets have the ECT codepoint set.\n \
    \  A number of other threats could arise if an attacker was a man in the\n   middle\
    \ (i.e., was in the middle of the path the packets travel to get\n   to the destination\
    \ host).  For a detailed discussion of those cases,\n   we urge the reader to\
    \ consult Section 16 of RFC 3168.\n   There is also ongoing work in the research\
    \ community and the IETF to\n   define alternate semantics for the CU/ECN field\
    \ of IP TOS octet (see\n   [RFC5559], [RFC5670], and [RFC5696]).  The application\
    \ of these\n   methods must be confined to tightly administered domains, and on\
    \ exit\n   from such domains, all packets need to be (re-)marked with ECN\n  \
    \ semantics.\n"
- title: 3.4.  Total Length
  contents:
  - "3.4.  Total Length\n   The Total Length field is the length of the datagram,\
    \ measured in\n   bytes, including both the IP header and the IP payload.  Being\
    \ a\n   16-bit field, it allows for datagrams of up to 65535 bytes.  RFC 791\n\
    \   [RFC0791] states that all hosts should be prepared to receive\n   datagrams\
    \ of up to 576 bytes (whether they arrive as a whole, or in\n   fragments).  However,\
    \ most modern implementations can reassemble\n   datagrams of at least 9 Kbytes.\n\
    \   Usually, a host will not send to a remote peer an IP datagram larger\n   than\
    \ 576 bytes, unless it is explicitly signaled that the remote peer\n   is able\
    \ to receive such \"large\" datagrams (for example, by means of\n   TCP's Maximum\
    \ Segment Size (MSS) option).  However, systems should\n   assume that they may\
    \ receive datagrams larger than 576 bytes,\n   regardless of whether or not they\
    \ signal their remote peers to do so.\n   In fact, it is common for Network File\
    \ System (NFS) [RFC3530]\n   implementations to send datagrams larger than 576\
    \ bytes, even without\n   explicit signaling that the destination system can receive\
    \ such\n   \"large\" datagram.\n      Additionally, see the discussion in Section\
    \ 4.1 (\"Fragment\n      Reassembly\") regarding the possible packet sizes resulting\
    \ from\n      fragment reassembly.\n   Implementations should be aware that the\
    \ IP module could be handed a\n   packet larger than the value actually contained\
    \ in the Total Length\n   field.  Such a difference usually has to do with legitimate\
    \ padding\n   bytes at the link-layer protocol, but it could also be the result\
    \ of\n   malicious activity by an attacker.  Furthermore, even when the\n   maximum\
    \ length of an IP datagram is 65535 bytes, if the link-layer\n   technology in\
    \ use allows for payloads larger than 65535 bytes, an\n   attacker could forge\
    \ such a large link-layer packet, meaning it for\n   the IP module.  If the IP\
    \ module of the receiving system were not\n   prepared to handle such an oversized\
    \ link-layer payload, an\n   unexpected failure might occur.  Therefore, the memory\
    \ buffer used by\n   the IP module to store the link-layer payload should be allocated\n\
    \   according to the payload size reported by the link layer, rather than\n  \
    \ according to the Total Length field of the IP packet it contains.\n   The IP\
    \ module could also be handed a packet that is smaller than the\n   actual IP\
    \ packet size claimed by the Total Length field.  This could\n   be used, for\
    \ example, to produce an information leakage.  Therefore,\n   the following check\
    \ should be performed:\n                   LinkLayer.PayloadSize >= Total Length\n\
    \   If this check fails, the IP packet should be dropped, and this event\n   should\
    \ be logged (e.g., a counter could be incremented reflecting the\n   packet drop).\
    \  As the previous expression implies, the number of\n   bytes passed by the link\
    \ layer to the IP module should contain at\n   least as many bytes as claimed\
    \ by the Total Length field of the IP\n   header.\n      [US-CERT2002] is an example\
    \ of the exploitation of a forged IP\n      Total Length field to produce an information\
    \ leakage attack.\n"
- title: 3.5.  Identification (ID)
  contents:
  - "3.5.  Identification (ID)\n   The Identification field is set by the sending\
    \ host to aid in the\n   reassembly of fragmented datagrams.  At any time, it\
    \ needs to be\n   unique for each set of {Source Address, Destination Address,\n\
    \   Protocol}.\n   In many systems, the value used for this field is determined\
    \ at the\n   IP layer, on a protocol-independent basis.  Many of those systems\n\
    \   also simply increment the IP Identification field for each packet\n   they\
    \ send.\n   This implementation strategy is inappropriate for a number of\n  \
    \ reasons.  Firstly, if the Identification field is set on a protocol-\n   independent\
    \ basis, it will wrap more often than necessary, and thus\n   the implementation\
    \ will be more prone to the problems discussed in\n   [Kent1987] and [RFC4963].\
    \  Secondly, this implementation strategy\n   opens the door to an information\
    \ leakage that can be exploited in a\n   number of ways.\n   [Sanfilippo1998a]\
    \ describes how the Identification field can be\n   leveraged to determine the\
    \ packet rate at which a given system is\n   transmitting information.  Later,\
    \ [Sanfilippo1998b] described how a\n   system with such an implementation can\
    \ be used to perform a stealth\n   port scan to a third (victim) host.  [Sanfilippo1999]\
    \ explained how\n   to exploit this implementation strategy to uncover the rules\
    \ of a\n   number of firewalls.  [Bellovin2002] explains how the IP\n   Identification\
    \ field can be exploited to count the number of systems\n   behind a NAT.  [Fyodor2004]\
    \ is an entire paper on most (if not all)\n   of the ways to exploit the information\
    \ provided by the Identification\n   field of the IP header.\n      Section 4.1\
    \ contains a discussion of the security implications of\n      the IP fragment\
    \ reassembly mechanism, which is the primary\n      \"consumer\" of this field.\n"
- title: 3.5.1.  Some Workarounds Implemented by the Industry
  contents:
  - "3.5.1.  Some Workarounds Implemented by the Industry\n   As the IP Identification\
    \ field is only used for the reassembly of\n   datagrams, some operating systems\
    \ (such as Linux) decided to set this\n   field to 0 in all packets that have\
    \ the DF bit set.  This would, in\n   principle, avoid any type of information\
    \ leakage.  However, it was\n   detected that some non-RFC-compliant middle-boxes\
    \ fragmented packets\n   even if they had the DF bit set.  In such a scenario,\
    \ all datagrams\n   originally sent with the DF bit set would all result in fragments\n\
    \   with an Identification field of 0, which would lead to problems\n   (\"collision\"\
    \ of the Identification number) in the reassembly process.\n   Linux (and Solaris)\
    \ later set the IP Identification field on a per-\n   IP-address basis.  This\
    \ avoids some of the security implications of\n   the IP Identification field,\
    \ but not all.  For example, systems\n   behind a load balancer can still be counted.\n"
- title: 3.5.2.  Possible Security Improvements
  contents:
  - "3.5.2.  Possible Security Improvements\n   Contrary to common wisdom, the IP\
    \ Identification field does not need\n   to be system-wide unique for each packet,\
    \ but has to be unique for\n   each {Source Address, Destination Address, Protocol}\
    \ tuple.\n      For instance, the TCP specification defines a generic send()\n\
    \      function that takes the IP ID as one of its arguments.\n   We provide an\
    \ analysis of the possible security improvements that\n   could be implemented,\
    \ based on whether the protocol using the\n   services of IP is connection-oriented\
    \ or connection-less.\n"
- title: 3.5.2.1.  Connection-Oriented Transport Protocols
  contents:
  - "3.5.2.1.  Connection-Oriented Transport Protocols\n   To avoid the security implications\
    \ of the information leakage\n   described above, a pseudo-random number generator\
    \ (PRNG) could be\n   used to set the IP Identification field on a {Source Address,\n\
    \   Destination Address} basis (for each connection-oriented transport\n   protocol).\n\
    \      [RFC4086] provides advice on the generation of pseudo-random\n      numbers.\n\
    \      [Klein2007] is a security advisory that describes a weakness in\n     \
    \ the pseudo-random number generator (PRNG) employed for the\n      generation\
    \ of the IP Identification by a number of operating\n      systems.\n   While\
    \ in theory a pseudo-random number generator could lead to\n   scenarios in which\
    \ a given Identification number is used more than\n   once in the same time span\
    \ for datagrams that end up getting\n   fragmented (with the corresponding potential\
    \ reassembly problems), in\n   practice, this is unlikely to cause trouble.\n\
    \   By default, most implementations of connection-oriented protocols,\n   such\
    \ as TCP, implement some mechanism for avoiding fragmentation\n   (such as the\
    \ Path-MTU Discovery mechanism described in [RFC1191]).\n   Thus, fragmentation\
    \ will only take place if a non-RFC-compliant\n   middle-box that still fragments\
    \ packets even when the DF bit is set\n   is placed somewhere along the path that\
    \ the packets travel to get to\n   the destination host.  Once the sending system\
    \ is signaled by the\n   middle-box (by means of an ICMP \"fragmentation needed\
    \ and DF bit set\"\n   error message) that it should reduce the size of the packets\
    \ it\n   sends, fragmentation would be avoided.  Also, for reassembly problems\n\
    \   to arise, the same Identification value would need to be reused very\n   frequently,\
    \ and either strong packet reordering or packet loss would\n   need to take place.\n\
    \   Nevertheless, regardless of what policy is used for selecting the\n   Identification\
    \ field, with the current link speeds fragmentation is\n   already bad enough\
    \ (i.e., very likely to lead to fragment reassembly\n   errors) to rely on it.\
    \  A mechanism for avoiding fragmentation (such\n   as [RFC1191] or [RFC4821]\
    \ should be implemented, instead.\n"
- title: 3.5.2.2.  Connectionless Transport Protocols
  contents:
  - "3.5.2.2.  Connectionless Transport Protocols\n   Connectionless transport protocols\
    \ often have these characteristics:\n   o  lack of flow-control mechanisms,\n\
    \   o  lack of packet sequencing mechanisms, and/or,\n   o  lack of reliability\
    \ mechanisms (such as \"timeout and retransmit\").\n   This basically means that\
    \ the scenarios and/or applications for which\n   connection-less transport protocols\
    \ are used assume that:\n   o  Applications will be used in environments in which\
    \ packet\n      reordering is very unlikely (such as Local Area Networks), as\
    \ the\n      transport protocol itself does not provide data sequencing.\n   o\
    \  The data transfer rates will be low enough that flow control will\n      be\
    \ unnecessary.\n   o  Packet loss is can be tolerated and/or is unlikely.\n  \
    \ With these assumptions in mind, the Identification field could still\n   be\
    \ set according to a pseudo-random number generator (PRNG).\n      [RFC4086] provides\
    \ advice on the generation of pseudo-random\n      numbers.\n   In the event a\
    \ given Identification number was reused while the first\n   instance of the same\
    \ number is still on the network, the first IP\n   datagram would be reassembled\
    \ before the fragments of the second IP\n   datagram get to their destination.\n\
    \   In the event this was not the case, the reassembly of fragments would\n  \
    \ result in a corrupt datagram.  While some existing work\n   [Silbersack2005]\
    \ assumes that this error would be caught by some\n   upper-layer error detection\
    \ code, the error detection code in\n   question (such as UDP's checksum) might\
    \ not be able to reliably\n   detect data corruption arising from the replacement\
    \ of a complete\n   data block (as is the case in corruption arising from collision\
    \ of IP\n   Identification numbers).\n      In the case of UDP, unfortunately\
    \ some systems have been known to\n      not enable the UDP checksum by default.\
    \  For most applications,\n      packets containing errors should be dropped by\
    \ the transport layer\n      and not delivered to the application.  A small number\
    \ of\n      applications may benefit from disabling the checksum; for example,\n\
    \      streaming media where it is desired to avoid dropping a complete\n    \
    \  sample for a single-bit error, and UDP tunneling applications\n      where\
    \ the payload (i.e., the inner packet) is protected by its own\n      transport\
    \ checksum or other error detection mechanism.\n   In general, if IP Identification\
    \ number collisions become an issue\n   for the application using the connection-less\
    \ protocol, the\n   application designers should consider using a different transport\n\
    \   protocol (which hopefully avoids fragmentation).\n   It must be noted that\
    \ an attacker could intentionally exploit\n   collisions of IP Identification\
    \ numbers to perform a DoS attack, by\n   sending forged fragments that would\
    \ cause the reassembly process to\n   result in a corrupt datagram that either\
    \ would be dropped by the\n   transport protocol or would incorrectly be handed\
    \ to the\n   corresponding application.  This issue is discussed in detail in\n\
    \   Section 4.1 (\"Fragment Reassembly\").\n"
- title: 3.6.  Flags
  contents:
  - "3.6.  Flags\n   The IP header contains 3 control bits, two of which are currently\n\
    \   used for the fragmentation and reassembly function.\n   As described by RFC\
    \ 791, their meaning is:\n   o  Bit 0: reserved, must be zero (i.e., reserved\
    \ for future\n      standardization)\n   o  Bit 1: (DF) 0 = May Fragment, 1 =\
    \ Don't Fragment\n   o  Bit 2: (MF) 0 = Last Fragment, 1 = More Fragments\n  \
    \ The DF bit is usually set to implement the Path-MTU Discovery (PMTUD)\n   mechanism\
    \ described in [RFC1191].  However, it can also be exploited\n   by an attacker\
    \ to evade Network Intrusion Detection Systems.  An\n   attacker could send a\
    \ packet with the DF bit set to a system\n   monitored by a NIDS, and depending\
    \ on the Path-MTU to the intended\n   recipient, the packet might be dropped by\
    \ some intervening router\n   (because of being too big to be forwarded without\
    \ fragmentation),\n   without the NIDS being aware of it.\n                  \
    \                        +---+\n                                          | H\
    \ |\n                                          +---+  Victim host\n          \
    \                                  |\n                 Router A              \
    \     |  MTU=1500\n                                            |\n           \
    \       +---+     +---+         +---+\n                  | R |-----| R |---------|\
    \ R |\n                  +---+     +---+         +---+\n                    |\
    \            MTU=17914      Router B\n          +---+     |\n          | S |-----+\n\
    \          +---+     |\n                    |\n      NIDS Sensor   |\n       \
    \             |\n           _   ___/---\\______                  Attacker\n  \
    \        / \\_/              \\_          +---+\n         /       Internet   \
    \   |---------| H |\n         \\_                  __/         +---+\n       \
    \    \\__     __    ___/    <------\n              \\___/  \\__/         17914-byte\
    \ packet\n                                  DF bit set\n      Figure 5: NIDS Evasion\
    \ by Means of the Internet Protocol DF Bit\n   In Figure 3, an attacker sends\
    \ a 17914-byte datagram meant for the\n   victim host in the same figure.  The\
    \ attacker's packet probably\n   contains an overlapping IP fragment or an overlapping\
    \ TCP segment,\n   aiming at \"confusing\" the NIDS, as described in [Ptacek1998].\
    \  The\n   packet is screened by the NIDS sensor at the network perimeter, which\n\
    \   probably reassembles IP fragments and TCP segments for the purpose of\n  \
    \ assessing the data transferred to and from the monitored systems.\n   However,\
    \ as the attacker's packet should transit a link with an MTU\n   smaller than\
    \ 17914 bytes (1500 bytes in this example), the router\n   that encounters that\
    \ this packet cannot be forwarded without\n   fragmentation (Router B) discards\
    \ the packet, and sends an ICMP\n   \"fragmentation needed and DF bit set\" error\
    \ message to the source\n   host.  In this scenario, the NIDS may remain unaware\
    \ that the\n   screened packet never reached the intended destination, and thus\
    \ get\n   an incorrect picture of the data being transferred to the monitored\n\
    \   systems.\n      [Shankar2003] introduces a technique named \"Active Mapping\"\
    \ that\n      prevents evasion of a NIDS by acquiring sufficient knowledge about\n\
    \      the network being monitored, to assess which packets will arrive\n    \
    \  at the intended recipient, and how they will be interpreted by it.\n   Some\
    \ firewalls are known to drop packets that have both the MF (More\n   Fragments)\
    \ and the DF (Don't Fragment) bits set.  While in principle\n   such a packet\
    \ might seem nonsensical, there are a number of reasons\n   for which non-malicious\
    \ packets with these two bits set can be found\n   in a network.  First, they\
    \ may exist as the result of some middle-box\n   processing a packet that was\
    \ too large to be forwarded without\n   fragmentation.  Instead of simply dropping\
    \ the corresponding packet\n   and sending an ICMP error message to the source\
    \ host, some middle-\n   boxes fragment the packet (copying the DF bit to each\
    \ fragment), and\n   also send an ICMP error message to the originating system.\
    \  Second,\n   some systems (notably Linux) set both the MF and the DF bits to\n\
    \   implement Path-MTU Discovery (PMTUD) for UDP.  These scenarios should\n  \
    \ be taken into account when configuring firewalls and/or tuning NIDSs.\n   Section\
    \ 4.1 contains a discussion of the security implications of the\n   IP fragment\
    \ reassembly mechanism.\n"
- title: 3.7.  Fragment Offset
  contents:
  - "3.7.  Fragment Offset\n   The Fragment Offset is used for the fragmentation and\
    \ reassembly of\n   IP datagrams.  It indicates where in the original datagram\
    \ payload\n   the payload of the fragment belongs, and is measured in units of\n\
    \   eight bytes.  As a consequence, all fragments (except the last one),\n   have\
    \ to be aligned on an 8-byte boundary.  Therefore, if a packet has\n   the MF\
    \ flag set, the following check should be enforced:\n                     (Total\
    \ Length - IHL * 4) % 8 == 0\n   If the packet does not pass this check, it should\
    \ be dropped, and\n   this event should be logged (e.g., a counter could be incremented\n\
    \   reflecting the packet drop).\n   Given that Fragment Offset is a 13-bit field,\
    \ it can hold a value of\n   up to 8191, which would correspond to an offset 65528\
    \ bytes within\n   the original (non-fragmented) datagram.  As such, it is possible\
    \ for\n   a fragment to implicitly claim to belong to a datagram larger than\n\
    \   65535 bytes (the maximum size for a legitimate IP datagram).  Even\n   when\
    \ the fragmentation mechanism would seem to allow fragments that\n   could reassemble\
    \ into such large datagrams, the intent of the\n   specification is to allow for\
    \ the transmission of datagrams of up to\n   65535 bytes.  Therefore, if a given\
    \ fragment would reassemble into a\n   datagram of more than 65535 bytes, the\
    \ resulting datagram should be\n   dropped, and this event should be logged (e.g.,\
    \ a counter could be\n   incremented reflecting the packet drop).  To detect such\
    \ a case, the\n   following check should be enforced on all packets for which\
    \ the\n   Fragment Offset contains a non-zero value:\n    Fragment Offset * 8\
    \ + (Total Length - IHL * 4) + IHL_FF * 4 <= 65535\n   where IHL_FF is the IHL\
    \ field of the first fragment (the one with a\n   Fragment Offset of 0).\n   If\
    \ a fragment does not pass this check, it should be dropped.\n   If IHL_FF is\
    \ not yet available because the first fragment has not yet\n   arrived, for a\
    \ preliminary, less rigid test, IHL_FF == IHL should be\n   assumed, and the test\
    \ is simplified to:\n                Fragment Offset * 8 + Total Length <= 65535\n\
    \   Once the first fragment is received, the full sanity check described\n   earlier\
    \ should be applied, if that fragment contains \"don't copy\"\n   options.\n \
    \  In the worst-case scenario, an attacker could craft IP fragments such\n   that\
    \ the reassembled datagram reassembled into a datagram of 131043\n   bytes.\n\
    \      Such a datagram would result when the first fragment has a\n      Fragment\
    \ Offset of 0 and a Total Length of 65532, and the second\n      (and last) fragment\
    \ has a Fragment Offset of 8189 (65512 bytes),\n      and a Total Length of 65535.\
    \  Assuming an IHL of 5 (i.e., a header\n      length of 20 bytes), the reassembled\
    \ datagram would be 65532 +\n      (65535 - 20) = 131047 bytes.\n   Additionally,\
    \ the IP module should implement all the necessary\n   measures to be able to\
    \ handle such illegitimate reassembled\n   datagrams, so as to avoid them from\
    \ overflowing the buffer(s) used\n   for the reassembly function.\n      [CERT1996c]\
    \ and [Kenney1996] describe the exploitation of this\n      issue to perform a\
    \ DoS attack.\n   Section 4.1 contains a discussion of the security implications\
    \ of the\n   IP fragment reassembly mechanism.\n"
- title: 3.8.  Time to Live (TTL)
  contents:
  - "3.8.  Time to Live (TTL)\n   The Time to Live (TTL) field has two functions:\
    \ to bound the lifetime\n   of the upper-layer packets (e.g., TCP segments) and\
    \ to prevent\n   packets from looping indefinitely in the network.\n   Originally,\
    \ this field was meant to indicate the maximum time a\n   datagram was allowed\
    \ to remain in the Internet system, in units of\n   seconds.  As every Internet\
    \ module that processes a datagram must\n   decrement the TTL by at least one,\
    \ the original definition of the TTL\n   field became obsolete, and in practice\
    \ it is interpreted as a hop\n   count (see Section 5.3.1 of [RFC1812]).\n   Most\
    \ systems allow the administrator to configure the TTL to be used\n   for the\
    \ packets they originate, with the default value usually being\n   a power of\
    \ 2, or 255 (e.g., see [Arkin2000]).  The recommended value\n   for the TTL field,\
    \ as specified by the IANA is 64 [IANA_IP_PARAM].\n   This value reflects the\
    \ assumed \"diameter\" of the Internet, plus a\n   margin to accommodate its growth.\n\
    \   The TTL field has a number of properties that are interesting from a\n   security\
    \ point of view.  Given that the default value used for the\n   TTL is usually\
    \ either a power of two, or 255, chances are that unless\n   the originating system\
    \ has been explicitly tuned to use a non-default\n   value, if a packet arrives\
    \ with a TTL of 60, the packet was\n   originally sent with a TTL of 64.  In the\
    \ same way, if a packet is\n   received with a TTL of 120, chances are that the\
    \ original packet had\n   a TTL of 128.\n      This discussion assumes there was\
    \ no protocol scrubber,\n      transparent proxy, or some other middle-box that\
    \ overwrites the\n      TTL field in a non-standard way, between the originating\
    \ system\n      and the point of the network in which the packet was received.\n\
    \   Determining the TTL with which a packet was originally sent by the\n   source\
    \ system can help to obtain valuable information.  Among other\n   things, it\
    \ may help in:\n   o  Fingerprinting the originating operating system.\n   o \
    \ Fingerprinting the originating physical device.\n   o  Mapping the network topology.\n\
    \   o  Locating the source host in the network topology.\n   o  Evading Network\
    \ Intrusion Detection Systems.\n   However, it can also be used to perform important\
    \ functions such as:\n   o  Improving the security of applications that make use\
    \ of the\n      Internet Protocol (IP).\n   o  Limiting spread of packets.\n"
- title: 3.8.1.  Fingerprinting the Operating System in Use by the Source Host
  contents:
  - "3.8.1.  Fingerprinting the Operating System in Use by the Source Host\n   Different\
    \ operating systems use a different default TTL for the\n   packets they send.\
    \  Thus, asserting the TTL with which a packet was\n   originally sent will help\
    \ heuristics to reduce the number of possible\n   operating systems in use by\
    \ the source host.  It should be noted that\n   since most systems use only a\
    \ handful of different default values,\n   the granularity of OS fingerprinting\
    \ that this technique provides is\n   negligible.  Additionally, these defaults\
    \ may be configurable\n   (system-wide or per protocol), and managed systems may\
    \ employ such\n   opportunities for operational purposes and to defeat the capability\n\
    \   of fingerprinting heuristics.\n"
- title: 3.8.2.  Fingerprinting the Physical Device from which the Packets
  contents:
  - "3.8.2.  Fingerprinting the Physical Device from which the Packets\n        Originate\n\
    \   When several systems are behind a middle-box such as a NAT or a load\n   balancer,\
    \ the TTL may help to count the number of systems behind the\n   middle-box. \
    \ If each of the systems behind the middle-box uses a\n   different default TTL\
    \ value for the packets it sends, or each system\n   is located at different distances\
    \ in the network topology, an\n   attacker could stimulate responses from the\
    \ devices being\n   fingerprinted, and responses that arrive with different TTL\
    \ values\n   could be assumed to come from a different devices.\n      Of course,\
    \ there are many other (and much more precise) techniques\n      to fingerprint\
    \ physical devices.  One weakness of this method is\n      that, while many systems\
    \ differ in the default TTL value that they\n      use, there are also many implementations\
    \ which use the same\n      default TTL value.  Additionally, packets sent by\
    \ a given device\n      may take different routes (e.g., due to load sharing or\
    \ route\n      changes), and thus a given packet may incorrectly be presumed to\n\
    \      come from a different device, when in fact it just traveled a\n      different\
    \ route.\n   However, these defaults may be configurable (system-wide or per\n\
    \   protocol) and managed systems may employ such opportunities for\n   operational\
    \ purposes and to defeat the capability of fingerprinting\n   heuristics.\n"
- title: 3.8.3.  Mapping the Network Topology
  contents:
  - "3.8.3.  Mapping the Network Topology\n   An originating host may set the TTL\
    \ field of the packets it sends to\n   progressively increasing values in order\
    \ to elicit an ICMP error\n   message from the routers that decrement the TTL\
    \ of each packet to\n   zero, and thereby determine the IP addresses of the routers\
    \ on the\n   path to the packet's destination.  This procedure has been\n   traditionally\
    \ employed by the traceroute tool.\n"
- title: 3.8.4.  Locating the Source Host in the Network Topology
  contents:
  - "3.8.4.  Locating the Source Host in the Network Topology\n   The TTL field may\
    \ also be used to locate the source system in the\n   network topology [Northcutt2000].\n\
    \             +---+     +---+      +---+    +---+     +---+\n             | A\
    \ |-----| R |------| R |----| R |-----| R |\n             +---+     +---+    \
    \  +---+    +---+     +---+\n                        /           |           \
    \    /   \\\n                       /            |              /     \\\n   \
    \                   /             |             /       +---+\n              \
    \       /   +---+    +---+      +---+        | E |\n                    /    |\
    \ R |----| R |------| R |--      +---+\n                   /     +---+    +---+\\\
    \     +---+  \\\n                  /     /          /    \\       \\    \\\n \
    \                /  ----          /      +---+   \\    \\+---+\n             \
    \   /  /             /       | F |    \\    | D |\n             +---+        \
    \  +---+        +---+     \\   +---|\n             | R |----------| R |--    \
    \             \\\n             +---+          +---+  \\                 \\\n \
    \              |  \\         /       \\    +---+|     +---+\n               |\
    \   \\       /         ----| R |------| R |\n               |    \\     /    \
    \          +---+      +---+\n             +---+   \\ +---+    +---+\n        \
    \     | B |    \\| R |----| C |\n             +---+     +---+    +---+\n     \
    \       Figure 6: Tracking a Host by Means of the TTL Field\n   Consider network\
    \ topology of Figure 6.  Assuming that an attacker\n   (\"F\" in the figure) is\
    \ performing some type of attack that requires\n   forging the Source Address\
    \ (such as for a TCP-based DoS reflection\n   attack), and some of the involved\
    \ hosts are willing to cooperate to\n   locate the attacking system.\n   Assuming\
    \ that:\n   o  All the packets A gets have a TTL of 61.\n   o  All the packets\
    \ B gets have a TTL of 61.\n   o  All the packets C gets have a TTL of 61.\n \
    \  o  All the packets D gets have a TTL of 62.\n   Based on this information,\
    \ and assuming that the system's default\n   value was not overridden, it would\
    \ be fair to assume that the\n   original TTL of the packets was 64.  With this\
    \ information, the\n   number of hops between the attacker and each of the aforementioned\n\
    \   hosts can be calculated.\n   The attacker is:\n   o  Four hops away from A.\n\
    \   o  Four hops away from B.\n   o  Four hops away from C.\n   o  Four hops away\
    \ from D.\n   In the network setup of Figure 3, the only system that satisfies\
    \ all\n   these conditions is the one marked as the \"F\".\n   The scenario described\
    \ above is for illustration purposes only.  In\n   practice, there are a number\
    \ of factors that may prevent this\n   technique from being successfully applied:\n\
    \   o  Unless there is a \"large\" number of cooperating systems, and the\n  \
    \    attacker is assumed to be no more than a few hops away from these\n     \
    \ systems, the number of \"candidate\" hosts will usually be too large\n     \
    \ for the information to be useful.\n   o  The attacker may be using a non-default\
    \ TTL value, or, what is\n      worse, using a pseudo-random value for the TTL\
    \ of the packets it\n      sends.\n   o  The packets sent by the attacker may\
    \ take different routes, as a\n      result of a change in network topology, load\
    \ sharing, etc., and\n      thus may lead to an incorrect analysis.\n"
- title: 3.8.5.  Evading Network Intrusion Detection Systems
  contents:
  - "3.8.5.  Evading Network Intrusion Detection Systems\n   The TTL field can be\
    \ used to evade Network Intrusion Detection\n   Systems.  Depending on the position\
    \ of a sensor relative to the\n   destination host of the examined packet, the\
    \ NIDS may get a different\n   picture from that of the intended destination system.\
    \  As an example,\n   a sensor may process a packet that will expire before getting\
    \ to the\n   destination host.  A general countermeasure for this type of attack\n\
    \   is to normalize the traffic that gets to an organizational network.\n   Examples\
    \ of such traffic normalization can be found in [Paxson2001].\n   OpenBSD Packet\
    \ Filter is an example of a packet filter that includes\n   TTL-normalization\
    \ functionality [OpenBSD-PF]\n"
- title: 3.8.6.  Improving the Security of Applications That Make Use of the
  contents:
  - "3.8.6.  Improving the Security of Applications That Make Use of the\n       \
    \ Internet Protocol (IP)\n   In some scenarios, the TTL field can be also used\
    \ to improve the\n   security of an application, by restricting the hosts that\
    \ can\n   communicate with the given application [RFC5082].  For example, there\n\
    \   are applications for which the communicating systems are typically in\n  \
    \ the same network segment (i.e., there are no intervening routers).\n   Such\
    \ an application is the BGP (Border Gateway Protocol) utilized by\n   two peer\
    \ routers (usually on a shared link medium).\n   If both systems use a TTL of\
    \ 255 for all the packets they send to\n   each other, then a check could be enforced\
    \ to require all packets\n   meant for the application in question to have a TTL\
    \ of 255.\n   As all packets sent by systems that are not in the same network\n\
    \   segment will have a TTL smaller than 255, those packets will not pass\n  \
    \ the check enforced by these two cooperating peers.  This check\n   reduces the\
    \ set of systems that may perform attacks against the\n   protected application\
    \ (BGP in this case), thus mitigating the attack\n   vectors described in [NISCC2004]\
    \ and [Watson2004].\n      This same check is enforced for related ICMP error\
    \ messages, with\n      the intent of mitigating the attack vectors described\
    \ in\n      [NISCC2005] and [RFC5927].\n   The TTL field can be used in a similar\
    \ way in scenarios in which the\n   cooperating systems are not in the same network\
    \ segment (i.e., multi-\n   hop peering).  In that case, the following check could\
    \ be enforced:\n                           TTL >= 255 - DeltaHops\n   This means\
    \ that the set of hosts from which packets will be accepted\n   for the protected\
    \ application will be reduced to those that are no\n   more than DeltaHops away.\
    \  While for obvious reasons the level of\n   protection will be smaller than\
    \ in the case of directly connected\n   peers, the use of the TTL field for protecting\
    \ multi-hop peering\n   still reduces the set of hosts that could potentially\
    \ perform a\n   number of attacks against the protected application.\n   This\
    \ use of the TTL field has been officially documented by the IETF\n   under the\
    \ name \"Generalized TTL Security Mechanism\" (GTSM) in\n   [RFC5082].\n   Some\
    \ protocol scrubbers enforce a minimum value for the TTL field of\n   the packets\
    \ they forward.  It must be understood that depending on\n   the minimum TTL being\
    \ enforced, and depending on the particular\n   network setup, the protocol scrubber\
    \ may actually help attackers to\n   fool the GTSM, by \"raising\" the TTL of\
    \ the attacking packets.\n"
- title: 3.8.7.  Limiting Spread
  contents:
  - "3.8.7.  Limiting Spread\n   The originating host sets the TTL field to a small\
    \ value (frequently\n   1, for link-scope services) in order to artificially limit\
    \ the\n   (topological) distance the packet is allowed to travel.  This is\n \
    \  suggested in Section 4.2.2.9 of RFC 1812 [RFC1812].  Further\n   discussion\
    \ of this technique can be found in RFC 1112 [RFC1112].\n"
- title: 3.9.  Protocol
  contents:
  - "3.9.  Protocol\n   The Protocol field indicates the protocol encapsulated in\
    \ the\n   Internet datagram.  The Protocol field may not only contain a value\n\
    \   corresponding to a protocol implemented by the system processing the\n   packet,\
    \ but also a value corresponding to a protocol not implemented,\n   or even a\
    \ value not yet assigned by the IANA [IANA_PROT_NUM].\n   While in theory there\
    \ should not be security implications from the\n   use of any value in the protocol\
    \ field, there have been security\n   issues in the past with systems that had\
    \ problems when handling\n   packets with some specific protocol numbers [Cisco2003]\
    \ [CERT2003].\n   A host (i.e., end-system) that receives an IP packet encapsulating\
    \ a\n   Protocol it does not support should drop the corresponding packet,\n \
    \  log the event, and possibly send an ICMP Protocol Unreachable (type\n   3,\
    \ code 2) error message.\n"
- title: 3.10.  Header Checksum
  contents:
  - "3.10.  Header Checksum\n   The Header Checksum field is an error-detection mechanism\
    \ meant to\n   detect errors in the IP header.  While in principle there should\
    \ not\n   be security implications arising from this field, it should be noted\n\
    \   that due to non-RFC-compliant implementations, the Header Checksum\n   might\
    \ be exploited to detect firewalls and/or evade NIDSs.\n   [Ed3f2002] describes\
    \ the exploitation of the TCP checksum for\n   performing such actions.  As there\
    \ are Internet routers known to not\n   check the IP Header Checksum, and there\
    \ might also be middle-boxes\n   (NATs, firewalls, etc.) not checking the IP checksum\
    \ allegedly due to\n   performance reasons, similar malicious activity to the\
    \ one described\n   in [Ed3f2002] might be performed with the IP checksum.\n"
- title: 3.11.  Source Address
  contents:
  - "3.11.  Source Address\n   The Source Address of an IP datagram identifies the\
    \ node from which\n   the packet originated.\n      Strictly speaking, the Source\
    \ Address of an IP datagram identifies\n      the interface of the sending system\
    \ from which the packet was\n      sent, (rather than the originating \"system\"\
    ), as in the Internet\n      Architecture there's no concept of \"node address\"\
    .\n   Unfortunately, it is trivial to forge the Source Address of an\n   Internet\
    \ datagram because of the apparent lack of consistent \"egress\n   filtering\"\
    \ near the edge of the network.  This has been exploited in\n   the past for performing\
    \ a variety of DoS attacks [NISCC2004]\n   [RFC4987] [CERT1996a] [CERT1996b] [CERT1998a]\
    \ and for impersonating\n   other systems in scenarios in which authentication\
    \ was based on the\n   Source Address of the sending system [daemon91996].\n \
    \  The extent to which these attacks can be successfully performed in\n   the\
    \ Internet can be reduced through deployment of ingress/egress\n   filtering in\
    \ the Internet routers.  [NISCC2006] is a detailed guide\n   on ingress and egress\
    \ filtering.  [RFC2827] and [RFC3704] discuss\n   ingress filtering.  [GIAC2000]\
    \ discusses egress filtering.\n   [SpooferProject] measures the Internet's susceptibility\
    \ to forged\n   Source Address IP packets.\n      Even when the obvious field\
    \ on which to perform checks for\n      ingress/egress filtering is the Source\
    \ Address and Destination\n      Address fields of the IP header, there are other\
    \ occurrences of IP\n      addresses on which the same type of checks should be\
    \ performed.\n      One example is the IP addresses contained in the payload of\
    \ ICMP\n      error messages, as discussed in [RFC5927] and [Gont2006].\n   There\
    \ are a number of sanity checks that should be performed on the\n   Source Address\
    \ of an IP datagram.  Details can be found in\n   Section 4.3 (\"Addressing\"\
    ).\n   Additionally, there exist freely available tools that allow\n   administrators\
    \ to monitor which IP addresses are used with which MAC\n   addresses [LBNL2006].\
    \  This functionality is also included in many\n   NIDSs.\n   It is also very\
    \ important to understand that authentication should\n   never rely solely on\
    \ the Source Address used by the communicating\n   systems.\n"
- title: 3.12.  Destination Address
  contents:
  - "3.12.  Destination Address\n   The Destination Address of an IP datagram identifies\
    \ the destination\n   host to which the packet is meant to be delivered.\n   \
    \   Strictly speaking, the Destination Address of an IP datagram\n      identifies\
    \ the interface of the destination network interface,\n      rather than the destination\
    \ \"system\", as in the Internet\n      Architecture there's no concept of \"\
    node address\".\n   There are a number of sanity checks that should be performed\
    \ on the\n   Destination Address of an IP datagram.  Details can be found in\n\
    \   Section 4.3 (\"Addressing\").\n"
- title: 3.13.  Options
  contents:
  - "3.13.  Options\n   According to RFC 791, IP options must be implemented by all\
    \ IP\n   modules, both in hosts and gateways (i.e., end-systems and\n   intermediate-systems).\
    \  This means that the general rules for\n   assembling, parsing, and processing\
    \ of IP options must be\n   implemented.  RFC 791 defines a set of options that\
    \ \"must be\n   understood\", but this set has been updated by RFC 1122 [RFC1122],\
    \ RFC\n   1812 [RFC1812], and other documents.  Section 3.13.2 of this document\n\
    \   describes for each option type the current understanding of the\n   implementation\
    \ requirements.  IP systems are required to ignore\n   options they do not implement.\n\
    \      It should be noted that while a number of IP options have been\n      specified,\
    \ they are generally only used for troubleshooting\n      purposes (except for\
    \ the Router Alert option and the different\n      Security options).\n   There\
    \ are two cases for the format of an option:\n   o  Case 1: A single byte of option-type.\n\
    \   o  Case 2: An option-type byte, an option-length byte, and the actual\n  \
    \    option-data bytes.\n   In Case 2, the option-length byte counts the option-type\
    \ byte and the\n   option-length byte, as well as the actual option-data bytes.\n\
    \   All current and future options except End of Option List (Type = 0)\n   and\
    \ No Operation (Type = 1), are of Class 2.\n   The option-type has three fields:\n\
    \   o  1 bit: copied flag.\n   o  2 bits: option class.\n   o  5 bits: option\
    \ number.\n   This format allows for the creation of new options for the extension\n\
    \   of the Internet Protocol (IP) and their transparent treatment on\n   intermediate-systems\
    \ that do not \"understand\" them, under direction\n   of the first three functional\
    \ parts.\n   The copied flag indicates whether this option should be copied to\
    \ all\n   fragments in the event the packet carrying it needs to be fragmented:\n\
    \   o  0 = not copied.\n   o  1 = copied.\n   The values for the option class\
    \ are:\n   o  0 = control.\n   o  1 = reserved for future use.\n   o  2 = debugging\
    \ and measurement.\n   o  3 = reserved for future use.\n   Finally, the option\
    \ number identifies the syntax of the rest of the\n   option.\n   [IANA_IP_PARAM]\
    \ contains the list of the currently assigned IP option\n   numbers.  It should\
    \ be noted that IP systems are required to ignore\n   those options they do not\
    \ implement.\n"
- title: 3.13.1.  General Issues with IP Options
  contents:
  - "3.13.1.  General Issues with IP Options\n   The following subsections discuss\
    \ security issues that apply to all\n   IP options.  The proposed checks should\
    \ be performed in addition to\n   any option-specific checks proposed in the next\
    \ sections.\n"
- title: 3.13.1.1.  Processing Requirements
  contents:
  - "3.13.1.1.  Processing Requirements\n   Router manufacturers tend to do IP option\
    \ processing on the main\n   processor, rather than on line cards.  Unless special\
    \ care is taken,\n   this represents DoS risk, as there is potential for overwhelming\
    \ the\n   router with option processing.\n   To reduce the impact of these packets\
    \ on the system performance, a\n   few countermeasures could be implemented:\n\
    \   o  Rate-limit the number of packets with IP options that are\n      processed\
    \ by the system.\n   o  Enforce a limit on the maximum number of options to be\
    \ accepted on\n      a given Internet datagram.\n   The first check avoids a flow\
    \ of packets with IP options to overwhelm\n   the system in question.  The second\
    \ check avoids packets with many IP\n   options to affect the performance of the\
    \ system.\n"
- title: 3.13.1.2.  Processing of the Options by the Upper-Layer Protocol
  contents:
  - "3.13.1.2.  Processing of the Options by the Upper-Layer Protocol\n   Section\
    \ 3.2.1.8 of RFC 1122 [RFC1122] states that all the IP options\n   received in\
    \ IP datagrams must be passed to the transport layer (or to\n   ICMP processing\
    \ when the datagram is an ICMP message).  Therefore,\n   care in option processing\
    \ must be taken not only at the Internet\n   layer but also in every protocol\
    \ module that may end up processing\n   the options included in an IP datagram.\n"
- title: 3.13.1.3.  General Sanity Checks on IP Options
  contents:
  - "3.13.1.3.  General Sanity Checks on IP Options\n   There are a number of sanity\
    \ checks that should be performed on IP\n   options before further option processing\
    \ is done.  They help prevent\n   a number of potential security problems, including\
    \ buffer overflows.\n   When these checks fail, the packet carrying the option\
    \ should be\n   dropped, and this event should be logged (e.g., a counter could\
    \ be\n   incremented to reflect the packet drop).\n   RFC 1122 [RFC1122] recommends\
    \ to send an ICMP \"Parameter Problem\"\n   message to the originating system\
    \ when a packet is dropped because of\n   an invalid value in a field, such as\
    \ the cases discussed in the\n   following subsections.  Sending such a message\
    \ might help in\n   debugging some network problems.  However, it would also alert\n\
    \   attackers about the system that is dropping packets because of the\n   invalid\
    \ values in the protocol fields.\n   We advice that systems default to sending\
    \ an ICMP \"Parameter Problem\"\n   error message when a packet is dropped because\
    \ of an invalid value in\n   a protocol field (e.g., as a result of dropping a\
    \ packet due to the\n   sanity checks described in this section).  However, we\
    \ recommend that\n   systems provide a system-wide toggle that allows an administrator\
    \ to\n   override the default behavior so that packets can be silently dropped\n\
    \   when an invalid value in a protocol field is encountered.\n   Option length\n\
    \      Section 3.2.1.8 of RFC 1122 explicitly states that the IP layer\n     \
    \ must not crash as the result of an option length that is outside\n      the\
    \ possible range, and mentions that erroneous option lengths\n      have been\
    \ observed to put some IP implementations into infinite\n      loops.\n      For\
    \ options that belong to the \"Case 2\" described in the previous\n      section,\
    \ the following check should be performed:\n                             option-length\
    \ >= 2\n         The value \"2\" accounts for the option-type byte and the option-\n\
    \         length byte.\n      This check prevents, among other things, loops in\
    \ option\n      processing that may arise from incorrect option lengths.\n   \
    \   Additionally, while the option-length byte of IP options of\n      \"Case\
    \ 2\" allows for an option length of up to 255 bytes, there is\n      a limit\
    \ on legitimate option length imposed by the space available\n      for options\
    \ in the IP header.\n      For all options of \"Case 2\", the following check\
    \ should be\n      enforced:\n                  option-offset + option-length\
    \ <= IHL * 4\n   Where option-offset is the offset of the first byte of the option\n\
    \   within the IP header, with the first byte of the IP header being\n   assigned\
    \ an offset of 0.\n      This check assures that the option does not claim to\
    \ extend beyond\n      the IP header.  If the packet does not pass this check,\
    \ it should\n      be dropped, and this event should be logged (e.g., a counter\
    \ could\n      be incremented to reflect the packet drop).\n      The aforementioned\
    \ check is meant to detect forged option-length\n      values that might make\
    \ an option overlap with the IP payload.\n      This would be particularly dangerous\
    \ for those IP options that\n      request the processing systems to write information\
    \ into the\n      option-data area (such as the Record Route option), as it would\n\
    \      allow the generation of overflows.\n   Data types\n      Many IP options\
    \ use pointer and length fields.  Care must be taken\n      as to the data type\
    \ used for these fields in the implementation.\n      For example, if an 8-bit\
    \ signed data type were used to hold an\n      8-bit pointer, then, pointer values\
    \ larger than 128 might\n      mistakenly be interpreted as negative numbers,\
    \ and thus might lead\n      to unpredictable results.\n"
- title: 3.13.2.  Issues with Specific Options
  contents:
  - '3.13.2.  Issues with Specific Options

    '
- title: 3.13.2.1.  End of Option List (Type=0)
  contents:
  - "3.13.2.1.  End of Option List (Type=0)\n   This option is used to indicate the\
    \ \"end of options\" in those cases\n   in which the end of options would not\
    \ coincide with the end of the\n   Internet Protocol header.  Octets in the IP\
    \ header following the \"End\n   of Option List\" are to be regarded as padding\
    \ (they should set to 0\n   by the originator and must to be ignored by receiving\
    \ nodes).\n   However, an originating node could alternatively fill the remaining\n\
    \   space in the Internet header with No Operation options (see\n   Section 3.13.2.2).\
    \  The End of Option List option allows slightly\n   more efficient parsing on\
    \ receiving nodes and should be preferred by\n   packet originators.  All IP systems\
    \ are required to understand both\n   encodings.\n"
- title: 3.13.2.2.  No Operation (Type=1)
  contents:
  - "3.13.2.2.  No Operation (Type=1)\n   The No Operation option is basically meant\
    \ to allow the sending\n   system to align subsequent options in, for example,\
    \ 32-bit\n   boundaries, but it can also be used at the end of the options (see\n\
    \   Section 3.13.2.1).\n   With a single exception (see Section 3.13.2.13), this\
    \ option is the\n   only IP option defined so far that can occur in multiple instances\
    \ in\n   a single IP packet.\n   This option does not have security implications.\n"
- title: 3.13.2.3.  Loose Source and Record Route (LSRR) (Type=131)
  contents:
  - "3.13.2.3.  Loose Source and Record Route (LSRR) (Type=131)\n   This option lets\
    \ the originating system specify a number of\n   intermediate-systems a packet\
    \ must pass through to get to the\n   destination host.  Additionally, the route\
    \ followed by the packet is\n   recorded in the option.  The receiving host (end-system)\
    \ must use the\n   reverse of the path contained in the received LSRR option.\n\
    \   The LSSR option can be of help in debugging some network problems.\n   Some\
    \ ISP (Internet Service Provider) peering agreements require\n   support for this\
    \ option in the routers within the peer of the ISP.\n   The LSRR option has well-known\
    \ security implications.  Among other\n   things, the option can be used to:\n\
    \   o  Bypass firewall rules\n   o  Reach otherwise unreachable Internet systems\n\
    \   o  Establish TCP connections in a stealthy way\n   o  Learn about the topology\
    \ of a network\n   o  Perform bandwidth-exhaustion attacks\n   Of these attack\
    \ vectors, the one that has probably received the least\n   attention is the use\
    \ of the LSRR option to perform bandwidth\n   exhaustion attacks.  The LSRR option\
    \ can be used as an amplification\n   method for performing bandwidth-exhaustion\
    \ attacks, as an attacker\n   could make a packet bounce multiple times between\
    \ a number of systems\n   by carefully crafting an LSRR option.\n      This is\
    \ the IPv4-version of the IPv6 amplification attack that was\n      widely publicized\
    \ in 2007 [Biondi2007].  The only difference is\n      that the maximum length\
    \ of the IPv4 header (and hence the LSRR\n      option) limits the amplification\
    \ factor when compared to the IPv6\n      counterpart.\n   While the LSSR option\
    \ may be of help in debugging some network\n   problems, its security implications\
    \ outweigh any legitimate use.\n   All systems should, by default, drop IP packets\
    \ that contain an LSRR\n   option, and should log this event (e.g., a counter\
    \ could be\n   incremented to reflect the packet drop).  However, they should\n\
    \   provide a system-wide toggle to enable support for this option for\n   those\
    \ scenarios in which this option is required.  Such system-wide\n   toggle should\
    \ default to \"off\" (or \"disable\").\n      [OpenBSD1998] is a security advisory\
    \ about an improper\n      implementation of such a system-wide toggle in 4.4BSD\
    \ kernels.\n   Section 3.3.5 of RFC 1122 [RFC1122] states that a host may be able\
    \ to\n   act as an intermediate hop in a source route, forwarding a source-\n\
    \   routed datagram to the next specified hop.  We strongly discourage\n   host\
    \ software from forwarding source-routed datagrams.\n   If processing of source-routed\
    \ datagrams is explicitly enabled in a\n   system, the following sanity checks\
    \ should be performed.\n   RFC 791 states that this option should appear, at most,\
    \ once in a\n   given packet.  Thus, if a packet contains more than one LSRR option,\n\
    \   it should be dropped, and this event should be logged (e.g., a\n   counter\
    \ could be incremented to reflect the packet drop).\n   Additionally, packets\
    \ containing a combination of LSRR and SSRR\n   options should be dropped, and\
    \ this event should be logged (e.g., a\n   counter could be incremented to reflect\
    \ the packet drop).\n   As all other IP options of \"Case 2\", the LSSR contains\
    \ a Length field\n   that indicates the length of the option.  Given the format\
    \ of the\n   option, the Length field should be checked to have a minimum value\
    \ of\n   three and be 3 (3 + n*4):\n                  LSRR.Length % 4 == 3 &&\
    \ LSRR.Length != 0\n   If the packet does not pass this check, it should be dropped,\
    \ and\n   this event should be logged (e.g., a counter could be incremented to\n\
    \   reflect the packet drop).\n   The Pointer is relative to this option.  Thus,\
    \ the minimum legal\n   value is 4.  Therefore, the following check should be\
    \ performed.\n                             LSRR.Pointer >= 4\n   If the packet\
    \ does not pass this check, it should be dropped, and\n   this event should be\
    \ logged (e.g., a counter could be incremented to\n   reflect the packet drop).\
    \  Additionally, the Pointer field should be\n   a multiple of 4.  Consequently,\
    \ the following check should be\n   performed:\n                           LSRR.Pointer\
    \ % 4 == 0\n   If a packet does not pass this check, it should be dropped, and\
    \ this\n   event should be logged (e.g., a counter could be incremented to\n \
    \  reflect the packet drop).\n   When a system receives an IP packet with the\
    \ LSRR option passing the\n   above checks, it should check whether or not the\
    \ source route is\n   empty.  The option is empty if:\n                      \
    \   LSRR.Pointer > LSRR.Length\n   In that case, routing should be based on the\
    \ Destination Address\n   field, and no further processing should be done on the\
    \ LSRR option.\n      [Microsoft1999] is a security advisory about a vulnerability\n\
    \      arising from improper validation of the LSRR.Pointer field.\n   If the\
    \ address in the Destination Address field has been reached, and\n   the option\
    \ is not empty, the next address in the source route\n   replaces the address\
    \ in the Destination Address field, and the IP\n   address of the interface that\
    \ will be used to forward this datagram\n   is recorded in its place in the LSRR.Data\
    \ field.  Then, the\n   LSRR.Pointer. is incremented by 4.\n      Note that the\
    \ sanity checks for the LSRR.Length and the\n      LSRR.Pointer fields described\
    \ above ensure that if the option is\n      not empty, there will be (4*n) octets\
    \ in the option.  That is,\n      there will be at least one IP address to read\
    \ and enough room to\n      record the IP address of the interface that will be\
    \ used to\n      forward this datagram.\n   The LSRR must be copied on fragmentation.\
    \  This means that if a\n   packet that carries the LSRR is fragmented, each of\
    \ the fragments\n   will have to go through the list of systems specified in the\
    \ LSRR\n   option.\n"
- title: 3.13.2.4.  Strict Source and Record Route (SSRR) (Type=137)
  contents:
  - "3.13.2.4.  Strict Source and Record Route (SSRR) (Type=137)\n   This option allows\
    \ the originating system to specify a number of\n   intermediate-systems a packet\
    \ must pass through to get to the\n   destination host.  Additionally, the route\
    \ followed by the packet is\n   recorded in the option, and the destination host\
    \ (end-system) must\n   use the reverse of the path contained in the received\
    \ SSRR option.\n   This option is similar to the Loose Source and Record Route\
    \ (LSRR)\n   option, with the only difference that in the case of SSRR, the route\n\
    \   specified in the option is the exact route the packet must take\n   (i.e.,\
    \ no other intervening routers are allowed to be in the route).\n   The SSSR option\
    \ can be of help in debugging some network problems.\n   Some ISP (Internet Service\
    \ Provider) peering agreements require\n   support for this option in the routers\
    \ within the peer of the ISP.\n   The SSRR option has the same security implications\
    \ as the LSRR\n   option.  Please refer to Section 3.13.2.3 for a discussion of\
    \ such\n   security implications.\n   As with the LSRR, while the SSSR option\
    \ may be of help in debugging\n   some network problems, its security implications\
    \ outweigh any\n   legitimate use of it.\n   All systems should, by default, drop\
    \ IP packets that contain an SSRR\n   option, and should log this event (e.g.,\
    \ a counter could be\n   incremented to reflect the packet drop).  However, they\
    \ should\n   provide a system-wide toggle to enable support for this option for\n\
    \   those scenarios in which this option is required.  Such system-wide\n   toggle\
    \ should default to \"off\" (or \"disable\").\n      [OpenBSD1998] is a security\
    \ advisory about an improper\n      implementation of such a system-wide toggle\
    \ in 4.4BSD kernels.\n   In the event processing of the SSRR option were explicitly\
    \ enabled,\n   the same sanity checks described for the LSRR option in\n   Section\
    \ 3.13.2.3 should be performed on the SSRR option.  Namely,\n   sanity checks\
    \ should be performed on the option length (SSRR.Length)\n   and the pointer field\
    \ (SSRR.Pointer).\n   If the packet passes the aforementioned sanity checks, the\
    \ receiving\n   system should determine whether the Destination Address of the\
    \ packet\n   corresponds to one of its IP addresses.  If does not, it should be\n\
    \   dropped, and this event should be logged (e.g., a counter could be\n   incremented\
    \ to reflect the packet drop).\n      Contrary to the IP Loose Source and Record\
    \ Route (LSRR) option,\n      the SSRR option does not allow in the route other\
    \ routers than\n      those contained in the option.  If the system implements\
    \ the weak\n      end-system model, it is allowed for the system to receive a\
    \ packet\n      destined to any of its IP addresses, on any of its interfaces.\
    \  If\n      the system implements the strong end-system model, a packet\n   \
    \   destined to it can be received only on the interface that\n      corresponds\
    \ to the IP address contained in the Destination Address\n      field [RFC1122].\n\
    \   If the packet passes this check, the receiving system should\n   determine\
    \ whether the source route is empty or not.  The option is\n   empty if:\n   \
    \                      SSRR.Pointer > SSRR.Length\n   In that case, if the address\
    \ in the destination field has not been\n   reached, the packet should be dropped,\
    \ and this event should be\n   logged (e.g., a counter could be incremented to\
    \ reflect the packet\n   drop).\n      [Microsoft1999] is a security advisory\
    \ about a vulnerability\n      arising from improper validation of the SSRR.Pointer\
    \ field.\n   If the option is not empty, and the address in the Destination\n\
    \   Address field has been reached, the next address in the source route\n   replaces\
    \ the address in the Destination Address field, and the IP\n   address of the\
    \ interface that will be used to forward this datagram\n   is recorded in its\
    \ place in the source route (SSRR.Data field).\n   Then, the SSRR.Pointer is incremented\
    \ by 4.\n      Note that the sanity checks for the SSRR.Length and the\n     \
    \ SSRR.Pointer fields described above ensure that if the option is\n      not\
    \ empty, there will be (4*n) octets in the option.  That is,\n      there will\
    \ be at least one IP address to read, and enough room to\n      record the IP\
    \ address of the interface that will be used to\n      forward this datagram.\n\
    \   The SSRR option must be copied on fragmentation.  This means that if\n   a\
    \ packet that carries the SSRR is fragmented, each of the fragments\n   will have\
    \ to go through the list of systems specified in the SSRR\n   option.\n"
- title: 3.13.2.5.  Record Route (Type=7)
  contents:
  - "3.13.2.5.  Record Route (Type=7)\n   This option provides a means to record the\
    \ route that a given packet\n   follows.\n   The option begins with an 8-bit option\
    \ code, which is equal to 7.\n   The second byte is the option length, which includes\
    \ the option-type\n   byte, the option-length byte, the pointer byte, and the\
    \ actual\n   option-data.  The third byte is a pointer into the route data,\n\
    \   indicating the first byte of the area in which to store the next\n   route\
    \ data.  The pointer is relative to the option start.\n   RFC 791 states that\
    \ this option should appear, at most, once in a\n   given packet.  Therefore,\
    \ if a packet has more than one instance of\n   this option, it should be dropped,\
    \ and this event should be logged\n   (e.g., a counter could be incremented to\
    \ reflect the packet drop).\n   The same sanity checks performed for the Length\
    \ field and the Pointer\n   field of the LSRR and the SSRR options should be performed\
    \ on the\n   Length field (RR.Length) and the Pointer field (RR.Pointer) of the\
    \ RR\n   option.  As with the LSRR and SSRR options, if the packet does not\n\
    \   pass these checks it should be dropped, and this event should be\n   logged\
    \ (e.g., a counter could be incremented to reflect the packet\n   drop).\n   When\
    \ a system receives an IP packet with the Record Route option that\n   passes\
    \ the above checks, it should check whether there is space in\n   the option to\
    \ store route information.  The option is full if:\n                         \
    \  RR.Pointer > RR.Length\n   If the option is full, the datagram should be forwarded\
    \ without\n   further processing of this option.\n   If the option is not full\
    \ (i.e., RR.Pointer <= RR.Length), the IP\n   address of the interface that will\
    \ be used to forward this datagram\n   should be recorded into the area pointed\
    \ to by the RR.Pointer, and\n   RR.Pointer should then incremented by 4.\n   This\
    \ option is not copied on fragmentation, and thus appears in the\n   first fragment\
    \ only.  If a fragment other than the one with offset 0\n   contains the Record\
    \ Route option, it should be dropped, and this\n   event should be logged (e.g.,\
    \ a counter could be incremented to\n   reflect the packet drop).\n   The Record\
    \ Route option can be exploited to learn about the topology\n   of a network.\
    \  However, the limited space in the IP header limits the\n   usefulness of this\
    \ option for that purpose if the target network is\n   several hops away.\n"
- title: 3.13.2.6.  Stream Identifier (Type=136)
  contents:
  - "3.13.2.6.  Stream Identifier (Type=136)\n   The Stream Identifier option originally\
    \ provided a means for the\n   16-bit SATNET stream Identifier to be carried through\
    \ networks that\n   did not support the stream concept.\n   However, as stated\
    \ by Section 4.2.2.1 of RFC 1812 [RFC1812], this\n   option is obsolete.  Therefore,\
    \ it must be ignored by the processing\n   systems.\n   In the case of legacy\
    \ systems still using this option, the length\n   field of the option should be\
    \ checked to be 4.  If the option does\n   not pass this check, it should be dropped,\
    \ and this event should be\n   logged (e.g., a counter could be incremented to\
    \ reflect the packet\n   drop).\n   RFC 791 states that this option appears at\
    \ most once in a given\n   datagram.  Therefore, if a packet contains more than\
    \ one instance of\n   this option, it should be dropped, and this event should\
    \ be logged\n   (e.g., a counter could be incremented to reflect the packet drop).\n"
- title: 3.13.2.7.  Internet Timestamp (Type=68)
  contents:
  - "3.13.2.7.  Internet Timestamp (Type=68)\n   This option provides a means for\
    \ recording the time at which each\n   system processed this datagram.  The timestamp\
    \ option has a number of\n   security implications.  Among them are the following:\n\
    \   o  It allows an attacker to obtain the current time of the systems\n     \
    \ that process the packet, which the attacker may find useful in a\n      number\
    \ of scenarios.\n   o  It may be used to map the network topology, in a similar\
    \ way to\n      the IP Record Route option.\n   o  It may be used to fingerprint\
    \ the operating system in use by a\n      system processing the datagram.\n  \
    \ o  It may be used to fingerprint physical devices by analyzing the\n      clock\
    \ skew.\n   Therefore, by default, the timestamp option should be ignored.\n \
    \  For those systems that have been explicitly configured to honor this\n   option,\
    \ the rest of this subsection describes some sanity checks that\n   should be\
    \ enforced on the option before further processing.\n   The option begins with\
    \ an option-type byte, which must be equal to\n   68.  The second byte is the\
    \ option-length, which includes the option-\n   type byte, the option-length byte,\
    \ the pointer, and the overflow/flag\n   byte.  The minimum legal value for the\
    \ option-length byte is 4, which\n   corresponds to an Internet Timestamp option\
    \ that is empty (no space\n   to store timestamps).  Therefore, upon receipt of\
    \ a packet that\n   contains an Internet Timestamp option, the following check\
    \ should be\n   performed:\n                               IT.Length >= 4\n  \
    \ If the packet does not pass this check, it should be dropped, and\n   this event\
    \ should be logged (e.g., a counter could be incremented to\n   reflect the packet\
    \ drop).\n   The Pointer is an index within this option, counting the option type\n\
    \   octet as octet #1.  It points to the first byte of the area in which\n   the\
    \ next timestamp data should be stored and thus, the minimum legal\n   value is\
    \ 5.  Since the only change of the Pointer allowed by RFC 791\n   is incrementing\
    \ it by 4 or 8, the following checks should be\n   performed on the Internet Timestamp\
    \ option, depending on the Flag\n   value (see below).\n   If IT.Flag is equal\
    \ to 0, the following check should be performed:\n                   IT.Pointer\
    \ %4 == 1 && IT.Pointer != 1\n   If the packet does not pass this check, it should\
    \ be dropped, and\n   this event should be logged (e.g., a counter could be incremented\
    \ to\n   reflect the packet drop).\n   Otherwise, the following sanity check should\
    \ be performed on the\n   option:\n                            IT.Pointer % 8\
    \ == 5\n   If the packet does not pass this check, it should be dropped, and\n\
    \   this event should be logged (e.g., a counter could be incremented to\n   reflect\
    \ the packet drop).\n   The flag field has three possible legal values:\n   o\
    \  0: Record time stamps only, stored in consecutive 32-bit words.\n   o  1: Record\
    \ each timestamp preceded with the Internet address of the\n      registering\
    \ entity.\n   o  3: The internet address fields of the option are pre-specified.\n\
    \      An IP module only registers its timestamp if it matches its own\n     \
    \ address with the next specified Internet address.\n   Therefore the following\
    \ check should be performed:\n                IT.Flag == 0 || IT.Flag == 1 ||\
    \ IT.Flag == 3\n   If the packet does not pass this check, it should be dropped,\
    \ and\n   this event should be logged (e.g., a counter could be incremented to\n\
    \   reflect the packet drop).\n   The timestamp field is a right-justified 32-bit\
    \ timestamp in\n   milliseconds since UTC.  If the time is not available in\n\
    \   milliseconds, or cannot be provided with respect to UTC, then any\n   time\
    \ may be inserted as a timestamp, provided the high-order bit of\n   the timestamp\
    \ is set, to indicate this non-standard value.\n   According to RFC 791, the initial\
    \ contents of the timestamp area must\n   be initialized to zero, or Internet\
    \ address/zero pairs.  However,\n   Internet systems should be able to handle\
    \ non-zero values, possibly\n   discarding the offending datagram.\n   When an\
    \ Internet system receives a packet with an Internet Timestamp\n   option, it\
    \ decides whether it should record its timestamp in the\n   option.  If it determines\
    \ that it should, it should then determine\n   whether the timestamp data area\
    \ is full, by means of the following\n   check:\n                           IT.Pointer\
    \ > IT.Length\n   If this condition is true, the timestamp data area is full.\
    \  If not,\n   there is room in the timestamp data area.\n   If the timestamp\
    \ data area is full, the overflow byte should be\n   incremented, and the packet\
    \ should be forwarded without inserting the\n   timestamp.  If the overflow byte\
    \ itself overflows, the packet should\n   be dropped, and this event should be\
    \ logged (e.g., a counter could be\n   incremented to reflect the packet drop).\n\
    \   If the timestamp data area is not full, then processing continues as\n   follows\
    \ (note that the above checks on IT.Pointer ensure that there\n   is room for\
    \ another entry in the option):\n   o  If IT.Flag is 0, then the system's 32-bit\
    \ timestamp is stored into\n      the area pointed to by the pointer byte and\
    \ the pointer byte is\n      incremented by 4.\n   o  If IT.Flag is 1, then the\
    \ IP address of the system is stored into\n      the area pointed to by the pointer\
    \ byte, followed by the 32-bit\n      system timestamp, and the pointer byte is\
    \ incremented by 8.\n   o  Otherwise (IT.Flag is 3), if the IP address in the\
    \ first 4 bytes\n      pointed to by IT.Pointer matches one of the IP addresses\
    \ assigned\n      to an interface of the system, then the system's timestamp is\n\
    \      stored into the area pointed to by IT.Pointer + 4, and the pointer\n  \
    \    byte is incremented by 8.\n   [Kohno2005] describes a technique for fingerprinting\
    \ devices by\n   measuring the clock skew.  It exploits, among other things, the\n\
    \   timestamps that can be obtained by means of the ICMP timestamp\n   request\
    \ messages [RFC0791].  However, the same fingerprinting method\n   could be implemented\
    \ with the aid of the Internet Timestamp option.\n"
- title: 3.13.2.8.  Router Alert (Type=148)
  contents:
  - "3.13.2.8.  Router Alert (Type=148)\n   The Router Alert option is defined in\
    \ RFC 2113 [RFC2113] and later\n   updates to it have been clarified by RFC 5350\
    \ [RFC5350].  It contains\n   a 16-bit Value governed by an IANA registry (see\
    \ [RFC5350]).  The\n   Router Alert option has the semantic \"routers should examine\
    \ this\n   packet more closely, if they participate in the functionality denoted\n\
    \   by the Value of the option\".\n   According to the syntax of the option as\
    \ defined in RFC 2113, the\n   following check should be enforced, if the router\
    \ supports this\n   option:\n                               RA.Length == 4\n \
    \  If the packet does not pass this check, it should be dropped, and\n   this\
    \ event should be logged (e.g., a counter could be incremented to\n   reflect\
    \ the packet drop).\n   A packet that contains a Router Alert option with an option\
    \ value\n   corresponding to functionality supported by an active module in the\n\
    \   router will not go through the router's fast-path but will be\n   processed\
    \ in the slow path of the router, handing it over for closer\n   inspection to\
    \ the modules that has registered the matching option\n   value.  Therefore, this\
    \ option may impact the performance of the\n   systems that handle the packet\
    \ carrying it.\n      [ROUTER-ALERT] analyzes the security implications of the\
    \ Router\n      Alert option, and identifies controlled environments in which\
    \ the\n      Router Alert option can be used safely.\n   As explained in RFC 2113\
    \ [RFC2113], hosts should ignore this option.\n"
- title: 3.13.2.9.  Probe MTU (Type=11) (Obsolete)
  contents:
  - "3.13.2.9.  Probe MTU (Type=11) (Obsolete)\n   This option was defined in RFC\
    \ 1063 [RFC1063] and originally provided\n   a mechanism to discover the Path-MTU.\n\
    \   This option is obsolete, and therefore any packet that is received\n   containing\
    \ this option should be dropped, and this event should be\n   logged (e.g., a\
    \ counter could be incremented to reflect the packet\n   drop).\n"
- title: 3.13.2.10.  Reply MTU (Type=12) (Obsolete)
  contents:
  - "3.13.2.10.  Reply MTU (Type=12) (Obsolete)\n   This option is defined in RFC\
    \ 1063 [RFC1063], and originally provided\n   a mechanism to discover the Path-MTU.\n\
    \   This option is obsolete, and therefore any packet that is received\n   containing\
    \ this option should be dropped, and this event should be\n   logged (e.g., a\
    \ counter could be incremented to reflect the packet\n   drop).\n"
- title: 3.13.2.11.  Traceroute (Type=82)
  contents:
  - "3.13.2.11.  Traceroute (Type=82)\n   This option is defined in RFC 1393 [RFC1393],\
    \ and originally provided\n   a mechanism to trace the path to a host.\n   The\
    \ Traceroute option was specified as \"experimental\", and it was\n   never deployed\
    \ on the public Internet.  Therefore, any packet that is\n   received containing\
    \ this option should be dropped, and this event\n   should be logged (e.g., a\
    \ counter could be incremented to reflect the\n   packet drop).\n"
- title: 3.13.2.12.  Department of Defense (DoD) Basic Security Option (Type=130)
  contents:
  - "3.13.2.12.  Department of Defense (DoD) Basic Security Option (Type=130)\n  \
    \ This option is used by Multi-Level-Secure (MLS) end-systems and\n   intermediate-systems\
    \ in specific environments to [RFC1108]:\n   o  Transmit from source to destination\
    \ in a network standard\n      representation the common security labels required\
    \ by computer\n      security models,\n   o  Validate the datagram as appropriate\
    \ for transmission from the\n      source and delivery to the destination, and\n\
    \   o  Ensure that the route taken by the datagram is protected to the\n     \
    \ level required by all protection authorities indicated on the\n      datagram.\n\
    \   It is specified by RFC 1108 [RFC1108] (which obsoletes RFC 1038\n   [RFC1038]).\n\
    \      RFC 791 [RFC0791] defined the \"Security Option\" (Type=130), which\n \
    \     used the same option type as the DoD Basic Security option\n      discussed\
    \ in this section.  The \"Security Option\" specified in RFC\n      791 is considered\
    \ obsolete by Section 3.2.1.8 of RFC 1122, and\n      therefore the discussion\
    \ in this section is focused on the DoD\n      Basic Security option specified\
    \ by RFC 1108 [RFC1108].\n   Section 4.2.2.1 of RFC 1812 states that routers \"\
    SHOULD implement\n   this option\".\n   The DoD Basic Security option is currently\
    \ implemented in a number of\n   operating systems (e.g., [IRIX2008], [SELinux2009],\
    \ [Solaris2007],\n   and [Cisco2008]), and deployed in a number of high-security\
    \ networks.\n   Systems that belong to networks in which this option is in use\
    \ should\n   process the DoD Basic Security option contained in each packet as\n\
    \   specified in [RFC1108].\n   RFC 1108 states that the option should appear\
    \ at most once in a\n   datagram.  Therefore, if more than one DoD Basic Security\
    \ option\n   (BSO) appears in a given datagram, the corresponding datagram should\n\
    \   be dropped, and this event should be logged (e.g., a counter could be\n  \
    \ incremented to reflect the packet drop).\n   RFC 1108 states that the option\
    \ Length is variable, with a minimum\n   option Length of 3 bytes.  Therefore,\
    \ the following check should be\n   performed:\n                             \
    \ BSO.Length >= 3\n   If the packet does not pass this check, it should be dropped,\
    \ and\n   this event should be logged (e.g., a counter could be incremented to\n\
    \   reflect the packet drop).\n      Current deployments of the security options\
    \ described in this\n      section and the two subsequent sections have motivated\
    \ the\n      specification of a \"Common Architecture Label IPv6 Security Option\n\
    \      (CALIPSO)\" for the IPv6 protocol [RFC5570].\n"
- title: 3.13.2.13.  DoD Extended Security Option (Type=133)
  contents:
  - "3.13.2.13.  DoD Extended Security Option (Type=133)\n   This option permits additional\
    \ security labeling information, beyond\n   that present in the Basic Security\
    \ option (Section 3.13.2.13), to be\n   supplied in an IP datagram to meet the\
    \ needs of registered\n   authorities.  It is specified by RFC 1108 [RFC1108].\n\
    \   This option may be present only in conjunction with the DoD Basic\n   Security\
    \ option.  Therefore, if a packet contains a DoD Extended\n   Security option\
    \ (ESO), but does not contain a DoD Basic Security\n   option, it should be dropped,\
    \ and this event should be logged (e.g.,\n   a counter could be incremented to\
    \ reflect the packet drop).  It\n   should be noted that, unlike the DoD Basic\
    \ Security option, this\n   option may appear multiple times in a single IP header.\n\
    \   Systems that belong to networks in which this option is in use,\n   should\
    \ process the DoD Extended Security option contained in each\n   packet as specified\
    \ in RFC 1108 [RFC1108].\n   RFC 1108 states that the option Length is variable,\
    \ with a minimum\n   option Length of 3 bytes.  Therefore, the following check\
    \ should be\n   performed:\n                              ESO.Length >= 3\n  \
    \ If the packet does not pass this check, it should be dropped, and\n   this event\
    \ should be logged (e.g., a counter could be incremented to\n   reflect the packet\
    \ drop).\n"
- title: 3.13.2.14.  Commercial IP Security Option (CIPSO) (Type=134)
  contents:
  - "3.13.2.14.  Commercial IP Security Option (CIPSO) (Type=134)\n   This option\
    \ was proposed by the Trusted Systems Interoperability\n   Group (TSIG), with\
    \ the intent of meeting trusted networking\n   requirements for the commercial\
    \ trusted systems market place.  It is\n   specified in [CIPSO1992] and [FIPS1994].\n\
    \      The TSIG proposal was taken to the Commercial Internet Security\n     \
    \ Option (CIPSO) Working Group of the IETF [CIPSOWG1994], and an\n      Internet-Draft\
    \ was produced [CIPSO1992].  The Internet-Draft was\n      never published as\
    \ an RFC, but the proposal was later standardized\n      by the U.S. National\
    \ Institute of Standards and Technology (NIST)\n      as \"Federal Information\
    \ Processing Standard Publication 188\"\n      [FIPS1994].\n   It is currently\
    \ implemented in a number of operating systems (e.g.,\n   IRIX [IRIX2008], Security-Enhanced\
    \ Linux [SELinux2009], and Solaris\n   [Solaris2007]), and deployed in a number\
    \ of high-security networks.\n      [Zakrzewski2002] and [Haddad2004] provide\
    \ an overview of a Linux\n      implementation.\n   Systems that belong to networks\
    \ in which this option is in use should\n   process the CIPSO option contained\
    \ in each packet as specified in\n   [CIPSO1992].\n   According to the option\
    \ syntax specified in [CIPSO1992], the\n   following validation check should be\
    \ performed:\n                             CIPSO.Length >= 6\n   If a packet does\
    \ not pass this check, it should be dropped, and this\n   event should be logged\
    \ (e.g., a counter could be incremented to\n   reflect the packet drop).\n"
- title: 3.13.2.15.  Sender Directed Multi-Destination Delivery (Type=149)
  contents:
  - "3.13.2.15.  Sender Directed Multi-Destination Delivery (Type=149)\n   This option\
    \ is defined in RFC 1770 [RFC1770] and originally provided\n   unreliable UDP\
    \ delivery to a set of addresses included in the option.\n   This option is obsolete.\
    \  If a received packet contains this option,\n   it should be dropped, and this\
    \ event should be logged (e.g., a\n   counter could be incremented to reflect\
    \ the packet drop).\n"
- title: 4.  Internet Protocol Mechanisms
  contents:
  - '4.  Internet Protocol Mechanisms

    '
- title: 4.1.  Fragment Reassembly
  contents:
  - "4.1.  Fragment Reassembly\n   To accommodate networks with different Maximum\
    \ Transmission Units\n   (MTUs), the Internet Protocol provides a mechanism for\
    \ the\n   fragmentation of IP packets by end-systems (hosts) and/or\n   intermediate-systems\
    \ (routers).  Reassembly of fragments is performed\n   only by the end-systems.\n\
    \      [Cerf1974] provides the rationale for why packet reassembly is not\n  \
    \    performed by intermediate-systems.\n   During the last few decades, IP fragmentation\
    \ and reassembly has been\n   exploited in a number of ways, to perform actions\
    \ such as evading\n   NIDSs, bypassing firewall rules, and performing DoS attacks.\n\
    \      [Bendi1998] and [Humble1998] are examples of the exploitation of\n    \
    \  these issues for performing DoS attacks.  [CERT1997] and\n      [CERT1998b]\
    \ document these issues.  [Anderson2001] is a survey of\n      fragmentation attacks.\
    \  [US-CERT2001] is an example of the\n      exploitation of IP fragmentation\
    \ to bypass firewall rules.\n      [CERT1999] describes the implementation of\
    \ fragmentation attacks\n      in Distributed Denial-of-Service (DDoS) attack\
    \ tools.\n   The problem with IP fragment reassembly basically has to do with\
    \ the\n   complexity of the function, in a number of aspects:\n   o  Fragment\
    \ reassembly is a stateful operation for a stateless\n      protocol (IP).  The\
    \ IP module at the host performing the\n      reassembly function must allocate\
    \ memory buffers both for\n      temporarily storing the received fragments and\
    \ to perform the\n      reassembly function.  Attackers can exploit this fact\
    \ to exhaust\n      memory buffers at the system performing the fragment reassembly.\n\
    \   o  The fragmentation and reassembly mechanisms were designed at a\n      time\
    \ in which the available bandwidths were very different from\n      the bandwidths\
    \ available nowadays.  With the current available\n      bandwidths, a number\
    \ of interoperability problems may arise, and\n      these issues may be intentionally\
    \ exploited by attackers to\n      perform DoS attacks.\n   o  Fragment reassembly\
    \ must usually be performed without any\n      knowledge of the properties of\
    \ the path the fragments follow.\n      Without this information, hosts cannot\
    \ make any educated guess on\n      how long they should wait for missing fragments\
    \ to arrive.\n   o  The fragment reassembly algorithm, as described by the IETF\n\
    \      specifications, is ambiguous, and allows for a number of\n      interpretations,\
    \ each of which has found place in different TCP/IP\n      stack implementations.\n\
    \   o  The reassembly process is somewhat complex.  Fragments may arrive\n   \
    \   out of order, duplicated, overlapping each other, etc.  This\n      complexity\
    \ has lead to numerous bugs in different implementations\n      of the IP protocol.\n"
- title: 4.1.1.  Security Implications of Fragment Reassembly
  contents:
  - '4.1.1.  Security Implications of Fragment Reassembly

    '
- title: 4.1.1.1.  Problems Related to Memory Allocation
  contents:
  - "4.1.1.1.  Problems Related to Memory Allocation\n   When an IP datagram is received\
    \ by an end-system, it will be\n   temporarily stored in system memory, until\
    \ the IP module processes it\n   and hands it to the protocol machine that corresponds\
    \ to the\n   encapsulated protocol.\n   In the case of fragmented IP packets,\
    \ while the IP module may perform\n   preliminary processing of the IP header\
    \ (such as checking the header\n   for errors and processing IP options), fragments\
    \ must be kept in\n   system buffers until all fragments are received and are\
    \ reassembled\n   into a complete Internet datagram.\n   As mentioned above, because\
    \ the Internet layer will not usually have\n   information about the characteristics\
    \ of the path between the system\n   and the remote host, no educated guess can\
    \ be made on the amount of\n   time that should be waited for the other fragments\
    \ to arrive.\n   Therefore, the specifications recommend to wait for a period\
    \ of time\n   that is acceptable for virtually all the possible network scenarios\n\
    \   in which the protocols might operate.  After that time has elapsed,\n   all\
    \ the received fragments for the corresponding incomplete packet\n   are discarded.\n\
    \      The original IP Specification, RFC 791 [RFC0791], states that\n      systems\
    \ should wait for at least 15 seconds for the missing\n      fragments to arrive.\
    \  Systems that follow the \"Example Reassembly\n      Procedure\" described in\
    \ Section 3.2 of RFC 791 may end up using a\n      reassembly timer of up to 4.25\
    \ minutes, with a minimum of 15\n      seconds.  Section 3.3.2 (\"Reassembly\"\
    ) of RFC 1122 corrected this\n      advice, stating that the reassembly timeout\
    \ should be a fixed\n      value between 60 and 120 seconds.\n   However, the\
    \ longer the system waits for the missing fragments to\n   arrive, the longer\
    \ the corresponding system resources must be tied to\n   the corresponding packet.\
    \  The amount of system memory is finite, and\n   even with today's systems, it\
    \ can still be considered a scarce\n   resource.\n   An attacker could take advantage\
    \ of the uncomfortable situation the\n   system performing fragment reassembly\
    \ is in, by sending forged\n   fragments that will never reassemble into a complete\
    \ datagram.  That\n   is, an attacker would send many different fragments, with\
    \ different\n   IP IDs, without ever sending all the necessary fragments that\
    \ would\n   be needed to reassemble them into a full IP datagram.  For each of\n\
    \   the fragments, the IP module would allocate resources and tie them to\n  \
    \ the corresponding fragment, until the reassembly timer for the\n   corresponding\
    \ packet expires.\n   There are some implementation strategies which could increase\
    \ the\n   impact of this attack.  For example, upon receipt of a fragment, some\n\
    \   systems allocate a memory buffer that will be large enough to\n   reassemble\
    \ the whole datagram.  While this might be beneficial in\n   legitimate cases,\
    \ this just amplifies the impact of the possible\n   attacks, as a single small\
    \ fragment could tie up memory buffers for\n   the size of an extremely large\
    \ (and unlikely) datagram.  The\n   implementation strategy suggested in RFC 815\
    \ [RFC0815] leads to such\n   an implementation.\n   The impact of the aforementioned\
    \ attack may vary depending on some\n   specific implementation details:\n   o\
    \  If the system does not enforce limits on the amount of memory that\n      can\
    \ be allocated by the IP module, then an attacker could tie all\n      system\
    \ memory to fragments, at which point the system would become\n      unusable,\
    \ perhaps crashing.\n   o  If the system enforces limits on the amount of memory\
    \ that can be\n      allocated by the IP module as a whole, then, when this limit\
    \ is\n      reached, all further IP packets that arrive would be discarded,\n\
    \      until some fragments time out and free memory is available again.\n   o\
    \  If the system enforces limits on the amount memory that can be\n      allocated\
    \ for the reassembly of fragments, then, when this limit\n      is reached, all\
    \ further fragments that arrive would be discarded,\n      until some fragment(s)\
    \ time out and free memory is available\n      again.\n"
- title: 4.1.1.2.  Problems That Arise from the Length of the IP Identification
  contents:
  - "4.1.1.2.  Problems That Arise from the Length of the IP Identification\n    \
    \      Field\n   The Internet Protocols are currently being used in environments\
    \ that\n   are quite different from the ones in which they were conceived.  For\n\
    \   instance, the availability of bandwidth at the time the Internet\n   Protocol\
    \ was designed was completely different from the availability\n   of bandwidth\
    \ in today's networks.\n   The Identification field is a 16-bit field that is\
    \ used for the\n   fragmentation and reassembly function.  In the event a datagram\
    \ gets\n   fragmented, all the corresponding fragments will share the same\n \
    \  {Source Address, Destination Address, Protocol, Identification\n   number}\
    \ four-tuple.  Thus, the system receiving the fragments will be\n   able to uniquely\
    \ identify them as fragments that correspond to the\n   same IP datagram.  At\
    \ a given point in time, there must be at most\n   only one packet in the network\
    \ with a given four-tuple.  If not, an\n   Identification number \"collision\"\
    \ might occur, and the receiving\n   system might end up \"mixing\" fragments\
    \ that correspond to different\n   IP datagrams which simply reused the same Identification\
    \ number.\n      For example, sending over a 1 Gbit/s path a continuous stream\
    \ of\n      (UDP) packets of roughly 1 kb size that all get fragmented into\n\
    \      two equally sized fragments of 576 octets each (minimum reassembly\n  \
    \    buffer size) would repeat the IP Identification values within less\n    \
    \  than 0.65 seconds (assuming roughly 10% link layer overhead); with\n      shorter\
    \ packets that still get fragmented, this figure could\n      easily drop below\
    \ 0.4 seconds.  With a single IP packet dropped in\n      this short time frame,\
    \ packets would start to be reassembled\n      wrongly and continuously once in\
    \ such interval until an error\n      detection and recovery algorithm at an upper\
    \ layer lets the\n      application back out.\n   For each group of fragments\
    \ whose Identification numbers \"collide\",\n   the fragment reassembly will lead\
    \ to corrupted packets.  The IP\n   payload of the reassembled datagram will be\
    \ handed to the\n   corresponding upper-layer protocol, where the error will (hopefully)\n\
    \   be detected by some error detecting code (such as the TCP checksum)\n   and\
    \ the packet will be discarded.\n   An attacker could exploit this fact to intentionally\
    \ cause a system\n   to discard all or part of the fragmented traffic it gets,\
    \ thus\n   performing a DoS attack.  Such an attacker would simply establish a\n\
    \   flow of fragments with different IP Identification numbers, to trash\n   all\
    \ or part of the IP Identification space.  As a result, the\n   receiving system\
    \ would use the attacker's fragments for the\n   reassembly of legitimate datagrams,\
    \ leading to corrupted packets\n   which would later (and hopefully) get dropped.\n\
    \   In most cases, use of a long fragment timeout will benefit the\n   attacker,\
    \ as forged fragments will keep the IP Identification space\n   trashed for a\
    \ longer period of time.\n"
- title: 4.1.1.3.  Problems That Arise from the Complexity of the Reassembly
  contents:
  - "4.1.1.3.  Problems That Arise from the Complexity of the Reassembly\n       \
    \   Algorithm\n   As IP packets can be duplicated by the network, and each packet\
    \ may\n   take a different path to get to the destination host, fragments may\n\
    \   arrive not only out of order and/or duplicated but also overlapping.\n   This\
    \ means that the reassembly process can be somewhat complex, with\n   the corresponding\
    \ implementation being not specifically trivial.\n   [Shannon2001] analyzes the\
    \ causes and attributes of fragment traffic\n   measured in several types of WANs.\n\
    \   During the years, a number of attacks have exploited bugs in the\n   reassembly\
    \ function of several operating systems, producing buffer\n   overflows that have\
    \ led, in most cases, to a crash of the attacked\n   system.\n"
- title: 4.1.1.4.  Problems That Arise from the Ambiguity of the Reassembly
  contents:
  - "4.1.1.4.  Problems That Arise from the Ambiguity of the Reassembly\n        \
    \  Process\n   Network Intrusion Detection Systems (NIDSs) typically monitor the\n\
    \   traffic on a given network with the intent of identifying traffic\n   patterns\
    \ that might indicate network intrusions.\n   In the presence of IP fragments,\
    \ in order to detect illegitimate\n   activity at the transport or application\
    \ layers (i.e., any protocol\n   layer above the network layer), a NIDS must perform\
    \ IP fragment\n   reassembly.\n   In order to correctly assess the traffic, the\
    \ result of the\n   reassembly function performed by the NIDS should be the same\
    \ as that\n   of the reassembly function performed by the intended recipient of\
    \ the\n   packets.\n   However, a number of factors make the result of the reassembly\n\
    \   process ambiguous:\n   o  The IETF specifications are ambiguous as to what\
    \ should be done in\n      the event overlapping fragments were received.  Thus,\
    \ in the\n      presence of overlapping data, the system performing the reassembly\n\
    \      function is free to honor either the first set of data received,\n    \
    \  the latest copy received, or any other copy received in between.\n   o  As\
    \ the specifications do not enforce any specific fragment timeout\n      value,\
    \ different systems may choose different values for the\n      fragment timeout.\
    \  This means that given a set of fragments\n      received at some specified\
    \ time intervals, some systems will\n      reassemble the fragments into a full\
    \ datagram, while others may\n      timeout the fragments and therefore drop them.\n\
    \   o  As mentioned before, as the fragment buffers get full, a DoS\n      condition\
    \ will occur unless some action is taken.  Many systems\n      flush part of the\
    \ fragment buffers when some threshold is reached.\n      Thus, depending on fragment\
    \ load, timing issues, and flushing\n      policy, a NIDS may get incorrect assumptions\
    \ about how (and if)\n      fragments are being reassembled by their intended\
    \ recipient.\n   As originally discussed by [Ptacek1998], these issues can be\n\
    \   exploited by attackers to evade intrusion detection systems.\n   There exist\
    \ freely available tools to forcefully fragment IP\n   datagrams so as to help\
    \ evade Intrusion Detection Systems.  Frag\n   router [Song1999] is an example\
    \ of such a tool; it allows an attacker\n   to perform all the evasion techniques\
    \ described in [Ptacek1998].\n   Ftester [Barisani2006] is a tool that helps to\
    \ audit systems\n   regarding fragmentation issues.\n"
- title: 4.1.1.5.  Problems That Arise from the Size of the IP Fragments
  contents:
  - "4.1.1.5.  Problems That Arise from the Size of the IP Fragments\n   One approach\
    \ to fragment filtering involves keeping track of the\n   results of applying\
    \ filter rules to the first fragment (i.e., the\n   fragment with a Fragment Offset\
    \ of 0), and applying them to\n   subsequent fragments of the same packet.  The\
    \ filtering module would\n   maintain a list of packets indexed by the Source\
    \ Address, Destination\n   Address, Protocol, and Identification number.  When\
    \ the initial\n   fragment is seen, if the MF bit is set, a list item would be\n\
    \   allocated to hold the result of filter access checks.  When packets\n   with\
    \ a non-zero Fragment Offset come in, look up the list element\n   with a matching\
    \ Source Address/Destination Address/Protocol/\n   Identification and apply the\
    \ stored result (pass or block).  When a\n   fragment with a zero MF bit is seen,\
    \ free the list element.\n   Unfortunately, the rules of this type of packet filter\
    \ can usually be\n   bypassed.  [RFC1858] describes the details of the involved\
    \ technique.\n"
- title: 4.1.2.  Possible Security Improvements
  contents:
  - '4.1.2.  Possible Security Improvements

    '
- title: 4.1.2.1.  Memory Allocation for Fragment Reassembly
  contents:
  - "4.1.2.1.  Memory Allocation for Fragment Reassembly\n   A design choice usually\
    \ has to be made as to how to allocate memory\n   to reassemble the fragments\
    \ of a given packet.  There are basically\n   two options:\n   o  Upon receipt\
    \ of the first fragment, allocate a buffer that will be\n      large enough to\
    \ concatenate the payload of each fragment.\n   o  Upon receipt of the first fragment,\
    \ create the first node of a\n      linked list to which each of the following\
    \ fragments will be\n      linked.  When all fragments have been received, copy\
    \ the IP\n      payload of each of the fragments (in the correct order) to a\n\
    \      separate buffer that will be handed to the protocol being\n      encapsulated\
    \ in the IP payload.\n   While the first of the choices might seem to be the most\n\
    \   straightforward, it implies that even when a single small fragment of\n  \
    \ a given packet is received, the amount of memory that will be\n   allocated\
    \ for that fragment will account for the size of the complete\n   IP datagram,\
    \ thus using more system resources than what is actually\n   needed.\n   Furthermore,\
    \ the only situation in which the actual size of the whole\n   datagram will be\
    \ known is when the last fragment of the packet is\n   received first, as that\
    \ is the only packet from which the total size\n   of the IP datagram can be asserted.\
    \  Otherwise, memory should be\n   allocated for the largest possible packet size\
    \ (65535 bytes).\n   The IP module should also enforce a limit on the amount of\
    \ memory\n   that can be allocated for IP fragments, as well as a limit on the\n\
    \   number of fragments that at any time will be allowed in the system.\n   This\
    \ will basically limit the resources spent on the reassembly\n   process, and\
    \ prevent an attacker from trashing the whole system\n   memory.\n   Furthermore,\
    \ the IP module should keep a different buffer for IP\n   fragments than for complete\
    \ IP datagrams.  This will basically\n   separate the effects of fragment attacks\
    \ on non-fragmented traffic.\n   Most TCP/IP implementations, such as that in\
    \ Linux and those in BSD-\n   derived systems, already implement this.\n   [Jones2002]\
    \ analyzes the amount of memory that may be needed for the\n   fragment reassembly\
    \ buffer depending on a number of network\n   characteristics.\n"
- title: 4.1.2.2.  Flushing the Fragment Buffer
  contents:
  - "4.1.2.2.  Flushing the Fragment Buffer\n   In the case of those attacks that\
    \ aim to consume the memory buffers\n   used for fragments, and those that aim\
    \ to cause a collision of IP\n   Identification numbers, there are a number of\
    \ countermeasures that\n   can be implemented.\n   Even with these countermeasures\
    \ in place, there is still the issue of\n   what to do when the buffer pool used\
    \ for IP fragments gets full.\n   Basically, if the fragment buffer is full, no\
    \ instance of\n   communication that relies on fragmentation will be able to progress.\n\
    \   Unfortunately, there are not many options for reacting to this\n   situation.\
    \  If nothing is done, all the instances of communication\n   that rely on fragmentation\
    \ will experience a denial of service.\n   Thus, the only thing that can be done\
    \ is flush all or part of the\n   fragment buffer, on the premise that legitimate\
    \ traffic will be able\n   to make use of the freed buffer space to allow communication\
    \ flows to\n   progress.\n   There are a number of factors that should be taken\
    \ into consideration\n   when flushing the fragment buffers.  First, if a fragment\
    \ of a given\n   packet (i.e., fragment with a given Identification number) is\n\
    \   flushed, all the other fragments that correspond to the same datagram\n  \
    \ should be flushed.  As in order for a packet to be reassembled all of\n   its\
    \ fragments must be received by the system performing the\n   reassembly function,\
    \ flushing only a subset of the fragments of a\n   given packet would keep the\
    \ corresponding buffers tied to fragments\n   that would never reassemble into\
    \ a complete datagram.  Additionally,\n   care must be taken so that, in the event\
    \ that subsequent buffer\n   flushes need to be performed, it is not always the\
    \ same set of\n   fragments that get dropped, as such a behavior would probably\
    \ cause a\n   selective DoS to the traffic flows to which that set of fragments\n\
    \   belongs.\n   Many TCP/IP implementations define a threshold for the number\
    \ of\n   fragments that, when reached, triggers a fragment-buffer flush.  Some\n\
    \   systems flush 1/2 of the fragment buffer when the threshold is\n   reached.\
    \  As mentioned before, the idea of flushing the buffer is to\n   create some\
    \ free space in the fragment buffer, on the premise that\n   this will allow for\
    \ new and legitimate fragments to be processed by\n   the IP module, thus letting\
    \ communication survive the overwhelming\n   situation.  On the other hand, the\
    \ idea of flushing a somewhat large\n   portion of the buffer is to avoid flushing\
    \ always the same set of\n   packets.\n"
- title: 4.1.2.3.  A More Selective Fragment Buffer Flushing Strategy
  contents:
  - "4.1.2.3.  A More Selective Fragment Buffer Flushing Strategy\n   One of the difficulties\
    \ in implementing countermeasures for the\n   fragmentation attacks described\
    \ throughout Section 4.1 is that it is\n   difficult to perform validation checks\
    \ on the received fragments.\n   For instance, the fragment on which validity\
    \ checks could be\n   performed, the first fragment, may be not the first fragment\
    \ to\n   arrive at the destination host.\n   Fragments cannot only arrive out\
    \ of order because of packet\n   reordering performed by the network, but also\
    \ because the system (or\n   systems) that fragmented the IP datagram may indeed\
    \ transmit the\n   fragments out of order.  A notable example of this is the Linux\n\
    \   TCP/IP stack, which transmits the fragments in reverse order.\n   This means\
    \ that we cannot enforce checks on the fragments for which\n   we allocate reassembly\
    \ resources, as the first fragment we receive\n   for a given packet may be some\
    \ other fragment than the first one (the\n   one with an Fragment Offset of 0).\n\
    \   However, at the point in which we decide to free some space in the\n   fragment\
    \ buffer, some refinements can be done to the flushing policy.\n   The first thing\
    \ we would like to do is to stop different types of\n   traffic from interfering\
    \ with each other.  This means, in principle,\n   that we do not want fragmented\
    \ UDP traffic to interfere with\n   fragmented TCP traffic.  In order to implement\
    \ this traffic\n   separation for the different protocols, a different fragment\
    \ buffer\n   pool would be needed, in principle, for each of the 256 different\n\
    \   protocols that can be encapsulated in an IP datagram.\n   We believe a trade-off\
    \ is to implement two separate fragment buffers:\n   one for IP datagrams that\
    \ encapsulate IPsec packets and another for\n   the rest of the traffic.  This\
    \ basically means that traffic not\n   protected by IPsec will not interfere with\
    \ those flows of\n   communication that are being protected by IPsec.\n   The\
    \ processing of each of these two different fragment buffer pools\n   would be\
    \ completely independent from each other.  In the case of the\n   IPsec fragment\
    \ buffer pool, when the buffers needs to be flushed, the\n   following refined\
    \ policy could be applied:\n   o  First, for each packet for which the IPsec header\
    \ has been\n      received, check that the Security Parameters Index (SPI) field\
    \ of\n      the IPsec header corresponds to an existing IPsec Security\n     \
    \ Association (SA), and probably also check that the IPsec sequence\n      number\
    \ is valid.  If the check fails, drop all the fragments that\n      correspond\
    \ to this packet.\n   o  Second, if still more fragment buffers need to be flushed,\
    \ drop\n      all the fragments that correspond to packets for which the full\n\
    \      IPsec header has not yet been received.  The number of packets for\n  \
    \    which this flushing is performed depends on the amount of free\n      space\
    \ that needs to be created.\n   o  Third, if after flushing packets with invalid\
    \ IPsec information\n      (First step), and packets on which validation checks\
    \ could not be\n      performed (Second step), there is still not enough space\
    \ in the\n      fragment buffer, drop all the fragments that correspond to packets\n\
    \      that passed the checks of the first step, until the necessary free\n  \
    \    space is created.\n   The rationale behind this policy is that, at the point\
    \ of flushing\n   fragment buffers, we prefer to keep those packets on which we\
    \ could\n   successfully perform a number of validation checks, over those\n \
    \  packets on which those checks failed, or the checks could not even be\n   performed.\n\
    \   By checking both the IPsec SPI and the IPsec sequence number, it is\n   virtually\
    \ impossible for an attacker that is off-path to perform a\n   DoS attack to communication\
    \ flows being protected by IPsec.\n   Unfortunately, some IP implementations (such\
    \ as that in Linux\n   [Linux]), when performing fragmentation, send the corresponding\n\
    \   fragments in reverse order.  In such cases, at the point of flushing\n   the\
    \ fragment buffer, legitimate fragments will receive the same\n   treatment as\
    \ the possible forged fragments.\n   This refined flushing policy provides an\
    \ increased level of\n   protection against this type of resource exhaustion attack,\
    \ while not\n   making the situation of out-of-order IPsec-secured traffic worse\
    \ than\n   with the simplified flushing policy described in the previous\n   section.\n"
- title: 4.1.2.4.  Reducing the Fragment Timeout
  contents:
  - "4.1.2.4.  Reducing the Fragment Timeout\n   RFC 1122 [RFC1122] states that the\
    \ reassembly timeout should be a\n   fixed value between 60 and 120 seconds. \
    \ The rationale behind these\n   long timeout values is that they should accommodate\
    \ any path\n   characteristics, such as long-delay paths.  However, it must be\
    \ noted\n   that this timer is really measuring inter-fragment delays, or, more\n\
    \   specifically, fragment jitter.\n   If all fragments take paths of similar\
    \ characteristics, the inter-\n   fragment delay will usually be, at most, a few\
    \ seconds.\n   Nevertheless, even if fragments take different paths of different\n\
    \   characteristics, the recommended 60 to 120 seconds are, in practice,\n   excessive.\n\
    \   Some systems have already reduced the fragment timeout to 30 seconds\n   [Linux].\
    \  The fragment timeout could probably be further reduced to\n   approximately\
    \ 15 seconds; although further research on this issue is\n   necessary.\n   It\
    \ should be noted that in network scenarios of long-delay and high-\n   bandwidth\
    \ (usually referred to as \"Long-Fat Networks\"), using a long\n   fragment timeout\
    \ would likely increase the probability of collision\n   of IP ID numbers.  Therefore,\
    \ in such scenarios it is highly\n   desirable to avoid the use of fragmentation\
    \ with techniques such as\n   PMTUD [RFC1191] or PLPMTUD [RFC4821].\n"
- title: 4.1.2.5.  Countermeasure for Some NIDS Evasion Techniques
  contents:
  - "4.1.2.5.  Countermeasure for Some NIDS Evasion Techniques\n   [Shankar2003] introduces\
    \ a technique named \"Active Mapping\" that\n   prevents evasion of a NIDS by\
    \ acquiring sufficient knowledge about\n   the network being monitored, to assess\
    \ which packets will arrive at\n   the intended recipient, and how they will be\
    \ interpreted by it.\n   [Novak2005] describes some techniques that are applied\
    \ by the Snort\n   [Snort] NIDS to avoid evasion.\n"
- title: 4.1.2.6.  Countermeasure for Firewall-Rules Bypassing
  contents:
  - "4.1.2.6.  Countermeasure for Firewall-Rules Bypassing\n   One of the classical\
    \ techniques to bypass firewall rules involves\n   sending packets in which the\
    \ header of the encapsulated protocol is\n   fragmented.  Even when it would be\
    \ legal (as far as the IETF\n   specifications are concerned) to receive such\
    \ a packets, the MTUs of\n   the network technologies used in practice are not\
    \ that small to\n   require the header of the encapsulated protocol to be fragmented\n\
    \   (e.g., see [RFC2544]).  Therefore, the system performing reassembly\n   should\
    \ drop all packets which fragment the upper-layer protocol\n   header, and this\
    \ event should be logged (e.g., a counter could be\n   incremented to reflect\
    \ the packet drop).\n   Additionally, given that many middle-boxes such as firewalls\
    \ create\n   state according to the contents of the first fragment of a given\n\
    \   packet, it is best that, in the event an end-system receives\n   overlapping\
    \ fragments, it honors the information contained in the\n   fragment that was\
    \ received first.\n   RFC 1858 [RFC1858] describes the abuse of IP fragmentation\
    \ to bypass\n   firewall rules.  RFC 3128 [RFC3128] corrects some errors in RFC\
    \ 1858.\n"
- title: 4.2.  Forwarding
  contents:
  - '4.2.  Forwarding

    '
- title: 4.2.1.  Precedence-Ordered Queue Service
  contents:
  - "4.2.1.  Precedence-Ordered Queue Service\n   Section 5.3.3.1 of RFC 1812 [RFC1812]\
    \ states that routers should\n   implement precedence-ordered queue service. \
    \ This means that when a\n   packet is selected for output on a (logical) link,\
    \ the packet of\n   highest precedence that has been queued for that link is sent.\n\
    \   Section 5.3.3.2 of RFC 1812 advises routers to default to maintaining\n  \
    \ strict precedence-ordered service.\n   Unfortunately, given that it is trivial\
    \ to forge the IP precedence\n   field of the IP header, an attacker could simply\
    \ forge a high\n   precedence number in the packets it sends to illegitimately\
    \ get\n   better network service.  If precedence-ordered queued service is not\n\
    \   required in a particular network infrastructure, it should be\n   disabled,\
    \ and thus all packets would receive the same type of\n   service, despite the\
    \ values in their Type of Service or\n   Differentiated Services fields.\n   When\
    \ precedence-ordered queue service is required in the network\n   infrastructure,\
    \ in order to mitigate the attack vector discussed in\n   the previous paragraph,\
    \ edge routers or switches should be configured\n   to police and remark the Type\
    \ of Service or Differentiated Services\n   values, according to the type of service\
    \ at which each end-system has\n   been allowed to send packets.\n   Bullet 4\
    \ of Section 5.3.3.3 of RFC 1812 states that routers \"MUST NOT\n   change precedence\
    \ settings on packets it did not originate\".\n   However, given the security\
    \ implications of the Precedence field, it\n   is fair for routers, switches,\
    \ or other middle-boxes, particularly\n   those in the network edge, to overwrite\
    \ the Type of Service (or\n   Differentiated Services) field of the packets they\
    \ are forwarding,\n   according to a configured network policy (this is the specified\n\
    \   behavior for DS domains [RFC2475]).\n   Sections 5.3.3.1 and 5.3.6 of RFC\
    \ 1812 state that if precedence-\n   ordered queue service is implemented and\
    \ enabled, the router \"MUST\n   NOT discard a packet whose precedence is higher\
    \ than that of a packet\n   that is not discarded\".  While this recommendation\
    \ makes sense given\n   the semantics of the Precedence field, it is important\
    \ to note that\n   it would be simple for an attacker to send packets with forged\
    \ high\n   Precedence value to congest some internet router(s), and cause all\n\
    \   (or most) traffic with a lower Precedence value to be discarded.\n"
- title: 4.2.2.  Weak Type of Service
  contents:
  - "4.2.2.  Weak Type of Service\n   Section 5.2.4.3 of RFC 1812 describes the algorithm\
    \ for determining\n   the next-hop address (i.e., the forwarding algorithm). \
    \ Bullet 3,\n   \"Weak TOS\", addresses the case in which routes contain a \"\
    type of\n   service\" attribute.  It states that in case a packet contains a non-\n\
    \   default TOS (i.e., 0000), only routes with the same TOS or with the\n   default\
    \ TOS should be considered for forwarding that packet.\n   However, this means\
    \ that if among the longest match routes for a\n   given packet are routes with\
    \ some TOS other than the one contained in\n   the received packet, and no routes\
    \ with the default TOS, the\n   corresponding packet would be dropped.  This may\
    \ or may not be a\n   desired behavior.\n   An alternative for the case in which\
    \ among the \"longest match\" routes\n   there are only routes with non-default\
    \ type of service that do not\n   match the TOS contained in the received packet,\
    \ would be to use a\n   route with any other TOS.  While this route would most\
    \ likely not be\n   able to address the type of service requested by packet, it\
    \ would, at\n   least, provide a \"best effort\" service.\n   It must be noted\
    \ that Section 5.3.2 of RFC 1812 allows routers to not\n   honor the TOS field.\
    \  Therefore, the proposed alternative behavior is\n   still compliant with the\
    \ IETF specifications.\n      While officially specified in the RFC series, TOS-based\
    \ routing is\n      not widely deployed in the Internet.\n"
- title: 4.2.3.  Impact of Address Resolution on Buffer Management
  contents:
  - "4.2.3.  Impact of Address Resolution on Buffer Management\n   In the case of\
    \ broadcast link-layer technologies, in order for a\n   system to transfer an\
    \ IP datagram it must usually first map an IP\n   address to the corresponding\
    \ link-layer address (for example, by\n   means of the Address Resolution Protocol\
    \ (ARP) [RFC0826]) .  This\n   means that while this operation is being performed,\
    \ the packets that\n   would require such a mapping would need to be kept in memory.\
    \  This\n   may happen both in the case of hosts and in the case of routers.\n\
    \   This situation might be exploited by an attacker, which could send a\n   large\
    \ amount of packets to a non-existent host that would supposedly\n   be directly\
    \ connected to the attacked router.  While trying to map\n   the corresponding\
    \ IP address into a link-layer address, the attacked\n   router would keep in\
    \ memory all the packets that would need to make\n   use of that link-layer address.\
    \  At the point in which the mapping\n   function times out, depending on the\
    \ policy implemented by the\n   attacked router, only the packet that triggered\
    \ the call to the\n   mapping function might be dropped.  In that case, the same\
    \ operation\n   would be repeated for every packet destined to the non-existent\
    \ host.\n   Depending on the timeout value for the mapping function, this\n  \
    \ situation might lead the router to run out of free buffer space, with\n   the\
    \ consequence that incoming legitimate packets would have to be\n   dropped, or\
    \ that legitimate packets already stored in the router's\n   buffers might get\
    \ dropped.  Both of these situations would lead\n   either to a complete DoS or\
    \ to a degradation of the network service.\n   One countermeasure to this problem\
    \ would be to drop, at the point the\n   mapping function times out, all the packets\
    \ destined to the address\n   that timed out.  In addition, a \"negative cache\
    \ entry\" might be kept\n   in the module performing the matching function, so\
    \ that for some\n   amount of time, the mapping function would return an error\
    \ when the\n   IP module requests to perform a mapping for some address for which\n\
    \   the mapping has recently timed out.\n      A common implementation strategy\
    \ for routers is that when a packet\n      is received that requires an ARP resolution\
    \ to be performed before\n      the packet can be forwarded, the packet is dropped\
    \ and the router\n      is then engaged in the ARP procedure.\n"
- title: 4.2.4.  Dropping Packets
  contents:
  - "4.2.4.  Dropping Packets\n   In some scenarios, it may be necessary for a host\
    \ or router to drop\n   packets from the output queue.  In the event that one\
    \ of such packets\n   happens to be an IP fragment, and there were other fragments\
    \ of the\n   same packet in the queue, those other fragments should also be\n\
    \   dropped.  The rationale for this policy is that it is nonsensical to\n   spend\
    \ system resources on those other fragments, because, as long as\n   one fragment\
    \ is missing, it will be impossible for the receiving\n   system to reassemble\
    \ them into a complete IP datagram.\n   Some systems have been known to drop just\
    \ a subset of fragments of a\n   given datagram, leading to a denial-of-service\
    \ condition, as only a\n   subset of all the fragments of the packets were actually\
    \ transferred\n   to the next hop.\n"
- title: 4.3.  Addressing
  contents:
  - '4.3.  Addressing

    '
- title: 4.3.1.  Unreachable Addresses
  contents:
  - "4.3.1.  Unreachable Addresses\n   It is important to understand that while there\
    \ are some addresses\n   that are supposed to be unreachable from the public Internet\
    \ (such as\n   the private IP addresses described in RFC 1918 [RFC1918], or the\n\
    \   \"loopback\" address), there are a number of tricks an attacker can\n   perform\
    \ to reach those IP addresses that would otherwise be\n   unreachable (e.g., exploit\
    \ the LSRR or SSRR IP options).  Therefore,\n   when applicable, packet filtering\
    \ should be performed at the private\n   network boundary to assure that those\
    \ addresses will be unreachable.\n   Similarly, link-local unicast addresses [RFC3927]\
    \ and multicast\n   addresses with limited scope (link- and site-local addresses)\
    \ should\n   not be accessible from outside the proper network boundaries and\
    \ not\n   be passed across these boundaries.\n   [RFC5735] provides a summary\
    \ of special use IPv4 addresses.\n"
- title: 4.3.2.  Private Address Space
  contents:
  - "4.3.2.  Private Address Space\n   The Internet Assigned Numbers Authority (IANA)\
    \ has reserved the\n   following three blocks of the IP address space for private\
    \ internets:\n   o  10.0.0.0 - 10.255.255.255 (10/8 prefix)\n   o  172.16.0.0\
    \ - 172.31.255.255 (172.16/12 prefix)\n   o  192.168.0.0 - 192.168.255.255 (192.168/16\
    \ prefix)\n   Use of these address blocks is described in RFC 1918 [RFC1918].\n\
    \   Where applicable, packet filtering should be performed at the\n   organizational\
    \ perimeter to assure that these addresses are not\n   reachable from outside\
    \ the private network where such addresses are\n   employed.\n"
- title: 4.3.3.  Former Class D Addresses (224/4 Address Block)
  contents:
  - "4.3.3.  Former Class D Addresses (224/4 Address Block)\n   The former Class D\
    \ addresses correspond to the 224/4 address block\n   and are used for Internet\
    \ multicast.  Therefore, if a packet is\n   received with a \"Class D\" address\
    \ as the Source Address, it should be\n   dropped, and this event should be logged\
    \ (e.g., a counter could be\n   incremented to reflect the packet drop).  Additionally,\
    \ if an IP\n   packet with a multicast Destination Address is received for a\n\
    \   connection-oriented protocol (e.g., TCP), the packet should be\n   dropped\
    \ (see Section 4.3.5), and this event should be logged (e.g., a\n   counter could\
    \ be incremented to reflect the packet drop).\n"
- title: 4.3.4.  Former Class E Addresses (240/4 Address Block)
  contents:
  - "4.3.4.  Former Class E Addresses (240/4 Address Block)\n   The former Class E\
    \ addresses correspond to the 240/4 address block,\n   and are currently reserved\
    \ for experimental use.  As a result, a most\n   routers discard packets that\
    \ contain a \"Class\" E address as the\n   Source Address or Destination Address.\
    \  If a packet is received with\n   a 240/4 address as the Source Address and/or\
    \ the Destination Address,\n   the packet should be dropped and this event should\
    \ be logged (e.g., a\n   counter could be incremented to reflect the packet drop).\n\
    \   It should be noted that the broadcast address 255.255.255.255 still\n   must\
    \ be treated as indicated in Section 4.3.7 of this document.\n"
- title: 4.3.5.  Broadcast/Multicast Addresses and Connection-Oriented Protocols
  contents:
  - "4.3.5.  Broadcast/Multicast Addresses and Connection-Oriented Protocols\n   For\
    \ connection-oriented protocols, such as TCP, shared state is\n   maintained between\
    \ only two endpoints at a time.  Therefore, if an IP\n   packet with a multicast\
    \ (or broadcast) Destination Address is\n   received for a connection-oriented\
    \ protocol (e.g., TCP), the packet\n   should be dropped, and this event should\
    \ be logged (e.g., a counter\n   could be incremented to reflect the packet drop).\n"
- title: 4.3.6.  Broadcast and Network Addresses
  contents:
  - "4.3.6.  Broadcast and Network Addresses\n   Originally, the IETF specifications\
    \ did not permit IP addresses to\n   have the value 0 or -1 (shorthand for all\
    \ bits set to 1) for any of\n   the Host number, network number, or subnet number\
    \ fields, except for\n   the cases indicated in Section 4.3.7.  However, this\
    \ changed\n   fundamentally with the deployment of Classless Inter-Domain Routing\n\
    \   (CIDR) [RFC4632], as with CIDR a system cannot know a priori what the\n  \
    \ subnet mask is for a particular IP address.\n   Many systems now allow administrators\
    \ to use the values 0 or -1 for\n   those fields.  Despite that according to the\
    \ original IETF\n   specifications these addresses are illegal, modern IP implementations\n\
    \   should consider these addresses to be valid.\n"
- title: 4.3.7.  Special Internet Addresses
  contents:
  - "4.3.7.  Special Internet Addresses\n   RFC 1812 [RFC1812] discusses the use of\
    \ some special Internet\n   addresses, which is of interest to perform some sanity\
    \ checks on the\n   Source Address and Destination Address fields of an IP packet.\
    \  It\n   uses the following notation for an IP address:\n   { <Network-prefix>,\
    \ <Host-number> }\n   where the length of the network prefix is generally implied\
    \ by the\n   network mask assigned to the IP interface under consideration.\n\
    \      RFC 1122 [RFC1122] contained a similar discussion of special\n      Internet\
    \ addresses, including some of the form { <Network-prefix>,\n      <Subnet-number>,\
    \ <Host-number> }.  However, as explained in\n      Section 4.2.2.11 of RFC 1812,\
    \ in a CIDR world, the subnet number\n      is clearly an extension of the network\
    \ prefix and cannot be\n      distinguished from the remainder of the prefix.\n\
    \   {0, 0}\n   This address means \"this host on this network\".  It is meant\
    \ to be\n   used only during the initialization procedure, by which the host\n\
    \   learns its own IP address.\n   If a packet is received with 0.0.0.0 as the\
    \ Source Address for any\n   purpose other than bootstrapping, the corresponding\
    \ packet should be\n   silently dropped, and this event should be logged (e.g.,\
    \ a counter\n   could be incremented to reflect the packet drop).  If a packet\
    \ is\n   received with 0.0.0.0 as the Destination Address, it should be\n   silently\
    \ dropped, and this event should be logged (e.g., a counter\n   could be incremented\
    \ to reflect the packet drop).\n   {0, Host number}\n   This address means \"\
    the specified host, in this network\".  As in the\n   previous case, it is meant\
    \ to be used only during the initialization\n   procedure by which the host learns\
    \ its own IP address.  If a packet\n   is received with such an address as the\
    \ Source Address for any\n   purpose other than bootstrapping, it should be dropped,\
    \ and this\n   event should be logged (e.g., a counter could be incremented to\n\
    \   reflect the packet drop).  If a packet is received with such an\n   address\
    \ as the Destination Address, it should be dropped, and this\n   event should\
    \ be logged (e.g., a counter could be incremented to\n   reflect the packet drop).\n\
    \   {-1, -1}\n   This address is the local broadcast address.  It should not be\
    \ used\n   as a source IP address.  If a packet is received with 255.255.255.255\n\
    \   as the Source Address, it should be dropped, and this event should be\n  \
    \ logged (e.g., a counter could be incremented to reflect the packet\n   drop).\n\
    \      Some systems, when receiving an ICMP echo request, for example,\n     \
    \ will use the Destination Address in the ICMP echo request packet\n      as the\
    \ Source Address of the response they send (in this case, an\n      ICMP echo\
    \ reply).  Thus, when such systems receive a request sent\n      to a broadcast\
    \ address, the Source Address of the response will\n      contain a broadcast\
    \ address.  This should be considered a bug,\n      rather than a malicious use\
    \ of the limited broadcast address.\n   {Network number, -1}\n   This is the directed\
    \ broadcast to the specified network.  As\n   recommended by RFC 2644 [RFC2644],\
    \ routers should not forward\n   network-directed broadcasts.  This avoids the\
    \ corresponding network\n   from being utilized as, for example, a \"smurf amplifier\"\
    \ [CERT1998a].\n   As noted in Section 4.3.6 of this document, many systems now\
    \ allow\n   administrators to configure these addresses as unicast addresses for\n\
    \   network interfaces.  In such scenarios, routers should forward these\n   addresses\
    \ as if they were traditional unicast addresses.\n   In some scenarios, a host\
    \ may have knowledge about a particular IP\n   address being a network-directed\
    \ broadcast address, rather than a\n   unicast address (e.g., that IP address\
    \ is configured on the local\n   system as a \"broadcast address\").  In such\
    \ scenarios, if a system can\n   infer that the Source Address of a received packet\
    \ is a network-\n   directed broadcast address, the packet should be dropped,\
    \ and this\n   event should be logged (e.g., a counter could be incremented to\n\
    \   reflect the packet drop).\n   As noted in Section 4.3.6 of this document,\
    \ with the deployment of\n   CIDR [RFC4632], it may be difficult for a system\
    \ to infer whether a\n   particular IP address that does not belong to a directly\
    \ attached\n   subnet is a broadcast address.\n   {127.0.0.0/8, any}\n   This\
    \ is the internal host loopback address.  Any packet that arrives\n   on any physical\
    \ interface containing this address as the Source\n   Address, the Destination\
    \ Address, or as part of a source route\n   (either LSRR or SSRR), should be dropped.\n\
    \   For example, packets with a Destination Address in the 127.0.0.0/8\n   address\
    \ block that are received on an interface other than loopback\n   should be silently\
    \ dropped.  Packets received on any interface other\n   than loopback with a Source\
    \ Address corresponding to the system\n   receiving the packet should also be\
    \ dropped.\n   In all the above cases, when a packet is dropped, this event should\n\
    \   be logged (e.g., a counter could be incremented to reflect the packet\n  \
    \ drop).\n"
- title: 5.  Security Considerations
  contents:
  - "5.  Security Considerations\n   This document discusses the security implications\
    \ of the Internet\n   Protocol (IP) and a number of implementation strategies\
    \ that help to\n   mitigate a number of vulnerabilities found in the protocol\
    \ during the\n   last 25 years or so.\n"
- title: 6.  Acknowledgements
  contents:
  - "6.  Acknowledgements\n   The author wishes to thank Alfred Hoenes for providing\
    \ very thorough\n   reviews of earlier versions of this document, thus leading\
    \ to\n   numerous improvements.\n   The author would like to thank Jari Arkko,\
    \ Ron Bonica, Stewart\n   Bryant, Adrian Farrel, Joel Jaeggli, Warren Kumari,\
    \ Bruno Rohee, and\n   Andrew Yourtchenko for providing valuable comments on earlier\n\
    \   versions of this document.\n   This document was written by Fernando Gont\
    \ on behalf of the UK CPNI\n   (United Kingdom's Centre for the Protection of\
    \ National\n   Infrastructure), and is heavily based on the \"Security Assessment\
    \ of\n   the Internet Protocol\" [CPNI2008] published by the UK CPNI in 2008.\n\
    \   The author would like to thank Randall Atkinson, John Day, Juan\n   Fraschini,\
    \ Roque Gagliano, Guillermo Gont, Martin Marino, Pekka\n   Savola, and Christos\
    \ Zoulas for providing valuable comments on\n   earlier versions of [CPNI2008],\
    \ on which this document is based.\n   The author would like to thank Randall\
    \ Atkinson and Roque Gagliano,\n   who generously answered a number of questions.\n\
    \   Finally, the author would like to thank UK CPNI (formerly NISCC) for\n   their\
    \ continued support.\n"
- title: 7.  References
  contents:
  - '7.  References

    '
- title: 7.1.  Normative References
  contents:
  - "7.1.  Normative References\n   [RFC0791]  Postel, J., \"Internet Protocol\",\
    \ STD 5, RFC 791,\n              September 1981.\n   [RFC0826]  Plummer, D., \"\
    Ethernet Address Resolution Protocol: Or\n              converting network protocol\
    \ addresses to 48.bit Ethernet\n              address for transmission on Ethernet\
    \ hardware\", STD 37,\n              RFC 826, November 1982.\n   [RFC1038]  St.\
    \ Johns, M., \"Draft revised IP security option\",\n              RFC 1038, January\
    \ 1988.\n   [RFC1063]  Mogul, J., Kent, C., Partridge, C., and K. McCloghrie,\
    \ \"IP\n              MTU discovery options\", RFC 1063, July 1988.\n   [RFC1108]\
    \  Kent, S., \"U.S\", RFC 1108, November 1991.\n   [RFC1112]  Deering, S., \"\
    Host extensions for IP multicasting\", STD 5,\n              RFC 1112, August\
    \ 1989.\n   [RFC1122]  Braden, R., \"Requirements for Internet Hosts -\n     \
    \         Communication Layers\", STD 3, RFC 1122, October 1989.\n   [RFC1191]\
    \  Mogul, J. and S. Deering, \"Path MTU discovery\", RFC 1191,\n             \
    \ November 1990.\n   [RFC1349]  Almquist, P., \"Type of Service in the Internet\
    \ Protocol\n              Suite\", RFC 1349, July 1992.\n   [RFC1393]  Malkin,\
    \ G., \"Traceroute Using an IP Option\", RFC 1393,\n              January 1993.\n\
    \   [RFC1770]  Graff, C., \"IPv4 Option for Sender Directed Multi-\n         \
    \     Destination Delivery\", RFC 1770, March 1995.\n   [RFC1812]  Baker, F.,\
    \ \"Requirements for IP Version 4 Routers\",\n              RFC 1812, June 1995.\n\
    \   [RFC1918]  Rekhter, Y., Moskowitz, R., Karrenberg, D., Groot, G., and\n  \
    \            E. Lear, \"Address Allocation for Private Internets\",\n        \
    \      BCP 5, RFC 1918, February 1996.\n   [RFC2113]  Katz, D., \"IP Router Alert\
    \ Option\", RFC 2113,\n              February 1997.\n   [RFC2119]  Bradner, S.,\
    \ \"Key words for use in RFCs to Indicate\n              Requirement Levels\"\
    , BCP 14, RFC 2119, March 1997.\n   [RFC2474]  Nichols, K., Blake, S., Baker,\
    \ F., and D. Black,\n              \"Definition of the Differentiated Services\
    \ Field (DS\n              Field) in the IPv4 and IPv6 Headers\", RFC 2474,\n\
    \              December 1998.\n   [RFC2475]  Blake, S., Black, D., Carlson, M.,\
    \ Davies, E., Wang, Z.,\n              and W. Weiss, \"An Architecture for Differentiated\n\
    \              Services\", RFC 2475, December 1998.\n   [RFC2644]  Senie, D.,\
    \ \"Changing the Default for Directed Broadcasts\n              in Routers\",\
    \ BCP 34, RFC 2644, August 1999.\n   [RFC2827]  Ferguson, P. and D. Senie, \"\
    Network Ingress Filtering:\n              Defeating Denial of Service Attacks\
    \ which employ IP Source\n              Address Spoofing\", BCP 38, RFC 2827,\
    \ May 2000.\n   [RFC3168]  Ramakrishnan, K., Floyd, S., and D. Black, \"The Addition\n\
    \              of Explicit Congestion Notification (ECN) to IP\",\n          \
    \    RFC 3168, September 2001.\n   [RFC3704]  Baker, F. and P. Savola, \"Ingress\
    \ Filtering for Multihomed\n              Networks\", BCP 84, RFC 3704, March\
    \ 2004.\n   [RFC3927]  Cheshire, S., Aboba, B., and E. Guttman, \"Dynamic\n  \
    \            Configuration of IPv4 Link-Local Addresses\", RFC 3927,\n       \
    \       May 2005.\n   [RFC4086]  Eastlake, D., Schiller, J., and S. Crocker, \"\
    Randomness\n              Requirements for Security\", BCP 106, RFC 4086, June\
    \ 2005.\n   [RFC4632]  Fuller, V. and T. Li, \"Classless Inter-domain Routing\n\
    \              (CIDR): The Internet Address Assignment and Aggregation\n     \
    \         Plan\", BCP 122, RFC 4632, August 2006.\n   [RFC4821]  Mathis, M. and\
    \ J. Heffner, \"Packetization Layer Path MTU\n              Discovery\", RFC 4821,\
    \ March 2007.\n   [RFC5082]  Gill, V., Heasley, J., Meyer, D., Savola, P., and\
    \ C.\n              Pignataro, \"The Generalized TTL Security Mechanism\n    \
    \          (GTSM)\", RFC 5082, October 2007.\n   [RFC5350]  Manner, J. and A.\
    \ McDonald, \"IANA Considerations for the\n              IPv4 and IPv6 Router\
    \ Alert Options\", RFC 5350,\n              September 2008.\n   [RFC5735]  Cotton,\
    \ M. and L. Vegoda, \"Special Use IPv4 Addresses\",\n              BCP 153, RFC\
    \ 5735, January 2010.\n   [RFC6040]  Briscoe, B., \"Tunnelling of Explicit Congestion\n\
    \              Notification\", RFC 6040, November 2010.\n"
- title: 7.2.  Informative References
  contents:
  - "7.2.  Informative References\n   [Anderson2001]\n              Anderson, J.,\
    \ \"An Analysis of Fragmentation Attacks\",\n              2001, <http://www.ouah.org/fragma.html>.\n\
    \   [Arkin2000]\n              Arkin, \"IP TTL Field Value with ICMP (Oops - Identifying\n\
    \              Windows 2000 again and more)\", 2000,\n              <http://ofirarkin.files.wordpress.com/2008/11/\n\
    \              ofirarkin2000-06.pdf>.\n   [Barisani2006]\n              Barisani,\
    \ A., \"FTester - Firewall and IDS testing tool\",\n              2001, <http://dev.inversepath.com/trac/ftester>.\n\
    \   [Bellovin1989]\n              Bellovin, S., \"Security Problems in the TCP/IP\
    \ Protocol\n              Suite\", Computer Communication Review Vol. 19, No.\
    \ 2, pp.\n              32-48, 1989.\n   [Bellovin2002]\n              Bellovin,\
    \ S., \"A Technique for Counting NATted Hosts\",\n              IMW'02 Nov. 6-8,\
    \ 2002, Marseille, France, 2002.\n   [Bendi1998]\n              Bendi, \"Bonk\
    \ exploit\", 1998,\n              <http://www.insecure.org/sploits/\n        \
    \      95.NT.fragmentation.bonk.html>.\n   [Biondi2007]\n              Biondi,\
    \ P. and A. Ebalard, \"IPv6 Routing Header Security\",\n              CanSecWest\
    \ 2007 Security Conference, 2007,\n              <http://www.secdev.org/conf/IPv6_RH_security-csw07.pdf>.\n\
    \   [CERT1996a]\n              CERT, \"CERT Advisory CA-1996-01: UDP Port Denial-of-\n\
    \              Service Attack\", 1996,\n              <http://www.cert.org/advisories/CA-1996-01.html>.\n\
    \   [CERT1996b]\n              CERT, \"CERT Advisory CA-1996-21: TCP SYN Flooding\
    \ and IP\n              Spoofing Attacks\", 1996,\n              <http://www.cert.org/advisories/CA-1996-21.html>.\n\
    \   [CERT1996c]\n              CERT, \"CERT Advisory CA-1996-26: Denial-of-Service\
    \ Attack\n              via ping\", 1996,\n              <http://www.cert.org/advisories/CA-1996-26.html>.\n\
    \   [CERT1997] CERT, \"CERT Advisory CA-1997-28: IP Denial-of-Service\n      \
    \        Attacks\", 1997,\n              <http://www.cert.org/advisories/CA-1997-28.html>.\n\
    \   [CERT1998a]\n              CERT, \"CERT Advisory CA-1998-01: Smurf IP Denial-of-\n\
    \              Service Attacks\", 1998,\n              <http://www.cert.org/advisories/CA-1998-01.html>.\n\
    \   [CERT1998b]\n              CERT, \"CERT Advisory CA-1998-13: Vulnerability\
    \ in Certain\n              TCP/IP Implementations\", 1998,\n              <http://www.cert.org/advisories/CA-1998-13.html>.\n\
    \   [CERT1999] CERT, \"CERT Advisory CA-1999-17: Denial-of-Service Tools\",\n\
    \              1999, <http://www.cert.org/advisories/CA-1999-17.html>.\n   [CERT2003]\
    \ CERT, \"CERT Advisory CA-2003-15: Cisco IOS Interface\n              Blocked\
    \ by IPv4 Packet\", 2003,\n              <http://www.cert.org/advisories/CA-2003-15.html>.\n\
    \   [CIPSO1992]\n              CIPSO, \"COMMERCIAL IP SECURITY OPTION (CIPSO 2.2)\"\
    , Work\n              in Progress, 1992.\n   [CIPSOWG1994]\n              CIPSOWG,\
    \ \"Commercial Internet Protocol Security Option\n              (CIPSO) Working\
    \ Group\", 1994, <http://www.ietf.org/\n              proceedings/94jul/charters/cipso-charter.html>.\n\
    \   [CPNI2008] Gont, F., \"Security Assessment of the Internet Protocol\",\n \
    \             2008, <http://www.cpni.gov.uk/Docs/InternetProtocol.pdf>.\n   [Cerf1974]\
    \ Cerf, V. and R. Kahn, \"A Protocol for Packet Network\n              Intercommunication\"\
    , IEEE Transactions on\n              Communications Vol. 22, No. 5, May 1974,\
    \ pp. 637-648,\n              1974.\n   [Cisco2003]\n              Cisco, \"Cisco\
    \ Security Advisory: Cisco IOS Interface\n              Blocked by IPv4 packet\"\
    , 2003, <http://www.cisco.com/en/\n              US/products/\n              products_security_advisory09186a00801a34c2.shtml>.\n\
    \   [Cisco2008]\n              Cisco, \"Cisco IOS Security Configuration Guide,\
    \ Release\n              12.2\", 2003, <http://www.cisco.com/en/US/docs/ios/12_2/\n\
    \              security/configuration/guide/scfipso.html>.\n   [Clark1988]\n \
    \             Clark, D., \"The Design Philosophy of the DARPA Internet\n     \
    \         Protocols\", Computer Communication Review Vol. 18, No. 4,\n       \
    \       1988.\n   [Ed3f2002] Ed3f, \"Firewall spotting and networks analysis with\
    \ a\n              broken CRC\", Phrack Magazine, Volume 0x0b, Issue\n       \
    \       0x3c, Phile #0x0c of 0x10, 2002, <http://www.phrack.org/\n           \
    \   issues.html?issue=60&id=12&mode=txt>.\n   [FIPS1994] FIPS, \"Standard Security\
    \ Label for Information Transfer\",\n              Federal Information Processing\
    \ Standards Publication. FIP\n              PUBS 188, 1994, <http://csrc.nist.gov/publications/fips/\n\
    \              fips188/fips188.pdf>.\n   [Fyodor2004]\n              Fyodor, \"\
    Idle scanning and related IP ID games\", 2004,\n              <http://www.insecure.org/nmap/idlescan.html>.\n\
    \   [GIAC2000] GIAC, \"Egress Filtering v 0.2\", 2000,\n              <http://www.sans.org/y2k/egress.htm>.\n\
    \   [Gont2006] Gont, F., \"Advanced ICMP packet filtering\", 2006,\n         \
    \     <http://www.gont.com.ar/papers/icmp-filtering.html>.\n   [Haddad2004]\n\
    \              Haddad, I. and M. Zakrzewski, \"Security Distribution for\n   \
    \           Linux Clusters\", Linux Journal, 2004,\n              <http://www.linuxjournal.com/article/6943>.\n\
    \   [Humble1998]\n              Humble, \"Nestea exploit\", 1998,\n          \
    \    <http://www.insecure.org/sploits/\n              linux.PalmOS.nestea.html>.\n\
    \   [IANA_ET]  IANA, \"Ether Types\",\n              <http://www.iana.org/assignments/ethernet-numbers>.\n\
    \   [IANA_IP_PARAM]\n              IANA, \"IP Parameters\",\n              <http://www.iana.org/assignments/ip-parameters>.\n\
    \   [IANA_PROT_NUM]\n              IANA, \"Protocol Numbers\",\n             \
    \ <http://www.iana.org/assignments/protocol-numbers>.\n   [IRIX2008] IRIX, \"\
    IRIX 6.5 trusted_networking(7) manual page\", 2008,\n              <http://techpubs.sgi.com/library/tpl/cgi-bin/\n\
    \              getdoc.cgi?coll=0650&db=man&fname=/usr/share/catman/a_man/\n  \
    \            cat7/trusted_networking.z>.\n   [Jones2002]\n              Jones,\
    \ R., \"A Method Of Selecting Values For the\n              Parameters Controlling\
    \ IP Fragment Reassembly\", 2002,\n              <ftp://ftp.cup.hp.com/dist/networking/briefs/\n\
    \              ip_reass_tuning.txt>.\n   [Kenney1996]\n              Kenney, M.,\
    \ \"The Ping of Death Page\", 1996,\n              <http://www.insecure.org/sploits/ping-o-death.html>.\n\
    \   [Kent1987] Kent, C. and J. Mogul, \"Fragmentation considered harmful\",\n\
    \              Proc. SIGCOMM '87 Vol. 17, No. 5, October 1987, 1987.\n   [Klein2007]\n\
    \              Klein, A., \"OpenBSD DNS Cache Poisoning and Multiple O/S\n   \
    \           Predictable IP ID Vulnerability\", 2007,\n              <http://www.trusteer.com/files/\n\
    \              OpenBSD_DNS_Cache_Poisoning_and_Multiple_OS_Predictable_IP\n  \
    \            _ID_Vulnerability.pdf>.\n   [Kohno2005]\n              Kohno, T.,\
    \ Broido, A., and kc. Claffy, \"Remote Physical\n              Device Fingerprinting\"\
    , IEEE Transactions on Dependable\n              and Secure Computing Vol. 2,\
    \ No. 2, 2005.\n   [LBNL2006] LBNL/NRG, \"arpwatch tool\", 2006, <http://ee.lbl.gov/>.\n\
    \   [Linux]    Linux Kernel Organization, \"The Linux Kernel Archives\",\n   \
    \           <http://www.kernel.org>.\n   [Microsoft1999]\n              Microsoft,\
    \ \"Microsoft Security Program: Microsoft Security\n              Bulletin (MS99-038).\
    \ Patch Available for \"Spoofed Route\n              Pointer\" Vulnerability\"\
    , 1999, <http://www.microsoft.com/\n              technet/security/bulletin/ms99-038.mspx>.\n\
    \   [NISCC2004]\n              NISCC, \"NISCC Vulnerability Advisory 236929: Vulnerability\n\
    \              Issues in TCP\", 2004, <http://www.cpni.gov.uk>.\n   [NISCC2005]\n\
    \              NISCC, \"NISCC Vulnerability Advisory 532967/NISCC/ICMP:\n    \
    \          Vulnerability Issues in ICMP packets with TCP payloads\",\n       \
    \       2005, <http://www.gont.com.ar/advisories/index.html>.\n   [NISCC2006]\n\
    \              NISCC, \"NISCC Technical Note 01/2006: Egress and Ingress\n   \
    \           Filtering\", 2006, <http://www.cpni.gov.uk>.\n   [Northcutt2000]\n\
    \              Northcut, S. and Novak, \"Network Intrusion Detection - An\n  \
    \            Analyst's Handbook\", Second Edition New Riders Publishing,\n   \
    \           2000.\n   [Novak2005]\n              Novak, \"Target-Based Fragmentation\
    \ Reassembly\", 2005,\n              <http://www.snort.org/assets/165/target_based_frag.pdf>.\n\
    \   [OpenBSD-PF]\n              Sanfilippo, S., \"PF: Scrub (Packet Normalization)\"\
    , 2010,\n              <ftp://ftp.openbsd.org/pub/OpenBSD/doc/pf-faq.pdf>.\n \
    \  [OpenBSD1998]\n              OpenBSD, \"OpenBSD Security Advisory: IP Source\
    \ Routing\n              Problem\", 1998,\n              <http://www.openbsd.org/advisories/sourceroute.txt>.\n\
    \   [Paxson2001]\n              Paxson, V., Handley, M., and C. Kreibich, \"Network\n\
    \              Intrusion Detection: Evasion, Traffic Normalization, and\n    \
    \          End-to-End Protocol Semantics\", USENIX Conference, 2001.\n   [Ptacek1998]\n\
    \              Ptacek, T. and T. Newsham, \"Insertion, Evasion and Denial\n  \
    \            of Service: Eluding Network Intrusion Detection\", 1998,\n      \
    \        <http://www.aciri.org/vern/Ptacek-Newsham-Evasion-98.ps>.\n   [RFC0815]\
    \  Clark, D., \"IP datagram reassembly algorithms\", RFC 815,\n              July\
    \ 1982.\n   [RFC1858]  Ziemba, G., Reed, D., and P. Traina, \"Security\n     \
    \         Considerations for IP Fragment Filtering\", RFC 1858,\n            \
    \  October 1995.\n   [RFC2544]  Bradner, S. and J. McQuaid, \"Benchmarking Methodology\
    \ for\n              Network Interconnect Devices\", RFC 2544, March 1999.\n \
    \  [RFC3128]  Miller, I., \"Protection Against a Variant of the Tiny\n       \
    \       Fragment Attack (RFC 1858)\", RFC 3128, June 2001.\n   [RFC3530]  Shepler,\
    \ S., Callaghan, B., Robinson, D., Thurlow, R.,\n              Beame, C., Eisler,\
    \ M., and D. Noveck, \"Network File System\n              (NFS) version 4 Protocol\"\
    , RFC 3530, April 2003.\n   [RFC4963]  Heffner, J., Mathis, M., and B. Chandler,\
    \ \"IPv4 Reassembly\n              Errors at High Data Rates\", RFC 4963, July\
    \ 2007.\n   [RFC4987]  Eddy, W., \"TCP SYN Flooding Attacks and Common\n     \
    \         Mitigations\", RFC 4987, August 2007.\n   [RFC5559]  Eardley, P., \"\
    Pre-Congestion Notification (PCN)\n              Architecture\", RFC 5559, June\
    \ 2009.\n   [RFC5570]  StJohns, M., Atkinson, R., and G. Thomas, \"Common\n  \
    \            Architecture Label IPv6 Security Option (CALIPSO)\",\n          \
    \    RFC 5570, July 2009.\n   [RFC5670]  Eardley, P., \"Metering and Marking Behaviour\
    \ of PCN-\n              Nodes\", RFC 5670, November 2009.\n   [RFC5696]  Moncaster,\
    \ T., Briscoe, B., and M. Menth, \"Baseline\n              Encoding and Transport\
    \ of Pre-Congestion Information\",\n              RFC 5696, November 2009.\n \
    \  [RFC5927]  Gont, F., \"ICMP Attacks against TCP\", RFC 5927, July 2010.\n \
    \  [ROUTER-ALERT]\n              Le Faucheur, F., Ed., \"IP Router Alert Considerations\
    \ and\n              Usage\", Work in Progress, June 2011.\n   [SELinux2009]\n\
    \              NSA, \"Security-Enhanced Linux\",\n              <http://www.nsa.gov/research/selinux/>.\n\
    \   [Sanfilippo1998a]\n              Sanfilippo, S., \"about the ip header id\"\
    , Post to Bugtraq\n              mailing-list, Mon Dec 14 1998,\n            \
    \  <http://www.kyuzz.org/antirez/papers/ipid.html>.\n   [Sanfilippo1998b]\n  \
    \            Sanfilippo, S., \"Idle scan\", Post to Bugtraq mailing-list,\n  \
    \            1998, <http://www.kyuzz.org/antirez/papers/dumbscan.html>.\n   [Sanfilippo1999]\n\
    \              Sanfilippo, S., \"more ip id\", Post to Bugtraq mailing-\n    \
    \          list, 1999,\n              <http://www.kyuzz.org/antirez/papers/moreipid.html>.\n\
    \   [Shankar2003]\n              Shankar, U. and V. Paxson, \"Active Mapping:\
    \ Resisting NIDS\n              Evasion Without Altering Traffic\", 2003,\n  \
    \            <http://www.icir.org/vern/papers/activemap-oak03.pdf>.\n   [Shannon2001]\n\
    \              Shannon, C., Moore, D., and K. Claffy, \"Characteristics of\n \
    \             Fragmented IP Traffic on Internet Links\", 2001.\n   [Silbersack2005]\n\
    \              Silbersack, M., \"Improving TCP/IP security through\n         \
    \     randomization without sacrificing interoperability\",\n              EuroBSDCon\
    \ 2005 Conference, 2005,\n              <http://www.silby.com/eurobsdcon05/eurobsdcon_slides.pdf>.\n\
    \   [Snort]    Sourcefire, Inc., \"Snort\", <http://www.snort.org>.\n   [Solaris2007]\n\
    \              Oracle, \"ORACLE SOLARIS WITH TRUSTED EXTENSIONS\", 2007, <h\n\
    \              ttp://www.oracle.com/us/products/servers-storage/solaris/\n   \
    \           solaris-trusted-ext-ds-075583.pdf>.\n   [Song1999] Song, D., \"Frag\
    \ router tool\",\n              <http://www.monkey.org/~dugsong/fragroute/>.\n\
    \   [SpooferProject]\n              MIT ANA, \"Spoofer Project\", 2010,\n    \
    \          <http://spoofer.csail.mit.edu/index.php>.\n   [US-CERT2001]\n     \
    \         US-CERT, \"US-CERT Vulnerability Note VU#446689: Check\n           \
    \   Point FireWall-1 allows fragmented packets through\n              firewall\
    \ if Fast Mode is enabled\", 2001,\n              <http://www.kb.cert.org/vuls/id/446689>.\n\
    \   [US-CERT2002]\n              US-CERT, \"US-CERT Vulnerability Note VU#310387:\
    \ Cisco IOS\n              discloses fragments of previous packets when Express\n\
    \              Forwarding is enabled\", 2002.\n   [Watson2004]\n             \
    \ Watson, P., \"Slipping in the Window: TCP Reset Attacks\",\n              CanSecWest\
    \ Conference, 2004.\n   [Zakrzewski2002]\n              Zakrzewski, M. and I.\
    \ Haddad, \"Linux Distributed Security\n              Module\", 2002, <http://www.linuxjournal.com/article/6215>.\n\
    \   [daemon91996]\n              daemon9, route, and infinity, \"IP-spoofing Demystified\n\
    \              (Trust-Relationship Exploitation)\", Phrack Magazine,\n       \
    \       Volume Seven, Issue Forty-Eight, File 14 of 18, 1988, <htt\n         \
    \     p://www.phrack.org/issues.html?issue=48&id=14&mode=txt>.\n"
- title: Author's Address
  contents:
  - "Author's Address\n   Fernando Gont\n   UK Centre for the Protection of National\
    \ Infrastructure\n   EMail: fernando@gont.com.ar\n   URI:   http://www.cpni.gov.uk\n"
