- title: __initial_text__
  contents:
  - '                OCRA: OATH Challenge-Response Algorithm

    '
- title: Abstract
  contents:
  - "Abstract\n   This document describes an algorithm for challenge-response\n  \
    \ authentication developed by the Initiative for Open Authentication\n   (OATH).\
    \  The specified mechanisms leverage the HMAC-based One-Time\n   Password (HOTP)\
    \ algorithm and offer one-way and mutual\n   authentication, and electronic signature\
    \ capabilities.\n"
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This document is not an Internet Standards Track specification;\
    \ it is\n   published for informational purposes.\n   This document is a product\
    \ of the Internet Engineering Task Force\n   (IETF).  It represents the consensus\
    \ of the IETF community.  It has\n   received public review and has been approved\
    \ for publication by the\n   Internet Engineering Steering Group (IESG).  Not\
    \ all documents\n   approved by the IESG are a candidate for any level of Internet\n\
    \   Standard; see Section 2 of RFC 5741.\n   Information about the current status\
    \ of this document, any errata,\n   and how to provide feedback on it may be obtained\
    \ at\n   http://www.rfc-editor.org/info/rfc6287.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (c) 2011 IETF Trust and the persons identified\
    \ as the\n   document authors.  All rights reserved.\n   This document is subject\
    \ to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n\
    \   (http://trustee.ietf.org/license-info) in effect on the date of\n   publication\
    \ of this document.  Please review these documents\n   carefully, as they describe\
    \ your rights and restrictions with respect\n   to this document.  Code Components\
    \ extracted from this document must\n   include Simplified BSD License text as\
    \ described in Section 4.e of\n   the Trust Legal Provisions and are provided\
    \ without warranty as\n   described in the Simplified BSD License.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1. Introduction ....................................................3\n\
    \   2. Notation and Terminology ........................................3\n  \
    \ 3. Algorithm Requirements ..........................................3\n   4.\
    \ OCRA Background .................................................4\n      4.1.\
    \ HOTP Algorithm .............................................4\n   5. Definition\
    \ of OCRA ..............................................5\n      5.1. DataInput\
    \ Parameters .......................................5\n      5.2. CryptoFunction\
    \ .............................................7\n   6. The OCRASuite ...................................................8\n\
    \      6.1. Algorithm ..................................................9\n  \
    \    6.2. CryptoFunction .............................................9\n    \
    \  6.3. DataInput ..................................................9\n      6.4.\
    \ OCRASuite Examples ........................................10\n   7. Algorithm\
    \ Modes for Authentication .............................10\n      7.1. One-Way\
    \ Challenge-Response ................................11\n      7.2. Mutual Challenge-Response\
    \ .................................12\n      7.3. Algorithm Modes for Signature\
    \ .............................13\n           7.3.1. Plain Signature ....................................13\n\
    \           7.3.2. Signature with Server Authentication ...............14\n  \
    \ 8. Security Considerations ........................................16\n    \
    \  8.1. Security Analysis of OCRA .................................16\n      8.2.\
    \ Implementation Considerations .............................17\n   9. Conclusion\
    \ .....................................................18\n   10. Acknowledgements\
    \ ..............................................18\n   11. References ....................................................19\n\
    \      11.1. Normative References .....................................19\n  \
    \    11.2. Informative References ...................................19\n   Appendix\
    \ A. Reference Implementation ..............................20\n   Appendix B.\
    \ Test Vectors Generation ...............................26\n   Appendix C. Test\
    \ Vectors ..........................................33\n     C.1. One-Way Challenge\
    \ Response .................................34\n     C.2. Mutual Challenge-Response\
    \ ..................................35\n     C.3. Plain Signature ............................................37\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   The Initiative for Open Authentication (OATH) [OATH] has\
    \ identified\n   several use cases and scenarios that require an asynchronous\
    \ variant\n   to accommodate users who do not want to maintain a synchronized\n\
    \   authentication system.  A commonly accepted method for this is to use\n  \
    \ a challenge-response scheme.\n   Such a challenge-response mode of authentication\
    \ is widely adopted in\n   the industry.  Several vendors already offer software\
    \ applications\n   and hardware devices implementing challenge-response -- but\
    \ each of\n   those uses vendor-specific proprietary algorithms.  For the benefits\n\
    \   of users there is a need for a standardized challenge-response\n   algorithm\
    \ that allows multi-sourcing of token purchases and\n   validation systems to\
    \ facilitate the democratization of strong\n   authentication.\n   Additionally,\
    \ this specification describes the means to create\n   symmetric key-based short\
    \ 'electronic signatures'.  Such signatures\n   are variants of challenge-response\
    \ mode where the data to be signed\n   becomes the challenge or is used to derive\
    \ the challenge.  Note that\n   the term 'electronic signature' and 'signature'\
    \ are used\n   interchangeably in this document.\n"
- title: 2.  Notation and Terminology
  contents:
  - "2.  Notation and Terminology\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\"\
    , \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"\
    MAY\", and \"OPTIONAL\" in this\n   document are to be interpreted as described\
    \ in [RFC2119].\n"
- title: 3.  Algorithm Requirements
  contents:
  - "3.  Algorithm Requirements\n   This section presents the main requirements that\
    \ drove this algorithm\n   design.  A lot of emphasis was placed on flexibility\
    \ and usability,\n   under the constraints and specificity of the HMAC-based One-Time\n\
    \   Password (HOTP) algorithm [RFC4226] and hardware token capabilities.\n   R1\
    \ - The algorithm MUST support challenge-response-based\n   authentication.\n\
    \   R2 - The algorithm MUST be capable of supporting symmetric key-based\n   short\
    \ electronic signatures.  Essentially, this is a variation of\n   challenge-response\
    \ where the challenge is derived from the data that\n   needs to be signed.\n\
    \   R3 - The algorithm MUST be capable of supporting server\n   authentication,\
    \ whereby the user can verify that he/she is talking to\n   a trusted server.\n\
    \   R4 - The algorithm SHOULD use HOTP [RFC4226] as a key building block.\n  \
    \ R5 - The length and format of the input challenge SHOULD be\n   configurable.\n\
    \   R6 - The output length and format of the generated response SHOULD be\n  \
    \ configurable.\n   R7 - The challenge MAY be generated with integrity checking\
    \ (e.g.,\n   parity bits).  This will allow tokens with pin pads to perform simple\n\
    \   error checking when the user enters the challenge value into a token.\n  \
    \ R8 - There MUST be a unique secret (key) for each token/soft token\n   that\
    \ is shared between the token and the authentication server.  The\n   keys MUST\
    \ be randomly generated or derived using a key derivation\n   algorithm.\n   R9\
    \ - The algorithm MAY enable additional data attributes such as a\n   timestamp\
    \ or session information to be included in the computation.\n   These data inputs\
    \ MAY be used individually or all together.\n"
- title: 4.  OCRA Background
  contents:
  - "4.  OCRA Background\n   OATH introduced the HOTP algorithm as a first open, freely\
    \ available\n   building block towards strengthening authentication for end-users\
    \ in\n   a variety of applications.  One-time passwords are very efficient at\n\
    \   solving specific security issues thanks to the dynamic nature of OTP\n   computations.\n\
    \   After carefully analyzing different use cases, OATH came to the\n   conclusion\
    \ that providing for extensions to the HOTP algorithms was\n   important.  A very\
    \ natural extension is to introduce a challenge mode\n   for computing HOTP values\
    \ based on random questions.  Equally\n   beneficial is being able to perform\
    \ mutual authentication between two\n   parties, or short-signature computation\
    \ for authenticating\n   transaction to improve the security of e-commerce applications.\n"
- title: 4.1.  HOTP Algorithm
  contents:
  - "4.1.  HOTP Algorithm\n   The HOTP algorithm, as defined in [RFC4226], is based\
    \ on an\n   increasing counter value and a static symmetric key known only to\
    \ the\n   prover and verifier parties.\n   As a reminder:\n                  \
    \   HOTP(K,C) = Truncate(HMAC-SHA1(K,C))\n   where Truncate represents the function\
    \ that converts an HMAC-SHA-1\n   value into an HOTP value.\n   We refer the reader\
    \ to [RFC4226] for the full description and further\n   details on the rationale\
    \ and security analysis of HOTP.\n   The present document describes the different\
    \ variants based on\n   similar constructions as HOTP.\n"
- title: 5.  Definition of OCRA
  contents:
  - "5.  Definition of OCRA\n   The OATH Challenge-Response Algorithm (OCRA) is a\
    \ generalization of\n   HOTP with variable data inputs not solely based on an\
    \ incremented\n   counter and secret key values.\n   The definition of OCRA requires\
    \ a cryptographic function, a key K and\n   a set of DataInput parameters.  This\
    \ section first formally\n   introduces OCRA and then introduces the definitions\
    \ and default\n   values recommended for all parameters.\n   In a nutshell,\n\
    \                     OCRA = CryptoFunction(K, DataInput)\n   where:\n   o  K:\
    \ a shared secret key known to both parties\n   o  DataInput: a structure that\
    \ contains the concatenation of the\n      various input data values defined in\
    \ details in section 5.1\n   o  CryptoFunction: this is the function performing\
    \ the OCRA\n      computation from the secret key K and the DataInput material;\n\
    \   CryptoFunction is described in details in Section 5.2\n"
- title: 5.1.  DataInput Parameters
  contents:
  - "5.1.  DataInput Parameters\n   This structure is the concatenation over byte\
    \ array of the OCRASuite\n   value as defined in section 6 with the different\
    \ parameters used in\n   the computation, save for the secret key K.\n   DataInput\
    \ = {OCRASuite | 00 | C | Q | P | S | T} where:\n   o  OCRASuite is a value representing\
    \ the suite of operations to\n      compute an OCRA response\n   o  00 is a byte\
    \ value used as a separator\n   o  C is an unsigned 8-byte counter value processed\
    \ high-order bit\n      first, and MUST be synchronized between all parties; It\
    \ loops\n      around from \"{Hex}0\" to \"{Hex}FFFFFFFFFFFFFFFF\" and then starts\n\
    \      over at \"{Hex}0\".  Note that 'C' is optional for all OCRA modes\n   \
    \   described in this document.\n   o  Q, mandatory, is a 128-byte list of (concatenated)\
    \ challenge\n      question(s) generated by the parties; if Q is less than 128\
    \ bytes,\n      then it should be padded with zeroes to the right\n   o  P is\
    \ a hash (SHA-1 [RFC3174], SHA-256 and SHA-512 [SHA2] are\n      supported) value\
    \ of PIN/password that is known to all parties\n      during the execution of\
    \ the algorithm; the length of P will depend\n      on the hash function that\
    \ is used\n   o  S is a UTF-8 [RFC3629] encoded string of length up to 512 bytes\n\
    \      that contains information about the current session; the length of\n  \
    \    S is defined in the OCRASuite string\n   o  T is an 8-byte unsigned integer\
    \ in big-endian order (i.e., network\n      byte order) representing the number\
    \ of time-steps (seconds,\n      minutes, hours, or days depending on the specified\
    \ granularity)\n      since midnight UTC of January 1, 1970 [UT].  More specifically,\
    \ if\n      the OCRA computation includes a timestamp T, you should first\n  \
    \    convert your current local time to UTC time; you can then derive\n      the\
    \ UTC time in the proper format (i.e., seconds, minutes, hours,\n      or days\
    \ elapsed from epoch time); the size of the time-step is\n      specified in the\
    \ OCRASuite string as described in Section 6.3\n   When computing a response,\
    \ the concatenation order is always the\n   following:\n                     \
    \               C |\n                OTHER-PARTY-GENERATED-CHALLENGE-QUESTION\
    \ |\n                    YOUR-GENERATED-CHALLENGE-QUESTION |\n               \
    \                  P| S | T\n   If a value is empty (i.e., a certain input is\
    \ not used in the\n   computation) then the value is simply not represented in\
    \ the string.\n   The counter on the token or client MUST be incremented every\
    \ time a\n   new computation is requested by the user.  The server's counter value\n\
    \   MUST only be incremented after a successful OCRA authentication.\n"
- title: 5.2.  CryptoFunction
  contents:
  - "5.2.  CryptoFunction\n   The default CryptoFunction is HOTP-SHA1-6, i.e., the\
    \ default mode of\n   computation for OCRA is HOTP with the default 6-digit dynamic\n\
    \   truncation and a combination of DataInput values as the message to\n   compute\
    \ the HMAC-SHA1 digest.\n   We denote t as the length in decimal digits of the\
    \ truncation output.\n   For instance, if t = 6, then the output of the truncation\
    \ is a\n   6-digit (decimal) value.\n   We define the HOTP family of functions\
    \ as an extension to HOTP:\n   1.  HOTP-H-t: these are the different possible\
    \ truncated versions of\n       HOTP, using the dynamic truncation method for\
    \ extracting an HOTP\n       value from the HMAC output\n   2.  We will denote\
    \ HOTP-H-t as the realization of an HOTP function\n       that uses an HMAC function\
    \ with the hash function H, and the\n       dynamic truncation as described in\
    \ [RFC4226] to extract a t-digit\n       value\n   3.  t=0 means that no truncation\
    \ is performed and the full HMAC value\n       is used for authentication purposes\n\
    \   We list the following preferred modes of computation, where * denotes\n  \
    \ the default CryptoFunction:\n   o  HOTP-SHA1-4: HOTP with SHA-1 as the hash\
    \ function for HMAC and a\n      dynamic truncation to a 4-digit value; this mode\
    \ is not\n      recommended in the general case, but it can be useful when a very\n\
    \      short authentication code is needed by an application\n   o  HOTP-SHA1-6:\
    \ HOTP with SHA-1 as the hash function for HMAC and a\n      dynamic truncation\
    \ to a 6-digit value\n   o  HOTP-SHA1-8: HOTP with SHA-1 as the hash function\
    \ for HMAC and a\n      dynamic truncation to an 8-digit value\n   o  HOTP-SHA256-6:\
    \ HOTP with SHA-256 as the hash function for HMAC and\n      a dynamic truncation\
    \ to a 6-digit value\n   o  HOTP-SHA512-6: HOTP with SHA-512 as the hash function\
    \ for HMAC and\n      a dynamic truncation to a 6-digit value\n   This table summarizes\
    \ all possible values for the CryptoFunction:\n     +---------------+--------------------+-------------------------+\n\
    \     |      Name     | HMAC Function Used |  Size of Truncation (t) |\n     +---------------+--------------------+-------------------------+\n\
    \     |  HOTP-SHA1-t  |      HMAC-SHA1     | 0 (no truncation), 4-10 |\n     |\
    \ HOTP-SHA256-t |     HMAC-SHA256    | 0 (no truncation), 4-10 |\n     | HOTP-SHA512-t\
    \ |     HMAC-SHA512    | 0 (no truncation), 4-10 |\n     +---------------+--------------------+-------------------------+\n\
    \                       Table 1: CryptoFunction Table\n"
- title: 6.  The OCRASuite
  contents:
  - "6.  The OCRASuite\n   An OCRASuite value is a text string that captures one mode\
    \ of\n   operation for OCRA, completely specifying the various options for\n \
    \  that computation.  An OCRASuite value is represented as follows:\n        \
    \          <Algorithm>:<CryptoFunction>:<DataInput>\n   The OCRASuite value is\
    \ the concatenation of three sub-components that\n   are described below.  Some\
    \ example OCRASuite strings are described in\n   Section 6.4.\n   The client and\
    \ server need to agree on one or two values of\n   OCRASuite.  These values may\
    \ be agreed upon at the time of token\n   provisioning or, for more sophisticated\
    \ client-server interactions,\n   these values may be negotiated for every transaction.\n\
    \   The provisioning of OCRA keys and related metadata such as OCRASuite\n   is\
    \ out of scope for this document.  [RFC6030] specifies one key\n   container specification\
    \ that facilitates provisioning of such data\n   between the client and the server.\n\
    \   Note that for Mutual Challenge-Response or Signature with Server\n   Authentication\
    \ modes, the client and server will need to agree on two\n   values of OCRASuite\
    \ -- one for server computation and another for\n   client computation.\n"
- title: 6.1.  Algorithm
  contents:
  - "6.1.  Algorithm\n   Description: Indicates the version of OCRA.\n   Values: OCRA-v\
    \ where v represents the version number (e.g., 1, 2).\n   This document specifies\
    \ version 1 of OCRA.\n"
- title: 6.2.  CryptoFunction
  contents:
  - "6.2.  CryptoFunction\n   Description: Indicates the function used to compute\
    \ OCRA values\n   Values: Permitted values are described in Section 5.2.\n"
- title: 6.3.  DataInput
  contents:
  - "6.3.  DataInput\n   Description: This component of the OCRASuite string captures\
    \ the list\n   of valid inputs for that computation; [] indicates a value is\n\
    \   optional:\n   [C] | QFxx | [PH | Snnn | TG] : Challenge-Response computation\n\
    \   [C] | QFxx | [PH | TG] : Plain Signature computation\n   Each input that is\
    \ used for the computation is represented by a\n   single letter (except Q), and\
    \ they are separated by a hyphen.\n   The input for challenge is further qualified\
    \ by the formats supported\n   by the client for challenge question(s).  Supported\
    \ values can be:\n                 +------------------+-------------------+\n\
    \                 |    Format (F)    | Up to Length (xx) |\n                 +------------------+-------------------+\n\
    \                 | A (alphanumeric) |       04-64       |\n                 |\
    \    N (numeric)   |       04-64       |\n                 |  H (hexadecimal)\
    \ |       04-64       |\n                 +------------------+-------------------+\n\
    \                      Table 2: Challenge Format Table\n   The default challenge\
    \ format is N08, numeric and up to 8 digits.\n   The input for P is further qualified\
    \ by the hash function used for\n   the PIN/password.  Supported values for hash\
    \ function can be:\n   Hash function (H) - SHA1, SHA256, SHA512.\n   The default\
    \ hash function for P is SHA1.\n   The input for S is further qualified by the\
    \ length of the session\n   data in bytes.  The client and server could agree\
    \ to any length but\n   the typical values are:\n   Length (nnn) - 064, 128, 256,\
    \ and 512.\n   The default length is 064 bytes.\n   The input for timestamps is\
    \ further qualified by G, size of the time-\n   step.  G can be specified in number\
    \ of seconds, minutes, or hours:\n           +--------------------+------------------------------+\n\
    \           | Time-Step Size (G) |           Examples           |\n          \
    \ +--------------------+------------------------------+\n           |       [1-59]S\
    \      | number of seconds, e.g., 20S |\n           |       [1-59]M      |  number\
    \ of minutes, e.g., 5M |\n           |       [0-48]H      |  number of hours,\
    \ e.g., 24H  |\n           +--------------------+------------------------------+\n\
    \                       Table 3: Time-step Size Table\n   Default value for G\
    \ is 1M, i.e., time-step size is one minute and the\n   T represents the number\
    \ of minutes since epoch time [UT].\n"
- title: 6.4.  OCRASuite Examples
  contents:
  - "6.4.  OCRASuite Examples\n   Here are some examples of OCRASuite strings:\n \
    \  o  \"OCRA-1:HOTP-SHA512-8:C-QN08-PSHA1\" means version 1 of OCRA with\n   \
    \   HMAC-SHA512 function, truncated to an 8-digit value, using the\n      counter,\
    \ a random challenge, and a SHA1 digest of the PIN/password\n      as parameters.\
    \  It also indicates that the client supports only\n      numeric challenge up\
    \ to 8 digits in length\n   o  \"OCRA-1:HOTP-SHA256-6:QA10-T1M\" means version\
    \ 1 of OCRA with HMAC-\n      SHA256 function, truncated to a 6-digit value, using\
    \ a random\n      alphanumeric challenge up to 10 characters in length and a\n\
    \      timestamp in number of minutes since epoch time\n   o  \"OCRA-1:HOTP-SHA1-4:QH8-S512\"\
    \ means version 1 of OCRA with HMAC-\n      SHA1 function, truncated to a 4-digit\
    \ value, using a random\n      hexadecimal challenge up to 8 nibbles and a session\
    \ value of 512\n      bytes\n"
- title: 7.  Algorithm Modes for Authentication
  contents:
  - "7.  Algorithm Modes for Authentication\n   This section describes the typical\
    \ modes in which the above defined\n   computation can be used for authentication.\n"
- title: 7.1.  One-Way Challenge-Response
  contents:
  - "7.1.  One-Way Challenge-Response\n   A challenge-response is a security mechanism\
    \ in which the verifier\n   presents a question (challenge) to the prover, who\
    \ must provide a\n   valid answer (response) to be authenticated.\n   To use this\
    \ algorithm for a one-way challenge-response, the verifier\n   will communicate\
    \ a challenge value (typically randomly generated) to\n   the prover.  The prover\
    \ will use the challenge in the computation as\n   described above.  The prover\
    \ then communicates the response to the\n   verifier to authenticate.\n   Therefore\
    \ in this mode, the typical data inputs will be:\n      C - Counter, optional.\n\
    \      Q - Challenge question, mandatory, supplied by the verifier.\n      P -\
    \ Hashed version of PIN/password, optional.\n      S - Session information, optional.\n\
    \      T - Timestamp, optional.\n   The diagram below shows the message exchange\
    \ between the client\n   (prover) and the server (verifier) to complete a one-way\
    \ challenge-\n   response authentication.\n   It is assumed that the client and\
    \ server have a pre-shared key K that\n   is used for the computation.\n     \
    \         CLIENT                                   SERVER\n             (PROVER)\
    \                                 VERIFIER)\n                |               \
    \                         |\n                |   Verifier sends challenge to prover\
    \   |\n                |   Challenge = Q                        |\n          \
    \      |<---------------------------------------|\n                |         \
    \                               |\n                |   Prover Computes Response\
    \             |\n                |   R = OCRA(K, {[C] | Q | [P | S | T]}) |\n\
    \                |   Prover sends Response = R            |\n                |--------------------------------------->|\n\
    \                |                                        |\n                |\
    \  Verifier Validates Response           |\n                |  If Response is\
    \ valid, Server sends OK |\n                |  If Response is not,  Server sends\
    \ NOK |\n                |<---------------------------------------|\n        \
    \        |                                        |\n"
- title: 7.2.  Mutual Challenge-Response
  contents:
  - "7.2.  Mutual Challenge-Response\n   Mutual challenge-response is a variation\
    \ of one-way challenge-\n   response where both the client and server mutually\
    \ authenticate each\n   other.\n   To use this algorithm, the client will first\
    \ send a random client-\n   challenge to the server.  The server computes the\
    \ server-response and\n   sends it to the client along with a server-challenge.\n\
    \   The client will first verify the server-response to be assured that\n   it\
    \ is talking to a valid server.  It will then compute the client-\n   response\
    \ and send it to the server to authenticate.  The server\n   verifies the client-response\
    \ to complete the two-way authentication\n   process.\n   In this mode there are\
    \ two computations: client-response and server-\n   response.  There are two separate\
    \ challenge questions, generated by\n   both parties.  We denote these challenge\
    \ questions Q1 and Q2.\n   Typical data inputs for server-response computation\
    \ will be:\n      C - Counter, optional.\n      QC - Challenge question, mandatory,\
    \ supplied by the client.\n      QS - Challenge question, mandatory, supplied\
    \ by the server.\n      S - Session information, optional.\n      T - Timestamp,\
    \ optional.\n   Typical data inputs for client-response computation will be:\n\
    \      C - Counter, optional.\n      QS - Challenge question, mandatory, supplied\
    \ by the server.\n      QC - Challenge question, mandatory, supplied by the client.\n\
    \      P - Hashed version of PIN/password, optional.\n      S - Session information,\
    \ optional.\n      T - Timestamp, optional.\n   The following diagram shows the\
    \ messages that are exchanged between\n   the client and the server to complete\
    \ a two-way mutual challenge-\n   response authentication.\n   It is assumed that\
    \ the client and server have a pre-shared key K (or\n   pair of keys if using\
    \ dual-key mode of computation) that is used for\n   the computation.\n      \
    \   CLIENT                                             SERVER\n        (PROVER)\
    \                                          (VERIFIER)\n           |          \
    \                                        |\n           |   1. Client sends client-challenge\
    \               |\n           |   QC = Client-challenge                      \
    \    |\n           |------------------------------------------------->|\n    \
    \       |                                                  |\n           |   2.\
    \ Server computes server-response             |\n           |      and sends server-challenge\
    \                  |\n           |   RS = OCRA(K, [C] | QC | QS | [S | T])   \
    \       |\n           |   QS = Server-challenge                          |\n \
    \          |   Response = RS, QS                              |\n           |<-------------------------------------------------|\n\
    \           |                                                  |\n           |\
    \   3. Client verifies server-response             |\n           |      and computes\
    \ client-response                |\n           |   OCRA(K, [C] | QC | QS | [S\
    \ | T]) != RS -> STOP |\n           |   RC = OCRA(K, [C] | QS | QC | [P | S |\
    \ T])      |\n           |   Response = RC                                  |\n\
    \           |------------------------------------------------->|\n           |\
    \                                                  |\n           |   4. Server\
    \ verifies client-response             |\n           |   OCRA(K, [C] | QS | QC\
    \ | [P|S|T]) != RC -> STOP |\n           |   Response = OK                   \
    \               |\n           |<-------------------------------------------------|\n\
    \           |                                                  |\n"
- title: 7.3.  Algorithm Modes for Signature
  contents:
  - "7.3.  Algorithm Modes for Signature\n   In this section we describe the typical\
    \ modes in which the above\n   defined computation can be used for electronic\
    \ signatures.\n"
- title: 7.3.1.  Plain Signature
  contents:
  - "7.3.1.  Plain Signature\n   To use this algorithm in plain signature mode, the\
    \ server will\n   communicate a signature-challenge value to the client (signer).\
    \  The\n   signature-challenge is either the data to be signed or derived from\n\
    \   the data to be signed using a hash function, for example.\n   The client will\
    \ use the signature-challenge in the computation as\n   described above.  The\
    \ client then communicates the signature value\n   (response) to the server to\
    \ authenticate.\n   Therefore in this mode, the data inputs will be:\n      C\
    \ - Counter, optional.\n      QS - Signature-challenge, mandatory, supplied by\
    \ the server.\n      P - Hashed version of PIN/password, optional.\n      T -\
    \ Timestamp, optional.\n   The picture below shows the messages that are exchanged\
    \ between the\n   client (prover) and the server (verifier) to complete a plain\n\
    \   signature operation.\n   It is assumed that the client and server have a pre-shared\
    \ key K that\n   is used for the computation.\n             CLIENT           \
    \                          SERVER\n            (PROVER)                      \
    \            (VERIFIER)\n               |                                    \
    \       |\n               |    Verifier sends signature-challenge     |\n    \
    \           |    Challenge = QS                         |\n               |<------------------------------------------|\n\
    \               |                                           |\n              \
    \ |    Client Computes Response               |\n               |    SIGN = OCRA(K,\
    \ [C] | QS | [P | T])     |\n               |    Response = SIGN             \
    \           |\n               |------------------------------------------>|\n\
    \               |                                           |\n              \
    \ |    Verifier Validates Response            |\n               |    Response\
    \ = OK                          |\n               |<------------------------------------------|\n\
    \               |                                           |\n"
- title: 7.3.2.  Signature with Server Authentication
  contents:
  - "7.3.2.  Signature with Server Authentication\n   This mode is a variation of\
    \ the plain signature mode where the client\n   can first authenticate the server\
    \ before generating a electronic\n   signature.\n   To use this algorithm, the\
    \ client will first send a random client-\n   challenge to the server.  The server\
    \ computes the server-response and\n   sends it to the client along with a signature-challenge.\n\
    \   The client will first verify the server-response to authenticate that\n  \
    \ it is talking to a valid server.  It will then compute the signature\n   and\
    \ send it to the server.\n   In this mode there are two computations: client-signature\
    \ and server-\n   response.\n   Typical data inputs for server-response computation\
    \ will be:\n      C - Counter, optional.\n      QC - Challenge question, mandatory,\
    \ supplied by the client.\n      QS - Signature-challenge, mandatory, supplied\
    \ by the server.\n      T - Timestamp, optional.\n   Typical data inputs for client-signature\
    \ computation will be:\n      C - Counter, optional.\n      QC - Challenge question,\
    \ mandatory, supplied by the client.\n      QS - Signature-challenge, mandatory,\
    \ supplied by the server.\n      P - Hashed version of PIN/password, optional.\n\
    \      T - Timestamp, optional.\n   The diagram below shows the messages that\
    \ are exchanged between the\n   client and the server to complete a signature\
    \ with server\n   authentication transaction.\n   It is assumed that the client\
    \ and server have a pre-shared key K (or\n   pair of keys if using dual-key mode\
    \ of computation) that is used for\n   the computation.\n        CLIENT      \
    \                                        SERVER\n       (PROVER)             \
    \                               VERIFIER)\n          |                       \
    \                            |\n          |    1. Client sends client-challenge\
    \               |\n          |    QC = Client-challenge                      \
    \    |\n          |-------------------------------------------------->|\n    \
    \      |                                                   |\n          |    2.\
    \ Server computes server-response             |\n          |       and sends signature-challenge\
    \               |\n          |    RS = OCRA(K, [C] | QC | QS | [T])          \
    \    |\n          |    QS = signature-challenge                       |\n    \
    \      |    Response = RS, QS                              |\n          |<--------------------------------------------------|\n\
    \          |                                                   |\n          |\
    \    3. Client verifies server-response             |\n          |       and computes\
    \ signature                      |\n          |    OCRA(K, [C] | QC | QS | [T])\
    \ != RS -> STOP     |\n          |    SIGN = OCRA( K, [C] | QS | QC | [P | T])\
    \       |\n          |    Response = SIGN                                |\n \
    \         |-------------------------------------------------->|\n          | \
    \                                                  |\n          |    4. Server\
    \ verifies Signature                   |\n          |    OCRA(K, [C] | QS | QC\
    \ | [P|T]) != SIGN -> STOP |\n          |    Response = OK                   \
    \               |\n          |<--------------------------------------------------|\n\
    \          |                                                   |\n"
- title: 8.  Security Considerations
  contents:
  - "8.  Security Considerations\n   Any algorithm is only as secure as the application\
    \ and the\n   authentication protocols that implement it.  Therefore, this section\n\
    \   discusses the critical security requirements that our choice of\n   algorithm\
    \ imposes on the authentication protocol and validation\n   software.\n"
- title: 8.1.  Security Analysis of OCRA
  contents:
  - "8.1.  Security Analysis of OCRA\n   The security and strength of this algorithm\
    \ depend on the properties\n   of the underlying building block HOTP, which is\
    \ a construction based\n   on HMAC [RFC2104] using SHA-1 [RFC3174] (or SHA-256\
    \ or SHA-512\n   [SHA2]) as the hash function.\n   The conclusion of the security\
    \ analysis detailed in [RFC4226] is\n   that, for all practical purposes, the\
    \ outputs of the dynamic\n   truncation on distinct counter inputs are uniformly\
    \ and independently\n   distributed strings.\n   The analysis demonstrates that\
    \ the best possible attack against the\n   HOTP function is the brute force attack.\n"
- title: 8.2.  Implementation Considerations
  contents:
  - "8.2.  Implementation Considerations\n   IC1 - In the authentication mode, the\
    \ client MUST support two-factor\n   authentication, i.e., the communication and\
    \ verification of something\n   you know (secret code such as a password, pass\
    \ phrase, PIN code,\n   etc.) and something you have (token).  The secret code\
    \ is known only\n   to the user and usually entered with the Response value for\n\
    \   authentication purpose (two-factor authentication).  Alternatively,\n   instead\
    \ of sending something you know to the server, the client may\n   use a hash of\
    \ the password or PIN code in the computation itself,\n   thus implicitly enabling\
    \ two-factor authentication.\n   IC2 - Keys SHOULD be of the length of the CryptoFunction\
    \ output to\n   facilitate interoperability.\n   IC3 - Keys SHOULD be chosen at\
    \ random or using a cryptographically\n   strong pseudo-random generator properly\
    \ seeded with a random value.\n   We RECOMMEND following the recommendations in\
    \ [RFC4086] for all\n   pseudo-random and random generations.  The pseudo-random\
    \ numbers used\n   for generating the keys SHOULD successfully pass the randomness\
    \ test\n   specified in [CN].\n   IC4 - Challenge questions SHOULD be 20-byte\
    \ values and MUST be at\n   least t-byte values where t stands for the digit-length\
    \ of the OCRA\n   truncation output.\n   IC5 - On the client side, the keys SHOULD\
    \ be embedded in a tamper-\n   resistant device or securely implemented in a software\
    \ application.\n   Additionally, by embedding the keys in a hardware device, you\
    \ also\n   have the advantage of improving the flexibility (mobility) of the\n\
    \   authentication system.\n   IC6 - All the communications SHOULD take place\
    \ over a secure channel,\n   e.g., SSL/TLS [RFC5246], IPsec connections.\n   IC7\
    \ - OCRA, when used in mutual authentication mode or in signature\n   with server\
    \ authentication mode, MAY use dual-key mode -- i.e., there\n   are two keys that\
    \ are shared between the client and the server.  One\n   shared key is used to\
    \ generate the server response on the server side\n   and to verify it on the\
    \ client side.  The other key is used to create\n   the response or signature\
    \ on the client side and to verify it on the\n   server side.\n   IC8 - We recommend\
    \ that implementations MAY use the session\n   information, S, as an additional\
    \ input in the computation.  For\n   example, S could be the session identifier\
    \ from the TLS session.\n   This will mitigate against certain types of man-in-the-middle\n\
    \   attacks.  However, this will introduce the additional dependency that\n  \
    \ first of all the prover needs to have access to the session\n   identifier to\
    \ compute the response and the verifier will need access\n   to the session identifier\
    \ to verify the response.  [RFC5056] contains\n   a relevant discussion of using\
    \ Channel Bindings to Secure Channels.\n   IC9 - In the signature mode, whenever\
    \ the counter or time (defined as\n   optional elements) are not used in the computation,\
    \ there might be a\n   risk of replay attack and the implementers should carefully\
    \ consider\n   this issue in the light of their specific application requirements\n\
    \   and security guidelines.  The server SHOULD also provide whenever\n   possible\
    \ a mean for the client (if able) to verify the validity of\n   the signature\
    \ challenge.\n   IC10 - We also RECOMMEND storing the keys securely in the validation\n\
    \   system, and more specifically, encrypting them using tamper-resistant\n  \
    \ hardware encryption and exposing them only when required: for\n   example, the\
    \ key is decrypted when needed to verify an OCRA response,\n   and re-encrypted\
    \ immediately to limit exposure in the RAM for a short\n   period of time.  The\
    \ key store MUST be in a secure area, to avoid as\n   much as possible direct\
    \ attack on the validation system and secrets\n   database.  Particularly, access\
    \ to the key material should be limited\n   to programs and processes required\
    \ by the validation system only.\n"
- title: 9.  Conclusion
  contents:
  - "9.  Conclusion\n   This document introduced several variants of HOTP for challenge-\n\
    \   response-based authentication and short signature-like computations.\n   The\
    \ OCRASuite provides for an easy integration and support of\n   different flavors\
    \ within an authentication and validation system.\n   Finally, OCRA should enable\
    \ mutual authentication both in connected\n   and off-line modes, with the support\
    \ of different response sizes and\n   mode of operations.\n"
- title: 10.  Acknowledgements
  contents:
  - "10.  Acknowledgements\n   We would like to thank Jeff Burstein, Shuh Chang, Oanh\
    \ Hoang, Philip\n   Hoyer, Jon Martinsson, Frederik Mennes, Mingliang Pei, Jonathan\n\
    \   Tuliani, Stu Vaeth, Enrique Rodriguez, and Robert Zuccherato for\n   their\
    \ comments and suggestions to improve this document.\n"
- title: 11.  References
  contents:
  - '11.  References

    '
- title: 11.1.  Normative References
  contents:
  - "11.1.  Normative References\n   [RFC2104]  Krawczyk, H., Bellare, M., and R.\
    \ Canetti, \"HMAC: Keyed-\n              Hashing for Message Authentication\"\
    , RFC 2104,\n              February 1997.\n   [RFC2119]  Bradner, S., \"Key words\
    \ for use in RFCs to Indicate\n              Requirement Levels\", BCP 14, RFC\
    \ 2119, March 1997.\n   [RFC3174]  Eastlake, D. and P. Jones, \"US Secure Hash\
    \ Algorithm 1\n              (SHA1)\", RFC 3174, September 2001.\n   [RFC3629]\
    \  Yergeau, F., \"UTF-8, a transformation format of ISO\n              10646\"\
    , STD 63, RFC 3629, November 2003.\n   [RFC4086]  Eastlake, D., Schiller, J.,\
    \ and S. Crocker, \"Randomness\n              Requirements for Security\", BCP\
    \ 106, RFC 4086, June 2005.\n   [RFC4226]  M'Raihi, D., Bellare, M., Hoornaert,\
    \ F., Naccache, D., and\n              O. Ranen, \"HOTP: An HMAC-Based One-Time\
    \ Password\n              Algorithm\", RFC 4226, December 2005.\n   [SHA2]   \
    \  NIST, \"FIPS PUB 180-3: Secure Hash Standard (SHS)\",\n              October\
    \ 2008, <http://csrc.nist.gov/publications/fips/\n              fips180-3/fips180-3_final.pdf>.\n"
- title: 11.2.  Informative References
  contents:
  - "11.2.  Informative References\n   [CN]       Coron, J. and D. Naccache, \"An\
    \ accurate evaluation of\n              Maurer's universal test\", LNCS 1556,\
    \ February 1999, <http:\n              //www.gemplus.com/smart/rd/publications/pdf/CN99maur.pdf>.\n\
    \   [OATH]     Initiative for Open Authentication, \"OATH Vision\",\n        \
    \      <http://www.openauthentication.org/about>.\n   [RFC5056]  Williams, N.,\
    \ \"On the Use of Channel Bindings to Secure\n              Channels\", RFC 5056,\
    \ November 2007.\n   [RFC5246]  Dierks, T. and E. Rescorla, \"The Transport Layer\
    \ Security\n              (TLS) Protocol Version 1.2\", RFC 5246, August 2008.\n\
    \   [RFC6030]  Hoyer, P., Pei, M., and S. Machani, \"Portable Symmetric\n    \
    \          Key Container (PSKC)\", RFC 6030, October 2010.\n   [UT]       Wikipedia,\
    \ \"Unix time\",\n              <http://en.wikipedia.org/wiki/Unix_time>.\n"
- title: Appendix A.  Reference Implementation
  contents:
  - "Appendix A.  Reference Implementation\n  <CODE BEGINS>\n  /**\n     Copyright\
    \ (c) 2011 IETF Trust and the persons identified as\n     authors of the code.\
    \ All rights reserved.\n     Redistribution and use in source and binary forms,\
    \ with or without\n     modification, is permitted pursuant to, and subject to\
    \ the license\n     terms contained in, the Simplified BSD License set forth in\
    \ Section\n     4.c of the IETF Trust's Legal Provisions Relating to IETF Documents\n\
    \     (http://trustee.ietf.org/license-info).\n   */\n  import javax.crypto.Mac;\n\
    \  import javax.crypto.spec.SecretKeySpec;\n  import java.math.BigInteger;\n \
    \ /**\n   * This an example implementation of OCRA.\n   * Visit www.openauthentication.org\
    \ for more information.\n   *\n   * @author Johan Rydell, PortWise\n   */\n  public\
    \ class OCRA {\n      private OCRA() {}\n      /**\n       * This method uses\
    \ the JCE to provide the crypto\n       * algorithm.\n       * HMAC computes a\
    \ Hashed Message Authentication Code with the\n       * crypto hash algorithm\
    \ as a parameter.\n       *\n       * @param crypto     the crypto algorithm (HmacSHA1,\
    \ HmacSHA256,\n       *                                   HmacSHA512)\n      \
    \ * @param keyBytes   the bytes to use for the HMAC key\n       * @param text\
    \       the message or text to be authenticated.\n       */\n      private static\
    \ byte[] hmac_sha1(String crypto,\n                       byte[] keyBytes, byte[]\
    \ text){\n          Mac hmac = null;\n          try {\n              hmac = Mac.getInstance(crypto);\n\
    \              SecretKeySpec macKey =\n                  new SecretKeySpec(keyBytes,\
    \ \"RAW\");\n              hmac.init(macKey);\n              return hmac.doFinal(text);\n\
    \          } catch (Exception e) {\n              e.printStackTrace();\n     \
    \     }\n          return null;\n      }\n      private static final int[] DIGITS_POWER\n\
    \      // 0 1  2   3    4     5      6       7        8\n      = {1,10,100,1000,10000,100000,1000000,10000000,100000000\
    \ };\n      /**\n       * This method converts HEX string to Byte[]\n       *\n\
    \       * @param hex   the HEX string\n       *\n       * @return      A byte\
    \ array\n       */\n      private static byte[] hexStr2Bytes(String hex){\n  \
    \        // Adding one byte to get the right conversion\n          // values starting\
    \ with \"0\" can be converted\n          byte[] bArray = new BigInteger(\"10\"\
    \ + hex,16).toByteArray();\n          // Copy all the REAL bytes, not the \"first\"\
    \n          byte[] ret = new byte[bArray.length - 1];\n          System.arraycopy(bArray,\
    \ 1, ret, 0, ret.length);\n          return ret;\n      }\n      /**\n       *\
    \ This method generates an OCRA HOTP value for the given\n       * set of parameters.\n\
    \       *\n       * @param ocraSuite    the OCRA Suite\n       * @param key  \
    \        the shared secret, HEX encoded\n       * @param counter      the counter\
    \ that changes on a per use\n       *                     basis, HEX encoded\n\
    \       * @param question     the challenge question, HEX encoded\n       * @param\
    \ password     a password that can be used, HEX encoded\n       * @param sessionInformation\
    \ Static information that identifies\n       *                     the current\
    \ session, Hex encoded\n       * @param timeStamp    a value that reflects a time\n\
    \       *\n       * @return A numeric String in base 10 that includes\n      \
    \ * {@link truncationDigits} digits\n       */\n      static public String generateOCRA(String\
    \ ocraSuite,\n              String key,\n              String counter,\n     \
    \         String question,\n              String password,\n              String\
    \ sessionInformation,\n              String timeStamp){\n          int codeDigits\
    \ = 0;\n          String crypto = \"\";\n          String result = null;\n   \
    \       int ocraSuiteLength = (ocraSuite.getBytes()).length;\n          int counterLength\
    \ = 0;\n          int questionLength = 0;\n          int passwordLength = 0;\n\
    \          int sessionInformationLength = 0;\n          int timeStampLength =\
    \ 0;\n          // The OCRASuites components\n          String CryptoFunction\
    \ = ocraSuite.split(\":\")[1];\n          String DataInput = ocraSuite.split(\"\
    :\")[2];\n          if(CryptoFunction.toLowerCase().indexOf(\"sha1\") > 1)\n \
    \             crypto = \"HmacSHA1\";\n          if(CryptoFunction.toLowerCase().indexOf(\"\
    sha256\") > 1)\n              crypto = \"HmacSHA256\";\n          if(CryptoFunction.toLowerCase().indexOf(\"\
    sha512\") > 1)\n              crypto = \"HmacSHA512\";\n          // How many\
    \ digits should we return\n          codeDigits = Integer.decode(CryptoFunction.substring(\n\
    \                  CryptoFunction.lastIndexOf(\"-\")+1));\n          // The size\
    \ of the byte array message to be encrypted\n          // Counter\n          if(DataInput.toLowerCase().startsWith(\"\
    c\")) {\n              // Fix the length of the HEX string\n              while(counter.length()\
    \ < 16)\n                  counter = \"0\" + counter;\n              counterLength=8;\n\
    \          }\n          // Question - always 128 bytes\n          if(DataInput.toLowerCase().startsWith(\"\
    q\") ||\n                  (DataInput.toLowerCase().indexOf(\"-q\") >= 0)) {\n\
    \              while(question.length() < 256)\n                  question = question\
    \ + \"0\";\n              questionLength=128;\n          }\n          // Password\
    \ - sha1\n          if(DataInput.toLowerCase().indexOf(\"psha1\") > 1){\n    \
    \          while(password.length() < 40)\n                  password = \"0\" +\
    \ password;\n              passwordLength=20;\n          }\n          // Password\
    \ - sha256\n          if(DataInput.toLowerCase().indexOf(\"psha256\") > 1){\n\
    \              while(password.length() < 64)\n                  password = \"\
    0\" + password;\n              passwordLength=32;\n          }\n          // Password\
    \ - sha512\n          if(DataInput.toLowerCase().indexOf(\"psha512\") > 1){\n\
    \              while(password.length() < 128)\n                  password = \"\
    0\" + password;\n              passwordLength=64;\n          }\n          // sessionInformation\
    \ - s064\n          if(DataInput.toLowerCase().indexOf(\"s064\") > 1){\n     \
    \         while(sessionInformation.length() < 128)\n                  sessionInformation\
    \ = \"0\" + sessionInformation;\n              sessionInformationLength=64;\n\
    \          }\n          // sessionInformation - s128\n          if(DataInput.toLowerCase().indexOf(\"\
    s128\") > 1){\n              while(sessionInformation.length() < 256)\n      \
    \            sessionInformation = \"0\" + sessionInformation;\n              sessionInformationLength=128;\n\
    \          }\n          // sessionInformation - s256\n          if(DataInput.toLowerCase().indexOf(\"\
    s256\") > 1){\n              while(sessionInformation.length() < 512)\n      \
    \            sessionInformation = \"0\" + sessionInformation;\n              sessionInformationLength=256;\n\
    \          }\n          // sessionInformation - s512\n          if(DataInput.toLowerCase().indexOf(\"\
    s512\") > 1){\n              while(sessionInformation.length() < 1024)\n     \
    \             sessionInformation = \"0\" + sessionInformation;\n             \
    \ sessionInformationLength=512;\n          }\n          // TimeStamp\n       \
    \   if(DataInput.toLowerCase().startsWith(\"t\") ||\n                  (DataInput.toLowerCase().indexOf(\"\
    -t\") > 1)){\n              while(timeStamp.length() < 16)\n                 \
    \ timeStamp = \"0\" + timeStamp;\n              timeStampLength=8;\n         \
    \ }\n          // Remember to add \"1\" for the \"00\" byte delimiter\n      \
    \    byte[] msg = new byte[ocraSuiteLength +\n                        counterLength\
    \ +\n                        questionLength +\n                        passwordLength\
    \ +\n                        sessionInformationLength +\n                    \
    \    timeStampLength +\n                        1];\n          // Put the bytes\
    \ of \"ocraSuite\" parameters into the message\n          byte[] bArray = ocraSuite.getBytes();\n\
    \          System.arraycopy(bArray, 0, msg, 0, bArray.length);\n          // Delimiter\n\
    \          msg[bArray.length] = 0x00;\n          // Put the bytes of \"Counter\"\
    \ to the message\n          // Input is HEX encoded\n          if(counterLength\
    \ > 0 ){\n              bArray = hexStr2Bytes(counter);\n              System.arraycopy(bArray,\
    \ 0, msg, ocraSuiteLength + 1,\n                      bArray.length);\n      \
    \    }\n          // Put the bytes of \"question\" to the message\n          //\
    \ Input is text encoded\n          if(questionLength > 0 ){\n              bArray\
    \ = hexStr2Bytes(question);\n              System.arraycopy(bArray, 0, msg, ocraSuiteLength\
    \ + 1 +\n                      counterLength, bArray.length);\n          }\n \
    \         // Put the bytes of \"password\" to the message\n          // Input\
    \ is HEX encoded\n          if(passwordLength > 0){\n              bArray = hexStr2Bytes(password);\n\
    \              System.arraycopy(bArray, 0, msg, ocraSuiteLength + 1 +\n      \
    \                counterLength +    questionLength, bArray.length);\n        \
    \  }\n          // Put the bytes of \"sessionInformation\" to the message\n  \
    \        // Input is text encoded\n          if(sessionInformationLength > 0 ){\n\
    \              bArray = hexStr2Bytes(sessionInformation);\n              System.arraycopy(bArray,\
    \ 0, msg, ocraSuiteLength + 1 +\n                      counterLength +     questionLength\
    \ +\n                      passwordLength, bArray.length);\n          }\n    \
    \      // Put the bytes of \"time\" to the message\n          // Input is text\
    \ value of minutes\n          if(timeStampLength > 0){\n              bArray =\
    \ hexStr2Bytes(timeStamp);\n              System.arraycopy(bArray, 0, msg, ocraSuiteLength\
    \ + 1 +\n                      counterLength + questionLength +\n            \
    \          passwordLength + sessionInformationLength,\n                      bArray.length);\n\
    \          }\n          bArray = hexStr2Bytes(key);\n          byte[] hash = hmac_sha1(crypto,\
    \ bArray, msg);\n          // put selected bytes into result int\n          int\
    \ offset = hash[hash.length - 1] & 0xf;\n          int binary =\n            \
    \  ((hash[offset] & 0x7f) << 24) |\n              ((hash[offset + 1] & 0xff) <<\
    \ 16) |\n              ((hash[offset + 2] & 0xff) << 8) |\n              (hash[offset\
    \ + 3] & 0xff);\n          int otp = binary % DIGITS_POWER[codeDigits];\n    \
    \      result = Integer.toString(otp);\n          while (result.length() < codeDigits)\
    \ {\n              result = \"0\" + result;\n          }\n          return result;\n\
    \      }\n  }\n  <CODE ENDS>\n"
- title: Appendix B.  Test Vectors Generation
  contents:
  - "Appendix B.  Test Vectors Generation\n  <CODE BEGINS>\n  /**\n     Copyright\
    \ (c) 2011 IETF Trust and the persons identified as\n     authors of the code.\
    \ All rights reserved.\n     Redistribution and use in source and binary forms,\
    \ with or without\n     modification, is permitted pursuant to, and subject to\
    \ the license\n     terms contained in, the Simplified BSD License set forth in\
    \ Section\n     4.c of the IETF Trust's Legal Provisions Relating to IETF Documents\n\
    \     (http://trustee.ietf.org/license-info).\n   */\n  import java.math.BigInteger;\n\
    \  import java.util.*;\n  import java.text.DateFormat;\n  import java.text.SimpleDateFormat;\n\
    \  public class TestOCRA {\n  public static String asHex (byte buf[]) {\n    \
    \  StringBuffer strbuf = new StringBuffer(buf.length * 2);\n      int i;\n   \
    \   for (i = 0; i < buf.length; i++) {\n          if (((int) buf[i] & 0xff) <\
    \ 0x10)\n              strbuf.append(\"0\");\n          strbuf.append(Long.toString((int)\
    \ buf[i] & 0xff, 16));\n      }\n      return strbuf.toString();\n  }\n  /**\n\
    \   * @param args\n   */\n  public static void main(String[] args) {\n      String\
    \ ocra = \"\";\n      String seed = \"\";\n      String ocraSuite = \"\";\n  \
    \    String counter = \"\";\n      String password = \"\";\n      String sessionInformation\
    \ = \"\";\n      String question = \"\";\n      String qHex = \"\";\n      String\
    \ timeStamp = \"\";\n      // PASS1234 is SHA1 hash of \"1234\"\n      String\
    \ PASS1234 = \"7110eda4d09e062aa5e4a390b0a572ac0d2c0220\";\n      String SEED\
    \ = \"3132333435363738393031323334353637383930\";\n      String SEED32 = \"31323334353637383930313233343536373839\"\
    \ +\n          \"30313233343536373839303132\";\n      String SEED64 = \"31323334353637383930313233343536373839\"\
    \ +\n          \"3031323334353637383930313233343536373839\" +\n          \"3031323334353637383930313233343536373839\"\
    \ +\n          \"3031323334\";\n      int STOP = 5;\n      Date myDate = Calendar.getInstance().getTime();\n\
    \      BigInteger b = new BigInteger(\"0\");\n      String sDate = \"Mar 25 2008,\
    \ 12:06:30 GMT\";\n      try{\n          DateFormat df =\n              new SimpleDateFormat(\"\
    MMM dd yyyy, HH:mm:ss zzz\");\n          myDate = df.parse(sDate);\n         \
    \ b = new BigInteger(\"0\" + myDate.getTime());\n          b = b.divide(new BigInteger(\"\
    60000\"));\n          System.out.println(\"Time of \\\"\" + sDate + \"\\\" is\
    \ in\");\n          System.out.println(\"milli sec: \" + myDate.getTime());\n\
    \          System.out.println(\"minutes: \" + b.toString());\n          System.out.println(\"\
    minutes (HEX encoded): \"\n              + b.toString(16).toUpperCase());\n  \
    \        System.out.println(\"Time of \\\"\" + sDate\n              + \"\\\" is\
    \ the same as this localized\");\n          System.out.println(\"time, \\\"\"\n\
    \              + new Date(myDate.getTime()) + \"\\\"\");\n          System.out.println();\n\
    \          System.out.println(\"Standard 20Byte key: \" +\n              \"3132333435363738393031323334353637383930\"\
    );\n          System.out.println(\"Standard 32Byte key: \" +\n              \"\
    3132333435363738393031323334353637383930\");\n          System.out.println(\"\
    \                     \" +\n              \"313233343536373839303132\");\n   \
    \       System.out.println(\"Standard 64Byte key: 313233343536373839\"\n     \
    \         + \"3031323334353637383930\");\n          System.out.println(\"    \
    \                 313233343536373839\"\n              + \"3031323334353637383930\"\
    );\n          System.out.println(\"                     313233343536373839\"\n\
    \              + \"3031323334353637383930\");\n          System.out.println(\"\
    \                     31323334\");\n          System.out.println();\n        \
    \  System.out.println(\"Plain challenge response\");\n          System.out.println(\"\
    ========================\");\n          System.out.println();\n          ocraSuite\
    \ = \"OCRA-1:HOTP-SHA1-6:QN08\";\n          System.out.println(ocraSuite);\n \
    \         System.out.println(\"=======================\");\n          seed = SEED;\n\
    \          counter = \"\";\n          question = \"\";\n          password = \"\
    \";\n          sessionInformation = \"\";\n          timeStamp = \"\";\n     \
    \     for(int i=0; i < 10; i++){\n              question = \"\" + i + i + i +\
    \ i + i + i + i + i;\n              qHex = new String((new BigInteger(question,10))\n\
    \                         .toString(16)).toUpperCase();\n              ocra =\
    \ OCRA.generateOCRA(ocraSuite,seed,counter,\n                             qHex,password,\n\
    \                             sessionInformation,timeStamp);\n               System.out.println(\"\
    Key: Standard 20Byte  Q: \"\n                      + question + \"  OCRA: \" +\
    \ ocra);\n          }\n          System.out.println();\n          ocraSuite =\
    \ \"OCRA-1:HOTP-SHA256-8:C-QN08-PSHA1\";\n          System.out.println(ocraSuite);\n\
    \          System.out.println(\"=================================\");\n      \
    \    seed = SEED32;\n          counter = \"\";\n          question = \"12345678\"\
    ;\n          password = PASS1234;\n          sessionInformation = \"\";\n    \
    \      timeStamp = \"\";\n          for(int i=0; i < 10; i++){\n             \
    \ counter = \"\" + i;\n              qHex = new String((new BigInteger(question,10))\n\
    \                         .toString(16)).toUpperCase();\n              ocra =\
    \ OCRA.generateOCRA(ocraSuite,seed,counter,\n                         qHex,password,sessionInformation,timeStamp);\n\
    \              System.out.println(\"Key: Standard 32Byte  C: \"\n            \
    \               + counter + \"  Q: \"\n                           + question +\
    \ \"  PIN(1234): \");\n              System.out.println(password + \"  OCRA: \"\
    \ + ocra);\n          }\n          System.out.println();\n          ocraSuite\
    \ = \"OCRA-1:HOTP-SHA256-8:QN08-PSHA1\";\n          System.out.println(ocraSuite);\n\
    \          System.out.println(\"===============================\");\n        \
    \  seed = SEED32;\n          counter = \"\";\n          question = \"\";\n   \
    \       password = PASS1234;\n          sessionInformation = \"\";\n         \
    \ timeStamp = \"\";\n          for(int i=0; i < STOP; i++){\n              question\
    \ = \"\" + i + i + i + i + i + i + i + i;\n              qHex = new String((new\
    \ BigInteger(question,10))\n                          .toString(16)).toUpperCase();\n\
    \              ocra = OCRA.generateOCRA(ocraSuite,seed,counter,\n            \
    \           qHex,password,sessionInformation,timeStamp);\n              System.out.println(\"\
    Key: Standard 32Byte  Q: \"\n                          + question + \"  PIN(1234):\
    \ \");\n              System.out.println(password + \"  OCRA: \" + ocra);\n  \
    \        }\n          System.out.println();\n          ocraSuite = \"OCRA-1:HOTP-SHA512-8:C-QN08\"\
    ;\n          System.out.println(ocraSuite);\n          System.out.println(\"===========================\"\
    );\n          seed = SEED64;\n          counter = \"\";\n          question =\
    \ \"\";\n          password = \"\";\n          sessionInformation = \"\";\n  \
    \        timeStamp = \"\";\n          for(int i=0; i < 10; i++){\n           \
    \   question = \"\" + i + i + i + i + i + i + i + i;\n              qHex = new\
    \ String((new BigInteger(question,10))\n                          .toString(16)).toUpperCase();\n\
    \              counter = \"0000\" + i;\n              ocra = OCRA.generateOCRA(ocraSuite,seed,counter,\n\
    \                       qHex,password,sessionInformation,timeStamp);\n       \
    \       System.out.println(\"Key: Standard 64Byte  C: \"\n                   \
    \    + counter + \"  Q: \"\n                       + question + \"  OCRA: \" +\
    \ ocra);\n          }\n          System.out.println();\n          ocraSuite =\
    \ \"OCRA-1:HOTP-SHA512-8:QN08-T1M\";\n          System.out.println(ocraSuite);\n\
    \          System.out.println(\"=============================\");\n          seed\
    \ = SEED64;\n          counter = \"\";\n          question = \"\";\n         \
    \ password = \"\";\n          sessionInformation = \"\";\n          timeStamp\
    \ = b.toString(16);\n          for(int i=0; i < STOP; i++){\n              question\
    \ = \"\" + i + i + i + i + i + i + i + i;\n              counter = \"\";\n   \
    \           qHex = new String((new BigInteger(question,10))\n                \
    \          .toString(16)).toUpperCase();\n              ocra = OCRA.generateOCRA(ocraSuite,seed,counter,\n\
    \                       qHex,password,sessionInformation,timeStamp);\n       \
    \       System.out.println(\"Key: Standard 64Byte  Q: \"\n                   \
    \       + question +\"  T: \"\n                            + timeStamp.toUpperCase()\n\
    \                          + \"  OCRA: \" + ocra);\n          }\n          System.out.println();\n\
    \          System.out.println();\n          System.out.println(\"Mutual Challenge\
    \ Response\");\n          System.out.println(\"=========================\");\n\
    \          System.out.println();\n          ocraSuite = \"OCRA-1:HOTP-SHA256-8:QA08\"\
    ;\n          System.out.println(\"OCRASuite (server computation) = \"\n      \
    \                       + ocraSuite);\n          System.out.println(\"OCRASuite\
    \ (client computation) = \"\n                             + ocraSuite);\n    \
    \      System.out.println(\"===============================\" +\n            \
    \  \"===========================\");\n          seed = SEED32;\n          counter\
    \ = \"\";\n          question = \"\";\n          password = \"\";\n          sessionInformation\
    \ = \"\";\n          timeStamp = \"\";\n          for(int i=0; i < STOP; i++){\n\
    \              question = \"CLI2222\" + i + \"SRV1111\" + i;\n              qHex\
    \ = asHex(question.getBytes());\n              ocra = OCRA.generateOCRA(ocraSuite,seed,counter,qHex,\n\
    \                           password,sessionInformation,timeStamp);\n        \
    \      System.out.println(\n                       \"(server)Key: Standard 32Byte\
    \  Q: \"\n                       + question + \"  OCRA: \"\n                 \
    \      + ocra);\n              question = \"SRV1111\" + i + \"CLI2222\" + i;\n\
    \              qHex = asHex(question.getBytes());\n              ocra = OCRA.generateOCRA(ocraSuite,seed,counter,qHex,\n\
    \                           password,sessionInformation,timeStamp);\n        \
    \      System.out.println(\n                       \"(client)Key: Standard 32Byte\
    \  Q: \"\n                       + question + \"  OCRA: \"\n                 \
    \      + ocra);\n          }\n          System.out.println();\n          String\
    \ ocraSuite1 = \"OCRA-1:HOTP-SHA512-8:QA08\";\n          String ocraSuite2 = \"\
    OCRA-1:HOTP-SHA512-8:QA08-PSHA1\";\n          System.out.println(\"OCRASuite (server\
    \ computation) = \"\n                             + ocraSuite1);\n          System.out.println(\"\
    OCRASuite (client computation) = \"\n                             + ocraSuite2);\n\
    \          System.out.println(\"===============================\" +\n        \
    \      \"=================================\");\n          ocraSuite = \"\";\n\
    \          seed = SEED64;\n          counter = \"\";\n          question = \"\"\
    ;\n          password = \"\";\n          sessionInformation = \"\";\n        \
    \  timeStamp = \"\";\n          for(int i=0; i < STOP; i++){\n              ocraSuite\
    \ = ocraSuite1;\n              question = \"CLI2222\" + i + \"SRV1111\" + i;\n\
    \              qHex = asHex(question.getBytes());\n              password = \"\
    \";\n              ocra = OCRA.generateOCRA(ocraSuite,seed,counter,qHex,\n   \
    \                        password,sessionInformation,timeStamp);\n           \
    \   System.out.println(\n                          \"(server)Key: Standard 64Byte\
    \  Q: \"\n                          + question + \"  OCRA: \"\n              \
    \            + ocra);\n              ocraSuite = ocraSuite2;\n              question\
    \ = \"SRV1111\" + i + \"CLI2222\" + i;\n              qHex = asHex(question.getBytes());\n\
    \              password = PASS1234;\n              ocra = OCRA.generateOCRA(ocraSuite,seed,counter,qHex,\n\
    \                           password,sessionInformation,timeStamp);\n        \
    \      System.out.println(\"(client)Key: Standard 64Byte  Q: \"\n            \
    \               + question);\n              System.out.println(\"P: \" + password.toUpperCase()\n\
    \                           + \"  OCRA: \" + ocra);\n          }\n          System.out.println();\n\
    \          System.out.println();\n          System.out.println(\"Plain Signature\"\
    );\n          System.out.println(\"===============\");\n          System.out.println();\n\
    \          ocraSuite = \"OCRA-1:HOTP-SHA256-8:QA08\";\n          System.out.println(ocraSuite);\n\
    \          System.out.println(\"=========================\");\n          seed\
    \ = SEED32;\n          counter = \"\";\n          question = \"\";\n         \
    \ password = \"\";\n          sessionInformation = \"\";\n          timeStamp\
    \ = \"\";\n          for(int i=0; i < STOP; i++){\n              question = \"\
    SIG1\" + i + \"000\";\n              qHex = asHex(question.getBytes());\n    \
    \          ocra = OCRA.generateOCRA(ocraSuite,seed,counter,qHex,\n           \
    \                password,sessionInformation,timeStamp);\n              System.out.println(\n\
    \                      \"Key: Standard 32Byte  Q(Signature challenge): \"\n  \
    \                    + question);\n              System.out.println(\"   OCRA:\
    \ \" + ocra);\n          }\n          System.out.println();\n          ocraSuite\
    \ = \"OCRA-1:HOTP-SHA512-8:QA10-T1M\";\n          System.out.println(ocraSuite);\n\
    \          System.out.println(\"=============================\");\n          seed\
    \ = SEED64;\n          counter = \"\";\n          question = \"\";\n         \
    \ password = \"\";\n          sessionInformation = \"\";\n          timeStamp\
    \ = b.toString(16);\n          for(int i=0; i < STOP; i++){\n              question\
    \ = \"SIG1\" + i + \"00000\";\n              qHex = asHex(question.getBytes());\n\
    \              ocra = OCRA.generateOCRA(ocraSuite,seed,counter,\n            \
    \               qHex,password,sessionInformation,timeStamp);\n              System.out.println(\n\
    \                      \"Key: Standard 64Byte  Q(Signature challenge): \"\n  \
    \                    + question);\n              System.out.println(\"   T: \"\
    \n                      + timeStamp.toUpperCase() + \"  OCRA: \"\n           \
    \           + ocra);\n          }\n      }catch (Exception e){\n             \
    \   System.out.println(\"Error : \" + e);\n      }\n  }\n  }\n  <CODE ENDS>\n"
- title: Appendix C.  Test Vectors
  contents:
  - "Appendix C.  Test Vectors\n   This section provides test values that can be used\
    \ for the OCRA\n   interoperability test.\n   Standard 20Byte key:\n   3132333435363738393031323334353637383930\n\
    \   Standard 32Byte key:\n   3132333435363738393031323334353637383930313233343536373839303132\n\
    \   Standard 64Byte key:\n   313233343536373839303132333435363738393031323334353637383930313233343\n\
    \   53637383930313233343536373839303132333435363738393031323334\n   PIN (1234)\
    \ SHA1 hash value:\n   7110eda4d09e062aa5e4a390b0a572ac0d2c0220\n"
- title: C.1.  One-Way Challenge Response
  contents:
  - "C.1.  One-Way Challenge Response\n                +-----------------+----------+------------+\n\
    \                |       Key       |     Q    | OCRA Value |\n               \
    \ +-----------------+----------+------------+\n                | Standard 20Byte\
    \ | 00000000 |   237653   |\n                | Standard 20Byte | 11111111 |  \
    \ 243178   |\n                | Standard 20Byte | 22222222 |   653583   |\n  \
    \              | Standard 20Byte | 33333333 |   740991   |\n                |\
    \ Standard 20Byte | 44444444 |   608993   |\n                | Standard 20Byte\
    \ | 55555555 |   388898   |\n                | Standard 20Byte | 66666666 |  \
    \ 816933   |\n                | Standard 20Byte | 77777777 |   224598   |\n  \
    \              | Standard 20Byte | 88888888 |   750600   |\n                |\
    \ Standard 20Byte | 99999999 |   294470   |\n                +-----------------+----------+------------+\n\
    \                          OCRA-1:HOTP-SHA1-6:QN08\n              +-----------------+---+----------+------------+\n\
    \              |       Key       | C |     Q    | OCRA Value |\n             \
    \ +-----------------+---+----------+------------+\n              | Standard 32Byte\
    \ | 0 | 12345678 |  65347737  |\n              | Standard 32Byte | 1 | 12345678\
    \ |  86775851  |\n              | Standard 32Byte | 2 | 12345678 |  78192410 \
    \ |\n              | Standard 32Byte | 3 | 12345678 |  71565254  |\n         \
    \     | Standard 32Byte | 4 | 12345678 |  10104329  |\n              | Standard\
    \ 32Byte | 5 | 12345678 |  65983500  |\n              | Standard 32Byte | 6 |\
    \ 12345678 |  70069104  |\n              | Standard 32Byte | 7 | 12345678 |  91771096\
    \  |\n              | Standard 32Byte | 8 | 12345678 |  75011558  |\n        \
    \      | Standard 32Byte | 9 | 12345678 |  08522129  |\n              +-----------------+---+----------+------------+\n\
    \                     OCRA-1:HOTP-SHA256-8:C-QN08-PSHA1\n                +-----------------+----------+------------+\n\
    \                |       Key       |     Q    | OCRA Value |\n               \
    \ +-----------------+----------+------------+\n                | Standard 32Byte\
    \ | 00000000 |  83238735  |\n                | Standard 32Byte | 11111111 |  01501458\
    \  |\n                | Standard 32Byte | 22222222 |  17957585  |\n          \
    \      | Standard 32Byte | 33333333 |  86776967  |\n                | Standard\
    \ 32Byte | 44444444 |  86807031  |\n                +-----------------+----------+------------+\n\
    \                      OCRA-1:HOTP-SHA256-8:QN08-PSHA1\n            +-----------------+-------+----------+------------+\n\
    \            |       Key       |   C   |     Q    | OCRA Value |\n           \
    \ +-----------------+-------+----------+------------+\n            | Standard\
    \ 64Byte | 00000 | 00000000 |  07016083  |\n            | Standard 64Byte | 00001\
    \ | 11111111 |  63947962  |\n            | Standard 64Byte | 00002 | 22222222\
    \ |  70123924  |\n            | Standard 64Byte | 00003 | 33333333 |  25341727\
    \  |\n            | Standard 64Byte | 00004 | 44444444 |  33203315  |\n      \
    \      | Standard 64Byte | 00005 | 55555555 |  34205738  |\n            | Standard\
    \ 64Byte | 00006 | 66666666 |  44343969  |\n            | Standard 64Byte | 00007\
    \ | 77777777 |  51946085  |\n            | Standard 64Byte | 00008 | 88888888\
    \ |  20403879  |\n            | Standard 64Byte | 00009 | 99999999 |  31409299\
    \  |\n            +-----------------+-------+----------+------------+\n      \
    \                  OCRA-1:HOTP-SHA512-8:C-QN08\n           +-----------------+----------+---------+------------+\n\
    \           |       Key       |     Q    |    T    | OCRA Value |\n          \
    \ +-----------------+----------+---------+------------+\n           | Standard\
    \ 64Byte | 00000000 | 132d0b6 |  95209754  |\n           | Standard 64Byte | 11111111\
    \ | 132d0b6 |  55907591  |\n           | Standard 64Byte | 22222222 | 132d0b6\
    \ |  22048402  |\n           | Standard 64Byte | 33333333 | 132d0b6 |  24218844\
    \  |\n           | Standard 64Byte | 44444444 | 132d0b6 |  36209546  |\n     \
    \      +-----------------+----------+---------+------------+\n               \
    \        OCRA-1:HOTP-SHA512-8:QN08-T1M\n"
- title: C.2.  Mutual Challenge-Response
  contents:
  - "C.2.  Mutual Challenge-Response\n   OCRASuite (server computation) = OCRA-1:HOTP-SHA256-8:QA08\n\
    \   OCRASuite (client computation) = OCRA-1:HOTP-SHA256-8:QA08\n            +-----------------+------------------+------------+\n\
    \            |       Key       |         Q        | OCRA Value |\n           \
    \ +-----------------+------------------+------------+\n            | Standard\
    \ 32Byte | CLI22220SRV11110 |  28247970  |\n            | Standard 32Byte | CLI22221SRV11111\
    \ |  01984843  |\n            | Standard 32Byte | CLI22222SRV11112 |  65387857\
    \  |\n            | Standard 32Byte | CLI22223SRV11113 |  03351211  |\n      \
    \      | Standard 32Byte | CLI22224SRV11114 |  83412541  |\n            +-----------------+------------------+------------+\n\
    \                    Server -- OCRA-1:HOTP-SHA256-8:QA08\n            +-----------------+------------------+------------+\n\
    \            |       Key       |         Q        | OCRA Value |\n           \
    \ +-----------------+------------------+------------+\n            | Standard\
    \ 32Byte | SRV11110CLI22220 |  15510767  |\n            | Standard 32Byte | SRV11111CLI22221\
    \ |  90175646  |\n            | Standard 32Byte | SRV11112CLI22222 |  33777207\
    \  |\n            | Standard 32Byte | SRV11113CLI22223 |  95285278  |\n      \
    \      | Standard 32Byte | SRV11114CLI22224 |  28934924  |\n            +-----------------+------------------+------------+\n\
    \                    Client -- OCRA-1:HOTP-SHA256-8:QA08\n   OCRASuite (server\
    \ computation) = OCRA-1:HOTP-SHA512-8:QA08\n   OCRASuite (client computation)\
    \ = OCRA-1:HOTP-SHA512-8:QA08-PSHA1\n            +-----------------+------------------+------------+\n\
    \            |       Key       |         Q        | OCRA Value |\n           \
    \ +-----------------+------------------+------------+\n            | Standard\
    \ 64Byte | CLI22220SRV11110 |  79496648  |\n            | Standard 64Byte | CLI22221SRV11111\
    \ |  76831980  |\n            | Standard 64Byte | CLI22222SRV11112 |  12250499\
    \  |\n            | Standard 64Byte | CLI22223SRV11113 |  90856481  |\n      \
    \      | Standard 64Byte | CLI22224SRV11114 |  12761449  |\n            +-----------------+------------------+------------+\n\
    \                    Server -- OCRA-1:HOTP-SHA512-8:QA08\n            +-----------------+------------------+------------+\n\
    \            |       Key       |         Q        | OCRA Value |\n           \
    \ +-----------------+------------------+------------+\n            | Standard\
    \ 64Byte | SRV11110CLI22220 |  18806276  |\n            | Standard 64Byte | SRV11111CLI22221\
    \ |  70020315  |\n            | Standard 64Byte | SRV11112CLI22222 |  01600026\
    \  |\n            | Standard 64Byte | SRV11113CLI22223 |  18951020  |\n      \
    \      | Standard 64Byte | SRV11114CLI22224 |  32528969  |\n            +-----------------+------------------+------------+\n\
    \                 Client -- OCRA-1:HOTP-SHA512-8:QA08-PSHA1\n"
- title: C.3.  Plain Signature
  contents:
  - "C.3.  Plain Signature\n   In this mode of operation, Q represents the signature\
    \ challenge.\n                +-----------------+----------+------------+\n  \
    \              |       Key       |     Q    | OCRA Value |\n                +-----------------+----------+------------+\n\
    \                | Standard 32Byte | SIG10000 |  53095496  |\n               \
    \ | Standard 32Byte | SIG11000 |  04110475  |\n                | Standard 32Byte\
    \ | SIG12000 |  31331128  |\n                | Standard 32Byte | SIG13000 |  76028668\
    \  |\n                | Standard 32Byte | SIG14000 |  46554205  |\n          \
    \      +-----------------+----------+------------+\n                         OCRA-1:HOTP-SHA256-8:QA08\n\
    \          +-----------------+------------+---------+------------+\n         \
    \ |       Key       |      Q     |    T    | OCRA Value |\n          +-----------------+------------+---------+------------+\n\
    \          | Standard 64Byte | SIG1000000 | 132d0b6 |  77537423  |\n         \
    \ | Standard 64Byte | SIG1100000 | 132d0b6 |  31970405  |\n          | Standard\
    \ 64Byte | SIG1200000 | 132d0b6 |  10235557  |\n          | Standard 64Byte |\
    \ SIG1300000 | 132d0b6 |  95213541  |\n          | Standard 64Byte | SIG1400000\
    \ | 132d0b6 |  65360607  |\n          +-----------------+------------+---------+------------+\n\
    \                       OCRA-1:HOTP-SHA512-8:QA10-T1M\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   David M'Raihi\n   Verisign, Inc.\n   487 E. Middlefield\
    \ Road\n   Mountain View, CA  94043\n   USA\n   EMail: davidietf@gmail.com\n \
    \  Johan Rydell\n   Portwise, Inc.\n   275 Hawthorne Ave, Suite 119\n   Palo Alto,\
    \ CA  94301\n   USA\n   EMail: johanietf@gmail.com\n   Siddharth Bajaj\n   Symantec\
    \ Corp.\n   350 Ellis Street\n   Mountain View, CA  94043\n   USA\n   EMail: siddharthietf@gmail.com\n\
    \   Salah Machani\n   Diversinet Corp.\n   2225 Sheppard Avenue East, Suite 1801\n\
    \   Toronto, Ontario  M2J 5C2\n   Canada\n   EMail: smachani@diversinet.com\n\
    \   David Naccache\n   Ecole Normale Superieure\n   ENS DI, 45 rue d'Ulm\n   Paris,\
    \   75005\n   France\n   EMail: david.naccache@ens.fr\n"
