- title: __initial_text__
  contents:
  - '                 Structured Data Exchange Format (SDXF)

    '
- title: Status of this Memo
  contents:
  - "Status of this Memo\n   This memo provides information for the Internet community.\
    \  It does\n   not specify an Internet standard of any kind.  Distribution of\
    \ this\n   memo is unlimited.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (C) The Internet Society (2001).  All Rights Reserved.\n"
- title: IESG Note
  contents:
  - "IESG Note\n   This document specifies a data exchange format and, partially,\
    \ an API\n   that can be used for creating and parsing such a format.  The IESG\n\
    \   notes that the same problem space can be addressed using formats that\n  \
    \ the IETF normally uses including ASN.1 and XML.  The document reader\n   is\
    \ strongly encouraged to carefully read section 13 before choosing\n   SDXF over\
    \ ASN.1 or XML.  Further, when storing text in SDXF, the user\n   is encourage\
    \ to use the datatype for UTF-8, specified in section 2.5.\n"
- title: Abstract
  contents:
  - "Abstract\n   This specification describes an all-purpose interchange format for\n\
    \   use as a file format or for net-working.  Data is organized in chunks\n  \
    \ which can be ordered in hierarchical structures.  This format is\n   self-describing\
    \ and CPU-independent.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   8.1 Introduction .................................................12\n\
    \   8.2 Basic definitions ............................................13\n   8.3\
    \ Definitions for C++ ..........................................15\n   8.4 Common\
    \ Definitions ...........................................16\n   8.5 Special functions\
    \ ............................................17\n   9.  'Support' of UTF-8 ...........................................19\n\
    \   10.  Security Considerations .....................................19\n   11.\
    \  Some general hints ..........................................20\n   12.  IANA\
    \ Considerations .........................................20\n   13.  Discussion\
    \ ..................................................21\n   13.1 SDXF vs. ASN.1\
    \ ..............................................21\n   13.2 SDXF vs. XML ................................................22\n\
    \   14.  Author's Address ............................................24\n   15.\
    \  Acknowledgements ............................................24\n   16.  References\
    \ ..................................................24\n   17.  Full Copyright\
    \ Statement ....................................26\n"
- title: 1. Introduction
  contents:
  - "1. Introduction\n   The purpose of the Structured Data eXchange Format (SDXF)\
    \ is to\n   permit the interchange of an arbitrary structured data block with\n\
    \   different kinds of data (numerical, text, bitstrings).  Because data\n   is\
    \ normalized to an abstract computer architecture independent\n   \"network format\"\
    , SDXF is usable as a network interchange data\n   format.\n   This data format\
    \ is not limited to any application, the demand for\n   this format is that it\
    \ is usable as a text format for word-\n   processing, as a picture format, a\
    \ sound format, for remote procedure\n   calls with complex parameters, suitable\
    \ for document formats, for\n   interchanging business data, etc.\n   SDXF is\
    \ self-describing, every program can unpack every SDXF-data\n   without knowing\
    \ the meaning of the individual data elements.\n   Together with the description\
    \ of the data format a set of functions\n   will be introduced.  With the help\
    \ of these functions one can create\n   and access the data elements of SDXF.\
    \  The idea is that a programmer\n   should only use these functions instead of\
    \ maintaining the structure\n   by himself on the level of bits and bytes.  (In\
    \ the speech of\n   object-oriented programming these functions are methods of\
    \ an object\n   which works as a handle for a given SDXF data block.)\n   SDXF\
    \ is not limited to a specific platform, along with a correct\n   preparation\
    \ of the SDXF functions the SDXF data can be interchanged\n   (via network or\
    \ data carrier) across the boundaries of different\n   architectures (specified\
    \ by the character code like ASCII, ANSI or\n   EBCDIC and the byte order for\
    \ binary data).\n   SDXF is also prepared to compress and encrypt parts or the\
    \ whole\n   block of SDXF data.\n"
- title: 2. Description of SDXF data format.
  contents:
  - '2. Description of SDXF data format.

    '
- title: 2.1 First we introduce the term "chunk".  A chunk is a data structure
  contents:
  - "2.1 First we introduce the term \"chunk\".  A chunk is a data structure\n   \
    \ with a fixed set of components.  A chunk may be \"elementary\" or\n    \"structured\"\
    .  The latter one contains itself one or more other\n    chunks.\n   A chunk consists\
    \ of a header and the data body (content):\n   +----------+-----+-------+-----------------------------------+\n\
    \   | Name     | Pos.| Length| Description                       |\n   +----------+-----+-------+-----------------------------------+\n\
    \   | chunk-ID |  1  |   2   | ID of the chunk (unsigned short)  |\n   | flags\
    \    |  3  |   1   | type and properties of this chunk |\n   | length   |  4 \
    \ |   3   | length  of the following data     |\n   | content  |  7  |   *)  |\
    \ net data or a list of of chunks   |\n   +----------+-----+-------+-----------------------------------+\n\
    \   (* as stated in \"length\". total length of chunk is length+6.  The\n   chunk\
    \ ID is a non-zero positive number.\n   or more visually:\n   +----+----+----+----+----+----+----+----+----+-...\n\
    \   | chunkID | fl | length       |  content\n   +----+----+----+----+----+----+----+----+----+-...\n\
    \   or in ASN.1 syntax:\n   chunk  ::=  SEQUENCE\n   {\n     chunkID INTEGER (1..65535),\n\
    \     flags   BIT STRING,\n     length  OCTET STRING SIZE 3, -- or: INTEGER (0..16777215)\n\
    \     content OCTET STRING\n   }\n"
- title: 2.2 Structured chunk.
  contents:
  - "2.2 Structured chunk.\n   A structured chunk is marked as such by the flag byte\
    \ (see 2.5).\n   Opposed to an elementary chunk its content consists of a list\
    \ of\n   chunks (elementary or structured):\n   +----+-+---+-------+-------+-------+-----+-------+\n\
    \   | id |f|len| chunk | chunk | chunk | ... | chunk |\n   +----+-+---+-------+-------+-------+-----+-------+\n\
    \   With the help of this concept you can reproduce every hierarchically\n   structured\
    \ data into a SDXF chunk.\n"
- title: 2.3 Some Remarks about the internal representation of the chunk's
  contents:
  - "2.3 Some Remarks about the internal representation of the chunk's\n    elements:\n\
    \   Binary values are always in high-order-first (big endian) format,\n   like\
    \ the binary values in the IP header (network format).  A length\n   of 300 (=256\
    \ + 32 + 12) is stored as\n   +----+----+----+----+----+----+----+----+----+--\n\
    \   |         |    | 00   01   2C |  content\n   +----+----+----+----+----+----+----+----+----+--\n\
    \   in hexadecimal notation.\n   This is also valid for the chunk-ID.\n"
- title: 2.4 Character values in the content portion are also an object of
  contents:
  - "2.4 Character values in the content portion are also an object of\n    adaptation:\
    \ see chapter 4.\n"
- title: '2.5 Meaning of the flag-bits: Let us represent the flag byte in this'
  contents:
  - "2.5 Meaning of the flag-bits: Let us represent the flag byte in this\n    manner:\n\
    \     +-+-+-+-+-+-+-+-+\n     |0|1|2|3|4|5|6|7|\n     +-+-+-+-+-+-+-+-+\n    \
    \  | | | | | | | |\n      | | | | | | | +-- reserved\n      | | | | | | +----\
    \ array\n      | | | | | +------ short chunk\n      | | | | +-------- encrypted\
    \ chunk\n      | | | +---------- compressed chunk\n      | | |\n      +-+-+------------\
    \ data type (0..7)\n   data types are:\n   0 -- pending structure (chunk is inconsistent,\
    \ see also 11.1)\n   1 -- structure\n   2 -- bit string\n   3 -- numeric\n   4\
    \ -- character\n   5 -- float (ANSI/IEEE 754-1985)\n   6 -- UTF-8\n   7 -- reserved\n"
- title: 2.6 A short chunk has no data body.  The 3 byte Length field is used as
  contents:
  - "2.6 A short chunk has no data body.  The 3 byte Length field is used as\n   data\
    \ bytes instead.  This is used in order to save space when there\n   are many\
    \ small chunks.\n"
- title: 2.7 Compressed and encrypted chunks are explained in chapter 5 and 6.
  contents:
  - '2.7 Compressed and encrypted chunks are explained in chapter 5 and 6.

    '
- title: 2.8 Arrays are explained in chapter 7.
  contents:
  - '2.8 Arrays are explained in chapter 7.

    '
- title: 2.9 Handling of UTF-8 is explained in chapter 9.
  contents:
  - '2.9 Handling of UTF-8 is explained in chapter 9.

    '
- title: '2.10 Not all combinations of bits are allowed or reasonable:'
  contents:
  - "2.10 Not all combinations of bits are allowed or reasonable:\n   -  the flags\
    \ 'array' and 'short' are mutually exclusive.\n   -  'short' is not applicable\
    \ for data type 'structure' and 'float'.\n   -  'array' is not applicable for\
    \ data type 'structure'.\n"
- title: 3. Introduction to the SDXF functions
  contents:
  - '3. Introduction to the SDXF functions

    '
- title: 3.1 General remarks
  contents:
  - "3.1 General remarks\n   The functionality of the SDXF concept is not bounded\
    \ to any\n   programming language, but of course the functions themselves must\
    \ be\n   coded in a particular language.  I discuss these functions in C and\n\
    \   C++, because in the meanwhile these languages are available on almost\n  \
    \ all platforms.\n   All these functions for reading and writing SDXF chunks uses\
    \ only one\n   parameter, a parameter structure.  In C++ this parameter structure\
    \ is\n   part of the \"SDXF class\" and the SDXF functions are methods of this\n\
    \   class.\n   An exact description of the interface is given in chapter 8.\n"
- title: 3.2 Writing a SDXF buffer
  contents:
  - "3.2 Writing a SDXF buffer\n   For to write SDXF chunks, there are following functions:\n\
    \   init    -- initialize the parameter structure\n   create  -- create a new\
    \ chunk\n   leave   -- \"close\" a structured chunk\n"
- title: 3.3 Reading a SDXF buffer
  contents:
  - "3.3 Reading a SDXF buffer\n   For to read SDXF chunks, there are following functions:\n\
    \   init    -- initialize the parameter structure\n   enter   -- \"go into\" a\
    \ structured chunk\n   next    -- \"go to\" the next chunk inside a structured\
    \ chunk\n   extract -- extract the content of an elementary chunk into\n     \
    \         user's data area\n   leave   -- \"go out\" off a structured chunk\n"
- title: '3.4 Example:'
  contents:
  - '3.4 Example:

    '
- title: '3.4.1 Writing:'
  contents:
  - "3.4.1 Writing:\n   For demonstration we use a reduced (outlined) C++ Form of\
    \ these\n   functions with polymorph definitions:\n   void create (short chunkID);\
    \ // opens a new structure,\n   void create (short chunkID, char *string);\n \
    \       // creates a new chunk with dataType character, etc.)\n   The sequence:\n\
    \   SDXF x(new); // create the SDXF object \"x\" for a new chunk\n           \
    \     // includes the \"init\"\n   x.create (3301);   // opens a new structure\n\
    \   x.create (3302, \"first chunk\");\n   x.create (3303, \"second chunk\");\n\
    \   x.create (3304);   // opens a new structure\n   x.create (3305, \"chunk in\
    \ a structure\");\n   x.create (3306, \"next chunk in a structure\");\n   x.leave\
    \ ();        // closes the inner structure\n   x.create (3307, \"third chunk\"\
    );\n   x.leave ();        // closes the outer structure\n   creates a chunk which\
    \ we can show graphically like:\n   3301\n    |\n    +--- 3302 = \"first chunk\"\
    \n    |\n    +--- 3303 = \"second chunk\"\n    |\n    +--- 3304\n    |      |\n\
    \    |      +--- 3305 = \"chunk in a structure\"\n    |      |\n    |      +---\
    \ 3306 = \"next chunk in a structure\"\n    |\n    +--- 3307 = \"last chunk\"\n"
- title: 3.4.2 Reading
  contents:
  - "3.4.2 Reading\n   A typically access to a structured SDXF chunk is a selection\
    \ inside\n   a loop:\n   SDXF x(old); // defines a SDXF object \"x\" for an old\
    \ chunk\n   x.enter ();  // enters the structure\n   while (x.rc == 0) // 0 ==\
    \ ok, rc will set by the SDXF functions\n   {\n     switch (x.chunkID)\n     {\n\
    \       case 3302:\n         x.extract (data1, maxLength1);\n                \
    \   // extr. 1st chunk into data1\n         break;\n       case 3303:\n      \
    \   x.extract (data2, maxLength2);\n                   // extr. 2nd chunk into\
    \ data2\n         break;\n       case 3304:  // we know this is a structure\n\
    \         x.enter (); // enters the inner structure\n         while (x.rc == 0)\
    \ // inner loop\n         {\n           switch (x.chunkID)\n           {\n   \
    \          case 3305:\n               x.extract (data3, maxLength3);\n       \
    \                  // extr. the chunk inside struct.\n               break;\n\
    \             case 3306:\n               x.extract (data4, maxLength4);\n    \
    \                     // extr. 2nd chunk inside struct.\n               break;\n\
    \           }\n           x.next (); // returns x.rc == 1 at end of structure\n\
    \         } // end-while\n         break;\n       case 3307:\n         x.extract\
    \ (data5, maxLength5);\n                   // extract last chunk into data\n \
    \        break;\n       // default: none - ignore unknown chunks !!!\n     } //\
    \ end-switch\n     x.next (); // returns x.rc = 1 at end of structure\n   } //\
    \ end-while\n"
- title: 4. Platform independence
  contents:
  - "4. Platform independence\n   The very most of the computer platforms today have\
    \ a 8-Bits-in-a-Byte\n   architecture, which enables data exchange between these\
    \ platforms.\n   But there are two significant points in which platforms may be\n\
    \   different:\n   a) The representation of binary numerical (the short and long\
    \ int and\n      floats).\n   b) The representation of characters (ASCII/ANSI\
    \ vs. EBCDIC)\n   Point (a) is the phenomenon of \"byte swapping\": How is a short\
    \ int\n   value 259 = 0x0103 = X'0103' be stored at address 4402?\n   The two\
    \ flavours are:\n   4402 4403\n   01   03    the big-endian, and\n   03   01 \
    \   the little-endian.\n   Point (b) is represented by a table of the assignment\
    \ of the 256\n   possible values of a Byte to printable or control characters.\
    \  (In\n   ASCII the letter \"A\" is assigned to value (or position) 0x41 = 65,\
    \ in\n   EBCDIC it is 0xC1 = 193.)\n   The solution of these problems is to normalize\
    \ the data:\n   We fix:\n   (a) The internal representation of binary numerals\
    \ are 2-complements\n       in big-endian order.\n   (b) The internal representation\
    \ of characters is ISO 8859-1 (also\n       known as Latin 1).\n   The fixing\
    \ of point (b) should be regarded as a first strike.  In\n   some environment\
    \ 8859-1 seems not to be the best choice, in a greek\n   or russian environment\
    \ 8859-5 or 8859-7 are appropriate.\n   Nevertheless, in a specific group (or\
    \ world) of applications, that is\n   to say all the applications which wants\
    \ to interchange data with a\n   defined protocol (via networking or diskette\
    \ or something else), this\n   internal character table must be unique.\n   So\
    \ a possibility to define a translation table (and his inversion)\n   should be\
    \ given.\n   Important: You construct a SDXF chunk not for a specific addressee,\n\
    \   but you adapt your data into a normalized format (or network format).\n  \
    \ This adaption is not done by the programmer, it will be done by the\n   create\
    \ and extract function.  An administrator has take care of\n   defining the correct\
    \ translation tables.\n"
- title: 5. Compression
  contents:
  - "5. Compression\n   As stated in 2.5 there is a flag bit which declares that the\n\
    \   following data (elementary or structured) are compressed.  This data\n   is\
    \ not further interpretable until it is decompressed.  Compression\n   is transparently\
    \ done by the SDXF functions: \"create\" does the\n   compression for elementary\
    \ chunks, \"leave\" for structured chunks,\n   \"extract\" does the decompression\
    \ for elementary chunks, \"enter\" for\n   structured chunks.\n   Transparently\
    \ means that the programmer has only to tell the SDXF\n   functions that he want\
    \ compress the following chunk(s).\n   For choosing between different compression\
    \ methods and for\n   controlling the decompressed (original) length, there is\
    \ an\n   additional definition:\n   After the chunk header for a compressed chunk,\
    \ a compression header\n   is following:\n   +-----------------------+---------------+---------------->\n\
    \   |      chunk header     | compr. header | compressed data\n   +---+---+---+---+---+---+---+---+---+---+---------------->\n\
    \   |chunkID|flg|   length  |md | orglength |\n   +---+---+---+---+---+---+---+---+---+---+---------------->\n\
    \   -  'orglength' is the original (decompressed) length of the data.\n   -  'md'\
    \ is the \"compression method\": Two methods are described here:\n      #  method\
    \ 01 for a simple (fast but not very effective)\n         \"Run Length 1\" or\
    \ \"Byte Run 1\" algorithm.  (More then two\n         consecutive identical characters\
    \ are replaced by the number of\n         these characters and the character itself.)\n\
    \         more precisely:\n         The compressed data consists of several sections\
    \ of various\n         length.  Every section starts with a \"counter\" byte,\
    \ a signed\n         \"tiny\" (8 bit) integer, which contains a length information.\n\
    \         If this byte contains the value \"n\",\n         with n >= 0 (and n\
    \ <128), the next n+1 bytes will be taken\n         unchanged;\n         with\
    \ n < 0 (and n > -128), the next byte will be replicated\n         -n+1 times;\n\
    \         n = -128 will be ignored.\n         Appending blanks will be cutted\
    \ in general.  If these are\n         necessary, they can be reconstructed while\
    \ \"extract\"ing with\n         the parameter field \"filler\" (see 8.2.1) set\
    \ to space\n         character.\n      #  method 02 for the wonderful \"deflate\"\
    \ algorithm which comes\n         from the \"zip\"-people.\n         The authors\
    \ are:\n         Jean-loup Gailly (deflate routine),\n         Mark Adler (inflate\
    \ routine), and others.\n         The deflate format is described in [DEFLATE].\n\
    \      The values for the compression method number are maintained by\n      IANA,\
    \ see chap. 12.1.\n"
- title: 6. Encryption
  contents:
  - "6. Encryption\n   As stated in 2.5 there is a flag bit which declares that the\n\
    \   following data (elementary or structured) is encrypted.  This data is\n  \
    \ not interpretable until it is decrypted.  En/Decryption is\n   transparently\
    \ done by the SDXF functions, \"create\" does the\n   encryption for elementary\
    \ chunks, \"leave\" for structured chunks,\n   \"extract\" does the decryption\
    \ for elementary chunks, \"enter\" for\n   structured chunks.  (Yes it sounds\
    \ very similar to chapter 5.)  More\n   then one encryption method for a given\
    \ range of applications is not\n   very reasonable. Some encryption algorithms\
    \ work with block ciphering\n   algorithms. That means that the length of the\
    \ data to encrypt must be\n   rounded up to the next multiple of this block length.\
    \ This blocksize\n   (zero means non-blocking) is reported by the encryption interface\n\
    \   routine (addressed by the option field *encryptProc, see chapter 8.5)\n  \
    \ with mode=3. If blocking is used, at least one byte is added, the\n   last byte\
    \ of the lengthening data contains the number of added bytes\n   minus one. With\
    \ this the decryption interface routine can calculate\n   the real data length.\n\
    \   If an application (or network connect handshaking protocol) needs to\n   negotiate\
    \ an encryption method it should be used a method number\n   maintained by IANA,\
    \ see chap. 12.2.\n   Even the en/decryption is done transparently, an encryption\
    \ key\n   (password) must be given to the SDXF functions.  Encryption is done\n\
    \   after translating character data into, decryption is done before\n   translation\
    \ from the internal (\"network-\") format.\n   If both, encryption and compression\
    \ are applied on the same chunk,\n   compression is done first - compression on\
    \ good encrypted data (same\n   strings appears as different after encryption)\
    \ tends to zero\n   compression rates.\n"
- title: 7. Arrays
  contents:
  - "7. Arrays\n   An array is a sequence of chunks with identical chunk-ID, length\
    \ and\n   data type.\n   At first a hint: in principle a special definition in\
    \ SDXF for such\n   an array is not really necessary:\n   It is not forbidden\
    \ that there are more than one chunk with equal\n   chunk-ID within the same structured\
    \ chunk.\n   Therefore with a sequence of SDX_next / SDX_extract calls one can\n\
    \   fill the destination array step by step.\n   If there are many occurrences\
    \ of chunks with the same chunk-ID (and a\n   comparative small length), the overhead\
    \ of the chunk-packages may be\n   significant.\n   Therefore the array flag is\
    \ introduced.  An array chunk has only one\n   chunk header for the complete sequence\
    \ of elementary chunks.  After\n   the chunk header for an array chunk, an array\
    \ header is following:\n   This is a short integer (big endian!) which contains\
    \ the number of\n   the array elements (CT).  Every element has a fixed length\
    \ (EL), so\n   the chunklength (CL) is CL = EL * CT + 2.\n   The data elements\
    \ follows immediately after the array header.\n   The complete array will be constructed\
    \ by SDX_create, the complete\n   array will be read by SDX_extract.\n   The parameter\
    \ fields (see 8.2.1) 'dataLength' and 'count' are used\n   for the SDXF functions\
    \ 'extract' and 'create':\n   Field 'dataLength' is the common length of the array\
    \ elements,\n   'count' is the actual dimension of the array for 'create' (input).\n\
    \   For the 'extract' function 'count' acts both as an input and output\n   parameter:\n\
    \   Input : the maximum dimension\n   output: the actual array dimension.\n  \
    \ (If output count is greater than input count, the 'data cutted'\n   warning\
    \ will be responded and the destination array is filled up to\n   the maximum\
    \ dimension.)\n"
- title: 8. Description of the SDXF functions
  contents:
  - '8. Description of the SDXF functions

    '
- title: 8.1 Introduction
  contents:
  - "8.1 Introduction\n   Following the principles of Object Oriented Programming,\
    \ not only the\n   description of the data is necessary, but also the functions\
    \ which\n   manipulate data - the \"methods\".\n   For the programmer knowing\
    \ the methods is more important than knowing\n   the data structure, the methods\
    \ has to know the exact specifications\n   of the data and guarantees the consistence\
    \ of the data while creating\n   them.\n   A SDXF object is an instance of a parameter\
    \ structure which acts as a\n   programming interface.  Especially it points to\
    \ an actual SDXF data\n   chunk, and, while processing on this data, there is\
    \ a pointer to the\n   actual inner chunk which will be the focus for the next\
    \ operation.\n   The benefit of an exact interface description is the same as\
    \ using\n   for example the standard C library functions: By using standard\n\
    \   interfaces your code remains platform independent.\n"
- title: 8.2 Basic definitions
  contents:
  - '8.2 Basic definitions

    '
- title: 8.2.1 The SDXF Parameter structure
  contents:
  - "8.2.1 The SDXF Parameter structure\n   All SDXF access functions need only one\
    \ parameter, a pointer to the\n   SDXF parameter structure:\n   First 3 prerequisite\
    \ definitions:\n   typedef short int      ChunkID;\n   typedef unsigned char \
    \ Byte;\n   typedef struct Chunk\n   {\n     ChunkID    chunkID;\n     Byte  \
    \     flags;\n     char       length [3];\n     Byte       data;\n   } Chunk;\n\
    \   And now the parameter structure:\n   typedef struct\n   {\n     ChunkID  chunkID;\
    \       // name (ID) of Chunk\n     Byte    *container;     // pointer to the\
    \ whole Chunk\n     long     bufferSize;    // size of container\n     Chunk \
    \  *currChunk;     // pointer to actual Chunk\n     long     dataLength;    //\
    \ length of data in Chunk\n     long     maxLength;     // max. length of Chunk\
    \ for SDX_extract\n     long     remainingSize; // rem. size in cont. after SDX_create\n\
    \     long     value;         // for data type numeric\n     double   fvalue;\
    \        // for data type float\n     char    *function;      // name of the executed\
    \ SDXF function\n     Byte    *data;          // pointer to Data\n     Byte  \
    \  *cryptkey;      // pointer to Crypt Key\n     short    count;         // (max.)\
    \ number of elements in an array\n     short    dataType;      // Chunk data type\
    \ / init open type\n     short    ec;            // extended return-code\n   \
    \  short    rc;            // return-code\n     short    level;         // level\
    \ of hierarchy\n     char     filler;        // filler char for SDX_extract\n\
    \     Byte     encrypt;       // Indication if data to encrypt (0 / 1)\n     Byte\
    \     compression;   // compression method\n                             //  \
    \ (00=none, 01=RL1, 02=zip/deflate)\n   } SDX_obj, *SDX_handle;\n   Only the \"\
    public\" fields of the parameter structure which acts as\n   input and output\
    \ for the SDXF functions is described here.  A given\n   implementation may add\
    \ some \"private\" fields to this structure.\n"
- title: 8.2.2 Basic Functions
  contents:
  - "8.2.2 Basic Functions\n   All these functions works with a SDX_handle as the\
    \ only formal\n   parameter.  Every function returns as output ec and rc as a\
    \ report of\n   success.  For the values for ec, rc and dataType see chap. 8.4.\n\
    \    1. SDX_init : Initialize the parameter structure.\n         input : container,\
    \ dataType, bufferSize (for dataType =\n                 SDX_NEW only)\n     \
    \    output: currChunk, dataLength (for dataType = SDX_OLD only),\n          \
    \       ec, rc,\n                 the other fields of the parameter structure\
    \ will be\n                 initialized.\n    2. SDX_enter : Enter a structured\
    \ chunk.\n       You can access the first chunk inside this structured chunk.\n\
    \         input : none\n         output: currChunk, chunkID, dataLength, level,\
    \ dataType,\n                 ec, rc\n    3. SDX_leave : Leave the actual entered\
    \ structured chunk.\n         input : none\n         output: currChunk, chunkID,\
    \ dataLength, level, dataType,\n                 ec, rc\n    4. SDX_next : Go\
    \ to the next chunk inside a structured chunk.\n         input : none\n      \
    \   output: currChunk, chunkID, dataLength, dataType, count, ec, rc\n        At\
    \ the end of a structured chunk SDX_next returns rc =\n        SDX_RC_failed and\
    \ ec = SDX_EC_eoc (end of chunk)\n        The actual structured chunk is SDX_leave'd\
    \ automatically.\n    5. SDX_extract : Extract data of the actual chunk.\n   \
    \    (If actual chunk is structured, only a copy is done, elsewhere\n       the\
    \ data is converted to host format.)\n       input / output depends on the dataType:\n\
    \       if dataType is structured, binary or char:\n         input : data, maxLength,\
    \ count, filler\n         output: dataLength, count, ec, rc\n       if dataType\
    \ is numeric (float resp.):\n         input : none\n         output: value (fvalue\
    \ resp.), ec, rc\n    6. SDX_select : Go to the (next) chunk with a given chunkID.\n\
    \         input : chunkID\n         output: currChunk, dataLength, dataType, ec,\
    \ rc\n    7. SDX_create : Creating a new chunk (at the end of the actual\n   \
    \    structured chunk).\n         input : chunkID, dataLength, data, (f)value,\
    \ dataType,\n                 compression, encrypt, count\n         update: remainingSize,\
    \ level\n         output: currChunk, dataLength, ec, rc\n    8. SDX_append : Append\
    \ a complete chunk at the end of the actual\n       structured chunk).\n     \
    \    input : data, maxLength, currChunk\n         update: remainingSize, level\n\
    \         output: chunkID, chunkLength, maxLength, dataType, ec, rc\n"
- title: 8.3 Definitions for C++
  contents:
  - "8.3 Definitions for C++\n   This is the specification of the SDXF class in C++:\
    \ (The type 'Byte'\n   is defined as \"unsigned char\" for bitstrings, opposed\
    \ to \"signed\n   char\" for character strings)\n   class C_SDXF\n   {\n     public:\n\
    \     // constructors and destructor:\n     C_SDXF  ();                      \
    \    // dummy\n     C_SDXF  (Byte *cont);                // old container\n  \
    \   C_SDXF  (Byte *cont, long size);     // new container\n     C_SDXF  (long\
    \ size);                 // new container\n     ~C_SDXF ();\n     // methods:\n\
    \     void init  (void);                   // old container\n     void init  (Byte\
    \ *cont);             // old container\n     void init  (Byte *cont, long size);\
    \  // new container\n     void init  (long size);              // new container\n\
    \     void enter   (void);\n     void leave   (void);\n     void next    (void);\n\
    \     long extract (Byte *data, long length);    // chars, bits\n     long extract\
    \ (void);                       // numeric data\n     void create  (ChunkID);\
    \                    // structured\n     void create  (ChunkID, long value); \
    \       // numeric\n     void create  (ChunkID, double fvalue);     // float\n\
    \     void create  (ChunkID, Byte *data, long length);// binary\n     void create\
    \  (ChunkID, char *data);             // chars\n     void set_compression (Byte\
    \ compression_method);\n     void set_encryption  (Byte *encryption_key);\n  \
    \   // interface:\n     ChunkID  id;        // see 8.4.1\n     short    dataType;\
    \  // see 8.4.2\n     long     length;    // length of data or chunk\n     long\
    \     value;\n     double   fvalue;\n     short    rc;  // the raw return code\
    \       see 8.4.3\n     short    ec;  // the extended return code  see 8.4.4\n\
    \     protected:\n     // implementation dependent ...\n   };\n"
- title: '8.4 Common Definitions:'
  contents:
  - '8.4 Common Definitions:

    '
- title: '8.4.1 Definition of ChunkID:'
  contents:
  - "8.4.1 Definition of ChunkID:\n   typedef short ChunkID;\n"
- title: '8.4.2 Values for dataType:'
  contents:
  - "8.4.2 Values for dataType:\n   SDX_DT_inconsistent     = 0\n   SDX_DT_structured\
    \       = 1\n   SDX_DT_binary           = 2\n   SDX_DT_numeric          = 3\n\
    \   SDX_DT_char             = 4\n   SDX_DT_float            = 5\n   SDX_DT_UTF8\
    \             = 6\n    data types for SDX_init:\n   SDX_OLD                 =\
    \ 1\n   SDX_NEW                 = 2\n"
- title: '8.4.3 Values for rc:'
  contents:
  - "8.4.3 Values for rc:\n   SDX_RC_ok               = 0\n   SDX_RC_failed      \
    \     = 1\n   SDX_RC_warning          = 1\n   SDX_RC_illegalOperation = 2\n  \
    \ SDX_RC_dataError        = 3\n   SDX_RC_parameterError   = 4\n   SDX_RC_programError\
    \     = 5\n   SDX_RC_noMemory         = 6\n"
- title: '8.4.4 Values for ec:'
  contents:
  - "8.4.4 Values for ec:\n   SDX_EC_ok              =  0\n   SDX_EC_eoc         \
    \    =  1 // end of chunk\n   SDX_EC_notFound        =  2\n   SDX_EC_dataCutted\
    \      =  3\n   SDX_EC_overflow        =  4\n   SDX_EC_wrongInitType   =  5\n\
    \   SDX_EC_comprerr        =  6 // compression error\n   SDX_EC_forbidden    \
    \   =  7\n   SDX_EC_unknown         =  8\n   SDX_EC_levelOvflw      =  9\n   SDX_EC_paramMissing\
    \    = 10\n   SDX_EC_magicError      = 11\n   SDX_EC_not_consistent  = 12\n  \
    \ SDX_EC_wrongDataType   = 13\n   SDX_EC_noMemory        = 14\n   SDX_EC_error\
    \           = 99 // rc is sufficiently\n"
- title: 8.5 Special functions
  contents:
  - "8.5 Special functions\n   Besides the basic definitions there is a global function\n\
    \   (SDX_getOptions) which returns a pointer to a global table of\n   options.\n\
    \   With the help of these options you can adapt the behaviour of SDXF.\n   Especially\
    \ you can define an alternative pair of translation tables\n   or an alternative\
    \ function which reads these tables from an external\n   resource (p.e. from disk).\n\
    \   Within this table of options there is also a pointer to the function\n   which\
    \ is used for encryption / decryption: You can install your own\n   encryption\
    \ algorithm by setting this pointer.\n   The options pointer is received by:\n\
    \   SDX_TOptions *opt = SDX_getOptions ();\n   With:\n   typedef struct\n   {\n\
    \    Byte            *toHost;        // Trans tab net -> host\n    Byte      \
    \      *toNet;         // Trans tab host -> net\n    int              maxlevel;\
    \      // highest possible level\n    int              translation;   // translation\
    \ net <-> host\n                                    // is in effect=1 or not=0\n\
    \    TEncryptProc    *encryptProc;   // alternate encryption routine\n    TGetTablesProc\
    \  *getTablesProc; // alternate routine defining\n                           \
    \         // translation Tables\n    TcvtUTF8Proc    *convertUTF8;   // routine\
    \ to convert to/from UTF-8\n   }  SDX_TOptions;\n   typedef long TencryptProc\
    \ (\n     int   mode,   // 1= to encrypt, 2= to decrypt, 3= encrypted length\n\
    \     Byte *buffer, // data to en/decrypt\n     long  len,    // len: length of\
    \ buffer\n     char *passw); // Password\n    // returns length of en/de-crypted\
    \ data\n    // (parameter buffer and passw are ignored for mode=3)\n    // returns\
    \ blocksize for mode=3 and len=0.\n    // blocksize is zero for non-blocking algorithms\n\
    \   typedef int TGetTablesProc (Byte **toNet, Byte **toHost);\n    // toNet, toHost:\
    \ pointer to output params.  Both params\n    // points to translation tables\
    \ of 256 Bytes.\n    // returns success: 1 = ok, 0 = error.\n   typedef int TcvtUTF8Proc\n\
    \   ( int   mode,     // 1 = to UTF-8, 2 = from UTF-8\n     Byte *target, int\
    \ *targetlength,  // output\n     Byte *source, int sourcelength);  // input\n\
    \   // targetlength contains maximal size as input param.\n   // returns success:\
    \ 1 = ok, 0 = no conversion\n"
- title: 9. 'Support' of UTF-8.
  contents:
  - "9. 'Support' of UTF-8.\n   Many systems supports [UTF-8] as a character format\
    \ for transferred\n   data.  The benefit is that no fixing of a specific character\
    \ set for\n   an application is needed because the set of 'all' characters is\
    \ used,\n   represented by the 'Universal Character Set' UCS-2 [UCS], a double\n\
    \   byte coding for characters.\n   SDXF does not really deal with UTF-8 by itself,\
    \ there are many\n   possibilities to interprete an UTF-8 sequence:  The application\
    \ may:\n   -  reconstruct the UCS-2 sequence,\n   -  accepts only the pure ASCII\
    \ character and maps non-ASCII to a\n      special 'non-printable' character.\n\
    \   -  target is pure ASCII, non-ASCII is replaced in a senseful manner\n    \
    \  (French accented vowels replaced by vowels without accents, etc.).\n   -  target\
    \ is a specific ANSI character set, the non-ASCII chars are\n      mapped as possible,\
    \ other replaced to a 'non-printable'.\n   -  etc.\n   But SDXF offers an interface\
    \ for the 'extract' and 'create'\n   functions:\n   A function pointer may be\
    \ specified in the options table to maintain\n   this possibility (see 8.5). \
    \ Default for this pointer is NULL: No\n   further conversions are done by SDXF,\
    \ the data are copied 'as is', it\n   is treated as a bit string as for data type\
    \ 'binary'.\n   If this function is specified, it is used by the 'create' function\n\
    \   with the 'toUTF8' mode, and by the 'extract' function with the '\n   fromUTF8'\
    \ mode.  The invoking of these functions is done by SDXF\n   transparently.\n\
    \   If the function returns zero (no conversion) SDXF copies the data\n   without\
    \ conversion.\n"
- title: 10. Security Considerations
  contents:
  - "10. Security Considerations\n   Any corruption of data in the chunk headers denounce\
    \ the complete\n   SDXF structure.\n   Any corruption of data in a encrypted or\
    \ compressed SDXF structure\n   makes this chunk unusable.  An integrity check\
    \ after decryption or\n   decompression should be done by the \"enter\" function.\n\
    \   While using TCP/IP (more precisely: IP) as a transmission medium we\n   can\
    \ trust on his CRC check on the transport layer.\n"
- title: 11. Some general hints
  contents:
  - "11. Some general hints\n   1. A consistent construction of a SDXF structure is\
    \ done if every\n      \"create\" to a structured chunk is closed by a paired\
    \ \"leave\".\n      While a structured chunk is under construction, his data type\
    \ is\n      set to zero - that means: this chunk is inconsistent.  The\n     \
    \ SDX_leave function sets the datatype to \"structured\".\n   2. While creating\
    \ an elementary chunk a platform dependent\n      transformation to a platform\
    \ independent format of the data is\n      performed - at the end of construction\
    \ the content of the buffer\n      is ready to transport to another site, without\
    \ any further\n      translation.\n   3. As you see no data definition in your\
    \ programming language is\n      needed for to construct a specific SDXF structure.\
    \  The data is\n      created dynamically by function calls.\n   4. With SDXF\
    \ as a base you can define protocols for client / server\n      applications.\
    \  These protocols may be extended in downward\n      compatibility manner by\
    \ following two rules:\n      Rule 1: Ignore unknown chunkIDs.\n      Rule 2:\
    \ The sequence of chunks should not be significant.\n"
- title: 12. IANA Considerations
  contents:
  - "12. IANA Considerations\n   The compression and encryption algorithms for SDXF\
    \ is not fixed, SDXF\n   is open for various algorithms.  Therefore an agreement\
    \ is necessary\n   to interprete the compression and encryption algorithm method\n\
    \   numbers.  (Encryption methods are not a semantic part of SDXF, but\n   may\
    \ be used for a connection protocol to negotiate the encryption\n   method to\
    \ use.)\n   Following two items are registered by IANA:\n"
- title: 12.1 COMPRESSION METHODS FOR SDXF
  contents:
  - "12.1 COMPRESSION METHODS FOR SDXF\n   The compressed SDXF chunk starts with a\
    \ \"compression header\".  This\n   header contains the compression method as\
    \ an unsigned 1-Byte integer\n   (1-255).  These numbers are assigned by IANA\
    \ and listed here:\n   compression\n    method     Description               \
    \      Hints\n   ---------   ------------------------------- -------------\n \
    \        01    RUN-LENGTH algorithm            see chap. 5\n         02    DEFLATE\
    \ (ZIP)                   see [DEFLATE]\n     03-239    IANA to assign\n    240-255\
    \    private or application specific\n"
- title: 12.2 ENCRYPTION METHODS FOR SDXF
  contents:
  - "12.2 ENCRYPTION METHODS FOR SDXF\n   An unique encryption method is fixed or\
    \ negotiated by handshaking.\n   For the latter one a number for each encryption\
    \ method is necessary.\n   These numbers are unsigned 1-Byte integers (1-255).\
    \  These numbers\n   are assigned by IANA and listed here:\n   encryption\n  \
    \   method    Description\n    ---------  ------------------------------\n   \
    \  01-239    IANA to assign\n    240-255    private or application specific\n"
- title: '12.3 Hints for assigning a number:'
  contents:
  - "12.3 Hints for assigning a number:\n   Developers which want to register a compression\
    \ or encrypt method for\n   SDXF should contact IANA for a method number.  The\
    \ ASSIGNED NUMBERS\n   document should be referred to for a current list of METHOD\
    \ numbers\n   and their corresponding protocols, see [IANA].  The new method SHOULD\n\
    \   be a standard published as a RFC or by a established standardization\n   organization\
    \ (as OSI).\n"
- title: 13. Discussion
  contents:
  - "13. Discussion\n   There are already some standards for Internet data exchanging,\
    \ IETF\n   prefers ASN.1 and XML therefore.  So the reasons for establish a new\n\
    \   data format should be discussed.\n"
- title: 13.1 SDXF vs. ASN.1
  contents:
  - "13.1 SDXF vs. ASN.1\n   The demand of ASN.1 (see [ASN.1]) is to serve program\
    \ language\n   independent means to define data structures.  The real data format\n\
    \   which is used to send the data is not defined by ASN.1 but usually\n   BER\
    \ or PER (or some derivates of them like CER and DER) are used in\n   this context,\
    \ see [BER] and [PER].\n   The idea behind ASN.1 is: On every platform on which\
    \ a given\n   application is to develop descriptions of the used data structures\n\
    \   are available in ASN.1 notation.  Out off these notations the real\n   language\
    \ dependent definitions are generated with the help of an\n   ASN.1-compiler.\n\
    \   This compiler generates also transform functions for these data\n   structures\
    \ for to pack and unpack to and from the BER (or other)\n   format.\n   A direct\
    \ comparison between ASN.1 and SDXF is somehow inappropriate:\n   The data format\
    \ of SDXF is related rather to BER (and relatives).\n   The use of ASN.1 to define\
    \ data structures is no contradiction to\n   SDXF, but: SDXF does not require\
    \ a complete data structure to build\n   the message to send, nor a complete data\
    \ structure will be generated\n   out off the received message.\n   The main difference\
    \ lies in the concept of building and\n   interpretation of the message, I want\
    \ to name it the \"static\" and\n   \"dynamic\" concept:\n   o  ASN.1 uses a \"\
    static\" approach: The whole data structure must\n      exists before the message\
    \ can be created.\n   o  SDXF constructs and interpretes the message in a \"dynamic\"\
    \ way,\n      the message will be packed and unpacked step by step by SDXF\n \
    \     functions.\n   The use of static structures may be appropriate for a series\
    \ of\n   applications, but for complex tasks it is often impossible to define\n\
    \   the message as a whole.  As an example try to define an ASN.1\n   description\
    \ for a complex structured text document which is presented\n   in XML:  There\
    \ are sections and paragraphs and text elements which\n   may recursively consist\
    \ of sections with specific text attributes.\n"
- title: 13.2 SDXF vs. XML
  contents:
  - "13.2 SDXF vs. XML\n   On the one hand SDXF and XML are similar as they can handle\
    \ any\n   recursive complex data stream.  The main difference is the kind of\n\
    \   data which are to be maintained:\n   o  XML works with pure text data (though\
    \ it should be noted that the\n      character representation is not standardized\
    \ by XML).  And: a XML\n      document with all his tags is readable by human.\
    \  Binary data as\n      graphic is not included directly but may be referenced\
    \ by an\n      external link as in HTML.\n      In XML there is no strong separation\
    \ between informational and\n      control data, escape characters (like \"<\"\
    \ and \"&\") and the\n      <![CDATA[...]]> construction are used to distinguish\
    \ between these\n      two types of data.\n   o  SDXF maintains machine-readable\
    \ data, it is not designed to be\n      readable by human nor to edit SDXF data\
    \ with a text editor (even\n      more if compression and encryption is used).\
    \  With the help of the\n      SDXF functions you have a quick and easy access\
    \ to every data\n      element.  The standard parser for a SDXF data structure\
    \ follows\n      always a simple template, the \"while - switch -case ID -\n \
    \     enter/extract\" pattern as outlined in chap. 3.4.2.\n   Because of the complete\
    \ different philosophy behind XML and SDXF (and\n   even ASN.1) a direct comparison\
    \ may not be very senseful, as XML has\n   its own right to exist next to ASN.1\
    \ (and even SDXF).\n   Nevertheless there is a chance to convert a XML data stream\
    \ into a\n   SDXF structure:  As a first strike, every XML tag becomes a SDXF\n\
    \   chunk ID.  An elementary sequence <tag>pure text</tag> can be\n   transformed\
    \ into an elementary (non-structured) chunk with data type\n   \"character\".\
    \  Tags with attributes and sequences with nested tags are\n   transformed into\
    \ structured chunks.  Because XML allows a tag\n   sequence everywhere in a text\
    \ stream, an artificially \"elementary\n   text\" tag must be introduced:\n  \
    \ If <t> is the tag for text elements, the sequence:\n   <t>this is a text <attr\
    \ value='bold'>with</attr> attributes</t>\n   is to be \"in thought\" replaced\
    \ by:\n   <t><et>this is a text </et><attr value='bold'><et>with</et></attr>\n\
    \   <et> attributes</et></t>\n   (With \"et\" as the \"elementary text\" tag)\n\
    \   This results in following SDXF structure:\n   ID_t\n   |\n   +-- ID_et = \"\
    \ this is a text \"\n   |\n   +-- ID_attr\n   |   |\n   |   +-- ID_value = \"\
    bold\"\n   |   |\n   |   +-- ID_et = \"with\"\n   |\n   +-- ID_et = \" attributes\"\
    \n   ID_t and ID_et may be represented by the same chunk ID, only\n   distinguished\
    \ by the data type (\"structured\" for <t> and \"character\"\n   for <et>)\n \
    \  Binary data as pictures can be directly imbedded into a SDXF\n   structure\
    \ instead referencing them as an external link like in HTML.\n"
- title: 14. Author's Address
  contents:
  - "14. Author's Address\n   Max Wildgrube\n   Schlossstrasse 120\n   60486 Frankfurt\n\
    \   Germany\n   EMail: max@wildgrube.com\n"
- title: 15. Acknowledgements
  contents:
  - "15. Acknowledgements\n   I would like to thank Michael J. Slifcak (mslifcak@iss.net)\
    \ for the\n   supporting discussions.\n"
- title: 16. References
  contents:
  - "16. References\n   [ASN.1]   Information processing systems - Open Systems\n\
    \             Interconnection, \"Specification of Abstract Syntax Notation\n \
    \            One (ASN.1)\", International Organization for\n             Standardization,\
    \ International Standard 8824, December\n             1987.\n   [BER]     Information\
    \ Processing Systems - Open Systems\n             Interconnection - \"Specification\
    \ of Basic Encoding Rules\n             for Abstract Notation One (ASN.1)\", International\n\
    \             Organization for Standardization, International Standard\n     \
    \        8825-1, December 1987.\n   [DEFLATE] Deutsch, P., \"DEFLATE Compressed\
    \ Data Format Specification\n             version 1.3\", RFC 1951, May 1996.\n\
    \   [IANA]    Internet Assigned Numbers Authority,\n             http://www.iana.org/numbers.htm\n\
    \   [PER]     Information Processing Systems  - Open Systems\n             Interconnection\
    \ -\"Specification of Packed Encoding Rules\n             for Abstract Syntax\
    \ Notation One (ASN.1)\", International\n             Organization for Standardization,\
    \ International Standard\n             8825-2.\n   [UCS]     ISO/IEC 10646-1:1993.\
    \ International Standard -- Information\n             technology -- Universal\
    \ Multiple-Octet Coded Character Set\n             (UCS)\n   [UTF8]    Yergeau,\
    \ F., \"UTF-8, a transformation format of ISO 10646\",\n             RFC 2279,\
    \ January 1998.\n"
- title: 17.  Full Copyright Statement
  contents:
  - "17.  Full Copyright Statement\n   Copyright (C) The Internet Society (2001).\
    \  All Rights Reserved.\n   This document and translations of it may be copied\
    \ and furnished to\n   others, and derivative works that comment on or otherwise\
    \ explain it\n   or assist in its implementation may be prepared, copied, published\n\
    \   and distributed, in whole or in part, without restriction of any\n   kind,\
    \ provided that the above copyright notice and this paragraph are\n   included\
    \ on all such copies and derivative works.  However, this\n   document itself\
    \ may not be modified in any way, such as by removing\n   the copyright notice\
    \ or references to the Internet Society or other\n   Internet organizations, except\
    \ as needed for the purpose of\n   developing Internet standards in which case\
    \ the procedures for\n   copyrights defined in the Internet Standards process\
    \ must be\n   followed, or as required to translate it into languages other than\n\
    \   English.\n   The limited permissions granted above are perpetual and will\
    \ not be\n   revoked by the Internet Society or its successors or assigns.\n \
    \  This document and the information contained herein is provided on an\n   \"\
    AS IS\" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING\n   TASK FORCE\
    \ DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING\n   BUT NOT LIMITED\
    \ TO ANY WARRANTY THAT THE USE OF THE INFORMATION\n   HEREIN WILL NOT INFRINGE\
    \ ANY RIGHTS OR ANY IMPLIED WARRANTIES OF\n   MERCHANTABILITY OR FITNESS FOR A\
    \ PARTICULAR PURPOSE.\n"
- title: Acknowledgement
  contents:
  - "Acknowledgement\n   Funding for the RFC Editor function is currently provided\
    \ by the\n   Internet Society.\n"
