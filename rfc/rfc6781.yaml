- title: __initial_text__
  contents:
  - '                DNSSEC Operational Practices, Version 2

    '
- title: Abstract
  contents:
  - "Abstract\n   This document describes a set of practices for operating the DNS\
    \ with\n   security extensions (DNSSEC).  The target audience is zone\n   administrators\
    \ deploying DNSSEC.\n   The document discusses operational aspects of using keys\
    \ and\n   signatures in the DNS.  It discusses issues of key generation, key\n\
    \   storage, signature generation, key rollover, and related policies.\n   This\
    \ document obsoletes RFC 4641, as it covers more operational\n   ground and gives\
    \ more up-to-date requirements with respect to key\n   sizes and the DNSSEC operations.\n"
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This document is not an Internet Standards Track specification;\
    \ it is\n   published for informational purposes.\n   This document is a product\
    \ of the Internet Engineering Task Force\n   (IETF).  It represents the consensus\
    \ of the IETF community.  It has\n   received public review and has been approved\
    \ for publication by the\n   Internet Engineering Steering Group (IESG).  Not\
    \ all documents\n   approved by the IESG are a candidate for any level of Internet\n\
    \   Standard; see Section 2 of RFC 5741.\n   Information about the current status\
    \ of this document, any errata,\n   and how to provide feedback on it may be obtained\
    \ at\n   http://www.rfc-editor.org/info/rfc6781.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (c) 2012 IETF Trust and the persons identified\
    \ as the\n   document authors.  All rights reserved.\n   This document is subject\
    \ to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n\
    \   (http://trustee.ietf.org/license-info) in effect on the date of\n   publication\
    \ of this document.  Please review these documents\n   carefully, as they describe\
    \ your rights and restrictions with respect\n   to this document.  Code Components\
    \ extracted from this document must\n   include Simplified BSD License text as\
    \ described in Section 4.e of\n   the Trust Legal Provisions and are provided\
    \ without warranty as\n   described in the Simplified BSD License.\n   This document\
    \ may contain material from IETF Documents or IETF\n   Contributions published\
    \ or made publicly available before November\n   10, 2008.  The person(s) controlling\
    \ the copyright in some of this\n   material may not have granted the IETF Trust\
    \ the right to allow\n   modifications of such material outside the IETF Standards\
    \ Process.\n   Without obtaining an adequate license from the person(s) controlling\n\
    \   the copyright in such materials, this document may not be modified\n   outside\
    \ the IETF Standards Process, and derivative works of it may\n   not be created\
    \ outside the IETF Standards Process, except to format\n   it for publication\
    \ as an RFC or to translate it into languages other\n   than English.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1. Introduction ....................................................4\n\
    \      1.1. The Use of the Term 'key' ..................................5\n  \
    \    1.2. Time Definitions ...........................................6\n   2.\
    \ Keeping the Chain of Trust Intact ...............................6\n   3. Key\
    \ Generation and Storage ......................................7\n      3.1. Operational\
    \ Motivation for Zone Signing Keys and\n           Key Signing Keys ...........................................8\n\
    \      3.2. Practical Consequences of KSK and ZSK Separation ..........10\n  \
    \         3.2.1. Rolling a KSK That Is Not a Trust Anchor ...........10\n    \
    \       3.2.2. Rolling a KSK That Is a Trust Anchor ...............11\n      \
    \     3.2.3. The Use of the SEP Flag ............................12\n      3.3.\
    \ Key Effectivity Period ....................................12\n      3.4. Cryptographic\
    \ Considerations ..............................14\n           3.4.1. Signature\
    \ Algorithm ................................14\n           3.4.2. Key Sizes ..........................................14\n\
    \           3.4.3. Private Key Storage ................................16\n  \
    \         3.4.4. Key Generation .....................................17\n    \
    \       3.4.5. Differentiation for 'High-Level' Zones? ............17\n   4. Signature\
    \ Generation, Key Rollover, and Related Policies .......18\n      4.1. Key Rollovers\
    \ .............................................18\n           4.1.1. Zone Signing\
    \ Key Rollovers .........................18\n                  4.1.1.1. Pre-Publish\
    \ Zone Signing Key Rollover .....19\n                  4.1.1.2. Double-Signature\
    \ Zone Signing Key Rollover 21\n                  4.1.1.3. Pros and Cons of the\
    \ Schemes ..............23\n           4.1.2. Key Signing Key Rollovers ..........................23\n\
    \                  4.1.2.1. Special Considerations for RFC 5011\n            \
    \               KSK Rollover ..............................26\n           4.1.3.\
    \ Single-Type Signing Scheme Key Rollover ............26\n           4.1.4. Algorithm\
    \ Rollovers ................................28\n                  4.1.4.1. Single-Type\
    \ Signing Scheme\n                           Algorithm Rollover ........................32\n\
    \                  4.1.4.2. Algorithm Rollover, RFC 5011 Style ........32\n  \
    \                4.1.4.3. Single Signing Type Algorithm\n                    \
    \       Rollover, RFC 5011 Style ..................33\n                  4.1.4.4.\
    \ NSEC-to-NSEC3 Algorithm Rollover ..........34\n           4.1.5. Considerations\
    \ for Automated Key Rollovers .........34\n      4.2. Planning for Emergency Key\
    \ Rollover .......................35\n           4.2.1. KSK Compromise .....................................35\n\
    \                  4.2.1.1. Emergency Key Rollover Keeping the\n             \
    \              Chain of Trust Intact .....................36\n               \
    \   4.2.1.2. Emergency Key Rollover Breaking\n                           the Chain\
    \ of Trust ........................37\n           4.2.2. ZSK Compromise .....................................37\n\
    \           4.2.3. Compromises of Keys Anchored in Resolvers ..........38\n  \
    \         4.2.4. Stand-By Keys ......................................38\n    \
    \  4.3. Parent Policies ...........................................39\n      \
    \     4.3.1. Initial Key Exchanges and Parental Policies\n                  Considerations\
    \ .....................................39\n           4.3.2. Storing Keys or Hashes?\
    \ ............................40\n           4.3.3. Security Lameness ..................................40\n\
    \           4.3.4. DS Signature Validity Period .......................41\n  \
    \         4.3.5. Changing DNS Operators .............................42\n    \
    \              4.3.5.1. Cooperating DNS Operators .................42\n      \
    \            4.3.5.2. Non-Cooperating DNS Operators .............44\n      4.4.\
    \ Time in DNSSEC ............................................46\n           4.4.1.\
    \ Time Considerations ................................46\n           4.4.2. Signature\
    \ Validity Periods .........................48\n                  4.4.2.1. Maximum\
    \ Value .............................48\n                  4.4.2.2. Minimum Value\
    \ .............................49\n                  4.4.2.3. Differentiation\
    \ between RRsets ............50\n   5. \"Next Record\" Types ............................................51\n\
    \      5.1. Differences between NSEC and NSEC3 ........................51\n  \
    \    5.2. NSEC or NSEC3 .............................................52\n    \
    \  5.3. NSEC3 Parameters ..........................................53\n      \
    \     5.3.1. NSEC3 Algorithm ....................................53\n        \
    \   5.3.2. NSEC3 Iterations ...................................53\n          \
    \ 5.3.3. NSEC3 Salt .........................................54\n           5.3.4.\
    \ Opt-Out ............................................54\n   6. Security Considerations\
    \ ........................................54\n   7. Acknowledgments ................................................55\n\
    \   8. Contributors ...................................................55\n  \
    \ 9. References .....................................................56\n    \
    \  9.1. Normative References ......................................56\n      9.2.\
    \ Informative References ....................................56\n   Appendix A.\
    \ Terminology ...........................................59\n   Appendix B. Typographic\
    \ Conventions ...............................61\n   Appendix C. Transition Figures\
    \ for Special Cases of Algorithm\n               Rollovers .............................................64\n\
    \   Appendix D. Transition Figure for Changing DNS Operators ..........68\n  \
    \ Appendix E. Summary of Changes from RFC 4641 ......................70\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   This document describes how to run a DNS Security (DNSSEC)-enabled\n\
    \   environment.  It is intended for operators who have knowledge of the\n   DNS\
    \ (see RFC 1034 [RFC1034] and RFC 1035 [RFC1035]) and want to\n   deploy DNSSEC\
    \ (RFC 4033 [RFC4033], RFC 4034 [RFC4034], RFC 4035\n   [RFC4035], and RFC 5155\
    \ [RFC5155]).  The focus of the document is on\n   serving authoritative DNS information\
    \ and is aimed at zone owners,\n   name server operators, registries, registrars,\
    \ and registrants.  It\n   assumes that there is no direct relationship between\
    \ those entities\n   and the operators of validating recursive name servers (validators).\n\
    \   During workshops and early operational deployment, operators and\n   system\
    \ administrators have gained experience about operating the DNS\n   with security\
    \ extensions (DNSSEC).  This document translates these\n   experiences into a\
    \ set of practices for zone administrators.\n   Although the DNS Root has been\
    \ signed since July 15, 2010 and now\n   more than 80 secure delegations are provisioned\
    \ in the root, at the\n   time of this writing there still exists relatively little\
    \ experience\n   with DNSSEC in production environments below the Top-Level Domain\n\
    \   (TLD) level; this document should therefore explicitly not be seen as\n  \
    \ representing 'Best Current Practices'.  Instead, it describes the\n   decisions\
    \ that should be made when deploying DNSSEC, gives the\n   choices available for\
    \ each one, and provides some operational\n   guidelines.  The document does not\
    \ give strong recommendations.  That\n   may be the subject for a future version\
    \ of this document.\n   The procedures herein are focused on the maintenance of\
    \ signed zones\n   (i.e., signing and publishing zones on authoritative servers).\
    \  It is\n   intended that maintenance of zones, such as re-signing or key\n \
    \  rollovers, be transparent to any verifying clients.\n   The structure of this\
    \ document is as follows.  In Section 2, we\n   discuss the importance of keeping\
    \ the \"chain of trust\" intact.\n   Aspects of key generation and storage of\
    \ keys are discussed in\n   Section 3; the focus in this section is mainly on\
    \ the security of the\n   private part of the key(s).  Section 4 describes considerations\n\
    \   concerning the public part of the keys.  Sections 4.1 and 4.2 deal\n   with\
    \ the rollover, or replacement, of keys.  Section 4.3 discusses\n   considerations\
    \ on how parents deal with their children's public keys\n   in order to maintain\
    \ chains of trust.  Section 4.4 covers all kinds\n   of timing issues around key\
    \ publication.  Section 5 covers the\n   considerations regarding selecting and\
    \ using the NSEC or NSEC3\n   [RFC5155] Resource Record.\n   The typographic conventions\
    \ used in this document are explained in\n   Appendix B.\n   Since we describe\
    \ operational suggestions and there are no protocol\n   specifications, the RFC\
    \ 2119 [RFC2119] language does not apply to\n   this document, though we do use\
    \ quotes from other documents that do\n   include the RFC 2119 language.\n   This\
    \ document obsoletes RFC 4641 [RFC4641].\n"
- title: 1.1.  The Use of the Term 'key'
  contents:
  - "1.1.  The Use of the Term 'key'\n   It is assumed that the reader is familiar\
    \ with the concept of\n   asymmetric cryptography, or public-key cryptography,\
    \ on which DNSSEC\n   is based (see the definition of 'asymmetric cryptography'\
    \ in RFC 4949\n   [RFC4949]).  Therefore, this document will use the term 'key'\
    \ rather\n   loosely.  Where it is written that 'a key is used to sign data',\
    \ it\n   is assumed that the reader understands that it is the private part of\n\
    \   the key pair that is used for signing.  It is also assumed that the\n   reader\
    \ understands that the public part of the key pair is published\n   in the DNSKEY\
    \ Resource Record (DNSKEY RR) and that it is the public\n   part that is used\
    \ in signature verification.\n"
- title: 1.2.  Time Definitions
  contents:
  - "1.2.  Time Definitions\n   In this document, we will be using a number of time-related\
    \ terms.\n   The following definitions apply:\n   Signature validity period: \
    \ The period that a signature is valid.  It\n      starts at the (absolute) time\
    \ specified in the signature inception\n      field of the RRSIG RR and ends at\
    \ the (absolute) time specified in\n      the expiration field of the RRSIG RR.\
    \  The document sometimes also\n      uses the term 'validity period', which means\
    \ the same.\n   Signature publication period:  The period that a signature is\n\
    \      published.  It starts at the time the signature is introduced in\n    \
    \  the zone for the first time and ends at the time when the\n      signature\
    \ is removed or replaced with a new signature.  After one\n      stops publishing\
    \ an RRSIG in a zone, it may take a while before\n      the RRSIG has expired\
    \ from caches and has actually been removed\n      from the DNS.\n   Key effectivity\
    \ period:  The period during which a key pair is\n      expected to be effective.\
    \  It is defined as the time between the\n      earliest inception time stamp\
    \ and the last expiration date of any\n      signature made with this key, regardless\
    \ of any discontinuity in\n      the use of the key.  The key effectivity period\
    \ can span multiple\n      signature validity periods.\n   Maximum/Minimum Zone\
    \ Time to Live (TTL):  The maximum or minimum\n      value of the TTLs from the\
    \ complete set of RRs in a zone, that are\n      used by validators or resolvers.\
    \  Note that the minimum TTL is not\n      the same as the MINIMUM field in the\
    \ SOA RR.  See RFC 2308\n      [RFC2308] for more information.\n"
- title: 2.  Keeping the Chain of Trust Intact
  contents:
  - "2.  Keeping the Chain of Trust Intact\n   Maintaining a valid chain of trust\
    \ is important because broken chains\n   of trust will result in data being marked\
    \ as Bogus (as defined in\n   RFC 4033 [RFC4033] Section 5), which may cause entire\
    \ (sub)domains to\n   become invisible to verifying clients.  The administrators\
    \ of secured\n   zones need to realize that, to verifying clients, their zone\
    \ is part\n   of a chain of trust.\n   As mentioned in the introduction, the procedures\
    \ herein are intended\n   to ensure that maintenance of zones, such as re-signing\
    \ or key\n   rollovers, will be transparent to the verifying clients on the\n\
    \   Internet.\n   Administrators of secured zones will need to keep in mind that\
    \ data\n   published on an authoritative primary server will not be immediately\n\
    \   seen by verifying clients; it may take some time for the data to be\n   transferred\
    \ to other (secondary) authoritative name servers and\n   clients may be fetching\
    \ data from caching non-authoritative servers.\n   In this light, note that the\
    \ time until the data is available on the\n   slave can be negligible when using\
    \ NOTIFY [RFC1996] and Incremental\n   Zone Transfer (IXFR) [RFC1995].  It increases\
    \ when Authoritative\n   (full) Zone Transfers (AXFRs) are used in combination\
    \ with NOTIFY.\n   It increases even more if you rely on the full zone transfers\
    \ being\n   based only on the SOA timing parameters for refresh.\n   For the verifying\
    \ clients, it is important that data from secured\n   zones can be used to build\
    \ chains of trust, regardless of whether the\n   data came directly from an authoritative\
    \ server, a caching name\n   server, or some middle box.  Only by carefully using\
    \ the available\n   timing parameters can a zone administrator ensure that the\
    \ data\n   necessary for verification can be obtained.\n   The responsibility\
    \ for maintaining the chain of trust is shared by\n   administrators of secured\
    \ zones in the chain of trust.  This is most\n   obvious in the case of a 'key\
    \ compromise' when a tradeoff must be\n   made between maintaining a valid chain\
    \ of trust and replacing the\n   compromised keys as soon as possible.  Then zone\
    \ administrators will\n   have to decide between keeping the chain of trust intact\
    \ -- thereby\n   allowing for attacks with the compromised key -- or deliberately\n\
    \   breaking the chain of trust and making secured subdomains invisible\n   to\
    \ security-aware resolvers (also see Section 4.2).\n"
- title: 3.  Key Generation and Storage
  contents:
  - "3.  Key Generation and Storage\n   This section describes a number of considerations\
    \ with respect to the\n   use of keys.  For the design of an operational procedure\
    \ for key\n   generation and storage, a number of decisions need to be made:\n\
    \   o  Does one differentiate between Zone Signing Keys and Key Signing\n    \
    \  Keys or is the use of one type of key sufficient?\n   o  Are Key Signing Keys\
    \ (likely to be) in use as trust anchors\n      [RFC4033]?\n   o  What are the\
    \ timing parameters that are allowed by the operational\n      requirements?\n\
    \   o  What are the cryptographic parameters that fit the operational\n      need?\n\
    \   The following section discusses the considerations that need to be\n   taken\
    \ into account when making those choices.\n"
- title: 3.1.  Operational Motivation for Zone Signing Keys and Key Signing Keys
  contents:
  - "3.1.  Operational Motivation for Zone Signing Keys and Key Signing Keys\n   The\
    \ DNSSEC validation protocol does not distinguish between different\n   types\
    \ of DNSKEYs.  The motivations to differentiate between keys are\n   purely operational;\
    \ validators will not make a distinction.\n   For operational reasons, described\
    \ below, it is possible to designate\n   one or more keys to have the role of\
    \ Key Signing Keys (KSKs).  These\n   keys will only sign the apex DNSKEY RRset\
    \ in a zone.  Other keys can\n   be used to sign all the other RRsets in a zone\
    \ that require\n   signatures.  They are referred to as Zone Signing Keys (ZSKs).\
    \  In\n   cases where the differentiation between the KSK and ZSK is not made,\n\
    \   i.e., where keys have the role of both KSK and ZSK, we talk about a\n   Single-Type\
    \ Signing Scheme.\n   If the two functions are separated, then for almost any\
    \ method of key\n   management and zone signing, the KSK is used less frequently\
    \ than the\n   ZSK.  Once a DNSKEY RRset is signed with the KSK, all the keys\
    \ in the\n   RRset can be used as ZSKs.  If there has been an event that increases\n\
    \   the risk that a ZSK is compromised, it can be simply replaced with a\n   ZSK\
    \ rollover.  The new RRset is then re-signed with the KSK.\n   Changing a key\
    \ that is a Secure Entry Point (SEP) [RFC4034] for a\n   zone can be relatively\
    \ expensive, as it involves interaction with\n   third parties: When a key is\
    \ only pointed to by a Delegation Signer\n   (DS) [RFC4034] record in the parent\
    \ zone, one needs to complete the\n   interaction with the parent and wait for\
    \ the updated DS record to\n   appear in the DNS.  In the case where a key is\
    \ configured as a trust\n   anchor, one has to wait until one has sufficient confidence\
    \ that all\n   trust anchors have been replaced.  In fact, it may be that one\
    \ is not\n   able to reach the complete user-base with information about the key\n\
    \   rollover.\n   Given the assumption that for KSKs the SEP flag is set, the\
    \ KSK can\n   be distinguished from a ZSK by examining the flag field in the DNSKEY\n\
    \   RR: If the flag field is an odd number, it is a KSK; otherwise, it is\n  \
    \ a ZSK.\n   There is also a risk that keys can be compromised through theft or\n\
    \   loss.  For keys that are installed on file-systems of name servers\n   that\
    \ are connected to the network (e.g., for dynamic updates), that\n   risk is relatively\
    \ high.  Where keys are stored on Hardware Security\n   Modules (HSMs) or stored\
    \ off-line, such risk is relatively low.\n   However, storing keys off-line or\
    \ with more limitations on access\n   control has a negative effect on the operational\
    \ flexibility.  By\n   separating the KSK and ZSK functionality, these risks can\
    \ be managed\n   while making the tradeoff against the involved costs.  For example,\
    \ a\n   KSK can be stored off-line or with more limitations on access control\n\
    \   than ZSKs, which need to be readily available for operational\n   purposes\
    \ such as the addition or deletion of zone data.  A KSK stored\n   on a smartcard\
    \ that is kept in a safe, combined with a ZSK stored on\n   a file-system accessible\
    \ by operators for daily routine use, may\n   provide better protection against\
    \ key compromise without losing much\n   operational flexibility.  It must be\
    \ said that some HSMs give the\n   option to have your keys online, giving more\
    \ protection and hardly\n   affecting the operational flexibility.  In those cases,\
    \ a KSK-ZSK\n   split is not more beneficial than the Single-Type Signing Scheme.\n\
    \   It is worth mentioning that there's not much point in obsessively\n   protecting\
    \ the key if you don't protect the zone files, which also\n   live on the file-systems.\n\
    \   Finally, there is a risk of cryptanalysis of the key material.  The\n   costs\
    \ of such analysis are correlated to the length of the key.\n   However, cryptanalysis\
    \ arguments provide no strong motivation for a\n   KSK/ZSK split.  Suppose one\
    \ differentiates between a KSK and a ZSK,\n   whereby the KSK effectivity period\
    \ is X times the ZSK effectivity\n   period.  Then, in order for the resistance\
    \ to cryptanalysis to be the\n   same for the KSK and the ZSK, the KSK needs to\
    \ be X times stronger\n   than the ZSK.  Since for all practical purposes X will\
    \ be somewhere\n   on the order of 10 to 100, the associated key sizes will vary\
    \ only by\n   about a byte in size for symmetric keys.  When translated to\n \
    \  asymmetric keys, the size difference is still too insignificant to\n   warrant\
    \ a key-split; it only marginally affects the packet size and\n   signing speed.\n\
    \   The arguments for differentiation between the ZSK and KSK are weakest\n  \
    \ when:\n   o  the exposure to risk is low (e.g., when keys are stored on HSMs);\n\
    \   o  one can be certain that a key is not used as a trust anchor;\n   o  maintenance\
    \ of the various keys cannot be performed through tools\n      (is prone to human\
    \ error); and\n   o  the interaction through the child-parent provisioning chain\
    \ -- in\n      particular, the timely appearance of a new DS record in the parent\n\
    \      zone in emergency situations -- is predictable.\n   If the above arguments\
    \ hold, then the costs of the operational\n   complexity of a KSK-ZSK split may\
    \ outweigh the costs of operational\n   flexibility, and choosing a Single-Type\
    \ Signing Scheme is a\n   reasonable option.  In other cases, we advise that the\
    \ separation\n   between KSKs and ZSKs is made.\n"
- title: 3.2.  Practical Consequences of KSK and ZSK Separation
  contents:
  - "3.2.  Practical Consequences of KSK and ZSK Separation\n   A key that acts only\
    \ as a Zone Signing Key is used to sign all the\n   data except the DNSKEY RRset\
    \ in a zone on a regular basis.  When a\n   ZSK is to be rolled, no interaction\
    \ with the parent is needed.  This\n   allows for a relatively short key effectivity\
    \ period.\n   A key with only the Key Signing Key role is to be used to sign the\n\
    \   DNSKEY RRs in a zone.  If a KSK is to be rolled, there may be\n   interactions\
    \ with other parties.  These can include the\n   administrators of the parent\
    \ zone or administrators of verifying\n   resolvers that have the particular key\
    \ configured as secure entry\n   points.  In the latter case, everyone relying\
    \ on the trust anchor\n   needs to roll over to the new key, a process that may\
    \ be subject to\n   stability costs if automated trust anchor rollover mechanisms\
    \ (e.g.,\n   RFC 5011 [RFC5011]) are not in place.  Hence, the key effectivity\n\
    \   period of these keys can and should be made much longer.\n"
- title: 3.2.1.  Rolling a KSK That Is Not a Trust Anchor
  contents:
  - "3.2.1.  Rolling a KSK That Is Not a Trust Anchor\n   There are three schools\
    \ of thought on rolling a KSK that is not a\n   trust anchor:\n   1.  It should\
    \ be done frequently and regularly (possibly every few\n       months), so that\
    \ a key rollover remains an operational routine.\n   2.  It should be done frequently\
    \ but irregularly.  \"Frequently\" means\n       every few months, again based\
    \ on the argument that a rollover is\n       a practiced and common operational\
    \ routine; \"irregular\" means\n       with a large jitter, so that third parties\
    \ do not start to rely\n       on the key and will not be tempted to configure\
    \ it as a trust\n       anchor.\n   3.  It should only be done when it is known\
    \ or strongly suspected\n       that the key can be or has been compromised, or\
    \ in conjunction\n       with operator change policies and procedures, like when\
    \ a new\n       algorithm or key storage is required.\n   There is no widespread\
    \ agreement on which of these three schools of\n   thought is better for different\
    \ deployments of DNSSEC.  There is a\n   stability cost every time a non-anchor\
    \ KSK is rolled over, but it is\n   possibly low if the communication between\
    \ the child and the parent is\n   good.  On the other hand, the only completely\
    \ effective way to tell\n   if the communication is good is to test it periodically.\
    \  Thus,\n   rolling a KSK with a parent is only done for two reasons: to test\
    \ and\n   verify the rolling system to prepare for an emergency, and in the\n\
    \   case of (preventing) an actual emergency.\n   Finally, in most cases a zone\
    \ administrator cannot be fully certain\n   that the zone's KSK is not in use\
    \ as a trust anchor somewhere.  While\n   the configuration of trust anchors is\
    \ not the responsibility of the\n   zone administrator, there may be stability\
    \ costs for the validator\n   administrator that (wrongfully) configured the trust\
    \ anchor when the\n   zone administrator rolls a KSK.\n"
- title: 3.2.2.  Rolling a KSK That Is a Trust Anchor
  contents:
  - "3.2.2.  Rolling a KSK That Is a Trust Anchor\n   The same operational concerns\
    \ apply to the rollover of KSKs that are\n   used as trust anchors: If a trust\
    \ anchor replacement is done\n   incorrectly, the entire domain that the trust\
    \ anchor covers will\n   become Bogus until the trust anchor is corrected.\n \
    \  In a large number of cases, it will be safe to work from the\n   assumption\
    \ that one's keys are not in use as trust anchors.  If a\n   zone administrator\
    \ publishes a DNSSEC signing policy and/or a DNSSEC\n   practice statement [DNSSEC-DPS],\
    \ that policy or statement should be\n   explicit regarding whether or not the\
    \ existence of trust anchors will\n   be taken into account.  There may be cases\
    \ where local policies\n   enforce the configuration of trust anchors on zones\
    \ that are mission\n   critical (e.g., in enterprises where the trust anchor for\
    \ the\n   enterprise domain is configured in the enterprise's validator).  It\n\
    \   is expected that the zone administrators are aware of such\n   circumstances.\n\
    \   One can argue that because of the difficulty of getting all users of\n   a\
    \ trust anchor to replace an old trust anchor with a new one, a KSK\n   that is\
    \ a trust anchor should never be rolled unless it is known or\n   strongly suspected\
    \ that the key has been compromised.  In other\n   words, the costs of a KSK rollover\
    \ are prohibitively high because\n   some users cannot be reached.\n   However,\
    \ the \"operational habit\" argument also applies to trust\n   anchor reconfiguration\
    \ at the clients' validators.  If a short key\n   effectivity period is used and\
    \ the trust anchor configuration has to\n   be revisited on a regular basis, the\
    \ odds that the configuration\n   tends to be forgotten are smaller.  In fact,\
    \ the costs for those\n   users can be minimized by automating the rollover with\
    \ RFC 5011\n   [RFC5011] and by rolling the key regularly (and advertising such)\
    \ so\n   that the operators of validating resolvers will put the appropriate\n\
    \   mechanism in place to deal with these stability costs: In other\n   words,\
    \ budget for these costs instead of incurring them unexpectedly.\n   It is therefore\
    \ preferable to roll KSKs that are expected to be used\n   as trust anchors on\
    \ a regular basis if and only if those rollovers\n   can be tracked using standardized\
    \ (e.g., RFC 5011 [RFC5011])\n   mechanisms.\n"
- title: 3.2.3.  The Use of the SEP Flag
  contents:
  - "3.2.3.  The Use of the SEP Flag\n   The so-called SEP [RFC4035] flag can be used\
    \ to distinguish between\n   keys that are intended to be used as the secure entry\
    \ point into the\n   zone when building chains of trust, i.e., they are (to be)\
    \ pointed to\n   by parental DS RRs or configured as a trust anchor.\n   While\
    \ the SEP flag does not play any role in validation, it is used\n   in practice\
    \ for operational purposes such as for the rollover\n   mechanism described in\
    \ RFC 5011 [RFC5011].  The common convention is\n   to set the SEP flag on any\
    \ key that is used for key exchanges with\n   the parent and/or potentially used\
    \ for configuration as a trust\n   anchor.  Therefore, it is suggested that the\
    \ SEP flag be set on keys\n   that are used as KSKs and not on keys that are used\
    \ as ZSKs, while in\n   those cases where a distinction between a KSK and ZSK\
    \ is not made\n   (i.e., for a Single-Type Signing Scheme), it is suggested that\
    \ the\n   SEP flag be set on all keys.\n   Note: Some signing tools may assume\
    \ a KSK/ZSK split and use the\n   (non-)presence of the SEP flag to determine\
    \ which key is to be used\n   for signing zone data; these tools may get confused\
    \ when a Single-\n   Type Signing Scheme is used.\n"
- title: 3.3.  Key Effectivity Period
  contents:
  - "3.3.  Key Effectivity Period\n   In general, the available key length sets an\
    \ upper limit on the key\n   effectivity period.  For all practical purposes,\
    \ it is sufficient to\n   define the key effectivity period based on purely operational\n\
    \   requirements and match the key length to that value.  Ignoring the\n   operational\
    \ perspective, a reasonable effectivity period for KSKs\n   that have corresponding\
    \ DS records in the parent zone is on the order\n   of two decades or longer.\
    \  That is, if one does not plan to test the\n   rollover procedure, the key should\
    \ be effective essentially forever\n   and only rolled over in case of emergency.\n\
    \   When one opts for a regular key rollover, a reasonable key\n   effectivity\
    \ period for KSKs that have a parent zone is one year,\n   meaning you have the\
    \ intent to replace them after 12 months.  The key\n   effectivity period is merely\
    \ a policy parameter and should not be\n   considered a constant value.  For example,\
    \ the real key effectivity\n   period may be a little bit longer than 12 months,\
    \ because not all\n   actions needed to complete the rollover could be finished\
    \ in time.\n   As argued above, this annual rollover gives an operational practice\n\
    \   of rollovers for both the zone and validator administrators.\n   Besides,\
    \ in most environments a year is a time span that is easily\n   planned and communicated.\n\
    \   Where keys are stored online and the exposure to various threats of\n   compromise\
    \ is fairly high, an intended key effectivity period of a\n   month is reasonable\
    \ for Zone Signing Keys.\n   Although very short key effectivity periods are theoretically\n\
    \   possible, when replacing keys one has to take into account the\n   rollover\
    \ considerations discussed in Sections 4.1 and 4.4.  Key\n   replacement endures\
    \ for a couple of Maximum Zone TTLs, depending on\n   the rollover scenario. \
    \ Therefore, a multiple of Maximum Zone TTL\n   durations is a reasonable lower\
    \ limit on the key effectivity period.\n   Forcing a shorter key effectivity period\
    \ will result in an\n   unnecessary and inconveniently large DNSKEY RRset published\
    \ in the\n   zone.\n   The motivation for having the ZSK's effectivity period\
    \ shorter than\n   the KSK's effectivity period is rooted in the operational\n\
    \   consideration that it is more likely that operators have more\n   frequent\
    \ read access to the ZSK than to the KSK.  Thus, in cases\n   where the ZSK cannot\
    \ be afforded the same level of protection as the\n   KSK (such as when zone keys\
    \ are kept online), and where the risk of\n   unauthorized disclosure of the ZSK's\
    \ private key is not negligible\n   (e.g., when HSMs are not in use), the ZSK's\
    \ effectivity period should\n   be kept shorter than the KSK's effectivity period.\n\
    \   In fact, if the risk of loss, theft, or other compromise is the same\n   for\
    \ a ZSK and a KSK, there is little reason to choose different\n   effectivity\
    \ periods for ZSKs and KSKs.  And when the split between\n   ZSKs and KSKs is\
    \ not made, the argument is redundant.\n   There are certainly cases in which\
    \ the use of a Single-Type Signing\n   Scheme with a long key effectivity period\
    \ is a good choice, for\n   example, where the costs and risks of compromise,\
    \ and the costs and\n   risks involved with having to perform an emergency roll,\
    \ are low.\n"
- title: 3.4.  Cryptographic Considerations
  contents:
  - '3.4.  Cryptographic Considerations

    '
- title: 3.4.1.  Signature Algorithm
  contents:
  - "3.4.1.  Signature Algorithm\n   At the time of this writing, there are three\
    \ types of signature\n   algorithms that can be used in DNSSEC: RSA, Digital Signature\n\
    \   Algorithm (DSA), and GOST.  Proposals for other algorithms are in the\n  \
    \ making.  All three are fully specified in many freely available\n   documents\
    \ and are widely considered to be patent-free.  The creation\n   of signatures\
    \ with RSA and DSA takes roughly the same time, but DSA\n   is about ten times\
    \ slower for signature verification.  Also note\n   that, in the context of DNSSEC,\
    \ DSA is limited to a maximum of\n   1024-bit keys.\n   We suggest the use of\
    \ RSA/SHA-256 as the preferred signature\n   algorithm and RSA/SHA-1 as an alternative.\
    \  Both have advantages and\n   disadvantages.  RSA/SHA-1 has been deployed for\
    \ many years, while\n   RSA/SHA-256 has only begun to be deployed.  On the other\
    \ hand, it is\n   expected that if effective attacks on either algorithm appear,\
    \ they\n   will appear for RSA/SHA-1 first.  RSA/MD5 should not be considered\n\
    \   for use because RSA/MD5 will very likely be the first common-use\n   signature\
    \ algorithm to be targeted for an effective attack.\n   At the time of publication,\
    \ it is known that the SHA-1 hash has\n   cryptanalysis issues, and work is in\
    \ progress to address them.  The\n   use of public-key algorithms based on hashes\
    \ stronger than SHA-1\n   (e.g., SHA-256) is recommended, if these algorithms\
    \ are available in\n   implementations (see RFC 5702 [RFC5702] and RFC 4509 [RFC4509]).\n\
    \   Also, at the time of publication, digital signature algorithms based\n   on\
    \ Elliptic Curve (EC) Cryptography with DNSSEC (GOST [RFC5933],\n   Elliptic Curve\
    \ Digital Signature Algorithm (ECDSA) [RFC6605]) are\n   being standardized and\
    \ implemented.  The use of EC has benefits in\n   terms of size.  On the other\
    \ hand, one has to balance that against\n   the amount of validating resolver\
    \ implementations that will not\n   recognize EC signatures and thus treat the\
    \ zone as insecure.  Beyond\n   the observation of this tradeoff, we will not\
    \ discuss this further.\n"
- title: 3.4.2.  Key Sizes
  contents:
  - "3.4.2.  Key Sizes\n   This section assumes RSA keys, as suggested in the previous\
    \ section.\n   DNSSEC signing keys should be large enough to avoid all known\n\
    \   cryptographic attacks during the effectivity period of the key.  To\n   date,\
    \ despite huge efforts, no one has broken a regular 1024-bit key;\n   in fact,\
    \ the best completed attack is estimated to be the equivalent\n   of a 700-bit\
    \ key.  An attacker breaking a 1024-bit signing key would\n   need to expend phenomenal\
    \ amounts of networked computing power in a\n   way that would not be detected\
    \ in order to break a single key.\n   Because of this, it is estimated that most\
    \ zones can safely use\n   1024-bit keys for at least the next ten years.  (A\
    \ 1024-bit\n   asymmetric key has an approximate equivalent strength of a symmetric\n\
    \   80-bit key.)\n   Depending on local policy (e.g., owners of keys that are\
    \ used as\n   extremely high value trust anchors, or non-anchor keys that may\
    \ be\n   difficult to roll over), it may be advisable to use lengths longer\n\
    \   than 1024 bits.  Typically, the next larger key size used is\n   2048 bits,\
    \ which has the approximate equivalent strength of a\n   symmetric 112-bit key\
    \ (RFC 3766 [RFC3766]).  Signing and verifying\n   with a 2048-bit key takes longer\
    \ than with a 1024-bit key.  The\n   increase depends on software and hardware\
    \ implementations, but public\n   operations (such as verification) are about\
    \ four times slower, while\n   private operations (such as signing) are about\
    \ eight times slower.\n   Another way to decide on the size of a key to use is\
    \ to remember that\n   the effort it takes for an attacker to break a 1024-bit\
    \ key is the\n   same, regardless of how the key is used.  If an attacker has\
    \ the\n   capability of breaking a 1024-bit DNSSEC key, he also has the\n   capability\
    \ of breaking one of the many 1024-bit Transport Layer\n   Security (TLS) [RFC5246]\
    \ trust anchor keys that are currently\n   installed in web browsers.  If the\
    \ value of a DNSSEC key is lower to\n   the attacker than the value of a TLS trust\
    \ anchor, the attacker will\n   use the resources to attack the latter.\n   It\
    \ is possible that there will be an unexpected improvement in the\n   ability\
    \ for attackers to break keys and that such an attack would\n   make it feasible\
    \ to break 1024-bit keys but not 2048-bit keys.  If\n   such an improvement happens,\
    \ it is likely that there will be a huge\n   amount of publicity, particularly\
    \ because of the large number of\n   1024-bit TLS trust anchors built into popular\
    \ web browsers.  At that\n   time, all 1024-bit keys (both ones with parent zones\
    \ and ones that\n   are trust anchors) can be rolled over and replaced with larger\
    \ keys.\n   Earlier documents (including the previous version of this document)\n\
    \   urged the use of longer keys in situations where a particular key was\n  \
    \ \"heavily used\".  That advice may have been true 15 years ago, but it\n   is\
    \ not true today when using RSA algorithms and keys of 1024 bits or\n   higher.\n"
- title: 3.4.3.  Private Key Storage
  contents:
  - "3.4.3.  Private Key Storage\n   It is preferred that, where possible, zone private\
    \ keys and the zone\n   file master copy that is to be signed be kept and used\
    \ in off-line,\n   non-network-connected, physically secure machines only.\n \
    \  Periodically, an application can be run to add authentication to a\n   zone\
    \ by adding RRSIG and NSEC/NSEC3 RRs.  Then the augmented file can\n   be transferred\
    \ to the master.\n   When relying on dynamic update [RFC3007] or any other update\n\
    \   mechanism that runs at a regular interval to manage a signed zone, be\n  \
    \ aware that at least one private key of the zone will have to reside\n   on the\
    \ master server or reside on an HSM to which the server has\n   access.  This\
    \ key is only as secure as the amount of exposure the\n   server receives to unknown\
    \ clients and on the level of security of\n   the host.  Although not mandatory,\
    \ one could administer a zone using\n   a \"hidden master\" scheme to minimize\
    \ the risk.  In this arrangement,\n   the master name server that processes the\
    \ updates is unavailable to\n   general hosts on the Internet; it is not listed\
    \ in the NS RRset.  The\n   name servers in the NS RRset are able to receive zone\
    \ updates through\n   IXFR, AXFR, or an out-of-band distribution mechanism, possibly\
    \ in\n   combination with NOTIFY or another mechanism to trigger zone\n   replication.\n\
    \   The ideal situation is to have a one-way information flow to the\n   network\
    \ to avoid the possibility of tampering from the network.\n   Keeping the zone\
    \ master on-line on the network and simply cycling it\n   through an off-line\
    \ signer does not do this.  The on-line version\n   could still be tampered with\
    \ if the host it resides on is\n   compromised.  For maximum security, the master\
    \ copy of the zone file\n   should be off-net and should not be updated based\
    \ on an unsecured\n   network-mediated communication.\n   The ideal situation\
    \ may not be achievable because of economic\n   tradeoffs between risks and costs.\
    \  For instance, keeping a zone file\n   off-line is not practical and will increase\
    \ the costs of operating a\n   DNS zone.  So, in practice, the machines on which\
    \ zone files are\n   maintained will be connected to a network.  Operators are\
    \ advised to\n   take security measures to shield the master copy against unauthorized\n\
    \   access in order to prevent modification of DNS data before it is\n   signed.\n\
    \   Similarly, the choice for storing a private key in an HSM will be\n   influenced\
    \ by a tradeoff between various concerns:\n   o  The risks that an unauthorized\
    \ person has unnoticed read access to\n      the private key.\n   o  The remaining\
    \ window of opportunity for the attacker.\n   o  The economic impact of the possible\
    \ attacks (for a TLD, that\n      impact will typically be higher than for an\
    \ individual user).\n   o  The costs of rolling the (compromised) keys.  (The\
    \ cost of rolling\n      a ZSK is lowest, and the cost of rolling a KSK that is\
    \ in wide use\n      as a trust anchor is highest.)\n   o  The costs of buying\
    \ and maintaining an HSM.\n   For dynamically updated secured zones [RFC3007],\
    \ both the master copy\n   and the private key that is used to update signatures\
    \ on updated RRs\n   will need to be on-line.\n"
- title: 3.4.4.  Key Generation
  contents:
  - "3.4.4.  Key Generation\n   Careful generation of all keys is a sometimes overlooked\
    \ but\n   absolutely essential element in any cryptographically secure system.\n\
    \   The strongest algorithms used with the longest keys are still of no\n   use\
    \ if an adversary can guess enough to lower the size of the likely\n   key space\
    \ so that it can be exhaustively searched.  Technical\n   suggestions for the\
    \ generation of random keys will be found in\n   RFC 4086 [RFC4086] and NIST SP\
    \ 800-90A [NIST-SP-800-90A].  In\n   particular, one should carefully assess whether\
    \ the random number\n   generator used during key generation adheres to these\
    \ suggestions.\n   Typically, HSMs tend to provide a good facility for key generation.\n\
    \   Keys with a long effectivity period are particularly sensitive, as\n   they\
    \ will represent a more valuable target and be subject to attack\n   for a longer\
    \ time than short-period keys.  It is preferred that long-\n   term key generation\
    \ occur off-line in a manner isolated from the\n   network via an air gap or,\
    \ at a minimum, high-level secure hardware.\n"
- title: 3.4.5.  Differentiation for 'High-Level' Zones?
  contents:
  - "3.4.5.  Differentiation for 'High-Level' Zones?\n   An earlier version of this\
    \ document (RFC 4641 [RFC4641]) made a\n   differentiation between key lengths\
    \ for KSKs used for zones that are\n   high in the DNS hierarchy and those for\
    \ KSKs used lower down in the\n   hierarchy.\n   This distinction is now considered\
    \ irrelevant.  Longer key lengths\n   for keys higher in the hierarchy are not\
    \ useful because the\n   cryptographic guidance is that everyone should use keys\
    \ that no one\n   can break.  Also, it is impossible to judge which zones are\
    \ more or\n   less valuable to an attacker.  An attack can only take place if\
    \ the\n   key compromise goes unnoticed and the attacker can act as a man-in-\n\
    \   the-middle (MITM).  For example, if example.com is compromised, and\n   the\
    \ attacker forges answers for somebank.example.com. and sends them\n   out during\
    \ an MITM, when the attack is discovered it will be simple\n   to prove that example.com\
    \ has been compromised, and the KSK will be\n   rolled.\n"
- title: 4.  Signature Generation, Key Rollover, and Related Policies
  contents:
  - '4.  Signature Generation, Key Rollover, and Related Policies

    '
- title: 4.1.  Key Rollovers
  contents:
  - "4.1.  Key Rollovers\n   Regardless of whether a zone uses periodic key rollovers\
    \ or only\n   rolls keys in case of an irregular event, key rollovers are a fact\
    \ of\n   life when using DNSSEC.  Zone administrators who are in the process\n\
    \   of rolling their keys have to take into account the fact that data\n   published\
    \ in previous versions of their zone still lives in caches.\n   When deploying\
    \ DNSSEC, this becomes an important consideration;\n   ignoring data that may\
    \ be in caches may lead to loss of service for\n   clients.\n   The most pressing\
    \ example of this occurs when zone material signed\n   with an old key is being\
    \ validated by a resolver that does not have\n   the old zone key cached.  If\
    \ the old key is no longer present in the\n   current zone, this validation fails,\
    \ marking the data Bogus.\n   Alternatively, an attempt could be made to validate\
    \ data that is\n   signed with a new key against an old key that lives in a local\
    \ cache,\n   also resulting in data being marked Bogus.\n   The typographic conventions\
    \ used in the diagrams below are explained\n   in Appendix B.\n"
- title: 4.1.1.  Zone Signing Key Rollovers
  contents:
  - "4.1.1.  Zone Signing Key Rollovers\n   If the choice for splitting ZSKs and KSKs\
    \ has been made, then those\n   two types of keys can be rolled separately, and\
    \ ZSKs can be rolled\n   without taking into account DS records from the parent\
    \ or the\n   configuration of such a key as the trust anchor.\n   For \"Zone Signing\
    \ Key rollovers\", there are two ways to make sure\n   that during the rollover\
    \ data still cached can be verified with the\n   new key sets or newly generated\
    \ signatures can be verified with the\n   keys still in caches.  One scheme, described\
    \ in Section 4.1.1.1, uses\n   key pre-publication; the other uses double signatures,\
    \ as described\n   in Section 4.1.1.2.  The pros and cons are described in\n \
    \  Section 4.1.1.3.\n"
- title: 4.1.1.1.  Pre-Publish Zone Signing Key Rollover
  contents:
  - "4.1.1.1.  Pre-Publish Zone Signing Key Rollover\n   This section shows how to\
    \ perform a ZSK rollover without the need to\n   sign all the data in a zone twice\
    \ -- the \"Pre-Publish key rollover\".\n   This method has advantages in the case\
    \ of a key compromise.  If the\n   old key is compromised, the new key has already\
    \ been distributed in\n   the DNS.  The zone administrator is then able to quickly\
    \ switch to\n   the new key and remove the compromised key from the zone.  Another\n\
    \   major advantage is that the zone size does not double, as is the case\n  \
    \ with the Double-Signature ZSK rollover.\n   Pre-Publish key rollover from DNSKEY_Z_10\
    \ to DNSKEY_Z_11 involves\n   four stages as follows:\n    ------------------------------------------------------------\n\
    \     initial            new DNSKEY          new RRSIGs\n    ------------------------------------------------------------\n\
    \     SOA_0              SOA_1               SOA_2\n     RRSIG_Z_10(SOA)    RRSIG_Z_10(SOA)\
    \     RRSIG_Z_11(SOA)\n     DNSKEY_K_1         DNSKEY_K_1          DNSKEY_K_1\n\
    \     DNSKEY_Z_10        DNSKEY_Z_10         DNSKEY_Z_10\n                   \
    \     DNSKEY_Z_11         DNSKEY_Z_11\n     RRSIG_K_1(DNSKEY)  RRSIG_K_1(DNSKEY)\
    \   RRSIG_K_1(DNSKEY)\n    ------------------------------------------------------------\n\
    \    ------------------------------------------------------------\n     DNSKEY\
    \ removal\n    ------------------------------------------------------------\n\
    \     SOA_3\n     RRSIG_Z_11(SOA)\n     DNSKEY_K_1\n     DNSKEY_Z_11\n     RRSIG_K_1(DNSKEY)\n\
    \    ------------------------------------------------------------\n          \
    \          Figure 1: Pre-Publish Key Rollover\n   initial:  Initial version of\
    \ the zone: DNSKEY_K_1 is the Key Signing\n      Key.  DNSKEY_Z_10 is used to\
    \ sign all the data of the zone, i.e.,\n      it is the Zone Signing Key.\n  \
    \ new DNSKEY:  DNSKEY_Z_11 is introduced into the key set (note that no\n    \
    \  signatures are generated with this key yet, but this does not\n      secure\
    \ against brute force attacks on its public key).  The\n      minimum duration\
    \ of this pre-roll phase is the time it takes for\n      the data to propagate\
    \ to the authoritative servers, plus the TTL\n      value of the key set.\n  \
    \ new RRSIGs:  At the \"new RRSIGs\" stage, DNSKEY_Z_11 is used to sign\n    \
    \  the data in the zone exclusively (i.e., all the signatures from\n      DNSKEY_Z_10\
    \ are removed from the zone).  DNSKEY_Z_10 remains\n      published in the key\
    \ set.  This way, data that was loaded into\n      caches from the zone in the\
    \ \"new DNSKEY\" step can still be\n      verified with key sets fetched from\
    \ this version of the zone.  The\n      minimum time that the key set including\
    \ DNSKEY_Z_10 is to be\n      published is the time that it takes for zone data\
    \ from the\n      previous version of the zone to expire from old caches, i.e.,\
    \ the\n      time it takes for this zone to propagate to all authoritative\n \
    \     servers, plus the Maximum Zone TTL value of any of the data in the\n   \
    \   previous version of the zone.\n   DNSKEY removal:  DNSKEY_Z_10 is removed\
    \ from the zone.  The key set,\n      now only containing DNSKEY_K_1 and DNSKEY_Z_11,\
    \ is re-signed with\n      DNSKEY_K_1.\n   The above scheme can be simplified\
    \ by always publishing the \"future\"\n   key immediately after the rollover.\
    \  The scheme would look as\n   follows (we show two rollovers); the future key\
    \ is introduced in \"new\n   DNSKEY\" as DNSKEY_Z_12 and again a newer one, numbered\
    \ 13, in \"new\n   DNSKEY (II)\":\n       initial             new RRSIGs     \
    \     new DNSKEY\n      -----------------------------------------------------------------\n\
    \       SOA_0               SOA_1               SOA_2\n       RRSIG_Z_10(SOA)\
    \     RRSIG_Z_11(SOA)     RRSIG_Z_11(SOA)\n       DNSKEY_K_1          DNSKEY_K_1\
    \          DNSKEY_K_1\n       DNSKEY_Z_10         DNSKEY_Z_10         DNSKEY_Z_11\n\
    \       DNSKEY_Z_11         DNSKEY_Z_11         DNSKEY_Z_12\n       RRSIG_K_1(DNSKEY)\
    \   RRSIG_K_1(DNSKEY)   RRSIG_K_1(DNSKEY)\n       ----------------------------------------------------------------\n\
    \       ----------------------------------------------------------------\n   \
    \    new RRSIGs (II)     new DNSKEY (II)\n       ----------------------------------------------------------------\n\
    \       SOA_3               SOA_4\n       RRSIG_Z_12(SOA)     RRSIG_Z_12(SOA)\n\
    \       DNSKEY_K_1          DNSKEY_K_1\n       DNSKEY_Z_11         DNSKEY_Z_12\n\
    \       DNSKEY_Z_12         DNSKEY_Z_13\n       RRSIG_K_1(DNSKEY)   RRSIG_K_1(DNSKEY)\n\
    \       ----------------------------------------------------------------\n   \
    \          Figure 2: Pre-Publish Zone Signing Key Rollover,\n                \
    \           Showing Two Rollovers\n   Note that the key introduced in the \"new\
    \ DNSKEY\" phase is not used\n   for production yet; the private key can thus\
    \ be stored in a\n   physically secure manner and does not need to be 'fetched'\
    \ every time\n   a zone needs to be signed.\n"
- title: 4.1.1.2.  Double-Signature Zone Signing Key Rollover
  contents:
  - "4.1.1.2.  Double-Signature Zone Signing Key Rollover\n   This section shows how\
    \ to perform a ZSK rollover using the double\n   zone data signature scheme, aptly\
    \ named \"Double-Signature rollover\".\n   During the \"new DNSKEY\" stage, the\
    \ new version of the zone file will\n   need to propagate to all authoritative\
    \ servers and the data that\n   exists in (distant) caches will need to expire,\
    \ requiring at least\n   the propagation delay plus the Maximum Zone TTL of previous\
    \ versions\n   of the zone.\n   Double-Signature ZSK rollover involves three stages\
    \ as follows:\n      ----------------------------------------------------------------\n\
    \      initial             new DNSKEY         DNSKEY removal\n      ----------------------------------------------------------------\n\
    \      SOA_0               SOA_1              SOA_2\n      RRSIG_Z_10(SOA)   \
    \  RRSIG_Z_10(SOA)\n                          RRSIG_Z_11(SOA)    RRSIG_Z_11(SOA)\n\
    \      DNSKEY_K_1          DNSKEY_K_1         DNSKEY_K_1\n      DNSKEY_Z_10  \
    \       DNSKEY_Z_10\n                          DNSKEY_Z_11        DNSKEY_Z_11\n\
    \      RRSIG_K_1(DNSKEY)   RRSIG_K_1(DNSKEY)  RRSIG_K_1(DNSKEY)\n      ----------------------------------------------------------------\n\
    \           Figure 3: Double-Signature Zone Signing Key Rollover\n   initial:\
    \  Initial version of the zone: DNSKEY_K_1 is the Key Signing\n      Key.  DNSKEY_Z_10\
    \ is used to sign all the data of the zone, i.e.,\n      it is the Zone Signing\
    \ Key.\n   new DNSKEY:  At the \"new DNSKEY\" stage, DNSKEY_Z_11 is introduced\n\
    \      into the key set and all the data in the zone is signed with\n      DNSKEY_Z_10\
    \ and DNSKEY_Z_11.  The rollover period will need to\n      continue until all\
    \ data from version 0 (i.e., the version of the\n      zone data containing SOA_0)\
    \ of the zone has been replaced in all\n      secondary servers and then has expired\
    \ from remote caches.  This\n      will take at least the propagation delay plus\
    \ the Maximum Zone TTL\n      of version 0 of the zone.\n   DNSKEY removal:  DNSKEY_Z_10\
    \ is removed from the zone, as are all\n      signatures created with it.  The\
    \ key set, now only containing\n      DNSKEY_Z_11, is re-signed with DNSKEY_K_1\
    \ and DNSKEY_Z_11.\n   At every instance, RRSIGs from the previous version of\
    \ the zone can\n   be verified with the DNSKEY RRset from the current version\
    \ and vice\n   versa.  The duration of the \"new DNSKEY\" phase and the period\
    \ between\n   rollovers should be at least the propagation delay to secondary\n\
    \   servers plus the Maximum Zone TTL of the previous version of the\n   zone.\n\
    \   Note that in this example we assumed for simplicity that the zone was\n  \
    \ not modified during the rollover.  In fact, new data can be\n   introduced at\
    \ any time during this period, as long as it is signed\n   with both keys.\n"
- title: 4.1.1.3.  Pros and Cons of the Schemes
  contents:
  - "4.1.1.3.  Pros and Cons of the Schemes\n   Pre-Publish key rollover:  This rollover\
    \ does not involve signing the\n      zone data twice.  Instead, before the actual\
    \ rollover, the new key\n      is published in the key set and thus is available\
    \ for\n      cryptanalysis attacks.  A small disadvantage is that this process\n\
    \      requires four stages.  Also, the Pre-Publish scheme involves more\n   \
    \   parental work when used for KSK rollovers, as explained in\n      Section\
    \ 4.1.2.\n   Double-Signature ZSK rollover:  The drawback of this approach is\
    \ that\n      during the rollover the number of signatures in your zone doubles;\n\
    \      this may be prohibitive if you have very big zones.  An advantage\n   \
    \   is that it only requires three stages.\n"
- title: 4.1.2.  Key Signing Key Rollovers
  contents:
  - "4.1.2.  Key Signing Key Rollovers\n   For the rollover of a Key Signing Key,\
    \ the same considerations as for\n   the rollover of a Zone Signing Key apply.\
    \  However, we can use a\n   Double-Signature scheme to guarantee that old data\
    \ (only the apex key\n   set) in caches can be verified with a new key set and\
    \ vice versa.\n   Since only the key set is signed with a KSK, zone size considerations\n\
    \   do not apply.\n   Note that KSK rollovers and ZSK rollovers are different\
    \ in the sense\n   that a KSK rollover requires interaction with the parent (and\n\
    \   possibly replacing trust anchors) and the ensuing delay while waiting\n  \
    \ for it.\n   ---------------------------------------------------------------------\n\
    \    initial            new DNSKEY        DS change    DNSKEY removal\n   ---------------------------------------------------------------------\n\
    \   Parent:\n    SOA_0 -----------------------------> SOA_1 ------------------------>\n\
    \    RRSIG_par(SOA) --------------------> RRSIG_par(SOA) --------------->\n  \
    \  DS_K_1 ----------------------------> DS_K_2 ----------------------->\n    RRSIG_par(DS)\
    \ ---------------------> RRSIG_par(DS) ---------------->\n   Child:\n    SOA_0\
    \              SOA_1 -----------------------> SOA_2\n    RRSIG_Z_10(SOA)    RRSIG_Z_10(SOA)\
    \ -------------> RRSIG_Z_10(SOA)\n    DNSKEY_K_1         DNSKEY_K_1 ------------------>\n\
    \                       DNSKEY_K_2 ------------------> DNSKEY_K_2\n    DNSKEY_Z_10\
    \        DNSKEY_Z_10 -----------------> DNSKEY_Z_10\n    RRSIG_K_1(DNSKEY)  RRSIG_K_1\
    \ (DNSKEY) ---------->\n                       RRSIG_K_2 (DNSKEY) ---------->\
    \ RRSIG_K_2(DNSKEY)\n   ---------------------------------------------------------------------\n\
    \           Figure 4: Stages of Deployment for a Double-Signature\n          \
    \               Key Signing Key Rollover\n   initial:  Initial version of the\
    \ zone.  The parental DS points to\n      DNSKEY_K_1.  Before the rollover starts,\
    \ the child will have to\n      verify what the TTL is of the DS RR that points\
    \ to DNSKEY_K_1 --\n      it is needed during the rollover, and we refer to the\
    \ value as\n      TTL_DS.\n   new DNSKEY:  During the \"new DNSKEY\" phase, the\
    \ zone administrator\n      generates a second KSK, DNSKEY_K_2.  The key is provided\
    \ to the\n      parent, and the child will have to wait until a new DS RR has\
    \ been\n      generated that points to DNSKEY_K_2.  After that DS RR has been\n\
    \      published on all servers authoritative for the parent's zone, the\n   \
    \   zone administrator has to wait at least TTL_DS to make sure that\n      the\
    \ old DS RR has expired from caches.\n   DS change:  The parent replaces DS_K_1\
    \ with DS_K_2.\n   DNSKEY removal:  DNSKEY_K_1 has been removed.\n   The scenario\
    \ above puts the responsibility for maintaining a valid\n   chain of trust with\
    \ the child.  It also is based on the premise that\n   the parent only has one\
    \ DS RR (per algorithm) per zone.  An\n   alternative mechanism has been considered.\
    \  Using an established\n   trust relationship, the interaction can be performed\
    \ in-band, and the\n   removal of the keys by the child can possibly be signaled\
    \ by the\n   parent.  In this mechanism, there are periods where there are two\
    \ DS\n   RRs at the parent.  This is known as a KSK Double-DS rollover and is\n\
    \   shown in Figure 5.  This method has some drawbacks for KSKs.  We\n   first\
    \ describe the rollover scheme and then indicate these drawbacks.\n   --------------------------------------------------------------------\n\
    \     initial         new DS         new DNSKEY       DS removal\n   --------------------------------------------------------------------\n\
    \   Parent:\n     SOA_0           SOA_1 ------------------------> SOA_2\n    \
    \ RRSIG_par(SOA)  RRSIG_par(SOA) ---------------> RRSIG_par(SOA)\n     DS_K_1\
    \          DS_K_1 ----------------------->\n                     DS_K_2 ----------------------->\
    \ DS_K_2\n     RRSIG_par(DS)   RRSIG_par(DS) ----------------> RRSIG_par(DS)\n\
    \   Child:\n     SOA_0 -----------------------> SOA_1 ---------------------------->\n\
    \     RRSIG_Z_10(SOA) -------------> RRSIG_Z_10(SOA) ------------------>\n   \
    \  DNSKEY_K_1 ------------------> DNSKEY_K_2 ----------------------->\n     DNSKEY_Z_10\
    \ -----------------> DNSKEY_Z_10 ---------------------->\n     RRSIG_K_1 (DNSKEY)\
    \ ----------> RRSIG_K_2 (DNSKEY) --------------->\n   --------------------------------------------------------------------\n\
    \              Figure 5: Stages of Deployment for a Double-DS\n              \
    \           Key Signing Key Rollover\n   When the child zone wants to roll, it\
    \ notifies the parent during the\n   \"new DS\" phase and submits the new key\
    \ (or the corresponding DS) to\n   the parent.  The parent publishes DS_K_1 and\
    \ DS_K_2, pointing to\n   DNSKEY_K_1 and DNSKEY_K_2, respectively.  During the\
    \ rollover (\"new\n   DNSKEY\" phase), which can take place as soon as the new\
    \ DS set\n   propagated through the DNS, the child replaces DNSKEY_K_1 with\n\
    \   DNSKEY_K_2.  If the old key has expired from caches, at the \"DS\n   removal\"\
    \ phase the parent can be notified that the old DS record can\n   be deleted.\n\
    \   The drawbacks of this scheme are that during the \"new DS\" phase, the\n \
    \  parent cannot verify the match between the DS_K_2 RR and DNSKEY_K_2\n   using\
    \ the DNS, as DNSKEY_K_2 is not yet published.  Besides, we\n   introduce a \"\
    security lame\" key (see Section 4.3.3).  Finally, the\n   child-parent interaction\
    \ consists of two steps.  The \"Double\n   Signature\" method only needs one interaction.\n"
- title: 4.1.2.1.  Special Considerations for RFC 5011 KSK Rollover
  contents:
  - "4.1.2.1.  Special Considerations for RFC 5011 KSK Rollover\n   The scenario sketched\
    \ above assumes that the KSK is not in use as a\n   trust anchor but that validating\
    \ name servers exclusively depend on\n   the parental DS record to establish the\
    \ zone's security.  If it is\n   known that validating name servers have configured\
    \ trust anchors,\n   then that needs to be taken into account.  Here, we assume\
    \ that zone\n   administrators will deploy RFC 5011 [RFC5011] style rollovers.\n\
    \   RFC 5011 style rollovers increase the duration of key rollovers: The\n   key\
    \ to be removed must first be revoked.  Thus, before the DNSKEY_K_1\n   removal\
    \ phase, DNSKEY_K_1 must be published for one more Maximum Zone\n   TTL with the\
    \ REVOKE bit set.  The revoked key must be self-signed, so\n   in this phase the\
    \ DNSKEY RRset must also be signed with DNSKEY_K_1.\n"
- title: 4.1.3.  Single-Type Signing Scheme Key Rollover
  contents:
  - "4.1.3.  Single-Type Signing Scheme Key Rollover\n   The rollover of a key when\
    \ a Single-Type Signing Scheme is used is\n   subject to the same requirement\
    \ as the rollover of a KSK or ZSK:\n   During any stage of the rollover, the chain\
    \ of trust needs to\n   continue to validate for any combination of data in the\
    \ zone as well\n   as data that may still live in distant caches.\n   There are\
    \ two variants for this rollover.  Since the choice for a\n   Single-Type Signing\
    \ Scheme is motivated by operational simplicity, we\n   describe the most straightforward\
    \ rollover scheme first.\n   -------------------------------------------------------------------\n\
    \     initial           new DNSKEY      DS change     DNSKEY removal\n   -------------------------------------------------------------------\n\
    \   Parent:\n     SOA_0 --------------------------> SOA_1 ---------------------->\n\
    \     RRSIG_par(SOA) -----------------> RRSIG_par(SOA) ------------->\n     DS_S_1\
    \ -------------------------> DS_S_2 --------------------->\n     RRSIG_par(DS_S_1)\
    \ --------------> RRSIG_par(DS_S_2) ---------->\n   Child:\n     SOA_0       \
    \      SOA_1 ----------------------> SOA_2\n     RRSIG_S_1(SOA)    RRSIG_S_1(SOA)\
    \ ------------->\n                       RRSIG_S_2(SOA) -------------> RRSIG_S_2(SOA)\n\
    \     DNSKEY_S_1        DNSKEY_S_1 ----------------->\n                      \
    \ DNSKEY_S_2 -----------------> DNSKEY_S_2\n     RRSIG_S_1(DNSKEY) RRSIG_S_1(DNSKEY)\
    \ ---------->\n                       RRSIG_S_2(DNSKEY) ----------> RRSIG_S_2(DNSKEY)\n\
    \   -------------------------------------------------------------------\n    \
    \         Figure 6: Stages of the Straightforward Rollover\n                 \
    \     in a Single-Type Signing Scheme\n   initial:  Parental DS points to DNSKEY_S_1.\
    \  All RRsets in the zone\n      are signed with DNSKEY_S_1.\n   new DNSKEY: \
    \ A new key (DNSKEY_S_2) is introduced, and all the RRsets\n      are signed with\
    \ both DNSKEY_S_1 and DNSKEY_S_2.\n   DS change:  After the DNSKEY RRset with\
    \ the two keys had time to\n      propagate into distant caches (that is, the\
    \ key set exclusively\n      containing DNSKEY_S_1 has been expired), the parental\
    \ DS record\n      can be changed.\n   DNSKEY removal:  After the DS RRset containing\
    \ DS_S_1 has expired\n      from distant caches, DNSKEY_S_1 can be removed from\
    \ the DNSKEY\n      RRset.\n   In this first variant, the new signatures and new\
    \ public key are\n   added to the zone.  Once they are propagated, the DS at the\
    \ parent is\n   switched.  If the old DS has expired from the caches, the old\n\
    \   signatures and old public key can be removed from the zone.\n   This rollover\
    \ has the drawback that it introduces double signatures\n   over all data of the\
    \ zone.  Taking these zone size considerations\n   into account, it is possible\
    \ to not introduce the signatures made\n   with DNSKEY_S_2 at the \"new DNSKEY\"\
    \ step.  Instead, signatures of\n   DNSKEY_S_1 are replaced with signatures of\
    \ DNSKEY_S_2 in an\n   additional stage between the \"DS change\" and \"DNSKEY\
    \ removal\" step:\n   After the DS RRset containing DS_S_1 has expired from distant\
    \ caches,\n   the signatures can be swapped.  Only after the new signatures made\n\
    \   with DNSKEY_S_2 have been propagated can the old public key\n   DNSKEY_S_1\
    \ be removed from the DNSKEY RRset.\n   The second variant of the Single-Type\
    \ Signing Scheme Key rollover is\n   the Double-DS rollover.  In this variant,\
    \ one introduces a new DNSKEY\n   into the key set and submits the new DS to the\
    \ parent.  The new key\n   is not yet used to sign RRsets.  The signatures made\
    \ with DNSKEY_S_1\n   are replaced with signatures made with DNSKEY_S_2 at the\
    \ moment that\n   DNSKEY_S_2 and DS_S_2 have been propagated.\n -----------------------------------------------------------------------\n\
    \   initial            new DS         new RRSIG         DS removal\n -----------------------------------------------------------------------\n\
    \ Parent:\n   SOA_0              SOA_1 -------------------------> SOA_2\n   RRSIG_par(SOA)\
    \     RRSIG_par(SOA) ----------------> RRSIG_par(SOA)\n   DS_S_1             DS_S_1\
    \ ------------------------>\n                      DS_S_2 ------------------------>\
    \ DS_S_2\n   RRSIG_par(DS)      RRSIG_par(DS) -----------------> RRSIG_par(DS)\n\
    \ Child:\n   SOA_0              SOA_1          SOA_2             SOA_3\n   RRSIG_S_1(SOA)\
    \     RRSIG_S_1(SOA) RRSIG_S_2(SOA)    RRSIG_S_2(SOA)\n   DNSKEY_S_1         DNSKEY_S_1\
    \     DNSKEY_S_1\n                      DNSKEY_S_2     DNSKEY_S_2        DNSKEY_S_2\n\
    \   RRSIG_S_1 (DNSKEY)                RRSIG_S_2(DNSKEY) RRSIG_S_2(DNSKEY)\n -----------------------------------------------------------------------\n\
    \       Figure 7: Stages of Deployment for a Double-DS Rollover in a\n       \
    \                 Single-Type Signing Scheme\n"
- title: 4.1.4.  Algorithm Rollovers
  contents:
  - "4.1.4.  Algorithm Rollovers\n   A special class of key rollovers is the one needed\
    \ for a change of\n   signature algorithms (either adding a new algorithm, removing\
    \ an old\n   algorithm, or both).  Additional steps are needed to retain integrity\n\
    \   during this rollover.  We first describe the generic case; special\n   considerations\
    \ for rollovers that involve trust anchors and single-\n   type keys are discussed\
    \ later.\n   There exist both a conservative and a liberal approach for algorithm\n\
    \   rollover.  This has to do with Section 2.2 of RFC 4035 [RFC4035]:\n      There\
    \ MUST be an RRSIG for each RRset using at least one DNSKEY\n      of each algorithm\
    \ in the zone apex DNSKEY RRset.  The apex\n      DNSKEY RRset itself MUST be\
    \ signed by each algorithm appearing\n      in the DS RRset located at the delegating\
    \ parent (if any).\n   The conservative approach interprets this section very\
    \ strictly,\n   meaning that it expects that every RRset has a valid signature\
    \ for\n   every algorithm signaled by the zone apex DNSKEY RRset, including\n\
    \   RRsets in caches.  The liberal approach uses a more loose\n   interpretation\
    \ of the section and limits the rule to RRsets in the\n   zone at the authoritative\
    \ name servers.  There is a reasonable\n   argument for saying that this is valid,\
    \ because the specific section\n   is a subsection of Section 2 (\"Zone Signing\"\
    ) of RFC 4035.\n   When following the more liberal approach, algorithm rollover\
    \ is just\n   as easy as a regular Double-Signature KSK rollover (Section 4.1.2).\n\
    \   Note that the Double-DS KSK rollover method cannot be used, since\n   that\
    \ would introduce a parental DS of which the apex DNSKEY RRset has\n   not been\
    \ signed with the introduced algorithm.\n   However, there are implementations\
    \ of validators known to follow the\n   more conservative approach.  Performing\
    \ a Double-Signature KSK\n   algorithm rollover will temporarily make your zone\
    \ appear as Bogus by\n   such validators during the rollover.  Therefore, the\
    \ rollover\n   described in this section will explain the stages of deployment\
    \ and\n   will assume that the conservative approach is used.\n   When adding\
    \ a new algorithm, the signatures should be added first.\n   After the TTL of\
    \ RRSIGs has expired and caches have dropped the old\n   data covered by those\
    \ signatures, the DNSKEY with the new algorithm\n   can be added.\n   After the\
    \ new algorithm has been added, the DS record can be\n   exchanged using Double-Signature\
    \ KSK rollover.\n   When removing an old algorithm, the DS for the algorithm should\
    \ be\n   removed from the parent zone first, followed by the DNSKEY and the\n\
    \   signatures (in the child zone).\n   Figure 8 describes the steps.\n   ----------------------------------------------------------------\n\
    \    initial              new RRSIGs           new DNSKEY\n   ----------------------------------------------------------------\n\
    \   Parent:\n    SOA_0 -------------------------------------------------------->\n\
    \    RRSIG_par(SOA) ----------------------------------------------->\n    DS_K_1\
    \ ------------------------------------------------------->\n    RRSIG_par(DS_K_1)\
    \ -------------------------------------------->\n   Child:\n    SOA_0        \
    \        SOA_1                SOA_2\n    RRSIG_Z_10(SOA)      RRSIG_Z_10(SOA)\
    \      RRSIG_Z_10(SOA)\n                         RRSIG_Z_11(SOA)      RRSIG_Z_11(SOA)\n\
    \    DNSKEY_K_1           DNSKEY_K_1           DNSKEY_K_1\n                  \
    \                            DNSKEY_K_2\n    DNSKEY_Z_10          DNSKEY_Z_10\
    \          DNSKEY_Z_10\n                                              DNSKEY_Z_11\n\
    \    RRSIG_K_1(DNSKEY)    RRSIG_K_1(DNSKEY)    RRSIG_K_1(DNSKEY)\n           \
    \                                   RRSIG_K_2(DNSKEY)\n   ----------------------------------------------------------------\n\
    \    new DS               DNSKEY removal       RRSIGs removal\n   ----------------------------------------------------------------\n\
    \   Parent:\n    SOA_1 ------------------------------------------------------->\n\
    \    RRSIG_par(SOA) ---------------------------------------------->\n    DS_K_2\
    \ ------------------------------------------------------>\n    RRSIG_par(DS_K_2)\
    \ ------------------------------------------->\n   Child:\n    ------------------->\
    \ SOA_3                SOA_4\n    -------------------> RRSIG_Z_10(SOA)\n    ------------------->\
    \ RRSIG_Z_11(SOA)      RRSIG_Z_11(SOA)\n    ------------------->\n    ------------------->\
    \ DNSKEY_K_2           DNSKEY_K_2\n    ------------------->\n    ------------------->\
    \ DNSKEY_Z_11          DNSKEY_Z_11\n    ------------------->\n    ------------------->\
    \ RRSIG_K_2(DNSKEY)    RRSIG_K_2(DNSKEY)\n   ----------------------------------------------------------------\n\
    \        Figure 8: Stages of Deployment during an Algorithm Rollover\n   initial:\
    \  Describes the state of the zone before any transition is\n      done.  The\
    \ number of the keys may vary, but all keys (in DNSKEY\n      records) for the\
    \ zone use the same algorithm.\n   new RRSIGs:  The signatures made with the new\
    \ key over all records in\n      the zone are added, but the key itself is not.\
    \  This step is\n      needed to propagate the signatures created with the new\
    \ algorithm\n      to the caches.  If this is not done, it is possible for a resolver\n\
    \      to retrieve the new DNSKEY RRset (containing the new algorithm)\n     \
    \ but to have RRsets in its cache with signatures created by the old\n      DNSKEY\
    \ RRset (i.e., without the new algorithm).\n      The RRSIG for the DNSKEY RRset\
    \ does not need to be pre-published\n      (since these records will travel together)\
    \ and does not need\n      special processing in order to keep them synchronized.\n\
    \   new DNSKEY:  After the old data has expired from caches, the new key\n   \
    \   can be added to the zone.\n   new DS:  After the cache data for the old DNSKEY\
    \ RRset has expired,\n      the DS record for the new key can be added to the\
    \ parent zone and\n      the DS record for the old key can be removed in the same\
    \ step.\n   DNSKEY removal:  After the cache data for the old DS RRset has\n \
    \     expired, the old algorithm can be removed.  This time, the old key\n   \
    \   needs to be removed first, before removing the old signatures.\n   RRSIGs\
    \ removal:  After the cache data for the old DNSKEY RRset has\n      expired,\
    \ the old signatures can also be removed during this step.\n   Below, we deal\
    \ with a few special cases of algorithm rollovers:\n   1: Single-Type Signing\
    \ Scheme Algorithm rollover:  when there is no\n      differentiation between\
    \ ZSKs and KSKs (Section 4.1.4.1).\n   2: RFC 5011 Algorithm rollover:  when trust\
    \ anchors can track the\n      roll via RFC 5011 style rollover (Section 4.1.4.2).\n\
    \   3: 1 and 2 combined:  when a Single-Type Signing Scheme Algorithm\n      rollover\
    \ is performed RFC 5011 style (Section 4.1.4.3).\n   In addition to the narrative\
    \ below, these special cases are\n   represented in Figures 12, 13, and 14 in\
    \ Appendix C.\n"
- title: 4.1.4.1.  Single-Type Signing Scheme Algorithm Rollover
  contents:
  - "4.1.4.1.  Single-Type Signing Scheme Algorithm Rollover\n   If one key is used\
    \ that acts as both ZSK and KSK, the same scheme and\n   figure as above (Figure\
    \ 8 in Section 4.1.4) applies, whereby all\n   DNSKEY_Z_* records from the table\
    \ are removed and all RRSIG_Z_* are\n   replaced with RRSIG_S_*.  All DNSKEY_K_*\
    \ records are replaced with\n   DNSKEY_S_*, and all RRSIG_K_* records are replaced\
    \ with RRSIG_S_*.\n   The requirement to sign with both algorithms and make sure\
    \ that old\n   RRSIGs have the opportunity to expire from distant caches before\n\
    \   introducing the new algorithm in the DNSKEY RRset is still valid.\n   This\
    \ is shown in Figure 12 in Appendix C.\n"
- title: 4.1.4.2.  Algorithm Rollover, RFC 5011 Style
  contents:
  - "4.1.4.2.  Algorithm Rollover, RFC 5011 Style\n   Trust anchor algorithm rollover\
    \ is almost as simple as a regular\n   RFC 5011-based rollover.  However, the\
    \ old trust anchor must be\n   revoked before it is removed from the zone.\n \
    \  The timeline (see Figure 13 in Appendix C) is similar to that of\n   Figure\
    \ 8 above, but after the \"new DS\" step, an additional step is\n   required where\
    \ the DNSKEY is revoked.  The details of this step\n   (\"revoke DNSKEY\") are\
    \ shown in Figure 9 below.\n   ---------------------------------\n     revoke\
    \ DNSKEY\n   ---------------------------------\n   Parent:\n     ----------------------------->\n\
    \     ----------------------------->\n     ----------------------------->\n  \
    \   ----------------------------->\n   Child:\n     SOA_3\n     RRSIG_Z_10(SOA)\n\
    \     RRSIG_Z_11(SOA)\n     DNSKEY_K_1_REVOKED\n     DNSKEY_K_2\n     DNSKEY_Z_11\n\
    \     RRSIG_K_1(DNSKEY)\n     RRSIG_K_2(DNSKEY)\n   ---------------------------------\n\
    \      Figure 9: The Revoke DNSKEY State That Is Added to an Algorithm\n     \
    \                Rollover when RFC 5011 Is in Use\n   There is one exception to\
    \ the requirement from RFC 4035 quoted in\n   Section 4.1.4 above: While all zone\
    \ data must be signed with an\n   unrevoked key, it is permissible to sign the\
    \ key set with a revoked\n   key.  The somewhat esoteric argument is as follows:\n\
    \   Resolvers that do not understand the RFC 5011 REVOKE flag will handle\n  \
    \ DNSKEY_K_1_REVOKED the same as if it were DNSKEY_K_1.  In other\n   words, they\
    \ will handle the revoked key as a normal key, and thus\n   RRsets signed with\
    \ this key will validate.  As a result, the\n   signature matches the algorithm\
    \ listed in the DNSKEY RRset.\n   Resolvers that do implement RFC 5011 will remove\
    \ DNSKEY_K_1 from the\n   set of trust anchors.  That is okay, since they have\
    \ already added\n   DNSKEY_K_2 as the new trust anchor.  Thus, algorithm 2 is\
    \ the only\n   signaled algorithm by now.  That is, we only need RRSIG_K_2(DNSKEY)\n\
    \   to authenticate the DNSKEY RRset, and we are still compliant with\n   Section\
    \ 2.2 of RFC 4035: There must be an RRSIG for each RRset using\n   at least one\
    \ DNSKEY of each algorithm in the zone apex DNSKEY RRset.\n"
- title: 4.1.4.3.  Single Signing Type Algorithm Rollover, RFC 5011 Style
  contents:
  - "4.1.4.3.  Single Signing Type Algorithm Rollover, RFC 5011 Style\n   If a decision\
    \ is made to perform an RFC 5011 style rollover with a\n   Single Signing Scheme\
    \ key, it should be noted that Section 2.1 of\n   RFC 5011 states:\n      Once\
    \ the resolver sees the REVOKE bit, it MUST NOT use this key\n      as a trust\
    \ anchor or for any other purpose except to validate\n      the RRSIG it signed\
    \ over the DNSKEY RRset specifically for the\n      purpose of validating the\
    \ revocation.\n   This means that once DNSKEY_S_1 is revoked, it cannot be used\
    \ to\n   validate its signatures over non-DNSKEY RRsets.  Thus, those RRsets\n\
    \   should be signed with a shadow key, DNSKEY_Z_10, during the algorithm\n  \
    \ rollover.  The shadow key can be removed at the same time the revoked\n   DNSKEY_S_1\
    \ is removed from the zone.  In other words, the zone must\n   temporarily fall\
    \ back to a KSK/ZSK split model during the rollover.\n   In other words, the rule\
    \ that at every RRset there must be at least\n   one signature for each algorithm\
    \ used in the DNSKEY RRset still\n   applies.  This means that a different key\
    \ with the same algorithm,\n   other than the revoked key, must sign the entire\
    \ zone.  Thus, more\n   operations are needed if the Single-Type Signing Scheme\
    \ is used.\n   Before rolling the algorithm, a new key must be introduced with\
    \ the\n   same algorithm as the key that is a candidate for revocation.  That\n\
    \   key can than temporarily act as a ZSK during the algorithm rollover.\n   As\
    \ with algorithm rollover RFC 5011 style, while all zone data must\n   be signed\
    \ with an unrevoked key, it is permissible to sign the key\n   set with a revoked\
    \ key using the same esoteric argument given in\n   Section 4.1.4.2.\n   The lesson\
    \ of all of this is that a Single-Type Signing Scheme\n   algorithm rollover using\
    \ RFC 5011 is as complicated as the name of\n   the rollover implies: Reverting\
    \ to a split-key scheme for the\n   duration of the rollover may be preferable.\n"
- title: 4.1.4.4.  NSEC-to-NSEC3 Algorithm Rollover
  contents:
  - "4.1.4.4.  NSEC-to-NSEC3 Algorithm Rollover\n   A special case is the rollover\
    \ from an NSEC signed zone to an NSEC3\n   signed zone.  In this case, algorithm\
    \ numbers are used to signal\n   support for NSEC3 but they do not mandate the\
    \ use of NSEC3.\n   Therefore, NSEC records should remain in the zone until the\
    \ rollover\n   to a new algorithm has completed and the new DNSKEY RRset has\n\
    \   populated distant caches, at the end of the \"new DNSKEY\" stage.  At\n  \
    \ that point, the validators that have not implemented NSEC3 will treat\n   the\
    \ zone as unsecured as soon as they follow the chain of trust to\n   the DS that\
    \ points to a DNSKEY of the new algorithm, while validators\n   that support NSEC3\
    \ will happily validate using NSEC.  Turning on\n   NSEC3 can then be done during\
    \ the \"new DS\" step: increasing the\n   serial number, introducing the NSEC3PARAM\
    \ record to signal that\n   NSEC3-authenticated data related to denial of existence\
    \ should be\n   served, and re-signing the zone.\n   In summary, an NSEC-to-NSEC3\
    \ rollover is an ordinary algorithm\n   rollover whereby NSEC is used all the\
    \ time and only after that\n   rollover finished NSEC3 needs to be deployed. \
    \ The procedures are\n   also listed in Sections 10.4 and 10.5 of RFC 5155 [RFC5155].\n"
- title: 4.1.5.  Considerations for Automated Key Rollovers
  contents:
  - "4.1.5.  Considerations for Automated Key Rollovers\n   As keys must be renewed\
    \ periodically, there is some motivation to\n   automate the rollover process.\
    \  Consider the following:\n   o  ZSK rollovers are easy to automate, as only\
    \ the child zone is\n      involved.\n   o  A KSK rollover needs interaction between\
    \ the parent and child.\n      Data exchange is needed to provide the new keys\
    \ to the parent;\n      consequently, this data must be authenticated, and integrity\
    \ must\n      be guaranteed in order to avoid attacks on the rollover.\n"
- title: 4.2.  Planning for Emergency Key Rollover
  contents:
  - "4.2.  Planning for Emergency Key Rollover\n   This section deals with preparation\
    \ for a possible key compromise.\n   It is advisable to have a documented procedure\
    \ ready for those times\n   when a key compromise is suspected or confirmed.\n\
    \   When the private material of one of a zone's keys is compromised, it\n   can\
    \ be used by an attacker for as long as a valid trust chain exists.\n   A trust\
    \ chain remains intact for\n   o  as long as a signature over the compromised\
    \ key in the trust chain\n      is valid, and\n   o  as long as the DS RR in the\
    \ parent zone points to the\n      (compromised) key signing the DNSKEY RRset,\
    \ and\n   o  as long as the (compromised) key is anchored in a resolver and is\n\
    \      used as a starting point for validation (this is generally the\n      hardest\
    \ to update).\n   While a trust chain to a zone's compromised key exists, your\n\
    \   namespace is vulnerable to abuse by anyone who has obtained\n   illegitimate\
    \ possession of the key.  Zone administrators have to make\n   a decision as to\
    \ whether the abuse of the compromised key is worse\n   than having data in caches\
    \ that cannot be validated.  If the zone\n   administrator chooses to break the\
    \ trust chain to the compromised\n   key, data in caches signed with this key\
    \ cannot be validated.\n   However, if the zone administrator chooses to take\
    \ the path of a\n   regular rollover, during the rollover the malicious key holder\
    \ can\n   continue to spoof data so that it appears to be valid.\n"
- title: 4.2.1.  KSK Compromise
  contents:
  - "4.2.1.  KSK Compromise\n   A compromised KSK can be used to sign the key set\
    \ of an attacker's\n   version of the zone.  That zone could be used to poison\
    \ the DNS.\n   A zone containing a DNSKEY RRset with a compromised KSK is vulnerable\n\
    \   as long as the compromised KSK is configured as the trust anchor or a\n  \
    \ DS record in the parent zone points to it.\n   Therefore, when the KSK has been\
    \ compromised, the trust anchor or the\n   parent DS record should be replaced\
    \ as soon as possible.  It is local\n   policy whether to break the trust chain\
    \ during the emergency\n   rollover.  The trust chain would be broken when the\
    \ compromised KSK\n   is removed from the child's zone while the parent still\
    \ has a DS\n   record pointing to the compromised KSK.  The assumption is that\
    \ there\n   is only one DS record at the parent.  If there are multiple DS\n \
    \  records, this does not apply, although the chain of trust of this\n   particular\
    \ key is broken.\n   Note that an attacker's version of the zone still uses the\n\
    \   compromised KSK, and the presence of the corresponding DS record in\n   the\
    \ parent would cause the data in this zone to appear as valid.\n   Removing the\
    \ compromised key would cause the attacker's version of\n   the zone to appear\
    \ as valid and the original zone as Bogus.\n   Therefore, we advise administrators\
    \ not to remove the KSK before the\n   parent has a DS record for the new KSK\
    \ in place.\n"
- title: 4.2.1.1.  Emergency Key Rollover Keeping the Chain of Trust Intact
  contents:
  - "4.2.1.1.  Emergency Key Rollover Keeping the Chain of Trust Intact\n   If it\
    \ is desired to perform an emergency key rollover in a manner\n   that keeps the\
    \ chain of trust intact, the timing of the replacement\n   of the KSK is somewhat\
    \ critical.  The goal is to remove the\n   compromised KSK as soon as the new\
    \ DS RR is available at the parent.\n   This means ensuring that the signature\
    \ made with a new KSK over the\n   key set that contains the compromised KSK expires\
    \ just after the new\n   DS appears at the parent.  Expiration of that signature\
    \ will cause\n   expiration of that key set from the caches.\n   The procedure\
    \ is as follows:\n   1.  Introduce a new KSK into the key set; keep the compromised\
    \ KSK in\n       the key set.  Lower the TTL for DNSKEYs so that the DNSKEY RRset\n\
    \       will expire from caches sooner.\n   2.  Sign the key set, with a short\
    \ validity period.  The validity\n       period should expire shortly after the\
    \ DS is expected to appear\n       in the parent and the old DSs have expired\
    \ from caches.  This\n       provides an upper limit on how long the compromised\
    \ KSK can be\n       used in a replay attack.\n   3.  Upload the DS for this new\
    \ key to the parent.\n   4.  Follow the procedure of the regular KSK rollover:\
    \ Wait for the DS\n       to appear at the authoritative servers, and then wait\
    \ as long as\n       the TTL of the old DS RRs.  If necessary, re-sign the DNSKEY\n\
    \       RRset and modify/extend the expiration time.\n   5.  Remove the compromised\
    \ DNSKEY RR from the zone, and re-sign the\n       key set using your \"normal\"\
    \ TTL and signature validity period.\n   An additional danger of a key compromise\
    \ is that the compromised key\n   could be used to facilitate a legitimate-looking\
    \ DNSKEY/DS rollover\n   and/or name server changes at the parent.  When that\
    \ happens, the\n   domain may be in dispute.  An authenticated out-of-band and\
    \ secure\n   notify mechanism to contact a parent is needed in this case.\n  \
    \ Note that this is only a problem when the DNSKEY and/or DS records\n   are used\
    \ to authenticate communication with the parent.\n"
- title: 4.2.1.2.  Emergency Key Rollover Breaking the Chain of Trust
  contents:
  - "4.2.1.2.  Emergency Key Rollover Breaking the Chain of Trust\n   There are two\
    \ methods to perform an emergency key rollover in a\n   manner that breaks the\
    \ chain of trust.  The first method causes the\n   child zone to appear Bogus\
    \ to validating resolvers.  The other causes\n   the child zone to appear Insecure.\
    \  These are described below.\n   In the method that causes the child zone to\
    \ appear Bogus to\n   validating resolvers, the child zone replaces the current\
    \ KSK with a\n   new one and re-signs the key set.  Next, it sends the DS of the\
    \ new\n   key to the parent.  Only after the parent has placed the new DS in\n\
    \   the zone is the child's chain of trust repaired.  Note that until\n   that\
    \ time, the child zone is still vulnerable to spoofing: The\n   attacker is still\
    \ in possession of the compromised key that the DS\n   points to.\n   An alternative\
    \ method of breaking the chain of trust is by removing\n   the DS RRs from the\
    \ parent zone altogether.  As a result, the child\n   zone would become Insecure.\
    \  After the DS has expired from distant\n   caches, the keys and signatures are\
    \ removed from the child zone, new\n   keys and signatures are introduced, and\
    \ finally, a new DS is\n   submitted to the parent.\n"
- title: 4.2.2.  ZSK Compromise
  contents:
  - "4.2.2.  ZSK Compromise\n   Primarily because there is no interaction with the\
    \ parent required\n   when a ZSK is compromised, the situation is less severe\
    \ than with a\n   KSK compromise.  The zone must still be re-signed with a new\
    \ ZSK as\n   soon as possible.  As this is a local operation and requires no\n\
    \   communication between the parent and child, this can be achieved\n   fairly\
    \ quickly.  However, one has to take into account that -- just\n   as with a normal\
    \ rollover -- the immediate disappearance of the old\n   compromised key may lead\
    \ to verification problems.  Also note that\n   until the RRSIG over the compromised\
    \ ZSK has expired, the zone may\n   still be at risk.\n"
- title: 4.2.3.  Compromises of Keys Anchored in Resolvers
  contents:
  - "4.2.3.  Compromises of Keys Anchored in Resolvers\n   A key can also be pre-configured\
    \ in resolvers as a trust anchor.  If\n   trust anchor keys are compromised, the\
    \ administrators of resolvers\n   using these keys should be notified of this\
    \ fact.  Zone\n   administrators may consider setting up a mailing list to communicate\n\
    \   the fact that a SEP key is about to be rolled over.  This\n   communication\
    \ will of course need to be authenticated by some means,\n   e.g., by using digital\
    \ signatures.\n   End-users faced with the task of updating an anchored key should\n\
    \   always verify the new key.  New keys should be authenticated out-of-\n   band,\
    \ for example, through the use of an announcement website that is\n   secured\
    \ using Transport Layer Security (TLS) [RFC5246].\n"
- title: 4.2.4.  Stand-By Keys
  contents:
  - "4.2.4.  Stand-By Keys\n   Stand-by keys are keys that are published in your zone\
    \ but are not\n   used to sign RRsets.  There are two reasons why someone would\
    \ want to\n   use stand-by keys.  One is to speed up the emergency key rollover.\n\
    \   The other is to recover from a disaster that leaves your production\n   private\
    \ keys inaccessible.\n   The way to deal with stand-by keys differs for ZSKs and\
    \ KSKs.  To\n   make a stand-by ZSK, you need to publish its DNSKEY RR.  To make\
    \ a\n   stand-by KSK, you need to get its DS RR published at the parent.\n   Assuming\
    \ you have your normal DNS operation, to prepare stand-by keys\n   you need to:\n\
    \   o  Generate a stand-by ZSK and KSK.  Store them safely in a location\n   \
    \   different than the place where the currently used ZSK and KSK are\n      held.\n\
    \   o  Pre-publish the DNSKEY RR of the stand-by ZSK in the zone.\n   o  Pre-publish\
    \ the DS of the stand-by KSK in the parent zone.\n   Now suppose a disaster occurs\
    \ and disables access to the currently\n   used keys.  To recover from that situation,\
    \ follow these procedures:\n   o  Set up your DNS operations and introduce the\
    \ stand-by KSK into the\n      zone.\n   o  Post-publish the disabled ZSK and\
    \ sign the zone with the stand-by\n      keys.\n   o  After some time, when the\
    \ new signatures have been propagated, the\n      old keys, old signatures, and\
    \ the old DS can be removed.\n   o  Generate a new stand-by key set at a different\
    \ location and\n      continue \"normal\" operation.\n"
- title: 4.3.  Parent Policies
  contents:
  - '4.3.  Parent Policies

    '
- title: 4.3.1.  Initial Key Exchanges and Parental Policies Considerations
  contents:
  - "4.3.1.  Initial Key Exchanges and Parental Policies Considerations\n   The initial\
    \ key exchange is always subject to the policies set by the\n   parent.  It is\
    \ specifically important in a registry-registrar-\n   registrant model where a\
    \ registry maintains the parent zone, and the\n   registrant (the user of the\
    \ child-domain name) deals with the\n   registry through an intermediary called\
    \ a registrar (see [RFC3375]\n   for a comprehensive definition).  The key material\
    \ is to be passed\n   from the DNS operator to the parent via a registrar, where\
    \ both the\n   DNS operator and registrar are selected by the registrant and might\n\
    \   be different organizations.  When designing a key exchange policy,\n   one\
    \ should take into account that the authentication and\n   authorization mechanisms\
    \ used during a key exchange should be as\n   strong as the authentication and\
    \ authorization mechanisms used for\n   the exchange of delegation information\
    \ between the parent and child.\n   That is, there is no implicit need in DNSSEC\
    \ to make the\n   authentication process stronger than it is for regular DNS.\n\
    \   Using the DNS itself as the source for the actual DNSKEY material has\n  \
    \ the benefit that it reduces the chances of user error.  A DNSKEY\n   query tool\
    \ can make use of the SEP bit [RFC4035] to select the proper\n   key(s) from a\
    \ DNSSEC key set, thereby reducing the chance that the\n   wrong DNSKEY is sent.\
    \  It can validate the self-signature over a key,\n   thereby verifying the ownership\
    \ of the private key material.\n   Fetching the DNSKEY from the DNS ensures that\
    \ the chain of trust\n   remains intact once the parent publishes the DS RR indicating\
    \ that\n   the child is secure.\n   Note: Out-of-band verification is still needed\
    \ when the key material\n   is fetched for the first time, even via DNS.  The\
    \ parent can never be\n   sure whether or not the DNSKEY RRs have been spoofed.\n\
    \   With some types of key rollovers, the DNSKEY is not pre-published,\n   and\
    \ a DNSKEY query tool is not able to retrieve the successor key.\n   In this case,\
    \ the out-of-band method is required.  This also allows\n   the child to determine\
    \ the digest algorithm of the DS record.\n"
- title: 4.3.2.  Storing Keys or Hashes?
  contents:
  - "4.3.2.  Storing Keys or Hashes?\n   When designing a registry system, one should\
    \ consider whether to\n   store the DNSKEYs and/or the corresponding DSs.  Since\
    \ a child zone\n   might wish to have a DS published using a message digest algorithm\n\
    \   not yet understood by the registry, the registry can't count on being\n  \
    \ able to generate the DS record from a raw DNSKEY.  Thus, we suggest\n   that\
    \ registry systems should be able to store DS RRs, even if they\n   also store\
    \ DNSKEYs (see also \"DNSSEC Trust Anchor Configuration and\n   Maintenance\"\
    \ [DNSSEC-TRUST-ANCHOR]).\n   The storage considerations also relate to the design\
    \ of the customer\n   interface and the method by which data is transferred between\
    \ the\n   registrant and registry: Will the child-zone administrator be able to\n\
    \   upload DS RRs with unknown hash algorithms, or does the interface\n   only\
    \ allow DNSKEYs?  When registries support the Extensible\n   Provisioning Protocol\
    \ (EPP) [RFC5910], that can be used for\n   registrar-registry interactions, since\
    \ that protocol allows the\n   transfer of both DS and, optionally, DNSKEY RRs.\
    \  There is no\n   standardized way to move the data between the customer and\
    \ the\n   registrar.  Different registrars have different mechanisms, ranging\n\
    \   from simple web interfaces to various APIs.  In some cases, the use\n   of\
    \ the DNSSEC extensions to EPP may be applicable.\n   Having an out-of-band mechanism\
    \ such as a registry directory (e.g.,\n   Whois) to find out which keys are used\
    \ to generate DS Resource\n   Records for specific owners and/or zones may also\
    \ help with\n   troubleshooting.\n"
- title: 4.3.3.  Security Lameness
  contents:
  - "4.3.3.  Security Lameness\n   Security lameness is defined as the state whereby\
    \ the parent has a DS\n   RR pointing to a nonexistent DNSKEY RR.  Security lameness\
    \ may occur\n   temporarily during a Double-DS rollover scheme.  However, care\
    \ should\n   be taken that not all DS RRs are pointing to a nonexistent DNSKEY\
    \ RR,\n   which will cause the child's zone to be marked Bogus by verifying DNS\n\
    \   clients.\n   As part of a comprehensive delegation check, the parent could,\
    \ at key\n   exchange time, verify that the child's key is actually configured\
    \ in\n   the DNS.  However, if a parent does not understand the hashing\n   algorithm\
    \ used by the child, the parental checks are limited to only\n   comparing the\
    \ key id.\n   Child zones should be very careful in removing DNSKEY material --\n\
    \   specifically, SEP keys -- for which a DS RR exists.\n   Once a zone is \"\
    security lame\", a fix (e.g., removing a DS RR) will\n   take time to propagate\
    \ through the DNS.\n"
- title: 4.3.4.  DS Signature Validity Period
  contents:
  - "4.3.4.  DS Signature Validity Period\n   Since the DS can be replayed as long\
    \ as it has a valid signature, a\n   short signature validity period for the DS\
    \ RRSIG minimizes the time\n   that a child is vulnerable in the case of a compromise\
    \ of the child's\n   KSK(s).  A signature validity period that is too short introduces\
    \ the\n   possibility that a zone is marked Bogus in the case of a\n   configuration\
    \ error in the signer.  There may not be enough time to\n   fix the problems before\
    \ signatures expire (this is a generic\n   argument; also see Section 4.4.2).\
    \  Something as mundane as zone\n   administrator unavailability during weekends\
    \ shows the need for DS\n   signature validity periods longer than two days. \
    \ Just like any\n   signature validity period, we suggest an absolute minimum\
    \ for the DS\n   signature validity period of a few days.\n   The maximum signature\
    \ validity period of the DS record depends on how\n   long child zones are willing\
    \ to be vulnerable after a key compromise.\n   On the other hand, shortening the\
    \ DS signature validity period\n   increases the operational risk for the parent.\
    \  Therefore, the parent\n   may have a policy to use a signature validity period\
    \ that is\n   considerably longer than the child would hope for.\n   A compromise\
    \ between the policy/operational constraints of the parent\n   and minimizing\
    \ damage for the child may result in a DS signature\n   validity period somewhere\
    \ between a week and several months.\n   In addition to the signature validity\
    \ period, which sets a lower\n   bound on the number of times the zone administrator\
    \ will need to sign\n   the zone data and an upper bound on the time that a child\
    \ is\n   vulnerable after key compromise, there is the TTL value on the DS\n \
    \  RRs.  Shortening the TTL reduces the damage of a successful replay\n   attack.\
    \  It does mean that the authoritative servers will see more\n   queries.  But\
    \ on the other hand, a short TTL lowers the persistence\n   of DS RRsets in caches,\
    \ thereby increasing the speed with which\n   updated DS RRsets propagate through\
    \ the DNS.\n"
- title: 4.3.5.  Changing DNS Operators
  contents:
  - "4.3.5.  Changing DNS Operators\n   The parent-child relationship is often described\
    \ in terms of a\n   registry-registrar-registrant model, where a registry maintains\
    \ the\n   parent zone and the registrant (the user of the child-domain name)\n\
    \   deals with the registry through an intermediary called a registrar\n   [RFC3375].\
    \  Registrants may outsource the maintenance of their DNS\n   system, including\
    \ the maintenance of DNSSEC key material, to the\n   registrar or to another third\
    \ party, referred to here as the DNS\n   operator.\n   For various reasons, a\
    \ registrant may want to move between DNS\n   operators.  How easy this move will\
    \ be depends principally on the DNS\n   operator from which the registrant is\
    \ moving (the losing operator),\n   as the losing operator has control over the\
    \ DNS zone and its keys.\n   The following sections describe the two cases: where\
    \ the losing\n   operator cooperates with the new operator (the gaining operator),\
    \ and\n   where the two do not cooperate.\n"
- title: 4.3.5.1.  Cooperating DNS Operators
  contents:
  - "4.3.5.1.  Cooperating DNS Operators\n   In this scenario, it is assumed that\
    \ the losing operator will not\n   pass any private key material to the gaining\
    \ operator (that would\n   constitute a trivial case) but is otherwise fully cooperative.\n\
    \   In this environment, the change could be made with a Pre-Publish ZSK\n   rollover,\
    \ whereby the losing operator pre-publishes the ZSK of the\n   gaining operator,\
    \ combined with a Double-Signature KSK rollover where\n   the two registrars exchange\
    \ public keys and independently generate a\n   signature over those key sets that\
    \ they combine and both publish in\n   their copy of the zone.  Once that is done,\
    \ they can use their own\n   private keys to sign any of their zone content during\
    \ the transfer.\n    ------------------------------------------------------------\n\
    \    initial            |        pre-publish                    |\n    ------------------------------------------------------------\n\
    \    Parent:\n     NS_A                            NS_A\n     DS_A           \
    \                 DS_A\n    ------------------------------------------------------------\n\
    \    Child at A:            Child at A:        Child at B:\n     SOA_A0      \
    \           SOA_A1             SOA_B0\n     RRSIG_Z_A(SOA)         RRSIG_Z_A(SOA)\
    \     RRSIG_Z_B(SOA)\n     NS_A                   NS_A               NS_B\n  \
    \   RRSIG_Z_A(NS)          NS_B               RRSIG_Z_B(NS)\n                \
    \            RRSIG_Z_A(NS)\n     DNSKEY_Z_A             DNSKEY_Z_A         DNSKEY_Z_A\n\
    \                            DNSKEY_Z_B         DNSKEY_Z_B\n     DNSKEY_K_A  \
    \           DNSKEY_K_A         DNSKEY_K_A\n                            DNSKEY_K_B\
    \         DNSKEY_K_B\n     RRSIG_K_A(DNSKEY)      RRSIG_K_A(DNSKEY)  RRSIG_K_A(DNSKEY)\n\
    \                            RRSIG_K_B(DNSKEY)  RRSIG_K_B(DNSKEY)\n    ------------------------------------------------------------\n\
    \    ------------------------------------------------------------\n          re-delegation\
    \                |   post-migration      |\n    ------------------------------------------------------------\n\
    \    Parent:\n              NS_B                           NS_B\n            \
    \  DS_B                           DS_B\n    ------------------------------------------------------------\n\
    \    Child at A:        Child at B:           Child at B:\n     SOA_A1       \
    \      SOA_B0                SOA_B1\n     RRSIG_Z_A(SOA)     RRSIG_Z_B(SOA)  \
    \      RRSIG_Z_B(SOA)\n     NS_A               NS_B                  NS_B\n  \
    \   NS_B               RRSIG_Z_B(NS)         RRSIG_Z_B(NS)\n     RRSIG_Z_A(NS)\n\
    \     DNSKEY_Z_A         DNSKEY_Z_A\n     DNSKEY_Z_B         DNSKEY_Z_B      \
    \      DNSKEY_Z_B\n     DNSKEY_K_A         DNSKEY_K_A\n     DNSKEY_K_B       \
    \  DNSKEY_K_B            DNSKEY_K_B\n     RRSIG_K_A(DNSKEY)  RRSIG_K_A(DNSKEY)\n\
    \     RRSIG_K_B(DNSKEY)  RRSIG_K_B(DNSKEY)     RRSIG_K_B(DNSKEY)\n    ------------------------------------------------------------\n\
    \               Figure 10: Rollover for Cooperating Operators\n   In this figure,\
    \ A denotes the losing operator and B the gaining\n   operator.  RRSIG_Z is the\
    \ RRSIG produced by a ZSK, RRSIG_K is\n   produced with a KSK, and the appended\
    \ A or B indicates the producers\n   of the key pair.  \"Child at A\" is how the\
    \ zone content is represented\n   by the losing DNS operator, and \"Child at B\"\
    \ is how the zone content\n   is represented by the gaining DNS operator.\n  \
    \ The zone is initially delegated from the parent to the name servers\n   of operator\
    \ A.  Operator A uses his own ZSK and KSK to sign the zone.\n   The cooperating\
    \ operator A will pre-publish the new NS record and the\n   ZSK and KSK of operator\
    \ B, including the RRSIG over the DNSKEY RRset\n   generated by the KSK of operator\
    \ B.  Operator B needs to publish the\n   same DNSKEY RRset.  When that DNSKEY\
    \ RRset has populated the caches,\n   the re-delegation can be made, which involves\
    \ adjusting the NS and DS\n   records in the parent zone to point to operator\
    \ B.  And after all\n   DNSSEC records related to operator A have expired from\
    \ the caches,\n   operator B can stop publishing the keys and signatures belonging\
    \ to\n   operator A, and vice versa.\n   The requirement to exchange signatures\
    \ has a couple of drawbacks.  It\n   requires more operational overhead, because\
    \ not only do the operators\n   have to exchange public keys but they also have\
    \ to exchange the\n   signatures of the new DNSKEY RRset.  This drawback does\
    \ not exist if\n   the Double-Signature KSK rollover is replaced with a Double-DS\
    \ KSK\n   rollover.  See Figure 15 in Appendix D for the diagram.\n   Thus, if\
    \ the registry and registrars allow DS records to be published\n   that do not\
    \ point to a published DNSKEY in the child zone, the\n   Double-DS KSK rollover\
    \ is preferred (see Figure 5), in combination\n   with the Pre-Publish ZSK rollover.\
    \  This does not require sharing the\n   KSK signatures between the operators,\
    \ but both operators still have\n   to publish each other's ZSKs.\n"
- title: 4.3.5.2.  Non-Cooperating DNS Operators
  contents:
  - "4.3.5.2.  Non-Cooperating DNS Operators\n   In the non-cooperating case, matters\
    \ are more complicated.  The\n   losing operator may not cooperate and leave the\
    \ data in the DNS as\n   is.  In extreme cases, the losing operator may become\
    \ obstructive and\n   publish a DNSKEY RR with a high TTL and corresponding signature\n\
    \   validity period so that registrar A's DNSKEY could end up in caches\n   for\
    \ (in theory at least) decades.\n   The problem arises when a validator tries\
    \ to validate with the losing\n   operator's key and there is no signature material\
    \ produced with the\n   losing operator available in the delegation path after\
    \ re-delegation\n   from the losing operator to the gaining operator has taken\
    \ place.\n   One could imagine a rollover scenario where the gaining operator\n\
    \   takes a copy of all RRSIGs created by the losing operator and\n   publishes\
    \ those in conjunction with its own signatures, but that\n   would not allow any\
    \ changes in the zone content.  Since a\n   re-delegation took place, the NS RRset\
    \ has by definition changed, so\n   such a rollover scenario will not work.  Besides,\
    \ if zone transfers\n   are not allowed by the losing operator and NSEC3 is deployed\
    \ in the\n   losing operator's zone, then the gaining operator's zone will not\n\
    \   have certainty that all of the losing operator's RRSIGs have been\n   copied.\n\
    \   The only viable operation for the registrant is to have his zone go\n   Insecure\
    \ for the duration of the change.  The registry should be\n   asked to remove\
    \ the DS RR pointing to the losing operator's DNSKEY\n   and to change the NS\
    \ RRset to point to the gaining operator.  Once\n   this has propagated through\
    \ the DNS, the registry should be asked to\n   insert the DS record pointing to\
    \ the (newly signed) zone at\n   operator B.\n   Note that some behaviors of resolver\
    \ implementations may aid in the\n   process of changing DNS operators:\n   o\
    \  TTL sanity checking, as described in RFC 2308 [RFC2308], will\n      limit\
    \ the impact of the actions of an obstructive losing operator.\n      Resolvers\
    \ that implement TTL sanity checking will use an upper\n      limit for TTLs on\
    \ RRsets in responses.\n   o  If RRsets at the zone cut (are about to) expire,\
    \ the resolver\n      restarts its search above the zone cut.  Otherwise, the\
    \ resolver\n      risks continuing to use a name server that might be un-delegated\n\
    \      by the parent.\n   o  Limiting the time that DNSKEYs that seem to be unable\
    \ to validate\n      signatures are cached and/or trying to recover from cases\
    \ where\n      DNSKEYs do not seem to be able to validate data also reduce the\n\
    \      effects of the problem of non-cooperating registrars.\n   However, there\
    \ is no operational methodology to work around this\n   business issue, and proper\
    \ contractual relationships between all\n   involved parties seem to be the only\
    \ solution to cope with these\n   problems.  It should be noted that in many cases,\
    \ the problem with\n   temporary broken delegations already exists when a zone\
    \ changes from\n   one DNS operator to another.  Besides, it is often the case\
    \ that when\n   operators are changed, the services that are referenced by that\
    \ zone\n   also change operators, possibly involving some downtime.\n   In any\
    \ case, to minimize such problems, the classic configuration is\n   to have relatively\
    \ short TTLs on all involved Resource Records.  That\n   will solve many of the\
    \ problems regarding changes to a zone,\n   regardless of whether DNSSEC is used.\n"
- title: 4.4.  Time in DNSSEC
  contents:
  - "4.4.  Time in DNSSEC\n   Without DNSSEC, all times in the DNS are relative. \
    \ The SOA fields\n   REFRESH, RETRY, and EXPIRATION are timers used to determine\
    \ the time\n   that has elapsed after a slave server synchronized with a master\n\
    \   server.  The TTL value and the SOA RR minimum TTL parameter [RFC2308]\n  \
    \ are used to determine how long a forwarder should cache data (or\n   negative\
    \ responses) after it has been fetched from an authoritative\n   server.  By using\
    \ a signature validity period, DNSSEC introduces the\n   notion of an absolute\
    \ time in the DNS.  Signatures in DNSSEC have an\n   expiration date after which\
    \ the signature is marked as invalid and\n   the signed data is to be considered\
    \ Bogus.\n   The considerations in this section are all qualitative and focused\
    \ on\n   the operational and managerial issues.  A more thorough quantitative\n\
    \   analysis of rollover timing parameters can be found in \"DNSSEC Key\n   Timing\
    \ Considerations\" [DNSSEC-KEY-TIMING].\n"
- title: 4.4.1.  Time Considerations
  contents:
  - "4.4.1.  Time Considerations\n   Because of the expiration of signatures, one\
    \ should consider the\n   following:\n   o  We suggest that the Maximum Zone TTL\
    \ value of your zone data be\n      smaller than your signature validity period.\n\
    \         If the TTL duration was similar to that of the signature\n         validity\
    \ period, then all RRsets fetched during the validity\n         period would be\
    \ cached until the signature expiration time.\n         Section 8.1 of RFC 4033\
    \ [RFC4033] suggests that \"the resolver\n         may use the time remaining\
    \ before expiration of the signature\n         validity period of a signed RRset\
    \ as an upper bound for the\n         TTL\".  As a result, the query load on authoritative\
    \ servers\n         would peak at the signature expiration time, as this is also\n\
    \         the time at which records simultaneously expire from caches.\n     \
    \    Having a TTL that is at least a few times smaller than your\n         signature\
    \ validity period avoids query load peaks.\n   o  We suggest that the signature\
    \ publication period end at least one\n      Maximum Zone TTL duration (but preferably\
    \ a minimum of a few days)\n      before the end of the signature validity period.\n\
    \         Re-signing a zone shortly before the end of the signature\n        \
    \ validity period may cause the simultaneous expiration of data\n         from\
    \ caches.  This in turn may lead to peaks in the load on\n         authoritative\
    \ servers.  To avoid this, schemes are deployed\n         whereby the zone is\
    \ periodically visited for a re-signing\n         operation, and those signatures\
    \ that are within a so-called\n         Refresh Period from signature expiration\
    \ are recreated.  Also\n         see Section 4.4.2 below.\n         In the case\
    \ of an operational error, you would have one Maximum\n         Zone TTL duration\
    \ to resolve the problem.  Re-signing a zone a\n         few days before the end\
    \ of the signature validity period\n         ensures that the signatures will\
    \ survive at least a (long)\n         weekend in case of such operational havoc.\
    \  This is called the\n         Refresh Period (see Section 4.4.2).\n   o  We\
    \ suggest that the Minimum Zone TTL be long enough to both fetch\n      and verify\
    \ all the RRs in the trust chain.  In workshop\n      environments, it has been\
    \ demonstrated [NIST-Workshop] that a low\n      TTL (under 5 to 10 minutes) caused\
    \ disruptions because of the\n      following two problems:\n      1.  During\
    \ validation, some data may expire before the validation\n          is complete.\
    \  The validator should be able to keep all data\n          until it is completed.\
    \  This applies to all RRs needed to\n          complete the chain of trust: DS,\
    \ DNSKEY, RRSIG, and the final\n          answers, i.e., the RRset that is returned\
    \ for the initial\n          query.\n      2.  Frequent verification causes load\
    \ on recursive name servers.\n          Data at delegation points, DS, DNSKEY,\
    \ and RRSIG RRs benefits\n          from caching.  The TTL on those should be\
    \ relatively long.\n          Data at the leaves in the DNS tree has less impact\
    \ on\n          recursive name servers.\n   o  Slave servers will need to be able\
    \ to fetch newly signed zones\n      well before the RRSIGs in the zone served\
    \ by the slave server pass\n      their signature expiration time.\n         When\
    \ a slave server is out of synchronization with its master\n         and data\
    \ in a zone is signed by expired signatures, it may be\n         better for the\
    \ slave server not to give out any answer.\n         Normally, a slave server\
    \ that is not able to contact a master\n         server for an extended period\
    \ will expire a zone.  When that\n         happens, the server will respond differently\
    \ to queries for\n         that zone.  Some servers issue SERVFAIL, whereas others\
    \ turn\n         off the AA bit in the answers.  The time of expiration is set\n\
    \         in the SOA record and is relative to the last successful\n         refresh\
    \ between the master and the slave servers.  There exists\n         no coupling\
    \ between the signature expiration of RRSIGs in the\n         zone and the expire\
    \ parameter in the SOA.\n         If the server serves a DNSSEC-secured zone,\
    \ then it may happen\n         that the signatures expire well before the SOA\
    \ expiration timer\n         counts down to zero.  It is not possible to completely\
    \ prevent\n         this by modifying the SOA parameters.\n         However, the\
    \ effects can be minimized where the SOA expiration\n         time is equal to\
    \ or shorter than the Refresh Period (see\n         Section 4.4.2).\n        \
    \ The consequence of an authoritative server not being able to\n         update\
    \ a zone for an extended period of time is that signatures\n         may expire.\
    \  In this case, non-secure resolvers will continue\n         to be able to resolve\
    \ data served by the particular slave\n         servers, while security-aware\
    \ resolvers will experience\n         problems because of answers being marked\
    \ as Bogus.\n         We suggest that the SOA expiration timer be approximately\
    \ one\n         third or a quarter of the signature validity period.  It will\n\
    \         allow problems with transfers from the master server to be\n       \
    \  noticed before signatures time out.\n         We also suggest that operators\
    \ of name servers that supply\n         secondary services develop systems to\
    \ identify upcoming\n         signature expirations in zones they slave and take\
    \ appropriate\n         action where such an event is detected.\n         When\
    \ determining the value for the expiration parameter, one\n         has to take\
    \ the following into account: What are the chances\n         that all secondaries\
    \ expire the zone?  How quickly can the\n         administrators of the secondary\
    \ servers be reached to load a\n         valid zone?  These questions are not\
    \ DNSSEC-specific but may\n         influence the choice of your signature validity\
    \ periods.\n"
- title: 4.4.2.  Signature Validity Periods
  contents:
  - '4.4.2.  Signature Validity Periods

    '
- title: 4.4.2.1.  Maximum Value
  contents:
  - "4.4.2.1.  Maximum Value\n   The first consideration for choosing a maximum signature\
    \ validity\n   period is the risk of a replay attack.  For low-value, long-term\n\
    \   stable resources, the risks may be minimal, and the signature\n   validity\
    \ period may be several months.  Although signature validity\n   periods of many\
    \ years are allowed, the same \"operational habit\"\n   arguments as those given\
    \ in Section 3.2.2 play a role: When a zone is\n   re-signed with some regularity,\
    \ then zone administrators remain\n   conscious of the operational necessity of\
    \ re-signing.\n"
- title: 4.4.2.2.  Minimum Value
  contents:
  - "4.4.2.2.  Minimum Value\n   The minimum value of the signature validity period\
    \ is set for the\n   time by which one would like to survive operational failure\
    \ in\n   provisioning: At what time will a failure be noticed, and at what\n \
    \  time is action expected to be taken?  By answering these questions,\n   availability\
    \ of zone administrators during (long) weekends or time\n   taken to access backup\
    \ media can be taken into account.  The result\n   could easily suggest a minimum\
    \ signature validity period of a few\n   days.\n   Note, however, that the argument\
    \ above is assuming that zone data has\n   just been signed and published when\
    \ the problem occurred.  In\n   practice, it may be that a zone is signed according\
    \ to a frequency\n   set by the Re-Sign Period, whereby the signer visits the\
    \ zone content\n   and only refreshes signatures that are within a given amount\
    \ of time\n   (the Refresh Period) of expiration.  The Re-Sign Period must be\n\
    \   smaller than the Refresh Period in order for zone data to be signed\n   in\
    \ a timely fashion.\n   If an operational problem occurs during re-signing, then\
    \ the\n   signatures in the zone to expire first are the ones that have been\n\
    \   generated longest ago.  In the worst case, these signatures are the\n   Refresh\
    \ Period minus the Re-Sign Period away from signature\n   expiration.\n   To make\
    \ matters slightly more complicated, some signers vary the\n   signature validity\
    \ period over a small range (the jitter interval) so\n   that not all signatures\
    \ expire at the same time.\n   In other words, the minimum signature validity\
    \ period is set by first\n   choosing the Refresh Period (usually a few days),\
    \ then defining the\n   Re-Sign Period in such a way that the Refresh Period minus\
    \ the\n   Re-Sign Period, minus the maximum jitter sets the time in which\n  \
    \ operational havoc can be resolved.\n   The relationship between signature times\
    \ is illustrated in Figure 11.\n   Inception          Signing                \
    \                 Expiration\n   time               time                     \
    \               time\n   |                  |                                \
    \ |     |     |\n   |------------------|---------------------------------|.....|.....|\n\
    \   |                  |                                 |     |     |\n     \
    \                                                     +/-jitter\n   | Inception\
    \ offset |                                       |\n   |<---------------->|  \
    \          Validity Period            |\n   |               |<---------------------------------------->|\n\
    \   Inception          Signing Reuse   Reuse   Reuse   New     Expiration\n  \
    \ time               time                            RRSIG   time\n   |      \
    \            |       |       |       |       |       |\n   |------------------|-------------------------------|-------|\n\
    \   |                  |       |       |       |       |       |\n           \
    \            <-----> <-----> <-----> <----->\n                     Re-Sign Period\n\
    \                                                |   Refresh   |\n           \
    \                                     |<----------->|\n                      \
    \                          |   Period    |\n                  Figure 11: Signature\
    \ Timing Parameters\n   Note that in the figure the validity of the signature\
    \ starts shortly\n   before the signing time.  That is done to deal with validators\
    \ that\n   might have some clock skew.  This is called the inception offset, and\n\
    \   it should be chosen so that false negatives are minimized to a\n   reasonable\
    \ level.\n"
- title: 4.4.2.3.  Differentiation between RRsets
  contents:
  - "4.4.2.3.  Differentiation between RRsets\n   It is possible to vary signature\
    \ validity periods between signatures\n   over different RRsets in the zone. \
    \ In practice, this could be done\n   when zones contain highly volatile data\
    \ (which may be the case in\n   dynamic-update environments).  Note, however,\
    \ that the risk of replay\n   (e.g., by stale secondary servers) should be the\
    \ leading factor in\n   determining the signature validity period, since the TTLs\
    \ on the data\n   itself are still the primary parameter for cache expiry.\n \
    \  In some cases, the risk of replaying existing data might be different\n   from\
    \ the risk of replaying the denial of data.  In those cases, the\n   signature\
    \ validity period on NSEC or NSEC3 records may be tweaked\n   accordingly.\n \
    \  When a zone contains secure delegations, then a relatively short\n   signature\
    \ validity period protects the child against replay attacks\n   in the case where\
    \ the child's key is compromised (see Section 4.3.4).\n   Since there is a higher\
    \ operational risk for the parent registry when\n   choosing a short validity\
    \ period and a higher operational risk for\n   the child when choosing a long\
    \ validity period, some (price)\n   differentiation may occur for validity periods\
    \ between individual DS\n   RRs in a single zone.\n   There seem to be no other\
    \ arguments for differentiation in validity\n   periods.\n"
- title: 5.  "Next Record" Types
  contents:
  - "5.  \"Next Record\" Types\n   One of the design tradeoffs made during the development\
    \ of DNSSEC was\n   to separate the signing and serving operations instead of\
    \ performing\n   cryptographic operations as DNS requests are being serviced.\
    \  It is\n   therefore necessary to create records that cover the very large\n\
    \   number of nonexistent names that lie between the names that do exist.\n  \
    \ There are two mechanisms to provide authenticated proof of\n   nonexistence\
    \ of domain names in DNSSEC: a clear-text one and an\n   obfuscated-data one.\
    \  Each mechanism:\n   o  includes a list of all the RRTYPEs present, which can\
    \ be used to\n      prove the nonexistence of RRTYPEs at a certain name;\n   o\
    \  stores only the name for which the zone is authoritative (that is,\n      glue\
    \ in the zone is omitted); and\n   o  uses a specific RRTYPE to store information\
    \ about the RRTYPEs\n      present at the name: The clear-text mechanism uses\
    \ NSEC, and the\n      obfuscated-data mechanism uses NSEC3.\n"
- title: 5.1.  Differences between NSEC and NSEC3
  contents:
  - "5.1.  Differences between NSEC and NSEC3\n   The clear-text mechanism (NSEC)\
    \ is implemented using a sorted linked\n   list of names in the zone.  The obfuscated-data\
    \ mechanism (NSEC3) is\n   similar but first hashes the names using a one-way\
    \ hash function,\n   before creating a sorted linked list of the resulting (hashed)\n\
    \   strings.\n   The NSEC record requires no cryptographic operations aside from\
    \ the\n   validation of its associated signature record.  It is human readable\n\
    \   and can be used in manual queries to determine correct operation.\n   The\
    \ disadvantage is that it allows for \"zone walking\", where one can\n   request\
    \ all the entries of a zone by following the linked list of\n   NSEC RRs via the\
    \ \"Next Domain Name\" field.  Though all agree that DNS\n   data is accessible\
    \ through query mechanisms, for some zone\n   administrators this behavior is\
    \ undesirable for policy, regulatory,\n   or other reasons.\n   Furthermore, NSEC\
    \ requires a signature over every RR in the zone\n   file, thereby ensuring that\
    \ any denial of existence is\n   cryptographically signed.  However, in a large\
    \ zone file containing\n   many delegations, very few of which are to signed zones,\
    \ this may\n   produce unacceptable additional overhead, especially where insecure\n\
    \   delegations are subject to frequent updates (a typical example might\n   be\
    \ a TLD operator with few registrants using secure delegations).\n   NSEC3 allows\
    \ intervals between two secure delegations to \"opt out\",\n   in which case they\
    \ may contain one or more insecure delegations, thus\n   reducing the size and\
    \ cryptographic complexity of the zone at the\n   expense of the ability to cryptographically\
    \ deny the existence of\n   names in a specific span.\n   The NSEC3 record uses\
    \ a hashing method of the requested name.  To\n   increase the workload required\
    \ to guess entries in the zone, the\n   number of hashing iterations can be specified\
    \ in the NSEC3 record.\n   Additionally, a salt can be specified that also modifies\
    \ the hashes.\n   Note that NSEC3 does not give full protection against information\n\
    \   leakage from the zone (you can still derive the size of the zone,\n   which\
    \ RRTYPEs are in there, etc.).\n"
- title: 5.2.  NSEC or NSEC3
  contents:
  - "5.2.  NSEC or NSEC3\n   The first motivation to deploy NSEC3 -- prevention of\
    \ zone\n   enumeration -- only makes sense when zone content is not highly\n \
    \  structured or trivially guessable.  Highly structured zones, such as\n   in-addr.arpa.,\
    \ ip6.arpa., and e164.arpa., can be trivially enumerated\n   using ordinary DNS\
    \ properties, while for small zones that only\n   contain records in the apex\
    \ of the zone and a few common names such\n   as \"www\" or \"mail\", guessing\
    \ zone content and proving completeness is\n   also trivial when using NSEC3.\
    \  In these cases, the use of NSEC is\n   preferred to ease the work required\
    \ by signers and validating\n   resolvers.\n   For large zones where there is\
    \ an implication of \"not readily\n   available\" names, such as those where one\
    \ has to sign a\n   non-disclosure agreement before obtaining it, NSEC3 is preferred.\n\
    \   The second reason to consider NSEC3 is \"Opt-Out\", which can reduce\n   the\
    \ number of NSEC3 records required.  This is discussed further\n   below (Section\
    \ 5.3.4).\n"
- title: 5.3.  NSEC3 Parameters
  contents:
  - "5.3.  NSEC3 Parameters\n   NSEC3 is controlled by a number of parameters, some\
    \ of which can be\n   varied: This section discusses the choice of those parameters.\n"
- title: 5.3.1.  NSEC3 Algorithm
  contents:
  - "5.3.1.  NSEC3 Algorithm\n   The NSEC3 hashing algorithm is performed on the Fully\
    \ Qualified\n   Domain Name (FQDN) in its uncompressed form.  This ensures that\
    \ brute\n   force work done by an attacker for one FQDN cannot be reused for\n\
    \   another FQDN attack, as these entries are by definition unique.\n   At the\
    \ time of this writing, there is only one NSEC3 hash algorithm\n   defined.  [RFC5155]\
    \ specifically states: \"When specifying a new hash\n   algorithm for use with\
    \ NSEC3, a transition mechanism MUST also be\n   defined\".  Therefore, this document\
    \ does not consider NSEC3 hash\n   algorithm transition.\n"
- title: 5.3.2.  NSEC3 Iterations
  contents:
  - "5.3.2.  NSEC3 Iterations\n   One of the concerns with NSEC3 is that a pre-calculated\
    \ dictionary\n   attack could be performed in order to assess whether or not certain\n\
    \   domain names exist within a zone.  Two mechanisms are introduced in\n   the\
    \ NSEC3 specification to increase the costs of such dictionary\n   attacks: iterations\
    \ and salt.\n   The iterations parameter defines the number of additional times\
    \ the\n   hash function has been performed.  A higher value results in greater\n\
    \   resiliency against dictionary attacks, at a higher computational cost\n  \
    \ for both the server and resolver.\n   RFC 5155 Section 10.3 [RFC5155] considers\
    \ the tradeoffs between\n   incurring cost during the signing process and imposing\
    \ costs to the\n   validating name server, while still providing a reasonable\
    \ barrier\n   against dictionary attacks.  It provides useful limits of iterations\n\
    \   for a given RSA key size.  These are 150 iterations for 1024-bit\n   keys,\
    \ 500 iterations for 2048-bit keys, and 2,500 iterations for\n   4096-bit keys.\
    \  Choosing a value of 100 iterations is deemed to be a\n   sufficiently costly,\
    \ yet not excessive, value: In the worst-case\n   scenario, the performance of\
    \ name servers would be halved, regardless\n   of key size [NSEC3-HASH-PERF].\n"
- title: 5.3.3.  NSEC3 Salt
  contents:
  - "5.3.3.  NSEC3 Salt\n   While the NSEC3 iterations parameter increases the cost\
    \ of hashing a\n   dictionary word, the NSEC3 salt reduces the lifetime for which\
    \ that\n   calculated hash can be used.  A change of the salt value by the zone\n\
    \   administrator would cause an attacker to lose all pre-calculated work\n  \
    \ for that zone.\n   There must be a complete NSEC3 chain using the same salt\
    \ value, that\n   matches the salt value in the NSEC3PARAM record.  NSEC3 salt\
    \ changes\n   do not need special rollover procedures.  Since changing the salt\n\
    \   requires that all the NSEC3 records be regenerated and thus requires\n   generating\
    \ new RRSIGs over these NSEC3 records, it makes sense to\n   align the change\
    \ of the salt with a change of the Zone Signing Key,\n   as that process in itself\
    \ already usually requires that all RRSIGs be\n   regenerated.  If there is no\
    \ critical dependency on incremental\n   signing and the zone can be signed with\
    \ little effort, there is no\n   need for such alignment.\n"
- title: 5.3.4.  Opt-Out
  contents:
  - "5.3.4.  Opt-Out\n   The Opt-Out mechanism was introduced to allow for a gradual\n\
    \   introduction of signed records in zones that contain mostly\n   delegation\
    \ records.  The use of the Opt-Out flag changes the meaning\n   of the NSEC3 span\
    \ from authoritative denial of the existence of names\n   within the span to proof\
    \ that DNSSEC is not available for the\n   delegations within the span.  This\
    \ allows for the addition or removal\n   of the delegations covered by the span\
    \ without recalculating or\n   re-signing RRs in the NSEC3 RR chain.\n   Opt-Out\
    \ is specified to be used only over delegation points and will\n   therefore only\
    \ bring relief to zones with a large number of insecure\n   delegations.  This\
    \ consideration typically holds for large TLDs and\n   similar zones; in most\
    \ other circumstances, Opt-Out should not be\n   deployed.  Further considerations\
    \ can be found in Section 12.2 of\n   RFC 5155 [RFC5155].\n"
- title: 6.  Security Considerations
  contents:
  - "6.  Security Considerations\n   DNSSEC adds data origin authentication and data\
    \ integrity to the DNS,\n   using digital signatures over Resource Record sets.\
    \  DNSSEC does not\n   protect against denial-of-service attacks, nor does it\
    \ provide\n   confidentiality.  For more general security considerations related\
    \ to\n   DNSSEC, please see RFC 4033 [RFC4033], RFC 4034 [RFC4034], and\n   RFC\
    \ 4035 [RFC4035].\n   This document tries to assess the operational considerations\
    \ to\n   maintain a stable and secure DNSSEC service.  When performing key\n \
    \  rollovers, it is important to keep in mind that it takes time for the\n   data\
    \ to be propagated to the verifying clients.  It is also important\n   to note\
    \ that this data may be cached.  Not taking into account the\n   'data propagation'\
    \ properties in the DNS may cause validation\n   failures, because cached data\
    \ may mismatch data fetched from the\n   authoritative servers; this will make\
    \ secured zones unavailable to\n   security-aware resolvers.\n"
- title: 7.  Acknowledgments
  contents:
  - "7.  Acknowledgments\n   Significant parts of the text of this document are copied\
    \ from\n   RFC 4641 [RFC4641].  That document was edited by Olaf Kolkman and\n\
    \   Miek Gieben.  Other people that contributed or were otherwise\n   involved\
    \ in that work were, in random order: Rip Loomis, Olafur\n   Gudmundsson, Wesley\
    \ Griffin, Michael Richardson, Scott Rose, Rick van\n   Rein, Tim McGinnis, Gilles\
    \ Guette, Olivier Courtay, Sam Weiler, Jelte\n   Jansen, Niall O'Reilly, Holger\
    \ Zuleger, Ed Lewis, Hilarie Orman,\n   Marcos Sanz, Peter Koch, Mike StJohns,\
    \ Emma Bretherick, Adrian\n   Bedford, Lindy Foster, and O. Courtay.\n   For this\
    \ version of the document, we would like to acknowledge people\n   who were actively\
    \ involved in the compilation of the document.  In\n   random order: Mark Andrews,\
    \ Patrik Faltstrom, Tony Finch, Alfred\n   Hoenes, Bill Manning, Scott Rose, Wouter\
    \ Wijngaards, Antoin\n   Verschuren, Marc Lampo, George Barwood, Sebastian Castro,\
    \ Suresh\n   Krishnaswamy, Eric Rescorla, Stephen Morris, Olafur Gudmundsson,\n\
    \   Ondrej Sury, and Rickard Bellgrim.\n"
- title: 8.  Contributors
  contents:
  - "8.  Contributors\n   Significant contributions to this document were from:\n\
    \      Paul Hoffman, who contributed on the choice of cryptographic\n      parameters\
    \ and addressing some of the trust anchor issues;\n      Jelte Jansen, who provided\
    \ the initial text in Section 4.1.4;\n      Paul Wouters, who provided the initial\
    \ text for Section 5, and\n      Alex Bligh, who improved it.\n   The figure in\
    \ Section 4.4.2 was adapted from the OpenDNSSEC user\n   documentation.\n"
- title: 9.  References
  contents:
  - '9.  References

    '
- title: 9.1.  Normative References
  contents:
  - "9.1.  Normative References\n   [RFC1034]  Mockapetris, P., \"Domain names - concepts\
    \ and facilities\",\n              STD 13, RFC 1034, November 1987.\n   [RFC1035]\
    \  Mockapetris, P., \"Domain names - implementation and\n              specification\"\
    , STD 13, RFC 1035, November 1987.\n   [RFC4033]  Arends, R., Austein, R., Larson,\
    \ M., Massey, D., and S.\n              Rose, \"DNS Security Introduction and\
    \ Requirements\",\n              RFC 4033, March 2005.\n   [RFC4034]  Arends,\
    \ R., Austein, R., Larson, M., Massey, D., and S.\n              Rose, \"Resource\
    \ Records for the DNS Security Extensions\",\n              RFC 4034, March 2005.\n\
    \   [RFC4035]  Arends, R., Austein, R., Larson, M., Massey, D., and S.\n     \
    \         Rose, \"Protocol Modifications for the DNS Security\n              Extensions\"\
    , RFC 4035, March 2005.\n   [RFC4509]  Hardaker, W., \"Use of SHA-256 in DNSSEC\
    \ Delegation Signer\n              (DS) Resource Records (RRs)\", RFC 4509, May\
    \ 2006.\n   [RFC5155]  Laurie, B., Sisson, G., Arends, R., and D. Blacka, \"DNS\n\
    \              Security (DNSSEC) Hashed Authenticated Denial of\n            \
    \  Existence\", RFC 5155, March 2008.\n   [RFC5702]  Jansen, J., \"Use of SHA-2\
    \ Algorithms with RSA in DNSKEY\n              and RRSIG Resource Records for\
    \ DNSSEC\", RFC 5702,\n              October 2009.\n"
- title: 9.2.  Informative References
  contents:
  - "9.2.  Informative References\n   [RFC1995]  Ohta, M., \"Incremental Zone Transfer\
    \ in DNS\", RFC 1995,\n              August 1996.\n   [RFC1996]  Vixie, P., \"\
    A Mechanism for Prompt Notification of Zone\n              Changes (DNS NOTIFY)\"\
    , RFC 1996, August 1996.\n   [RFC2119]  Bradner, S., \"Key words for use in RFCs\
    \ to Indicate\n              Requirement Levels\", BCP 14, RFC 2119, March 1997.\n\
    \   [RFC2308]  Andrews, M., \"Negative Caching of DNS Queries (DNS\n         \
    \     NCACHE)\", RFC 2308, March 1998.\n   [RFC3007]  Wellington, B., \"Secure\
    \ Domain Name System (DNS) Dynamic\n              Update\", RFC 3007, November\
    \ 2000.\n   [RFC3375]  Hollenbeck, S., \"Generic Registry-Registrar Protocol\n\
    \              Requirements\", RFC 3375, September 2002.\n   [RFC3766]  Orman,\
    \ H. and P. Hoffman, \"Determining Strengths For\n              Public Keys Used\
    \ For Exchanging Symmetric Keys\", BCP 86,\n              RFC 3766, April 2004.\n\
    \   [RFC4086]  Eastlake, D., Schiller, J., and S. Crocker, \"Randomness\n    \
    \          Requirements for Security\", BCP 106, RFC 4086, June 2005.\n   [RFC4641]\
    \  Kolkman, O. and R. Gieben, \"DNSSEC Operational Practices\",\n            \
    \  RFC 4641, September 2006.\n   [RFC4949]  Shirey, R., \"Internet Security Glossary,\
    \ Version 2\",\n              RFC 4949, August 2007.\n   [RFC5011]  StJohns, M.,\
    \ \"Automated Updates of DNS Security (DNSSEC)\n              Trust Anchors\"\
    , RFC 5011, September 2007.\n   [RFC5910]  Gould, J. and S. Hollenbeck, \"Domain\
    \ Name System (DNS)\n              Security Extensions Mapping for the Extensible\n\
    \              Provisioning Protocol (EPP)\", RFC 5910, May 2010.\n   [RFC5933]\
    \  Dolmatov, V., Chuprina, A., and I. Ustinov, \"Use of GOST\n              Signature\
    \ Algorithms in DNSKEY and RRSIG Resource Records\n              for DNSSEC\"\
    , RFC 5933, July 2010.\n   [RFC6605]  Hoffman, P. and W. Wijngaards, \"Elliptic\
    \ Curve Digital\n              Signature Algorithm (DSA) for DNSSEC\", RFC 6605,\n\
    \              April 2012.\n   [NIST-Workshop]\n              Rose, S., \"NIST\
    \ DNSSEC workshop notes\", July 2001,\n              <http://www.ietf.org/mail-archive/web/dnsop/current/\n\
    \              msg01020.html>.\n   [NIST-SP-800-90A]\n              Barker, E.\
    \ and J. Kelsey, \"Recommendation for Random\n              Number Generation\
    \ Using Deterministic Random Bit\n              Generators\", NIST Special Publication\
    \ 800-90A,\n              January 2012.\n   [RFC5246]  Dierks, T. and E. Rescorla,\
    \ \"The Transport Layer Security\n              (TLS) Protocol Version 1.2\",\
    \ RFC 5246, August 2008.\n   [DNSSEC-KEY-TIMING]\n              Morris, S., Ihren,\
    \ J., and J. Dickinson, \"DNSSEC Key\n              Timing Considerations\", Work\
    \ in Progress, July 2012.\n   [DNSSEC-DPS]\n              Ljunggren, F., Eklund\
    \ Lowinder, AM., and T. Okubo, \"A\n              Framework for DNSSEC Policies\
    \ and DNSSEC Practice\n              Statements\", Work in Progress, November\
    \ 2012.\n   [DNSSEC-TRUST-ANCHOR]\n              Larson, M. and O. Gudmundsson,\
    \ \"DNSSEC Trust Anchor\n              Configuration and Maintenance\", Work in\
    \ Progress,\n              October 2010.\n   [NSEC3-HASH-PERF]\n             \
    \ Schaeffer, Y., \"NSEC3 Hash Performance\", NLnet Labs\n              document\
    \ 2010-002, March 2010.\n"
- title: Appendix A.  Terminology
  contents:
  - "Appendix A.  Terminology\n   In this document, there is some jargon used that\
    \ is defined in other\n   documents.  In most cases, we have not copied the text\
    \ from the\n   documents defining the terms but have given a more elaborate\n\
    \   explanation of the meaning.  Note that these explanations should not\n   be\
    \ seen as authoritative.\n   Anchored key:  A DNSKEY configured in resolvers around\
    \ the globe.\n      This key is hard to update, hence the term 'anchored'.\n \
    \  Bogus:  Also see Section 5 of RFC 4033 [RFC4033].  An RRset in DNSSEC\n   \
    \   is marked \"Bogus\" when a signature of an RRset does not validate\n     \
    \ against a DNSKEY.\n   Key rollover:  A key rollover (also called key supercession\
    \ in some\n      environments) is the act of replacing one key pair with another\
    \ at\n      the end of a key effectivity period.\n   Key Signing Key or KSK: \
    \ A Key Signing Key (KSK) is a key that is\n      used exclusively for signing\
    \ the apex key set.  The fact that a\n      key is a KSK is only relevant to the\
    \ signing tool.\n   Key size:  The term 'key size' can be substituted by 'modulus\
    \ size'\n      throughout the document for RSA keys.  It is mathematically more\n\
    \      correct to use modulus size for RSA keys, but as this is a\n      document\
    \ directed at operators we feel more at ease with the term\n      'key size'.\n\
    \   Private and public keys:  DNSSEC secures the DNS through the use of\n    \
    \  public-key cryptography.  Public-key cryptography is based on the\n      existence\
    \ of two (mathematically related) keys, a public key and a\n      private key.\
    \  The public keys are published in the DNS by the use\n      of the DNSKEY Resource\
    \ Record (DNSKEY RR).  Private keys should\n      remain private.\n   Refresh\
    \ Period:  The period before the expiration time of the\n      signature, during\
    \ which the signature is refreshed by the signer.\n   Re-Sign Period:  This refers\
    \ to the frequency with which a signing\n      pass on the zone is performed.\
    \  The Re-Sign Period defines when\n      the zone is exposed to the signer. \
    \ And on the signer, not all\n      signatures in the zone have to be regenerated:\
    \ That depends on the\n      Refresh Period.\n   Secure Entry Point (SEP) key:\
    \  A KSK that has a DS record in the\n      parent zone pointing to it or that\
    \ is configured as a trust\n      anchor.  Although not required by the protocol,\
    \ we suggest that\n      the SEP flag [RFC4034] be set on these keys.\n   Self-signature:\
    \  This only applies to signatures over DNSKEYs; a\n      signature made with\
    \ DNSKEY x over DNSKEY x is called a self-\n      signature.  Note: Without further\
    \ information, self-signatures\n      convey no trust.  They are useful to check\
    \ the authenticity of the\n      DNSKEY, i.e., they can be used as a hash.\n \
    \  Signing jitter:  A random variation in the signature validity period\n    \
    \  of RRSIGs in a zone to prevent all of them from expiring at the\n      same\
    \ time.\n   Signer:  The system that has access to the private key material and\n\
    \      signs the Resource Record sets in a zone.  A signer may be\n      configured\
    \ to sign only parts of the zone, e.g., only those RRsets\n      for which existing\
    \ signatures are about to expire.\n   Singing the zone file:  The term used for\
    \ the event where an\n      administrator joyfully signs its zone file while producing\
    \ melodic\n      sound patterns.\n   Single-Type Signing Scheme:  A signing scheme\
    \ whereby the distinction\n      between Zone Signing Keys and Key Signing Keys\
    \ is not made.\n   Zone administrator:  The 'role' that is responsible for signing\
    \ a\n      zone and publishing it on the primary authoritative server.\n   Zone\
    \ Signing Key (ZSK):  A key that is used for signing all data in a\n      zone\
    \ (except, perhaps, the DNSKEY RRset).  The fact that a key is\n      a ZSK is\
    \ only relevant to the signing tool.\n"
- title: Appendix B.  Typographic Conventions
  contents:
  - "Appendix B.  Typographic Conventions\n   The following typographic conventions\
    \ are used in this document:\n   Key notation:  A key is denoted by DNSKEY_x_y,\
    \ where x is an\n      identifier for the type of key: K for Key Signing Key,\
    \ Z for Zone\n      Signing Key, and S when there is no distinction made between\
    \ KSKs\n      and ZSKs but the key is used as a secure entry point.  The 'y'\n\
    \      denotes a number or an identifier; y could be thought of as the\n     \
    \ key id.\n   RRsets ignored:  If the signatures of non-DNSKEY RRsets have the\
    \ same\n      parameters as the SOA, then those are not mentioned; e.g., in the\n\
    \      example below, the SOA is signed with the same parameters as the\n    \
    \  foo.example.com A RRset and the latter is therefore ignored in the\n      abbreviated\
    \ notation.\n   RRset notations:  RRs are only denoted by the type.  All other\n\
    \      information -- owner, class, rdata, and TTL -- is left out.  Thus:\n  \
    \    \"example.com 3600 IN A 192.0.2.1\" is reduced to \"A\".  RRsets are a\n\
    \      list of RRs.  An example of this would be \"A1, A2\", specifying the\n\
    \      RRset containing two \"A\" records.  This could again be abbreviated\n\
    \      to just \"A\".\n   Signature notation:  Signatures are denoted as RRSIG_x_y(type),\
    \ which\n      means that the RRset with the specific RRTYPE 'type' is signed\n\
    \      with DNSKEY_x_y.  Signatures in the parent zone are denoted as\n      RRSIG_par(type).\n\
    \   SOA representation:  SOAs are represented as SOA_x, where x is the\n     \
    \ serial number.\n   DS representation:  DSs are represented as DS_x_y, where\
    \ x and y are\n      identifiers similar to the key notation: x is an identifier\
    \ for\n      the type of key the DS record refers to; y is the 'key id' of the\n\
    \      key it refers to.\n   Zone representation:  Using the above notation we\
    \ have simplified the\n      representation of a signed zone by leaving out all\
    \ unnecessary\n      details, such as the names, and by representing all data\
    \ by\n      \"SOA_x\".\n   Using this notation, the following signed zone:\n \
    \  example.com.  3600  IN SOA   ns1.example.com. olaf.example.net. (\n       \
    \                    2005092303 ; serial\n                           450     \
    \   ; refresh (7 minutes 30 seconds)\n                           600        ;\
    \ retry (10 minutes)\n                           345600     ; expire (4 days)\n\
    \                           300        ; minimum (5 minutes)\n               \
    \            )\n          3600    RRSIG    SOA 5 2 3600 20120824013000 (\n   \
    \                        20100424013000 14 example.com.\n                    \
    \       NMafnzmmZ8wevpCOI+/JxqWBzPxrnzPnSXfo\n                           ...\n\
    \                           OMY3rTMA2qorupQXjQ== )\n          3600    NS     \
    \  ns1.example.com.\n          3600    NS       ns2.example.com.\n          3600\
    \    NS       ns3.example.com.\n          3600    RRSIG    NS 5 2 3600 20120824013000\
    \ (\n                           20100424013000 14 example.com.\n             \
    \              p0Cj3wzGoPFftFZjj3jeKGK6wGWLwY6mCBEz\n                        \
    \   ...\n                           +SqZIoVHpvE7YBeH46wuyF8w4XknA4Oeimc4\n   \
    \                        zAgaJM/MeG08KpeHhg== )\n          3600    TXT      \"\
    Net::DNS  domain\"\n          3600    RRSIG    TXT 5 2 3600 20120824013000 (\n\
    \                           20100424013000 14 example.com.\n                 \
    \          o7eP8LISK2TEutFQRvK/+U3wq7t4X+PQaQkp\n                           ...\n\
    \                           BcQ1o99vwn+IS4+J1g== )\n          300     NSEC   \
    \  foo.example.com. NS SOA TXT RRSIG NSEC DNSKEY\n          300     RRSIG    NSEC\
    \ 5 2 300 20120824013000 (\n                           20100424013000 14 example.com.\n\
    \                           JtHm8ta0diCWYGu/TdrE1O1sYSHblN2i/IX+\n           \
    \                ...\n                           PkXNI/Vgf4t3xZaIyw== )\n    \
    \      3600    DNSKEY   256 3 5 (\n                           AQPaoHW/nC0fj9HuCW3hACSGiP0AkPS3dQFX\n\
    \                           ...\n                           sAuryjQ/HFa5r4mrbhkJ\n\
    \                           ) ; key id = 14\n          3600    DNSKEY   257 3\
    \ 5 (\n                           AQPUiszMMAi36agx/V+7Tw95l8PYmoVjHWvO\n     \
    \                      ...\n                           oy88Nh+u2c9HF1tw0naH\n\
    \                           ) ; key id = 15\n          3600    RRSIG    DNSKEY\
    \ 5 2 3600 20120824013000 (\n                           20100424013000 14 example.com.\n\
    \                           HWj/VEr6p/FiUUiL70QQWtk+NBIlsJ9mdj5U\n           \
    \                ...\n                           QhhmMwV3tIxJk2eDRQ== )\n    \
    \      3600    RRSIG    DNSKEY 5 2 3600 20120824013000 (\n                   \
    \        20100424013000 15 example.com.\n                           P47CUy/xPV8qIEuua4tMKG6ei3LQ8RYv3TwE\n\
    \                           ...\n                           JWL70YiUnUG3m9OL9w==\
    \ )\n  foo.example.com.  3600  IN A 192.0.2.2\n          3600    RRSIG    A 5\
    \ 3 3600 20120824013000 (\n                           20100424013000 14 example.com.\n\
    \                           xHr023P79YrSHHMtSL0a1nlfUt4ywn/vWqsO\n           \
    \                ...\n                           JPV/SA4BkoFxIcPrDQ== )\n    \
    \      300     NSEC     example.com. A RRSIG NSEC\n          300     RRSIG   \
    \ NSEC 5 3 300 20120824013000 (\n                           20100424013000 14\
    \ example.com.\n                           Aaa4kgKhqY7Lzjq3rlPlFidymOeBEK1T6vUF\n\
    \                           ...\n                           Qe000JyzObxx27pY8A==\
    \ )\n   is reduced to the following representation:\n            SOA_2005092303\n\
    \            RRSIG_Z_14(SOA_2005092303)\n            DNSKEY_K_14\n           \
    \ DNSKEY_Z_15\n            RRSIG_K_14(DNSKEY)\n            RRSIG_Z_15(DNSKEY)\n\
    \   The rest of the zone data has the same signature as the SOA record,\n   i.e.,\
    \ an RRSIG created with DNSKEY_K_14.\n"
- title: Appendix C.  Transition Figures for Special Cases of Algorithm Rollovers
  contents:
  - "Appendix C.  Transition Figures for Special Cases of Algorithm Rollovers\n  \
    \ The figures in this appendix complement and illustrate the special\n   cases\
    \ of algorithm rollovers as described in Section 4.1.4.\n   ----------------------------------------------------------------\n\
    \    initial              new RRSIGs           new DNSKEY\n   ----------------------------------------------------------------\n\
    \   Parent:\n    SOA_0 -------------------------------------------------------->\n\
    \    RRSIG_par(SOA) ----------------------------------------------->\n    DS_S_1\
    \ ------------------------------------------------------->\n    RRSIG_par(DS_S_1)\
    \ -------------------------------------------->\n   Child:\n    SOA_0        \
    \        SOA_1                SOA_2\n    RRSIG_S_1(SOA)       RRSIG_S_1(SOA) \
    \      RRSIG_S_1(SOA)\n                         RRSIG_S_2(SOA)       RRSIG_S_2(SOA)\n\
    \    DNSKEY_S_1           DNSKEY_S_1           DNSKEY_S_1\n                  \
    \                            DNSKEY_S_2\n    RRSIG_S_1(DNSKEY)    RRSIG_S_1(DNSKEY)\
    \    RRSIG_S_1(DNSKEY)\n                         RRSIG_S_2(DNSKEY)    RRSIG_S_2(DNSKEY)\n\
    \   ----------------------------------------------------------------\n    new\
    \ DS               DNSKEY removal       RRSIGs removal\n   ----------------------------------------------------------------\n\
    \   Parent:\n    SOA_1 ------------------------------------------------------->\n\
    \    RRSIG_par(SOA) ---------------------------------------------->\n    DS_S_2\
    \ ------------------------------------------------------>\n    RRSIG_par(DS_S_2)\
    \ ------------------------------------------->\n   Child:\n    ------------------->\
    \ SOA_3                SOA_4\n    -------------------> RRSIG_S_1(SOA)\n    ------------------->\
    \ RRSIG_S_2(SOA)       RRSIG_S_2(SOA)\n    ------------------->\n    ------------------->\
    \ DNSKEY_S_2           DNSKEY_S_2\n    -------------------> RRSIG_S_1(DNSKEY)\n\
    \    -------------------> RRSIG_S_2(DNSKEY)    RRSIG_S_2(DNSKEY)\n   ----------------------------------------------------------------\n\
    \           Figure 12: Single-Type Signing Scheme Algorithm Roll\n   Also see\
    \ Section 4.1.4.1.\n   ----------------------------------------------------------------\n\
    \    initial              new RRSIGs           new DNSKEY\n   ----------------------------------------------------------------\n\
    \   Parent:\n    SOA_0 -------------------------------------------------------->\n\
    \    RRSIG_par(SOA) ----------------------------------------------->\n    DS_K_1\
    \ ------------------------------------------------------->\n    RRSIG_par(DS_K_1)\
    \ -------------------------------------------->\n   Child:\n    SOA_0        \
    \        SOA_1                SOA_2\n    RRSIG_Z_1(SOA)       RRSIG_Z_1(SOA) \
    \      RRSIG_Z_1(SOA)\n                         RRSIG_Z_2(SOA)       RRSIG_Z_2(SOA)\n\
    \    DNSKEY_K_1           DNSKEY_K_1           DNSKEY_K_1\n                  \
    \                            DNSKEY_K_2\n    DNSKEY_Z_1           DNSKEY_Z_1 \
    \          DNSKEY_Z_1\n                                              DNSKEY_Z_2\n\
    \    RRSIG_K_1(DNSKEY)    RRSIG_K_1(DNSKEY)    RRSIG_K_1(DNSKEY)\n           \
    \                                   RRSIG_K_2(DNSKEY)\n   ----------------------------------------------------------------\n\
    \    new DS               revoke DNSKEY        DNSKEY removal\n   ----------------------------------------------------------------\n\
    \   Parent:\n    SOA_1 ------------------------------------------------------->\n\
    \    RRSIG_par(SOA) ---------------------------------------------->\n    DS_K_2\
    \ ------------------------------------------------------>\n    RRSIG_par(DS_K_2)\
    \ ------------------------------------------->\n   Child:\n    ------------------->\
    \ SOA_3                SOA_4\n    -------------------> RRSIG_Z_1(SOA)       RRSIG_Z_1(SOA)\n\
    \    -------------------> RRSIG_Z_2(SOA)       RRSIG_Z_2(SOA)\n    ------------------->\
    \ DNSKEY_K_1_REVOKED\n    -------------------> DNSKEY_K_2           DNSKEY_K_2\n\
    \    ------------------->\n    -------------------> DNSKEY_Z_2           DNSKEY_Z_2\n\
    \    -------------------> RRSIG_K_1(DNSKEY)\n    -------------------> RRSIG_K_2(DNSKEY)\
    \    RRSIG_K_2(DNSKEY)\n   ----------------------------------------------------------------\n\
    \    RRSIGs removal\n   ----------------------------------------------------------------\n\
    \   Parent:\n    ------------------------------------->\n    ------------------------------------->\n\
    \    ------------------------------------->\n    ------------------------------------->\n\
    \   Child:\n    SOA_5\n    RRSIG_Z_2(SOA)\n    DNSKEY_K_2\n    DNSKEY_Z_2\n  \
    \  RRSIG_K_2(DNSKEY)\n   ----------------------------------------------------------------\n\
    \                 Figure 13: RFC 5011 Style Algorithm Roll\n   Also see Section\
    \ 4.1.4.2.\n   ----------------------------------------------------------------\n\
    \    initial              new RRSIGs           new DNSKEY\n   ----------------------------------------------------------------\n\
    \   Parent:\n    SOA_0 -------------------------------------------------------->\n\
    \    RRSIG_par(SOA) ----------------------------------------------->\n    DS_S_1\
    \ ------------------------------------------------------->\n    RRSIG_par(DS_S_1)\
    \ -------------------------------------------->\n   Child:\n    SOA_0        \
    \        SOA_1                SOA_2\n    RRSIG_S_1(SOA)\n    RRSIG_Z_10(SOA) \
    \     RRSIG_Z_10(SOA)      RRSIG_Z_10(SOA)\n                         RRSIG_S_2(SOA)\
    \       RRSIG_S_2(SOA)\n    DNSKEY_S_1           DNSKEY_S_1           DNSKEY_S_1\n\
    \    DNSKEY_Z_10          DNSKEY_Z_10          DNSKEY_Z_10\n                 \
    \                             DNSKEY_S_2\n    RRSIG_S_1(DNSKEY)    RRSIG_S_1(DNSKEY)\
    \    RRSIG_S_1(DNSKEY)\n                         RRSIG_S_2(DNSKEY)    RRSIG_S_2(DNSKEY)\n\
    \   ----------------------------------------------------------------\n    new\
    \ DS               revoke DNSKEY        DNSKEY removal\n   ----------------------------------------------------------------\n\
    \   Parent:\n    SOA_1 ------------------------------------------------------->\n\
    \    RRSIG_par(SOA) ---------------------------------------------->\n    DS_S_2\
    \ ------------------------------------------------------>\n    RRSIG_par(DS_S_2)\
    \ ------------------------------------------->\n   Child:\n    ------------------->\
    \ SOA_3                SOA_4\n    -------------------> RRSIG_Z_10(SOA)\n    ------------------->\
    \ RRSIG_S_2(SOA)       RRSIG_S_2(SOA)\n    -------------------> DNSKEY_S_1_REVOKED\n\
    \    -------------------> DNSKEY_Z_10\n    -------------------> DNSKEY_S_2   \
    \        DNSKEY_S_2\n    -------------------> RRSIG_S_1(DNSKEY)    RRSIG_S_1(DNSKEY)\n\
    \    -------------------> RRSIG_S_2(DNSKEY)    RRSIG_S_2(DNSKEY)\n   ----------------------------------------------------------------\n\
    \    RRSIGs removal\n   ----------------------------------------------------------------\n\
    \   Parent:\n    ------------------------------------->\n    ------------------------------------->\n\
    \    ------------------------------------->\n    ------------------------------------->\n\
    \   Child:\n    SOA_5\n    RRSIG_S_2(SOA)\n    DNSKEY_S_2\n    RRSIG_S_2(DNSKEY)\n\
    \   ----------------------------------------------------------------\n       \
    \     Figure 14: RFC 5011 Algorithm Roll in a Single-Type\n                  \
    \      Signing Scheme Environment\n   Also see Section 4.1.4.3.\n"
- title: Appendix D.  Transition Figure for Changing DNS Operators
  contents:
  - "Appendix D.  Transition Figure for Changing DNS Operators\n   The figure in this\
    \ Appendix complements and illustrates the special\n   case of changing DNS operators\
    \ as described in Section 4.3.5.1.\n    ------------------------------------------------------------\n\
    \    new DS             |        pre-publish                    |\n    ------------------------------------------------------------\n\
    \    Parent:\n     NS_A                            NS_A\n     DS_A DS_B      \
    \                 DS_A DS_B\n    ------------------------------------------------------------\n\
    \    Child at A:            Child at A:        Child at B:\n     SOA_A0      \
    \           SOA_A1             SOA_B0\n     RRSIG_Z_A(SOA)         RRSIG_Z_A(SOA)\
    \     RRSIG_Z_B(SOA)\n     NS_A                   NS_A               NS_B\n  \
    \   RRSIG_Z_A(NS)          NS_B               RRSIG_Z_B(NS)\n                \
    \            RRSIG_Z_A(NS)\n     DNSKEY_Z_A             DNSKEY_Z_A         DNSKEY_Z_A\n\
    \                            DNSKEY_Z_B         DNSKEY_Z_B\n     DNSKEY_K_A  \
    \           DNSKEY_K_A         DNSKEY_K_B\n     RRSIG_K_A(DNSKEY)      RRSIG_K_A(DNSKEY)\
    \  RRSIG_K_A(DNSKEY)\n                            RRSIG_K_B(DNSKEY)  RRSIG_K_B(DNSKEY)\n\
    \    ------------------------------------------------------------\n    ------------------------------------------------------------\n\
    \          re-delegation                |   post-migration      |\n    ------------------------------------------------------------\n\
    \    Parent:\n              NS_B                           NS_B\n            \
    \  DS_A DS_B                      DS_B\n    ------------------------------------------------------------\n\
    \    Child at A:        Child at B:           Child at B:\n     SOA_A1       \
    \      SOA_B0                SOA_B1\n     RRSIG_Z_A(SOA)     RRSIG_Z_B(SOA)  \
    \      RRSIG_Z_B(SOA)\n     NS_A               NS_B                  NS_B\n  \
    \   NS_B               RRSIG_Z_B(NS)         RRSIG_Z_B(NS)\n     RRSIG_Z_A(NS)\n\
    \     DNSKEY_Z_A         DNSKEY_Z_A\n     DNSKEY_Z_B         DNSKEY_Z_B      \
    \      DNSKEY_Z_B\n     DNSKEY_K_A         DNSKEY_K_B            DNSKEY_K_B\n\
    \     RRSIG_K_A(DNSKEY)  RRSIG_K_B(DNSKEY)     RRSIG_K_B(DNSKEY)\n    ------------------------------------------------------------\n\
    \   Figure 15: An Alternative Rollover Approach for Cooperating Operators\n"
- title: Appendix E.  Summary of Changes from RFC 4641
  contents:
  - "Appendix E.  Summary of Changes from RFC 4641\n   This document differs from\
    \ RFC 4641 [RFC4641] in the following ways:\n   o  Addressed the errata listed\
    \ on\n      <http://www.rfc-editor.org/errata_search.php?rfc=4641>.\n   o  Recommended\
    \ RSA/SHA-256 in addition to RSA/SHA-1.\n   o  Did a complete rewrite of Section\
    \ 3.5 of RFC 4641 (Section 3.4.2\n      of this document), removing the table\
    \ and suggesting a key size of\n      1024 for keys in use for less than 8 years,\
    \ issued up to at least\n      2015.\n   o  Removed the KSK for high-level zones\
    \ consideration.\n   o  Added text on algorithm rollover.\n   o  Added text on\
    \ changing (non-cooperating) DNS registrars.\n   o  Did a significant rewrite\
    \ of Section 3, whereby the argument is\n      made that the timescales for rollovers\
    \ are made purely on\n      operational arguments.\n   o  Added Section 5.\n \
    \  o  Introduced Single-Type Signing Scheme terminology and made the\n      arguments\
    \ for the choice of a Single-Type Signing Scheme more\n      explicit.\n   o \
    \ Added a section about stand-by keys.\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Olaf M. Kolkman\n   NLnet Labs\n   Science Park 400\n\
    \   Amsterdam  1098 XH\n   The Netherlands\n   EMail: olaf@nlnetlabs.nl\n   URI:\
    \   http://www.nlnetlabs.nl\n   W. (Matthijs) Mekking\n   NLnet Labs\n   Science\
    \ Park 400\n   Amsterdam  1098 XH\n   The Netherlands\n   EMail: matthijs@nlnetlabs.nl\n\
    \   URI:   http://www.nlnetlabs.nl\n   R. (Miek) Gieben\n   SIDN Labs\n   Meander\
    \ 501\n   Arnhem  6825 MD\n   The Netherlands\n   EMail: miek.gieben@sidn.nl\n\
    \   URI:   http://www.sidn.nl\n"
