- contents:
  - "            Internet X.509 Public Key Infrastructure (PKI)\n                       Proxy
    Certificate Profile\n"
  title: __initial_text__
- contents:
  - "Status of this Memo\n   This document specifies an Internet standards track protocol
    for the\n   Internet community, and requests discussion and suggestions for\n
    \  improvements.  Please refer to the current edition of the \"Internet\n   Official
    Protocol Standards\" (STD 1) for the standardization state\n   and status of this
    protocol.  Distribution of this memo is unlimited.\n"
  title: Status of this Memo
- contents:
  - "Copyright Notice\n   Copyright (C) The Internet Society (2004).\n"
  title: Copyright Notice
- contents:
  - "Abstract\n   This document forms a certificate profile for Proxy Certificates,\n
    \  based on X.509 Public Key Infrastructure (PKI) certificates as\n   defined
    in RFC 3280, for use in the Internet.  The term Proxy\n   Certificate is used
    to describe a certificate that is derived from,\n   and signed by, a normal X.509
    Public Key End Entity Certificate or by\n   another Proxy Certificate for the
    purpose of providing restricted\n   proxying and delegation within a PKI based
    authentication system.\n"
  title: Abstract
- contents:
  - "Table of Contents\n   1.  Introduction . . . . . . . . . . . . . . . . . . .
    . . . . . .  3\n   2.  Overview of Approach . . . . . . . . . . . . . . . . .
    . . . .  4\n       2.1.  Terminology. . . . . . . . . . . . . . . . . . . . .
    . .  4\n       2.2.  Background . . . . . . . . . . . . . . . . . . . . . . .
    \ 5\n       2.3.  Motivation for Proxying. . . . . . . . . . . . . . . . .  5\n
    \      2.4.  Motivation for Restricted Proxies. . . . . . . . . . . .  7\n       2.5.
    \ Motivation for Unique Proxy Name . . . . . . . . . . . .  8\n       2.6.  Description
    Of Approach. . . . . . . . . . . . . . . . .  9\n       2.7.  Features Of This
    Approach. . . . . . . . . . . . . . . . 10\n   3.  Certificate and Certificate
    Extensions Profile . . . . . . . . 12\n       3.1.  Issuer . . . . . . . . . .
    . . . . . . . . . . . . . . . 12\n       3.2.  Issuer Alternative Name. . . .
    . . . . . . . . . . . . . 12\n       3.3.  Serial Number. . . . . . . . . . .
    . . . . . . . . . . . 12\n       3.4.  Subject. . . . . . . . . . . . . . . .
    . . . . . . . . . 13\n       3.5.  Subject Alternative Name . . . . . . . . .
    . . . . . . . 13\n       3.6.  Key Usage and Extended Key Usage . . . . . . .
    . . . . . 13\n       3.7.  Basic Constraints. . . . . . . . . . . . . . . . .
    . . . 14\n       3.8.  The ProxyCertInfo Extension. . . . . . . . . . . . . .
    . 14\n   4.  Proxy Certificate Path Validation. . . . . . . . . . . . . . . 17\n
    \      4.1.  Basic Proxy Certificate Path Validation. . . . . . . . . 19\n       4.2.
    \ Using the Path Validation Algorithm. . . . . . . . . . . 23\n   5.  Commentary
    . . . . . . . . . . . . . . . . . . . . . . . . . . 24\n       5.1.  Relationship
    to Attribute Certificates . . . . . . . . . 24\n       5.2.  Kerberos 5 Tickets
    . . . . . . . . . . . . . . . . . . . 28\n       5.3.  Examples of usage of Proxy
    Restrictions. . . . . . . . . 28\n       5.4.  Delegation Tracing . . . . . .
    . . . . . . . . . . . . . 29\n   6.  Security Considerations. . . . . . . . .
    . . . . . . . . . . . 30\n       6.1.  Compromise of a Proxy Certificate. . .
    . . . . . . . . . 30\n       6.2.  Restricting Proxy Certificates . . . . . .
    . . . . . . . 31\n       6.3.  Relying Party Trust of Proxy Certificates. . .
    . . . . . 31\n       6.4.  Protecting Against Denial of Service with Key Generation
    32\n       6.5.  Use of Proxy Certificates in a Central Repository. . . . 32\n
    \  7.  IANA Considerations. . . . . . . . . . . . . . . . . . . . . . 33\n   8.
    \ References . . . . . . . . . . . . . . . . . . . . . . . . . . 33\n       8.1.
    \ Normative References . . . . . . . . . . . . . . . . . . 33\n       8.2.  Informative
    References . . . . . . . . . . . . . . . . . 33\n   9.  Acknowledgments. . . .
    . . . . . . . . . . . . . . . . . . . . 34\n   Appendix A. 1988 ASN.1 Module.
    . . . . . . . . . . . . . . . . . . 35\n   Authors' Addresses . . . . . . . .
    . . . . . . . . . . . . . . . . 36\n   Full Copyright Notice. . . . . . . . .
    . . . . . . . . . . . . . . 37\n"
  title: Table of Contents
- contents:
  - "1.  Introduction\n   Use of a proxy credential [i7] is a common technique used
    in security\n   systems to allow entity A to grant to another entity B the right
    for\n   B to be authorized with others as if it were A.  In other words,\n   entity
    B is acting as a proxy on behalf of entity A.  This document\n   forms a certificate
    profile for Proxy Certificates, based on the RFC\n   3280, \"Internet X.509 Public
    Key Infrastructure Certificate and CRL\n   Profile\" [n2].\n   In addition to
    simple, unrestricted proxying, this profile defines:\n   *  A framework for carrying
    policies in Proxy Certificates that\n      allows proxying to be limited (perhaps
    completely disallowed)\n      through either restrictions or enumeration of rights.\n
    \  *  Proxy Certificates with unique names, derived from the name of the\n      end
    entity certificate name.  This allows the Proxy Certificates\n      to be used
    in conjunction with attribute assertion approaches such\n      as Attribute Certificates
    [i3] and have their own rights\n      independent of their issuer.\n   Section
    2 provides a non-normative overview of the approach.  It\n   begins by defining
    terminology, motivating Proxy Certificates, and\n   giving a brief overview of
    the approach.  It then introduces the\n   notion of a Proxy Issuer, as distinct
    from a Certificate Authority,\n   to describe how end entity signing of a Proxy
    Certificate is\n   different from end entity signing of another end entity certificate,\n
    \  and therefore why this approach does not violate the end entity\n   signing
    restrictions contained in the X.509 keyCertSign field of the\n   keyUsage extension.
    \ It then continues with discussions of how\n   subject names are used by this
    proxying approach, and features of\n   this approach.\n   Section 3 defines requirements
    on information content in Proxy\n   Certificates.  This profile addresses two
    fields in the basic\n   certificate as well as five certificate extensions.  The
    certificate\n   fields are the subject and issuer fields.  The certificate extensions\n
    \  are subject alternative name, issuer alternative name, key usage,\n   basic
    constraints, and extended key usage.  A new certificate\n   extension, Proxy Certificate
    Information, is introduced.\n   Section 4 defines path validation rules for Proxy
    Certificates.\n   Section 5 provides non-normative commentary on Proxy Certificates.\n
    \  Section 6 discusses security considerations relating to Proxy\n   Certificates.\n
    \  References, listed in Section 8, are sorted into normative and\n   information
    references.  Normative references, listed in Section 8.1,\n   are in the form
    [nXX].  Informative references, listed in Section\n   8.2, are in the form [iXX].\n
    \  Section 9 contains acknowledgements.\n   Following Section 9, contains the
    Appendix, the contact information\n   for the authors, the intellectual property
    information, and the\n   copyright information for this document.\n   The key
    words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\",
    \"SHOULD NOT\", \"RECOMMENDED\",  \"MAY\", and \"OPTIONAL\" in this\n   document
    are to be interpreted as described in BCP 14, RFC 2119 [n1].\n"
  title: 1.  Introduction
- contents:
  - "2.  Overview of Approach\n   This section provides non-normative commentary on
    Proxy Certificates.\n   The goal of this specification is to develop a X.509 Proxy\n
    \  Certificate profile and to facilitate their use within Internet\n   applications
    for those communities wishing to make use of restricted\n   proxying and delegation
    within an X.509 Public Key Infrastructure\n   (PKI) authentication based system.\n
    \  This section provides relevant background, motivation, an overview of\n   the
    approach, and related work.\n"
  - contents:
    - "2.1.  Terminology\n   This document uses the following terms:\n   *  CA: A
      \"Certification Authority\", as defined by X.509 [n2]\n   *  EEC: An \"End Entity
      Certificate\", as defined by X.509.  That is,\n      it is an X.509 Public Key
      Certificate issued to an end entity,\n      such as a user or a service, by
      a CA.\n   *  PKC: An end entity \"Public Key Certificate\".  This is synonymous\n
      \     with an EEC.\n   *  PC: A \"Proxy Certificate\", the profile of which
      is defined by this\n      document.\n   *  PI: A \"Proxy Issuer\" is an entity
      with an End Entity Certificate\n      or Proxy Certificate that issues a Proxy
      Certificate.  The Proxy\n      Certificate is signed using the private key associated
      with the\n      public key in the Proxy Issuer's certificate.\n   *  AC: An
      \"Attribute Certificate\", as defined by \"An Internet\n      Attribute Certificate
      Profile for Authorization\" [i3].\n   *  AA: An \"Attribute Authority\", as
      defined in [i3].\n"
    title: 2.1.  Terminology
  - contents:
    - "2.2.  Background\n   Computational and Data \"Grids\" have emerged as a common
      approach to\n   constructing dynamic, inter-domain, distributed computing\n
      \  environments.  As explained in [i5], large research and development\n   efforts
      starting around 1995 have focused on the question of what\n   protocols, services,
      and APIs are required for effective, coordinated\n   use of resources in these
      Grid environments.\n   In 1997, the Globus Project (www.globus.org) introduced
      the Grid\n   Security Infrastructure (GSI) [i4].  This library provides for
      public\n   key based authentication and message protection, based on standard\n
      \  X.509 certificates and public key infrastructure, the SSL/TLS\n   protocol
      [i2], and delegation using proxy certificates similar to\n   those profiled
      in this document.  GSI has been used, in turn, to\n   build numerous middleware
      libraries and applications, which have been\n   deployed in large-scale production
      and experimental Grids [i1].  GSI\n   has emerged as the dominant security solution
      used by Grid efforts\n   worldwide.\n   This experience with GSI has proven
      the viability of restricted\n   proxying as a basis for authorization within
      Grids, and has further\n   proven the viability of using X.509 Proxy Certificates,
      as defined in\n   this document, as the basis for that proxying.  This document
      is one\n   part of an effort to migrate this experience with GSI into standards,\n
      \  and in the process clean up the approach and better reconcile it with\n   existing
      and recent standards.\n"
    title: 2.2.  Background
  - contents:
    - "2.3.  Motivation for Proxying\n   A motivating example will assist in understanding
      the role proxying\n   can play in building Internet based applications.\n   Steve
      is an engineer who wants to use a reliable file transfer\n   service to manage
      the movement of a number of large files around\n   between various hosts on
      his company's Intranet-based Grid.  From his\n   laptop he wants to submit a
      number of transfer requests to the\n   service and have the files transferred
      while he is doing other\n   things, including being offline.  The transfer service
      may queue the\n   requests for some time (e.g., until after hours or a period
      of low\n   resource usage) before initiating the transfers.  The transfer\n
      \  service will then, for each file, connect to each of the source and\n   destination
      hosts, and instruct them to initiate a data connection\n   directly from the
      source to the destination in order to transfer the\n   file.  Steve will leave
      an agent running on his laptop that will\n   periodically check on progress
      of the transfer by contacting the\n   transfer service.  Of course, he wants
      all of this to happen securely\n   on his company's resources, which requires
      that he initiate all of\n   this using his PKI smartcard.\n   This scenario
      requires authentication and delegation in a variety of\n   places:\n   *  Steve
      needs to be able to mutually authenticate with the reliable\n      file transfer
      service to submit the transfer request.\n   *  Since the storage hosts know
      nothing about the file transfer\n      service, the file transfer service needs
      to be delegated the\n      rights to mutually authenticate with the various
      storage hosts\n      involved directly in the file transfer, in order to initiate
      the\n      file transfer.\n   *  The source and destination hosts of a particular
      transfer must be\n      able to mutual authenticate with each other, to ensure
      the file is\n      being transferred to and from the proper parties.\n   *  The
      agent running on Steve's laptop must mutually authenticate\n      with the file
      transfer service in order to check the result of the\n      transfers.\n   Proxying
      is a viable approach to solving two (related) problems in\n   this scenario:\n
      \  *  Single sign-on: Steve wants to enter his smartcard password (or\n      pin)
      once, and then run a program that will submit all the file\n      transfer requests
      to the transfer service, and then periodically\n      check on the status of
      the transfer.  This program needs to be\n      given the rights to be able to
      perform all of these operations\n      securely, without requiring repeated
      access to the smartcard or\n      Steve's password.\n   *  Delegation: Various
      remote processes in this scenario need to\n      perform secure operations on
      Steve's behalf, and therefore must be\n      delegated the necessary rights.
      \ For example, the file transfer\n      service needs to be able to authenticate
      on Steve's behalf with\n      the source and destination hosts, and must in
      turn delegate rights\n      to those hosts so that they can authenticate with
      each other.\n   Proxying can be used to secure all of these interactions:\n
      \  *  Proxying allows for the private key stored on the smartcard to be\n      accessed
      just once, in order to create the necessary proxy\n      credential, which allows
      the client/agent program to be authorized\n      as Steve when submitting the
      requests to the transfer service.\n      Access to the smartcard and Steve's
      password is not required after\n      the initial creation of the proxy credential.\n
      \  *  The client program on the laptop can delegate to the file transfer\n      service
      the right to act on Steve's behalf.  This, in turn, allows\n      the service
      to authenticate to the storage hosts and inherit\n      Steve's privileges in
      order to start the file transfers.\n   *  When the transfer service authenticates
      to hosts to start the file\n      transfer, the service can delegate to the
      hosts the right to act\n      on Steve's behalf so that each pair of hosts involved
      in a file\n      transfer can mutually authenticate to ensure the file is securely\n
      \     transferred.\n   *  When the agent on the laptop reconnects to the file
      transfer\n      service to check on the status of the transfer, it can perform\n
      \     mutual authentication.  The laptop may use a newly generated proxy\n      credential,
      which is just created anew using the smartcard.\n   This scenario, and others
      similar to it, is being built today within\n   the Grid community.  The Grid
      Security Infrastructure's single sign-\n   on and delegation capabilities, built
      on X.509 Proxy Certificates,\n   are being employed to provide authentication
      services to these\n   applications.\n"
    title: 2.3.  Motivation for Proxying
  - contents:
    - "2.4.  Motivation for Restricted Proxies\n   One concern that arises is what
      happens if a machine that has been\n   delegated the right to inherit Steve's
      privileges has been\n   compromised?  For example, in the above scenario, what
      if the machine\n   running the file transfer service is compromised, such that
      the\n   attacker can gain access to the credential that Steve delegated to\n
      \  that service?  Can the attacker now do everything that Steve is\n   allowed
      to do?\n   A solution to this problem is to allow for restrictions to be placed\n
      \  on the proxy by means of policies on the proxy certificates. For\n   example,
      the machine running the reliable file transfer service in\n   the above example
      might only be given Steve's right for the purpose\n   of reading the source
      files and writing the destination files.\n   Therefore, if that file transfer
      service is compromised, the attacker\n   cannot modify source files, cannot
      create or modify other files to\n   which Steve has access, cannot start jobs
      on behalf of Steve, etc.\n   All that an attacker would be able to do is read
      the specific files\n   to which the file transfer service has been delegated
      read access,\n   and write bogus files in place of those that the file transfer\n
      \  service has been delegated write access. Further, by limiting the\n   lifetime
      of the credential that is delegated to the file transfer\n   service, the effects
      of a compromise can be further mitigated.\n   Other potential uses for restricted
      proxy credentials are discussed\n   in [i7].\n"
    title: 2.4.  Motivation for Restricted Proxies
  - contents:
    - "2.5.  Motivation for Unique Proxy Name\n   The dynamic creation of entities
      (e.g., processes and services) is an\n   essential part of Grid computing.  These
      entities will require rights\n   in order to securely perform their function.
      \ While it is possible to\n   obtain rights solely through proxying as described
      in previous\n   sections, this has limitations.  For example what if an entity
      should\n   have rights that are granted not just from the proxy issuer but from\n
      \  a third party as well?  While it is possible in this case for the\n   entity
      to obtain and hold two proxy certifications, in practice it is\n   simpler for
      subsequent credentials to take the form of attribute\n   certificates.\n   It
      is also desirable for these entities to have a unique identity so\n   that they
      can be explicitly discussed in policy statements.  For\n   example, a user initiating
      a third-party FTP transfer could grant\n   each FTP server a PC with a unique
      identity and inform each server of\n   the identity of the other, then when
      the two servers connected they\n   could authenticate themselves and know they
      are connected to the\n   proper party.\n   In order for a party to have rights
      of it's own it requires a unique\n   identity.  Possible options for obtaining
      an unique identity are:\n   1) Obtain an identity from a traditional Certification
      Authority\n      (CA).\n   2) Obtain a new identity independently - for example
      by using the\n      generated public key and a self-signed certificate.\n   3)
      Derive the new identity from an existing identity.\n   In this document we describe
      an approach to option #3, because:\n      *  It is reasonably light-weight,
      as it can be done without\n         interacting with a third party.  This is
      important when\n         creating identities dynamically.\n      *  As described
      in the previous section, a common use for PCs is\n         for restricted proxying,
      so deriving their identity from the\n         identity of the EEC makes this
      straightforward.  Nonetheless\n         there are circumstances where the creator
      does not wish to\n         delegate all or any of its rights to a new entity.
      \ Since the\n         name is unique, this is easily accomplished by #3 as well,
      by\n         allowing the application of a policy to limit proxying.\n"
    title: 2.5.  Motivation for Unique Proxy Name
  - contents:
    - "2.6.  Description Of Approach\n   This document defines an X.509 \"Proxy Certificate\"
      or \"PC\" as a means\n   of providing for restricted proxying within an (extended)
      X.509 PKI\n   based authentication system.\n   A Proxy Certificate is an X.509
      public key certificate with the\n   following properties:\n   1) It is signed
      by either an X.509 End Entity Certificate (EEC), or\n      by another PC.  This
      EEC or PC is referred to as the Proxy Issuer\n      (PI).\n   2) It can sign
      only another PC.  It cannot sign an EEC.\n   3) It has its own public and private
      key pair, distinct from any\n      other EEC or PC.\n   4) It has an identity
      derived from the identity of the EEC that\n      signed the PC.  When a PC is
      used for authentication, in may\n      inherit rights of the EEC that signed
      the PC, subject to the\n      restrictions that are placed on that PC by the
      EEC.\n   5) Although its identity is derived from the EEC's identity, it is\n
      \     also unique.  This allows this identity to be used for\n      authorization
      as an independent identity from the identity of the\n      issuing EEC, for
      example in conjunction with attribute assertions\n      as defined in [i3].\n
      \  6) It contains a new X.509 extension to identify it as a PC and to\n      place
      policies on the use of the PC.  This new extension, along\n      with other
      X.509 fields and extensions, are used to enable proper\n      path validation
      and use of the PC.\n   The process of creating a PC is as follows:\n   1) A
      new public and private key pair is generated.\n   2) That key pair is used to
      create a request for a Proxy Certificate\n      that conforms to the profile
      described in this document.\n   3) A Proxy Certificate, signed by the private
      key of the EEC or by\n      another PC, is created in response to the request.
      \ During this\n      process, the PC request is verified to ensure that the
      requested\n      PC is valid (e.g., it is not an EEC, the PC fields are\n      appropriately
      set, etc).\n   When a PC is created as part of a delegation from entity A to
      entity\n   B, this process is modified by performing steps #1 and #2 within\n
      \  entity B, then passing the PC request from entity B to entity A over\n   an
      authenticated, integrity checked channel, then entity A performs\n   step #3
      and passes the PC back to entity B.\n   Path validation of a PC is very similar
      to normal path validation,\n   with a few additional checks to ensure, for example,
      proper PC\n   signing constraints.\n"
    title: 2.6.  Description Of Approach
  - contents:
    - "2.7.  Features Of This Approach\n   Using Proxy Certificates to perform delegation
      has several features\n   that make it attractive:\n   *  Ease of integration\n
      \     o  Because a PC requires only a minimal change to path validation,\n         it
      is very easy to incorporate support for Proxy Certificates\n         into existing
      X.509 based software.  For example, SSL/TLS\n         requires no protocol changes
      to support authentication using a\n         PC.  Further, an SSL/TLS implementation
      requires only minor\n         changes to support PC path validation, and to
      retrieve the\n         authenticated subject of the signing EEC instead of the
      subject\n         of the PC for authorization purposes.\n      o  Many existing
      authorization systems use the X.509 subject name\n         as the basis for
      access control.  Proxy Certificates can be\n         used with such authorization
      systems without modification,\n         since such a PC inherits its name and
      rights from the EEC that\n         signed it and the EEC name can be used in
      place of the PC name\n         for authorization decisions.\n   *  Ease of use\n
      \     o  Using PC for single sign-on helps make X.509 PKI authentication\n         easier
      to use, by allowing users to \"login\" once and then\n         perform various
      operations securely.\n      o  For many users, properly managing their own EEC
      private key is\n         a nuisance at best, and a security risk at worst.  One
      option\n         easily enabled with a PC is to manage the EEC private keys
      and\n         certificates in a centrally managed repository. When a user\n
      \        needs a PKI credential, the user can login to the repository\n         using
      name/password, one time password, etc.  Then the\n         repository can delegate
      a PC to the user with proxy rights, but\n         continue to protect the EEC
      private key in the repository.\n   *  Protection of private keys\n      o  By
      using the remote delegation approach outlined above, entity\n         A can
      delegate a PC to entity B, without entity B ever seeing\n         the private
      key of entity A, and without entity A ever seeing\n         the private key
      of the newly delegated PC held by entity B.  In\n         other words, private
      keys never need to be shared or\n         communicated by the entities participating
      in a delegation of a\n         PC.\n      o  When implementing single sign-on,
      using a PC helps protect the\n         private key of the EEC, because it minimizes
      the exposure and\n         use of that private key.  For example, when an EEC
      private key\n         is password protected on disk, the password and unencrypted\n
      \        private key need only be available during the creation of the\n         PC.
      \ That PC can then be used for the remainder of its valid\n         lifetime,
      without requiring access to the EEC password or\n         private key.  Similarly,
      when the EEC private key lives on a\n         smartcard, the smartcard need
      only be present in the machine\n         during the creation of the PC.\n   *
      \ Limiting consequences of a compromised key\n      o  When creating a PC, the
      PI can limit the validity period of the\n         PC, the depth of the PC path
      that can be created by that PC,\n         and key usage of the PC and its descendents.
      \ Further, fine-\n         grained policies can be carried by a PC to even further\n
      \        restrict the operations that can be performed using the PC.\n         These
      restrictions permit the PI to limit damage that could be\n         done by the
      bearer of the PC, either accidentally or\n         maliciously.\n      o  A
      compromised PC private key does NOT compromise the EEC\n         private key.
      \ This makes a short term, or an otherwise\n         restricted PC attractive
      for day-to-day use, since a\n         compromised PC does not require the user
      to go through the\n         usually cumbersome and time consuming process of
      having the EEC\n         with a new private key reissued by the CA.\n   See
      Section 5 below for more discussion on how Proxy Certificates\n   relate to
      Attribute Certificates.\n"
    title: 2.7.  Features Of This Approach
  title: 2.  Overview of Approach
- contents:
  - "3.  Certificate and Certificate Extensions Profile\n   This section defines the
    usage of X.509 certificate fields and\n   extensions in Proxy Certificates, and
    defines one new extension for\n   Proxy Certificate Information.\n   All Proxy
    Certificates MUST include the Proxy Certificate Information\n   (ProxyCertInfo)
    extension defined in this section and the extension\n   MUST be critical.\n"
  - contents:
    - "3.1.  Issuer\n   The Proxy Issuer of a Proxy Certificate MUST be either an
      End Entity\n   Certificate, or another Proxy Certificate.\n   The Proxy Issuer
      MUST NOT have an empty subject field.\n   The issuer field of a Proxy Certificate
      MUST contain the subject\n   field of its Proxy Issuer.\n   If the Proxy Issuer
      certificate has the KeyUsage extension, the\n   Digital Signature bit MUST be
      asserted.\n"
    title: 3.1.  Issuer
  - contents:
    - "3.2.  Issuer Alternative Name\n   The issuerAltName extension MUST NOT be present
      in a Proxy\n   Certificate.\n"
    title: 3.2.  Issuer Alternative Name
  - contents:
    - "3.3.  Serial Number\n   The serial number of a Proxy Certificate (PC) SHOULD
      be unique\n   amongst all Proxy Certificates issued by a particular Proxy Issuer.\n
      \  However, a Proxy Issuer MAY use an approach to assigning serial\n   numbers
      that merely ensures a high probability of uniqueness.\n   For example, a Proxy
      Issuer MAY use a sequentially assigned integer\n   or a UUID to assign a unique
      serial number to a PC it issues.  Or a\n   Proxy Issuer MAY use a SHA-1 hash
      of the PC public key to assign a\n   serial number with a high probability of
      uniqueness.\n"
    title: 3.3.  Serial Number
  - contents:
    - "3.4.  Subject\n   The subject field of a Proxy Certificate MUST be the issuer
      field\n   (that is the subject of the Proxy Issuer) appended with a single\n
      \  Common Name component.\n   The value of the Common Name SHOULD be unique
      to each Proxy\n   Certificate bearer amongst all Proxy Certificates with the
      same\n   issuer.\n   If a Proxy Issuer issues two proxy certificates to the
      same bearer,\n   the Proxy Issuer MAY choose to use the same Common Name for
      both.\n   Examples of this include Proxy Certificates for different uses (e.g.,\n
      \  signing vs encryption) or the re-issuance of an expired Proxy\n   Certificate.\n
      \  The Proxy Issuer MAY use an approach to assigning Common Name values\n   that
      merely ensures a high probability of uniqueness.  This value MAY\n   be the
      same value used for the serial number.\n   The result of this approach is that
      all subject names of Proxy\n   Certificates are derived from the name of the
      issuing EEC (it will be\n   the first part of the subject name appended with
      one or more CN\n   components) and are unique to each bearer.\n"
    title: 3.4.  Subject
  - contents:
    - "3.5.  Subject Alternative Name\n   The subjectAltName extension MUST NOT be
      present in a Proxy\n   Certificate.\n"
    title: 3.5.  Subject Alternative Name
  - contents:
    - "3.6.  Key Usage and Extended Key Usage\n   If the Proxy Issuer certificate
      has a Key Usage extension, the\n   Digital Signature bit MUST be asserted.\n
      \  This document places no constraints on the presence or contents of\n   the
      key usage and extended key usage extension.  However, section 4.2\n   explains
      what functions should be allowed a proxy certificate by a\n   relying party.\n"
    title: 3.6.  Key Usage and Extended Key Usage
  - contents:
    - "3.7.  Basic Constraints\n   The cA field in the basic constraints extension
      MUST NOT be TRUE.\n"
    title: 3.7.  Basic Constraints
  - contents:
    - "3.8.  The ProxyCertInfo Extension\n   A new extension, ProxyCertInfo, is defined
      in this subsection.\n   Presence of the ProxyCertInfo extension indicates that
      a certificate\n   is a Proxy Certificate and whether or not the issuer of the\n
      \  certificate has placed any restrictions on its use.\n   id-pkix OBJECT IDENTIFIER
      ::= { iso(1) identified-organization(3)\n            dod(6) internet(1) security(5)
      mechanisms(5) pkix(7) }\n   id-pe OBJECT IDENTIFIER ::= { id-pkix 1 }\n   id-pe-proxyCertInfo
      OBJECT IDENTIFIER ::= { id-pe 14 }\n   ProxyCertInfo ::= SEQUENCE {\n        pCPathLenConstraint
      \  INTEGER (0..MAX) OPTIONAL,\n        proxyPolicy           ProxyPolicy }\n
      \  ProxyPolicy ::= SEQUENCE {\n        policyLanguage        OBJECT IDENTIFIER,\n
      \       policy          OCTET STRING OPTIONAL }\n   If a certificate is a Proxy
      Certificate, then the proxyCertInfo\n   extension MUST be present, and this
      extension MUST be marked as\n   critical.\n   If a certificate is not a Proxy
      Certificate, then the proxyCertInfo\n   extension MUST be absent.\n   The ProxyCertInfo
      extension consists of one required and two optional\n   fields, which are described
      in detail in the following subsections.\n"
    - contents:
      - "3.8.1.  pCPathLenConstraint\n   The pCPathLenConstraint field, if present,
        specifies the maximum\n   depth of the path of Proxy Certificates that can
        be signed by this\n   Proxy Certificate.  A pCPathLenConstraint of 0 means
        that this\n   certificate MUST NOT be used to sign a Proxy Certificate.  If
        the\n   pCPathLenConstraint field is not present then the maximum proxy path\n
        \  length is unlimited.  End entity certificates have unlimited maximum\n
        \  proxy path lengths.\n"
      title: 3.8.1.  pCPathLenConstraint
    - contents:
      - "3.8.2.  proxyPolicy\n   The proxyPolicy field specifies a policy on the use
        of this\n   certificate for the purposes of authorization.  Within the\n   proxyPolicy,
        the policy field is an expression of policy, and the\n   policyLanguage field
        indicates the language in which the policy is\n   expressed.\n   The proxyPolicy
        field in the proxyCertInfo extension does not define\n   a policy language
        to be used for proxy restrictions; rather, it\n   places the burden on those
        parties using that extension to define an\n   appropriate language, and to
        acquire an OID for that language (or to\n   select an appropriate previously-defined
        language/OID).  Because it\n   is essential for the PI that issues a certificate
        with a proxyPolicy\n   field and the relying party that interprets that field
        to agree on\n   its meaning, the policy language OID must correspond to a
        policy\n   language (including semantics), not just a policy grammar.\n   The
        policyLanguage field has two values of special importance,\n   defined in
        Appendix A, that MUST be understood by all parties\n   accepting Proxy Certificates:\n
        \  *  id-ppl-inheritAll indicates that this is an unrestricted proxy\n      that
        inherits all rights from the issuing PI.  An unrestricted\n      proxy is
        a statement that the Proxy Issuer wishes to delegate all\n      of its authority
        to the bearer (i.e., to anyone who has that proxy\n      certificate and can
        prove possession of the associated private\n      key).  For purposes of authorization,
        this an unrestricted proxy\n      effectively impersonates the issuing PI.\n
        \  *  id-ppl-independent indicates that this is an independent proxy\n      that
        inherits no rights from the issuing PI.  This PC MUST be\n      treated as
        an independent identity by relying parties.  The only\n      rights this PC
        has are those granted explicitly to it.\n   For either of the policyLanguage
        values listed above, the policy\n   field MUST NOT be present.\n   Other values
        for the policyLanguage field indicates that this is a\n   restricted proxy
        certification and have some other policy limiting\n   its ability to do proxying.
        \ In this case the policy field MAY be\n   present and it MUST contain information
        expressing the policy.  If\n   the policy field is not present the policy
        MUST be implicit in the\n   value of the policyLanguage field itself.  Authors
        of additional\n   policy languages are encouraged to publicly document their
        policy\n   language and list it in the IANA registry (see Section 7).\n   Proxy
        policies are used to limit the amount of authority delegated,\n   for example
        to assert that the proxy certificate may be used only to\n   make requests
        to a specific server, or only to authorize specific\n   operations on specific
        resources.  This document is agnostic to the\n   policies that can be placed
        in the policy field.\n   Proxy policies impose additional requirements on
        the relying party,\n   because only the relying party is in a position to
        ensure that those\n   policies are enforced.  When making an authorization
        decision based\n   on a proxy certificate based on rights that proxy certificate\n
        \  inherited from its issuer, it is the relying party's responsibility\n   to
        verify that the requested authority is compatible with all\n   policies in
        the PC's certificate path.  In other words, the relying\n   party MUST verify
        that the following three conditions are all met:\n   1) The relying party
        MUST know how to interpret the proxy policy and\n      the request is allowed
        under that policy.\n   2) If the Proxy Issuer is an EEC then the relying party's
        local\n      policies MUST authorize the request for the entity named in the\n
        \     EEC.\n   3) If the Proxy Issuer is another PC, then one of the following
        MUST\n      be true:\n      a. The relying party's local policies authorize
        the Proxy Issuer\n         to perform the request.\n      b. The Proxy Issuer
        inherits the right to perform the request from\n         its issuer by means
        of its proxy policy.  This must be verified\n         by verifying these three
        conditions on the Proxy Issuer in a\n         recursive manner.\n   If these
        conditions are not met, the relying party MUST either deny\n   authorization,
        or ignore the PC and the whole certificate chain\n   including the EEC entirely
        when making its authorization decision\n   (i.e., make the same decision that
        it would have made had the PC and\n   it's certificate chain never been presented).\n
        \  The relying party MAY impose additional restrictions as to which\n   proxy
        certificates it accepts.  For example, a relying party MAY\n   choose to reject
        all proxy certificates, or MAY choose to accept\n   proxy certificates only
        for certain operations, etc.\n   Note that since a proxy certificate has a
        unique identity it MAY also\n   have rights granted to it by means other than
        inheritance from it's\n   issuer via its proxy policy.  The rights granted
        to the bearer of a\n   PC are the union of the rights granted to the PC identity
        and the\n   inherited rights.  The inherited rights consist of the intersection\n
        \  of the rights granted to the PI identity intersected with the proxy\n   policy
        in the PC.\n   For example, imagine that Steve is authorized to read and write
        files\n   A and B on a file server, and that he uses his EEC to create a PC\n
        \  that includes the policy that it can be used only to read or write\n   files
        A and C.  Then a trusted attribute authority grants an\n   Attribute Certificate
        granting the PC the right to read file D. This\n   would make the rights of
        the PC equal to the union of the rights\n   granted to the PC identity (right
        to read file D) with the\n   intersection of the rights granted to Steve,
        the PI, (right to read\n   files A and B) with the policy in the PC (can only
        read files A and\n   C).  This would mean the PC would have the following
        rights:\n   *  Right to read file A: Steve has this right and he issued the
        PC\n      and his policy grants this right to the PC.\n   *  Right to read
        file D: This right is granted explicitly to the PC\n      by a trusted authority.\n
        \  The PC would NOT have the following rights:\n   *  Right to read file B:
        Although Steve has this right, it is\n      excluded by his policy on the
        PC.\n   *  Right to read file C: Although Steve's policy grants this right,\n
        \     he does not have this right himself.\n   In many cases, the relying
        party will not have enough information to\n   evaluate the above criteria
        at the time that the certificate path is\n   validated.  For example, if a
        certificate is used to authenticate a\n   connection to some server, that
        certificate is typically validated\n   during that authentication step, before
        any requests have been made\n   of the server.  In that case, the relying
        party MUST either have some\n   authorization mechanism in place that will
        check the proxy policies,\n   or reject any certificate that contains proxy
        policies (or that has a\n   parent certificate that contains proxy policies).\n"
      title: 3.8.2.  proxyPolicy
    title: 3.8.  The ProxyCertInfo Extension
  title: 3.  Certificate and Certificate Extensions Profile
- contents:
  - "4.  Proxy Certificate Path Validation\n   Proxy Certification path processing
    verifies the binding between the\n   proxy certificate distinguished name and
    proxy certificate public\n   key.  The binding is limited by constraints which
    are specified in\n   the certificates which comprise the path and inputs which
    are\n   specified by the relying party.\n   This section describes an algorithm
    for validating proxy\n   certification paths.  Conforming implementations of this\n
    \  specification are not required to implement this algorithm, but MUST\n   provide
    functionality equivalent to the external behavior resulting\n   from this procedure.
    \ Any algorithm may be used by a particular\n   implementation so long as it derives
    the correct result.\n   The algorithm presented in this section validates the
    proxy\n   certificate with respect to the current date and time.  A conformant\n
    \  implementation MAY also support validation with respect to some point\n   in
    the past.  Note that mechanisms are not available for validating a\n   proxy certificate
    with respect to a time outside the certificate\n   validity period.\n   Valid
    paths begin with the end entity certificate (EEC) that has\n   already been validated
    by public key certificate validation\n   procedures in RFC 3280 [n2].  The algorithm
    requires the public key\n   of the EEC and the EEC's subject distinguished name.\n
    \  To meet the goal of verifying the proxy certificate, the proxy\n   certificate
    path validation process verifies, among other things,\n   that a prospective certification
    path (a sequence of n certificates)\n   satisfies the following conditions:\n
    \  (a) for all x in {1, ..., n-1}, the subject of certificate x is the\n       issuer
    of proxy certificate x+1 and the subject distinguished\n       name of certificate
    x+1 is a legal subject distinguished name to\n       have been issued by certificate
    x;\n   (b) certificate 1 is valid proxy certificate issued by the end entity\n
    \      certificate whose information is given as input to the proxy\n       certificate
    path validation process;\n   (c) certificate n is the proxy certificate to be
    validated;\n   (d) for all x in {1, ..., n}, the certificate was valid at the
    time\n       in question; and\n   (e) for all certificates in the path with a
    pCPathLenConstraint\n       field, the number of certificates in the path following
    that\n       certificate does not exceed the length specified in that field.\n
    \  At this point there is no mechanism defined for revoking proxy\n   certificates.\n"
  - contents:
    - "4.1.  Basic Proxy Certificate Path Validation\n   This section presents the
      algorithm in four basic steps to mirror the\n   description of public key certificate
      path validation in RFC 3280:\n   (1) initialization, (2) basic proxy certificate
      processing, (3)\n   preparation for the next proxy certificate, and (4) wrap-up.
      Steps\n   (1) and (4) are performed exactly once.  Step (2) is performed for\n
      \  all proxy certificates in the path.  Step (3) is performed for all\n   proxy
      certificates in the path except the final proxy certificate.\n   Certificate
      path validation as described in RFC 3280 MUST have been\n   done prior to using
      this algorithm to validate the end entity\n   certificate.  This algorithm then
      processes the proxy certificate\n   chain using the end entity certificate information
      produced by RFC\n   3280 path validation.\n"
    - contents:
      - "4.1.1.  Inputs\n   This algorithm assumes the following inputs are provided
        to the path\n   processing logic:\n   (a) information about the entity certificate
        already verified using\n       RFC 3280 path validation.  This information
        includes:\n      (1) the end entity name,\n      (2) the working_public_key
        output from RFC 3280 path validation,\n      (3) the working_public_key_algorithm
        output from RFC 3280,\n      (4) and the working_public_key_parameters output
        from RFC 3280\n          path validation.\n   (b) prospective proxy certificate
        path of length n.\n   (c) acceptable-pc-policy-language-set: A set of proxy
        certificate\n       policy languages understood by the policy evaluation code.
        \ The\n       acceptable-pc-policy-language-set MAY contain the special value\n
        \      id-ppl-anyLanguage (as defined in Appendix A) if the path\n       validation
        code should not check the proxy certificate policy\n       languages (typically
        because the set of known policy languages is\n       not known yet and will
        be checked later in the authorization\n       process).\n   (d) the current
        date and time.\n"
      title: 4.1.1.  Inputs
    - contents:
      - "4.1.2.  Initialization\n   This initialization phase establishes the following
        state variables\n   based upon the inputs:\n   (a) working_public_key_algorithm:
        the digital signature algorithm\n       used to verify the signature of a
        proxy certificate. The\n       working_public_key_algorithm is initialized
        from the input\n       information provided from RFC 3280 path validation.\n
        \  (b) working_public_key: the public key used to verify the signature\n       of
        a proxy certificate.  The working_public_key is initialized\n       from the
        input information provided from RFC 3280 path\n       validation.\n   (c)
        working_public_key_parameters: parameters associated with the\n       current
        public key, that may be required to verify a signature\n       (depending
        upon the algorithm).  The\n       proxy_issuer_public_key_parameters variable
        is initialized from\n       the input information provided from RFC 3280 path
        validation.\n   (d) working_issuer_name: the issuer distinguished name expected
        in\n       the next proxy certificate in the chain.  The working_issuer_name\n
        \      is initialized to the distinguished name in the end entity\n       certificate
        validated by RFC 3280 path validation.\n   (e) max_path_length: this integer
        is initialized to n, is decremented\n       for each proxy certificate in
        the path.  This value may also be\n       reduced by the pcPathLenConstraint
        value of any proxy certificate\n       in the chain.\n   (f) proxy_policy_list:
        this list is empty to start and will be filled\n       in with the key usage
        extensions, extended key usage extensions\n       and proxy policies in the
        chain.\n   Upon completion of the initialization steps, perform the basic\n
        \  certificate processing steps specified in 4.1.3.\n"
      title: 4.1.2.  Initialization
    - contents:
      - "4.1.3.  Basic Proxy Certificate Processing\n   The basic path processing
        actions to be performed for proxy\n   certificate i (for all i in [1..n])
        are listed below.\n   (a) Verify the basic certificate information.  The certificate
        MUST\n       satisfy each of the following:\n      (1) The certificate was
        signed with the\n          working_public_key_algorithm using the working_public_key
        and\n          the working_public_key_parameters.\n      (2) The certificate
        validity period includes the current time.\n      (3) The certificate issuer
        name is the working_issuer_name.\n      (4) The certificate subject name is
        the working_issuer_name with a\n          CN component appended.\n   (b) The
        proxy certificate MUST have a ProxyCertInfo extension.\n       Process the
        extension as follows:\n      (1) If the pCPathLenConstraint field is present
        in the\n          ProxyCertInfo field and the value it contains is less than\n
        \         max_path_length, set max_path_length to its value.\n      (2) If
        acceptable-pc-policy-language-set is not id-ppl-\n          anyLanguage, the
        OID in the policyLanguage field MUST be\n          present in acceptable-pc-policy-language-set.\n
        \  (c) The tuple containing the certificate subject name, policyPolicy,\n
        \      key usage extension (if present) and extended key usage extension\n
        \      (if present) must be appended to proxy_policy_list.\n   (d) Process
        other certificate extensions, as described in [n2]:\n      (1) Recognize and
        process any other critical extensions present in\n          the proxy certificate.\n
        \     (2) Process any recognized non-critical extension present in the\n          proxy
        certificate.\n   If either step (a), (b) or (d) fails, the procedure terminates,\n
        \  returning a failure indication and an appropriate reason.\n   If i is not
        equal to n, continue by performing the preparatory steps\n   listed in 4.1.4.
        \ If i is equal to n, perform the wrap-up steps\n   listed in 4.1.5.\n"
      title: 4.1.3.  Basic Proxy Certificate Processing
    - contents:
      - "4.1.4.  Preparation for next Proxy Certificate\n   (a) Verify max_path_length
        is greater than zero and decrement\n       max_path_length.\n   (b) Assign
        the certificate subject name to working_issuer_name.\n   (c) Assign the certificate
        subjectPublicKey to working_public_key.\n   (d) If the subjectPublicKeyInfo
        field of the certificate contains an\n       algorithm field with non-null
        parameters, assign the parameters\n       to the working_public_key_parameters
        variable.\n       If the subjectPublicKeyInfo field of the certificate contains
        an\n       algorithm field with null parameters or parameters are omitted,\n
        \      compare the certificate subjectPublicKey algorithm to the\n       working_public_key_algorithm.
        \ If the certificate\n       subjectPublicKey algorithm and the working_public_key_algorithm\n
        \      are different, set the working_public_key_parameters to null.\n   (e)
        Assign the certificate subjectPublicKey algorithm to the\n       working_public_key_algorithm
        variable.\n   (f) If a key usage extension is present, verify that the\n       digitalSignature
        bit is set.\n   If either check (a) or (f) fails, the procedure terminates,
        returning\n   a failure indication and an appropriate reason.\n   If (a) and
        (f) complete successfully, increment i and perform the\n   basic certificate
        processing specified in 4.1.3.\n"
      title: 4.1.4.  Preparation for next Proxy Certificate
    - contents:
      - "4.1.5.  Wrap-up Procedures\n   (a) Assign the certificate subject name to
        working_issuer_name.\n   (b) Assign the certificate subjectPublicKey to working_public_key.\n
        \  (c) If the subjectPublicKeyInfo field of the certificate contains an\n
        \      algorithm field with non-null parameters, assign the parameters\n       to
        the proxy_issuer_public_key_parameters variable.\n       If the subjectPublicKeyInfo
        field of the certificate contains an\n       algorithm field with null parameters
        or parameters are omitted,\n       compare the certificate subjectPublicKey
        algorithm to the\n       proxy_issuer_public_key_algorithm.  If the certificate\n
        \      subjectPublicKey algorithm and the\n       proxy_issuer_public_key_algorithm
        are different, set the\n       proxy_issuer_public_key_parameters to null.\n
        \  (d) Assign the certificate subjectPublicKey algorithm to the\n       proxy_issuer_public_key_algorithm
        variable.\n"
      title: 4.1.5.  Wrap-up Procedures
    - contents:
      - "4.1.6.  Outputs\n   If path processing succeeds, the procedure terminates,
        returning a\n   success indication together with final value of the\n   working_public_key,
        the working_public_key_algorithm, the\n   working_public_key_parameters, and
        the proxy_policy_list.\n"
      title: 4.1.6.  Outputs
    title: 4.1.  Basic Proxy Certificate Path Validation
  - contents:
    - "4.2.  Using the Path Validation Algorithm\n   Each Proxy Certificate contains
      a ProxyCertInfo extension, which\n   always contains a policy language OID,
      and may also contain a policy\n   OCTET STRING.  These policies serve to indicate
      the desire of each\n   issuer in the proxy certificate chain, starting with
      the EEC, to\n   delegate some subset of their rights to the issued proxy certificate.\n
      \  This chain of policies is returned by the algorithm to the\n   application.\n
      \  The application MAY make authorization decisions based on the subject\n   distinguished
      name of the proxy certificate or on one of the proxy\n   certificates in it's
      issuing chain or on the EEC that serves as the\n   root of the chain.  If an
      application chooses to use the subject\n   distinguished name of a proxy certificate
      in the issuing chain or the\n   EEC it MUST use the returned policies to restrict
      the rights it\n   grants to the proxy certificate.  If the application does
      not know\n   how to parse any policy in the policy chain it MUST not use, for
      the\n   purposes of making authorization decisions, the subject distinguished\n
      \  name of any certificate in the chain prior to the certificate in\n   which
      the unrecognized policy appears.\n   Application making authorization decisions
      based on the contents of\n   the proxy certificate key usage or extended key
      usage extensions MUST\n   examine the list of key usage, extended key usage
      and proxy policies\n   resulting from proxy certificate path validation and
      determine the\n   effective key usage functions of the proxy certificate as
      follows:\n   *  If a certificate is a proxy certificate with a proxy policy
      of\n      id-ppl-independent or an end entity certificate, the effective key\n
      \     usage functions of that certificate is as defined by the key usage\n      and
      extended key usage extensions in that certificate.  The key\n      usage functionality
      of the issuer has no bearing on the effective\n      key usage functionality.\n
      \  *  If a certificate is a proxy certificate with a policy other than\n      id-ppl-independent,
      the effective key usage and extended key usage\n      functionality of the proxy
      certificate is the intersection of the\n      functionality of those extensions
      in the proxy certificate and the\n      effective key usage functionality of
      the proxy issuer.\n"
    title: 4.2.  Using the Path Validation Algorithm
  title: 4.  Proxy Certificate Path Validation
- contents:
  - "5.  Commentary\n   This section provides non-normative commentary on Proxy Certificates.\n"
  - contents:
    - "5.1.  Relationship to Attribute Certificates\n   An Attribute Certificate [i3]
      can be used to grant to one identity,\n   the holder, some attribute such as
      a role, clearance level, or\n   alternative identity such as \"charging identity\"
      or \"audit identity\".\n   This is accomplished by way of a trusted Attribute
      Authority (AA),\n   which issues signed Attribute Certificates (AC), each of
      which binds\n   an identity to a particular set of attributes. Authorization\n
      \  decisions can then be made by combining information from the\n   authenticated
      End Entity Certificate providing the identity, with the\n   signed Attribute
      Certificates providing binding of that identity to\n   attributes.\n   There
      is clearly some overlap between the capabilities provided by\n   Proxy Certificates
      and Attribute Certificates.  However, the\n   combination of the two approaches
      together provides a broader\n   spectrum of solutions to authorization in X.509
      based systems, than\n   either solution alone.  This section seeks to clarify
      some of the\n   overlaps, differences, and synergies between Proxy Certificate
      and\n   Attribute Certificates.\n"
    - contents:
      - "5.1.1.  Types of Attribute Authorities\n   For the purposes of this discussion,
        Attribute Authorities, and the\n   uses of the Attribute Certificates that
        they produce, can be broken\n   down into two broad classes:\n   1) End entity
        AA: An End Entity Certificate may be used to sign an\n      AC.  This can
        be used, for example, to allow an end entity to\n      delegate some of its
        privileges to another entity.\n   2) Third party AA: A separate entity, aside
        from the end entity\n      involved in an authenticated interaction, may sign
        ACs in order to\n      bind the authenticated identity with additional attributes,
        such\n      as role, group, etc.  For example, when a client authenticates\n
        \     with a server, the third party AA may provide an AC that binds the\n
        \     client identity to a particular group, which the server then uses\n
        \     for authorization purposes.\n   This second type of Attribute Authority,
        the third party AA, works\n   equally well with an EEC or a PC.  For example,
        unrestricted Proxy\n   Certificates can be used to delegate the EEC's identity
        to various\n   other parties.  Then when one of those other parties uses the
        PC to\n   authenticate with a service, that service will receive the EEC's\n
        \  identity via the PC, and can apply any ACs that bind that identity to\n
        \  attributes in order to determine authorization rights. Additionally\n   PC
        with policies could be used to selectively deny the binding of ACs\n   to
        a particular proxy.  An AC could also be bound to a particular PC\n   using
        the subject or issuer and serial number of the proxy\n   certificate.  There
        would appear to be great synergies between the\n   use of Proxy Certificates
        and Attribute Certificates produced by\n   third party Attribute Authorities.\n
        \  However, the uses of Attribute Certificates that are granted by the\n   first
        type of Attribute Authority, the end entity AA, overlap\n   considerably with
        the uses of Proxy Certificates as described in the\n   previous sections.
        \ Such Attribute Certificates are generally used\n   for delegation of rights
        from one end entity to others, which clearly\n   overlaps with the stated
        purpose of Proxy Certificates, namely single\n   sign-on and delegation.\n"
      title: 5.1.1.  Types of Attribute Authorities
    - contents:
      - "5.1.2.  Delegation Using Attribute Certificates\n   In the motivating example
        in Section 2, PCs are used to delegate\n   Steve's identity to the various
        other jobs and entities that need to\n   act on Steve's behalf.  This allows
        those other entities to\n   authenticate as if they were Steve, for example
        to the mass storage\n   system.\n   A solution to this example could also
        be cast using Attribute\n   Certificates that are signed by Steve's EEC, which
        grant to the other\n   entities in this example the right to perform various
        operations on\n   Steve's behalf.  In this example, the reliable file transfer
        service\n   and all the hosts involved in file transfers, the starter program,\n
        \  the agent, the simulation jobs, and the post-processing job would\n   each
        have their own EECs.  Steve's EEC would therefore issue ACs to\n   bind each
        of those other EEC identities to attributes that grant the\n   necessary privileges
        allow them to, for example, access the mass\n   storage system.\n   However,
        this AC based solution to delegation has some disadvantages\n   as compared
        to the PC based solution:\n   *  All protocols, authentication code, and identity
        based\n      authorization services must be modified to understand ACs.  With\n
        \     the PC solution, protocols (e.g., TLS) likely need no\n      modification,
        authentication code needs minimal modification\n      (e.g., to perform PC
        aware path validation), and identity based\n      authorization services need
        minimal modification (e.g., possibly\n      to find the EEC name and to check
        for any proxy policies).\n   *  ACs need to be created by Steve's EEC, which
        bind attributes to\n      each of the other identities involved in the distributed\n
        \     application (i.e., the agent, simulation jobs, and post-processing\n
        \     job the file transfer service, the hosts transferring files).\n      This
        implies that Steve must know in advance which other\n      identities may
        be involved in this distributed application, in\n      order to generate the
        appropriate ACs which are signed by Steve's\n      ECC.  On the other hand,
        the PC solution allows for much more\n      flexibility, since parties can
        further delegate a PC without a\n      priori knowledge by the originating
        EEC.\n   There are many unexplored tradeoffs and implications in this\n   discussion
        of delegation.  However, reasonable arguments can be made\n   in favor of
        either an AC based solution to delegation or a PC based\n   solution to delegation.
        \ The choice of which approach should be taken\n   in a given instance may
        depend on factors such as the software that\n   it needs to be integrated
        into, the type of delegation required, and\n   other factors.\n"
      title: 5.1.2.  Delegation Using Attribute Certificates
    - contents:
      - "5.1.3.  Propagation of Authorization Information\n   One possible use of
        Proxy Certificates is to carry authorization\n   information associated with
        a particular identity.\n   The merits of placing authorization information
        into End Entity\n   Certificates (also called a Public Key Certificate or
        PKC) have been\n   widely debated.  For example, Section 1 of \"An Internet
        Attribute\n   Certificate Profile for Authorization\" [i3] states:\n      \"Authorization
        information may be placed in a PKC extension or\n      placed in a separate
        attribute certificate (AC).  The placement of\n      authorization information
        in PKCs is usually undesirable for two\n      reasons.  First, authorization
        information often does not have the\n      same lifetime as the binding of
        the identity and the public key.\n      When authorization information is
        placed in a PKC extension, the\n      general result is the shortening of
        the PKC useful lifetime.\n      Second, the PKC issuer is not usually authoritative
        for the\n      authorization information.  This results in additional steps
        for\n      the PKC issuer to obtain authorization information from the\n      authoritative
        source.\n      For these reasons, it is often better to separate authorization\n
        \     information from the PKC.  Yet, authorization information also\n      needs
        to be bound to an identity.  An AC provides this binding; it\n      is simply
        a digitally signed (or certified) identity and set of\n      attributes.\"\n
        \  Placing authorization information in a PC mitigates the first\n   undesirable
        property cited above.  Since a PC has a lifetime that is\n   mostly independent
        of (always shorter than) its signing EEC, a PC\n   becomes a viable approach
        for carrying authorization information for\n   the purpose of delegation.\n
        \  The second undesirable property cited above is true.  If a third\n   party
        AA is authoritative, then using ACs issued by that third party\n   AA is a
        natural approach to disseminating authorization information.\n   However,
        this is true whether the identity being bound by these ACs\n   comes from
        an EEC (PKC), or from a PC.\n   There is one case, however, that the above
        text does not consider.\n   When performing delegation, it is usually the
        EEC itself that is\n   authoritative (not the EEC issuer, or any third party
        AA).  That is,\n   it is up to the EEC to decide what authorization rights
        it is willing\n   to grant to another party.  In this situation, including
        such\n   authorization information into PCs that are generated by the EEC\n
        \  seems a reasonable approach to disseminating such information.\n"
      title: 5.1.3.  Propagation of Authorization Information
    - contents:
      - "5.1.4.  Proxy Certificate as Attribute Certificate Holder\n   In a system
        that employs both PCs and ACs, one can imagine the\n   utility of allowing
        a PC to be the holder of an AC.  This would allow\n   for a particular delegated
        instance of an identity to be given an\n   attribute, rather than all delegated
        instances of that identity being\n   given the attribute.\n   However, the
        issue of how to specify a PC as the holder of an AC\n   remains open.  An
        AC could be bound to a particular instance of a PC\n   using the unique subject
        name of the PC, or it's issuer and serial\n   number combination.\n   Unrestricted
        PCs issued by that PC would then inherit those ACs and\n   independent PCs
        would not.  PCs issued with a policy would depend on\n   the policy as to
        whether or not they inherit the issuing PC's ACs\n   (and potentially which
        ACs they inherit).\n   While an AC can be bound to one PC by the AA, how can
        the AA restrict\n   that PC from passing it on to a subsequently delegated
        PC? One\n   possible solution would be to define an extension to attribute\n
        \  certificates that allows the attribute authority to state whether an\n
        \  issued AC is to apply only to the particular entity to which it is\n   bound,
        or if it may apply to PCs issued by that entity.\n   One issue that an AA
        in this circumstance would need to be aware of\n   is that the PI of the PC
        that the AA bound the AC to, could issue\n   another PC with the same name
        as the original PC to a different\n   entity, effectively stealing the AC.
        \ This implies that an AA issuing\n   an AC to a PC need to not only trust
        the entity holding the PC, but\n   the entity holding the PC's issuer as well.\n"
      title: 5.1.4.  Proxy Certificate as Attribute Certificate Holder
    title: 5.1.  Relationship to Attribute Certificates
  - contents:
    - "5.2.  Kerberos 5 Tickets\n   The Kerberos Network Authentication Protocol (RFC
      1510 [i6]) is a\n   widely used authentication system based on conventional
      (shared\n   secret key) cryptography.  It provides support for single sign-on
      via\n   creation of \"Ticket Granting Tickets\" or \"TGT\", and support for\n
      \  delegation of rights via \"forwardable tickets\".\n   Kerberos 5 tickets
      have informed many of the ideas surrounding X.509\n   Proxy Certificates.  For
      example, the local creation of a short-lived\n   PC can be used to provide single
      sign-on in an X.509 PKI based\n   system, just as creation of short-lived TGT
      allows for single sign-on\n   in a Kerberos based system.  And just as a TGT
      can be forwarded\n   (i.e., delegated) to another entity to allow for proxying
      in a\n   Kerberos based system, so can a PC can be delegated to allow for\n
      \  proxying in an X.509 PKI based system.\n   A major difference between a Kerberos
      TGT and an X.509 PC is that\n   while creation and delegation of a TGT requires
      the involvement of a\n   third party (Key Distribution Center), a PC can be
      unilaterally\n   created without the active involvement of a third party.  That
      is, a\n   user can directly create a PC from an EEC for single sign-on\n   capability,
      without requiring communication with a third party.  And\n   an entity with
      a PC can delegate the PC to another entity (i.e., by\n   creating a new PC,
      signed by the first) without requiring\n   communication with a third party.\n
      \  The method used by Kerberos implementations to protect a TGT can also\n   be
      used to protect the private key of a PC.  For example, some Unix\n   implementations
      of Kerberos use standard Unix file system security to\n   protect a user's TGT
      from compromise.  Similarly, the Globus\n   Toolkit's Grid Security Infrastructure
      implementation of Proxy\n   Certificates protects a user's PC private key using
      this same\n   approach.\n"
    title: 5.2.  Kerberos 5 Tickets
  - contents:
    - "5.3.  Examples of usage of Proxy Restrictions\n   This section gives some examples
      of Proxy Certificate usage and some\n   examples of how the Proxy policy can
      be used to restrict Proxy\n   Certificates.\n"
    - contents:
      - "5.3.1.  Example use of proxies without Restrictions\n   Steve wishes to perform
        a third-party FTP transfer between two FTP\n   servers.  Steve would use an
        existing PC to authenticate to both\n   servers and delegate a PC to both
        hosts.  He would inform each host\n   of the unique subject name of the PC
        given to the other host.  When\n   the servers establish the data channel
        connection to each other, they\n   use these delegated credentials to perform
        authentication and verify\n   they are talking to the correct entity by checking
        the result of the\n   authentication matches the name as provided by Steve.\n"
      title: 5.3.1.  Example use of proxies without Restrictions
    - contents:
      - "5.3.2.  Example use of proxies with Restrictions\n   Steve wishes to delegate
        to a process the right to perform a transfer\n   of a file from host H1 to
        host H2 on his behalf.  Steve would\n   delegate a PC to the process and he
        would use Proxy Policy to\n   restrict the delegated PC to two rights - the
        right to read file F1\n   on host H1 and the right to write file F2 on host
        H2.\n   The process then uses this restricted PC to authenticate to servers\n
        \  H1 and H2.  The process would also delegate a PC to both servers.\n   Note
        that these delegated PCs would inherit the restrictions of their\n   parents,
        though this is not relevant to this example.  As in the\n   example in the
        previous Section, each host would be provided with the\n   unique name of
        the PC given to the other server.\n   Now when the process issues the command
        to transfer the file F1 on H1\n   and to F2 on H2, these two servers perform
        an authorization check\n   based on the restrictions in the PC that the process
        used to\n   authenticate with them (in addition to any local policy they have).\n
        \  Namely H1 checks that the PC gives the user the right to read F1 and\n
        \  H2 checks that the PC gives the user the right to write F2. When\n   setting
        up the data channel the servers would again verify the names\n   resulting
        from the authentication match the names provided by Steve\n   as in the example
        in the previous Section.\n   The extra security provided by these restrictions
        is that now if the\n   PC delegated to the process by Steve is stolen, its
        use is greatly\n   limited.\n"
      title: 5.3.2.  Example use of proxies with Restrictions
    title: 5.3.  Examples of usage of Proxy Restrictions
  - contents:
    - "5.4.  Delegation Tracing\n   A relying party accepting a Proxy Certificate
      may have an interest in\n   knowing which parties issued earlier Proxy Certificates
      in the\n   certificate chain and to whom they delegated them.  For example it\n
      \  may know that a particular service or resource is known to have been\n   compromised
      and if any part of a Proxy Certificate's chain was issued\n   to the compromised
      service a relying party may wish to disregard the\n   chain.\n   A delegation
      tracing mechanism was considered by the authors as\n   additional information
      to be carried in the ProxyCertInfo extension.\n   However at this time agreement
      has not been reached as to what this\n   information should include so it was
      left out of this document, and\n   will instead be considered in future revisions.
      \ The debate mainly\n   centers on whether the tracing information should simply
      contain the\n   identity of the issuer and receiver or it should also contain
      all the\n   details of the delegated proxy and a signed statement from the\n
      \  receiver that the proxy was actually acceptable to it.\n"
    - contents:
      - "5.4.1.  Site Information in Delegation Tracing\n   In some cases, it may
        be desirable to know the hosts involved in a\n   delegation transaction (for
        example, a relying party may wish to\n   reject proxy certificates that were
        created on a specific host or\n   domain).  An extension could be modified
        to include the PA's and\n   Acceptor's IP addresses; however, IP addresses
        are typically easy to\n   spoof, and in some cases the two parties to a transaction
        may not\n   agree on the IP addresses being used (e.g., if the Acceptor is
        on a\n   host that uses NAT, the Acceptor and the PA may disagree about the\n
        \  Acceptor's IP address).\n   Another suggestion was, in those cases where
        domain information is\n   needed, to require that the subject names of all
        End Entities\n   involved (the Acceptor(s) and the End Entity that appears
        in a PC's\n   certificate path) include domain information.\n"
      title: 5.4.1.  Site Information in Delegation Tracing
    title: 5.4.  Delegation Tracing
  title: 5.  Commentary
- contents:
  - "6.  Security Considerations\n   In this Section we discuss security considerations
    related to the use\n   of Proxy Certificates.\n"
  - contents:
    - "6.1.  Compromise of a Proxy Certificate\n   A Proxy Certificate is generally
      less secure than the EEC that issued\n   it.  This is due to the fact that the
      private key of a PC is\n   generally not protected as rigorously as that of
      the EEC.  For\n   example, the private key of a PC is often protected using
      only file\n   system security, in order to allow that PC to be used for single\n
      \  sign-on purposes.  This makes the PC more susceptible to compromise.\n   However,
      the risk of a compromised PC is only the misuse of a single\n   user's privileges.
      \ Due to the PC path validation checks, a PC cannot\n   be used to sign an EEC
      or PC for another user.\n   Further, a compromised PC can only be misused for
      the lifetime of the\n   PC, and within the bound of the restriction policy carried
      by the PC.\n   Therefore, one common way to limit the misuse of a compromised
      PC is\n   to limit its validity period to no longer than is needed, and/or to\n
      \  include a restriction policy in the PC that limits the use of the\n   (compromised)
      PC.\n   In addition, if a PC is compromised, it does NOT compromise the EEC\n
      \  that created the PC.  This property is of great utility in protecting\n   the
      highly valuable, and hard to replace, public key of the EEC.  In\n   other words,
      the use of Proxy Certificates to provide single sign-on\n   capabilities in
      an X.509 PKI environment can actually increase the\n   security of the end entity
      certificates, because creation and use of\n   the PCs for user authentication
      limits the exposure of the EEC\n   private key to only the creation of the first
      level PC.\n"
    title: 6.1.  Compromise of a Proxy Certificate
  - contents:
    - "6.2.  Restricting Proxy Certificates\n   The pCPathLenConstraint field of the
      proxyCertInfo extension can be\n   used by an EEC to limit subsequent delegation
      of the PC.  A service\n   may choose to only authorize a request if a valid
      PC can be delegated\n   to it.  An example of such as service is a job starter,
      which may\n   choose to reject a job start request if a valid PC cannot be\n
      \  delegated to it.  By limiting the pCPathLenConstraint, an EEC can\n   ensure
      that a compromised PC of one job cannot be used to start\n   additional jobs
      elsewhere.\n   An EEC or PC can limit what a new PC can be used for by turning
      off\n   bits in the Key Usage and Extended Key Usage extensions.  Once a key\n
      \  usage or extended key usage has been removed, the path validation\n   algorithm
      ensures that it cannot be added back in a subsequent PC.\n   In other words,
      key usage can only be decreased in PC chains.\n   The EEC could use the CRL
      Distribution Points extension and/or OCSP\n   to take on the responsibility
      of revoking PCs that it had issued, if\n   it felt that they were being misused.\n"
    title: 6.2.  Restricting Proxy Certificates
  - contents:
    - "6.3.  Relying Party Trust of Proxy Certificates\n   The relying party that
      is going to authorize some actions on the\n   basis of a PC will be aware that
      it has been presented with a PC, and\n   can determine the depth of the delegation
      and the time that the\n   delegation took place.  It may want to use this information
      in\n   addition to the information from the signing EEC.  Thus a highly\n   secure
      resource might refuse to accept a PC at all, or maybe only a\n   single level
      of delegation, etc.\n   The relying party should also be aware that since the
      policy\n   restricting the rights of a PC is the intersection of the policy
      of\n   all the PCs in it's certificate chain, this means any change in the\n
      \  certificate chain can effect the policy of the PC.  Since there is no\n   mechanism
      in place to enforce unique subject names of PCs, if an\n   issuer were to issue
      two PCs with identical names and keys, but\n   different rights, this could
      allow the two PCs to be substituted for\n   each other in path validation and
      effect the rights of a PC down the\n   chain.  Ultimately, this means the relying
      party places trust in the\n   entities that are acting as Proxy Issuers in the
      chain to behave\n   properly.\n"
    title: 6.3.  Relying Party Trust of Proxy Certificates
  - contents:
    - "6.4.  Protecting Against Denial of Service with Key Generation\n   As discussed
      in Section 2.3, one of the motivations for Proxy\n   Certificates is to allow
      for dynamic delegation between parties. This\n   delegation potentially requires,
      by the party receiving the\n   delegation, the generation of a new key pair
      which is a potentially\n   computationally expensive operation.  Care should
      be taken by such\n   parties to prevent another entity from performing a denial
      of service\n   attack by causing them to consume large amount of resource doing
      key\n   generation.\n   A general guideline would always to perform authentication
      of the\n   delegating party to prevent such attacks from being performed\n   anonymously.
      \ Another guideline would be to maintain some state to\n   detect and prevent
      such attacks.\n"
    title: 6.4.  Protecting Against Denial of Service with Key Generation
  - contents:
    - "6.5.  Use of Proxy Certificates with a Central Repository\n   As discussed
      in Section 2.7, one potential use of Proxy Certificates\n   is to ease certificate
      management for end users by storing the EEC\n   private keys and certificates
      in a centrally managed repository.\n   When a user needs a PKI credential, the
      user can login to the\n   repository using name/password, one time password,
      etc. and the\n   repository would then delegate a PC to the user with proxy
      rights,\n   but continue to protect the EEC private key in the repository.\n
      \  Care must be taken with this approach since compromise of the\n   repository
      will potentially give the attacker access to the long-term\n   private keys
      stored in the repository.  It is strongly suggested that\n   some form of hardware
      module be used to store the long-term private\n   keys, which will serve to
      help prevent their direct threat though it\n   may still allow a successful
      attacker to use the keys while the\n   repository is compromised to sign arbitrary
      objects (including Proxy\n   Certificates).\n"
    title: 6.5.  Use of Proxy Certificates with a Central Repository
  title: 6.  Security Considerations
- contents:
  - "7.  IANA Considerations\n   IANA has established a registry for policy languages.
    \ Registration\n   under IETF space is by IETF standards action as described in
    [i8].\n   Private policy languages should be under organizational OIDs; policy\n
    \  language authors are encouraged to list such languages in the IANA\n   registry,
    along with a pointer to a specification.\n   OID                      Description\n
    \  ---                      -----------\n   1.3.6.1.5.5.7.21.1       id-ppl-inheritALL\n
    \  1.3.6.1.5.5.7.21.2       id-ppl-independent\n"
  title: 7.  IANA Considerations
- contents:
  - '8.  References

    '
  - contents:
    - "8.1.  Normative References\n   [n1]    Bradner, S., \"Key words for use in
      RFCs to Indicate\n           Requirement Levels\", BCP 14, RFC 2119, March 1997.\n
      \  [n2]    Housley, R., Polk, W., Ford, W., and D. Solo, \"Internet X.509\n
      \          Public Key Infrastructure Certificate and Certificate\n           Revocation
      List (CRL) Profile\", RFC 3280, April 2002.\n"
    title: 8.1.  Normative References
  - contents:
    - "8.2.  Informative References\n   [i1]    Butler, R., Engert, D., Foster, I.,
      Kesselman, C., and S.\n           Tuecke, \"A National-Scale Authentication
      Infrastructure\",\n           IEEE Computer, vol. 33, pp. 60-66, 2000.\n   [i2]
      \   Dierks, T. and C. Allen, \"The TLS Protocol Version 1.0\", RFC\n           2246,
      January 1999.\n   [i3]    Farrell, S. and R. Housley, \"An Internet Attribute\n
      \          Certificate Profile for Authorization\", RFC 3281, April 2002.\n
      \  [i4]    Foster, I., Kesselman, C., Tsudik, G., and S. Tuecke, \"A\n           Security
      Architecture for Computational Grids\", presented at\n           Proceedings
      of the 5th ACM Conference on Computer and\n           Communications Security,
      1998.\n   [i5]    Foster, I., Kesselman, C., and S. Tuecke, \"The Anatomy of
      the\n           Grid: Enabling Scalable Virtual Organizations\", International\n
      \          Journal of Supercomputer Applications, 2001.\n   [i6]    Kohl, J.
      and C. Neuman, \"The Kerberos Network Authentication\n           Service (V5)\",
      RFC 1510, September 1993.\n   [i7]    Neuman, B. Clifford, \"Proxy-Based Authorization
      and\n           Accounting for Distributed Systems\", In Proceedings of the\n
      \          13th International Conference on Distributed Computing\n           Systems,
      pages 283-291, May 1993.\n   [i8]    Narten, T. and H. Alvestrand. \"Guidelines
      for Writing an IANA\n           Considerations Section in RFC\", RFC 2434, October
      1998.\n"
    title: 8.2.  Informative References
  title: 8.  References
- contents:
  - "9.  Acknowledgments\n   We are pleased to acknowledge significant contributions
    to this\n   document by David Chadwick, Ian Foster, Jarek Gawor, Carl Kesselman,\n
    \  Sam Meder, Jim Schaad, and Frank Siebenlist.\n   We are grateful to numerous
    colleagues for discussions on the topics\n   covered in this paper, in particular
    (in alphabetical order, with\n   apologies to anybody we've missed): Carlisle
    Adams, Joe Bester, Randy\n   Butler, Keith Jackson, Steve Hanna, Russ Housley,
    Stephen Kent, Bill\n   Johnston, Marty Humphrey, Sam Lang, Ellen McDermott, Clifford
    Neuman,\n   Gene Tsudik.\n   We are also grateful to members of the Global Grid
    Forum (GGF) Grid\n   Security Infrastructure working group (GSI-WG), and the Internet\n
    \  Engineering Task Force (IETF) Public-Key Infrastructure (X.509)\n   working
    group (PKIX) for feedback on this document.\n   This work was supported in part
    by the Mathematical, Information, and\n   Computational Sciences Division subprogram
    of the Office of Advanced\n   Scientific Computing Research, U.S. Department of
    Energy, under\n   Contract W-31-109-Eng-38 and DE-AC03-76SF0098; by the Defense\n
    \  Advanced Research Projects Agency under contract N66001-96-C-8523; by\n   the
    National Science Foundation; and by the NASA Information Power\n   Grid project.\n"
  title: 9.  Acknowledgments
- contents:
  - "Appendix A. 1988 ASN.1 Module\n   PKIXproxy88 { iso(1) identified-organization(3)
    dod(6)\n       internet(1) security(5) mechanisms(5) pkix(7) id-mod(0)\n       proxy-cert-extns(25)
    }\n   DEFINITIONS EXPLICIT TAGS ::=\n   BEGIN\n   -- EXPORTS ALL --\n   -- IMPORTS
    NONE --\n   -- PKIX specific OIDs\n   id-pkix OBJECT IDENTIFIER ::=\n           {
    iso(1) identified-organization(3)\n                dod(6) internet(1) security(5)
    mechanisms(5) pkix(7) }\n   -- private certificate extensions\n   id-pe   OBJECT
    IDENTIFIER ::= { id-pkix 1 }\n   -- Locally defined OIDs\n   -- The proxy certificate
    extension\n   id-pe-proxyCertInfo    OBJECT IDENTIFIER ::= { id-pe 14 }\n   --
    Proxy certificate policy languages\n   id-ppl  OBJECT IDENTIFIER ::= { id-pkix
    21 }\n   -- Proxy certificate policies languages defined in\n   id-ppl-anyLanguage
    \    OBJECT IDENTIFIER ::= { id-ppl 0 }\n   id-ppl-inheritAll      OBJECT IDENTIFIER
    ::= { id-ppl 1 }\n   id-ppl-independent     OBJECT IDENTIFIER ::= { id-ppl 2 }\n
    \  -- The ProxyCertInfo Extension\n   ProxyCertInfoExtension  ::= SEQUENCE {\n
    \        pCPathLenConstraint     ProxyCertPathLengthConstraint\n                                       OPTIONAL,\n
    \        proxyPolicy             ProxyPolicy }\n   ProxyCertPathLengthConstraint
    \ ::= INTEGER\n   ProxyPolicy  ::= SEQUENCE {\n         policyLanguage          OBJECT
    IDENTIFIER,\n         policy                  OCTET STRING OPTIONAL }\n   END\n"
  title: Appendix A. 1988 ASN.1 Module
- contents:
  - "Authors' Addresses\n   Steven Tuecke\n   Distributed Systems Laboratory\n   Mathematics
    and Computer Science Division\n   Argonne National Laboratory\n   Argonne, IL
    60439\n   Phone: 630-252-8711\n   EMail: tuecke@mcs.anl.gov\n   Von Welch\n   National
    Center for Supercomputing Applications\n   University of Illinois\n   EMail: vwelch@ncsa.uiuc.edu\n
    \  Doug Engert\n   Argonne National Laboratory\n   EMail: deengert@anl.gov\n   Laura
    Pearlman\n   University of Southern California, Information Sciences Institute\n
    \  EMail: laura@isi.edu\n   Mary Thompson\n   Lawrence Berkeley National Laboratory\n
    \  EMail: mrthompson@lbl.gov\n"
  title: Authors' Addresses
- contents:
  - "Full Copyright Statement\n   Copyright (C) The Internet Society (2004).  This
    document is subject\n   to the rights, licenses and restrictions contained in
    BCP 78, and\n   except as set forth therein, the authors retain all their rights.\n
    \  This document and the information contained herein are provided on an\n   \"AS
    IS\" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS\n   OR IS SPONSORED
    BY (IF ANY), THE INTERNET SOCIETY AND THE INTERNET\n   ENGINEERING TASK FORCE
    DISCLAIM ALL WARRANTIES, EXPRESS OR IMPLIED,\n   INCLUDING BUT NOT LIMITED TO
    ANY WARRANTY THAT THE USE OF THE\n   INFORMATION HEREIN WILL NOT INFRINGE ANY
    RIGHTS OR ANY IMPLIED\n   WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR
    PURPOSE.\n"
  title: Full Copyright Statement
- contents:
  - "Intellectual Property\n   The IETF takes no position regarding the validity or
    scope of any\n   Intellectual Property Rights or other rights that might be claimed
    to\n   pertain to the implementation or use of the technology described in\n   this
    document or the extent to which any license under such rights\n   might or might
    not be available; nor does it represent that it has\n   made any independent effort
    to identify any such rights.  Information\n   on the procedures with respect to
    rights in RFC documents can be\n   found in BCP 78 and BCP 79.\n   Copies of IPR
    disclosures made to the IETF Secretariat and any\n   assurances of licenses to
    be made available, or the result of an\n   attempt made to obtain a general license
    or permission for the use of\n   such proprietary rights by implementers or users
    of this\n   specification can be obtained from the IETF on-line IPR repository
    at\n   http://www.ietf.org/ipr.\n   The IETF invites any interested party to bring
    to its attention any\n   copyrights, patents or patent applications, or other
    proprietary\n   rights that may cover technology that may be required to implement\n
    \  this standard.  Please address the information to the IETF at ietf-\n   ipr@ietf.org.\n"
  title: Intellectual Property
- contents:
  - "Acknowledgement\n   Funding for the RFC Editor function is currently provided
    by the\n   Internet Society.\n"
  title: Acknowledgement
