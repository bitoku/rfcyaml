- contents:
  - '       Compressing IP/UDP/RTP Headers for Low-Speed Serial Links

    '
  title: __initial_text__
- contents:
  - "Status of this Memo\n   This document specifies an Internet standards track protocol
    for the\n   Internet community, and requests discussion and suggestions for\n
    \  improvements.  Please refer to the current edition of the \"Internet\n   Official
    Protocol Standards\" (STD 1) for the standardization state\n   and status of this
    protocol.  Distribution of this memo is unlimited.\n"
  title: Status of this Memo
- contents:
  - "Copyright Notice\n   Copyright (C) The Internet Society (1999).  All Rights Reserved.\n"
  title: Copyright Notice
- contents:
  - "Abstract\n   This document describes a method for compressing the headers of\n
    \  IP/UDP/RTP datagrams to reduce overhead on low-speed serial links.\n   In many
    cases, all three headers can be compressed to 2-4 bytes.\n   Comments are solicited
    and should be addressed to the working group\n   mailing list rem-conf@es.net
    and/or the author(s).\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\",
    \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\",
    and \"OPTIONAL\" in this\n   document are to be interpreted as described in RFC
    2119.\n"
  title: Abstract
- contents:
  - "1.  Introduction\n   Since the Real-time Transport Protocol was published as
    an RFC [1],\n   there has been growing interest in using RTP as one step to achieve\n
    \  interoperability among different implementations of network\n   audio/video
    applications.  However, there is also concern that the\n   12-byte RTP header
    is too large an overhead for 20-byte payloads when\n   operating over low speed
    lines such as dial-up modems at 14.4 or 28.8\n   kb/s.  (Some existing applications
    operating in this environment use\n   an application-specific protocol with a
    header of a few bytes that\n   has reduced functionality relative to RTP.)\n   Header
    size may be reduced through compression techniques as has been\n   done with great
    success for TCP [2].  In this case, compression might\n   be applied to the RTP
    header alone, on an end-to-end basis, or to the\n   combination of IP, UDP and
    RTP headers on a link-by-link basis.\n   Compressing the 40 bytes of combined
    headers together provides\n   substantially more gain than compressing 12 bytes
    of RTP header alone\n   because the resulting size is approximately the same (2-4
    bytes) in\n   either case.  Compressing on a link-by-link basis also provides\n
    \  better performance because the delay and loss rate are lower.\n   Therefore,
    the method defined here is for combined compression of IP,\n   UDP and RTP headers
    on a link-by-link basis.\n   This document defines a compression scheme that may
    be used with\n   IPv4, IPv6 or packets encapsulated with more than one IP header,\n
    \  though the initial focus is on IPv4.  The IP/UDP/RTP compression\n   defined
    here is intended to fit within the more general compression\n   framework specified
    in [3] for use with both IPv6 and IPv4.  That\n   framework defines TCP and non-TCP
    as two classes of transport above\n   IP.  This specification creates IP/UDP/RTP
    as a third class extracted\n   from the non-TCP class.\n"
  title: 1.  Introduction
- contents:
  - "2.  Assumptions and Tradeoffs\n   The goal of this compression scheme is to reduce
    the IP/UDP/RTP\n   headers to two bytes for most packets in the case where no
    UDP\n   checksums are being sent, or four bytes with checksums.  It is\n   motivated
    primarily by the specific problem of sending audio and\n   video over 14.4 and
    28.8 dialup modems.  These links tend to provide\n   full-duplex communication,
    so the protocol takes advantage of that\n   fact, though the protocol may also
    be used with reduced performance\n   on simplex links.  This compression scheme
    performs best on local\n   links with low round-trip-time.\n   This specification
    does not address segmentation and preemption of\n   large packets to reduce the
    delay across the slow link experienced by\n   small real-time packets, except
    to identify in Section 4 some\n   interactions between segmentation and compression
    that may occur.\n   Segmentation schemes may be defined separately and used in\n
    \  conjunction with the compression defined here.\n   It should be noted that
    implementation simplicity is an important\n   factor to consider in evaluating
    a compression scheme.\n   Communications servers may need to support compression
    over perhaps\n   as many as 100 dial-up modem lines using a single processor.\n
    \  Therefore, it may be appropriate to make some simplifications in the\n   design
    at the expense of generality, or to produce a flexible design\n   that is general
    but can be subsetted for simplicity.  Higher\n   compression gain might be achieved
    by communicating more complex\n   models for the changing header fields from the
    compressor to the\n   decompressor, but that complexity is deemed unnecessary.
    \ The next\n   sections discuss some of the tradeoffs listed here.\n"
  - contents:
    - "2.1.  Simplex vs. Full Duplex\n   In the absence of other constraints, a compression
      scheme that worked\n   over simplex links would be preferred over one that did
      not.\n   However, operation over a simplex link requires periodic refreshes\n
      \  with an uncompressed packet header to restore compression state in\n   case
      of error.  If an explicit error signal can be returned instead,\n   the delay
      to recovery may be shortened substantially.  The overhead\n   in the no-error
      case is also reduced.  To gain these performance\n   improvements, this specification
      includes an explicit error\n   indication sent on the reverse path.\n   On a
      simplex link, it would be possible to use a periodic refresh\n   instead.  Whenever
      the decompressor detected an error in a particular\n   packet stream, it would
      simply discard all packets in that stream\n   until an uncompressed header was
      received for that stream, and then\n   resume decompression.  The penalty would
      be the potentially large\n   number of packets discarded.  The periodic refresh
      method described\n   in Section 3.3 of [3] applies to IP/UDP/RTP compression
      on simplex\n   links or links with high delay as well as to other non-TCP packet\n
      \  streams.\n"
    title: 2.1.  Simplex vs. Full Duplex
  - contents:
    - "2.2.  Segmentation and Layering\n   Delay induced by the time required to send
      a large packet over the\n   slow link is not a problem for one-way audio, for
      example, because\n   the receiver can adapt to the variance in delay.  However,
      for\n   interactive conversations, minimizing the end-to-end delay is\n   critical.
      \ Segmentation of large, non-real-time packets to allow\n   small real-time
      packets to be transmitted between segments can reduce\n   the delay.\n   This
      specification deals only with compression and assumes\n   segmentation, if included,
      will be handled as a separate layer.  It\n   would be inappropriate to integrate
      segmentation and compression in\n   such a way that the compression could not
      be used by itself in\n   situations where segmentation was deemed unnecessary
      or impractical.\n   Similarly, one would like to avoid any requirements for
      a reservation\n   protocol.  The compression scheme can be applied locally on
      the two\n   ends of a link independent of any other mechanisms except for the\n
      \  requirements that the link layer provide some packet type codes, a\n   packet
      length indication, and good error detection.\n   Conversely, separately compressing
      the IP/UDP and RTP layers loses\n   too much of the compression gain that is
      possible by treating them\n   together.  Crossing these protocol layer boundaries
      is appropriate\n   because the same function is being applied across all layers.\n"
    title: 2.2.  Segmentation and Layering
  title: 2.  Assumptions and Tradeoffs
- contents:
  - "3.  The Compression Algorithm\n   The compression algorithm defined in this document
    draws heavily upon\n   the design of TCP/IP header compression as described in
    RFC 1144 [2].\n   Readers are referred to that RFC for more information on the\n
    \  underlying motivations and general principles of header compression.\n"
  - contents:
    - "3.1.  The basic idea\n   In TCP header compression, the first factor-of-two
      reduction in data\n   rate comes from the observation that half of the bytes
      in the IP and\n   TCP headers remain constant over the life of the connection.
      \ After\n   sending the uncompressed header once, these fields may be elided
      from\n   the compressed headers that follow.  The remaining compression comes\n
      \  from differential coding on the changing fields to reduce their size,\n   and
      from eliminating the changing fields entirely for common cases by\n   calculating
      the changes from the length of the packet.  This length\n   is indicated by
      the link-level protocol.\n   For RTP header compression, some of the same techniques
      may be\n   applied.  However, the big gain comes from the observation that\n
      \  although several fields change in every packet, the difference from\n   packet
      to packet is often constant and therefore the second-order\n   difference is
      zero.  By maintaining both the uncompressed header and\n   the first-order differences
      in the session state shared between the\n   compressor and decompressor, all
      that must be communicated is an\n   indication that the second-order difference
      was zero.  In that case,\n   the decompressor can reconstruct the original header
      without any loss\n   of information simply by adding the first-order differences
      to the\n   saved uncompressed header as each compressed packet is received.\n
      \  Just as TCP/IP header compression maintains shared state for multiple\n   simultaneous
      TCP connections, this IP/UDP/RTP compression SHOULD\n   maintain state for multiple
      session contexts.  A session context is\n   defined by the combination of the
      IP source and destination\n   addresses, the UDP source and destination ports,
      and the RTP SSRC\n   field.  A compressor implementation might use a hash function
      on\n   these fields to index a table of stored session contexts.  The\n   compressed
      packet carries a small integer, called the session context\n   identifier or
      CID, to indicate in which session context that packet\n   should be interpreted.
      \ The decompressor can use the CID to index its\n   table of stored session
      contexts directly.\n   Because the RTP compression is lossless, it may be applied
      to any UDP\n   traffic that benefits from it.  Most likely, the only packets
      that\n   will benefit are RTP packets, but it is acceptable to use heuristics\n
      \  to determine whether or not the packet is an RTP packet because no\n   harm
      is done if the heuristic gives the wrong answer.  This does\n   require executing
      the compression algorithm for all UDP packets, or\n   at least those with even
      port numbers (see section 3.4).\n   Most compressor implementations will need
      to maintain a \"negative\n   cache\" of packet streams that have failed to compress
      as RTP packets\n   for some number of attempts in order to avoid further attempts.\n
      \  Failing to compress means that some fields in the potential RTP\n   header
      that are expected to remain constant most of the time, such as\n   the payload
      type field, keep changing.  Even if the other such fields\n   remain constant,
      a packet stream with a constantly changing SSRC\n   field SHOULD be entered
      in the negative cache to avoid consuming all\n   of the available session contexts.
      \ The negative cache is indexed by\n   the source and destination IP address
      and UDP port pairs but not the\n   RTP SSRC field since the latter may be changing.
      \ When RTP\n   compression fails, the IP and UDP headers MAY still be compressed.\n
      \  Fragmented IP Packets that are not initial fragments and packets that\n   are
      not long enough to contain a complete UDP header MUST NOT be sent\n   as FULL_HEADER
      packets.  Furthermore, packets that do not\n   additionally contain at least
      12 bytes of UDP data MUST NOT be used\n   to establish RTP context.  If such
      a packet is sent as a FULL_HEADER\n   packet, it MAY be followed by COMPRESSED_UDP
      packets but MUST NOT be\n   followed by COMPRESSED_RTP packets.\n"
    title: 3.1.  The basic idea
  - contents:
    - "3.2.  Header Compression for RTP Data Packets\n   In the IPv4 header, only
      the total length, packet ID, and header\n   check-sum fields will normally change.
      \ The total length is redundant\n   with the length provided by the link layer,
      and since this\n   compression scheme must depend upon the link layer to provide
      good\n   error detection (e.g., PPP's CRC [4]), the header checksum may also\n
      \  be elided.  This leaves only the packet ID, which, assuming no IP\n   fragmentation,
      would not need to be communicated.  However, in order\n   to maintain lossless
      compression, changes in the packet ID will be\n   transmitted.  The packet ID
      usually increments by one or a small\n   number for each packet.  (Some systems
      increment the ID with the\n   bytes swapped, which results in slightly less
      compression.)  In the\n   IPv6 base header, there is no packet ID nor header
      checksum and only\n   the payload length field changes.\n   In the UDP header,
      the length field is redundant with the IP total\n   length field and the length
      indicated by the link layer.  The UDP\n   check-sum field will be a constant
      zero if the source elects not to\n   generate UDP checksums.  Otherwise, the
      checksum must be communicated\n   intact in order to preserve the lossless compression.
      \ Maintaining\n   end-to-end error detection for applications that require it
      is an\n   important principle.\n   In the RTP header, the SSRC identifier is
      constant in a given context\n   since that is part of what identifies the particular
      context.  For\n   most packets, only the sequence number and the timestamp will
      change\n   from packet to packet.  If packets are not lost or misordered\n   upstream
      from the compressor, the sequence number will increment by\n   one for each
      packet.  For audio packets of constant duration, the\n   timestamp will increment
      by the number of sample periods conveyed in\n   each packet.  For video, the
      timestamp will change on the first\n   packet of each frame, but then stay constant
      for any additional\n   packets in the frame.  If each video frame occupies only
      one packet,\n   but the video frames are generated at a constant rate, then
      again the\n   change in the timestamp from frame to frame is constant.  Note
      that\n   in each of these cases the second-order difference of the sequence\n
      \  number and timestamp fields is zero, so the next packet header can be\n   constructed
      from the previous packet header by adding the first-order\n   differences for
      these fields that are stored in the session context\n   along with the previous
      uncompressed header.  When the second-order\n   difference is not zero, the
      magnitude of the change is usually much\n   smaller than the full number of
      bits in the field, so the size can be\n   reduced by encoding the new first-order
      difference and transmitting\n   it rather than the absolute value.\n   The M
      bit will be set on the first packet of an audio talkspurt and\n   the last packet
      of a video frame.  If it were treated as a constant\n   field such that each
      change required sending the full RTP header,\n   this would reduce the compression
      significantly.  Therefore, one bit\n   in the compressed header will carry the
      M bit explicitly.\n   If the packets are flowing through an RTP mixer, most
      commonly for\n   audio, then the CSRC list and CC count will also change.  However,\n
      \  the CSRC list will typically remain constant during a talkspurt or\n   longer,
      so it need be sent only when it changes.\n"
    title: 3.2.  Header Compression for RTP Data Packets
  - contents:
    - "3.3.  The protocol\n   The compression protocol must maintain a collection
      of shared\n   information in a consistent state between the compressor and\n
      \  decompressor.  There is a separate session context for each\n   IP/UDP/RTP
      packet stream, as defined by a particular combination of\n   the IP source and
      destination addresses, UDP source and destination\n   ports, and the RTP SSRC
      field.  The number of session contexts to be\n   maintained MAY be negotiated
      between the compressor and decompressor.\n   Each context is identified by an
      8- or 16-bit identifier, depending\n   upon the number of contexts negotiated,
      so the maximum number is\n   65536.  Both uncompressed and compressed packets
      MUST carry the\n   context ID and a 4-bit sequence number used to detect packet
      loss\n   between the compressor and decompressor.  Each context has its own\n
      \  separate sequence number space so that a single packet loss need only\n   invalidate
      one context.\n   The shared information in each context consists of the following\n
      \  items:\n      o The full IP, UDP and RTP headers, possibly including a CSRC\n
      \       list, for the last packet sent by the compressor or\n        reconstructed
      by the decompressor.\n      o The first-order difference for the IPv4 ID field,
      initialized to\n        1 whenever an uncompressed IP header for this context
      is\n        received and updated each time a delta IPv4 ID field is received\n
      \       in a compressed packet.\n      o The first-order difference for the
      RTP timestamp field,\n        initialized to 0 whenever an uncompressed packet
      for this\n        context is received and updated each time a delta RTP timestamp\n
      \       field is received in a compressed packet.\n      o The last value of
      the 4-bit sequence number, which is used to\n        detect packet loss between
      the compressor and decompressor.\n      o The current generation number for
      non-differential coding of UDP\n        packets with IPv6 (see [3]).  For IPv4,
      the generation number\n        may be set to zero if the COMPRESSED_NON_TCP
      packet type,\n        defined below, is never used.\n      o A context-specific
      delta encoding table (see section 3.3.4) may\n        optionally be negotiated
      for each context.\n   In order to communicate packets in the various uncompressed
      and\n   compressed forms, this protocol depends upon the link layer being\n
      \  able to provide an indication of four new packet formats in addition\n   to
      the normal IPv4 and IPv6 packet formats:\n      FULL_HEADER - communicates the
      uncompressed IP header plus any\n      following headers and data to establish
      the uncompressed header\n      state in the decompressor for a particular context.
      \ The FULL-\n      HEADER packet also carries the 8- or 16-bit session context\n
      \     identifier and the 4-bit sequence number to establish\n      synchronization
      between the compressor and decompressor.  The\n      format is shown in section
      3.3.1.\n      COMPRESSED_UDP - communicates the IP and UDP headers compressed
      to\n      6 or fewer bytes (often 2 if UDP checksums are disabled), followed\n
      \     by any subsequent headers (possibly RTP) in uncompressed form,\n      plus
      data.  This packet type is used when there are differences in\n      the usually
      constant fields of the (potential) RTP header.  The\n      RTP header includes
      a potentially changed value of the SSRC field,\n      so this packet may redefine
      the session context.  The format is\n      shown in section 3.3.3.\n      COMPRESSED_RTP
      - indicates that the RTP header is compressed along\n      with the IP and UDP
      headers.  The size of this header may still be\n      just two bytes, or more
      if differences must be communicated.  This\n      packet type is used when the
      second-order difference (at least in\n      the usually constant fields) is
      zero.  It includes delta encodings\n      for those fields that have changed
      by other than the expected\n      amount to establish the first-order differences
      after an\n      uncompressed RTP header is sent and whenever they change.  The\n
      \     format is shown in section 3.3.2.\n      CONTEXT_STATE - indicates a special
      packet sent from the\n      decompressor to the compressor to communicate a
      list of context\n      IDs for which synchronization has or may have been lost.
      \ This\n      packet is only sent across the point-to-point link so it requires\n
      \     no IP header.  The format is shown in section 3.3.5.\n   When this compression
      scheme is used with IPv6 as part of the general\n   header compression framework
      specified in [3], another packet type\n   MAY be used:\n      COMPRESSED_NON_TCP
      - communicates the compressed IP and UDP\n      headers as defined in [3] without
      differential encoding.  If it\n      were used for IPv4, it would require one
      or two bytes more than\n      the COMPRESSED_UDP form listed above in order
      to carry the IPv4 ID\n      field.  For IPv6, there is no ID field and this
      non-differential\n      compression is more resilient to packet loss.\n   Assignments
      of numeric codes for these packet formats in the Point-\n   to-Point Protocol
      [4] are to be made by the Internet Assigned Numbers\n   Authority.\n"
    - contents:
      - "3.3.1.  FULL_HEADER (uncompressed) packet format\n   The definition of the
        FULL_HEADER packet given here is intended to be\n   the consistent with the
        definition given in [3].  Full details on\n   design choices are given there.\n
        \  The format of the FULL_HEADER packet is the same as that of the\n   original
        packet.  In the IPv4 case, this is usually an IP header,\n   followed by a
        UDP header and UDP payload that may be an RTP header\n   and its payload.
        \ However, the FULL_HEADER packet may also carry IP\n   encapsulated packets,
        in which case there would be two IP headers\n   followed by UDP and possibly
        RTP.  Or in the case of IPv6, the packet\n   may be built of some combination
        of IPv6 and IPv4 headers.  Each\n   successive header is indicated by the
        type field of the previous\n   header, as usual.\n   The FULL_HEADER packet
        differs from the corresponding normal IPv4 or\n   IPv6 packet in that it must
        also carry the compression context ID and\n   the 4-bit sequence number.  In
        order to avoid expanding the size of\n   the header, these values are inserted
        into length fields in the IP\n   and UDP headers since the actual length may
        be inferred from the\n   length provided by the link layer.  Two 16-bit length
        fields are\n   needed; these are taken from the first two available headers
        in the\n   packet.  That is, for an IPv4/UDP packet, the first length field
        is\n   the total length field of the IPv4 header, and the second is the\n
        \  length field of the UDP header.  For an IPv4 encapsulated packet, the\n
        \  first length field would come from the total length field of the\n   first
        IP header, and the second length field would come from the\n   total length
        field of the second IP header.\n   As specified in Sections 5.3.2 of [3],
        the position of the context ID\n   (CID) and 4-bit sequence number varies
        depending upon whether 8- or\n   16-bit context IDs have been selected, as
        shown in the following\n   diagram (16 bits wide, with the most-significant
        bit is to the left):\n           For 8-bit context ID:\n           +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \          |0|1| Generation|      CID      |  First length field\n           +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \          +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n           |            0          |
        \ seq  |  Second length field\n           +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \          For 16-bit context ID:\n           +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \          |1|1| Generation|   0   |  seq  |  First length field\n           +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \          +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n           |              CID
        \             |  Second length field\n           +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  The first bit in the first length field indicates the length of the\n   CID.
        \ The length of the CID MUST either be constant for all contexts\n   or two
        additional distinct packet types MUST be provided to\n   separately indicate
        COMPRESSED_UDP and COMPRESSED_RTP packet formats\n   with 8- and 16-bit CIDs.
        \ The second bit in the first length field is\n   1 to indicate that the 4-bit
        sequence number is present, as is always\n   the case for this IP/UDP/RTP
        compression scheme.\n   The generation field is used with IPv6 for COMPRESSED_NON_TCP
        packets\n   as described in [3].  For IPv4-only implementations that do not
        use\n   COMPRESSED_NON_TCP packets, the compressor SHOULD set the generation\n
        \  value to zero.  For consistent operation between IPv4 and IPv6, the\n   generation
        value is stored in the context when it is received by the\n   decompressor,
        and the most recent value is returned in the\n   CONTEXT_STATE packet.\n   When
        a FULL_HEADER packet is received, the complete set of headers is\n   stored
        into the context selected by the context ID.  The 4-bit\n   sequence number
        is also stored in the context, thereby\n   resynchronizing the decompressor
        to the compressor.\n   When COMPRESSED_NON_TCP packets are used, the 4-bit
        sequence number\n   is inserted into the \"Data Field\" of that packet and
        the D bit is set\n   as described in Section 6 of [3].  When a COMPRESSED_NON_TCP
        packet\n   is received, the generation number is compared to the value stored
        in\n   the context.  If they are not the same, the context is not up to date\n
        \  and MUST be refreshed by a FULL_HEADER packet.  If the generation\n   does
        match, then the compressed IP and UDP header information, the\n   4-bit sequence
        number, and the (potential) RTP header are all stored\n   into the saved context.\n
        \  The amount of memory required to store the context will vary\n   depending
        upon how many encapsulating headers are included in the\n   FULL_HEADER packet.
        \ The compressor and decompressor MAY negotiate a\n   maximum header size.\n"
      title: 3.3.1.  FULL_HEADER (uncompressed) packet format
    - contents:
      - "3.3.2.  COMPRESSED_RTP packet format\n   When the second-order difference
        of the RTP header from packet to\n   packet is zero, the decompressor can
        reconstruct a packet simply by\n   adding the stored first-order differences
        to the stored uncompressed\n   header representing the previous packet.  All
        that need be\n   communicated is the session context identifier and a small
        sequence\n   number (not related to the RTP sequence number) to maintain\n
        \  synchronization and detect packet loss between the compressor and\n   decompressor.\n
        \  If the second-order difference of the RTP header is not zero for some\n
        \  fields, the new first-order difference for just those fields is\n   communicated
        using a compact encoding.  The new first-order\n   difference values are added
        to the corresponding fields in the\n   uncompressed header in the decompressor's
        session context, and are\n   also stored explicitly in the context to be added
        to the\n   corresponding fields again on each subsequent packet in which the\n
        \  second-order difference is zero.  Each time the first-order\n   difference
        changes, it is transmitted and stored in the context.\n   In practice, the
        only fields for which it is useful to store the\n   first-order difference
        are the IPv4 ID field and the RTP timestamp.\n   For the RTP sequence number
        field, the usual increment is 1.  If the\n   sequence number changes by other
        than 1, the difference must be\n   communicated but does not set the expected
        difference for the next\n   packet.  Instead, the expected first-order difference
        remains fixed\n   at 1 so that the difference need not be explicitly communicated
        on\n   the next packet assuming it is in order.\n   For the RTP timestamp,
        when a FULL_HEADER, COMPRESSED_NON_TCP or\n   COMPRESSED_UDP packet is sent
        to refresh the RTP state, the stored\n   first-order difference is initialized
        to zero.  If the timestamp is\n   the same on the next packet (e.g., same
        video frame), then the\n   second-order difference is zero.  Otherwise, the
        difference between\n   the timestamps of the two packets is transmitted as
        the new first-\n   order difference to be added to the timestamp in the uncompressed\n
        \  header stored in the decompressor's context and also stored as the\n   first-order
        difference in that context.  Each time the first-order\n   difference changes
        on subsequent packets, that difference is again\n   transmitted and used to
        update the context.\n   Similarly, since the IPv4 ID field frequently increments
        by one, the\n   first-order difference for that field is initialized to one
        when the\n   state is refreshed by a FULL_HEADER packet, or when a\n   COMPRESSED_NON_TCP
        packet is sent since it carries the ID field in\n   uncompressed form.  Thereafter,
        whenever the first-order difference\n   changes, it is transmitted and stored
        in the context.\n   A bit mask will be used to indicate which fields have
        changed by\n   other than the expected difference.  In addition to the small
        link\n   sequence number, the list of items to be conditionally communicated\n
        \  in the compressed IP/UDP/RTP header is as follows:\n      I = IPv4 packet
        ID (always 0 if no IPv4 header)\n      U = UDP checksum\n      M = RTP marker
        bit\n      S = RTP sequence number\n      T = RTP timestamp\n      L = RTP
        CSRC count and list\n   If 4 bits are needed for the link sequence number
        to get a reasonable\n   probability of loss detection, there are too few bits
        remaining to\n   assign one bit to each of these items and still fit them
        all into a\n   single byte to go along with the context ID.\n   It is not
        necessary to explicitly carry the U bit to indicate the\n   presence of the
        UDP checksum because a source will typically include\n   check-sums on all
        packets of a session or none of them.  When the\n   session state is initialized
        with an uncompressed header, if there is\n   a nonzero checksum present, an
        unencoded 16-bit checksum will be\n   inserted into the compressed header
        in all subsequent packets until\n   this setting is changed by sending another
        uncompressed packet.\n   Of the remaining items, the L bit for the CSRC count
        and list may be\n   the one least frequently used.  Rather than dedicating
        a bit in the\n   mask to indicate CSRC change, an unusual combination of the
        other\n   bits may be used instead.  This bit combination is denoted MSTI.
        \ If\n   all four of the bits for the IP packet ID, RTP marker bit, RTP\n
        \  sequence number and RTP timestamp are set, this is a special case\n   indicating
        an extended form of the compressed RTP header will follow.\n   That header
        will include an additional byte containing the real\n   values of the four
        bits plus the CC count.  The CSRC list, of length\n   indicated by the CC
        count, will be included just as it appears in the\n   uncompressed RTP header.\n
        \  The other fields of the RTP header (version, P bit, X bit, payload\n   type
        and SSRC identifier) are assumed to remain relatively constant.\n   In particular,
        the SSRC identifier is defined to be constant for a\n   given context because
        it is one of the factors selecting the context.\n   If any of the other fields
        change, the uncompressed RTP header MUST\n   sent as described in Section
        3.3.3.\n   The following diagram shows the compressed IP/UDP/RTP header with\n
        \  dotted lines indicating fields that are conditionally present.  The\n   most
        significant bit is numbered 0.  Multi-byte fields are sent in\n   network
        byte order (most significant byte first).  The delta fields\n   are often
        a single byte as shown but may be two or three bytes\n   depending upon the
        delta value as explained in Section 3.3.4.\n             0   1   2   3   4
        \  5   6   7\n           +...............................+\n           :   msb
        of session context ID   :  (if 16-bit CID)\n           +-------------------------------+\n
        \          |   lsb of session context ID   |\n           +---+---+---+---+---+---+---+---+\n
        \          | M | S | T | I | link sequence |\n           +---+---+---+---+---+---+---+---+\n
        \          :                               :\n           +         UDP checksum
        \         +  (if nonzero in context)\n           :                               :\n
        \          +...............................+\n           :                               :\n
        \          +        \"RANDOM\" fields        +  (if encapsulated)\n           :
        \                              :\n           +...............................+\n
        \          : M'| S'| T'| I'|      CC       :  (if MSTI = 1111)\n           +...............................+\n
        \          :         delta IPv4 ID         :  (if I or I' = 1)\n           +...............................+\n
        \          :      delta RTP sequence       :  (if S or S' = 1)\n           +...............................+\n
        \          :      delta RTP timestamp      :  (if T or T' = 1)\n           +...............................+\n
        \          :                               :\n           :           CSRC
        list           :  (if MSTI = 1111\n           :                               :
        \  and CC nonzero)\n           :                               :\n           +...............................+\n
        \          :                               :\n           :      RTP header
        extension     :  (if X set in context)\n           :                               :\n
        \          :                               :\n           +-------------------------------+\n
        \          |                               |\n           |            RTP
        data           |\n           /                               /\n           /
        \                              /\n           |                               |\n
        \          +-------------------------------+\n           :            padding
        \           :  (if P set in context)\n           +...............................+\n
        \  When more than one IPv4 header is present in the context as\n   initialized
        by the FULL_HEADER packet, then the IP ID fields of\n   encapsulating headers
        MUST be sent as absolute values as described in\n   [3].  These fields are
        identified as \"RANDOM\" fields.  They are\n   inserted into the COMPRESSED_RTP
        packet in the same order as they\n   appear in the original headers, immediately
        following the UDP\n   checksum if present or the MSTI byte if not, as shown
        in the diagram.\n   Only if an IPv4 packet immediately precedes the UDP header
        will the\n   IP ID of that header be sent differentially, i.e., potentially
        with\n   no bits if the second difference is zero, or as a delta IPv4 ID field\n
        \  if not.  If there is not an IPv4 header immediately preceding the UDP\n
        \  header, then the I bit MUST be 0 and no delta IPv4 ID field will be\n   present.\n"
      title: 3.3.2.  COMPRESSED_RTP packet format
    - contents:
      - "3.3.3.  COMPRESSED_UDP packet format\n   If there is a change in any of the
        fields of the RTP header that are\n   normally constant (such as the payload
        type field), then an\n   uncompressed RTP header MUST be sent.  If the IP
        and UDP headers do\n   not also require updating, this RTP header MAY be carried
        in a\n   COMPRESSED_UDP packet rather than a FULL_HEADER packet.  The\n   COMPRESSED_UDP
        packet has the same format as the COMPRESSED_RTP\n   packet except that the
        M, S and T bits are always 0 and the\n   corresponding delta fields are never
        included:\n             0   1   2   3   4   5   6   7\n           +...............................+\n
        \          :   msb of session context ID   :  (if 16-bit CID)\n           +-------------------------------+\n
        \          |   lsb of session context ID   |\n           +---+---+---+---+---+---+---+---+\n
        \          | 0 | 0 | 0 | I | link sequence |\n           +---+---+---+---+---+---+---+---+\n
        \          :                               :\n           +         UDP checksum
        \         +  (if nonzero in context)\n           :                               :\n
        \          +...............................+\n           :                               :\n
        \          +        \"RANDOM\" fields        +  (if encapsulated)\n           :
        \                              :\n           +...............................+\n
        \          :         delta IPv4 ID         :  (if I = 1)\n           +-------------------------------+\n
        \          |           UDP data            |\n           :   (uncompressed
        RTP header)   :\n   Note that this constitutes a form of IP/UDP header compression\n
        \  different from COMPRESSED_NON_TCP packet type defined in [3].  The\n   motivation
        is to allow reaching the target of two bytes when UDP\n   checksums are disabled,
        as IPv4 allows.  The protocol in [3] does not\n   use differential coding
        for UDP packets, so in the IPv4 case, two\n   bytes of IP ID, and two bytes
        of UDP checksum if nonzero, would\n   always be transmitted in addition to
        two bytes of compression prefix.\n   For IPv6, the COMPRESSED_NON_TCP packet
        type MAY be used instead.\n"
      title: 3.3.3.  COMPRESSED_UDP packet format
    - contents:
      - "3.3.4.  Encoding of differences\n   The delta fields in the COMPRESSED_RTP
        and COMPRESSED_UDP packets are\n   encoded with a variable-length mapping
        for compactness of the more\n   commonly-used values.  A default encoding
        is specified below, but it\n   is RECOMMENDED that implementations use a table-driven
        delta encoder\n   and decoder to allow negotiation of a table specific for
        each session\n   if appropriate, possibly even an optimal Huffman encoding.
        \ Encodings\n   based on sequential interpretation of the bit stream, of which
        this\n   default table and Huffman encoding are examples, allow a reasonable\n
        \  table size and may result in an execution speed faster than a non-\n   table-driven
        implementation with explicit tests for ranges of values.\n   The default delta
        encoding is specified in the following table.  This\n   encoding was designed
        to efficiently encode the small changes that\n   may occur in the IP ID and
        in RTP sequence number when packets are\n   lost upstream from the compressor,
        yet still handling most audio and\n   video deltas in two bytes.  The column
        on the left is the decimal\n   value to be encoded, and the column on the
        right is the resulting\n   sequence of bytes shown in hexadecimal and in the
        order in which they\n   are transmitted (network byte order).  The first and
        last values in\n   each contiguous range are shown, with ellipses in between:\n
        \        Decimal  Hex\n          -16384  C0 00 00\n               :  :\n            -129
        \ C0 3F 7F\n            -128  80 00\n               :  :\n              -1
        \ 80 7F\n               0  00\n               :  :\n             127  7F\n
        \            128  80 80\n               :  :\n           16383  BF FF\n           16384
        \ C0 40 00\n               :  :\n         4194303  FF FF FF\n   For positive
        values, a change of zero through 127 is represented\n   directly in one byte.
        \ If the most significant two bits of the byte\n   are 10 or 11, this signals
        an extension to a two- or three-byte\n   value, respectively.  The least significant
        six bits of the first\n   byte are combined, in decreasing order of significance,
        with the next\n   one or two bytes to form a 14- or 22-bit value.\n   Negative
        deltas may occur when packets are misordered or in the\n   intentionally out-of-order
        RTP timestamps on MPEG video [5].  These\n   events are less likely, so a
        smaller range of negative values is\n   encoded using otherwise redundant
        portions of the positive part of\n   the table.\n   A change in the RTP timestamp
        value less than -16384 or greater than\n   4194303 forces the RTP header to
        be sent uncompressed using a\n   FULL_HEADER, COMPRESSED_NON_TCP or COMPRESSED_UDP
        packet type.  The\n   IP ID and RTP sequence number fields are only 16 bits,
        so negative\n   deltas for those fields SHOULD be masked to 16 bits and then
        encoded\n   (as large positive 16-bit numbers).\n"
      title: 3.3.4.  Encoding of differences
    - contents:
      - "3.3.5.  Error Recovery\n   Whenever the 4-bit sequence number for a particular
        context\n   increments by other than 1, except when set by a FULL_HEADER or\n
        \  COMPRESSED_NON_TCP packet, the decompressor MUST invalidate that\n   context
        and send a CONTEXT_STATE packet back to the compressor\n   indicating that
        the context has been invalidated.  All packets for\n   the invalid context
        MUST be discarded until a FULL_HEADER or\n   COMPRESSED_NON_TCP packet is
        received for that context to re-\n   establish consistent state (unless the
        \"twice\" algorithm is used as\n   described later in this section).  Since
        multiple compressed packets\n   may arrive in the interim, the decompressor
        SHOULD NOT retransmit the\n   CONTEXT_STATE packet for every compressed packet
        received, but\n   instead SHOULD limit the rate of retransmission to avoid
        flooding the\n   reverse channel.\n   When an error occurs on the link, the
        link layer will usually discard\n   the packet that was damaged (if any),
        but may provide an indication\n   of the error.  Some time may elapse before
        another packet is\n   delivered for the same context, and then that packet
        would have to be\n   discarded by the decompressor when it is observed to
        be out of\n   sequence, resulting in at least two packets lost.  To allow
        faster\n   recovery if the link does provide an explicit error indication,
        the\n   decompressor MAY optionally send an advisory CONTEXT_STATE packet\n
        \  listing the last valid sequence number and generation number for one\n
        \  or more recently active contexts (not necessarily all).  For a given\n
        \  context, if the compressor has sent no compressed packet with a\n   higher
        sequence number, and if the generation number matches the\n   current generation,
        no corrective action is required.  Otherwise, the\n   compressor MAY choose
        to mark the context invalid so that the next\n   packet is sent in FULL_HEADER
        or COMPRESSED_NON_TCP mode (FULL_HEADER\n   is required if the generation
        doesn't match).  However, note that if\n   the link round-trip-time is large
        compared to the inter-packet\n   spacing, there may be several packets from
        multiple contexts in\n   flight across the link, increasing the probability
        that the sequence\n   numbers will already have advanced when the CONTEXT_STATE
        packet is\n   received by the compressor.  The result could be that some contexts\n
        \  are invalidated unnecessarily, causing extra bandwidth to be\n   consumed.\n
        \  The format of the CONTEXT_STATE packet is shown in the following\n   diagrams.
        \ The first byte is a type code to allow the CONTEXT_STATE\n   packet type
        to be shared by multiple compression schemes within the\n   general compression
        framework specified in [3].  The contents of the\n   remainder of the packet
        depends upon the compression scheme.  For the\n   IP/UDP/RTP compression scheme
        specified here, the remainder of the\n   CONTEXT_STATE packet is structured
        as a list of blocks to allow the\n   state for multiple contexts to be indicated,
        preceded by a one-byte\n   count of the number of blocks.\n   Two type code
        values are used for the IP/UDP/RTP compression scheme.\n   The value 1 indicates
        that 8-bit session context IDs are being used:\n             0   1   2   3
        \  4   5   6   7\n           +---+---+---+---+---+---+---+---+\n           |
        1 = IP/UDP/RTP with 8-bit CID |\n           +---+---+---+---+---+---+---+---+\n
        \          |         context count         |\n           +---+---+---+---+---+---+---+---+\n
        \          +---+---+---+---+---+---+---+---+\n           |       session context
        ID      |\n           +---+---+---+---+---+---+---+---+\n           | I |
        0 | 0 | 0 |    sequence   |\n           +---+---+---+---+---+---+---+---+\n
        \          | 0 | 0 |       generation      |\n           +---+---+---+---+---+---+---+---+\n
        \                         ...\n           +---+---+---+---+---+---+---+---+\n
        \          |       session context ID      |\n           +---+---+---+---+---+---+---+---+\n
        \          | I | 0 | 0 | 0 |    sequence   |\n           +---+---+---+---+---+---+---+---+\n
        \          | 0 | 0 |       generation      |\n           +---+---+---+---+---+---+---+---+\n
        \  The value 2 indicates that 16-bit session context IDs are being used.\n
        \  The session context ID is sent in network byte order (most\n   significant
        byte first):\n             0   1   2   3   4   5   6   7\n           +---+---+---+---+---+---+---+---+\n
        \          | 2 = IP/UDP/RTP with 16-bit CID|\n           +---+---+---+---+---+---+---+---+\n
        \          |         context count         |\n           +---+---+---+---+---+---+---+---+\n
        \          +---+---+---+---+---+---+---+---+\n           |                               |\n
        \          +       session context ID      +\n           |                               |\n
        \          +---+---+---+---+---+---+---+---+\n           | I | 0 | 0 | 0 |
        \   sequence   |\n           +---+---+---+---+---+---+---+---+\n           |
        0 | 0 |       generation      |\n           +---+---+---+---+---+---+---+---+\n
        \                         ...\n           +---+---+---+---+---+---+---+---+\n
        \          |                               |\n           +       session context
        ID      +\n           |                               |\n           +---+---+---+---+---+---+---+---+\n
        \          | I | 0 | 0 | 0 |    sequence   |\n           +---+---+---+---+---+---+---+---+\n
        \          | 0 | 0 |       generation      |\n           +---+---+---+---+---+---+---+---+\n
        \  The bit labeled \"I\" is set to one for contexts that have been marked\n
        \  invalid and require a FULL_HEADER of COMPRESSED_NON_TCP packet to be\n
        \  transmitted.  If the I bit is zero, the context state is advisory.\n   The
        I bit is set to zero to indicate advisory context state that MAY\n   be sent
        following a link error indication.\n   Since the CONTEXT_STATE packet itself
        may be lost, retransmission of\n   one or more blocks is allowed.  It is expected
        that retransmission\n   will be triggered only by receipt of another packet,
        but if the line\n   is near idle, retransmission MAY be triggered by a relatively
        long\n   timer (on the order of 1 second).\n   If a CONTEXT_STATE block for
        a given context is retransmitted, it may\n   cross paths with the FULL_HEADER
        or COMPRESSED_NON_TCP packet\n   intended to refresh that context.  In that
        case, the compressor MAY\n   choose to ignore the error indication.\n   In
        the case where UDP checksums are being transmitted, the\n   decompressor MAY
        attempt to use the \"twice\" algorithm described in\n   section 10.1 of [3].
        \ In this algorithm, the delta is applied more\n   than once on the assumption
        that the delta may have been the same on\n   the missing packet(s) and the
        one subsequently received.  Success is\n   indicated by a checksum match.
        \ For the scheme defined here, the\n   difference in the 4- bit sequence number
        tells number of times the\n   delta must be applied.  Note, however, that
        there is a nontrivial\n   risk of an incorrect positive indication.  It may
        be advisable to\n   request a FULL_HEADER or COMPRESSED_NON_TCP packet even
        if the\n   \"twice\" algorithm succeeds.\n   Some errors may not be detected,
        for example if 16 packets are lost\n   in a row and the link level does not
        provide an error indication.  In\n   that case, the decompressor will generate
        packets that are not valid.\n   If UDP checksums are being transmitted, the
        receiver will probably\n   detect the invalid packets and discard them, but
        the receiver does\n   not have any means to signal the decompressor.  Therefore,
        it is\n   RECOMMENDED that the decompressor verify the UDP checksum\n   periodically,
        perhaps one out of 16 packets.  If an error is\n   detected, the decompressor
        would invalidate the context and signal\n   the compressor with a CONTEXT_STATE
        packet.\n"
      title: 3.3.5.  Error Recovery
    title: 3.3.  The protocol
  - contents:
    - "3.4.  Compression of RTCP Control Packets\n   By relying on the RTP convention
      that data is carried on an even port\n   number and the corresponding RTCP packets
      are carried on the next\n   higher (odd) port number, one could tailor separate
      compression\n   schemes to be applied to RTP and RTCP packets.  For RTCP, the\n
      \  compression could apply not only to the header but also the \"data\",\n   that
      is, the contents of the different packet types.  The numbers in\n   Sender Report
      (SR) and Receiver Report (RR) RTCP packets would not\n   compress well, but
      the text information in the Source Description\n   (SDES) packets could be compressed
      down to a bit mask indicating each\n   item that was present but compressed
      out (for timing purposes on the\n   SDES NOTE item and to allow the end system
      to measure the average\n   RTCP packet size for the interval calculation).\n
      \  However, in the compression scheme defined here, no compression will\n   be
      done on the RTCP headers and \"data\" for several reasons (though\n   compression
      SHOULD still be applied to the IP and UDP headers).\n   Since the RTP protocol
      specification suggests that the RTCP packet\n   interval be scaled so that the
      aggregate RTCP bandwidth used by all\n   participants in a session will be no
      more than 5% of the session\n   bandwidth, there is not much to be gained from
      RTCP compression.\n   Compressing out the SDES items would require a significant
      increase\n   in the shared state that must be stored for each context ID.  And,
      in\n   order to allow compression when SDES information for several sources\n
      \  was sent through an RTP \"mixer\", it would be necessary to maintain a\n
      \  separate RTCP session context for each SSRC identifier.  In a session\n   with
      more than 255 participants, this would cause perfect thrashing\n   of the context
      cache even when only one participant was sending data.\n   Even though RTCP
      is not compressed, the fraction of the total\n   bandwidth occupied by RTCP
      packets on the compressed link remains no\n   more than 5% in most cases, assuming
      that the RTCP packets are sent\n   as COMPRESSED_UDP packets.  Given that the
      uncompressed RTCP traffic\n   consumes no more than 5% of the total session
      bandwidth, then for a\n   typical RTCP packet length of 90 bytes, the portion
      of the compressed\n   bandwidth used by RTCP will be no more than 5% if the
      size of the\n   payload in RTP data packets is at least 108 bytes.  If the size
      of\n   the RTP data payload is smaller, the fraction will increase, but is\n
      \  still less than 7% for a payload size of 37 bytes.  For large data\n   payloads,
      the compressed RTCP fraction is less than the uncompressed\n   RTCP fraction
      (for example, 4% at 1000 bytes).\n"
    title: 3.4.  Compression of RTCP Control Packets
  - contents:
    - "3.5.  Compression of non-RTP UDP Packets\n   As described earlier, the COMPRESSED_UDP
      packet MAY be used to\n   compress UDP packets that don't carry RTP.  Whatever
      data follows the\n   UDP header is unlikely to have some constant values in
      the bits that\n   correspond to usually constant fields in the RTP header.  In\n
      \  particular, the SSRC field would likely change.  Therefore, it is\n   necessary
      to keep track of the non-RTP UDP packet streams to avoid\n   using up all the
      context slots as the \"SSRC field\" changes (since\n   that field is part of
      what identifies a particular RTP context).\n   Those streams may each be given
      a context, but the encoder would set\n   a flag in the context to indicate that
      the changing SSRC field should\n   be ignored and COMPRESSED_UDP packets should
      always be sent instead\n   of COMPRESSED_RTP packets.\n"
    title: 3.5.  Compression of non-RTP UDP Packets
  title: 3.  The Compression Algorithm
- contents:
  - "4.  Interaction With Segmentation\n   A segmentation scheme may be used in conjunction
    with RTP header\n   compression to allow small, real-time packets to interrupt
    large,\n   presumably non-real-time packets in order to reduce delay.  It is\n
    \  assumed that the large packets bypass the compressor and decompressor\n   since
    the interleaving would modify the sequencing of packets at the\n   decompressor
    and cause the appearance of errors.  Header compression\n   should be less important
    for large packets since the overhead ratio\n   is smaller.\n   If some packets
    from an RTP session context are selected for\n   segmentation (perhaps based on
    size) and some are not, there is a\n   possibility of re-ordering.  This would
    reduce the compression\n   efficiency because the large packets would appear as
    lost packets in\n   the sequence space.  However, this should not cause more serious\n
    \  problems because the RTP sequence numbers should be reconstructed\n   correctly
    and will allow the application to correct the ordering.\n   Link errors detected
    by the segmentation scheme using its own\n   sequencing information MAY be indicated
    to the compressor with an\n   advisory CONTEXT_STATE message just as for link
    errors detected by\n   the link layer itself.\n   The context ID byte is placed
    first in the COMPRESSED_RTP header so\n   that this byte MAY be shared with the
    segmentation layer if such\n   sharing is feasible and has been negotiated.  Since
    the compressor\n   may assign context ID values arbitrarily, the value can be
    set to\n   match the context identifier from the segmentation layer.\n"
  title: 4.  Interaction With Segmentation
- contents:
  - "5.  Negotiating Compression\n   The use of IP/UDP/RTP compression over a particular
    link is a\n   function of the link-layer protocol.  It is expected that such\n
    \  negotiation will be defined separately for PPP [4], for example.  The\n   following
    items MAY be negotiated:\n      o The size of the context ID.\n      o The maximum
    size of the stack of headers in the context.\n      o A context-specific table
    for decoding of delta values.\n"
  title: 5.  Negotiating Compression
- contents:
  - "6.  Acknowledgments\n   Several people have contributed to the design of this
    compression\n   scheme and related problems.  Scott Petrack initiated discussion
    of\n   RTP header compression in the AVT working group at Los Angeles in\n   March,
    1996.  Carsten Bormann has developed an overall architecture\n   for compression
    in combination with traffic control across a low-\n   speed link, and made several
    specific contributions to the scheme\n   described here.  David Oran independently
    developed a note based on\n   similar ideas, and suggested the use of PPP Multilink
    protocol for\n   segmentation.  Mikael Degermark has contributed advice on integration\n
    \  of this compression scheme with the IPv6 compression framework.\n"
  title: 6.  Acknowledgments
- contents:
  - "7.  References:\n   [1] Schulzrinne, H., Casner, S., Frederick, R. and V. Jacobson,
    \"RTP:\n       A Transport Protocol for real-time applications\", RFC 1889,\n
    \      January 1996.\n   [2] Jacobson, V., \"TCP/IP Compression for Low-Speed
    Serial Links\",\n       RFC 1144, February 1990.\n   [3] Degermark, M., Nordgren,
    B. and S. Pink, \"Header Compression for\n       IPv6\", RFC 2507, February 1999.\n
    \  [4] Simpson, W., \"The Point-to-Point Protocol (PPP)\", STD 51, RFC\n       1661,
    July 1994.\n   [5] Hoffman, D., Fernando, G., Goyal, V. and M. Civanlar, \"RTP\n
    \      Payload Format for MPEG1/MPEG2 Video\", RFC 2250, January 1998.\n"
  title: '7.  References:'
- contents:
  - "8.  Security Considerations\n   Because encryption eliminates the redundancy
    that this compression\n   scheme tries to exploit, there is some inducement to
    forego\n   encryption in order to achieve operation over a low-bandwidth link.\n
    \  However, for those cases where encryption of data and not headers is\n   satisfactory,
    RTP does specify an alternative encryption method in\n   which only the RTP payload
    is encrypted and the headers are left in\n   the clear.  That would allow compression
    to still be applied.\n   A malfunctioning or malicious compressor could cause
    the decompressor\n   to reconstitute packets that do not match the original packets
    but\n   still have valid IP, UDP and RTP headers and possibly even valid UDP\n
    \  check-sums.  Such corruption may be detected with end-to-end\n   authentication
    and integrity mechanisms which will not be affected by\n   the compression.  Constant
    portions of authentication headers will be\n   compressed as described in [3].\n
    \  No authentication is performed on the CONTEXT_STATE control packet\n   sent
    by this protocol.  An attacker with access to the link between\n   the decompressor
    and compressor could inject false CONTEXT_STATE\n   packets and cause compression
    efficiency to be reduced, probably\n   resulting in congestion on the link.  However,
    an attacker with\n   access to the link could also disrupt the traffic in many
    other ways.\n   A potential denial-of-service threat exists when using compression\n
    \  techniques that have non-uniform receiver-end computational load.\n   The attacker
    can inject pathological datagrams into the stream which\n   are complex to decompress
    and cause the receiver to be overloaded and\n   degrading processing of other
    streams.  However, this compression\n   does not exhibit any significant non-uniformity.\n
    \  A security review of this protocol found no additional security\n   considerations.\n"
  title: 8.  Security Considerations
- contents:
  - "9.  Authors' Addresses\n   Stephen L. Casner\n   Cisco Systems, Inc.\n   170
    West Tasman Drive\n   San Jose, CA 95134-1706\n   United States\n   EMail: casner@cisco.com\n
    \  Van Jacobson\n   Cisco Systems, Inc.\n   170 West Tasman Drive\n   San Jose,
    CA 95134-1706\n   United States\n   EMail: van@cisco.com\n"
  title: 9.  Authors' Addresses
- contents:
  - "10.  Full Copyright Statement\n   Copyright (C) The Internet Society (1999).
    \ All Rights Reserved.\n   This document and translations of it may be copied
    and furnished to\n   others, and derivative works that comment on or otherwise
    explain it\n   or assist in its implementation may be prepared, copied, published\n
    \  and distributed, in whole or in part, without restriction of any\n   kind,
    provided that the above copyright notice and this paragraph are\n   included on
    all such copies and derivative works.  However, this\n   document itself may not
    be modified in any way, such as by removing\n   the copyright notice or references
    to the Internet Society or other\n   Internet organizations, except as needed
    for the purpose of\n   developing Internet standards in which case the procedures
    for\n   copyrights defined in the Internet Standards process must be\n   followed,
    or as required to translate it into languages other than\n   English.\n   The
    limited permissions granted above are perpetual and will not be\n   revoked by
    the Internet Society or its successors or assigns.\n   This document and the information
    contained herein is provided on an\n   \"AS IS\" basis and THE INTERNET SOCIETY
    AND THE INTERNET ENGINEERING\n   TASK FORCE DISCLAIMS ALL WARRANTIES, EXPRESS
    OR IMPLIED, INCLUDING\n   BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE
    INFORMATION\n   HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES
    OF\n   MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.\n"
  title: 10.  Full Copyright Statement
