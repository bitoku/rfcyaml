Abstract The syntaxes of attributes in a Lightweight Directory Access Protocol (LDAP) or X.500 directory range from simple data types, such as text string, integer, or boolean, to complex structured data types, such as the syntaxes of the directory schema operational attributes.
Matching rules defined for the complex syntaxes usually only provide the most immediately useful matching capability.
This document defines generic matching rules that can match any user selected component parts in an attribute value of any arbitrarily complex attribute syntax.
The structure or data type of data held in an attribute of a Lightweight Directory Access Protocol (LDAP)
[7] or X.500 [19] directory is described by the attribute's syntax.
Attribute syntaxes range from simple data types, such as text string, integer, or boolean, to complex data types, for example, the syntaxes of the directory schema operational attributes.
In X.500, the attribute syntaxes are explicitly described by Abstract Syntax Notation One (ASN.1) [13] type definitions.
ASN.1 type notation has a number of simple data types (e.g., PrintableString, INTEGER, BOOLEAN), and combining types (i.e., SET, SEQUENCE, SET OF, SEQUENCE OF, and CHOICE) for constructing arbitrarily complex data types from simpler component types.
In LDAP, the attribute syntaxes are usually described in Augmented Backus Naur Form (ABNF) [2], though there is an implied association between the LDAP attribute syntaxes and the X.500 ASN.1 types.
To a large extent, the data types of attribute values in either an LDAP or X.500 directory are described by ASN.1 types.
This formal description can be exploited to identify component parts of an attribute value for a variety of purposes.
This document addresses attribute value matching.
With any complex attribute syntax there is normally a requirement to partially match an attribute value of that syntax by matching only selected components of the value.
Typically, matching rules specific to the attribute syntax are defined to fill this need.
These highly specific matching rules usually only provide the most immediately useful matching capability.
Some complex attribute syntaxes don't even have an equality matching rule let alone any additional matching rules for partial matching.
This document defines a generic way of matching user selected components in an attribute value of any arbitrarily complex attribute syntax, where that syntax is described using ASN.1 type notation.
All of the type notations defined in X.680 [13] are supported.
Section 3 describes the ComponentAssertion, a testable assertion about the value of a component of an attribute value of any complex syntax.
Section 4 introduces the ComponentFilter assertion, which is an expression of ComponentAssertions.
The ComponentFilter enables more powerful filter matching of components in an attribute value.
Section 5 defines the componentFilterMatch matching rule, which enables a ComponentFilter to be evaluated against attribute values.
Section 6 defines matching rules for component wise equality matching of attribute values of any syntax described by an ASN.1 type definition.
Examples showing the usage of componentFilterMatch are in Section 7.
For a new attribute syntax, the Generic String Encoding Rules [9] and the specifications in sections 3 to 6 of this document make it possible to fully and precisely define the LDAP specific encoding, the LDAP and X.500 binary encoding (and possibly other ASN.1 encodings in the future), a suitable equality matching rule, and a comprehensive collection of component matching capabilities, by simply writing down an ASN.1 type definition for the syntax.
These implicit definitions are also automatically extended if the ASN.1 type is later extended.
The algorithmic relationship between the ASN.1 type definition, the various encodings and the component matching behaviour makes directory server implementation support for the component matching rules amenable to automatic code generation from ASN.1 type definitions.
Schema designers have the choice of storing related items of data as a single attribute value of a complex syntax in some entry, or as a subordinate entry where the related data items are stored as separate attribute values of simpler syntaxes.
The inability to search component parts of a complex syntax has been used as an argument for favouring the subordinate entries approach.
The component matching rules provide the analogous matching capability on an attribute value of a complex syntax that a search filter has on a subordinate entry.
Most LDAP syntaxes have corresponding ASN.1 type definitions, though they are usually not reproduced or referenced alongside the formal definition of the LDAP syntax.
Syntaxes defined with only a character string encoding, i.e., without an explicit or implied corresponding ASN.1 type definition, cannot use the component matching capabilities described in this document unless and until a semantically equivalent ASN.1 type definition is defined for them.
Throughout this document "type" shall be taken to mean an ASN.1 type unless explicitly qualified as an attribute type, and
"value" shall be taken to mean an ASN.1 value unless explicitly qualified as an attribute value.
Note that "ASN.1 value" does not mean a Basic Encoding Rules (BER) [17] encoded value.
The ASN.1 value is an abstract concept that is independent of any particular encoding.
BER is just one possible encoding of an ASN.1 value.
The component matching rules operate at the abstract level without regard for the possible encodings of a value.
Attribute type and matching rule definitions in this document are provided in both the X.500 [10] and LDAP [4] description formats.
Note that the LDAP descriptions have been rendered with additional white space and line breaks for the sake of readability.
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED" and "MAY" in this document are to be interpreted as described in BCP 14, RFC 2119 [1].
The key word "OPTIONAL" is exclusively used with its ASN.1 meaning.
ComponentAssertion A ComponentAssertion is an assertion about the presence, or values of, components within an ASN.1 value, i.e., an instance of an ASN.1 type.
The ASN.1 value is typically an attribute value, where the ASN.1 type is the syntax of the attribute.
However, a ComponentAssertion may also be applied to a component part of an attribute value.
The assertion evaluates to either TRUE, FALSE or Undefined for each tested ASN.1 value.
A ComponentAssertion is described by the following ASN.1 type (assumed to be defined with "EXPLICIT TAGS" in force):
MATCHING RULE.&AssertionType is an open type (formerly known as the ANY type).
The "component" field of a ComponentAssertion identifies which component part of a value of some ASN.1 type is to be tested, the "useDefaultValues" field indicates whether DEFAULT values are to be substituted for absent component values, the "rule" field indicates how the component is to be tested, and the "value" field is an asserted ASN.1 value against which the component is tested.
The ASN.1 type of the asserted value is determined by the chosen rule.
The fields of a ComponentAssertion are described in detail in the following sections.
Component Type Substitutions ASN.1 type notation has a number of constructs for referencing other defined types, and constructs that are irrelevant for matching purposes.
These constructs are not represented in a component reference in any way and substitutions of the component type are performed to eliminate them from further consideration.
These substitutions automatically occur prior to each ComponentId, whether constructing or interpreting a component reference, but do not occur after the last ComponentId, except as allowed by Section 3.2.
If the ASN.1 type is an ASN.1 type reference then the component type is taken to be the actual definition on the right hand side of the type assignment for the referenced type.
If the ASN.1 type is a tagged type then the component type is taken to be the type without the tag.
If the ASN.1 type is a constrained type (see X.680 [13] and X.682 [15] for the details of ASN.1 constraint notation) then the component type is taken to be the type without the constraint.
If the ASN.1 type is an ObjectClassFieldType
(Clause 14 of X.681 [14]) that denotes a specific ASN.1 type (e.g., MATCHING RULE.&id denotes the OBJECT IDENTIFIER type)
then the component type is taken to be the denoted type.
Section 3.1.6 describes the case where the ObjectClassFieldType denotes an open type.
If the ASN.1 type is a selection type other than one used in the list of components for a SET or SEQUENCE type then the component type is taken to be the selected alternative type from the named CHOICE.
If the ASN.1 type is a TypeFromObject (Clause 15 of X.681 [14]) then the component type is taken to be the denoted type.
If the ASN.1 type is a ValueSetFromObjects (Clause 15 of X.681 [14]) then the component type is taken to be the governing type of the denoted values.
Referencing SET, SEQUENCE and CHOICE Components
If the ASN.1 type is a SET or SEQUENCE type then
the <identifier> form of ComponentId may be used to identify the component type within that SET or SEQUENCE having that identifier.
If <identifier> references an OPTIONAL component type and that component is not present in a particular value
then there are no corresponding component values.
If <identifier> references a DEFAULT component type and useDefaultValues is TRUE (the default setting for useDefaultValues) and that component is not present in a particular value
then the component value is taken to be the default value.
If <identifier> references a DEFAULT component type and useDefaultValues is FALSE and that component is not present in a particular value
then there are no corresponding component values.
If the ASN.1 type is a CHOICE type then the <identifier> form of ComponentId may be used to identify the alternative type within that CHOICE having that identifier.
If <identifier> references an alternative other than the one used in a particular value
then there are no corresponding component values.
The COMPONENTS OF notation in Clause 24 of X.680 [13] augments the defined list of components in a SET or SEQUENCE type by including all the components of another defined SET or SEQUENCE type respectively.
These included components are referenced directly by identifier as though they were defined in line in the SET or SEQUENCE type containing the COMPONENTS OF notation.
The SelectionType (Clause 29 of X.680 [13]), when used in the list of components for a SET or SEQUENCE type, includes a single component from a defined CHOICE type.
This included component is referenced directly by identifier as though it was defined in line in the SET or SEQUENCE type.
The REAL type is treated as though it is the SEQUENCE type defined in Clause 20.5 of X.680 [13].
The EMBEDDED PDV type is treated as though it is the SEQUENCE type defined in Clause 33.5 of X.680 [13].
The EXTERNAL type is treated as though it is the SEQUENCE type defined in Clause 8.18.1 of X.690 [17].
The unrestricted CHARACTER STRING type is treated as though it is the SEQUENCE type defined in Clause 40.5 of X.680 [13].
The INSTANCE OF type is treated as though it is the SEQUENCE type defined in Annex C of X.681 [14].
The <identifier> form MUST NOT be used on any other ASN.1 type.
Referencing SET OF and SEQUENCE OF Components
If the ASN.1 type is a SET OF or SEQUENCE OF type then the <from beginning>, <from end>, <count> and <all> forms of ComponentId may be used.
If <from beginning> references a higher numbered instance than the last instance in a particular value of the SET OF or SEQUENCE OF type then there is no corresponding component value.
The <from end> form of ComponentId may be used to identify one instance of the component type of the SET OF or SEQUENCE OF type, where " 1" is the last instance, " 2" is the second last instance, and so on.
If <from end> references a lower numbered instance than the first instance in a particular value of the SET OF or SEQUENCE OF type
then there is no corresponding component value.
The <count> form of ComponentId identifies a notional count of the number of instances of the component type in a value of the SET OF or SEQUENCE OF type.
This count is not explicitly represented but for matching purposes it has an assumed ASN.1 type of INTEGER
of the <count> form, if used, MUST be the last ComponentId in a component reference.
The <all> form of ComponentId may be used to simultaneously identify all instances of the component type of the SET OF or SEQUENCE OF type.
It is through the <all> form that a component reference can identify more than one component value.
However, if a particular value of the SET OF or SEQUENCE OF type is an empty list, then there are no corresponding component values.
Where multiple component values are identified, the remaining ComponentIds in the component reference, if any, can identify zero, one or more subcomponent values for each of the higher level component values.
The corresponding ASN.1 type for the <from beginning>, <from end
>, and <all> forms of ComponentId is the component type of the SET OF or SEQUENCE OF type.
The <from beginning>, <count>, <from end
<all> forms MUST NOT be used on ASN.1 types other than SET OF or SEQUENCE OF.
Parameterized Types A component reference cannot be formed for a parameterized type unless the type has been used with actual parameters, in which case the type is treated as though the DummyReferences [16] have been substituted with the actual parameters.
Component Referencing Example Consider the following ASN.1 type definitions.
Following are component references constructed with respect to the type ExampleType.
The component reference "part1" identifies a component of a value of ExampleType having the ASN.1 tagged type [0] INTEGER.
The component reference "part2" identifies a component of a value of ExampleType having the ASN.1 type of [1]
The component reference "part2.option" identifies a component of a value of ExampleType having the ASN.1 type of PrintableString.
A ComponentAssertion could also be applied to a value of ASN.1 type ExampleSet, in which case the component reference "option" would identify the same kind of information.
The component reference "part3" identifies a component of a value of ExampleType having the ASN.1 type of [2] SET OF OBJECT IDENTIFIER.
The component reference "part3.2" identifies the second instance of the part3 SET OF.
The instance has the ASN.1 type of OBJECT IDENTIFIER.
The component reference "part3.0" identifies the count of the number of instances in the part3
The count has the corresponding ASN.1 type of INTEGER (0..MAX).
The component reference "part3. " identifies all the instances in the part3
Each instance has the ASN.1 type of OBJECT IDENTIFIER.
The component reference "part4" identifies a component of a value of ExampleType having the ASN.1 type of [3] ExampleChoice.
The component reference "part4.miney mo" identifies a component of a value of ExampleType having the ASN.1 type of OCTET STRING.
Referencing Components of Open Types
If a sequence of ComponentIds identifies an ObjectClassFieldType denoting an open type (e.g., ATTRIBUTE.&Type denotes an open type)
then the ASN.1 type of the component varies.
An open type is typically constrained by some other component(s) in an outer enclosing type, either formally through the use of a component relation constraint [15], or informally in the accompanying text, so the actual ASN.1 type of a value of the open type will generally be known.
The constraint will also limit the range of permissible types.
The <select> form of ComponentId may be used to identify one of these permissible types in an open type.
Subcomponents of that type can then be identified with further ComponentIds.
The other components constraining the open type are termed the referenced components [15].
The <select> form contains a list of one or more values which take the place of the value(s) of the referenced component(s) to uniquely identify one of the permissible types of the open type.
Where the open type is constrained by a component relation constraint, there is a <Value> in the <select> form for each of the referenced components in the component relation constraint, appearing in the same order.
The ASN.1 type of each of these values is the same as the ASN.1 type of the corresponding referenced component.
The type of a referenced component is potentially any ASN.1 type however it is typically an OBJECT IDENTIFIER or INTEGER, which means that the <Value> in the <select> form of ComponentId will nearly always be an <ObjectIdentifierValue> or <IntegerValue> [9].
Furthermore, component relation constraints typically have only one referenced component.
Where the open type is not constrained by a component relation constraint, the specification introducing the syntax containing the open type should explicitly nominate the referenced components and their order, so that the <select> form can be used.
If an instance of <select> contains a value other than the value of the referenced component used in a particular value of the outer enclosing type
then there are no corresponding component values for the open type.
The ASN.1 type AttributeTypeAndValue [10]
describes a single attribute value of a nominated attribute type.
SEQUENCE { type    ATTRIBUTE.&id ({SupportedAttributes}), value   ATTRIBUTE.&Type
ATTRIBUTE.&Type denotes an open type, in this case an attribute value, and ({SupportedAttributes}{@type}) is a component relation constraint that constrains the open type to be of the attribute syntax for the attribute type.
The component relation constraint references only the "type" component, which has the ASN.1 type of OBJECT IDENTIFIER, thus if the <select> form of ComponentId is used to identify attribute values of specific attribute types it will contain a single OBJECT IDENTIFIER value.
The component reference "value" on AttributeTypeAndValue refers to the open type.
One of the X.500 standard attributes is facsimileTelephoneNumber [12], which is identified with the OBJECT IDENTIFIER 2.5.4.23, and is defined to have the following syntax.
The component reference "value.(2.5.4.23)" on AttributeTypeAndValue specifies an attribute value with the FacsimileTelephoneNumber syntax.
The component reference "value.(2.5.4.23).telephoneNumber" on AttributeTypeAndValue identifies the telephoneNumber component of a facsimileTelephoneNumber attribute value.
The component reference "value.(facsimileTelephoneNumber)" is equivalent to "value.(2.5.4.23)".
If the AttributeTypeAndValue ASN.1 value contains an attribute type other than facsimileTelephoneNumber then there are no corresponding component values for the component references "value.(2.5.4.23)" and "value.(2.5.4.23).telephoneNumber".
Sometimes the contents of a BIT STRING or OCTET STRING value are required to be the encodings of other ASN.1 values of specific ASN.1 types.
For example, the extnValue component of the Extension type component in the Certificate type [11] is an OCTET STRING that is required to contain a Distinguished Encoding Rules (DER) [17] encoding of a certificate extension value.
It is useful to be able to refer to the embedded encoded value and its components.
An embedded encoded value is here referred to as a contained value and its associated type as the contained type.
If the ASN.1 type is a BIT STRING or OCTET STRING type containing encodings of other ASN.1 values then the <content> form of ComponentId may be used to identify the contained type.
Subcomponents of that type can then be identified with further ComponentIds.
The contained type may be (effectively) an open type, constrained by some other component in an outer enclosing type (e.g., in a certificate Extension, extnValue is constrained by the chosen extnId).
In these cases the next ComponentId, if any, MUST be of the <select> form.
For the purpose of building component references, the content of the extnValue OCTET STRING in the Extension type is assumed to be an open type having a notional component relation constraint with the extnId component as the single referenced component, i.e., EXTENSION.&ExtnType ({ExtensionSet}{@extnId})
The data value component of the associated types for the EMBEDDED PDV and CHARACTER STRING types is an OCTET STRING containing the encoding of a data value described by the identification component.
For the purpose of building component references, the content of the data value OCTET STRING in these types is assumed to be an open type having a notional component relation constraint with the identification component as the single referenced component.
The Extension ASN.1 type [11] describes a single certificate extension value of a nominated extension type.
The component reference "extnValue" on Extension refers to a component type of OCTET STRING.
The corresponding component values will be OCTET STRING values.
The component reference "extnValue.content" on Extension refers to the type of the contained type, which in this case is an open type.
One of the X.509 [11] standard extensions is basicConstraints, which is identified with the OBJECT IDENTIFIER 2.5.29.19 and is defined to have the following syntax.
The component reference "extnValue.content.(2.5.29.19)" on Extension specifies a BasicConstraintsSyntax extension value and the component reference "extnValue.content.(2.5.29.19).cA
" identifies the cA component of a BasicConstraintsSyntax extension value.
The rule in a ComponentAssertion specifies how the zero, one or more component values identified by the component reference are tested by the assertion.
Attribute matching rules are used to specify the semantics of the test.
Each matching rule has a notional set of attribute syntaxes (typically one), defined as ASN.1 types, to which it may be applied.
When used in a ComponentAssertion these matching rules apply to the same ASN.1 types, only in this context the corresponding ASN.1 values are not necessarily complete attribute values.
Note that the referenced component type may be a tagged and/or constrained version of the expected attribute syntax (e.g., [0] INTEGER, whereas integerMatch would expect simply INTEGER), or an open type.
Additional type substitutions of the kind described in Section 3.1.1 are performed as required to reduce the component type to the same type as the attribute syntax expected by the matching rule.
If a matching rule applies to more than one attribute syntax (e.g., objectIdentifierFirstComponentMatch [12]) then the minimum number of substitutions required to conform to any one of those syntaxes is performed.
If a matching rule can apply to any attribute syntax (e.g., the allComponentsMatch rule defined in Section 6.2)
then the referenced component type is used as is, with no additional substitutions.
The value in a ComponentAssertion will be of the assertion syntax (i.e., ASN.1 type) required by the chosen matching rule.
Note that the assertion syntax of a matching rule is not necessarily the same as the attribute syntax(es) to which the rule may be applied.
Some matching rules do not have a fixed assertion syntax (e.g., allComponentsMatch).
The required assertion syntax is determined in each instance of use by the syntax of the attribute type to which the matching rule is applied.
For these rules the ASN.1 type of the referenced component is used in place of an attribute syntax to decide the required assertion syntax.
The ComponentAssertion is Undefined if: a) the matching rule in the ComponentAssertion is not known to the evaluating procedure, b) the matching rule is not applicable to the referenced component type, even with the additional type substitutions, c)
the value in the ComponentAssertion does not conform to the assertion syntax defined for the matching rule, d) some part of the component reference identifies an open type in the tested value that cannot be decoded, or e) the implementation does not support the particular combination of component reference and matching rule.
If the ComponentAssertion is not Undefined then the ComponentAssertion evaluates to TRUE if there is at least one component value for which the matching rule applied to that component value returns TRUE, and evaluates to FALSE otherwise (which includes the case where there are no component values).
Applicability of Existing Matching Rules
String Matching ASN.1 has a number of built in restricted character string types with different character sets and/or different character encodings.
A directory user generally has little interest in the particular character set or encoding used to represent a character string component value, and some directory server implementations make no distinction between the different string types in their internal representation of values.
So rather than define string matching rules for each of the restricted character string types, the existing case ignore and case exact string matching rules are extended to apply to component values of any of the restricted character string types and any ChoiceOfStrings type [9], in addition to component values of the DirectoryString type.
This extension is only for the purposes of component matching described in this document.
The relevant string matching rules are: caseIgnoreMatch, caseIgnoreOrderingMatch, caseIgnoreSubstringsMatch, caseExactMatch, caseExactOrderingMatch and caseExactSubstringsMatch.
The relevant restricted character string types are: NumericString, PrintableString, VisibleString, IA5String, UTF8String, BMPString, UniversalString, TeletexString, VideotexString, GraphicString and GeneralString.
A ChoiceOfStrings type is a purely syntactic CHOICE of these ASN.1 string types.
Note that GSER [9] declares each and every use of the DirectoryString{} parameterized type to be a ChoiceOfStrings type.
The assertion syntax of the string matching rules is still DirectoryString regardless of the string syntax of the component being matched.
Thus an implementation will be called upon to compare a DirectoryString value to a value of one of the restricted character string types, or a ChoiceOfStrings type.
As is the case when comparing two DirectoryStrings where the chosen alternatives are of different string types, the comparison proceeds so long as the corresponding characters are representable in both character sets.
Telephone Number Matching Early editions of X.520 [12] gave the syntax of the telephoneNumber attribute as a constrained PrintableString.
The fourth edition of X.520 equates the ASN.1 type name TelephoneNumber to the constrained PrintableString and uses TelephoneNumber as the attribute and assertion syntax.
For the purposes of component matching, telephoneNumberMatch and telephoneNumberSubstringsMatch are permitted to be applied to any PrintableString value, as well as to TelephoneNumber values.
Distinguished Name Matching The DistinguishedName type is defined by assignment to be the same as the RDNSequence type, however RDNSequence is sometimes directly used in other type definitions.
For the purposes of component matching, distinguishedNameMatch is also permitted to be applied to values of the RDNSequence type.
This section defines additional matching rules that may prove useful in ComponentAssertions.
These rules may also be used in extensibleMatch search filters [3].
The distinguishedNameMatch matching rule can match whole distinguished names but it is sometimes useful to be able to match specific Relative Distinguished Names (RDNs) in a Distinguished Name (DN) without regard for the other RDNs in the DN.
The rdnMatch matching rule allows component RDNs of a DN to be tested.
The LDAP style definitions for rdnMatch and its assertion syntax are: ( 1.2.36.79672281.1.13.3 NAME 'rdnMatch' SYNTAX 1.2.36.79672281.1.5.0 )
( 1.2.36.79672281.1.5.0 DESC 'RDN' )
The LDAP specific encoding for a value of the RDN syntax is given by the <RelativeDistinguishedNameValue> rule [9].
The rdnMatch rule evaluates to true if the component value and assertion value are the same RDN, using the same RDN comparison method as distinguishedNameMatch.
When using rdnMatch to match components of DNs it is important to note that the LDAP specific encoding of a DN [5] reverses the order of the RDNs.
So for the DN represented in LDAP as "cn Steven Legg,o Adacel,c AU", the RDN "cn Steven Legg
" corresponds to the component reference "3", or alternatively, " 1".
At times it would be useful to test not if a specific value of a particular component is present, but whether any value of a particular component is present.
The presentMatch matching rule allows the presence of a particular component value to be tested.
The LDAP style definitions for presentMatch and its assertion syntax are: (
1.2.36.79672281.1.13.5 NAME 'presentMatch' SYNTAX 1.2.36.79672281.1.5.1 )
( 1.2.36.79672281.1.5.1 DESC 'NULL' )
The LDAP specific encoding for a value of the NULL syntax is given by the <NullValue> rule [9].
In a ComponentAssertion, presentMatch evaluates to TRUE if and only if the component reference identifies one or more component values, regardless of the actual component value contents.
Note that if useDefaultValues is TRUE then the identified component values may be (part of) a DEFAULT value.
The notional count referenced by the <count> form of ComponentId is taken to be present if the SET OF value is present, and absent otherwise.
Note that in ASN.1 notation an absent SET OF value is distinctly different from a SET OF value that is present but empty.
It is up to the specification using the ASN.1 notation to decide whether the distinction matters.
Often an empty SET OF component and an absent SET OF component are treated as semantically equivalent.
If a SET OF value is present, but empty, a presentMatch on the SET OF component SHALL return TRUE and the notional count SHALL be regarded as present and equal to zero.
Summary of Useful Matching Rules
The following is a non exhaustive list of useful matching rules and the ASN.1 types to which they can be applied, taking account of all the extensions described in Section 3.2.1, and the new matching rules defined in Section 3.2.2.
Note that the allComponentsMatch matching rule defined in Section 6.2 can be used for equality matching of values of the ENUMERATED, NULL, REAL and RELATIVE OID ASN.1 types, among other things.
The ComponentAssertion allows the value(s) of any one component type in a complex ASN.1 type to be matched, but there is often a desire to match the values of more than one component type.
A ComponentFilter is an assertion about the presence, or values of, multiple components within an ASN.1 value.
The ComponentFilter assertion, an expression of ComponentAssertions, evaluates to either TRUE, FALSE or Undefined for each tested ASN.1 value.
A ComponentFilter is described by the following ASN.1 type (assumed to be defined with "EXPLICIT TAGS" in force):
A ComponentFilter that is a ComponentAssertion evaluates to TRUE if the ComponentAssertion is TRUE, evaluates to FALSE if the ComponentAssertion is FALSE, and evaluates to Undefined otherwise.
The "and" of a sequence of component filters evaluates to TRUE if the sequence is empty or if each component filter evaluates to TRUE, evaluates to FALSE if at least one component filter is FALSE, and evaluates to Undefined otherwise.
The "or" of a sequence of component filters evaluates to FALSE if the sequence is empty or if each component filter evaluates to FALSE, evaluates to TRUE if at least one component filter is TRUE, and evaluates to Undefined otherwise.
The "not" of a component filter evaluates to TRUE if the component filter is FALSE, evaluates to FALSE if the component filter is TRUE, and evaluates to Undefined otherwise.
The componentFilterMatch matching rule allows a ComponentFilter to be applied to an attribute value.
The result of the matching rule is the result of applying the ComponentFilter to the attribute value.
The LDAP style definitions for componentFilterMatch and its assertion syntax are: ( 1.2.36.79672281.1.13.2 NAME 'componentFilterMatch' SYNTAX 1.2.36.79672281.1.5.2 )
( 1.2.36.79672281.1.5.2 DESC 'ComponentFilter' )
The LDAP specific encoding for the ComponentFilter assertion syntax is specified by GSER [9].
As a convenience to implementors, an equivalent ABNF description of the GSER encoding for ComponentFilter is provided here.
In the event that there is a discrepancy between this ABNF and the encoding determined by GSER, GSER is to be taken as definitive.
The GSER encoding of a ComponentFilter is described by the following equivalent ABNF:
; "component" use defaults label
one or more space characters msp
1 %x20  ; one or more space characters
The ABNF for <Value>, <StringValue>,
<BooleanValue> is defined by GSER [9].
The ABNF descriptions of LDAP specific encodings for attribute syntaxes typically do not clearly or consistently delineate the component parts of an attribute value.
A regular and uniform character string encoding for arbitrary component data types is needed to encode the assertion value in a ComponentAssertion.
The <Value> rule from GSER provides a human readable text encoding for a component value of any arbitrary ASN.1 type.
The X.500 style definition [10] for componentFilterMatch is:
} A ComponentAssertion can potentially use any matching rule, including componentFilterMatch, so componentFilterMatch may be nested.
The component references in a nested componentFilterMatch are relative to the component corresponding to the containing ComponentAssertion.
In Section 7, an example search on the seeAlso attribute shows this usage.
Equality Matching of Complex Components
It is possible to test if an attribute value of a complex ASN.1 syntax is the same as some purported (i.e., assertion) value by using a complicated ComponentFilter that tests if corresponding components are the same.
However, it would be more convenient to be able to present a whole assertion value to a matching rule that could do the component wise comparison of an attribute value with the assertion value for any arbitrary attribute syntax.
Similarly, the ability to do a straightforward equality comparison of a component value that is itself of a complex ASN.1 type would also be convenient.
It would be difficult to define a single matching rule that simultaneously satisfies all notions of what the equality matching semantics should be.
For example, in some instances a case sensitive comparison of string components may be preferable to a case insensitive comparison.
Therefore a basic equality matching rule, allComponentsMatch, is defined in Section 6.2, and the means to derive new matching rules from it with slightly different equality matching semantics are described in Section 6.3.
The directoryComponentsMatch defined in Section 6.4 is a derivation of allComponentsMatch that suits typical uses of the directory.
Other specifications are free to derive new rules from allComponentsMatch or directoryComponentsMatch, that suit their usage of the directory.
The allComponentsMatch rule, the directoryComponentsMatch rule and any matching rules derived from them are collectively called component equality matching rules.
The component equality matching rules have a variable assertion syntax.
In X.500 this is indicated by omitting the optional SYNTAX field in the MATCHING RULE information object.
The assertion syntax then defaults to the target attribute's syntax in actual usage, unless the description of the matching rule says otherwise.
The SYNTAX field in the LDAP specific encoding of a MatchingRuleDescription is mandatory, so the OpenAssertionType syntax is defined to fill the same role.
That is, the OpenAssertionType syntax is semantically equivalent to an omitted SYNTAX field in an X.500 MATCHING RULE information object.
OpenAssertionType MUST NOT be used as the attribute syntax in an attribute type definition.
Unless explicitly varied by the description of a particular matching rule, if an OpenAssertionType assertion value appears in a ComponentAssertion its LDAP specific encoding is described by the <Value> rule in GSER [9], otherwise its LDAP specific encoding is the encoding defined for the syntax of the attribute type to which the matching rule with the OpenAssertionType assertion syntax is applied.
The LDAP definition for the OpenAssertionType syntax is: ( 1.2.36.79672281.1.5.3 DESC 'OpenAssertionType' ) 6.2.
The LDAP style definition for allComponentsMatch is: ( 1.2.36.79672281.1.13.6
The X.500 style definition for allComponentsMatch is: allComponentsMatch
Otherwise, the assertion syntax of allComponentsMatch is the same as the attribute syntax of the attribute to which the matching rule is applied.
Broadly speaking, this matching rule evaluates to true if and only if corresponding components of the assertion value and the attribute or component value are the same.
In detail, equality is determined by the following cases applied recursively.
Two values of a SET or SEQUENCE type are the same if and only if, for each component type, the corresponding component values are either, 1)
both present and the same, or 3) absent or the same as the DEFAULT value for the component, if a DEFAULT value is defined.
Values of an EMBEDDED PDV, EXTERNAL, unrestricted CHARACTER STRING, or INSTANCE OF type are compared according to their respective associated SEQUENCE type (see Section 3.1.2).
Two values of a SEQUENCE OF type are the same if and only if, the values have the same number of (possibly duplicated) instances and corresponding instances are the same.
Two values of a SET OF type are the same if and only if, the values have the same number of instances and each distinct instance occurs in both values the same number of times,
i.e., both values have the same instances, including duplicates, but in any order.
Two values of a CHOICE type are the same if and only if, both values are of the same chosen alternative and the component values are the same.
Two BIT STRING values are the same if and only if the values have the same number of bits and corresponding bits are the same.
If the BIT STRING type is defined with a named bit list then trailing zero bits in the values are treated as absent for the purposes of this comparison.
Two BOOLEAN values are the same if and only if both are TRUE or both are FALSE.
Two values of a string type are the same if and only if the values have the same number of characters and corresponding characters are the same.
For the purposes of allComponentsMatch, the string types are NumericString, PrintableString, TeletexString (T61String), VideotexString, IA5String, GraphicString, VisibleString (ISO646String), GeneralString, UniversalString, BMPString, UTF8String, GeneralizedTime, UTCTime and ObjectDescriptor.
Two INTEGER values are the same if and only if the integers are equal.
Two ENUMERATED values are the same if and only if the enumeration item identifiers are the same (equivalently, if the integer values associated with the identifiers are equal).
Two NULL values are always the same, unconditionally.
Two OBJECT IDENTIFIER values are the same if and only if the values have the same number of arcs and corresponding arcs are the same.
Two OCTET STRING values are the same if and only if the values have the same number of octets and corresponding octets are the same.
Two REAL values are the same if and only if they are both the same special value, or neither is a special value and they have the same base and represent the same real number.
The special values for REAL are zero, PLUS INFINITY and MINUS INFINITY.
Two RELATIVE OID values are the same if and only if the values have the same number of arcs and corresponding arcs are the same.
The respective starting nodes for the RELATIVE OID values are disregarded in the comparison, i.e., they are assumed to be the same.
Two values of an open type are the same if and only if both are of the same ASN.1 type and are the same according to that type.
If the actual ASN.1 type of the values is unknown then the allComponentsMatch rule evaluates to Undefined.
Tags and constraints, being part of the type definition and not part of the abstract values, are ignored for matching purposes.
The allComponentsMatch rule may be used as the defined equality matching rule for an attribute.
Deriving Component Equality Matching Rules
A new component equality matching rule with more refined matching semantics may be derived from allComponentsMatch, or any other component equality matching rule, using the convention described in this section.
The matching behaviour of a derived component equality matching rule is specified by nominating, for each of one or more identified components, a commutative equality matching rule that will be used to match values of that component.
This overrides the matching that would otherwise occur for values of that component using the base rule for the derivation.
These overrides can be conveniently represented as rows in a table of the following form.
Usually, all component values of a particular ASN.1 type are to be matched the same way.
An ASN.1 type reference (e.g., DistinguishedName) or an ASN.1 built in type name (e.g., INTEGER) in the Component column of the table specifies that the nominated equality matching rule is to be applied to all values of the named type, regardless of context.
specifies that the nominated matching rule applies only to the identified components of values of the named type.
Other component values that happen to be of the same ASN.1 type are not selected.
Additional type substitutions as described in Section 3.2 are assumed to be performed to align the component type with the matching rule assertion syntax.
Conceptually, the rows in a table for the base rule are appended to the rows in the table for a derived rule for the purpose of deciding the matching semantics of the derived rule.
Notionally, allComponentsMatch has an empty table.
A row specifying values of an outer containing type (e.g., DistinguishedName) takes precedence over a row specifying values of an inner component type (e.g., RelativeDistinguishedName), regardless of their order in the table.
Specifying a row for component values of an inner type is only useful if a value of the type can also appear on its own, or as a component of values of a different outer type.
For example, if there is a row for DistinguishedName then a row for RelativeDistinguishedName can only ever apply to RelativeDistinguishedName component values that are not part of a DistinguishedName.
A row for values of an outer type in the table for the base rule takes precedence over a row for values of an inner type in the table for the derived rule.
Where more than one row applies to a particular component value the earlier row takes precedence over the later row.
Thus rows in the table for the derived rule take precedence over any rows for the same component in the table for the base rule.
The directoryComponentsMatch matching rule is derived from the allComponentsMatch matching rule.
The LDAP style definition for directoryComponentsMatch is: (
1.2.36.79672281.1.13.7 NAME 'directoryComponentsMatch' SYNTAX 1.2.36.79672281.1.5.3 )
The X.500 style definition for directoryComponentsMatch is: directoryComponentsMatch MATCHING RULE ::
The DistinguishedName type is defined by assignment to be the same as the RDNSequence type.
Some types (e.g., Name and LocalName) directly reference RDNSequence rather than DistinguishedName.
Specifying RDNSequence captures all these DN like types.
A RelativeDistinguishedName value is only matched by rdnMatch if it is not part of an RDNSequence value.
The telephone number component of the FacsimileTelephoneNumber ASN.1 type [12] is defined as a constrained PrintableString.
component values that are part of a FacsimileTelephoneNumber value can be identified separately from other components of PrintableString type by the specifier FacsimileTelephoneNumber.telephoneNumber, so that telephoneNumberMatch can be selectively applied.
The fourth edition of X.520 defines the telephoneNumber component of FacsimileTelephoneNumber to be of the type TelephoneNumber, making the row for FacsimileTelephoneNumber.telephoneNumber components redundant.
The directoryComponentsMatch rule may be used as the defined equality matching rule for an attribute.
This section contains examples of search filters using the componentFilterMatch matching rule.
The filters are described using the string representation of LDAP search filters [18].
Note that this representation requires asterisks to be escaped in assertion values
(in these examples the assertion values are all <ComponentAssertion> encodings).
The asterisks have not been escaped in these examples for the sake of clarity, and to avoid confusing the protocol representation of LDAP search filter assertion values, where such escaping does not apply.
Line breaks and indenting have been added only as an aid to readability.
The example search filters using componentFilterMatch are all single extensible match filter items, though there is no reason why componentFilterMatch can't be used in more complicated search filters.
The first examples describe searches over the objectClasses schema operational attribute, which has an attribute syntax described by the ASN.1 type ObjectClassDescription
[10], and holds the definitions of the object classes known to a directory server.
The definition of ObjectClassDescription is as follows:
A value of OBJECT CLASS.&id is an OBJECT IDENTIFIER for an object class.
A value of ATTRIBUTE.&id is an OBJECT IDENTIFIER for an attribute type.
The following search filter finds the object class definition for the object class identified by the OBJECT IDENTIFIER 2.5.6.18:
item:{ component "identifier", rule objectIdentifierMatch, value 2.5.6.18 })
A match on the "identifier" component of objectClasses values is equivalent to the objectIdentifierFirstComponentMatch matching rule applied to attribute values of the objectClasses attribute type.
The componentFilterMatch matching rule subsumes the functionality of the objectIdentifierFirstComponentMatch, integerFirstComponentMatch and directoryStringFirstComponentMatch matching rules.
The following search filter finds the object class definition for the object class called foobar:
An object class definition can have multiple names and the above filter will match an objectClasses value if any one of the names is "foobar".
The component reference "name.0" identifies the notional count of the number of names in an object class definition.
The following search filter finds object class definitions with exactly one name:
item:{ component "name.0", rule integerMatch, value 1 })
The "description" component of an ObjectClassDescription is defined to be an OPTIONAL DirectoryString.
The following search filter finds object class definitions that have descriptions, regardless of the contents of the description string:
item:{ component "description", rule presentMatch, value NULL })
The presentMatch returns TRUE if the description component is present and FALSE otherwise.
The following search filter finds object class definitions that don't have descriptions:
componentFilterMatch:  not:item:{ component "description", rule presentMatch, value NULL })
The following search filter finds object class definitions with the word "bogus" in the description:
An object class is obsolete if the "obsolete" component is present and set to TRUE.
The following search filter finds all obsolete object classes: (
item:{ component "obsolete", rule booleanMatch, value TRUE })
An object class is not obsolete if the "obsolete" component is not present, in which case it defaults to FALSE, or is present but is explicitly set to FALSE.
The following search filter finds all non  obsolete object classes: (
item:{ component "obsolete", rule booleanMatch, value FALSE })
The useDefaultValues flag in the ComponentAssertion defaults to TRUE
so the componentFilterMatch rule treats an absent "obsolete" component as being present and set to FALSE.
The following search filter finds only object class definitions where the "obsolete" component has been explicitly set to FALSE, rather than implicitly defaulting to FALSE:
item:{ component "obsolete", useDefaultValues FALSE, rule booleanMatch, value FALSE })
With the useDefaultValues flag set to FALSE, if the "obsolete" component is absent the component reference identifies no component value and the matching rule will return FALSE.
The matching rule can only return TRUE if the component is present and set to FALSE.
The "information.kind" component of the ObjectClassDescription is an ENUMERATED type.
The allComponentsMatch matching rule can be used to match values of an ENUMERATED type.
The following search filter finds object class definitions for auxiliary object classes:
item:{ component "information.kind", rule allComponentsMatch, value auxiliary })
The following search filter finds auxiliary object classes with commonName (cn or 2.5.4.3) as a mandatory attribute:
The following search filter finds auxiliary object classes with commonName as a mandatory or optional attribute:
Extra care is required when matching optional SEQUENCE OF or SET OF components because of the distinction between an absent list of instances and a present, but empty, list of instances.
The following search filter finds object class definitions with less than three names, including object class definitions with a present but empty list of names, but does not find object class definitions with an absent list of names:
item:{ component "name.0", rule integerOrderingMatch, value 3 })
If the "name" component is absent the "name.0" component is also considered to be absent and the ComponentAssertion evaluates to FALSE.
If the "name" component is present, but empty, the "name.0" component is also present and equal to zero, so the ComponentAssertion evaluates to TRUE.
To also find the object class definitions with an absent list of names the following search filter would be used:
Distinguished names embedded in other syntaxes can be matched with a componentFilterMatch.
The uniqueMember attribute type has an attribute syntax described by the ASN.1 type NameAndOptionalUID.
(uniqueMember:componentFilterMatch:  item:{ component "dn", rule distinguishedNameMatch, value "
cn Steven Legg,o Adacel,c AU" })
The DistinguishedName and RelativeDistinguishedName ASN.1 types are also complex ASN.1 types so the component matching rules can be applied to their inner components.
A value of ATTRIBUTE.&Type is constrained by the type component of AttributeTypeAndValue to be of the attribute syntax of the nominated attribute type.
Note: the fourth edition of X.500 extends and renames the AttributeTypeAndValue SEQUENCE type.
The seeAlso attribute has the DistinguishedName syntax.
The following search filter finds seeAlso attribute values containing the RDN, "o Adacel", anywhere in the DN: (
The following search filter finds all seeAlso attribute values with "cn Steven Legg" as the RDN of the named entry (i.e., the "first" RDN in an LDAPDN or the "last" RDN in an X.500 DN):
(seeAlso:componentFilterMatch:  item:{ component " 1", rule rdnMatch, value "cn Steven Legg" })
The following search filter finds all seeAlso attribute values naming entries in the DIT subtree of "o Adacel,c AU": (seeAlso:
The following search filter finds all seeAlso attribute values containing the naming attribute types commonName (cn) and telephoneNumber in the same RDN:
The following search filter would find all seeAlso attribute values containing the attribute types commonName and telephoneNumber, but not necessarily in the same RDN:
:{ item:{ component " .
.type", rule objectIdentifierMatch, value cn }, item:{ component " .
The following search filter finds all seeAlso attribute values containing the word "Adacel" in any organizationalUnitName (ou) attribute value in any AttributeTypeAndValue of any RDN:
(seeAlso:componentFilterMatch:  item:{ component " .
The component reference " .
.value" identifies an open type, in this case an attribute value.
In a particular AttributeTypeAndValue, if the attribute type is not organizationalUnitName then the ComponentAssertion evaluates to FALSE.
Otherwise the substring assertion is evaluated against the attribute value.
Absent component references in ComponentAssertions can be exploited to avoid false positive matches on multi valued attributes.
For example, suppose there is a multi valued attribute named productCodes, defined to have the Integer syntax (1.3.6.1.4.1.1466.115.121.1.27).
An entry whose productCodes attribute contains only the values 1 and 10 will match the above filter.
The first subfilter is satisfied by the value 10 (10 is not less than 3), and the second subfilter is satisfied by the value 1
(1 is less than 8).
The following search filter can be used instead to only match entries that have a productCodes value in the range 3 to 7, because the ComponentFilter is evaluated against each productCodes value in isolation:
An entry whose productCodes attribute contains only the values 1 and 10 will not match the above filter.
The component matching rules described in this document allow for a compact specification of matching capabilities that could otherwise have been defined by a plethora of specific matching rules, i.e., despite their expressiveness and flexibility the component matching rules do not behave in a way uncharacteristic of other matching rules, so the security issues for component matching rules are no different than for any other matching rule.
However, because the component matching rules are applicable to any attribute syntax, support for them in a directory server may allow searching of attributes that were previously unsearchable by virtue of there not being a suitable matching rule.
Such attribute types ought to be properly protected with appropriate access controls.
A generic, interoperable access control mechanism has not yet been developed, however, and implementors should be aware of the interaction of that lack with the increased risk of exposure described above.
The Internet Assigned Numbers Authority (IANA) has updated the LDAP descriptors registry [8] as indicated by the following templates: Subject: Request for LDAP Descriptor Registration Descriptor (short name): componentFilterMatch Object Identifier: 1.2.36.79672281.1.13.2 Person & email address to contact for further information: Steven Legg <steven.legg@adacel.com.au
Request for LDAP Descriptor Registration Descriptor (short name): rdnMatch Object Identifier:
1.2.36.79672281.1.13.3 Person & email address to contact for further information:
Request for LDAP Descriptor Registration Descriptor (short name): presentMatch Object Identifier:
1.2.36.79672281.1.13.5 Person & email address to contact for further information:
Request for LDAP Descriptor Registration Descriptor (short name): allComponentsMatch
1.2.36.79672281.1.13.6 Person & email address to contact for further information:
Request for LDAP Descriptor Registration Descriptor (short name)
: directoryComponentsMatch Object Identifier: 1.2.36.79672281.1.13.7 Person & email address to contact for further information:
The object identifiers have been assigned for use in this specification by Adacel Technologies, under an arc assigned to Adacel by Standards Australia.
