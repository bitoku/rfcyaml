- title: __initial_text__
  contents:
  - '                 Introduction to Accounting Management

    '
- title: Status of this Memo
  contents:
  - "Status of this Memo\n   This memo provides information for the Internet community.\
    \  It does\n   not specify an Internet standard of any kind.  Distribution of\
    \ this\n   memo is unlimited.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (C) The Internet Society (2000).  All Rights Reserved.\n"
- title: Abstract
  contents:
  - "Abstract\n   The field of Accounting Management is concerned with the collection\n\
    \   of resource consumption data for the purposes of capacity and trend\n   analysis,\
    \ cost allocation, auditing, and billing.  This document\n   describes each of\
    \ these problems, and discusses the issues involved\n   in design of modern accounting\
    \ systems.\n   Since accounting applications do not have uniform security and\n\
    \   reliability requirements, it is not possible to devise a single\n   accounting\
    \ protocol and set of security services that will meet all\n   needs.  Thus the\
    \ goal of accounting management is to provide a set of\n   tools that can be used\
    \ to meet the requirements of each application.\n   This document describes the\
    \ currently available tools as well as the\n   state of the art in accounting\
    \ protocol design.  A companion\n   document, RFC 2924, reviews the state of the\
    \ art in accounting\n   attributes and record formats.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1.  Introduction                                      \
    \       2\n       1.1   Requirements language                              3\n\
    \       1.2   Terminology                                        3\n       1.3\
    \   Accounting management architecture                 5\n       1.4   Accounting\
    \ management objectives                   7\n       1.5   Intra-domain and inter-domain\
    \ accounting          10\n       1.6   Accounting record production          \
    \            11\n       1.7   Requirements summary                           \
    \   13\n   2.  Scaling and reliability                                 14\n  \
    \     2.1   Fault resilience                                  14\n       2.2 \
    \  Resource consumption                              23\n       2.3   Data collection\
    \ models                            26\n   3.  Review of Accounting Protocols\
    \                          32\n       3.1 RADIUS                             \
    \                 32\n       3.2 TACACS+                                     \
    \        33\n       3.3 SNMP                                                33\n\
    \   4.  Review of Accounting Data Transfer                      43\n       4.1\
    \ SMTP                                                44\n       4.2 Other protocols\
    \                                     44\n   5.  Summary                     \
    \                            45\n   6. Security Considerations               \
    \                   48\n   7. Acknowledgments                                \
    \          48\n   8. References                                              \
    \ 48\n   9. Authors' Addresses                                       52\n   10.\
    \ Intellectual Property Statement                         53\n   11. Full Copyright\
    \ Statement                                54\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   The field of Accounting Management is concerned with the\
    \ collection\n   of resource consumption data for the purposes of capacity and\
    \ trend\n   analysis, cost allocation, auditing, and billing.  This document\n\
    \   describes each of these problems, and discusses the issues involved\n   in\
    \ design of modern accounting systems.\n   Since accounting applications do not\
    \ have uniform security and\n   reliability requirements, it is not possible to\
    \ devise a single\n   accounting protocol and set of security services that will\
    \ meet all\n   needs.  Thus the goal of accounting management is to provide a\
    \ set of\n   tools that can be used to meet the requirements of each application.\n\
    \   This document describes the currently available tools as well as the\n   state\
    \ of the art in accounting protocol design.  A companion\n   document, RFC 2924,\
    \ reviews the state of the art in accounting\n   attributes and record formats.\n"
- title: 1.1.  Requirements language
  contents:
  - "1.1.  Requirements language\n   In this document, the key words \"MAY\", \"MUST,\
    \ \"MUST NOT\", \"optional\",\n   \"recommended\", \"SHOULD\", and \"SHOULD NOT\"\
    , are to be interpreted as\n   described in [6].\n"
- title: 1.2.  Terminology
  contents:
  - "1.2.  Terminology\n   This document frequently uses the following terms:\n  \
    \ Accounting\n             The collection of resource consumption data for the\n\
    \             purposes of capacity and trend analysis, cost allocation,\n    \
    \         auditing, and billing.  Accounting management requires that\n      \
    \       resource consumption be  measured, rated, assigned, and\n            \
    \ communicated between appropriate parties.\n   Archival accounting\n        \
    \     In archival accounting, the goal is to collect all\n             accounting\
    \ data, to reconstruct missing entries as best as\n             possible in the\
    \ event of data loss, and to archive data for\n             a mandated time period.\
    \  It is \"usual and customary\" for\n             these systems to be engineered\
    \ to be very robust against\n             accounting data loss.  This may include\
    \ provisions for\n             transport layer as well as application layer\n\
    \             acknowledgments, use of non-volatile storage, interim\n        \
    \     accounting capabilities (stored or transmitted over the\n             wire),\
    \ etc.  Legal or financial requirements frequently\n             mandate archival\
    \ accounting practices, and may often\n             dictate that data be kept\
    \ confidential, regardless of\n             whether it is to be used for billing\
    \ purposes or not.\n   Rating    The act of determining the price to be charged\
    \ for use of a\n             resource.\n   Billing   The act of preparing an invoice.\n\
    \   Usage sensitive billing\n             A billing process that depends on usage\
    \ information to\n             prepare an invoice can be said to be usage-sensitive.\
    \  In\n             contrast, a process that is independent of usage\n       \
    \      information is said to be non-usage-sensitive.\n   Auditing  The act of\
    \ verifying the correctness of a procedure.  In\n             order to be able\
    \ to conduct an audit it is necessary to be\n             able to definitively\
    \ determine what procedures were\n             actually carried out so as to be\
    \ able to compare this to\n             the recommended process.  Accomplishing\
    \ this may require\n             security services such as authentication and\
    \ integrity\n             protection.\n   Cost Allocation\n             The act\
    \ of allocating costs between entities.  Note that\n             cost allocation\
    \ and rating are fundamentally different\n             processes.  In cost allocation\
    \ the objective is typically\n             to allocate a known cost among several\
    \ entities.  In rating\n             the objective is to determine the amount\
    \ to be charged for\n             use of a resource.  In cost allocation, the\
    \ cost per unit\n             of resource may need to be determined; in rating,\
    \ this is\n             typically a given.\n   Interim accounting\n          \
    \   Interim accounting provides a snapshot of usage during a\n             user's\
    \ session.  This may be useful in the event of a\n             device reboot or\
    \ other network problem that prevents the\n             reception or generation\
    \ of a session summary packet or\n             session record.  Interim accounting\
    \ records can always be\n             summarized without the loss of information.\
    \  Note that\n             interim accounting records may be stored internally\
    \ on the\n             device (such as in non-volatile storage) so as to survive\
    \ a\n             reboot and thus may not always be transmitted over the\n   \
    \          wire.\n   Session record\n             A session record represents\
    \ a summary of the resource\n             consumption of a user over the entire\
    \ session.  Accounting\n             gateways creating the session record may\
    \ do so by\n             processing interim accounting events or accounting events\n\
    \             from several devices serving the same user.\n   Accounting Protocol\n\
    \             A protocol used to convey data for accounting purposes.\n   Intra-domain\
    \ accounting\n             Intra-domain accounting involves the collection of\n\
    \             information on resource usage within an administrative\n       \
    \      domain, for use within that domain.  In intra-domain\n             accounting,\
    \ accounting packets and session records\n             typically do not cross\
    \ administrative boundaries.\n   Inter-domain accounting\n             Inter-domain\
    \ accounting involves the collection of\n             information on resource\
    \ usage within an administrative\n             domain, for use within another\
    \ administrative domain.  In\n             inter-domain accounting, accounting\
    \ packets and session\n             records will typically cross administrative\
    \ boundaries.\n   Real-time accounting\n             Real-time accounting involves\
    \ the processing of information\n             on resource usage within a defined\
    \ time window.  Time\n             constraints are typically imposed in order\
    \ to limit\n             financial risk.\n   Accounting server\n             The\
    \ accounting server receives accounting data from devices\n             and translates\
    \ it into session records.  The accounting\n             server may also take\
    \ responsibility for the routing of\n             session records to interested\
    \ parties.\n"
- title: 1.3.  Accounting management architecture
  contents:
  - "1.3.  Accounting management architecture\n   The accounting management architecture\
    \ involves interactions between\n   network devices, accounting servers, and billing\
    \ servers.  The\n   network device collects resource consumption data in the form\
    \ of\n   accounting metrics.  This information is then transferred to an\n   accounting\
    \ server.  Typically this is accomplished via an accounting\n   protocol, although\
    \ it is also possible for devices to generate their\n   own session records.\n\
    \   The accounting server then processes the accounting data received\n   from\
    \ the network device.  This processing may include summarization\n   of interim\
    \ accounting information, elimination of duplicate data, or\n   generation of\
    \ session records.\n   The processed accounting data is then submitted to a billing\
    \ server,\n   which typically handles rating and invoice generation, but may also\n\
    \   carry out auditing, cost allocation, trend analysis or capacity\n   planning\
    \ functions.  Session records may be batched and compressed by\n   the accounting\
    \ server prior to submission to the billing server in\n   order to reduce the\
    \ volume of accounting data and the bandwidth\n   required to accomplish the transfer.\n\
    \   One of the functions of the accounting server is to distinguish\n   between\
    \ inter and intra-domain accounting events and to route them\n   appropriately.\
    \  For session records containing a Network Access\n   Identifier (NAI), described\
    \ in [8], the distinction can be made by\n   examining the domain portion of the\
    \ NAI.  If the domain portion is\n   absent or corresponds to the local domain,\
    \ then the session record is\n   treated as an intra-domain accounting event.\
    \  Otherwise, it is\n   treated as an inter-domain accounting event.\n   Intra-domain\
    \ accounting events are typically routed to the local\n   billing server, while\
    \ inter-domain accounting events will be routed\n   to accounting servers operating\
    \ within other administrative domains.\n   While it is not required that session\
    \ record formats used in inter\n   and intra-domain accounting be the same, this\
    \ is desirable, since it\n   eliminates translations that would otherwise be required.\n\
    \   Where a proxy forwarder is employed, domain-based access controls may\n  \
    \ be employed by the proxy forwarder, rather than by the devices\n   themselves.\
    \  The network device will typically speak an accounting\n   protocol to the proxy\
    \ forwarder, which may then either convert the\n   accounting packets to session\
    \ records, or forward the accounting\n   packets to another domain.  In either\
    \ case, domain separation is\n   typically achieved by having the proxy forwarder\
    \ sort the session\n   records or accounting messages by destination.\n   Where\
    \ the accounting proxy is not trusted, it may be difficult to\n   verify that\
    \ the proxy is issuing correct session records based on the\n   accounting messages\
    \ it receives, since the original accounting\n   messages typically are not forwarded\
    \ along with the session records.\n   Therefore where trust is an issue, the proxy\
    \ typically forwards the\n   accounting packets themselves.  Assuming that the\
    \ accounting protocol\n   supports data object security, this allows the end-points\
    \ to verify\n   that the proxy has not modified the data in transit or snooped\
    \ on the\n   packet contents.\n   The diagram below illustrates the accounting\
    \ management architecture:\n        +------------+\n        |            |\n \
    \       |   Network  |\n        |   Device   |\n        |            |\n     \
    \   +------------+\n              |\n   Accounting |\n   Protocol   |\n      \
    \        |\n              V\n        +------------+                          \
    \     +------------+\n        |            |                               | \
    \           |\n        |   Org B    |  Inter-domain session records |  Org A \
    \    |\n        |   Acctg.   |<----------------------------->|  Acctg.    |\n\
    \        |Proxy/Server|   or accounting protocol      |  Server    |\n       \
    \ |            |                               |            |\n        +------------+\
    \                               +------------+\n              |              \
    \                              |\n              |                            \
    \                |\n   Transfer   | Intra-domain                             \
    \  |\n   Protocol   | Session records                            |\n         \
    \     |                                            |\n              V        \
    \                                    V\n        +------------+               \
    \                +------------+\n        |            |                      \
    \         |            |\n        |  Org B     |                             \
    \  |  Org A     |\n        |  Billing   |                               |  Billing\
    \   |\n        |  Server    |                               |  Server    |\n \
    \       |            |                               |            |\n        +------------+\
    \                               +------------+\n"
- title: 1.4.  Accounting management objectives
  contents:
  - "1.4.  Accounting management objectives\n   Accounting Management involves the\
    \ collection of resource consumption\n   data for the purposes of capacity and\
    \ trend analysis, cost\n   allocation, auditing, billing.  Each of these tasks\
    \ has different\n   requirements.\n"
- title: 1.4.1.  Trend analysis and capacity planning
  contents:
  - "1.4.1.  Trend analysis and capacity planning\n   In trend analysis and capacity\
    \ planning, the goal is typically a\n   forecast of future usage.  Since such\
    \ forecasts are inherently\n   imperfect, high reliability is typically not required,\
    \ and moderate\n   packet loss can be tolerated.  Where it is possible to use\n\
    \   statistical sampling techniques to reduce data collection\n   requirements\
    \ while still providing the forecast with the desired\n   statistical accuracy,\
    \ it may be possible to tolerate high packet loss\n   as long as bias is not introduced.\n\
    \   The security requirements for trend analysis and capacity planning\n   depend\
    \ on the circumstances of data collection and the sensitivity of\n   the data.\
    \  Additional security services may be required when data is\n   being transferred\
    \ between administrative domains.  For example, when\n   information is being\
    \ collected and analyzed within the same\n   administrative domain, integrity\
    \ protection and authentication may be\n   used in order to guard against collection\
    \ of invalid data.  In\n   inter-domain applications confidentiality may be desirable\
    \ to guard\n   against snooping by third parties.\n"
- title: 1.4.2.  Billing
  contents:
  - "1.4.2.  Billing\n   When accounting data is used for billing purposes, the requirements\n\
    \   depend on whether the billing process is usage-sensitive or not.\n"
- title: 1.4.2.1.  Non-usage sensitive billing
  contents:
  - "1.4.2.1.  Non-usage sensitive billing\n   Since by definition, non-usage-sensitive\
    \ billing does not require\n   usage information, in theory all accounting data\
    \ can be lost without\n   affecting the billing process.  Of course this would\
    \ also affect\n   other tasks such as trend analysis or auditing, so that such\n\
    \   wholesale data loss would still be unacceptable.\n"
- title: 1.4.2.2.  Usage-sensitive billing
  contents:
  - "1.4.2.2.  Usage-sensitive billing\n   Since usage-sensitive billing processes\
    \ depend on usage information,\n   packet loss may translate directly to revenue\
    \ loss.  As a result, the\n   billing process may need to conform to financial\
    \ reporting and legal\n   requirements, and therefore an archival accounting approach\
    \ may be\n   needed.\n   Usage-sensitive systems may also require low processing\
    \ delay.  Today\n   credit risk is commonly managed by computerized fraud detection\n\
    \   systems that are designed to detect unusual activity.  While\n   efficiency\
    \ concerns might otherwise dictate batched transmission of\n   accounting data,\
    \ where there is a risk of fraud, financial exposure\n   increases with processing\
    \ delay.  Thus it may be advisable to\n   transmit each event individually to\
    \ minimize batch size, or even to\n   utilize quality of service techniques to\
    \ minimize queuing delays.  In\n   addition, it may be necessary for authorization\
    \ to be dependent on\n   ability to pay.\n   Whether these techniques will be\
    \ useful varies by application since\n   the degree of financial exposure is application-dependent.\
    \  For\n   dial-up Internet access from a local provider, charges are typically\n\
    \   low and therefore the risk of loss is small.  However, in the case of\n  \
    \ dial-up roaming or voice over IP, time-based charges may be\n   substantial\
    \ and therefore the risk of fraud is larger.  In such\n   situations it is highly\
    \ desirable to quickly detect unusual account\n   activity, and it may be desirable\
    \ for authorization to depend on\n   ability to pay.  In situations where valuable\
    \ resources can be\n   reserved, or where charges can be high, very large bills\
    \ may be rung\n   up quickly, and processing may need to be completed within a\
    \ defined\n   time window in order to limit exposure.\n   Since in usage-sensitive\
    \ systems, accounting data translates into\n   revenue, the security and reliability\
    \ requirements are greater.  Due\n   to financial and legal requirements such\
    \ systems need to be able to\n   survive an audit.  Thus security services such\
    \ as authentication,\n   integrity and replay protection are frequently required\
    \ and\n   confidentiality and data object integrity may also be desirable.\n \
    \  Application-layer acknowledgments are also often required so as to\n   guard\
    \ against accounting server failures.\n"
- title: 1.4.3.  Auditing
  contents:
  - "1.4.3.  Auditing\n   With enterprise networking expenditures on the rise, interest\
    \ in\n   auditing is increasing.  Auditing, which is the act of verifying the\n\
    \   correctness of a procedure, commonly relies on accounting data.\n   Auditing\
    \ tasks include verifying the correctness of an invoice\n   submitted by a service\
    \ provider, or verifying conformance to usage\n   policy, service level agreements,\
    \ or security guidelines.\n   To permit a credible audit, the auditing data collection\
    \ process must\n   be at least as reliable as the accounting process being used\
    \ by the\n   entity that is being audited.  Similarly, security policies for the\n\
    \   audit should be at least as stringent as those used in preparation of\n  \
    \ the original invoice.  Due to financial and legal requirements,\n   archival\
    \ accounting practices are frequently required in this\n   application.\n   Where\
    \ auditing procedures are used to verify conformance to usage or\n   security\
    \ policies, security services may be desired.  This typically\n   will include\
    \ authentication, integrity and replay protection as well\n   as confidentiality\
    \ and data object integrity.  In order to permit\n   response to security incidents\
    \ in progress, auditing applications\n   frequently are built to operate with\
    \ low processing delay.\n"
- title: 1.4.4.  Cost allocation
  contents:
  - "1.4.4.  Cost allocation\n   The application of cost allocation and billback methods\
    \ by enterprise\n   customers is not yet widespread.  However, with the convergence\
    \ of\n   telephony and data communications, there is increasing interest in\n\
    \   applying cost allocation and billback procedures to networking costs,\n  \
    \ as is now commonly practiced with telecommunications costs.\n   Cost allocation\
    \ models, including traditional costing mechanisms\n   described in [21]-[23]\
    \ and activity-based costing techniques\n   described in [24] are typically based\
    \ on detailed analysis of usage\n   data, and as a result they are almost always\
    \ usage-sensitive.\n   Whether these techniques are applied to allocation of costs\
    \ between\n   partners in a venture or to allocation of costs between departments\n\
    \   in a single firm, cost allocation models often have profound\n   behavioral\
    \ and financial impacts.  As a result, systems developed for\n   this purposes\
    \ are typically as concerned with reliable data\n   collection and security as\
    \ are billing applications.  Due to\n   financial and legal requirements, archival\
    \ accounting practices are\n   frequently required in this application.\n"
- title: 1.5.  Intra-domain and inter-domain accounting
  contents:
  - "1.5.  Intra-domain and inter-domain accounting\n   Much of the initial work on\
    \ accounting management has focused on\n   intra-domain accounting applications.\
    \  However, with the increasing\n   deployment of services such as dial-up roaming,\
    \ Internet fax, Voice\n   and Video over IP and QoS, applications requiring inter-domain\n\
    \   accounting are becoming increasingly common.\n   Inter-domain accounting differs\
    \ from intra-domain accounting in\n   several important ways.  Intra-domain accounting\
    \ involves the\n   collection of information on resource consumption within an\n\
    \   administrative domain, for use within that domain.  In intra-domain\n   accounting,\
    \ accounting packets and session records typically do not\n   cross administrative\
    \ boundaries.  As a result, intra-domain\n   accounting applications typically\
    \ experience low packet loss and\n   involve transfer of data between trusted\
    \ entities.\n   In contrast, inter-domain accounting involves the collection of\n\
    \   information on resource consumption within an administrative domain,\n   for\
    \ use within another administrative domain.  In inter-domain\n   accounting, accounting\
    \ packets and session records will typically\n   cross administrative boundaries.\
    \  As a result, inter-domain\n   accounting applications may experience substantial\
    \ packet loss.  In\n   addition, the entities involved in the transfers cannot\
    \ be assumed to\n   trust each other.\n   Since inter-domain accounting applications\
    \ involve transfers of\n   accounting data between domains, additional security\
    \ measures may be\n   desirable.  In addition to authentication, replay and integrity\n\
    \   protection, it may be desirable to deploy security services such as\n   confidentiality\
    \ and data object integrity.  In inter-domain\n   accounting each involved party\
    \ also typically requires a copy of each\n   accounting event for invoice generation\
    \ and auditing.\n"
- title: 1.6.  Accounting record production
  contents:
  - "1.6.  Accounting record production\n   Typically, a single accounting record\
    \ is produced per session, or in\n   some cases, a set of interim records which\
    \ can be summarized in a\n   single record for billing purposes.  However, to\
    \ support deployment\n   of services such as wireless access or complex billing\
    \ regimes, a\n   more sophisticated approach is required.\n   It is necessary\
    \ to generate several accounting records from a single\n   session when pricing\
    \ changes during a session.  For instance, the\n   price of a service can be higher\
    \ during peak hours than off-peak.\n   For a session continuing from one tariff\
    \ period to another, it\n   becomes necessary for a device to report \"packets\
    \ sent\" during both\n   periods.\n   Time is not the only factor requiring this\
    \ approach.  For instance,\n   in mobile access networks the user may roam from\
    \ one place to another\n   while still being connected in the same session.  If\
    \ roaming causes a\n   change in the tariffs, it is necessary to account for resource\n\
    \   consumed in the first and second areas.  Another example is where\n   modifications\
    \ are allowed to an ongoing session.  For example, it is\n   possible that a session\
    \ could be re-authorized with improved QoS.\n   This would require production\
    \ of accounting records at both QoS\n   levels.\n   These examples could be addressed\
    \ by using vectors or multi-\n   dimensional arrays to represent resource consumption\
    \ within a single\n   session record.  For example, the vector or array could\
    \ describe the\n   resource consumption for each combination of factors, e.g.\
    \ one data\n   item could be the number of packets during peak hour in the area\
    \ of\n   the home operator.  However, such an approach seems complicated and\n\
    \   inflexible and as a result, most current systems produce a set of\n   records\
    \ from one session.  A session identifier needs to be present\n   in the records\
    \ to permit accounting systems to tie the records\n   together.\n   In most cases,\
    \ the network device will determine when multiple\n   session records are needed,\
    \ as the local device is aware of factors\n   affecting local tariffs, such as\
    \ QoS changes and roaming.  However,\n   future systems are being designed that\
    \ enable the home domain to\n   control the generation of accounting records.\
    \  This is of importance\n   in inter-domain accounting or when network devices\
    \ do not have tariff\n   information.  The centralized control of accounting record\
    \ production\n   can be realized, for instance, by having authorization servers\n\
    \   require re-authorization at certain times and requiring the\n   production\
    \ of accounting records upon each re-authorization.\n   In conclusion, in some\
    \ cases it is necessary to produce multiple\n   accounting records from a single\
    \ session.  It must be possible to do\n   this without requiring the user to start\
    \ a new session or to re-\n   authenticate.  The production of multiple records\
    \ can be controlled\n   either by the network device or by the AAA server.  The\
    \ requirements\n   for timeliness, security and reliability in multiple record\
    \ sessions\n   are the same as for single-record sessions.\n"
- title: 1.7.  Requirements summary
  contents:
  - "1.7.  Requirements summary\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                 |                     |                   |\n   |  Usage\
    \          |   Intra-domain      | Inter-domain      |\n   |                 |\
    \                     |                   |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                 | Robustness vs.      | Robustness vs.    |\n   |      \
    \           | packet loss         | packet loss       |\n   |  Capacity      \
    \ |                     |                   |\n   |  Planning       | Integrity,\
    \          | Integrity,        |\n   |                 | authentication,     |\
    \ authentication,   |\n   |                 | replay protection   | replay prot.\
    \      |\n   |                 | [confidentiality]   | confidentiality   |\n \
    \  |                 |                     | [data object sec.]|\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |  Non-usage      | Integrity,          | Integrity,        |\n   |  Sensitive\
    \      | authentication,     | authentication,   |\n   |  Billing        | replay\
    \ protection   | replay protection |\n   |                 | [confidentiality]\
    \   | confidentiality   |\n   |                 |                     | [data\
    \ object sec.]|\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                 | Archival            | Archival          |\n   |  Usage\
    \          | accounting          | accounting        |\n   |  Sensitive      |\
    \ Integrity,          | Integrity,        |\n   |  Billing,       | authentication,\
    \     | authentication,   |\n   |  Cost           | replay protection   | replay\
    \ prot.      |\n   |  Allocation &   | [confidentiality]   | confidentiality \
    \  |\n   |  Auditing       | [Bounds on          | [data object sec.]|\n   | \
    \                |  processing delay]  | [Bounds on        |\n   |           \
    \      |                     | processing delay] |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                 | Archival            | Archival          |\n   |  Time\
    \           | accounting          | accounting        |\n   |  Sensitive     \
    \ | Integrity,          | Integrity,        |\n   |  Billing,       | authentication,\
    \     | authentication,   |\n   |  fraud          | replay protection   | replay\
    \ prot.      |\n   |  detection,     | [confidentiality]   | confidentiality \
    \  |\n   |  roaming        |                     | [Data object      |\n   | \
    \                | Bounds on           |  security and     |\n   |           \
    \      |  processing delay   |  receipt support] |\n   |                 |   \
    \                  | Bounds on         |\n   |                 |             \
    \        |  processing delay |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   Key\n   [] = optional\n"
- title: 2.  Scaling and reliability
  contents:
  - "2.  Scaling and reliability\n   With the continuing growth of the Internet, it\
    \ is important that\n   accounting management systems be scalable and reliable.\
    \  This section\n   discusses the resources consumed by accounting management\
    \ systems as\n   well as the scalability and reliability properties exhibited\
    \ by\n   various data collection and transport models.\n"
- title: 2.1.  Fault resilience
  contents:
  - "2.1.  Fault resilience\n   As noted earlier, in applications such as usage-sensitive\
    \ billing,\n   cost allocation and auditing, an archival approach to accounting\
    \ is\n   frequently mandated, due to financial and legal requirements.  Since\n\
    \   in such situations loss of accounting data can translate to revenue\n   loss,\
    \ there is incentive to engineer a high degree of fault\n   resilience.  Faults\
    \ which may be encountered include:\n      Packet loss\n      Accounting server\
    \ failures\n      Network failures\n      Device reboots\n   To date, much of\
    \ the debate on accounting reliability has focused on\n   resilience against packet\
    \ loss and the differences between UDP, SCTP\n   and TCP-based transport.  However,\
    \ it should be understood that\n   resilience against packet loss is only  one\
    \ aspect of meeting\n   archival accounting requirements.\n   As noted in [18],\
    \ \"once the cable is cut you don't need more\n   retransmissions, you need a\
    \ *lot* more voltage.\"  Thus, the choice of\n   transport has no impact on resilience\
    \ against faults such as network\n   partition, accounting server failures or\
    \ device reboots.  What does\n   provide resilience against these faults is non-volatile\
    \ storage.\n   The importance of non-volatile storage in design of reliable\n\
    \   accounting systems cannot be over-emphasized.  Without non-volatile\n   storage,\
    \ event-driven systems will lose data once the transmission\n   timeout has been\
    \ exceeded, and batching designs will experience data\n   loss once the internal\
    \ memory used for accounting data storage has\n   been exceeded.  Via use of non-volatile\
    \ storage, and internally\n   stored interim records, most of these data losses\
    \ can be avoided.\n   It may even be argued that non-volatile storage is more\
    \ important to\n   accounting reliability than network connectivity, since for\
    \ many\n   years reliable accounting systems were implemented based solely on\n\
    \   physical storage, without any network connectivity.  For example,\n   phone\
    \ usage data used to be stored on paper, film, or magnetic media\n   and carried\
    \ from the place of collection to a central location for\n   bill processing.\n"
- title: 2.1.1.  Interim accounting
  contents:
  - "2.1.1.  Interim accounting\n   Interim accounting provides protection against\
    \ loss of session\n   summary data by providing checkpoint information that can\
    \ be used to\n   reconstruct the session record in the event that the session\
    \ summary\n   information is lost.  This technique may be applied to any data\n\
    \   collection model (i.e. event-driven or polling) and is supported in\n   both\
    \ RADIUS [25] and in TACACS+.\n   While interim accounting can provide resilience\
    \ against packet loss,\n   server failures, short-duration network failures, or\
    \ device reboot,\n   its applicability is limited.  Transmission of interim accounting\n\
    \   data over the wire should not be thought of as a mainstream\n   reliability\
    \ improvement technique since it increases use of network\n   bandwidth in normal\
    \ operation, while providing benefits only in the\n   event of a fault.\n   Since\
    \ most packet loss on the Internet is due to congestion, sending\n   interim accounting\
    \ data over the wire can make the problem worse by\n   increasing bandwidth usage.\
    \  Therefore on-the-wire interim accounting\n   is best restricted to high-value\
    \ accounting data such as information\n   on long-lived sessions.  To protect\
    \ against loss of data on such\n   sessions, the interim reporting interval is\
    \ typically set several\n   standard deviations larger than the average session\
    \ duration.  This\n   ensures that most sessions will not result in generation\
    \ of interim\n   accounting events and the additional bandwidth consumed by interim\n\
    \   accounting will be limited.  However, as the interim accounting\n   interval\
    \ decreases toward the average session time, the additional\n   bandwidth consumed\
    \ by interim accounting increases markedly, and as a\n   result, the interval\
    \ must be set with caution.\n   Where non-volatile storage is unavailable, interim\
    \ accounting can\n   also result in excessive consumption of memory that could\
    \ be better\n   allocated to storage of session data.  As a result, implementors\n\
    \   should be careful to ensure that new interim accounting data\n   overwrites\
    \ previous data rather than accumulating additional interim\n   records in memory,\
    \ thereby worsening the buffer exhaustion problem.\n   Given the increasing popularity\
    \ of non-volatile storage for use in\n   consumer devices such as digital cameras,\
    \ such devices are rapidly\n   declining in price.  This makes it increasingly\
    \ feasible for network\n   devices to include built-in support for non-volatile\
    \ storage.  This\n   can be accomplished, for example, by support for compact\
    \ PCMCIA\n   cards.\n   Where non-volatile storage is available, this can be used\
    \ to store\n   interim accounting data.  Stored interim events are then replaced\
    \ by\n   updated interim events or by session data when the session completes.\n\
    \   The session data can itself be erased once the data has been\n   transmitted\
    \ and acknowledged at the application layer.  This approach\n   avoids interim\
    \ data being transmitted over the wire except in the\n   case of a device reboot.\
    \  When a device reboots, internally stored\n   interim records are transferred\
    \ to the accounting server.\n"
- title: 2.1.2.  Multiple record sessions
  contents:
  - "2.1.2.  Multiple record sessions\n   Generation of multiple accounting records\
    \ within a session can\n   introduce scalability problems that cannot be controlled\
    \ using the\n   techniques available in interim accounting.\n   For example, in\
    \ the case of interim records kept in non-volatile\n   storage, it is possible\
    \ to overwrite previous interim records with\n   the most recent one or summarize\
    \ them to a session record.  Where\n   interim updates are sent over the wire,\
    \ it is possible to control\n   bandwidth usage by adjusting the interim accounting\
    \ interval.\n   These measures are not applicable where multiple session records\
    \ are\n   produced from a single session, since these records cannot be\n   summarized\
    \ or overwritten without loss of information.  As a result,\n   multiple record\
    \ production can result in increased consumption of\n   bandwidth and memory.\
    \  Implementors should be careful to ensure that\n   worst-case multiple record\
    \ processing requirements do not exceed the\n   capabilities of their systems.\n\
    \   As an example, a tariff change at a particular time of day could, if\n   implemented\
    \ carelessly, create a sudden peak in the consumption of\n   memory and bandwidth\
    \ as the records need to be stored and/or\n   transported.  Rather than attempting\
    \ to send all of the records at\n   once, it may be desirable to keep them in\
    \ non-volatile storage and\n   send all of the related records together in a batch\
    \ when the session\n   completes.  It may also be desirable to shape the accounting\
    \ traffic\n   flow so as to reduce the peak bandwidth consumption.  This can be\n\
    \   accomplished by introduction of a randomized delay interval.  If the\n   home\
    \ domain can also control the generation of multiple accounting\n   records, the\
    \ estimation of the worst-case processing requirements can\n   be very difficult.\n"
- title: 2.1.3.  Packet loss
  contents:
  - "2.1.3.  Packet loss\n   As packet loss is a fact of life on the Internet, accounting\n\
    \   protocols dealing with session data need to be resilient against\n   packet\
    \ loss.  This is particularly important in inter-domain\n   accounting, where\
    \ packets often pass through Network Access Points\n   (NAPs) where packet loss\
    \ may be substantial.  Resilience against\n   packet loss can be accomplished\
    \ via implementation of a retry\n   mechanism on top of UDP, or use of TCP [7]\
    \ or SCTP [26].  On-the-wire\n   interim accounting provides only limited benefits\
    \ in mitigating the\n   effects of packet loss.\n   UDP-based transport is frequently\
    \ used in accounting applications.\n   However, this is not appropriate in all\
    \ cases.  Where accounting data\n   will not fit within a single UDP packet without\
    \ fragmentation, use of\n   TCP or SCTP transport may be preferred to use of multiple\
    \ round-trips\n   in UDP.  As noted in [47] and [49], this may be an issue in\
    \ the\n   retrieval of large tables.\n   In addition, in cases where congestion\
    \ is likely, such as in inter-\n   domain accounting, TCP or SCTP congestion control\
    \ and round-trip time\n   estimation will be very useful, optimizing throughput.\
    \  In\n   applications which require maintenance of session state, such as\n \
    \  simultaneous usage control, TCP and application-layer keep alive\n   packets\
    \ or SCTP with its built-in heartbeat capabilities provide a\n   mechanism for\
    \ keeping track of session state.\n   When implementing UDP retransmission, there\
    \ are a number of issues to\n   keep in mind:\n      Data model\n      Retry behavior\n\
    \      Congestion control\n      Timeout behavior\n   Accounting reliability can\
    \ be influenced by how the data is modeled.\n   For example, it is almost always\
    \ preferable to use cumulative\n   variables rather than expressing accounting\
    \ data in terms of a change\n   from a previous data item.  With cumulative data,\
    \ the current state\n   can be recovered by a successful retrieval, even after\
    \ many packets\n   have been lost.  However, if the data is transmitted as a change\
    \ then\n   the state will not be recovered until the next cumulative update is\n\
    \   sent.  Thus, such implementations are much more vulnerable to packet\n   loss,\
    \ and should be avoided wherever possible.\n   In designing a UDP retry mechanism,\
    \ it is important that the retry\n   timers relate to the round-trip time, so\
    \ that retransmissions will\n   not typically occur within the period in which\
    \ acknowledgments may be\n   expected to arrive.  Accounting bandwidth may be\
    \ significant in some\n   circumstances, so that the added traffic due to unnecessary\n\
    \   retransmissions may increase congestion levels.\n   Congestion control in\
    \ accounting data transfer is a somewhat\n   controversial issue.  Since accounting\
    \ traffic is often considered\n   mission-critical, it has been argued that congestion\
    \ control is not a\n   requirement; better to let other less-critical traffic\
    \ back off in\n   response to congestion.  Moreover, without non-volatile storage,\n\
    \   congestive back-off in accounting applications can result in data\n   loss\
    \ due to buffer exhaustion.\n   However, it can also be argued that in modern\
    \ accounting\n   implementations, it is possible to implement congestion control\
    \ while\n   improving throughput and maintaining high reliability.  In\n   circumstances\
    \ where there is sustained packet loss, there simply is\n   not sufficient capacity\
    \ to maintain existing transmission rates.\n   Thus, aggregate throughput will\
    \ actually improve if congestive back-\n   off is implemented.  This is due to\
    \ elimination of retransmissions\n   and the ability to utilize techniques such\
    \ as RED to desynchronize\n   flows.  In addition, with QoS mechanisms such as\
    \ differentiated\n   services, it is possible to mark accounting packets for preferential\n\
    \   handling so as to provide for lower packet loss if desired.  Thus\n   considerable\
    \ leeway is available to the network administrator in\n   controlling the treatment\
    \ of accounting packets and hard coding\n   inelastic behavior is unnecessary.\
    \  Typically, systems implementing\n   non-volatile storage allow for backlogged\
    \ accounting data to be\n   placed in non-volatile storage pending transmission,\
    \ so that buffer\n   exhaustion resulting from congestive back-off need not be\
    \ a concern.\n   Since UDP is not really a transport protocol, UDP-based accounting\n\
    \   protocols such as [4] often do not prescribe timeout behavior.  Thus\n   implementations\
    \ may exhibit widely different behavior.  For example,\n   one implementation\
    \ may drop accounting data after three constant\n   duration retries to the same\
    \ server, while another may implement\n   exponential back-off to a given server,\
    \ then switch to another\n   server, up to a total timeout interval of twelve\
    \ hours, while storing\n   the untransmitted data on non-volatile storage.  The\
    \ practical\n   difference between these approaches is substantial; the former\n\
    \   approach will not satisfy archival accounting requirements while the\n   latter\
    \ may.  More predictable behavior can be achieved via use of\n   SCTP or TCP transport.\n"
- title: 2.1.4.  Accounting server failover
  contents:
  - "2.1.4.  Accounting server failover\n   In the event of a failure of the primary\
    \ accounting server, it is\n   desirable for the device to failover to a secondary\
    \ server.\n   Providing one or more secondary servers can remove much of the risk\n\
    \   of accounting server failure, and as a result use of secondary\n   servers\
    \ has become commonplace.\n   For protocols based on TCP, it is possible for the\
    \ device to maintain\n   connections to both the primary and secondary accounting\
    \ servers,\n   using the secondary connection after expiration of a timer on the\n\
    \   primary connection.  Alternatively,  it is possible to open a\n   connection\
    \ to the secondary accounting server after a timeout or loss\n   of the primary\
    \ connection, or on  expiration of a timer.  Thus,\n   accounting protocols based\
    \ on TCP are capable of responding more\n   rapidly to connectivity failures than\
    \ TCP timeouts would otherwise\n   allow, at the expense of an increased risk\
    \ of duplicates.\n   With SCTP, it is possible to control transport layer timeout\n\
    \   behavior, and therefore it is not necessary for the accounting\n   application\
    \ to maintain its own timers.  SCTP also enables\n   multiplexing of multiple\
    \ connections within a single transport\n   connection, all maintaining the same\
    \ congestion control state,\n   avoiding the \"head of line blocking\" issues\
    \ that can occur with TCP.\n   However, since SCTP is not widely available, use\
    \ of this transport\n   can impose an additional implementation burden on the\
    \ designer.\n   For protocols using UDP, transmission to the secondary  server\
    \ can\n   occur after a number of retries or timer expiration.  For\n   compatibility\
    \ with congestion avoidance, it is advisable to\n   incorporate techniques such\
    \ as round-trip-time estimation, slow start\n   and congestive back-off.  Thus\
    \ the accounting protocol designer\n   utilizing UDP often is lead to re-inventing\
    \ techniques already\n   existing in TCP and SCTP.  As a result, the use of raw\
    \ UDP transport\n   in accounting applications is not recommended.\n   With any\
    \ transport it is possible for the primary and secondary\n   accounting servers\
    \ to receive duplicate packets, so support for\n   duplicate elimination is required.\
    \  Since accounting server failures\n   can result in data accumulation on accounting\
    \ clients, use of non-\n   volatile storage can ensure against data loss due to\
    \ transmission\n   timeouts or buffer exhaustion.  On-the-wire interim accounting\n\
    \   provides only limited benefits in mitigating the effects of\n   accounting\
    \ server failures.\n"
- title: 2.1.5.  Application layer acknowledgments
  contents:
  - "2.1.5.  Application layer acknowledgments\n   It is possible for the accounting\
    \ server to experience partial\n   failures.  For example, a failure in the database\
    \ back end could\n   leave the accounting retrieval process or thread operable\
    \ while the\n   process or thread responsible for storing the data is non-functional.\n\
    \   Similarly, it is possible for the accounting application to run out\n   of\
    \ disk space, making it unable to continue storing incoming session\n   records.\n\
    \   In such cases it is desirable to distinguish between transport layer\n   acknowledgment\
    \ and application layer acknowledgment.  Even though\n   both acknowledgments\
    \ may be sent within the same packet (such as a\n   TCP segment carrying an application\
    \ layer acknowledgment along with a\n   piggy-backed ACK), the semantics are different.\
    \  A transport-layer\n   acknowledgment means \"the transport layer has taken\
    \ responsibility\n   for delivering the data to the application\", while an application-\n\
    \   layer acknowledgment means \"the application has taken responsibility\n  \
    \ for the data\".\n   A common misconception is that use of TCP transport guarantees\
    \ that\n   data is delivered to the application.  However, as noted in RFC 793\n\
    \   [7]:\n    An acknowledgment by TCP does not guarantee that the data has been\n\
    \    delivered to the end user, but only that the receiving TCP has taken\n  \
    \  the responsibility to do so.\n   Therefore, if receiving TCP fails after sending\
    \ the ACK, the\n   application may not receive the data.  Similarly, if the application\n\
    \   fails prior to committing the data to stable storage, the data may be\n  \
    \ lost.  In order for a sending application to be sure that the data it\n   sent\
    \ was received by the receiving application, either a graceful\n   close of the\
    \ TCP connection or an application-layer acknowledgment is\n   required. In order\
    \ to protect against data loss, it is necessary that\n   the application-layer\
    \ acknowledgment imply that the data has been\n   written to stable storage or\
    \ suitably processed so as to guard\n   against loss.\n   In the case of partial\
    \ failures, it is possible for the transport\n   layer to acknowledge receipt\
    \ via transport layer acknowledgment,\n   without having delivered the data to\
    \ the application.  Similarly, the\n   application may not complete the tasks\
    \ necessary to take\n   responsibility for the data.\n   For example, an accounting\
    \ server may receive data from the transport\n   layer but be incapable of storing\
    \ it data due to a back end database\n   problem or disk fault.  In this case\
    \ it should not send an\n   application layer acknowledgment, even though a a\
    \ transport layer\n   acknowledgment is appropriate.  Rather, an application layer\
    \ error\n   message should be sent indicating the source of the problem, such\
    \ as\n   \"Backend store unavailable\".\n   Thus application-layer acknowledgment\
    \ capability requires not only\n   the ability to acknowledge when the application\
    \ has taken\n   responsibility for the data, but also the ability to indicate\
    \ when\n   the application has not taken responsibility for the data, and why.\n"
- title: 2.1.6.  Network failures
  contents:
  - "2.1.6.  Network failures\n   Network failures may result in partial or complete\
    \ loss of\n   connectivity for the accounting client.  In the event of partial\n\
    \   connectivity loss, it may not be possible to reach the primary\n   accounting\
    \ server, in which case switch over to the secondary\n   accounting server is\
    \ necessary.  In the event of a network partition,\n   it may be necessary to\
    \ store accounting events in device memory or\n   non-volatile storage until connectivity\
    \ can be re-established.\n   As with accounting server failures, on-the-wire interim\
    \ accounting\n   provides only limited benefits in mitigating the effects of network\n\
    \   failures.\n"
- title: 2.1.7.  Device reboots
  contents:
  - "2.1.7.  Device reboots\n   In the event of a device reboot, it is desirable to\
    \ minimize the loss\n   of data on sessions in progress.  Such losses may be significant\
    \ even\n   if the devices themselves are very reliable, due to long-lived\n  \
    \ sessions, which can comprise a significant fraction of total resource\n   consumption.\
    \  To guard against loss of these high-value sessions,\n   interim accounting\
    \ data is typically transmitted over the wire.  When\n   interim accounting in-place\
    \ is combined with non-volatile storage it\n   becomes possible to guard against\
    \ data loss in much shorter sessions.\n   This is possible since interim accounting\
    \ data need only be stored in\n   non-volatile memory until the session completes,\
    \ at which time the\n   interim data may be replaced by the session record.  As\
    \ a result,\n   interim accounting data need never be sent over the wire, and\
    \ it is\n   possible to decrease the interim interval so as to provide a very\n\
    \   high degree of protection against data loss.\n"
- title: 2.1.8.  Accounting proxies
  contents:
  - "2.1.8.  Accounting proxies\n   In order to maintain high reliability, it is important\
    \ that\n   accounting proxies pass through transport and application layer\n \
    \  acknowledgments and do not store and forward accounting packets.\n   This enables\
    \ the end-systems to control re-transmission behavior and\n   utilize techniques\
    \ such as non-volatile storage and secondary servers\n   to improve resilience.\n\
    \   Accounting proxies sending a transport or application layer ACK to\n   the\
    \ device without receiving one from the accounting server fool the\n   device\
    \ into thinking that the accounting request had been accepted by\n   the accounting\
    \ server when this is not the case.  As a result, the\n   device can delete the\
    \ accounting packet from non-volatile storage\n   before it has been accepted\
    \ by the accounting server.  The leaves the\n   accounting proxy responsible for\
    \ delivering accounting packets.  If\n   the accounting proxy involves moving\
    \ parts (e.g. a disk drive) while\n   the devices do not, overall system reliability\
    \ can be reduced.\n   Store and forward accounting proxies only add value in situations\n\
    \   where the accounting subsystem is unreliable.  For example, where\n   devices\
    \ do not implement non-volatile storage and the accounting\n   protocol lacks\
    \ transport and application layer reliability, locating\n   the accounting proxy\
    \ (with its stable storage) close to the device\n   can reduce the risk of data\
    \ loss.\n   However, such systems are inherently unreliable so that they are only\n\
    \   appropriate for use in capacity planning or non-usage sensitive\n   billing\
    \ applications.  If archival accounting reliability is desired,\n   it is necessary\
    \ to engineer a reliable accounting system from the\n   start using the techniques\
    \ described in this document, rather than\n   attempting to patch an inherently\
    \ unreliable system by adding store\n   and forward accounting proxies.\n"
- title: 2.1.9.  Fault resilience summary
  contents:
  - "2.1.9.  Fault resilience summary\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                 |                                       |\n   |  Fault \
    \         |   Counter-measures                    |\n   |                 |  \
    \                                     |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                 |                                       |\n   |  Packet\
    \         |   Retransmission based on RTT         |\n   |  loss           |  \
    \ Congestion control                  |\n   |                 |   Well-defined\
    \ timeout behavior       |\n   |                 |   Duplicate elimination   \
    \            |\n   |                 |   Interim accounting*                 |\n\
    \   |                 |   Non-volatile storage                |\n   |        \
    \         |   Cumulative variables                |\n   |                 |  \
    \                                     |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                 |                                       |\n   |  Accounting\
    \     |   Primary-secondary servers           |\n   |  server & net   |   Duplicate\
    \ elimination               |\n   |  failures       |   Interim accounting*  \
    \               |\n   |                 |   Application layer ACK & error msgs.\
    \ |\n   |                 |   Non-volatile storage                |\n   |    \
    \             |                                       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                 |                                       |\n   |  Device\
    \         |   Interim accounting*                 |\n   |  reboots        |  \
    \ Non-volatile storage                |\n   |                 |              \
    \                         |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   Key\n   * = limited usefulness without non-volatile storage\n   Note: Accounting\
    \ proxies are not a reliability\n   enhancement mechanism.\n"
- title: 2.2.  Resource consumption
  contents:
  - "2.2.  Resource consumption\n   In the process of growing to meet the needs of\
    \ providers and\n   customers, accounting management systems consume a variety\
    \ of\n   resources, including:\n      Network bandwidth\n      Memory\n      Non-volatile\
    \ storage\n      State on the accounting management system\n      CPU on the management\
    \ system and managed devices\n   In order to understand the limits to scaling,\
    \ we examine each of\n   these resources in turn.\n"
- title: 2.2.1.  Network bandwidth
  contents:
  - "2.2.1.  Network bandwidth\n   Accounting management systems consume network bandwidth\
    \ in\n   transferring accounting data.  The network bandwidth consumed is\n  \
    \ proportional to the amount of data transferred, as well as required\n   network\
    \ overhead.  Since accounting data for a given event may be 100\n   octets or\
    \ less, if each event is transferred individually, overhead\n   can represent\
    \ a considerable proportion of total bandwidth\n   consumption.  As a result,\
    \ it is often desirable to transfer\n   accounting data in batches, enabling network\
    \ overhead to be spread\n   over a larger payload, and enabling efficient use\
    \ of compression.  As\n   noted in [48], compression can be enabled in the accounting\
    \ protocol,\n   or can be done at the IP layer as described in [5].\n"
- title: 2.2.2.  Memory
  contents:
  - "2.2.2.  Memory\n   In accounting systems without non-volatile storage, accounting\
    \ data\n   must be stored in volatile memory during the period between when it\n\
    \   is generated and when it is transferred.  The resulting memory\n   consumption\
    \ will depend on retry and retransmission algorithms.\n   Since systems designed\
    \ for high reliability will typically wish to\n   retry for long periods, or may\
    \ store interim accounting data, the\n   resulting memory consumption can be considerable.\
    \  As a result, if\n   non-volatile storage is unavailable, it may be desirable\
    \ to compress\n   accounting data awaiting transmission.\n   As noted earlier,\
    \ implementors of interim accounting should take care\n   to ensure against excessive\
    \ memory usage by overwriting older interim\n   accounting data with newer data\
    \ for the same session rather than\n   accumulating interim data in the buffer.\n"
- title: 2.2.3.  Non-volatile storage
  contents:
  - "2.2.3.  Non-volatile storage\n   Since accounting data stored in memory will\
    \ typically be lost in the\n   event of a device reboot or a timeout, it may be\
    \ desirable to provide\n   non-volatile storage for undelivered accounting data.\
    \  With the costs\n   of non-volatile storage declining rapidly, network devices\
    \ will be\n   increasingly capable of incorporating non-volatile storage support\n\
    \   over the next few years.\n   Non-volatile storage may be used to store interim\
    \ or session records.\n   As with memory utilization, interim accounting overwrite\
    \ is desirable\n   so as to prevent excessive storage consumption.  Note that\
    \ the use of\n   ASCII data representation enables use of highly efficient text\n\
    \   compression algorithms that can minimize storage requirements.  Such\n   compression\
    \ algorithms are only typically applied to session records\n   so as to enable\
    \ implementation of interim data overwrite.\n"
- title: 2.2.4.  State on the accounting management system
  contents:
  - "2.2.4.  State on the accounting management system\n   In order to keep track\
    \ of received accounting data, accounting\n   management systems may need to keep\
    \ state on managed devices or\n   concurrent sessions.  Since the number of devices\
    \ is typically much\n   smaller than the number of concurrent sessions, it is\
    \ desirable to\n   keep only per-device state if possible.\n"
- title: 2.2.5.  CPU requirements
  contents:
  - "2.2.5.  CPU requirements\n   CPU consumption of the managed and managing nodes\
    \ will be\n   proportional to the complexity of the required accounting processing.\n\
    \   Operations such as ASN.1 encoding and decoding,\n   compression/decompression,\
    \ and encryption/decryption can consume\n   considerable resources, both on accounting\
    \ clients and servers.\n   The effect of these operations on accounting system\
    \ reliability\n   should not be under-estimated, particularly in the case of devices\n\
    \   with moderate CPU resources.  In the event that devices are over-\n   taxed\
    \ by accounting tasks, it is likely that overall device\n   reliability will suffer.\n"
- title: 2.2.6.  Efficiency measures
  contents:
  - "2.2.6.  Efficiency measures\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                 |                                       |\n   |  Resource\
    \       |   Efficiency measures                 |\n   |                 |    \
    \                                   |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                 |                                       |\n   |  Network\
    \        |   Batching                            |\n   |  Bandwidth      |   Compression\
    \                         |\n   |                 |                          \
    \             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                 |                                       |\n   |  Memory\
    \         |   Compression                         |\n   |                 |  \
    \ Interim accounting overwrite        |\n   |                 |              \
    \                         |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                 |                                       |\n   |  Non-volatile\
    \   |   Compression                         |\n   |  Storage        |   Interim\
    \ accounting overwrite        |\n   |                 |                      \
    \                 |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                 |                                       |\n   |  System\
    \         |   Per-device state                    |\n   |  state          |  \
    \                                     |\n   |                 |              \
    \                         |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                 |                                       |\n   |  CPU   \
    \         |   Hardware assisted                   |\n   |  requirements   |  \
    \   compression/encryption            |\n   |                 |              \
    \                         |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n"
- title: 2.3. Data collection models
  contents:
  - "2.3. Data collection models\n   Several data collection models are currently\
    \ in use today for the\n   purposes of accounting data collection.  These include:\n\
    \      Polling model\n      Event-driven model without batching\n      Event-driven\
    \ model with batching\n      Event-driven polling model\n"
- title: 2.3.1.  Polling model
  contents:
  - "2.3.1.  Polling model\n   In the polling model, an accounting manager will poll\
    \ devices for\n   accounting information at regular intervals.  In order to ensure\n\
    \   against loss of data, the polling interval will need to be shorter\n   than\
    \ the maximum time that accounting data can be stored on the\n   polled device.\
    \  For devices without non-volatile stage, this is\n   typically determined by\
    \ available memory; for devices with non-\n   volatile storage the maximum polling\
    \ interval is determined by the\n   size of non-volatile storage.\n   The polling\
    \ model results in an accumulation of data within\n   individual devices, and\
    \ as a result, data is typically transferred to\n   the accounting manager in\
    \ a batch, resulting in an efficient transfer\n   process.  In terms of Accounting\
    \ Manager state, polling systems scale\n   with the number of managed devices,\
    \ and system bandwidth usage scales\n   with the amount of data transferred.\n\
    \   Without non-volatile storage, the polling model results in loss of\n   accounting\
    \ data due to device reboots, but not due to packet loss or\n   network failures\
    \ of sufficiently short duration to be handled within\n   available memory.  This\
    \ is because the Accounting Manager will\n   continue to poll until the data is\
    \ received.  In situations where\n   operational difficulties are encountered,\
    \ the volume of accounting\n   data will frequently increase so as to make data\
    \ loss more likely.\n   However, in this case the polling model will detect the\
    \ problem since\n   attempts to reach the managed devices will fail.\n   The polling\
    \ model scales poorly for implementation of shared use or\n   roaming services,\
    \ including wireless data, Internet telephony, QoS\n   provisioning or Internet\
    \ access.  This is because in order to\n   retrieve accounting data for users\
    \ within a given domain, the\n   Accounting Management station would need to periodically\
    \ poll all\n   devices in all domains, most of which would not contain any relevant\n\
    \   data.  There are also issues with processing delay, since use of a\n   polling\
    \ interval also implies an average processing delay of half the\n   polling interval.\
    \  This may be too high for accounting data that\n   requires low processing delay.\
    \  Thus the event-driven polling or the\n   pure event-driven approach is more\
    \ appropriate for usage sensitive\n   billing applications such as shared use\
    \ or roaming implementations.\n   Per-device state is typical of polling-based\
    \ network management\n   systems, which often also carry out accounting management\
    \ functions,\n   since network management systems need to  keep track of the state\
    \ of\n   network devices for operational purposes.  These systems offer\n   average\
    \ processing delays equal to half the polling interval.\n"
- title: 2.3.2.  Event-driven model without batching
  contents:
  - "2.3.2.  Event-driven model without batching\n   In the event-driven model, a\
    \ device will contact the accounting\n   server or manager when it is ready to\
    \ transfer accounting data.  Most\n   event-driven accounting systems, such as\
    \ those based on RADIUS\n   accounting, described in [4], transfer only one accounting\
    \ event per\n   packet, which is inefficient.\n   Without non-volatile storage,\
    \ a pure event-driven model typically\n   stores accounting events that have not\
    \ yet been delivered only until\n   the timeout interval expires.  As a result\
    \ this model has the\n   smallest memory requirements.  Once the timeout interval\
    \ has expired,\n   the accounting event is lost, even if the device has sufficient\n\
    \   buffer space to continue to store it.  As a result, the event-driven\n   model\
    \ is the least reliable, since accounting data loss will occur\n   due to device\
    \ reboots, sustained packet loss, or network failures of\n   duration greater\
    \ than the timeout interval.  In event-driven\n   protocols without a \"keep alive\"\
    \ message, accounting servers cannot\n   assume a device failure should no messages\
    \ arrive for an extended\n   period.  Thus, event-driven accounting systems are\
    \ typically not\n   useful in monitoring of device health.\n   The event-driven\
    \ model is frequently used in shared use networks and\n   roaming, since this\
    \ model sends data to the recipient domains without\n   requiring them to poll\
    \ a large number of devices, most of which have\n   no relevant data.  Since the\
    \ event-driven model typically does not\n   support batching, it permits accounting\
    \ records to be sent with low\n   processing delay, enabling application of fraud\
    \ prevention\n   techniques.  However, because roaming accounting events are\n\
    \   frequently of high value, the poor reliability of this model is an\n   issue.\
    \  As a result, the event-driven polling model may be more\n   appropriate.\n\
    \   Per-session state is typical of event-driven systems without\n   batching.\
    \  As a result, the event-driven approach scales poorly.\n   However, event-driven\
    \ systems offer the lowest processing delay since\n   events are processed immediately\
    \ and there is no possibility of an\n   event requiring low processing delay being\
    \ caught behind a batch\n   transfer.\n"
- title: 2.3.3.  Event-driven model with batching
  contents:
  - "2.3.3.  Event-driven model with batching\n   In the event-driven model with batching,\
    \ a device will contact the\n   accounting server or manager when it is ready\
    \ to transfer accounting\n   data.  The device can contact the server when a batch\
    \ of a given size\n   has been gathered, when data of a certain type is available\
    \ or after\n   a minimum time period has elapsed.  Such systems can transfer more\n\
    \   than one accounting event per packet and are thus more efficient.\n   An event-driven\
    \ system with batching will store accounting events\n   that have not yet been\
    \ delivered up to the limits of memory.  As a\n   result, accounting data loss\
    \ will occur due to device reboots, but\n   not due to packet loss or network\
    \ failures of sufficiently short\n   duration to be handled within available memory.\
    \  Note that while\n   transfer efficiency will increase with batch size, without\
    \ non-\n   volatile storage, the potential data loss from a device reboot will\n\
    \   also increase.\n   Where event-driven systems with batching have a keep-alive\
    \ interval\n   and run over reliable transport, the accounting server can assume\n\
    \   that a failure has occurred if no messages are received within the\n   keep-alive\
    \ interval.  Thus, such implementations can be useful in\n   monitoring of device\
    \ health.  When used for this purpose the average\n   time delay prior to failure\
    \ detection is one half the keep-alive\n   interval.\n   Through implementation\
    \ of a scheduling algorithm, event-driven\n   systems with batching can deliver\
    \ appropriate service to accounting\n   events that require low processing delay.\
    \  For example, high-value\n   inter-domain accounting events could be sent immediately,\
    \ thus\n   enabling use of fraud-prevention techniques, while all other events\n\
    \   would be batched.  However, there is a possibility that an event\n   requiring\
    \ low processing delay will be caught behind a batch transfer\n   in progress.\
    \  Thus the maximum processing delay is proportional to\n   the maximum batch\
    \ size divided by the link speed.\n   Event-driven systems with batching scale\
    \ with the number of active\n   devices.  As a result this approach scales better\
    \ than the pure\n   event-driven approach, or even the polling approach, and is\n\
    \   equivalent in terms of scaling to the event-driven polling approach.\n   However,\
    \ the event-driven batching approach has lower processing\n   delay than the event-driven\
    \ polling approach, since delivery of\n   accounting data requires fewer round-trips\
    \ and events requiring low\n   processing delay can be accommodated if a scheduling\
    \ algorithm is\n   employed.\n"
- title: 2.3.4.  Event-driven polling model
  contents:
  - "2.3.4.  Event-driven polling model\n   In the event-driven polling model an accounting\
    \ manager will poll the\n   device for accounting data only when it receives an\
    \ event.  The\n   accounting client can generate an event when a batch of a given\
    \ size\n   has been gathered, when data of a certain type is available or after\n\
    \   a minimum time period has elapsed.  Note that while transfer\n   efficiency\
    \ will increase with batch size, without non-volatile\n   storage, the potential\
    \ data loss from a device reboot will also\n   increase.\n   Without non-volatile\
    \ storage, an event-driven polling model will lose\n   data due to device reboots,\
    \ but not due to packet loss, or network\n   partitions of short-duration.  Unless\
    \ a minimum delivery interval is\n   set, event-driven polling systems are not\
    \ useful in monitoring of\n   device health.\n   The event-driven polling model\
    \ can be suitable for use in roaming\n   since it permits accounting data to be\
    \ sent to the roaming partners\n   with low processing delay.  At the same time\
    \ non-roaming accounting\n   can be handled via more efficient polling techniques,\
    \ thereby\n   providing the best of both worlds.\n   Where batching can be implemented,\
    \ the state required in event-driven\n   polling can be reduced to scale with\
    \ the number of active devices.\n   If portions of the network vary widely in\
    \ usage, then this state may\n   actually be less than that of the polling approach.\
    \  Note that\n   processing delay in this approach is higher than in event-driven\n\
    \   accounting with batching since at least two round-trips are required\n   to\
    \ deliver data: one for the event notification, and one for the\n   resulting\
    \ poll.\n"
- title: 2.3.5.  Data collection summary
  contents:
  - "2.3.5.  Data collection summary\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                 |                   |                   |\n   |     Model\
    \       |       Pros        |      Cons         |\n   |                 |    \
    \               |                   |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |  Polling        | Per-device state  | Not robust        |\n   |        \
    \         | Robust against    |  against device   |\n   |                 |  \
    \ packet loss     |  reboot, server   |\n   |                 | Batch transfers\
    \   |  or network       |\n   |                 |                   |  failures*\
    \        |\n   |                 |                   | Polling interval  |\n \
    \  |                 |                   |  determined by    |\n   |         \
    \        |                   |  storage limit    |\n   |                 |   \
    \                | High processing   |\n   |                 |               \
    \    |  delay            |\n   |                 |                   | Unsuitable\
    \ for    |\n   |                 |                   |  use in roaming   |\n \
    \  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   |  Event-driven,\
    \  | Lowest processing | Not robust        |\n   |   no batching   |  delay  \
    \          |  against packet   |\n   |                 | Suitable for      | \
    \ loss, device     |\n   |                 |  use in roaming   |  reboot, or \
    \      |\n   |                 |                   |  network          |\n   |\
    \                 |                   |  failures*        |\n   |            \
    \     |                   | Low efficiency    |\n   |                 |      \
    \             | Per-session state |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |  Event-driven,  | Single round-trip | Not robust        |\n   |   with batching\
    \ |  latency          |  against device   |\n   |      and        | Batch transfers\
    \   |  reboot, network  |\n   |   scheduling    | Suitable for      |  failures*\
    \        |\n   |                 |  use in roaming   |                   |\n \
    \  |                 | Per active device |                   |\n   |         \
    \        |  state            |                   |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |  Event-driven   | Batch transfers   | Not robust        |\n   |   polling\
    \       | Suitable for      |  against device   |\n   |                 |  use\
    \ in roaming   |  reboot, network  |\n   |                 | Per active device\
    \ |  failures*        |\n   |                 |  state            | Two round-trip\
    \    |\n   |                 |                   |  latency          |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   Key\n   * = addressed by non-volatile storage\n"
- title: 3.  Review of Accounting Protocols
  contents:
  - "3.  Review of Accounting Protocols\n   Accounting systems have been successfully\
    \ implemented using protocols\n   such as RADIUS, TACACS+, and SNMP.  This section\
    \ describes the\n   characteristics of each of these protocols.\n"
- title: 3.1.  RADIUS
  contents:
  - "3.1.  RADIUS\n   RADIUS accounting, described in [4], was developed as an add-on\
    \ to\n   the RADIUS authentication protocol, described in [3].  As a result,\n\
    \   RADIUS accounting shares the event-driven approach of RADIUS\n   authentication,\
    \ without support for batching or polling.  As a\n   result, RADIUS accounting\
    \ scales with the number of accounting events\n   instead of the number of devices,\
    \ and accounting transfers are\n   inefficient.\n   Since RADIUS accounting is\
    \ based on UDP and timeout and retry\n   parameters are not specified, implementations\
    \ vary widely in their\n   approach to reliability, with some implementations\
    \ retrying until\n   delivery or buffer exhaustion, and others losing accounting\
    \ data\n   after a few retries.  Since RADIUS accounting does not provide for\n\
    \   application-layer acknowledgments or error messages, a RADIUS\n   Accounting-Response\
    \ is equivalent to a transport-layer acknowledgment\n   and provides no protection\
    \ against application layer malfunctions.\n   Due to the lack of reliability,\
    \ it is not possible to do simultaneous\n   usage control based on RADIUS accounting\
    \ alone.  Typically another\n   device data source is required, such as polling\
    \ of a session MIB or a\n   command-line session over telnet.\n   RADIUS accounting\
    \ implementations are vulnerable to packet loss as\n   well as application layer\
    \ failures, network failures and device\n   reboots.  These deficiencies are magnified\
    \ in inter-domain accounting\n   as is required in roaming ([1],[2]).  On the\
    \ other hand, the event-\n   driven approach of RADIUS accounting is useful where\
    \ low processing\n   delay is required, such as credit risk management or fraud\
    \ detection.\n   While RADIUS accounting does provide hop-by-hop authentication\
    \ and\n   integrity protection, and IPSEC can be employed to provide hop-by-hop\n\
    \   confidentiality, data object security is not supported, and thus\n   systems\
    \ based on RADIUS accounting are not capable of being deployed\n   with untrusted\
    \ proxies, or in situations requiring auditability, as\n   noted in [2].\n   While\
    \ RADIUS does not support compression, IP compression, described\n   in [5], can\
    \ be employed to provide this.  While in principle\n   extensible with the definition\
    \ of new attributes, RADIUS suffers from\n   the very small standard attribute\
    \ space (256 attributes).\n"
- title: 3.2.  TACACS+
  contents:
  - "3.2.  TACACS+\n   TACACS+ offers an accounting model with start, stop, and interim\n\
    \   update messages.  Since TACACS+ is based on TCP, implementations are\n   typically\
    \ resilient against packet loss and short-lived network\n   partitions, and TACACS+\
    \ scales with the number of devices.  Since\n   TACACS+ runs over TCP, it offers\
    \ support for both transport layer and\n   application layer acknowledgments,\
    \ and is suitable for simultaneous\n   usage control and handling of accounting\
    \ events that require moderate\n   though not the lowest processing delay.\n \
    \  TACACS+ provides for hop-by-hop authentication and integrity\n   protection\
    \ as well as hop-by-hop confidentiality.  Data object\n   security is not supported,\
    \ and therefore systems based on TACACS+\n   accounting are not deployable in\
    \ the presence of untrusted proxies.\n   While TACACS+ does not support compression,\
    \ IP compression, described\n   in [5], can be employed to provide this.\n"
- title: 3.3.  SNMP
  contents:
  - "3.3.  SNMP\n   SNMP, described in [19],[27]-[41], has been widely deployed in\
    \ a wide\n   variety of intra-domain accounting applications, typically using\
    \ the\n   polling data collection model.  Polling allows data to be collected\n\
    \   on multiple accounting events simultaneously, resulting in per-device\n  \
    \ state.  Management applications are able to retry requests when a\n   response\
    \ is not received, providing resiliency against packet loss or\n   even short-lived\
    \ network partitions.  Implementations without non-\n   volatile storage are not\
    \ robust against device reboots or network\n   failures, but when combined with\
    \ non-volatile storage they can be\n   made highly reliable.\n   SMIv1, the data\
    \ modeling language of SNMPv1, has traps to permit\n   trap-directed polling,\
    \ but the traps are not acknowledged, and lost\n   traps can lead to a loss of\
    \ data.  SMIv2, used by SNMPv2c and SNMPv3,\n   has Inform Requests which are\
    \ acknowledged notifications.  This makes\n   it possible to implement a more\
    \ reliable event-driven polling model\n   or event-driven batching model.  However,\
    \ we are not aware of any\n   SNMP-based accounting implementations currently\
    \ built on the use of\n   Informs.\n"
- title: 3.3.1.  Security services
  contents:
  - "3.3.1.  Security services\n   SNMPv1 and SNMPv2c support per-packet authentication\
    \ and read-only\n   and read-write access profiles, via the community string.\
    \  This\n   clear-text password approach provides only trivial authentication,\n\
    \   and no per-packet integrity checks, replay protection or\n   confidentiality.\
    \  View-based access control [40] can be supported\n   using the snmpCommunityMIB,\
    \ defined in [11], and SNMPv1 or SNMPv2c\n   messages.  The updated SNMP architecture\
    \ [rfc2571] supports per-\n   packet hop-by-hop authentication, integrity and\
    \ replay protection,\n   confidentiality and access control.\n   The SNMP User\
    \ Security Model (USM) [38] uses shared secrets, and when\n   the product of the\
    \ number of domains and devices is large, such as in\n   inter-domain accounting\
    \ applications, the number of shared secrets\n   can get out of hand.  The localized\
    \ key capability in USM allows a\n   manager to have one central key, sharing\
    \ it with many SNMP entities\n   in a localized way while preventing the other\
    \ entities from getting\n   at each other's data.  This can assist in cross-domain\
    \ security if\n   deployed properly.\n   SNMPv3 does not support end-to-end data\
    \ object integrity and\n   confidentiality; SNMP proxy entities decrypt and re-encrypt\
    \ the data\n   they forward.  In the presence of an untrusted proxy entity, this\n\
    \   would be inadequate.\n"
- title: 3.3.2.  Application layer acknowledgments
  contents:
  - "3.3.2.  Application layer acknowledgments\n   SNMP uses application-layer acknowledgment\
    \ to indicate that data has\n   been processed.  SNMP Responses to get, get-next,\
    \ or get-bulk\n   requests return the requested data, or an error code indicating\
    \ the\n   nature of the error encountered.\n   A noError SNMP Response to a SET\
    \ command indicates that the requested\n   assignments were made by the application.\
    \  SNMP SETs are atomic; the\n   command either succeeds or fails.  An error-response\
    \ indicates that\n   the entity received the request, but did not succeed in executing\
    \ it.\n   Notifications do not use acknowledgements to indicate that data has\n\
    \   been processed.  The Inform notification returns an acknowledgement\n   of\
    \ receipt, but not of processing, by design.  Since the updated SNMP\n   architecture\
    \ treats entities as peers with varying levels of\n   functionality, it is possible\
    \ to use SETs in either direction between\n   cooperating entities to achieve\
    \ processing acknowledgements.\n   There are eighteen SNMP error codes.  The design\
    \ of SNMP makes\n   service-specific error codes unnecessary and undesirable.\n"
- title: 3.3.3.  Proxy forwarders
  contents:
  - "3.3.3.  Proxy forwarders\n   In the accounting management architecture, proxy\
    \ forwarders play an\n   important role, forwarding intra and inter-domain accounting\
    \ events\n   to the correct destinations.  The proxy forwarder may also play a\n\
    \   role in a polling or event-driven polling architecture.\n   The functionality\
    \ of an SNMP Proxy Forwarder is defined in [39].  For\n   example, the network\
    \ devices may be configured to send notifications\n   for all domains to the Proxy\
    \ Forwarder, and the devices may be\n   configured to allow the Proxy Forwarder\
    \ to access all MIB data.\n   The use of proxy forwarders may reduce the number\
    \ of shared secrets\n   required for inter-domain accounting.  With Proxy Forwarders,\
    \ the\n   domains could share a secret with the Proxy Forwarder, and in turn,\n\
    \   the Proxy Forwarder could share a secret with each of the devices.\n   Thus\
    \ the number of shared secrets will scale with the sum of the\n   number of devices\
    \ and domains rather than the product.\n   The engine of an SNMP Proxy Forwarder\
    \ does not look inside the PDU of\n   the message except to determine to which\
    \ SNMP engine the PDU should\n   be forwarded or which local SNMP application\
    \ should process the PDU.\n   The SNMP Proxy Forwarder does not modify the varbind\
    \ values; it does\n   not modify the varbind list except to translate between\
    \ SNMP\n   versions; and it does not provide any varbind level access control.\n"
- title: 3.3.4.  Domain-based access controls in SNMP
  contents:
  - "3.3.4.  Domain-based access controls in SNMP\n   Domain-based access controls\
    \ are required where multiple\n   administrative domains are involved, such as\
    \ in the shared use\n   networks and roaming associations described in [1].  Since\
    \ the same\n   device may be accessed by multiple organizations, it is often\n\
    \   necessary to control access to accounting data according to the\n   user's\
    \ organization.  This ensures that organizations may be given\n   access to accounting\
    \ data relating to their users, but not to data\n   relating to users of other\
    \ organizations.\n   In order to apply domain-based access controls, in inter-domain\n\
    \   accounting, it is first necessary to identify the data subset that is\n  \
    \ to have its access controlled.  Several conceptual abstractions are\n   used\
    \ for identifying subsets of data in SNMP.  These include engines,\n   contexts,\
    \ and views.  This section describes how this functionality\n   may be applied\
    \ in intra and inter-domain accounting.\n"
- title: 3.3.4.1.  Engines
  contents:
  - "3.3.4.1.  Engines\n   The new SNMP architecture, described in [27], added the\
    \ concept of an\n   SNMP engine to improve mobility support and to identify which\
    \ data\n   source is being referenced.  The engine is the portion of an SNMP\n\
    \   entity that constructs messages, provides security functions, and\n   maps\
    \ to the transport layer.  Traditional agents and traditional\n   managers each\
    \ contain an SNMP engine.  engineID allows an SNMP engine\n   to be uniquely identified,\
    \ independent of the address where it is\n   attached to the network.\n   A securityEngineID\
    \ field in a message identifies the engine which\n   provides access to the security\
    \ credentials contained in the message\n   header.  A contextEngineID field in\
    \ a message identifies the engine\n   which provides access to the data contained\
    \ in the PDU.\n   The SNMPv3 message format explicitly passes both.  In SNMPv1\
    \ and\n   SNMPv2c, the data origin is typically assumed to be the\n   communications\
    \ endpoint (SNMP agent).  SNMPv1 and SNMPv2c messages\n   contain a community\
    \ name; the community name and the source address\n   can be mapped to an engineID\
    \ via the snmpCommunityTable, described in\n   [11].\n"
- title: 3.3.4.2.  Contexts
  contents:
  - "3.3.4.2.  Contexts\n   Contexts are used to identify subsets of objects, within\
    \ the scope of\n   an engine, that are tied to instrumentation.  A contextName\
    \ refers to\n   a particular subset within an engine.\n   Contexts are commonly\
    \ tied to hardware components, to logical\n   entities related to the hardware\
    \ components, or to logical services.\n   For example, contextNames might include\
    \ board5, board7, repeater1,\n   repeater2, etc.\n   An SNMP agent populates a\
    \ read-only dynamic table to tell the manager\n   what contexts it recognizes.\
    \  Typically contexts are defined by the\n   agent rather than the manager since\
    \ if the manager defined them, the\n   agent would not know how to tie the contexts\
    \ to the underlying\n   instrumentation.  It is possible that MIB modules could\
    \ be defined to\n   allow a manager to assign contextNames to a logical subset\
    \ of\n   instrumentation.\n   While each context may support instances of multiple\
    \ MIB modules,\n   each contextName is limited to one instance of a particular\
    \ MIB\n   module.  If multiple instances of a MIB module are required per\n  \
    \ engine, then unique contextNames must be defined (e.g. repeater1,\n   repeater2).\
    \  The default context \"\" is used for engines which only\n   support single\
    \ instances of MIB modules, and it is used for MIB\n   modules where it only makes\
    \ sense to have one instance of that MIB\n   module in an engine and that instance\
    \ must be easy to locate, such as\n   the system MIB or the security MIBs.\n \
    \  SNMPv3 messages contain contextNames which are limited to the scope\n   of\
    \ the contextEngineID in the message.  SNMPv1 and SNMPv2c messages\n   contain\
    \ communities which can be mapped to contextNames within the\n   local engine,\
    \ or can be mapped to contextNames within other engines\n   via the snmpCommunityTable,\
    \ described in [11].\n"
- title: 3.3.4.3.  Views
  contents:
  - "3.3.4.3.  Views\n   Views are defined in the View-based Access Control Model.\
    \  A view is\n   a mask which is used to determine access to the managed objects\
    \ in a\n   particular context.  The view identifies which objects are visible,\n\
    \   by specifying OIDs of the subtrees included and excluded.  There is\n   also\
    \ a mechanism to allow wildcards in the OID specification.\n   For example, it\
    \ is possible to define a view that includes RMON\n   tables, and another view\
    \ that includes only the SNMPv3 security\n   related tables.  Using these views,\
    \ it is possible to allow access to\n   the RMON view for users Joe and Josephine\
    \ (the RMON administrators),\n   and access to the SNMPv3 security tables for\
    \ user Adam (the SNMP\n   security Administrator).\n   Views can be set up with\
    \ wildcards.  For a table that is indexed\n   using IP addresses, Joe can be allowed\
    \ access to all rows in given\n   RMON tables (e.g. the RMON hostTable) that are\
    \ in the subnet\n   10.2.x.x, while Josephine is given access to all rows for\
    \ subnet\n   10.200.x.x.\n   Views filter at the name level (OIDs), not at the\
    \ value level, so\n   defining views based on the values of non-index data is\
    \ not\n   supported.  In this example, were the IP address to have been used\n\
    \   merely as a data item rather than an index, it would not be possible\n   to\
    \ utilize view-based access control to achieve the desired objective\n   (delegation\
    \ of administrative responsibility according to subnet).\n   View-based access\
    \ control is independent of message version.  It can\n   be utilized by entities\
    \ using SNMPv1, SNMPv2c, or SNMPv3 message\n   formats.\n"
- title: 3.3.5.  Inter-domain access-control alternatives
  contents:
  - "3.3.5.  Inter-domain access-control alternatives\n   As the number of network\
    \ devices within the shared use or roaming\n   network grows, the polling model\
    \ of data collection becomes\n   increasingly impractical since most devices will\
    \ not carry data\n   relating to the polling organization.  As a result, shared-use\n\
    \   networks or roaming associations relying on SNMP-based accounting\n   have\
    \ generally collected data for all organizations and then sorted\n   the resulting\
    \ session records for delivery to each organization.\n   While functional, this\
    \ approach will typically result in increased\n   processing delay as the number\
    \ of organizations and data records\n   grows.\n   This issue can be addressed\
    \ in SNMP using the event-driven, event-\n   driven polling or event-driven batching\
    \ approaches.  Traps and\n   Informs permit SNMP-enabled devices to notify domains\
    \ that have\n   accounting data awaiting collection.  SNMP Applications [39] defines\n\
    \   a standard module for managing notifications.\n   To use the event-driven\
    \ approaches, the device must be able to\n   determine when information is available\
    \ for a domain.  Domain-\n   specific data can be differentiated at the SNMP agent\
    \ level through\n   the use of the domain as an index, and the separation of data\
    \ into\n   domain-specific contexts.\n"
- title: 3.3.5.1.  Domain as index
  contents:
  - "3.3.5.1.  Domain as index\n   View-based access control [40] allows multiple\
    \ fine-grained views of\n   an SNMP MIB to be assigned to specific groups of users,\
    \ such that\n   access rights to the included data elements depend on the identity\
    \ of\n   the user making the request.\n   For example, all users of bigco.com\
    \ which are allowed access to the\n   device would be defined in the User-based\
    \ security MIB module (or\n   other security model MIB module).  For simplicity\
    \ in administering\n   access control, the users can be grouped using a vacmGroupName,\
    \ e.g.\n   bigco.  A view of a subset of the data objects in the MIB can be\n\
    \   defined in the vacmViewFamilyTreeTable.  A vacmAccessTable pairs\n   groups\
    \ and views.  For messages received from users in the bigco\n   group, access\
    \ would only be provided to the data permitted to be\n   viewed by bigco users,\
    \ as defined in the view family tree.  This\n   requires that each domain accessing\
    \ the data be given one or more\n   separate vacmGroupNames, an appropriate ViewTable\
    \ be defined, and the\n   vacmAccessTable be configured for each group.\n   Views\
    \ filter at the name (OID) level, not at the data (value) level.\n   When using\
    \ views to filter by domain it is necessary to use the\n   domain as an index.\
    \  Standard view-based access control is not\n   designed to filter based on the\
    \ values on non-indexed fields.\n   For example, a table of session data could\
    \ be indexed by record\n   number and domain, allowing a view to be defined that\
    \ could restrict\n   access to bigco data to the administrators of the bigco domain.\n\
    \   An advantage of using domains as an index is that this technique can\n   be\
    \ used with SNMPv1 and SNMPv2c agents as well as with SNMPv3 agents.\n   A disadvantage\
    \ is that the MIB modules must be specifically designed\n   for this purpose.\
    \  Since existing MIB modules rarely use the domain\n   as an index, domain separation\
    \ cannot be enabled within legacy MIB\n   modules using this technique.\n   SNMP\
    \ does support a RowPointer convention that could be used to\n   define a new\
    \ table, indexed by domain, which holds tuples between the\n   domain and existing\
    \ rows of data.  This would introduce issues of\n   synchronization between tables.\n"
- title: 3.3.5.2.  Contexts
  contents:
  - "3.3.5.2.  Contexts\n   ContextNames can be used to differentiate multiple instances\
    \ of a MIB\n   module within an engine.\n   Individual domains, such as bigco.com,\
    \ could be mapped to logical\n   contexts, such as a bigco context.  The agent\
    \ would need to create\n   and recognize new contexts and to know which instrumentation\
    \ is\n   associated with the logical context.  The agent needs to collect\n  \
    \ accounting data by domain and make the data accessible via distinct\n   contexts,\
    \ so that access control can be applied to the context to\n   prevent disclosure\
    \ of sensitive information to the wrong domain.  The\n   VACM access control views\
    \ are applied relative to the context, so an\n   operation can be permitted or\
    \ denied a user based on the context\n   which contains the data.\n   Domain separation\
    \ is handled by using contextName to differentiate\n   multiple virtual tables.\
    \  For example, if accounting data has been\n   collected on users with the bigco.com\
    \ and smallco.com domains, then a\n   separate virtual instance of the accounting\
    \ session record table\n   would exist for each domain, and each domain would\
    \ have a\n   corresponding contextName.  When a get-bulk request is made with\
    \ a\n   contextName of bigco, then data from the virtual table in the bigco\n\
    \   context, i.e.  corresponding to the bigco.com domain, would be\n   returned.\n\
    \   There are a number of design approaches to creating new contexts and\n   associating\
    \ the contexts with appropriate instrumentation, most\n   notably a sub-agent\
    \ approach and a manager-configured MIB approach.\n   AgentX [51], which standardizes\
    \ a registration protocol between sub-\n   agents and master agents to simplify\
    \ SNMP agent implementation,\n   allows for the creation and recognition of new\
    \ contextNames when a\n   subagent registers to provide support for a particular\
    \ MIB subtree\n   range.  The sub-agent knows how to support a particular\n  \
    \ functionality, e.g.  instrumentation exposed via a range of MIB\n   objects.\
    \  Based on values detected in the data, such as\n   source=bigco.com, the sub-agent\
    \ could determine that a new domain\n   needed to be tracked and create the appropriate\
    \ context for the\n   collection of the data, plus the appropriate access control\
    \ entries.\n   The determination could be table-driven, using MIB configuration.\n\
    \   A manager-driven approach could use a MIB module to predefine\n   contextNames\
    \ corresponding to the domains of interest, and to\n   indicate which objects\
    \ should be collected, how to differentiate to\n   which domain the data should\
    \ be applied based on a specified\n   condition, and what access control rules\
    \ apply to the context.\n   Either technique could associate existing MIB modules\
    \ to domain-\n   specific contexts, so domain separation can be applied to MIB\
    \ modules\n   not specifically designed with domain separation in mind.  Legacy\n\
    \   agents would not be designed to do this, so they would need to be\n   updated\
    \ to support inter-domain separation and VACM access control.\n   The use of contextNames\
    \ for inter-domain separation represents new\n   territory, so careful consideration\
    \ would be needed in designing the\n   MIB modules and applications to provide\
    \ domain to context and context\n   to instrumentation mappings, and to ensure\
    \ that security is not\n   weakened.\n"
- title: 3.3.6.  Outstanding issues
  contents:
  - "3.3.6.  Outstanding issues\n   There are issues that arise when using SNMP for\
    \ transfer of bulk\n   data, including issues of latency, network overhead, and\
    \ table\n   retrieval, as discussed in [49].\n   In accounting applications, management\
    \ stations often must retrieve\n   large tables.  Latency can be high, even with\
    \ the get-bulk operation,\n   because the response must fit into the largest supported\
    \ packet size,\n   requiring multiple round-trips.  Transfers may be serialized\
    \ and the\n   resulting latency will be a combination of multiple round-trip times,\n\
    \   possible timeout and re-transmission delays and processing overhead,\n   which\
    \ may result in unacceptable performance.  Since data may change\n   during the\
    \ course of multiple retrievals, it can be difficult to get\n   a consistent snapshot.\n\
    \   For bulk transfers, SNMP network overhead can be high due to the lack\n  \
    \ of compression, inefficiency of BER encoding, the  transmission of\n   redundant\
    \ OID prefixes, and the \"get-bulk overshoot problem\".  In\n   bulk transfer\
    \ of a table, the OIDs transferred are redundant: all OID\n   prefixes up to the\
    \ column number are identical, as are the instance\n   identifier postfixes of\
    \ all entries of a single table row.  Thus it\n   may be possible to reduce this\
    \ redundancy by compressing the OIDs, or\n   by not transferring an OID with each\
    \ variable.\n   The \"get-bulk overshoot problem\", described in reference [50],\
    \ occurs\n   when using the get-bulk PDU.  The problem is that the manager\n \
    \  typically does not know the number of rows in the table.  As a\n   result,\
    \ it must either request too many rows, retrieving unneeded\n   data, or too few,\
    \ resulting in the need for multiple get-bulk\n   requests.  Note that the \"\
    get-bulk overshoot\" problem may be\n   preventable on the agent side.  Reference\
    \ [41] states that an agent\n   can terminate the get-bulk because of \"local\
    \ constraints\" (see items\n   1 and 3 on pages 15/16 of [41]).  This could be\
    \ interpreted to mean\n   that it is possible to stop at the end of a table.\n"
- title: 3.3.6.1.  Ongoing research
  contents:
  - "3.3.6.1.  Ongoing research\n   To address issues of latency and efficiency, the\
    \ Network Management\n   Research Group (NMRG) was formed within the Internet\
    \ Research Task\n   Force (IRTF).  Since the NMRG work is research and is not\
    \ on the\n   standards track, it should be understood that the NMRG proposals\
    \ may\n   never be standardized, or may change substantially during the\n   standardization\
    \ process.  As a result, these proposals represent\n   works in progress and are\
    \ not readily available for use.\n   The proposals under discussion in the IRTF\
    \ Network Management\n   Research Group (NMRG) are described in [46].  These include\
    \ an SNMP-\n   over-TCP transport mapping, described in [47]; SNMP payload\n \
    \  compression, described in [48]; and the addition of a \"get subtree\"\n   PDU\
    \ or the subtree retrieval MIB [50].\n   The SNMP-over-TCP transport mapping may\
    \ result in substantial latency\n   reductions in table retrieval.  The latency\
    \ reduction of an SNMP-\n   over-TCP transport mapping will likely manifest itself\
    \ primarily in\n   the polling, event-driven polling and event-driven batching\
    \ modes.\n   Payload compression methods include compression of the IP packet,\
    \ as\n   described in [5] or compression of the SNMP payload, described in\n \
    \  [48].\n   Proposed improvements to table retrieval include a subtree retrieval\n\
    \   MIB and the addition of a get-subtree PDU.  The subtree retrieval MIB\n  \
    \ [50] requires no changes to the SNMP protocol or SNMP protocol\n   engine, so\
    \ it can be implemented and deployed more easily than a\n   change to the protocol.\
    \  The addition of a get-subtree PDU implies\n   changes to the protocol and to\
    \ the engines of all SNMP entities which\n   would support it.  Since it may be\
    \ possible to address the \"get-bulk\n   overshoot problem\" without changes to\
    \ the SNMP protocol, the\n   necessity of this modification is controversial.\n\
    \   Reference [49] also discusses file-based storage of SNMP data, and\n   use\
    \ of an FTP MIB, to enable storage of SNMP data in non-volatile\n   storage, and\
    \ subsequent bulk transfer via FTP.  This approach would\n   require implementation\
    \ of additional MIB modules as well as FTP, and\n   requires separate security\
    \ mechanisms such as IPSEC to provide\n   authentication, replay, integrity protection\
    \ and confidentiality for\n   the data in transit.  The file-based transfer approach\
    \ has an\n   important benefit - compatibility with non-volatile storage.\n  \
    \ Issues of legacy support exist with the NMRG proposals.  Devices\n   which do\
    \ not implement the new functionality would need to be\n   accommodated.  This\
    \ is especially problematic for proxy forwarders,\n   which may need to act as\
    \ translators between new and legacy entities.\n   In these situations, the overhead\
    \ of translation may offset the\n   benefits of the new technologies.\n"
- title: 3.3.6.2.  On-going security extension research
  contents:
  - "3.3.6.2.  On-going security extension research\n   In order to simplify key management\
    \ and enable use of certificate-\n   based security in SNMPv3, a Kerberos Security\
    \ Model (KSM) for SNMPv3\n   has been proposed in [44].  This memo is not on the\
    \ standards track,\n   and therefore is not yet readily available for use.\n \
    \  Use of Kerberos with SNMPv3 requires storage of a key on the KDC for\n   each\
    \ device and domain, while dynamically generating a session key\n   for conversations\
    \ between domains and devices.  In terms of stored\n   keys, the KSM approach\
    \ scales with the sum of devices and domains; in\n   terms of dynamic session\
    \ keys, it scales as the product of domains\n   and devices.\n   As Kerberos is\
    \ extended to allow initial authentication via public\n   key, as described in\
    \ [42], and cross-realm authentication, as\n   described in [43], the KSM inherits\
    \ these capabilities.  As a result,\n   this approach may have potential to reduce\
    \ or even eliminate the\n   shared secret management problem.  However, it should\
    \ also be noted\n   that certificate-based authentication can strain the limits\
    \ of UDP\n   packet sizes supported in SNMP implementations, so that alternate\n\
    \   transport mappings may be required to support this.\n   An IPSEC-based security\
    \ model for SNMPv3 has been discussed.\n   Implementation of such a security model\
    \ would require the SNMPv3\n   engine to be able to retrieve the properties of\
    \ the IPSEC security\n   association used to protect the SNMPv3 traffic.  This\
    \ would include\n   the security services invoked, as well as information relating\
    \ to the\n   other endpoint, such as the authentication method and presented\n\
    \   identity and certificate.  To date such APIs have not been widely\n   implemented,\
    \ and in addition, most IPSEC implementations only support\n   machine certificates,\
    \ which may not provide the required granularity\n   of identification.  Thus,\
    \ an IPSEC-based security model for SNMPv3\n   would probably take several years\
    \ to come to fruition.\n"
- title: 3.3.7.  SNMP summary
  contents:
  - "3.3.7.  SNMP summary\n   Given the wealth of existing accounting-related MIB\
    \ modules, it is\n   likely that SNMP will remain a popular accounting protocol\
    \ for the\n   foreseeable future.\n   Support for notifications makes it possible\
    \ to implement the event-\n   driven, event-driven polling and event-driven batching\
    \ models.  This\n   makes it possible to notify domains of available data rather\
    \ than\n   requiring them to poll for it, which is critical in shared use\n  \
    \ networks and roaming.\n   Given the SNMPv3 security enhancements, it is desirable\
    \ for SNMP-\n   based intra-domain accounting implementations to upgrade to SNMPv3.\n\
    \   Such an upgrade is virtually mandatory for inter-domain applications.\n  \
    \ In inter-domain accounting, the burden of managing SNMPv3 shared\n   secrets\
    \ can be reduced via the localized key capability or via\n   implementation of\
    \ a Proxy Forwarder.  In the long term, alternative\n   security models such as\
    \ the Kerberos Security Model may further\n   reduce the effort required to manage\
    \ security and enable streamlined\n   inter-domain operation.\n   SNMP-based accounting\
    \ has limitations in terms of efficiency and\n   latency that may make it inappropriate\
    \ for use in situations\n   requiring low processing delay or low overhead.  This\
    \ includes usage\n   sensitive billing applications where fraud detection may\
    \ be required.\n   These issues can be addressed via proposals under discussion\
    \ in the\n   IRTF Network Management Research Group (NMRG).  The experimental\
    \ SNMP\n   over TCP transport mapping may prove helpful at reducing latency.\n\
    \   Depending on the volume of data, some form of compression may also be\n  \
    \ worth considering.  However, since these proposals are still in the\n   research\
    \ stage, and are not on the standards track, these\n   capabilities are not readily\
    \ available, and the specifications could\n   change considerably before they\
    \ reach their final form.\n   SNMP supports separation of accounting data by domain,\
    \ using either\n   of two general approaches with the VACM access control model.\
    \  The\n   domain as index approach can be used if the desired MIB module\n  \
    \ supports domain indexing, or it can implemented using an additional\n   table.\
    \  The domain-context approach can be used in agents which\n   support dynamic\
    \ logical contexts and a domain-to-context and\n   context-to-instrumentation\
    \ mapping mechanism.  Either approach can be\n   supported using SNMPv1, SNMPv2c,\
    \ or SNMPv3 messages, by utilizing the\n   snmpCommunitytable [11] to provide\
    \ a community-to-context mapping.\n"
- title: 4.  Review of Accounting Data Transfer
  contents:
  - "4.  Review of Accounting Data Transfer\n   In order for session records to be\
    \ transmitted between accounting\n   servers, a transfer protocol is required.\
    \  Transfer protocols in use\n   today include SMTP, FTP, and HTTP.  For a review\
    \ of accounting\n   attributes and record formats, see [45].\n   Reference [49]\
    \ contains a discussion of alternative encodings for SMI\n   data types, as well\
    \ as alternative protocols for transmission of\n   accounting data.  For example,\
    \ [49] describes how MIME tags and XML\n   DTDs may be used for encoding of SNMP\
    \ messages or SMI data types.\n   This enables data from SNMP MIBs to be transported\
    \ using any protocol\n   that can encapsulate MIME or XML, including SMTP and\
    \ HTTP.\n"
- title: 4.1.  SMTP
  contents:
  - "4.1.  SMTP\n   To date, few accounting management systems have been built on\
    \ SMTP\n   since the implementation of a store-and-forward message system has\n\
    \   traditionally required access to non-volatile storage which has not\n   been\
    \ widely available on network devices.  However, SMTP-based\n   implementations\
    \ have many desirable characteristics, particularly\n   with regards to security.\n\
    \   Accounting management systems using SMTP for accounting transfer will\n  \
    \ typically support batching so that message processing overhead will\n   be spread\
    \ over multiple accounting records.  As a result, these\n   systems result in\
    \ per-active device state.  Since accounting systems\n   using SMTP as a transfer\
    \ mechanism have access to substantial non-\n   volatile storage, they can generate,\
    \ compress if necessary, and store\n   accounting records until they are transferred\
    \ to the collection site.\n   As a result, accounting systems implemented using\
    \ SMTP can be highly\n   efficient and scalable.  Using IPSEC, TLS or Kerberos,\
    \ hop-by-hop\n   security services such as authentication, integrity protection\
    \ and\n   confidentiality can be provided.\n   As described in [13] and [15],\
    \ data object security is available for\n   SMTP, and in addition, the facilities\
    \ described in [12] make it\n   possible to request and receive signed receipts,\
    \ which enables non-\n   repudiation as described in [12]-[17].  As a result,\
    \ accounting\n   systems utilizing SMTP for accounting data transfer are capable\
    \ of\n   satisfying the most demanding security requirements.  However, such\n\
    \   systems are not typically capable of providing low processing delay,\n   although\
    \ this may be addressed by the enhancements described in [20].\n"
- title: 4.2.  Other protocols
  contents:
  - "4.2.  Other protocols\n   File transfer protocols such as FTP and HTTP have been\
    \ used for\n   transfer of accounting data.  For example, Reference [9] describes\
    \ a\n   means for representing ASN.1-based accounting data for storage on\n  \
    \ archival media.  Through the use of the Bulk File MIB, accounting\n   data from\
    \ an SNMP MIB can be stored in ASN.1, bulk binary or Bulk\n   ASCII format, and\
    \ then subsequently retrieved as required using the\n   FTP Client MIB.\n   Given\
    \ access to sufficient non-volatile storage, accounting systems\n   based on record\
    \ formats and transfer protocols can avoid loss of data\n   due to long-duration\
    \ network partitions, server failures or device\n   reboots.  Since it is possible\
    \ for the transfer to be driven from the\n   collection site, the collector can\
    \ retry transfers until successful,\n   or with HTTP may even be able to restart\
    \ partially completed\n   transfers.  As a result, file transfer-based systems\
    \ can be made\n   highly reliable, and the batching of accounting records makes\n\
    \   possible efficient transfers and application of required security\n   services\
    \ with lessened overhead.\n"
- title: 5.  Summary
  contents:
  - "5.  Summary\n   As noted previously in this document, accounting applications\
    \ vary in\n   their security and reliability requirements.  Some uses such as\n\
    \   capacity planning may only require authentication, integrity and\n   replay\
    \ protection, and modest reliability.  Other applications such\n   as inter-domain\
    \ usage-sensitive billing may require the highest\n   degree of security and reliability,\
    \ since in these cases the transfer\n   of accounting data will lead directly\
    \ to the transfer of funds.\n   Since accounting applications do not have uniform\
    \ security and\n   reliability requirements, it is not possible to devise a single\n\
    \   accounting protocol and set of security services that will meet all\n   needs.\
    \  Rather, the goal of accounting management should be to\n   provide a set of\
    \ tools that can be used to construct accounting\n   systems meeting the requirements\
    \ of an individual application.  As a\n   result, it is important to analyze a\
    \ given accounting application to\n   ensure that the methods chosen meet the\
    \ security and reliability\n   requirements of the application.\n   Based on an\
    \ analysis of the requirements, it appears that existing\n   deployed protocols\
    \ are capable of meeting the requirements for\n   intra-domain capacity planning\
    \ and non-usage sensitive billing.  In\n   these applications efficient transfer\
    \ of bulk data is useful although\n   not critical.  Thus, it is possible to use\
    \ SNMPv3 to satisfy these\n   requirements, without the NMRG extensions.  These\
    \ include TCP\n   transport mapping, sub-tree retrieval, and OID compression.\n\
    \   In inter-domain capacity planning and non-usage sensitive billing,\n   the\
    \ security and reliability requirements are greater.  As a result,\n   no existing\
    \ deployed protocol satisfies the requirements.  For\n   example, existing protocols\
    \ lack data object security support and\n   extensions to improve scalability\
    \ of inter-domain authentication are\n   needed, such as the Kerberos Security\
    \ Model (KSM) for SNMPv3.\n   For usage sensitive billing, as well as cost allocation\
    \ and auditing\n   applications, the reliability requirement are greater.  Here\n\
    \   transport layer reliability is required to provide robustness against\n  \
    \ packet loss, as well as application layer acknowledgments to provide\n   robustness\
    \ against accounting server failures.  SNMP operations with\n   the exception\
    \ of InforRequest provide application layer\n   acknowledgments, and the TCP transport\
    \ mapping proposed by NMRG\n   provides robustness against packet loss.  Inter-domain\
    \ operation can\n   benefit from data object security (which no existing protocol\n\
    \   provides) as well as inter-domain security model enhancements (such\n   as\
    \ the KSM).\n   Where high-value sessions are involved, such as in roaming, Mobile\n\
    \   IP, or telephony, it may be necessary to put bounds on processing\n   delay.\
    \  This implies the need to reduce latency.  As a result, the\n   NMRG extensions\
    \ are required in time sensitive billing applications,\n   including TCP transport\
    \ mapping, get-subtree capabilities and OID\n   compression.  High reliability\
    \ is also required in this application,\n   implying the need for application\
    \ layer as well as transport layer\n   acknowledgments.  SNMPv3 with the NMRG\
    \ extensions and security\n   scalability improvements such as the KSM can satisfy\
    \ the requirements\n   in intra-domain use.\n   However, in inter-domain use,\
    \ additional security precautions such as\n   data object security and receipt\
    \ support are required.  No existing\n   protocol can meet these requirements.\
    \  A summary is given in the\n   table on the next page.\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                 |                     |                   |\n   |  Usage\
    \          |   Intra-domain      | Inter-domain      |\n   |                 |\
    \                     |                   |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                 |                     |                   |\n   |  Capacity\
    \       | SNMPv3 &            | SNMPv3 &<*        |\n   |  Planning       | RADIUS\
    \ #%@          |                   |\n   |                 | TACACS+ @       \
    \    |                   |\n   |                 |                     |     \
    \              |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                 |                     |                   |\n   |  Non-usage\
    \      | SNMPv3 &            | SNMPv3 &<*        |\n   |  Sensitive      | RADIUS\
    \ #%@          |                   |\n   |  Billing        | TACACS+ @       \
    \    |                   |\n   |                 |                     |     \
    \              |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                 |                     |                   |\n   |  Usage\
    \          |                     |                   |\n   |  Sensitive      |\
    \                     |                   |\n   |  Billing,       | SNMPv3 &>$\
    \          | SNMPv3 &<>*$      |\n   |  Cost           | TACACS+ &$@         |\
    \                   |\n   |  Allocation &   |                     |          \
    \         |\n   |  Auditing       |                     |                   |\n\
    \   |                 |                     |                   |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                 |                     |                   |\n   |  Time\
    \           |                     |                   |\n   |  Sensitive     \
    \ | SNMPv3 &>$          |  No existing      |\n   |  Billing,       |        \
    \             |  protocol         |\n   |  fraud          |                  \
    \   |                   |\n   |  detection,     |                     |      \
    \             |\n   |  roaming        |                     |                \
    \   |\n   |                 |                     |                   |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   Key\n   # = lacks confidentiality support\n   * = lacks data object security\n\
    \   % = limited robustness against packet loss\n   & = lacks application layer\
    \ acknowledgment (e.g. SNMP InformRequest)\n   $ = requires non-volatile storage\n\
    \   @ = lacks batching support\n   < = lacks certificate support (KSM, work in\
    \ progress)\n   > = lacks support for large packet sizes (TCP transport mapping,\n\
    \       experimental)\n"
- title: 6.  Security Considerations
  contents:
  - "6.  Security Considerations\n   Security issues are discussed throughout this\
    \ memo.\n"
- title: 7.  Acknowledgments
  contents:
  - "7.  Acknowledgments\n   The authors would like to thank Bert Wijnen (Lucent),\
    \ Keith\n   McCloghrie (Cisco Systems), Jan Melen (Ericsson) and Jarmo Savolainen\n\
    \   (Ericsson) for useful discussions of this problem space.\n"
- title: 8.  References
  contents:
  - "8.  References\n   [1]  Aboba, B., Lu J., Alsop J., Ding J. and W. Wang, \"Review\
    \ of\n        Roaming Implementations\", RFC 2194, September 1997.\n   [2]  Aboba,\
    \ B. and G. Zorn, \"Criteria for Evaluating Roaming\n        Protocols\", RFC\
    \ 2477, January 1999.\n   [3]  Rigney, C., Rubens, A., Simpson, W. and S. Willens,\
    \ \"Remote\n        Authentication Dial In User Service (RADIUS)\", RFC  2138,\
    \ April,\n        1997.\n   [4]  Rigney, C., \"RADIUS  Accounting\", RFC 2139,\
    \ April 1997.\n   [5]  Shacham, A., Monsour, R., Pereira, R. and M. Thomas, \"\
    IP Payload\n        Compression Protocol (IPComp)\", RFC 2393, December 1998.\n\
    \   [6]  Bradner, S., \"Key words for use in RFCs to Indicate Requirement\n  \
    \      Levels\", BCP 14, RFC 2119, March 1997.\n   [7]  Information Sciences Institute,\
    \ \"Transmission Control Protocol\",\n        RFC 793, September 1981.\n   [8]\
    \  Aboba,  B. and  M.  Beadles, \"The Network Access Identifier\",\n        RFC\
    \ 2486, January 1999.\n   [9]  McCloghrie, K., Heinanen, J., Greene, W. and A.\
    \ Prasad,\n        \"Accounting Information for ATM Networks\", RFC 2512, February\n\
    \        1999.\n   [10] McCloghrie, K., Heinanen, J., Greene, W., and A. Prasad,\n\
    \        \"Managed Objects for Controlling the Collection and Storage of\n   \
    \     Accounting Information for Connection-Oriented Networks\", RFC\n       \
    \ 2513, February 1999.\n   [11] Frye, R., Levi, D., Routhier, S. and B. Wijnen,\
    \ \"Coexistence\n        between Version 1, Version 2, and Version 3 of the Internet-\n\
    \        standard Management Framework\", RFC 2576, March 2000.\n   [12] Fajman,\
    \ R., \"An Extensible Message Format for Message\n        Disposition Notifications\"\
    , RFC 2298, March 1998.\n   [13] Elkins, M., \"MIME  Security with Pretty Good\
    \ Privacy (PGP)\", RFC\n        2015, October 1996.\n   [14] Vaudreuil, G., \"\
    The Multipart/Report Content Type for the\n        Reporting of  Mail System Administrative\
    \ Messages\", RFC 1892,\n        January 1996.\n   [15] Galvin, J., Murphy, S.,\
    \ Crocker, S. and N. Freed, \"Security\n        Multiparts for MIME:  Multi-part/Signed\
    \ and\n        Multipart/Encrypted\", RFC 1847, October 1995.\n   [16] Crocker,\
    \ D., \"MIME Encapsulation of EDI Objects\", RFC 1767,\n        March 1995.\n\
    \   [17] Borenstein, N. and N. Freed, \"MIME (Multipurpose Internet Mail\n   \
    \     Extensions) Part One: Mechanisms for Specifying and Describing\n       \
    \ the Format of Internet Message Bodies\", RFC 1521, December 1993.\n   [18] Rose,\
    \ M.T., The Simple Book, Second Edition, Prentice Hall,\n        Upper Saddle\
    \ River, NJ, 1996.\n   [19] Case, J., Mundy, R., Partain, D. and B. Stewart, \"\
    Introduction\n        to Version 3 of the Internet-standard Network Management\n\
    \        Framework\", RFC 2570, April 1999.\n   [20] Klyne, G., \"Timely Delivery\
    \ for Facsimile Using Internet Mail\",\n        Work in Progress.\n   [21] Johnson,\
    \ H. T., Kaplan, R. S., Relevance Lost: The Rise and Fall\n        of Management\
    \ Accounting, Harvard Business School Press, Boston,\n        Massachusetts, 1987.\n\
    \   [22] Horngren, C. T., Foster, G., Cost Accounting: A Managerial\n        Emphasis.\
    \  Prentice Hall, Englewood Cliffs, New Jersey, 1991.\n   [23] Kaplan, R. S.,\
    \ Atkinson, Anthony A., Advanced Management\n        Accounting, Prentice Hall,\
    \ Englewood Cliffs, New Jersey, 1989.\n   [24] Cooper, R., Kaplan, R. S., The\
    \ Design of Cost Management\n        Systems.  Prentice Hall, Englewood Cliffs,\
    \ New Jersey, 1991.\n   [25] Rigney, C., Willats, S. and P. Calhoun, \"RADIUS\
    \ Extensions\", RFC\n        2869, June 2000.\n   [26] Stewart, R., et al., \"\
    Simple Control Transmission Protocol\", RFC\n        2960, October 2000.\n   [27]\
    \ Harrington, D., Presuhn, R., and B. Wijnen, \"An Architecture for\n        Describing\
    \ SNMP Management Frameworks\", RFC 2571, April 1999.\n   [28] Rose, M., and K.\
    \ McCloghrie, \"Structure and Identification of\n        Management Information\
    \ for TCP/IP-based Internets\", STD 16, RFC\n        1155, May 1990.\n   [29]\
    \ Rose, M. and K. McCloghrie, \"Concise MIB Definitions\", STD 16,\n        RFC\
    \ 1212, March 1991.\n   [30] Rose, M., \"A Convention for Defining Traps for use\
    \ with the\n        SNMP\", RFC 1215, March 1991.\n   [31] McCloghrie, K., Perkins,\
    \ D. and J. Schoenwaelder, \"Structure of\n        Management Information Version\
    \ 2 (SMIv2)\", STD 58, RFC 2578,\n        April 1999.\n   [32] McCloghrie, K.,\
    \ Perkins, D. and J. Schoenwaelder, \"Textual\n        Conventions for SMIv2\"\
    , STD 58, RFC 2579, April 1999.\n   [33] McCloghrie, K., Perkins, D. and J. Schoenwaelder,\
    \ \"Conformance\n        Statements for SMIv2\", STD 58, RFC 2580, April 1999.\n\
    \   [34] Case, J., Fedor, M., Schoffstall, M. and J. Davin, \"Simple\n       \
    \ Network Management Protocol\", STD 15, RFC 1157, May 1990.\n   [35] Case, J.,\
    \ McCloghrie, K., Rose, M. and S. Waldbusser,\n        \"Introduction to Community-based\
    \ SNMPv2\", RFC 1901, January\n        1996.\n   [36] Case, J., McCloghrie, K.,\
    \ Rose, M. and S. Waldbusser, \"Transport\n        Mappings for Version 2 of the\
    \ Simple Network Management Protocol\n        (SNMPv2)\", RFC 1906, January 1996.\n\
    \   [37] Case, J., Harrington D., Presuhn R. and B. Wijnen, \"Message\n      \
    \  Processing and Dispatching for the Simple Network Management\n        Protocol\
    \ (SNMP)\", RFC 2572, April 1999.\n   [38] Blumenthal, U. and B. Wijnen, \"User-based\
    \ Security Model (USM)\n        for version 3 of the Simple Network Management\
    \ Protocol\n        (SNMPv3)\", RFC 2574, April 1999.\n   [39] Levi, D., Meyer,\
    \ P. and B. Stewart, \"SNMPv3 Applications\", RFC\n        2573, April 1999.\n\
    \   [40] Wijnen, B., Presuhn, R. and K. McCloghrie, \"View-based Access\n    \
    \    Control Model (VACM) for the Simple Network Management Protocol\n       \
    \ (SNMP)\", RFC 2575, April 1999.\n   [41] Case, J., McCloghrie, K., Rose, M.\
    \ and S. Waldbusser, \"Protocol\n        Operations for Version 2 of the Simple\
    \ Network Management\n        Protocol (SNMPv2)\", RFC 1905, January 1996.\n \
    \  [42] Tung, B., Neuman, C., Hur, M., Medvinsky, A., Medvinsky, S.,\n       \
    \ Wray, J. and J. Trostle, \"Public Key Cryptography for Initial\n        Authentication\
    \ in Kerberos\", Work in Progress.\n   [43] Tung, B., Ryutov, T., Neuman, C.,\
    \ Tsudik, G., Sommerfeld, B.,\n        Medvinsky, A. and M. Hur, \"Public Key\
    \ Cryptography for Cross-\n        Realm Authentication in Kerberos\", Work in\
    \ Progress.\n   [44] Hornstein, K. and W. Hardaker, \"A Kerberos Security Model\
    \ for\n        SNMPv3\", Work in Progress.\n   [45] Brownlee, N. and A. Blount,\
    \ \"Accounting Attributes and Record\n        Formats\", RFC 2924, September 2000.\n\
    \   [46] Network Management Research Group Web page,\n        http://www.ibr.cs.tu-bs.de/projects/nmrg/\n\
    \   [47] Schoenwaelder, J.,\"SNMP-over-TCP Transport Mapping\", Work in\n    \
    \    Progress.\n   [48] Schoenwaelder, J., \"SNMP Payload Compression\", Work\
    \ in Progress.\n   [49] Sprenkels, R., Martin-Flatin, J.,\"Bulk Transfers of MIB\
    \ Data\",\n        Simple Times, http://www.simple-times.org/pub/simple-\n   \
    \     times/issues/7-1.html, March 1999.\n   [50] Thaler, D., \"Get Subtree Retrieval\
    \ MIB\", Work in Progress.\n   [51] Daniele, M., Wijnen, B., Ellison, M. and D.\
    \ Francisco, \"Agent\n        Extensibility (AgentX) Protocol Version 1\", RFC\
    \ 2741, January\n        2000.\n"
- title: 9.  Authors' Addresses
  contents:
  - "9.  Authors' Addresses\n   Bernard Aboba\n   Microsoft Corporation\n   One Microsoft\
    \ Way\n   Redmond, WA 98052\n   USA\n   Phone: +1 425 936 6605\n   EMail: bernarda@microsoft.com\n\
    \   Jari Arkko\n   Oy LM Ericsson Ab\n   02420 Jorvas\n   Finland\n   Phone: +358\
    \ 40 5079256\n   EMail: Jari.Arkko@ericsson.com\n   David Harrington\n   Cabletron\
    \ Systems Inc.\n   P.O.Box 5005\n   Rochester NH 03867-5005\n   USA\n   Phone:\
    \ +1 603 337 7357\n   EMail: dbh@cabletron.com\n"
- title: 10.  Intellectual Property Statement
  contents:
  - "10.  Intellectual Property Statement\n   The IETF takes no position regarding\
    \ the validity or scope of any\n   intellectual property or other rights that\
    \ might be claimed to\n   pertain to the implementation or use of the technology\
    \ described in\n   this document or the extent to which any license under such\
    \ rights\n   might or might not be available; neither does it represent that it\n\
    \   has made any effort to identify any such rights.  Information on the\n   IETF's\
    \ procedures with respect to rights in standards-track and\n   standards-related\
    \ documentation can be found in BCP-11.  Copies of\n   claims of rights made available\
    \ for publication and any assurances of\n   licenses to be made available, or\
    \ the result of an attempt made to\n   obtain a general license or permission\
    \ for the use of such\n   proprietary rights by implementors or users of this\
    \ specification can\n   be obtained from the IETF Secretariat.\n   The IETF invites\
    \ any interested party to bring to its attention any\n   copyrights, patents or\
    \ patent applications, or other proprietary\n   rights which may cover technology\
    \ that may be required to practice\n   this standard.  Please address the information\
    \ to the IETF Executive\n   Director.\n"
- title: 11.  Full Copyright Statement
  contents:
  - "11.  Full Copyright Statement\n   Copyright (C) The Internet Society (2000).\
    \  All Rights Reserved.\n   This document and translations of it may be copied\
    \ and furnished to\n   others, and derivative works that comment on or otherwise\
    \ explain it\n   or assist in its implementation may be prepared, copied, published\n\
    \   and distributed, in whole or in part, without restriction of any\n   kind,\
    \ provided that the above copyright notice and this paragraph are\n   included\
    \ on all such copies and derivative works.  However, this\n   document itself\
    \ may not be modified in any way, such as by removing\n   the copyright notice\
    \ or references to the Internet Society or other\n   Internet organizations, except\
    \ as needed for the purpose of\n   developing Internet standards in which case\
    \ the procedures for\n   copyrights defined in the Internet Standards process\
    \ must be\n   followed, or as required to translate it into languages other than\n\
    \   English.\n   The limited permissions granted above are perpetual and will\
    \ not be\n   revoked by the Internet Society or its successors or assigns.\n \
    \  This document and the information contained herein is provided on an\n   \"\
    AS IS\" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING\n   TASK FORCE\
    \ DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING\n   BUT NOT LIMITED\
    \ TO ANY WARRANTY THAT THE USE OF THE INFORMATION\n   HEREIN WILL NOT INFRINGE\
    \ ANY RIGHTS OR ANY IMPLIED WARRANTIES OF\n   MERCHANTABILITY OR FITNESS FOR A\
    \ PARTICULAR PURPOSE.\n"
- title: Acknowledgement
  contents:
  - "Acknowledgement\n   Funding for the RFC Editor function is currently provided\
    \ by the\n   Internet Society.\n"
