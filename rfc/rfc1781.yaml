- title: __initial_text__
  contents:
  - '        Using the OSI Directory to Achieve User Friendly Naming

    '
- title: Status of this Memo
  contents:
  - "Status of this Memo\n   This document specifies an Internet standards track protocol\
    \ for the\n   Internet community, and requests discussion and suggestions for\n\
    \   improvements.  Please refer to the current edition of the \"Internet\n   Official\
    \ Protocol Standards\" (STD 1) for the standardization state\n   and status of\
    \ this protocol.  Distribution of this memo is unlimited.\n"
- title: Abstract
  contents:
  - "Abstract\n   The OSI Directory has user friendly naming as a goal.  A simple\n\
    \   minded usage of the directory does not achieve this.  Two aspects not\n  \
    \ achieved are:\n    o  A user oriented notation\n    o  Guessability\n   This\
    \ proposal sets out some conventions for representing names in a\n   friendly\
    \ manner, and shows how this can be used to achieve really\n   friendly naming.\
    \  This then leads to a specification of a standard\n   format for representing\
    \ names, and to procedures to resolve them.\n   This leads to a specification\
    \ which allows directory names to be\n   communicated between humans.  The format\
    \ in this specification is\n   identical to that defined in [5], and it is intended\
    \ that these\n   specifications are compatible.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   7.   Support of OSI Services ....................................\
    \  15\n   8.   Experience .................................................  16\n\
    \   9.   Relationship to other work .................................  17\n  \
    \ 10.  Issues .....................................................  19\n   11.\
    \  References .................................................  20\n   12.  Security\
    \ Considerations ....................................  21\n   13.  Author's Address\
    \ ...........................................  21\n   A.   Pseudo-code for the\
    \ matching algorithm .....................  22\n   List of Figures\n       1.\
    \     Example usage of User Friendly Naming ................  18\n       2.  \
    \   Matching Algorithm ...................................  22\n   List of Tables\n\
    \       1.     Local environment for private DUA ....................  10\n  \
    \     2.     Local environment for US Public DUA ..................  11\n"
- title: 1.  Why a notation is needed
  contents:
  - "1.  Why a notation is needed\n   Many OSI Applications make use of Distinguished\
    \ Names (DN) as defined\n   in the OSI Directory [1].  The main reason for having\
    \ a notation for\n   name format is to interact with a user interface.  This specification\n\
    \   is coming dangerously close to the sin of standardising interfaces.\n   However,\
    \ there are aspects of presentation which it is desirable to\n   standardise.\n\
    \   It is important to have a common format to be able to conveniently\n   refer\
    \ to names.  This might be done to represent a directory name on\n   a business\
    \ card or in an email message.  There is a need for a format\n   to support human\
    \ to human communication, which must be string based\n   (not ASN.1) and user\
    \ oriented.\n   In very many cases, a user will be required to input a name. \
    \ This\n   notation is designed to allow this to happen in a uniform manner\n\
    \   across many user interfaces.  The intention is that the name can just\n  \
    \ be typed in.  There should not be any need to engage in form filling\n   or\
    \ complex dialogue.  It should be possible to take the \"human\"\n   description\
    \ given at the meeting, and use it directly.  The means in\n   which this happens\
    \ will become clear later.\n   This approach uses the syntax defined in [5] for\
    \ representing\n   distinguished names.  By relaxing some of the constraints on\
    \ this\n   specification, it is argued that a more user oriented specification\n\
    \   is produced.  However, this syntax cannot be mapped algorithmically\n   onto\
    \ a distinguished name without the use of a directory.\n   This notation is targeted\
    \ towards a general user oriented system, and\n   in particular to represent the\
    \ names of humans.  Other syntaxes may\n   be more appropriate for other uses\
    \ of the directory.  For example,\n   the OSF Syntax may be more appropriate for\
    \ some system oriented uses.\n   (The OSF Syntax uses \"/\" as a separator, and\
    \ forms names in a manner\n   intended to resemble UNIX filenames).\n   This notation\
    \ is targeted towards names which follow a particular DIT\n   structure:  organisationally\
    \ oriented.  This may make it\n   inappropriate for some types of application.\
    \  There may be a\n   requirement to extend this notation to deal more cleanly\
    \ with fully\n   geographical names.\n   This approach effectively defines a definition\
    \ of descriptive names\n   on top of the primitive names defined by the OSI Directory.\n"
- title: 2.  The Notation
  contents:
  - "2.  The Notation\n   The notation used in this specification is defined in [5].\
    \  This\n   notation defines an unambiguous representation of distinguished name,\n\
    \   and this specification is designed to be used in conjunction with\n   this\
    \ format.  Both specifications arise from the same piece of\n   research work\
    \ [4].  Some examples of the specification are given\n   here.  The author's User\
    \ Friendly Name (UFN) might be written:\n   Steve Kille, Computer Science, University\
    \ College London, GB\n   or\n   S. Kille, Computer Science, University College\
    \ London, GB\n   This may be folded, perhaps to display in multi-column format.\
    \  For\n   example:\n   Steve Kille,\n   Computer Science,\n   University College\
    \ London,\n   GB\n   Another UFN might be:\n   Christian Huitema, INRIA, FR\n\
    \   or\n   James Hacker,\n   Basingstoke,\n   Widget Inc,\n   GB\n   The final\
    \ example shows quoting of a comma in an Organisation name:\n   L. Eagle, \"Sue,\
    \ Grabbit and Runn\", GB\n   A purported name is what a user supplies to an interface\
    \ for\n   resolution into one or more distinguished names.  A system should\n\
    \   almost always store a name as a distinguished name.  This will be\n   more\
    \ efficient, and avoid problems with purported names which become\n   ambiguous\
    \ when a new name appears.  A user interface may display a\n   distinguished name,\
    \ using the distinguished name notation.  However,\n   it may display a purported\
    \ name in cases where this will be more\n   pleasing to the user.  Examples of\
    \ this might be:\n   o  Omission of the higher components of the distinguished\
    \ name are\n      not displayed (abbreviation).\n   o  Omission of attribute types,\
    \ where the type is unlikely to be\n      needed to resolve ambiguity.\n   The\
    \ ways in which a purported name may vary from a distinguished name\n   are now\
    \ described:\n   Type Omission\n   There are two cases of this.\n     o  Schema\
    \ defaulting.  In this case, although the type is not\n        present, a schema\
    \ defaulting is used to deduce the type.  The\n        first two types of schema\
    \ defaulting may be used to deduce a\n        distinguished name without the use\
    \ of the directory.  The use\n        of schema defaulting may be useful to improve\
    \ the performance\n        of UFN resolution.  The types of schema defaulting\
    \ are:\n        --  Default Schema\n        --  Context Dependent Default Schema\n\
    \        --  Data Dependent Default Schema\n     o  Omission of the type to be\
    \ resolved by searching.\n   Default Schema\n   The attribute type of an attribute\
    \ may always be present.  This may\n   be done to emphasise the type structure\
    \ of a name.  In some cases,\n   the typing may be omitted.  This is done in a\
    \ way so that in many\n   common cases, no attribute types are needed.  The following\
    \ type\n   hierarchy (schema) is assumed:\n   Common Name, (((Organisational Unit)*,\
    \  Organisation,) Country).\n   Explicitly typed RDNs may be inserted into this\
    \ hierarchy at any\n   point.  The least significant component is always of type\
    \ Common\n   Name.  Other types follow the defined organisational hierarchy.\n\
    \   The following are equivalent:\n   Filestore Access, Bells, Computer Science,\n\
    \   University College London, GB\n   and\n   CN=Filestore Access, OU=Bells, OU=Computer\
    \ Science,\n   O=University College London, C=GB\n   To interpet a distinguished\
    \ name presented in this format, with some\n   or all of the attributes with the\
    \ type not specified, the types are\n   derived according to the type hierarchy\
    \ by the following algorithm:\n    1.  If the first attribute type is not specified,\
    \ it is\n        CommonName.\n    2.  If the last attribute type is not specified,\
    \ it is Country.\n    3.  If there is no organisation explicitly specified, the\
    \ last\n        attribute with type not specified is of type Organisation.\n \
    \   4.  Any remaining attribute with type unspecified must be before\n       \
    \ an Organisation or OrganisationalUnit attribute, and is of\n        type OrganisationalUnit.\n\
    \   To take a distinguished name, and generate a name of this format with\n  \
    \ attribute types omitted, the following steps are followed.\n    1.  If the first\
    \ attribute is of type CommonName, the type may be\n        omitted.\n    2. \
    \ If the last attribute is of type Country, the type may be\n        omitted.\n\
    \    3.  If the last attribute is of type Country, the last\n        Organisation\
    \ attribute may have the type omitted.\n    4.  All attributes of type OrganisationalUnit\
    \ may have the type\n        omitted, unless they are after an Organisation attribute\
    \ or\n        the first attribute is of type OrganisationalUnit.\n   Context Dependent\
    \ Default Schema\n   The distinguished name notation defines a fixed schema for\
    \ type\n   defaulting.  It may be useful to have different defaults in different\n\
    \   contexts.  For example, the defaulting convention may be applied in a\n  \
    \ modified fashion to objects which are known not to be common name\n   objects.\
    \  This will always be followed if the least significant\n   component is explicitly\
    \ typed.  In this case, the following hierarchy\n   is followed:\n   ((Organisational\
    \ Unit)*,  Organisation,) Country\n   Data Dependent Defaulting\n   There are\
    \ cases where it would be optimal\n   to default according to the data.  For example,\
    \ in:\n   Einar Stefferud, Network Management Associates, CA, US\n   It would\
    \ be useful to default \"CA\" to type State.  This might be done\n   by defaulting\
    \ all two letter attributes under C=US to type State.\n   General Defaulting\n\
    \   A type may be omitted in cases where it does not follow a default\n   schema\
    \ hierarchy, and then type variants can be explored by\n   searching.  Thus a\
    \ distinguished name could be represented by a\n   uniquely matching purported\
    \ name.  For example,\n   James Hacker,\n   Basingstoke,\n   Widget Inc,\n   GB\n\
    \   Would match the distinguished name:\n   CN=James Hacker,\n   L=Basingstoke,\n\
    \   O=Widget Inc,\n   C=GB\n   Abbreviation\n   Some of the more significant components\
    \ of the DN will be omitted,\n   and then defaulted in some way (e.g., relative\
    \ to a local context).\n   For example:\n   Steve Kille\n   Could be interpreted\
    \ in the context of an organisational default.\n   Local Type Keywords\n   Local\
    \ values can be used to identify types, in addition to the\n   keywords defined\
    \ in [5].  For example, \"Organisation\" may be\n   recognised as an alternative\
    \ to \"O\".\n   Component Omission\n   An intermediate component of the name may\
    \ be omitted.  Typically this\n   will be an organisational unit.  For example:\n\
    \   Steve Kille, University College London, GB\n   In some cases, this can be\
    \ combined with abbreviation.  For example:\n   Steve Kille, University College\
    \ London\n   Approximation\n   Approximate renditions or alternate values of one\
    \ or\n   more of the components will be supplied.  For example:\n   Stephen Kille,\
    \ CS, UCL, GB\n   or\n   Steve Keill, Comp Sci, Univarstiy College London, GB\n\
    \   Friendly Country\n   A \"friendly country name\" can be used instead of the\
    \ ISO 3166 two\n   letter code.  For example:  UK; USA; France; Deutchland.\n"
- title: 3.  Communicating Directory Names
  contents:
  - "3.  Communicating Directory Names\n   A goal of this standard is to provide a\
    \ means of communicating\n   directory names.  Two approaches are given, one defined\
    \ in [5], and\n   the other here.  A future version of these specifications may\
    \ contain\n   only one of these approaches, or recommend use of one approach.\
    \  The\n   approach can usually be distinguished implicitly, as types are\n  \
    \ normally omitted in the UFN approach, and are always present in the\n   Distinguished\
    \ Name approach.  No recommendation is made here, but the\n   merits of each approach\
    \ is given.\n   1.  Distinguished Name or DN. A representation of the distinguished\n\
    \       name, according to the specification of [5].\n   2.  User Friendly Name\
    \ or UFN. A purported name, which is expected to\n       unambiguously resolve\
    \ onto the distinguished name.\n   When a UFN is communicated, a form which should\
    \ efficiently and\n   unambiguously resolve onto a distinguished name should be\
    \ chosen.\n   Thus it is reasonable to omit types, or to use alternate values\
    \ which\n   will unambiguously identify the entry in question (e.g., by use of\
    \ an\n   alternate value of the RDN attribute type).  It is not reasonable to\n\
    \   use keys which are (or are likely to become) ambiguous.  The approach\n  \
    \ used should be implicit from the context, rather than wired into the\n   syntax.\
    \  The terms \"Directory Name\" and \"X.500 Name\" should be used\n   to refer\
    \ to a name which might be either a DN or UFN. An example of\n   appropriate usage\
    \ of both forms is given in the Section which defines\n   the Author's location\
    \ in Section 12.  Advantages of communicating the\n   DN are:\n    o  The Distinguished\
    \ Name is an unambiguous and stable reference to\n       the user.\n    o  The\
    \ DN will be used efficiently by the directory to obtain\n       information.\n\
    \   Advantages of communicating the UFN are:\n    o  Redundant type information\
    \ can be omitted (e.g., \"California\",\n       rather than \"State=California\"\
    , where there is known to be no\n       ambiguity.\n    o  Alternate values can\
    \ be used to identify a component.  This might\n       be used to select a value\
    \ which is meaningful to the recipient, or\n       to use a shorter form of the\
    \ name.  Often the uniqueness\n       requirements of registration will lead to\
    \ long names, which users\n       will wish to avoid.\n    o  Levels of the hierarchy\
    \ may be omitted.  For example in a very\n       small organisation, where a level\
    \ of hierarchy has been used to\n       represent company structure, and the person\
    \ has a unique name\n       within the organisation.\n   Where UFN form is used,\
    \ it is important to specify an unambiguous\n   form.  In some ways, this is analogous\
    \ to writing a postal address.\n   There are many legal ways to write it.  Care\
    \ needs to be taken to\n   make the address unambiguous.\n"
- title: 4.  Matching a purported name
  contents:
  - "4.  Matching a purported name\n   The following approach specifies a default\
    \ algorithm to be used with\n   the User Friendly Naming approach.  It is appropriate\
    \ to modify this\n   algorithm, and future specifications may propose alternative\n\
    \   algorithms.  Two simple algorithms are noted in passing, which may be\n  \
    \ useful in some contexts:\n   1.  Use type omission only, but otherwise require\
    \ the value of the RDN\n       attribute to be present.\n   2.  Require each RDN\
    \ to be identified as in 1), or by an exact match\n       on an alternate value\
    \ of the RDN attribute.\n   These algorithms do not offer the flexibility of the\
    \ default\n   algorithm proposed, but give many of the benefits of the approach\
    \ in\n   a very simple manner.\n   The major utility of the purported name is\
    \ to provide the important\n   \"user friendly\" characteristic of guessability.\
    \  A user will supply a\n   purported name to a user interface, and this will\
    \ be resolved onto a\n   distinguished name.  When a user supplies a purported\
    \ name there is a\n   need to derive the DN. In most cases, it should be possible\
    \ to derive\n   a single name from the purported name.  In some cases, ambiguities\n\
    \   will arise and the user will be prompted to select from a multiple\n   matches.\
    \  This should also be the case where a component of the name\n   did not \"match\
    \ very well\".\n   There is an assumption that the user will simply enter the\
    \ name\n   correctly.  The purported name variants are designed to make this\n\
    \   happen!  There is no need for fancy window based interfaces or form\n   filling\
    \ for many applications of the directory.  Note that the fancy\n   interfaces\
    \ still have a role for browsing, and for more complex\n   matching.  This type\
    \ of naming is to deal with cases where\n   information on a known user is desired\
    \ and keyed on the user's name.\n"
- title: 4.1  Environment
  contents:
  - "4.1  Environment\n   All matches occur in the context of a local environment.\
    \  The local\n   environment defines a sequence of names of a non-leaf objects\
    \ in the\n   DIT. This environment effectively defines a list of acceptable name\n\
    \   abbreviations where the DUA is employed.  The environment should be\n   controllable\
    \ by the individual user.  It also defines an order in\n   which to operate.\n\
    \   This list is defined in the context of the number of name components\n   supplied.\
    \  This allows varying heuristics, depending on the\n   environment, to make the\
    \ approach have the \"right\" behaviour.  In\n   most cases, the environment will\
    \ start at a local point in the DIT,\n   and move upwards.  Examples are given\
    \ in Tables 1 and 2.  Table 1\n   shows an example for a typical local DUA, which\
    \ has the following\n   characteristics:\n   One component\n   Assumed first to\
    \ be a user in the department, then a user or\n   department within the university,\
    \ then a national organisation, and\n   finally a country.\n   Two components\n\
    \   Most significant component is first assumed to be a national\n   organisation,\
    \ then a department (this might be reversed in some\n   organisations), and finally\
    \ a country.\n   Three or more components\n   The most significant component is\
    \ first assumed to be a country, then\n   a national organisation, and finally\
    \ a department.\n"
- title: 4.2  Matching
  contents:
  - "4.2  Matching\n   A purported name will be supplied, usually with a small number\
    \ of\n   components.  This will be matched in the context of an environment.\n\
    \   Where there are multiple components to be matched, these should be\n   matched\
    \ sequentially.  If an unambiguous DN is determined, the match\n   continues as\
    \ if the full DN had been supplied.  For example, if\n         +-----------+--------------------------------------+\n\
    \         |Number of  |Environment                           |\n         |Components\
    \ |                                      |\n         +-----------+--------------------------------------+\n\
    \         |1          |Physics, University College London, GB|\n         |   \
    \        |University College London, GB         |\n         |           |GB  \
    \                                  |\n         +-----------+--------------------------------------+\n\
    \         |2          |GB                                    |\n         |   \
    \        |University College London, GB         |\n         |           |--  \
    \                                  |\n         +-----------+--------------------------------------+\n\
    \         |3+         |--                                    |\n         |   \
    \        |GB                                    |\n         |           |University\
    \ College London, GB         |\n         +-----------+--------------------------------------+\n\
    \             Table 1:  Local environment for private DUA\n                  \
    \   +------------+-----------+\n                     | Number of  |Environment|\n\
    \                     | Components |           |\n                     +------------+-----------+\n\
    \                     |  1,2       | US        |\n                     |     \
    \       | CA        |\n                     |            | --        |\n     \
    \                +------------+-----------+\n                     |  3+      \
    \  | --        |\n                     |            | US        |\n          \
    \           |            | CA        |\n                     +------------+-----------+\n\
    \            Table 2:  Local environment for US Public DUA\n   Stephen Kille,\
    \ UCL\n   is being matched in the context of environment GB, first UCL is\n  \
    \ resolved to the distinguished name:\n   University College London, GB\n   Then\
    \ the next component of the purported name is taken to determine\n   the final\
    \ name.  If there is an ambiguity (e.g., if UCL had made two\n   matches, both\
    \ paths are explored to see if the ambiguity can be\n   resolved.  Eventually\
    \ a set of names will be passed back to the user.\n   Each component of the environment\
    \ is taken in turn.  If the purported\n   name has more components than the maximum\
    \ depth, the environment\n   element is skipped.  The advantage of this will be\
    \ seen in the\n   example given later.\n   A match of a name is considered to\
    \ have three levels:\n   Exact A DN is specified exactly\n   Good Initially, a\
    \ match should be considered good if it is\n       unambiguous, and exactly matches\
    \ an attribute value in the entry.\n       For human names, a looser metric is\
    \ probably desirable (e.g.,\n       S Kille should be a good match of S. Kille,\
    \ S.E. Kille or Steve\n       Kille even if these are not explicit alternate values).\n\
    \   Poor Any other substring or approximate match\n   Following a match, the reference\
    \ can be followed, or the user\n   prompted.  If there are multiple matches, more\
    \ than one path may be\n   followed.  There is also a shift/reduce type of choice:\
    \  should any\n   partial matches be followed or should the next element of the\n\
    \   environment be tried.  The following heuristics are suggested, which\n   may\
    \ be modified in the light of experience.  The overall aim is to\n   resolve cleanly\
    \ specified names with a minimum of fuss, but give\n   sufficient user control\
    \ to prevent undue searching and delay.\n   1.  Always follow an exact match.\n\
    \   2.  Follow all good matches if there are no exact matches.\n   3.  If there\
    \ are only poor matches, prompt the user.  If the user\n       accepts one or\
    \ more matches, they can be considered as good.  If\n       all are rejected,\
    \ this can be treated as no matches.\n   4.  Automatically move to the next element\
    \ of the environment if no\n       matches are found.\n   When the final component\
    \ is matched, a set of names will be\n   identified.  If none are identified,\
    \ proceed to the next environment\n   element.  If the user rejects all of the\
    \ names, processing of the\n   next environment element should be confirmed.\n\
    \   The exact approach to matching will depend on the level of the tree\n   at\
    \ which matching is being done.  We can now consider how attributes\n   are matched\
    \ at various levels of the DIT.\n   There is an issue of approximate matching.\
    \  Sometimes it helps, and\n   sometimes just returns many spurious matches. \
    \ When a search is\n   requested, all relevant attributes should be returned,\
    \ so that\n   distinguished and non-distinguished values can be looked at.  This\n\
    \   will allow a distinction to be made between good and poor matches.\n   It\
    \ is important that where, for example, an acronym exactly matches\n   an organisation,\
    \ that the user is not prompted about other\n   organisations where it matches\
    \ as a substring.\n"
- title: 4.3  Top Level
  contents:
  - "4.3  Top Level\n   In this case, a match is being done at the root of the DIT.\
    \ Three\n   approaches are suggested, dependent on the length of supplied name.\n\
    \   All lead to a single level search of the top level of the DIT.\n   Exactly\
    \ 2\n   This is assumed to be a 3166 two letter country code, or an exact\n  \
    \ match on a friendly country or organisation (e.g., UK or UN). Do\n   exact match\
    \ on country and friendly country.\n   Greater than 2\n   Make an approximate\
    \ and substring match on friendly country and\n   organisation.\n"
- title: 4.4  Intermediate Level
  contents:
  - "4.4  Intermediate Level\n   Once the root level has been dealt with, intermediate\
    \ levels will be\n   looking for organisational components (Organisation, Locality,\
    \ Org\n   Unit).  In some cases, private schema control will allow the system\n\
    \   to determine which is at the next level.  In general this will not be\n  \
    \ possible.  In each case, make a substring and approximate match\n   search of\
    \ one level.  The choice depends on the base object used in\n   the search.\n\
    \   1.  If DN has no Organisation or Locality, filter on Organisation and\n  \
    \     Locality.\n   2.  If DN has Org Unit, filter on Org Unit.\n   3.  If DN\
    \ has Organisation, filter on Locality and Org Unit.\n   4.  If DN has Locality,\
    \ filter on Organisation.\n   These allow some optimisation, based on legal choices\
    \ of schema.\n   Keeping filters short is usually desirable to improve performance.\
    \  A\n   few examples of this, where a base object has been determined (either\n\
    \   by being the environment or by partial resolution of a purported\n   name),\
    \ and the next element of a purported name is being considered.\n   This will\
    \ generate a single level search.  What varies is the types\n   being filtered\
    \ against.  If the DN is:\n   University College London, GB\n   The search should\
    \ be for Org Unit or Locality.  If the DN is:\n   Organisation=UN\n   the search\
    \ should be for Org Unit or Locality.\n   There may be some improvements with\
    \ respect to very short keys.  Not\n   making approximate or substring matches\
    \ in these cases seems sensible\n   (It might be desirable to allow \"*\" as a\
    \ part of the purported name\n   notation.)\n"
- title: 4.5  Bottom Level
  contents:
  - "4.5  Bottom Level\n   The \"Bottom Level\" is to deal with leaf entries in the\
    \ DIT. This will\n   often be a person, but may also be a role, an application\
    \ entity or\n   something else.\n   The last component of a purported name may\
    \ either reference a leaf or\n   non-leaf.  For this reason, both should be tested\
    \ for.  As a\n   heuristic, if the base object for the search has two or more\n\
    \   components it should be tested first as a bottom level name and then\n   intermediate.\
    \  Reverse this for shorter names.  This optimises for\n   the (normal) case of\
    \ non-leaves high up the tree and leaves low down\n   the tree.\n   For bottom\
    \ level names, make an approximate and substring match\n   against Common Name,\
    \ Surname, and User ID. Where common name is\n   looked for, a full subtree search\
    \ will be used when at the second\n   level of the DIT or lower, otherwise a single\
    \ level search.\n   For example, if I have resolved a purported name to the distinguished\n\
    \   name\n   University College London, GB\n   and have a single component Bloggs,\
    \ this will generate a subtree\n   search.\n"
- title: 5.  Examples
  contents:
  - "5.  Examples\n   This is all somewhat confusing, and a few examples are given.\
    \  These\n   are all in the context of the environment shown in Table 1 on Page\n\
    \   13.\n   If \"Joe Bloggs\" is supplied, a subtree search of\n   Physics, University\
    \ College London, GB\n   will be made, and the user prompted for \"Joseph Z. Bloggs\"\
    \ as the\n   only possible match.\n   If \"Computer Science\" is supplied, first\n\
    \   Physics, University College London, GB\n   will be searched, and the user\
    \ will reject the approximate match of\n   \"Colin Skin\".  Then a subtree search\
    \ of\n   University College London, GB\n   will be made, looking for a person.\
    \  Then a single level search will\n   be made looking for Org Unit, and\n   Computer\
    \ Science, University College London, GB\n   will be returned without prompting\
    \ (exact match).  Supplying \"Steve\n   Kille\" will lead to a failed subtree\
    \ search of\n   Physics, University College London, GB\n   and lead straight to\
    \ a subtree search of\n   University College London, GB\n   This will lead to\
    \ an exact value match, and so a single entry\n   returned without prompting.\n\
    \   If \"Andrew Findlay, Brunel\" is supplied, the first element of the\n   environment\
    \ will be skipped, single level search of \"Brunel\" under\n   \"GB\" will find:\n\
    \   Brunel University, GB\n   and a subtree search for \"Andrew Findlay\" initiated.\
    \  This will yield\n   Andrew Findlay, Computing and Media Services, Brunel University,\
    \ GB\n   Dr A J Findlay, Manufacturing and Engineering Systems, Brunel\n   University,\
    \ GB\n   and the user will be prompted with a choice.\n   This approach shows\
    \ how a simple format of this nature will \"do the\n   right thing\" in many cases.\n"
- title: 6.  Support required from the standard
  contents:
  - "6.  Support required from the standard\n   Fortunately, all that is needed is\
    \ there!  It would be useful to have\n   \"friendly country name\" as a standard\
    \ attribute.\n"
- title: 7.  Support of OSI Services
  contents:
  - "7.  Support of OSI Services\n   The major focus of this work has been to provide\
    \ a mechanism for\n   identifying Organisations and Users.  A related function\
    \ is to\n   identify applications.  Where the Application is identified by an\
    \ AET\n   (Application Entity Title) with an RDN of Common Name, this\n   specification\
    \ leads to a natural usage.  For example, if a filestore\n   is named \"gannet\"\
    , then this could easily be identified by the name:\n   Gannet, Computer Laboratory,\
    \ Cambridge University, GB\n   In normal usage, this might lead to access (using\
    \ a purported name)\n   of:\n   FTAM gannet,cambridge\n   A second type of access\
    \ is where the user identifies an Organisation\n   (Organisational Unit), and\
    \ expects to obtain a default service.  The\n   service is implied by the application,\
    \ and should not require any\n   additional naming as far as the user is concerned.\
    \  It is proposed\n   that this is supported by User Friendly Naming in the following\
    \ way.\n   1.  Determine that the purported name identifies a non-leaf object,\n\
    \       which is of object class Organisation or Organisational Unit or\n    \
    \   Locality.\n   2.  Perform a single level search for Application Entities which\n\
    \       support the required application contexts.  This assumes that all\n  \
    \     services which are supporting default access for the organisation\n    \
    \   are registered at one level below (possibly by the use of\n       aliases),\
    \ and that other services (specific machines or parts of\n       the organisation)\
    \ are represented further down the tree.  This\n       seems to be a reasonable\
    \ layout, and its utility can be evaluated\n       by experiment.\n"
- title: 8.  Experience
  contents:
  - "8.  Experience\n   An experimental implementation of this has been written by\
    \ Colin\n   Robbins.  The example in Figure 1 shows that it can be very effective\n\
    \   at locating known individuals with a minimum of effort.  This code has\n \
    \  been deployed within the \"FRED\" interface of the PSI Pilot [9], and\n   within\
    \ an prototype interface for managing distribution lists.  The\n   user reaction\
    \ has been favourable:\n   Some issues have arisen from this experience:\n   \
    \ o  Where there is more than one level of Organisational Unit, and the\n    \
    \   user guesses one which is not immediately below the organisation,\n      \
    \ the algorithm works badly.  There does not appear to be an easy\n       fix\
    \ for this.  It is not clear if this is a serious deficiency.\n    o  Substring\
    \ searching is currently done with leading and trailing\n       wildcards.  As\
    \ many implementations will not implement leading\n       wildcards efficiently,\
    \ it may be preferable to only use trailing\n       wildcards.  The effect of\
    \ this on the algorithm needs to be\n       investigated.\n   Implementors of\
    \ this specification are encouraged to investigate\n   variants of the basic algorithm.\
    \  A final specification should depend\n   on experience with such variants.\n"
- title: 9.  Relationship to other work
  contents:
  - "9.  Relationship to other work\n   Colin Robbin's work on the interface \"Tom\"\
    \ and implementation of a\n   distribution list interface strongly influenced\
    \ this specification\n   [6].\n   Some of the ideas used here originally came\
    \ from a UK Proposal to the\n   ISO/CCITT Directory Group on \"New Name Forms\"\
    \ [2].  This defined, and\n   showed how to implement, four different types of\
    \ names:\n   Typed and Ordered The current Distinguished Name is a restricted\n\
    \   example of this type of name.\n   -> t hales, csiro, australia\n   Found good\
    \ match(es) for 'australia'\n   Found exact match(es) for 'csiro'\n   Please select\
    \ from the following:\n      Trevor Hales, OC, HPCC, DIT, IICT, CSIRO, AU [y/n]\
    \ ? y\n   The following were matched...\n      Trevor Hales, OC, HPCC, DIT, IICT,\
    \ CSIRO, AU\n   -> g michaelson, queensland, au\n   Found exact match(es) for\
    \ 'au'\n   Please select from the following:\n      University of Queensland,\
    \ AU [y/n] ? y\n      Axolotl, AU [y/n] ? n\n   Please select from the following:\n\
    \      George Michaelson, Prentice Computer Centre, University of\n      Queensland,\
    \ AU\n   [y/n] ? y\n      Manager, University of Queensland, AU [y/n] ? n\n  \
    \ The following were matched...\n      George Michaelson, Prentice Computer Centre,\
    \ University of\n      Queensland, AU\n   -> r needham, cambridge\n   Found good\
    \ match(es) for 'cambridge'\n   Please select from the following:\n      Roger\
    \ Needham, Computer Lab, Cambridge University [y/n] ? y\n   The following were\
    \ matched...\n      Roger Needham, Computer Lab, Cambridge University\n   -> kirstein\n\
    \   Found good match(es) for 'kirstein'\n   The following were matched...\n  \
    \    Peter Kirstein\n              Figure 1:  Example usage of User Friendly Naming\n\
    \   Untyped and Ordered\n   This is the type of name proposed here (with some\
    \ extensions to allow\n   optional typing).  It is seen as meeting the key user\
    \ requirement of\n   disliking typed names, and is efficient to implement.\n \
    \  Typed and Unordered\n   This sort of name is proposed by others as the key\
    \ basis for user\n   friendly naming.  Neufeld shows how X.500 can be used to\
    \ provide this\n   [7], and Peterson proposes the Profile system to provide this\
    \ [8].\n   The author contends that whilst typed naming is interesting for some\n\
    \   types of searching (e.g., yellow page searching), it is less\n   desirable\
    \ for naming objects.  This is borne out by operational\n   experience with OSI\
    \ Directories [3].\n   Untyped and Unordered\n   Surprisingly this form of name\
    \ can be supported quite easily.\n   However, a considerable gain in efficiency\
    \ can be achieved by\n   requiring ordering.  In practice, users can supply this\
    \ easily.\n   Therefore, this type of name is not proposed.\n"
- title: 10.  Issues
  contents:
  - "10.  Issues\n   The following issues are noted, which would need to be resolved\n\
    \   before this document is progressed as an Internet Standard.\n   Potential\
    \ Ambiguity\n   Whilst the intention of the notation is to allow for specification\
    \ of\n   alternate values, it inherently allows for ambiguous names to be\n  \
    \ specified.  It needs to be demonstrated that problems of this\n   characteristic\
    \ are outweighed by other benefits of the notation.\n   Utility\n   Determine\
    \ that the specification is being implemented and used.\n   Performance\n   Measurements\
    \ on the performance implications of using this approach\n   should be made.\n\
    \   Alogrithm\n   The utility of the algorithm, and possible variants, should\
    \ be\n   investigated.\n   This format, and the procedures for resolving purported\
    \ names, should\n   be evolved to an Internet Standard.  The syntax can be expected\
    \ to be\n   stable.  In light of experience, the algorithm for resolving\n   purported\
    \ names may be changed.\n"
- title: 11.  References
  contents:
  - "11.  References\n   [1] The Directory --- overview of concepts, models and services,\n\
    \       1993. CCITT X.500 Series Recommendations.\n   [2] S.E. Kille. New name\
    \ forms, May 1989.  ISO/IEC/JTC 21/ WG4/N797\n       UK National Body Contribution\
    \ to the Oslo Directory Meeting.\n   [3] S.E. Kille. The THORN large scale pilot\
    \ exercise.  Computer\n       Networks and ISDN Systems, 16(1):143--145, January\
    \ 1989.\n   [4] S.E. Kille. Using the OSI directory to achieve user friendly\n\
    \       naming. Research Note RN/20/29, Department of Computer Science,\n    \
    \   University College London, February 1990.\n   [5] Kille, S., \"A String Representation\
    \ of Distinguished Names\", RFC\n       1779, ISODE Consortium, March 1995.\n\
    \   [6] S.E. Kille and C.J. Robbins. The ISO development environment:\n      \
    \ User's manual (version 7.0), July 1991. Volume 5:  QUIPU.\n   [7] G.W. Neufeld.\
    \ Descriptive names in X.500.  In SIGCOMM 89\n       Symposiun Communications\
    \ Architectures and Protocols, pages 64--\n       71, September 1989.\n   [8]\
    \ L.L. Petersen. The profile naming service.  ACM Transactions on\n       Computing\
    \ Systems, 6(4):341--364, November 1988.\n   [9] M.T. Rose. Realizing the White\
    \ Pages using the OSI Directory\n       Service. Technical Report 90--05--10--1,\
    \ Performance Systems\n       International, Inc., May 1990.\n"
- title: 12.  Security Considerations
  contents:
  - "12.  Security Considerations\n   Security issues are not discussed in this memo.\n"
- title: 13.  Author's Address
  contents:
  - "13.  Author's Address\n   Steve Kille\n   ISODE Consortium\n   The Dome\n   The\
    \ Square\n   Richmond, Surrey\n   TW9 1DT\n   England\n   Phone:+44-181-332-9091\n\
    \   EMail:  S.Kille@ISODE.COM\n   DN: CN=Steve Kille,\n   O=ISODE Consortium,\
    \ C=GB\n   UFN: S. Kille,\n   ISODE Consortium, GB\n"
- title: A.  Pseudo-code for the matching algorithm
  contents:
  - "A.  Pseudo-code for the matching algorithm\n   The following pseudo-code is intended\
    \ to clarify the matching\n   algorithm.  The language uses ASN.1 data types,\
    \ with flow control\n   \"C\"-like, but with keywords upper-cased.\n"
- title: PurportedName ::= SEQUENCE OF String
  contents:
  - "PurportedName ::= SEQUENCE OF String\n                -- simplication, as attribute\
    \ types can optionally be\n                -- specified\n                -- Each\
    \ element of the Purported Name is a string\n                -- which has been\
    \ parsed from the BNF\n"
- title: Attribute ::= SEQUENCE {
  contents:
  - "Attribute ::= SEQUENCE {\n        type OBJECT IDENTIFIER,\n        value ANY\
    \ }\n"
- title: RDN ::= Attribute -- simplification, as can be multi-value
  contents:
  - 'RDN ::= Attribute -- simplification, as can be multi-value

    '
- title: DN ::= SEQUENCE OF RDN
  contents:
  - 'DN ::= SEQUENCE OF RDN

    '
- title: Environment ::= SEQUENCE OF DN
  contents:
  - 'Environment ::= SEQUENCE OF DN

    '
- title: EnvironmentList ::= SEQUENCE OF SEQUENCE {
  contents:
  - "EnvironmentList ::= SEQUENCE OF SEQUENCE {\n                        lower-bound\
    \ INTEGER,\n                        upper-bound INTEGER,\n                   \
    \     environment Environment }\n"
- title: 'friendlyMatch(p:  PurportedName; el:  EnvironmentList):    SET OF DN'
  contents:
  - 'friendlyMatch(p:  PurportedName; el:  EnvironmentList):    SET OF DN

    '
- title: '{'
  contents:
  - "{\n                                -- Find correct environment\n        IF length(el)\
    \ == 0 THEN return(NULL);\n        IF length(p) <= head(el).upper-bound\n    \
    \                    && length(p) >= head(el).lower-bound THEN\n             \
    \   return envMatch (p, head(el).environment);\n        ELSE\n               \
    \ return(friendlyMatch(p, tail(el));\n"
- title: '}'
  contents:
  - '}

    '
- title: 'envMatch(p:  PurportedName; e:  Environment):    SET OF DN'
  contents:
  - 'envMatch(p:  PurportedName; e:  Environment):    SET OF DN

    '
- title: '{'
  contents:
  - "{\n                                -- Check elements of environment\n       \
    \                         -- in the defined order\n        matches:  SET OF DN;\n\
    \        IF length(e) == 0 THEN return(NULL);\n        matches = purportedMatch(head(e).DN,\
    \ p)\n        IF matches != NULL THEN\n                return(matches);\n    \
    \    ELSE\n                return(envMatch(p, tail(e));\n"
- title: '}'
  contents:
  - '}

    '
- title: 'purportedMatch(base:  DN; p:  PurportedName):  SET OF DN'
  contents:
  - 'purportedMatch(base:  DN; p:  PurportedName):  SET OF DN

    '
- title: '{'
  contents:
  - "{\n        s:  String = head(p);\n        matches:  SET OF DN = NULL;\n     \
    \   IF length(p) == 1 THEN\n                IF length(base) == 0 THEN\n      \
    \                  IF (matches = rootSearch(s)) != NULL THEN\n               \
    \                 return(matches);\n                        ELSE return(leafSearch(base,\
    \ s, one-level);\n                ELSE IF length(base) == 1 THEN\n           \
    \             IF (matches = intSearch(base, s)) != NULL THEN\n               \
    \                 return(matches);\n                        ELSE return(leafSearch(base,\
    \ s, one-level);\n                ELSE\n                        IF (matches =\
    \ leafSearch(base, s, subtree)) !=\n                                NULL THEN\
    \ return(matches);\n                        ELSE return(intsearch(base, s);\n\
    \        IF length(base) == 0 THEN\n                FOR x IN rootSearch(s) DO\n\
    \                        matches += (purportedMatch(x, tail(p));\n        ELSE\n\
    \                FOR x IN intSearch(base, s) DO\n                        matches\
    \ += (purportedMatch(x, tail(p));\n        return(matches);\n"
- title: '}'
  contents:
  - '}

    '
- title: -- General.    Might need to tighten the filter for short strings,
  contents:
  - '-- General.    Might need to tighten the filter for short strings,

    '
- title: -- in order to stop being flooded.    Alternatively, this could be
  contents:
  - '-- in order to stop being flooded.    Alternatively, this could be

    '
- title: -- done if the loose search hits a size limit
  contents:
  - '-- done if the loose search hits a size limit

    '
- title: 'rootSearch(s:  String):  SET OF DN'
  contents:
  - 'rootSearch(s:  String):  SET OF DN

    '
- title: '{'
  contents:
  - "{\n        IF length(s) == 2 THEN\n                return(search(NULL, one-level,\
    \ s, {CountryName,\n                        FriendlyCountryName, OrganizationName},\n\
    \                        {exact}, {Country, Organisation}));\n               \
    \         -- test exact match only\n                        -- probably a country\
    \ code\n        ELSE\n                return(search(NULL, one-level, s, {OrganizationName,\n\
    \                        FriendlyCountryName}, {substring, approx},\n        \
    \                {Country, Organisation}));\n"
- title: '}'
  contents:
  - '}

    '
- title: 'intSearch( base:  DN; s:  String)'
  contents:
  - 'intSearch( base:  DN; s:  String)

    '
- title: '{'
  contents:
  - "{\n        IF present(base, OrgUnitName) THEN\n                return(search(base,\
    \ one-level, s, {OrgUnitName},\n                        {substring, approx}, {OrgUnit}));\n\
    \        ELSE IF present(base, OrganisationName) THEN\n                return(search(base,\
    \ one-level, s, {OrgUnitName,\n                        LocalityName}, {substring,\
    \ approx},\n                        {Organization, OrgUnit, Locality}));\n   \
    \     ELSE IF present(base, LocalityName) THEN\n                return(search(base,\
    \ one-level, s, {OrganisationName},\n                        {substring, approx},\
    \ {Locality});\n        ELSE\n                return(search(base, one-level, s,\
    \ {OrganisationName,\n                        LocalityName}, {substring, approx},\n\
    \                        {Organisation, Locality}));\n"
- title: '}'
  contents:
  - '}

    '
- title: 'present(d:  DN; t:  AttributeType):  BOOLEAN'
  contents:
  - 'present(d:  DN; t:  AttributeType):  BOOLEAN

    '
- title: '{'
  contents:
  - "{\n        FOR x IN d DO\n                IF x.type == t THEN return(TRUE);\n\
    \        return(FALSE);\n"
- title: '}'
  contents:
  - '}

    '
- title: SearchScope := ENUMERATED (base-object, one-level, subtree)
  contents:
  - 'SearchScope := ENUMERATED (base-object, one-level, subtree)

    '
- title: 'leafSearch(base:  DN; s:  String; search-scope:  SearchScope)'
  contents:
  - 'leafSearch(base:  DN; s:  String; search-scope:  SearchScope)

    '
- title: '{'
  contents:
  - "{\n        return(search(base, search-scope, s, {CommonName, Surname,\n     \
    \           UserId}, {substring, approx}));\n"
- title: '}'
  contents:
  - '}

    '
- title: 'search(base:  DN; search-scope:  SearchScope; s:  string;'
  contents:
  - "search(base:  DN; search-scope:  SearchScope; s:  string;\n        alist SET\
    \ OF AttributeType; matchtypes SET OF MatchType\n        objectClasses SET OF\
    \ ObjectClass OPTIONAL): SET OF DN\n"
- title: '{'
  contents:
  - "{\n        -- mapped onto Directory Search, with OR conjunction\n        -- of\
    \ filter items\n        return dNSelect (s, search-results, alist);\n"
- title: '}'
  contents:
  - '}

    '
- title: 'read(base:  DN; alist SET OF AttributeType):  SET OF Attribute;'
  contents:
  - 'read(base:  DN; alist SET OF AttributeType):  SET OF Attribute;

    '
- title: '{'
  contents:
  - "{\n        -- mapped onto Directory Read\n        -- Types repeated to deal with\
    \ multiple values\n        -- This would be implemented by returning selected\
    \ info\n        -- with the search operation\n"
- title: '}'
  contents:
  - '}

    '
- title: 'dNSelect(s:  String; dlist SET OF DN;'
  contents:
  - "dNSelect(s:  String; dlist SET OF DN;\n                     alist:  SET OF AttributeType):16SET0OF\
    \ DN\n"
- title: '{'
  contents:
  - "{\n        exact, good:  SET OF DN;\n        FOR x IN dlist DO\n            \
    \    IF last(DN).Value == s THEN\n                        exact += x;\n      \
    \          ELSE IF FOR y IN read(x, alist) DO\n                        IF y.value\
    \ == s THEN\n                                good += x;\n        IF exact != NULL\
    \ THEN return(exact);\n        IF good != NULL THEN return(good);\n        return(userQuery(dlist));\n"
- title: '}'
  contents:
  - '}

    '
- title: 'userQuery(dlist SET OF DN): SET OF DN'
  contents:
  - 'userQuery(dlist SET OF DN): SET OF DN

    '
- title: '{'
  contents:
  - "{\n        -- pass back up for manual checking\n        -- user can strip all\
    \ matches to force progres....\n"
- title: '}'
  contents:
  - '}

    '
- title: head()    -- return first element of list
  contents:
  - 'head()    -- return first element of list

    '
- title: tail()    -- return list with first element removed
  contents:
  - 'tail()    -- return list with first element removed

    '
- title: length()  -- return size of list
  contents:
  - 'length()  -- return size of list

    '
- title: last()    -- return last element of list
  contents:
  - "last()    -- return last element of list\n                    Figure 2: Matching\
    \ Algorithm\n"
