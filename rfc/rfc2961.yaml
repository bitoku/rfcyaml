- title: __initial_text__
  contents:
  - '               RSVP Refresh Overhead Reduction Extensions

    '
- title: Status of this Memo
  contents:
  - "Status of this Memo\n   This document specifies an Internet standards track protocol\
    \ for the\n   Internet community, and requests discussion and suggestions for\n\
    \   improvements.  Please refer to the current edition of the \"Internet\n   Official\
    \ Protocol Standards\" (STD 1) for the standardization state\n   and status of\
    \ this protocol.  Distribution of this memo is unlimited.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (C) The Internet Society (2001).  All Rights Reserved.\n"
- title: Abstract
  contents:
  - "Abstract\n   This document describes a number of mechanisms that can be used\
    \ to\n   reduce processing overhead requirements of refresh messages,\n   eliminate\
    \ the state synchronization latency incurred when an RSVP\n   (Resource ReserVation\
    \ Protocol) message is lost and, when desired,\n   refreshing state without the\
    \ transmission of whole refresh messages.\n   The same extensions also support\
    \ reliable RSVP message delivery on a\n   per hop basis.  These extension present\
    \ no backwards compatibility\n   issues.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1      Introduction and Background ................................2\n\
    \   1.1    Trigger and Refresh Messages ...............................4\n   2\
    \      Refresh-Reduction-Capable Bit ..............................4\n   3   \
    \   RSVP Bundle Message ........................................5\n   3.1    Bundle\
    \ Header ..............................................5\n   3.2    Message Formats\
    \ ............................................6\n   3.3    Sending RSVP Bundle\
    \ Messages ...............................7\n   3.4    Receiving RSVP Bundle Messages\
    \ .............................8\n   4      MESSAGE_ID Extension .......................................8\n\
    \   4.1    Modification of Standard Message Formats ...................9\n   4.2\
    \    MESSAGE_ID Objects ........................................10\n   4.3   \
    \ MESSAGE_ID_ACK and MESSAGE_ID_NACK Objects ................11\n   4.4    Ack\
    \ Message Format ........................................11\n   4.5    MESSAGE_ID\
    \ Object Usage ...................................12\n   4.6    MESSAGE_ID_ACK\
    \ Object and MESSAGE_ID_NACK Object Usage ....14\n   4.7    Multicast Considerations\
    \ ..................................15\n   4.7.1  Reference RSVP/Routing Interface\
    \ ..........................16\n   4.8    Compatibility .............................................16\n\
    \   5      Summary Refresh Extension .................................17\n   5.1\
    \    MESSAGE_ID LIST, SRC_LIST and MCAST_LIST Objects ..........18\n   5.2   \
    \ Srefresh Message Format ...................................24\n   5.3    Srefresh\
    \ Message Usage ....................................25\n   5.4    Srefresh NACK\
    \ .............................................28\n   5.5    Preserving RSVP Soft\
    \ State ................................28\n   5.6    Compatibility .............................................29\n\
    \   6      Exponential Back-Off Procedures ...........................29\n   6.1\
    \    Outline of Operation ......................................30\n   6.2   \
    \ Time Parameters ...........................................30\n   6.3    Retransmission\
    \ Algorithm ..................................31\n   6.4    Performance Considerations\
    \ ................................31\n   7      Acknowledgments ...........................................31\n\
    \   8      Security Considerations ...................................32\n   9\
    \      References ................................................32\n   10  \
    \   Authors' Addresses ........................................33\n   11     Full\
    \ Copyright Statement...................................34\n"
- title: 1. Introduction and Background
  contents:
  - "1. Introduction and Background\n   Standard RSVP [RFC2205] maintains state via\
    \ the generation of RSVP\n   refresh messages.  Refresh messages are used to both\
    \ synchronize\n   state between RSVP neighbors and to recover from lost RSVP messages.\n\
    \   The use of Refresh messages to cover many possible failures has\n   resulted\
    \ in a number of operational problems.  One problem relates to\n   scaling, another\
    \ relates to the reliability and latency of RSVP\n   Signaling.\n   The scaling\
    \ problems are linked to the resource requirements (in\n   terms of processing\
    \ and memory) of running RSVP.  The resource\n   requirements increase proportionally\
    \ with the number of sessions.\n   Each session requires the generation, transmission,\
    \ reception and\n   processing of RSVP Path and Resv messages per refresh period.\n\
    \   Supporting a large number of sessions, and the corresponding volume\n   of\
    \ refresh messages, presents a scaling problem.\n   The reliability and latency\
    \ problem occurs when a non-refresh RSVP\n   message is lost in transmission.\
    \  Standard RSVP [RFC2205] recovers\n   from a lost message via RSVP refresh messages.\
    \  In the face of\n   transmission loss of RSVP messages, the end-to-end latency\
    \ of RSVP\n   signaling is tied to the refresh interval of the node(s) experiencing\n\
    \   the loss.  When end-to-end signaling is limited by the refresh\n   interval,\
    \ the delay incurred in the establishment or the change of a\n   reservation may\
    \ be beyond the range of what is acceptable for some\n   applications.\n   One\
    \ way to address the refresh volume problem is to increase the\n   refresh period,\
    \ \"R\" as defined in Section 3.7 of [RFC2205].\n   Increasing the value of R\
    \ provides linear improvement on transmission\n   overhead, but at the cost of\
    \ increasing the time it takes to\n   synchronize state.\n   One way to address\
    \ the reliability and latency of RSVP Signaling is\n   to decrease the refresh\
    \ period R.  Decreasing the value of R\n   increases the probability that state\
    \ will be installed in the face of\n   message loss, but at the cost of increasing\
    \ refresh message rate and\n   associated processing requirements.\n   An additional\
    \ issue is the time to deallocate resources after a tear\n   message is lost.\
    \  RSVP does not retransmit ResvTear or PathTear\n   messages.  If the sole tear\
    \ message transmitted is lost, then\n   resources will only be deallocated once\
    \ the \"cleanup timer\" interval\n   has passed.  This may result in resources\
    \ being allocated for an\n   unnecessary period of time.  Note that even when\
    \ the refresh period\n   is adjusted, the \"cleanup timer\" must still expire\
    \ since tear\n   messages are not retransmitted.\n   The extensions defined in\
    \ this document address both the refresh\n   volume and the reliability issues\
    \ with mechanisms other than\n   adjusting refresh rate.  The extensions are collectively\
    \ referred to\n   as the \"Refresh Overhead Reduction\" or the \"Refresh Reduction\"\
    \n   extensions.  A Bundle message is defined to reduce overall message\n   handling\
    \ load.  A MESSAGE_ID object is defined to reduce refresh\n   message processing\
    \ by allowing the receiver to more readily identify\n   an unchanged message.\
    \  A MESSAGE_ACK object is defined which can be\n   used to detect message loss\
    \ and support reliable RSVP message\n   delivery on a per hop basis.  A summary\
    \ refresh message is defined to\n   enable refreshing state without the transmission\
    \ of whole refresh\n   messages, while maintaining RSVP's ability to indicate\
    \ when state is\n   lost and to adjust to changes in routing.\n   The key words\
    \ \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\"\
    , \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this\n   document\
    \ are to be interpreted as described in [RFC2119].\n"
- title: 1.1. Trigger and Refresh Messages
  contents:
  - "1.1. Trigger and Refresh Messages\n   This document categorizes RSVP messages\
    \ into two types: trigger and\n   refresh messages.  Trigger messages are those\
    \ RSVP messages that\n   advertise state or any other information not previously\
    \ transmitted.\n   Trigger messages include messages advertising new state, a\
    \ route\n   change that alters a reservation path, or a modification to an\n \
    \  existing RSVP session or reservation.  Trigger messages also include\n   those\
    \ messages that include changes in non-RSVP processed objects,\n   such as changes\
    \ in the Policy or ADSPEC objects.\n   Refresh messages represent previously advertised\
    \ state and contain\n   exactly the same objects and same information as a previously\n\
    \   transmitted message, and are sent over the same path.  Only Path and\n   Resv\
    \ messages can be refresh messages.  Refresh messages are\n   identical to the\
    \ corresponding previously transmitted message, with\n   some possible exceptions.\
    \  Specifically, the checksum field, the\n   flags field and the INTEGRITY object\
    \ may differ in refresh messages.\n"
- title: 2. Refresh-Reduction-Capable Bit
  contents:
  - "2. Refresh-Reduction-Capable Bit\n   To indicate support for the refresh overhead\
    \ reduction extensions, an\n   additional capability bit is added to the common\
    \ RSVP header, which\n   is defined in [RFC2205].\n       0                  \
    \ 1                   2                   3\n       0 1 2 3 4 5 6 7 8 9 0 1 2\
    \ 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |  Vers | Flags |   Msg Type    |         RSVP Checksum         |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |\
    \   Send_TTL    |  (Reserved)   |         RSVP Length           |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      Flags: 4 bits\n         0x01: Refresh (overhead) reduction capable\n  \
    \         When set, indicates that this node is willing and capable of\n     \
    \      receiving all the messages and objects described in this\n           document.\
    \  This includes the Bundle message described in\n           Section 3, the MESSAGE_ID\
    \ objects and Ack messages described\n           in Section 4, and the MESSAGE_ID\
    \ LIST objects and Srefresh\n           message described in Section 5.  This\
    \ bit is meaningful only\n           between RSVP neighbors.\n   Nodes supporting\
    \ the refresh overhead reduction extensions must also\n   take care to recognize\
    \ when a next hop stops sending RSVP messages\n   with the Refresh-Reduction-Capable\
    \ bit set.  To cover this case,\n   nodes supporting the refresh overhead reduction\
    \ extensions MUST\n   examine the flags field of each received RSVP message. \
    \ If the flag\n   changes from indicating support to indicating non-support then,\n\
    \   unless configured otherwise, Srefresh messages (described in Section\n   5)\
    \ MUST NOT be used for subsequent state refreshes to that neighbor\n   and Bundle\
    \ messages (Section 3) MUST NOT be sent to that neighbor.\n   Note, a node that\
    \ supports reliable RSVP message delivery (Section 4)\n   but not Bundle and Srefresh\
    \ messages, will not set the Refresh-\n   Reduction-Capable bit.\n"
- title: 3. RSVP Bundle Message
  contents:
  - "3. RSVP Bundle Message\n   An RSVP Bundle message consists of a bundle header\
    \ followed by a body\n   consisting of a variable number of standard RSVP messages.\
    \  A Bundle\n   message is used to aggregate multiple RSVP messages within a single\n\
    \   PDU.  The term \"bundling\" is used to avoid confusion with RSVP\n   reservation\
    \ aggregation.  The following subsections define the\n   formats of the bundle\
    \ header and the rules for including standard\n   RSVP messages as part of the\
    \ message.\n"
- title: 3.1. Bundle Header
  contents:
  - "3.1. Bundle Header\n       0                   1                   2        \
    \           3\n       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7\
    \ 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      | Vers  | Flags |   Msg type    |         RSVP checksum         |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |\
    \   Send_TTL    |  (Reserved)   |         RSVP length           |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      The format of the bundle header is identical to the format of the\n   \
    \   RSVP common header [RFC2205].  The fields in the header are as\n      follows:\n\
    \      Vers: 4 bits\n         Protocol version number.  This is version 1.\n \
    \     Flags: 4 bits\n         0x01: Refresh (overhead) reduction capable\n   \
    \        See Section 2.\n         0x02-0x08: Reserved\n      Msg type: 8 bits\n\
    \         12 = Bundle\n      RSVP checksum: 16 bits\n         The one's complement\
    \ of the one's complement sum of the entire\n         message, with the checksum\
    \ field replaced by zero for the\n         purpose of computing the checksum.\
    \  An all-zero value means\n         that no checksum was transmitted.  Because\
    \ individual sub-\n         messages may carry their own checksum as well as the\
    \ INTEGRITY\n         object for authentication, this field MAY be set to zero.\
    \  Note\n         that when the checksum is not computed, the header of the\n\
    \         bundle message will not be covered by any checksum.  If the\n      \
    \   checksum is computed, individual sub-messages MAY set their own\n        \
    \ checksum to zero.\n      Send_TTL: 8 bits\n         The IP TTL value with which\
    \ the message was sent.  This is used\n         by RSVP to detect a non-RSVP hop\
    \ by comparing the Send_TTL with\n         the IP TTL in a received message.\n\
    \      RSVP length: 16 bits\n         The total length of this RSVP Bundle message\
    \ in bytes,\n         including the bundle header and the sub-messages that follow.\n"
- title: 3.2. Message Formats
  contents:
  - "3.2. Message Formats\n   An RSVP Bundle message must contain at least one sub-message.\
    \  A\n   sub-message MAY be any message type except for another Bundle\n   message.\n\
    \       0                   1                   2                   3\n      \
    \ 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      | Vers  | Flags |      12       |         RSVP checksum         |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |\
    \   Send_TTL    |  (Reserved)   |         RSVP length           |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |                                                               |\n   \
    \   //                   First sub-message                         //\n      |\
    \                                                               |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |                                                               |\n   \
    \   //                   More sub-messages..                       //\n      |\
    \                                                               |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n"
- title: 3.3. Sending RSVP Bundle Messages
  contents:
  - "3.3. Sending RSVP Bundle Messages\n   Support for RSVP Bundle messages is optional.\
    \  While message bundling\n   helps in scaling RSVP, by reducing processing overhead\
    \ and bandwidth\n   consumption, a node is not required to transmit every standard\
    \ RSVP\n   message in a Bundle message.  A node MUST always be ready to receive\n\
    \   standard RSVP messages.\n   RSVP Bundle messages can only be sent to RSVP\
    \ neighbors that support\n   bundling.  Methods for discovering such information\
    \ include: (1)\n   manual configuration and (2) observing the Refresh-Reduction-Capable\n\
    \   bit (see Section 2) in the received RSVP messages.  RSVP Bundle\n   messages\
    \ MUST NOT be used if the RSVP neighbor does not support RSVP\n   Bundle messages.\n\
    \   RSVP Bundle messages are sent hop by hop between RSVP-capable nodes\n   as\
    \ \"raw\" IP datagrams with protocol number 46.  The IP source address\n   is\
    \ an address local to the system that originated the Bundle message.\n   The IP\
    \ destination address is the RSVP neighbor for which the sub-\n   messages are\
    \ intended.\n   RSVP Bundle messages SHOULD NOT be sent with the Router Alert\
    \ IP\n   option in their IP headers.  This is because Bundle messages are\n  \
    \ addressed directly to RSVP neighbors.\n   Each RSVP Bundle message MUST occupy\
    \ exactly one IP datagram, which\n   is approximately 64K bytes.  If it exceeds\
    \ the MTU, the datagram is\n   fragmented by IP and reassembled at the recipient\
    \ node.\n   Implementations may choose to limit each RSVP Bundle message to the\n\
    \   MTU size of the outgoing link, e.g., 1500 bytes.  Implementations\n   SHOULD\
    \ also limit the amount of time that a message is delayed in\n   order to be bundled.\
    \  Different limits may be used for trigger and\n   standard refresh messages.\
    \  Trigger messages SHOULD be delayed a\n   minimal amount of time.  Refresh messages\
    \ may be delayed up to their\n   refresh interval.  Note that messages related\
    \ to the same Resv or\n   Path state should not be delayed at different intervals\
    \ in order to\n   preserve ordering.\n   If the RSVP neighbor is not known or\
    \ changes in next hops cannot be\n   identified via routing, Bundle messages MUST\
    \ NOT be used.  Note that\n   when the routing next hop is not RSVP capable it\
    \ will typically not\n   be possible to identify changes in next hop.\n   Any\
    \ message that will be handled by the RSVP neighbor indicated in a\n   Bundle\
    \ Message's destination address may be included in the same\n   message.  This\
    \ includes all RSVP messages that would be sent out a\n   point-to-point link.\
    \  It includes any message, such as a Resv,\n   addressed to the same destination\
    \ address.  It also includes Path and\n   PathTear messages when the next hop\
    \ is known to be the destination\n   and changes in next hops can be detected.\
    \  Path and PathTear messages\n   for multicast sessions MUST NOT be sent in Bundle\
    \ messages when the\n   outgoing link is not a point-to-point link or when the\
    \ next hop does\n   not support the refresh overhead reduction extensions.\n"
- title: 3.4. Receiving RSVP Bundle Messages
  contents:
  - "3.4. Receiving RSVP Bundle Messages\n   If the local system does not recognize\
    \ or does not wish to accept a\n   Bundle message, the received messages shall\
    \ be discarded without\n   further analysis.\n   The receiver next compares the\
    \ Send_TTL with which a Bundle message\n   is sent to the IP TTL with which it\
    \ is received.  If a non-RSVP hop\n   is detected, the number of non-RSVP hops\
    \ is recorded.  It is used\n   later in processing of sub-messages.\n   Next,\
    \ the receiver verifies the version number and checksum of the\n   RSVP Bundle\
    \ message and discards the message if any mismatch is\n   found.\n   The receiver\
    \ then starts decapsulating individual sub-messages.  Each\n   sub-message has\
    \ its own complete message length and authentication\n   information.  With the\
    \ exception of using the Send_TTL from the\n   header of the Bundle message, each\
    \ sub-message is processed as if it\n   was received individually.\n"
- title: 4. MESSAGE_ID Extension
  contents:
  - "4. MESSAGE_ID Extension\n   Three new objects are defined as part of the MESSAGE_ID\
    \ extension.\n   The objects are the MESSAGE_ID object, the MESSAGE_ID_ACK object,\
    \ and\n   the MESSAGE_ID_NACK objects.  The first two objects are used to\n  \
    \ support acknowledgments and reliable RSVP message delivery.  The last\n   object\
    \ is used to support the summary refresh extension described in\n   Section 5.\
    \  The MESSAGE_ID object can also be used to simply provide\n   a shorthand indication\
    \ of when the message carrying the object is a\n   refresh message.  Such information\
    \ can be used by the receiving node\n   to reduce refresh processing requirements.\n\
    \   Message identification and acknowledgment is done on a per hop basis.\n  \
    \ All types of MESSAGE_ID objects contain a message identifier.  The\n   identifier\
    \ MUST be unique on a per object generator's IP address\n   basis.  No more than\
    \ one MESSAGE_ID object may be included in an RSVP\n   message.  Each message\
    \ containing a MESSAGE_ID object may be\n   acknowledged via a MESSAGE_ID_ACK\
    \ object, when so indicated.\n   MESSAGE_ID_ACK and MESSAGE_ID_NACK objects may\
    \ be sent piggy-backed\n   in unrelated RSVP messages or in RSVP Ack messages.\
    \  RSVP messages\n   carrying any of the three object types may be included in\
    \ a bundle\n   message.  When included, each object is treated as if it were\n\
    \   contained in a standard, non-bundled, RSVP message.\n"
- title: 4.1. Modification of Standard Message Formats
  contents:
  - "4.1. Modification of Standard Message Formats\n   The MESSAGE_ID, MESSAGE_ID_ACK\
    \ and MESSAGE_ID_NACK objects may be\n   included in the standard RSVP messages,\
    \ as defined in [RFC2205].\n   When included, one or more MESSAGE_ID_ACK or MESSAGE_ID_NACK\
    \ objects\n   MUST immediately follow the INTEGRITY object.  When no INTEGRITY\n\
    \   object is present, the MESSAGE_ID_ACK or MESSAGE_ID_NACK objects MUST\n  \
    \ immediately follow the message or sub-message header.  Only one\n   MESSAGE_ID\
    \ object MAY be included in a message or sub-message and it\n   MUST follow any\
    \ present MESSAGE_ID_ACK or MESSAGE_ID_NACK objects.\n   When no MESSAGE_ID_ACK\
    \ or MESSAGE_ID_NACK objects are present, the\n   MESSAGE_ID object MUST immediately\
    \ follow the INTEGRITY object.  When\n   no INTEGRITY object is present, the MESSAGE_ID\
    \ object MUST\n   immediately follow the message or sub-message header.\n   The\
    \ ordering of the ACK objects for all standard RSVP messages is:\n   <Common Header>\
    \  [ <INTEGRITY> ]\n                    [ [<MESSAGE_ID_ACK> | <MESSAGE_ID_NACK>]\
    \ ... ]\n                    [ <MESSAGE_ID> ]\n"
- title: 4.2. MESSAGE_ID Objects
  contents:
  - "4.2. MESSAGE_ID Objects\n   MESSAGE_ID Class = 23\n   MESSAGE_ID object\n   \
    \   Class = MESSAGE_ID Class, C_Type = 1\n       0                   1       \
    \            2                   3\n       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7\
    \ 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |     Flags     |                      Epoch                    |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |\
    \                       Message_Identifier                      |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      Flags: 8 bits\n         0x01 = ACK_Desired flag\n           Indicates that\
    \ the sender requests the receiver to send an\n           acknowledgment for the\
    \ message.\n      Epoch: 24 bits\n         A value that indicates when the Message_Identifier\
    \ sequence has\n         reset.  SHOULD be randomly generated each time a node\
    \ reboots\n         or the RSVP agent is restarted.  The value SHOULD NOT be the\n\
    \         same as was used when the node was last operational.  This\n       \
    \  value MUST NOT be changed during normal operation.\n      Message_Identifier:\
    \ 32 bits\n         When combined with the message generator's IP address, the\n\
    \         Message_Identifier field uniquely identifies a message.  The\n     \
    \    values placed in this field change incrementally and only\n         decrease\
    \ when the Epoch changes or when the value wraps.\n"
- title: 4.3. MESSAGE_ID_ACK and MESSAGE_ID_NACK Objects
  contents:
  - "4.3. MESSAGE_ID_ACK and MESSAGE_ID_NACK Objects\n   MESSAGE_ID_ACK Class = 24\n\
    \   MESSAGE_ID_ACK object\n      Class = MESSAGE_ID_ACK Class, C_Type = 1\n  \
    \     0                   1                   2                   3\n       0\
    \ 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |     Flags     |                      Epoch                    |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |\
    \                       Message_Identifier                      |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      Flags: 8 bits\n         No flags are currently defined.  This field MUST\
    \ be zero on\n         transmission and ignored on receipt.\n      Epoch: 24 bits\n\
    \         The Epoch field copied from the message being acknowledged.\n      Message_Identifier:\
    \ 32 bits\n         The Message_Identifier field copied from the message being\n\
    \         acknowledged.\n   MESSAGE_ID_NACK object\n      Class = MESSAGE_ID_ACK\
    \ Class, C_Type = 2\n         Definition is the same as the MESSAGE_ID_ACK object.\n"
- title: 4.4. Ack Message Format
  contents:
  - "4.4. Ack Message Format\n   Ack messages carry one or more MESSAGE_ID_ACK or\
    \ MESSAGE_ID_NACK\n   objects.  They MUST NOT contain any MESSAGE_ID objects.\
    \  Ack messages\n   are sent between neighboring RSVP nodes.  The IP destination\
    \ address\n   of an Ack message is the unicast address of the node that generated\n\
    \   the message(s) being acknowledged.  For messages with RSVP_HOP\n   objects,\
    \ such as Path and Resv messages, the address is found in the\n   RSVP_HOP object.\
    \  For other messages, such as ResvConf, the\n   associated IP address is the\
    \ source address in the IP header.  The IP\n   source address is an address of\
    \ the node that sends the Ack message.\n   The Ack message format is as follows:\n\
    \     <ACK Message> ::= <Common Header> [ <INTEGRITY> ]\n                    \
    \   <MESSAGE_ID_ACK> | <MESSAGE_ID_NACK>\n                       [ [<MESSAGE_ID_ACK>\
    \ | <MESSAGE_ID_NACK>] ... ]\n     For Ack messages, the Msg Type field of the\
    \ Common Header MUST be\n     set to 13.\n     Section 4.6 provides guidance on\
    \ when an Ack message should be used\n     and when MESSAGE_ID objects should\
    \ be sent piggy-backed in other\n     RSVP messages.\n"
- title: 4.5. MESSAGE_ID Object Usage
  contents:
  - "4.5. MESSAGE_ID Object Usage\n   The MESSAGE_ID object may be included in any\
    \ RSVP message other than\n   the Ack and Bundle messages.  The MESSAGE_ID object\
    \ is always\n   generated and processed over a single hop between RSVP neighbors.\n\
    \   The IP address of the object generator, i.e., the node that creates\n   the\
    \ object, is represented in a per RSVP message type specific\n   fashion.  For\
    \ messages with RSVP_HOP objects, such as Path and Resv\n   messages, the generator's\
    \ IP address is found in the RSVP_HOP object.\n   For other messages, such as\
    \ ResvConf message, the generator's IP\n   address is the source address in the\
    \ IP header.  Note that MESSAGE_ID\n   objects can only be used in a Bundle sub-messages,\
    \ but not in a\n   Bundle message.  As is always the case with the Bundle message,\
    \ each\n   sub-message is processed as if it was received individually.  This\n\
    \   includes processing of MESSAGE_ID objects.\n   The Epoch field contains a\
    \ generator selected value.  The value is\n   used to indicate when the sender\
    \ resets the values used in the\n   Message_Identifier field.  On startup, a node\
    \ SHOULD randomly select\n   a value to be used in the Epoch field.  The node\
    \ SHOULD ensure that\n   the selected value is not the same as was used when the\
    \ node was last\n   operational.  The value MUST NOT be changed unless the node\
    \ or the\n   RSVP agent is restarted.\n   The Message_Identifier field contains\
    \ a generator selected value.\n   This value, when combined with the generator's\
    \ IP address, identifies\n   a particular RSVP message and the specific state\
    \ information it\n   represents.  The combination of Message_Identifier and Epoch\
    \ can also\n   be used to detect out of order messages.  When a node is sending\
    \ a\n   refresh message with a MESSAGE_ID object, it SHOULD use the same\n   Message_Identifier\
    \ value that was used in the RSVP message that first\n   advertised the state\
    \ being refreshed.  When a node is sending a\n   trigger message, the Message_Identifier\
    \ value MUST have a value that\n   is greater than any other value previously\
    \ used with the same Epoch\n   field value.  A value is considered to have been\
    \ used when it has\n   been sent in any message using the associated IP address\
    \ with the\n   same Epoch field value.\n   The ACK_Desired flag is set when the\
    \ MESSAGE_ID object generator\n   wants a MESSAGE_ID_ACK object sent in response\
    \ to the message.  Such\n   information can be used to ensure reliable delivery\
    \ of RSVP messages\n   in the face of network loss.  Nodes setting the ACK_Desired\
    \ flag\n   SHOULD retransmit unacknowledged messages at a more rapid interval\n\
    \   than the standard refresh period until the message is acknowledged or\n  \
    \ until a \"rapid\" retry limit is reached.  Rapid retransmission rate\n   MUST\
    \ be based on the exponential exponential back-off procedures\n   defined in section\
    \ 6.  The ACK_Desired flag will typically be set\n   only in trigger messages.\
    \  The ACK_Desired flag MAY be set in refresh\n   messages.  Issues relate to\
    \ multicast sessions are covered in a later\n   section.\n   Nodes processing\
    \ incoming MESSAGE_ID objects SHOULD check to see if a\n   newly received message\
    \ is out of order and can be ignored.  Out of\n   order messages SHOULD be ignored,\
    \ i.e., silently dropped.  Out of\n   order messages can be identified by examining\
    \ the values in the Epoch\n   and Message_Identifier fields.  To determine ordering,\
    \ the received\n   Epoch value must match the value previously received from the\
    \ message\n   sender.  If the values differ then the receiver MUST NOT treat the\n\
    \   message as out of order.  When the Epoch values match and the\n   Message_Identifier\
    \ value is less than the largest value previously\n   received from the sender,\
    \ then the receiver SHOULD check the value\n   previously received for the state\
    \ associated with the message.  This\n   check should be performed for any message\
    \ that installs or changes\n   state.  (Includes at least: Path, Resv, PathTear,\
    \ ResvTear, PathErr\n   and ResvErr.)  If no local state information can be associated\
    \ with\n   the message, the receiver MUST NOT treat the message as out of order.\n\
    \   If local state can be associated with the message and the received\n   Message_Identifier\
    \ value is less than the most recently received\n   value associated with the\
    \ state, the message SHOULD be treated as\n   being out of order.\n   Note that\
    \ the 32-bit Message_Identifier value MAY wrap.  To cover the\n   wrap case, the\
    \ following expression may be used to test if a newly\n   received Message_Identifier\
    \ value is less than a previously received\n   value:\n       if ((int) old_id\
    \ - (int) new_id > 0) {\n          new value is less than old value;\n       }\n\
    \   MESSAGE_ID objects of messages that are not out of order SHOULD be\n   used\
    \ to aid in determining if the message represents new state or a\n   state refresh.\
    \  Note that state is only refreshed in Path and Resv\n   messages.  If the received\
    \ Epoch values differs from the value\n   previously received from the message\
    \ sender, the message is a trigger\n   message and the receiver MUST fully process\
    \ the message.  If a Path\n   or Resv message contains the same Message_Identifier\
    \ value that was\n   used in the most recently received message for the same session\
    \ and,\n   for Path messages, SENDER_TEMPLATE then the receiver SHOULD treat the\n\
    \   message as a state refresh.  If the Message_Identifier value is\n   greater\
    \ than the most recently received value, the receiver MUST\n   fully processes\
    \ the message.  When fully processing a Path or Resv\n   message, the receiver\
    \ MUST store the received Message_Identifier\n   value as part of the local Path\
    \ or Resv state for future reference.\n   Nodes receiving a non-out of order message\
    \ containing a MESSAGE_ID\n   object with the ACK_Desired flag set, SHOULD respond\
    \ with a\n   MESSAGE_ID_ACK object.  Note that MESSAGE_ID objects received in\n\
    \   messages containing errors, i.e., are not syntactically valid,  MUST\n   NOT\
    \ be acknowledged.  PathErr and ResvErr messages SHOULD be treated\n   as implicit\
    \ acknowledgments.\n"
- title: 4.6. MESSAGE_ID_ACK Object and MESSAGE_ID_NACK Object Usage
  contents:
  - "4.6. MESSAGE_ID_ACK Object and MESSAGE_ID_NACK Object Usage\n   The MESSAGE_ID_ACK\
    \ object is used to acknowledge receipt of messages\n   containing MESSAGE_ID\
    \ objects that were sent with the ACK_Desired\n   flag set.  A MESSAGE_ID_ACK\
    \ object MUST NOT be generated in response\n   to a received MESSAGE_ID object\
    \ when the ACK_Desired flag is not set.\n   The MESSAGE_ID_NACK object is used\
    \ as part of the summary refresh\n   extension.  The generation and processing\
    \ of MESSAGE_ID_NACK objects\n   is described in further detail in Section 5.4.\n\
    \   MESSAGE_ID_ACK and MESSAGE_ID_NACK objects MAY be sent in any RSVP\n   message\
    \ that has an IP destination address matching the generator of\n   the associated\
    \ MESSAGE_ID object.  This means that the objects will\n   not typically be included\
    \ in the non hop-by-hop Path, PathTear and\n   ResvConf messages.  When no appropriate\
    \ message is available, one or\n   more objects SHOULD be sent in an Ack message.\
    \  Implementations\n   SHOULD include MESSAGE_ID_ACK and MESSAGE_ID_NACK objects\
    \ in standard\n   RSVP messages when possible.\n   Implementations SHOULD limit\
    \ the amount of time that an object is\n   delayed in order to be piggy-backed\
    \ or sent in an Ack message.\n   Different limits may be used for MESSAGE_ID_ACK\
    \ and MESSAGE_ID_NACK\n   objects.  MESSAGE_ID_ACK objects are used to detect\
    \ link transmission\n   losses.  If an ACK object is delayed too long, the corresponding\n\
    \   message will be retransmitted.  To avoid such retransmission, ACK\n   objects\
    \ SHOULD be delayed a minimal amount of time.  A delay time\n   equal to the link\
    \ transit time MAY be used.  MESSAGE_ID_NACK objects\n   may be delayed an independent\
    \ and longer time, although additional\n   delay increases the amount of time\
    \ a desired reservation is not\n   installed.\n"
- title: 4.7. Multicast Considerations
  contents:
  - "4.7. Multicast Considerations\n   Path and PathTear messages may be sent to IP\
    \ multicast destination\n   addresses.  When the destination is a multicast address,\
    \ it is\n   possible that a single message containing a single MESSAGE_ID object\n\
    \   will be received by multiple RSVP next hops.  When the ACK_Desired\n   flag\
    \ is set in this case, acknowledgment processing is more complex.\n   There are\
    \ a number of issues to be addressed including ACK implosion,\n   number of acknowledgments\
    \ to be expected and handling of new\n   receivers.\n   ACK implosion occurs when\
    \ each receiver responds to the MESSAGE_ID\n   object at approximately the same\
    \ time.  This can lead to a\n   potentially large number of MESSAGE_ID_ACK objects\
    \ being\n   simultaneously delivered to the message generator.  To address this\n\
    \   case, the receiver MUST wait a random interval prior to acknowledging\n  \
    \ a MESSAGE_ID object received in a message destined to a multicast\n   address.\
    \  The random interval SHOULD be between zero (0) and a\n   configured maximum\
    \ time.  The configured maximum SHOULD be set in\n   proportion to the refresh\
    \ and \"rapid\" retransmission interval, i.e,\n   such that the maximum time before\
    \ sending an acknowledgment does not\n   result in retransmission.  It should\
    \ be noted that ACK implosion is\n   being addressed by spreading acknowledgments\
    \ out in time, not by ACK\n   suppression.\n   A more fundamental issue is the\
    \ number of acknowledgments that the\n   upstream node, i.e., the message generator,\
    \ should expect.  The\n   number of acknowledgments that should be expected is\
    \ the same as the\n   number of RSVP next hops.  In the router-to-router case,\
    \ the number\n   of next hops can often be obtained from routing.  When hosts\
    \ are\n   either the upstream node or the next hops, the number of next hops\n\
    \   will typically not be readily available.  Another case where the\n   number\
    \ of RSVP next hops will typically not be known is when there\n   are non-RSVP\
    \ routers between the message generator and the RSVP next\n   hops.\n   When the\
    \ number of next hops is not known, the message generator\n   SHOULD only expect\
    \ a single response.  The result of this behavior\n   will be special retransmission\
    \ handling until the message is\n   delivered to at least one next hop, then followed\
    \ by standard RSVP\n   refreshes.  Refresh messages will synchronize state with\
    \ any next\n   hops that don't receive the original message.\n"
- title: 4.7.1. Reference RSVP/Routing Interface
  contents:
  - "4.7.1. Reference RSVP/Routing Interface\n   When using the MESSAGE_ID extension\
    \ with multicast sessions it is\n   preferable for RSVP to obtain the number of\
    \ next hops from routing\n   and to be notified when that number changes.  The\
    \ interface between\n   routing and RSVP is purely an implementation issue.  Since\
    \ RSVP\n   [RFC2205] describes a reference routing interface, a version of the\n\
    \   RSVP/routing interface updated to provide number of next hop\n   information\
    \ is presented.  See [RFC2205] for previously defined\n   parameters and function\
    \ description.\n      o    Route Query\n           Mcast_Route_Query( [ SrcAddress,\
    \ ] DestAddress,\n                              Notify_flag )\n              \
    \                -> [ IncInterface, ] OutInterface_list,\n                   \
    \           NHops_list\n      o    Route Change Notification\n           Mcast_Route_Change(\
    \ ) -> [ SrcAddress, ] DestAddress,\n                             [ IncInterface,\
    \ ] OutInterface_list,\n                             NHops_list\n      NHops_list\
    \ provides the number of multicast group members\n      reachable via each OutInterface_list\
    \ entry.\n"
- title: 4.8. Compatibility
  contents:
  - "4.8. Compatibility\n   All nodes sending messages with the Refresh-Reduction-Capable\
    \ bit set\n   will support the MESSAGE_ID Extension.  There are no backward\n\
    \   compatibility issues raised by the MESSAGE_ID Class with nodes that\n   do\
    \ not set the Refresh-Reduction-Capable bit.  The MESSAGE_ID Class\n   has an\
    \ assigned value whose form is 0bbbbbbb.  Per RSVP [RFC2205],\n   classes with\
    \ values of this form must be rejected with an \"Unknown\n   Object Class\" error\
    \ by nodes not supporting the class.  When the\n   receiver of a MESSAGE_ID object\
    \ does not support the class, a\n   corresponding error message will be generated.\
    \  The generator of the\n   MESSAGE_ID object will see the error and then MUST\
    \ re-send the\n   original message without the MESSAGE_ID object.  In this case,\
    \ the\n   message generator MAY still choose to retransmit messages at the\n \
    \  \"rapid\" retransmission interval.  Lastly, since the MESSAGE_ID_ACK\n   class\
    \ can only be issued in response to the MESSAGE_ID object, there\n   are no possible\
    \ issues with this class or Ack messages.  A node MAY\n   support the MESSAGE_ID\
    \ Extension without supporting the other refresh\n   overhead reduction extensions.\n"
- title: 5. Summary Refresh Extension
  contents:
  - "5. Summary Refresh Extension\n   The summary refresh extension enables the refreshing\
    \ of RSVP state\n   without the transmission of standard Path or Resv messages.\
    \  The\n   benefits of the described extension are that it reduces the amount\
    \ of\n   information that must be transmitted and processed in order to\n   maintain\
    \ RSVP state synchronization.  Importantly, the described\n   extension preserves\
    \ RSVP's ability to handle non-RSVP next hops and\n   to adjust to changes in\
    \ routing.  This extension cannot be used with\n   Path or Resv messages that\
    \ contain any change from previously\n   transmitted messages, i.e., are trigger\
    \ messages.\n   The summary refresh extension builds on the previously defined\n\
    \   MESSAGE_ID extension.  Only state that was previously advertised in\n   Path\
    \ and Resv messages containing MESSAGE_ID objects can be refreshed\n   via the\
    \ summary refresh extension.\n   The summary refresh extension uses the objects\
    \ and the ACK message\n   previously defined as part of the MESSAGE_ID extension,\
    \ and a new\n   Srefresh message.  The new message carries a list of\n   Message_Identifier\
    \ fields corresponding to the Path and Resv trigger\n   messages that established\
    \ the state.  The Message_Identifier fields\n   are carried in one of three Srefresh\
    \ related objects.  The three\n   objects are the MESSAGE_ID LIST object, the\
    \ MESSAGE_ID SRC_LIST\n   object, and the MESSAGE_ID MCAST_LIST object.\n   The\
    \ MESSAGE_ID LIST object is used to refresh all Resv state, and\n   Path state\
    \ of unicast sessions.  It is made up of a list of\n   Message_Identifier fields\
    \ that were originally advertised in\n   MESSAGE_ID objects.  The other two objects\
    \ are used to refresh Path\n   state of multicast sessions.  A node receiving\
    \ a summary refresh for\n   multicast path state will at times need source and\
    \ group information.\n   These two objects provide this information.  The objects\
    \ differ in\n   the information they contain and how they are sent.  Both carry\n\
    \   Message_Identifier fields and corresponding source IP addresses.  The\n  \
    \ MESSAGE_ID SRC_LIST is sent in messages addressed to the session's\n   multicast\
    \ IP address.  The MESSAGE_ID MCAST_LIST object adds the\n   group address and\
    \ is sent in messages addressed to the RSVP next hop.\n   The MESSAGE_ID MCAST_LIST\
    \ is normally used on point-to-point links.\n   An RSVP node receiving an Srefresh\
    \ message, matches each listed\n   Message_Identifier field with installed Path\
    \ or Resv state.  All\n   matching state is updated as if a normal RSVP refresh\
    \ message has\n   been received.  If matching state cannot be found, then the\
    \ Srefresh\n   message sender is notified via a refresh NACK.\n   A refresh NACK\
    \ is sent via the MESSAGE_ID_NACK object.  As described\n   in the previous section,\
    \ the rules for sending a MESSAGE_ID_NACK\n   object are the same as for sending\
    \ a MESSAGE_ID_ACK object.  This\n   includes sending MESSAGE_ID_NACK object both\
    \ piggy-backed in\n   unrelated RSVP messages or in RSVP ACK messages.\n"
- title: 5.1. MESSAGE_ID LIST, SRC_LIST and MCAST_LIST Objects
  contents:
  - "5.1. MESSAGE_ID LIST, SRC_LIST and MCAST_LIST Objects\n   MESSAGE_ID LIST object\n\
    \   MESSAGE_ID_LIST Class = 25\n      Class = MESSAGE_ID_LIST Class, C_Type =\
    \ 1\n       0                   1                   2                   3\n  \
    \     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |     Flags     |                      Epoch                    |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |\
    \                       Message_Identifier                      |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |                                 :                             |\n   \
    \   //                                :                            //\n      |\
    \                                 :                             |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |                       Message_Identifier                      |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      Flags:\
    \ 8 bits\n         No flags are currently defined.  This field MUST be zero on\n\
    \         transmission and ignored on receipt.\n      Epoch: 24 bits\n       \
    \  The Epoch field from the MESSAGE_ID object corresponding to the\n         trigger\
    \ message that advertised the state being refreshed.\n      Message_Identifier:\
    \ 32 bits\n         The Message_Identifier field from the MESSAGE_ID object\n\
    \         corresponding to the trigger message that advertised the state\n   \
    \      being refreshed.  One or more Message_Identifiers may be\n         included.\n\
    \   IPv4/MESSAGE_ID SRC_LIST object\n      Class = MESSAGE_ID_LIST Class, C_Type\
    \ = 2\n       0                   1                   2                   3\n\
    \       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n    \
    \  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |\
    \     Flags     |                      Epoch                    |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |                              Source_                          |\n   \
    \   |                      Message_Identifier_Tuple                 |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |                                 :                             |\n   \
    \   //                                :                            //\n      |\
    \                                 :                             |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |                              Source_                          |\n   \
    \   |                      Message_Identifier_Tuple                 |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   Where a Source_Message_Identifier_Tuple consists of:\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |                        Message_Identifier                     |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |\
    \                    Source_IP_Address (4 bytes)                |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   IPv6/MESSAGE_ID SRC_LIST object\n      Class = MESSAGE_ID_LIST Class, C_Type\
    \ = 3\n       0                   1                   2                   3\n\
    \       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n    \
    \  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |\
    \     Flags     |                      Epoch                    |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |                                                               |\n   \
    \   |                            IPv6_Source_                       |\n      |\
    \                      Message_Identifier_Tuple                 |\n      |   \
    \                                                            |\n      |      \
    \                                                         |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |                                 :                             |\n   \
    \   //                                :                            //\n      |\
    \                                 :                             |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |                                                               |\n   \
    \   |                            IPv6_Source_                       |\n      |\
    \                      Message_Identifier_Tuple                 |\n      |   \
    \                                                            |\n      |      \
    \                                                         |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   Where a IPv6 Source_Message_Identifier_Tuple consists of:\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |                        Message_Identifier                     |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |\
    \                                                               |\n      |   \
    \                   IPv6 Source_IP_Address                   |\n      |      \
    \                      (16 Bytes)                         |\n      |         \
    \                                                      |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      Flags: 8 bits\n         No flags are currently defined.  This field MUST\
    \ be zero on\n         transmission and ignored on receipt.\n      Epoch: 24 bits\n\
    \         The Epoch field from the MESSAGE_ID object corresponding to the\n  \
    \       trigger message that advertised the state being refreshed.\n      Message_Identifier\n\
    \         The Message_Identifier field from the MESSAGE_ID object\n         corresponding\
    \ to the trigger message that advertised the Path\n         state being refreshed.\
    \  One or more Message_Identifiers may be\n         included.  Each Message_Identifier\
    \ MUST be followed by the\n         source IP address corresponding to the sender\
    \ described in the\n         Path state being refreshed.\n      Source_IP_Address\n\
    \         The IP address corresponding to the sender of the Path state\n     \
    \    being refreshed.\n      IPv4/MESSAGE_ID MCAST_LIST object\n      Class =\
    \ MESSAGE_ID_LIST Class, C_Type = 4\n       0                   1            \
    \       2                   3\n       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9\
    \ 0 1 2 3 4 5 6 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |     Flags     |                      Epoch                    |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |\
    \                             Multicast_                        |\n      |   \
    \                     Message_Identifier_                    |\n      |      \
    \                         Tuple                           |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |                                 :                             |\n   \
    \   //                                :                            //\n      |\
    \                                 :                             |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |                             Multicast_                        |\n   \
    \   |                        Message_Identifier_                    |\n      |\
    \                               Tuple                           |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   Where a Multicast_Message_Identifier_Tuple consists of:\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |                        Message_Identifier                     |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |\
    \                    Source_IP_Address (4 bytes)                |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |                 Destination_IP_Address (4 bytes)              |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   IPv6/MESSAGE_ID\
    \ MCAST_LIST object\n      Class = MESSAGE_ID_LIST Class, C_Type = 5\n       0\
    \                   1                   2                   3\n       0 1 2 3\
    \ 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |     Flags     |                      Epoch                    |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |\
    \                                                               |\n      |   \
    \                                                            |\n      |      \
    \                                                         |\n      |         \
    \                  IPv6 Multicast_                     |\n      |            \
    \            Message_Identifier_                    |\n      |               \
    \                Tuple                           |\n      |                  \
    \                                             |\n      |                     \
    \                                          |\n      |                        \
    \                                       |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |                                 :                             |\n   \
    \   //                                :                            //\n      |\
    \                                 :                             |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |                                                               |\n   \
    \   |                                                               |\n      |\
    \                                                               |\n      |   \
    \                        IPv6 Multicast_                     |\n      |      \
    \                  Message_Identifier_                    |\n      |         \
    \                      Tuple                           |\n      |            \
    \                                                   |\n      |               \
    \                                                |\n      |                  \
    \                                             |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   Where a IPv6 Multicast_Message_Identifier_Tuple consists of:\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |                        Message_Identifier                     |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |\
    \                                                               |\n      |   \
    \                   IPv6 Source_IP_Address                   |\n      |      \
    \                      (16 Bytes)                         |\n      |         \
    \                                                      |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |                                                               |\n   \
    \   |                     IPv6 Destination_IP_Address               |\n      |\
    \                            (16 Bytes)                         |\n      |   \
    \                                                            |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      Flags: 8 bits\n         No flags are currently defined.  This field MUST\
    \ be zero on\n         transmission and ignored on receipt.\n      Epoch: 24 bits\n\
    \         The Epoch field from the MESSAGE_ID object corresponding to the\n  \
    \       trigger message that advertised the state being refreshed.\n      Message_Identifier:\
    \ 32 bits\n         The Message_Identifier field from the MESSAGE_ID object\n\
    \         corresponding to the trigger message that advertised the Path\n    \
    \     state being refreshed.  One or more Message_Identifiers may be\n       \
    \  included.  Each Message_Identifier MUST be followed by the\n         source\
    \ IP address corresponding to the sender of the Path state\n         being refreshed,\
    \ and the destination IP address of the session.\n      Source_IP_Address\n  \
    \       The IP address corresponding to the sender of the Path state\n       \
    \  being refreshed.\n      Destination_IP_Address\n         The destination IP\
    \ address corresponding to the session of the\n         Path state being refreshed.\n"
- title: 5.2. Srefresh Message Format
  contents:
  - "5.2. Srefresh Message Format\n   Srefresh messages carry one or more MESSAGE_ID\
    \ LIST, MESSAGE_ID\n   SRC_LIST, and MESSAGE_ID MCAST_LIST objects.  MESSAGE_ID\
    \ LIST and\n   MESSAGE_ID MCAST_LIST objects MAY be carried in the same Srefresh\n\
    \   message.  MESSAGE_ID SRC_LIST can not be combined in Srefresh\n   messages\
    \ with the other objects.  A single Srefresh message MAY\n   refresh both Path\
    \ and Resv state.\n   Srefresh messages carrying Message_Identifier fields corresponding\
    \ to\n   Path state are normally sent with a destination IP address equal to\n\
    \   the address carried in the corresponding SESSION objects.  The\n   destination\
    \ IP address MAY be set to the RSVP next hop when the next\n   hop is known to\
    \ be RSVP capable and either (a) the session is unicast\n   or (b) the outgoing\
    \ interface is a point-to-point link.  Srefresh\n   messages carrying Message_Identifier\
    \ fields corresponding to Resv\n   state MUST be sent with a destination IP address\
    \ set to the Resv\n   state's previous hop.\n   Srefresh messages sent to a multicast\
    \ session's destination IP\n   address, MUST contain MESSAGE_ID SRC_LIST objects\
    \ and MUST NOT\n   include any MESSAGE_ID LIST or MESSAGE_ID MCAST_LIST objects.\n\
    \   Srefresh messages sent to the RSVP next hop MAY contain either or\n   both\
    \ MESSAGE_ID LIST and MESSAGE_ID MCAST_LIST objects, but MUST NOT\n   include\
    \ any MESSAGE_ID SRC_LIST objects.\n   The source IP address of an Srefresh message\
    \ is an address of the\n   node that generates the message.  The source IP address\
    \ MUST match\n   the address associate with the MESSAGE_ID objects when they were\n\
    \   included in a standard RSVP message.  As previously mentioned, the\n   source\
    \ address associated with a MESSAGE_ID object is represented in\n   a per RSVP\
    \ message type specific fashion.  For messages with RSVP_HOP\n   objects, such\
    \ as Path and Resv messages, the address is found in the\n   RSVP_HOP object.\
    \  For other messages, such as ResvConf message, the\n   associated IP address\
    \ is the source address in the IP header.\n   Srefresh messages that are addressed\
    \ to a session's destination IP\n   address MUST be sent with the Router Alert\
    \ IP option in their IP\n   headers.  Srefresh messages addressed directly to\
    \ RSVP neighbors\n   SHOULD NOT be sent with the Router Alert IP option in their\
    \ IP\n   headers.\n   Each Srefresh message MUST occupy exactly one IP datagram.\
    \  If it\n   exceeds the MTU, the datagram is fragmented by IP and reassembled\
    \ at\n   the recipient node.  Srefresh messages MAY be sent within an RSVP\n \
    \  Bundle messages.  Although this is not expected since Srefresh\n   messages\
    \ can carry a list of Message_Identifier fields within a\n   single object.  Implementations\
    \ may choose to limit each Srefresh\n   message to the MTU size of the outgoing\
    \ link, e.g., 1500 bytes.\n   The Srefresh message format is:\n   <Srefresh Message>\
    \ ::= <Common Header> [ <INTEGRITY> ]\n                         [ [<MESSAGE_ID_ACK>\
    \ | <MESSAGE_ID_NACK>] ... ]\n                         [ <MESSAGE_ID> ]\n    \
    \                     <srefresh list> | <source srefresh list>\n   <srefresh list>\
    \ ::= <MESSAGE_ID LIST> | <MESSAGE_ID MCAST_LIST>\n                         [\
    \ <srefresh list> ]\n   <source srefresh list> ::= <MESSAGE_ID SRC_LIST>\n   \
    \                             [ <source srefresh list> ]\n   For Srefresh messages,\
    \ the Msg Type field of the Common Header MUST\n   be set to 15.\n"
- title: 5.3. Srefresh Message Usage
  contents:
  - "5.3. Srefresh Message Usage\n   An Srefresh message may be generated to refresh\
    \ Resv and Path state.\n   If an Srefresh message is used to refresh some particular\
    \ state, then\n   the generation of a standard refresh message for that particular\n\
    \   state SHOULD be suppressed.  A state's refresh interval is not\n   affected\
    \ by the use of Srefresh message based refreshes.\n   When generating an Srefresh\
    \ message, a node SHOULD refresh as much\n   Path and Resv state as is possible\
    \ by including the information from\n   as many MESSAGE_ID objects in the same\
    \ Srefresh message.  Only the\n   information from MESSAGE_ID objects that meet\
    \ the source and\n   destination IP address restrictions, as described in Sections\
    \ 5.2,\n   may be included in the same Srefresh message.  Identifying Resv state\n\
    \   that can be refreshed using the same Srefresh message is fairly\n   straightforward.\
    \  Identifying which Path state may be included is a\n   little more complex.\n\
    \   Only state that was previously advertised in Path and Resv messages\n   containing\
    \ MESSAGE_ID objects can be refreshed via an Srefresh\n   message.  Srefresh message\
    \ based refreshes must preserve the state\n   synchronization properties of Path\
    \ or Resv message based refreshes.\n   Specifically, the use of Srefresh messages\
    \ MUST NOT result in state\n   being timed-out at the RSVP next hop.  The period\
    \ at which state is\n   refreshed when using Srefresh messages MAY be shorter\
    \ than the period\n   that would be used when using Path or Resv message based\
    \ refreshes,\n   but it MUST NOT be longer.\n   The particular approach used to\
    \ trigger Srefresh message based\n   refreshes is implementation specific.  Some\
    \ possibilities are\n   triggering Srefresh message generation based on each state's\
    \ refresh\n   period or, on a per interface basis, periodically generating Srefresh\n\
    \   messages to refresh all state that has not been refreshed within the\n   state's\
    \ refresh interval.  Other approaches are also possible.  A\n   default Srefresh\
    \ message generation interval of 30 seconds is\n   suggested for nodes that do\
    \ not dynamically calculate a generation\n   interval.\n   When generating an\
    \ Srefresh message, there are two methods for\n   identifying which Path state\
    \ may be refreshed in a specific message.\n   In both cases, the previously mentioned\
    \ refresh interval and source\n   IP address restrictions must be followed.  The\
    \ primary method is to\n   include only those sessions that share the same destination\
    \ IP\n   address in the same Srefresh message.\n   The secondary method for identifying\
    \ which Path state may be\n   refreshed within a single Srefresh message is an\
    \ optimization.  This\n   method MAY be used when the next hop is known to support\
    \ RSVP and\n   when either (a) the session is unicast or (b) the outgoing interface\n\
    \   is a point-to-point link.  This method MUST NOT be used when the next\n  \
    \ hop is not known to support RSVP or when the outgoing interface is to\n   a\
    \ multi-access network and the session is to a multicast address.\n   The use\
    \ of this method MAY be administratively configured.  When\n   using this method,\
    \ the destination address in the IP header of the\n   Srefresh message is usually\
    \ the next hop's address.  When the use of\n   this method is administratively\
    \ configured, the destination address\n   should be the well known group address\
    \ 224.0.0.14.  When the outgoing\n   interface is a point-to-point link, all Path\
    \ state associated with\n   sessions advertised out the interface SHOULD be included\
    \ in the same\n   Srefresh message.  When the outgoing interface is not a point-to-\n\
    \   point link, all unicast session Path state SHOULD be included in the\n   same\
    \ Srefresh message.\n   Identifying which Resv state may be refreshed within a\
    \ single\n   Srefresh message is based simply on the source and destination IP\n\
    \   addresses.  Any state that was previously advertised in Resv messages\n  \
    \ with the same IP addresses as an Srefresh message MAY be included.\n   After\
    \ identifying the Path and Resv state that can be included in a\n   particular\
    \ Srefresh message, the message generator adds to the\n   message MESSAGE_ID information\
    \ matching each identified state's\n   previously used object.  For all Resv state\
    \ and for Path state of\n   unicast sessions, the information is added to the\
    \ message in a\n   MESSAGE_ID LIST object that has a matching Epoch value.  (Note\
    \ only\n   one Epoch value will be in use during normal operation.)  If no\n \
    \  matching object exists, then a new MESSAGE_ID LIST object is created.\n   Path\
    \ state of multicast sessions may be added to the same message\n   when the destination\
    \ address of the Srefresh message is the RSVP next\n   hop and the outgoing interface\
    \ is a point-to-point link.  In this\n   case the information is added to the\
    \ message in a MESSAGE_ID\n   MCAST_LIST object that has a matching Epoch value.\
    \  If no matching\n   object exists, then a new MESSAGE_ID MCAST_LIST object is\
    \ created.\n   When the destination address of the message is a multicast address,\n\
    \   then identified information is added to the message in a MESSAGE_ID\n   SRC_LIST\
    \ object that has a matching Epoch value.  If no matching\n   object exists, then\
    \ a new MESSAGE_ID SRC_LIST object is created.\n   Once the Srefresh message is\
    \ composed, the message generator\n   transmits the message out the proper interface.\n\
    \   Upon receiving an Srefresh message, the node MUST attempt to identify\n  \
    \ matching installed Path or Resv state.  Matching is done based on the\n   source\
    \ address in the IP header of the Srefresh message, the object\n   type and each\
    \ Message_Identifier field.  If matching state can be\n   found, then the receiving\
    \ node MUST update the matching state\n   information as if a standard refresh\
    \ message had been received.  If\n   matching state cannot be identified, then\
    \ an Srefresh NACK MUST be\n   generated corresponding to the unmatched Message_Identifier\
    \ field.\n   Message_Identifier fields received in MESSAGE_ID LIST objects may\n\
    \   correspond to any Resv state or to Path state of unicast sessions.\n   Message_Identifier\
    \ fields received in MESSAGE_ID SRC_LIST or\n   MCAST_LIST objects correspond\
    \ to Path state of multicast sessions.\n   An additional check must be performed\
    \ to determine if a NACK should\n   be generated for unmatched Message_Identifier\
    \ fields associated with\n   Path state of multicast sessions, i.e., fields that\
    \ were carried in\n   MESSAGE_ID SRC_LIST or MCAST_LIST objects.  The receiving\
    \ node must\n   check to see if the node would forward data packets originated\
    \ from\n   the source corresponding to the unmatched field.  This check,\n   commonly\
    \ known as an RPF check, is performed based on the source and\n   group information\
    \ carried in the MESSAGE_ID SRC_LIST and MCAST_LIST\n   objects.  In both objects\
    \ the IP address of the source is listed\n   immediately after the corresponding\
    \ Message_Identifier field.  The\n   group address is listed immediately after\
    \ the source IP address in\n   MESSAGE_ID MCAST_LIST objects.  The group address\
    \ is the message's\n   destination IP address when MESSAGE_ID SRC_LIST objects\
    \ are used.\n   The receiving node only generates an Srefresh NACK when the node\n\
    \   would forward packets to the identified group from the listed sender.\n  \
    \ If the node would forward multicast data packets from a listed sender\n   and\
    \ there is a corresponding unmatched Message_Identifier field, then\n   an appropriate\
    \ Srefresh NACK MUST be generated.  If the node would\n   not forward packets\
    \ to the identified group from a listed sender, a\n   corresponding unmatched\
    \ Message_Identifier field is silently ignored.\n"
- title: 5.4. Srefresh NACK
  contents:
  - "5.4. Srefresh NACK\n   Srefresh NACKs are used to indicate that a received\n\
    \   Message_Identifier field carried in MESSAGE_ID LIST, SRC_LIST, or\n   MCAST_LIST\
    \ object does not match any installed state.  This may occur\n   for a number\
    \ of reasons including, for example, a route change.  An\n   Srefresh NACK is\
    \ encoded in a MESSAGE_ID_NACK object.  When\n   generating an Srefresh NACK,\
    \ the epoch and Message_Identifier fields\n   of the MESSAGE_ID_NACK object MUST\
    \ have the same value as was\n   received.  MESSAGE_ID_NACK objects are transmitted\
    \ as described in\n   Section 4.6.\n   Received MESSAGE_ID_NACK objects indicate\
    \ that the object generator\n   does not have any installed state matching the\
    \ object.  Upon\n   receiving a MESSAGE_ID_NACK object, the receiver performs\
    \ an\n   installed Path or Resv state lookup based on the Epoch and\n   Message_Identifier\
    \ values contained in the object.  If matching state\n   is found, then the receiver\
    \ MUST transmit the matching state via a\n   standard Path or Resv message.  If\
    \ the receiver cannot identify any\n   installed state, then no action is required.\n"
- title: 5.5. Preserving RSVP Soft State
  contents:
  - "5.5. Preserving RSVP Soft State\n   As discussed in [RFC2205], RSVP uses soft\
    \ state to address a large\n   class of potential errors.  RSVP does this by periodically\
    \ sending a\n   full representation of installed state in Resv and Path messages.\n\
    \   Srefresh messages are used in place of the periodic sending of\n   standard\
    \ Path and Resv refresh messages.  While this provides scaling\n   benefits and\
    \ protects against common network events such as packet\n   loss or routing change,\
    \ it does not provide exactly the same error\n   recovery properties.  An example\
    \ error that could potentially be\n   recovered from via standard messages but\
    \ not with Srefresh messages\n   is internal corruption of state.  This section\
    \ recommends two methods\n   that can be used to better preserve RSVP's soft state\
    \ error recovery\n   mechanism.  Both mechanisms are supported using existing\
    \ protocol\n   messages.\n   The first mechanism uses a checksum or other algorithm\
    \ to detect a\n   previously unnoticed change in internal state.  This mechanism\
    \ does\n   not protect against internal state corruption.  It just covers the\n\
    \   case where a trigger message should have been sent, but was not.\n   When\
    \ sending a Path or Resv trigger message, a node should run a\n   checksum or\
    \ other algorithm, such as [MD5], over the internal state\n   and store the result.\
    \  The choice of algorithm is an administrative\n   decision.  Periodically the\
    \ node should rerun the algorithm and\n   compare the new result with the stored\
    \ result.  If the values differ,\n   then a corresponding standard Path or Resv\
    \ refresh message should be\n   sent and the new value should be stored.  The\
    \ recomputation period\n   should be set based on the computation resources of\
    \ the node and the\n   reliability requirements of the network.\n   The second\
    \ mechanism is simply to periodically send standard Path and\n   Resv refresh\
    \ messages.  Since this mechanism uses standard refresh\n   messages, it can recover\
    \ from the same set of errors as standard\n   RSVP.  When using this mechanism,\
    \ the period that standard refresh\n   messages are sent must be longer than the\
    \ interval that Srefresh\n   messages are generated in order to gain the benefits\
    \ of using the\n   summary refresh extension.  When a standard refresh message\
    \ is sent,\n   a corresponding summary refresh SHOULD NOT be sent during the same\n\
    \   refresh period.  When a node supports the periodic generation of\n   standard\
    \ refresh messages while Srefreshes are being used, the\n   frequency of generation\
    \ of standard refresh messages relative to the\n   generation of summary refreshes\
    \ SHOULD be configurable by the network\n   administrator.\n"
- title: 5.6. Compatibility
  contents:
  - "5.6. Compatibility\n   Nodes supporting the summary refresh extension advertise\
    \ their\n   support via the Refresh-Reduction-Capable bit in the RSVP message\n\
    \   header.  This enables nodes supporting the extension to detect each\n   other.\
    \  When it is not known if a next hop supports the extension,\n   standard Path\
    \ and Resv message based refreshes MUST be used.  Note\n   that when the routing\
    \ next hop does not support RSVP, it will not\n   always be possible to detect\
    \ if the RSVP next hop supports the\n   summary refresh extension.  Therefore,\
    \ when the routing next hop is\n   not RSVP capable the Srefresh message based\
    \ refresh SHOULD NOT be\n   used.  A node MAY be administratively configured to\
    \ use Srefresh\n   messages in all cases when all RSVP nodes in a network are\
    \ known to\n   support the summary refresh extension.  This is useful since when\n\
    \   operating in this mode, the extension properly adjusts to the case of\n  \
    \ non-RSVP next hops and changes in routing.\n   Per section 2, nodes supporting\
    \ the summary refresh extension must\n   also take care to recognize when a next\
    \ hop stops sending RSVP\n   messages with the Refresh-Reduction-Capable bit set.\n"
- title: 6. Exponential Back-Off Procedures
  contents:
  - "6. Exponential Back-Off Procedures\n   This section is based on [Pan] and provides\
    \ procedures to implement\n   exponential back-off for retransmission of messages\
    \ awaiting\n   acknowledgment, see Section 4.5.  Implementations MUST use the\n\
    \   described procedures or their equivalent.\n"
- title: 6.1. Outline of Operation
  contents:
  - "6.1. Outline of Operation\n   The following is one possible mechanism for exponential\
    \ back-off\n   retransmission of an unacknowledged RSVP message: When sending\
    \ such a\n   message, a node inserts a MESSAGE_ID object with the ACK_Desired\
    \ flag\n   set.  The sending node will retransmit the message until a message\n\
    \   acknowledgment is received or the message has been transmitted a\n   maximum\
    \ number of times.  Upon reception, a receiving node\n   acknowledges the arrival\
    \ of the message by sending back a message\n   acknowledgment (that is, a corresponding\
    \ MESSAGE_ID_ACK object.)\n   When the sending node receives the acknowledgment\
    \ retransmission of\n   the message is stopped.  The interval between retransmissions\
    \ is\n   governed by a rapid retransmission timer.  The rapid retransmission\n\
    \   timer starts at a small interval and increases exponentially until it\n  \
    \ reaches a threshold.\n"
- title: 6.2. Time Parameters
  contents:
  - "6.2. Time Parameters\n   The described procedures make use of the following time\
    \ parameters.\n   All parameters are per interface.\n      Rapid retransmission\
    \ interval Rf:\n           Rf is the initial retransmission interval for unacknowledged\n\
    \           messages.  After sending the message for the first time, the\n   \
    \        sending node will schedule a retransmission after Rf seconds.\n     \
    \      The value of Rf could be as small as the round trip time\n           (RTT)\
    \ between a sending and a receiving node, if known.\n      Rapid retry limit Rl:\n\
    \           Rl is the maximum number of times a message will be\n           transmitted\
    \ without being acknowledged.\n      Increment value Delta:\n           Delta\
    \ governs the speed with which the sender increases the\n           retransmission\
    \ interval.  The ratio of two successive\n           retransmission intervals\
    \ is (1 + Delta).\n   Suggested default values are an initial retransmission timeout\
    \ (Rf)\n   of 500ms, a power of 2 exponential back-off (Delta = 1) and a retry\n\
    \   limit (Rl) of 3.\n"
- title: 6.3. Retransmission Algorithm
  contents:
  - "6.3. Retransmission Algorithm\n   After a sending node transmits a message containing\
    \ a MESSAGE_ID\n   object with the ACK_Desired flag set, it should immediately\
    \ schedule\n   a retransmission after Rf seconds.  If a corresponding MESSAGE_ID_ACK\n\
    \   object is received earlier than Rf seconds, then retransmission\n   SHOULD\
    \ be canceled.  Otherwise, it will retransmit the message after\n   (1 + Delta)*Rf\
    \ seconds.  The staged retransmission will continue\n   until either an appropriate\
    \ MESSAGE_ID_ACK object is received, or the\n   rapid retry limit, Rl, has been\
    \ reached.\n   A sending node can use the following algorithm when transmitting\
    \ a\n   message containing a MESSAGE_ID object with the ACK_Desired flag set:\n\
    \       Prior to initial transmission initialize: Rk = Rf and Rn = 0\n       while\
    \ (Rn++ < Rl)  {\n           transmit the message;\n           wake up after Rk\
    \ seconds;\n           Rk = Rk * (1 + Delta);\n       }\n       /* acknowledged\
    \ or no reply from receiver for too long: */ do any\n       needed clean up; exit;\n\
    \   Asynchronously, when a sending node receives a corresponding\n   MESSAGE_ID_ACK\
    \ object, it will change the retry count, Rn, to Rl.\n   Note that the transmitting\
    \ node does not advertise the use of the\n   described exponential back-off procedures\
    \ via the TIME_VALUE object.\n"
- title: 6.4. Performance Considerations
  contents:
  - "6.4. Performance Considerations\n   The use of exponential back-off retransmission\
    \ is a new and\n   significant addition to RSVP.  It will be important to review\
    \ related\n   operations and performance experience before this document advances\n\
    \   to Draft Standard.  It will be particularly important to review\n   experience\
    \ with multicast, and any ACK implosion problems actually\n   encountered.\n"
- title: 7. Acknowledgments
  contents:
  - "7. Acknowledgments\n   This document represents ideas and comments from the MPLS-TE\
    \ design\n   team and participants in the RSVP Working Group's interim meeting.\n\
    \   Thanks to Bob Braden, Lixia Zhang, Fred Baker, Adrian Farrel, Roch\n   Guerin,\
    \ Kireeti Kompella, David Mankins, Henning Schulzrinne, Andreas\n   Terzis, Lan\
    \ Wang and Masanobu Yuhara for specific feedback on the\n   various versions of\
    \ the document.\n   Portions of this work are based on work done by Masanobu Yuhara\
    \ and\n   Mayumi Tomikawa [Yuhara].\n"
- title: 8. Security Considerations
  contents:
  - "8. Security Considerations\n   No new security issues are raised in this document.\
    \  See [RFC2205]\n   for a general discussion on RSVP security issues.\n"
- title: 9. References
  contents:
  - "9. References\n   [Pan]     Pan, P., Schulzrinne, H., \"Staged Refresh Timers\
    \ for RSVP,\"\n             Global Internet'97, Phoenix, AZ, November 1997.\n\
    \             http://www.cs.columbia.edu/~pingpan/papers/timergi.pdf\n   [MD5]\
    \     Rivest, R., \"The MD5 Message-Digest Algorithm\", RFC 1321,\n          \
    \   April 1992.\n   [RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate\n\
    \             Requirement Levels\", BCP 14, RFC 2119, March 1997.\n   [RFC2205]\
    \ Braden, R., Ed., Zhang, L., Berson, S., Herzog, S. and S.\n             Jamin\
    \ , \"Resource ReserVation Protocol -- Version 1\n             Functional Specification\"\
    , RFC 2205, September 1997.\n   [Yuhara]  Yuhara, M., and M Tomikawa, \"RSVP Extensions\
    \ for ID-based\n             Refreshes\", Work in Progress.\n"
- title: 10. Authors' Addresses
  contents:
  - "10. Authors' Addresses\n   Lou Berger\n   LabN Consulting, LLC\n   Phone:  +1\
    \ 301 468 9228\n   EMail:  lberger@labn.net\n   Der-Hwa Gan\n   Juniper Networks,\
    \ Inc.\n   1194 N. Mathilda Avenue,\n   Sunnyvale, CA 94089\n   Voice: +1 408\
    \ 745 2074\n   Email:  dhg@juniper.net\n   George Swallow\n   Cisco Systems, Inc.\n\
    \   250 Apollo Drive\n   Chelmsford, MA 01824\n   Phone:  +1 978 244 8143\n  \
    \ EMail:  swallow@cisco.com\n   Ping Pan\n   Juniper Networks, Inc.\n   1194 N.\
    \ Mathilda Avenue,\n   Sunnyvale, CA 94089\n   Voice: +1 408 745 3704\n   Email:\
    \  pingpan@juniper.net\n   Franco Tommasi\n   University of Lecce, Fac. Ingegneria\n\
    \   Via Monteroni 73100 Lecce, ITALY\n   EMail:  franco.tommasi@unile.it\n   Simone\
    \ Molendini\n   University of Lecce, Fac. Ingegneria\n   Via Monteroni 73100 Lecce,\
    \ ITALY\n   EMail:  molendini@ultra5.unile.it\n"
- title: 11.  Full Copyright Statement
  contents:
  - "11.  Full Copyright Statement\n   Copyright (C) The Internet Society (2001).\
    \  All Rights Reserved.\n   This document and translations of it may be copied\
    \ and furnished to\n   others, and derivative works that comment on or otherwise\
    \ explain it\n   or assist in its implementation may be prepared, copied, published\n\
    \   and distributed, in whole or in part, without restriction of any\n   kind,\
    \ provided that the above copyright notice and this paragraph are\n   included\
    \ on all such copies and derivative works.  However, this\n   document itself\
    \ may not be modified in any way, such as by removing\n   the copyright notice\
    \ or references to the Internet Society or other\n   Internet organizations, except\
    \ as needed for the purpose of\n   developing Internet standards in which case\
    \ the procedures for\n   copyrights defined in the Internet Standards process\
    \ must be\n   followed, or as required to translate it into languages other than\n\
    \   English.\n   The limited permissions granted above are perpetual and will\
    \ not be\n   revoked by the Internet Society or its successors or assigns.\n \
    \  This document and the information contained herein is provided on an\n   \"\
    AS IS\" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING\n   TASK FORCE\
    \ DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING\n   BUT NOT LIMITED\
    \ TO ANY WARRANTY THAT THE USE OF THE INFORMATION\n   HEREIN WILL NOT INFRINGE\
    \ ANY RIGHTS OR ANY IMPLIED WARRANTIES OF\n   MERCHANTABILITY OR FITNESS FOR A\
    \ PARTICULAR PURPOSE.\n"
- title: Acknowledgement
  contents:
  - "Acknowledgement\n   Funding for the RFC Editor function is currently provided\
    \ by the\n   Internet Society.\n"
