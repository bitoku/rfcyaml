- contents:
  - '           Session Initiation Protocol (SIP) Overload Control

    '
  title: __initial_text__
- contents:
  - "Abstract\n   Overload occurs in Session Initiation Protocol (SIP) networks when\n
    \  SIP servers have insufficient resources to handle all the SIP\n   messages
    they receive.  Even though the SIP protocol provides a\n   limited overload control
    mechanism through its 503 (Service\n   Unavailable) response code, SIP servers
    are still vulnerable to\n   overload.  This document defines the behavior of SIP
    servers involved\n   in overload control and also specifies a loss-based overload
    scheme\n   for SIP.\n"
  title: Abstract
- contents:
  - "Status of This Memo\n   This is an Internet Standards Track document.\n   This
    document is a product of the Internet Engineering Task Force\n   (IETF).  It represents
    the consensus of the IETF community.  It has\n   received public review and has
    been approved for publication by the\n   Internet Engineering Steering Group (IESG).
    \ Further information on\n   Internet Standards is available in Section 2 of RFC
    5741.\n   Information about the current status of this document, any errata,\n
    \  and how to provide feedback on it may be obtained at\n   http://www.rfc-editor.org/info/rfc7339.\n"
  title: Status of This Memo
- contents:
  - "Copyright Notice\n   Copyright (c) 2014 IETF Trust and the persons identified
    as the\n   document authors.  All rights reserved.\n   This document is subject
    to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n
    \  (http://trustee.ietf.org/license-info) in effect on the date of\n   publication
    of this document.  Please review these documents\n   carefully, as they describe
    your rights and restrictions with respect\n   to this document.  Code Components
    extracted from this document must\n   include Simplified BSD License text as described
    in Section 4.e of\n   the Trust Legal Provisions and are provided without warranty
    as\n   described in the Simplified BSD License.\n"
  title: Copyright Notice
- contents:
  - "Table of Contents\n   1. Introduction ....................................................4\n
    \  2. Terminology .....................................................5\n   3.
    Overview of Operations ..........................................6\n   4. Via
    Header Parameters for Overload Control ......................6\n      4.1. The
    \"oc\" Parameter .........................................6\n      4.2. The \"oc-algo\"
    Parameter ....................................7\n      4.3. The \"oc-validity\"
    Parameter ................................8\n      4.4. The \"oc-seq\" Parameter
    .....................................8\n   5. General Behavior ................................................9\n
    \     5.1. Determining Support for Overload Control ..................10\n      5.2.
    Creating and Updating the Overload Control Parameters .....10\n      5.3. Determining
    the \"oc\" Parameter Value ......................12\n      5.4. Processing the
    Overload Control Parameters ................12\n      5.5. Using the Overload
    Control Parameter Values ...............13\n      5.6. Forwarding the Overload
    Control Parameters ................14\n      5.7. Terminating Overload Control
    ..............................14\n      5.8. Stabilizing Overload Algorithm Selection
    ..................15\n      5.9. Self-Limiting .............................................15\n
    \     5.10. Responding to an Overload Indication .....................16\n           5.10.1.
    Message Prioritization at the Hop before\n                   the Overloaded Server
    .............................16\n           5.10.2. Rejecting Requests at an Overloaded
    Server ........17\n      5.11. 100 Trying Provisional Response and Overload\n
    \           Control Parameters .......................................17\n   6.
    Example ........................................................18\n   7. The
    Loss-Based Overload Control Scheme .........................19\n      7.1. Special
    Parameter Values for Loss-Based Overload Control ..19\n      7.2. Default Algorithm
    for Loss-Based Overload Control .........20\n   8. Relationship with Other IETF
    SIP Load Control Efforts ..........23\n   9. Syntax .........................................................24\n
    \  10. Design Considerations .........................................24\n      10.1.
    SIP Mechanism ............................................24\n           10.1.1.
    SIP Response Header ...............................24\n           10.1.2. SIP
    Event Package .................................25\n      10.2. Backwards Compatibility
    ..................................26\n   11. Security Considerations .......................................27\n
    \  12. IANA Considerations ...........................................29\n   13.
    References ....................................................29\n      13.1.
    Normative References .....................................29\n      13.2. Informative
    References ...................................30\n   Appendix A. Acknowledgements
    ......................................31\n   Appendix B. RFC 5390 Requirements
    .................................31\n"
  title: Table of Contents
- contents:
  - "1.  Introduction\n   As with any network element, a Session Initiation Protocol
    (SIP)\n   [RFC3261] server can suffer from overload when the number of SIP\n   messages
    it receives exceeds the number of messages it can process.\n   Overload can pose
    a serious problem for a network of SIP servers.\n   During periods of overload,
    the throughput of a network of SIP\n   servers can be significantly degraded.
    \ In fact, overload may lead to\n   a situation where the retransmissions of dropped
    SIP messages may\n   overwhelm the capacity of the network.  This is often called\n
    \  \"congestion collapse\".\n   Overload is said to occur if a SIP server does
    not have sufficient\n   resources to process all incoming SIP messages.  These
    resources may\n   include CPU processing capacity, memory, input/output, or disk\n
    \  resources.\n   For overload control, this document only addresses failure cases\n
    \  where SIP servers are unable to process all SIP requests due to\n   resource
    constraints.  There are other cases where a SIP server can\n   successfully process
    incoming requests but has to reject them due to\n   failure conditions unrelated
    to the SIP server being overloaded.  For\n   example, a Public Switched Telephone
    Network (PSTN) gateway that runs\n   out of trunks but still has plenty of capacity
    to process SIP\n   messages should reject incoming INVITEs using a 488 (Not Acceptable\n
    \  Here) response [RFC4412].  Similarly, a SIP registrar that has lost\n   connectivity
    to its registration database but is still capable of\n   processing SIP requests
    should reject REGISTER requests with a 500\n   (Server Error) response [RFC3261].
    \ Overload control does not apply\n   to these cases, and SIP provides appropriate
    response codes for them.\n   The SIP protocol provides a limited mechanism for
    overload control\n   through its 503 (Service Unavailable) response code.  However,
    this\n   mechanism cannot prevent overload of a SIP server, and it cannot\n   prevent
    congestion collapse.  In fact, the use of the 503 (Service\n   Unavailable) response
    code may cause traffic to oscillate and shift\n   between SIP servers, thereby
    worsening an overload condition.  A\n   detailed discussion of the SIP overload
    problem, the problems with\n   the 503 (Service Unavailable) response code, and
    the requirements for\n   a SIP overload control mechanism can be found in [RFC5390].\n
    \  This document defines the protocol for communicating overload\n   information
    between SIP servers and clients so that clients can\n   reduce the volume of traffic
    sent to overloaded servers, avoiding\n   congestion collapse and increasing useful
    throughput.  Section 4\n   describes the Via header parameters used for this communication.
    \ The\n   general behavior of SIP servers and clients involved in overload\n   control
    is described in Section 5.  In addition, Section 7 specifies\n   a loss-based
    overload control scheme.\n   This document specifies the loss-based overload control
    scheme\n   (Section 7), which is mandatory to implement for this specification.\n
    \  In addition, this document allows other overload control schemes to\n   be
    supported as well.  To do so effectively, the expectations and\n   primitive protocol
    parameters common to all classes of overload\n   control schemes are specified
    in this document.\n"
  title: 1.  Introduction
- contents:
  - "2.  Terminology\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\",
    \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\"
    in this\n   document are to be interpreted as described in RFC 2119 [RFC2119].\n
    \  In this document, the terms \"SIP client\" and \"SIP server\" are used in\n
    \  their generic forms.  Thus, a \"SIP client\" could refer to the client\n   transaction
    state machine in a SIP proxy, or it could refer to a user\n   agent client (UAC).
    \ Similarly, a \"SIP server\" could be a user agent\n   server (UAS) or the server
    transaction state machine in a proxy.\n   Various permutations of this are also
    possible, for instance, SIP\n   clients and servers could also be part of back-to-back
    user agents\n   (B2BUAs).\n   However, irrespective of the context these terms
    are used in (i.e.,\n   proxy, B2BUA, UAS, UAC), \"SIP client\" applies to any
    SIP entity that\n   provides overload control to traffic destined downstream.
    \ Similarly,\n   \"SIP server\" applies to any SIP entity that is experiencing
    overload\n   and would like its upstream neighbor to throttle incoming traffic.\n
    \  Unless otherwise specified, all SIP entities described in this\n   document
    are assumed to support this specification.\n   The normative statements in this
    specification as they apply to SIP\n   clients and SIP servers assume that both
    the SIP clients and SIP\n   servers support this specification.  If, for instance,
    only a SIP\n   client supports this specification and not the SIP server, then
    the\n   normative statements in this specification pertinent to the behavior\n
    \  of a SIP server do not apply to the server that does not support this\n   specification.\n"
  title: 2.  Terminology
- contents:
  - "3.  Overview of Operations\n   This section provides an overview of how the overload
    control\n   mechanism operates by introducing the overload control parameters.\n
    \  Section 4 provides more details and normative behavior on the\n   parameters
    listed below.\n   Because overload control is performed hop-by-hop, the Via header\n
    \  parameter is attractive since it allows two adjacent SIP entities to\n   indicate
    support for, and exchange information associated with,\n   overload control [RFC6357].
    \ Additional advantages of this choice are\n   discussed in Section 10.1.1.  An
    alternative mechanism using SIP\n   event packages was also considered, and the
    characteristics of that\n   choice are further outlined in Section 10.1.2.\n   This
    document defines four new parameters for the SIP Via header for\n   overload control.
    \ These parameters provide a mechanism for conveying\n   overload control information
    between adjacent SIP entities.  The \"oc\"\n   parameter is used by a SIP server
    to indicate a reduction in the\n   number of requests arriving at the server.
    \ The \"oc-algo\" parameter\n   contains a token or a list of tokens corresponding
    to the class of\n   overload control algorithms supported by the client.  The
    server\n   chooses one algorithm from this list.  The \"oc-validity\" parameter\n
    \  establishes a time limit for which overload control is in effect, and\n   the
    \"oc-seq\" parameter aids in sequencing the responses at the\n   client.  These
    parameters are discussed in detail in the next\n   section.\n"
  title: 3.  Overview of Operations
- contents:
  - "4.  Via Header Parameters for Overload Control\n   The four Via header parameters
    are introduced below.  Further context\n   about how to interpret these under
    various conditions is provided in\n   Section 5.\n"
  - contents:
    - "4.1.  The \"oc\" Parameter\n   This parameter is inserted by the SIP client
      and updated by the SIP\n   server.\n   A SIP client MUST add an \"oc\" parameter
      to the topmost Via header it\n   inserts into every SIP request.  This provides
      an indication to\n   downstream neighbors that the client supports overload
      control.\n   There MUST NOT be a value associated with the parameter (the value\n
      \  will be added by the server).\n   The downstream server MUST add a value
      to the \"oc\" parameter in the\n   response going upstream to a client that
      included the \"oc\" parameter\n   in the request.  Inclusion of a value to the
      parameter represents two\n   things.  First, upon the first contact (see Section
      5.1), addition of\n   a value by the server to this parameter indicates (to
      the client)\n   that the downstream server supports overload control as defined
      in\n   this document.  Second, if overload control is active, then it\n   indicates
      the level of control to be applied.\n   When a SIP client receives a response
      with the value in the \"oc\"\n   parameter filled in, it MUST reduce, as indicated
      by the \"oc\" and\n   \"oc-algo\" parameters, the number of requests going downstream
      to the\n   SIP server from which it received the response (see Section 5.10
      for\n   pertinent discussion on traffic reduction).\n"
    title: 4.1.  The "oc" Parameter
  - contents:
    - "4.2.  The \"oc-algo\" Parameter\n   This parameter is inserted by the SIP client
      and updated by the SIP\n   server.\n   A SIP client MUST add an \"oc-algo\"
      parameter to the topmost Via\n   header it inserts into every SIP request, with
      a default value of\n   \"loss\".\n   This parameter contains names of one or
      more classes of overload\n   control algorithms.  A SIP client MUST support
      the loss-based\n   overload control scheme and MUST insert at least the token
      \"loss\" as\n   one of the \"oc-algo\" parameter values.  In addition, the SIP
      client\n   MAY insert other tokens, separated by a comma, in the \"oc-algo\"\n
      \  parameter if it supports other overload control schemes such as a\n   rate-based
      scheme [RATE-CONTROL].  Each element in the comma-\n   separated list corresponds
      to the class of overload control\n   algorithms supported by the SIP client.
      \ When more than one class of\n   overload control algorithms is present in
      the \"oc-algo\" parameter,\n   the client may indicate algorithm preference
      by ordering the list in\n   a decreasing order of preference.  However, the
      client cannot assume\n   that the server will pick the most preferred algorithm.\n
      \  When a downstream SIP server receives a request with multiple\n   overload
      control algorithms specified in the \"oc-algo\" parameter\n   (optionally sorted
      by decreasing order of preference), it chooses one\n   algorithm from the list
      and MUST return the single selected algorithm\n   to the client.\n   Once the
      SIP server has chosen a mutually agreeable class of overload\n   control algorithms
      and communicated it to the client, the selection\n   stays in effect until the
      algorithm is changed by the server.\n   Furthermore, the client MUST continue
      to include all the supported\n   algorithms in subsequent requests; the server
      MUST respond with the\n   agreed-to algorithm until the algorithm is changed
      by the server.\n   The selection SHOULD stay the same for a non-trivial duration
      of time\n   to allow the overload control algorithm to stabilize its behavior\n
      \  (see Section 5.8).\n   The \"oc-algo\" parameter does not define the exact
      algorithm to be\n   used for traffic reduction; rather, the intent is to use
      any\n   algorithm from a specific class of algorithms that affect traffic\n
      \  reduction similarly.  For example, the reference algorithm in\n   Section
      7.2 can be used as a loss-based algorithm, or it can be\n   substituted by any
      other loss-based algorithm that results in\n   equivalent traffic reduction.\n"
    title: 4.2.  The "oc-algo" Parameter
  - contents:
    - "4.3.  The \"oc-validity\" Parameter\n   This parameter MAY be inserted by the
      SIP server in a response; it\n   MUST NOT be inserted by the SIP client in a
      request.\n   This parameter contains a value that indicates an interval of time\n
      \  (measured in milliseconds) that the load reduction specified in the\n   value
      of the \"oc\" parameter should be in effect.  The default value\n   of the \"oc-validity\"
      parameter is 500 (milliseconds).  If the client\n   receives a response with
      the \"oc\" and \"oc-algo\" parameters suitably\n   filled in, but no \"oc-validity\"
      parameter, the SIP client should\n   behave as if it had received \"oc-validity=500\".\n
      \  A value of 0 in the \"oc-validity\" parameter is reserved to denote the\n
      \  event that the server wishes to stop overload control or to indicate\n   that
      it supports overload control but is not currently requesting any\n   reduction
      in traffic (see Section 5.7).\n   A non-zero value for the \"oc-validity\" parameter
      MUST only be present\n   in conjunction with an \"oc\" parameter.  A SIP client
      MUST discard a\n   non-zero value of the \"oc-validity\" parameter if the client
      receives\n   it in a response without the corresponding \"oc\" parameter being\n
      \  present as well.\n   After the value specified in the \"oc-validity\" parameter
      expires and\n   until the SIP client receives an updated set of overload control\n
      \  parameters from the SIP server, overload control is not in effect\n   between
      the client and the downstream SIP server.\n"
    title: 4.3.  The "oc-validity" Parameter
  - contents:
    - "4.4.  The \"oc-seq\" Parameter\n   This parameter MUST be inserted by the SIP
      server in a response; it\n   MUST NOT be inserted by the SIP client in a request.\n
      \  This parameter contains an unsigned integer value that indicates the\n   sequence
      number associated with the \"oc\" parameter.  This sequence\n   number is used
      to differentiate two \"oc\" parameter values generated\n   by an overload control
      algorithm at two different instants in time.\n   \"oc\" parameter values generated
      by an overload control algorithm at\n   time t and t+1 MUST have an increasing
      value in the \"oc-seq\"\n   parameter.  This allows the upstream SIP client
      to properly collate\n   out-of-order responses.\n      Note: A timestamp can
      be used as a value of the \"oc-seq\"\n      parameter.\n   If the value contained
      in the \"oc-seq\" parameter overflows during the\n   period in which the load
      reduction is in effect, then the \"oc-seq\"\n   parameter MUST be reset to the
      current timestamp or an appropriate\n   base value.\n      Note: A client implementation
      can recognize that an overflow has\n      occurred when it receives an \"oc-seq\"
      parameter whose value is\n      significantly less than several previous values.
      \ (Note that an\n      \"oc-seq\" parameter whose value does not deviate significantly
      from\n      the last several previous values is symptomatic of a tardy packet.\n
      \     However, overflow will cause the \"oc-seq\" parameter value to be\n      significantly
      less than the last several values.)  If an overflow\n      is detected, then
      the client should use the overload parameters in\n      the new message, even
      though the sequence number is lower.  The\n      client should also reset any
      internal state to reflect the\n      overflow so that future messages (following
      the overflow) will be\n      accepted.\n"
    title: 4.4.  The "oc-seq" Parameter
  title: 4.  Via Header Parameters for Overload Control
- contents:
  - "5.  General Behavior\n   When forwarding a SIP request, a SIP client uses the
    SIP procedures\n   of [RFC3263] to determine the next-hop SIP server.  The procedures
    of\n   [RFC3263] take a SIP URI as input, extract the domain portion of that\n
    \  URI for use as a lookup key, query the Domain Name Service (DNS) to\n   obtain
    an ordered set of one or more IP addresses with a port number\n   and transport
    corresponding to each IP address in this set (the\n   \"Expected Output\").\n
    \  After selecting a specific SIP server from the Expected Output, a SIP\n   client
    determines whether overload controls are currently active with\n   that server.
    \ If overload controls are currently active (and the \"oc-\n   validity\" period
    has not yet expired), the client applies the\n   relevant algorithm to determine
    whether or not to send the SIP\n   request to the server.  If overload controls
    are not currently active\n   with this server (which will be the case if this
    is the initial\n   contact with the server, the last response from this server
    had\n   \"oc-validity=0\", or the time period indicated by the \"oc-validity\"\n
    \  parameter has expired), the SIP client sends the SIP message to the\n   server
    without invoking any overload control algorithm.\n"
  - contents:
    - "5.1.  Determining Support for Overload Control\n   If a client determines that
      this is the first contact with a server,\n   the client MUST insert the \"oc\"
      parameter without any value and MUST\n   insert the \"oc-algo\" parameter with
      a list of algorithms it supports.\n   This list MUST include \"loss\" and MAY
      include other algorithm names\n   approved by IANA and described in corresponding
      documents.  The\n   client transmits the request to the chosen server.\n   If
      a server receives a SIP request containing the \"oc\" and \"oc-algo\"\n   parameters,
      the server MUST determine if it has already selected the\n   overload control
      algorithm class with this client.  If it has, the\n   server SHOULD use the
      previously selected algorithm class in its\n   response to the message.  If
      the server determines that the message\n   is from a new client or a client
      the server has not heard from in a\n   long time, the server MUST choose one
      algorithm from the list of\n   algorithms in the \"oc-algo\" parameter.  It
      MUST put the chosen\n   algorithm as the sole parameter value in the \"oc-algo\"
      parameter of\n   the response it sends to the client.  In addition, if the server
      is\n   currently not in an overload condition, it MUST set the value of the\n
      \  \"oc\" parameter to be 0 and MAY insert an \"oc-validity=0\" parameter in\n
      \  the response to further qualify the value in the \"oc\" parameter.  If\n
      \  the server is currently overloaded, it MUST follow the procedures in\n   Section
      5.2.\n      Note: A client that supports the rate-based overload control\n      scheme
      [RATE-CONTROL] will consider \"oc=0\" as an indication not to\n      send any
      requests downstream at all.  Thus, when the server\n      inserts \"oc-validity=0\"
      as well, it is indicating that it does\n      support overload control, but
      it is not under overload mode right\n      now (see Section 5.7).\n"
    title: 5.1.  Determining Support for Overload Control
  - contents:
    - "5.2.  Creating and Updating the Overload Control Parameters\n   A SIP server
      provides overload control feedback to its upstream\n   clients by providing
      a value for the \"oc\" parameter to the topmost\n   Via header field of a SIP
      response, that is, the Via header added by\n   the client before it sent the
      request to the server.\n   Since the topmost Via header of a response will be
      removed by an\n   upstream client after processing it, overload control feedback\n
      \  contained in the \"oc\" parameter will not travel beyond the upstream\n   SIP
      client.  A Via header parameter therefore provides hop-by-hop\n   semantics
      for overload control feedback (see [RFC6357]) even if the\n   next-hop neighbor
      does not support this specification.\n   The \"oc\" parameter can be used in
      all response types, including\n   provisional, success, and failure responses
      (please see Section 5.11\n   for special consideration on transporting overload
      control parameters\n   in a 100 Trying response).  A SIP server can update the
      \"oc\"\n   parameter in a response, asking the client to increase or decrease\n
      \  the number of requests destined to the server or to stop performing\n   overload
      control altogether.\n   A SIP server that has updated the \"oc\" parameter SHOULD
      also add a\n   \"oc-validity\" parameter.  The \"oc-validity\" parameter defines
      the\n   time in milliseconds during which the overload control feedback\n   specified
      in the \"oc\" parameter is valid.  The default value of the\n   \"oc-validity\"
      parameter is 500 (milliseconds).\n   When a SIP server retransmits a response,
      it SHOULD use the \"oc\" and\n   \"oc-validity\" parameter values consistent
      with the overload state at\n   the time the retransmitted response was sent.
      \ This implies that the\n   values in the \"oc\" and \"oc-validity\" parameters
      may be different than\n   the ones used in previous retransmissions of the response.
      \ Due to\n   the fact that responses sent over UDP may be subject to delays
      in the\n   network and arrive out of order, the \"oc-seq\" parameter aids in\n
      \  detecting a stale \"oc\" parameter value.\n   Implementations that are capable
      of updating the \"oc\" and \"oc-\n   validity\" parameter values during retransmissions
      MUST insert the\n   \"oc-seq\" parameter.  The value of this parameter MUST
      be a set of\n   numbers drawn from an increasing sequence.\n   Implementations
      that are not capable of updating the \"oc\" and \"oc-\n   validity\" parameter
      values during retransmissions -- or\n   implementations that do not want to
      do so because they will have to\n   regenerate the message to be retransmitted
      -- MUST still insert a\n   \"oc-seq\" parameter in the first response associated
      with a\n   transaction; however, they do not have to update the value in\n   subsequent
      retransmissions.\n   The \"oc-validity\" and \"oc-seq\" Via header parameters
      are only defined\n   in SIP responses and MUST NOT be used in SIP requests.
      \ These\n   parameters are only useful to the upstream neighbor of a SIP server\n
      \  (i.e., the entity that is sending requests to the SIP server) since\n   the
      client is the entity that can offload traffic by redirecting or\n   rejecting
      new requests.  If requests are forwarded in both directions\n   between two
      SIP servers (i.e., the roles of upstream/downstream\n   neighbors change), there
      are also responses flowing in both\n   directions.  Thus, both SIP servers can
      exchange overload\n   information.\n   This specification provides a good overload
      control mechanism that\n   can protect a SIP server from overload.  However,
      if a SIP server\n   wants to limit advertisements of overload control capability
      for\n   privacy reasons, it might decide to perform overload control only for\n
      \  requests that are received on a secure transport, such as Transport\n   Layer
      Security (TLS).  Indicating support for overload control on a\n   request received
      on an untrusted link can leak privacy in the form of\n   capabilities supported
      by the server.  To limit the knowledge that\n   the server supports overload
      control, a server can adopt a policy of\n   inserting overload control parameters
      in only those requests received\n   over trusted links such that these parameters
      are only visible to\n   trusted neighbors.\n"
    title: 5.2.  Creating and Updating the Overload Control Parameters
  - contents:
    - "5.3.  Determining the \"oc\" Parameter Value\n   The value of the \"oc\" parameter
      is determined by the overloaded\n   server using any pertinent information at
      its disposal.  The only\n   constraint imposed by this document is that the
      server control\n   algorithm MUST produce a value for the \"oc\" parameter that
      it expects\n   the receiving SIP clients to apply to all downstream SIP requests\n
      \  (dialogue forming as well as in-dialogue) to this SIP server.  Beyond\n   this
      stipulation, the process by which an overloaded server\n   determines the value
      of the \"oc\" parameter is considered out of the\n   scope of this document.\n
      \     Note: This stipulation is required so that both the client and\n      server
      have a common view of which messages the overload control\n      applies to.
      \ With this stipulation in place, the client can\n      prioritize messages
      as discussed in Section 5.10.1.\n   As an example, a value of \"oc=10\" when
      the loss-based algorithm is\n   used implies that 10% of the total number of
      SIP requests (dialogue\n   forming as well as in-dialogue) are subject to reduction
      at the\n   client.  Analogously, a value of \"oc=10\" when the rate-based\n
      \  algorithm [RATE-CONTROL] is used indicates that the client should\n   send
      SIP requests at a rate of 10 SIP requests or fewer per second.\n"
    title: 5.3.  Determining the "oc" Parameter Value
  - contents:
    - "5.4.  Processing the Overload Control Parameters\n   A SIP client SHOULD remove
      the \"oc\", \"oc-validity\", and \"oc-seq\"\n   parameters from all Via headers
      of a response received, except for\n   the topmost Via header.  This prevents
      overload control parameters\n   that were accidentally or maliciously inserted
      into Via headers by a\n   downstream SIP server from traveling upstream.\n   The
      scope of overload control applies to unique combinations of IP\n   and port
      values.  A SIP client maintains the overload control values\n   received (along
      with the address and port number of the SIP servers\n   from which they were
      received) for the duration specified in the \"oc-\n   validity\" parameter or
      the default duration.  Each time a SIP client\n   receives a response with an
      overload control parameter from a\n   downstream SIP server, it compares the
      \"oc-seq\" value extracted from\n   the Via header with the \"oc-seq\" value
      stored for this server.  If\n   these values match, the response does not update
      the overload control\n   parameters related to this server, and the client continues
      to\n   provide overload control as previously negotiated.  If the \"oc-seq\"\n
      \  value extracted from the Via header is larger than the stored value,\n   the
      client updates the stored values by copying the new values of the\n   \"oc\",
      \"oc-algo\", and \"oc-seq\" parameters from the Via header to the\n   stored
      values.  Upon such an update of the overload control\n   parameters, the client
      restarts the validity period of the new\n   overload control parameters.  The
      overload control parameters now\n   remain in effect until the validity period
      expires or the parameters\n   are updated in a new response.  Stored overload
      control parameters\n   MUST be reset to default values once the validity period
      has expired\n   (see Section 5.7 for the detailed steps on terminating overload\n
      \  control).\n"
    title: 5.4.  Processing the Overload Control Parameters
  - contents:
    - "5.5.  Using the Overload Control Parameter Values\n   A SIP client MUST honor
      overload control values it receives from\n   downstream neighbors.  The SIP
      client MUST NOT forward more requests\n   to a SIP server than allowed by the
      current \"oc\" and \"oc-algo\"\n   parameter values from that particular downstream
      server.\n   When forwarding a SIP request, a SIP client uses the SIP procedures\n
      \  of [RFC3263] to determine the next-hop SIP server.  The procedures of\n   [RFC3263]
      take a SIP URI as input, extract the domain portion of that\n   URI for use
      as a lookup key, query the DNS to obtain an ordered set\n   of one or more IP
      addresses with a port number and transport\n   corresponding to each IP address
      in this set (the Expected Output).\n   After selecting a specific SIP server
      from the Expected Output, the\n   SIP client determines if it already has overload
      control parameter\n   values for the server chosen from the Expected Output.
      \ If the SIP\n   client has a non-expired \"oc\" parameter value for the server
      chosen\n   from the Expected Output, then this chosen server is operating in\n
      \  overload control mode.  Thus, the SIP client determines if it can or\n   cannot
      forward the current request to the SIP server based on the\n   \"oc\" and \"oc-algo\"
      parameters and any relevant local policy.\n   The particular algorithm used
      to determine whether or not to forward\n   a particular SIP request is a matter
      of local policy and may take\n   into account a variety of prioritization factors.
      \ However, this\n   local policy SHOULD transmit the same number of SIP requests
      as the\n   sample algorithm defined by the overload control scheme being used.\n
      \  (See Section 7.2 for the default loss-based overload control\n   algorithm.)\n"
    title: 5.5.  Using the Overload Control Parameter Values
  - contents:
    - "5.6.  Forwarding the Overload Control Parameters\n   Overload control is defined
      in a hop-by-hop manner.  Therefore,\n   forwarding the contents of the overload
      control parameters is\n   generally NOT RECOMMENDED and should only be performed
      if permitted\n   by the configuration of SIP servers.  This means that a SIP
      proxy\n   SHOULD strip the overload control parameters inserted by the client\n
      \  before proxying the request further downstream.  Of course, when the\n   proxy
      acts as a client and proxies the request downstream, it is free\n   to add overload
      control parameters pertinent to itself in the Via\n   header it inserted in
      the request.\n"
    title: 5.6.  Forwarding the Overload Control Parameters
  - contents:
    - "5.7.  Terminating Overload Control\n   A SIP client removes overload control
      if one of the following events\n   occur:\n   1.  The \"oc-validity\" period
      previously received by the client from\n       this server (or the default value
      of 500 ms if the server did not\n       previously specify an \"oc-validity\"
      parameter) expires.\n   2.  The client is explicitly told by the server to stop
      performing\n       overload control using the \"oc-validity=0\" parameter.\n
      \  A SIP server can decide to terminate overload control by explicitly\n   signaling
      the client.  To do so, the SIP server MUST set the value of\n   the \"oc-validity\"
      parameter to 0.  The SIP server MUST increment the\n   value of \"oc-seq\" and
      SHOULD set the value of the \"oc\" parameter to\n   0.\n      Note that the
      loss-based overload control scheme (Section 7) can\n      effectively stop overload
      control by setting the value of the \"oc\"\n      parameter to 0.  However,
      the rate-based scheme [RATE-CONTROL]\n      needs an additional piece of information
      in the form of \"oc-\n      validity=0\".\n   When the client receives a response
      with a higher \"oc-seq\" number\n   than the one it most recently processed,
      it checks the \"oc-validity\"\n   parameter.  If the value of the \"oc-validity\"
      parameter is 0, this\n   indicates to the client that overload control of messages
      destined to\n   the server is no longer necessary and the traffic can flow without\n
      \  any reduction.  Furthermore, when the value of the \"oc-validity\"\n   parameter
      is 0, the client SHOULD disregard the value in the \"oc\"\n   parameter.\n"
    title: 5.7.  Terminating Overload Control
  - contents:
    - "5.8.  Stabilizing Overload Algorithm Selection\n   Realities of deployments
      of SIP necessitate that the overload control\n   algorithm may be changed upon
      a system reboot or a software upgrade.\n   However, frequent changes of the
      overload control algorithm must be\n   avoided.  Frequent changes of the overload
      control algorithm will not\n   benefit the client or the server as such flapping
      does not allow the\n   chosen algorithm to stabilize.  An algorithm change,
      when desired, is\n   simply accomplished by the SIP server choosing a new algorithm
      from\n   the list in the client's \"oc-algo\" parameter and sending it back
      to\n   the client in a response.\n   The client associates a specific algorithm
      with each server it sends\n   traffic to, and when the server changes the algorithm,
      the client\n   must change its behavior accordingly.\n   Once the server selects
      a specific overload control algorithm for a\n   given client, the algorithm
      SHOULD NOT change the algorithm\n   associated with that client for at least
      3600 seconds (1 hour).  This\n   period may involve one or more cycles of overload
      control being in\n   effect and then being stopped depending on the traffic
      and resources\n   at the server.\n      Note: One way to accomplish this involves
      the server saving the\n      time of the last algorithm change in a lookup table,
      indexed by\n      the client's network identifiers.  The server only changes
      the\n      \"oc-algo\" parameter when the time since the last change has\n      surpassed
      3600 seconds.\n"
    title: 5.8.  Stabilizing Overload Algorithm Selection
  - contents:
    - "5.9.  Self-Limiting\n   In some cases, a SIP client may not receive a response
      from a server\n   after sending a request.  RFC 3261 [RFC3261] states:\n      Note:
      When a timeout error is received from the transaction layer,\n      it MUST
      be treated as if a 408 (Request Timeout) status code has\n      been received.
      \ If a fatal transport error is reported by the\n      transport layer ...,
      the condition MUST be treated as a 503\n      (Service Unavailable) status code.\n
      \  In the event of repeated timeouts or fatal transport errors, the SIP\n   client
      MUST stop sending requests to this server.  The SIP client\n   SHOULD periodically
      probe if the downstream server is alive using any\n   mechanism at its disposal.
      \ Clients should be conservative in their\n   probing (e.g., using an exponential
      back-off) so that their liveness\n   probes do not exacerbate an overload situation.
      \ Once a SIP client\n   has successfully received a normal response for a request
      sent to the\n   downstream server, the SIP client can resume sending SIP requests.\n
      \  It should, of course, honor any overload control parameters it may\n   receive
      in the initial, or later, responses.\n"
    title: 5.9.  Self-Limiting
  - contents:
    - "5.10.  Responding to an Overload Indication\n   A SIP client can receive overload
      control feedback indicating that it\n   needs to reduce the traffic it sends
      to its downstream server.  The\n   client can accomplish this task by sending
      some of the requests that\n   would have gone to the overloaded element to a
      different destination.\n   It needs to ensure, however, that this destination
      is not in overload\n   and is capable of processing the extra load.  A client
      can also\n   buffer requests in the hope that the overload condition will resolve\n
      \  quickly and the requests can still be forwarded in time.  In many\n   cases,
      however, it will need to reject these requests with a \"503\n   (Service Unavailable)\"
      response without the Retry-After header.\n"
    - contents:
      - "5.10.1.  Message Prioritization at the Hop before the Overloaded Server\n
        \  During an overload condition, a SIP client needs to prioritize\n   requests
        and select those requests that need to be rejected or\n   redirected.  This
        selection is largely a matter of local policy.  It\n   is expected that a
        SIP client will follow local policy as long as the\n   result in reduction
        of traffic is consistent with the overload\n   algorithm in effect at that
        node.  Accordingly, the normative\n   behavior in the next three paragraphs
        should be interpreted with the\n   understanding that the SIP client will
        aim to preserve local policy\n   to the fullest extent possible.\n   A SIP
        client SHOULD honor the local policy for prioritizing SIP\n   requests such
        as policies based on message type, e.g., INVITEs versus\n   requests associated
        with existing sessions.\n   A SIP client SHOULD honor the local policy for
        prioritizing SIP\n   requests based on the content of the Resource-Priority
        header (RPH)\n   [RFC4412].  Specific (namespace.value) RPH contents may indicate\n
        \  high-priority requests that should be preserved as much as possible\n   during
        overload.  The RPH contents can also indicate a low-priority\n   request that
        is eligible to be dropped during times of overload.\n   A SIP client SHOULD
        honor the local policy for prioritizing SIP\n   requests relating to emergency
        calls as identified by the SOS URN\n   [RFC5031] indicating an emergency request.
        \ This policy ensures that\n   when a server is overloaded and non-emergency
        calls outnumber\n   emergency calls in the traffic arriving at the client,
        the few\n   emergency calls will be given preference.  If, on the other hand,
        the\n   server is overloaded and the majority of calls arriving at the client\n
        \  are emergency in nature, then no amount of message prioritization\n   will
        ensure the delivery of all emergency calls if the client is to\n   reduce
        the amount of traffic as requested by the server.\n   A local policy can be
        expected to combine both the SIP request type\n   and the prioritization markings,
        and it SHOULD be honored when\n   overload conditions prevail.\n"
      title: 5.10.1.  Message Prioritization at the Hop before the Overloaded Server
    - contents:
      - "5.10.2.  Rejecting Requests at an Overloaded Server\n   If the upstream SIP
        client to the overloaded server does not support\n   overload control, it
        will continue to direct requests to the\n   overloaded server.  Thus, for
        the non-participating client, the\n   overloaded server must bear the cost
        of rejecting some requests from\n   the client as well as the cost of processing
        the non-rejected\n   requests to completion.  It would be fair to devote the
        same amount\n   of processing at the overloaded server to the combination
        of\n   rejection and processing from a non-participating client as the\n   overloaded
        server would devote to processing requests from a\n   participating client.
        \ This is to ensure that SIP clients that do not\n   support this specification
        don't receive an unfair advantage over\n   those that do.\n   A SIP server
        that is in overload and has started to throttle incoming\n   traffic MUST
        reject some requests from non-participating clients with\n   a 503 (Service
        Unavailable) response without the Retry-After header.\n"
      title: 5.10.2.  Rejecting Requests at an Overloaded Server
    title: 5.10.  Responding to an Overload Indication
  - contents:
    - "5.11.  100 Trying Provisional Response and Overload Control Parameters\n   The
      overload control information sent from a SIP server to a client\n   is transported
      in the responses.  While implementations can insert\n   overload control information
      in any response, special attention\n   should be accorded to overload control
      information transported in a\n   100 Trying response.\n   Traditionally, the
      100 Trying response has been used in SIP to quench\n   retransmissions.  In
      some implementations, the 100 Trying message may\n   not be generated by the
      transaction user (TU) nor consumed by the TU.\n   In these implementations,
      the 100 Trying response is generated at the\n   transaction layer and sent to
      the upstream SIP client.  At the\n   receiving SIP client, the 100 Trying is
      consumed at the transaction\n   layer by inhibiting the retransmission of the
      corresponding request.\n   Consequently, implementations that insert overload
      control\n   information in the 100 Trying cannot assume that the upstream SIP\n
      \  client passed the overload control information in the 100 Trying to\n   their
      corresponding TU.  For this reason, implementations that insert\n   overload
      control information in the 100 Trying MUST re-insert the\n   same (or updated)
      overload control information in the first non-100\n   Trying response being
      sent to the upstream SIP client.\n"
    title: 5.11.  100 Trying Provisional Response and Overload Control Parameters
  title: 5.  General Behavior
- contents:
  - "6.  Example\n   Consider a SIP client, P1, which is sending requests to another\n
    \  downstream SIP server, P2.  The following snippets of SIP messages\n   demonstrate
    how the overload control parameters work.\n           INVITE sips:user@example.com
    SIP/2.0\n           Via: SIP/2.0/TLS p1.example.net;\n             branch=z9hG4bK2d4790.1;oc;oc-algo=\"loss,A\"\n
    \          ...\n           SIP/2.0 100 Trying\n           Via: SIP/2.0/TLS p1.example.net;\n
    \            branch=z9hG4bK2d4790.1;received=192.0.2.111;\n             oc=0;oc-algo=\"loss\";oc-validity=0\n
    \          ...\n   In the messages above, the first line is sent by P1 to P2.
    \ This line\n   is a SIP request; because P1 supports overload control, it inserts\n
    \  the \"oc\" parameter in the topmost Via header that it created.  P1\n   supports
    two overload control algorithms: \"loss\" and an algorithm\n   called \"A\".\n
    \  The second line -- a SIP response -- shows the topmost Via header\n   amended
    by P2 according to this specification and sent to P1.\n   Because P2 also supports
    overload control and chooses the loss-based\n   scheme, it sends \"loss\" back
    to P1 in the \"oc-algo\" parameter.  It\n   also sets the value of the \"oc\"
    and \"oc-validity\" parameters to 0\n   because it is not currently requesting
    overload control activation.\n   Had P2 not supported overload control, it would
    have left the \"oc\"\n   and \"oc-algo\" parameters unchanged, thus allowing the
    client to know\n   that it did not support overload control.\n   At some later
    time, P2 starts to experience overload.  It sends the\n   following SIP message
    indicating that P1 should decrease the messages\n   arriving to P2 by 20% for
    0.5 seconds.\n          SIP/2.0 180 Ringing\n          Via: SIP/2.0/TLS p1.example.net;\n
    \           branch=z9hG4bK2d4790.3;received=192.0.2.111;\n            oc=20;oc-algo=\"loss\";oc-validity=500;\n
    \           oc-seq=1282321615.782\n          ...\n   After some time, the overload
    condition at P2 subsides.  It then\n   changes the parameter values in the response
    it sends to P1 to allow\n   P1 to send all messages destined to P2.\n          SIP/2.0
    183 Queued\n          Via: SIP/2.0/TLS p1.example.net;\n            branch=z9hG4bK2d4790.4;received=192.0.2.111;\n
    \           oc=0;oc-algo=\"loss\";oc-validity=0;oc-seq=1282321892.439\n          ...\n"
  title: 6.  Example
- contents:
  - "7.  The Loss-Based Overload Control Scheme\n   Under a loss-based approach, a
    SIP server asks an upstream neighbor\n   to reduce the number of requests it would
    normally forward to this\n   server by a certain percentage.  For example, a SIP
    server can ask an\n   upstream neighbor to reduce the number of requests this
    neighbor\n   would normally send by 10%.  The upstream neighbor then redirects
    or\n   rejects 10% of the traffic originally destined for that server.\n   This
    section specifies the semantics of the overload control\n   parameters associated
    with the loss-based overload control scheme.\n   The general behavior of SIP clients
    and servers is specified in\n   Section 5 and is applicable to SIP clients and
    servers that implement\n   loss-based overload control.\n"
  - contents:
    - "7.1.  Special Parameter Values for Loss-Based Overload Control\n   The loss-based
      overload control scheme is identified using the token\n   \"loss\".  This token
      appears in the \"oc-algo\" parameter list sent by\n   the SIP client.\n   Upon
      entering the overload state, a SIP server that has selected the\n   loss-based
      algorithm will assign a value to the \"oc\" parameter.  This\n   value MUST
      be in the range of [0, 100], inclusive.  This value\n   indicates to the client
      the percentage by which the client is to\n   reduce the number of requests being
      forwarded to the overloaded\n   server.  The SIP client may use any algorithm
      that reduces the\n   traffic it sends to the overloaded server by the amount
      indicated.\n   Such an algorithm should honor the message prioritization discussion\n
      \  in Section 5.10.1.  While a particular algorithm is not subject to\n   standardization,
      for completeness, a default algorithm for loss-based\n   overload control is
      provided in Section 7.2.\n"
    title: 7.1.  Special Parameter Values for Loss-Based Overload Control
  - contents:
    - "7.2.  Default Algorithm for Loss-Based Overload Control\n   This section describes
      a default algorithm that a SIP client can use\n   to throttle SIP traffic going
      downstream by the percentage loss value\n   specified in the \"oc\" parameter.\n
      \  The client maintains two categories of requests.  The first category\n   will
      include requests that are candidates for reduction, and the\n   second category
      will include requests that are not subject to\n   reduction except when all
      messages in the first category have been\n   rejected and further reduction
      is still needed.  Section 5.10.1\n   contains directives on identifying messages
      for inclusion in the\n   second category.  The remaining messages are allocated
      to the first\n   category.\n   Under overload condition, the client converts
      the value of the \"oc\"\n   parameter to a value that it applies to requests
      in the first\n   category.  As a simple example, if \"oc=10\" and 40% of the
      requests\n   should be included in the first category, then:\n      10 / 40
      * 100 = 25\n   Or, 25% of the requests in the first category can be reduced
      to get\n   an overall reduction of 10%.  The client uses random discard to\n
      \  achieve the 25% reduction of messages in the first category.\n   Messages
      in the second category proceed downstream unscathed.  To\n   affect the 25%
      reduction rate from the first category, the client\n   draws a random number
      between 1 and 100 for the request picked from\n   the first category.  If the
      random number is less than or equal to\n   the converted value of the \"oc\"
      parameter, the request is not\n   forwarded; otherwise, the request is forwarded.\n
      \  A reference algorithm is shown below.\n"
    - 'cat1 := 80.0         // Category 1 -- Subject to reduction

      '
    - 'cat2 := 100.0 - cat1 // Category 2 -- Under normal operations,

      '
    - '// only subject to reduction after category 1 is exhausted.

      '
    - '// Note that the above ratio is simply a reasonable default.

      '
    - '// The actual values will change through periodic sampling

      '
    - '// as the traffic mix changes over time.

      '
    - "while (true) {\n  // We're modeling message processing as a single work\n  //
      queue that contains both incoming and outgoing messages.\n  sip_msg := get_next_message_from_work_queue()\n
      \ update_mix(cat1, cat2)  // See Note below\n  switch (sip_msg.type) {\n    case
      outbound request:\n      destination := get_next_hop(sip_msg)\n      oc_context
      := get_oc_context(destination)\n      if (oc_context == null)  {\n          send_to_network(sip_msg)
      // Process it normally by\n          // sending the request to the next hop
      since this\n          // particular destination is not subject to overload.\n
      \     }\n      else  {\n         // Determine if server wants to enter in overload
      or is in\n         // overload.\n         in_oc := extract_in_oc(oc_context)\n
      \        oc_value := extract_oc(oc_context)\n         oc_validity := extract_oc_validity(oc_context)\n
      \        if (in_oc == false or oc_validity is not in effect)  {\n            send_to_network(sip_msg)
      // Process it normally by sending\n            // the request to the next hop
      since this particular\n            // destination is not subject to overload.
      \ Optionally,\n            // clear the oc context for this server (not shown).\n
      \        }\n         else  {  // Begin performing overload control.\n            r
      := random()\n            drop_msg := false\n            category := assign_msg_to_category(sip_msg)\n
      \           pct_to_reduce_cat1 = oc_value / cat1 * 100\n            if (oc_value
      <= cat1)  {  // Reduce all msgs from category 1\n                if (r <= pct_to_reduce_cat1
      && category == cat1)  {\n                   drop_msg := true\n                }\n
      \           }\n            else  { // oc_value > category 1.  Reduce 100% of
      msgs from\n                    // category 1 and remaining from category 2.\n
      \              pct_to_reduce_cat2 = (oc_value - cat1) / cat2 * 100\n               if
      (category == cat1)  {\n                  drop_msg := true\n               }\n
      \              else  {\n                  if (r <= pct_to_reduce_cat2)  {\n
      \                     drop_msg := true;\n                  }\n               }\n
      \           }\n            if (drop_msg == false) {\n                send_to_network(sip_msg)
      // Process it normally by\n               // sending the request to the next
      hop.\n            }\n            else  {\n               // Do not send request
      downstream; handle it locally by\n               // generating response (if
      a proxy) or treating it as\n               // an error (if a user agent).\n
      \           }\n         }  // End perform overload control.\n      }\n    end
      case // outbound request\n    case outbound response:\n      if (we are in overload)
      {\n        add_overload_parameters(sip_msg)\n      }\n      send_to_network(sip_msg)\n
      \   end case // outbound response\n    case inbound response:\n       if (sip_msg
      has oc parameter values)  {\n           create_or_update_oc_context()  // For
      the specific server\n           // that sent the response, create or update
      the oc context,\n           // i.e., extract the values of the oc-related parameters\n
      \          // and store them for later use.\n       }\n       process_msg(sip_msg)\n
      \   end case // inbound response\n    case inbound request:\n      if (we are
      not in overload)  {\n         process_msg(sip_msg)\n      }\n      else {  //
      We are in overload.\n         if (sip_msg has oc parameters)  {  // Upstream
      client supports\n            process_msg(sip_msg)  // oc; only sends important
      requests.\n         }\n         else {  // Upstream client does not support
      oc\n            if (local_policy(sip_msg) says process message)  {\n               process_msg(sip_msg)\n
      \           }\n            else  {\n               send_response(sip_msg, 503)\n
      \           }\n         }\n      }\n    end case // inbound request\n  }\n"
    - "}\n   Note: A simple way to sample the traffic mix for category 1 and\n   category
      2 is to associate a counter with each category of message.\n   Periodically
      (every 5-10 seconds), get the value of the counters, and\n   calculate the ratio
      of category 1 messages to category 2 messages\n   since the last calculation.\n
      \  Example: In the last 5 seconds, a total of 500 requests arrived at\n   the
      queue.  450 out of the 500 were messages subject to reduction,\n   and 50 out
      of 500 were classified as requests not subject to\n   reduction.  Based on this
      ratio, cat1 := 90 and cat2 := 10, so a\n   90/10 mix will be used in overload
      calculations.\n"
    title: 7.2.  Default Algorithm for Loss-Based Overload Control
  title: 7.  The Loss-Based Overload Control Scheme
- contents:
  - "8.  Relationship with Other IETF SIP Load Control Efforts\n   The overload control
    mechanism described in this document is reactive\n   in nature, and apart from
    the message prioritization directives\n   listed in Section 5.10.1, the mechanisms
    described in this document\n   will not discriminate requests based on user identity,
    filtering\n   action, and arrival time.  SIP networks that require pro-active\n
    \  overload control mechanisms can upload user-level load control\n   filters
    as described in [RFC7200].  Local policy will also dictate\n   the precedence
    of different overload control mechanisms applied to\n   the traffic.  Specifically,
    in a scenario where load control filters\n   are installed by signaling neighbors
    [RFC7200] and the same traffic\n   can also be throttled using the overload control
    mechanism, local\n   policy will dictate which of these schemes shall be given
    precedence.\n   Interactions between the two schemes are out of the scope of this\n
    \  document.\n"
  title: 8.  Relationship with Other IETF SIP Load Control Efforts
- contents:
  - "9.  Syntax\n   This specification extends the existing definition of the Via
    header\n   field parameters of [RFC3261].  The ABNF [RFC5234] syntax is as\n   follows:\n
    \      via-params  =/ oc / oc-validity / oc-seq / oc-algo\n       oc          =
    \"oc\" [EQUAL oc-num]\n       oc-num      = 1*DIGIT\n       oc-validity = \"oc-validity\"
    [EQUAL delta-ms]\n       oc-seq      = \"oc-seq\" EQUAL 1*12DIGIT \".\" 1*5DIGIT\n
    \      oc-algo     = \"oc-algo\" EQUAL DQUOTE algo-list *(COMMA algo-list)\n                     DQUOTE\n
    \      algo-list   = \"loss\" / *(other-algo)\n       other-algo  = %x41-5A /
    %x61-7A / %x30-39\n       delta-ms    = 1*DIGIT\n"
  title: 9.  Syntax
- contents:
  - "10.  Design Considerations\n   This section discusses specific design considerations
    for the\n   mechanism described in this document.  General design considerations\n
    \  for SIP overload control can be found in [RFC6357].\n"
  - contents:
    - "10.1.  SIP Mechanism\n   A SIP mechanism is needed to convey overload feedback
      from the\n   receiving to the sending SIP entity.  A number of different\n   alternatives
      exist to implement such a mechanism.\n"
    - contents:
      - "10.1.1.  SIP Response Header\n   Overload control information can be transmitted
        using a new Via\n   header field parameter for overload control.  A SIP server
        can add\n   this header parameter to the responses it is sending upstream
        to\n   provide overload control feedback to its upstream neighbors.  This\n
        \  approach has the following characteristics:\n   o  A Via header parameter
        is light-weight and creates very little\n      overhead.  It does not require
        the transmission of additional\n      messages for overload control and does
        not increase traffic or\n      processing burdens in an overload situation.\n
        \  o  Overload control status can frequently be reported to upstream\n      neighbors
        since it is a part of a SIP response.  This enables the\n      use of this
        mechanism in scenarios where the overload status needs\n      to be adjusted
        frequently.  It also enables the use of overload\n      control mechanisms
        that use regular feedback, such as window-based\n      overload control.\n
        \  o  With a Via header parameter, overload control status is inherent\n      in
        SIP signaling and is automatically conveyed to all relevant\n      upstream
        neighbors, i.e., neighbors that are currently\n      contributing traffic.
        \ There is no need for a SIP server to\n      specifically track and manage
        the set of current upstream or\n      downstream neighbors with which it should
        exchange overload\n      feedback.\n   o  Overload status is not conveyed
        to inactive senders.  This avoids\n      the transmission of overload feedback
        to inactive senders, which\n      do not contribute traffic.  If an inactive
        sender starts to\n      transmit while the receiver is in overload, it will
        receive\n      overload feedback in the first response and can adjust the
        amount\n      of traffic forwarded accordingly.\n   o  A SIP server can limit
        the distribution of overload control\n      information by only inserting
        it into responses to known upstream\n      neighbors.  A SIP server can use
        transport-level authentication\n      (e.g., via TLS) with its upstream neighbors.\n"
      title: 10.1.1.  SIP Response Header
    - contents:
      - "10.1.2.  SIP Event Package\n   Overload control information can also be conveyed
        from a receiver to\n   a sender using a new event package.  Such an event
        package enables a\n   sending entity to subscribe to the overload status of
        its downstream\n   neighbors and receive notifications of overload control
        status\n   changes in NOTIFY requests.  This approach has the following\n
        \  characteristics:\n   o  Overload control information is conveyed decoupled
        from SIP\n      signaling.  It enables an overload control manager, which
        is a\n      separate entity, to monitor the load on other servers and provide\n
        \     overload control feedback to all SIP servers that have set up\n      subscriptions
        with the controller.\n   o  With an event package, a receiver can send updates
        to senders that\n      are currently inactive.  Inactive senders will receive
        a\n      notification about the overload and can refrain from sending\n      traffic
        to this neighbor until the overload condition is resolved.\n      The receiver
        can also notify all potential senders once they are\n      permitted to send
        traffic again.  However, these notifications do\n      generate additional
        traffic, which adds to the overall load.\n   o  A SIP entity needs to set
        up and maintain overload control\n      subscriptions with all upstream and
        downstream neighbors.  A new\n      subscription needs to be set up before/while
        a request is\n      transmitted to a new downstream neighbor.  Servers can
        be\n      configured to subscribe at boot time.  However, this would require\n
        \     additional protection to avoid the avalanche restart problem for\n      overload
        control.  Subscriptions need to be terminated when they\n      are not needed
        any more, which can be done, for example, using a\n      timeout mechanism.\n
        \  o  A receiver needs to send NOTIFY messages to all subscribed\n      upstream
        neighbors in a timely manner when the control algorithm\n      requires a
        change in the control variable (e.g., when a SIP server\n      is in an overload
        condition).  This includes active as well as\n      inactive neighbors.  These
        NOTIFYs add to the amount of traffic\n      that needs to be processed.  To
        ensure that these requests will\n      not be dropped due to overload, a priority
        mechanism needs to be\n      implemented in all servers these requests will
        pass through.\n   o  As overload feedback is sent to all senders in separate
        messages,\n      this mechanism is not suitable when frequent overload control\n
        \     feedback is needed.\n   o  A SIP server can limit the set of senders
        that can receive\n      overload control information by authenticating subscriptions
        to\n      this event package.\n   o  This approach requires each proxy to
        implement user agent\n      functionality (UAS and UAC) to manage the subscriptions.\n"
      title: 10.1.2.  SIP Event Package
    title: 10.1.  SIP Mechanism
  - contents:
    - "10.2.  Backwards Compatibility\n   A new overload control mechanism needs to
      be backwards compatible so\n   that it can be gradually introduced into a network
      and function\n   properly if only a fraction of the servers support it.\n   Hop-by-hop
      overload control (see [RFC6357]) has the advantage that it\n   does not require
      that all SIP entities in a network support it.  It\n   can be used effectively
      between two adjacent SIP servers if both\n   servers support overload control
      and does not depend on the support\n   from any other server or user agent.
      \ The more SIP servers in a\n   network support hop-by-hop overload control,
      the better protected the\n   network is against occurrences of overload.\n   A
      SIP server may have multiple upstream neighbors from which only\n   some may
      support overload control.  If a server would simply use this\n   overload control
      mechanism, only those that support it would reduce\n   traffic.  Others would
      keep sending at the full rate and benefit from\n   the throttling by the servers
      that support overload control.  In\n   other words, upstream neighbors that
      do not support overload control\n   would be better off than those that do.\n
      \  A SIP server should therefore follow the behavior outlined in\n   Section
      5.10.2 to handle clients that do not support overload\n   control.\n"
    title: 10.2.  Backwards Compatibility
  title: 10.  Design Considerations
- contents:
  - "11.  Security Considerations\n   Overload control mechanisms can be used by an
    attacker to conduct a\n   denial-of-service attack on a SIP entity if the attacker
    can pretend\n   that the SIP entity is overloaded.  When such a forged overload\n
    \  indication is received by an upstream SIP client, it will stop\n   sending
    traffic to the victim.  Thus, the victim is subject to a\n   denial-of-service
    attack.\n   To better understand the threat model, consider the following\n   diagram:\n
    \        Pa -------                    ------ Pb\n                   \\                  /\n
    \        :  ------ +-------- P1 ------+------ :\n                   /    L1        L2
    \ \\\n         :  -------                    ------ :\n         -----> Downstream
    (requests)\n         <----- Upstream (responses)\n   Here, requests travel downstream
    from the left-hand side, through\n   Proxy P1, towards the right-hand side; responses
    travel upstream from\n   the right-hand side, through P1, towards the left-hand
    side.  Proxies\n   Pa, Pb, and P1 support overload control.  L1 and L2 are labels
    for\n   the links connecting P1 to the upstream clients and downstream\n   servers.\n
    \  If an attacker is able to modify traffic between Pa and P1 on link\n   L1,
    it can cause a denial-of-service attack on P1 by having Pa not\n   send any traffic
    to P1.  Such an attack can proceed by the attacker\n   modifying the response
    from P1 to Pa such that Pa's Via header is\n   changed to indicate that all requests
    destined towards P1 should be\n   dropped.  Conversely, the attacker can simply
    remove any \"oc\", \"oc-\n   validity\", and \"oc-seq\" markings added by P1 in
    a response to Pa.  In\n   such a case, the attacker will force P1 into overload
    by denying\n   request quenching at Pa even though Pa is capable of performing\n
    \  overload control.\n   Similarly, if an attacker is able to modify traffic between
    P1 and Pb\n   on link L2, it can change the Via header associated with P1 in a\n
    \  response from Pb to P1 such that all subsequent requests destined\n   towards
    Pb from P1 are dropped.  In essence, the attacker mounts a\n   denial-of-service
    attack on Pb by indicating false overload control.\n   Note that it is immaterial
    whether Pb supports overload control or\n   not; the attack will succeed as long
    as the attacker is able to\n   control L2.  Conversely, an attacker can suppress
    a genuine overload\n   condition at Pb by simply removing any \"oc\", \"oc-validity\",
    and \"oc-\n   seq\" markings added by Pb in a response to P1.  In such a case,
    the\n   attacker will force P1 into sending requests to Pb even under\n   overload
    conditions because P1 would not be aware that Pb supports\n   overload control.\n
    \  Attacks that indicate false overload control are best mitigated by\n   using
    TLS in conjunction with applying BCP 38 [RFC2827].  Attacks\n   that are mounted
    to suppress genuine overload conditions can be\n   similarly avoided by using
    TLS on the connection.  Generally, TCP or\n   WebSockets [RFC6455] in conjunction
    with BCP 38 makes it more\n   difficult for an attacker to insert or modify messages
    but may still\n   prove inadequate against an adversary that controls links L1
    and L2.\n   TLS provides the best protection from an attacker with access to the\n
    \  network links.\n   Another way to conduct an attack is to send a message containing
    a\n   high overload feedback value through a proxy that does not support\n   this
    extension.  If this feedback is added to the second Via header\n   (or all Via
    headers), it will reach the next upstream proxy.  If the\n   attacker can make
    the recipient believe that the overload status was\n   created by its direct downstream
    neighbor (and not by the attacker\n   further downstream), the recipient stops
    sending traffic to the\n   victim.  A precondition for this attack is that the
    victim proxy does\n   not support this extension since it would not pass through
    overload\n   control feedback otherwise.\n   A malicious SIP entity could gain
    an advantage by pretending to\n   support this specification but never reducing
    the amount of traffic\n   it forwards to the downstream neighbor.  If its downstream
    neighbor\n   receives traffic from multiple sources that correctly implement\n
    \  overload control, the malicious SIP entity would benefit since all\n   other
    sources to its downstream neighbor would reduce load.\n      Note: The solution
    to this problem depends on the overload control\n      method.  With rate-based,
    window-based, and other similar overload\n      control algorithms that promise
    to produce no more than a\n      specified number of requests per unit time, the
    overloaded server\n      can regulate the traffic arriving to it.  However, when
    using\n      loss-based overload control, such policing is not always obvious\n
    \     since the load forwarded depends on the load received by the\n      client.\n
    \  To prevent such attacks, servers should monitor client behavior to\n   determine
    whether they are complying with overload control policies.\n   If a client is
    not conforming to such policies, then the server\n   should treat it as a non-supporting
    client (see Section 5.10.2).\n   Finally, a distributed denial-of-service (DDoS)
    attack could cause an\n   honest server to start signaling an overload condition.
    \ Such a DDoS\n   attack could be mounted without controlling the communications
    links\n   since the attack simply depends on the attacker injecting a large\n
    \  volume of packets on the communication links.  If the honest server\n   attacked
    by a DDoS attack has a long \"oc-validity\" interval and the\n   attacker can
    guess this interval, the attacker can keep the server\n   overloaded by synchronizing
    the DDoS traffic with the validity\n   period.  While such an attack may be relatively
    easy to spot,\n   mechanisms for combating it are outside the scope of this document\n
    \  and, of course, since attackers can invent new variations, the\n   appropriate
    mechanisms are likely to change over time.\n"
  title: 11.  Security Considerations
- contents:
  - "12.  IANA Considerations\n   This specification defines four new Via header parameters
    as detailed\n   below in the \"Header Field Parameter and Parameter Values\" sub-\n
    \  registry as per the registry created by [RFC3968].  The required\n   information
    is:\n       Header Field  Parameter Name  Predefined Values  Reference\n       __________________________________________________________\n
    \      Via           oc                 Yes             [RFC7339]\n       Via
    \          oc-validity        Yes             [RFC7339]\n       Via           oc-seq
    \            Yes             [RFC7339]\n       Via           oc-algo            Yes
    \            [RFC7339]\n"
  title: 12.  IANA Considerations
- contents:
  - '13.  References

    '
  - contents:
    - "13.1.  Normative References\n   [RFC2119]  Bradner, S., \"Key words for use
      in RFCs to Indicate\n              Requirement Levels\", BCP 14, RFC 2119, March
      1997.\n   [RFC3261]  Rosenberg, J., Schulzrinne, H., Camarillo, G., Johnston,\n
      \             A., Peterson, J., Sparks, R., Handley, M., and E.\n              Schooler,
      \"SIP: Session Initiation Protocol\", RFC 3261,\n              June 2002.\n
      \  [RFC3263]  Rosenberg, J. and H. Schulzrinne, \"Session Initiation\n              Protocol
      (SIP): Locating SIP Servers\", RFC 3263, June\n              2002.\n   [RFC3968]
      \ Camarillo, G., \"The Internet Assigned Number Authority\n              (IANA)
      Header Field Parameter Registry for the Session\n              Initiation Protocol
      (SIP)\", BCP 98, RFC 3968, December\n              2004.\n   [RFC4412]  Schulzrinne,
      H. and J. Polk, \"Communications Resource\n              Priority for the Session
      Initiation Protocol (SIP)\", RFC\n              4412, February 2006.\n   [RFC5234]
      \ Crocker, D. and P. Overell, \"Augmented BNF for Syntax\n              Specifications:
      ABNF\", STD 68, RFC 5234, January 2008.\n"
    title: 13.1.  Normative References
  - contents:
    - "13.2.  Informative References\n   [RATE-CONTROL]\n              Noel, E. and
      P. Williams, \"Session Initiation Protocol\n              (SIP) Rate Control\",
      Work in Progress, July 2014.\n   [RFC2827]  Ferguson, P. and D. Senie, \"Network
      Ingress Filtering:\n              Defeating Denial of Service Attacks which
      employ IP Source\n              Address Spoofing\", BCP 38, RFC 2827, May 2000.\n
      \  [RFC5031]  Schulzrinne, H., \"A Uniform Resource Name (URN) for\n              Emergency
      and Other Well-Known Services\", RFC 5031,\n              January 2008.\n   [RFC5390]
      \ Rosenberg, J., \"Requirements for Management of Overload in\n              the
      Session Initiation Protocol\", RFC 5390, December 2008.\n   [RFC6357]  Hilt,
      V., Noel, E., Shen, C., and A. Abdelal, \"Design\n              Considerations
      for Session Initiation Protocol (SIP)\n              Overload Control\", RFC
      6357, August 2011.\n   [RFC6455]  Fette, I. and A. Melnikov, \"The WebSocket
      Protocol\", RFC\n              6455, December 2011.\n   [RFC7200]  Shen, C.,
      Schulzrinne, H., and A. Koike, \"A Session\n              Initiation Protocol
      (SIP) Load-Control Event Package\", RFC\n              7200, April 2014.\n"
    title: 13.2.  Informative References
  title: 13.  References
- contents:
  - "Appendix A.  Acknowledgements\n   The authors acknowledge the contributions of
    Bruno Chatras, Keith\n   Drage, Janet Gunn, Rich Terpstra, Daryl Malas, Eric Noel,
    R.\n   Parthasarathi, Antoine Roly, Jonathan Rosenberg, Charles Shen, Rahul\n
    \  Srivastava, Padma Valluri, Shaun Bharrat, Paul Kyzivat, and Jeroen\n   Van
    Bemmel to this document.\n   Adam Roach and Eric McMurry helped flesh out the
    different cases for\n   handling SIP messages described in the algorithm in Section
    7.2.\n   Janet Gunn reviewed the algorithm and suggested changes that led to\n
    \  simpler processing for the case where \"oc_value > cat1\".\n   Richard Barnes
    provided invaluable comments as a part of the Area\n   Director review of the
    document.\n"
  title: Appendix A.  Acknowledgements
- contents:
  - "Appendix B.  RFC 5390 Requirements\n   Table 1 provides a summary of how this
    specification fulfills the\n   requirements of [RFC5390].  A more detailed view
    on how each\n   requirements is fulfilled is provided after the table.\n                    +-------------+-------------------+\n
    \                   | Requirement | Meets requirement |\n                    +-------------+-------------------+\n
    \                   | REQ 1       | Yes               |\n                    |
    REQ 2       | Yes               |\n                    | REQ 3       | Partially
    \        |\n                    | REQ 4       | Yes               |\n                    |
    REQ 5       | Partially         |\n                    | REQ 6       | Not applicable
    \   |\n                    | REQ 7       | Yes               |\n                    |
    REQ 8       | Partially         |\n                    | REQ 9       | Yes               |\n
    \                   | REQ 10      | Yes               |\n                    |
    REQ 11      | Yes               |\n                    | REQ 12      | Yes               |\n
    \                   | REQ 13      | Yes               |\n                    |
    REQ 14      | Yes               |\n                    | REQ 15      | Yes               |\n
    \                   | REQ 16      | Yes               |\n                    |
    REQ 17      | Partially         |\n                    | REQ 18      | Yes               |\n
    \                   | REQ 19      | Yes               |\n                    |
    REQ 20      | Yes               |\n                    | REQ 21      | Yes               |\n
    \                   | REQ 22      | Yes               |\n                    |
    REQ 23      | Yes               |\n                    +-------------+-------------------+\n
    \          Table 1: Summary of Meeting Requirements in RFC 5390\n   REQ 1: The
    overload mechanism shall strive to maintain the overall\n   useful throughput
    (taking into consideration the quality-of-service\n   needs of the using applications)
    of a SIP server at reasonable\n   levels, even when the incoming load on the network
    is far in excess\n   of its capacity.  The overall throughput under load is the
    ultimate\n   measure of the value of an overload control mechanism.\n      Meets
    REQ 1: Yes.  The overload control mechanism allows an\n      overloaded SIP server
    to maintain a reasonable level of throughput\n      as it enters into congestion
    mode by requesting the upstream\n      clients to reduce traffic destined downstream.\n
    \  REQ 2: When a single network element fails, goes into overload, or\n   suffers
    from reduced processing capacity, the mechanism should strive\n   to limit the
    impact of this on other elements in the network.  This\n   helps to prevent a
    small-scale failure from becoming a widespread\n   outage.\n      Meets REQ 2:
    Yes.  When a SIP server enters overload mode, it will\n      request the upstream
    clients to throttle the traffic destined to\n      it.  As a consequence of this,
    the overloaded SIP server will\n      itself generate proportionally less downstream
    traffic, thereby\n      limiting the impact on other elements in the network.\n
    \  REQ 3: The mechanism should seek to minimize the amount of\n   configuration
    required in order to work.  For example, it is better\n   to avoid needing to
    configure a server with its SIP message\n   throughput, as these kinds of quantities
    are hard to determine.\n      Meets REQ 3: Partially.  On the server side, the
    overload\n      condition is determined monitoring \"S\" (cf., Section 4 of\n
    \     [RFC6357]) and reporting a load feedback \"F\" as a value to the\n      \"oc\"
    parameter.  On the client side, a throttle \"T\" is applied to\n      requests
    going downstream based on \"F\".  This specification does\n      not prescribe
    any value for \"S\" nor a particular value for \"F\".\n      The \"oc-algo\" parameter
    allows for automatic convergence to a\n      particular class of overload control
    algorithm.  There are\n      suggested default values for the \"oc-validity\"
    parameter.\n   REQ 4: The mechanism must be capable of dealing with elements that
    do\n   not support it so that a network can consist of a mix of elements\n   that
    do and don't support it.  In other words, the mechanism should\n   not work only
    in environments where all elements support it.  It is\n   reasonable to assume
    that it works better in such environments, of\n   course.  Ideally, there should
    be incremental improvements in overall\n   network throughput as increasing numbers
    of elements in the network\n   support the mechanism.\n      Meets REQ 4: Yes.
    \ The mechanism is designed to reduce congestion\n      when a pair of communicating
    entities support it.  If a downstream\n      overloaded SIP server does not respond
    to a request in time, a SIP\n      client will attempt to reduce traffic destined
    towards the non-\n      responsive server as outlined in Section 5.9.\n   REQ
    5: The mechanism should not assume that it will only be deployed\n   in environments
    with completely trusted elements.  It should seek to\n   operate as effectively
    as possible in environments where other\n   elements are malicious; this includes
    preventing malicious elements\n   from obtaining more than a fair share of service.\n
    \     Meets REQ 5: Partially.  Since overload control information is\n      shared
    between a pair of communicating entities, a confidential\n      and authenticated
    channel can be used for this communication.\n      However, if such a channel
    is not available, then the security\n      ramifications outlined in Section 11
    apply.\n   REQ 6: When overload is signaled by means of a specific message, the\n
    \  message must clearly indicate that it is being sent because of\n   overload,
    as opposed to other, non-overload-based failure conditions.\n   This requirement
    is meant to avoid some of the problems that have\n   arisen from the reuse of
    the 503 response code for multiple purposes.\n   Of course, overload is also signaled
    by lack of response to requests.\n   This requirement applies only to explicit
    overload signals.\n      Meets REQ 6: Not applicable.  Overload control information
    is\n      signaled as part of the Via header and not in a new header.\n   REQ
    7: The mechanism shall provide a way for an element to throttle\n   the amount
    of traffic it receives from an upstream element.  This\n   throttling shall be
    graded so that it is not \"all or nothing\" as with\n   the current 503 mechanism.
    \ This recognizes the fact that overload is\n   not a binary state and that there
    are degrees of overload.\n      Meets REQ 7: Yes.  Please see Sections 5.5 and
    5.10.\n   REQ 8: The mechanism shall ensure that, when a request was not\n   processed
    successfully due to overload (or failure) of a downstream\n   element, the request
    will not be retried on another element that is\n   also overloaded or whose status
    is unknown.  This requirement derives\n   from REQ 1.\n      Meets REQ 8: Partially.
    \ A SIP client that has overload\n      information from multiple downstream servers
    will not retry the\n      request on another element.  However, if a SIP client
    does not\n      know the overload status of a downstream server, it may send the\n
    \     request to that server.\n   REQ 9: That a request has been rejected from
    an overloaded element\n   shall not unduly restrict the ability of that request
    to be submitted\n   to and processed by an element that is not overloaded.  This\n
    \  requirement derives from REQ 1.\n      Meets REQ 9: Yes.  A SIP client conformant
    to this specification\n      will send the request to a different element.\n   REQ
    10: The mechanism should support servers that receive requests\n   from a large
    number of different upstream elements, where the set of\n   upstream elements
    is not enumerable.\n      Meets REQ 10: Yes.  There are no constraints on the
    number of\n      upstream clients.\n   REQ 11: The mechanism should support servers
    that receive requests\n   from a finite set of upstream elements, where the set
    of upstream\n   elements is enumerable.\n      Meets REQ 11: Yes.  There are no
    constraints on the number of\n      upstream clients.\n   REQ 12: The mechanism
    should work between servers in different\n   domains.\n      Meets REQ 12: Yes.
    \ There are no inherent limitations on using\n      overload control between domains.
    \ However, interconnections\n      points that engage in overload control between
    domains will have\n      to populate and maintain the overload control parameters
    as\n      requests cross domains.\n   REQ 13: The mechanism must not dictate a
    specific algorithm for\n   prioritizing the processing of work within a proxy
    during times of\n   overload.  It must permit a proxy to prioritize requests based
    on any\n   local policy so that certain ones (such as a call for emergency\n   services
    or a call with a specific value of the Resource-Priority\n   header field [RFC4412])
    are given preferential treatment, such as not\n   being dropped, being given additional
    retransmission, or being\n   processed ahead of others.\n      Meets REQ 13: Yes.
    \ Please see Section 5.10.\n   REQ 14: The mechanism should provide unambiguous
    directions to\n   clients on when they should retry a request and when they should
    not.\n   This especially applies to TCP connection establishment and SIP\n   registrations
    in order to mitigate against an avalanche restart.\n      Meets REQ 14: Yes.  Section
    5.9 provides normative behavior on\n      when to retry a request after repeated
    timeouts and fatal\n      transport errors resulting from communications with
    a non-\n      responsive downstream SIP server.\n   REQ 15: In cases where a network
    element fails, is so overloaded that\n   it cannot process messages, or cannot
    communicate due to a network\n   failure or network partition, it will not be
    able to provide explicit\n   indications of the nature of the failure or its levels
    of congestion.\n   The mechanism must properly function in these cases.\n      Meets
    REQ 15: Yes.  Section 5.9 provides normative behavior on\n      when to retry
    a request after repeated timeouts and fatal\n      transport errors resulting
    from communications with a non-\n      responsive downstream SIP server.\n   REQ
    16: The mechanism should attempt to minimize the overhead of the\n   overload
    control messaging.\n      Meets REQ 16: Yes.  Overload control messages are sent
    in the\n      topmost Via header, which is always processed by the SIP elements.\n
    \  REQ 17: The overload mechanism must not provide an avenue for\n   malicious
    attack, including DoS and DDoS attacks.\n      Meets REQ 17: Partially.  Since
    overload control information is\n      shared between a pair of communicating
    entities, a confidential\n      and authenticated channel can be used for this
    communication.\n      However, if such a channel is not available, then the security\n
    \     ramifications outlined in Section 11 apply.\n   REQ 18: The overload mechanism
    should be unambiguous about whether a\n   load indication applies to a specific
    IP address, host, or URI so\n   that an upstream element can determine the load
    of the entity to\n   which a request is to be sent.\n      Meets REQ 18: Yes.
    \ Please see discussion in Section 5.5.\n   REQ 19: The specification for the
    overload mechanism should give\n   guidance on which message types might be desirable
    to process over\n   others during times of overload, based on SIP-specific\n   considerations.
    \ For example, it may be more beneficial to process a\n   SUBSCRIBE refresh with
    Expires of zero than a SUBSCRIBE refresh with\n   a non-zero expiration (since
    the former reduces the overall amount of\n   load on the element) or to process
    re-INVITEs over new INVITEs.\n      Meets REQ 19: Yes.  Please see Section 5.10.\n
    \  REQ 20: In a mixed environment of elements that do and do not\n   implement
    the overload mechanism, no disproportionate benefit shall\n   accrue to the users
    or operators of the elements that do not\n   implement the mechanism.\n      Meets
    REQ 20: Yes.  An element that does not implement overload\n      control does
    not receive any measure of extra benefit.\n   REQ 21: The overload mechanism should
    ensure that the system remains\n   stable.  When the offered load drops from above
    the overall capacity\n   of the network to below the overall capacity, the throughput
    should\n   stabilize and become equal to the offered load.\n      Meets REQ 21:
    Yes.  The overload control mechanism described in\n      this document ensures
    the stability of the system.\n   REQ 22: It must be possible to disable the reporting
    of load\n   information towards upstream targets based on the identity of those\n
    \  targets.  This allows a domain administrator who considers the load\n   of
    their elements to be sensitive information to restrict access to\n   that information.
    \ Of course, in such cases, there is no expectation\n   that the overload mechanism
    itself will help prevent overload from\n   that upstream target.\n      Meets
    REQ 22: Yes.  An operator of a SIP server can configure the\n      SIP server
    to only report overload control information for\n      requests received over
    a confidential channel, for example.\n      However, note that this requirement
    is in conflict with REQ 3 as\n      it introduces a modicum of extra configuration.\n
    \  REQ 23: It must be possible for the overload mechanism to work in\n   cases
    where there is a load balancer in front of a farm of proxies.\n      Meets REQ
    23: Yes.  Depending on the type of load balancer, this\n      requirement is met.
    \ A load balancer fronting a farm of SIP\n      proxies could be a SIP-aware load
    balancer or one that is not SIP-\n      aware.  If the load balancer is SIP-aware,
    it can make conscious\n      decisions on throttling outgoing traffic towards
    the individual\n      server in the farm based on the overload control parameters\n
    \     returned by the server.  On the other hand, if the load balancer\n      is
    not SIP-aware, then there are other strategies to perform\n      overload control.
    \ Section 6 of [RFC6357] documents some of these\n      strategies in more detail
    (see discussion related to Figure 3(a)\n      of that document).\n"
  title: Appendix B.  RFC 5390 Requirements
- contents:
  - "Authors' Addresses\n   Vijay K. Gurbani (editor)\n   Bell Labs, Alcatel-Lucent\n
    \  1960 Lucent Lane, Rm 9C-533\n   Naperville, IL  60563\n   USA\n   EMail: vkg@bell-labs.com\n
    \  Volker Hilt\n   Bell Labs, Alcatel-Lucent\n   Lorenzstrasse 10\n   70435 Stuttgart\n
    \  Germany\n   EMail: volker.hilt@bell-labs.com\n   Henning Schulzrinne\n   Columbia
    University/Department of Computer Science\n   450 Computer Science Building\n
    \  New York, NY  10027\n   USA\n   Phone: +1 212 939 7004\n   EMail: hgs@cs.columbia.edu\n
    \  URI:   http://www.cs.columbia.edu\n"
  title: Authors' Addresses
