- title: __initial_text__
  contents:
  - "   Negative-Acknowledgment (NACK)-Oriented Reliable Multicast (NORM)\n      \
    \                     Building Blocks\n"
- title: Status of this Memo
  contents:
  - "Status of this Memo\n   This memo defines an Experimental Protocol for the Internet\n\
    \   community.  It does not specify an Internet standard of any kind.\n   Discussion\
    \ and suggestions for improvement are requested.\n   Distribution of this memo\
    \ is unlimited.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (C) The Internet Society (2004).\n"
- title: Abstract
  contents:
  - "Abstract\n   This document discusses the creation of negative-acknowledgment\n\
    \   (NACK)-oriented reliable multicast (NORM) protocols.  The rationale\n   for\
    \ NORM goals and assumptions are presented.  Technical challenges\n   for NACK-oriented\
    \ (and in some cases general) reliable multicast\n   protocol operation are identified.\
    \  These goals and challenges are\n   resolved into a set of functional \"building\
    \ blocks\" that address\n   different aspects of NORM protocol operation.  It\
    \ is anticipated that\n   these building blocks will be useful in generating different\n\
    \   instantiations of reliable multicast protocols.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1. Introduction . . . . . . . . . . . . . . . . . . . .\
    \ . . . . .   3\n   2. Rationale. . . . . . . . . . . . . . . . . . . . . . .\
    \ . . . .   4\n      2.1. Delivery Service Model  . . . . . . . . . . . . . .\
    \ . . .   4\n      2.2. Group Membership Dynamics . . . . . . . . . . . . . .\
    \ . .   5\n      2.3. Sender/Receiver Relationships . . . . . . . . . . . . .\
    \ .   5\n      2.4. Group Size Scalability. . . . . . . . . . . . . . . . . .\
    \   6\n      2.5. Data Delivery Performance . . . . . . . . . . . . . . . .  \
    \ 6\n      2.6. Network Environments. . . . . . . . . . . . . . . . . . .   6\n\
    \      2.7. Router/Intermediate System Assistance . . . . . . . . . .   7\n  \
    \ 3. Functionality. . . . . . . . . . . . . . . . . . . . . . . . .   7\n    \
    \  3.1. NORM Sender Transmission. . . . . . . . . . . . . . . . .  10\n      3.2.\
    \ NORM Repair Process . . . . . . . . . . . . . . . . . . .  11\n           3.2.1.\
    \ Receiver NACK Process Initiation . . . . . . . . .  11\n           3.2.2. NACK\
    \ Suppression . . . . . . . . . . . . . . . . .  13\n           3.2.3. NACK Content\
    \ . . . . . . . . . . . . . . . . . . .  17\n                  3.2.3.1. NACK and\
    \ FEC Repair Strategies. . . . . .  17\n                  3.2.3.2. NACK Content\
    \ Format . . . . . . . . . . .  20\n           3.2.4. Sender Repair Response .\
    \ . . . . . . . . . . . . .  21\n      3.3. NORM Receiver Join Policies and Procedures.\
    \ . . . . . . .  23\n      3.4. Reliable Multicast Member Identification. . .\
    \ . . . . . .  24\n      3.5. Data Content Identification . . . . . . . . . .\
    \ . . . . .  24\n      3.6. Forward Error Correction (FEC). . . . . . . . . .\
    \ . . . .  26\n      3.7. Round-trip Timing Collection. . . . . . . . . . . .\
    \ . . .  27\n           3.7.1. One-to-Many Sender GRTT Measurement. . . . . .\
    \ . .  27\n           3.7.2. One-to-Many Receiver RTT Measurement . . . . . .\
    \ .  29\n           3.7.3. Many-to-Many RTT Measurement . . . . . . . . . . .\
    \  29\n           3.7.4. Sender GRTT Advertisement. . . . . . . . . . . . .  30\n\
    \      3.8. Group Size Determination/Estimation . . . . . . . . . . .  31\n  \
    \    3.9. Congestion Control Operation. . . . . . . . . . . . . . .  31\n    \
    \  3.10 Router/Intermediate System Assistance . . . . . . . . . .  31\n      3.11\
    \ NORM Applicability. . . . . . . . . . . . . . . . . . . .  31\n   4. Security\
    \ Considerations. . . . . . . . . . . . . . . . . . . .  32\n   5. Acknowledgements\
    \ . . . . . . . . . . . . . . . . . . . . . . .  33\n   6. References . . . .\
    \ . . . . . . . . . . . . . . . . . . . . . .  33\n      6.1. Normative References.\
    \ . . . . . . . . . . . . . . . . . .  33\n      6.2. Informative References.\
    \ . . . . . . . . . . . . . . . . .  33\n   7. Authors' Addresses . . . . . .\
    \ . . . . . . . . . . . . . . . .  35\n      Full Copyright Statement . . . .\
    \ . . . . . . . . . . . . . . .  36\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   Reliable multicast transport is a desirable technology for\
    \ the\n   efficient and reliable distribution of data to a group on the\n   Internet.\
    \  The complexities of group communication paradigms\n   necessitate different\
    \ protocol types and instantiations to meet the\n   range of performance and scalability\
    \ requirements of different\n   potential reliable multicast applications and\
    \ users [3].  This\n   document addresses the creation of negative-acknowledgment\
    \ (NACK)-\n   oriented reliable multicast (NORM) protocols.  While different\n\
    \   protocol instantiations may be required to meet specific application\n   and\
    \ network architecture demands [4], there are a number of\n   fundamental components\
    \ that may be common to these different\n   instantiations.  This document describes\
    \ the framework and common\n   \"building block\" components relevant to multicast\
    \ protocols based\n   primarily on NACK operation for reliable transport.  While\
    \ this\n   document discusses a large set of reliable multicast components and\n\
    \   issues relevant to NORM protocol design, it specifically addresses in\n  \
    \ detail the following building blocks which are not addressed in other\n   IETF\
    \ documents:\n      1) NORM sender transmission strategies,\n      2) NACK-oriented\
    \ repair process with timer-based feedback\n         suppression, and\n      3)\
    \ Round-trip timing for adapting NORM timers.\n   The potential relationships\
    \ to other reliable multicast transport\n   building blocks (Forward Error Correction\
    \ (FEC), congestion control)\n   and general issues with NORM protocols are also\
    \ discussed.  This\n   document is a product of the IETF RMT WG and follows the\
    \ guidelines\n   provided in RFC 3269 [5].  The key words \"MUST\", \"MUST NOT\"\
    ,\n   \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\",\n  \
    \ \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be\n   interpreted\
    \ as described in BCP 14, RFC 2119 [1].\n"
- title: Statement of Intent
  contents:
  - "Statement of Intent\n   This memo contains part of the definitions necessary\
    \ to fully specify\n   a Reliable Multicast Transport protocol in accordance with\
    \ RFC 2357.\n   As per RFC 2357, the use of any reliable multicast protocol in\
    \ the\n   Internet requires an adequate congestion control scheme.\n   While waiting\
    \ for such a scheme to be available, or for an existing\n   scheme to be proven\
    \ adequate, the Reliable Multicast Transport\n   working group (RMT) publishes\
    \ this Request for Comments in the\n   \"Experimental\" category.\n   It is the\
    \ intent of RMT to re-submit this specification as an IETF\n   Proposed Standard\
    \ as soon as the above condition is met.\n"
- title: 2.  Rationale
  contents:
  - "2.  Rationale\n   Each potential protocol instantiation using the building blocks\n\
    \   presented here (and in other applicable building block documents)\n   will\
    \ have specific criteria that may influence individual protocol\n   design.  To\
    \ support the development of applicable building blocks, it\n   is useful to identify\
    \ and summarize driving general protocol design\n   goals and assumptions.  These\
    \ are areas that each protocol\n   instantiation will need to address in detail.\
    \  Each building block\n   description in this document will include a discussion\
    \ of the impact\n   of these design criteria.  The categories of design criteria\n\
    \   considered here include:\n      1) Delivery Service Model,\n      2) Group\
    \ Membership Dynamics,\n      3) Sender/receiver relationships,\n      4) Group\
    \ Size Scalability,\n      5) Data Delivery Performance,\n      6) Network Environments,\
    \ and\n      7) Router/Intermediate System Interactions.\n   All of these areas\
    \ are at least briefly discussed.  Additionally,\n   other reliable multicast\
    \ transport building block documents such as\n   [9] have been created to address\
    \ areas outside of the scope of this\n   document.  NORM protocol instantiations\
    \ may depend upon these other\n   building blocks as well as the ones presented\
    \ here.  This document\n   focuses on areas that are unique to NORM but may be\
    \ used in concert\n   with the other building block areas.  In some cases, a building\
    \ block\n   may be able address a wide range of assumptions, while in other cases\n\
    \   there will be trade-offs required to meet different application needs\n  \
    \ or operating  environments.  Where necessary, building block features\n   are\
    \ designed to be parametric to meet different requirements.  Of\n   course, an\
    \ underlying goal will be to minimize design complexity and\n   to at least recommend\
    \ default values for any such parameters that\n   meet a general purpose \"bulk\
    \ data transfer\" requirement in a typical\n   Internet environment.\n"
- title: 2.1.  Delivery Service Model
  contents:
  - "2.1.  Delivery Service Model\n   The implicit goal of a reliable multicast transport\
    \ protocol is the\n   reliable delivery of data among a group of members communicating\n\
    \   using IP multicast datagram service.  However, the specific service\n   the\
    \ application is attempting to provide can impact design decisions.\n   A most\
    \ basic service model for reliable multicast transport is that\n   of \"bulk transfer\"\
    \ which is a primary focus of this and other related\n   RMT working group documents.\
    \  However, the same principles in\n   protocol design may also be applied to\
    \ other services models, e.g.,\n   more interactive exchanges of small messages\
    \ such as with white-\n   boarding or text chat.  Within these different models\
    \ there are\n   issues such as the sender's ability to cache transmitted data\
    \ (or\n   state referencing it) for retransmission or repair.  The needs for\n\
    \   ordering and/or causality in the sequence of transmissions and\n   receptions\
    \ among members in the group may be different depending upon\n   data content.\
    \  The group communication paradigm differs significantly\n   from the point-to-point\
    \ model in that, depending upon the data\n   content type, some receivers may\
    \ complete reception of a portion of\n   data content and be able to act upon\
    \ it before other members have\n   received the content.  This may be acceptable\
    \ (or even desirable) for\n   some applications but not for others.  These varying\
    \ requirements\n   drive the need for a number of different protocol instantiation\n\
    \   designs.  A significant challenge in developing generally useful\n   building\
    \ block mechanisms is accommodating even a limited range of\n   these capabilities\
    \ without defining specific application-level\n   details.\n"
- title: 2.2.  Group Membership Dynamics
  contents:
  - "2.2.  Group Membership Dynamics\n   One area where group communication can differ\
    \ from point-to-point\n   communications is that even if the composition of the\
    \ group changes,\n   the \"thread\" of communication can still exist.  This contrasts\
    \ with\n   the point-to-point communication model where, if either of the two\n\
    \   parties leave, the communication process (exchange of data) is\n   terminated\
    \ (or at least paused).  Depending upon application goals,\n   senders and receivers\
    \ participating in a reliable multicast transport\n   \"session\" may be able\
    \ to join late, leave, and/or potentially rejoin\n   while the ongoing group communication\
    \ \"thread\" still remains\n   functional and useful.  Also note that this can\
    \ impact protocol\n   message content.  If \"late joiners\" are supported, some\
    \ amount of\n   additional information may be placed in message headers to\n \
    \  accommodate this functionality.  Alternatively, the information may\n   be\
    \ sent in its own message (on demand or intermittently) if the\n   impact to the\
    \ overhead of typical message transmissions is deemed too\n   great.  Group dynamics\
    \ can also impact other protocol mechanisms such\n   as NACK timing, congestion\
    \ control operation, etc.\n"
- title: 2.3.  Sender/Receiver Relationships
  contents:
  - "2.3.  Sender/Receiver Relationships\n   The relationship of senders and receivers\
    \ among group members\n   requires consideration.  In some applications, there\
    \ may be a single\n   sender multicasting to a group of receivers.  In other cases,\
    \ there\n   may be more than one sender or the potential for everyone in the\n\
    \   group to be a sender _and_ receiver of data may exist.\n"
- title: 2.4.  Group Size Scalability
  contents:
  - "2.4.  Group Size Scalability\n   Native IP multicast [2] may scale to extremely\
    \ large group sizes.  It\n   may be desirable for some applications to scale along\
    \ with the\n   multicast infrastructure's ability to scale.  In its simplest form,\n\
    \   there are limits to the group size to which a NACK-oriented protocol\n   can\
    \ apply without NACK implosion problems.  Research suggests that\n   NORM group\
    \ sizes on the order of tens of thousands of receivers may\n   operate with modest\
    \ feedback to the sender using probabilistic,\n   timer-based suppression techniques\
    \ [7].  However, the potential for\n   router assistance and/or other NACK suppression\
    \ heuristics may enable\n   these protocols to scale to very large group sizes.\
    \  In large scale\n   cases, it may be prohibitive for members to maintain state\
    \ on all\n   other members (in particular, other receivers) in the group.  The\n\
    \   impact of group size needs to be considered in the development of\n   applicable\
    \ building blocks.\n"
- title: 2.5.  Data Delivery Performance
  contents:
  - "2.5.  Data Delivery Performance\n   There is a trade-off between scalability\
    \ and data delivery latency\n   when designing NACK-oriented protocols.  If probabilistic,\
    \ timer-\n   based NACK suppression is to be used, there will be some delays built\n\
    \   into the NACK process to allow suppression to occur and for the\n   sender\
    \ of data to identify appropriate content for efficient repair\n   transmission.\
    \  For example, backoff timeouts can be used to ensure\n   efficient NACK suppression\
    \ and repair transmission, but this comes at\n   a cost of increased delivery\
    \ latency and increased buffering\n   requirements for both senders and receivers.\
    \  The building blocks\n   SHOULD allow applications to establish bounds for data\
    \ delivery\n   performance.  Note that application designers must be aware of\
    \ the\n   scalability trade-off that is made when such bounds are applied.\n"
- title: 2.6.  Network Environments
  contents:
  - "2.6.  Network Environments\n   The Internet Protocol has historically assumed\
    \ a role of providing\n   service across heterogeneous network topologies.  It\
    \ is desirable\n   that a reliable multicast protocol be capable of effectively\n\
    \   operating across a wide range of the networks to which general\n   purpose\
    \ IP service applies.  The bandwidth available on the links\n   between the members\
    \ of a single group today may vary between low\n   numbers of kbit/s for wireless\
    \ links and multiple Gbit/s for high\n   speed LAN connections, with varying degrees\
    \ of contention from other\n   flows.  Recently, a number of asymmetric network\
    \ services including\n   56K/ADSL modems, CATV Internet service, satellite and\
    \ other wireless\n   communication services have begun to proliferate.  Many of\
    \ these are\n   inherently broadcast media with potentially large \"fan-out\"\
    \ to which\n   IP multicast service is highly applicable.  Additionally, policy\n\
    \   and/or technical issues may result in topologies where multicast\n   connectivity\
    \ is limited to a single source multicast (SSM) model from\n   a specific source\
    \ [8].  Receivers in the group may be restricted to\n   unicast feedback for NACKs\
    \ and other messages.  Consideration must be\n   given, in building block development\
    \ and protocol design, to the\n   nature of the underlying networks.\n"
- title: 2.7.  Router/Intermediate System Assistance
  contents:
  - "2.7.  Router/Intermediate System Assistance\n   While intermediate assistance\
    \ from devices/systems with direct\n   knowledge of the underlying network topology\
    \ may be used to leverage\n   the performance and scalability of reliable multicast\
    \ protocols,\n   there will continue to be a number of instances where this is\
    \ not\n   available or practical.  Any building block components for NACK-\n \
    \  oriented reliable multicast SHALL be capable of operating without\n   such\
    \ assistance.  However, it is RECOMMENDED that such protocols also\n   consider\
    \ utilizing these features when available.\n"
- title: 3.  Functionality
  contents:
  - "3.  Functionality\n   The previous section has presented the role of protocol\
    \ building\n   blocks and some of the criteria that may affect NORM building block\n\
    \   identification/design.  This section describes different building\n   block\
    \ areas applicable to NORM protocols.  Some of these areas are\n   specific to\
    \ NACK-oriented protocols.  Detailed descriptions of such\n   areas are provided.\
    \  In other cases, the areas (e.g., node\n   identifiers, forward error correction\
    \ (FEC), etc.) may be applicable\n   to other forms of reliable multicast.  In\
    \ those cases, the discussion\n   below describes requirements placed on those\
    \ other general building\n   block areas from the standpoint of NACK-oriented\
    \ reliable multicast.\n   Where applicable, other building block documents are\
    \ referenced for\n   possible contribution to NORM protocols.\n   For each building\
    \ block, a notional \"interface description\" is\n   provided to illustrate any\
    \ dependencies of one building block\n   component upon another or upon other\
    \ protocol parameters.  A building\n   block component may require some form of\
    \ \"input\" from another\n   building block component or other source to perform\
    \ its function.\n   Any \"inputs\" required by a building block component and/or\
    \ any\n   resultant \"output\" provided will be defined and described in each\n\
    \   building block component's interface description.  Note that the set\n   of\
    \ building blocks presented here do not fully satisfy each other's\n   \"input\"\
    \ and \"output\" needs.  In some cases, \"inputs\" for the building\n   blocks\
    \ here must come from other building blocks external to this\n   document (e.g.,\
    \ congestion control or FEC).  In other cases NORM\n   building block \"inputs\"\
    \ must be satisfied by the specific protocol\n   instantiation or implementation\
    \ (e.g., application data and control).\n   The following building block components\
    \ relevant to NORM are\n   identified:\n   (NORM-Specific)\n        1)   NORM\
    \ Sender Transmission\n        2)   NORM Repair Process\n        3)   NORM Receiver\
    \ Join Policies\n   (General Purpose)\n        4)   Node (member) Identification\n\
    \        5)   Data Content Identification\n        6)   Forward Error Correction\
    \ (FEC)\n        7)   Round-trip Timing Collection\n        8)   Group Size Determination/Estimation\n\
    \        9)   Congestion Control Operation\n        10)  Router/Intermediate System\
    \ Assistance\n        11)  Ancillary Protocol Mechanisms\n   Figure 1 provides\
    \ a pictorial overview of these building block areas\n   and some of their relationships.\
    \  For example, the content of the\n   data messages that a sender initially transmits\
    \ depends upon the\n   \"Node Identification\", \"Data Content Identification\"\
    , and \"FEC\"\n   components while the rate of message transmission will generally\n\
    \   depend upon the \"Congestion Control\" component.  Subsequently, the\n   receivers'\
    \ response to these transmissions (e.g., NACKing for repair)\n   will depend upon\
    \ the data message content and inputs from other\n   building block components.\
    \  Finally, the sender's processing of\n   receiver responses will feed back into\
    \ its transmission strategy.\n                                     Application\
    \ Data and Control\n                                                 |\n     \
    \                                            v\n    .---------------------.  \
    \          .-----------------------.\n    | Node Identification |----------->|\
    \  Sender Transmission  |<------.\n    `---------------------'       _.-' `-----------------------'\
    \       |\n    .---------------------.   _.-' .'            | .--------------.\
    \    |\n    | Data Identification |--'   .''             | |  Join Policy |  \
    \  |\n    `---------------------'    .' '              v `--------------'    |\n\
    \    .---------------------.  .'  '     .------------------------.      |\n .->|\
    \ Congestion Control  |-'   '      | Receiver NACK          |      |\n |  `---------------------'\
    \   .'       | Repair Process         |      |\n |  .---------------------. .'\
    \         | .------------------.   |      |\n |  |        FEC          |'.   \
    \       | | NACK Initiation  |   |      |\n |  `---------------------'` `._  \
    \     | `------------------'   |      |\n |  .---------------------. ``. `-._\
    \   | .------------------.   |      |\n `--|    RTT Collection   |._` `    `->|\
    \ | NACK Content     |   |      |\n    `---------------------' .`- `      | `------------------'\
    \   |      |\n    .---------------------.  \\ `-`._   | .------------------. \
    \  |      |\n    |    Group Size Est.  |---.-`---`->| | NACK Suppression |   |\
    \      |\n    `---------------------'`.  ` `     | `------------------'   |  \
    \    |\n    .---------------------.  `  ` `    `------------------------'    \
    \  |\n    |       Other         |   `  ` `             | .-----------------. |\n\
    \    `---------------------'    `  ` `            | |Router Assistance| |\n  \
    \                              `. ` `           v `-----------------' |\n    \
    \                              `.`' .-------------------------.     |\n      \
    \                               `>| Sender NACK Processing  |_____/\n        \
    \                               | and Repair Response     |\n                \
    \                       `-------------------------'\n                    ^   \
    \                      ^\n                    |                         |\n  \
    \                .-----------------------------.\n                  |        \
    \ (Security)          |\n                  `-----------------------------'\n \
    \               Fig. 1 - NORM Building Block Framework\n   The components on the\
    \ left side of this figure are areas that may be\n   applicable beyond NORM. \
    \ The most significant of these components are\n   discussed in other building\
    \ block documents such as [9].  A brief\n   description of these areas and their\
    \ role in the NORM protocol is\n   given below.  The components on the right are\
    \ seen as specific to\n   NORM protocols, most notably the NACK repair process.\
    \  These areas\n   are discussed in detail below.  Some other components (e.g.,\n\
    \   \"Security\") impact many aspects of the protocol, and others such as\n  \
    \ \"Router Assistance\" may be more transparent to the core protocol\n   processing.\
    \  The sections below describe the \"NORM Sender\n   Transmission\", \"NORM Repair\
    \ Process\", and \"RTT Collection\" building\n   blocks in detail.  The relationships\
    \ to and among the other building\n   block areas are also discussed, focusing\
    \ on issues applicable to NORM\n   protocol design.  Where applicable, specific\
    \ technical\n   recommendations are made for mechanisms that will properly satisfy\n\
    \   the goals of NORM transport for the Internet.\n"
- title: 3.1.  NORM Sender Transmission
  contents:
  - "3.1.  NORM Sender Transmission\n   NORM senders will transmit data content to\
    \ the multicast session.\n   The data content will be application dependent. \
    \ The sender will\n   transmit data content at a rate, and with message sizes,\
    \ determined\n   by application and/or network architecture requirements.  Any\
    \ FEC\n   encoding of sender transmissions SHOULD conform with the guidelines\n\
    \   of [9].  When congestion control mechanisms are needed (REQUIRED for\n   general\
    \ Internet operation), NORM transmission SHALL be controlled by\n   the congestion\
    \ control mechanism.  In any case, it is RECOMMENDED\n   that all data transmissions\
    \ from  NORM senders be subject to rate\n   limitations determined by the application\
    \ or congestion control\n   algorithm.  The sender's transmissions SHOULD make\
    \ good utilization\n   of the available capacity (which may be limited by the\
    \ application\n   and/or by congestion control).  As a result, it is expected\
    \ there\n   will be overlap and multiplexing of new data content transmission\n\
    \   with repair content.  Other factors related to application operation\n   may\
    \ determine sender transmission formats and methods.  For example,\n   some consideration\
    \ needs to be given to the sender's behavior during\n   intermittent idle periods\
    \ when it has no data to transmit.\n   In addition to data content, other sender\
    \ messages or commands may be\n   employed as part of protocol operation.  These\
    \ messages may occur\n   outside of the scope of application data transfer.  In\
    \ NORM\n   protocols, reliability of such protocol messages may be attempted by\n\
    \   redundant transmission when positive acknowledgement is prohibitive\n   due\
    \ to group size scalability concerns.  Note that protocol design\n   SHOULD provide\
    \ mechanisms for dealing with cases where such messages\n   are not received by\
    \ the group.  As an example, a command message\n   might be redundantly transmitted\
    \ by a sender to indicate that it is\n   temporarily (or permanently) halting\
    \ transmission.  At this time, it\n   may be appropriate for receivers to respond\
    \ with NACKs for any\n   outstanding repairs they require following the rules\
    \ of the NORM NACK\n   procedure.  For efficiency, the sender should allow sufficient\
    \ time\n   between the redundant transmissions to receive any NACK-oriented\n\
    \   responses from the receivers to this command.\n   In general, when there is\
    \ any resultant NACK or other feedback\n   operation, the timing of redundant\
    \ transmission of control messages\n   issued by a sender and other NORM protocol\
    \ timeouts should be\n   dependent upon the group greatest round trip timing (GRTT)\
    \ estimate\n   and any expected resultant NACK or other feedback operation.  The\n\
    \   NORM GRTT is an estimate of the worst-case round-trip timing from a\n   sender\
    \ to any receivers in the group.  It is assumed that the GRTT\n   interval is\
    \ a conservative estimate of the maximum span (with respect\n   to delay) of the\
    \ multicast group across a network topology with\n   respect to given sender.\
    \  NORM instantiations SHOULD be able to\n   dynamically adapt to a wide range\
    \ of multicast network topologies.\n   Sender Transmission Interface Description\n\
    \   Inputs:\n      1) Application data and control\n      2) Sender node identifier\n\
    \      3) Data identifiers\n      4) Segmentation and FEC parameters\n      5)\
    \ Transmission rate\n      6) Application controls\n      7) Receiver feedback\
    \ messages (e.g., NACKs)\n   Outputs:\n      1) Controlled transmission of messages\
    \ with headers uniquely\n         identifying data or repair content within the\
    \ context of the\n         NORM session.\n      2) Commands indicating sender's\
    \ status or other transport\n         control actions to be taken.\n"
- title: 3.2.  NORM Repair Process
  contents:
  - "3.2.  NORM Repair Process\n   A critical component of NORM protocols is the NACK\
    \ repair process.\n   This includes the receiver's role in detecting and requesting\
    \ repair\n   needs, and the sender's response to such requests.  There are four\n\
    \   primary elements of the NORM repair process:\n      1) Receiver NACK process\
    \ initiation,\n      3) NACK suppression,\n      2) NACK message content,\n  \
    \    4) Sender NACK processing and response.\n"
- title: 3.2.1.  Receiver NACK Process Initiation
  contents:
  - "3.2.1.  Receiver NACK Process Initiation\n   The NORM NACK process (cycle) will\
    \ be initiated by receivers that\n   detect a need for repair transmissions from\
    \ a specific sender to\n   achieve reliable reception.  When FEC is applied, a\
    \ receiver should\n   initiate the NACK process only when it is known its repair\n\
    \   requirements exceed the amount of pending FEC transmission for a\n   given\
    \ coding block of data content.  This can be determined at the\n   end of the\
    \ current transmission block (if it is indicated) or upon\n   the start of reception\
    \ of a subsequent coding block or transmission\n   object.  This implies the NORM\
    \ data content is marked to identify its\n   FEC block number and that ordinal\
    \ relationship is preserved in order\n   of transmission.\n   Alternatively, if\
    \ the sender's transmission advertises the quantity\n   of repair packets it is\
    \ already planning to send for a block, the\n   receiver may be able to initiate\
    \ the NACK processor earlier.\n   Allowing receivers to initiate NACK cycles at\
    \ any time they detect\n   their repair needs have exceeded pending repair transmissions\
    \ may\n   result in slightly quicker repair cycles.  However, it may be useful\n\
    \   to limit NACK process initiation to specific events such as at the\n   end-of-transmission\
    \ of an FEC coding block or upon detection of\n   subsequent coding blocks.  This\
    \ can allow receivers to aggregate NACK\n   content into a smaller number of NACK\
    \ messages and provide some\n   implicit loose synchronization among the receiver\
    \ set to help\n   facilitate effective probabilistic suppression of NACK feedback.\
    \  The\n   receiver MUST maintain a history of data content received from the\n\
    \   sender to determine its current repair needs.  When FEC is employed,\n   it\
    \ is expected that the history will correspond to a record of\n   pending or partially-received\
    \ coding blocks.\n   For probabilistic, timer-base suppression of feedback, the\
    \ NACK cycle\n   should begin with receivers observing backoff timeouts.  In\n\
    \   conjunction with initiating this backoff timeout, it is important\n   that\
    \ the receivers record the current position in the sender's\n   transmission sequence\
    \ at which they initiate the NACK cycle.  When\n   the suppression backoff timeout\
    \ expires, the receivers should only\n   consider their repair needs up to this\
    \ recorded transmission position\n   in making the decision to transmit or suppress\
    \ a NACK.  Without this\n   restriction, suppression is greatly reduced as additional\
    \ content is\n   received from the sender during the time a NACK message propagates\n\
    \   across the network to the sender and other receivers.\n   Receiver NACK Process\
    \ Initiation Interface Description\n   Inputs:\n      1) Sender data content with\
    \ sequencing identifiers from sender\n         transmissions.\n      2) History\
    \ of content received from sender.\n   Outputs:\n      1) NACK process initiation\
    \ decision\n      2) Recorded sender transmission sequence position.\n"
- title: 3.2.2.  NACK Suppression
  contents:
  - "3.2.2.  NACK Suppression\n   An effective NORM feedback suppression mechanism\
    \ is the use of random\n   backoff timeouts prior to NACK transmission by receivers\
    \ requiring\n   repairs [10].  Upon expiration of the backoff timeout, a receiver\n\
    \   will request repairs unless its pending repair needs have been\n   completely\
    \ superseded by NACK messages heard from other receivers\n   (when receivers are\
    \ multicasting NACKs) or from some indicator from\n   the sender.  When receivers\
    \ are unicasting NACK messages, the sender\n   may facilitate NACK suppression\
    \ by forwarding a representation of\n   NACK content it has received to the group\
    \ at large or provide some\n   other indicator of the repair information it will\
    \ be subsequently\n   transmitting.\n   For effective and scalable suppression\
    \ performance, the backoff\n   timeout periods used by receivers should be independently,\
    \ randomly\n   picked by receivers with a truncated exponential distribution [6].\n\
    \   This results in the majority of the receiver set holding off\n   transmission\
    \ of NACK messages under the assumption that the smaller\n   number of \"early\
    \ NACKers\" will supersede the repair needs of the\n   remainder of the group.\
    \  The mean of the distribution should be\n   determined as a function of the\
    \ current estimate of sender<->group\n   GRTT and a group size estimate that is\
    \ determined by other mechanisms\n   within the protocol or preset by the multicast\
    \ application.\n   A simple algorithm can be constructed to generate random backoff\n\
    \   timeouts with the appropriate distribution.  Additionally, the\n   algorithm\
    \ may be designed to optimize the backoff distribution given\n   the number of\
    \ receivers (R) potentially generating feedback.  This\n   \"optimization\" minimizes\
    \ the number of feedback messages (e.g., NACK)\n   in the worst-case situation\
    \ where all receivers generate a NACK.  The\n   maximum backoff timeout (T_maxBackoff)\
    \ can be set to control reliable\n   delivery latency versus volume of feedback\
    \ traffic.  A larger value\n   of T_maxBackoff will result in a lower density\
    \ of feedback traffic\n   for a given repair cycle.  A smaller value of T_maxBackoff\
    \ results in\n   shorter latency which also reduces the buffering requirements\
    \ of\n   senders and receivers for reliable transport.\n   Given the receiver\
    \ group size (R), and maximum allowed backoff\n   timeout (T_maxBackoff), random\
    \ backoff timeouts (t') with a truncated\n   exponential distribution can be picked\
    \ with the following algorithm:\n   1) Establish an optimal mean (L) for the exponential\
    \ backoff based on\n      the group size:\n                                L =\
    \ ln(R) + 1\n   2) Pick a random number (x) from a uniform distribution over a\
    \ range\n      of:\n               L                           L             \
    \      L\n       --------------------  to   --------------------  +  ----------\n\
    \      T_maxBackoff*(exp(L)-1)    T_maxBackoff*(exp(L)-1)  T_maxBackoff\n   3)\
    \ Transform this random variate to generate the desired random\n      backoff\
    \ time (t') with the following equation:\n      t' = T_maxBackoff/L * ln(x * (exp(L)\
    \ - 1) * (T_maxBackoff/L))\n   This C language function can be used to generate\
    \ an appropriate\n   random backoff time interval:\n      double RandomBackoff(double\
    \ maxTime, double groupSize)\n      {\n          double lambda = log(groupSize)\
    \ + 1;\n          double x = UniformRand(lambda/maxTime) +\n                 \
    \    lambda / (maxTime*(exp(lambda)-1));\n          return ((maxTime/lambda) *\n\
    \                  log(x*(exp(lambda)-1)*(maxTime/lambda)));\n      }  // end\
    \ RandomBackoff()\n   where UniformRand(double max) returns random numbers with\
    \ a uniform\n   distribution from the range of 0..max.  For example, based on\
    \ the\n   POSIX \"rand()\" function, the following C code can be used:\n     \
    \ double UniformRand(double max)\n      {\n          return (max * ((double)rand()/(double)RAND_MAX));\n\
    \      }\n   The number of expected NACK messages generated (N) within the first\n\
    \   round trip time for a single feedback event is approximately:\n      N = exp(1.2\
    \ * L / (2*T_maxBackoff/GRTT))\n   Thus the maximum backoff time can be adjusted\
    \ to tradeoff worst-case\n   NACK feedback volume versus latency.  This is derived\
    \ from [6] and\n   assumes  T_maxBackoff >= GRTT, and L is the mean of the distribution\n\
    \   optimized for the given group size as shown in the algorithm above.\n   Note\
    \ that other mechanisms within the protocol may work to reduce\n   redundant NACK\
    \ generation further.  It is suggested that T_maxBackoff\n   be selected as an\
    \ integer multiple of the sender's current advertised\n   GRTT estimate such that:\n\
    \      T_maxBackoff = K * GRTT ;where K >= 1\n   For general Internet operation,\
    \ a default value of K=4 is RECOMMENDED\n   for operation with multicast (to the\
    \ group at large) NACK delivery\n   and a value of K=6 for unicast NACK delivery.\
    \  Alternate values may\n   be used to for buffer utilization, reliable delivery\
    \ latency and\n   group size scalability tradeoffs.\n   Given that (K*GRTT) is\
    \ the maximum backoff time used by the receivers\n   to initiate NACK transmission,\
    \ other timeout periods related to the\n   NACK repair process can be scaled accordingly.\
    \  One of those timeouts\n   is the amount of time a receiver should wait after\
    \ generating a NACK\n   message before allowing itself to initiate another NACK\n\
    \   backoff/transmission cycle (T_rcvrHoldoff).  This delay should be\n   sufficient\
    \ for the sender to respond to the received NACK with repair\n   messages.  An\
    \ appropriate value depends upon the amount of time for\n   the NACK to reach\
    \ the sender and the sender to provide a repair\n   response.  This MUST include\
    \ any amount of sender NACK aggregation\n   period during which possible multiple\
    \ NACKs are accumulated to\n   determine an efficient repair response.  These\
    \ timeouts are further\n   discussed in the section below on \"Sender NACK Processing\
    \ and Repair\n   Response\".\n   There are also secondary measures that can be\
    \ applied to improve the\n   performance of feedback suppression.  For example,\
    \ the sender's data\n   content transmissions can follow an ordinal sequence of\
    \ transmission.\n   When repairs for data content occur, the receiver can note\
    \ that the\n   sender has \"rewound\" its data content transmission position by\n\
    \   observing the data object, FEC block number, and FEC symbol\n   identifiers.\
    \  Receivers SHOULD limit transmission of NACKs to only\n   when the sender's\
    \ current transmission position exceeds the point to\n   which the receiver has\
    \ incomplete reception.  This reduces premature\n   requests for repair of data\
    \ the sender may be planning to provide in\n   response to other receiver requests.\
    \  This mechanism can be very\n   effective for protocol convergence in high loss\
    \ conditions when\n   transmissions of NACKs from other receivers (or indicators\
    \ from the\n   sender) are lost.  Another mechanism (particularly applicable when\n\
    \   FEC is used) is for the sender to embed an indication of impending\n   repair\
    \ transmissions in current packets sent.  For example, the\n   indication may\
    \ be as simple as an advertisement of the number of FEC\n   packets to be sent\
    \ for the current applicable coding block.\n   Finally, some consideration might\
    \ be given to using the NACKing\n   history of receivers to weight their selection\
    \ of NACK backoff\n   timeout intervals.  For example, if a receiver has historically\
    \ been\n   experiencing the greatest degree of loss, it may promote itself to\n\
    \   statistically NACK sooner than other receivers.  Note this requires\n   there\
    \ is correlation over successive intervals of time in the loss\n   experienced\
    \ by a receiver.  Such correlation MAY not be present in\n   multicast networks.\
    \  This adjustment of backoff timeout selection may\n   require the creation of\
    \ an \"early NACK\" slot for these historical\n   NACKers.  This additional slot\
    \ in the NACK backoff window will result\n   in a longer repair cycle process\
    \ that may not be desirable for some\n   applications.  The resolution of these\
    \ trade-offs may be dependent\n   upon the protocol's target application set or\
    \ network.\n   After the random backoff timeout has expired, the receiver will\
    \ make\n   a decision on whether to generate a NACK repair request or not (i.e.,\n\
    \   it has been suppressed).  The NACK will be suppressed when any of the\n  \
    \ following conditions has occurred:\n   1) The accumulated state of NACKs heard\
    \ from other receivers (or\n      forwarding of this state by the sender) is equal\
    \ to or supersedes\n      the repair needs of the local receiver.  Note that the\
    \ local\n      receiver should consider its repair needs only up to the sender\n\
    \      transmission position recorded at the NACK cycle initiation (when\n   \
    \   the backoff timer was activated).\n   2) The sender's data content transmission\
    \ position \"rewinds\" to a\n      point ordinally less than that of the lowest\
    \ sequence position of\n      the local receiver's repair needs.  (This detection\
    \ of sender\n      \"rewind\" indicates the sender has already responded to other\n\
    \      receiver repair needs of which the local receiver may not have\n      been\
    \ aware).  This \"rewind\" event can occur any time between 1)\n      when the\
    \ NACK cycle was initiated with the backoff timeout\n      activation and 2) the\
    \ current moment when the backoff timeout has\n      expired to suppress the NACK.\
    \  Another NACK cycle must be\n      initiated by the receiver when the sender's\
    \ transmission sequence\n      position exceeds the receiver's lowest ordinal\
    \ repair point.  Note\n      it is possible that the local receiver may have had\
    \ its repair\n      needs satisfied as a result of the sender's response to the\
    \ repair\n      needs of other receivers and no further NACKing is required.\n\
    \   If these conditions have not occurred and the receiver still has\n   pending\
    \ repair needs, a NACK message is generated and transmitted.\n   The NACK should\
    \ consist of an accumulation of repair needs from the\n   receiver's lowest ordinal\
    \ repair point up to the current sender\n   transmission sequence position.  A\
    \ single NACK message should be\n   generated and the NACK message content should\
    \ be truncated if it\n   exceeds the payload size of single protocol message.\
    \  When such NACK\n   payload limits occur, the NACK content SHOULD contain requests\
    \ for\n   the ordinally lowest repair content needed from the sender.\n   NACK\
    \ Suppression Interface Description\n   Inputs:\n      1) NACK process initiation\
    \ decision.\n      2) Recorded sender transmission sequence position.\n      3)\
    \ Sender GRTT.\n      4) Sender group size estimate.\n      5) Application-defined\
    \ bound on backoff timeout period.\n      6) NACKs from other receivers.\n   \
    \   7) Pending repair indication from sender (may be forwarded\n         NACKs).\n\
    \      8) Current sender transmission sequence position.\n   Outputs:\n      1)\
    \ Yes/no decision to generate NACK message upon backoff timer\n         expiration.\n"
- title: 3.2.3.  NACK Content
  contents:
  - "3.2.3.  NACK Content\n   The content of NACK messages generated by reliable multicast\n\
    \   receivers will include information detailing their current repair\n   needs.\
    \  The specific information depends on the use and type of FEC\n   in the NORM\
    \ repair process.  The identification of repair needs is\n   dependent upon the\
    \ data content identification (See Section 3.5\n   below).  At the highest level\
    \ the NACK content will identify the\n   sender to which the NACK is addressed\
    \ and the data transport object\n   (or stream) within the sender's transmission\
    \ that needs repair.  For\n   the indicated transport entity, the NACK content\
    \ will then identify\n   the specific FEC coding blocks and/or symbols it requires\
    \ to\n   reconstruct the complete transmitted data.  This content may consist\n\
    \   of FEC block erasure counts and/or explicit indication of missing\n   blocks\
    \ or symbols (segments) of data and FEC content.  It should also\n   be noted\
    \ that NORM can be effectively instantiated without a\n   requirement for reliable\
    \ NACK delivery using the techniques discussed\n   here.\n"
- title: 3.2.3.1.  NACK and FEC Repair Strategies
  contents:
  - "3.2.3.1.  NACK and FEC Repair Strategies\n   Where FEC-based repair is used,\
    \ the NACK message content will\n   minimally need to identify the coding block(s)\
    \ for which repair is\n   needed and a count of erasures (missing packets) for\
    \ the coding\n   block.  An exact count of erasures implies the FEC algorithm\
    \ is\n   capable of repairing _any_ loss combination within the coding block.\n\
    \   This count may need to be adjusted for some FEC algorithms.\n   Considering\
    \ that multiple repair rounds may be required to\n   successfully complete repair,\
    \ an erasure count also implies that the\n   quantity of unique FEC parity packets\
    \ the server has available to\n   transmit is essentially unlimited (i.e., the\
    \ server will always be\n   able to provide new, unique, previously unsent parity\
    \ packets in\n   response to any subsequent repair requests for the same coding\n\
    \   block).  Alternatively, the sender may \"round-robin\" transmit through\n\
    \   its available set of FEC symbols for a given coding block, and\n   eventually\
    \ affect repair.  For a most efficient repair strategy, the\n   NACK content will\
    \ need to also _explicitly_ identify which symbols\n   (information and/or parity)\
    \ the receiver requires to successfully\n   reconstruct the content of the coding\
    \ block.  This will be\n   particularly true of small to medium size block FEC\
    \ codes (e.g., Reed\n   Solomon) that are capable of provided a limited number\
    \ of parity\n   symbols per FEC coding block.\n   When FEC is not used as part\
    \ of the repair process, or the protocol\n   instantiation is required to provide\
    \ reliability even when the sender\n   has transmitted all available parity for\
    \ a given coding block (or the\n   sender's ability to buffer transmission history\
    \ is exceeded by the\n   delay*bandwidth*loss characteristics of the network topology),\
    \ the\n   NACK content will need to contain _explicit_ coding block and/or\n \
    \  segment loss information so that the sender can provide appropriate\n   repair\
    \ packets and/or data retransmissions.  Explicit loss\n   information in NACK\
    \ content may also potentially serve other\n   purposes.  For example, it may\
    \ be useful for decorrelating loss\n   characteristics among a group of receivers\
    \ to help differentiate\n   candidate congestion control bottlenecks among the\
    \ receiver set.\n   When FEC is used and NACK content is designed to contain explicit\n\
    \   repair requests, there is a strategy where the receivers can NACK for\n  \
    \ specific content that will help facilitate NACK suppression and\n   repair efficiency.\
    \  The assumptions for this strategy are that sender\n   may potentially exhaust\
    \ its supply of new, unique parity packets\n   available for a given coding block\
    \ and be required to explicitly\n   retransmit some data or parity symbols to\
    \ complete reliable transfer.\n   Another assumption is that an FEC algorithm\
    \ where any parity packet\n   can fill any erasure within the coding block (e.g.,\
    \ Reed Solomon) is\n   used.  The goal of this strategy is to make maximum use\
    \ of the\n   available parity and provide the minimal amount of data and repair\n\
    \   transmissions during reliable transfer of data content to the group.\n   When\
    \ systematic FEC codes are used, the sender transmits the data\n   content of\
    \ the coding block (and optionally some quantity of parity\n   packets) in its\
    \ initial transmission.  Note that a systematic FEC\n   coding block is considered\
    \ to be logically made up of the contiguous\n   set of data vectors plus parity\
    \ vectors for the given FEC algorithm\n   used.  For example, a coding scheme\
    \ that provides for 64 data symbols\n   and 32 parity symbols per coding block\
    \ would contain FEC symbol\n   identifiers in the range of 0 to 95.\n   Receivers\
    \ then can construct NACK messages requesting sufficient\n   content to satisfy\
    \ their repair needs.  For example, if the receiver\n   has three erasures in\
    \ a given received coding block, it will request\n   transmission of the three\
    \ lowest ordinal parity vectors in the coding\n   block.  In our example coding\
    \ scheme from the previous paragraph, the\n   receiver would explicitly request\
    \ parity symbols 64 to 66 to fill its\n   three erasures for the coding block.\
    \  Note that if the receiver's\n   loss for the coding block exceeds the available\
    \ parity quantity\n   (i.e., greater than 32 missing symbols in our example),\
    \ the receiver\n   will be required to construct a NACK requesting all (32) of\
    \ the\n   available parity symbols plus some additional portions of its missing\n\
    \   data symbols in order to reconstruct the block.  If this is done\n   consistently\
    \ across the receiver group, the resulting NACKs will\n   comprise a minimal set\
    \ of sender transmissions to satisfy their\n   repair needs.\n   In summary, the\
    \ rule is to request the lower ordinal portion of the\n   parity content for the\
    \ FEC coding block to satisfy the erasure repair\n   needs on the first NACK cycle.\
    \  If the available number of parity\n   symbols is insufficient, the receiver\
    \ will also request the subset of\n   ordinally highest missing data symbols to\
    \ cover what the parity\n   symbols will not fill.  Note this strategy assumes\
    \ FEC codes such as\n   Reed-Solomon for which a single parity symbol can repair\
    \ any erased\n   symbol.  This strategy would need minor modification to take\
    \ into\n   account the possibly limited repair capability of other FEC types.\n\
    \   On subsequent NACK repair cycles where the receiver may have received\n  \
    \ some portion of its previously requested repair content, the receiver\n   will\
    \ use the same strategy, but only NACK for the set of parity\n   and/or data symbols\
    \ it has not yet received.  Optionally, the\n   receivers could also provide a\
    \ count of erasures as a convenience to\n   the sender or intermediate systems\
    \ assisting NACK operation.\n   After receipt and accumulation of NACK messages\
    \ during the\n   aggregation period, the sender can begin transmission of fresh\n\
    \   (previously untransmitted) parity symbols for the coding block based\n   on\
    \ the highest receiver erasure count _if_ it has a sufficient\n   quantity of\
    \ parity symbols that were _not_ previously transmitted.\n   Otherwise, the sender\
    \ MUST resort to transmitting the explicit set of\n   repair vectors requested.\
    \  With this approach, the sender needs to\n   maintain very little state on requests\
    \ it has received from the group\n   without need for synchronization of repair\
    \ requests from the group.\n   Since all receivers use the same consistent algorithm\
    \ to express\n   their explicit repair needs, NACK suppression among receivers\
    \ is\n   simplified over the course of multiple repair cycles.  The receivers\n\
    \   can simply compare NACKs heard from other receivers against their own\n  \
    \ calculated repair needs to determine whether they should transmit or\n   suppress\
    \ their pending NACK messages.\n"
- title: 3.2.3.2.  NACK Content Format
  contents:
  - "3.2.3.2.  NACK Content Format\n   The format of NACK content will depend on the\
    \ protocol's data service\n   model and the format of data content identification\
    \ the protocol\n   uses.  This NACK format also depends upon the type of FEC encoding\n\
    \   (if any) used.  Figure 2 illustrates a logical, hierarchical\n   transmission\
    \ content identification scheme, denoting that the notion\n   of objects (or streams)\
    \ and/or FEC blocking is optional at the\n   protocol instantiation's discretion.\
    \  Note that the identification of\n   objects is with respect to a given sender.\
    \  It is recommended that\n   transport data content identification is done within\
    \ the context of a\n   sender in a given session.  Since the notion of session\
    \ \"streams\" and\n   \"blocks\" is optional, the framework degenerates to that\
    \ of typical\n   transport data segmentation and reassembly in its simplest form.\n\
    \   Session_\n           \\_\n              Sender_\n                     \\_\n\
    \                        [Object/Stream(s)]_\n                               \
    \            \\_\n                                              [FEC Blocks]_\n\
    \                                                           \\_\n            \
    \                                                  Symbols\n            Fig. 2:\
    \ NORM Data Content Identification Hierarchy\n   The format of NACK messages should\
    \ meet the following goals:\n   1) Able to identify transport data unit transmissions\
    \ required to\n      repair a portion of the received content, whether it is an\
    \ entire\n      missing object/stream (or range), entire FEC coding block(s),\
    \ or\n      sets of symbols,\n   2) Be simple to process for NACK aggregation\
    \ and suppression,\n   3) Be capable of including NACKs for multiple objects,\
    \ FEC coding\n      blocks and/or symbols in a single message, and\n   4) Have\
    \ a reasonably compact format.\n   If the NORM transport object/stream is identified\
    \ with an <objectId>\n   and the FEC symbol being transmitted is identified with\
    \ an\n   <fecPayloadId>, the concatenation of <objectId::fecPayloadId>\n   comprises\
    \ a basic transport protocol data unit (TPDU) identifier for\n   symbols from\
    \ a given source.  NACK content can be composed of lists\n   and/or ranges of\
    \ these TPDU identifiers to build up NACK messages to\n   describe the receivers\
    \ repair needs.  If no hierarchical object\n   delineation or FEC blocking is\
    \ used, the TPDU is a simple linear\n   representation of the data symbols transmitted\
    \ by the sender.  When\n   the TPDU represents a hierarchy for purposes of object/stream\n\
    \   delineation and/or FEC blocking, the NACK content unit may require\n   flags\
    \ to indicate which portion of the TPDU is applicable.  For\n   example, if an\
    \ entire \"object\" (or range of objects) is missing in\n   the received data,\
    \ the receiver will not necessarily know the\n   appropriate range of <sourceBlockNumbers>\
    \ or <encodingSymbolIds> for\n   which to request repair and thus requires some\
    \ mechanism to request\n   repair (or retransmission) of the entire unit represented\
    \ by an\n   <objectId>.  The same is true if entire FEC coding blocks represented\n\
    \   by one or a range of <sourceBlockNumbers> have been lost.\n   NACK Content\
    \ Interface Description\n   Inputs:\n      1) Sender identification.\n      2)\
    \ Sender data identification.\n      3) Sender FEC Object Transmission Information.\n\
    \      4) Recorded sender transmission sequence position.\n      5) Current sender\
    \ transmission sequence position.  History of\n         repair needs for this\
    \ sender.\n   Outputs:\n      1)   NACK message with repair requests.\n"
- title: 3.2.4.  Sender Repair Response
  contents:
  - "3.2.4.  Sender Repair Response\n   Upon reception of a repair request from a\
    \ receiver in the group, the\n   sender will initiate a repair response procedure.\
    \  The sender may\n   wish to delay transmission of repair content until it has\
    \ had\n   sufficient time to accumulate potentially multiple NACKs from the\n\
    \   receiver set.  This allows the sender to determine the most efficient\n  \
    \ repair strategy for a given transport stream/object or FEC coding\n   block.\
    \  Depending upon the approach used, some protocols may find it\n   beneficial\
    \ for the sender to provide an indicator of pending repair\n   transmissions as\
    \ part of its current transmitted message content.\n   This can aid some NACK\
    \ suppression mechanisms.  The amount of time to\n   perform this NACK aggregation\
    \ should be sufficient to allow for the\n   maximum receiver NACK backoff window\
    \ (\"T_maxBackoff\" from Section\n   3.2.2) and propagation of NACK messages from\
    \ the receivers to the\n   sender.  Note the maximum transmission delay of a message\
    \ from a\n   receiver to the sender may be approximately (1*GRTT) in the case\
    \ of\n   very asymmetric network topology with respect to transmission delay.\n\
    \   Thus, if the maximum receiver NACK backoff time is T_maxBackoff =\n   K*GRTT,\
    \ the sender NACK aggregation period should be equal to at\n   least:\n      \
    \     T_sndrAggregate = T_maxBackoff + 1*GRTT = (K+1)*GRTT\n   Immediately after\
    \ the sender NACK aggregation period, the sender will\n   begin transmitting repair\
    \ content determined from the aggregate NACK\n   state and continue with any new\
    \ transmission.  Also, at this time,\n   the sender should observe a \"holdoff\"\
    \ period where it constrains\n   itself from initiating a new NACK aggregation\
    \ period to allow\n   propagation of the new transmission sequence position due\
    \ to the\n   repair response to the receiver group.  To allow for worst case\n\
    \   asymmetry, this \"holdoff\" time should be:\n                          T_sndrHoldoff\
    \ = 1*GRTT\n   Recall that the receivers will also employ a \"holdoff\" timeout\
    \ after\n   generating a NACK message to allow time for the sender's response.\n\
    \   Given a sender <T_sndrAggregate> plus <T_sndrHoldoff> time of\n   (K+1)*GRTT,\
    \ the receivers should use holdoff timeouts of:\n       T_rcvrHoldoff = T_sndrAggregate\
    \ + T_sndrHoldoff = (K+2)*GRTT\n   This allows for a worst-case propagation time\
    \ of the receiver's NACK\n   to the sender, the sender's aggregation time and\
    \ propagation of the\n   sender's response back to the receiver.  Additionally,\
    \ in the case of\n   unicast feedback from the receiver set, it may be useful\
    \ for the\n   sender to forward (via multicast) a representation of its aggregated\n\
    \   NACK content to the group to allow for NACK suppression when there is\n  \
    \ not multicast connectivity among the receiver set.\n   At the expiration of\
    \ the <T_sndrAggregate> timeout, the sender will\n   begin transmitting repair\
    \ messages according to the accumulated\n   content of NACKs received.  There\
    \ are some guidelines with regards to\n   FEC-based repair and the ordering of\
    \ the repair response from the\n   sender that can improve reliable multicast\
    \ efficiency:\n   1) When FEC is used, it is beneficial that the sender transmit\n\
    \      previously untransmitted parity content as repair messages\n      whenever\
    \ possible.  This  maximizes the receiving nodes' ability\n      to reconstruct\
    \ the entire transmitted content from their\n      individual subsets of received\
    \ messages.\n   2) The transmitted object and/or stream data and repair content\n\
    \      should be indexed with  monotonically increasing sequence numbers\n   \
    \   (within a reasonably large ordinal space).  If the sender observes\n     \
    \ the discipline of transmitting repair for the earliest content\n      (e.g.,\
    \ ordinally lowest FEC blocks) first, the receivers can use a\n      strategy\
    \ of withholding repair requests for later content until\n      the sender once\
    \ again returns to that point in the object/stream\n      transmission sequence.\
    \  This can increase overall message\n      efficiency among the group and help\
    \ work to keep repair cycles\n      relatively synchronized without dependence\
    \ upon strict time\n      synchronization among the sender and receivers.  This\
    \ also helps\n      minimize the buffering requirements of receivers and senders\
    \ and\n      reduces redundant transmission of data to the group at large.\n \
    \  Sender Repair Response Interface Description\n   Inputs:\n      1) Receiver\
    \ NACK messages\n      2) Group timing information\n   Outputs\n      1) Repair\
    \ messages (FEC and/or Data content retransmission)\n      2) Advertisement of\
    \ current pending repair transmissions when\n         unicast receiver feedback\
    \ is detected.\n"
- title: 3.3.  NORM Receiver Join Policies and Procedures
  contents:
  - "3.3.  NORM Receiver Join Policies and Procedures\n   Consideration should be\
    \ given to the policies and procedures by which\n   new receivers join a group\
    \ (perhaps where reliable transmission is\n   already in progress) and begin requesting\
    \ repair.  If receiver joins\n   are unconstrained, the dynamics of group membership\
    \ may impede the\n   application's ability to meet its goals for forward progression\
    \ of\n   data transmission.  Policies limiting the opportunities when\n   receivers\
    \ begin participating in the NACK process may be used to\n   achieve the desired\
    \ behavior.  For example, it may be beneficial for\n   receivers to attempt reliable\
    \ reception from a newly-heard sender\n   only upon non-repair transmissions of\
    \ data in the first FEC block of\n   an object or logical portion of a stream.\
    \  The sender may also\n   implement policies limiting the receivers from which\
    \ it will accept\n   NACK requests, but this may be prohibitive for scalability\
    \ reasons in\n   some situations.  Alternatively, it may be desirable to have\
    \ a looser\n   transport synchronization policy and rely upon session management\n\
    \   mechanisms to limit group dynamics that can cause poor performance,\n   in\
    \ some types of bulk transfer applications (or for potential\n   interactive reliable\
    \ multicast applications).\n   Group Join Policy Interface Description\n   Inputs:\n\
    \      1) Current object/stream data/repair content and sequencing\n         identifiers\
    \ from sender transmissions.\n   Outputs:\n      1) Receiver yes/no decision to\
    \ begin receiving and NACKing for\n         reliable reception of data\n"
- title: 3.4.  Reliable Multicast Member Identification
  contents:
  - "3.4.  Reliable Multicast Member Identification\n   In a NORM protocol (or other\
    \ multicast protocols) where there is the\n   potential for multiple sources of\
    \ data, it is necessary to provide\n   some mechanism to uniquely identify the\
    \ sources (and possibly some or\n   all receivers in some cases) within the group.\
    \  Identity based on\n   arriving packet source addresses is insufficient for\
    \ several reasons.\n   These reasons include routing changes for hosts with multiple\n\
    \   interfaces that result in different packet source addresses for a\n   given\
    \ host over time, network address translation (NAT) or firewall\n   devices, or\
    \ other transport/network bridging approaches.  As a\n   result, some type of\
    \ unique source identifier <sourceId> field should\n   be present in packets transmitted\
    \ by reliable multicast session\n   members.\n"
- title: 3.5.  Data Content Identification
  contents:
  - "3.5.  Data Content Identification\n   The data and repair content transmitted\
    \ by a NORM sender requires\n   some form of identification in the protocol header\
    \ fields.  This\n   identification is required to facilitate the reliable NACK-oriented\n\
    \   repair process.  These identifiers will also be used in NACK messages\n  \
    \ generated.  This building block document assumes two very general\n   types\
    \ of data that may comprise bulk transfer session content.  One\n   type is static,\
    \ discrete objects of finite size and the other is\n   continuous non-finite streams.\
    \  A given application  may wish to\n   reliably multicast data content using\
    \ either one or both of these\n   paradigms.  While it may be possible for some\
    \ applications to further\n   generalize this model and provide mechanisms to\
    \ encapsulate static\n   objects as content embedded within a stream, there are\
    \ advantages in\n   many applications to provide distinct support for static bulk\
    \ objects\n   and messages with the context of a reliable multicast session. \
    \ These\n   applications may include content caching servers, file transfer, or\n\
    \   collaborative tools with bulk content.  Applications with\n   requirements\
    \ for these static object types can then take advantage of\n   transport layer\
    \ mechanisms (i.e., segmentation/reassembly, caching,\n   integrated forward error\
    \ correction coding, etc.) rather than being\n   required to provide their own\
    \ mechanisms for these functions at the\n   application layer.\n   As noted, some\
    \ applications may alternatively desire to transmit bulk\n   content in the form\
    \ of one or more streams of non-finite size.\n   Example streams include continuous\
    \ quasi-real-time message broadcasts\n   (e.g., stock ticker) or some content\
    \ types that are part of\n   collaborative tools or other applications.  And,\
    \ as indicated above,\n   some applications may wish to encapsulate other bulk\
    \ content (e.g.,\n   files) into one or more streams within a multicast session.\n\
    \   The components described within this building block document are\n   envisioned\
    \ to be applicable to both of these models with the\n   potential for a mix of\
    \ both types within a single multicast session.\n   To support this requirement,\
    \ the normal data content identification\n   should include a field to uniquely\
    \ identify the object or stream\n   <objectId> within some reasonable temporal\
    \ or ordinal interval.  Note\n   that it is _not_ expected that this data content\
    \ identification will\n   be globally unique.  It is expected that the object/stream\
    \ identifier\n   will be unique with respect to a given sender within the reliable\n\
    \   multicast session and during the time that sender is supporting a\n   specific\
    \ transport instance of that object or stream.\n   Since the \"bulk\" object/stream\
    \ content usually requires segmentation,\n   some form of segment identification\
    \ must also be  provided.  This\n   segment identifier will be relative to any\
    \ object or stream\n   identifier that has been provided.  Thus, in some cases,\
    \ NORM\n   protocol instantiations may be able to receive transmissions and\n\
    \   request repair for multiple streams and one or more sets of static\n   objects\
    \ in parallel.  For protocol instantiations employing FEC the\n   segment identification\
    \ portion of the data content identifier may\n   consist of a logical concatenation\
    \ of a coding block identifier\n   <sourceBlockNumber> and an identifier for the\
    \ specific data or parity\n   symbol <encodingSymbolId> of the code block.  The\
    \ FEC Building Block\n   document [9] provides a standard message format for identifying\
    \ FEC\n   transmission content.  NORM protocol instantiations using FEC SHOULD\n\
    \   follow that document's guidelines.\n   Additionally, flags to determine the\
    \ usage of the content identifier\n   fields (e.g., stream vs. object) may be\
    \ applicable.  Flags may also\n   serve other purposes in data content identification.\
    \  It is expected\n   that any flags defined will be dependent upon individual\
    \ protocol\n   instantiations.\n   In summary, the following data content identification\
    \ fields may be\n   required for NORM protocol data content messages:\n   1) Source\
    \ node identifier (<sourceId>)\n   2) Object/Stream identifier (<objectId>), if\
    \ applicable.\n   3) FEC Block identifier (<sourceBlockNumber>), if applicable.\n\
    \   4) FEC Symbol identifier (<encodingSymbolId>)\n   5) Flags to differentiate\
    \ interpretation of identifier fields or\n      identifier structure that implicitly\
    \ indicates usage.\n   6) Additional FEC transmission content fields per FEC Building\
    \ Block\n   These fields have been identified because any generated NACK messages\n\
    \   will use these identifiers in requesting repair or retransmission of\n   data.\
    \  NORM protocols that use these data content fields should also\n   be compatible\
    \ with support for intermediate system assistance to\n   reliable multicast transport\
    \ operation when available.\n"
- title: 3.6.  Forward Error Correction (FEC)
  contents:
  - "3.6.  Forward Error Correction (FEC)\n   Multiple forward error correction (FEC)\
    \ approaches have been\n   identified that can provide great performance enhancements\
    \ to the\n   repair process of NACK-oriented and other reliable multicast\n  \
    \ protocols [11], [12], [13].  NORM protocols can reap additional\n   benefits\
    \ since FEC-based repair does not _generally_ require explicit\n   knowledge of\
    \ repair content within the bounds of its coding block\n   size (in symbols).\
    \  In NORM, parity repair packets generated will\n   generally be transmitted\
    \ only in response to NACK repair requests\n   from receiving nodes.  However,\
    \ there are benefits in some network\n   environments for transmitting some predetermined\
    \ quantity of FEC\n   repair packets multiplexed with the regular data symbol\
    \ transmissions\n   [14].  This can reduce the amount of NACK traffic generated\
    \ with\n   relatively little overhead cost when group sizes are very large or\n\
    \   the network connectivity has a large delay*bandwidth product with\n   some\
    \ nominal level of expected packet loss.  While the application of\n   FEC is\
    \ not unique to NORM, these sorts of requirements may dictate\n   the types of\
    \ algorithms and protocol approaches that are applicable.\n   A specific issue\
    \ related to the use of FEC with NORM is the mechanism\n   used to identify the\
    \ portion(s) of transmitted data content to which\n   specific FEC packets are\
    \ applicable.  It is expected that FEC\n   algorithms will be based on generating\
    \ a set of parity repair packets\n   for a corresponding block of transmitted\
    \ data packets.  Since data\n   content packets are uniquely identified by the\
    \ concatenation of\n   <sourceId::objectId::sourceBlockNumber::encodingSymbolId>\
    \ during\n   transport, it is expected that FEC packets will be identified in\
    \ a\n   similar manner.  The FEC Building Block document [9] provides\n   detailed\
    \ recommendations concerning application of FEC and standard\n   formats for related\
    \ reliable multicast protocol messages.\n"
- title: 3.7.  Round-trip Timing Collection
  contents:
  - "3.7.  Round-trip Timing Collection\n   The measurement of packet propagation\
    \ round-trip time (RTT) among\n   members of the group is required to support\
    \ timer-based NACK\n   suppression algorithms, timing of sender commands or certain\
    \ repair\n   functions, and congestion control operation.  The nature of the\n\
    \   round-trip information collected is dependent upon the type of\n   interaction\
    \ among the members of the group.  In the case where only\n   \"one-to-many\"\
    \ transmission is required, it may be that only the\n   sender require RTT knowledge\
    \ of the greatest RTT (GRTT) among the\n   receiver set and/or RTT knowledge of\
    \ only a portion of the group.\n   Here, the GRTT information might be collected\
    \ in a reasonably\n   scalable manner.  For congestion control operation, it is\
    \ possible\n   that RTT information may be required by each receiver in the group.\n\
    \   In this case, an alternative RTT collection scheme may be utilized\n   where\
    \ receivers collect individual RTT measurements with respect to\n   the sender\
    \ and advertise them to the group or sender.  Where it is\n   likely that exchange\
    \ of reliable multicast data will occur among the\n   group on a \"many-to-many\"\
    \ basis, there are alternative measurement\n   techniques that might be employed\
    \ for increased efficiency [15].  And\n   in some cases, there might be absolute\
    \ time synchronization among\n   hosts that may simplify RTT measurement.  There\
    \ are trade-offs in\n   multicast congestion control design that require further\n\
    \   consideration before a universal recommendation on RTT (or GRTT)\n   measurement\
    \ can be specified.  Regardless of how the RTT information\n   is collected (and\
    \ more specifically GRTT) with respect to congestion\n   control or other requirements,\
    \ the sender will need to advertise its\n   current GRTT estimate to the group\
    \ for various timeouts used by\n   receivers.\n"
- title: 3.7.1.  One-to-Many Sender GRTT Measurement
  contents:
  - "3.7.1.  One-to-Many Sender GRTT Measurement\n   The goal of this form of RTT\
    \ measurement is for the sender to learn\n   the GRTT among the receivers who\
    \ are actively participating in NORM\n   operation.  The set of receivers participating\
    \ in this process may be\n   the entire group or some subset of the group determined\
    \ from another\n   mechanism within the protocol instantiation.  An approach to\
    \ collect\n   this GRTT information follows.\n   The sender periodically polls\
    \ the group with a message (independent\n   or \"piggy-backed\" with other transmissions)\
    \ containing a <sendTime>\n   timestamp relative to an internal clock at the sender.\
    \  Upon\n   reception of this message, the receivers will record this <sendTime>\n\
    \   timestamp and the time (referenced to their own clocks) at which it\n   was\
    \ received <recvTime>.  When the receiver provides feedback to the\n   sender\
    \ (either explicitly or as part of other feedback messages\n   depending upon\
    \ protocol instantiation specification), it will\n   construct a \"response\"\
    \ using the formula:\n            grttResponse = sendTime + (currentTime - recvTime)\n\
    \   where the <sendTime> is the timestamp from the last probe message\n   received\
    \ from the source and the (<currentTime> - <recvTime>) is the\n   amount of time\
    \ differential since that request was received until the\n   receiver generated\
    \ the response.\n   The sender processes each receiver response by calculating\
    \ a current\n   RTT measurement for the receiver from whom the response was received\n\
    \   using the following formula:\n                   RTT_rcvr = currentTime -\
    \ grttResponse\n   During the each periodic GRTT probing interval, the source\
    \ keeps the\n   peak round trip timing measurement (RTT_peak) from the set of\n\
    \   responses it has received.  A conservative estimate of GRTT is kept\n   to\
    \ maximize the efficiency of redundant NACK suppression and repair\n   aggregation.\
    \  The update to the source's ongoing estimate of GRTT is\n   done observing the\
    \ following rules:\n   1) If a receiver's response round trip time (RTT_rcvr)\
    \ is greater\n      than the current GRTT estimate, the GRTT is immediately updated\
    \ to\n      this new peak value:\n                               GRTT = RTT_rcvr\n\
    \   2) At the end of the response collection period (i.e., the GRTT probe\n  \
    \    interval), if the recorded \"peak\" response RTT_peak) is less than\n   \
    \   the current GRTT estimate, the GRTT is updated to:\n                     \
    \   GRTT = MAX(0.9*GRTT, RTT_peak)\n   3) If no feedback is received, the sender\
    \ GRTT estimate remains\n      unchanged.\n   4) At the end of the response collection\
    \ period, the peak tracking\n      value (RTT_peak) is reset to ZERO for subsequent\
    \ peak detection.\n   The GRTT collection period (i.e., period of probe transmission)\
    \ could\n   be fixed at a value on the order of that expected for group\n   membership\
    \ and/or network topology dynamics.  For robustness, more\n   rapid probing could\
    \ be used at protocol startup before settling to a\n   less frequent, steady-state\
    \ interval.  Optionally, an algorithm may\n   be developed to adjust the GRTT\
    \ collection period dynamically in\n   response to the current GRTT estimate (or\
    \ variations in it) and to an\n   estimation of packet loss.  The overhead of\
    \ probing messages could\n   then be reduced when the GRTT estimate is stable\
    \ and unchanging, but\n   be adjusted to track more dynamically during periods\
    \ of variation\n   with correspondingly shorter GRTT collection periods.  GRTT\n\
    \   collection may also be coupled with collection of other information\n   for\
    \ congestion control purposes.\n   In summary, although NORM repair cycle timeouts\
    \ are based on GRTT, it\n   should be noted that convergent operation of the protocol\
    \ does not\n   _strictly_ depend on highly accurate GRTT estimation.  The current\n\
    \   mechanism has proved sufficient in simulations and in the\n   environments\
    \ where NORM-like protocols have been deployed to date.\n   The estimate provided\
    \ by the algorithm tracks the peak envelope of\n   actual GRTT (including operating\
    \ system effect as well as network\n   delays) even in relatively high loss connectivity.\
    \  The steady-state\n   probing/update interval may potentially be varied to accommodate\n\
    \   different levels of expected network dynamics in different\n   environments.\n"
- title: 3.7.2.  One-to-Many Receiver RTT Measurement
  contents:
  - "3.7.2.  One-to-Many Receiver RTT Measurement\n   In this approach, receivers\
    \ send messages with timestamps to the\n   sender.  To control the volume of these\
    \ receiver-generated messages,\n   a suppression mechanism similar to that described\
    \ for NACK\n   suppression my be used.  The \"age\" of receivers' RTT measurement\n\
    \   should be kept by receivers and used as a metric in competing for\n   feedback\
    \ opportunities in the suppression scheme.  For example,\n   receiver who have\
    \ not made any RTT measurement or whose RTT\n   measurement has aged most should\
    \ have precedence over other\n   receivers.  In turn the sender may have limited\
    \ capacity to provide\n   an \"echo\" of the receiver timestamps back to the group,\
    \ and it could\n   use this RTT \"age\" metric to determine which receivers get\n\
    \   precedence.  The sender can determine the GRTT as described in 3.7.1\n   if\
    \ it provides sender timestamps to the group.  Alternatively,\n   receivers who\
    \ note their RTT is greater than the sender GRTT can\n   compete in the feedback\
    \ opportunity/suppression scheme to provide the\n   sender and group with this\
    \ information.\n"
- title: 3.7.3.  Many-to-Many RTT Measurement
  contents:
  - "3.7.3.  Many-to-Many RTT Measurement\n   For reliable multicast sessions that\
    \ involve multiple senders, it may\n   be useful to have RTT measurements occur\
    \ on a true \"many-to-many\"\n   basis rather than have each sender independently\
    \ tracking RTT.  Some\n   protocol efficiency can be gained when receivers can\
    \ infer an\n   approximation of their RTT with respect to a sender based on RTT\n\
    \   information they have on another sender and that other sender's RTT\n   with\
    \ respect to the new sender of interest.  For example, for\n   receiver \"a\"\
    \ and sender's \"b\" and \"c\", it is likely that:\n                  RTT(a<->b)\
    \ <= RTT(a<->c)) + RTT(b<->c)\n   Further refinement of this estimate can be conducted\
    \ if RTT\n   information is available to a node concerning its own RTT to a small\n\
    \   subset of other group members and RTT information among those other\n   group\
    \ members it learns during protocol operation.\n"
- title: 3.7.4.  Sender GRTT Advertisement
  contents:
  - "3.7.4.  Sender GRTT Advertisement\n   To facilitate deterministic NORM protocol\
    \ operation, the sender\n   should robustly advertise its current estimation of\
    \ GRTT to the\n   receiver set.  Common, robust knowledge of the sender's current\n\
    \   operating GRTT estimate among the group will allow the protocol to\n   progress\
    \ in its most efficient manner.  The sender's GRTT estimate\n   can be robustly\
    \ advertised to the group by simply embedding the\n   estimate into all pertinent\
    \ messages transmitted by the sender.  The\n   overhead of this can be made quite\
    \ small by quantizing (compressing)\n   the GRTT estimate to a single byte of\
    \ information.  The following C-\n   language functions allows this to be done\
    \ over a wide range (RTT_MIN\n   through RTT_MAX) of GRTT values while maintaining\
    \ a greater range of\n   precision for small GRTT values and less precision for\
    \ large values.\n   Values of 1.0e-06 seconds and 1000 seconds are RECOMMENDED\
    \ for\n   RTT_MIN and RTT_MAX respectively.  NORM applications may wish to\n \
    \  place an additional, smaller upper limit on the GRTT advertised by\n   senders\
    \ to meet application data delivery latency constraints at the\n   expense of\
    \ greater feedback volume in some network environments.\n      unsigned char QuantizeGrtt(double\
    \ grtt)\n      {\n          if (grtt > RTT_MAX)\n              grtt = RTT_MAX;\n\
    \          else if (grtt < RTT_MIN)\n              grtt = RTT_MIN;\n         \
    \ if (grtt < (33*RTT_MIN))\n              return ((unsigned char)(grtt / RTT_MIN)\
    \ - 1);\n          else\n              return ((unsigned char)(ceil(255.0-\n \
    \                                     (13.0 * log(RTT_MAX/grtt)))));\n      }\n\
    \      double UnquantizeRtt(unsigned char qrtt)\n      {\n           return ((qrtt\
    \ <= 31) ?\n                     (((double)(qrtt+1))*(double)RTT_MIN) :\n    \
    \                (RTT_MAX/exp(((double)(255-qrtt))/(double)13.0)));\n      }\n\
    \   Note that this function is useful for quantizing GRTT times in the\n   range\
    \ of 1 microsecond to 1000 seconds.  Of course, NORM protocol\n   implementations\
    \ may wish to further constrain advertised GRTT\n   estimates (e.g., limit the\
    \ maximum value) for practical reasons.\n"
- title: 3.8.  Group Size Determination/Estimation
  contents:
  - "3.8.  Group Size Determination/Estimation\n   When NORM protocol operation includes\
    \ mechanisms that excite feedback\n   from the group at large (e.g., congestion\
    \ control), it may be\n   possible to roughly estimate the group size based on\
    \ the number of\n   feedback messages received with respect to the distribution\
    \ of the\n   probabilistic suppression mechanism used.  Note the timer-based\n\
    \   suppression mechanism described in this document does not require a\n   very\
    \ accurate estimate of group size to perform adequately.  Thus, a\n   rough estimate,\
    \ particularly if conservatively managed, may suffice.\n   Group size may also\
    \ be determined administratively.  In absence of a\n   group size determination\
    \ mechanism a default group size value of\n   10,000 is RECOMMENDED for reasonable\
    \ management of feedback given the\n   scalability of expected NORM usage.\n"
- title: 3.9.  Congestion Control Operation
  contents:
  - "3.9.  Congestion Control Operation\n   Congestion control that fairly shares\
    \ available network capacity\n   with other reliable multicast and TCP instantiations\
    \ is REQUIRED for\n   general Internet operation.  The TCP-Friendly Multicast\
    \ Congestion\n   Control (TFMCC) [16] or Pragmatic General Multicast Congestion\n\
    \   Control (PGMCC) techniques [17] may be applied to NORM operation to\n   meet\
    \ this requirement.\n"
- title: 3.10.  Router/Intermediate System Assistance
  contents:
  - "3.10.  Router/Intermediate System Assistance\n   NACK-oriented protocols may\
    \ benefit from general purpose router\n   assistance.  In particular, additional\
    \ NACK suppression where routers\n   or intermediate systems can aggregate NACK\
    \ content (or filter\n   duplicate NACK content) from receivers as it is relayed\
    \ toward the\n   sender could enhance NORM group size scalability.  For NORM protocols\n\
    \   using FEC, it is possible that intermediate systems may be able to\n   filter\
    \ FEC repair messages to provide an intelligent \"subcast\" of\n   repair content\
    \ to different legs of the multicast topology depending\n   on the repair needs\
    \ learned from previous receiver NACKs.  Both of\n   these types of assist functions\
    \ would require router interpretation\n   of transport data unit content identifiers\
    \ and flags.\n"
- title: 3.11.  NORM Applicability
  contents:
  - "3.11.  NORM Applicability\n   The NORM building block applies to protocols wishing\
    \ to employ\n   negative acknowledgement to achieve reliable data transfer.  Properly\n\
    \   designed negative-acknowledgement (NACK)-oriented reliable multicast\n   (NORM)\
    \ protocols offer scalability advantages for applications and/or\n   network topologies\
    \ where, for various reasons, it is prohibitive to\n   construct a higher order\
    \ delivery infrastructure above the basic\n   Layer 3 IP multicast service (e.g.,\
    \ unicast or hybrid\n   unicast/multicast data distribution trees).  Additionally,\
    \ the\n   scalability property of NACK-oriented protocols [18], [19] is\n   applicable\
    \ where broad \"fan-out\" is expected for a single network hop\n   (e.g., cable-TV\
    \ data delivery, satellite, or other broadcast\n   communication services).  Furthermore,\
    \ the simplicity of a protocol\n   based on \"flat\" group-wide multicast distribution\
    \ may offer\n   advantages for a broad range of distributed services or dynamic\n\
    \   networks and applications.  NORM protocols can make use of reciprocal\n  \
    \ (among senders and receivers) multicast communication under the Any-\n   Source\
    \ Multicast (ASM) model defined in RFC 1112 [2], and are capable\n   of scalable\
    \ operation in asymmetric topologies such as Single-Source\n   Multicast (SSM)\
    \ [8] where there may only be unicast routing service\n   from the receivers to\
    \ the sender(s).\n   NORM operation is compatible with transport layer forward\
    \ error\n   correction coding techniques as described in [13] and congestion\n\
    \   control mechanisms such as those described in [16] and [17].  A\n   principal\
    \ limitation of NORM operation involves group size\n   scalability when network\
    \ capacity for receiver feedback is very\n   limited.  NORM operation is also\
    \ governed by implementation buffering\n   constraints.  Buffering greater than\
    \ that required for typical\n   point-to-point reliable transport (e.g., TCP)\
    \ is recommended to allow\n   for disparity in the receiver group connectivity\
    \ and to allow for the\n   feedback delays required to attain group size scalability.\n"
- title: 4.  Security Considerations
  contents:
  - "4.  Security Considerations\n   NORM protocols are expected to be subject to\
    \ the same sort of\n   security vulnerabilities as other IP and IP multicast protocols.\n\
    \   NORM is compatible with IP security (IPsec) authentication mechanisms\n  \
    \ [20] that are RECOMMENDED for protection against session intrusion\n   and denial\
    \ of service attacks.  A particular threat for NACK based\n   protocols is that\
    \ of NACK replay attacks that would prevent a NORM\n   sender from making forward\
    \ progress in transmission.  Any standard\n   IPsec mechanisms that can provide\
    \ protection against such replay\n   attacks are RECOMMENDED for use.  Additionally,\
    \ NORM protocol\n   instantiations SHOULD consider providing support for their\
    \ own NACK\n   replay attack protection when network layer mechanisms are not\n\
    \   available.  The IETF Multicast Security (msec) Working Group is also\n   developing\
    \ solutions which may be applicable to NORM in the future.\n"
- title: 5.  Acknowledgements (and these are not Negative)
  contents:
  - "5.  Acknowledgements (and these are not Negative)\n   The authors would like\
    \ to thank Rick Jones, and Joerg Widmer for\n   their valuable comments on this\
    \ document.  The authors would also\n   like to thank the RMT working group chairs,\
    \ Roger Kermode and Lorenzo\n   Vicisano, for their support in development of\
    \ this specification, and\n   Sally Floyd for her early inputs into this document.\n"
- title: 6.  References
  contents:
  - '6.  References

    '
- title: 6.1.  Normative References
  contents:
  - "6.1.  Normative References\n   [1]  Bradner, S., \"Key words for use in RFCs\
    \ to Indicate Requirement\n        Levels\", BCP 14, RFC 2119, March 1997.\n \
    \  [2]  Deering, S., \"Host Extensions for IP Multicasting\", STD 5, RFC\n   \
    \     1112, August 1989.\n"
- title: 6.2.  Informative References
  contents:
  - "6.2.  Informative References\n   [3]  Mankin, A., Romanow, A., Bradner, S., and\
    \ V. Paxson, \"IETF\n        Criteria for Evaluating Reliable Multicast Transport\
    \ and\n        Application Protocols\", RFC 2357, June 1998.\n   [4]  Clark, D.\
    \ and D. Tennenhouse, \"Architectural Considerations for\n        a New Generation\
    \ of Protocols\". In Proc. ACM SIGCOMM, pages\n        201--208, September 1990.\n\
    \   [5]  Kermode, R. and L. Vicisano, \"Author Guidelines for Reliable\n     \
    \   Multicast Transport (RMT) Building Blocks and Protocol\n        Instantiation\
    \ documents\", RFC 3269, April 2002.\n   [6]  Nonnenmacher, J. and E. Biersack,\
    \ \"Optimal Multicast Feedback,\"\n        in IEEE Infocom, San Francisco, California,\
    \ p. 964, March/April\n        1998.\n   [7]  Macker, J. and R. Adamson, \"Quantitative\
    \ Prediction of Nack\n        Oriented Reliable Multicast (NORM) Feedback\", Proc.\
    \ IEEE MILCOM\n        2002, October 2002.\n   [8]  Holbrook, H., \"A Channel\
    \ Model for Multicast\", Ph.D.\n        Dissertation, Stanford University, Department\
    \ of Computer\n        Science, Stanford, California, August 2001.\n   [9]  Luby,\
    \ M., Vicisano, L., Gemmell, J., Rizzo, L., Handley, M., and\n        J. Crowcroft,\
    \ \"Forward Error Correction (FEC) Building Block\",\n        RFC 3452, December\
    \ 2002.\n   [10] Floyd, S., Jacobson, V., McCanne, S., Liu, C., and L. Zhang.\
    \ \"A\n        Reliable Multicast Framework for Light-weight Sessions and\n  \
    \      Application Level Framing\", Proc. ACM SIGCOMM, August 1995.\n   [11] Metzner,\
    \ J., \"An Improved Broadcast Retransmission Protocol\",\n        IEEE Transactions\
    \ on Communications, Vol. Com-32, No.6, June\n        1984.\n   [12] Macker, J.,\
    \ \"Reliable Multicast Transport and Integrated\n        Erasure-based Forward\
    \ Error Correction\", Proc. IEEE MILCOM 97,\n        October 1997.\n   [13] Luby,\
    \ M., Vicisano, L., Gemmell, J., Rizzo, L., Handley, M., and\n        J. Crowcroft,\
    \ \"The Use of Forward Error Correction (FEC) in\n        Reliable Multicast\"\
    , RFC 3453, December 2002.\n   [14] Gossink, D. and J. Macker, \"Reliable Multicast\
    \ and Integrated\n        Parity Retransmission with Channel Estimation\", IEEE\
    \ GLOBECOM\n        98'.\n   [15] Ozdemir, V., Muthukrishnan, S., and I. Rhee,\
    \ \"Scalable, Low-\n        Overhead Network Delay Estimation\", NCSU/AT&T White\
    \ Paper,\n        February 1999.\n   [16] Widmer, J. and M. Handley, \"Extending\
    \ Equation-Based Congestion\n        Control to Multicast Applications\", Proc\
    \ ACM SIGCOMM 2001, San\n        Diego, August 2001.\n   [17] Rizzo, L., \"pgmcc:\
    \ A TCP-Friendly Single-Rate Multicast\n        Congestion Control Scheme\", Proc\
    \ ACM SIGCOMM 2000, Stockholm,\n        August 2000.\n   [18] Pingali, S., Towsley,\
    \ D., and J. Kurose, \"A Comparison of\n        Sender-Initiated and Receiver-Initiated\
    \ Reliable Multicast\n        Protocols\".  In Proc. INFOCOM, San Francisco, CA,\
    \ October 1993.\n   [19] B.N. Levine, J.J. Garcia-Luna-Aceves, \"A Comparison\
    \ of Known\n        Classes of Reliable Multicast Protocols\", Proc. International\n\
    \        Conference on Network Protocols (ICNP-96), Columbus, Ohio, Oct\n    \
    \    29--Nov 1, 1996.\n   [20] Kent, S. and R. Atkinson, \"Security Architecture\
    \ for the\n        Internet Protocol\", RFC 2401, November 1998.\n"
- title: 7.  Authors' Addresses
  contents:
  - "7.  Authors' Addresses\n   Brian Adamson\n   Naval Research Laboratory\n   Washington,\
    \ DC 20375\n   EMail: adamson@itd.nrl.navy.mil\n   Carsten Bormann\n   Universitaet\
    \ Bremen TZI\n   Postfach 330440\n   D-28334 Bremen, Germany\n   EMail: cabo@tzi.org\n\
    \   Mark Handley\n   Department of Computer Science\n   University College London\n\
    \   Gower Street\n   London\n   WC1E 6BT\n   UK\n   EMail: M.Handley@cs.ucl.ac.uk\n\
    \   Joe Macker\n   Naval Research Laboratory\n   Washington, DC 20375\n   EMail:\
    \ macker@itd.nrl.navy.mil\n"
- title: Full Copyright Statement
  contents:
  - "Full Copyright Statement\n   Copyright (C) The Internet Society (2004).\n   This\
    \ document is subject to the rights, licenses and restrictions\n   contained in\
    \ BCP 78, and except as set forth therein, the authors\n   retain all their rights.\n\
    \   This document and the information contained herein are provided on an\n  \
    \ \"AS IS\" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS\n  \
    \ OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY AND THE INTERNET\n   ENGINEERING\
    \ TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS OR IMPLIED,\n   INCLUDING BUT NOT\
    \ LIMITED TO ANY WARRANTY THAT THE USE OF THE\n   INFORMATION HEREIN WILL NOT\
    \ INFRINGE ANY RIGHTS OR ANY IMPLIED\n   WARRANTIES OF MERCHANTABILITY OR FITNESS\
    \ FOR A PARTICULAR PURPOSE.\n"
- title: Intellectual Property
  contents:
  - "Intellectual Property\n   The IETF takes no position regarding the validity or\
    \ scope of any\n   Intellectual Property Rights or other rights that might be\
    \ claimed to\n   pertain to the implementation or use of the technology described\
    \ in\n   this document or the extent to which any license under such rights\n\
    \   might or might not be available; nor does it represent that it has\n   made\
    \ any independent effort to identify any such rights.  Information\n   on the\
    \ IETF's procedures with respect to rights in IETF Documents can\n   be found\
    \ in BCP 78 and BCP 79.\n   Copies of IPR disclosures made to the IETF Secretariat\
    \ and any\n   assurances of licenses to be made available, or the result of an\n\
    \   attempt made to obtain a general license or permission for the use of\n  \
    \ such proprietary rights by implementers or users of this\n   specification can\
    \ be obtained from the IETF on-line IPR repository at\n   http://www.ietf.org/ipr.\n\
    \   The IETF invites any interested party to bring to its attention any\n   copyrights,\
    \ patents or patent applications, or other proprietary\n   rights that may cover\
    \ technology that may be required to implement\n   this standard.  Please address\
    \ the information to the IETF at ietf-\n   ipr@ietf.org.\n"
- title: Acknowledgement
  contents:
  - "Acknowledgement\n   Funding for the RFC Editor function is currently provided\
    \ by the\n   Internet Society.\n"
