- title: __initial_text__
  contents:
  - "                       IP Multicast Applications:\n                        Challenges\
    \ and Solutions\n"
- title: Status of this Memo
  contents:
  - "Status of this Memo\n   This memo provides information for the Internet community.\
    \  It does\n   not specify an Internet standard of any kind.  Distribution of\
    \ this\n   memo is unlimited.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (C) The Internet Society (2001).  All Rights Reserved.\n"
- title: Abstract
  contents:
  - "Abstract\n   This document describes the challenges involved with designing and\n\
    \   implementing multicast applications.  It is an introductory guide for\n  \
    \ application developers that highlights the unique considerations of\n   multicast\
    \ applications as compared to unicast applications.\n   To this end, the document\
    \ presents a taxonomy of multicast\n   application I/O models and examples of\
    \ the services they can support.\n   It then describes the service requirements\
    \ of these multicast\n   applications, and the recent and ongoing efforts to build\
    \ protocol\n   solutions to support these services.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1. Introduction. . . . . . . . . . . . . . . . . . . .\
    \ . . . . . . 2\n     1.1 Motivation . . . . . . . . . . . . . . . . . . . . .\
    \ . . . . 2\n     1.2 Focus and Scope. . . . . . . . . . . . . . . . . . . . .\
    \ . . 3\n   2. IP Multicast-enabled Network. . . . . . . . . . . . . . . . . .\
    \ 3\n     2.1 Essential Protocol Components. . . . . . . . . . . . . . . . 4\n\
    \       2.1.1 Expedient Joins and Leaves . . . . . . . . . . . . . . . 5\n   \
    \    2.1.2 Send without a Join. . . . . . . . . . . . . . . . . . . 5\n   3. IP\
    \ Multicast Application Taxonomy . . . . . . . . . . . . . . . 6\n     3.1 One-to-Many\
    \ Applications . . . . . . . . . . . . . . . . . . 8\n     3.2 Many-to-Many Applications.\
    \ . . . . . . . . . . . . . . . . . 9\n     3.3 Many-to-One Applications . . .\
    \ . . . . . . . . . . . . . . .10\n   4. Common Multicast Service Requirements\
    \ . . . . . . . . . . . . .13\n     4.1 Bandwidth Requirements . . . . . . . .\
    \ . . . . . . . . . . .13\n     4.2 Delay Requirements . . . . . . . . . . . .\
    \ . . . . . . . . .13\n   5. Unique Multicast Service Requirements . . . . . .\
    \ . . . . . . .14\n     5.1 Address Management . . . . . . . . . . . . . . . .\
    \ . . . . .16\n     5.2 Session Management . . . . . . . . . . . . . . . . . .\
    \ . . .16\n     5.3 Heterogeneous Receiver Support . . . . . . . . . . . . . .\
    \ .18\n     5.4 Reliable Data Delivery . . . . . . . . . . . . . . . . . . .20\n\
    \     5.5 Security . . . . . . . . . . . . . . . . . . . . . . . . . .21\n   \
    \  5.6 Synchronized Play-Out. . . . . . . . . . . . . . . . . . . .23\n   6. Service\
    \ APIs. . . . . . . . . . . . . . . . . . . . . . . . . .23\n   7. Security Considerations\
    \ . . . . . . . . . . . . . . . . . . . .24\n   8. Acknowledgements. . . . . .\
    \ . . . . . . . . . . . . . . . . . .24\n   9. References. . . . . . . . . . .\
    \ . . . . . . . . . . . . . . . .24\n   10. Authors' Addresses . . . . . . . .\
    \ . . . . . . . . . . . . . .27\n   11. Full Copyright Statement . . . . . . .\
    \ . . . . . . . . . . . .28\n"
- title: 1. Introduction
  contents:
  - "1. Introduction\n   IP Multicast will play a prominent role on the Internet in\
    \ the coming\n   years.  It is a requirement, not an option, if the Internet is\
    \ going\n   to scale.  Multicast allows application developers to add more\n \
    \  functionality without significantly impacting the network.\n   Developing multicast-enabled\
    \ applications is ostensibly simple.\n   Having datagram access allows any application\
    \ to send to a multicast\n   address.  A multicast application need only increase\
    \ the Internet\n   Protocol (IP) time-to-live (TTL) value to more than 1 (the\
    \ default\n   value) to allow outgoing datagrams to traverse routers.  To receive\
    \ a\n   multicast datagram, applications join the multicast group, which\n   transparently\
    \ generates an [IGMPv2, IGMPv3] group membership report.\n   This apparent simplicity\
    \ is deceptive, however.  Enabling multicast\n   support in applications and protocols\
    \ that can scale well on a\n   heterogeneous network is a significant challenge.\
    \  Specifically,\n   sending constant bit rate datastreams, reliable data delivery,\n\
    \   security, and managing many-to-many communications all require\n   special\
    \ consideration.  Some solutions are available, but many of\n   these services\
    \ are still active research areas.\n"
- title: 1.1 Motivation
  contents:
  - "1.1 Motivation\n   The purpose of this document is to provide a framework for\n\
    \   understanding the challenges of designing and implementing multicast\n   applications.\
    \  In order to use multicast communications correctly,\n   application developers\
    \ must first understand the various I/O models\n   and the network services (in\
    \ addition to basic multicast\n   communication) that are required.  Secondly,\
    \ application developers\n   need to be aware of efforts underway to provide these\
    \ services.  Such\n   efforts range in maturity from deployed commercial products\
    \ to basic\n   research efforts to evaluate feasibility.\n   Multicast-based applications\
    \ and services will play an important role\n   in the future of the Internet as\
    \ continued multicast deployment\n   encourages their use and development.  It\
    \ is important that\n   developers be aware of the issues and solutions available--and\n\
    \   especially of their limitations--in order to avoid protocols that\n   negatively\
    \ impact networks (thereby counter-acting the benefits of\n   multicast) or wasting\
    \ their efforts \"re-inventing the wheel\".\n   The hope is that by raising developers'\
    \ awareness, we can adjust\n   their expectations of finding solutions and lead\
    \ them to successful,\n   scalable, and \"network-friendly\" development efforts.\n"
- title: 1.2 Focus and Scope
  contents:
  - "1.2 Focus and Scope\n   Our initial premise is that the multicast infrastructure\
    \ is\n   transparent to applications, so it is not directly relevant to this\n\
    \   discussion.  Our focus here is on multicast application protocol\n   services,\
    \ so this document explicitly avoids any discussion of\n   multicast routing issues.\
    \  We identify and describe the multicast-\n   specific issues involved with developing\
    \ applications.\n   We assume the reader has a general understanding of the mechanics\
    \ of\n   multicast, and in this respect we intend to compliment other\n   introductory\
    \ documents [BeauW, Maufer, Miller].  Since this is an\n   introductory survey\
    \ rather than a comprehensive examination, we refer\n   readers to other multicast\
    \ application requirements descriptions [RM,\n   LSMA, Miller] for more detail.\n\
    \   In the remainder of this document we first define the term \"IP\n   multicast\
    \ enabled network\", the multicast infrastructure and\n   essential multicast\
    \ services.  Next we describe the types of new\n   functionality that multicast\
    \ applications can enable and their\n   requirements.  We then examine the services\
    \ that satisfy these\n   requirements, the challenges they present, and provide\
    \ a brief survey\n   of the solutions available or under development.  We wrap\
    \ up with a\n   discussion of application programming interfaces (APIs) for multicast\n\
    \   services.\n"
- title: 2. IP Multicast Enabled Network
  contents:
  - "2. IP Multicast Enabled Network\n   An \"IP multicast-enabled network\" provides\
    \ end-to-end services in the\n   IP network infrastructure to allow any IP host\
    \ to send datagrams to\n   an IP multicast address that any number of other IP\
    \ hosts widely\n   dispersed can receive.\n   There are two kinds of multicast-enabled\
    \ networks available.  The\n   first is based on the original multicast service\
    \ model as defined in\n   RFC 1112 [Deering].  In this model, a receiver simply\
    \ joins the group\n   and does not need to know the identity of the source(s).\
    \  This model\n   is known by a number of names including Internet Standard Multicast\n\
    \   (ISM), Internet Traditional Multicast (ITM), Deering multicast, etc.\n   The\
    \ second kind of multicast modifies the original service model such\n   that in\
    \ addition to knowing the group address, a receiver must know\n   the set of relevant\
    \ sources.  This type of multicast is called Source\n   Specific Multicast (SSM)\
    \ [SSM].  It becomes the application's\n   responsibility to know what kind of\
    \ multicast capability the network\n   provides.  Currently, the only way for\
    \ an application to know the\n   type of multicast is based on the group address.\
    \  If the group is in\n   the 232/8 range, the application should assume SSM is\
    \ the service\n   model.  Otherwise, the application should assume source-generic\n\
    \   multicast is the service model.\n   At the time of this writing, end-to-end\
    \ \"global\" multicast service is\n   not yet available, but the size of the \"\
    multicast-enabled\" Internet\n   is growing.  Recent development and deployment\
    \ of interdomain\n   multicast routing protocols and multicast-friendly Internet\
    \ exchanges\n   have enabled peering between major ISPs.  This, along with the\n\
    \   increasing availability of compelling content, is spurring deployment\n  \
    \ and availability of the IP Multicast Enabled Network.\n   In the remainder of\
    \ this document we assume that the multicast-\n   enabled network is already ubiquitous.\
    \  Since such a large and\n   growing portion of the global Internet is IP multicast-enabled\
    \ now,\n   and many enterprise networks (intranets) are also, this perspective\n\
    \   is relevant today.\n"
- title: 2.1 Essential Protocol Components
  contents:
  - "2.1 Essential Protocol Components\n   An IP multicast enabled network requires\
    \ two essential protocol\n   components:\n     1) An IP host-based protocol to\
    \ allow a receiver application to\n        notify a local router(s) that it has\
    \ joined the group, and\n        initiate the data flow from all sender(s) within\
    \ the scope\n     2) An IP router-based protocol to allow any routers with multicast\n\
    \        group members (receivers) on their local networks to communicate\n  \
    \      with other routers to ensure that all datagrams sent to the\n        group\
    \ address are forwarded to all receivers within the intended\n        scope\n\
    \   Ideally, these protocol components are transparent to multicast\n   applications.\
    \  However, there are two aspects of their functionality\n   requirements that\
    \ are worth mentioning specifically, since they\n   affect application performance\
    \ and design.  These are the multicast\n   application requirements for:\n   \
    \  - Expedient Joins and Leaves\n     - Sends without a Join\n"
- title: 2.1.1 Expedient Joins and Leaves
  contents:
  - "2.1.1 Expedient Joins and Leaves\n   Some applications require expedient group\
    \ joins and leaves, as their\n   usability or functionality are sensitive to the\
    \ latency involved with\n   joining and leaving a group.\n      Join Latency:\
    \ The time it takes for data to begin flowing after an\n      application issues\
    \ a command to join a multicast group\n      Leave Latency: The time it takes\
    \ for data to stop flowing after an\n      application issues a command to leave\
    \ a multicast group\n      [IGMPv2,IGMPv3]\n   For example, using distributed\
    \ a/v as a multicast-based \"television\"\n   must allow users to \"channel surf\"\
    --changing channels frequently.\n   Each channel change generates a group leave\
    \ and group join, so delays\n   in either will affect usability.  In a sense,\
    \ this is more of a user\n   requirement than an application requirement.\n  \
    \ The functionality of distributed interactive simulations [DIS] is\n   often\
    \ sensitive to join/leave latency.  This is particularly true\n   when trying\
    \ to exchange information to represent fast moving objects\n   that quickly enter\
    \ and exit the scope of a simulated environment\n   (e.g., low-flying, fast-moving\
    \ aircraft).  If the join latency is too\n   long, the information provided may\
    \ be old by the time it is received.\n   A fast leave phase is highly desirable\
    \ both for effective congestion\n   control mechanisms, to stop undesirable flows\
    \ quickly, and for the\n   network in general, to better filter unwanted traffic\
    \ [Rizzo].\n   Applications cannot affect control over either join or leave latency,\n\
    \   but are dependent on the multicast infrastructure to enable expedient\n  \
    \ operations.  This is a basic multicast service requirement.\n"
- title: 2.1.2 Sends without a Join
  contents:
  - "2.1.2 Sends without a Join\n   Applications that send to a multicast address\
    \ should be able to start\n   sending immediately, without having to join the\
    \ destination group\n   first.  This is important for embedded devices and bursty-source\n\
    \   applications with low-delay delivery requirements.\n   The current IGMP-based\
    \ multicast host model and all current\n   implementations allow senders to send\
    \ to a group without joining it\n   as a standard feature.\n"
- title: 3. IP Multicast Application Taxonomy
  contents:
  - "3. IP Multicast Application Taxonomy\n   With an IP multicast-enabled network\
    \ available, some unique and\n   powerful applications and application services\
    \ are possible.\n   \"Multicast enables coordination - it is well suited to loosely\n\
    \   coupled distributed systems (of people, servers, databases,\n   processes,\
    \ devices...)\" [Estrin].\n   A \"multicast application\" is simply defined as\
    \ any application that\n   sends to and/or receives from an IP multicast address.\
    \  These may or\n   may not also reference IP unicast addresses, as we describe\
    \ later.\n   What differentiates IP multicast applications from one-to-one unicast\n\
    \   applications are the other sender and receiver relationships\n   multicast\
    \ enables.  There are three general categories of multicast\n   applications:\n\
    \      One-to-Many (1toM): A single host sending to two or more (n)\n      receivers\n\
    \      Many-to-Many (MtoM): Any number of hosts sending to the same\n      multicast\
    \ group address, as well as receiving from it\n      Many-to-One (Mto1): Any number\
    \ of receivers sending data back to a\n      (source) sender via unicast or multicast\n\
    \                            +-----------------------------------+\n         \
    \                   |        Host 2->n (\"many\")         |\n                \
    \            +-------------+---------------------+\n                         \
    \   |   One-Way   |       Two-Way       |\n                            +-------------+---------------------|\n\
    \                            |  A      B   |   C      D      E   |\n         \
    \       +-----------+-------------+---------------------+\n                | \
    \   I/O    |             |  S(m)/  S(u)/  S(m)/|\n                | Operations|\
    \ S(m)   R(m) |  R(m)   R(m)   R(u) |\n    +-------+---+-----------+-------------+---------------------|\n\
    \    |       | 1 | S(m)      |        1toM |  MtoM               |\n    | Host\
    \  | 2 | R(m)      | Mto1        |  MtoM               |\n    |       +---+-----------+-------------+\
    \                     |\n    |  1    | 3 | S(m)/R(m) | Mto1   1toM    MtoM   \
    \            |\n    |       | 4 | S(m)/R(u) |                       Mto1     \
    \   |\n    |(\"one\")| 5 | S(u)/R(m) |                              Mto1 |\n \
    \   +-------+---+-----------+-----------------------------------+\n          Legend:\
    \    S: \"Send\"          (u): \"unicast\"\n          ------     R: \"Receive\"\
    \       (m): \"multicast\"\n   Table 1: Application types characterized by I/O\
    \ relationships\n            and destination address types (multicast or unicast)\n\
    \   Table 1 defines these application types in terms of the I/O\n   relationships\
    \ they represent.  These categories are defined in terms\n   of the combination\
    \ of communication mechanisms they use.  At the IP\n   level, all multicast I/O\
    \ is only 1toM or MtoM and unicast is always\n   one-to-one (1to1).  The Mto1\
    \ category, for example, refers to several\n   possible combinations of IP-level\
    \ relationships, including unicast.\n   We created the Mto1 category to help differentiate\
    \ between the many\n   applications and services that use multicast.\n       \
    \          1toM:           MtoM:            Mto1:\n                  R1      \
    \       S1/R1             S1\n                 /               / | \\        \
    \       \\\n                S-R2         S2/R2-+-S3/R3         S2-R\n        \
    \         \\...            \\ | /            .../\n                  Rn      \
    \       Sn/Rn             Sn\n                Legend:  S: \"Sender\"\n       \
    \         ------   R: \"Receiver\"\n      Figure 1: Generalization of the three\
    \ application categories\n   Figure 1 illustrates the general model for each of\
    \ the three\n   multicast application categories.  Again it is worth emphasizing\
    \ that\n   Mto1 is an artificial category defined by the application-level\n \
    \  relationship between sender(s) and receiver.  At the IP-level,\n   multicast\
    \ does not provide an Mto1 I/O mechanism, since it does not\n   allow senders\
    \ to limit receivers, nor even know who they are.\n   Receiver information and\
    \ limitations are enabled at the application\n   level, as required by the multicast\
    \ application.\n   We describe each of these general application types in more\
    \ detail\n   and provide application examples of each in the sub-sections below.\n\
    \   The list of examples is not comprehensive, but attempts to define the\n  \
    \ prominent multicast application and service types in each of the\n   three general\
    \ categories.  We reference the items in these lists in\n   the remainder of this\
    \ document as we describe their specific service\n   requirements, define the\
    \ challenges they present, and reference\n   solutions available or under development.\n"
- title: 3.1 One-to-Many Applications
  contents:
  - "3.1 One-to-Many Applications\n   One-to-Many (1toM) applications have a single\
    \ sender, and multiple\n   simultaneous receivers.  Entry B1 in Table 1 represents\
    \ the classic\n   1toM relationship.  Entry B3 differs only slightly, as the sender\n\
    \   also acts as receiver (i.e., it has loopback enabled).\n   When people think\
    \ of multicast, they most often think of broadcast-\n   based multimedia applications:\
    \ television (video) and radio (audio).\n   This is a reasonable analogy and indeed\
    \ these are significant\n   multicast applications, but these are far from the\
    \ extent of\n   applications that multicast can enable.  Audio/Video distribution\n\
    \   represents a fraction of the multicast application possibilities, and\n  \
    \ most do not have analogs in today's consumer broadcast industry.\n      a) Scheduled\
    \ audio/video (a/v) distribution: Lectures,\n         presentations, meetings,\
    \ or any other type of scheduled event\n         whose multimedia coverage could\
    \ benefit an audience (i.e.\n         television and radio \"broadcasts\").  One\
    \ or more constant-bit-\n         rate (CBR) datastreams and relatively high-bandwidth\
    \ demands\n         characterize these applications.  When more than one datastream\n\
    \         is present--as with an audio/video combination--the two are\n      \
    \   synchronized and one typically has a higher priority than the\n         other(s).\
    \  For example, in an a/v combination it is more\n         important to ensure\
    \ an intelligible audio stream, than perfect\n         video.\n      b) Push media:\
    \ News headlines, weather updates, sports scores, or\n         other types of\
    \ non-essential dynamic information.  \"Drip-feed\",\n         relatively low-bandwidth\
    \ data characterize these applications.\n      c) File Distribution and Caching:\
    \ Web site content, executable\n         binaries, and other file-based updates\
    \ sent to distributed\n         end-user or replication/caching sites\n      d)\
    \ Announcements: Network time, multicast session schedules,\n         random numbers,\
    \ keys, configuration updates, (scoped) network\n         locality beacons, or\
    \ other types of information that are\n         commonly useful.  Their bandwidth\
    \ demands can vary, but\n         generally they are very low bandwidth.\n   \
    \   e) Monitoring: Stock prices, Sensor equipment (seismic activity,\n       \
    \  telemetry, meteorological or oceanic readings), security\n         systems,\
    \ manufacturing or other types of real-time information.\n         Bandwidth demands\
    \ vary with sample frequency and resolution,\n         and may be either constant-bit-rate\
    \ or bursty (if event-\n         driven).\n"
- title: 3.2 Many-to-Many Applications
  contents:
  - "3.2 Many-to-Many Applications\n   In many-to-Many (MtoM) applications two or\
    \ more of the receivers also\n   act as senders.  In other words, MtoM applications\
    \ are characterized\n   by two-way multicast communications.\n   The many-to-many\
    \ capabilities of IP multicast enable the most unique\n   and powerful applications.\
    \  Each host running an MtoM application may\n   receive data from multiple senders\
    \ while it also sends data to all of\n   them.  As a result, many-to-many applications\
    \ often present complex\n   coordination and management challenges.\n      f)\
    \ Multimedia Conferencing: Audio/Video and whiteboard comprise\n         the classic\
    \ conference application.  Having multiple\n         datastreams with different\
    \ priorities characterizes this type\n         of application.  Co-ordination\
    \ issues--such as determining who\n         gets to talk when--complicate their\
    \ development and usability.\n         There are common heuristics and \"rules\
    \ of play\", but no\n         standards exist for managing conference group dynamics.\n\
    \      g) Synchronized Resources: Shared distributed databases of any\n      \
    \   type (schedules, directories, as well as traditional\n         Information\
    \ System databases).\n      h) Concurrent Processing: Distributed parallel processing.\n\
    \      i) Collaboration: Shared document editing.\n      j) Distance Learning:\
    \ This is a one-to-many a/v distribution\n         application with \"upstream\"\
    \ capability that allows receivers to\n         question the speaker(s).\n   \
    \   k) Chat Groups: These are like text-based conferences, but may\n         also\
    \ provide simulated representations (\"avatars\") for each\n         \"speaker\"\
    \ in simulated environments.\n      l) Distributed Interactive Simulations [DIS]:\
    \ Each object in a\n         simulation multicasts descriptive information (e.g.,\
    \ telemetry)\n         so all other objects can render the object, and interact\
    \ as\n         necessary.  The bandwidth demands for these can be tremendous,\n\
    \         as the number of objects and the resolution of descriptive\n       \
    \  information increases.\n      m) Multi-player Games: Many multi-player games\
    \ are simply\n         distributed interactive simulations, and may include chat\
    \ group\n         capabilities.  Bandwidth usage can vary widely, although\n \
    \        today's first-generation multi-player games attempt to minimize\n   \
    \      bandwidth usage to increase the target audience (many of whom\n       \
    \  still use dial-up modems).\n      n) Jam Sessions: Shared encoded audio (e.g.,\
    \ music).  The\n         bandwidth demands vary based on the encoding technique,\
    \ sample\n         rate, sample resolution, number of channels, etc.\n"
- title: 3.3 Many-to-One Applications
  contents:
  - "3.3 Many-to-One Applications\n   Unlike the one-to-many and many-to-many application\
    \ categories, the\n   many-to-one (Mto1) category does not represent a communications\n\
    \   mechanism at the IP layer.  Mto1 applications have multiple senders\n   and\
    \ one (or a few) receiver(s), as defined by the application layer.\n   Table 1\
    \ shows that Mto1 applications can be one-way or use a two-way\n   request/response\
    \ type protocol, where either senders or receiver(s)\n   may generate the request.\
    \  Figure 2 characterizes the I/O\n   relationship possibilities in Mto1 applications:\n\
    \   Mto1 applications have many scaling issues.  Too many simultaneous\n   senders\
    \ can potentially overwhelm receiver(s), a condition\n   characterized as an \"\
    implosion problem\".   Another considerable\n   scaling problem is the large amount\
    \ of state in the network that\n   having many multicast senders generates.  This\
    \ is largely transparent\n   to applications and the effect may be diminished\
    \ in the future with\n   the use of bi-directional trees in multicast routing\
    \ protocols, but\n   nonetheless it should be considered by application designers.\n\
    \   1)  S1        2)  S1            3)  S1           4)  S1\n         \\     \
    \        \\                 \\                \\\n       S2-R          S2-R  \
    \            S2-R             S2-R\n      .../          .../              .../\
    \             .../\n       Sn            Sn                Sn               Sn\n\
    \      Data(m)     Request(m)       Request(m)       Request(u)\n      ------>\
    \     ---------->     <----------       ---------->\n                  Response(u)\
    \      Response(u)      Response(m)\n                 <-----------      ----------->\
    \    <----------\n       Figure 2: Characterization of Mto1 I/O possibilities\n\
    \   No standards yet exist for alternate and equivalent Mto1 application\n   designs,\
    \ but there are a number of possibilities to consider [HNRS].\n   Since the main\
    \ advantage of using multicast in a Mto1 application is\n   that senders need\
    \ not know the receiver(s) unicast address(es), one\n   alternative is for each\
    \ receiver to advertise its unicast address via\n   multicast.  However, since\
    \ this strategy still leaves the potential\n   for implosion on each receiver,\
    \ additional strategies may be needed\n   to distribute the load.  For example,\
    \ it may be possible to increase\n   the number of receivers (in a \"flat\" receiver\
    \ topology) or establish\n   localized receivers (in a \"hierarchical\" topology)\
    \ as used in \"local\n   recovery\" (section 5.3).  Such methods have coordination\
    \ issues, and\n   since standard solutions have not yet been identified, Mto1\n\
    \   application developers should consider their alternatives carefully.\n   \
    \   o) Resource Discovery: Service Location, for example, leverages IP\n     \
    \    Multicast to enable something like a \"host anycasting service\"\n      \
    \   capability [AnyCast]: A multicast receiver to send a query to a\n        \
    \ group address, to elicit responses from the closest host so\n         they can\
    \ satisfy the request.  The responses might also contain\n         information\
    \ that allows the receiver to determine the most\n         appropriate (e.g.,\
    \ closest) service provider to use.\n            In Table 1, this application\
    \ is entry D4.  It is also\n            illustrated in Figure 2 by possibility\
    \ number 3.\n            Alternately, the response could be to a multicast rather\n\
    \            than unicast address, although technically that would make\n    \
    \        it an MtoM application type (this is how the Service\n            Location\
    \ Protocol [SLP] operates, when a user agent attempts\n            to locate a\
    \ directory agent).\n      p) Data Collection: This is the converse of a one-to-many\n\
    \         \"monitoring\" application described earlier.  In this case there\n\
    \         may be any number of distributed \"sensors\" that send data to a\n \
    \        data collection host.  The sensors might send updates in\n         response\
    \ to a request from the data collector, or send\n         continuously at regular\
    \ intervals, or send spontaneously when a\n         pre-defined event occurs.\
    \  Bandwidth demands can vary based on\n         sample frequency and resolution.\n\
    \         This is illustrated in Table 1 by entries A1 and A3, the only\n    \
    \     difference being that A3 has a loopback interface.  In Figure\n        \
    \ 2, this is possibility number 1.  Since the number of receivers\n         can\
    \ easily be more than one, this is really an MtoM\n         application.\n   \
    \   q) Auctions: The \"auctioneer\" starts the bidding by describing\n       \
    \  whatever it is for sale (product or service or whatever), and\n         receivers\
    \ send their bids privately or publicly (i.e., to a\n         unicast or multicast\
    \ address).\n         This is possibility number 2 in Figure 2, and D5 in Table\
    \ 1.\n         The response could be sent to a multicast address, although\n \
    \        technically that would make it an MtoM application.\n      r) Polling:\
    \ The \"pollster\" sends out a question, and the \"pollees\"\n         respond\
    \ with answers.  This is possibility number 2 in Figure\n         2, and could\
    \ also be characterized as an MtoM application if\n         the response is to\
    \ a multicast address.\n      s) Jukebox: Allows near-on-demand a/v playback.\
    \  Receivers use an\n         \"out-of-band\" protocol mechanism (via web, email,\
    \ unicast or\n         multicast requests, etc.) to send their playback request\
    \ into a\n         scheduling queue [IMJ].\n         This is characterized by\
    \ possibility number 4 in Figure 2, and\n         entry D4 in Table 1.  The initial\
    \ unicast request is the only\n         difference between this type of application\
    \ and a typical 1toM.\n         If that initial request were sent to a multicast\
    \ address, this\n         would effectively be an MtoM application.\n      t)\
    \ Accounting: This is basically data collection but is worth\n         separating\
    \ since it is such an important application.  In some\n         multicast applications\
    \ it is imperative to know information\n         about each receiver, possibly\
    \ in real-time.  But such\n         information can be overwhelming [MRM].  Current\
    \ mechanisms,\n         like RTCP (which is actually MtoM since it is multicast\
    \ but\n         could be made Mto1), use scaling techniques but trade-off\n  \
    \       information granularity.  As a group grows the total amount of\n     \
    \    feedback is constant but each receiver sends less.\n"
- title: 4. Common Multicast Service Requirements
  contents:
  - "4. Common Multicast Service Requirements\n   Some multicast application service\
    \ requirements are common to unicast\n   network applications as well.  We characterize\
    \ two of them here--\n   bandwidth and delay requirements.\n"
- title: 4.1 Bandwidth Requirements
  contents:
  - "4.1 Bandwidth Requirements\n   Figure 3 shows multicast applications approximate\
    \ bandwidth\n   requirements.\n   Unicast and multicast applications both need\
    \ to design applications\n   to adapt to the variability of network conditions.\
    \  But as we\n   describe in section 5.3, it is the need to accommodate multiple\n\
    \   heterogeneous multicast receivers--with their diversity of bandwidth\n   capacity\
    \ and delivery delays--that presents the unique challenge for\n   multicast applications\
    \ to satisfy these requirements.\n          |\n     1toM |     b, d          c,\
    \ e               a\n          |\n     MtoM |       k           g, i        f,\
    \ h, j, l, m, n\n          |\n     Mto1 |   o, q, r         p, t             \
    \  s\n          |\n          +-----------------------------------------------\n\
    \            Low Bandwidth                  High Bandwidth\n           Figure\
    \ 3: Bandwidth Requirements of applications\n"
- title: 4.2 Delay Requirements
  contents:
  - "4.2 Delay Requirements\n   Aside from those with time-sensitive data (e.g., stock\
    \ prices, and\n   real-time monitoring information), most one-to-many applications\
    \ have\n   a high tolerance for delay and delay variance (jitter).  Constant\n\
    \   bit-rate (CBR) data--such as streaming media (audio/video)--are\n   sensitive\
    \ to jitter, but applications commonly counteract the effects\n   by buffering\
    \ data and delaying playback.\n   Most many-to-one and many-to-many multicast\
    \ applications are\n   intolerant of delays because they are bidirectional, interactive\
    \ and\n   request/response dependent.  As a result, delays should be minimized,\n\
    \   since they can adversely affect the application's usability.\n   This need\
    \ to minimize delays is most evident in (two-way) conference\n   applications,\
    \ where users cannot converse effectively if the audio or\n   video is delayed\
    \ more than 500 milliseconds.  For this and other\n   examples see Figure 4, which\
    \ plots multicast applications on a\n   (coarse) scale of sensitivity to delivery\
    \ delays.\n          |\n     1toM |     b, c         a, d                e\n \
    \         |\n     MtoM |               g, i, j, k       f, h, l, m, n\n      \
    \    |\n     Mto1 |      r        o, p, s, t             q\n          |\n    \
    \      +-----------------------------------------------\n            Delay Tolerant\
    \                Delay Intolerant\n           Figure 4: Delay tolerance of application\
    \ types\n   For delay-intolerant multicast (or unicast) applications, quality\
    \ of\n   service (QoS) is the only option.  IP networks currently provide only\n\
    \   \"best effort\" delivery, so data are subject to variable router\n   queuing\
    \ delays and loss due to network congestion (router queue\n   overflows).  IP\
    \ QoS standards do exist now [RSVP] and efforts to\n   enable end-to-end QoS support\
    \ in the Internet are underway [E2EQOS].\n   However, QoS support is an IP network\
    \ infrastructure consideration.\n   Although there are multicast-specific challenges\
    \ for implementing QoS\n   in the network for multicast flows, they are beyond\
    \ the control of\n   applications, so further discussion of the QoS protocols\
    \ and services\n   is beyond the scope of this document.\n"
- title: 5. Unique Multicast Service Requirements
  contents:
  - "5. Unique Multicast Service Requirements\n   The three application categories\
    \ described earlier are very general\n   in nature.  Within each category and\
    \ even among each of the\n   application types, specific application instances\
    \ have a variety of\n   application requirements.  One-to-many application types\
    \ are\n   relatively simple to develop, but as we pointed out there are\n   challenges\
    \ involved with developing many-to-one and many-to-many\n   applications.  Some\
    \ of these have requirements bandwidth and delay\n   requirements, similar to\
    \ unicast applications.\n   Multicast applications can be further differentiated\
    \ from unicast\n   applications and from each other by the services they require.\
    \  In\n   this section we provide a survey of the various services that have\n\
    \   unique requirements for multicast applications.\n    +--------------------------------------------------------------+\n\
    \    |                  Multicast Application                       |\n    +--------------------------------------+\
    \   +-------------------+\n    +-------------------------------------+|   |+--------++--------+\n\
    \    |          Multicast Security         ||   ||        ||        |\n    +----------------------+\
    \   +----------+|   || System ||        |\n    +----------++---------+|   |+---------+|\
    \   ||  Time  || Codecs |\n    | Reliable || Address ||   || Session ||   || \
    \       ||        |\n    | Delivery ||   Mgt   ||   ||   Mgt   ||   ||       \
    \ ||        |\n    +----------++---------++---++---------++---++--------++--------+\n\
    \    +----------------------------------------++--------------------+\n    | \
    \    Basic IP Multicast Service         ||     IP Unicast     |\n    |       (e.g.,\
    \ UDP and IGMPv2/v3)        ||      Service       |\n    +----------------------------------------++--------------------+\n\
    \            Figure 5: Multicast service requirements summary\n   Here's the list\
    \ of multicast application service requirements:\n      Address Management - Selection\
    \ and coordinated of address\n      allocation.  The need is to provide assurances\
    \ against \"address\n      collision\" and to provide address ownership.\n   \
    \   Session Management - Perform application-layer services on top of\n      multicast\
    \ transport.  These services depend heavily on the\n      application but include\
    \ functions like session advertisement,\n      billing, group member monitoring,\
    \ key distribution, etc.\n      Heterogeneous Receiver Support - Sending to receivers\
    \ with a wide\n      variety of bandwidth capacities, latency characteristics,\
    \ and\n      network congestion requires feedback to monitor receiver\n      performance.\n\
    \      Reliable Data Delivery - Ensuring that all data sent is received\n    \
    \  by all receivers.\n      Security - Ensuring content privacy among dynamic\
    \ multicast group\n      memberships, and limiting senders.\n      Synchronized\
    \ Play-Out - Allow multiple receivers to \"replay\" data\n      received in synchronized\
    \ fashion.\n   In the remainder of this section, we describe each of these\n \
    \  application services in more detail, the challenges they present, and\n   the\
    \ status of standardized solutions.\n"
- title: 5.1 Address Management
  contents:
  - "5.1 Address Management\n   One of the first questions facing a multicast application\
    \ developer\n   is what multicast address to use.  Multicast addresses are not\n\
    \   assigned to individual hosts, assignments can change dynamically, and\n  \
    \ addresses sometimes have semantics of their own (e.g., Admin\n   Scoping). \
    \ Multicast applications require an address management\n   service that provides\
    \ address allocation or assignment queries.\n   There are a number of ways for\
    \ applications to learn about multicast\n   addresses:\n      Hard-Coded: Software\
    \ configuration, encoded in a binary\n      executable, or burned into ROM in\
    \ embedded devices.  These\n      applications typically reference IANA statically\
    \ allocated\n      multicast addresses (including relative addresses).\n     \
    \ Advertised: Session announcements (as described in the next\n      section),\
    \ or via another \"out-of-band\" query or discovery protocol\n      mechanism.\n\
    \      Algorithmically Derived: Using a programmatic algorithm to\n      allocate\
    \ a statistically random (unused) address.\n        |\n   1toM |    c, e     \
    \     a, b                d\n        |\n   MtoM |               f, j, k, n   \
    \     g, h, i, l, m\n        |\n   Mto1 |    r            o, p, s            \
    \ q, t\n        |\n        +-----------------------------------------------\n\
    \          Hard-Coded       Advertised      Algorithmic\n      Figure 6: Multicast\
    \ address usage for application types\n   In almost all cases, application designers\
    \ should assume that\n   multicast addresses are to be dynamic.  Very little of\
    \ the multicast\n   address space is available for static assignment by IANA [MADDR].\n\
    \   Also, given the host-specific addressing available with SSM,\n   Internet-wide,\
    \ static address assignment is expected to be very rare.\n"
- title: 5.2 Session Management
  contents:
  - "5.2 Session Management\n   Session management is one of the most misunderstood\
    \ services with\n   respect to multicast.  Most application developers assume\
    \ that\n   multicast will provide services like security, encryption,\n   reliability,\
    \ session advertisement, monitoring, billing, etc.  In\n   fact, multicast is\
    \ simply a transport mechanism that provides end-\n   to-end delivery.  All of\
    \ the other services are application-layer\n   services that must be provided\
    \ by each particular application.\n   Furthermore, in most cases there are not\
    \ defined standards for how\n   these functions should be provided.  The particular\
    \ functions are\n   dependent on the particular needs of the application, and\
    \ no single\n   method (or standard) can be made to be sufficient for all cases.\n\
    \   While there are no generic solutions which provide all session\n   management\
    \ functions, there are some protocols and common techniques\n   that provide support\
    \ for some of the functions.  Techniques for\n   congestion control and heterogeneous\
    \ receiver support are discussed\n   in Section 5.3.  Protocols for reliability\
    \ are discussed in Section\n   5.4.  Security considerations are discussed in\
    \ Section 5.5.\n   With respect to session advertisement, there are a number of\n\
    \   mechanisms for advertising sessions.  One commonly used technique is\n   to\
    \ advertise sessions via the WWW.  Users can join a group by\n   clicking on URLs,\
    \ and then having a response returned to the user\n   that includes the group\
    \ address and maybe information about group\n   source(s).  Another mechanism\
    \ is the session description protocol\n   [SDP].  It provides a format for representing\
    \ information about\n   sessions, but it does not provide the transport for dissemination\
    \ of\n   these session descriptions, nor does it provide address allocation\n\
    \   and management.  SDP only provides the syntax for describing session\n   attributes.\n\
    \   SDP session descriptions may be conveyed publicly or privately by\n   means\
    \ of any number of transports including web (HTTP) and MIME\n   encoded email.\
    \  The session announcement protocol [SAP] is the de\n   facto standard transport\
    \ and many multicast-enabled applications\n   currently use it.  SAP limits distribution\
    \ via multicast scoping, but\n   the current protocol definition has scaling issues\
    \ that need to be\n   addressed.  Specifically, the initialization latency for\
    \ a session\n   directory can be quite long, and it increases in proportion to\
    \ the\n   number of session announcements.  This is to an extent a multicast\n\
    \   infrastructure issue, however, as this level of protocol detail\n   should\
    \ be transparent to applications.\n   The session management service needs to:\n\
    \     - Advertise scheduled sessions\n     - Provide a query mechanism for retrieving\n\
    \       information about session schedules\n"
- title: 5.3 Heterogeneous Receiver Support
  contents:
  - "5.3 Heterogeneous Receiver Support\n   The Internet is a network of networks.\
    \  IP's strength is its ability\n   to enable seamless interoperability between\
    \ hosts on disparate\n   network media, the heterogeneous network.\n   When two\
    \ hosts communicate via unicast--one-to-one--across an IP\n   network, it is relatively\
    \ easy for senders to adapt to varying\n   network conditions.  The Transmission\
    \ Control Protocol (TCP) provides\n   reliable data transport, and is the model\
    \ of \"network friendly\"\n   adaptability.\n   TCP receivers send acknowledgements\
    \ back to the sender for data\n   delivered.  A TCP sender detects data loss from\
    \ the data sent that is\n   not acknowledged.  When it detects data loss, TCP\
    \ infers that there\n   is network congestion or a low-bandwidth link, and adapts\
    \ by\n   throttling down its send rate [SlowStart].\n   User Datagram Protocol\
    \ (UDP) does not enable a receiver feedback loop\n   the way TCP does, since UDP\
    \ does not provide reliable data delivery\n   service.  As a result, it also does\
    \ not have a loss detection and\n   adaptive congestion control mechanism as TCP\
    \ does.  However, it is\n   possible for a unicast UDP application to enable similar\
    \ adaptive\n   algorithms to achieve the same result, or even improve on it.\n\
    \   A unicast UDP application that uses a feedback mechanism to detect\n   data\
    \ loss and adapt the send rate, can do so better than TCP.  TCP\n   automatically\
    \ reduces the \"congestion window\" when data loss is\n   detected, although the\
    \ updated send rate may be slower than a CBR\n   audio/video stream requires.\
    \  When a UDP application detects loss, it\n   can adapt the data itself to accommodate\
    \ the lower send rate.  For\n   example, a UDP application can:\n     -  Reduce\
    \ the data resolution (e.g., send lower fidelity\n        audio/video by reducing\
    \ sample frequency or frame rate) to\n        reduce data rate.\n     -  Modify\
    \ the data encoding to add redundant data (e.g., forward\n        error correction)\
    \ offset in time to avoid fate sharing.  This\n        could also be \"layered\"\
    , so a percentage of data loss will\n        simply reduce fidelity rather than\
    \ corrupt the data.\n     -  Reduce the send rate of one datastream in order to\
    \ favor another\n        of higher priority (e.g., sacrifice video in order to\
    \ ensure\n        audio delivery).\n     -  Send data at a lower rate (i.e., with\
    \ a different encoding) on a\n        separate multicast address and/or port number\
    \ for high-loss\n        receivers.\n   However, with multicast applications--one-to-many\
    \ or many-to-many--\n   which have multiple receivers, the feedback loop design\
    \ needs\n   modification.  If all receivers return data loss reports\n   simultaneously,\
    \ the sender is easily overwhelmed in the storm of\n   replies.  This is known\
    \ as the \"implosion problem\".\n   Another problem is that heterogeneous receiver\
    \ capabilities can vary\n   widely due to the wide range of (static) network media\
    \ bandwidth\n   capabilities and dynamically due to transient traffic conditions.\
    \  If\n   a sender adapts its send rate and data resolution based on the loss\n\
    \   rate of its worst receiver(s), then it can only service the lowest\n   common\
    \ denominator.  Hence, a single \"crying baby\" can spoil it for\n   all other\
    \ receivers.\n   Strategies exist for dealing with these heterogeneous receiver\n\
    \   problems.  Here are two examples:\n     Shared Learning - When loss is detected\
    \ (i.e., a sequenced packet\n        isn't received), a receiver starts a random\
    \ timer.  If it\n        receives a data loss report sent by another receiver\
    \ as it waits\n        for the timer to expire, it stops the timer and does not\
    \ send a\n        report.  Otherwise, it sends a report when the timer expires.\n\
    \        The Real-Time Protocol and its feedback-loop counterpart Real-\n    \
    \    Time Control Protocol [RTP/RTCP] employ a strategy similar to\n        this\
    \ to keep feedback traffic to 5 percent or less than the\n        overall session\
    \ traffic.  This technique was originally utilized\n        in IGMP.\n     Local\
    \ Recovery - Some receivers may be designated as local\n        distribution points\
    \ or \"transcoders\" that either re-send data\n        locally (possibly via unicast)\
    \ when loss is reported or they re-\n        encode the data for lower bandwidth\
    \ receivers before re-sending.\n        No standards exist for these strategies,\
    \ although \"local\n        recovery\" is used by several reliable multicast protocols.\n\
    \   Adaptive multicast application design for heterogeneous receivers is\n   still\
    \ an active area of research.  The fundamental requirements are\n   to maximize\
    \ application usability, while accommodating network\n   conditions in a \"network\
    \ friendly\" manner.  In other words,\n   congestion detection and avoidance are\
    \ (at least) as important in\n   protocol design as the user experience.  The\
    \ adaptive mechanisms must\n   also be stable, so they do not adapt too quickly--changing\
    \ encoding\n   and rates based on too little information about what may be a\n\
    \   transient condition--to avoid oscillation.\n   This \"feedback loop\" service\
    \ necessary for support of heterogeneous\n   receivers is not illustrated in the\
    \ services summary in Figure 4,\n   although it could be added alongside \"Reliable\
    \ Transport\" and the\n   others.  This service could be implemented within an\
    \ application or\n   accessed externally, as provided by the operating system\
    \ or a third\n   party.  See [HNRS] for a taxonomy of strategies for providing\n\
    \   feedback for multicast, with the ultimate goal of developing a common\n  \
    \ multicast feedback protocol.\n"
- title: 5.4 Reliable Data Delivery
  contents:
  - "5.4 Reliable Data Delivery\n   Many of the multicast application examples in\
    \ our list--like\n   audio/video distribution--have loss-tolerant data content.\
    \  In other\n   words, the data content itself can remain useful even if some\
    \ of it\n   is lost.  For example, audio might have a short gap or lower fidelity\n\
    \   but will remain intelligible despite some data loss.\n   Other application\
    \ examples--like caching and synchronized resources-\n   -require reliable data\
    \ delivery.  They deliver content that must be\n   complete, unchanged, in sequence,\
    \ and without duplicates.  The \"Loss\n   Intolerant\" column in Figure 7 shows\
    \ a list of applications with this\n   requirement, while the others can tolerate\
    \ varying levels of data\n   loss.  The tolerance levels are typically determined\
    \ by the nature of\n   the data and the encoding in use.\n        |\n   1toM |\
    \     b             a, d               c, e\n        |\n   MtoM |            \
    \ f, j, k, l, m, n       g, h, i\n        |\n   Mto1 |                o, p, r,\
    \ s, t          q\n        |\n        +------------------------------------------------\n\
    \          Loss Tolerant                   Loss Intolerant\n      Figure 7: Reliability\
    \ Requirements of Application types\n   Some of the challenges involved with enabling\
    \ reliable multicast\n   transport are the same as those of sending to heterogeneous\n\
    \   receivers, and some solutions are similar also.  For example, many\n   reliable\
    \ multicast transport protocols avoid the implosion problem by\n   using negative\
    \ acknowledgements (NAKs) from receivers to indicate\n   what was lost.  They\
    \ also use \"shared learning\" whereby receivers\n   listen to others' NAKs and\
    \ then listen for the resulting\n   retransmission of data, rather than requesting\
    \ retransmission by\n   sending a NAK themselves.\n   Although reliable delivery\
    \ cannot change the data sent--except,\n   perhaps, to use a loss-less data compression\
    \ algorithm--they can use\n   other adaptive techniques like sending redundant\
    \ data, or adjusting\n   the send rate.\n   Although many reliable multicast protocol\
    \ implementations exist\n   [Obraczka], and a few are already available in commercial\
    \ products,\n   none of them are standardized.  Work is ongoing in the \"Reliable\n\
    \   Multicast\" research group of the Internet Research Task Force [IRTF]\n  \
    \ to provide a better definition of the problem, the multicast\n   transport requirements,\
    \ and protocol mechanisms.\n   Scalability is the paramount concern, and it implies\
    \ the general need\n   for \"network friendly\" protocols that detect and avoid\
    \ congestion as\n   they provide reliable delivery.  Other considerations are\
    \ protocol\n   robustness, support for \"late joins\", group management and security\n\
    \   (which we discuss next).\n   The current consensus is that due to the wide\
    \ variety of multicast\n   application requirements--some of which are at odds--no\
    \ single\n   multicast transport will likely be appropriate for all applications.\n\
    \   As a result, most believe that we will eventually standardize a\n   number\
    \ of reliable multicast protocols, rather than a single one\n   [BULK, RMT].\n"
- title: 5.5 Security
  contents:
  - "5.5 Security\n   For any IP network application--unicast or multicast--security\
    \ is\n   necessary because networks comprise users with different levels of\n\
    \   trust.\n   Network application security is challenging, even for unicast.\
    \  And\n   as the need for security increases--gauged by the risks of being\n\
    \   without it--the challenges increase also.  Security system complexity\n  \
    \ and overhead is commensurate with the protection it provides.  \"No\n   one\
    \ can guarantee 100% security.  But we can work toward 100% risk\n   acceptance...Strong\
    \ cryptography can withstand targeted attacks up to\n   a point--the point at\
    \ which it becomes easier to get the information\n   some other way...A good design\
    \ starts with a threat model: what the\n   system is designed to protect, from\
    \ whom, and for how long.\"\n   [Schneier]\n   Multicast applications are no different\
    \ than unicast applications\n   with respect to their need for security, and they\
    \ require the same\n   basic security services: user authentication, data integrity,\
    \ data\n   privacy and user privacy (anonymity).  However, enabling security for\n\
    \   multicast applications is even more of a challenge than for unicast.\n   Having\
    \ multiple receivers makes a difference, as does their\n   heterogeneity and the\
    \ dynamic nature of multicast group memberships.\n   Multicast security requirements\
    \ can include any combination of the\n   following services:\n      Limiting Senders\
    \   - Controlling who can send to group addresses\n      Limiting Receivers -\
    \ Controlling who can receive\n      Limiting Access    - Controlling who can\
    \ \"read\" multicast content\n      either by encrypting content or limiting receivers\
    \ (which isn't\n      possible yet)\n      Verifying Content  - Ensuring that\
    \ data originated from an\n      authenticated sender and was not altered en route\n\
    \      Protecting Receiver Privacy - Controlling whether sender(s) or\n      other\
    \ receivers know receiver identity\n      Firewall Traversal - Proxying outgoing\
    \ \"join\" requests through\n      firewalls, allowing incoming or outgoing traffic\
    \ through, and\n      (possibly) authenticating receivers for filtering purposes\
    \ and\n      security [Finlayson].\n   This list is not comprehensive, but includes\
    \ the most commonly needed\n   security services.  Different multicast applications\
    \ and different\n   application contexts can have very different needs with respect\
    \ to\n   these services, and others.  Two main issues emerge, where the\n   performance\
    \ of current solutions leaves much to be desired [MSec].\n      Individual authentication\
    \ - how is sender identity verified for\n      each multicast datagram received?\n\
    \      Membership revocation - how is further group access disabled for\n    \
    \  group members that leave the group (e.g., encryption keys in their\n      possession\
    \ disabled)?\n   Performance is largely a factor when a user joins or leaves a\
    \ group.\n   For example, methods used to authenticate potential group members\n\
    \   during joins or re-keying current members after a member leaves can\n   involve\
    \ significant processing and protocol overhead and result in\n   significant delays\
    \ that affect usability.\n   Like reliable multicast, secure multicast is also\
    \ under investigation\n   in the Internet Research Task Force [IRTF].  Protocol\
    \ mechanisms for\n   many of the most important of these services--such as limiting\n\
    \   senders--have not yet been defined, let alone developed and deployed.\n  \
    \ As is true for reliable multicast, the current consensus is that no\n   single\
    \ security protocol will satisfy the wide diversity of\n   sometimes-contradictory\
    \ requirements among multicast applications.\n   Hence, multicast security will\
    \ also likely require a number of\n   different protocols.\n"
- title: 5.6 Synchronized Play-Out
  contents:
  - "5.6 Synchronized Play-Out\n   This refers to having all receivers simultaneously\
    \ play-out the\n   multicast data they received.  This may be necessary for fairness--\n\
    \   playing-out prices for auctions, or stock-prices--or to ensure\n   synchronization\
    \ with other receivers, such as when playing music.\n   Here is an analogy to\
    \ illustrate: Imagine a multi-speaker stereo\n   system that is wired throughout\
    \ a home (via analog).  With the stereo\n   playing on all speaker sets, you will\
    \ hear continuous music as you\n   walk from room-to-room.\n   Now imagine a house\
    \ full of multi-media and network enabled computer\n   systems.  Although they\
    \ will all receive the same music datastream\n   simultaneously via multicast,\
    \ they will provide discontinuous music\n   playback as you walk room-to-room.\n\
    \   To provide synchronized playback that would enable continuous music\n   from\
    \ room-to-room would require three things:\n      1) system clocks on all systems\
    \ should be synchronized\n      2) datastreams must be framed with timestamps\n\
    \      3) you must know the playback latency of the multimedia hardware\n   The\
    \ third of these is the most difficult to achieve at this time.\n   Hardware and\
    \ drivers don't provide any mechanism for retrieving this\n   information, although\
    \ different audio and video devices have a wide-\n   range of performance.\n"
- title: 6. Service APIs
  contents:
  - "6. Service APIs\n   In some cases, the protocol services mentioned in this document\
    \ can\n   be enabled transparently by passive configuration mechanisms and\n \
    \  \"middleware\". For example, it is conceivable that a UDP\n   implementation\
    \ could implicitly enable a reliable multicast protocol\n   without the explicit\
    \ interaction of the application.\n   Sometimes, however, applications need explicit\
    \ access to these\n   services for flexibility and control.  For example, an adaptive\n\
    \   application sending to a heterogeneous group of receivers using RTP\n   may\
    \ need to process RTCP reports from receivers in order to adapt\n   accordingly\
    \ (by throttling send rate or changing data encoders, for\n   example) [RTP API].\
    \  Hence, there is often a need for service APIs\n   that allow an application\
    \ to qualify and initiate service requests,\n   and receive event notifications.\
    \  In Figure 5, the top edge of the\n   box for each service effectively represents\
    \ its API.\n   Network APIs generally reflect the protocols they support.  Their\n\
    \   functionality and argument values are a (varying) subset of protocol\n   message\
    \ types, header fields and values.  Although some protocol\n   details and actions\
    \ may not be exposed in APIs--since many protocol\n   mechanics need not be exposed--others\
    \ are crucial to efficient and\n   flexible application operation.\n   A more\
    \ complete examination of the application services described in\n   this document\
    \ might also identify the protocol features that could be\n   mapped to define\
    \ a (generic) API definition for that service.  APIs\n   are often controversial,\
    \ however.  Not only are there many language\n   differences, but it is also possible\
    \ to create different APIs by\n   exposing different levels of detail in trade-offs\
    \ between flexibility\n   and simplicity.\n"
- title: 7. Security Considerations
  contents:
  - "7. Security Considerations\n   See section 5.4\n"
- title: 8. Acknowledgements
  contents:
  - "8. Acknowledgements\n   The authors would like to acknowledge and thank the following\n\
    \   individuals for their helpful feedback: Ran Canetti, Brian Haberman,\n   Eric\
    \ A. Hall, Kenneth C. Miller, and Dave Thaler.\n"
- title: 9. References
  contents:
  - "9. References\n   [AnyCast]   Partridge, C., Mendez, T. and W. Milliken, \"Host\n\
    \               Anycasting Service\", RFC 1546, November 1993.\n   [BeauW]   \
    \  B. Williamson, \"Developing IP Multicast Networks, Volume\n               I\"\
    , (c) 2000 Cisco Press, Indianapolis IN, ISBN 1-57870-\n               077-9.\n\
    \   [BULK]      Whetten, B., Vicisano, L., Kermode, R., Handley, M.,\n       \
    \        Floyd, S. and M. Luby, \"Reliable Multicast Transport\n             \
    \  Building Blocks for One-to-Many Bulk-Data Transfer\", RFC\n               3048,\
    \ January 2001.\n   [Deering]   Deering, S., \"Host Extensions for IP Multicasting\"\
    , STD\n               5, RFC 1112, August 1989.\n   [DIS]       Pullen, J., Mytak,\
    \ M. and C. Bouwens, \"Limitations of\n               Internet Protocol Suite\
    \ for Distributed Simulation in the\n               Large Multicast Environment\"\
    , RFC 2502, February 1999.\n   [E2EQOS]    Bernet, Y., Yavatkar, R., Ford, P.,\
    \ Baker, F., Zhang, L.,\n               Speer, M., Braden, R. and B. Davie, \"\
    Integrated Services\n               Operation over Diffserv Networks\", RFC 2998,\
    \ November\n               2000.\n   [Estrin]    D. Estrin, \"Multicast: Enabler\
    \ and Challenge\", Caltech\n               Earthlink Seminar Series, April 22,\
    \ 1998.\n   [Finlayson] Finlayson, R., \"IP Multicast and Firewalls\", RFC 2588,\n\
    \               May 1999.\n   [HNRS]      Hofman, Nonnenmacher, Rosenberg, Schulzrinne,\
    \ \"A Taxonomy\n               of Feedback for Multicast\", June 1999, Work in\
    \ Progress.\n   [IGMPv2]    Fenner, B., \"Internet Group Management Protocol,\
    \ Version\n               2\", RFC 2236, November 1997.\n   [IGMPv3]    Cain,\
    \ B., Deering, S., Kouvelas, I. and A. Thyagarajan,\n               \"Internet\
    \ Group Management Protocol, Version 3\", Work in\n               Progress.\n\
    \   [IMJ]       K. Almeroth and M. Ammar, \"The Interactive Multimedia\n     \
    \          Jukebox (IMJ): A New Paradigm for the On-Demand Delivery\n        \
    \       of Audio/Video\", Proceedings of the Seventh International\n         \
    \      World Wide Web Conference, Brisbane, AUSTRALIA, April\n               1998.\n\
    \   [IRTF]      Weinrib, A. and J. Postel, \"The IRTF Guidelines and\n       \
    \        Procedures\", BCP 8, RFC 2014, January 1996.\n   [Kermode]   Kermode,\
    \ R., \"MADCAP Multicast Scope Nesting State\n               Option\", RFC 2907,\
    \ September 2000.\n   [LSMA]      Bagnall, P., Briscoe, R. and A. Poppitt, \"\
    Taxonomy of\n               Communication Requirements for Large-scale Multicast\n\
    \               Applications\", RFC 2729, December 1999.\n   [MADDR]     Albanna,\
    \ Z., Almeroth, K., Meyer, D. and M. Schipper,\n               \"IANA Guidelines\
    \ for IPv4 Multicast Address Assignments\",\n               BCP 51, RFC 3171,\
    \ August 2001.\n   [MASC]      Estrin, D., Govindan, R., Handley, M., Kumar, S.,\n\
    \               Radoslavov, P. and D. Thaler, \"The Multicast Address-Set\n  \
    \             Claim (MASC) Protocol\", RFC 2909, September 2000.\n   [Maufer]\
    \    T. Maufer, \"Deploying IP Multicast in the Enterprise\",\n              \
    \ (c) 1998 Prentice Hall, Upper Saddle River NJ ISBN 0-13-\n               897687-2.\n\
    \   [Miller]    C. K. Miller, \"Multicast Networking and Applications\",\n   \
    \            (c) 1999 Addison Wesley Longman, Reading MA ISBN 0-201-\n       \
    \        30979-3.\n   [MADCAP]    Hanna, S., Patel, B. and M. Shah, \"Multicast\
    \ Address\n               Dynamic Client Allocation Protocol (MADCAP)\", RFC 2730,\n\
    \               December 1999.\n   [MRM]       K. Sarac, K. Almeroth, \"Supporting\
    \ Multicast Deployment\n               Efforts: A Survey of Tools for Multicast\
    \ Monitoring\",\n               Journal of High Speed Networking--Special Issue\
    \ on\n               Management of Multimedia Networking, March 2001\n   [MSec]\
    \      Multicast Security (msec) IETF Working Group charter\n   [MZAP]      Handley,\
    \ M., Thaler, D. and R. Kermode, \"Multicast-Scope\n               Zone Announcement\
    \ Protocol (MZAP)\", RFC 2776, February\n               2000.\n   [Obraczka] \
    \ K. Obraczka \"Multicast Transport Mechanisms: A Survey and\n               Taxonomy\"\
    , IEEE Communications Magazine, Vol. 36 No. 1,\n               January 1998.\n\
    \   [Rizzo]     L. Rizzo, \"Fast Group management in IGMP\", HIPPARC 98\n    \
    \           workshop, June 1998, UCL London\n               http://www.iet.unipi.it/~luigi/hipparc98.ps.gz\n\
    \   [RM]        Mankin, A.,  Romanow, A., Bradner, S. and V. Paxson,\n       \
    \        \"IETF Criteria for Evaluating Reliable Multicast\n               Transport\
    \ and Application Protocols\", RFC 2357, June\n               1998.\n   [RSVP]\
    \      Wroclawski, J., \"The Use of RSVP with IETF Integrated\n              \
    \ Services\", RFC 2210, September 1997.\n   [RTP API]   H. Schulzrinne, et al,\
    \ \"RTP Library API Specification,\"\n               http://www.cs.columbia.edu/IRT/software/rtplib/rtplib-\n\
    \               1.0a1/rtp_api.html\n   [RTP/RTCP]  Schulzrinne, H., Casner, S.,\
    \ Frederick, R. and V.\n               Jacobson, \"RTP: A Transport Protocol for\
    \ Real-Time\n               Applications\", RFC 1889, January 1996.\n   [SAP]\
    \       Handley, M., Perkins, C. and E. Whelan, \"Session\n               Announcement\
    \ Protocol\", RFC 2974, October 2000.\n   [SDP]       Handley, M., and V. Jacobson,\
    \ \"SDP: Session Description\n               Protocol\", RFC 2327, April 1998.\n\
    \   [Schneier]  B. Schneier, \"Why Cryptography Is Harder Than It Looks\",\n \
    \              December 1996, http://www.counterpane.com/whycrypto.html\n   [SlowStart]\
    \ Stevens, W., \"TCP Slow Start, Congestion Avoidance, Fast\n               Retransmit,\
    \ and Fast Recovery Algorithms\", RFC 2001,\n               January 1997.\n  \
    \ [SLP]       Veizades, J., Guttman, E., Perkins, C. and S. Kaplan,\n        \
    \       \"Service Location Protocol\", RFC 2165, June 1997.\n   [SSM]       Holbrook,\
    \ H. and B. Cain, \"Specific Multicast for IP\",\n               Work in Progress.\n"
- title: 10. Authors' Addresses
  contents:
  - "10. Authors' Addresses\n   Bob Quinn\n   Celox Networks\n   2 Park Central Drive\n\
    \   Southborough, MA 01772\n   Phone: +1 508 305 7000\n   EMail: bquinn@celoxnetworks.com\n\
    \   Kevin Almeroth\n   Department of Computer Science\n   University of California\n\
    \   Santa Barbara, CA 93106-5110\n   Phone: +1 805 893 2777\n   EMail: almeroth@cs.ucsb.edu\n"
- title: 11.  Full Copyright Statement
  contents:
  - "11.  Full Copyright Statement\n   Copyright (C) The Internet Society (2001).\
    \  All Rights Reserved.\n   This document and translations of it may be copied\
    \ and furnished to\n   others, and derivative works that comment on or otherwise\
    \ explain it\n   or assist in its implementation may be prepared, copied, published\n\
    \   and distributed, in whole or in part, without restriction of any\n   kind,\
    \ provided that the above copyright notice and this paragraph are\n   included\
    \ on all such copies and derivative works.  However, this\n   document itself\
    \ may not be modified in any way, such as by removing\n   the copyright notice\
    \ or references to the Internet Society or other\n   Internet organizations, except\
    \ as needed for the purpose of\n   developing Internet standards in which case\
    \ the procedures for\n   copyrights defined in the Internet Standards process\
    \ must be\n   followed, or as required to translate it into languages other than\n\
    \   English.\n   The limited permissions granted above are perpetual and will\
    \ not be\n   revoked by the Internet Society or its successors or assigns.\n \
    \  This document and the information contained herein is provided on an\n   \"\
    AS IS\" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING\n   TASK FORCE\
    \ DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING\n   BUT NOT LIMITED\
    \ TO ANY WARRANTY THAT THE USE OF THE INFORMATION\n   HEREIN WILL NOT INFRINGE\
    \ ANY RIGHTS OR ANY IMPLIED WARRANTIES OF\n   MERCHANTABILITY OR FITNESS FOR A\
    \ PARTICULAR PURPOSE.\n"
- title: Acknowledgement
  contents:
  - "Acknowledgement\n   Funding for the RFC Editor function is currently provided\
    \ by the\n   Internet Society.\n"
