- title: __initial_text__
  contents:
  - ''
- title: Independent Submission                                     M. Thornburgh
  contents:
  - "Independent Submission                                     M. Thornburgh\n  \
    \           Adobe's RTMFP Profile for Flash Communication\n"
- title: Abstract
  contents:
  - "Abstract\n   This memo describes how to use Adobe's Secure Real-Time Media Flow\n\
    \   Protocol (RTMFP) to transport the video, audio, and data messages of\n   Adobe\
    \ Flash platform communications.  Aspects of this application\n   profile include\
    \ cryptographic methods and data formats, flow metadata\n   formats, and protocol\
    \ details for client-server and peer-to-peer\n   communication.\n"
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This document is not an Internet Standards Track specification;\
    \ it is\n   published for informational purposes.\n   This is a contribution to\
    \ the RFC Series, independently of any other\n   RFC stream.  The RFC Editor has\
    \ chosen to publish this document at\n   its discretion and makes no statement\
    \ about its value for\n   implementation or deployment.  Documents approved for\
    \ publication by\n   the RFC Editor are not a candidate for any level of Internet\n\
    \   Standard; see Section 2 of RFC 5741.\n   Information about the current status\
    \ of this document, any errata,\n   and how to provide feedback on it may be obtained\
    \ at\n   http://www.rfc-editor.org/info/rfc7425.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (c) 2014 IETF Trust and the persons identified\
    \ as the\n   document authors.  All rights reserved.\n   This document is subject\
    \ to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n\
    \   (http://trustee.ietf.org/license-info) in effect on the date of\n   publication\
    \ of this document.  Please review these documents\n   carefully, as they describe\
    \ your rights and restrictions with respect\n   to this document.\n   This document\
    \ may not be modified, and derivative works of it may not\n   be created, except\
    \ to format it for publication as an RFC or to\n   translate it into languages\
    \ other than English.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1. Introduction ....................................................3\n\
    \   2. Terminology .....................................................4\n  \
    \ 3. Common Syntax Elements ..........................................4\n   4.\
    \ Cryptography Profile ............................................5\n      4.1.\
    \ Default Session Key ........................................5\n      4.2. Diffie-Hellman\
    \ Groups ......................................6\n      4.3. Certificates ...............................................6\n\
    \           4.3.1. Format ..............................................6\n  \
    \         4.3.2. Fingerprint .........................................7\n    \
    \       4.3.3. Options .............................................7\n      \
    \            4.3.3.1. Hostname ...................................8\n        \
    \          4.3.3.2. Accepts Ancillary Data .....................8\n          \
    \        4.3.3.3. Extra Randomness ...........................8\n            \
    \      4.3.3.4. Supported Ephemeral Diffie-Hellman Group ...9\n              \
    \    4.3.3.5. Static Diffie-Hellman Public Key ...........9\n           4.3.4.\
    \ Authenticity .......................................10\n           4.3.5. Signing\
    \ and Verifying Messages .....................10\n                  4.3.5.1. Options\
    \ ...................................11\n                           4.3.5.1.1.\
    \ Simple Password ................11\n           4.3.6. Glare Resolution ...................................13\n\
    \           4.3.7. Session Override ...................................13\n  \
    \    4.4. Endpoint Discriminators ...................................13\n    \
    \       4.4.1. Format .............................................14\n      \
    \     4.4.2. Options ............................................14\n        \
    \          4.4.2.1. Required Hostname .........................15\n          \
    \        4.4.2.2. Ancillary Data ............................15\n            \
    \      4.4.2.3. Fingerprint ...............................16\n           4.4.3.\
    \ Certificate Selection ..............................16\n           4.4.4. Canonical\
    \ Endpoint Discriminator ...................17\n      4.5. Session Keying Components\
    \ .................................18\n           4.5.1. Format .............................................19\n\
    \           4.5.2. Options ............................................19\n  \
    \                4.5.2.1. Ephemeral Diffie-Hellman Public Key .......20\n    \
    \              4.5.2.2. Extra Randomness ..........................20\n      \
    \            4.5.2.3. Diffie-Hellman Group Select ...............21\n        \
    \          4.5.2.4. HMAC Negotiation ..........................21\n          \
    \        4.5.2.5. Session Sequence Number Negotiation .......22\n      4.6. Session\
    \ Key Computation ...................................23\n           4.6.1. Public\
    \ Key Selection ...............................23\n                  4.6.1.1.\
    \ Initiator and Responder Ephemeral .........23\n                  4.6.1.2. Initiator\
    \ Ephemeral and Responder Static ..23\n                  4.6.1.3. Initiator Static\
    \ and Responder Ephemeral ..24\n                  4.6.1.4. Initiator and Responder\
    \ Static ............24\n           4.6.2. Diffie-Hellman Shared Secret .......................24\n\
    \           4.6.3. Packet Encrypt/Decrypt Keys ........................25\n  \
    \         4.6.4. Packet HMAC Send/Receive Keys ......................25\n    \
    \       4.6.5. Session Nonces .....................................26\n      \
    \     4.6.6. Session Sequence Number ............................26\n      4.7.\
    \ Packet Encryption .........................................27\n           4.7.1.\
    \ Cipher .............................................27\n           4.7.2. Format\
    \ .............................................27\n           4.7.3. Verification\
    \ .......................................29\n                  4.7.3.1. Simple\
    \ Checksum ...........................30\n                  4.7.3.2. HMAC ......................................30\n\
    \                  4.7.3.3. Session Sequence Number ...................31\n  \
    \ 5. Flash Communication ............................................31\n    \
    \  5.1. RTMP Messages .............................................31\n      \
    \     5.1.1. Flow Metadata ......................................32\n        \
    \   5.1.2. Message Mapping ....................................34\n      5.2.\
    \ Flow Synchronization ......................................35\n      5.3. Client-to-Server\
    \ Connection ...............................36\n           5.3.1. Connecting .........................................36\n\
    \           5.3.2. Server-to-Client Return Control Flow ...............37\n  \
    \         5.3.3. setPeerInfo Command ................................37\n    \
    \       5.3.4. Set Keepalive Timers Command .......................39\n      \
    \     5.3.5. Additional Flows for Streams .......................40\n        \
    \          5.3.5.1. To Server .................................40\n          \
    \        5.3.5.2. From Server ...............................40\n            \
    \      5.3.5.3. Closing Stream Flows ......................41\n           5.3.6.\
    \ Closing the Connection .............................41\n           5.3.7. Example\
    \ ............................................42\n      5.4. Direct Peer-to-Peer\
    \ Streams ...............................43\n           5.4.1. Connecting .........................................43\n\
    \           5.4.2. Return Flows for Stream ............................43\n  \
    \         5.4.3. Closing the Connection .............................44\n   6.\
    \ IANA Considerations ............................................44\n      6.1.\
    \ RTMFP URI Scheme Registration .............................44\n   7. Security\
    \ Considerations ........................................46\n   8. References\
    \ .....................................................47\n      8.1. Normative\
    \ References ......................................47\n      8.2. Informative\
    \ References ....................................49\n   Acknowledgements ..................................................49\n\
    \   Author's Address ..................................................49\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   Adobe's Secure Real-Time Media Flow Protocol (RTMFP) [RFC7016]\
    \ is a\n   general-purpose transport service for real-time media and bulk data\n\
    \   in IP networks, and it is suited to client-server and peer-to-peer\n   (P2P)\
    \ communication.  RTMFP provides a generalized framework for\n   securing its\
    \ communications according to the needs of its\n   application.\n   The Flash\
    \ platform comprises the Flash runtime (including Flash\n   Player) from Adobe\
    \ Systems Incorporated, communication servers such\n   as Adobe Media Server,\
    \ and interoperable clients and servers provided\n   by other parties.\n   Real-time\
    \ streaming network communication for the Flash platform of\n   video, audio,\
    \ and data typically uses Adobe's Real-Time Messaging\n   Protocol (RTMP) [RTMP]\
    \ messages.  RTMP messages were originally\n   designed to be transported over\
    \ RTMP Chunk Stream in TCP [RTMP];\n   however, other transports (such as the\
    \ one described in this memo)\n   are possible.\n   This memo specifies the syntax\
    \ and semantics for transporting RTMP\n   messages over RTMFP, and it extends\
    \ Flash communication semantics to\n   include direct P2P communication.  This\
    \ memo further specifies a\n   concrete Cryptography Profile for RTMFP tailored\
    \ to the application\n   and cryptographic needs of Flash platform client-server\
    \ and P2P\n   communications.\n   These protocols and profiles were developed\
    \ by Adobe Systems\n   Incorporated and are not the product of an IETF activity.\n"
- title: 2.  Terminology
  contents:
  - "2.  Terminology\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\"\
    , \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"NOT RECOMMENDED\"\
    , \"MAY\", and\n   \"OPTIONAL\" in this document are to be interpreted as described\
    \ in\n   [RFC2119].\n   \"HMAC\" means the Keyed-Hash Message Authentication Code\
    \ (HMAC)\n   algorithm [RFC2104].\n   \"HMAC-SHA256\" means HMAC using the SHA-256\
    \ Secure Hash Algorithm\n   [SHA256] [RFC6234].\n   \"HMAC-SHA256(K, M)\" means\
    \ the calculation of the HMAC-SHA256 of\n   message M using key K.\n"
- title: 3.  Common Syntax Elements
  contents:
  - "3.  Common Syntax Elements\n   Definitions of types and structures in this specification\
    \ use\n   traditional text diagrams paired with procedural descriptions using\
    \ a\n   C-like syntax.  The C-like procedural descriptions SHALL be construed\n\
    \   as definitive.\n   Structures are packed to take only as many bytes as explicitly\n\
    \   indicated.  There is no 32-bit alignment constraint, and fields are\n   not\
    \ padded for alignment unless explicitly indicated or described.\n   Text diagrams\
    \ may include a bit ruler across the top; this is a\n   convenience for counting\
    \ bits in individual fields and does not\n   necessarily imply field alignment\
    \ on a multiple of the ruler width.\n   Unless specified otherwise, reserved fields\
    \ SHOULD be set to 0 by a\n   sender and MUST be ignored by a receiver.\n   The\
    \ procedural syntax of this specification defines correct and\n   error-free encoded\
    \ inputs to a parser.  The procedural syntax does\n   not describe a fully featured\
    \ parser, including error detection and\n   handling.  Implementations MUST include\
    \ means to identify error\n   circumstances, including truncations causing elementary\
    \ or composed\n   types not to fit inside containing structures, fields, or elements.\n\
    \   Unless specified otherwise, an error circumstance SHALL abort the\n   parsing\
    \ and processing of an element and its enclosing elements.\n   This memo uses\
    \ the elementary and composed types described in\n   Section 2.1 of RFC 7016.\
    \  The definitions of that section are\n   incorporated by reference as though\
    \ fully set forth here.\n"
- title: 4.  Cryptography Profile
  contents:
  - "4.  Cryptography Profile\n   RTMFP defines a general security framework but delegates\
    \ specifics,\n   such as packet encryption ciphers and key agreement algorithms,\
    \ to an\n   application-defined Cryptography Profile.\n   This section defines\
    \ the RTMFP Cryptography Profile for Flash\n   platform communication.\n"
- title: 4.1.  Default Session Key
  contents:
  - "4.1.  Default Session Key\n   RTMFP uses a Default Session Key and associated\
    \ default cipher\n   configuration during session startup handshaking, where session-\n\
    \   specific keys and ciphers are negotiated.\n   The default cipher is the Advanced\
    \ Encryption Standard [AES] with\n   128-bit keys operating in Cipher Block Chaining\
    \ [CBC] mode, as\n   described in Section 4.7.1.  The Default Session Key is the\
    \ 16 bytes\n   of the string \"Adobe Systems 02\" encoded in UTF-8 [RFC3629]:\n\
    \           Hex: 41 64 6F 62 65 20 53 79 73 74 65 6D 73 20 30 32\n   The Default\
    \ Session Key uses checksum mode for packet verification\n   and does not use\
    \ session sequence numbers (Section 4.7.3).\n"
- title: 4.2.  Diffie-Hellman Groups
  contents:
  - "4.2.  Diffie-Hellman Groups\n   Implementations conforming to this profile MUST\
    \ support Diffie-\n   Hellman [DH] modular exponentiation (MODP) group 2 (1024\
    \ bits) as\n   defined in [RFC7296], and SHOULD support Diffie-Hellman MODP group\
    \ 5\n   (1536 bits) and group 14 (2048 bits) as defined in [RFC3526].\n   Implementations\
    \ MAY support additional groups.\n"
- title: 4.3.  Certificates
  contents:
  - "4.3.  Certificates\n   This section defines the certificate format for this Cryptography\n\
    \   Profile, and the mapping to the abstract properties and semantics for\n  \
    \ RTMFP endpoint identities.\n"
- title: 4.3.1.  Format
  contents:
  - "4.3.1.  Format\n   A certificate in this profile is encoded as a sequence of\
    \ zero or\n   more RTMFP Options and Markers (Section 2.1.3 of RFC 7016).  The\n\
    \   first marker (if any) in the certificate separates the canonical\n   section\
    \ of the certificate from the remainder.  Some options are\n   ignored if they\
    \ occur outside of the canonical section (that is,\n   after the first marker).\n\
    \   +~~~/~~~/~~~+   +~~~/~~~/~~~+~~~~~+~~~/~~~/~~~+   +~~~/~~~/~~~+\n   | L \\\
    \ T \\ V |...| L \\ T \\ V |  0  | L \\ T \\ V |...| L \\ T \\ V |\n   +~~~/~~~/~~~+\
    \   +~~~/~~~/~~~+~~~~~+~~~/~~~/~~~+   +~~~/~~~/~~~+\n   ^                    \
    \       ^  ^  ^                           ^\n   |  Zero or more non-empty   |\
    \  |  |   Zero or more Options    |\n   |         Options           |  |  +------\
    \  or Markers  -------+\n   |                           |  |\n   +---  Canonical\
    \ Section  ---+  +---- First Marker\n                                        (if\
    \ present)\n   struct certificate_t\n   {\n       canonicalStart = remainder();\n\
    \       canonicalEnd = remainder();\n       markerFound = false;\n       while(remainder()\
    \ > 0)\n       {\n           option_t option :variable*8;\n           if(0 ==\
    \ option.length)\n               markerFound = true;\n           else if(!markerFound)\n\
    \               canonicalEnd = remainder();\n       };\n       canonicalSectionLength\
    \ = canonicalStart - canonicalEnd;\n   } :variable*8;\n"
- title: 4.3.2.  Fingerprint
  contents:
  - "4.3.2.  Fingerprint\n   A certificate's fingerprint is the SHA-256 hash [SHA256]\
    \ of the\n   canonical section of the certificate (that is, the hash of the first\n\
    \   canonicalSectionLength bytes of the certificate).\n   The certificate's fingerprint\
    \ is also called the \"peer ID\".\n"
- title: 4.3.3.  Options
  contents:
  - "4.3.3.  Options\n   This section lists options that can appear in a certificate.\
    \  The\n   following option type codes are defined:\n   0x00:    Hostname (must\
    \ be in canonical section) (Section 4.3.3.1)\n   0x0a:    Accepts Ancillary Data\
    \ (must be in canonical section)\n            (Section 4.3.3.2)\n   0x0e:    Extra\
    \ Randomness (Section 4.3.3.3)\n   0x15:    Supported Ephemeral Diffie-Hellman\
    \ Group (must be in\n            canonical section) (Section 4.3.3.4)\n   0x1d:\
    \    Static Diffie-Hellman Public Key (must be in canonical\n            section)\
    \ (Section 4.3.3.5)\n   An implementation MUST ignore a certificate option type\
    \ that is not\n   understood.\n"
- title: 4.3.3.1.  Hostname
  contents:
  - "4.3.3.1.  Hostname\n   This option gives an optional hostname for the endpoint.\
    \  This option\n   MUST be ignored if is not in the canonical section.  This option\
    \ MUST\n   NOT occur more than once in a certificate.\n   +-------------/-+-------------/-+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~+\n\
    \   |   length    \\ |     0x00    \\ |         hostname              |\n   +-------------/-+-------------/-+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~/\n\
    \   struct hostnameCertOptionValue_t\n   {\n       uint8_t hostname[remainder()];\n\
    \   } :remainder()*8;\n"
- title: 4.3.3.2.  Accepts Ancillary Data
  contents:
  - "4.3.3.2.  Accepts Ancillary Data\n   This option indicates that the endpoint\
    \ will accept an Endpoint\n   Discriminator encoding an Ancillary Data option\
    \ (Section 4.4.2.2).\n   This option MUST be ignored if it is not in the canonical\
    \ section.\n   +-------------/-+-------------/-+\n   |   length    \\ |     0x0a\
    \    \\ |\n   +-------------/-+-------------/-+\n"
- title: 4.3.3.3.  Extra Randomness
  contents:
  - "4.3.3.3.  Extra Randomness\n   This option can be used to add extra entropy or\
    \ randomness to a\n   certificate that doesn't have any other cryptographic pseudorandom\n\
    \   members (such as a public key).  This option is typically used so\n   that\
    \ endpoints using ephemeral Diffie-Hellman keying can have a\n   unique certificate\
    \ fingerprint.\n   +-------------/-+-------------/-+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~+\n\
    \   |   length    \\ |     0x0e    \\ |       extra randomness        |\n   +-------------/-+-------------/-+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~/\n\
    \   struct extraRandomnessCertOptionValue_t\n   {\n       uint_t extraRandomness[remainder()];\n\
    \   } :remainder()*8;\n"
- title: 4.3.3.4.  Supported Ephemeral Diffie-Hellman Group
  contents:
  - "4.3.3.4.  Supported Ephemeral Diffie-Hellman Group\n   This option specifies\
    \ a Diffie-Hellman group ID that is supported for\n   ephemeral keying.  This\
    \ option MUST be ignored if it is not in the\n   canonical section.  This option\
    \ may occur more than once in the\n   certificate; each instance indicates an\
    \ additional group that is\n   supported for key agreement.\n   +-------------/-+-------------/-+-------------/-+\n\
    \   |   length    \\ |     0x15    \\ |   group ID  \\ |\n   +-------------/-+-------------/-+-------------/-+\n\
    \   struct ephemeralDHGroupCertOptionValue_t\n   {\n       vlu_t groupID :variable*8;\n\
    \   } :variable*8;\n   The presence of this option means that the certificate\
    \ uses ephemeral\n   Diffie-Hellman public keys only.  The certificate MUST NOT\
    \ contain a\n   Static Diffie-Hellman public key (Section 4.3.3.5).\n"
- title: 4.3.3.5.  Static Diffie-Hellman Public Key
  contents:
  - "4.3.3.5.  Static Diffie-Hellman Public Key\n   This option specifies a Diffie-Hellman\
    \ group ID and static public key\n   in that group.  This option MUST be ignored\
    \ if it is not in the\n   canonical section.  This option MAY occur more than\
    \ once in the\n   certificate; however, this option SHOULD NOT occur more than\
    \ once for\n   each group ID.  The behavior for specifying more than one public\
    \ key\n   per group ID is not defined.\n   +-------------/-+-------------/-+-------------/-+\n\
    \   |   length    \\ |     0x1d    \\ |   group ID  \\ |\n   +-------------/-+-------------/-+-------------/-+\n\
    \   +------------------------------------------------------------------+\n   |\
    \                  Diffie-Hellman Public Key                       |\n   +------------------------------------------------------------------/\n\
    \   struct staticDHPublicKeyCertOptionValue_t\n   {\n       vlu_t   groupID :variable*8;\n\
    \       uintn_t publicKey :remainder()*8; // network byte order\n   } :remainder()*8;\n\
    \   The presence of this option means that the certificate uses static\n   Diffie-Hellman\
    \ public keys only.  The certificate MUST NOT contain\n   any Supported Ephemeral\
    \ Diffie-Hellman Group options\n   (Section 4.3.3.4).\n"
- title: 4.3.4.  Authenticity
  contents:
  - "4.3.4.  Authenticity\n   This profile does not use a public key infrastructure,\
    \ nor are there\n   signing keys present in certificates.  Therefore, any properly\n\
    \   encoded certificate is considered authentic according to Section 3.2\n   of\
    \ RFC 7016.\n   A certificate containing a static public key can only be used\n\
    \   successfully for session communication if the holder of the\n   certificate\
    \ actually holds the private key associated with the public\n   key.  Authenticity\
    \ of an identity and its peer ID (Section 4.3.2)\n   having a certificate containing\
    \ a static public key is implied by\n   successful encrypted communication with\
    \ the associated endpoint\n   (Section 4.6).\n   See Section 7 for further discussion\
    \ of security issues related to\n   identities.\n"
- title: 4.3.5.  Signing and Verifying Messages
  contents:
  - "4.3.5.  Signing and Verifying Messages\n   RTMFP Initiator Initial Keying and\
    \ Responder Initial Keying messages\n   have a field for the sender's digital\
    \ signature of the keying\n   parameters (Sections 2.3.7 and 2.3.8 of RFC 7016).\
    \  In this profile,\n   the signature field of those messages is encoded as a\
    \ sequence of\n   zero or more RTMFP Options.\n   +~~~/~~~/~~~~~~~+          \
    \     +~~~/~~~/~~~~~~~+\n   | L \\ T \\   V   |...............| L \\ T \\   V\
    \   |\n   +~~~/~~~/~~~~~~~+               +~~~/~~~/~~~~~~~+\n   ^            \
    \                                   ^\n   +-------------  Zero or more Options\
    \  ----------+\n   struct initialKeyingSignature_t\n   {\n       while(remainder()\
    \ > 0)\n           option_t option :variable*8;\n   } :remainder()*8;\n   If a\
    \ signer has no signature options to send, it MAY encode a\n   signature as a\
    \ UTF-8 capital \"X\" (hex 58) or as empty.  A verifier\n   MUST interpret a malformed\
    \ signature field or a signature field\n   consisting only of a UTF-8 capital\
    \ \"X\" as though it was empty.\n   If a verifier does not require a signature,\
    \ it SHALL consider any\n   signature field (including an empty or malformed one)\
    \ to be valid.  A\n   verifier MAY require a signature comprising one or more\
    \ non-empty\n   options that are valid according to their respective types.\n\
    \   This profile does not use a public key infrastructure, nor are there\n   signing\
    \ keys present in certificates.  Section 4.3.5.1.1 defines a\n   simple ID/password\
    \ credential system.\n"
- title: 4.3.5.1.  Options
  contents:
  - "4.3.5.1.  Options\n   This section lists options that can appear in an RTMFP\
    \ Initial Keying\n   signature field.  The following option type code is defined:\n\
    \   0x1d:  Simple Password (Section 4.3.5.1.1)\n   Future or derived profiles\
    \ may define additional signature field\n   options and semantics; therefore,\
    \ a verifier SHOULD ignore option\n   types that are not understood.\n"
- title: 4.3.5.1.1.  Simple Password
  contents:
  - "4.3.5.1.1.  Simple Password\n   This option encodes a password identifier (such\
    \ as a user name, or an\n   application-specific or implementation-specific selector)\
    \ and an HMAC\n   over the signed parameters using the identified password as\
    \ the HMAC\n   key.  This option can occur more than once (for example, to allow\n\
    \   interoperation between a current and a previous version of an\n   implementation\
    \ using implementation-specific passwords).\n   To support the versioning use\
    \ case, a verifier SHOULD ignore a Simple\n   Password option encoding an unrecognized\
    \ password identifier.  A\n   verifier SHOULD treat the entire signature as invalid\
    \ if any Simple\n   Password option encodes a recognized password identifier with\
    \ an\n   invalid password HMAC.\n    0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4\
    \ 5 6 7|0 1 2 3 4 5 6 7\n   +-------------/-+-------------/-+\n   |   length \
    \   \\ |     0x1d    \\ |\n   +-------------/-+-------------/-+\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                                                               |\n   + -\
    \ - - - - - - + - - - - - - - + - - - - - - - + - - - - - - - +\n   |        \
    \                                                       |\n   + - - - - - - -\
    \ + - - - - - - - + - - - - - - - + - - - - - - - +\n   |                    \
    \                                           |\n   + - - - - - - - + - - - - -\
    \ - - + - - - - - - - + - - - - - - - +\n   |                           hmacSHA256\
    \                          |\n   + - - - - - - - + - - - - - - - + - - - - - -\
    \ - + - - - - - - - +\n   |                                                  \
    \             |\n   + - - - - - - - + - - - - - - - + - - - - - - - + - - - -\
    \ - - - +\n   |                                                              \
    \ |\n   + - - - - - - - + - - - - - - - + - - - - - - - + - - - - - - - +\n  \
    \ |                                                               |\n   + - -\
    \ - - - - - + - - - - - - - + - - - - - - - + - - - - - - - +\n   |          \
    \                                                     |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   +~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~+\n   |  \
    \                         passwordID                          |\n   +~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~/\n\
    \   struct simplePasswordSignatureOptionValue_t\n   {\n       uint8_t hmacSHA256[32];\n\
    \       uint8_t passwordID[remainder()];\n   } :remainder()*8;\n   hmacSHA256:\
    \  HMAC-SHA256(K, M), where K is the password associated\n      with passwordID,\
    \ and M is the signed parameters.\n   passwordID:  The identifier (such as a user\
    \ name) for the password\n      used as the HMAC key.\n"
- title: 4.3.6.  Glare Resolution
  contents:
  - "4.3.6.  Glare Resolution\n   Glare occurs when two endpoints initiate a session\
    \ each to the other\n   concurrently.\n   Compare the near end's certificate to\
    \ the far end's with a binary\n   lexicographic comparison, one byte at a time,\
    \ up to the length of the\n   shorter certificate.  At the first corresponding\
    \ byte from each\n   certificate that is different, the certificate having the\
    \ differing\n   byte (treated as an unsigned 8-bit integer) with the lower value\
    \ is\n   ordered before the other certificate.  If the certificates are not\n\
    \   the same length and they are identical up to the length of the\n   shorter\
    \ certificate, then the shorter certificate is ordered before\n   the longer.\n\
    \   The near end prevails as the Initiator in case of glare if its\n   certificate\
    \ is ordered before, or is identical to, the certificate of\n   the far end. \
    \ Otherwise, the near end's certificate is ordered after\n   the far end's certificate,\
    \ and the near end assumes the role of\n   Responder.\n"
- title: 4.3.7.  Session Override
  contents:
  - "4.3.7.  Session Override\n   A new incoming session overrides an existing session\
    \ only if the\n   certificate for the new session is identical to the certificate\
    \ for\n   the existing session.\n"
- title: 4.4.  Endpoint Discriminators
  contents:
  - "4.4.  Endpoint Discriminators\n   This section describes the Endpoint Discriminator\
    \ (EPD) (Section 3.2\n   of RFC 7016) format and semantics for this Cryptography\
    \ Profile, and\n   the mapping to RTMFP's abstract certificate and identity selection\n\
    \   semantics.\n"
- title: 4.4.1.  Format
  contents:
  - "4.4.1.  Format\n   An EPD in this profile is encoded as a sequence of zero or\
    \ more RTMFP\n   Options.\n   +~~~/~~~/~~~~~~~+               +~~~/~~~/~~~~~~~+\n\
    \   | L \\ T \\   V   |...............| L \\ T \\   V   |\n   +~~~/~~~/~~~~~~~+\
    \               +~~~/~~~/~~~~~~~+\n   ^                                      \
    \         ^\n   +-------------  Zero or more Options  ----------+\n   struct endpointDiscriminator_t\n\
    \   {\n       while(remainder() > 0)\n           option_t option :variable*8;\n\
    \   } :remainder()*8;\n"
- title: 4.4.2.  Options
  contents:
  - "4.4.2.  Options\n   This section lists options that can appear in an EPD.  The\
    \ following\n   option type codes are defined:\n   0x00:  Required Hostname (Section\
    \ 4.4.2.1)\n   0x0a:  Ancillary Data (Section 4.4.2.2)\n   0x0f:  Fingerprint\
    \ (Section 4.4.2.3)\n   The use of these options for selecting certificates is\
    \ described in\n   Section 4.4.3.\n   An implementation MUST ignore EPD option\
    \ types that are not\n   understood.\n"
- title: 4.4.2.1.  Required Hostname
  contents:
  - "4.4.2.1.  Required Hostname\n   This option indicates the hostname to match against\
    \ the certificate's\n   Hostname option (Section 4.3.3.1).\n   +-------------/-+-------------/-+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~+\n\
    \   |   length    \\ |     0x00    \\ |         hostname              |\n   +-------------/-+-------------/-+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~/\n\
    \   struct hostnameEPDOptionValue_t\n   {\n       uint8_t hostname[remainder()];\n\
    \   } :remainder()*8;\n   This option MUST NOT occur more than once in an EPD.\n"
- title: 4.4.2.2.  Ancillary Data
  contents:
  - "4.4.2.2.  Ancillary Data\n   In this profile, this option indicates the server\
    \ Uniform Resource\n   Identifier (URI) [RFC3986] encoded in UTF-8 to which a\
    \ client is\n   connecting on this session, for example,\n   \"rtmfp://server.example.com/app/instance\"\
    .\n   +-------------/-+-------------/-+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~+\n   |\
    \   length    \\ |     0x0a    \\ |       ancillary data          |\n   +-------------/-+-------------/-+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~/\n\
    \   struct ancillaryDataEPDOptionValue_t\n   {\n       uint8_t ancillaryData[remainder()];\n\
    \   } :remainder()*8;\n   This option MUST NOT occur more than once in an EPD.\n"
- title: 4.4.2.3.  Fingerprint
  contents:
  - "4.4.2.3.  Fingerprint\n   This option indicates the 256-bit (32-byte) fingerprint\n\
    \   (Section 4.3.2) of a certificate.\n    0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1\
    \ 2 3 4 5 6 7|0 1 2 3 4 5 6 7\n   +-------------/-+-------------/-+\n   |   length\
    \    \\ |     0x0f    \\ |\n   +-------------/-+-------------/-+\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                                                               |\n   + -\
    \ - - - - - - + - - - - - - - + - - - - - - - + - - - - - - - +\n   |        \
    \                                                       |\n   + - - - - - - -\
    \ + - - - - - - - + - - - - - - - + - - - - - - - +\n   |                    \
    \                                           |\n   + - - - - - - - + - - - - -\
    \ - - + - - - - - - - + - - - - - - - +\n   |                          fingerprint\
    \                          |\n   + - - - - - - - + - - - - - - - + - - - - - -\
    \ - + - - - - - - - +\n   |                                                  \
    \             |\n   + - - - - - - - + - - - - - - - + - - - - - - - + - - - -\
    \ - - - +\n   |                                                              \
    \ |\n   + - - - - - - - + - - - - - - - + - - - - - - - + - - - - - - - +\n  \
    \ |                                                               |\n   + - -\
    \ - - - - - + - - - - - - - + - - - - - - - + - - - - - - - +\n   |          \
    \                                                     |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   struct fingerprintEPDOptionValue_t\n   {\n       uint8_t fingerprint[32];\n\
    \   } :256;\n   This option MUST NOT occur more than once in an EPD.\n"
- title: 4.4.3.  Certificate Selection
  contents:
  - "4.4.3.  Certificate Selection\n   This section describes the REQUIRED method\
    \ of determining whether an\n   EPD selects a certificate.\n   An EPD MUST contain\
    \ at least one of Fingerprint, Required Hostname,\n   or Ancillary Data options\
    \ to select any certificate.\n   A Fingerprint EPD option selects or rejects a\
    \ certificate no matter\n   what other options are present.\n   Without a Fingerprint\
    \ option, a Required Hostname EPD option, if\n   present, REQUIRES an identical\
    \ Hostname option in the certificate.\n   Without a Fingerprint option, an Ancillary\
    \ Data EPD option, if\n   present, REQUIRES that the certificate has an Accepts\
    \ Ancillary Data\n   option.\n   if EPD contains a Fingerprint option:\n     \
    \  if certificate.fingerprint == option.fingerprint:\n           certificate is\
    \ selected. stop.\n       else:\n           certificate is not selected. stop.\n\
    \   else:\n       if EPD contains a Required Hostname option:\n           if certificate\
    \ contains a Hostname option:\n               if certificate.hostname != option.hostname:\n\
    \                   certificate is not selected. stop.\n           else:\n   \
    \            certificate is not selected. stop.\n       if EPD contains an Ancillary\
    \ Data option:\n           if certificate doesn't have an Accepts Ancillary Data\
    \ option:\n               certificate is not selected. stop.\n       else if EPD\
    \ does not contain a Required Hostname option:\n           certificate is not\
    \ selected. stop.\n       certificate is selected. stop.\n     Figure 1: Algorithm\
    \ to Test Whether an EPD Selects a Certificate\n"
- title: 4.4.4.  Canonical Endpoint Discriminator
  contents:
  - "4.4.4.  Canonical Endpoint Discriminator\n   In this profile, a Canonical Endpoint\
    \ Discriminator (Section 3.2 of\n   RFC 7016) contains only a Fingerprint option\
    \ (Section 4.4.2.3) and no\n   other options.  The option length and type code\
    \ MUST be encoded as\n   1-byte VLUs, even though VLU encoding allows those fields\
    \ to be\n   encoded in an arbitrary number of bytes.  That is, the Canonical\n\
    \   Endpoint Discriminator MUST be exactly 34 bytes long, with a length\n   field\
    \ of 0x21 encoded as one byte, a type code of 0x0f encoded as one\n   byte, and\
    \ 32 bytes of fingerprint.\n    0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6\
    \ 7|0 1 2 3 4 5 6 7\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   |     0x21     \
    \ |     0x0f      |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                                                               |\n   + -\
    \ - - - - - - + - - - - - - - + - - - - - - - + - - - - - - - +\n   |        \
    \                                                       |\n   + - - - - - - -\
    \ + - - - - - - - + - - - - - - - + - - - - - - - +\n   |                    \
    \                                           |\n   + - - - - - - - + - - - - -\
    \ - - + - - - - - - - + - - - - - - - +\n   |                          fingerprint\
    \                          |\n   + - - - - - - - + - - - - - - - + - - - - - -\
    \ - + - - - - - - - +\n   |                                                  \
    \             |\n   + - - - - - - - + - - - - - - - + - - - - - - - + - - - -\
    \ - - - +\n   |                                                              \
    \ |\n   + - - - - - - - + - - - - - - - + - - - - - - - + - - - - - - - +\n  \
    \ |                                                               |\n   + - -\
    \ - - - - - + - - - - - - - + - - - - - - - + - - - - - - - +\n   |          \
    \                                                     |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   struct canonicalEndpointDiscriminator_t\n   {\n       uint8_t length = 0x21;\n\
    \       uint8_t type = 0x0f;\n       uint8_t fingerprint[32];\n   } :272;\n"
- title: 4.5.  Session Keying Components
  contents:
  - "4.5.  Session Keying Components\n   This section describes the format of the\
    \ Session Key Initiator\n   Component of the Initiator Initial Keying RTMFP chunk\
    \ and the Session\n   Key Responder Component of the Responder Initial Keying\
    \ RTMFP chunk\n   (Sections 2.3.7 and 2.3.8 of RFC 7016).  The Initiator and Responder\n\
    \   Session Keying Components have the same format.\n"
- title: 4.5.1.  Format
  contents:
  - "4.5.1.  Format\n   A Session Keying Component in this profile is encoded as a\
    \ sequence\n   of zero or more RTMFP Options.\n   +~~~/~~~/~~~~~~~+          \
    \     +~~~/~~~/~~~~~~~+\n   | L \\ T \\   V   |...............| L \\ T \\   V\
    \   |\n   +~~~/~~~/~~~~~~~+               +~~~/~~~/~~~~~~~+\n   ^            \
    \                                   ^\n   +-------------  Zero or more Options\
    \  ----------+\n   struct sessionKeyingComponent_t\n   {\n       while(remainder()\
    \ > 0)\n           option_t option :variable*8;\n   } :remainder()*8;\n"
- title: 4.5.2.  Options
  contents:
  - "4.5.2.  Options\n   This section lists options that can appear in a Session Keying\n\
    \   Component.  The following option type codes are defined:\n   0x0d:  Ephemeral\
    \ Diffie-Hellman Public Key (Section 4.5.2.1)\n   0x0e:  Extra Randomness (Section\
    \ 4.5.2.2)\n   0x1d:  Diffie-Hellman Group Select (Section 4.5.2.3)\n   0x1a:\
    \  HMAC Negotiation (Section 4.5.2.4)\n   0x1e:  Session Sequence Number Negotiation\
    \ (Section 4.5.2.5)\n   An implementation MUST ignore a session keying component\
    \ option type\n   that is not understood.\n"
- title: 4.5.2.1.  Ephemeral Diffie-Hellman Public Key
  contents:
  - "4.5.2.1.  Ephemeral Diffie-Hellman Public Key\n   This option specifies a Diffie-Hellman\
    \ group ID and public key in\n   that group.  This option MUST NOT be sent if\
    \ the sender's certificate\n   has a static Diffie-Hellman public key.  This option\
    \ MUST be sent if\n   the sender's certificate does not have a static Diffie-Hellman\
    \ public\n   key.  This option MUST NOT be sent more than once.\n   +-------------/-+-------------/-+-------------/-+\n\
    \   |   length    \\ |     0x0d    \\ |   group ID  \\ |\n   +-------------/-+-------------/-+-------------/-+\n\
    \   +------------------------------------------------------------------+\n   |\
    \                  Diffie-Hellman Public Key                       |\n   +------------------------------------------------------------------/\n\
    \   struct ephemeralDHPublicKeyKeyingOptionValue_t\n   {\n       vlu_t   groupID\
    \ :variable*8;\n       uintn_t publicKey :remainder()*8; // network byte order\n\
    \   } :remainder()*8;\n"
- title: 4.5.2.2.  Extra Randomness
  contents:
  - "4.5.2.2.  Extra Randomness\n   This option can be used to add extra entropy or\
    \ randomness to a\n   keying component, particularly when the sender uses a static\
    \ public\n   key.  When used for that purpose, the extra randomness SHOULD be\n\
    \   cryptographically strong pseudorandom bytes not less than 16 bytes\n   (for\
    \ cryptographically significant entropy) and not more than 64\n   bytes (the length\
    \ of a SHA-256 input block) in length.  The extra\n   randomness serves as a salt\
    \ when computing the session keys\n   (Section 4.6).\n   +-------------/-+-------------/-+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~+\n\
    \   |   length    \\ |     0x0e    \\ |       extra randomness        |\n   +-------------/-+-------------/-+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~/\n\
    \   struct extraRandomnessKeyingOptionValue_t\n   {\n       uint_t extraRandomness[remainder()];\n\
    \   } :remainder()*8;\n"
- title: 4.5.2.3.  Diffie-Hellman Group Select
  contents:
  - "4.5.2.3.  Diffie-Hellman Group Select\n   This option is sent by the Initiator\
    \ to specify which Diffie-Hellman\n   group to use for key agreement.  The Initiator\
    \ MUST send this option\n   when it advertises a static Diffie-Hellman public\
    \ key in its\n   certificate and MUST NOT send this option if it sends an ephemeral\n\
    \   Diffie-Hellman public key.  This option MUST NOT be sent more than\n   once.\n\
    \   +-------------/-+-------------/-+-------------/-+\n   |   length    \\ | \
    \    0x1d    \\ |   group ID  \\ |\n   +-------------/-+-------------/-+-------------/-+\n\
    \   struct staticDHGroupSelectKeyingOptionValue_t\n   {\n       vlu_t   groupID\
    \ :variable*8;\n   } :variable*8;\n"
- title: 4.5.2.4.  HMAC Negotiation
  contents:
  - "4.5.2.4.  HMAC Negotiation\n   This option is used to negotiate sending and receiving\
    \ of an HMAC\n   field for packet verification.\n                            \
    \       |0 1 2 3 4 5 6 7|\n   +-------------/-+-------------/-+-+-+-+-+-+-+-+-+-------------/-+\n\
    \   |             \\ |             \\ |         |S|S|R|             \\ |\n   |\
    \   length    / |     0x1a    / |   rsv   |N|O|E|  hmacLength / |\n   |      \
    \       \\ |             \\ |         |D|R|Q|             \\ |\n   +-------------/-+-------------/-+-+-+-+-+-+-+-+-+-------------/-+\n\
    \   struct hmacNegotiationKeyingOptionValue_t\n   {\n       uintn_t reserved :5;\
    \          // rsv\n       bool_t  willSendAlways :1;    // SND\n       bool_t\
    \  willSendOnRequest :1; // SOR\n       bool_t  request :1;           // REQ\n\
    \       vlu_t   hmacLength :variable*8;\n   } :variable*8;\n   willSendAlways:\
    \  If set, the sender will send an HMAC on packets in\n      this session.\n \
    \  willSendOnRequest:  If set, the sender will send an HMAC on packets\n     \
    \ in this session if the other end sets the request flag in its HMAC\n      Negotiation.\n\
    \   request:  If set, the sender would very much like the receiver to\n      send\
    \ an HMAC on its packets.  If the other end doesn't send an\n      HMAC on its\
    \ packets, the session can fail.\n   hmacLength:  If the sender negotiates to\
    \ send an HMAC on its packets,\n      the HMAC field will be this many bytes long.\
    \  This value MUST be\n      between 4 and 32 inclusive, or 0 if and only if willSendAlways\
    \ and\n      willSendOnRequest are clear.\n   The handshake operational semantics\
    \ for this option are described in\n   Section 4.6.4.\n"
- title: 4.5.2.5.  Session Sequence Number Negotiation
  contents:
  - "4.5.2.5.  Session Sequence Number Negotiation\n   This option is used to negotiate\
    \ sending and receiving of the Session\n   Sequence Number field for packet verification.\n\
    \                                   |0 1 2 3 4 5 6 7|\n   +-------------/-+-------------/-+-+-+-+-+-+-+-+-+\n\
    \   |             \\ |             \\ |         |S|S|R|\n   |   length    / |\
    \     0x1e    / |   rsv   |N|O|E|\n   |             \\ |             \\ |    \
    \     |D|R|Q|\n   +-------------/-+-------------/-+-+-+-+-+-+-+-+-+\n   struct\
    \ sseqNegotiationKeyingOptionValue_t\n   {\n       uintn_t reserved :5;      \
    \    // rsv\n       bool_t  willSendAlways :1;    // SND\n       bool_t  willSendOnRequest\
    \ :1; // SOR\n       bool_t  request :1;           // REQ\n   } :8;\n   willSendAlways:\
    \  If set, the sender will send a session sequence\n      number in packets in\
    \ this session.\n   willSendOnRequest:  If set, the sender will send a session\
    \ sequence\n      number in packets in this session if the other end sets the\n\
    \      request flag in its Session Sequence Number Negotiation.\n   request: \
    \ If set, the sender would very much like the receiver to\n      send a session\
    \ sequence number in its packets.  If the other end\n      doesn't send a session\
    \ sequence number in its packets, the session\n      can fail.\n   The handshake\
    \ operational semantics for this option are described in\n   Section 4.6.6.\n"
- title: 4.6.  Session Key Computation
  contents:
  - "4.6.  Session Key Computation\n   This section describes how to compute the cryptographic\
    \ keys and\n   other settings for packet encryption and verification.\n   The\
    \ Session Key Near Component (SKNC) means the keying component sent\n   by the\
    \ near end of the session; that is, it is the Session Key\n   Initiator Component\
    \ at the Initiator and the Session Key Responder\n   Component at the Responder.\n\
    \   The Session Key Far Component (SKFC) means the keying component sent\n   by\
    \ the far end of the session; that is, it is the Session Key\n   Responder Component\
    \ at the Initiator and the Session Key Initiator\n   Component at the Responder.\n"
- title: 4.6.1.  Public Key Selection
  contents:
  - "4.6.1.  Public Key Selection\n   This section enumerates the public key selection\
    \ methods for all\n   possible combinations of static or ephemeral public key\
    \ modes for\n   each endpoint according to their certificate options (Section\
    \ 4.3.3).\n"
- title: 4.6.1.1.  Initiator and Responder Ephemeral
  contents:
  - "4.6.1.1.  Initiator and Responder Ephemeral\n   The Initiator and Responder list\
    \ one or more Supported Ephemeral\n   Diffie-Hellman Group options (Section 4.3.3.4)\
    \ in their certificates.\n   The Initiator sends exactly one Ephemeral Diffie-Hellman\
    \ Public Key\n   option (Section 4.5.2.1) in its Session Key Initiator Component,\n\
    \   which selects one group from among those supported by the Responder\n   and\
    \ Initiator.  Responder sends exactly one Ephemeral Diffie-Hellman\n   Public\
    \ Key option in its Session Key Responder Component, in the same\n   group as\
    \ indicated by the Initiator.\n"
- title: 4.6.1.2.  Initiator Ephemeral and Responder Static
  contents:
  - "4.6.1.2.  Initiator Ephemeral and Responder Static\n   The Responder lists one\
    \ or more Static Diffie-Hellman Public Key\n   options (Section 4.3.3.5) in its\
    \ certificate.  The Initiator lists\n   one or more Supported Ephemeral Diffie-Hellman\
    \ Group options in its\n   certificate.  The Initiator sends exactly one Ephemeral\
    \ Diffie-\n   Hellman Public Key option in its Session Key Initiator Component,\n\
    \   which selects one group from among those supported by the Responder\n   and\
    \ Initiator and the corresponding public key for the Responder.\n   Responder\
    \ uses its public key from the indicated group, and sends\n   only an Extra Randomness\
    \ option (Section 4.5.2.2) in its Session Key\n   Responder Component to salt\
    \ the session keys.\n"
- title: 4.6.1.3.  Initiator Static and Responder Ephemeral
  contents:
  - "4.6.1.3.  Initiator Static and Responder Ephemeral\n   The Responder lists one\
    \ or more Supported Ephemeral Diffie-Hellman\n   Group options in its certificate.\
    \  The Initiator lists one or more\n   Static Diffie-Hellman Public Key options\
    \ in its certificate.  The\n   Initiator sends exactly one Diffie-Hellman Group\
    \ Select option\n   (Section 4.5.2.3) in its Session Key Initiator Component,\
    \ which\n   selects one group from among those supported by the Responder and\n\
    \   Initiator and the corresponding public key for the Initiator, plus an\n  \
    \ Extra Randomness option to salt the session keys.  The Responder\n   sends an\
    \ Ephemeral Diffie-Hellman Public Key option in its Session\n   Key Responder\
    \ Component in the same group as indicated by the\n   Initiator.\n"
- title: 4.6.1.4.  Initiator and Responder Static
  contents:
  - "4.6.1.4.  Initiator and Responder Static\n   The Initiator and Responder each\
    \ list one or more Static Diffie-\n   Hellman Public Key options in their certificates.\
    \  The Initiator\n   sends exactly one Diffie-Hellman Group Select option in its\
    \ Session\n   Key Initiator Component, which selects one group and corresponding\n\
    \   public keys from among those supported by the Responder and\n   Initiator,\
    \ and an Extra Randomness option to salt the session keys.\n   The Responder sends\
    \ an Extra Randomness option in its Session Key\n   Responder Component to add\
    \ its own salt to the session keys.\n"
- title: 4.6.2.  Diffie-Hellman Shared Secret
  contents:
  - "4.6.2.  Diffie-Hellman Shared Secret\n   To be acceptable, a Diffie-Hellman public\
    \ key MUST have all of the\n   following properties:\n   o  Be at least 16777216\
    \ (2^24);\n   o  Be at most the group's prime modulus minus 16777216;\n   o  Have\
    \ at least 16 \"1\" bits;\n   o  Have at least 16 \"0\" bits, not including leading\
    \ zeros.\n   An endpoint MUST NOT complete to an S_OPEN session with a far\n \
    \  endpoint using a public key that is not acceptable according to these\n   criteria.\n\
    \   Once the group and corresponding public key of the far end is\n   determined,\
    \ the far end's public key and the near end's private key\n   are combined according\
    \ to Diffie-Hellman [DH] to compute the Diffie-\n   Hellman Shared Secret, an\
    \ integer.\n   In the following sections, DH_SECRET means the Diffie-Hellman Shared\n\
    \   Secret encoded as a byte-aligned unsigned integer in network byte\n   order\
    \ with no leading zero bytes.  For example, if the shared secret\n   is 4886718345,\
    \ DH_SECRET would be the five bytes:\n                            Hex: 01 23 45\
    \ 67 89\n"
- title: 4.6.3.  Packet Encrypt/Decrypt Keys
  contents:
  - "4.6.3.  Packet Encrypt/Decrypt Keys\n   Packets are encrypted using a symmetric\
    \ cipher, such as the Advanced\n   Encryption Standard [AES].  Distinct keys are\
    \ used for sending and\n   receiving packets.  Each end's sending (encrypt) key\
    \ is the other\n   end's receiving (decrypt) key.\n   The raw keys computed in\
    \ this section for encryption and decryption\n   are transformed in a manner specific\
    \ to the cipher with which they\n   are to be used.  In this profile, AES-128\
    \ is the only currently\n   defined cipher.  For this cipher, the first 128 bits\
    \ (16 bytes) of\n   the 256-bit output of the calculation are taken to be the\
    \ AES-128\n   key.\n      Set ENCRYPT_KEY = HMAC-SHA256(DH_SECRET, HMAC-SHA256(SKFC,\
    \ SKNC));\n      Set DECRYPT_KEY = HMAC-SHA256(DH_SECRET, HMAC-SHA256(SKNC, SKFC));\n\
    \   The full 256 bits of ENCRYPT_KEY and DECRYPT_KEY are used in the\n   computations\
    \ in the following sections.\n"
- title: 4.6.4.  Packet HMAC Send/Receive Keys
  contents:
  - "4.6.4.  Packet HMAC Send/Receive Keys\n   Packets can be verified that they were\
    \ not corrupted or modified by\n   appending an HMAC to the packet.  Whether to\
    \ use an HMAC or a simple\n   checksum is determined during the initial keying\
    \ phase using the HMAC\n   Negotiation option (Section 4.5.2.4).  Distinct HMAC\
    \ keys are used\n   for sending and receiving packets.  Each end's sending key\
    \ is the\n   other end's receiving key, and vice versa.\n      Set HMAC_SEND_KEY\
    \ = HMAC_SHA256(DH_SECRET, ENCRYPT_KEY);\n      Set HMAC_RECV_KEY = HMAC_SHA256(DH_SECRET,\
    \ DECRYPT_KEY);\n   If an endpoint sets the willSendAlways flag in its HMAC Negotiation\n\
    \   option, then it MUST send an HMAC on packets it sends with this\n   session\
    \ key.\n   If an endpoint's willSendAlways flag is clear but its\n   willSendOnRequest\
    \ flag is set, then it MUST send an HMAC on packets\n   it sends with this session\
    \ key if and only if the other endpoint's\n   request flag is set.\n   If a sending\
    \ endpoint's willSendAlways and willSendOnRequest flags\n   are clear, then the\
    \ receiving endpoint SHOULD reject that keying\n   component if the receiving\
    \ endpoint is configured to require the\n   sending endpoint to send HMAC.\n \
    \  If HMAC is negotiated to be used, the corresponding hmacLength MUST\n   be\
    \ between 4 and 32 inclusive.\n   If HMAC is negotiated not to be used, a simple\
    \ checksum is used for\n   packet verification.\n   The Default Session Key uses\
    \ the simple checksum and does not use\n   HMAC.\n"
- title: 4.6.5.  Session Nonces
  contents:
  - "4.6.5.  Session Nonces\n   Session nonces are per-session, cryptographically\
    \ strong secret\n   values known only to the two endpoints of the session.  They\
    \ can be\n   used for application-layer cryptographic challenges (such as signing\n\
    \   or password verification).  These nonces are a convenience being pre-\n  \
    \ shared and pre-agreed-upon in a secure manner during the initial\n   keying\
    \ handshake.\n   Each end's near nonce is the other end's far nonce, and vice\
    \ versa.\n      Set NEAR_NONCE = HMAC_SHA256(DH_SECRET, SKNC);\n      Set FAR_NONCE\
    \ = HMAC_SHA256(DH_SECRET, SKFC);\n"
- title: 4.6.6.  Session Sequence Number
  contents:
  - "4.6.6.  Session Sequence Number\n   Duplicate packets can be detected and rejected\
    \ by using an optional\n   session sequence number inside the encrypted packets.\
    \  The session\n   sequence number is a monotonically increasing unbounded integer\
    \ and\n   does not wrap.  Session sequence numbers SHOULD start at zero and\n\
    \   SHOULD increment by one for each packet sent using that session key.\n   Implementations\
    \ MUST handle session sequence numbers with no less\n   than 64 bits of range.\n\
    \   If an endpoint's willSendAlways flag in its Session Sequence Number\n   Negotiation\
    \ option (Section 4.5.2.5) is set, then it MUST send a\n   session sequence number\
    \ in packets it sends with this session key.\n   If an endpoint's willSendAlways\
    \ flag is clear but its\n   willSendOnRequest flag is set, then it MUST send a\
    \ session sequence\n   number on packets it sends with this session key if and\
    \ only if the\n   other endpoint's request flag is set.\n   If a sending endpoint's\
    \ willSendAlways and willSendOnRequest flags\n   are clear, then the receiving\
    \ endpoint SHOULD reject that keying\n   component if the receiving endpoint is\
    \ configured to require the\n   sending endpoint to send session sequence numbers.\n\
    \   The Default Session Key does not use session sequence numbers.\n"
- title: 4.7.  Packet Encryption
  contents:
  - "4.7.  Packet Encryption\n   This section describes the concrete syntax and operational\
    \ semantics\n   of RTMFP packet encryption for this Cryptography Profile.\n"
- title: 4.7.1.  Cipher
  contents:
  - "4.7.1.  Cipher\n   This profile defines AES-128 [AES] in CBC [CBC] mode as the\
    \ only\n   cipher.  Extensions to this profile can specify and negotiate\n   additional\
    \ ciphers and modes by defining certificate and keying\n   component options and\
    \ associated semantics.\n   For AES-128-CBC, the initialization vector (IV) for\
    \ each packet is 16\n   zero bytes.  The IV is not included in the packet.\n"
- title: 4.7.2.  Format
  contents:
  - "4.7.2.  Format\n   The Encrypted Packet is the encryptedPacket field of an RTMFP\n\
    \   Multiplex packet (Section 2.2.2 of RFC 7016); that is, the portion of\n  \
    \ the Multiplex packet following the scrambled session ID.  The\n   Encrypted\
    \ Packet has the following format:\n   +----------------+     +----------------+~~~~~~~~~~~~~~~~~~~~~~~+\n\
    \   |  CBC Block 1   | ... |  CBC Block N   |     truncatedHMAC     |\n   +----------------+\
    \     +----------------+~~~~~~~~~~~~~~~~~~~~~~~+\n   ^                       \
    \                ^                       ^\n   |     Zero or more AES-128 chained\
    \      | hmacLength bytes long |\n   +--------    cipher blocks   -----------+---\
    \  (may be zero)  ---+\n   struct flashProfileEncryptedPacket_t\n   {\n      \
    \ if(HMAC is being used)\n           hmacLength = negotiated length;\n       else\n\
    \           hmacLength = 0;\n       struct\n       {\n           iv[16 bytes]\
    \ = { 0 };\n           blockCount = 0;\n           while((remainder() > hmacLength)\
    \ && (remainder() >= 16))\n           {\n               uint8_t cbcBlock[16];\n\
    \               blockCount++;\n           }\n       } chainedCipherBlocks :variable*16*8;\n\
    \       if(HMAC is being used)\n       {\n           if(remainder() == hmacLength)\n\
    \               uint8_t truncatedHMAC[hmacLength];\n           else\n        \
    \       packetVerificationFailed();\n       }\n       else if(remainder() > 0)\n\
    \           packetVerificationFailed();\n   } :encryptedPacket.length*8;\n   cbcBlock:\
    \  The next AES-128-CBC block.\n   chainedCipherBlocks:  The concatenation of\
    \ every cipher block in the\n      packet (over which the HMAC is computed).\n\
    \   truncatedHMAC:  If HMAC was negotiated to be used (Section 4.5.2.4),\n   \
    \   this field is set to the first negotiated hmacLength bytes of the\n      HMAC\
    \ of the chainedCipherBlocks.\n   The plaintext data before encryption or after\
    \ decryption has the\n   following format:\n    0 1 2 3 4 5 6 7|0 1 2 3 4 5 6\
    \ 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7\n   +~~~~~~~~~~~~~/~+\n   | SSEQ (opt.) \\\
    \ |\n   +~~~~~~~~~~~~~/~+\n   +~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+\n   |        Checksum\
    \ (opt.)        |\n   +~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+\n   +~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~+\n\
    \   |                        Plain RTMFP Packet                     |\n   +~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~/\n\
    \   struct flashProfilePlainPacket_t\n   {\n       if(session sequence numbers\
    \ being used)\n           vlu_t sessionSequenceNumber :variable*8; // SSEQ\n \
    \      if(HMAC not being used)\n           uint16_t checksum;\n       packet_t\
    \ plainRTMFPPacket :variable*8;\n   } :chainedCipherBlocks.blockCount*16*8;\n\
    \   sessionSequenceNumber:  If session sequence numbers were negotiated\n    \
    \  to be used (Section 4.6.6), this field is present and is the VLU\n      session\
    \ sequence number of this packet.\n   checksum:  If HMAC was not negotiated to\
    \ be used, this field is\n      present and is the simple checksum (Section 4.7.3.1)\
    \ of the\n      remaining bytes of this structure.\n   plainRTMFPPacket:  The\
    \ (plain, unencrypted) RTMFP Packet\n      (Section 2.2.4 of RFC 7016) plus any\
    \ necessary padding.\n   When assembling this structure and prior to calculating\
    \ the checksum\n   (if present), if the structure's total length is not an integer\n\
    \   multiple of 16 bytes (the AES cipher block size), pad the end of\n   plainRTMFPPacket\
    \ with as many bytes having a value of 0xff as are\n   needed to bring the structure's\
    \ total length to an integer multiple\n   of 16 bytes.  The receiver's RTMFP Packet\
    \ parser (Section 2.2.4 of\n   RFC 7016) will consume this padding.\n"
- title: 4.7.3.  Verification
  contents:
  - "4.7.3.  Verification\n   In RTMFP, the Cryptography Profile is responsible for\
    \ packet\n   verification.  In this profile, packets are verified with an HMAC\
    \ or\n   a simple checksum, depending on the configuration of the endpoints,\n\
    \   and optionally verified against replay or duplication using session\n   sequence\
    \ numbers.  The simple checksum is inside the encrypted\n   packet, so it becomes\
    \ essentially a 16-bit cryptographic checksum.\n"
- title: 4.7.3.1.  Simple Checksum
  contents:
  - "4.7.3.1.  Simple Checksum\n   The simple checksum is the 16-bit ones' complement\
    \ of the 16-bit\n   ones' complement sum of all 16-bit (2 bytes in network byte\
    \ order)\n   words to be checked.  If there are an odd number of bytes to be\n\
    \   checked, then for purposes of this checksum, treat the last byte as\n   the\
    \ lower 8 bits of a 16-bit word whose upper 8 bits are 0.  This is\n   also known\
    \ as the \"Internet Checksum\" [RFC1071].\n   When present, the checksum is calculated\
    \ over all bytes of the\n   plaintext packet starting after the checksum field\
    \ through the end of\n   the plain packet.  It cannot be calculated until the\
    \ plain packet is\n   padded, if necessary, to bring its length to an integer\
    \ multiple of\n   16 bytes (the AES cipher block size).  The session sequence\
    \ number\n   field, if present, and the checksum field itself are not included\
    \ in\n   the checksum.\n   On receiving a packet being verified with a checksum:\
    \ calculate the\n   checksum over all the bytes of the plaintext packet following\
    \ the\n   checksum field and compare the checksum to the value in the checksum\n\
    \   field.  If they match, the packet is verified; if they do not match,\n   the\
    \ packet is corrupt and MUST be discarded as though it was never\n   received.\n"
- title: 4.7.3.2.  HMAC
  contents:
  - "4.7.3.2.  HMAC\n   When present, the HMAC field is the last hmacLength bytes\
    \ of the\n   packet and is calculated over all of the encrypted cipher blocks\
    \ of\n   the packet preceding the HMAC field.  The value of the HMAC field is\n\
    \   the first hmacLength bytes of the HMAC-SHA256 of the checked data,\n   using\
    \ the computed HMAC keys (Section 4.6.4) and negotiated\n   hmacLength (Section\
    \ 4.5.2.4).  Note each endpoint independently\n   specifies the length of the\
    \ HMAC it will send via its hmacLength\n   field.\n   When an endpoint has negotiated\
    \ to send an HMAC, it encrypts the data\n   blocks, computes the HMAC over the\
    \ encrypted data blocks using its\n   HMAC_SEND_KEY, and appends the first hmacLength\
    \ bytes of that hash\n   after the final encrypted data block.\n   When an endpoint\
    \ has negotiated to receive an HMAC, the endpoint\n   computes the HMAC over the\
    \ encrypted data blocks using its\n   HMAC_RECV_KEY and then compares the first\
    \ receive hmacLength bytes of\n   the computed HMAC to the HMAC field in the packet.\
    \  If they are\n   identical, the packet is verified; if they are not identical,\
    \ the\n   packet is corrupt and MUST be discarded as though it was never\n   received.\n\
    \   HMAC and simple checksum verification are mutually exclusive.\n"
- title: 4.7.3.3.  Session Sequence Number
  contents:
  - "4.7.3.3.  Session Sequence Number\n   Session sequence numbers are used to detect\
    \ and reject a packet that\n   was duplicated in the network or replayed by an\
    \ attacker and to\n   ensure the first chained cipher block of every packet is\
    \ unique, in\n   lieu of a full-block initialization vector.  Sequence numbers\
    \ start\n   at zero, increase by one for each packet sent in the session, do not\n\
    \   wrap, and do not repeat.\n   When session sequence numbers are negotiated\
    \ to be used, the receiver\n   MUST allow for packets to be reordered in the network\
    \ by up to at\n   least 32 sequence numbers; note, however, that reordering by\
    \ more\n   than three packets can trigger loss detection and retransmission by\n\
    \   negative acknowledgement, just as with TCP, and is therefore not\n   likely\
    \ to occur in the real Internet.\n   [RFC4302], [RFC4303], and [RFC6479] describe\
    \ Anti-Replay Window\n   methods that can be employed to detect duplicate sequence\
    \ numbers.\n   Other methods are possible.\n   Any packet received having a session\
    \ sequence number that was already\n   seen in that session, either directly or\
    \ by being less than the\n   lowest sequence number in the Anti-Replay Window,\
    \ is a duplicate and\n   MUST be discarded as though never received.\n"
- title: 5.  Flash Communication
  contents:
  - "5.  Flash Communication\n   The Flash platform uses RTMP [RTMP] messages for\
    \ media streaming and\n   communication.  This section describes how to transport\
    \ RTMP messages\n   over RTMFP flows and additional messages and semantics unique\
    \ to this\n   transport.\n"
- title: 5.1.  RTMP Messages
  contents:
  - "5.1.  RTMP Messages\n   An RTMP message comprises a virtual header and a payload.\
    \  The\n   virtual header comprises a Message Type, a Payload Length, a\n   Timestamp,\
    \ and a Stream ID.  The format of the payload is dependent\n   on the type of\
    \ message.\n   An RTMP message is mapped onto a lower transport layer, such as\
    \ RTMP\n   Chunk Stream [RTMP] or RTMFP.  RTMP messages were initially designed\n\
    \   along with, and for transport on, RTMP Chunk Stream.  This design\n   constrains\
    \ the possible values of RTMP message header fields.  In\n   particular:\n   \
    \   Message Type is 8 bits wide, and is therefore constrained to\n      values\
    \ from 0 to 255 inclusive;\n      Payload Length is 24 bits wide, so messages\
    \ can be at most\n      16777215 bytes long;\n      Timestamp is 32 bits wide,\
    \ so timestamps range from 0 to\n      4294967295 and wrap around;\n      Stream\
    \ ID is 24 bits wide, and is therefore constrained to values\n      from 0 to\
    \ 16777215 inclusive.\n   RTMP Chunk Stream Protocol Control messages (message\
    \ types 1, 2, 3,\n   5, and 6) are not used when transporting RTMP messages in\
    \ RTMFP\n   flows.  Messages of those types SHOULD NOT be sent and MUST be\n \
    \  ignored.\n"
- title: 5.1.1.  Flow Metadata
  contents:
  - "5.1.1.  Flow Metadata\n   All messages in RTMFP are transported in flows.  In\
    \ this profile, an\n   RTMFP flow for RTMP messages carries the messages for exactly\
    \ one\n   RTMP Stream ID.  Multiple flows can carry messages for the same\n  \
    \ Stream ID; for example, the video and audio messages of a stream\n   could be\
    \ sent on separate flows, allowing the audio to be given\n   higher transmission\
    \ priority.\n   The User Metadata for flows in this profile begins with a distinct\n\
    \   signature to distinguish among different kinds of flows.  The User\n   Metadata\
    \ for a flow used for RTMP messages begins with the two-\n   character signature\
    \ \"TC\".\n   The Stream ID is encoded in the flow's User Metadata so that it\n\
    \   doesn't need to be sent with each message.\n   The sender can have a priori\
    \ knowledge about the kind of media it\n   intends to send on a flow and its intended\
    \ use and can give the\n   receiver a hint as to whether messages should be delivered\
    \ as soon as\n   possible or in their original queuing order.  For example, the\
    \ sender\n   might be sending real-time, delay-sensitive audio messages on a flow,\n\
    \   and hint that the receiver should take delivery of the messages on\n   that\
    \ flow as soon as they arrive in the network, to reduce the end-\n   to-end latency\
    \ of the audio.\n   The receiver can choose to take delivery of messages on flows\
    \ as soon\n   as they arrive in the network or in the messages' original queuing\n\
    \   order.  A receiver that chooses to take delivery of messages as soon\n   as\
    \ they arrive in the network MUST be prepared for the messages to\n   arrive out-of-order.\
    \  For example, a receiver may choose not to\n   render a newly received audio\
    \ message having a timestamp earlier than\n   the most recently rendered audio\
    \ timestamp.\n   The sender can choose to abandon a message that it has queued\
    \ in a\n   flow before the message has been delivered to the receiver.  For\n\
    \   example, the sender may abandon a real-time, delay-sensitive audio\n   message\
    \ that has not been delivered within one second, to avoid\n   spending transmission\
    \ resources on stale media that is no longer\n   relevant.\n   Note: A gap will\
    \ cause a delay at the receiver of at least one round-\n   trip time if the receiver\
    \ is taking delivery of messages in original\n   queuing order.\n    0 1 2 3 4\
    \ 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+~~~~~~~~~~~~~/~+\n\
    \   |               |               |         |S|r|R|             \\ |\n   | \
    \  0x54  'T'   |   0x43  'C'   |   rsv   |I|s|X|   streamID  / |\n   |       \
    \        |               |         |D|v|I|             \\ |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+~~~~~~~~~~~~~/~+\n\
    \   struct RTMPMetadata_t\n   {\n       uint8_t signature[2] == { 'T', 'C' };\n\
    \       uintn_t reserved1       :5; // rsv\n       bool_t  streamIDPresent :1;\
    \ // SID\n       uintn_t reserved2       :1; // rsv\n       uintn_t receiveIntent\
    \   :1; // RXI\n           // 0: original queuing order, 1: network arrival order\n\
    \       if(streamIDPresent)\n           vlu_t   streamID        :variable*8;\n\
    \   } :variable*8;\n   signature:  Metadata signature for RTMP message flows,\
    \ being the two\n      UTF-8 coded characters \"TC\".\n   streamIDPresent:  A\
    \ boolean flag indicating whether the streamID\n      field is present.  In this\
    \ profile, this flag MUST be set.\n   receiveIntent:  A hint by the sender as\
    \ to the best order in which to\n      take delivery of messages from the flow.\
    \  A value of zero\n      indicates a hint that the flow's messages should be\
    \ received in\n      the order they were originally queued by the sender (that\
    \ is, in\n      ascending sequence number order); a value of one indicates a hint\n\
    \      that the flow's messages should be received in the order they\n      arrive\
    \ in the network, even if there are sequence number gaps or\n      reordering.\
    \  Network arrival order is typically hinted for live,\n      delay-sensitive\
    \ flows, such as for audio media.  To take delivery\n      of a message as soon\
    \ as it arrives in the network: receive it from\n      the receiving flow's RECV_BUFFER\
    \ as soon as it becomes complete\n      (Section 3.6.3.3 of RFC 7016), and remove\
    \ it from the RECV_BUFFER.\n      Section 3.6.3.3 of RFC 7016 describes how to\
    \ take delivery of\n      messages in original queuing order.\n   streamID:  If\
    \ the streamIDPresent flag is set, this field is present\n      and is the RTMP\
    \ stream ID to which the messages in this flow\n      belong.  In this profile,\
    \ this field MUST be present.\n   A receiver SHOULD reject an RTMP message flow\
    \ if its streamIDPresent\n   flag is clear.  This profile doesn't define a stream\
    \ mapping for this\n   case.\n   Derived or composed profiles can define additional\
    \ flow types and\n   corresponding metadata signatures.  A receiver SHOULD reject\
    \ a flow\n   having an unrecognized metadata signature.\n"
- title: 5.1.2.  Message Mapping
  contents:
  - "5.1.2.  Message Mapping\n   This section describes the format of an RTMP message\
    \ (Section 5.1) in\n   an RTMFP flow.\n    0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1\
    \ 2 3 4 5 6 7|0 1 2 3 4 5 6 7\n   +-+-+-+-+-+-+-+-+\n   |  messageType  |\n  \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   |    \
    \                       timestamp                           |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                         messagePayload                        |\n   +~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~/\n\
    \   struct RTMPMessage_t\n   {\n       uint8_t  messageType;\n       uint32_t\
    \ timestamp;\n       uint8_t  messagePayload[remainder()];\n   } :flowMessageLength*8;\n\
    \   messageType:  The RTMP Message Type;\n   timestamp:  The RTMP Timestamp, in\
    \ network byte order;\n   messagePayload:  The payload of the RTMP message;\n\
    \   payload length:  The RTMP message payload length is inferred from the\n  \
    \    length of the RTMFP message;\n   Stream ID:  The Stream ID for this message\
    \ is taken from the metadata\n      of the flow on which this message was received.\n"
- title: 5.2.  Flow Synchronization
  contents:
  - "5.2.  Flow Synchronization\n   RTMFP flows are independent and have no inter-flow\
    \ ordering\n   guarantee.  RTMP was designed for transport over a single, reliable,\n\
    \   strictly ordered byte stream.  Some RTMP message semantics take\n   advantage\
    \ of this ordering; for example, a Stream EOF User Control\n   event must not\
    \ be processed until after all media messages for the\n   corresponding stream\
    \ have been received.  Flow Synchronization\n   messages provide a barrier to\
    \ align message delivery across flows\n   when required by RTMP semantics.\n \
    \  A Flow Synchronization message is coded as a User Control event\n   message\
    \ (Type 4) having Event Type 34.  Message timestamps are\n   ignored and MAY be\
    \ set to 0.\n    0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6\
    \ 7\n   +-+-+-+-+-+-+-+-+\n   |       4       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                           timestamp                           |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |         eventType = 34        |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                             syncID                            |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                             count                             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   struct flowSyncUserControlMessagePayload_t\n   {\n       uint16_t eventType\
    \ = 34;\n       uint32_t syncID;\n       uint32_t count;\n   } :10*8;\n   eventType:\
    \  The RTMP User Control Message Event Type.  Flow\n      Synchronization messages\
    \ have type 34 (0x22);\n   syncID:  The identifier for this barrier;\n   count:\
    \  The number of flows being synchronized by syncID.  This field\n      MUST be\
    \ at least 1 and SHOULD be at least 2.\n   On receipt of a Flow Synchronization\
    \ message, a receiver SHOULD\n   suspend receipt of further messages on that flow\
    \ until count Flow\n   Synchronization messages (including this one) with the\
    \ same syncID\n   have been received on flows in the same flow association tree.\n\
    \   Example: Consider flows F1 and F2 in the same NetConnection carrying\n   messages\
    \ M, and let Sync(syncID,count) denote a Flow Synchronization\n   message.\n \
    \                                      |                |\n             F1: M1\
    \  M2  M4  Sync(8,2) | Sync(13,2).....| M7\n                                 \
    \      |                |\n             F2:   M3  Sync(8,2).......| M5  Sync(13,2)\
    \ | M6\n                                       |                |\n          \
    \                         Barrier 8        Barrier 13\n              Figure 2:\
    \ Example Flow Synchronization Barriers\n   Flow Synchronization messages form\
    \ a delivery barrier to impart at\n   least a partial message ordering across\
    \ flows.  In this example,\n   message M5 comes after M1..4 and before M6..7;\
    \ however, M3 could be\n   delivered before or after any of M1, M2, or M4, and\
    \ M6 could come\n   before or after M7.\n   Flow Synchronization can cause a priority\
    \ inversion; therefore, it\n   SHOULD NOT be used except when necessary to preserve\
    \ RTMP ordering\n   semantics.\n"
- title: 5.3.  Client-to-Server Connection
  contents:
  - "5.3.  Client-to-Server Connection\n   The client connects to a server.  The connection\
    \ comprises one main\n   control flow in each direction from client to server\
    \ and from server\n   to client for NetConnection messages, and zero or more flows\
    \ in each\n   direction for NetStream media messages.  NetStream flows may come\
    \ and\n   go naturally over time according to media transport needs.  An\n   exception\
    \ on a NetConnection control sending flow indicates the\n   closure by the other\
    \ end of the NetConnection and all associated\n   NetStreams.\n   The client MUST\
    \ NOT use the same client certificate for more than one\n   server connection;\
    \ that is, a client's peer ID MUST NOT be reused.\n"
- title: 5.3.1.  Connecting
  contents:
  - "5.3.1.  Connecting\n   The client desires a connection to a server having an\
    \ RTMFP URI, for\n   example, \"rtmfp://server.example.com/app/instance\".  The\
    \ client\n   gathers one or more initial candidate addresses for the server named\n\
    \   in the URI (for example, by using the Domain Name System (DNS)\n   [RFC1035]).\
    \  The client creates an EPD having an Ancillary Data\n   option (Section 4.4.2.2)\
    \ encoding the URI.  The client initiates an\n   RTMFP session to the one or more\
    \ candidate addresses using the EPD.\n   When the session transitions to the S_OPEN\
    \ state, the client opens a\n   new flow in that session for Stream ID 0 and Receive\
    \ Intent 0\n   \"original queuing order\".  This is the client's NetConnection\
    \ main\n   control flow.  The client sends an RTMP \"connect\" command on the\
    \ flow\n   and waits for a response or exception.\n"
- title: 5.3.2.  Server-to-Client Return Control Flow
  contents:
  - "5.3.2.  Server-to-Client Return Control Flow\n   The server, on accepting the\
    \ client's NetConnection control flow, and\n   receiving and accepting the \"\
    connect\" command, opens one or more\n   return flows to the client having Stream\
    \ ID 0 and associated to the\n   control flow from the client.  Flows for Stream\
    \ ID 0 are the server's\n   NetConnection control flows.  The server sends a \"\
    _result\" or\n   \"_error\" transaction response for the client's connect command.\n\
    \   When the client receives the first return flow from the server for\n   Stream\
    \ ID 0 and associated to the client's NetConnection control\n   flow, the client\
    \ assumes that flow is the canonical return\n   NetConnection control flow from\
    \ the server, to which all new client-\n   to-server flows should be associated.\n\
    \   On receipt of a \"_result\" transaction response on Stream ID 0 for the\n\
    \   client's connect command, the connection is up.\n   The client MAY open additional\
    \ return control flows to the server on\n   Stream ID 0, associated to the server's\
    \ canonical NetConnection\n   control flow.\n"
- title: 5.3.3.  setPeerInfo Command
  contents:
  - "5.3.3.  setPeerInfo Command\n   The \"setPeerInfo\" command is sent by the client\
    \ to the server over\n   the NetConnection control flow to inform the server of\
    \ candidate\n   socket addresses through which the client might be reachable.\
    \  This\n   list SHOULD include all directly connected interface addresses and\n\
    \   proxy addresses except as provided below.  The list MAY be empty.\n   The\
    \ list need not include the address of the server, even if the\n   server is to\
    \ act as an introducer for the client.  The list SHOULD\n   NOT include link-local\
    \ or loopback addresses.\n   This command is sent as a regular RTMP NetConnection\
    \ command; that\n   is, as an RTMP Type 20 Command Message or an RTMP Type 17\
    \ Command\n   Extended Message on Stream ID 0.  A Type 20 Command Message SHOULD\
    \ be\n   used if the object encoding negotiated during the \"connect\" and\n \
    \  \"_result\" handshake is AMF0 [AMF0], and a Type 17 Command Extended\n   Message\
    \ SHOULD be used if the negotiated object encoding is AMF3\n   [AMF3].\n   Note:\
    \ A Type 20 Command Message payload is a sequence of AMF objects\n   encoded in\
    \ AMF0.\n   Note: A Type 17 Command Extended Message payload begins with a format\n\
    \   selector byte, followed by a sequence of objects in a format-specific\n  \
    \ encoding.  At the time of writing, only format 0 is defined;\n   therefore,\
    \ the format selector byte MUST be 0.  Format 0 is a\n   sequence of AMF objects,\
    \ each encoded in AMF0 by default; AMF3\n   encoding for an object can be selected\
    \ by prefixing it with an\n   \"avmplus-object-marker\" (0x11) as defined in [AMF0].\n\
    \   To complete the RTMFP NetConnection handshake, an RTMFP client MUST\n   send\
    \ a setPeerInfo command to the server after receiving a successful\n   response\
    \ to the \"connect\" command.\n   (\n       \"setPeerInfo\", // AMF String, command\
    \ name\n       0.0,  // AMF Number, transaction ID\n       NULL, // AMF Null,\
    \ no command object\n       ...   // zero or more AMF Strings, each an address\n\
    \   )\n   Each listed socket address includes an IPv4 or IPv6 address in\n   presentation\
    \ format and a UDP port number in decimal, separated by a\n   colon.  Since the\
    \ IPv6 address presentation format uses colons, IPv6\n   addresses are enclosed\
    \ in square brackets [RFC3986].\n                        (\n                 \
    \           \"setPeerInfo\",\n                            0.0,\n             \
    \               NULL,\n                            \"192.0.2.129:50001\",\n  \
    \                          \"[2001:db8:1::2]:50002\"\n                       \
    \ )\n                   Figure 3: Example setPeerInfo Command\n   A server SHOULD\
    \ assume that the client is behind a Network Address\n   Translator (NAT) if and\
    \ only if the observed far endpoint address of\n   the session for the flow on\
    \ which this command was received does not\n   appear in the setPeerInfo address\
    \ list.\n"
- title: 5.3.4.  Set Keepalive Timers Command
  contents:
  - "5.3.4.  Set Keepalive Timers Command\n   The server can advise the client to\
    \ set or change the client's\n   session keepalive timer periods for its connection\
    \ to the server and\n   for its P2P connections.  The server MAY choose keepalive\
    \ periods\n   based on static configuration, application- or deployment-specific\n\
    \   circumstances, whether the client appears to be behind a NAT, or for\n   any\
    \ other reason.\n   The Set Keepalive Timers command is sent by the server to\
    \ the client\n   on Stream ID 0 as a User Control event message (Type 4) having\
    \ Event\n   Type 41.  Message timestamps are ignored and MAY be set to 0.\n  \
    \  0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7\n   +-+-+-+-+-+-+-+-+\n\
    \   |       4       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                           timestamp                           |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |         eventType = 41        |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                    serverKeepalivePeriodMsec                  |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                     peerKeepalivePeriodMsec                   |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   struct setKeepaliveUserControlMessagePayload_t\n   {\n       uint16_t eventType\
    \ = 41;\n       uint32_t serverKeepalivePeriodMsec;\n       uint32_t peerKeepalivePeriodMsec;\n\
    \   } :10*8;\n   eventType:  The RTMP User Control Message Event Type.  Set Keepalive\n\
    \      Timers messages have type 41 (0x29);\n   serverKeepalivePeriodMsec:  The\
    \ keepalive period, in milliseconds,\n      that the client is advised to set\
    \ on its RTMFP session with the\n      server;\n   peerKeepalivePeriodMsec:  The\
    \ keepalive period, in milliseconds, that\n      the client is advised to use\
    \ on its RTMFP sessions with any peer\n      that is not the server.\n   The client\
    \ MUST define minimum values for these keepalive periods,\n   below which it will\
    \ not set them, regardless of the values in this\n   message.  The minimum keepalive\
    \ timer periods SHOULD be at least five\n   seconds.  The client MAY define maximum\
    \ values for these keepalive\n   periods, above which it will not set them.\n\
    \   On receipt of this message from the server, a client SHOULD set its\n   RTMFP\
    \ server and peer keepalive timer periods to the indicated values\n   subject\
    \ to the client's minimum and maximum values.  The server MAY\n   send this message\
    \ more than once, particularly if conditions that it\n   uses to determine the\
    \ timer periods change.\n"
- title: 5.3.5.  Additional Flows for Streams
  contents:
  - "5.3.5.  Additional Flows for Streams\n   The client or server opens additional\
    \ flows to the other side to\n   carry messages for any stream.  Additional flows\
    \ are associated to\n   the canonical NetConnection control flow from the other\
    \ side.\n         Client                                            Server\n \
    \        ------>--C2S-Control-Flow------------------------->--+\n            \
    \                                                  |\n            +--<------------------------S2C-Control-Flow---<--+\n\
    \            |                                                 |\n           \
    \ |  <------------------------S2C-Stream-Flow-1--<--+\n            |         \
    \                         :              |\n            |  <------------------------S2C-Stream-Flow-M--<--+\n\
    \            |\n            +-->--C2S-Stream-Flow-1------------------------>\n\
    \            |               :\n            +-->--C2S-Stream-Flow-N------------------------>\n\
    \       Figure 4: Schematic Flow Association Tree for a NetConnection\n"
- title: 5.3.5.1.  To Server
  contents:
  - "5.3.5.1.  To Server\n   Additional flows from the client to the server for stream\
    \ messages\n   are opened with the Stream ID for that stream and associated in\n\
    \   return to the server's canonical NetConnection control flow.\n   The client\
    \ MAY create as many flows as desired for any Stream ID\n   (including Stream\
    \ ID 0) at any time.\n"
- title: 5.3.5.2.  From Server
  contents:
  - "5.3.5.2.  From Server\n   Additional flows from the server to the client for\
    \ stream messages\n   are opened with the Stream ID for that stream, and associated\
    \ in\n   return to the client's NetConnection control flow.\n   The server MAY\
    \ create as many flows as desired for any Stream ID\n   (including Stream ID 0)\
    \ at any time.\n"
- title: 5.3.5.3.  Closing Stream Flows
  contents:
  - "5.3.5.3.  Closing Stream Flows\n   Either end MAY close a sending flow that is\
    \ not for Stream ID 0 at\n   any time with no semantic meaning for the stream.\n\
    \   At any time, either end MAY reject a receiving flow that is not one\n   of\
    \ the other end's NetConnection control flows.  No flow exception\n   codes are\
    \ defined by this profile, so the receiving end SHOULD use\n   exception code\
    \ 0 when rejecting the flow.  The sending end, on\n   notification of any exception\
    \ for a stream flow, SHOULD NOT open a\n   new flow to take the rejected flow's\
    \ place for transport of messages\n   for that stream.  If an end rejects any\
    \ flow for a stream, it SHOULD\n   reject all the flows for that stream, otherwise\
    \ Flow Synchronization\n   messages (Section 5.2) that were in flight could be\
    \ discarded and\n   some flows might become or remain stuck in a suspended state.\n"
- title: 5.3.6.  Closing the Connection
  contents:
  - "5.3.6.  Closing the Connection\n   The client or server can signal an orderly\
    \ close of the connection by\n   closing its NetConnection control sending flows\
    \ and all stream\n   sending flows.  The other end, on receiving a close/complete\n\
    \   notification for the canonical NetConnection control receiving flow,\n   closes\
    \ its sending flows.  When both ends observe all receiving flows\n   have closed\
    \ and completed, the connection has cleanly terminated.\n   Either end can abruptly\
    \ terminate the connection by rejecting the\n   NetConnection control receiving\
    \ flows or by closing the underlying\n   RTMFP session.  On notification of any\
    \ exception on a NetConnection\n   control sending flow, the end seeing the exception\
    \ knows the other\n   end has terminated abruptly, and can immediately close all\
    \ sending\n   and receiving flows for that connection.\n"
- title: 5.3.7.  Example
  contents:
  - "5.3.7.  Example\n                 Client                    Server\n        \
    \           |IHello (EPD:anc=URI)     |\n               -+- |------------------------>|\n\
    \                |  |                         |\n                |  |       RHello\
    \ (RCert:anc)|\n          RTMFP |  |<------------------------|\n         Session|\
    \  |                         |\n          Hand- |  |IIKeying                 |\n\
    \          shake |  |------------------------>|\n                |  |        \
    \                 |\n                |  |                 RIKeying|\n        \
    \       -+- |<------------------------|\n                   |                \
    \         |\n               -+- |\"connect\" command        |\n         (Str.ID=0)|-CFlow-0---------------->|\n\
    \                |  |                         |\n                |  |       \"\
    _result\" response|\n          RTMP  |  |<----------------SFlow-0-|(Str.ID=0,\n\
    \         Connect|  |                         | Assoc=CFlow-0)\n          Hand-\
    \ |  |\"setPeerInfo\" command    |\n          shake |  |-CFlow-0---------------->|\n\
    \               -+- |                         |\n                   |\"createStream\"\
    \ command   |\n               -+- |-CFlow-0---------------->|\n              \
    \  |  |                         |\n                |  |     \"_result\" (str.ID=5)|\n\
    \                |  |<----------------SFlow-0-|\n                |  |        \
    \                 |\n                |  |\"play\" command           |\n      \
    \   (Str.ID=5,|-CFlow-1---------------->|\n     Assoc=SFlow-0)|              \
    \           |\n                |  | StreamBegin User Control|\n              \
    \  |  |<----------------SFlow-1-|(Str.ID=5,\n                |  |            \
    \             | Assoc=CFlow-0)\n                |  |  (RTMP stream events)   |\n\
    \     Streaming  |  |<----------------SFlow-1-|\n                |  |        \
    \                 |\n                |  |        Audio Data       |\n        \
    \        |  |<----------------SFlow-2-|(Str.ID=5,\n                |  |      \
    \                   | Assoc=CFlow-0)\n                |  |        Video Data \
    \      |\n                |  |<----------------SFlow-3-|(Str.ID=5,\n         \
    \       |  |            :            | Assoc=CFlow-0)\n                   |  \
    \          :            |\n             Figure 5: Example NetConnection Message\
    \ Exchange\n"
- title: 5.4.  Direct Peer-to-Peer Streams
  contents:
  - "5.4.  Direct Peer-to-Peer Streams\n   Clients can connect directly to other clients\
    \ for P2P streaming and\n   data exchange.  A client MAY have multiple separate\
    \ P2P NetStreams\n   with a peer in one RTMFP session, each a separate logical\
    \ connection.\n   P2P NetStreams are unidirectional, initiated by a subscriber\
    \ (the\n   side issuing the \"play\" command) to a publisher.  The subscribing\n\
    \   peer has a control flow to the publisher.  The publisher has zero or\n   more\
    \ return flows to the subscriber associated to the subscriber's\n   control flow,\
    \ for the stream media and data.\n"
- title: 5.4.1.  Connecting
  contents:
  - "5.4.1.  Connecting\n   A client desires to subscribe directly to a stream being\
    \ published in\n   P2P mode by a publishing peer.  The client learns the peer\
    \ ID of the\n   publisher and the stream name through application-specific means.\n\
    \   If the client does not already have an RTMFP session with that peer\n   ID,\
    \ it initiates a new session, creating an EPD containing a\n   Fingerprint option\
    \ (Section 4.4.2.3) for the publisher's peer ID and\n   using the server session's\
    \ DESTADDR as the initial candidate address\n   for the session to the peer. \
    \ The server acts as an Introducer\n   (Section 3.5.1.6 of RFC 7016), using forward\
    \ and redirect messages to\n   help the client and the peer establish a session.\n\
    \   When an S_OPEN session exists to the desired peer, the client creates\n  \
    \ a new independent flow to that peer.  The flow MUST have a non-zero\n   Stream\
    \ ID.  The client sends an RTMP \"play\" command over the flow,\n   giving the\
    \ name of the desired stream at the publisher.  This flow is\n   the subscriber's\
    \ control flow.\n"
- title: 5.4.2.  Return Flows for Stream
  contents:
  - "5.4.2.  Return Flows for Stream\n   The publisher, on accepting a new flow not\
    \ indicating a return\n   association with any of its sending flows and having\
    \ a non-zero\n   Stream ID, receives and processes the \"play\" command.  If and\
    \ when\n   the request is acceptable to the publisher, it opens one or more\n\
    \   return flows to the subscribing peer, associated to the subscriber's\n   control\
    \ flow and having the same Stream ID.  The publisher sends a\n   StreamBegin User\
    \ Control message, appropriate RTMP status events, and\n   the stream media over\
    \ the one or more return flows.\n   The subscriber uses the return association\
    \ of the media flows to the\n   subscriber control flow to determine the stream\
    \ to which the media\n   belongs.\n   The publisher MAY open any number of media\
    \ flows for the stream and\n   close them at any time.  The opening and closing\
    \ of media flows has\n   no semantic meaning for the stream, except that the opening\
    \ of at\n   least one flow and the reception of at least one media message or\
    \ a\n   StreamBegin User Control message indicates that the publisher is\n   publishing\
    \ the requested stream to the subscriber.\n         Subscriber               \
    \                      Publisher\n         ------>--Subscriber-Control-Flow------------------>--+\n\
    \                                                              |\n           \
    \    <------------------Publisher-Stream-Flow-1--<--+\n                      \
    \                        :               |\n               <------------------Publisher-Stream-Flow-N--<--+\n\
    \   Figure 6: Schematic Flow Association Tree for a P2P Direct Connection\n"
- title: 5.4.3.  Closing the Connection
  contents:
  - "5.4.3.  Closing the Connection\n   Either end can close the stream by closing\
    \ or rejecting the\n   subscriber's control flow.  The publisher SHOULD close\
    \ and unpublish\n   to the subscriber on receipt of a close/complete of the control\
    \ flow.\n   The subscriber SHOULD consider the stream closed on notification of\n\
    \   any exception on the control flow.\n"
- title: 6.  IANA Considerations
  contents:
  - "6.  IANA Considerations\n   This memo specifies option type code values for Certificate\
    \ fields\n   (Section 4.3.3), Endpoint Discriminator fields (Section 4.4.2), and\n\
    \   Session Keying Component fields (Section 4.5.2).  It also specifies a\n  \
    \ flow metadata signature (Section 5.1.1).  The type code values and\n   signatures\
    \ for this profile are assigned and maintained by Adobe, and\n   therefore require\
    \ no action from IANA.\n"
- title: 6.1.  RTMFP URI Scheme Registration
  contents:
  - "6.1.  RTMFP URI Scheme Registration\n   This memo describes use of an RTMFP URI\
    \ scheme (Section 4.4.2.2,\n   Section 5.3.1, Figure 5).  Per this section, the\
    \ \"rtmfp\" URI scheme\n   has been registered by IANA.\n   The syntax and semantics\
    \ of this URI scheme are described using the\n   Augmented Backus-Naur Form (ABNF)\
    \ [RFC5234] rules from RFC 3986.\n   URI scheme name:  rtmfp\n   Status:  provisional\n\
    \   URI scheme syntax:\n      rtmfp-uri-scheme = \"rtmfp:\"\n                \
    \       / \"rtmfp://\" host [ \":\" port ] path-abempty\n   URI scheme semantics:\
    \  The first form is used in the APIs of some\n      implementations to indicate\
    \ instantiation of an RTMFP client\n      according to this memo, but without\
    \ connecting to a server.  Such\n      an instantiation might be used for pure\
    \ peer-to-peer\n      communication.\n      The second form provides location\
    \ information for the server to\n      which to connect and optional additional\
    \ information to pass to\n      the server.  The only operation for this URI form\
    \ is to connect to\n      a server (initial candidate address(es) for which are\
    \ named by\n      host and port) according to Section 5.3.  The UDP port for initial\n\
    \      candidate addresses, if not specified, is 1935.  If the host is a\n   \
    \   reg-name, the initial candidate address set SHOULD comprise all\n      IPv4\
    \ and IPv6 addresses to which reg-name resolves.  The semantics\n      of path-abempty\
    \ are specific to the server.  Connections are made\n      using RTMFP as specified\
    \ by this memo.\n   Encoding considerations:  The path-abempty component represents\n\
    \      textual data consisting of characters from the Universal Character\n  \
    \    Set.  This component SHOULD be encoded according to Section 2.5 of\n    \
    \  RFC 3986.\n   Applications/protocols that use this URI scheme name:  The Flash\n\
    \      runtime (including Flash Player) from Adobe Systems Incorporated,\n   \
    \   communication servers such as Adobe Media Server, and\n      interoperable\
    \ clients and servers provided by other parties, using\n      RTMFP according\
    \ to this memo.\n   Interoperability considerations:  This scheme requires use\
    \ of RTMFP\n      as defined by RFC 7016 in the manner described by this memo.\n\
    \   Security considerations:  See Security Considerations (Section 7) in\n   \
    \   this memo.\n   Contact:  Michael Thornburgh, Adobe Systems Incorporated,\n\
    \      <mthornbu@adobe.com>.\n   Author/Change controller:  Michael Thornburgh,\
    \ Adobe Systems\n      Incorporated, <mthornbu@adobe.com>.\n   References:\n \
    \     Thornburgh, M., \"Adobe's Secure Real-Time Media Flow Protocol\",\n    \
    \  RFC 7016, November 2013.\n      This memo.\n"
- title: 7.  Security Considerations
  contents:
  - "7.  Security Considerations\n   Section 4 details the cryptographic aspects of\
    \ this profile.\n   This profile does not define or use a Public Key Infrastructure\n\
    \   (PKI).  Clients SHOULD use static Diffie-Hellman keys in their\n   certificates\
    \ (Section 4.3.3.5).  Clients MUST create a new\n   certificate with a distinct\
    \ fingerprint for each new NetConnection\n   (Section 5.3).  These constraints\
    \ make client identities ephemeral\n   but unable to be forged.  A man-in-the-middle\
    \ cannot successfully\n   interpose itself in a connection to a target client\
    \ addressed by its\n   fingerprint/peer ID if the target client uses a static\
    \ Diffie-Hellman\n   public key.\n   Servers can have long-lived RTMFP instances,\
    \ so they SHOULD use\n   ephemeral Diffie-Hellman public keys for forward secrecy.\
    \  This\n   allows server peer IDs to be forged; however, clients do not connect\n\
    \   to servers by peer ID, so this is irrelevant.\n   When a client connects to\
    \ a server, the client will accept the\n   response of any endpoint claiming to\
    \ be \"a server\".  It is assumed\n   that an attacker that can passively observe\
    \ traffic on a network\n   segment can also inject its own packets with any source\
    \ or\n   destination and any payload.  An attacker can trick a client into\n \
    \  connecting to a rogue server or man-in-the-middle, either by\n   observing\
    \ Initiator Hello packets from the client and responding\n   earliest with a matching\
    \ Responder Hello or by using tricks such as\n   DNS spoofing or poisoning to\
    \ direct a client to connect directly to\n   the rogue.  A TCP-based transport\
    \ would be vulnerable to similar\n   attacks.  Since there is no PKI, this profile\
    \ gives no guarantee that\n   the client has actually connected to the desired\
    \ server, versus a\n   rogue or man-in-the-middle.  In circumstances where assurance\
    \ is\n   required that the connection is directly to the desired server, the\n\
    \   client can use the Session Nonces (Section 4.6.5) to challenge the\n   server,\
    \ for example, over a different channel having acceptable\n   security properties\
    \ (such as an HTTPS) to transitively establish the\n   server's identity and verify\
    \ that the end-to-end communication is\n   private and authentic.\n   When session\
    \ sequence numbers (Section 4.7.3.3) are not used, it is\n   possible for an attacker\
    \ to use traffic analysis techniques and\n   record encrypted packets containing\
    \ the start of a new flow, and\n   later to replay those packets after the flow\
    \ has closed, which can\n   look to the receiver like a brand new flow.  In circumstances\
    \ where\n   this can be detrimental, session sequence numbers SHOULD be used.\n\
    \   Replay of packets for existing flows is not detrimental as the\n   receiver\
    \ detects and discards duplicate flow sequence numbers, and\n   flow sequence\
    \ numbers do not wrap or otherwise repeat.\n   Packet encryption uses CBC with\
    \ the same (null) initialization vector\n   for each packet.  This can reveal\
    \ to an observer whether two packets\n   contain identical plaintext.  However,\
    \ the maximum-length RTMFP\n   common header and User Data or Data Acknowledgement\
    \ header, including\n   flow sequence number, always fit within the first 16-byte\
    \ cipher\n   block, so each initial cipher block for most packets will already\
    \ be\n   unique even if timestamps are suppressed.  Sending identical messages\n\
    \   in a flow uses unique flow sequence numbers, so cipher blocks will be\n  \
    \ unique in this case.  Keepalive pings and retransmission of lost data\n   can\
    \ result in identical cipher blocks; however, traffic analysis can\n   also reveal\
    \ likely keepalives or retransmissions, and retransmission\n   only occurs as\
    \ a result of observable network loss, so this is\n   usually irrelevant.  In\
    \ circumstances where any identical cipher\n   block is unacceptable, session\
    \ sequence numbers SHOULD be used as\n   they guarantee each initial cipher block\
    \ will be unique.\n   Packet verification can use a 16-bit simple checksum\n \
    \  (Section 4.7.3.1).  The checksum is inside the encrypted packet, so\n   for\
    \ external packet modifications the checksum is equivalent to a\n   16-bit cryptographic\
    \ digest.  In circumstances where this is\n   insufficient, HMAC verification\
    \ (Section 4.7.3.2) SHOULD be used.\n"
- title: 8.  References
  contents:
  - '8.  References

    '
- title: 8.1.  Normative References
  contents:
  - "8.1.  Normative References\n   [AES]      National Institute of Standards and\
    \ Technology, \"Advanced\n              Encryption Standard (AES)\", FIPS PUB\
    \ 197, November 2001,\n              <http://csrc.nist.gov/publications/fips/fips197/\n\
    \              fips-197.pdf>.\n   [AMF0]     Adobe Systems Incorporated, \"Action\
    \ Message Format -- AMF\n              0\", December 2007, <http://www.adobe.com/go/spec_amf0>.\n\
    \   [AMF3]     Adobe Systems Incorporated, \"Action Message Format -- AMF\n  \
    \            3\", January 2013, <http://www.adobe.com/go/spec_amf3>.\n   [CBC]\
    \      Dworkin, M., \"Recommendation for Block Cipher Modes of\n             \
    \ Operation\", NIST Special Publication 800-38A, December\n              2001,\
    \ <http://csrc.nist.gov/publications/nistpubs/800-38a/\n              sp800-38a.pdf>.\n\
    \   [DH]       Diffie, W. and M. Hellman, \"New Directions in\n              Cryptography\"\
    , IEEE Transactions on Information Theory, V.\n              IT-22, n. 6, June\
    \ 1977.\n   [RFC2104]  Krawczyk, H., Bellare, M., and R. Canetti, \"HMAC: Keyed-\n\
    \              Hashing for Message Authentication\", RFC 2104, February\n    \
    \          1997, <http://www.rfc-editor.org/info/rfc2104>.\n   [RFC2119]  Bradner,\
    \ S., \"Key words for use in RFCs to Indicate\n              Requirement Levels\"\
    , BCP 14, RFC 2119, March 1997,\n              <http://www.rfc-editor.org/info/rfc2119>.\n\
    \   [RFC3526]  Kivinen, T. and M. Kojo, \"More Modular Exponential (MODP)\n  \
    \            Diffie-Hellman groups for Internet Key Exchange (IKE)\",\n      \
    \        RFC 3526, May 2003,\n              <http://www.rfc-editor.org/info/rfc3526>.\n\
    \   [RFC3629]  Yergeau, F., \"UTF-8, a transformation format of ISO\n        \
    \      10646\", STD 63, RFC 3629, November 2003,\n              <http://www.rfc-editor.org/info/rfc3629>.\n\
    \   [RFC3986]  Berners-Lee, T., Fielding, R., and L. Masinter, \"Uniform\n   \
    \           Resource Identifier (URI): Generic Syntax\", STD 66, RFC\n       \
    \       3986, January 2005,\n              <http://www.rfc-editor.org/info/rfc3986>.\n\
    \   [RFC5234]  Crocker, D. and P. Overell, \"Augmented BNF for Syntax\n      \
    \        Specifications: ABNF\", STD 68, RFC 5234, January 2008,\n           \
    \   <http://www.rfc-editor.org/info/rfc5234>.\n   [RFC6234]  Eastlake, D. and\
    \ T. Hansen, \"US Secure Hash Algorithms\n              (SHA and SHA-based HMAC\
    \ and HKDF)\", RFC 6234, May 2011,\n              <http://www.rfc-editor.org/info/rfc6234>.\n\
    \   [RFC7016]  Thornburgh, M., \"Adobe's Secure Real-Time Media Flow\n       \
    \       Protocol\", RFC 7016, November 2013,\n              <http://www.rfc-editor.org/info/rfc7016>.\n\
    \   [RFC7296]  Kaufman, C., Hoffman, P., Nir, Y., Eronen, P., and T.\n       \
    \       Kivinen, \"Internet Key Exchange Protocol Version 2\n              (IKEv2)\"\
    , STD 79, RFC 7296, October 2014,\n              <http://www.rfc-editor.org/info/rfc7296>.\n\
    \   [RTMP]     Adobe Systems Incorporated, \"Real-Time Messaging Protocol\n  \
    \            (RTMP) specification\", December 2012,\n              <http://www.adobe.com/go/spec_rtmp>.\n\
    \   [SHA256]   National Institute of Standards and Technology, \"Secure\n    \
    \          Hash Standard\", FIPS PUB 180-4, March 2012,\n              <http://csrc.nist.gov/publications/fips/fips180-4/\n\
    \              fips-180-4.pdf>.\n"
- title: 8.2.  Informative References
  contents:
  - "8.2.  Informative References\n   [RFC1035]  Mockapetris, P., \"Domain names -\
    \ implementation and\n              specification\", STD 13, RFC 1035, November\
    \ 1987,\n              <http://www.rfc-editor.org/info/rfc1035>.\n   [RFC1071]\
    \  Braden, R., Borman, D., Partridge, C., and W. Plummer,\n              \"Computing\
    \ the Internet checksum\", RFC 1071, September\n              1988, <http://www.rfc-editor.org/info/rfc1071>.\n\
    \   [RFC4302]  Kent, S., \"IP Authentication Header\", RFC 4302, December\n  \
    \            2005, <http://www.rfc-editor.org/info/rfc4302>.\n   [RFC4303]  Kent,\
    \ S., \"IP Encapsulating Security Payload (ESP)\", RFC\n              4303, December\
    \ 2005,\n              <http://www.rfc-editor.org/info/rfc4303>.\n   [RFC6479]\
    \  Zhang, X. and T. Tsou, \"IPsec Anti-Replay Algorithm\n              without\
    \ Bit Shifting\", RFC 6479, January 2012,\n              <http://www.rfc-editor.org/info/rfc6479>.\n"
- title: Acknowledgements
  contents:
  - "Acknowledgements\n   Special thanks go to Glenn Eguchi, Matthew Kaufman, and\
    \ Adam Lane for\n   their contributions to the design of this profile.\n   Thanks\
    \ to Philipp Hancke, Kevin Igoe, Paul Kyzivat, and Milos\n   Trboljevac for their\
    \ detailed reviews of this memo.\n"
- title: Author's Address
  contents:
  - "Author's Address\n   Michael C. Thornburgh\n   Adobe Systems Incorporated\n \
    \  345 Park Avenue\n   San Jose, CA  95110-2704\n   United States\n   Phone: +1\
    \ 408 536 6000\n   EMail: mthornbu@adobe.com\n   URI:   http://www.adobe.com/\n"
