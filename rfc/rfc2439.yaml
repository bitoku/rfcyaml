- title: __initial_text__
  contents:
  - '                         BGP Route Flap Damping

    '
- title: Status of this Memo
  contents:
  - "Status of this Memo\n   This document specifies an Internet standards track protocol\
    \ for the\n   Internet community, and requests discussion and suggestions for\n\
    \   improvements.  Please refer to the current edition of the \"Internet\n   Official\
    \ Protocol Standards\" (STD 1) for the standardization state\n   and status of\
    \ this protocol.  Distribution of this memo is unlimited.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (C) The Internet Society (1998).  All Rights Reserved.\n"
- title: Abstract
  contents:
  - "Abstract\n   A usage of the BGP routing protocol is described which is capable\
    \ of\n   reducing the routing traffic passed on to routing peers and therefore\n\
    \   the load on these peers without adversely affecting route convergence\n  \
    \ time for relatively stable routes.  This technique has been\n   implemented\
    \ in commercial products supporting BGP. The technique is\n   also applicable\
    \ to IDRP.\n   The overall goals are:\n   o  to provide a mechanism capable of\
    \ reducing router processing load\n      caused by instability\n   o  in doing\
    \ so prevent sustained routing oscillations\n   o  to do so without sacrificing\
    \ route convergence time for generally\n      well behaved routes.\n   This must\
    \ be accomplished keeping other goals of BGP in mind:\n   o  pack changes into\
    \ a small number of updates\n   o  preserve consistent routing\n   o  minimal\
    \ addition space and computational overhead\n   An excessive rate of update to\
    \ the advertised reachability of a\n   subset of Internet prefixes has been widespread\
    \ in the Internet.\n   This observation was made in the early 1990s by many people\
    \ involved\n   in Internet operations and remains the case.  These excessive updates\n\
    \   are not necessarily periodic so route oscillation would be a\n   misleading\
    \ term.  The informal term used to describe this effect is\n   \"route flap\"\
    .  The techniques described here are now widely deployed\n   and are commonly\
    \ referred to as \"route flap damping\".\n"
- title: 1 Overview
  contents:
  - "1 Overview\n   To maintain scalability of a routed internet, it is necessary\
    \ to\n   reduce the amount of change in routing state propagated by BGP in\n \
    \  order to limit processing requirements.  The primary contributors of\n   processing\
    \ load resulting from BGP updates are the BGP decision\n   process and adding\
    \ and removing forwarding entries.\n   Consider the following example.  A widely\
    \ deployed BGP implementation\n   may tend to fail due to high routing update\
    \ volume.  For example, it\n   may be unable to maintain it's BGP or IGP sessions\
    \ if sufficiently\n   loaded.  The failure of one router can further contribute\
    \ to the load\n   on other routers.  This additional load may cause failures in\
    \ other\n   instances of the same implementation or other implementations with\
    \ a\n   similar weakness.  In the worst case, a stable oscillation could\n   result.\
    \  Such worse cases have already been observed in practice.\n   A BGP implementation\
    \ must be prepared for a large volume of routing\n   traffic.  A BGP implementation\
    \ cannot rely upon the sender to\n   sufficiently shield it from route instabilities.\
    \  The guidelines here\n   are designed to prevent sustained oscillations, but\
    \ do not eliminate\n   the need for robust and efficient implementations.  The\
    \ mechanisms\n   described here allow routing instability to be contained at an\
    \ AS\n   border router bordering the instability.\n   Even where BGP implementations\
    \ are highly robust, the performance of\n   the routing process is limited.  Limiting\
    \ the propagation of\n   unnecessary change then becomes an issue of maintaining\
    \ reasonable\n   route change convergence time as a routing topology grows.\n"
- title: 2 Methods of Limiting Route Advertisement
  contents:
  - "2 Methods of Limiting Route Advertisement\n   Two methods of controlling the\
    \ frequency of route advertisement are\n   described here.  The first involves\
    \ fixed timers.  The fixed timer\n   technique has no space overhead per route\
    \ but has the disadvantage of\n   slowing route convergence for the normal case\
    \ where a route does not\n   have a history of instability.  The second method\
    \ overcomes this\n   limitation at the expense of maintaining some additional\
    \ space\n   overhead.  The additional overhead includes a small amount of state\n\
    \   per route and a very small processing overhead.\n   It is possible and desirable\
    \ to combine both techniques.  In\n   practice, fixed timers have been set to\
    \ very short time intervals and\n   have proven useful to pack routes into a smaller\
    \ number of updates\n   when routes arrive in separate updates.  The BGP protocol\
    \ refers to\n   this as packing Network Layer Reachability Information (NLRI)\
    \ [5].\n   Seldom are fixed timers set to the tens of minutes to hours that\n\
    \   would be necessary to actually damp route flap.  To do so would\n   produce\
    \ the undesirable effect of severely limiting routing\n   convergence.\n"
- title: 2.1 Existing Fixed Timer Recommendations
  contents:
  - "2.1 Existing Fixed Timer Recommendations\n   BGP-3 does not make specific recommendations\
    \ in this area [1].  The\n   short section entitled \"Frequency of Route Selection\"\
    \ simply\n   recommends that something be done and makes broad statements\n  \
    \ regarding certain properties that are desirable or undesirable.\n   BGP4 retains\
    \ the \"Frequency of Route Advertisement\" section and adds\n   a \"Frequency\
    \ of Route Origination\" section.  BGP-4 describes a method\n   of limiting route\
    \ advertisement involving a fixed (configurable)\n   MinRouteAdvertisementInterval\
    \ timer and fixed\n   MinASOriginationInterval timer [5].  The recommended timer\
    \ values of\n   MinRouteAdvertisementInterval is 30 seconds and\n   MinASOriginationInterval\
    \ is 15 seconds.\n"
- title: 2.2 Desirable Properties of Damping Algorithms
  contents:
  - "2.2 Desirable Properties of Damping Algorithms\n   Before describing damping\
    \ algorithms the objectives need to be\n   clearly defined.  Some key properties\
    \ are examined to clarify the\n   design rationale.\n   The overall objective\
    \ is to reduce the route update load without\n   limiting convergence time for\
    \ well behaved routes.  To accomplish\n   this, criteria must be defined for well\
    \ behaved and poorly behaved\n   routes.  An algorithm must be defined which allows\
    \ poorly behaved\n   routes to be identified.  Ideally, this measure would be\
    \ a prediction\n   of the future stability of a route.\n   Any delay in propagation\
    \ of well behaved routes should be minimal.\n   Some delay is tolerable to support\
    \ better packing of updates.  Delay\n   of poorly behave routes should, if possible,\
    \ be proportional to a\n   measure of the expected future instability of the route.\
    \  Delay in\n   propagating an unstable route should cause the unstable route\
    \ to be\n   suppressed until there is some degree of confidence that the route\n\
    \   has stabilized.\n   If a large number of route changes are received in separate\
    \ updates\n   over some very short period of time and these updates have the\n\
    \   potential to be combined into a single update then these should be\n   packed\
    \ as efficiently as possible before propagating further.  Some\n   small delay\
    \ in propagating well behaved routes is tolerable and is\n   necessary to allow\
    \ better packing of updates.\n   Where routes are unstable, use and announcement\
    \ of the routes should\n   be suppressed rather than suppressing their removal.\
    \  Where one route\n   to a destination is stable, and another route to the same\
    \ destination\n   is somewhat unstable, if possible, the unstable route should\
    \ be\n   suppressed more aggressively than if there were no alternate path.\n\
    \   Routing consistency within an AS is very important.  Only very\n   minimal\
    \ delay of internal BGP (IBGP) should be done.  Routing\n   consistency across\
    \ AS boundaries is also very important.  It is\n   highly undesirable to advertise\
    \ a route that is different from the\n   route that is being used, except for\
    \ a very minimal time.  It is more\n   desirable to suppress the acceptance of\
    \ a route (and therefore the\n   use of that route in the IGP) rather than suppress\
    \ only the\n   redistribution.\n   It is clearly not possible to accurately predict\
    \ the future stability\n   of a route.  The recent history of stability is generally\
    \ regarded as\n   a good basis for estimating the likelihood of future stability.\
    \  The\n   criteria that is used to distinguish well behaved from poorly behaved\n\
    \   routes is therefore based on the recent history of stability of the\n   route.\
    \  There is no simple quantitative expression of recent\n   stability so a figure\
    \ of merit must be defined.  Some desirable\n   characteristics of this figure\
    \ of merit would be that the farther in\n   the past that instability occurred,\
    \ the less it's affect on the\n   figure of merit and that the instability measure\
    \ would be cumulative\n   rather than reflecting only the most recent event.\n\
    \   The algorithms should behave such that for routes which have a\n   history\
    \ of stability but make a few transitions, those transitions\n   should be made\
    \ quickly.  If transitions continue, advertisement of\n   the route should be\
    \ suppressed.  There should be some memory of prior\n   instability.  The degree\
    \ to which prior instability is considered\n   should be gradually reduced as\
    \ long as the route remains announced\n   and stable.\n"
- title: 2.3 Design Choices
  contents:
  - "2.3 Design Choices\n   After routes have been accepted their readvertisement\
    \ will be briefly\n   suppressed to improve packing of updates.  There may be\
    \ a lengthy\n   suppression of the acceptance of an external route.  How long\
    \ a route\n   will be suppressed is based on a figure of merit that is expected\
    \ to\n   be correlated to the probability of future instability of a route.\n\
    \   Routes with high figure of merit values will be suppressed.  An\n   exponential\
    \ decay algorithm was chosen as the basis for reducing the\n   figure of merit\
    \ over time.  These choices should be viewed as\n   suggestions for implementation.\n\
    \   An exponential decay function has the property that previous\n   instability\
    \ can be remembered for a fairly long time.  The rate at\n   which the instability\
    \ figure of merit decays slows as time goes on.\n   Exponential decay has the\
    \ following property.\n         f(f(figure-of-merit, t1), t2) = f(figure-of-merit,\
    \ t1+t2)\n   This property allows the decay for a long period to be computed in\
    \ a\n   single operation regardless of the current value (figure-of-merit).\n\
    \   As a performance optimization, the decay can be applied in fixed time\n  \
    \ increments.  Given a desired decay half life, the decay for a single\n   time\
    \ increment can be computed ahead of time.  The decay for multiple\n   time increments\
    \ is expressed below.\n        f(figure-of-merit, n*t0) = f(figure-of-merit, t0)**n\
    \ = K**n\n   The values of K ** n can be precomputed for a reasonable number of\n\
    \   \"n\" and stored in an array.  The value of \"K\" is always less than\n  \
    \ one.  The array size can be bounded since the value quickly\n   approaches zero.\
    \  This makes the decay easy to compute using an array\n   bound check, an array\
    \ lookup and a single multiply regardless as to\n   how much time has elapsed.\n"
- title: 3 Limiting Route Advertisements using Fixed Timers
  contents:
  - "3 Limiting Route Advertisements using Fixed Timers\n   This method of limiting\
    \ route advertisements involves the use of\n   fixed timers applied to the process\
    \ of sending routes.  It's primary\n   purpose is to improve the packing of routes\
    \ in BGP update messages.\n   The delay in advertising a stable route should be\
    \ bounded and\n   minimal.  The delay in advertising an unreachable need not be\
    \ zero,\n   but should also be bounded and should probably have a separate bound\n\
    \   set less than or equal to the bound for a reachable advertisement.\n   The\
    \ BGP protocol defines the use of a Routing Information Base (RIB).\n   Routes\
    \ that need to be readvertised can be marked in the RIB or an\n   external set\
    \ of structures maintained, which references the RIB.\n   Periodically, a subset\
    \ of the marked routes can be flushed.  This is\n   fairly straightforward and\
    \ accomplishes the objectives.  Computation\n   for too simple an implementation\
    \ may be order N squared.  To avoid N\n   squared performance, some form of data\
    \ structure is needed to group\n   routes with common attributes.\n   An implementation\
    \ should pack updates efficiently, provide a minimum\n   readvertisement delay,\
    \ provide a bounds on the maximum\n   readvertisement delay that would be experienced\
    \ solely as a result of\n   the algorithm used to provide a minimum delay, and\
    \ must be\n   computationally efficient in the presence of a very large number\
    \ of\n   candidates for readvertisement.\n"
- title: 4 Stability Sensitive Suppression of Route Advertisement
  contents:
  - "4 Stability Sensitive Suppression of Route Advertisement\n   This method of limiting\
    \ route advertisements uses a measure of route\n   stability applied on a per\
    \ route basis.  This technique is applied\n   when receiving updates from external\
    \ peers only (EBGP). Applying this\n   technique to IBGP learned routes or to\
    \ advertisement to IBGP or EBGP\n   peers after making a route selection can result\
    \ in routing loops.\n   A figure of merit based on a measure of instability is\
    \ maintained on\n   a per route basis.  This figure of merit is used in the decision\
    \ to\n   suppress the use of the route.  Routes with high figure of merit are\n\
    \   suppressed.  Each time a route is withdrawn, the figure of merit is\n   incremented.\
    \  While the route is not changing the figure of merit\n   value is decayed exponentially\
    \ with separate decay rates depending on\n   whether the route is stable and reachable\
    \ or has been stable and\n   unreachable.  The decay rate may be slower when the\
    \ route is\n   unreachable, or the stability figure of merit could remain fixed\
    \ (not\n   decay at all) while the route remains unreachable.  Whether to decay\n\
    \   unreachable routes at the same rate, a slower rate, or not at all is\n   an\
    \ implementation choice.  Decaying at a slower rate is recommended.\n   A very\
    \ efficient implementation is suggested in the following\n   sections.  The implementation\
    \ only requires computation for the\n   routes contained in an update, when an\
    \ update is received or\n   withdrawn (as opposed to the simplistic approach of\
    \ periodically\n   decaying each route).  The suggested implementation involves\
    \ only a\n   small number of simple operations, and can be implemented using\n\
    \   scaled integers.\n   The behavior of unstable routes is fairly predictable.\
    \  Severely\n   flapping routes will often be advertised and withdrawn at regular\n\
    \   time intervals corresponding to the timers of a particular protocol\n   (the\
    \ IGP or exterior protocol in use where the problem exists).\n   Marginal circuits\
    \ or mild congestion can result in a long term\n   pattern of occasional brief\
    \ route withdrawal or occasional brief\n   connectivity.\n"
- title: 4.1 Single vs.  Multiple Configuration Parameter Sets
  contents:
  - "4.1 Single vs.  Multiple Configuration Parameter Sets\n   The behavior of the\
    \ algorithm is modified by a number of configurable\n   parameters.  It is possible\
    \ to configure separate sets of parameters\n   designed to handle short term severe\
    \ route flap and chronic milder\n   route flap (a pattern of occasional drops\
    \ over a long time period).\n   The former would require a fast decay and low\
    \ threshold (allowing a\n   small number of consecutive flaps to cause a route\
    \ to be suppressed,\n   but allowing it to be reused after a relatively short\
    \ period of\n   stability).  The latter would require a very slow decay and a\
    \ higher\n   threshold and might be appropriate for routes for which there was\
    \ an\n   alternate path of similar bandwidth.\n   It may also be desirable to\
    \ configure different thresholds for routes\n   with roughly equivalent alternate\
    \ paths than for routes where the\n   alternate paths have a lower bandwidth or\
    \ tend to be congested.  This\n   can be solved by associating a different set\
    \ of parameters with\n   different ranges of preference values.  Parameter selection\
    \ could be\n   based on BGP LOCAL_PREF.\n   Parameter selection could also be\
    \ based on whether an alternate route\n   was known.  A route would be considered\
    \ if, for any applicable\n   parameter set, an alternate route with the specified\
    \ preference value\n   existed and the figure of merit associated with the parameter\
    \ set did\n   not indicate a need to suppress the route.  A less aggressive\n\
    \   suppression would be applied to the case where no alternate route at\n   all\
    \ existed.  In the simplest case, a more aggressive suppression\n   would be applied\
    \ if any alternate route existed.  Only the highest\n   preference (most preferred)\
    \ value needs to be specified, since the\n   ranges may overlap.\n   It might\
    \ also be desirable to configure a different set of thresholds\n   for routes\
    \ which rely on switched services and may disconnect at\n   times to reduce connect\
    \ charges.  Such routes might be expected to\n   change state somewhat more often,\
    \ but should be suppressed if\n   continuous state changes indicate instability.\n\
    \   While not essential, it might be desirable to be able to configure\n   multiple\
    \ sets of configuration parameters per route.  It may also be\n   desirable to\
    \ be able to configure sets of parameters that only\n   correspond to a set of\
    \ routes (identified by AS path, peer router,\n   specific destinations or other\
    \ means).  Experience may dictate how\n   much flexibility is needed and how to\
    \ best to set the parameters.\n   Whether to allow different damping parameter\
    \ sets for different\n   routes, and whether to allow multiple figures of merit\
    \ per route is\n   an implementation choice.\n   Parameter selection can also\
    \ be based on prefix length.  The\n   rationale is that longer prefixes tend to\
    \ reach less end systems and\n   are less important and these less important prefixes\
    \ can be damped\n   more aggressively.  This technique is in fairly widespread\
    \ use.\n   Small sites or those with dense address allocation who are multihomed\n\
    \   are often reachable by long prefixes which are not easily aggregated.\n  \
    \ These sites tend to dispute the choice of prefix length for parameter\n   selection.\
    \  Advocates of the technique point out that it encourages\n   better aggregation.\n"
- title: 4.2 Configuration Parameters
  contents:
  - "4.2 Configuration Parameters\n   At configuration time, a number of parameters\
    \ may be specified by the\n   user.  The configuration parameters are expressed\
    \ in units meaningful\n   to the user.  These differ from the parameters used\
    \ at run time which\n   are in unit convenient for computation.  The run time\
    \ parameters are\n   derived from the configuration parameters.  Suggested configuration\n\
    \   parameters are listed below.\n     cutoff threshold (cut)\n        This value\
    \ is expressed as a number of route withdrawals.  It is\n        the value above\
    \ which a route advertisement will be suppressed.\n     reuse threshold (reuse)\n\
    \        This value is expressed as a number of route withdrawals.  It is\n  \
    \      the value below which a suppressed route will now be used again.\n    \
    \ maximum hold down time (T-hold)\n        This value is the maximum time a route\
    \ can be suppressed no\n        matter how unstable it has been prior to this\
    \ period of\n        stability.\n     decay half life while reachable (decay-ok)\n\
    \        This value is the time duration in minutes or seconds during\n      \
    \  which the accumulated stability figure of merit will be reduced\n        by\
    \ half if the route if considered reachable (whether suppressed\n        or not).\n\
    \     decay half life while unreachable (decay-ng)\n        This value is the\
    \ time duration in minutes or seconds during\n        which the accumulated stability\
    \ figure of merit will be reduced\n        by half if the route if considered\
    \ unreachable.  If not\n        specified or set to zero, no decay will occur\
    \ while a route\n        remains unreachable.\n     decay memory limit (Tmax-ok\
    \ or Tmax-ng)\n        This is the maximum time that any memory of previous instability\n\
    \        will be retained given that the route's state remains unchanged,\n  \
    \      whether reachable or unreachable.  This parameter is generally\n      \
    \  used to determine array sizes.\n   There may be multiple sets of the parameters\
    \ above as described in\n   Section 4.1.  The configuration parameters listed\
    \ below would be\n   applied system wide.  These include the time granularity\
    \ of all\n   computations, and the parameters used to control reevaluation of\n\
    \   routes that have previously been suppressed.\n     time granularity (delta-t)\n\
    \        This is the time granularity in seconds used to perform all\n       \
    \ decay computations.\n     reuse list time granularity (delta-reuse)\n      \
    \  This is the time interval between evaluations of the reuse\n        lists.\
    \  Each reuse lists corresponds to an additional time\n        increment.\n  \
    \   reuse list memory reuse-list-max\n        This is the time value corresponding\
    \ to the last reuse list.\n        This may be the maximum value of T-hold for\
    \ all parameter sets\n        of may be configured.\n     number of reuse lists\
    \ (reuse-list-size)\n        This is the number of reuse lists.  It may be determined\
    \ from\n        reuse-list-max or set explicitly.\n   A recommended optimization\
    \ is described in Section 4.8.6 that\n   involves an array referred to as the\
    \ \"reuse index array\".  A reuse\n   index array is needed for each decay rate\
    \ in use.  The reuse index\n   array is used to estimate which reuse list to place\
    \ a route when it\n   is suppressed.  Proper placement avoids the need to periodically\n\
    \   evaluate decay to determine if a route can be reused or when storage\n   can\
    \ be recovered.  Using the reuse index array avoids the need to\n   compute a\
    \ logarithm to determine placement.  One additional system\n   wide parameter\
    \ can be introduced.\n     reuse index array size (reuse-index-array-size)\n \
    \       This is the size of reuse index arrays.  This size determines\n      \
    \  the accuracy with which suppressed routes can be placed within\n        the\
    \ set of reuse lists when suppressed for a long time.\n"
- title: 4.3 Guidelines for Setting Parameters
  contents:
  - "4.3 Guidelines for Setting Parameters\n   The decay half life should be set to\
    \ a time considerably longer than\n   the period of the route flap it is intended\
    \ to address.  For example,\n   if the decay is set to ten minutes and a route\
    \ is withdrawn and\n   readvertised exactly every ten minutes, the route would\
    \ continue to\n   flap if the cutoff was set to a value of 2 or above.\n   The\
    \ stability figure of merit itself is an accumulated time decayed\n   total. \
    \ This must be kept in mind in setting the decay time, cutoff\n   values and reuse\
    \ values.  The figure of merit is increased each time\n   a route transitions\
    \ from reachable to unreachable.  The figure of\n   merit is decayed at a rate\
    \ proportional to its current value.\n   Increasing the rate of route flap therefore\
    \ increments the figure of\n   merit more often and reaches a given threshhold\
    \ in a shorter amount\n   of time.  When the response to a constant rate route\
    \ flap is plotted\n   this looks like a sawtooth with an abrupt rising edge and\
    \ a decaying\n   falling edge.  Since the absolute decay amount is proportional\
    \ to the\n   figure of merit, at a continuous constant flap rate the baseline\
    \ of\n   the sawtooth will tend to stop rising and converge if not clipped by\n\
    \   a ceiling value.\n   If clipped by a ceiling value, the sawtooth baseline\
    \ will simply\n   reach the ceiling faster at a higher rate of route flap.  For\n\
    \   example, if flapping at four times the decay rate the following\n   progression\
    \ occurs.  When the route becomes unreachable the first\n   time the value becomes\
    \ 1.  When the next flap occurs, one is added to\n   the previous value, which\
    \ has been decreased by the fourth root of 2\n   (the amount of decay that would\
    \ occur in 1/4 of the half life time if\n   decay is exponential).  The sequence\
    \ is 1, 1.84, 2.55, 3.14, 3.64,\n   4.06, 4.42, 4.71, 4.96, 5.17, ..., converging\
    \ at about 6.285.  If a\n   route flaps at four times the decay rate, it will\
    \ reach 3 in 4\n   cycles, 4 in 6 cycles, 5 in 10 cycles, and will converge at\
    \ about\n   6.3.  At twice the decay time, it will reach 3 in 7 cycles, and\n\
    \   converge at a value of less than 3.5.\n   Figure 1 shows the stability figure\
    \ of merit for route flap at a\n   constant rate.  The time axis is labeled in\
    \ multiples of the decay\n   half life.  The plots represent route flap with a\
    \ period of 1/2, 1/3,\n   1/4, and 1/8 times the decay half life.  A ceiling of\
    \ 4.5 was set,\n   which can be seen to affect three of the plots, effectively\
    \ limiting\n   the time it takes to readvertise the route regardless of the prior\n\
    \   history.  With cutoff and reuse thresholds of 1.5 and 0.75,  routes\n   would\
    \ be suppressed after being declared unreachable 2-3 times and be\n   used again\
    \ after approximately 2 decay half life periods of\n   stability.\n   This function\
    \ can be expressed formally.  Reachability of a route can\n   be represented by\
    \ a variable \"R\" with possible values of 0 and 1\n   representing unreachable\
    \ and reachable.  At a discrete time R can\n   only have one value.  The figure\
    \ of merit is increased by 1 at each\n   transition from R=1 to R=0 and clipped\
    \ to a ceiling value.  The decay\n   in figure of merit can then be expressed\
    \ over a set of discrete times\n   as follows.\n      figure-of-merit(t) = K *\
    \ figure-of-merit(t - delta-t) \n      K = K1 for R=0 K=K2 for R=1\n   The four\
    \ plots are presented vertically.  Due to space limitations,\n   only a limited\
    \ set of points along the time axis are shown.  The\n   value of the figure of\
    \ merit is given.  Along side each value is a\n   very low resolution strip chart\
    \ made up of ASCII dots.  This is just\n   intended to give a rough feel for the\
    \ rise and fall of the values.\n   The strip charts are not displayed on an overlapping\
    \ set of axes\n   because the sawtooth waveforms cross each other quite frequently.\
    \  At\n   the very low resolution of these plots, the rise and fall of the\n \
    \  baseline is evident, but the sawtooth nature is only observed in the\n   printed\
    \ value.\n   From the maximum hold time value (T-hold), a ratio of the reuse value\n\
    \   to a ceiling can be determined.  An integer value for the ceiling can\n  \
    \ then be chosen such that overflow will not be a problem and all other\n   values\
    \ can be scaled accordingly.  If both cutoffs are specified or\n   if multiple\
    \ parameter sets are used the highest ceiling will be used.\n   time      figure-of-merit\
    \ as a function of time (in minutes)\n  0.00    0.000 .         0.000 .      \
    \   0.000 .         0.000 .\n  0.08    0.000 .         0.000 .         0.000 .\
    \         0.000 .\n  0.16    0.000 .         0.000 .         0.000 .         0.973\
    \  .\n  0.24    0.000 .         0.000 .         0.000 .         0.920  .\n  0.32\
    \    0.000 .         0.000 .         0.946  .        1.817    .\n  0.40    0.000\
    \ .         0.953  .        0.895  .        2.698     .\n  0.48    0.000 .   \
    \      0.901  .        0.847  .        2.552     .\n  0.56    0.953  .       \
    \ 0.853  .        1.754    .      3.367      .\n  0.64    0.901  .        0.807\
    \  .        1.659   .       4.172        .\n  0.72    0.853  .        1.722  \
    \  .      1.570   .       3.947        .\n  0.80    0.807  .        1.629   .\
    \       2.444     .     4.317        .\n  0.88    0.763  .        1.542   .  \
    \     2.312     .     4.469        .\n  0.96    0.722  .        1.458   .    \
    \   2.188    .      4.228        .\n  1.04    1.649   .       2.346     .    \
    \ 3.036      .    4.347        .\n  1.12    1.560   .       2.219    .      2.872\
    \      .    4.112        .\n  1.20    1.476   .       2.099    .      2.717  \
    \   .     4.257        .\n  1.28    1.396   .       1.986    .      3.543    \
    \   .   4.377        .\n  1.36    1.321   .       2.858      .    3.352      .\
    \    4.141        .\n  1.44    1.250   .       2.704     .     3.171      .  \
    \  4.287        .\n  1.52    2.162    .      2.558     .     3.979        .  4.407\
    \        .\n  1.60    2.045    .      2.420     .     3.765       .   4.170  \
    \      .\n  1.68    1.935    .      3.276      .    3.562       .   4.317    \
    \    .\n  1.76    1.830    .      3.099      .    4.356        .  4.438      \
    \  .\n  1.84    1.732    .      2.932      .    4.121        .  4.199        .\n\
    \  1.92    1.638   .       2.774     .     3.899       .   3.972        .\n  2.00\
    \    1.550   .       2.624     .     3.688       .   3.758       .\n  2.08   \
    \ 1.466   .       2.483     .     3.489       .   3.555       .\n  2.16    1.387\
    \   .       2.349     .     3.301      .    3.363      .\n  2.24    1.312   .\
    \       2.222    .      3.123      .    3.182      .\n  2.32    1.242   .    \
    \   2.102    .      2.955      .    3.010      .\n  2.40    1.175   .       1.989\
    \    .      2.795     .     2.848      .\n  2.48    1.111  .        1.882    .\
    \      2.644     .     2.694     .\n  2.56    1.051  .        1.780    .     \
    \ 2.502     .     2.549     .\n  2.64    0.995  .        1.684   .       2.367\
    \     .     2.411     .\n  2.72    0.941  .        1.593   .       2.239    .\
    \      2.281     .\n  2.80    0.890  .        1.507   .       2.118    .     \
    \ 2.158    .\n  2.88    0.842  .        1.426   .       2.004    .      2.042\
    \    .\n  2.96    0.797  .        1.349   .       1.896    .      1.932    .\n\
    \  3.04    0.754  .        1.276   .       1.794    .      1.828    .\n  3.12\
    \    0.713  .        1.207   .       1.697    .      1.729    .\n  3.20    0.675\
    \  .        1.142   .       1.605   .       1.636   .\n  3.28    0.638  .    \
    \    1.081  .        1.519   .       1.547   .\n  3.36    0.604  .        1.022\
    \  .        1.437   .       1.464   .\n  3.44    0.571  .        0.967  .    \
    \    1.359   .       1.385   .\n   Figure 1: Instability figure of merit for flap\
    \ at a constant rate\n  time      figure-of-merit as a function of time (in minutes)\n\
    \  0.00    0.000 .         0.000 .         0.000 .\n  0.20    0.000 .        \
    \ 0.000 .         0.000 .\n  0.40    0.000 .         0.000 .         0.000 .\n\
    \  0.60    0.000 .         0.000 .         0.000 .\n  0.80    0.000 .        \
    \ 0.000 .         0.000 .\n  1.00    0.999  .        0.999  .        0.999  .\n\
    \  1.20    0.971  .        0.971  .        0.929  .\n  1.40    0.945  .      \
    \  0.945  .        0.809  .\n  1.60    0.919  .        0.865  .        0.704 \
    \ .\n  1.80    0.894  .        0.753  .        0.613  .\n  2.00    1.812    .\
    \      1.657   .       1.535   .\n  2.20    1.762    .      1.612   .       1.428\
    \   .\n  2.40    1.714    .      1.568   .       1.244   .\n  2.60    1.667  \
    \ .       1.443   .       1.083  .\n  2.80    1.622   .       1.256   .      \
    \ 0.942  .\n  3.00    1.468   .       1.094  .        0.820  .\n  3.20    2.400\
    \     .     2.036    .      1.694    .\n  3.40    2.335     .     1.981    . \
    \     1.475   .\n  3.60    2.271     .     1.823    .      1.284   .\n  3.80 \
    \   2.209    .      1.587   .       1.118  .\n  4.00    1.999    .      1.381\
    \   .       0.973  .\n  4.20    2.625     .     2.084    .      1.727    .\n \
    \ 4.40    2.285     .     1.815    .      1.503   .\n  4.60    1.990    .    \
    \  1.580   .       1.309   .\n  4.80    1.732    .      1.375   .       1.139\
    \   .\n  5.00    1.508   .       1.197   .       0.992  .\n  5.20    1.313   .\
    \       1.042  .        0.864  .\n  5.40    1.143   .       0.907  .        0.752\
    \  .\n  5.60    0.995  .        0.790  .        0.654  .\n  5.80    0.866  . \
    \       0.688  .        0.570  .\n  6.00    0.754  .        0.599  .        0.496\
    \ .\n  6.20    0.656  .        0.521 .         0.432 .\n  6.40    0.571  .   \
    \     0.454 .         0.376 .\n  6.60    0.497 .         0.395 .         0.327\
    \ .\n  6.80    0.433 .         0.344 .         0.285 .\n  7.00    0.377 .    \
    \     0.299 .         0.248 .\n  7.20    0.328 .         0.261 .         0.216\
    \ .\n  7.40    0.286 .         0.227 .         0.188 .\n  7.60    0.249 .    \
    \     0.197 .         0.164 .\n  7.80    0.216 .         0.172 .         0.142\
    \ .\n  8.00    0.188 .         0.150 .         0.124 .\n          Figure 2: Separate\
    \ decay constants when unreachable\n   Figure 2 shows the effect of configuring\
    \ separate decay rates to be\n   used when the route is reachable or unreachable.\
    \  The decay rate is 5\n   times slower when the route is unreachable.  In the\
    \ three case shown,\n   the period of the route flap is equal to the decay half\
    \ life but the\n   route is reachable 1/8 of the time in one, reachable 1/2 the\
    \ time in\n   one, and reachable 7/8 of the time in the other.  In the last case\n\
    \   the route is not suppressed until after the third unreachable (when\n   it\
    \ is above the top threshold after becoming reachable again).\n   The main point\
    \ of Figure 2 is to show the effect of changing the duty\n   cycle of the square\
    \ wave in the variable \"R\" for a fixed frequency of\n   the square wave.  If\
    \ the decay constants are chosen such that decay\n   is slower when R=0 (the route\
    \ is unreachable), then the figure of\n   merit rises more slowly (more accurately,\
    \ the baseline of the\n   sawtooth waveform rises more slowly) if the route is\
    \ reachable a\n   larger percentage of the time.  The effect when the route becomes\n\
    \   persistently reachable again can be fairly negligible if the sawtooth\n  \
    \ is clipped by a ceiling value, but is more significant if a slow\n   route flap\
    \ rate or short interval of route flapping is such that the\n   sawtooth does\
    \ not reach the ceiling value.  In Figure 2 the interval\n   in which the routes\
    \ are unstable is short enough that the ceiling\n   value is not reached, therefore,\
    \ the routes that are reachable for a\n   greater percentage of the route flap\
    \ cycle are reused (placed in the\n   RIB and advertised to peers) sooner than\
    \ others after the route\n   becomes stable again (\"R\" becomes 1, indicating\
    \ the announced state\n   goes to reachable and remains there).\n   In both Figure\
    \ 1 and Figure 2, routes would be suppressed.  Routes\n   flapping at the decay\
    \ half life or less would be withdrawn two or\n   three times and then remain\
    \ withdrawn until they had remained stably\n   announced and stable for on the\
    \ order of 1 1/2 to 2 1/2 times the\n   decay half life (given the ceiling in\
    \ the example).\n   The purpose of damping BGP route flap is to reduce the processor\n\
    \   burden at the immediate router and the processor burden to downstream\n  \
    \ routers (BGP peer routers and peers of peers that will see the route\n   announcements\
    \ advertised by the immediate router).  Computing a\n   figure of merit at each\
    \ discrete time interval using  figure-of-\n   merit(t) = K * figure-of-merit(t\
    \ - delta-t) would be very inefficient\n   and defeat the purpose.  This problem\
    \ is addressed by defering\n   computation as long as possible and doing a single\
    \ simple computation\n   to compensate for the decay during the time that has\
    \ elapsed since\n   the figure of merit was last updated.  The use of decay arrays\n\
    \   provides the single simple calculation.  The use of reuse lists\n   (described\
    \ later) provide a means to defer calculations.  A route\n   becomes usable if\
    \ there was not further change for a period of time\n   and the route is unreachable.\
    \  The data structure storage is\n   recovered if the route's state has not changed\
    \ for a period of time\n   and it has been unreachable.  The reuse arrays provide\
    \ a means to\n   estimate how long a computation can be deferred if there is no\n\
    \   further change.\n   A larger time granularity will keep table storage down.\
    \  The time\n   granularity should be less than a minimal reasonable time between\n\
    \   expected worse case route flaps.  It might be reasonable to fix this\n   parameter\
    \ at compile time or set a default and strongly recommend\n   that the user leave\
    \ it alone.  With an exponential decay, array size\n   can be greatly reduced\
    \ by setting a period of complete stability\n   after which the decayed total\
    \ will be considered zero rather than\n   retaining a tiny quantity.  Alternately,\
    \ very long decays can be\n   implemented by multiplying more than once if array\
    \ bounds are\n   exceeded.\n   The reuse lists hold suppressed routes grouped\
    \ according to how long\n   it will be before the routes are eligible for reuse.\
    \  Periodically\n   each list will be advanced by one position and one list removed\
    \ as\n   described in Section 4.8.7.  All of the suppressed routes in the\n  \
    \ removed list will be reevaluated and either used or placed in another\n   list\
    \ according to how much additional time must elapse before the\n   route can be\
    \ reused.  The last list will always contain all the\n   routes which will not\
    \ be advertised for more time than is appropriate\n   for the remaining list heads.\
    \  When the last list advances to the\n   front, some of the routes will not be\
    \ ready to be used and will have\n   to be requeued.  The time interval for reconsidering\
    \ suppressed\n   routes and number of list heads should be configurable.  Reasonable\n\
    \   defaults might be 30 seconds and 64 list heads.  A route suppressed\n   for\
    \ a long time would need to be reevaluated every 32 minutes.\n"
- title: 4.4 Run Time Data Structures
  contents:
  - "4.4 Run Time Data Structures\n   A fixed small amount of per system storage will\
    \ be required.  Where\n   sets of multiple configuration parameters are used,\
    \ storage will be\n   required per set of parameters.  A small amount of per route\
    \ storage\n   is required.  A set of list heads is needed.  These list heads are\n\
    \   used to arrange suppressed routes according to the time remaining\n   until\
    \ they can be reused.\n   A separate reuse list can be used to hold unreachable\
    \ routes for the\n   purpose of later recovering storage if they remain unreachable\
    \ too\n   long.  This might be more accurately described as a recycling list.\n\
    \   The advantage this would provide is making free data structures\n   available\
    \ as soon as possible.  Alternately, the data structures can\n   simply be placed\
    \ on a queue and the storage recovered when the route\n   hits the front of the\
    \ queue and if storage is needed.  The latter is\n   less optimal but simple.\n\
    \   If multiple sets of configuration parameters are allowed per route,\n   there\
    \ is a need for some means of associating more than one figure of\n   merit and\
    \ set of parameters with each route.  Building a linked list\n   of these objects\
    \ seems like one of a number of reasonable\n   implementations.  Similarly, a\
    \ means of associating a route to a\n   reuse list is required.  A small overhead\
    \ will be required for the\n   pointers needed to implement whatever data structure\
    \ is chosen for\n   the reuse lists.  The suggested implementation uses a double\
    \ linked\n   lists and so requires two pointers per figure of merit.\n   Each\
    \ set of configuration parameters can reference decay arrays and\n   reuse arrays.\
    \  These arrays should be shared among multiple sets of\n   parameters since their\
    \ storage requirement is not negligible.  There\n   will be only one set of reuse\
    \ list heads for the entire router.\n"
- title: 4.4.1 Data Structures for Configuration Parameter Sets
  contents:
  - "4.4.1 Data Structures for Configuration Parameter Sets\n   Based on the configuration\
    \ parameters described in the previous\n   section, the following values can be\
    \ computed as scaled integers\n   directly from the corresponding configuration\
    \ parameters.\n   o  decay array scale factor (decay-array-scale-factor)\n   o\
    \  cutoff value (cut)\n   o  reuse value (reuse)\n   o  figure of merit ceiling\
    \ (ceiling)\n   Each configuration parameter set will reference one or two decay\n\
    \   arrays and one or two reuse arrays.  Only one array will be needed if\n  \
    \ the decay rate is the same while a route is unreachable as while it\n   is reachable,\
    \ or if the stability figure of merit does not decay\n   while a route is unreachable.\n"
- title: 4.4.2 Data Structures per Decay Array and Reuse Index Array
  contents:
  - "4.4.2 Data Structures per Decay Array and Reuse Index Array\n   The following\
    \ are also computed from the configuration parameters\n   though not as directly.\
    \  The computation is described in Section 4.5.\n   o  decay rate per tick (decay-delta-t)\n\
    \   o  decay array size (decay-array-size)\n   o  decay array (decay[])\n   o\
    \  reuse index array size (reuse-index-array-size)\n   o  reuse index array (reuse-index-array[])\n\
    \   For each decay rate specified, an array will be used to store the\n   value\
    \ of a computed parameter raised to the power of the index of\n   each array element.\
    \  This is to speed computations.  The decay rate\n   per tick is an intermediate\
    \ value expressed as a real number and used\n   to compute the values stored in\
    \ the decay arrays.  The array size is\n   computed from the decay memory limit\
    \ configuration parameter\n   expressed as an array size or as a maximum hold\
    \ time.\n   The decay array size must be of sufficient size to accommodate the\n\
    \   specified decay memory given the time granularity, or sufficient to\n   hold\
    \ the number of array elements until integer rounding produces a\n   zero result\
    \ if that value is smaller, or a implementation imposed\n   reasonable size to\
    \ prevent configurations which use excessive memory.\n   Implementations may chose\
    \ to make the array size shorter and multiply\n   more than once when decaying\
    \ a long time interval to reduce storage.\n   The reuse index arrays serve a similar\
    \ purpose to the decay arrays.\n   In BGP, a route is said to be \"used\" if it\
    \ is considered the best\n   route.  In this context, if the route is \"used\"\
    \ it is placed in the\n   RIB and is eligible for advertisement to BGP peers.\
    \  If a route is\n   withdrawn (a BGP announcement is made by a peer indicating\
    \ that it is\n   no longer reachable), then it is no longer eligible for \"use\"\
    .  When\n   a route becomes reachable it may not be \"used\" immediately if the\n\
    \   figure of merit indicates that a recent instability has occurred.\n   After\
    \ the route remains stable and the figure of merit decays below\n   the \"reuse\"\
    \ threshhold, the route is said to be eligible to be\n   \"reused\" (treated as\
    \ truly reachable, placed in the RIB and\n   advertised to peers).  The amount\
    \ of time until a route can be reused\n   can be determined using a array lookup.\
    \  The array can be built given\n   the decay rate.  The array is indexed using\
    \ a scaled integer\n   proportional to the ratio between a current stability figure\
    \ of merit\n   value and the value needed for the route to be reused.\n"
- title: 4.4.3 Per Route State
  contents:
  - "4.4.3 Per Route State\n   Information must be maintained per some tuple representing\
    \ a route.\n   At the very minimum, the NLRI (BGP prefix and length) must be\n\
    \   contained in the tuple.  Different BGP attributes may be included or\n   excluded\
    \ depending on the specific situation.  The AS path should\n   also be contained\
    \ in the tuple by default.  The tuple may also\n   optionally contain other BGP\
    \ attributes such as\n   MULTI_EXIT_DISCRIMINATOR (MED).\n   The tuple representing\
    \ a route for the purpose of route flap damping\n   is:\n      tuple entry   \
    \         default      options\n      -------------------------------------------\n\
    \      NLRI\n        prefix               required\n        length           \
    \    required\n      AS path                included     option to exclude\n \
    \     last AS set in path    excluded     option to include\n      next hop  \
    \             excluded     option to include\n      MED                    excluded\
    \     option to include\n                                          in comparisons\
    \ only\n   The AS path is generally included in order to identify downstream\n\
    \   instability which is not being damped or not being sufficiently\n   damped\
    \ and is alternating between a stable and an unstable path.\n   Under rare circumstances\
    \ it may be desirable to exclude AS path for\n   all or a subset of prefixes.\
    \  If an AS path ends in an AS set, in\n   practice the path is always for an\
    \ aggregate.  Changes to the\n   trailing AS set should be ignored.  Ideally the\
    \ AS path comparison\n   should insure that at least one AS has remained constant\
    \ in the old\n   and new AS set, but completely ignoring the contents of a trailing\
    \ AS\n   set is also acceptable.\n   Including next hop and MED changes can help\
    \ suppress the use of an AS\n   which is internally unstable or avoid a next hop\
    \ which is closer to\n   an unstable IGP path in the adjacent AS. If a large number\
    \ of MED\n   values are used, the increase in the amount of state may become a\n\
    \   problem.  For this reason MED is disabled by default and enabled only\n  \
    \ as part of the tuple comparison, using a single state entry\n   regardless of\
    \ MED value.  Including MED will suppress the use of the\n   adjacent AS even\
    \ though the change need not be propagated further.\n   Using MED is only a safe\
    \ practice if a path is known to exist through\n   another AS or where there are\
    \ enough peering sites with the adjacent\n   AS such that routes heard at only\
    \ a subset of the peering sites will\n   be suppressed.\n"
- title: 4.4.4 Data Structures per Route
  contents:
  - "4.4.4 Data Structures per Route\n   The following information must be maintained\
    \ per route.  A route here\n   is considered to be a tuple usually containing\
    \ NLRI, next hop, and AS\n   path as defined in Section 4.4.3.\n     stability\
    \ figure of merit (figure-of-merit)\n        Each route must have a stability\
    \ figure of merit per applicable\n        parameter set.\n     last time updated\
    \ (time-update)\n        The exact last time updated must be maintained to allow\n\
    \        exponential decay of the accumulated figure of merit to be\n        deferred\
    \ until the route might reasonable be considered eligible\n        for a change\
    \ in status (having gone from unreachable to\n        reachable or advancing within\
    \ the reuse lists).\n     config block pointer\n        Any implementation that\
    \ supports multiple parameter sets must\n        provide a means of quickly identifying\
    \ which set of parameters\n        corresponds to the route currently being considered.\
    \  For\n        implementations supporting only parameter sets where all routes\n\
    \        must be treated the same, this pointer is not required.\n     reuse list\
    \ traversal pointers\n        If doubly linked lists are used to implement reuse\
    \ lists, then\n        two pointers will be needed, previous and next.  Generally\
    \ there\n        is a double linked list which is unused when a route is\n   \
    \     suppressed from use that can be used for reuse list traversal\n        eliminating\
    \ the need for additional pointer storage.\n"
- title: 4.5 Processing Configuration Parameters
  contents:
  - "4.5 Processing Configuration Parameters\n        From the configuration parameters,\
    \ it is possible to precompute\n        a number of values that will be used repeatedly\
    \ and retain these\n        to speed later computations that will be required\
    \ frequently.\n        Scaling is usually dependent on the highest value that\
    \ figure-\n        of-merit can attain, referred to here as the ceiling.  The\
    \ real\n        number value of the ceiling will typically be determined by the\n\
    \        following equation.  The ceiling can also be configured to a\n      \
    \  specific value, which in turn dictates T-hold.\n            ceiling = reuse\
    \ * (exp(T-hold/decay-half-life) * log(2))\n        In the above equation, reuse\
    \ is the reuse threshhold described\n        in Section 4.2.\n        The methods\
    \ of scaled integer arithmetic are not described in\n        detail here.  The\
    \ methods of determining the real values are\n        given.  Translation into\
    \ scaled integer values and the details\n        of scaled integer arithmetic\
    \ are left up to the individual\n        implementations.\n     The ceiling value\
    \ can be set to be the largest integer that can fit\n     in half the bits available\
    \ for an unsigned integer.  This will\n     allow the scaled integers to be multiplied\
    \ by the scaled decay\n     value and then shifted down.  Implementations may\
    \ prefer to use\n     real numbers or may use any integer scaling deemed appropriate\
    \ for\n     their architecture.\n     penalty value and thresholds (as proportional\
    \ scaled integers)\n        The figure of merit penalty for one route withdrawal\
    \ and the\n        cutoff values must be scaled according to the above scaling\n\
    \        factor.\n     decay rate per tick (decay[1])\n        The decay value\
    \ per increment of time as defined by the time\n        granularity must be determined\
    \ (at least initially as a floating\n        point number).  The per tick decay\
    \ is a number slightly less\n        than one.  It is the Nth root of the one\
    \ half where N is the\n        half life divided by the time granularity.\n  \
    \        decay[1] = exp ((1 / (decay-half-life/delta-t)) * log (1/2))\n     decay\
    \ array size (decay-array-size)\n        The decay array size is the decay memory\
    \ divided by the time\n        granularity.  If integer truncation brings the\
    \ value of an array\n        element to zero, the array can be made smaller. \
    \ An\n        implementation should also impose a maximum reasonable array\n \
    \       size or allow more than one multiplication.\n                       decay-array-size\
    \ = (Tmax/delta-t)\n     decay array (decay[])\n        Each i-th element of the\
    \ decay array is the per tick delay\n        raised to the i-th power.  This might\
    \ be best done by successive\n        floating point multiplies followed by scaling\
    \ and integer\n        rounding or truncation.  The array itself need only be\
    \ computed\n        at startup.\n                            decay[i] = decay[1]\
    \ ** i\n"
- title: 4.6 Building the Reuse Index Arrays
  contents:
  - "4.6 Building the Reuse Index Arrays\n   The reuse lists may be accessed quite\
    \ frequently if a lot of routes\n   are flapping sufficiently to be suppressed.\
    \  A method of speeding the\n   determination of which reuse list to use for a\
    \ given route is\n   suggested.  This method is introduced in Section 4.2, its\n\
    \   configuration described in Section 4.4.2 and the algorithms described\n  \
    \ in Section 4.8.6 and Section 4.8.7.  This section describes building\n   the\
    \ reuse list index arrays.\n   A ratio of the figure of merit of the route under\
    \ consideration to\n   the cutoff value is used as the basis for an array lookup.\
    \  The ratio\n   is scaled and truncated to an integer and used to index the array.\n\
    \   The array entry is an integer used to determine which reuse list to\n   use.\n\
    \     reuse array maximum ratio (max-ratio)\n        This is the maximum ratio\
    \ between the current value of the\n        stability figure of merit and the\
    \ target reuse value that can be\n        indexed by the reuse array.  It may\
    \ be limited by the ceiling\n        imposed by the maximum hold time or by the\
    \ amount of time that\n        the reuse lists cover.\n          max-ratio = min(ceiling/reuse,\
    \ exp((1 / (half-life/reuse-\n       array-time)) * log(2)))\n     reuse array\
    \ scale factor ( scale-factor )\n        Since the reuse array is an estimator,\
    \ the reuse array scale\n        factor has to be computed such that the full\
    \ size of the reuse\n        array is used.\n            scale-factor = reuse-index-array-size\
    \ / (max-ratio - 1)\n     reuse index array (reuse-index-array[])\n        Each\
    \ reuse index array entry should contain an index into the\n        reuse list\
    \ array pointing to one of the list heads.  This index\n        should corresponding\
    \ to the reuse list that will be evaluated\n        just after a route would be\
    \ eligible for reuse given the ratio\n        of current value of the stability\
    \ figure of merit to target\n        reuse value corresponding the the reuse array\
    \ entry.\n          reuse-index-array[j] = integer((decay-half-life / reuse-\n\
    \       time-granularity) * log(1/(reuse * (1 + (j / scale-factor)))) /\n    \
    \   log(1/2))\n   To determine which reuse queue to place a route which is being\n\
    \   suppressed, the following procedure is used.  Divide the current\n   figure\
    \ of merit by the cutoff.  Subtract one.  Multiply by the scale\n   factor.  This\
    \ is the index into the reuse index array (reuse-index-\n   array[]).  The value\
    \ fetched from the reuse index array (reuse-\n   index-array[]) is an index into\
    \ the array of reuse lists (reuse-\n   array[]).  If this index is off the end\
    \ of the array use the last\n   queue otherwise look in the array and pick the\
    \ number of the queue\n   from the array at that index.  This is quite fast and\
    \ well worth the\n   setup and storage required.\n"
- title: 4.7 A Sample Configuration
  contents:
  - "4.7 A Sample Configuration\n   A simple example is presented here in which the\
    \ space overhead is\n   estimated for a set of configuration parameters.  The\
    \ design here\n   assumes:\n   1.  there is a single parameter set used for all\
    \ routes,\n   2.  decay time for unreachable routes is slower than for reachable\n\
    \       routes\n   3.  the arrays must be full size, rather than allow more than\
    \ one\n       multiply per decay operation to reduce the array size.\n   This\
    \ example is used in later sections.  The use of multiple\n   parameter sets complicates\
    \ the examples somewhat.  Where multiple\n   parameter sets are allowed for a\
    \ single route, the decay portion of\n   the algorithm is repeated for each parameter\
    \ set.  If different\n   routes are allowed to have different parameter sets,\
    \ the routes must\n   have pointers to the parameter sets to keep the time to\
    \ locate to a\n   minimum, but the algorithms are otherwise unchanged.\n   A sample\
    \ set of configuration parameters and a sample set of\n   implementation parameters\
    \ are provided in in the two following lists.\n     1.  Configuration Parameters\n\
    \        o cut = 1.25\n        o reuse = 0.5\n        o T-hold = 15 mins\n   \
    \     o decay-ok = 5 min\n        o decay-ng = 15 min\n        o Tmax-ok, Tmax-ng\
    \ = 15, 30 mins\n     2.  Implementation Parameters\n        o delta-t = 1 sec\n\
    \        o delta-reuse = 15 sec\n        o reuse-list-size = 256\n        o reuse-index-array-size\
    \ = 1,024\n   Using these configuration and implementation parameters and the\n\
    \   equations in Section 4.5, the space overhead can be computed.  There\n   is\
    \ a fixed space overhead that is independent of the number of\n   routes.  There\
    \ is a space requirement associated with a stable route.\n   There is a larger\
    \ space requirement associated with an unstable\n   route.  The space requirements\
    \ for the parameters above are provide\n   in the lists below.\n     1.  fixed\
    \ overhead (using parameters from previous example)\n        o 900 * integer -\
    \ decay array\n        o 1,800 * integer - decay array\n        o 120 * pointer\
    \ - reuse list-heads\n        o 2,048 * integer - reuse index arrays\n     2.\
    \  overhead per stable route\n        o pointer - containing null entry\n    \
    \ 3.  overhead per unstable route\n        o pointer - to a damping structure\
    \ containing the following\n        o integer - figure of merit  + bit for state\n\
    \        o integer - last time updated\n        o 2 * pointer - reuse list pointers\
    \ (prev, next)\n   The decay arrays are sized acording to delta-t and Tmax-ok\
    \ or Tmax-\n   ng.  The number of reuse list-heads is based on delta-reuse and\
    \ the\n   greater of Tmax-ok or Tmax-ng.  There are two reuse index arrays\n \
    \  whose size is a configured parameter.\n   Figure 3 shows the behavior of the\
    \ algorithm with the parameters\n   given above.  Four cases are given in this\
    \ example.  In all four,\n   there is a twelve minute period of route oscillations.\
    \  Two periods\n   of oscillation are used, 2 minutes and 4 minutes.  Two duty\
    \ cycles\n   are used, one in which the route is reachable during 20% of the cycle\n\
    \   and the other where the route is reachable during 80% of the cycle.\n   In\
    \ all four cases, the route becomes suppressed after it becomes\n   unreachable\
    \ the second time.  Once suppressed, it remains suppressed\n   until some period\
    \ after becoming stable.  The routes which oscillate\n   over a 4 minute period\
    \ are no longer suppressed within 9-11 minutes\n   after becoming stable.  The\
    \ routes with a 2 minute period of\n   oscillation are suppressed for nearly the\
    \ maximum 15 minute period\n   after becoming stable.\n"
- title: 4.8 Processing Routing Protocol Activity
  contents:
  - "4.8 Processing Routing Protocol Activity\n   The prior sections concentrate on\
    \ configuration parameters and their\n   relationship to the parameters and arrays\
    \ used at run time and\n   provide the algorithms for initializing run time storage.\
    \  This\n   section provides the steps taken in processing routing events and\n\
    \   timer events when running.\n   The routing events are:\n     1.  A BGP peer\
    \ or new route comes up for the first time (or after\n         an extended down\
    \ time) (Section 4.8.1)\n     2.  A route becomes unreachable (Section 4.8.2)\n\
    \     3.  A route becomes reachable again (Section 4.8.3)\n     4.  A route changes\
    \ (Section 4.8.4)\n     5.  A peer goes down (Section 4.8.5)\n     time      figure-of-merit\
    \ as a function of time (in minutes)\n     0.00    0.000 .         0.000 .   \
    \      0.000 .         0.000 .\n     0.62    0.000 .         0.000 .         0.000\
    \ .         0.000 .\n     1.25    0.000 .         0.000 .         0.000 .    \
    \     0.000 .\n     1.88    0.000 .         0.000 .         0.000 .         0.000\
    \ .\n     2.50    0.977  .        0.968  .        0.000 .         0.000 .\n  \
    \   3.12    0.949  .        0.888  .        0.000 .         0.000 .\n     3.75\
    \    0.910  .        0.814  .        0.000 .         0.000 .\n     4.37    1.846\
    \    .      1.756    .      0.983  .        0.983  .\n     5.00    1.794    .\
    \      1.614    .      0.955  .        0.935  .\n     5.63    1.735    .     \
    \ 1.480   .       0.928  .        0.858  .\n     6.25    2.619      .    2.379\
    \     .     0.901  .        0.786  .\n     6.88    2.544      .    2.207     .\
    \     0.876  .        0.721  .\n     7.50    2.472     .     2.024     .     0.825\
    \  .        0.661  .\n     8.13    3.308       .   2.875      .    1.761    .\
    \      1.608    .\n     8.75    3.213       .   2.698      .    1.711    .   \
    \   1.562    .\n     9.38    3.122       .   2.474     .     1.662    .      1.436\
    \   .\n    10.00    3.922        .  3.273       .   1.615    .      1.317   .\n\
    \    10.63    3.810        .  3.107       .   1.569    .      1.207   .\n    11.25\
    \    3.702        .  2.849      .    1.513    .      1.107   .\n    11.88    3.498\
    \       .   2.613      .    1.388   .       1.015   .\n    12.50    3.904    \
    \    .  3.451       .   2.312     .     1.953    .\n    13.13    3.580       \
    \ .  3.164       .   2.120     .     1.791    .\n    13.75    3.283       .  \
    \ 2.902      .    1.944    .      1.643    .\n    14.38    3.010       .   2.661\
    \      .    1.783    .      1.506    .\n    15.00    2.761      .    2.440   \
    \  .     1.635    .      1.381   .\n    15.63    2.532      .    2.238     . \
    \    1.499   .       1.267   .\n    16.25    2.321     .     2.052     .     1.375\
    \   .       1.161   .\n    16.88    2.129     .     1.882    .      1.261   .\
    \       1.065   .\n    17.50    1.952    .      1.725    .      1.156   .    \
    \   0.977  .\n    18.12    1.790    .      1.582    .      1.060   .       0.896\
    \  .\n    18.75    1.641    .      1.451   .       0.972  .        0.821  .\n\
    \    19.38    1.505    .      1.331   .       0.891  .        0.753  .\n    20.00\
    \    1.380   .       1.220   .       0.817  .        0.691  .\n    20.62    1.266\
    \   .       1.119   .       0.750  .        0.633  .\n    21.25    1.161   . \
    \      1.026   .       0.687  .        0.581  .\n    21.87    1.064   .      \
    \ 0.941  .        0.630  .        0.533  .\n    22.50    0.976  .        0.863\
    \  .        0.578  .        0.488 .\n    23.12    0.895  .        0.791  .   \
    \     0.530  .        0.448 .\n    23.75    0.821  .        0.725  .        0.486\
    \ .         0.411 .\n    24.37    0.753  .        0.665  .        0.446 .    \
    \     0.377 .\n    25.00    0.690  .        0.610  .        0.409 .         0.345\
    \ .\n Figure 3: Some fairly long route flap cycles, repeated for 12 minutes,\n\
    \                   followed by a period of stability.\n   The reuse list is used\
    \ to provide a means of fast evaluation of route\n   that had been suppressed,\
    \ but had been stable long enough to be\n   reused again or had been suppressed\
    \ long enough that it can be\n   treated as a new route.  The following two operations\
    \ are described.\n     1.  Inserting into a reuse list (Section 4.8.6)\n     2.\
    \  Reuse list processing every delta-t seconds (Section 4.8.7)\n"
- title: 4.8.1 Processing a New Peer or New Routes
  contents:
  - "4.8.1 Processing a New Peer or New Routes\n   When a peer comes up, no action\
    \ is required if the routes had no\n   previous history of instability, for example\
    \ if this is the first\n   time the peer is coming up and announcing these routes.\
    \  For each\n   route, the pointer to the damping structure would be zeroed and\
    \ route\n   used.  The same action is taken for a new route or a route that has\n\
    \   been down long enough that the figure of merit reached zero and the\n   damping\
    \ structure was deleted.\n"
- title: 4.8.2 Processing Unreachable Messages
  contents:
  - "4.8.2 Processing Unreachable Messages\n   When a route is withdrawn or changed\
    \ (Section 4.8.4 describes how a\n   change is handled), the following procedure\
    \ is used.\n   If there is no previous stability history (the damping structure\n\
    \   pointer is zero), then:\n     1.  allocate a damping structure\n     2.  set\
    \ figure-of-merit = 1\n     3.  withdraw the route\n   Otherwise, if there is\
    \ an existing damping structure, then:\n     1.  set t-diff = t-now - t-updated\n\
    \     2.  if (t-diff puts you off the end of the array) {\n      setfigure-of-merit\
    \ =1\n    }else {\n      setfigure-of-merit =figure-of-merit *decay-array-ok [t-diff\
    \ ]+ 1\n      if(figure-of-merit >ceiling) {\n        setfigure-of-merit =ceiling\n\
    \      }\n    }\n     3.  remove the route from a reuse list if it is on one\n\
    \     4.  withdraw the route unless it is already suppressed\n   In either case\
    \ then:\n     1.  set t-updated = t-now\n     2.  insert into a reuse list (see\
    \ Section 4.8.6)\n   If there was a stability history, the previous value of the\
    \ stability\n   figure of merit is decayed.  This is done using the decay array\n\
    \   (decay-array).  The index is determined by subtracting the current\n   time\
    \ and the last time updated, then dividing by the time\n   granularity.  If the\
    \ index is zero, the figure of merit is unchanged\n   (no decay).  If it is greater\
    \ than the array size, it is zeroed.\n   Otherwise use the index to fetch a decay\
    \ array element and multiply\n   the figure of merit by the array element.  If\
    \ using the suggested\n   scaled integer method, shift down half an integer. \
    \ Add the scaled\n   penalty for one more unreachable (shown above as 1).  If\
    \ the result\n   is above the ceiling replace it with the ceiling value.  Now\
    \ update\n   the last time updated field (preferably taking into account how much\n\
    \   time was truncated before doing the decay calculation).\n   When a route becomes\
    \ unreachable, alternate paths must be considered.\n   This process is complicated\
    \ slightly if different configuration\n   parameters are used in the presence\
    \ or absence of viable alternate\n   paths.  If all of these alternate paths have\
    \ been suppressed because\n   there had previously been an alternate route and\
    \ the new route\n   withdrawal changes that condition, the suppressed alternate\
    \ paths\n   must be reevaluated.  They should be reevaluated in order of normal\n\
    \   route preference.  When one of these alternate routes is encountered\n   that\
    \ had been suppressed but is now usable since there is no\n   alternate route,\
    \ no further routes need to be reevaluated.  This only\n   applies if routes are\
    \ given two different reuse thresholds, one for\n   use when there is an alternate\
    \ path and a higher threshold to use\n   when suppressing the route would result\
    \ in making the destination\n   completely unreachable.\n"
- title: 4.8.3 Processing Route Advertisements
  contents:
  - "4.8.3 Processing Route Advertisements\n   When a route is readvertised if there\
    \ is no damping structure, then\n   the procedure is the same as in Section 4.8.1.\n\
    \     1.  don't create a new damping structure\n     2.  use the route\n   If\
    \ an damping structure exists, the figure of merit is decayed and\n   the figure\
    \ of merit and last time updated fields are updated.  A\n   decision is now made\
    \ as to whether the route can be used immediately\n   or needs to be suppressed\
    \ for some period of time.\n     1.  set t-diff = t-now - t-updated\n     2. \
    \ if (t-diff puts you off the end of the array) {\n           set figure-of-merit\
    \ =0\n         }else {\n           set figure-of-merit= figure-of-merit* decay-array-ng[t-diff]\n\
    \         }\n     3.  if ( not suppressed and figure-of-merit < cut ) {\n    \
    \       use the route\n         }else if( suppressed and figure-of-merit< reuse)\
    \ {\n           set state tonot suppressed\n           remove the route from a\
    \ reuse list\n           use the route\n         }else {\n           set state\
    \ to suppressed\n           don't use the route\n           insert into a reuse\
    \ list (see Section 4.8.6)\n         }\n     4.  if ( figure-of-merit > 0 ) {\n\
    \           set t-updated= t-now\n         }else {\n           recover memory\
    \ for damping struct\n           zero pointer to damping struct\n         }\n\
    \   If the route is deemed usable, a search for the current best route\n   must\
    \ be made.  The newly reachable route is then evaluated according\n   to the BGP\
    \ protocol rules for route selection.\n   If the new route is usable, the previous\
    \ best route is examined.\n   Prior to route comparisons, the current best route\
    \ may have to be\n   reevaluated if separate parameter sets are used depending\
    \ on the\n   presence or absence of an alternate route.  If there had been no\n\
    \   alternate the previous best route may be suppressed.\n   If the new route\
    \ is to be suppressed it is placed on a reuse list\n   only if it would have been\
    \ preferred to the current best route had\n   the new route been accepted as stable.\
    \  There is no reason to queue a\n   route on a reuse list if after the route\
    \ becomes usable it would not\n   be used anyway due to the existence of a more\
    \ preferred route.  Such\n   a route would not have to be reevaluated unless the\
    \ preferred route\n   became unreachable.  As specified here, the less preferred\
    \ route\n   would be reevaluated and potentially used or potentially added to\
    \ a\n   reuse list when processing the withdrawal of a more preferred best\n \
    \  route.\n"
- title: 4.8.4 Processing Route Changes
  contents:
  - "4.8.4 Processing Route Changes\n   If a route is replaced by a peer router by\
    \ supplying a new path, the\n   route that is being replaced should be treated\
    \ as if an unreachable\n   were received (see Section 4.8.2).  This will occur\
    \ when a peer\n   somewhere back in the AS path is continuously switching between\
    \ two\n   AS paths and that peer is not damping route flap (or applying less\n\
    \   damping).  There is no way to determine if one AS path is stable and\n   the\
    \ other is flapping, or if they are both flapping.  If the cycle is\n   sufficiently\
    \ short compared to convergence times neither route\n   through that peer will\
    \ deliver packets very reliably.  Since there is\n   no way to affect the peer\
    \ such that it chooses the stable of the two\n   AS paths, the only viable option\
    \ is to penalize both routes by\n   considering each change as an unreachable\
    \ followed by a route\n   advertisement.\n"
- title: 4.8.5 Processing A Peer Router Loss
  contents:
  - "4.8.5 Processing A Peer Router Loss\n   When a peer routing session is broken,\
    \ either all individual routes\n   advertised by that peer may be marked as unstable,\
    \ or the peering\n   session itself may be marked as unstable.  Marking the peer\
    \ will save\n   considerable memory.  Since the individual routes are advertised\
    \ as\n   unreachable to routers beyond the immediate problem, per route state\n\
    \   will be incurred beyond the peer immediately adjacent to the BGP\n   session\
    \ that went down.  If the instability continues, the\n   immediately adjacent\
    \ router need only keep track of the peer\n   stability history.  The routers\
    \ beyond that point will receive no\n   further advertisements or withdrawal of\
    \ routes and will dispose of\n   the damping structure over time.\n   BGP notification\
    \ through an optional transitive attribute that\n   damping will already be applied\
    \ may be considered in the future to\n   reduce the number of routers that incur\
    \ damping structure storage\n   overhead.\n"
- title: 4.8.6 Inserting into the Reuse Timer List
  contents:
  - "4.8.6 Inserting into the Reuse Timer List\n   The reuse lists are used to provide\
    \ a means of fast evaluation of\n   route that had been suppressed, but had been\
    \ stable long enough to be\n   reused again.  The data structure consists of a\
    \ series of list heads.\n   Each list contains a set of routes that are scheduled\
    \ for\n   reevaluation at approximately the same time.  The set of reuse list\n\
    \   heads are treated as a circular array.  Refer to Figure 4.\n   A simple implementation\
    \ of the circular array of list heads would be\n   an array containing the list\
    \ heads.  An offset is used when accessing\n   the array.  The offset would identify\
    \ the first list.  The Nth list\n   would be at the index corresponding to N plus\
    \ the offset modulo the\n   number of list heads.  This design will be assumed\
    \ in the examples\n   that follow.\n   A key requirement is to be able to insert\
    \ an entry in the most\n   appropriate queue with a minimum of computation.  The\
    \ computation is\n   given only the current value of figure-of-merit.  Instead\
    \ of a\n   computation which would involve a logarithm, the reuse array (reuse-\n\
    \   array[]) described in Section 4.6 is used.  The array, scale, and\n   bounds\
    \ are precomputed to map figure-of-merit to the nearest list\n   head without\
    \ requiring a logarithm to be computed (see Section 4.5).\n       +-+    +-+ \
    \   +-+          non-empty linked list means\n       | |    | |    | |     <--\
    \  that there are routes with\n       +-+    +-+    +-+          defered action\
    \ to be taken\n        ^      ^      ^           N * delta-reuse seconds later.\n\
    \        |      |      |\n     +------+------+------+------+------+      +------+\n\
    \     | list | list | list | list | list |  ... | list |\n     | head | head |\
    \ head | head | head |  ... | head |\n     +------+------+------+------+------+\
    \      +------+\n        ^      ^      ^      ^      ^             ^\n       Nth\
    \    1st    2nd    3rd    4th           N-1\n               |\n       offset to\
    \ first list\n       (the offset is incremented every delta-reuse seconds)\n \
    \                  Figure 4: Reuse List Data Structures\n   Note that in the following\
    \ sections the operator prefix notation\n   \"modulo a b\" means \"b % a\" in\
    \ C language algebraic operator notation.\n   For example, \"modulo 16 1023\"\
    \ would be 15.\n     1.  scale figure-of-merit for the index array lookup producing\n\
    \         index\n     2.  check index against the array bound\n     3.  if (within\
    \ the array bound) {\n           set index =reuse-array [index ]\n         }else\
    \ {\n           set index =reuse-list-size -1\n         }\n     4.  insert into\
    \ the list\n           reuse-list[ moduloreuse-list-size (index +offset )]\n \
    \  Choosing the correct reuse list involves only a multiply and shift to\n   do\
    \ the scaling, an integer truncation, then an array lookup in the\n   reuse array\
    \ (reuse-array[]).  The value retrieved from the reuse\n   array is used to select\
    \ a reuse list.  The reuse list is a circular\n   list.  The most common method\
    \ of implementing a circular list is to\n   use an array and apply an offset and\
    \ modulo operation to pick the\n   correct array entry.  The offset is incremented\
    \ to rotate the\n   circular list.\n"
- title: 4.8.7 Handling Reuse Timer Events
  contents:
  - "4.8.7 Handling Reuse Timer Events\n   The granularity of the reuse timer should\
    \ be more coarse than that of\n   the decay timer.  As a result, when the reuse\
    \ timer fires, suppressed\n   routes should be decayed by multiple increments\
    \ of decay time.  Some\n   computation can be avoided by always inserting into\
    \ the reuse list\n   corresponding to one time increment past reuse eligibility.\
    \  In cases\n   where the reuse lists have a longer \"memory\" than the \"decay\
    \ memory\"\n   (described above), all of the routes in the first queue will be\n\
    \   available for immediate reuse if reachable or the history entry could\n  \
    \ be disposed of if unreachable.\n   When it is time to advance the lists, the\
    \ first queue on the reuse\n   list must be processed and the circular queue must\
    \ be rotated.  Using\n   an array and an offset as a circular array (as described\
    \ in Section\n   4.8.6), the algorithm below is repeated every delta-reuse seconds.\n\
    \     1.  save a pointer to the current zeroth queue head and zero the\n     \
    \    list head entry\n     2.  set offset = modulo reuse-list-size ( offset +\
    \ 1 ), thereby\n         rotating the circular queue of list-heads\n     3.  if\
    \ ( the saved list head pointer is non-empty )\n         for each entry {\n  \
    \         sett-diff =t-now -t-updated\n           set figure-of-merit =figure-of-merit\
    \ *decay-array-ok [t-diff ]\n           sett-updated =t-now\n           if( figure-of-merit<\
    \ reuse)\n             reuse the route\n           else\n             re-insert\
    \ into another list (seeSection 4.8.6)\n         }\n   The value of the zeroth\
    \ list head would be saved and the array entry\n   itself zeroed.  The list heads\
    \ would then be advanced by incrementing\n   the offset.  Starting with the saved\
    \ head of the old zeroth list,\n   each route would be reevaluated and used, disposed\
    \ of entirely or\n   requeued if it were not ready for reuse.  If a route is used,\
    \ it must\n   be treated as if it were a new route advertisement as described\
    \ in\n   Section 4.8.3.\n"
- title: 5 Implementation Experience
  contents:
  - "5 Implementation Experience\n   The first implementations of \"route flap damping\"\
    \ were the route\n   server daemon (rsd) coding by Ramesh Govindan (ISI) and the\
    \ Cisco IOS\n   implementation by Ravi Chandra.  Both implementations first became\n\
    \   available in 1995 and have been used extensively.  The rsd\n   implementation\
    \ has been in use in route servers at the NSF funded\n   Network Access Points\
    \ (NAPs) and at other major Internet\n   interconnects.  The Cisco IOS version\
    \ has been in use by Internet\n   Service Providers worldwide.  The rsd implementation\
    \ has been\n   integrated in releases of gated (see http://www.gated.org) and\
    \ is\n   available in commercial routers using gated.\n   There are now more than\
    \ 2 years of BGP route damping deployment\n   experience.  Some problems have\
    \ occurred in deployment.  So far these\n   are solvable by careful implementation\
    \ of the algorithm and by\n   careful deployment.  In some topologies coordinated\
    \ deployment can be\n   helpful and in all cases disclosure of the use of route\
    \ damping and\n   the parameters used is highly beneficial in debugging connectivity\n\
    \   problems.\n   Some of the problems have occurred due to subtle implementation\n\
    \   errors.  Route damping should never be applied on IBGP learned\n   routes.\
    \  To do so can open the possibility for persistent route\n   loops.  When IBGP\
    \ routes within an AS are inconsistent, route loops\n   can easily form.  Suppressing\
    \ IBGP learned routes causes such\n   inconsistencies.  Implementations should\
    \ disallow configuration of\n   route damping on IBGP peers.\n   Penalties for\
    \ instability should only be applied when a route is\n   removed or replaced and\
    \ not when a route is added.  If damping\n   parameters are applied consistently,\
    \ this implementation constraint\n   will result in a stable secondary path being\
    \ preferred over an\n   unstable primary path due to damping of the primary path\
    \ near the\n   source.\n   In topologies where multiple AS paths to a given destination\
    \ exist\n   flapping of the primary path can result in suppression of the\n  \
    \ secondary path.  This can occur if no damping is being done near the\n   cause\
    \ of the route flap or if damping is being applied more\n   aggressively by a\
    \ distant AS. This problem can be solved in one of\n   two ways.  Damping can\
    \ be done near the source of the route flap and\n   the damping parameters can\
    \ be made consistent.  Alternately, a\n   distant AS which insists on more aggressive\
    \ damping parameters can\n   disable penalizing routes on AS path change, penalizing\
    \ routes only\n   if they are withdrawn completely.  In order to do so, the\n\
    \   implementation must support this option (as described in Section\n   4.4.3).\n\
    \   Route flap should be damped near the source.  Single homed\n   destinations\
    \ can be covered by static routes.  Aggregation provides\n   another means of\
    \ damping.  Providers should damp their own internal\n   problems, however damping\
    \ on IGP link state origination is not yet\n   implemented by router vendors.\
    \  Providers which use multiple AS\n   within their own topology should damp between\
    \ their own AS. Providers\n   should damp adjacent providers AS.\n   Damping provides\
    \ a means to limit propagation excessive route change\n   when connectivity is\
    \ highly intermittent.  Once a problem is\n   corrected, damping state corresponding\
    \ to the prefixes known to be\n   damped due to the problem just fixed can be\
    \ manually cleared.  In\n   order to determine where damping may have occurred\
    \ after connectivity\n   problems, providers should publish their damping parameters.\n\
    \   Providers should be willing to manually clear damping on specific\n   prefixes\
    \ or AS paths at the request of other providers when the\n   request is accompanied\
    \ by credible assurance that the problem has\n   truly been addressed.\n   By\
    \ damping their own routing information, providers can reduce their\n   own need\
    \ to make requests of other providers to clear damping state\n   after correcting\
    \ a problem.  Providers should be pro-active and\n   monitor what prefixes and\
    \ paths are suppressed in addition to\n   monitoring link states and BGP session\
    \ state.\n"
- title: Acknowledgements
  contents:
  - "Acknowledgements\n   This work and this document may not have been completed\
    \ without the\n   advise, comments and encouragement of Yakov Rekhter (Cisco).\
    \  Dennis\n   Ferguson (MCI) provided a description of the algorithms in the gated\n\
    \   BGP implementation and many valuable comments and insights.  David\n   Bolen\
    \ (ANS) and Jordan Becker (ANS) provided valuable comments,\n   particularly regarding\
    \ early simulations.  Over four years elapsed\n   between the initial draft presented\
    \ to the BGP WG (October 1993) and\n   this iteration.  At the time of this writing\
    \ there is significant\n   experience with two implementations, each having been\
    \ deployed since\n   1995.  One was led by Ramesh Govindan (ISI) for the NSF Routing\n\
    \   Arbiter project.  The second was led by Ravi Chandra (Cisco).  Sean\n   Doran\
    \ (Sprintlink) and Serpil Bayraktar (ANS) were among the early\n   independent\
    \ testers of the Cisco pre-beta implementation.  Valuable\n   comments and implementation\
    \ feedback were shared by many individuals\n   on the IETF IDR WG and the RIPE\
    \ Routing Work Group and in NANOG and\n   IEPG.\n   Thanks also to Rob Coltun\
    \ (Fore Systems), Sanjay Wadhwa (Fore), John\n   Scudder (IENG), Eric Bennet (IENG)\
    \ and Jayesh Bhatt (Bay Networks)\n   for pointing out errors in the math uncovered\
    \ during coding of more\n   recent implementations.  These errors appeared in\
    \ the details of the\n   implementation suggestion sections written after the\
    \ first two\n   implementations were completed.  Thanks also to Vern Paxson for\
    \ a\n   very thorough review resulting in numerous clarifications to the\n   document.\n"
- title: References
  contents:
  - "References\n   [1] Gross, P., and Y. Rekhter, \"Application of the border gateway\n\
    \       protocol in the internet\", RFC 1268, October 1991.\n   [2] ISO/IEC. \
    \ Iso/iec 10747 - information technology - telecommuni-\n       cations and information\
    \ exchange between systems - protocol for\n       exchange of inter-domain routeing\
    \ information among intermediate\n       systems to support forwarding of iso\
    \ 8473 pdus.  Technical\n       report, International Organization for Standardization,\
    \ August\n       1994.  ftp://merit.edu/pub/iso/idrp.ps.gz.\n   [3] Lougheed,\
    \ K., and Y. Rekhter, \"A border gateway protocol 3 (BGP-\n       3)\", RFC 1267,\
    \ October 1991.\n   [4] Rekhter, Y., and P. Gross, \"Application of the border\
    \ gateway\n       protocol in the internet\", RFC 1772, March 1995.\n   [5] Rekhter,\
    \ Y., and T. Li, \"A border gateway protocol 4 (BGP-4)\",\n       RFC 1771, March\
    \ 1995.\n   [6] Rekhter, Y., and C. Topolcic,\"Exchanging routing information\n\
    \       across provider boundaries in the CIDR environment\", RFC 1520,\n    \
    \   September 1993.\n   [7] Traina, P., \"BGP-4 protocol analysis\", RFC 1774,\
    \ March 1995.\n   [8] Traina, P., \"Experience with the BGP-4 protocol\", RFC\
    \ 1773, March\n       1995.\n"
- title: Security Considerations
  contents:
  - "Security Considerations\n   The practices outlined in this document do not further\
    \ weaken the\n   security of the routing protocols.  Denial of service is possible\
    \ in\n   an already insecure routing environment but these practices only\n  \
    \ contribute to the persistence of such attacks and do not impact the\n   methods\
    \ of prevention and the methods of determining the source.\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Curtis Villamizar\n   ANS\n   EMail: curtis@ans.net\n\
    \   Ravi Chandra\n   Cisco Systems\n   EMail: rchandra@cisco.com\n   Ramesh Govindan\n\
    \   ISI\n   EMail: govindan@isi.edu\n"
- title: Full Copyright Statement
  contents:
  - "Full Copyright Statement\n   Copyright (C) The Internet Society (1998).  All\
    \ Rights Reserved.\n   This document and translations of it may be copied and\
    \ furnished to\n   others, and derivative works that comment on or otherwise explain\
    \ it\n   or assist in its implementation may be prepared, copied, published\n\
    \   and distributed, in whole or in part, without restriction of any\n   kind,\
    \ provided that the above copyright notice and this paragraph are\n   included\
    \ on all such copies and derivative works.  However, this\n   document itself\
    \ may not be modified in any way, such as by removing\n   the copyright notice\
    \ or references to the Internet Society or other\n   Internet organizations, except\
    \ as needed for the purpose of\n   developing Internet standards in which case\
    \ the procedures for\n   copyrights defined in the Internet Standards process\
    \ must be\n   followed, or as required to translate it into languages other than\n\
    \   English.\n   The limited permissions granted above are perpetual and will\
    \ not be\n   revoked by the Internet Society or its successors or assigns.\n \
    \  This document and the information contained herein is provided on an\n   \"\
    AS IS\" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING\n   TASK FORCE\
    \ DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING\n   BUT NOT LIMITED\
    \ TO ANY WARRANTY THAT THE USE OF THE INFORMATION\n   HEREIN WILL NOT INFRINGE\
    \ ANY RIGHTS OR ANY IMPLIED WARRANTIES OF\n   MERCHANTABILITY OR FITNESS FOR A\
    \ PARTICULAR PURPOSE.\n"
