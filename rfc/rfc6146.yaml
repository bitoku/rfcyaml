- title: __initial_text__
  contents:
  - "        Stateful NAT64: Network Address and Protocol Translation\n          \
    \         from IPv6 Clients to IPv4 Servers\n"
- title: Abstract
  contents:
  - "Abstract\n   This document describes stateful NAT64 translation, which allows\n\
    \   IPv6-only clients to contact IPv4 servers using unicast UDP, TCP, or\n   ICMP.\
    \  One or more public IPv4 addresses assigned to a NAT64\n   translator are shared\
    \ among several IPv6-only clients.  When stateful\n   NAT64 is used in conjunction\
    \ with DNS64, no changes are usually\n   required in the IPv6 client or the IPv4\
    \ server.\n"
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This is an Internet Standards Track document.\n   This\
    \ document is a product of the Internet Engineering Task Force\n   (IETF).  It\
    \ represents the consensus of the IETF community.  It has\n   received public\
    \ review and has been approved for publication by the\n   Internet Engineering\
    \ Steering Group (IESG).  Further information on\n   Internet Standards is available\
    \ in Section 2 of RFC 5741.\n   Information about the current status of this document,\
    \ any errata,\n   and how to provide feedback on it may be obtained at\n   http://www.rfc-editor.org/info/rfc6146.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (c) 2011 IETF Trust and the persons identified\
    \ as the\n   document authors.  All rights reserved.\n   This document is subject\
    \ to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n\
    \   (http://trustee.ietf.org/license-info) in effect on the date of\n   publication\
    \ of this document.  Please review these documents\n   carefully, as they describe\
    \ your rights and restrictions with respect\n   to this document.  Code Components\
    \ extracted from this document must\n   include Simplified BSD License text as\
    \ described in Section 4.e of\n   the Trust Legal Provisions and are provided\
    \ without warranty as\n   described in the Simplified BSD License.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1.  Introduction . . . . . . . . . . . . . . . . . . .\
    \ . . . . . .  4\n     1.1.  Features of Stateful NAT64 . . . . . . . . . . .\
    \ . . . . .  5\n     1.2.  Overview . . . . . . . . . . . . . . . . . . . . .\
    \ . . . .  6\n       1.2.1.  Stateful NAT64 Solution Elements . . . . . . . .\
    \ . . .  6\n       1.2.2.  Stateful NAT64 Behavior Walk-Through . . . . . . .\
    \ . .  8\n       1.2.3.  Filtering  . . . . . . . . . . . . . . . . . . . . .\
    \ . 10\n   2.  Terminology  . . . . . . . . . . . . . . . . . . . . . . . . .\
    \ 11\n   3.  Stateful NAT64 Normative Specification . . . . . . . . . . . . 14\n\
    \     3.1.  Binding Information Bases  . . . . . . . . . . . . . . . . 14\n  \
    \   3.2.  Session Tables . . . . . . . . . . . . . . . . . . . . . . 15\n    \
    \ 3.3.  Packet Processing Overview . . . . . . . . . . . . . . . . 17\n     3.4.\
    \  Determining the Incoming Tuple . . . . . . . . . . . . . . 18\n     3.5.  Filtering\
    \ and Updating Binding and Session Information . . 20\n       3.5.1.  UDP Session\
    \ Handling . . . . . . . . . . . . . . . . . 21\n         3.5.1.1.  Rules for\
    \ Allocation of IPv4 Transport\n                   Addresses for UDP  . . . .\
    \ . . . . . . . . . . . . 23\n       3.5.2.  TCP Session Handling . . . . . .\
    \ . . . . . . . . . . . 24\n         3.5.2.1.  State Definition . . . . . . .\
    \ . . . . . . . . . . 24\n         3.5.2.2.  State Machine for TCP Processing\
    \ in the NAT64  . . 25\n         3.5.2.3.  Rules for Allocation of IPv4 Transport\n\
    \                   Addresses for TCP  . . . . . . . . . . . . . . . . 33\n  \
    \     3.5.3.  ICMP Query Session Handling  . . . . . . . . . . . . . 33\n    \
    \   3.5.4.  Generation of the IPv6 Representations of IPv4\n               Addresses\
    \  . . . . . . . . . . . . . . . . . . . . . . 36\n     3.6.  Computing the Outgoing\
    \ Tuple . . . . . . . . . . . . . . . 36\n       3.6.1.  Computing the Outgoing\
    \ 5-Tuple for TCP, UDP, and\n               for ICMP Error Messages Containing\
    \ a TCP or UDP\n               Packets  . . . . . . . . . . . . . . . . . . .\
    \ . . . . 37\n       3.6.2.  Computing the Outgoing 3-Tuple for ICMP Query\n \
    \              Messages and for ICMP Error Messages Containing an\n          \
    \     ICMP Query . . . . . . . . . . . . . . . . . . . . . . 38\n     3.7.  Translating\
    \ the Packet . . . . . . . . . . . . . . . . . . 38\n     3.8.  Handling Hairpinning\
    \ . . . . . . . . . . . . . . . . . . . 39\n   4.  Protocol Constants . . . .\
    \ . . . . . . . . . . . . . . . . . . 39\n   5.  Security Considerations  . .\
    \ . . . . . . . . . . . . . . . . . 40\n     5.1.  Implications on End-to-End\
    \ Security  . . . . . . . . . . . 40\n     5.2.  Filtering  . . . . . . . . .\
    \ . . . . . . . . . . . . . . . 40\n     5.3.  Attacks on NAT64 . . . . . . .\
    \ . . . . . . . . . . . . . . 41\n     5.4.  Avoiding Hairpinning Loops . . .\
    \ . . . . . . . . . . . . . 42\n   6.  Contributors . . . . . . . . . . . . .\
    \ . . . . . . . . . . . . 43\n   7.  Acknowledgements . . . . . . . . . . . .\
    \ . . . . . . . . . . . 43\n   8.  References . . . . . . . . . . . . . . . .\
    \ . . . . . . . . . . 43\n     8.1.  Normative References . . . . . . . . . .\
    \ . . . . . . . . . 43\n     8.2.  Informative References . . . . . . . . . .\
    \ . . . . . . . . 44\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   This document specifies stateful NAT64, a mechanism for\
    \ IPv4-IPv6\n   transition and IPv4-IPv6 coexistence.  Together with DNS64 [RFC6147],\n\
    \   these two mechanisms allow an IPv6-only client to initiate\n   communications\
    \ to an IPv4-only server.  They also enable peer-to-peer\n   communication between\
    \ an IPv4 and an IPv6 node, where the\n   communication can be initiated when\
    \ either end uses existing, NAT-\n   traversal, peer-to-peer communication techniques,\
    \ such as Interactive\n   Connectivity Establishment (ICE) [RFC5245].  Stateful\
    \ NAT64 also\n   supports IPv4-initiated communications to a subset of the IPv6\
    \ hosts\n   through statically configured bindings in the stateful NAT64.\n  \
    \ Stateful NAT64 is a mechanism for translating IPv6 packets to IPv4\n   packets\
    \ and vice versa.  The translation is done by translating the\n   packet headers\
    \ according to the IP/ICMP Translation Algorithm defined\n   in [RFC6145].  The\
    \ IPv4 addresses of IPv4 hosts are algorithmically\n   translated to and from\
    \ IPv6 addresses by using the algorithm defined\n   in [RFC6052] and an IPv6 prefix\
    \ assigned to the stateful NAT64 for\n   this specific purpose.  The IPv6 addresses\
    \ of IPv6 hosts are\n   translated to and from IPv4 addresses by installing mappings\
    \ in the\n   normal Network Address Port Translation (NAPT) manner [RFC3022].\
    \  The\n   current specification only defines how stateful NAT64 translates\n\
    \   unicast packets carrying TCP, UDP, and ICMP traffic.  Multicast\n   packets\
    \ and other protocols, including the Stream Control\n   Transmission Protocol\
    \ (SCTP), the Datagram Congestion Control\n   Protocol (DCCP), and IPsec, are\
    \ out of the scope of this\n   specification.\n   DNS64 is a mechanism for synthesizing\
    \ AAAA resource records (RRs)\n   from A RRs.  The IPv6 address contained in the\
    \ synthetic AAAA RR is\n   algorithmically generated from the IPv4 address and\
    \ the IPv6 prefix\n   assigned to a NAT64 device by using the same algorithm defined\
    \ in\n   [RFC6052].\n   Together, these two mechanisms allow an IPv6-only client\
    \ (i.e., a\n   host with a networking stack that only implements IPv6, a host\
    \ with a\n   networking stack that implements both protocols but with only IPv6\n\
    \   connectivity, or a host running an IPv6-only application) to initiate\n  \
    \ communications to an IPv4-only server (which is analogous to the\n   IPv6-only\
    \ host above).\n   These mechanisms are expected to play a critical role in IPv4-IPv6\n\
    \   transition and IPv4-IPv6 coexistence.  Due to IPv4 address depletion,\n  \
    \ it is likely that in the future, the new clients will be IPv6-only\n   and they\
    \ will want to connect to the existing IPv4-only servers.  The\n   stateful NAT64\
    \ and DNS64 mechanisms are easily deployable, since they\n   do not require changes\
    \ to either the IPv6 client or the IPv4 server.\n   For basic functionality, the\
    \ approach only requires the deployment of\n   the stateful NAT64 function in\
    \ the devices connecting an IPv6-only\n   network to the IPv4-only network, along\
    \ with the deployment of a few\n   DNS64-enabled name servers accessible to the\
    \ IPv6-only hosts.  An\n   analysis of the application scenarios can be found\
    \ in [RFC6144].\n   For brevity, in the rest of the document, we will refer to\
    \ the\n   stateful NAT64 either as stateful NAT64 or simply as NAT64.\n"
- title: 1.1.  Features of Stateful NAT64
  contents:
  - "1.1.  Features of Stateful NAT64\n   The features of NAT64 are:\n   o  NAT64\
    \ is compliant with the recommendations for how NATs should\n      handle UDP\
    \ [RFC4787], TCP [RFC5382], and ICMP [RFC5508].  As such,\n      NAT64 only supports\
    \ Endpoint-Independent Mappings and supports\n      both Endpoint-Independent\
    \ and Address-Dependent Filtering.\n      Because of the compliance with the aforementioned\
    \ requirements,\n      NAT64 is compatible with current NAT traversal techniques,\
    \ such as\n      ICE [RFC5245], and with other NAT traversal techniques.\n   o\
    \  In the absence of preexisting state in a NAT64, only IPv6 nodes\n      can\
    \ initiate sessions to IPv4 nodes.  This works for roughly the\n      same class\
    \ of applications that work through IPv4-to-IPv4 NATs.\n   o  Depending on the\
    \ filtering policy used (Endpoint-Independent, or\n      Address-Dependent), IPv4-nodes\
    \ might be able to initiate sessions\n      to a given IPv6 node, if the NAT64\
    \ somehow has an appropriate\n      mapping (i.e., state) for an IPv6 node, via\
    \ one of the following\n      mechanisms:\n      *  The IPv6 node has recently\
    \ initiated a session to the same or\n         another IPv4 node.  This is also\
    \ the case if the IPv6 node has\n         used a NAT-traversal technique (such\
    \ as ICE).\n      *  A statically configured mapping exists for the IPv6 node.\n\
    \   o  IPv4 address sharing: NAT64 allows multiple IPv6-only nodes to\n      share\
    \ an IPv4 address to access the IPv4 Internet.  This helps\n      with the forthcoming\
    \ IPv4 exhaustion.\n   o  As currently defined in this NAT64 specification, only\
    \ TCP, UDP,\n      and ICMP are supported.  Support for other protocols (such\
    \ as\n      other transport protocols and IPsec) is to be defined in separate\n\
    \      documents.\n"
- title: 1.2.  Overview
  contents:
  - "1.2.  Overview\n   This section provides a non-normative introduction to NAT64.\
    \  This is\n   achieved by describing the NAT64 behavior involving a simple setup\n\
    \   that involves a single NAT64 device, a single DNS64, and a simple\n   network\
    \ topology.  The goal of this description is to provide the\n   reader with a\
    \ general view of NAT64.  It is not the goal of this\n   section to describe all\
    \ possible configurations nor to provide a\n   normative specification of the\
    \ NAT64 behavior.  So, for the sake of\n   clarity, only TCP and UDP are described\
    \ in this overview; the details\n   of ICMP, fragmentation, and other aspects\
    \ of translation are\n   purposefully avoided in this overview.  The normative\
    \ specification\n   of NAT64 is provided in Section 3.\n   The NAT64 mechanism\
    \ is implemented in a device that has (at least)\n   two interfaces, an IPv4 interface\
    \ connected to the IPv4 network, and\n   an IPv6 interface connected to the IPv6\
    \ network.  Packets generated\n   in the IPv6 network for a receiver located in\
    \ the IPv4 network will\n   be routed within the IPv6 network towards the NAT64\
    \ device.  The\n   NAT64 will translate them and forward them as IPv4 packets\
    \ through\n   the IPv4 network to the IPv4 receiver.  The reverse takes place\
    \ for\n   packets generated by hosts connected to the IPv4 network for an IPv6\n\
    \   receiver.  NAT64, however, is not symmetric.  In order to be able to\n   perform\
    \ IPv6-IPv4 translation, NAT64 requires state.  The state\n   contains the binding\
    \ of an IPv6 address and TCP/UDP port (hereafter\n   called an IPv6 transport\
    \ address) to an IPv4 address and TCP/UDP port\n   (hereafter called an IPv4 transport\
    \ address).\n   Such binding state is either statically configured in the NAT64\
    \ or it\n   is created when the first packet flowing from the IPv6 network to\
    \ the\n   IPv4 network is translated.  After the binding state has been\n   created,\
    \ packets flowing in both directions on that particular flow\n   are translated.\
    \  The result is that, in the general case, NAT64 only\n   supports communications\
    \ initiated by the IPv6-only node towards an\n   IPv4-only node.  Some additional\
    \ mechanisms (like ICE) or static\n   binding configuration can be used to provide\
    \ support for\n   communications initiated by an IPv4-only node to an IPv6-only\
    \ node.\n"
- title: 1.2.1.  Stateful NAT64 Solution Elements
  contents:
  - "1.2.1.  Stateful NAT64 Solution Elements\n   In this section, we describe the\
    \ different elements involved in the\n   NAT64 approach.\n   The main component\
    \ of the proposed solution is the translator itself.\n   The translator has essentially\
    \ two main parts, the address\n   translation mechanism and the protocol translation\
    \ mechanism.\n   Protocol translation from an IPv4 packet header to an IPv6 packet\n\
    \   header and vice versa is performed according to the IP/ICMP\n   Translation\
    \ Algorithm [RFC6145].\n   Address translation maps IPv6 transport addresses to\
    \ IPv4 transport\n   addresses and vice versa.  In order to create these mappings,\
    \ the\n   NAT64 has two pools of addresses: an IPv6 address pool (to represent\n\
    \   IPv4 addresses in the IPv6 network) and an IPv4 address pool (to\n   represent\
    \ IPv6 addresses in the IPv4 network).\n   The IPv6 address pool is one or more\
    \ IPv6 prefixes assigned to the\n   translator itself.  Hereafter, we will call\
    \ the IPv6 address pool\n   Pref64::/n; in the case there is more than one prefix\
    \ assigned to the\n   NAT64, the comments made about Pref64::/n apply to each\
    \ of them.\n   Pref64::/n will be used by the NAT64 to construct IPv4-Converted\
    \ IPv6\n   addresses as defined in [RFC6052].  Due to the abundance of IPv6\n\
    \   address space, it is possible to assign one or more Pref64::/n, each\n   of\
    \ them being equal to or even bigger than the size of the whole IPv4\n   address\
    \ space.  This allows each IPv4 address to be mapped into a\n   different IPv6\
    \ address by simply concatenating a Pref64::/n with the\n   IPv4 address being\
    \ mapped and a suffix.  The provisioning of the\n   Pref64::/n as well as the\
    \ address format are defined in [RFC6052].\n   The IPv4 address pool is a set\
    \ of IPv4 addresses, normally a prefix\n   assigned by the local administrator.\
    \  Since IPv4 address space is a\n   scarce resource, the IPv4 address pool is\
    \ small and typically not\n   sufficient to establish permanent one-to-one mappings\
    \ with IPv6\n   addresses.  So, except for the static/manually created ones, mappings\n\
    \   using the IPv4 address pool will be created and released dynamically.\n  \
    \ Moreover, because of the IPv4 address scarcity, the usual practice\n   for NAT64\
    \ is likely to be the binding of IPv6 transport addresses\n   into IPv4 transport\
    \ addresses, instead of IPv6 addresses into IPv4\n   addresses directly, enabling\
    \ a higher utilization of the limited IPv4\n   address pool.  This implies that\
    \ NAT64 performs both address and port\n   translation.\n   Because of the dynamic\
    \ nature of the IPv6-to-IPv4 address mapping and\n   the static nature of the\
    \ IPv4-to-IPv6 address mapping, it is far\n   simpler to allow communications\
    \ initiated from the IPv6 side toward\n   an IPv4 node, whose address is algorithmically\
    \ mapped into an IPv6\n   address, than communications initiated from IPv4-only\
    \ nodes to an\n   IPv6 node.  In that case, an IPv4 address needs to be associated\
    \ with\n   the IPv6 node's address dynamically.\n   Using a mechanism such as\
    \ DNS64, an IPv6 client obtains an IPv6\n   address that embeds the IPv4 address\
    \ of the IPv4 server and sends a\n   packet to that IPv6 address.  The packets\
    \ are intercepted by the\n   NAT64 device, which associates an IPv4 transport\
    \ address out of its\n   IPv4 pool to the IPv6 transport address of the initiator,\
    \ creating\n   binding state, so that reply packets can be translated and forwarded\n\
    \   back to the initiator.  The binding state is kept while packets are\n   flowing.\
    \  Once the flow stops, and based on a timer, the IPv4\n   transport address is\
    \ returned to the IPv4 address pool so that it can\n   be reused for other communications.\n\
    \   To allow an IPv6 initiator to do a DNS lookup to learn the address of\n  \
    \ the responder, DNS64 [RFC6147] is used to synthesize AAAA RRs from\n   the A\
    \ RRs.  The IPv6 addresses contained in the synthetic AAAA RRs\n   contain a Pref64::/n\
    \ assigned to the NAT64 and the IPv4 address of\n   the responder.  The synthetic\
    \ AAAA RRs are passed back to the IPv6\n   initiator, which will initiate an IPv6\
    \ communication with an IPv6\n   address associated to the IPv4 receiver.  The\
    \ packet will be routed\n   to the NAT64 device, which will create the IPv6-to-IPv4\
    \ address\n   mapping as described before.\n"
- title: 1.2.2.  Stateful NAT64 Behavior Walk-Through
  contents:
  - "1.2.2.  Stateful NAT64 Behavior Walk-Through\n   In this section, we provide\
    \ a simple example of the NAT64 behavior.\n   We consider an IPv6 node that is\
    \ located in an IPv6-only site and\n   that initiates a TCP connection to an IPv4-only\
    \ node located in the\n   IPv4 network.\n   The scenario for this case is depicted\
    \ in the following figure:\n             +---------------------+         +---------------+\n\
    \             |IPv6 network         |         |    IPv4       |\n            \
    \ |           |  +-------------+  |  network      |\n             |          \
    \ |--| Name server |--|               |\n             |           |  | with DNS64\
    \  |  |  +----+       |\n             |  +----+   |  +-------------+  |  | H2\
    \ |       |\n             |  | H1 |---|         |         |  +----+       |\n\
    \             |  +----+   |      +-------+    |  192.0.2.1    |\n            \
    \ |2001:db8::1|------| NAT64 |----|               |\n             |          \
    \ |      +-------+    |               |\n             |           |         |\
    \         |               |\n             +---------------------+         +---------------+\n\
    \   The figure above shows an IPv6 node H1 with an IPv6 address\n   2001:db8::1\
    \ and an IPv4 node H2 with IPv4 address 192.0.2.1.  H2 has\n   h2.example.com\
    \ as its Fully Qualified Domain Name (FQDN).\n   A NAT64 connects the IPv6 network\
    \ to the IPv4 network.  This NAT64\n   uses the Well-Known Prefix 64:ff9b::/96\
    \ defined in [RFC6052] to\n   represent IPv4 addresses in the IPv6 address space\
    \ and a single IPv4\n   address 203.0.113.1 assigned to its IPv4 interface.  The\
    \ routing is\n   configured in such a way that the IPv6 packets addressed to a\n\
    \   destination address in 64:ff9b::/96 are routed to the IPv6 interface\n   of\
    \ the NAT64 device.\n   Also shown is a local name server with DNS64 functionality.\
    \  The\n   local name server uses the Well-Known Prefix 64:ff9b::/96 to create\n\
    \   the IPv6 addresses in the synthetic RRs.\n   For this example, assume the\
    \ typical DNS situation where IPv6 hosts\n   have only stub resolvers, and the\
    \ local name server does the\n   recursive lookups.\n   The steps by which H1\
    \ establishes communication with H2 are:\n   1.  H1 performs a DNS query for h2.example.com\
    \ and receives the\n       synthetic AAAA RR from the local name server that implements\
    \ the\n       DNS64 functionality.  The AAAA record contains an IPv6 address\n\
    \       formed by the Well-Known Prefix and the IPv4 address of H2 (i.e.,\n  \
    \     64:ff9b::192.0.2.1).\n   2.  H1 sends a TCP SYN packet to H2.  The packet\
    \ is sent from a\n       source transport address of (2001:db8::1,1500) to a destination\n\
    \       transport address of (64:ff9b::192.0.2.1,80), where the ports are\n  \
    \     set by H1.\n   3.  The packet is routed to the IPv6 interface of the NAT64\
    \ (since\n       IPv6 routing is configured that way).\n   4.  The NAT64 receives\
    \ the packet and performs the following actions:\n       *  The NAT64 selects\
    \ an unused port (e.g., 2000) on its IPv4\n          address 203.0.113.1 and creates\
    \ the mapping entry\n          (2001:db8::1,1500) <--> (203.0.113.1,2000)\n  \
    \     *  The NAT64 translates the IPv6 header into an IPv4 header using\n    \
    \      the IP/ICMP Translation Algorithm [RFC6145].\n       *  The NAT64 includes\
    \ (203.0.113.1,2000) as the source transport\n          address in the packet\
    \ and (192.0.2.1,80) as the destination\n          transport address in the packet.\
    \  Note that 192.0.2.1 is\n          extracted directly from the destination IPv6\
    \ address of the\n          received IPv6 packet that is being translated.  The\n\
    \          destination port 80 of the translated packet is the same as\n     \
    \     the destination port of the received IPv6 packet.\n   5.  The NAT64 sends\
    \ the translated packet out of its IPv4 interface\n       and the packet arrives\
    \ at H2.\n   6.  H2 node responds by sending a TCP SYN+ACK packet with the\n \
    \      destination transport address (203.0.113.1,2000) and source\n       transport\
    \ address (192.0.2.1,80).\n   7.  Since the IPv4 address 203.0.113.1 is assigned\
    \ to the IPv4\n       interface of the NAT64 device, the packet is routed to the\
    \ NAT64\n       device, which will look for an existing mapping containing\n \
    \      (203.0.113.1,2000).  Since the mapping (2001:db8::1,1500) <-->\n      \
    \ (203.0.113.1,2000) exists, the NAT64 performs the following\n       operations:\n\
    \       *  The NAT64 translates the IPv4 header into an IPv6 header using\n  \
    \        the IP/ICMP Translation Algorithm [RFC6145].\n       *  The NAT64 includes\
    \ (2001:db8::1,1500) as the destination\n          transport address in the packet\
    \ and (64:ff9b::192.0.2.1,80) as\n          the source transport address in the\
    \ packet.  Note that\n          192.0.2.1 is extracted directly from the source\
    \ IPv4 address\n          of the received IPv4 packet that is being translated.\
    \  The\n          source port 80 of the translated packet is the same as the\n\
    \          source port of the received IPv4 packet.\n   8.  The translated packet\
    \ is sent out of the IPv6 interface to H1.\n   The packet exchange between H1\
    \ and H2 continues, and packets are\n   translated in the different directions\
    \ as previously described.\n   It is important to note that the translation still\
    \ works if the IPv6\n   initiator H1 learns the IPv6 representation of H2's IPv4\
    \ address\n   (i.e., 64:ff9b::192.0.2.1) through some scheme other than a DNS\n\
    \   lookup.  This is because the DNS64 processing does NOT result in any\n   state\
    \ being installed in the NAT64 and because the mapping of the\n   IPv4 address\
    \ into an IPv6 address is the result of concatenating the\n   Well-Known Prefix\
    \ to the original IPv4 address.\n"
- title: 1.2.3.  Filtering
  contents:
  - "1.2.3.  Filtering\n   NAT64 may do filtering, which means that it only allows\
    \ a packet in\n   through an interface under certain circumstances.  The NAT64\
    \ can\n   filter IPv6 packets based on the administrative rules to create\n  \
    \ entries in the binding and session tables.  The filtering can be\n   flexible\
    \ and general, but the idea of the filtering is to provide the\n   administrators\
    \ necessary control to avoid denial-of-service (DoS)\n   attacks that would result\
    \ in exhaustion of the NAT64's IPv4 address,\n   port, memory, and CPU resources.\
    \  Filtering techniques of incoming\n   IPv6 packets are not specific to the NAT64\
    \ and therefore are not\n   described in this specification.\n   Filtering of\
    \ IPv4 packets, on the other hand, is tightly coupled to\n   the NAT64 state and\
    \ therefore is described in this specification.  In\n   this document, we consider\
    \ that the NAT64 may do no filtering, or it\n   may filter incoming IPv4 packets.\n\
    \   NAT64 filtering of incoming IPv4 packets is consistent with the\n   recommendations\
    \ of [RFC4787] and [RFC5382].  Because of that, the\n   NAT64 as specified in\
    \ this document supports both Endpoint-\n   Independent Filtering and Address-Dependent\
    \ Filtering, both for TCP\n   and UDP as well as filtering of ICMP packets.\n\
    \   If a NAT64 performs Endpoint-Independent Filtering of incoming IPv4\n   packets,\
    \ then an incoming IPv4 packet is dropped unless the NAT64 has\n   state for the\
    \ destination transport address of the incoming IPv4\n   packet.\n   If a NAT64\
    \ performs Address-Dependent Filtering of incoming IPv4\n   packets, then an incoming\
    \ IPv4 packet is dropped unless the NAT64 has\n   state involving the destination\
    \ transport address of the IPv4\n   incoming packet and the particular source\
    \ IP address of the incoming\n   IPv4 packet.\n"
- title: 2.  Terminology
  contents:
  - "2.  Terminology\n   This section provides a definitive reference for all the\
    \ terms used\n   in this document.\n   The key words \"MUST\", \"MUST NOT\", \"\
    REQUIRED\", \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\"\
    , \"MAY\", and \"OPTIONAL\" in this\n   document are to be interpreted as described\
    \ in RFC 2119 [RFC2119].\n   The following additional terms are used in this document:\n\
    \   3-Tuple:  The tuple (source IP address, destination IP address, ICMP\n   \
    \   Identifier).  A 3-tuple uniquely identifies an ICMP Query session.\n     \
    \ When an ICMP Query session flows through a NAT64, each session has\n      two\
    \ different 3-tuples: one with IPv4 addresses and one with IPv6\n      addresses.\n\
    \   5-Tuple:  The tuple (source IP address, source port, destination IP\n    \
    \  address, destination port, transport protocol).  A 5-tuple\n      uniquely\
    \ identifies a UDP/TCP session.  When a UDP/TCP session\n      flows through a\
    \ NAT64, each session has two different 5-tuples:\n      one with IPv4 addresses\
    \ and one with IPv6 addresses.\n   BIB:  Binding Information Base.  A table of\
    \ bindings kept by a NAT64.\n      Each NAT64 has a BIB for each translated protocol.\
    \  An\n      implementation compliant to this document would have a BIB for\n\
    \      TCP, one for UDP, and one for ICMP Queries.  Additional BIBs would\n  \
    \    be added to support other protocols, such as SCTP.\n   Endpoint-Independent\
    \ Mapping:  In NAT64, using the same mapping for\n      all the sessions involving\
    \ a given IPv6 transport address of an\n      IPv6 host (irrespectively of the\
    \ transport address of the IPv4\n      host involved in the communication).  Endpoint-Independent\
    \ Mapping\n      is important for peer-to-peer communication.  See [RFC4787] for\n\
    \      the definition of the different types of mappings in IPv4-to-IPv4\n   \
    \   NATs.\n   Filtering, Endpoint-Independent:  The NAT64 only filters incoming\n\
    \      IPv4 packets destined to a transport address for which there is no\n  \
    \    state in the NAT64, regardless of the source IPv4 transport\n      address.\
    \  The NAT forwards any packets destined to any transport\n      address for which\
    \ it has state.  In other words, having state for\n      a given transport address\
    \ is sufficient to allow any packets back\n      to the internal endpoint.  See\
    \ [RFC4787] for the definition of the\n      different types of filtering in IPv4-to-IPv4\
    \ NATs.\n   Filtering, Address-Dependent:  The NAT64 filters incoming IPv4\n \
    \     packets destined to a transport address for which there is no\n      state\
    \ (similar to the Endpoint-Independent Filtering).\n      Additionally, the NAT64\
    \ will filter out incoming IPv4 packets\n      coming from a given IPv4 address\
    \ X and destined for a transport\n      address for which it has state if the\
    \ NAT64 has not sent packets\n      to X previously (independently of the port\
    \ used by X).  In other\n      words, for receiving packets from a specific IPv4\
    \ endpoint, it is\n      necessary for the IPv6 endpoint to send packets first\
    \ to that\n      specific IPv4 endpoint's IP address.\n   Hairpinning:  Having\
    \ a packet do a \"U-turn\" inside a NAT and come\n      back out the same side\
    \ as it arrived on.  If the destination IPv6\n      address and its embedded IPv4\
    \ address are both assigned to the\n      NAT64 itself, then the packet is being\
    \ sent to another IPv6 host\n      connected to the same NAT64.  Such a packet\
    \ is called a 'hairpin\n      packet'.  A NAT64 that forwards hairpin packets\
    \ back to the IPv6\n      host is defined as supporting \"hairpinning\".  Hairpinning\
    \ support\n      is important for peer-to-peer applications, as there are cases\n\
    \      when two different hosts on the same side of a NAT can only\n      communicate\
    \ using sessions that hairpin through the NAT.  Hairpin\n      packets can be\
    \ either TCP or UDP.  More detailed explanation of\n      hairpinning and examples\
    \ for the UDP case can be found in\n      [RFC4787].\n   ICMP Query packet:  ICMP\
    \ packets that are not ICMP error messages.\n      For ICMPv6, ICMPv6 Query Messages\
    \ are the ICMPv6 Informational\n      messages as defined in [RFC4443].  For ICMPv4,\
    \ ICMPv4 Query\n      messages are all ICMPv4 messages that are not ICMPv4 error\n\
    \      messages.\n   Mapping or Binding:  A mapping between an IPv6 transport\
    \ address and\n      a IPv4 transport address or a mapping between an (IPv6 address,\n\
    \      ICMPv6 Identifier) pair and an (IPv4 address, ICMPv4 Identifier)\n    \
    \  pair.  Used to translate the addresses and ports / ICMP\n      Identifiers\
    \ of packets flowing between the IPv6 host and the IPv4\n      host.  In NAT64,\
    \ the IPv4 address and port / ICMPv4 Identifier is\n      always one assigned\
    \ to the NAT64 itself, while the IPv6 address\n      and port / ICMPv6 Identifier\
    \ belongs to some IPv6 host.\n   Session:  The flow of packets between two different\
    \ hosts.  This may\n      be TCP, UDP, or ICMP Queries.  In NAT64, typically one\
    \ host is an\n      IPv4 host, and the other one is an IPv6 host.  However, due\
    \ to\n      hairpinning, both hosts might be IPv6 hosts.\n   Session table:  A\
    \ table of sessions kept by a NAT64.  Each NAT64 has\n      three session tables,\
    \ one for TCP, one for UDP, and one for ICMP\n      Queries.\n   Stateful NAT64:\
    \  A function that has per-flow state that translates\n      IPv6 packets to IPv4\
    \ packets and vice versa, for TCP, UDP, and\n      ICMP.  The NAT64 uses binding\
    \ state to perform the translation\n      between IPv6 and IPv4 addresses.  In\
    \ this document, we also refer\n      to stateful NAT64 simply as NAT64.\n   Stateful\
    \ NAT64 device:  The device where the NAT64 function is\n      executed.  In this\
    \ document, we also refer to stateful NAT64\n      device simply as NAT64 device.\n\
    \   Transport Address:  The combination of an IPv6 or IPv4 address and a\n   \
    \   port.  Typically written as (IP address,port), e.g.,\n      (192.0.2.15,8001).\n\
    \   Tuple:  Refers to either a 3-tuple or a 5-tuple as defined above.\n   For\
    \ a detailed understanding of this document, the reader should also\n   be familiar\
    \ with NAT terminology [RFC4787].\n"
- title: 3.  Stateful NAT64 Normative Specification
  contents:
  - "3.  Stateful NAT64 Normative Specification\n   A NAT64 is a device with at least\
    \ one IPv6 interface and at least one\n   IPv4 interface.  Each NAT64 device MUST\
    \ have at least one unicast /n\n   IPv6 prefix assigned to it, denoted Pref64::/n.\
    \  Additional\n   considerations about the Pref64::/n are presented in Section\
    \ 3.5.4.\n   A NAT64 MUST have one or more unicast IPv4 addresses assigned to\
    \ it.\n   A NAT64 uses the following conceptual dynamic data structures:\n   o\
    \  UDP Binding Information Base\n   o  UDP Session Table\n   o  TCP Binding Information\
    \ Base\n   o  TCP Session Table\n   o  ICMP Query Binding Information Base\n \
    \  o  ICMP Query Session Table\n   These tables contain information needed for\
    \ the NAT64 processing.\n   The actual division of the information into six tables\
    \ is done in\n   order to ease the description of the NAT64 behavior.  NAT64\n\
    \   implementations are free to use different data structures but they\n   MUST\
    \ store all the required information, and the externally visible\n   outcome MUST\
    \ be the same as the one described in this document.\n   The notation used is\
    \ the following: uppercase letters are IPv4\n   addresses; uppercase letters with\
    \ a prime(') are IPv6 addresses;\n   lowercase letters are ports; IPv6 prefixes\
    \ of length n are indicated\n   by \"P::/n\"; mappings are indicated as \"(X,x)\
    \ <--> (Y',y)\".\n"
- title: 3.1.  Binding Information Bases
  contents:
  - "3.1.  Binding Information Bases\n   A NAT64 has three Binding Information Bases\
    \ (BIBs): one for TCP, one\n   for UDP, and one for ICMP Queries.  In the case\
    \ of UDP and TCP BIBs,\n   each BIB entry specifies a mapping between an IPv6\
    \ transport address\n   and an IPv4 transport address:\n      (X',x) <--> (T,t)\n\
    \   where X' is some IPv6 address, T is an IPv4 address, and x and t are\n   ports.\
    \  T will always be one of the IPv4 addresses assigned to the\n   NAT64.  The\
    \ BIB has then two columns: the BIB IPv6 transport address\n   and the BIB IPv4\
    \ transport address.  A given IPv6 or IPv4 transport\n   address can appear in\
    \ at most one entry in a BIB: for example,\n   (2001:db8::17, 49832) can appear\
    \ in at most one TCP and at most one\n   UDP BIB entry.  TCP and UDP have separate\
    \ BIBs because the port\n   number space for TCP and UDP are distinct.  If the\
    \ BIBs are\n   implemented as specified in this document, it results in\n   Endpoint-Independent\
    \ Mappings in the NAT64.  The information in the\n   BIBs is also used to implement\
    \ Endpoint-Independent Filtering.\n   (Address-Dependent Filtering is implemented\
    \ using the session tables\n   described below.)\n   In the case of the ICMP Query\
    \ BIB, each ICMP Query BIB entry\n   specifies a mapping between an (IPv6 address,\
    \ ICMPv6 Identifier) pair\n   and an (IPv4 address, ICMPv4 Identifier) pair.\n\
    \      (X',i1) <--> (T,i2)\n   where X' is some IPv6 address, T is an IPv4 address,\
    \ i1 is an ICMPv6\n   Identifier, and i2 is an ICMPv4 Identifier.  T will always\
    \ be one of\n   the IPv4 addresses assigned to the NAT64.  A given (IPv6 or IPv4\n\
    \   address, ICMPv6 or ICMPv4 Identifier) pair can appear in at most one\n   entry\
    \ in the ICMP Query BIB.\n   Entries in any of the three BIBs can be created dynamically\
    \ as the\n   result of the flow of packets as described in Section 3.5, but they\n\
    \   can also be created manually by an administrator.  NAT64\n   implementations\
    \ SHOULD support manually configured BIB entries for\n   any of the three BIBs.\
    \  Dynamically created entries are deleted from\n   the corresponding BIB when\
    \ the last session associated with the BIB\n   entry is removed from the session\
    \ table.  Manually configured BIB\n   entries are not deleted when there is no\
    \ corresponding Session Table\n   Entry and can only be deleted by the administrator.\n"
- title: 3.2.  Session Tables
  contents:
  - "3.2.  Session Tables\n   A NAT64 also has three session tables: one for TCP sessions,\
    \ one for\n   UDP sessions, and one for ICMP Query sessions.  Each entry keeps\n\
    \   information on the state of the corresponding session.  In the TCP\n   and\
    \ UDP session tables, each entry specifies a mapping between a pair\n   of IPv6\
    \ transport addresses and a pair of IPv4 transport addresses:\n      (X',x),(Y',y)\
    \ <--> (T,t),(Z,z)\n   where X' and Y' are IPv6 addresses, T and Z are IPv4 addresses,\
    \ and\n   x, y, z, and t are ports.  T will always be one of the IPv4 addresses\n\
    \   assigned to the NAT64.  Y' is always the IPv6 representation of the\n   IPv4\
    \ address Z, so Y' is obtained from Z using the algorithm applied\n   by the NAT64\
    \ to create IPv6 representations of IPv4 addresses. y will\n   always be equal\
    \ to z.\n   For each TCP or UDP Session Table Entry (STE), there are then five\n\
    \   columns.  The terminology used for the STE columns is from the\n   perspective\
    \ of an incoming IPv6 packet being translated into an\n   outgoing IPv4 packet.\
    \  The columns are:\n      The STE source IPv6 transport address; (X',x) in the\
    \ example\n      above.\n      The STE destination IPv6 transport address; (Y',y)\
    \ in the example\n      above.\n      The STE source IPv4 transport address; (T,t)\
    \ in the example above.\n      The STE destination IPv4 transport address; (Z,z)\
    \ in the example\n      above.\n      The STE lifetime.\n   In the ICMP Query\
    \ session table, each entry specifies a mapping\n   between a 3-tuple of IPv6\
    \ source address, IPv6 destination address,\n   and ICMPv6 Identifier and a 3-tuple\
    \ of IPv4 source address, IPv4\n   destination address, and ICMPv4 Identifier:\n\
    \      (X',Y',i1) <--> (T,Z,i2)\n   where X' and Y' are IPv6 addresses, T and\
    \ Z are IPv4 addresses, i1 is\n   an ICMPv6 Identifier, and i2 is an ICMPv4 Identifier.\
    \  T will always\n   be one of the IPv4 addresses assigned to the NAT64.  Y' is\
    \ always the\n   IPv6 representation of the IPv4 address Z, so Y' is obtained\
    \ from Z\n   using the algorithm applied by the NAT64 to create IPv6\n   representations\
    \ of IPv4 addresses.\n   For each ICMP Query Session Table Entry (STE), there\
    \ are then seven\n   columns:\n      The STE source IPv6 address; X' in the example\
    \ above.\n      The STE destination IPv6 address; Y' in the example above.\n \
    \     The STE ICMPv6 Identifier; i1 in the example above.\n      The STE source\
    \ IPv4 address; T in the example above.\n      The STE destination IPv4 address;\
    \ Z in the example above.\n      The STE ICMPv4 Identifier; i2 in the example\
    \ above.\n      The STE lifetime.\n"
- title: 3.3.  Packet Processing Overview
  contents:
  - "3.3.  Packet Processing Overview\n   The NAT64 uses the session state information\
    \ to determine when the\n   session is completed, and also uses session information\
    \ for Address-\n   Dependent Filtering.  A session can be uniquely identified\
    \ by either\n   an incoming tuple or an outgoing tuple.\n   For each TCP or UDP\
    \ session, there is a corresponding BIB entry,\n   uniquely specified by either\
    \ the source IPv6 transport address (in\n   the IPv6 --> IPv4 direction) or the\
    \ destination IPv4 transport\n   address (in the IPv4 --> IPv6 direction).  For\
    \ each ICMP Query\n   session, there is a corresponding BIB entry, uniquely specified\
    \ by\n   either the source IPv6 address and ICMPv6 Identifier (in the IPv6 -->\n\
    \   IPv4 direction) or the destination IPv4 address and the ICMPv4\n   Identifier\
    \ (in the IPv4 --> IPv6 direction).  However, for all the\n   BIBs, a single BIB\
    \ entry can have multiple corresponding sessions.\n   When the last corresponding\
    \ session is deleted, if the BIB entry was\n   dynamically created, the BIB entry\
    \ is deleted.\n   The NAT64 will receive packets through its interfaces.  These\
    \ packets\n   can be either IPv6 packets or IPv4 packets, and they may carry TCP\n\
    \   traffic, UDP traffic, or ICMP traffic.  The processing of the packets\n  \
    \ will be described next.  In the case that the processing is common to\n   all\
    \ the aforementioned types of packets, we will refer to the packet\n   as the\
    \ incoming IP packet in general.  In the case that the\n   processing is specific\
    \ to IPv6 packets, we will explicitly refer to\n   the incoming packet as an incoming\
    \ IPv6 packet; analogous terminology\n   will apply in the case of processing\
    \ that is specific to IPv4\n   packets.\n   The processing of an incoming IP packet\
    \ takes the following steps:\n   1.  Determining the incoming tuple\n   2.  Filtering\
    \ and updating binding and session information\n   3.  Computing the outgoing\
    \ tuple\n   4.  Translating the packet\n   5.  Handling hairpinning\n   The details\
    \ of these steps are specified in the following\n   subsections.\n   This breakdown\
    \ of the NAT64 behavior into processing steps is done\n   for ease of presentation.\
    \  A NAT64 MAY perform the steps in a\n   different order or MAY perform different\
    \ steps, but the externally\n   visible outcome MUST be the same as the one described\
    \ in this\n   document.\n"
- title: 3.4.  Determining the Incoming Tuple
  contents:
  - "3.4.  Determining the Incoming Tuple\n   This step associates an incoming tuple\
    \ with every incoming IP packet\n   for use in subsequent steps.  In the case\
    \ of TCP, UDP, and ICMP error\n   packets, the tuple is a 5-tuple consisting of\
    \ the source IP address,\n   source port, destination IP address, destination\
    \ port, and transport\n   protocol.  In case of ICMP Queries, the tuple is a 3-tuple\
    \ consisting\n   of the source IP address, destination IP address, and ICMP\n\
    \   Identifier.\n   If the incoming IP packet contains a complete (un-fragmented)\
    \ UDP or\n   TCP protocol packet, then the 5-tuple is computed by extracting the\n\
    \   appropriate fields from the received packet.\n   If the incoming packet is\
    \ a complete (un-fragmented) ICMP Query\n   message (i.e., an ICMPv4 Query message\
    \ or an ICMPv6 Informational\n   message), the 3-tuple is the source IP address,\
    \ the destination IP\n   address, and the ICMP Identifier.\n   If the incoming\
    \ IP packet contains a complete (un-fragmented) ICMP\n   error message containing\
    \ a UDP or a TCP packet, then the incoming\n   5-tuple is computed by extracting\
    \ the appropriate fields from the IP\n   packet embedded inside the ICMP error\
    \ message.  However, the role of\n   source and destination is swapped when doing\
    \ this: the embedded\n   source IP address becomes the destination IP address\
    \ in the incoming\n   5-tuple, the embedded source port becomes the destination\
    \ port in the\n   incoming 5-tuple, etc.  If it is not possible to determine the\n\
    \   incoming 5-tuple (perhaps because not enough of the embedded packet\n   is\
    \ reproduced inside the ICMP message), then the incoming IP packet\n   MUST be\
    \ silently discarded.\n   If the incoming IP packet contains a complete (un-fragmented)\
    \ ICMP\n   error message containing an ICMP error message, then the packet is\n\
    \   silently discarded.\n   If the incoming IP packet contains a complete (un-fragmented)\
    \ ICMP\n   error message containing an ICMP Query message, then the incoming\n\
    \   3-tuple is computed by extracting the appropriate fields from the IP\n   packet\
    \ embedded inside the ICMP error message.  However, the role of\n   source and\
    \ destination is swapped when doing this: the embedded\n   source IP address becomes\
    \ the destination IP address in the incoming\n   3-tuple, the embedded destination\
    \ IP address becomes the source\n   address in the incoming 3-tuple, and the embedded\
    \ ICMP Identifier is\n   used as the ICMP Identifier of the incoming 3-tuple.\
    \  If it is not\n   possible to determine the incoming 3-tuple (perhaps because\
    \ not\n   enough of the embedded packet is reproduced inside the ICMP message),\n\
    \   then the incoming IP packet MUST be silently discarded.\n   If the incoming\
    \ IP packet contains a fragment, then more processing\n   may be needed.  This\
    \ specification leaves open the exact details of\n   how a NAT64 handles incoming\
    \ IP packets containing fragments, and\n   simply requires that the external behavior\
    \ of the NAT64 be compliant\n   with the following conditions:\n      The NAT64\
    \ MUST handle fragments.  In particular, NAT64 MUST handle\n      fragments arriving\
    \ out of order, conditional on the following:\n      *  The NAT64 MUST limit the\
    \ amount of resources devoted to the\n         storage of fragmented packets in\
    \ order to protect from DoS\n         attacks.\n      *  As long as the NAT64\
    \ has available resources, the NAT64 MUST\n         allow the fragments to arrive\
    \ over a time interval.  The time\n         interval SHOULD be configurable and\
    \ the default value MUST be\n         of at least FRAGMENT_MIN.\n      *  The\
    \ NAT64 MAY require that the UDP, TCP, or ICMP header be\n         completely\
    \ contained within the fragment that contains fragment\n         offset equal\
    \ to zero.\n      For incoming packets carrying TCP or UDP fragments with a non-zero\n\
    \      checksum, NAT64 MAY elect to queue the fragments as they arrive\n     \
    \ and translate all fragments at the same time.  In this case, the\n      incoming\
    \ tuple is determined as documented above to the un-\n      fragmented packets.\
    \  Alternatively, a NAT64 MAY translate the\n      fragments as they arrive, by\
    \ storing information that allows it to\n      compute the 5-tuple for fragments\
    \ other than the first.  In the\n      latter case, subsequent fragments may arrive\
    \ before the first, and\n      the rules (in the bulleted list above) about how\
    \ the NAT64 handles\n      (out-of-order) fragments apply.\n      For incoming\
    \ IPv4 packets carrying UDP packets with a zero\n      checksum, if the NAT64\
    \ has enough resources, the NAT64 MUST\n      reassemble the packets and MUST\
    \ calculate the checksum.  If the\n      NAT64 does not have enough resources,\
    \ then it MUST silently\n      discard the packets.  The handling of fragmented\
    \ and un-fragmented\n      UDP packets with a zero checksum as specified above\
    \ deviates from\n      that specified in [RFC6145].\n      Implementers of NAT64\
    \ should be aware that there are a number of\n      well-known attacks against\
    \ IP fragmentation; see [RFC1858] and\n      [RFC3128].  Implementers should also\
    \ be aware of additional issues\n      with reassembling packets at high rates,\
    \ described in [RFC4963].\n   If the incoming packet is an IPv6 packet that contains\
    \ a protocol\n   other than TCP, UDP, or ICMPv6 in the last Next Header, then\
    \ the\n   packet SHOULD be discarded and, if the security policy permits, the\n\
    \   NAT64 SHOULD send an ICMPv6 Destination Unreachable error message\n   with\
    \ Code 4 (Port Unreachable) to the source address of the received\n   packet.\
    \  NOTE: This behavior may be updated by future documents that\n   define how\
    \ other protocols such as SCTP or DCCP are processed by\n   NAT64.\n   If the\
    \ incoming packet is an IPv4 packet that contains a protocol\n   other than TCP,\
    \ UDP, or ICMPv4, then the packet SHOULD be discarded\n   and, if the security\
    \ policy permits, the NAT64 SHOULD send an ICMPv4\n   Destination Unreachable\
    \ error message with Code 2 (Protocol\n   Unreachable) to the source address of\
    \ the received packet.  NOTE:\n   This behavior may be updated by future documents\
    \ that define how\n   other protocols such as SCTP or DCCP are processed by NAT64.\n"
- title: 3.5.  Filtering and Updating Binding and Session Information
  contents:
  - "3.5.  Filtering and Updating Binding and Session Information\n   This step updates\
    \ binding and session information stored in the\n   appropriate tables.  This\
    \ step may also filter incoming packets, if\n   desired.\n   The details of this\
    \ step depend on the protocol, i.e., UDP, TCP, or\n   ICMP.  The behaviors for\
    \ UDP, TCP, and ICMP Queries are described in\n   Section 3.5.1, Section 3.5.2,\
    \ and Section 3.5.3, respectively.  For\n   the case of ICMP error messages, they\
    \ do not affect in any way either\n   the BIBs or the session tables, so there\
    \ is no processing resulting\n   from these messages in this section.  ICMP error\
    \ message processing\n   continues in Section 3.6.\n   Irrespective of the transport\
    \ protocol used, the NAT64 MUST silently\n   discard all incoming IPv6 packets\
    \ containing a source address that\n   contains the Pref64::/n.  This is required\
    \ in order to prevent\n   hairpinning loops as described in Section 5.  In addition,\
    \ the NAT64\n   MUST only process incoming IPv6 packets that contain a destination\n\
    \   address that contains Pref64::/n.  Likewise, the NAT64 MUST only\n   process\
    \ incoming IPv4 packets that contain a destination address that\n   belongs to\
    \ the IPv4 pool assigned to the NAT64.\n"
- title: 3.5.1.  UDP Session Handling
  contents:
  - "3.5.1.  UDP Session Handling\n   The following state information is stored for\
    \ a UDP session:\n      Binding:(X',x),(Y',y) <--> (T,t),(Z,z)\n      Lifetime:\
    \ a timer that tracks the remaining lifetime of the UDP\n      session.  When\
    \ the timer expires, the UDP session is deleted.  If\n      all the UDP sessions\
    \ corresponding to a dynamically created UDP\n      BIB entry are deleted, then\
    \ the UDP BIB entry is also deleted.\n   An IPv6 incoming packet with an incoming\
    \ tuple with source transport\n   address (X',x) and destination transport address\
    \ (Y',y) is processed\n   as follows:\n      The NAT64 searches for a UDP BIB\
    \ entry that contains the BIB IPv6\n      transport address that matches the IPv6\
    \ source transport address\n      (X',x).  If such an entry does not exist, the\
    \ NAT64 tries to\n      create a new entry (if resources and policy permit). \
    \ The source\n      IPv6 transport address of the packet (X',x) is used as the\
    \ BIB\n      IPv6 transport address, and the BIB IPv4 transport address is set\n\
    \      to (T,t), which is allocated using the rules defined in\n      Section\
    \ 3.5.1.1.  The result is a BIB entry as follows: (X',x)\n      <--> (T,t).\n\
    \      The NAT64 searches for the Session Table Entry corresponding to\n     \
    \ the incoming 5-tuple.  If no such entry is found, the NAT64 tries\n      to\
    \ create a new entry (if resources and policy permit).  The\n      information\
    \ included in the session table is as follows:\n      *  The STE source IPv6 transport\
    \ address is set to (X',x), i.e.,\n         the source IPv6 transport address\
    \ contained in the received\n         IPv6 packet.\n      *  The STE destination\
    \ IPv6 transport address is set to (Y',y),\n         i.e., the destination IPv6\
    \ transport address contained in the\n         received IPv6 packet.\n      *\
    \  The STE source IPv4 transport address is extracted from the\n         corresponding\
    \ UDP BIB entry, i.e., it is set to (T,t).\n      *  The STE destination IPv4\
    \ transport is set to (Z(Y'),y), y being\n         the same port as the STE destination\
    \ IPv6 transport address and\n         Z(Y') being algorithmically generated from\
    \ the IPv6 destination\n         address (i.e., Y') using the reverse algorithm\
    \ (see\n         Section 3.5.4).\n      The result is a Session Table Entry as\
    \ follows:\n      (X',x),(Y',y) <--> (T,t),(Z(Y'),y)\n      The NAT64 sets (or\
    \ resets) the timer in the Session Table Entry to\n      the maximum session lifetime.\
    \  The maximum session lifetime MAY be\n      configurable, and the default SHOULD\
    \ be at least UDP_DEFAULT.  The\n      maximum session lifetime MUST NOT be less\
    \ than UDP_MIN.  The\n      packet is translated and forwarded as described in\
    \ the following\n      sections.\n   An IPv4 incoming packet, with an incoming\
    \ tuple with source IPv4\n   transport address (W,w) and destination IPv4 transport\
    \ address (T,t)\n   is processed as follows:\n      The NAT64 searches for a UDP\
    \ BIB entry that contains the BIB IPv4\n      transport address matching (T,t),\
    \ i.e., the IPv4 destination\n      transport address in the incoming IPv4 packet.\
    \  If such an entry\n      does not exist, the packet MUST be dropped.  An ICMP\
    \ error message\n      with Type 3 (Destination Unreachable) MAY be sent to the\
    \ original\n      sender of the packet.\n      If the NAT64 applies Address-Dependent\
    \ Filters on its IPv4\n      interface, then the NAT64 checks to see if the incoming\
    \ packet is\n      allowed according to the Address-Dependent Filtering rule.\
    \  To do\n      this, it searches for a Session Table Entry with an STE source\n\
    \      IPv4 transport address equal to (T,t), i.e., the destination IPv4\n   \
    \   transport address in the incoming packet, and STE destination IPv4\n     \
    \ address equal to W, i.e., the source IPv4 address in the incoming\n      packet.\
    \  If such an entry is found (there may be more than one),\n      packet processing\
    \ continues.  Otherwise, the packet is discarded.\n      If the packet is discarded,\
    \ then an ICMP error message MAY be sent\n      to the original sender of the\
    \ packet.  The ICMP error message, if\n      sent, has Type 3 (Destination Unreachable)\
    \ and Code 13\n      (Communication Administratively Prohibited).\n      In case\
    \ the packet is not discarded in the previous processing\n      (either because\
    \ the NAT64 is not filtering or because the packet\n      is compliant with the\
    \ Address-Dependent Filtering rule), then the\n      NAT64 searches for the Session\
    \ Table Entry containing the STE\n      source IPv4 transport address equal to\
    \ (T,t) and the STE\n      destination IPv4 transport address equal to (W,w).\
    \  If no such\n      entry is found, the NAT64 tries to create a new entry (if\n\
    \      resources and policy permit).  In case a new UDP Session Table\n      Entry\
    \ is created, it contains the following information:\n      *  The STE source\
    \ IPv6 transport address is extracted from the\n         corresponding UDP BIB\
    \ entry.\n      *  The STE destination IPv6 transport address is set to (Y'(W),w),\n\
    \         w being the same port w as the source IPv4 transport address\n     \
    \    and Y'(W) being the IPv6 representation of W, generated using\n         the\
    \ algorithm described in Section 3.5.4.\n      *  The STE source IPv4 transport\
    \ address is set to (T,t), i.e.,\n         the destination IPv4 transport addresses\
    \ contained in the\n         received IPv4 packet.\n      *  The STE destination\
    \ IPv4 transport is set to (W,w), i.e., the\n         source IPv4 transport addresses\
    \ contained in the received IPv4\n         packet.\n      The NAT64 sets (or resets)\
    \ the timer in the Session Table Entry to\n      the maximum session lifetime.\
    \  The maximum session lifetime MAY be\n      configurable, and the default SHOULD\
    \ be at least UDP_DEFAULT.  The\n      maximum session lifetime MUST NOT be less\
    \ than UDP_MIN.  The\n      packet is translated and forwarded as described in\
    \ the following\n      sections.\n"
- title: 3.5.1.1.  Rules for Allocation of IPv4 Transport Addresses for UDP
  contents:
  - "3.5.1.1.  Rules for Allocation of IPv4 Transport Addresses for UDP\n   When a\
    \ new UDP BIB entry is created for a source transport address of\n   (S',s), the\
    \ NAT64 allocates an IPv4 transport address for this BIB\n   entry as follows:\n\
    \      If there exists some other BIB entry containing S' as the IPv6\n      address\
    \ and mapping it to some IPv4 address T, then the NAT64\n      SHOULD use T as\
    \ the IPv4 address.  Otherwise, use any IPv4 address\n      of the IPv4 pool assigned\
    \ to the NAT64 to be used for translation.\n      If the port s is in the Well-Known\
    \ port range 0-1023, and the\n      NAT64 has an available port t in the same\
    \ port range, then the\n      NAT64 SHOULD allocate the port t.  If the NAT64\
    \ does not have a\n      port available in the same range, the NAT64 MAY assign\
    \ a port t\n      from another range where it has an available port.  (This behavior\n\
    \      is recommended in REQ 3-a of [RFC4787].)\n      If the port s is in the\
    \ range 1024-65535, and the NAT64 has an\n      available port t in the same port\
    \ range, then the NAT64 SHOULD\n      allocate the port t.  If the NAT64 does\
    \ not have a port available\n      in the same range, the NAT64 MAY assign a port\
    \ t from another\n      range where it has an available port.  (This behavior\
    \ is\n      recommended in REQ 3-a of [RFC4787].)\n      The NAT64 SHOULD preserve\
    \ the port parity (odd/even), as per\n      Section 4.2.2 of [RFC4787]).\n   \
    \   In all cases, the allocated IPv4 transport address (T,t) MUST NOT\n      be\
    \ in use in another entry in the same BIB, but can be in use in\n      other BIBs\
    \ (e.g., the UDP and TCP BIBs).\n   If it is not possible to allocate an appropriate\
    \ IPv4 transport\n   address or create a BIB entry, then the packet is discarded.\
    \  The\n   NAT64 SHOULD send an ICMPv6 Destination Unreachable error message\n\
    \   with Code 3 (Address Unreachable).\n"
- title: 3.5.2.  TCP Session Handling
  contents:
  - "3.5.2.  TCP Session Handling\n   In this section, we describe how the TCP BIB\
    \ and session table are\n   populated.  We do so by defining the state machine\
    \ that the NAT64\n   uses for TCP.  We first describe the states and the information\n\
    \   contained in them, and then we describe the actual state machine and\n   state\
    \ transitions.\n"
- title: 3.5.2.1.  State Definition
  contents:
  - "3.5.2.1.  State Definition\n   The following state information is stored for\
    \ a TCP session:\n      Binding:(X',x),(Y',y) <--> (T,t),(Z,z)\n      Lifetime:\
    \ a timer that tracks the remaining lifetime of the TCP\n      session.  When\
    \ the timer expires, the TCP session is deleted.  If\n      all the TCP sessions\
    \ corresponding to a TCP BIB entry are deleted,\n      then the dynamically created\
    \ TCP BIB entry is also deleted.\n   Because the TCP session inactivity lifetime\
    \ is set to at least 2\n   hours and 4 minutes (as per [RFC5382]), it is important\
    \ that each TCP\n   Session Table Entry corresponds to an existing TCP session.\
    \  In order\n   to do that, for each TCP session established, the TCP connection\n\
    \   state is tracked using the following state machine.\n   The states are as\
    \ follows:\n      CLOSED: Analogous to [RFC0793], CLOSED is a fictional state\n\
    \      because it represents the state when there is no state for this\n     \
    \ particular 5-tuple, and therefore no connection.\n      V4 INIT: An IPv4 packet\
    \ containing a TCP SYN was received by the\n      NAT64, implying that a TCP connection\
    \ is being initiated from the\n      IPv4 side.  The NAT64 is now waiting for\
    \ a matching IPv6 packet\n      containing the TCP SYN in the opposite direction.\n\
    \      V6 INIT: An IPv6 packet containing a TCP SYN was received,\n      translated,\
    \ and forwarded by the NAT64, implying that a TCP\n      connection is being initiated\
    \ from the IPv6 side.  The NAT64 is\n      now waiting for a matching IPv4 packet\
    \ containing the TCP SYN in\n      the opposite direction.\n      ESTABLISHED:\
    \ Represents an open connection, with data able to flow\n      in both directions.\n\
    \      V4 FIN RCV: An IPv4 packet containing a TCP FIN was received by\n     \
    \ the NAT64, data can still flow in the connection, and the NAT64 is\n      waiting\
    \ for a matching TCP FIN in the opposite direction.\n      V6 FIN RCV: An IPv6\
    \ packet containing a TCP FIN was received by\n      the NAT64, data can still\
    \ flow in the connection, and the NAT64 is\n      waiting for a matching TCP FIN\
    \ in the opposite direction.\n      V6 FIN + V4 FIN RCV: Both an IPv4 packet containing\
    \ a TCP FIN and\n      an IPv6 packet containing an TCP FIN for this connection\
    \ were\n      received by the NAT64.  The NAT64 keeps the connection state alive\n\
    \      and forwards packets in both directions for a short period of time\n  \
    \    to allow remaining packets (in particular, the ACKs) to be\n      delivered.\n\
    \      TRANS: The lifetime of the state for the connection is set to\n      TCP_TRANS\
    \ minutes either because a packet containing a TCP RST was\n      received by\
    \ the NAT64 for this connection or simply because the\n      lifetime of the connection\
    \ has decreased and there are only\n      TCP_TRANS minutes left.  The NAT64 will\
    \ keep the state for the\n      connection for TCP_TRANS minutes, and if no other\
    \ data packets for\n      that connection are received, the state for this connection\
    \ is\n      then terminated.\n"
- title: 3.5.2.2.  State Machine for TCP Processing in the NAT64
  contents:
  - "3.5.2.2.  State Machine for TCP Processing in the NAT64\n   The state machine\
    \ used by the NAT64 for the TCP session processing is\n   depicted next.  The\
    \ described state machine handles all TCP segments\n   received through the IPv6\
    \ and IPv4 interface.  There is one state\n   machine per TCP connection that\
    \ is potentially established through\n   the NAT64.  After bootstrapping of the\
    \ NAT64 device, all TCP sessions\n   are in CLOSED state.  As we mention above,\
    \ the CLOSED state is a\n   fictional state when there is no state for that particular\
    \ connection\n   in the NAT64.  It should be noted that there is one state machine\
    \ per\n   connection, so only packets belonging to a given connection are\n  \
    \ inputs to the state machine associated to that connection.  In other\n   words,\
    \ when in the state machine below we state that a packet is\n   received, it is\
    \ implicit that the incoming 5-tuple of the data packet\n   matches to the one\
    \ of the state machine.\n   A TCP segment with the SYN flag set that is received\
    \ through the IPv6\n   interface is called a V6 SYN, similarly, V4 SYN, V4 FIN,\
    \ V6 FIN, V6\n   FIN + V4 FIN, V6 RST, and V4 RST.\n   The figure presents a simplified\
    \ version of the state machine; refer\n   to the text for the full specification\
    \ of the state machine.\n                                      +-----------------------------+\n\
    \                                      |                             |\n     \
    \                                 V                             |\n          \
    \             V6       +------+      V4                    |\n               \
    \   +----SYN------|CLOSED|-----SYN------+             |\n                  | \
    \            +------+              |             |\n                  |      \
    \          ^                  |             |\n                  |           \
    \     |TCP_TRANS T.O.    |             |\n                  V                |\
    \                  V             |\n              +-------+         +-------+\
    \          +-------+        |\n              |V6 INIT|         | TRANS |     \
    \     |V4 INIT|        |\n              +-------+         +-------+          +-------+\
    \        |\n                 |               |    ^               |          \
    \   |\n                 |         data pkt   |               |             |\n\
    \                 |               |  V4 or V6 RST      |             |\n     \
    \            |               |  TCP_EST T.O.      |             |\n          \
    \    V4 SYN             V    |              V6 SYN         |\n               \
    \  |          +--------------+          |             |\n                 +--------->|\
    \ ESTABLISHED  |<---------+             |\n                            +--------------+\
    \                        |\n                              |           |      \
    \                   |\n                          V4 FIN       V6 FIN         \
    \              |\n                              |           |                \
    \         |\n                              V           V                     \
    \    |\n                      +---------+       +----------+                |\n\
    \                      | V4 FIN  |       |  V6 FIN  |                |\n     \
    \                 |   RCV   |       |    RCV   |                |\n          \
    \            +---------+       +----------+                |\n               \
    \               |           |                         |\n                    \
    \      V6 FIN       V4 FIN                 TCP_TRANS\n                       \
    \       |           |                        T.O.\n                          \
    \    V           V                         |\n                         +---------------------+\
    \                    |\n                         | V4 FIN + V6 FIN RCV |--------------------+\n\
    \                         +---------------------+\n   We next describe the state\
    \ information and the transitions.\n   *** CLOSED ***\n   If a V6 SYN is received\
    \ with an incoming tuple with source transport\n   address (X',x) and destination\
    \ transport address (Y',y) (this is the\n   case of a TCP connection initiated\
    \ from the IPv6 side), the\n   processing is as follows:\n   1.  The NAT64 searches\
    \ for a TCP BIB entry that matches the IPv6\n       source transport address (X',x).\n\
    \          If such an entry does not exist, the NAT64 tries to create a\n    \
    \      new BIB entry (if resources and policy permit).  The BIB IPv6\n       \
    \   transport address is set to (X',x), i.e., the source IPv6\n          transport\
    \ address of the packet.  The BIB IPv4 transport\n          address is set to\
    \ an IPv4 transport address allocated using\n          the rules defined in Section\
    \ 3.5.2.3.  The processing of the\n          packet continues as described in\
    \ bullet 2.\n          If the entry already exists, then the processing continues\
    \ as\n          described in bullet 2.\n   2.  Then the NAT64 tries to create\
    \ a new TCP session entry in the TCP\n       session table (if resources and policy\
    \ permit).  The information\n       included in the session table is as follows:\n\
    \          The STE source IPv6 transport address is set to (X',x), i.e.,\n   \
    \       the source transport address contained in the received V6 SYN\n      \
    \    packet.\n          The STE destination IPv6 transport address is set to (Y',y),\n\
    \          i.e., the destination transport address contained in the\n        \
    \  received V6 SYN packet.\n          The STE source IPv4 transport address is\
    \ set to the BIB IPv4\n          transport address of the corresponding TCP BIB\
    \ entry.\n          The STE destination IPv4 transport address contains the port\
    \ y\n          (i.e., the same port as the IPv6 destination transport\n      \
    \    address) and the IPv4 address that is algorithmically\n          generated\
    \ from the IPv6 destination address (i.e., Y') using\n          the reverse algorithm\
    \ as specified in Section 3.5.4.\n          The lifetime of the TCP Session Table\
    \ Entry is set to at least\n          TCP_TRANS (the transitory connection idle\
    \ timeout as defined\n          in [RFC5382]).\n   3.  The state of the session\
    \ is moved to V6 INIT.\n   4.  The NAT64 translates and forwards the packet as\
    \ described in the\n       following sections.\n   If a V4 SYN packet is received\
    \ with an incoming tuple with source\n   IPv4 transport address (Y,y) and destination\
    \ IPv4 transport address\n   (X,x) (this is the case of a TCP connection initiated\
    \ from the IPv4\n   side), the processing is as follows:\n      If the security\
    \ policy requires silently dropping externally\n      initiated TCP connections,\
    \ then the packet is silently discarded.\n      Else, if the destination transport\
    \ address contained in the\n      incoming V4 SYN (i.e., X,x) is not in use in\
    \ the TCP BIB, then:\n         The NAT64 tries to create a new Session Table Entry\
    \ in the TCP\n         session table (if resources and policy permit), containing\
    \ the\n         following information:\n         +  The STE source IPv4 transport\
    \ address is set to (X,x), i.e.,\n            the destination transport address\
    \ contained in the V4 SYN.\n         +  The STE destination IPv4 transport address\
    \ is set to (Y,y),\n            i.e., the source transport address contained in\
    \ the V4 SYN.\n         +  The STE transport IPv6 source address is left unspecified\n\
    \            and may be populated by other protocols that are out of the\n   \
    \         scope of this specification.\n         +  The STE destination IPv6 transport\
    \ address contains the port\n            y (i.e., the same port as the STE destination\
    \ IPv4 transport\n            address) and the IPv6 representation of Y (i.e.,\
    \ the IPv4\n            address of the STE destination IPv4 transport address),\n\
    \            generated using the algorithm described in Section 3.5.4.\n     \
    \    The state is moved to V4 INIT.\n         The lifetime of the STE entry is\
    \ set to TCP_INCOMING_SYN as per\n         [RFC5382], and the packet is stored.\
    \  The result is that the\n         NAT64 will not drop the packet based on the\
    \ filtering, nor\n         create a BIB entry.  Instead, the NAT64 will only create\
    \ the\n         Session Table Entry and store the packet.  The motivation for\n\
    \         this is to support simultaneous open of TCP connections.\n      If the\
    \ destination transport address contained in the incoming V4\n      SYN (i.e.,\
    \ X,x) is in use in the TCP BIB, then:\n         The NAT64 tries to create a new\
    \ Session Table Entry in the TCP\n         session table (if resources and policy\
    \ permit), containing the\n         following information:\n         +  The STE\
    \ source IPv4 transport address is set to (X,x), i.e.,\n            the destination\
    \ transport address contained in the V4 SYN.\n         +  The STE destination\
    \ IPv4 transport address is set to (Y,y),\n            i.e., the source transport\
    \ address contained in the V4 SYN.\n         +  The STE transport IPv6 source\
    \ address is set to the IPv6\n            transport address contained in the corresponding\
    \ TCP BIB\n            entry.\n         +  The STE destination IPv6 transport\
    \ address contains the port\n            y (i.e., the same port as the STE destination\
    \ IPv4 transport\n            address) and the IPv6 representation of Y (i.e.,\
    \ the IPv4\n            address of the STE destination IPv4 transport address),\n\
    \            generated using the algorithm described in Section 3.5.4.\n     \
    \    The state is moved to V4 INIT.\n         If the NAT64 is performing Address-Dependent\
    \ Filtering, the\n         lifetime of the STE entry is set to TCP_INCOMING_SYN\
    \ as per\n         [RFC5382], and the packet is stored.  The motivation for\n\
    \         creating the Session Table Entry and storing the packet\n         (instead\
    \ of simply dropping the packet based on the filtering)\n         is to support\
    \ simultaneous open of TCP connections.\n         If the NAT64 is not performing\
    \ Address-Dependent Filtering, the\n         lifetime of the STE is set to at\
    \ least TCP_TRANS (the\n         transitory connection idle timeout as defined\
    \ in [RFC5382]),\n         and it translates and forwards the packet as described\
    \ in the\n         following sections.\n   For any other packet belonging to this\
    \ connection:\n      If there is a corresponding entry in the TCP BIB, the packet\n\
    \      SHOULD be translated and forwarded if the security policy allows\n    \
    \  doing so.  The state remains unchanged.\n      If there is no corresponding\
    \ entry in the TCP BIB, the packet is\n      silently discarded.\n   *** V4 INIT\
    \ ***\n   If a V6 SYN is received with incoming tuple with source transport\n\
    \   address (X',x) and destination transport address (Y',y), then the\n   lifetime\
    \ of the TCP Session Table Entry is set to at least the\n   maximum session lifetime.\
    \  The value for the maximum session lifetime\n   MAY be configurable, but it\
    \ MUST NOT be less than TCP_EST (the\n   established connection idle timeout as\
    \ defined in [RFC5382]).  The\n   default value for the maximum session lifetime\
    \ SHOULD be set to\n   TCP_EST.  The packet is translated and forwarded.  The\
    \ state is moved\n   to ESTABLISHED.\n   If the lifetime expires, an ICMP Port\
    \ Unreachable error (Type 3, Code\n   3) containing the IPv4 SYN packet stored\
    \ is sent back to the source\n   of the v4 SYN, the Session Table Entry is deleted,\
    \ and the state is\n   moved to CLOSED.\n   For any other packet, the packet SHOULD\
    \ be translated and forwarded\n   if the security policy allows doing so.  The\
    \ state remains unchanged.\n   *** V6 INIT ***\n   If a V4 SYN is received (with\
    \ or without the ACK flag set), with an\n   incoming tuple with source IPv4 transport\
    \ address (Y,y) and\n   destination IPv4 transport address (X,x), then the state\
    \ is moved to\n   ESTABLISHED.  The lifetime of the TCP Session Table Entry is\
    \ set to\n   at least the maximum session lifetime.  The value for the maximum\n\
    \   session lifetime MAY be configurable, but it MUST NOT be less than\n   TCP_EST\
    \ (the established connection idle timeout as defined in\n   [RFC5382]).  The\
    \ default value for the maximum session lifetime\n   SHOULD be set to TCP_EST.\
    \  The packet is translated and forwarded.\n   If the lifetime expires, the Session\
    \ Table Entry is deleted, and the\n   state is moved to CLOSED.\n   If a V6 SYN\
    \ packet is received, the packet is translated and\n   forwarded.  The lifetime\
    \ of the TCP Session Table Entry is set to at\n   least TCP_TRANS.  The state\
    \ remains unchanged.\n   For any other packet, the packet SHOULD be translated\
    \ and forwarded\n   if the security policy allows doing so.  The state remains\
    \ unchanged.\n   *** ESTABLISHED ***\n   If a V4 FIN packet is received, the packet\
    \ is translated and\n   forwarded.  The state is moved to V4 FIN RCV.\n   If a\
    \ V6 FIN packet is received, the packet is translated and\n   forwarded.  The\
    \ state is moved to V6 FIN RCV.\n   If a V4 RST or a V6 RST packet is received,\
    \ the packet is translated\n   and forwarded.  The lifetime is set to TCP_TRANS\
    \ and the state is\n   moved to TRANS.  (Since the NAT64 is uncertain whether\
    \ the peer will\n   accept the RST packet, instead of moving the state to CLOSED,\
    \ it\n   moves to TRANS, which has a shorter lifetime.  If no other packets\n\
    \   are received for this connection during the short timer, the NAT64\n   assumes\
    \ that the peer has accepted the RST packet and moves to\n   CLOSED.  If packets\
    \ keep flowing, the NAT64 assumes that the peer has\n   not accepted the RST packet\
    \ and moves back to the ESTABLISHED state.\n   This is described below in the\
    \ TRANS state processing description.)\n   If any other packet is received, the\
    \ packet is translated and\n   forwarded.  The lifetime of the TCP Session Table\
    \ Entry is set to at\n   least the maximum session lifetime.  The value for the\
    \ maximum\n   session lifetime MAY be configurable, but it MUST NOT be less than\n\
    \   TCP_EST (the established connection idle timeout as defined in\n   [RFC5382]).\
    \  The default value for the maximum session lifetime\n   SHOULD be set to TCP_EST.\
    \  The state remains unchanged as\n   ESTABLISHED.\n   If the lifetime expires,\
    \ then the NAT64 SHOULD send a probe packet\n   (as defined next) to at least\
    \ one of the endpoints of the TCP\n   connection.  The probe packet is a TCP segment\
    \ for the connection\n   with no data.  The sequence number and the acknowledgment\
    \ number are\n   set to zero.  All flags but the ACK flag are set to zero.  The\
    \ state\n   is moved to TRANS.\n      Upon the reception of this probe packet,\
    \ the endpoint will reply\n      with an ACK containing the expected sequence\
    \ number for that\n      connection.  It should be noted that, for an active connection,\n\
    \      each of these probe packets will generate one packet from each end\n  \
    \    involved in the connection, since the reply of the first point to\n     \
    \ the probe packet will generate a reply from the other endpoint.\n   *** V4 FIN\
    \ RCV ***\n   If a V6 FIN packet is received, the packet is translated and\n \
    \  forwarded.  The lifetime is set to TCP_TRANS.  The state is moved to\n   V6\
    \ FIN + V4 FIN RCV.\n   If any packet other than the V6 FIN is received, the packet\
    \ is\n   translated and forwarded.  The lifetime of the TCP Session Table\n  \
    \ Entry is set to at least the maximum session lifetime.  The value for\n   the\
    \ maximum session lifetime MAY be configurable, but it MUST NOT be\n   less than\
    \ TCP_EST (the established connection idle timeout as defined\n   in [RFC5382]).\
    \  The default value for the maximum session lifetime\n   SHOULD be set to TCP_EST.\
    \  The state remains unchanged as V4 FIN RCV.\n   If the lifetime expires, the\
    \ Session Table Entry is deleted, and the\n   state is moved to CLOSED.\n   ***\
    \ V6 FIN RCV ***\n   If a V4 FIN packet is received, the packet is translated\
    \ and\n   forwarded.  The lifetime is set to TCP_TRANS.  The state is moved to\n\
    \   V6 FIN + V4 FIN RCV.\n   If any packet other than the V4 FIN is received,\
    \ the packet is\n   translated and forwarded.  The lifetime of the TCP Session\
    \ Table\n   Entry is set to at least the maximum session lifetime.  The value\
    \ for\n   the maximum session lifetime MAY be configurable, but it MUST NOT be\n\
    \   less than TCP_EST (the established connection idle timeout as defined\n  \
    \ in [RFC5382]).  The default value for the maximum session lifetime\n   SHOULD\
    \ be set to TCP_EST.  The state remains unchanged as V6 FIN RCV.\n   If the lifetime\
    \ expires, the Session Table Entry is deleted and the\n   state is moved to CLOSED.\n\
    \   *** V6 FIN + V4 FIN RCV ***\n   All packets are translated and forwarded.\n\
    \   If the lifetime expires, the Session Table Entry is deleted and the\n   state\
    \ is moved to CLOSED.\n   *** TRANS ***\n   If a packet other than a RST packet\
    \ is received, the lifetime of the\n   TCP Session Table Entry is set to at least\
    \ the maximum session\n   lifetime.  The value for the maximum session lifetime\
    \ MAY be\n   configurable, but it MUST NOT be less than TCP_EST (the established\n\
    \   connection idle timeout as defined in [RFC5382]).  The default value\n   for\
    \ the maximum session lifetime SHOULD be set to TCP_EST.  The state\n   is moved\
    \ to ESTABLISHED.\n   If the lifetime expires, the Session Table Entry is deleted\
    \ and the\n   state is moved to CLOSED.\n"
- title: 3.5.2.3.  Rules for Allocation of IPv4 Transport Addresses for TCP
  contents:
  - "3.5.2.3.  Rules for Allocation of IPv4 Transport Addresses for TCP\n   When a\
    \ new TCP BIB entry is created for a source transport address of\n   (S',s), the\
    \ NAT64 allocates an IPv4 transport address for this BIB\n   entry as follows:\n\
    \      If there exists some other BIB entry in any of the BIBs that\n      contains\
    \ S' as the IPv6 address and maps it to some IPv4 address\n      T, then T SHOULD\
    \ be used as the IPv4 address.  Otherwise, use any\n      IPv4 address of the\
    \ IPv4 pool assigned to the NAT64 to be used for\n      translation.\n      If\
    \ the port s is in the Well-Known port range 0-1023, and the\n      NAT64 has\
    \ an available port t in the same port range, then the\n      NAT64 SHOULD allocate\
    \ the port t.  If the NAT64 does not have a\n      port available in the same\
    \ range, the NAT64 MAY assign a port t\n      from another range where it has\
    \ an available port.\n      If the port s is in the range 1024-65535, and the\
    \ NAT64 has an\n      available port t in the same port range, then the NAT64\
    \ SHOULD\n      allocate the port t.  If the NAT64 does not have a port available\n\
    \      in the same range, the NAT64 MAY assign a port t from another\n      range\
    \ where it has an available port.\n      In all cases, the allocated IPv4 transport\
    \ address (T,t) MUST NOT\n      be in use in another entry in the same BIB, but\
    \ can be in use in\n      other BIBs (e.g., the UDP and TCP BIBs).\n   If it is\
    \ not possible to allocate an appropriate IPv4 transport\n   address or create\
    \ a BIB entry, then the packet is discarded.  The\n   NAT64 SHOULD send an ICMPv6\
    \ Destination Unreachable error message\n   with Code 3 (Address Unreachable).\n"
- title: 3.5.3.  ICMP Query Session Handling
  contents:
  - "3.5.3.  ICMP Query Session Handling\n   The following state information is stored\
    \ for an ICMP Query session\n   in the ICMP Query session table:\n      Binding:(X',Y',i1)\
    \ <--> (T,Z,i2)\n      Lifetime: a timer that tracks the remaining lifetime of\
    \ the ICMP\n      Query session.  When the timer expires, the session is deleted.\n\
    \      If all the ICMP Query sessions corresponding to a dynamically\n      created\
    \ ICMP Query BIB entry are deleted, then the ICMP Query BIB\n      entry is also\
    \ deleted.\n   An incoming ICMPv6 Informational packet with IPv6 source address\
    \ X',\n   IPv6 destination address Y', and ICMPv6 Identifier i1 is processed as\n\
    \   follows:\n      If the local security policy determines that ICMPv6 Informational\n\
    \      packets are to be filtered, the packet is silently discarded.\n      Else,\
    \ the NAT64 searches for an ICMP Query BIB entry that matches\n      the (X',i1)\
    \ pair.  If such an entry does not exist, the NAT64\n      tries to create a new\
    \ entry (if resources and policy permit) with\n      the following data:\n   \
    \   *  The BIB IPv6 address is set to X' (i.e., the source IPv6\n         address\
    \ of the IPv6 packet).\n      *  The BIB ICMPv6 Identifier is set to i1 (i.e.,\
    \ the ICMPv6\n         Identifier).\n      *  If there exists another BIB entry\
    \ in any of the BIBs that\n         contains the same IPv6 address X' and maps\
    \ it to an IPv4\n         address T, then use T as the BIB IPv4 address for this\
    \ new\n         entry.  Otherwise, use any IPv4 address assigned to the IPv4\n\
    \         interface.\n      *  Any available value is used as the BIB ICMPv4 Identifier,\
    \ i.e.,\n         any identifier value for which no other entry exists with the\n\
    \         same (IPv4 address, ICMPv4 Identifier) pair.\n      The NAT64 searches\
    \ for an ICMP Query Session Table Entry\n      corresponding to the incoming 3-tuple\
    \ (X',Y',i1).  If no such\n      entry is found, the NAT64 tries to create a new\
    \ entry (if\n      resources and policy permit).  The information included in\
    \ the new\n      Session Table Entry is as follows:\n      *  The STE IPv6 source\
    \ address is set to X' (i.e., the address\n         contained in the received\
    \ IPv6 packet).\n      *  The STE IPv6 destination address is set to Y' (i.e.,\
    \ the\n         address contained in the received IPv6 packet).\n      *  The\
    \ STE ICMPv6 Identifier is set to i1 (i.e., the identifier\n         contained\
    \ in the received IPv6 packet).\n      *  The STE IPv4 source address is set to\
    \ the IPv4 address\n         contained in the corresponding BIB entry.\n     \
    \ *  The STE ICMPv4 Identifier is set to the IPv4 identifier\n         contained\
    \ in the corresponding BIB entry.\n      *  The STE IPv4 destination address is\
    \ algorithmically generated\n         from Y' using the reverse algorithm as specified\
    \ in\n         Section 3.5.4.\n      The NAT64 sets (or resets) the timer in the\
    \ session table entry to\n      the maximum session lifetime.  By default, the\
    \ maximum session\n      lifetime is ICMP_DEFAULT.  The maximum lifetime value\
    \ SHOULD be\n      configurable.  The packet is translated and forwarded as described\n\
    \      in the following sections.\n   An incoming ICMPv4 Query packet with source\
    \ IPv4 address Y,\n   destination IPv4 address X, and ICMPv4 Identifier i2 is\
    \ processed as\n   follows:\n      The NAT64 searches for an ICMP Query BIB entry\
    \ that contains X as\n      the IPv4 address and i2 as the ICMPv4 Identifier.\
    \  If such an\n      entry does not exist, the packet is dropped.  An ICMP error\n\
    \      message MAY be sent to the original sender of the packet.  The\n      ICMP\
    \ error message, if sent, has Type 3, Code 1 (Host\n      Unreachable).\n    \
    \  If the NAT64 filters on its IPv4 interface, then the NAT64 checks\n      to\
    \ see if the incoming packet is allowed according to the Address-\n      Dependent\
    \ Filtering rule.  To do this, it searches for a Session\n      Table Entry with\
    \ an STE source IPv4 address equal to X, an STE\n      ICMPv4 Identifier equal\
    \ to i2, and a STE destination IPv4 address\n      equal to Y.  If such an entry\
    \ is found (there may be more than\n      one), packet processing continues. \
    \ Otherwise, the packet is\n      discarded.  If the packet is discarded, then\
    \ an ICMP error message\n      MAY be sent to the original sender of the packet.\
    \  The ICMP error\n      message, if sent, has Type 3 (Destination Unreachable)\
    \ and Code 13\n      (Communication Administratively Prohibited).\n      In case\
    \ the packet is not discarded in the previous processing\n      steps (either\
    \ because the NAT64 is not filtering or because the\n      packet is compliant\
    \ with the Address-Dependent Filtering rule),\n      then the NAT64 searches for\
    \ a Session Table Entry with an STE\n      source IPv4 address equal to X, an\
    \ STE ICMPv4 Identifier equal to\n      i2, and a STE destination IPv4 address\
    \ equal to Y.  If no such\n      entry is found, the NAT64 tries to create a new\
    \ entry (if\n      resources and policy permit) with the following information:\n\
    \      *  The STE source IPv4 address is set to X.\n      *  The STE ICMPv4 Identifier\
    \ is set to i2.\n      *  The STE destination IPv4 address is set to Y.\n    \
    \  *  The STE source IPv6 address is set to the IPv6 address of the\n        \
    \ corresponding BIB entry.\n      *  The STE ICMPv6 Identifier is set to the ICMPv6\
    \ Identifier of\n         the corresponding BIB entry.\n      *  The STE destination\
    \ IPv6 address is set to the IPv6\n         representation of the IPv4 address\
    \ of Y, generated using the\n         algorithm described in Section 3.5.4.\n\
    \      *  The NAT64 sets (or resets) the timer in the session table entry\n  \
    \       to the maximum session lifetime.  By default, the maximum\n         session\
    \ lifetime is ICMP_DEFAULT.  The maximum lifetime value\n         SHOULD be configurable.\
    \  The packet is translated and forwarded\n         as described in the following\
    \ sections.\n"
- title: 3.5.4.  Generation of the IPv6 Representations of IPv4 Addresses
  contents:
  - "3.5.4.  Generation of the IPv6 Representations of IPv4 Addresses\n   NAT64 supports\
    \ multiple algorithms for the generation of the IPv6\n   representation of an\
    \ IPv4 address and vice versa.  The constraints\n   imposed on the generation\
    \ algorithms are the following:\n      The algorithm MUST be reversible, i.e.,\
    \ it MUST be possible to\n      derive the original IPv4 address from the IPv6\
    \ representation.\n      The input for the algorithm MUST be limited to the IPv4\
    \ address,\n      the IPv6 prefix (denoted Pref64::/n) used in the IPv6\n    \
    \  representations, and optionally a set of stable parameters that\n      are\
    \ configured in the NAT64 (such as a fixed string to be used as\n      a suffix).\n\
    \         If we note n the length of the prefix Pref64::/n, then n MUST\n    \
    \     be less than or equal to 96.  If a Pref64::/n is configured\n         through\
    \ any means in the NAT64 (such as manually configured, or\n         other automatic\
    \ means not specified in this document), the\n         default algorithm MUST\
    \ use this prefix.  If no prefix is\n         available, the algorithm SHOULD\
    \ use the Well-Known Prefix\n         (64:ff9b::/96) defined in [RFC6052].\n \
    \  NAT64 MUST support the algorithm for generating IPv6 representations\n   of\
    \ IPv4 addresses defined in Section 2.3 of [RFC6052].  The\n   aforementioned\
    \ algorithm SHOULD be used as default algorithm.\n"
- title: 3.6.  Computing the Outgoing Tuple
  contents:
  - "3.6.  Computing the Outgoing Tuple\n   This step computes the outgoing tuple\
    \ by translating the IP addresses\n   and port numbers or ICMP Identifier in the\
    \ incoming tuple.\n   In the text below, a reference to a BIB means the TCP BIB,\
    \ the UDP\n   BIB, or the ICMP Query BIB, as appropriate.\n      NOTE: Not all\
    \ addresses are translated using the BIB.  BIB entries\n      are used to translate\
    \ IPv6 source transport addresses to IPv4\n      source transport addresses, and\
    \ IPv4 destination transport\n      addresses to IPv6 destination transport addresses.\
    \  They are NOT\n      used to translate IPv6 destination transport addresses\
    \ to IPv4\n      destination transport addresses, nor to translate IPv4 source\n\
    \      transport addresses to IPv6 source transport addresses.  The\n      latter\
    \ cases are handled by applying the algorithmic\n      transformation described\
    \ in Section 3.5.4.  This distinction is\n      important; without it, hairpinning\
    \ doesn't work correctly.\n"
- title: 3.6.1.  Computing the Outgoing 5-Tuple for TCP, UDP, and for ICMP Error
  contents:
  - "3.6.1.  Computing the Outgoing 5-Tuple for TCP, UDP, and for ICMP Error\n   \
    \     Messages Containing a TCP or UDP Packets\n   The transport protocol in the\
    \ outgoing 5-tuple is always the same as\n   that in the incoming 5-tuple.  When\
    \ translating from IPv4 ICMP to\n   IPv6 ICMP, the protocol number in the last\
    \ next header field in the\n   protocol chain is set to 58 (IPv6-ICMP).  When\
    \ translating from IPv6\n   ICMP to IPv4 ICMP, the protocol number in the protocol\
    \ field of the\n   IP header is set to 1 (ICMP).\n   When translating in the IPv6\
    \ --> IPv4 direction, let the source and\n   destination transport addresses in\
    \ the incoming 5-tuple be (S',s) and\n   (D',d), respectively.  The outgoing source\
    \ transport address is\n   computed as follows: if the BIB contains an entry (S',s)\
    \ <--> (T,t),\n   then the outgoing source transport address is (T,t).\n   The\
    \ outgoing destination address is computed algorithmically from D'\n   using the\
    \ address transformation described in Section 3.5.4.\n   When translating in the\
    \ IPv4 --> IPv6 direction, let the source and\n   destination transport addresses\
    \ in the incoming 5-tuple be (S,s) and\n   (D,d), respectively.  The outgoing\
    \ source transport address is\n   computed as follows:\n      The outgoing source\
    \ transport address is generated from S using\n      the address transformation\
    \ algorithm described in Section 3.5.4.\n      The BIB table is searched for an\
    \ entry (X',x) <--> (D,d), and if\n      one is found, the outgoing destination\
    \ transport address is set to\n      (X',x).\n"
- title: 3.6.2.  Computing the Outgoing 3-Tuple for ICMP Query Messages and for
  contents:
  - "3.6.2.  Computing the Outgoing 3-Tuple for ICMP Query Messages and for\n    \
    \    ICMP Error Messages Containing an ICMP Query\n   When translating in the\
    \ IPv6 --> IPv4 direction, let the source and\n   destination addresses in the\
    \ incoming 3-tuple be S' and D',\n   respectively, and the ICMPv6 Identifier be\
    \ i1.  The outgoing source\n   address is computed as follows: the BIB contains\
    \ an entry (S',i1)\n   <--> (T,i2), then the outgoing source address is T and\
    \ the ICMPv4\n   Identifier is i2.\n   The outgoing IPv4 destination address is\
    \ computed algorithmically\n   from D' using the address transformation described\
    \ in Section 3.5.4.\n   When translating in the IPv4 --> IPv6 direction, let the\
    \ source and\n   destination addresses in the incoming 3-tuple be S and D,\n \
    \  respectively, and the ICMPv4 Identifier is i2.  The outgoing source\n   address\
    \ is generated from S using the address transformation\n   algorithm described\
    \ in Section 3.5.4.  The BIB is searched for an\n   entry containing (X',i1) <-->\
    \ (D,i2), and, if found, the outgoing\n   destination address is X' and the outgoing\
    \ ICMPv6 Identifier is i1.\n"
- title: 3.7.  Translating the Packet
  contents:
  - "3.7.  Translating the Packet\n   This step translates the packet from IPv6 to\
    \ IPv4 or vice versa.\n   The translation of the packet is as specified in Sections\
    \ 4 and 5 of\n   the IP/ICMP Translation Algorithm [RFC6145], with the following\n\
    \   modifications:\n   o  When translating an IP header (Sections 4.1 and 5.1\
    \ of [RFC6145]),\n      the source and destination IP address fields are set to\
    \ the source\n      and destination IP addresses from the outgoing tuple as determined\n\
    \      in Section 3.6.\n   o  When the protocol following the IP header is TCP\
    \ or UDP, then the\n      source and destination ports are modified to the source\
    \ and\n      destination ports from the outgoing 5-tuple.  In addition, the TCP\n\
    \      or UDP checksum must also be updated to reflect the translated\n      addresses\
    \ and ports; note that the TCP and UDP checksum covers the\n      pseudo-header\
    \ that contains the source and destination IP\n      addresses.  An algorithm\
    \ for efficiently updating these checksums\n      is described in [RFC3022].\n\
    \   o  When the protocol following the IP header is ICMP and it is an\n      ICMP\
    \ Query message, the ICMP Identifier is set to the one from the\n      outgoing\
    \ 3-tuple as determined in Section 3.6.2.\n   o  When the protocol following the\
    \ IP header is ICMP and it is an\n      ICMP error message, the source and destination\
    \ transport addresses\n      in the embedded packet are set to the destination\
    \ and source\n      transport addresses from the outgoing 5-tuple (note the swap\
    \ of\n      source and destination).\n   The size of outgoing packets as well\
    \ and the potential need for\n   fragmentation is done according to the behavior\
    \ defined in the IP/\n   ICMP Translation Algorithm [RFC6145].\n"
- title: 3.8.  Handling Hairpinning
  contents:
  - "3.8.  Handling Hairpinning\n   If the destination IP address of the translated\
    \ packet is an IPv4\n   address assigned to the NAT64 itself, then the packet\
    \ is a hairpin\n   packet.  Hairpin packets are processed as follows:\n   o  The\
    \ outgoing 5-tuple becomes the incoming 5-tuple.\n   o  The packet is treated\
    \ as if it was received on the outgoing\n      interface.\n   o  Processing of\
    \ the packet continues at step 2 -- \"Filtering and\n      Updating Binding and\
    \ Session Information\" (Section 3.5).\n"
- title: 4.  Protocol Constants
  contents:
  - "4.  Protocol Constants\n   UDP_MIN: 2 minutes (as defined in [RFC4787])\n   UDP_DEFAULT:\
    \ 5 minutes (as defined in [RFC4787])\n   TCP_TRANS: 4 minutes (as defined in\
    \ [RFC5382])\n   TCP_EST: 2 hours (The minimum lifetime for an established TCP\
    \ session\n   defined in [RFC5382] is 2 hours and 4 minutes, which is achieved\
    \ by\n   adding the 2 hours with this timer and the 4 minutes with the\n   TCP_TRANS\
    \ timer.)\n   TCP_INCOMING_SYN: 6 seconds (as defined in [RFC5382])\n   FRAGMENT_MIN:\
    \ 2 seconds\n   ICMP_DEFAULT: 60 seconds (as defined in [RFC5508])\n"
- title: 5.  Security Considerations
  contents:
  - '5.  Security Considerations

    '
- title: 5.1.  Implications on End-to-End Security
  contents:
  - "5.1.  Implications on End-to-End Security\n   Any protocols that protect IP header\
    \ information are essentially\n   incompatible with NAT64.  This implies that\
    \ end-to-end IPsec\n   verification will fail when the Authentication Header (AH)\
    \ is used\n   (both transport and tunnel mode) and when ESP is used in transport\n\
    \   mode.  This is inherent in any network-layer translation mechanism.\n   End-to-end\
    \ IPsec protection can be restored, using UDP encapsulation\n   as described in\
    \ [RFC3948].  The actual extensions to support IPsec\n   are out of the scope\
    \ of this document.\n"
- title: 5.2.  Filtering
  contents:
  - "5.2.  Filtering\n   NAT64 creates binding state using packets flowing from the\
    \ IPv6 side\n   to the IPv4 side.  In accordance with the procedures defined in\
    \ this\n   document following the guidelines defined in [RFC4787], a NAT64 MUST\n\
    \   offer \"Endpoint-Independent Mapping\".  This means:\n      For any IPv6 packet\
    \ with source (S'1,s1) and destination\n      (Pref64::D1,d1) that creates an\
    \ external mapping to (S1,s1v4),\n      (D1,d1), for any subsequent packet from\
    \ (S'1,s1) to\n      (Pref64::D2,d2) that creates an external mapping to (S2,s2v4),\n\
    \      (D2,d2), within a given binding timer window,\n      (S1,s1v4) = (S2,s2v4)\
    \ for all values of D2,d2\n   Implementations MAY also provide support for \"\
    Address-Dependent\n   Mapping\" as also defined in this document and following\
    \ the\n   guidelines defined in [RFC4787].\n   The security properties, however,\
    \ are determined by which packets the\n   NAT64 filter allows in and which it\
    \ does not.  The security\n   properties are determined by the filtering behavior\
    \ and filtering\n   configuration in the filtering portions of the NAT64, not\
    \ by the\n   address mapping behavior.  For example:\n      Without filtering\
    \ - When \"Endpoint-Independent Mapping\" is used in\n      NAT64, once a binding\
    \ is created in the IPv6 ---> IPv4 direction,\n      packets from any node on\
    \ the IPv4 side destined to the IPv6\n      transport address will traverse the\
    \ NAT64 gateway and be forwarded\n      to the IPv6 transport address that created\
    \ the binding.  However,\n      With filtering - When \"Endpoint-Independent Mapping\"\
    \ is used in\n      NAT64, once a binding is created in the IPv6 ---> IPv4 direction,\n\
    \      packets from any node on the IPv4 side destined to the IPv6\n      transport\
    \ address will first be processed against the filtering\n      rules.  If the\
    \ source IPv4 address is permitted, the packets will\n      be forwarded to the\
    \ IPv6 transport address.  If the source IPv4\n      address is explicitly denied\
    \ -- or the default policy is to deny\n      all addresses not explicitly permitted\
    \ -- then the packet will be\n      discarded.  A dynamic filter may be employed\
    \ whereby the filter\n      will only allow packets from the IPv4 address to which\
    \ the\n      original packet that created the binding was sent.  This means\n\
    \      that only the IPv4 addresses to which the IPv6 host has initiated\n   \
    \   connections will be able to reach the IPv6 transport address, and\n      no\
    \ others.  This essentially narrows the effective operation of\n      the NAT64\
    \ device to an \"Address-Dependent Mapping\" behavior,\n      though not by its\
    \ mapping behavior, but instead by its filtering\n      behavior.\n   As currently\
    \ specified, the NAT64 only requires filtering traffic\n   based on the 5-tuple.\
    \  In some cases (e.g., statically configured\n   mappings), this may make it\
    \ easy for an attacker to guess.  An\n   attacker need not be able to guess other\
    \ fields, e.g., the TCP\n   sequence number, to get a packet through the NAT64.\
    \  While such\n   traffic might be dropped by the final destination, it does not\n\
    \   provide additional mitigations against bandwidth/CPU attacks\n   targeting\
    \ the internal network.  To avoid this type of abuse, a NAT64\n   MAY keep track\
    \ of the sequence number of TCP packets in order to\n   verify the proper sequencing\
    \ of exchanged segments, in particular,\n   those of the SYNs and the FINs.\n"
- title: 5.3.  Attacks on NAT64
  contents:
  - "5.3.  Attacks on NAT64\n   The NAT64 device itself is a potential victim of different\
    \ types of\n   attacks.  In particular, the NAT64 can be a victim of DoS attacks.\n\
    \   The NAT64 device has a limited number of resources that can be\n   consumed\
    \ by attackers creating a DoS attack.  The NAT64 has a limited\n   number of IPv4\
    \ addresses that it uses to create the bindings.  Even\n   though the NAT64 performs\
    \ address and port translation, it is\n   possible for an attacker to consume\
    \ all the IPv4 transport addresses\n   by sending IPv6 packets with different\
    \ source IPv6 transport\n   addresses.  This attack can only be launched from\
    \ the IPv6 side,\n   since IPv4 packets are not used to create binding state.\
    \  DoS attacks\n   can also affect other limited resources available in the NAT64\
    \ such\n   as memory or link capacity.  For instance, it is possible for an\n\
    \   attacker to launch a DoS attack on the memory of the NAT64 device by\n   sending\
    \ fragments that the NAT64 will store for a given period.  If\n   the number of\
    \ fragments is high enough, the memory of the NAT64 could\n   be exhausted.  Similarly,\
    \ a DoS attack against the NAT64 can be\n   crafted by sending either V4 or V6\
    \ SYN packets that consume memory in\n   the form of session and/or binding table\
    \ entries.  In the case of\n   IPv4 SYNs the situation is aggravated by the requirement\
    \ to also\n   store the data packets for a given amount of time, requiring more\n\
    \   memory from the NAT64 device.  NAT64 devices MUST implement proper\n   protection\
    \ against such attacks, for instance, allocating a limited\n   amount of memory\
    \ for fragmented packet storage as specified in\n   Section 3.4.\n   Another consideration\
    \ related to NAT64 resource depletion refers to\n   the preservation of binding\
    \ state.  Attackers may try to keep a\n   binding state alive forever by sending\
    \ periodic packets that refresh\n   the state.  In order to allow the NAT64 to\
    \ defend against such\n   attacks, the NAT64 MAY choose not to extend the session\
    \ entry\n   lifetime for a specific entry upon the reception of packets for that\n\
    \   entry through the external interface.  As described in the framework\n   document\
    \ [RFC6144], the NAT64 can be deployed in multiple scenarios,\n   in some of which\
    \ the Internet side is the IPv6 one, and in others of\n   which the Internet side\
    \ is the IPv4 one.  It is then important to\n   properly set which is the Internet\
    \ side of the NAT64 in each specific\n   configuration.\n"
- title: 5.4.  Avoiding Hairpinning Loops
  contents:
  - "5.4.  Avoiding Hairpinning Loops\n   If an IPv6-only client can guess the IPv4\
    \ binding address that will\n   be created, it can use the IPv6 representation\
    \ of that address as the\n   source address for creating this binding.  Then,\
    \ any packet sent to\n   the binding's IPv4 address could loop in the NAT64. \
    \ This is\n   prevented in the current specification by filtering incoming packets\n\
    \   containing Pref64::/n in the source address, as described below.\n   Consider\
    \ the following example:\n   Suppose that the IPv4 pool is 192.0.2.0/24\n   Then,\
    \ the IPv6-only client sends this to NAT64:\n      Source: [Pref64::192.0.2.1]:500\n\
    \      Destination: any\n   The NAT64 allocates 192.0.2.1:500 as the IPv4 binding\
    \ address.  Now\n   anything sent to 192.0.2.1:500, be it a hairpinned IPv6 packet\
    \ or an\n   IPv4 packet, could loop.\n   It is not hard to guess the IPv4 address\
    \ that will be allocated.\n   First, the attacker creates a binding and uses (for\
    \ example) Simple\n   Traversal of the UDP Protocol through NAT (STUN) [RFC5389]\
    \ to learn\n   its external IPv4 address.  New bindings will always have this\n\
    \   address.  Then, it uses a source port in the range 1-1023.  This will\n  \
    \ increase the chances to 1/512 (since range and parity are preserved\n   by NAT64\
    \ in UDP).\n   In order to address this vulnerability, the NAT64 MUST drop IPv6\n\
    \   packets whose source address is in Pref64::/n, as defined in\n   Section 3.5.\n"
- title: 6.  Contributors
  contents:
  - "6.  Contributors\n   George Tsirtsis\n      Qualcomm\n      tsirtsis@googlemail.com\n\
    \   Greg Lebovitz\n      Juniper\n      gregory.ietf@gmail.com\n   Simon Perreault\n\
    \      Viagenie\n      simon.perreault@viagenie.ca\n"
- title: 7.  Acknowledgements
  contents:
  - "7.  Acknowledgements\n   Dave Thaler, Dan Wing, Alberto Garcia-Martinez, Reinaldo\
    \ Penno,\n   Ranjana Rao, Lars Eggert, Senthil Sivakumar, Zhen Cao, Xiangsong\
    \ Cui,\n   Mohamed Boucadair, Dong Zhang, Bryan Ford, Kentaro Ebisawa, Charles\n\
    \   Perkins, Magnus Westerlund, Ed Jankiewicz, David Harrington, Peter\n   McCann,\
    \ Julien Laganier, Pekka Savola, and Joao Damas reviewed the\n   document and\
    \ provided useful comments to improve it.\n   The content of the document was\
    \ improved thanks to discussions with\n   Christian Huitema, Fred Baker, and Jari\
    \ Arkko.\n   Marcelo Bagnulo and Iljitsch van Beijnum are partly funded by\n \
    \  Trilogy, a research project supported by the European Commission\n   under\
    \ its Seventh Framework Program.\n"
- title: 8.  References
  contents:
  - '8.  References

    '
- title: 8.1.  Normative References
  contents:
  - "8.1.  Normative References\n   [RFC2119]  Bradner, S., \"Key words for use in\
    \ RFCs to Indicate\n              Requirement Levels\", BCP 14, RFC 2119, March\
    \ 1997.\n   [RFC4443]  Conta, A., Deering, S., and M. Gupta, \"Internet Control\n\
    \              Message Protocol (ICMPv6) for the Internet Protocol\n         \
    \     Version 6 (IPv6) Specification\", RFC 4443, March 2006.\n   [RFC4787]  Audet,\
    \ F. and C. Jennings, \"Network Address Translation\n              (NAT) Behavioral\
    \ Requirements for Unicast UDP\", BCP 127,\n              RFC 4787, January 2007.\n\
    \   [RFC5382]  Guha, S., Biswas, K., Ford, B., Sivakumar, S., and P.\n       \
    \       Srisuresh, \"NAT Behavioral Requirements for TCP\", BCP 142,\n       \
    \       RFC 5382, October 2008.\n   [RFC5508]  Srisuresh, P., Ford, B., Sivakumar,\
    \ S., and S. Guha, \"NAT\n              Behavioral Requirements for ICMP\", BCP\
    \ 148, RFC 5508,\n              April 2009.\n   [RFC6052]  Bao, C., Huitema, C.,\
    \ Bagnulo, M., Boucadair, M., and X.\n              Li, \"IPv6 Addressing of IPv4/IPv6\
    \ Translators\", RFC 6052,\n              October 2010.\n   [RFC6145]  Li, X.,\
    \ Bao, C., and F. Baker, \"IP/ICMP Translation\n              Algorithm\", RFC\
    \ 6145, April 2011.\n"
- title: 8.2.  Informative References
  contents:
  - "8.2.  Informative References\n   [RFC0793]  Postel, J., \"Transmission Control\
    \ Protocol\", STD 7,\n              RFC 793, September 1981.\n   [RFC1858]  Ziemba,\
    \ G., Reed, D., and P. Traina, \"Security\n              Considerations for IP\
    \ Fragment Filtering\", RFC 1858,\n              October 1995.\n   [RFC3022] \
    \ Srisuresh, P. and K. Egevang, \"Traditional IP Network\n              Address\
    \ Translator (Traditional NAT)\", RFC 3022,\n              January 2001.\n   [RFC3128]\
    \  Miller, I., \"Protection Against a Variant of the Tiny\n              Fragment\
    \ Attack (RFC 1858)\", RFC 3128, June 2001.\n   [RFC3948]  Huttunen, A., Swander,\
    \ B., Volpe, V., DiBurro, L., and M.\n              Stenberg, \"UDP Encapsulation\
    \ of IPsec ESP Packets\",\n              RFC 3948, January 2005.\n   [RFC4963]\
    \  Heffner, J., Mathis, M., and B. Chandler, \"IPv4 Reassembly\n             \
    \ Errors at High Data Rates\", RFC 4963, July 2007.\n   [RFC5245]  Rosenberg,\
    \ J., \"Interactive Connectivity Establishment\n              (ICE): A Protocol\
    \ for Network Address Translator (NAT)\n              Traversal for Offer/Answer\
    \ Protocols\", RFC 5245,\n              April 2010.\n   [RFC5389]  Rosenberg,\
    \ J., Mahy, R., Matthews, P., and D. Wing,\n              \"Session Traversal\
    \ Utilities for NAT (STUN)\", RFC 5389,\n              October 2008.\n   [RFC6144]\
    \  Baker, F., Li, X., Bao, C., and K. Yin, \"Framework for\n              IPv4/IPv6\
    \ Translation\", RFC 6144, April 2011.\n   [RFC6147]  Bagnulo, M., Sullivan, A.,\
    \ Matthews, P., and I. van\n              Beijnum, \"DNS64: DNS extensions for\
    \ Network Address\n              Translation from IPv6 Clients to IPv4 Servers\"\
    , RFC 6147,\n              April 2011.\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Marcelo Bagnulo\n   UC3M\n   Av. Universidad 30\n   Leganes,\
    \ Madrid  28911\n   Spain\n   Phone: +34-91-6249500\n   EMail: marcelo@it.uc3m.es\n\
    \   URI:   http://www.it.uc3m.es/marcelo\n   Philip Matthews\n   Alcatel-Lucent\n\
    \   600 March Road\n   Ottawa, Ontario\n   Canada\n   Phone: +1 613-592-4343 x224\n\
    \   EMail: philip_matthews@magma.ca\n   Iljitsch van Beijnum\n   IMDEA Networks\n\
    \   Avda. del Mar Mediterraneo, 22\n   Leganes, Madrid  28918\n   Spain\n   EMail:\
    \ iljitsch@muada.com\n"
