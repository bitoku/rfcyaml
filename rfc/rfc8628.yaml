- contents:
  - '                  OAuth 2.0 Device Authorization Grant

    '
  title: __initial_text__
- contents:
  - "Abstract\n   The OAuth 2.0 device authorization grant is designed for Internet-\n
    \  connected devices that either lack a browser to perform a user-agent-\n   based
    authorization or are input constrained to the extent that\n   requiring the user
    to input text in order to authenticate during the\n   authorization flow is impractical.
    \ It enables OAuth clients on such\n   devices (like smart TVs, media consoles,
    digital picture frames, and\n   printers) to obtain user authorization to access
    protected resources\n   by using a user agent on a separate device.\n"
  title: Abstract
- contents:
  - "Status of This Memo\n   This is an Internet Standards Track document.\n   This
    document is a product of the Internet Engineering Task Force\n   (IETF).  It represents
    the consensus of the IETF community.  It has\n   received public review and has
    been approved for publication by the\n   Internet Engineering Steering Group (IESG).
    \ Further information on\n   Internet Standards is available in Section 2 of RFC
    7841.\n   Information about the current status of this document, any errata,\n
    \  and how to provide feedback on it may be obtained at\n   https://www.rfc-editor.org/info/rfc8628.\n"
  title: Status of This Memo
- contents:
  - "Copyright Notice\n   Copyright (c) 2019 IETF Trust and the persons identified
    as the\n   document authors.  All rights reserved.\n   This document is subject
    to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n
    \  (https://trustee.ietf.org/license-info) in effect on the date of\n   publication
    of this document.  Please review these documents\n   carefully, as they describe
    your rights and restrictions with respect\n   to this document.  Code Components
    extracted from this document must\n   include Simplified BSD License text as described
    in Section 4.e of\n   the Trust Legal Provisions and are provided without warranty
    as\n   described in the Simplified BSD License.\n"
  title: Copyright Notice
- contents:
  - "Table of Contents\n   1.  Introduction  . . . . . . . . . . . . . . . . . . .
    . . . . .   3\n   2.  Terminology . . . . . . . . . . . . . . . . . . . . . .
    . . .   5\n   3.  Protocol  . . . . . . . . . . . . . . . . . . . . . . . . .
    .   5\n     3.1.  Device Authorization Request  . . . . . . . . . . . . . .   5\n
    \    3.2.  Device Authorization Response . . . . . . . . . . . . . .   7\n     3.3.
    \ User Interaction  . . . . . . . . . . . . . . . . . . . .   8\n       3.3.1.
    \ Non-Textual Verification URI Optimization . . . . . .   9\n     3.4.  Device
    Access Token Request . . . . . . . . . . . . . . .  10\n     3.5.  Device Access
    Token Response  . . . . . . . . . . . . . .  11\n   4.  Discovery Metadata  .
    . . . . . . . . . . . . . . . . . . . .  12\n   5.  Security Considerations .
    . . . . . . . . . . . . . . . . . .  12\n     5.1.  User Code Brute Forcing .
    . . . . . . . . . . . . . . . .  12\n     5.2.  Device Code Brute Forcing . .
    . . . . . . . . . . . . . .  13\n     5.3.  Device Trustworthiness  . . . . .
    . . . . . . . . . . . .  13\n     5.4.  Remote Phishing . . . . . . . . . . .
    . . . . . . . . . .  14\n     5.5.  Session Spying  . . . . . . . . . . . . .
    . . . . . . . .  15\n     5.6.  Non-Confidential Clients  . . . . . . . . . .
    . . . . . .  15\n     5.7.  Non-Visual Code Transmission  . . . . . . . . . .
    . . . .  15\n   6.  Usability Considerations  . . . . . . . . . . . . . . . .
    . .  16\n     6.1.  User Code Recommendations . . . . . . . . . . . . . . . .
    \ 16\n     6.2.  Non-Browser User Interaction  . . . . . . . . . . . . . .  17\n
    \  7.  IANA Considerations . . . . . . . . . . . . . . . . . . . . .  17\n     7.1.
    \ OAuth Parameter Registration  . . . . . . . . . . . . . .  17\n     7.2.  OAuth
    URI Registration  . . . . . . . . . . . . . . . . .  17\n     7.3.  OAuth Extensions
    Error Registration . . . . . . . . . . .  18\n     7.4.  OAuth Authorization Server
    Metadata . . . . . . . . . . .  18\n   8.  Normative References  . . . . . . .
    . . . . . . . . . . . . .  19\n   Acknowledgements  . . . . . . . . . . . . .
    . . . . . . . . . . .  20\n   Authors' Addresses  . . . . . . . . . . . . . .
    . . . . . . . . .  21\n"
  title: Table of Contents
- contents:
  - "1.  Introduction\n   This OAuth 2.0 [RFC6749] protocol extension enables OAuth
    clients to\n   request user authorization from applications on devices that have\n
    \  limited input capabilities or lack a suitable browser.  Such devices\n   include
    smart TVs, media consoles, picture frames, and printers,\n   which lack an easy
    input method or a suitable browser required for\n   traditional OAuth interactions.
    \ The authorization flow defined by\n   this specification, sometimes referred
    to as the \"device flow\",\n   instructs the user to review the authorization
    request on a secondary\n   device, such as a smartphone, which does have the requisite
    input and\n   browser capabilities to complete the user interaction.\n   The device
    authorization grant is not intended to replace browser-\n   based OAuth in native
    apps on capable devices like smartphones.\n   Those apps should follow the practices
    specified in \"OAuth 2.0 for\n   Native Apps\" [RFC8252].\n   The operating requirements
    for using this authorization grant type\n   are:\n   (1)  The device is already
    connected to the Internet.\n   (2)  The device is able to make outbound HTTPS
    requests.\n   (3)  The device is able to display or otherwise communicate a URI
    and\n        code sequence to the user.\n   (4)  The user has a secondary device
    (e.g., personal computer or\n        smartphone) from which they can process the
    request.\n   As the device authorization grant does not require two-way\n   communication
    between the OAuth client on the device and the user\n   agent (unlike other OAuth
    2 grant types, such as the authorization\n   code and implicit grant types), it
    supports several use cases that\n   cannot be served by those other approaches.\n
    \  Instead of interacting directly with the end user's user agent (i.e.,\n   browser),
    the device client instructs the end user to use another\n   computer or device
    and connect to the authorization server to approve\n   the access request.  Since
    the protocol supports clients that can't\n   receive incoming requests, clients
    poll the authorization server\n   repeatedly until the end user completes the
    approval process.\n   The device client typically chooses the set of authorization
    servers\n   to support (i.e., its own authorization server or those of providers\n
    \  with which it has relationships).  It is common for the device client\n   to
    support only one authorization server, such as in the case of a TV\n   application
    for a specific media provider that supports only that\n   media provider's authorization
    server.  The user may not yet have an\n   established relationship with that authorization
    provider, though one\n   can potentially be set up during the authorization flow.\n
    \     +----------+                                +----------------+\n      |
    \         |>---(A)-- Client Identifier --->|                |\n      |          |
    \                               |                |\n      |          |<---(B)--
    Device Code,      ---<|                |\n      |          |          User Code,
    \           |                |\n      |  Device  |          & Verification URI
    \   |                |\n      |  Client  |                                |                |\n
    \     |          |  [polling]                     |                |\n      |
    \         |>---(E)-- Device Code       --->|                |\n      |          |
    \         & Client Identifier   |                |\n      |          |                                |
    \ Authorization |\n      |          |<---(F)-- Access Token      ---<|     Server
    \    |\n      +----------+   (& Optional Refresh Token)   |                |\n
    \           v                                     |                |\n            :
    \                                    |                |\n           (C) User Code
    & Verification URI       |                |\n            :                                     |
    \               |\n            v                                     |                |\n
    \     +----------+                                |                |\n      |
    End User |                                |                |\n      |    at    |<---(D)--
    End user reviews  --->|                |\n      |  Browser |          authorization
    request |                |\n      +----------+                                +----------------+\n
    \                   Figure 1: Device Authorization Flow\n   The device authorization
    flow illustrated in Figure 1 includes the\n   following steps:\n   (A)  The client
    requests access from the authorization server and\n        includes its client
    identifier in the request.\n   (B)  The authorization server issues a device code
    and an end-user\n        code and provides the end-user verification URI.\n   (C)
    \ The client instructs the end user to use a user agent on another\n        device
    and visit the provided end-user verification URI.  The\n        client provides
    the user with the end-user code to enter in\n        order to review the authorization
    request.\n   (D)  The authorization server authenticates the end user (via the\n
    \       user agent), and prompts the user to input the user code\n        provided
    by the device client.  The authorization server\n        validates the user code
    provided by the user, and prompts the\n        user to accept or decline the request.\n
    \  (E)  While the end user reviews the client's request (step D), the\n        client
    repeatedly polls the authorization server to find out if\n        the user completed
    the user authorization step.  The client\n        includes the device code and
    its client identifier.\n   (F)  The authorization server validates the device
    code provided by\n        the client and responds with the access token if the
    client is\n        granted access, an error if they are denied access, or an\n
    \       indication that the client should continue to poll.\n"
  title: 1.  Introduction
- contents:
  - "2.  Terminology\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\",
    \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"NOT RECOMMENDED\",
    \"MAY\", and\n   \"OPTIONAL\" in this document are to be interpreted as described
    in\n   BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all\n   capitals,
    as shown here.\n"
  title: 2.  Terminology
- contents:
  - '3.  Protocol

    '
  - contents:
    - "3.1.  Device Authorization Request\n   This specification defines a new OAuth
      endpoint: the device\n   authorization endpoint.  This is separate from the
      OAuth\n   authorization endpoint defined in [RFC6749] with which the user\n
      \  interacts via a user agent (i.e., a browser).  By comparison, when\n   using
      the device authorization endpoint, the OAuth client on the\n   device interacts
      with the authorization server directly without\n   presenting the request in
      a user agent, and the end user authorizes\n   the request on a separate device.
      \ This interaction is defined as\n   follows.\n   The client initiates the authorization
      flow by requesting a set of\n   verification codes from the authorization server
      by making an HTTP\n   \"POST\" request to the device authorization endpoint.\n
      \  The client makes a device authorization request to the device\n   authorization
      endpoint by including the following parameters using\n   the \"application/x-www-form-urlencoded\"
      format, per Appendix B of\n   [RFC6749], with a character encoding of UTF-8
      in the HTTP request\n   entity-body:\n   client_id\n      REQUIRED if the client
      is not authenticating with the\n      authorization server as described in Section
      3.2.1. of [RFC6749].\n      The client identifier as described in Section 2.2
      of [RFC6749].\n   scope\n      OPTIONAL.  The scope of the access request as
      defined by\n      Section 3.3 of [RFC6749].\n   For example, the client makes
      the following HTTPS request:\n      POST /device_authorization HTTP/1.1\n      Host:
      server.example.com\n      Content-Type: application/x-www-form-urlencoded\n
      \     client_id=1406020730&scope=example_scope\n   All requests from the device
      MUST use the Transport Layer Security\n   (TLS) protocol [RFC8446] and implement
      the best practices of BCP 195\n   [RFC7525].\n   Parameters sent without a value
      MUST be treated as if they were\n   omitted from the request.  The authorization
      server MUST ignore\n   unrecognized request parameters.  Request and response
      parameters\n   MUST NOT be included more than once.\n   The client authentication
      requirements of Section 3.2.1 of [RFC6749]\n   apply to requests on this endpoint,
      which means that confidential\n   clients (those that have established client
      credentials) authenticate\n   in the same manner as when making requests to
      the token endpoint, and\n   public clients provide the \"client_id\" parameter
      to identify\n   themselves.\n   Due to the polling nature of this protocol (as
      specified in\n   Section 3.4), care is needed to avoid overloading the capacity
      of the\n   token endpoint.  To avoid unneeded requests on the token endpoint,\n
      \  the client SHOULD only commence a device authorization request when\n   prompted
      by the user and not automatically, such as when the app\n   starts or when the
      previous authorization session expires or fails.\n"
    title: 3.1.  Device Authorization Request
  - contents:
    - "3.2.  Device Authorization Response\n   In response, the authorization server
      generates a unique device\n   verification code and an end-user code that are
      valid for a limited\n   time and includes them in the HTTP response body using
      the\n   \"application/json\" format [RFC8259] with a 200 (OK) status code.  The\n
      \  response contains the following parameters:\n   device_code\n      REQUIRED.
      \ The device verification code.\n   user_code\n      REQUIRED.  The end-user
      verification code.\n   verification_uri\n      REQUIRED.  The end-user verification
      URI on the authorization\n      server.  The URI should be short and easy to
      remember as end users\n      will be asked to manually type it into their user
      agent.\n   verification_uri_complete\n      OPTIONAL.  A verification URI that
      includes the \"user_code\" (or\n      other information with the same function
      as the \"user_code\"),\n      which is designed for non-textual transmission.\n
      \  expires_in\n      REQUIRED.  The lifetime in seconds of the \"device_code\"
      and\n      \"user_code\".\n   interval\n      OPTIONAL.  The minimum amount
      of time in seconds that the client\n      SHOULD wait between polling requests
      to the token endpoint.  If no\n      value is provided, clients MUST use 5 as
      the default.\n   For example:\n      HTTP/1.1 200 OK\n      Content-Type: application/json\n
      \     Cache-Control: no-store\n      {\n        \"device_code\": \"GmRhmhcxhwAzkoEqiMEg_DnyEysNkuNhszIySk9eS\",\n
      \       \"user_code\": \"WDJB-MJHT\",\n        \"verification_uri\": \"https://example.com/device\",\n
      \       \"verification_uri_complete\":\n            \"https://example.com/device?user_code=WDJB-MJHT\",\n
      \       \"expires_in\": 1800,\n        \"interval\": 5\n      }\n   In the event
      of an error (such as an invalidly configured client),\n   the authorization
      server responds in the same way as the token\n   endpoint specified in Section
      5.2 of [RFC6749].\n"
    title: 3.2.  Device Authorization Response
  - contents:
    - "3.3.  User Interaction\n   After receiving a successful authorization response,
      the client\n   displays or otherwise communicates the \"user_code\" and the\n
      \  \"verification_uri\" to the end user and instructs them to visit the\n   URI
      in a user agent on a secondary device (for example, in a browser\n   on their
      mobile phone) and enter the user code.\n            +-----------------------------------------------+\n
      \           |                                               |\n            |
      \ Using a browser on another device, visit:    |\n            |  https://example.com/device
      \                  |\n            |                                               |\n
      \           |  And enter the code:                          |\n            |
      \ WDJB-MJHT                                    |\n            |                                               |\n
      \           +-----------------------------------------------+\n                    Figure
      2: Example User Instruction\n   The authorizing user navigates to the \"verification_uri\"
      and\n   authenticates with the authorization server in a secure TLS-protected\n
      \  [RFC8446] session.  The authorization server prompts the end user to\n   identify
      the device authorization session by entering the \"user_code\"\n   provided
      by the client.  The authorization server should then inform\n   the user about
      the action they are undertaking and ask them to\n   approve or deny the request.
      \ Once the user interaction is complete,\n   the server instructs the user to
      return to their device.\n   During the user interaction, the device continuously
      polls the token\n   endpoint with the \"device_code\", as detailed in Section
      3.4, until\n   the user completes the interaction, the code expires, or another\n
      \  error occurs.  The \"device_code\" is not intended for the end user\n   directly;
      thus, it should not be displayed during the interaction to\n   avoid confusing
      the end user.\n   Authorization servers supporting this specification MUST implement
      a\n   user-interaction sequence that starts with the user navigating to\n   \"verification_uri\"
      and continues with them supplying the \"user_code\"\n   at some stage during
      the interaction.  Other than that, the exact\n   sequence and implementation
      of the user interaction is up to the\n   authorization server; for example,
      the authorization server may\n   enable new users to sign up for an account
      during the authorization\n   flow or add additional security verification steps.\n
      \  It is NOT RECOMMENDED for authorization servers to include the user\n   code
      (\"user_code\") in the verification URI (\"verification_uri\"), as\n   this
      increases the length and complexity of the URI that the user\n   must type.
      \ While the user must still type a similar number of\n   characters with the
      \"user_code\" separated, once they successfully\n   navigate to the \"verification_uri\",
      any errors in entering the code\n   can be highlighted by the authorization
      server to improve the user\n   experience.  The next section documents the user
      interaction with\n   \"verification_uri_complete\", which is designed to carry
      both pieces\n   of information.\n"
    - contents:
      - "3.3.1.  Non-Textual Verification URI Optimization\n   When \"verification_uri_complete\"
        is included in the authorization\n   response (Section 3.2), clients MAY present
        this URI in a non-textual\n   manner using any method that results in the
        browser being opened with\n   the URI, such as with QR (Quick Response) codes
        or NFC (Near Field\n   Communication), to save the user from typing the URI.\n
        \  For usability reasons, it is RECOMMENDED for clients to still display\n
        \  the textual verification URI (\"verification_uri\") for users who are\n
        \  not able to use such a shortcut.  Clients MUST still display the\n   \"user_code\",
        as the authorization server will require the user to\n   confirm it to disambiguate
        devices or as remote phishing mitigation\n   (see Section 5.4).\n   If the
        user starts the user interaction by navigating to\n   \"verification_uri_complete\",
        then the user interaction described in\n   Section 3.3 is still followed,
        with the optimization that the user\n   does not need to type in the \"user_code\".
        \ The server SHOULD display\n   the \"user_code\" to the user and ask them
        to verify that it matches\n   the \"user_code\" being displayed on the device
        to confirm they are\n   authorizing the correct device.  As before, in addition
        to taking\n   steps to confirm the identity of the device, the user should
        also be\n   afforded the choice to approve or deny the authorization request.\n
        \           +-------------------------------------------------+\n            |
        \                                                |\n            |  Scan the
        QR code or, using     +------------+  |\n            |  a browser on another
        device,   |[_]..  . [_]|  |\n            |  visit:                         |
        .  ..   . .|  |\n            |  https://example.com/device     | . .  . ....|
        \ |\n            |                                 |.   . . .   |  |\n            |
        \ And enter the code:            |[_]. ... .  |  |\n            |  WDJB-MJHT
        \                     +------------+  |\n            |                                                 |\n
        \           +-------------------------------------------------+\n      Figure
        3: Example User Instruction with QR Code Representation\n                     of
        the Complete Verification URI\n"
      title: 3.3.1.  Non-Textual Verification URI Optimization
    title: 3.3.  User Interaction
  - contents:
    - "3.4.  Device Access Token Request\n   After displaying instructions to the
      user, the client creates an\n   access token request and sends it to the token
      endpoint (as defined\n   by Section 3.2 of [RFC6749]) with a \"grant_type\"
      of\n   \"urn:ietf:params:oauth:grant-type:device_code\".  This is an extension\n
      \  grant type (as defined by Section 4.5 of [RFC6749]) created by this\n   specification,
      with the following parameters:\n   grant_type\n      REQUIRED.  Value MUST be
      set to\n      \"urn:ietf:params:oauth:grant-type:device_code\".\n   device_code\n
      \     REQUIRED.  The device verification code, \"device_code\" from the\n      device
      authorization response, defined in Section 3.2.\n   client_id\n      REQUIRED
      if the client is not authenticating with the\n      authorization server as
      described in Section 3.2.1. of [RFC6749].\n      The client identifier as described
      in Section 2.2 of [RFC6749].\n   For example, the client makes the following
      HTTPS request (line\n   breaks are for display purposes only):\n      POST /token
      HTTP/1.1\n      Host: server.example.com\n      Content-Type: application/x-www-form-urlencoded\n
      \     grant_type=urn%3Aietf%3Aparams%3Aoauth%3Agrant-type%3Adevice_code\n      &device_code=GmRhmhcxhwAzkoEqiMEg_DnyEysNkuNhszIySk9eS\n
      \     &client_id=1406020730\n   If the client was issued client credentials
      (or assigned other\n   authentication requirements), the client MUST authenticate
      with the\n   authorization server as described in Section 3.2.1 of [RFC6749].\n
      \  Note that there are security implications of statically distributed\n   client
      credentials; see Section 5.6.\n   The response to this request is defined in
      Section 3.5.  Unlike other\n   OAuth grant types, it is expected for the client
      to try the access\n   token request repeatedly in a polling fashion based on
      the error code\n   in the response.\n"
    title: 3.4.  Device Access Token Request
  - contents:
    - "3.5.  Device Access Token Response\n   If the user has approved the grant,
      the token endpoint responds with\n   a success response defined in Section 5.1
      of [RFC6749]; otherwise, it\n   responds with an error, as defined in Section
      5.2 of [RFC6749].\n   In addition to the error codes defined in Section 5.2
      of [RFC6749],\n   the following error codes are specified for use with the device\n
      \  authorization grant in token endpoint responses:\n   authorization_pending\n
      \     The authorization request is still pending as the end user hasn't\n      yet
      completed the user-interaction steps (Section 3.3).  The\n      client SHOULD
      repeat the access token request to the token\n      endpoint (a process known
      as polling).  Before each new request,\n      the client MUST wait at least
      the number of seconds specified by\n      the \"interval\" parameter of the
      device authorization response (see\n      Section 3.2), or 5 seconds if none
      was provided, and respect any\n      increase in the polling interval required
      by the \"slow_down\"\n      error.\n   slow_down\n      A variant of \"authorization_pending\",
      the authorization request is\n      still pending and polling should continue,
      but the interval MUST\n      be increased by 5 seconds for this and all subsequent
      requests.\n   access_denied\n      The authorization request was denied.\n   expired_token\n
      \     The \"device_code\" has expired, and the device authorization\n      session
      has concluded.  The client MAY commence a new device\n      authorization request
      but SHOULD wait for user interaction before\n      restarting to avoid unnecessary
      polling.\n   The \"authorization_pending\" and \"slow_down\" error codes define\n
      \  particularly unique behavior, as they indicate that the OAuth client\n   should
      continue to poll the token endpoint by repeating the token\n   request (implementing
      the precise behavior defined above).  If the\n   client receives an error response
      with any other error code, it MUST\n   stop polling and SHOULD react accordingly,
      for example, by displaying\n   an error to the user.\n   On encountering a connection
      timeout, clients MUST unilaterally\n   reduce their polling frequency before
      retrying.  The use of an\n   exponential backoff algorithm to achieve this,
      such as doubling the\n   polling interval on each such connection timeout, is
      RECOMMENDED.\n   The assumption of this specification is that the separate device
      on\n   which the user is authorizing the request does not have a way to\n   communicate
      back to the device with the OAuth client.  This protocol\n   only requires a
      one-way channel in order to maximize the viability of\n   the protocol in restricted
      environments, like an application running\n   on a TV that is only capable of
      outbound requests.  If a return\n   channel were to exist for the chosen user-interaction
      interface, then\n   the device MAY wait until notified on that channel that
      the user has\n   completed the action before initiating the token request (as
      an\n   alternative to polling).  Such behavior is, however, outside the\n   scope
      of this specification.\n"
    title: 3.5.  Device Access Token Response
  title: 3.  Protocol
- contents:
  - "4.  Discovery Metadata\n   Support for this protocol is declared in OAuth 2.0
    Authorization\n   Server Metadata [RFC8414] as follows.  The value\n   \"urn:ietf:params:oauth:grant-type:device_code\"
    is included in values\n   of the \"grant_types_supported\" key, and the following
    new key value\n   pair is added:\n   device_authorization_endpoint\n      OPTIONAL.
    \ URL of the authorization server's device authorization\n      endpoint, as defined
    in Section 3.1.\n"
  title: 4.  Discovery Metadata
- contents:
  - '5.  Security Considerations

    '
  - contents:
    - "5.1.  User Code Brute Forcing\n   Since the user code is typed by the user,
      shorter codes are more\n   desirable for usability reasons.  This means the
      entropy is typically\n   less than would be used for the device code or other
      OAuth bearer\n   token types where the code length does not impact usability.\n
      \  Therefore, it is recommended that the server rate-limit user code\n   attempts.\n
      \  The user code SHOULD have enough entropy that, when combined with\n   rate-limiting
      and other mitigations, a brute-force attack becomes\n   infeasible.  For example,
      it's generally held that 128-bit symmetric\n   keys for encryption are seen
      as good enough today because an attacker\n   has to put in 2^96 work to have
      a 2^-32 chance of guessing correctly\n   via brute force.  The rate-limiting
      and finite lifetime on the user\n   code place an artificial limit on the amount
      of work an attacker can\n   \"do\".  If, for instance, one uses an 8-character
      base 20 user code\n   (with roughly 34.5 bits of entropy), the rate-limiting
      interval and\n   validity period would need to only allow 5 attempts in order
      to get\n   the same 2^-32 probability of success by random guessing.\n   A successful
      brute forcing of the user code would enable the attacker\n   to approve the
      authorization grant with their own credentials, after\n   which the device would
      receive a device authorization grant linked to\n   the attacker's account.  This
      is the opposite scenario to an OAuth\n   bearer token being brute forced, whereby
      the attacker gains control\n   of the victim's authorization grant.  Such attacks
      may not always\n   make economic sense.  For example, for a video app, the device
      owner\n   may then be able to purchase movies using the attacker's account\n
      \  (though even in this case a privacy risk would still remain and thus\n   is
      important to protect against).  Furthermore, some uses of the\n   device flow
      give the granting account the ability to perform actions\n   that need to be
      protected, such as controlling the device.\n   The precise length of the user
      code and the entropy contained within\n   is at the discretion of the authorization
      server, which needs to\n   consider the sensitivity of their specific protected
      resources, the\n   practicality of the code length from a usability standpoint,
      and any\n   mitigations that are in place, such as rate-limiting, when\n   determining
      the user code format.\n"
    title: 5.1.  User Code Brute Forcing
  - contents:
    - "5.2.  Device Code Brute Forcing\n   An attacker who guesses the device code
      would be able to potentially\n   obtain the authorization code once the user
      completes the flow.  As\n   the device code is not displayed to the user and
      thus there are no\n   usability considerations on the length, a very high entropy
      code\n   SHOULD be used.\n"
    title: 5.2.  Device Code Brute Forcing
  - contents:
    - "5.3.  Device Trustworthiness\n   Unlike other native application OAuth 2.0
      flows, the device\n   requesting the authorization is not the same as the device
      from which\n   the user grants access.  Thus, signals from the approving user's\n
      \  session and device are not always relevant to the trustworthiness of\n   the
      client device.\n   Note that if an authorization server used with this flow
      is\n   malicious, then it could perform a man-in-the-middle attack on the\n
      \  backchannel flow to another authorization server.  In this scenario,\n   the
      man-in-the-middle is not completely hidden from sight, as the end\n   user would
      end up on the authorization page of the wrong service,\n   giving them an opportunity
      to notice that the URL in the browser's\n   address bar is wrong.  For this
      to be possible, the device\n   manufacturer must either be the attacker and
      shipping a device\n   intended to perform the man-in-the-middle attack, or be
      using an\n   authorization server that is controlled by an attacker, possibly\n
      \  because the attacker compromised the authorization server used by the\n   device.
      \ In part, the person purchasing the device is counting on the\n   manufacturer
      and its business partners to be trustworthy.\n"
    title: 5.3.  Device Trustworthiness
  - contents:
    - "5.4.  Remote Phishing\n   It is possible for the device flow to be initiated
      on a device in an\n   attacker's possession.  For example, an attacker might
      send an email\n   instructing the target user to visit the verification URL
      and enter\n   the user code.  To mitigate such an attack, it is RECOMMENDED
      to\n   inform the user that they are authorizing a device during the user-\n
      \  interaction step (see Section 3.3) and to confirm that the device is\n   in
      their possession.  The authorization server SHOULD display\n   information about
      the device so that the user could notice if a\n   software client was attempting
      to impersonate a hardware device.\n   For authorization servers that support
      the\n   \"verification_uri_complete\" optimization discussed in Section 3.3.1,\n
      \  it is particularly important to confirm that the device is in the\n   user's
      possession, as the user no longer has to type in the code\n   being displayed
      on the device manually.  One suggestion is to display\n   the code during the
      authorization flow and ask the user to verify\n   that the same code is currently
      being displayed on the device they\n   are setting up.\n   The user code needs
      to have a long enough lifetime to be useable\n   (allowing the user to retrieve
      their secondary device, navigate to\n   the verification URI, log in, etc.)
      but should be sufficiently short\n   to limit the usability of a code obtained
      for phishing.  This doesn't\n   prevent a phisher from presenting a fresh token,
      particularly if they\n   are interacting with the user in real time, but it
      does limit the\n   viability of codes sent over email or text message.\n"
    title: 5.4.  Remote Phishing
  - contents:
    - "5.5.  Session Spying\n   While the device is pending authorization, it may
      be possible for a\n   malicious user to physically spy on the device user interface
      (by\n   viewing the screen on which it's displayed, for example) and hijack\n
      \  the session by completing the authorization faster than the user that\n   initiated
      it.  Devices SHOULD take into account the operating\n   environment when considering
      how to communicate the code to the user\n   to reduce the chances it will be
      observed by a malicious user.\n"
    title: 5.5.  Session Spying
  - contents:
    - "5.6.  Non-Confidential Clients\n   Device clients are generally incapable of
      maintaining the\n   confidentiality of their credentials, as users in possession
      of the\n   device can reverse-engineer it and extract the credentials.\n   Therefore,
      unless additional measures are taken, they should be\n   treated as public clients
      (as defined by Section 2.1 of [RFC6749]),\n   which are susceptible to impersonation.
      \ The security considerations\n   of Section 5.3.1 of [RFC6819] and Sections
      8.5 and 8.6 of [RFC8252]\n   apply to such clients.\n   The user may also be
      able to obtain the \"device_code\" and/or other\n   OAuth bearer tokens issued
      to their client, which would allow them to\n   use their own authorization grant
      directly by impersonating the\n   client.  Given that the user in possession
      of the client credentials\n   can already impersonate the client and create
      a new authorization\n   grant (with a new \"device_code\"), this doesn't represent
      a separate\n   impersonation vector.\n"
    title: 5.6.  Non-Confidential Clients
  - contents:
    - "5.7.  Non-Visual Code Transmission\n   There is no requirement that the user
      code be displayed by the device\n   visually.  Other methods of one-way communication
      can potentially be\n   used, such as text-to-speech audio or Bluetooth Low Energy.
      \ To\n   mitigate an attack in which a malicious user can bootstrap their\n
      \  credentials on a device not in their control, it is RECOMMENDED that\n   any
      chosen communication channel only be accessible by people in\n   close proximity,
      for example, users who can see or hear the device.\n"
    title: 5.7.  Non-Visual Code Transmission
  title: 5.  Security Considerations
- contents:
  - "6.  Usability Considerations\n   This section is a non-normative discussion of
    usability\n   considerations.\n"
  - contents:
    - "6.1.  User Code Recommendations\n   For many users, their nearest Internet-connected
      device will be their\n   mobile phone; typically, these devices offer input
      methods that are\n   more time-consuming than a computer keyboard to change
      the case or\n   input numbers.  To improve usability (improving entry speed
      and\n   reducing retries), the limitations of such devices should be taken\n
      \  into account when selecting the user code character set.\n   One way to improve
      input speed is to restrict the character set to\n   case-insensitive A-Z characters,
      with no digits.  These characters\n   can typically be entered on a mobile keyboard
      without using modifier\n   keys.  Further removing vowels to avoid randomly
      creating words\n   results in the base 20 character set \"BCDFGHJKLMNPQRSTVWXZ\".
      \ Dashes\n   or other punctuation may be included for readability.\n   An example
      user code following this guideline, \"WDJB-MJHT\", contains\n   8 significant
      characters and has dashes added for end-user\n   readability.  The resulting
      entropy is 20^8.\n   Pure numeric codes are also a good choice for usability,
      especially\n   for clients targeting locales where A-Z character keyboards are
      not\n   used, though the length of such a code needs to be longer to maintain\n
      \  high entropy.\n   An example numeric user code that contains 9 significant
      digits and\n   dashes added for end-user readability with an entropy of 10^9
      is\n   \"019-450-730\".\n   When processing the inputted user code, the server
      should strip\n   dashes and other punctuation that it added for readability
      (making\n   the inclusion of such punctuation by the user optional).  For codes\n
      \  using only characters in the A-Z range, as with the base 20 charset\n   defined
      above, the user's input should be uppercased before a\n   comparison to account
      for the fact that the user may input the\n   equivalent lowercase characters.
      \ Further stripping of all characters\n   outside the chosen character set is
      recommended to reduce instances\n   where an errantly typed character (like
      a space character)\n   invalidates otherwise valid input.\n   It is RECOMMENDED
      to avoid character sets that contain two or more\n   characters that can easily
      be confused with each other, like \"0\" and\n   \"O\" or \"1\", \"l\" and \"I\".
      \ Furthermore, to the extent practical, when\n   a character set contains a
      character that may be confused with\n   characters outside the character set,
      a character outside the set MAY\n   be substituted with the one in the character
      set with which it is\n   commonly confused; for example, \"O\" may be substituted
      for \"0\" when\n   using the numerical 0-9 character set.\n"
    title: 6.1.  User Code Recommendations
  - contents:
    - "6.2.  Non-Browser User Interaction\n   Devices and authorization servers MAY
      negotiate an alternative code\n   transmission and user-interaction method in
      addition to the one\n   described in Section 3.3.  Such an alternative user-interaction
      flow\n   could obviate the need for a browser and manual input of the code,\n
      \  for example, by using Bluetooth to transmit the code to the\n   authorization
      server's companion app.  Such interaction methods can\n   utilize this protocol
      as, ultimately, the user just needs to identify\n   the authorization session
      to the authorization server; however, user\n   interaction other than through
      the verification URI is outside the\n   scope of this specification.\n"
    title: 6.2.  Non-Browser User Interaction
  title: 6.  Usability Considerations
- contents:
  - '7.  IANA Considerations

    '
  - contents:
    - "7.1.  OAuth Parameter Registration\n   This specification registers the following
      values in the IANA \"OAuth\n   Parameters\" registry [IANA.OAuth.Parameters]
      established by\n   [RFC6749].\n      Name: device_code\n      Parameter Usage
      Location: token request\n      Change Controller: IESG\n      Reference: Section
      3.4 of RFC 8628\n"
    title: 7.1.  OAuth Parameter Registration
  - contents:
    - "7.2.  OAuth URI Registration\n   This specification registers the following
      values in the IANA \"OAuth\n   URI\" registry [IANA.OAuth.Parameters] established
      by [RFC6755].\n      URN: urn:ietf:params:oauth:grant-type:device_code\n      Common
      Name: Device Authorization Grant Type for OAuth 2.0\n      Change Controller:
      IESG\n      Specification Document: Section 3.4 of RFC 8628\n"
    title: 7.2.  OAuth URI Registration
  - contents:
    - "7.3.  OAuth Extensions Error Registration\n   This specification registers
      the following values in the IANA \"OAuth\n   Extensions Error Registry\" registry
      [IANA.OAuth.Parameters]\n   established by [RFC6749].\n      Name: authorization_pending\n
      \     Usage Location: Token endpoint response\n      Protocol Extension: RFC
      8628\n      Change Controller: IETF\n      Reference: Section 3.5 of RFC 8628\n
      \     Name: access_denied\n      Usage Location: Token endpoint response\n      Protocol
      Extension: RFC 8628\n      Change Controller: IETF\n      Reference: Section
      3.5 of RFC 8628\n      Name: slow_down\n      Usage Location: Token endpoint
      response\n      Protocol Extension: RFC 8628\n      Change Controller: IETF\n
      \     Reference: Section 3.5 of RFC 8628\n      Name: expired_token\n      Usage
      Location: Token endpoint response\n      Protocol Extension: RFC 8628\n      Change
      Controller: IETF\n      Reference: Section 3.5 of RFC 8628\n"
    title: 7.3.  OAuth Extensions Error Registration
  - contents:
    - "7.4.  OAuth Authorization Server Metadata\n   This specification registers
      the following values in the IANA \"OAuth\n   Authorization Server Metadata\"
      registry [IANA.OAuth.Parameters]\n   established by [RFC8414].\n      Metadata
      name: device_authorization_endpoint\n      Metadata Description: URL of the
      authorization server's device\n      authorization endpoint\n      Change Controller:
      IESG\n      Reference: Section 4 of RFC 8628\n"
    title: 7.4.  OAuth Authorization Server Metadata
  title: 7.  IANA Considerations
- contents:
  - "8.  Normative References\n   [IANA.OAuth.Parameters]\n              IANA, \"OAuth
    Parameters\",\n              <http://www.iana.org/assignments/oauth-parameters>.\n
    \  [RFC2119]  Bradner, S., \"Key words for use in RFCs to Indicate\n              Requirement
    Levels\", BCP 14, RFC 2119,\n              DOI 10.17487/RFC2119, March 1997,\n
    \             <https://www.rfc-editor.org/info/rfc2119>.\n   [RFC6749]  Hardt,
    D., Ed., \"The OAuth 2.0 Authorization Framework\",\n              RFC 6749, DOI
    10.17487/RFC6749, October 2012,\n              <https://www.rfc-editor.org/info/rfc6749>.\n
    \  [RFC6755]  Campbell, B. and H. Tschofenig, \"An IETF URN Sub-Namespace\n              for
    OAuth\", RFC 6755, DOI 10.17487/RFC6755, October 2012,\n              <https://www.rfc-editor.org/info/rfc6755>.\n
    \  [RFC6819]  Lodderstedt, T., Ed., McGloin, M., and P. Hunt, \"OAuth 2.0\n              Threat
    Model and Security Considerations\", RFC 6819,\n              DOI 10.17487/RFC6819,
    January 2013,\n              <https://www.rfc-editor.org/info/rfc6819>.\n   [RFC7525]
    \ Sheffer, Y., Holz, R., and P. Saint-Andre,\n              \"Recommendations
    for Secure Use of Transport Layer\n              Security (TLS) and Datagram Transport
    Layer Security\n              (DTLS)\", BCP 195, RFC 7525, DOI 10.17487/RFC7525,
    May\n              2015, <https://www.rfc-editor.org/info/rfc7525>.\n   [RFC8174]
    \ Leiba, B., \"Ambiguity of Uppercase vs Lowercase in RFC\n              2119
    Key Words\", BCP 14, RFC 8174, DOI 10.17487/RFC8174,\n              May 2017,
    <https://www.rfc-editor.org/info/rfc8174>.\n   [RFC8252]  Denniss, W. and J. Bradley,
    \"OAuth 2.0 for Native Apps\",\n              BCP 212, RFC 8252, DOI 10.17487/RFC8252,
    October 2017,\n              <https://www.rfc-editor.org/info/rfc8252>.\n   [RFC8259]
    \ Bray, T., Ed., \"The JavaScript Object Notation (JSON) Data\n              Interchange
    Format\", STD 90, RFC 8259,\n              DOI 10.17487/RFC8259, December 2017,\n
    \             <https://www.rfc-editor.org/info/rfc8259>.\n   [RFC8414]  Jones,
    M., Sakimura, N., and J. Bradley, \"OAuth 2.0\n              Authorization Server
    Metadata\", RFC 8414,\n              DOI 10.17487/RFC8414, June 2018,\n              <https://www.rfc-editor.org/info/rfc8414>.\n
    \  [RFC8446]  Rescorla, E., \"The Transport Layer Security (TLS) Protocol\n              Version
    1.3\", RFC 8446, DOI 10.17487/RFC8446, August 2018,\n              <https://www.rfc-editor.org/info/rfc8446>.\n"
  title: 8.  Normative References
- contents:
  - "Acknowledgements\n   The starting point for this document was the Internet-Draft\n
    \  draft-recordon-oauth-v2-device, authored by David Recordon and Brent\n   Goldman,
    which itself was based on content in draft versions of the\n   OAuth 2.0 protocol
    specification removed prior to publication due to\n   a then-lack of sufficient
    deployment expertise.  Thank you to the\n   OAuth Working Group members who contributed
    to those earlier drafts.\n   This document was produced in the OAuth Working Group
    under the\n   chairpersonship of Rifaat Shekh-Yusef and Hannes Tschofenig, with\n
    \  Benjamin Kaduk, Kathleen Moriarty, and Eric Rescorla serving as\n   Security
    Area Directors.\n   The following individuals contributed ideas, feedback, and
    wording\n   that shaped and formed the final specification:\n   Ben Campbell,
    Brian Campbell, Roshni Chandrashekhar, Alissa Cooper,\n   Eric Fazendin, Benjamin
    Kaduk, Jamshid Khosravian, Mirja Kuehlewind,\n   Torsten Lodderstedt, James Manger,
    Dan McNulty, Breno de Medeiros,\n   Alexey Melnikov, Simon Moffatt, Stein Myrseth,
    Emond Papegaaij,\n   Justin Richer, Adam Roach, Nat Sakimura, Andrew Sciberras,
    Marius\n   Scurtescu, Filip Skokan, Robert Sparks, Ken Wang, Christopher Wood,\n
    \  Steven E. Wright, and Qin Wu.\n"
  title: Acknowledgements
- contents:
  - "Authors' Addresses\n   William Denniss\n   Google\n   1600 Amphitheatre Pkwy\n
    \  Mountain View, CA  94043\n   United States of America\n   Email: wdenniss@google.com\n
    \  URI:   https://wdenniss.com/deviceflow\n   John Bradley\n   Ping Identity\n
    \  Email: ve7jtb@ve7jtb.com\n   URI:   http://www.thread-safe.com/\n   Michael
    B. Jones\n   Microsoft\n   Email: mbj@microsoft.com\n   URI:   http://self-issued.info/\n
    \  Hannes Tschofenig\n   ARM Limited\n   Austria\n   Email: Hannes.Tschofenig@gmx.net\n
    \  URI:   http://www.tschofenig.priv.at\n"
  title: Authors' Addresses
