- title: __initial_text__
  contents:
  - '             RELIABLE ASYNCHRONOUS TRANSFER PROTOCOL (RATP)

    '
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This RFC suggests a proposed protocol for the ARPA-Internet\n\
    \   community, and requests discussion and suggestions for improvements.\n   Distribution\
    \ of this memo is unlimited.\n   This paper proposes and specifies a protocol\
    \ which allows two\n   programs to reliably communicate over a communication link.\
    \  It\n   ensures that the data entering one end of the link if received\n   arrives\
    \ at the other end intact and unaltered.  The protocol, named\n   RATP, is designed\
    \ to operate over a full duplex point-to-point\n   connection.  It contains some\
    \ features which tailor it to the RS-232\n   links now in common use.\n"
- title: Introduction
  contents:
  - "Introduction\n   We are witnessing today an explosive growth in the small or\
    \ personal\n   computer market.  Such inexpensive computers are not normally\n\
    \   connected to a computer network.  They are most likely stand-alone\n   devices.\
    \  But virtually all of them have an RS-232 interface.  They\n   also usually\
    \ have a modem.  This allows them to communicate over the\n   telephone with any\
    \ other similarly equipped computer.\n   The telephone system is a pervasive network,\
    \ but one of the\n   characteristics of the telephone system is the unpredictable\
    \ quality\n   of the circuit.  The standard telephone circuit is designed for\
    \ voice\n   communication and not data communication.  Voice communication\n \
    \  tolerates a much higher degree of 'noise' than does a data circuit,\n   so\
    \ a voice circuit is tolerant of a much higher level of noise than\n   is a data\
    \ circuit.  Thus it is not uncommon for a byte of data\n   transferred over a\
    \ telephone circuit to have noise inserted.  For the\n   same reason it is also\
    \ not uncommon to have spurious data bytes added\n   to the data stream.\n   The\
    \ need for a method of reliably transferring data over an RS-232\n   point-to-point\
    \ link has become severe.  As the number of powerful\n   personal computers grows,\
    \ the need for them to communicate with one\n   another grows as well.  The new\
    \ markets and new services that these\n   computers will eventually allow their\
    \ users to access will rely\n   heavily upon the telephone system.  Services like\
    \ electronic mail,\n   electronic banking, ordering merchandise from home with\
    \ a personal\n   computer, etc.  As the information revolution proceeds data itself\n\
    \   will become a commodity.  All require accuracy of the data sent or\n   received.\n"
- title: RFC 916                                                     October 1984
  contents:
  - 'RFC 916                                                     October 1984

    '
- title: Reliable Asynchronous Transfer Protocol
  contents:
  - 'Reliable Asynchronous Transfer Protocol

    '
- title: 1. Philosopy of Design
  contents:
  - "1. Philosopy of Design\n   Many tradeoffs were made in designing this protocol.\
    \  Decisions were\n   made by above all ensuring reliability and then by favoring\n\
    \   simplicity of implementation.  It is hoped that this protocol is\n   simple\
    \ enough to be implemented not only by small computers but also\n   by stand alone\
    \ devices incorporating microcomputers which accept\n   commands over RS-232 lines.\
    \  Sophisticated but unnecessary features\n   such as dynamic window management\
    \ [TCP 81] were left out for\n   simplicity's sake.  Having several packets outstanding\
    \ at a time was\n   eliminated for the same reason, and data queued to send when\
    \ a\n   connection is closed remotely is discarded.  This eliminates two\n   states\
    \ from the protocol implementation.\n   The reader may ask why define this protocol\
    \ at all, there are after\n   all already RS-232 transport protocols in use. \
    \ This is true but some\n   lack one or more features vitally important or are\
    \ too complex.  See\n   Appendix II for a brief survey.\n      - A protocol which\
    \ can only transfer data in one direction is\n        unable to use a single RS-232\
    \ link for a full-duplex connection.\n        As such it cannot act as a bridge\
    \ between most computer\n        networks.  Also it is not capable of supporting\
    \ any applications\n        requiring the two-way exchange of data.  In particular\
    \ it is not\n        a platform suitable for the creation of most higher level\n\
    \        applications.  Unidirectional flow of data is sufficient for a\n    \
    \    weak implementation of file transfer but insufficient for remote\n      \
    \  terminal service, transaction oriented processing, etc.\n      - Some of the\
    \ existing RS-232 transport protocols allow the use of\n        only fixed size\
    \ packets or do not allow the receiver to place a\n        limit on the sender's\
    \ packets.  Where that block size is too\n        large for the receiving end\
    \ concentrator, that concentrator is\n        likely to immediately invoke flow\
    \ control.  This results in many\n        dropped and damaged packets.  The receiver\
    \ must be able to\n        inform the sender at connection initiation what is\
    \ the maximum\n        packet size it is prepared to receive.\n      - Some protocols\
    \ have a number of features which may or may not be\n        implemented at each\
    \ site.  Examples are, several checksumming\n        algorithms, differing data\
    \ transmission restrictions, sometimes\n        8-bit data, sometimes restricted\
    \ ASCII subsets, etc.  The\n        resulting requirement that all sites implement\
    \ all the various\n        features is rarely met.\n   Finally, the size of this\
    \ document may be imposing.  The document\n   attempts to fully specify the behavior\
    \ of the protocol.  A careful\n"
- title: RFC 916                                                     October 1984
  contents:
  - 'RFC 916                                                     October 1984

    '
- title: Reliable Asynchronous Transfer Protocol
  contents:
  - "Reliable Asynchronous Transfer Protocol\n   exposition of the protocol's behavior\
    \ under all circumstances is\n   necessary to answer any questions an implementor\
    \ might have, to make\n   it possible to verify the protocol, etc.  This size\
    \ of this\n   specification should not be taken as an indication of the difficulty\n\
    \   of implementing it.\n   1.1. The Host Environment\n      This protocol is\
    \ designed to operate on any point-to-point\n      communication link capable\
    \ of transmitting and receiving data.  It\n      is not necessary that the link\
    \ be asynchronous.  Because neither\n      end of a connection has control over\
    \ when the other decides to\n      transmit, the link should be full duplex. \
    \ It is expected that in\n      the vast majority of circumstances an asynchronous\
    \ full-duplex\n      RS-232 link will be used.\n      In practice this protocol\
    \ could reside anywhere from the RS-232\n      driver software on a microcomputer\
    \ in a concentrator all the way\n      to the user software level.  Ideally it\
    \ properly resides inside\n      the host operating system or concentrator.  It\
    \ should be an option\n      associated with communication link which is selectable\
    \ by the user\n      program.  If reliable data transmission were of great importance\n\
    \      then the software would choose the option.  Once the option were\n    \
    \  chosen the initial connection handshaking would begin.\n      There are many\
    \ cases where this protocol will not reside in a host\n      operating system\
    \ (initially this will always be so).  In addition\n      there are many pieces\
    \ of stand-alone equipment which accept\n      commands over an RS-232 link. \
    \ A plotter is such an example.  To\n      have a several hour plot ruined by\
    \ noise on an unreliable data\n      line is an all too often occurrence.  The\
    \ sending and receiving\n      sides of the protocol should be as simple as possible\
    \ allowing\n      applications software and stand alone devices to utilize the\n\
    \      protocol with little penalty of time or space.\n   1.2. Relation to Other\
    \ Protocols\n      The \"layering\" concept has become the accepted way of designing\n\
    \      communications protocols.  Because this protocol will operate in a\n  \
    \    point-to-point environment it comprises both the datagram and\n      reliable\
    \ connection layers.  No multi-network capability is\n      implied.  Where a\
    \ link using this protocol bridges differing\n      networks it is expected that\
    \ other protocols like TCP will have\n      their packets fragmented and encapsulated\
    \ inside the packets of\n      this protocol.\n"
- title: RFC 916                                                     October 1984
  contents:
  - 'RFC 916                                                     October 1984

    '
- title: Reliable Asynchronous Transfer Protocol
  contents:
  - 'Reliable Asynchronous Transfer Protocol

    '
- title: 2. Packet Specification
  contents:
  - "2. Packet Specification\n   RATP transmits data over a full-duplex communication\
    \ link.  Data may\n   be transmitted in both directions over the link.  A stream\
    \ of data is\n   communicated by being broken up into 8-bit pieces called octets.\n\
    \   These octets are serially accumulated to form a packet.  The packet\n   is\
    \ the unit of data communicated over the link.  The protocol\n   virtually guarantees\
    \ that the data transmitted at one end, if\n   received, arrives unaltered and\
    \ intact at the other end.\n   Within an octet all eight bits contain data.  All\
    \ eight bits must be\n   preserved by the link interface and associated device\
    \ driver.  In\n   many operating systems this is ensured by placing the connection\
    \ into\n   RAW or BINARY data mode.  During normal operation packets are\n   transmitted\
    \ and acknowledged one at a time over the link in each\n   direction.  Each packet\
    \ is composed of a HEADER followed by a DATA\n   portion.  The DATA portion may\
    \ be empty.\n      NOTE: There are some older operating systems and devices which\
    \ do\n      not permit 8-bit communication over an RS-232 link.  Most of these\n\
    \      allow restricted 7-bit communication.  RATP can automatically\n      detect\
    \ this situation during connection initiation and utilizes a\n      special packing\
    \ strategy when full 8-bit communication is not\n      possible.  This is entirely\
    \ transparent to any client software.\n      See Appendix I for a discussion of\
    \ this case.\n"
- title: RFC 916                                                     October 1984
  contents:
  - 'RFC 916                                                     October 1984

    '
- title: Reliable Asynchronous Transfer Protocol
  contents:
  - "Reliable Asynchronous Transfer Protocol\n   2.1. Header Format\n      Byte No.\n\
    \             +-------------------------------+\n             |              \
    \                 |\n         1   |          Synch Leader         | Hex 01\n \
    \            |                               |\n             +-------------------------------+\n\
    \             | S | A | F | R | S | A | E | S |\n         2   | Y | C | I | S\
    \ | N | N | O | O | Control\n             | N | K | N | T |   |   | R |   |\n\
    \             +-------------------------------+\n             |              \
    \                 |\n         3   |      Data length (0-255)      |\n        \
    \     |                               |\n             +-------------------------------+\n\
    \             |                               |\n         4   |        Header\
    \ Checksum        |\n             |                               |\n        \
    \     +-------------------------------+\n                       Header Portion\
    \ of a Packet\n      2.1.1. Synch Leader\n         RS-232 provides a self-clocking\
    \ communications medium.  The\n         wires over which data flows are often\
    \ placed in 'noisy'\n         environments where the noise can appear as added\
    \ unwanted data.\n         For this reason the beginning of a packet is denoted\
    \ by a one\n         octet SYNCH pattern.  This allows the receiver to discard\
    \ noise\n         which appears on the connection prior to the reception of a\n\
    \         packet.  The SYNCH pattern is defined to be the one octet hex\n    \
    \     01, the ASCII Start Of Header character <SOH>.\n         The SYNCH pattern\
    \ should ideally be unlikely to occur as the\n         result of noise.  Differing\
    \ modems, etc. have differing\n         responses to noise so this is hard to\
    \ achieve.  The pattern\n         chosen is thought to be a good compromise since\
    \ many modems\n         manifest noise by setting the high order bits.  Situations\
    \ will\n         occur in which receiver is scanning for the beginning of a\n\
    \         packet and a spurious SYNCH pattern is seen.  To detect\n         situations\
    \ of this type a header checksum is provided (see\n         below).\n"
- title: RFC 916                                                     October 1984
  contents:
  - 'RFC 916                                                     October 1984

    '
- title: Reliable Asynchronous Transfer Protocol
  contents:
  - "Reliable Asynchronous Transfer Protocol\n      2.1.2. Control Bits\n        \
    \ The first octet following the SYNCH pattern contains a 5-bit\n         field\
    \ of control flags and two 1-bit sequence number fields.\n         The last bit\
    \ is reserved and must be zero.\n         2.1.2.1. SYN - Synchronize Flag\n  \
    \          Synchronize the connection.  No data may be sent in a packet\n    \
    \        which has the SYN flag set.\n         2.1.2.2. ACK - Acknowledge Flag\n\
    \            Acknowledge number is significant.  Data may accompany a\n      \
    \      packet which has this flag set as long as neither of SYN,\n           \
    \ RST, nor FIN are also set.  Once a connection has been\n            established\
    \ this is always set.\n         2.1.2.3. RST - Reset Flag\n            Reset the\
    \ connection.  This is a method by which one end of\n            a connection\
    \ can reset the other when an anomalous condition\n            is detected.  No\
    \ data may be sent in a packet which has the\n            RST flag set.\n    \
    \     2.1.2.4. FIN - Finishing Flag\n            This indicates that no more data\
    \ will be sent to the other\n            end of the connection.  It also indicates\
    \ that no more data\n            will be accepted.  No data may be sent in a packet\
    \ which has\n            the FIN flag set.\n         2.1.2.5. SN - Sequence Number\n\
    \            The Sequence Number associated with this packet.\n         2.1.2.6.\
    \ AN - Acknowledge Number\n            If the ACK control flag is set this is\
    \ the next Sequence\n            Number the sender of the packet is expecting\
    \ to receive.\n         2.1.2.7. EOR - End of Record\n            This bit is\
    \ provided as an aid for higher level protocols\n            which may need to\
    \ fragment their packets.  The Internet\n            protocol for example often\
    \ uses packets as large as 576\n            octets.  A packet of such size would\
    \ require fragmentation\n"
- title: RFC 916                                                     October 1984
  contents:
  - 'RFC 916                                                     October 1984

    '
- title: Reliable Asynchronous Transfer Protocol
  contents:
  - "Reliable Asynchronous Transfer Protocol\n            when transported using this\
    \ protocol. The EOR bit if set\n            provides information to the higher\
    \ level that a record is\n            terminated in this packet.  It is for information\
    \ only and\n            is the responsibility of the higher level to set/clear\
    \ it\n            when building packets to send.  The interface to the\n     \
    \       protocol must provide a method of reading/setting/clearing\n         \
    \   this bit.\n         2.1.2.8. SO - Single Octet\n            One application\
    \ thought to be of special importance is\n            single character transmission\
    \ --- a user communicates from\n            the keyboard of a personal computer\
    \ to another computer over\n            an unreliable link.  Since rapid interactive\
    \ response is\n            desirable it is expected that many of the characters\
    \ typed\n            will be transmitted individually.  To minimize the overhead\n\
    \            of this special case the SO control flag is provided.\n         \
    \   The SO flag has no meaning if either the SYN, RST, or FIN\n            flags\
    \ are set.  Assume none of those flags are set, then if\n            the SO flag\
    \ is set it indicates that a single octet of data\n            is contained in\
    \ this packet. Since the amount of data is\n            known to be one octet\
    \ the LENGTH field is superfluous and\n            itself contains the data octet.\
    \  The data portion of the\n            packet is not transmitted.\n         \
    \   The SO flag removes the need to transmit the data portion of\n           \
    \ the packet in this special case.  Without the SO flag seven\n            octets\
    \ would be required of the packet, with it only four\n            are needed and\
    \ so transmission efficiency is improved by 40\n            percent.  The header\
    \ checksum protects the single octet of\n            data.\n      2.1.3. Length\n\
    \         The second octet following the SYNCH pattern holds length\n        \
    \ information.  If the SYN bit is present this contains the\n         maximum\
    \ number of data octets the receiver is allowed to\n         transmit in any single\
    \ packet to the sender.  This quantity is\n         called the MDL.  A sender\
    \ may indicate his unwillingness to\n         accept any data octets by specifying\
    \ an MDL of zero.  In this\n         case presumably all the data would be moving\
    \ from the sender to\n         the receiver.  Obviously if data is to be transmitted\
    \ both\n         sides of a connection cannot have an MDL of zero.\n         If\
    \ neither the SYN, RST, nor FIN flags are set this is an 8-bit\n         field\
    \ called LENGTH.  In this case if the SO flag bit is set\n"
- title: RFC 916                                                     October 1984
  contents:
  - 'RFC 916                                                     October 1984

    '
- title: Reliable Asynchronous Transfer Protocol
  contents:
  - "Reliable Asynchronous Transfer Protocol\n         then LENGTH contains a single\
    \ octet of data.  Otherwise it\n         contains the count of data octets in\
    \ this packet.  From zero\n         (0) to MDL octets of data may appear in a\
    \ single packet.  MDL\n         is limited to a maximum of 255.\n      2.1.4.\
    \ Header Checksum\n         The header checksum algorithm is the 8-bit equivalent\
    \ of the\n         16-bit data checksum detailed below.  It is built and processed\n\
    \         in an similar manner but is eight bits wide instead of sixteen.\n  \
    \       When sending the header checksum octet is initially cleared.\n       \
    \  An 8-bit sum of the control, length, and header checksum octets\n         is\
    \ formed employing end-around carry.  That sum is then\n         complemented\
    \ and stored in the header checksum octet.  Upon\n         receipt the 8-bit end-around\
    \ carry sum is formed of the same\n         three octets.  If the sum is octal\
    \ 377 the header is presumed\n         to be valid.  In all other cases the header\
    \ is assumed to be\n         invalid.\n         The reasons for providing this\
    \ separate protection to the\n         header are discussed in the chapter dealing\
    \ with error\n         handling.  The header checksum covers the control and data\n\
    \         length octets.  It does not include the SYNCH pattern.\n   2.2. Data\
    \ Format\n      The data portion of a packet immediately follows the header if\
    \ the\n      SO flag is not set and LENGTH > 0.  It consists of LENGTH data\n\
    \      octets  immediately followed by two data checksum octets.  If\n      present\
    \ the data portion contains LENGTH+2 octets.\n"
- title: RFC 916                                                     October 1984
  contents:
  - 'RFC 916                                                     October 1984

    '
- title: Reliable Asynchronous Transfer Protocol
  contents:
  - "Reliable Asynchronous Transfer Protocol\n      Data Byte No.\n              \
    \    +-------------------------------+\n         1        |                  \
    \             | High order \\\n                  +--                         \
    \  --+             > Word\n         2        |                               |\
    \ Low order  /\n                  +--                           --+\n        \
    \ .        |            Data               | High order \\\n                 \
    \ +--                           --+             > Word\n         .        |  \
    \                             | Low order  /\n                  +--          \
    \                 --+\n         LENGTH   |                               | High\
    \ order \\\n                  +-------------------------------+             >\
    \ Word\n                  |   Imaginary padding octet 0   | Low order  /\n   \
    \               +-------------------------------+\n         LENGTH+1 |       \
    \                        | High order \\\n                  +--       Data Checksum\
    \       --+             > Word\n         LENGTH+2 |                          \
    \     | Low order  /\n                  +-------------------------------+\n  \
    \                      Data Portion of a Packet\n      2.2.1. Data Checksum\n\
    \         The last two octets of the data portion of a packet are a data\n   \
    \      checksum.  A 16-bit checksum is used by this protocol to detect\n     \
    \    incorrectly transmitted data.  This has shown itself to be a\n         reliable\
    \ method for detecting most categories of bit drop out\n         and bit insertion.\
    \  While it does not guarantee the detection\n         of all such errors the\
    \ probability of such an error going\n         undetected is on the order of 2**(-16).\n\
    \         The checksum octets follow the data to enable the sender of a\n    \
    \     packet to compute the checksum while transmitting a packet and\n       \
    \  the receiver to compute the checksum while receiving the\n         packet.\
    \  Thus neither must store the packet and then process\n         the data for\
    \ checksumming in a separate pass.\n         Order of Transmission\n         \
    \   The order in which the 8-bit octets are assembled into\n            16-bit\
    \ words, which is the low order octet and which is the\n            high, must\
    \ be rigidly specified for the purpose of computing\n            16-bit checksums.\
    \  We specify the big endian ordering in the\n            diagram above [Cohen\
    \ 81].\n"
- title: RFC 916                                                     October 1984
  contents:
  - 'RFC 916                                                     October 1984

    '
- title: Reliable Asynchronous Transfer Protocol
  contents:
  - "Reliable Asynchronous Transfer Protocol\n         Checksum Algorithm\n      \
    \      The checksum algorithm chosen is similar to that used by\n            IP/TCP\
    \ protocols [IP 81] [TCP 81].  This algorithm has shown\n            itself to\
    \ be both reliable and relatively easy to compute.\n            The interested\
    \ reader may refer to [TCP Checksum 78] for a\n            more thorough discussion\
    \ of its properties.\n         The checksum algorithm is:\n            SENDER\n\
    \               The unsigned sum of the 16-bit words of the data portion\n   \
    \            of the packet is formed.  Any overflow is added into the\n      \
    \         lowest order bit.  This sum does not include the header\n          \
    \     portion of the packet.  For the purpose of building a\n               packet\
    \ for transmission the two octet checksum field is\n               zero.  The\
    \ sum formed is then bit complemented and\n               inserted into the checksum\
    \ field before transmission.\n               If the total number of data octets\
    \ is odd then the last\n               octet is padded to the right (low order)\
    \ with zeros to\n               form a 16-bit word for checksum purposes.  This\
    \ pad octet\n               is not transmitted as part of the packet.\n      \
    \      RECEIVER\n               The sum is computed as above but including the\
    \ values\n               received in the checksum field.  If the 16-bit sum is\n\
    \               octal 177777 then the data is presumed to be valid.  In\n    \
    \           all other cases the data is presumed to be invalid.\n         This\
    \ unsigned 16-bit sum adds 16-bit quantities with any\n         overflow bit added\
    \ into the lowest order bit of the sum.  This\n         is called 'end around\
    \ carry'.  End around carry addition\n         provides several properties: 1)\
    \ It provides full commutivity of\n         addition (summing in any order is\
    \ equivalent), and 2) If you\n         apply a given rotation to each quantity\
    \ before addition and\n         when the final total is formed apply the inverse\
    \ rotation, then\n         the result will be equivalent to any other rotation\
    \ chosen.\n         The latter property gives little endian machines like a PDP-11\n\
    \         the go ahead to pick up 16-bit quantities and add them in byte\n   \
    \      swapped order.\n"
- title: RFC 916                                                     October 1984
  contents:
  - 'RFC 916                                                     October 1984

    '
- title: Reliable Asynchronous Transfer Protocol
  contents:
  - "Reliable Asynchronous Transfer Protocol\n            The PDP-11 code to calculate\
    \ the checksum is:\n                     CLR R0         ; R0 will get the checksum\n\
    \                                    ; R2 contains LENGTH count\n            \
    \   LOOP: ADD (R1)+,R0   ; Add the next 16-bit byte\n                     ADC\
    \ R0         ; Make any carry be end around\n                     SOB R2,LOOP\
    \    ; Loop over entire packet\n                     COM R0         ; Bit complement\
    \ result\n   2.3. Sequence Numbers\n      Sequence numbers work with acknowledge\
    \ numbers to inform the\n      sender that his last data packet was received,\
    \ and to inform the\n      receiver of the sequence number of the next data packet\
    \ it expects\n      to see.  When the ACK flag is set in a packet the AN field\n\
    \      contains the sequence number of the next data packet it expects\n     \
    \ from the sender.  The sender looks at the AN field and by\n      implication\
    \ knows that the packet he just sent should have had a\n      sequence number\
    \ of:\n         <AN received-1 modulo 2>\n      If it did have that number that\
    \ packet is considered to have been\n      acknowledged.\n      Similarly, the\
    \ receiver expects the next data packet it sees to\n      have an SN field value\
    \ equal to the AN field of the last\n      acknowledge message it sent.  If this\
    \ is not the case then the\n      receiver assumes that it is receiving a duplicate\
    \ of a data packet\n      it earlier acknowledged.  This implies that the packet\
    \ containing\n      the acknowledgment did not arrive and therefor the packet\
    \ that\n      contained the acknowledgment should be retransmitted.  The\n   \
    \   duplicate data packet is discarded.\n      The only packets which require\
    \ acknowledgment are packets\n      containing status flags (SYN, RST, FIN, or\
    \ SO) or data.  A packet\n      which contains only an acknowledgment, i.e. <AN=n><CTL=ACK>,\
    \ does\n      not require a response (it contains no status flags or data).\n\
    \      Both the AN and SN fields are a single bit wide.  Since at most\n     \
    \ one packet is in the process of being sent/acknowledged in a\n      particular\
    \ direction at any one time a single bit is sufficient to\n      provide a method\
    \ of duplicate packet detection and removal of a\n      packet from the retransmission\
    \ queue.  The arithmetic to advance\n      these numbers is modulo 2.  Thus when\
    \ a data packet has been\n      acknowledged the sender's next sequence number\
    \ will be the current\n      one, plus one modulo 2:\n"
- title: RFC 916                                                     October 1984
  contents:
  - 'RFC 916                                                     October 1984

    '
- title: Reliable Asynchronous Transfer Protocol
  contents:
  - "Reliable Asynchronous Transfer Protocol\n         <SN = SN + 1 modulo 2>\n  \
    \    The individual acknowledgment of each packet containing data can\n      mislead\
    \ one into thinking that side A of a connection cannot send\n      data to side\
    \ B until it receives a packet from B. That only then\n      can it acknowledge\
    \ B's packet and place in the acknowledging\n      packet some data of its own.\
    \  This is not the case.\n      As long as its last packet sent requiring a response\
    \ has been\n      acknowledged each side of a connection is free to send a data\n\
    \      packet whenever it wishes.  Naturally, if one side is sending a\n     \
    \ data packet and it also must acknowledge receipt of a data packet\n      from\
    \ the other side, it is most efficient to combine both\n      functions in a single\
    \ packet.\n   2.4. Maximum Packet Size\n      The maximum packet size is:\n  \
    \       SYNCH + HEADER + Data Checksum + 255 = 261 octets\n      There is therefor\
    \ no need to allocate more than that amount of\n      storage for any received\
    \ packets.\n"
- title: RFC 916                                                     October 1984
  contents:
  - 'RFC 916                                                     October 1984

    '
- title: Reliable Asynchronous Transfer Protocol
  contents:
  - 'Reliable Asynchronous Transfer Protocol

    '
- title: 3. The Opening and Closing of a Connection
  contents:
  - "3. The Opening and Closing of a Connection\n   3.1. Opening a Connection\n  \
    \    A \"three-way handshake\" is the procedure used to establish a\n      connection.\
    \  It is normally initiated by one end of the connection\n      and responded\
    \ to by the other.  It will still work if both sides\n      simultaneously initiate\
    \ the procedure.  Experience has shown that\n      this strategy of opening a\
    \ connection reduces the probability of\n      false connections to an acceptably\
    \ low level.\n      The simplest form of the three-way handshake is illustrated\
    \ in the\n      diagram below.  The time order is line by line from top to bottom\n\
    \      with certain lines numbered for reference.  User events are placed\n  \
    \    in brackets as in [OPEN].  An arrow (-->) represents the direction\n    \
    \  of flow of a packet and an ellipsis (...) indicates a packet in\n      transit.\
    \  Side A and side B are the two ends of the connection.\n      An \"XXX\" indicates\
    \ a packet which is lost or rejected.  The\n      contents of the packet are shown\
    \ on the center of each line.  The\n      state of both connections is that caused\
    \ by the departure or\n      arrival of the packet represented on the line.  The\
    \ contents of\n      the data portion of a packet are left out for clarity.\n\
    \      Side A                                             Side B\n      1. CLOSED\
    \                                          LISTEN\n      2. [OPEN request]\n \
    \         SYN-SENT ->   <SN=0><CTL=SYN><MDL=n>     ...\n      3.             \
    \                              -->   SYN-RECEIVED\n              ... <SN=0><AN=1><CTL=SYN,ACK><MDL=m>\
    \ <--\n      4. ESTABLISHED <--\n              -->    <SN=1><AN=1><CTL=ACK><DATA>\
    \   ...\n      5.                                           -->   ESTABLISHED\n\
    \      In line 2 above the user at side A has requested that a connection\n  \
    \    be opened.  Side A then attempts to open a connection by sending a\n    \
    \  SYN packet to side B which is in the LISTEN state.  It specifies\n      its\
    \ initial sequence number, here zero.  It places in the LENGTH\n      field of\
    \ the header the largest number of data octets it can\n      consume in any one\
    \ packet (MDL).  The MDL is normally positive.\n      The action of sending this\
    \ packet places A in the SYN-SENT state.\n      In line 3 side B has just received\
    \ the SYN packet from A. This\n"
- title: RFC 916                                                     October 1984
  contents:
  - 'RFC 916                                                     October 1984

    '
- title: Reliable Asynchronous Transfer Protocol
  contents:
  - "Reliable Asynchronous Transfer Protocol\n      places B in the SYN-RECEIVED state.\
    \  B now sends a SYN packet to A\n      which acknowledges the SYN it just received\
    \ from A. Note that the\n      AN field indicates B is now expecting to hear SN=1,\
    \ thus\n      acknowledging the SYN packet from A which used SN=0.  B also\n \
    \     specifies in the LENGTH field the largest number of data octets it\n   \
    \   is prepared to consume.\n      Side A receives the SYN packet from B which\
    \ acknowledges A's\n      original SYN packet in line 4.  This places A in the\
    \ ESTABLISHED\n      state.  Side A can now be confident that B expects to receive\
    \ more\n      packets from A.\n      A is now free to send B the first DATA packet.\
    \  In line 5 upon\n      receipt of this packet side B is placed into the ESTABLISHED\n\
    \      state.  DATA cannot be sent until the sender is in the ESTABLISHED\n  \
    \    state.  This is because the LENGTH field is used to specify the\n      MDL\
    \ when opening the connection.\n   3.2. Recovering from a Simultaneous Active\
    \ OPEN\n      It is of course possible that both ends of a connection may choose\n\
    \      to  perform an active OPEN simultaneously.  In this case neither\n    \
    \  end of the connection is in the LISTEN state, both send SYN\n      packets.\
    \  A reliable bidirectional protocol must recover from this\n      situation.\
    \  It should recover in such a manner that the connection\n      is successfully\
    \ initiated.\n"
- title: RFC 916                                                     October 1984
  contents:
  - 'RFC 916                                                     October 1984

    '
- title: Reliable Asynchronous Transfer Protocol
  contents:
  - "Reliable Asynchronous Transfer Protocol\n      Side A                       \
    \                      Side B\n      1. CLOSED                               \
    \           CLOSED\n      2. [OPEN request]\n         SYN-SENT -->  <SN=0><CTL=SYN><MDL=n>\
    \       ...\n      3.     ...                                         [OPEN request]\n\
    \                       <SN=0><CTL=SYN><MDL=m>       <--  SYN-SENT\n      4. \
    \                                           -->  SYN-RECEIVED\n             ...\
    \  <SN=0><AN=1><CTL=SYN,ACK><MDL=m>  <--\n      5. (packet finally arrives)\n\
    \         SYN-RECEIVED  <--  <SN=0><CTL=SYN><MDL=m>\n             -->  <SN=0><AN=1><CTL=SYN,ACK><MDL=n>\
    \  -->  ESTABLISHED\n              ...       <SN=1><AN=1><CTL=ACK>       <--\n\
    \      6. (packet finally arrives)\n         ESTABLISHED <-- <SN=0><AN=1><CTL=SYN,ACK><MDL=m>\n\
    \                     -->   <SN=1><AN=1><CTL=ACK>    ...\n      During simultaneous\
    \ connection both  sides  of  the  connection\n      cycle  from  the CLOSED state\
    \ through SYN-SENT to SYN-RECEIVED,\n      and finally to ESTABLISHED.\n   3.3.\
    \ Detecting a Half-Open Connection\n      Any computer may crash after a connection\
    \ has been established.\n      After recovering from the crash it may attempt\
    \ to open a new\n      connection.  The other end must be able to detect this\
    \ condition\n      and treat it as an error.\n"
- title: RFC 916                                                     October 1984
  contents:
  - 'RFC 916                                                     October 1984

    '
- title: Reliable Asynchronous Transfer Protocol
  contents:
  - "Reliable Asynchronous Transfer Protocol\n      Side A                       \
    \                      Side\n      1. ESTABLISHED                            \
    \         ESTABLISHED\n                -->   <SN=0><AN=1><CTL=ACK><DATA>  ...\n\
    \                                                   -->\n      (crashes)\n   \
    \   2.        XXX   <SN=1><AN=1><CTL=ACK><DATA>  <--\n      3. (attempts to open\
    \ new connection )\n                -->    <SN=0><CTL=SYN><MDL=m>      -->\n \
    \               ...  <SN=0><AN=1><CTL=RST,ACK>     <--   (abort)\n           \
    \                                              CLOSED\n      4.        <--\n \
    \     (connection refused)\n         CLOSED\n   3.4. Closing a Connection\n  \
    \    Either side may choose to close an established connection.  This\n      is\
    \ accomplished by sending a packet with the FIN  control bit set.\n      No  data\
    \ may appear in a FIN packet.  The other end of the\n      connection responds\
    \ by shutting down its end of the connection and\n      sending a FIN, ACK in\
    \ response.\n      Side A                                             Side B\n\
    \      1. ESTABLISHED                                     ESTABLISHED\n      2.\
    \ [CLOSE request from user]\n         FIN-WAIT  -->     <SN=0><AN=1><CTL=FIN>\
    \    ...\n      3.                                            -->  LAST-ACK\n\
    \                   ...   <SN=1><AN=1><CTL=FIN,ACK>  <--\n      4. TIME-WAIT <--\n\
    \                   -->     <SN=1><AN=0><CTL=ACK>    ...\n      5.           \
    \                                 -->  CLOSED\n      6. (after 2*SRTT time passes)\n\
    \         CLOSED\n      In line 2 the user on side A of the fully opened connection\
    \ has\n      decided to close it down by issuing a CLOSE call.  No more data\n"
- title: RFC 916                                                     October 1984
  contents:
  - 'RFC 916                                                     October 1984

    '
- title: Reliable Asynchronous Transfer Protocol
  contents:
  - "Reliable Asynchronous Transfer Protocol\n      will be accepted for sending.\
    \  If data remains unsent a message\n      \"Warning: Unsent data remains.\" is\
    \ communicated to the user.  No\n      more data will be received.  A packet containing\
    \ a FIN but no data\n      is constructed and sent.  Side A goes into the FIN-WAIT\
    \ state.\n      Side B sees the FIN sent and immediately builds a FIN, ACK packet\n\
    \      in response.  It then goes into the LAST-ACK state.  The FIN, ACK\n   \
    \   packet is received by side A and an answering ACK is immediately\n      sent.\
    \  Side A then goes to the TIME-WAIT state.  In line 5 side B\n      receives\
    \ the final acknowledgment of its FIN, ACK packet and goes\n      to the CLOSED\
    \ state.  In line 6 after waiting to be sure its last\n      acknowledgment was\
    \ received side A goes to the CLOSED state (SRTT\n      is the Smoothed Round\
    \ Trip Time and is defined in section 6.3.1).\n"
- title: RFC 916                                                     October 1984
  contents:
  - 'RFC 916                                                     October 1984

    '
- title: Reliable Asynchronous Transfer Protocol
  contents:
  - 'Reliable Asynchronous Transfer Protocol

    '
- title: 4. Packet Reception
  contents:
  - "4. Packet Reception\n   The act of receiving a packet is relatively straightforward.\
    \  There\n   are a few points which deserve some discussion.  This chapter will\n\
    \   discuss packet reception stage by stage in time order.\n   Synch Detection\n\
    \      The first stage in the reception of a packet is the discovery of a\n  \
    \    SYNCH pattern.  Octets are read continuously and discarded until\n      the\
    \ SYNCH pattern is seen.  Once SYNCH has been observed proceed\n      to the Header\
    \ Reception stage.\n   Header Reception\n      The remainder of the header is\
    \ three octets in length.  No further\n      processing can continue until the\
    \ complete header has been read.\n      Once read the header checksum test is\
    \ performed.  If this test\n      fails it is assumed that the current SYNCH pattern\
    \ was the result\n      of a data error.  Since the correct SYNCH may appear immediately\n\
    \      after the current one, go back to the Synch Detection stage but\n     \
    \ treat the three octets of the header following the bad SYNCH as\n      new input.\n\
    \      If the header checksum test succeeds then proceed to the Data\n      Reception\
    \ stage.\n   Data Reception\n      A determination of the remaining length of\
    \ the packet is made.  If\n      either of the SYN, RST, SO, or FIN flags are\
    \ set then legally the\n      entire packet has already been read and it is considered\
    \ to have\n      'arrived'.  No data portion of a packet is present when one of\n\
    \      those flags is set.  Otherwise the LENGTH field specifies the\n      remaining\
    \ amount of data to read.  In this case if the LENGTH\n      field is zero then\
    \ the packet contains no data portion and it is\n      considered to have arrived.\n\
    \      We now assume that a data portion is present and LENGTH was\n      non-zero.\
    \  Counting the data checksum LENGTH+2 octets must now be\n      read.  Once read\
    \ the data checksum test is performed.  If this\n      test fails the entire packet\
    \ is discarded, return to the Synch\n      Detection stage.  If the test succeeds\
    \ then the packet is\n      considered to have arrived.\n"
- title: RFC 916                                                     October 1984
  contents:
  - 'RFC 916                                                     October 1984

    '
- title: Reliable Asynchronous Transfer Protocol
  contents:
  - "Reliable Asynchronous Transfer Protocol\n   Once arrived the packet is released\
    \ to the upper level protocol\n   software.  In a multiprocess implementation\
    \ packet reception would\n   now begin again at the Synch Detection stage.\n"
- title: RFC 916                                                     October 1984
  contents:
  - 'RFC 916                                                     October 1984

    '
- title: Reliable Asynchronous Transfer Protocol
  contents:
  - 'Reliable Asynchronous Transfer Protocol

    '
- title: 5. Functional Specification
  contents:
  - "5. Functional Specification\n   A convenient model for the discussion and implementation\
    \ of protocols\n   is that of a state machine.  A connection can be thought of\
    \ as\n   passing through a variety of states, with possible error conditions,\n\
    \   from its inception until it is closed.  In such a model each state\n   represents\
    \ a known point in the history of a connection.  The\n   connection passes from\
    \ state to state in response to events.  These\n   events are caused by user calls\
    \ to the protocol interface (a request\n   to open or close a connection, data\
    \ to send, etc.), incoming packets,\n   and timeouts.\n   Information about a\
    \ connection must be maintained at both ends of\n   that connection.  Following\
    \ the terminology of [TCP 81] the\n   information necessary to the successful\
    \ operation of a connection is\n   called the Transmission Control Block or TCB.\
    \  The user requests to\n   the protocol interface are OPEN, SEND, RECEIVE, ABORT,\
    \ STATUS, and\n   CLOSE.\n   This chapter is broken up into three parts.  First\
    \ a brief\n   description of each protocol state will be presented.  Following\
    \ this\n   is a slightly more detailed look at the allowed transitions which\n\
    \   occur between states.  Finally a detailed discussion of the behavior\n   of\
    \ each state is given.\n   5.1. Protocol States\n      The states used to describe\
    \ this protocol are:\n         LISTEN\n            This state represents waiting\
    \ for a connection from the\n            other end of the link.\n         SYN-SENT\n\
    \            This represents waiting for a matching connection request\n     \
    \       after having sent a connection request.\n         SYN-RECEIVED\n     \
    \       This represents waiting for a confirming connection request\n        \
    \    acknowledgment after having both received and sent a\n            connection\
    \ request.\n"
- title: RFC 916                                                     October 1984
  contents:
  - 'RFC 916                                                     October 1984

    '
- title: Reliable Asynchronous Transfer Protocol
  contents:
  - "Reliable Asynchronous Transfer Protocol\n         ESTABLISHED\n            This\
    \ state represents a connection fully opened at both\n            ends.  This\
    \ is the normal state for data transfer.\n         FIN-WAIT\n            In this\
    \ state one is waiting for a connection termination\n            request from\
    \ the other end of the connection and an\n            acknowledgment of a termination\
    \ request previously sent.\n         LAST-ACK\n            This end of the connection\
    \ has seen and acknowledged a\n            termination request from the other\
    \ end.  This end has\n            responded with a termination request of its\
    \ own and is now\n            expecting an acknowledgment of that request.\n \
    \        CLOSING\n            This represents waiting for an acknowledgment of\
    \ a\n            connection termination request.\n         TIME-WAIT\n       \
    \     This represents waiting for enough time to pass to be sure\n           \
    \ that the other end of the connection received the\n            acknowledgment\
    \ of its termination request.\n         CLOSED\n            A fictional state\
    \ which represents a completely terminated\n            connection.  If either\
    \ end of a connection is in this state\n            it will neither send nor receive\
    \ data or control packets.\n"
- title: RFC 916                                                     October 1984
  contents:
  - 'RFC 916                                                     October 1984

    '
- title: Reliable Asynchronous Transfer Protocol
  contents:
  - "Reliable Asynchronous Transfer Protocol\n   5.2. State Transitions\n      This\
    \ section describes events which cause the protocol to depart\n      from its\
    \ current state.  A brief mention of each state is\n      accompanied by a list\
    \ of departure events and to which state the\n      protocol goes as a result\
    \ of those events.  Departures due to the\n      presence of a RST flag are not\
    \ shown.\n      5.2.1. LISTEN\n         This is a request to listen for any connection\
    \ from the other\n         end of the link.  In this state, no packets are sent.\
    \  The\n         connection may be thought of as half-open.  A STATUS request\n\
    \         will return to the caller this information.\n         Arrived at from\
    \ the CLOSED state in response to a passive OPEN.\n         In a passive OPEN\
    \ no packets are sent, the interface is waiting\n         for the initiation of\
    \ a connection from the other end of the\n         link.  Also this state can\
    \ be reached in certain cases in\n         response to an RST connection reset\
    \ request.\n         Departures\n            - A CLOSE request is made by the\
    \ user.  Delete the half-open\n              TCB and go to the CLOSED state.\n\
    \            - A packet arrives with the SYN flag set.  Retrieve the\n       \
    \       sender's MDL he placed into the LENGTH field.  Set AN to\n           \
    \   be received SN+1 modulo 2.  Build a response packet with\n              SYN,\
    \ ACK set.  Choose your MDL and place it into the\n              LENGTH octet.\
    \  Choose your initial SN, place in AN.  Send\n              this packet and go\
    \ to the SYN-RECEIVED state.\n      5.2.2. SYN-SENT\n         Arrived at from\
    \ the CLOSED state in response to a user's active\n         OPEN request.\n  \
    \       Departures\n            - A CLOSE request is made by the user.  Delete\
    \ the TCB and\n              go to the CLOSED state.\n            - A packet arrives\
    \ with the SYN flag set.  Retrieve the\n              sender's MDL he placed into\
    \ the LENGTH field.  Set AN to\n"
- title: RFC 916                                                     October 1984
  contents:
  - 'RFC 916                                                     October 1984

    '
- title: Reliable Asynchronous Transfer Protocol
  contents:
  - "Reliable Asynchronous Transfer Protocol\n              be received SN+1 modulo\
    \ 2.  Build a response packet with\n              ACK set, place in AN.  Send\
    \ this packet and go to the\n              SYN-RECEIVED state.\n            -\
    \ A packet arrives with the SYN, ACK flags set.  Retrieve\n              the sender's\
    \ MDL he placed into the LENGTH field.  Set AN\n              to be received SN+1\
    \ modulo 2.  Build a response packet\n              with ACK set.  Set SN to be\
    \ SN+1 modulo 2, place SN and AN\n              into the header.  Remembering\
    \ the other end's MDL, build\n              data portion of packet.  Send this\
    \ packet and go to the\n              ESTABLISHED state.\n      5.2.3. SYN-RECEIVED\n\
    \         Arrived at from the LISTEN and SYN-SENT states in response to\n    \
    \     an arriving SYN packet.\n         Departures\n            - A CLOSE request\
    \ is made by the user.  Create a packet with\n              FIN set.  Send it\
    \ and go to the FIN-WAIT state.\n            - A packet arrives with the ACK flag\
    \ set.  This packet\n              acknowledges a previous SYN packet.  Go to\
    \ the ESTABLISHED\n              state.  The TCB should now note the connection\
    \ is fully\n              opened.\n            - A packet arrives with the FIN\
    \ flag set.  The other end has\n              decided to close the connection.\
    \  Create a packet with\n              FIN, ACK set.  Send it and go to the LAST-ACK\
    \ state.\n      5.2.4. ESTABLISHED\n         This state is the normal state for\
    \ a connection.  Data packets\n         may be exchanged in both directions (MDL\
    \ allowing).  It is\n         arrived at from the SYN-RECEIVED and SYN-SENT states\
    \ in\n         response to the completion of connection initiation.\n        \
    \ Departures\n            - In response to a CLOSE request from the user.  Set\
    \ AN to\n              be most recently received SN+1 modulo 2.  Build a packet\n\
    \              with FIN set.  Set SN to be SN+1 modulo 2, place SN and AN\n  \
    \            into the header and send the packet.  Go to the FIN-WAIT\n      \
    \        state.\n            - A packet containing a FIN is received.  Set AN\
    \ to be\n"
- title: RFC 916                                                     October 1984
  contents:
  - 'RFC 916                                                     October 1984

    '
- title: Reliable Asynchronous Transfer Protocol
  contents:
  - "Reliable Asynchronous Transfer Protocol\n              received SN+1 modulo 2.\
    \  Build a response packet with both\n              FIN and ACK set.  Set SN to\
    \ be SN+1 modulo 2, place SN and\n              AN into the header.  No data portion\
    \ is built.  Send this\n              packet and go to the LAST-ACK state.\n \
    \     5.2.5. FIN-WAIT\n         Arrived at from either the SYN-RECEIVED state\
    \ or from the\n         ESTABLISHED state.  In both cases the user had requested\
    \ a\n         CLOSE of the connection and a packet with a FIN was sent.\n    \
    \     Departures\n            - A FIN, ACK packet is received which acknowledges\
    \ the FIN\n              just sent.  Go to the TIME-WAIT state.\n            -\
    \ A FIN packet is received which indicates the other end of\n              the\
    \ connection has simultaneously decided to close.  Set\n              AN=received\
    \ SN+1 modulo 2, and SN=SN+1 modulo 2.  Send a\n              response packet\
    \ with the ACK set.  Go to the CLOSING\n              state.\n      5.2.6. LAST-ACK\n\
    \         Arrived at from the ESTABLISHED and SYN-RECEIVED states.\n         Departures\n\
    \            - An ACK is received for the last packet sent which was a\n     \
    \         FIN.  Delete the TCB and go to the CLOSED state.\n      5.2.7. CLOSING\n\
    \         Arrived at from the FIN-WAIT state.\n         Departures\n         \
    \   - An ACK is received for the last packet sent which was a\n              FIN.\
    \  Go to the TIME-WAIT state.\n      5.2.8. TIME-WAIT\n         Arrived at from\
    \ the FIN-WAIT and CLOSING states.\n"
- title: RFC 916                                                     October 1984
  contents:
  - 'RFC 916                                                     October 1984

    '
- title: Reliable Asynchronous Transfer Protocol
  contents:
  - "Reliable Asynchronous Transfer Protocol\n         Departures\n            - This\
    \ states waits until 2*SRTT time has passed.  It then\n              deletes the\
    \ TCB associated with the connection and goes to\n              the CLOSED state.\n\
    \      5.2.9. CLOSED\n         This state can be arrived at for a number of reasons:\
    \ 1) while\n         in the LISTEN state the user requests a CLOSE, 2) while in\
    \ the\n         SYN-SENT state the user requests a CLOSE, 3) while in the\n  \
    \       TIME-WAIT state the 2*SRTT time period has elapsed, and 4)\n         while\
    \ in the LAST-ACK state an arriving packet has an ACK of\n         the previously\
    \ sent FIN packet.\n         In this state no data is read or sent over the link.\
    \  To leave\n         this state requires an outside request to open a new\n \
    \        connection.\n         Departures\n            - User requests an active\
    \ OPEN.  Create a packet with SYN\n              set.  Choose your MDL and place\
    \ it into the LENGTH octet.\n              Choose your initial SN.  AN is immaterial.\
    \  Send this\n              packet and go to the SYN-SENT state.  The TCB for\
    \ this\n              connection is created.  The connection may be thought of\n\
    \              as half-open.  A STATUS request will return to the caller\n   \
    \           this information.\n            - User requests a passive OPEN.  The\
    \ TCB for this connection\n              is created.  The connection may be thought\
    \ of as\n              half-open.  A STATUS request will return to the caller\n\
    \              this information.  Go to the LISTEN state.\n"
- title: RFC 916                                                     October 1984
  contents:
  - 'RFC 916                                                     October 1984

    '
- title: Reliable Asynchronous Transfer Protocol
  contents:
  - "Reliable Asynchronous Transfer Protocol\n   5.3. State Behavior\n      This section\
    \ discusses in detail the behavior of each state in\n      response to the arrival\
    \ of a packet.  In what follows a packet is\n      not considered to have arrived\
    \ until it has passed a number of\n      tests (see the chapter entitled: Packet\
    \ Reception).\n      The method chosen to describe state behavior is tabular.\
    \  Each\n      state is listed opposite a sequence of named procedures to execute\n\
    \      whenever a packet has arrived.\n      STATE                BEHAVIOR\n \
    \     =============+========================\n      LISTEN       |  A\n      -------------+------------------------\n\
    \      SYN-SENT     |  B\n      -------------+------------------------\n     \
    \ SYN-RECEIVED |  C1  D1  E  F1  H1\n      -------------+------------------------\n\
    \      ESTABLISHED  |  C2  D2  E  F2  H2  I1\n      -------------+------------------------\n\
    \      FIN-WAIT     |  C2  D2  E  F3  H3\n      -------------+------------------------\n\
    \      LAST-ACK     |  C2  D3  E  F3  H4\n      -------------+------------------------\n\
    \      CLOSING      |  C2  D3  E  F3  H5\n      -------------+------------------------\n\
    \      TIME-WAIT    |  D3  E  F3 H6\n      -------------+------------------------\n\
    \      CLOSED       |  G\n      -------------+------------------------\n     \
    \ For example, in the ESTABLISHED state the arrival of a packet\n      causes\
    \ procedure C2 to be executed, then D2, then E, F2, H2, and\n      finally I1.\
    \  Any procedure may terminate the processing which\n      occurs or cause a state\
    \ change.  Note that these procedures are\n      executed in sequence, first C2,\
    \ then D2, etc.  The time ordering\n      cannot be mixed.\n      The particular\
    \ actions associated with each procedure are now\n      described.\n"
- title: RFC 916                                                     October 1984
  contents:
  - 'RFC 916                                                     October 1984

    '
- title: Reliable Asynchronous Transfer Protocol
  contents:
  - "Reliable Asynchronous Transfer Protocol\n      A  --------------------------------------------------------\n\
    \         This procedure details the behavior of the LISTEN state.  First\n  \
    \       check the packet for the RST flag.  If it is set then packet is\n    \
    \     discarded and ignored, return and continue the processing\n         associated\
    \ with this state.\n         We assume now that the RST flag was not set.  Check\
    \ the packet\n         for the ACK flag.  If it is set we have an illegal condition\n\
    \         since no connection has yet been opened.  Send a RST packet\n      \
    \   with the correct response SN value:\n            <SN=received AN><CTL=RST>\n\
    \         Return to the current state without any further processing.\n      \
    \   We assume now that neither the RST nor the ACK flags were set.\n         Check\
    \ the packet for a SYN flag.  If it is set then an attempt\n         is being\
    \ made to open a connection.  Create a TCB for this\n         connection.  The\
    \ sender has placed its MDL in the LENGTH field,\n         also specified is the\
    \ sender's initial SN value.  Retrieve and\n         place them into the TCB.\
    \  Note that the presence of the SO flag\n         is ignored since it has no\
    \ meaning when either of the SYN, RST,\n         or FIN flags are set.\n     \
    \    Send a SYN packet which acknowledges the SYN received.  Choose\n        \
    \ the initial SN value and the MDL for this end of the\n         connection:\n\
    \            <SN=0><AN=received SN+1 modulo 2><CTL=SYN, ACK><LENGTH=MDL>\n   \
    \      and go to the SYN-RECEIVED state without any further\n         processing.\n\
    \         Any packet not satisfying the above tests is discarded and\n       \
    \  ignored.  Return to the current state without any further\n         processing.\n"
- title: RFC 916                                                     October 1984
  contents:
  - 'RFC 916                                                     October 1984

    '
- title: Reliable Asynchronous Transfer Protocol
  contents:
  - "Reliable Asynchronous Transfer Protocol\n      B  --------------------------------------------------------\n\
    \         This procedure represents the behavior of the SYN-SENT state\n     \
    \    and is entered when this end of the connection decides to\n         execute\
    \ an active OPEN.\n         First, check the packet for the ACK flag.  If the\
    \ ACK flag is\n         set then check to see if the AN value was as expected.\
    \  If it\n         was continue below.  Otherwise the AN value was unexpected.\
    \  If\n         the RST flag was set then discard the packet and return to the\n\
    \         current state without any further processing, else send a\n        \
    \ reset:\n            <SN=received AN><CTL=RST>\n         Discard the packet and\
    \ return to the current state without any\n         further processing.\n    \
    \     At this point either the ACK flag was set and the AN value was\n       \
    \  as expected or ACK was not set.  Second, check the RST flag.\n         If the\
    \ RST flag is set there are two cases:\n            1. If the ACK flag is set\
    \ then discard the packet, flush the\n            retransmission queue, inform\
    \ the user \"Error: Connection\n            refused\", delete the TCB, and go\
    \ to the CLOSED state without\n            any further processing.\n         \
    \   2. If the ACK flag was not set then discard the packet and\n            return\
    \ to this state without any further processing.\n         At this point we assume\
    \ the packet contained an ACK which was\n         Ok, or there was no ACK, and\
    \ there was no RST.  Now check the\n         packet for the SYN flag.  If the\
    \ ACK flag was set then our SYN\n         has been acknowledged.  Store MDL received\
    \ in the TCB.  At this\n         point we are technically in the ESTABLISHED state.\
    \  Send an\n         acknowledgment packet and any initial data which is queued\
    \ to\n         send:\n            <SN=received AN><AN=received SN+1 modulo 2><CTL=ACK><DATA>\n\
    \         Go to the ESTABLISHED state without any further processing.\n      \
    \   If the SYN flag was set but the ACK was not set then the other\n         end\
    \ of the connection has executed an active open also.\n         Acknowledge the\
    \ SYN, choose your MDL, and send:\n            <SN=0><AN=received SN+1 modulo\
    \ 2><CTL=SYN, ACK><LENGTH=MDL>\n"
- title: RFC 916                                                     October 1984
  contents:
  - 'RFC 916                                                     October 1984

    '
- title: Reliable Asynchronous Transfer Protocol
  contents:
  - "Reliable Asynchronous Transfer Protocol\n         Go to the SYN-RECEIVED state\
    \ without any further processing.\n         Any packet not satisfying the above\
    \ tests is discarded and\n         ignored.  Return to the current state without\
    \ any further\n         processing.\n      C1 --------------------------------------------------------\n\
    \         Examine the received SN field value.  If the SN value was\n        \
    \ expected then return and continue the processing associated\n         with this\
    \ state.\n         We now assume the SN value was not what was expected.\n   \
    \      If either RST or FIN were set discard the packet and return to\n      \
    \   the current state without any further processing.\n         If neither RST\
    \ nor FIN flags were set it is assumed that this\n         packet is a duplicate\
    \ of one already received.  Send an ACK\n         back:\n            <SN=received\
    \ AN><AN=received SN+1 modulo 2><CTL=ACK>\n         Discard the duplicate packet\
    \ and return to the current state\n         without any further processing.\n\
    \      C2 --------------------------------------------------------\n         Examine\
    \ the received SN field value.  If the SN value was\n         expected then return\
    \ and continue the processing associated\n         with this state.\n        \
    \ We now assume the SN value was not what was expected.\n         If either RST\
    \ or FIN were set discard the packet and return to\n         the current state\
    \ without any further processing.\n         If SYN was set we assume that the\
    \ other end crashed and has\n         attempted to open a new connection.  We\
    \ respond by sending a\n         legal reset:\n            <SN=received AN><AN=received\
    \ SN+1 modulo 2><CTL=RST, ACK>\n         This will cause the other end, currently\
    \ in the SYN-SENT state,\n         to close.  Flush the retransmission queue,\
    \ inform the user\n         \"Error: Connection reset\", discard the packet, delete\
    \ the TCB,\n         and go to the CLOSED state without any further processing.\n"
- title: RFC 916                                                     October 1984
  contents:
  - 'RFC 916                                                     October 1984

    '
- title: Reliable Asynchronous Transfer Protocol
  contents:
  - "Reliable Asynchronous Transfer Protocol\n         If neither RST, FIN, nor SYN\
    \ flags were set it is assumed that\n         this packet is a duplicate of one\
    \ already received.  Send an\n         ACK back:\n            <SN=received AN><AN=received\
    \ SN+1 modulo 2><CTL=ACK>\n         Discard the duplicate packet and return to\
    \ the current state\n         without any further processing.\n      D1 --------------------------------------------------------\n\
    \         The packet is examined for a RST flag.  If RST is not set then\n   \
    \      return and continue the processing associated with this state.\n      \
    \   RST is now assumed to have been set.  If the connection was\n         originally\
    \ initiated from the LISTEN state (it was passively\n         opened) then flush\
    \ the retransmission queue, discard the\n         packet, and go to the LISTEN\
    \ state without any further\n         processing.\n         If instead the connection\
    \ was initiated actively (came from the\n         SYN-SENT state) then flush the\
    \ retransmission queue, inform the\n         user \"Error: Connection refused\"\
    , discard the packet, delete\n         the TCB, and go to the CLOSED state without\
    \ any further\n         processing.\n      D2 --------------------------------------------------------\n\
    \         The packet is examined for a RST flag.  If RST is not set then\n   \
    \      return and continue the processing associated with this state.\n      \
    \   RST is now assumed to have been set.  Any data remaining to be\n         sent\
    \ is flushed.  The retransmission queue is flushed, the user\n         is informed\
    \ \"Error: Connection reset.\", discard the packet,\n         delete the TCB,\
    \ and go to the CLOSED state without any further\n         processing.\n     \
    \ D3 --------------------------------------------------------\n         The packet\
    \ is examined for a RST flag.  If RST is not set then\n         return and continue\
    \ the processing associated with this state.\n         RST is now assumed to have\
    \ been set.  Discard the packet,\n         delete the TCB, and go to the CLOSED\
    \ state without any further\n         processing.\n"
- title: RFC 916                                                     October 1984
  contents:
  - 'RFC 916                                                     October 1984

    '
- title: Reliable Asynchronous Transfer Protocol
  contents:
  - "Reliable Asynchronous Transfer Protocol\n      E  --------------------------------------------------------\n\
    \         Check the presence of the SYN flag.  If the SYN flag is not set\n  \
    \       then return and continue the processing associated with this\n       \
    \  state.\n         We now assume that the SYN flag was set.  The presence of\
    \ a SYN\n         here is an error.  Flush the retransmission queue, send a legal\n\
    \         RST packet.\n            If the ACK flag was set then send:\n      \
    \         <SN=received AN><CTL=RST>\n            If the ACK flag was not set then\
    \ send:\n               <SN=0><CTL=RST>\n         The user should receive the\
    \ message \"Error: Connection reset.\",\n         then delete the TCB and go to\
    \ the CLOSED state without any\n         further processing.\n      F1 --------------------------------------------------------\n\
    \         Check the presence of the ACK flag.  If ACK is not set then\n      \
    \   discard the packet and return without any further processing.\n         We\
    \ now assume that the ACK flag was set.  If the AN field value\n         was as\
    \ expected then return and continue the processing\n         associated with this\
    \ state.\n         We now assume that the ACK flag was set and that the AN field\n\
    \         value was unexpected.  If the connection was originally\n         initiated\
    \ from the LISTEN state (it was passively opened) then\n         flush the retransmission\
    \ queue, discard the packet, and send a\n         legal RST packet:\n        \
    \    <SN=received AN><CTL=RST>\n         Then delete the TCB and go to the LISTEN\
    \ state without any\n         further processing.\n         Otherwise the connection\
    \ was initiated actively (came from the\n         SYN-SENT state) then inform\
    \ the user \"Error: Connection\n         refused\", flush the retransmission queue,\
    \ discard the packet,\n         and send a legal RST packet:\n"
- title: RFC 916                                                     October 1984
  contents:
  - 'RFC 916                                                     October 1984

    '
- title: Reliable Asynchronous Transfer Protocol
  contents:
  - "Reliable Asynchronous Transfer Protocol\n            <SN=received AN><CTL=RST>\n\
    \         Then delete the TCB and go to the CLOSED state without any\n       \
    \  further processing.\n      F2 --------------------------------------------------------\n\
    \         Check the presence of the ACK flag.  If ACK is not set then\n      \
    \   discard the packet and return without any further processing.\n         We\
    \ now assume that the ACK flag was set.  If the AN field value\n         was as\
    \ expected then flush the retransmission queue and inform\n         the user with\
    \ an \"Ok\" if a buffer has been entirely\n         acknowledged.  Another packet\
    \ containing data may now be sent.\n         Return and continue the processing\
    \ associated with this state.\n         We now assume that the ACK flag was set\
    \ and that the AN field\n         value was unexpected.  This is assumed to indicate\
    \ a duplicate\n         acknowledgment.  It is ignored, return and continue the\n\
    \         processing associated with this state.\n      F3 --------------------------------------------------------\n\
    \         Check the presence of the ACK flag.  If ACK is not set then\n      \
    \   discard the packet and return without any further processing.\n         We\
    \ now assume that the ACK flag was set.  If the AN field value\n         was as\
    \ expected then continue the processing associated with\n         this state.\n\
    \         We now assume that the ACK flag was set and that the AN field\n    \
    \     value was unexpected.  This is ignored, return and continue\n         with\
    \ the processing associated with this state.\n      G  --------------------------------------------------------\n\
    \         This procedure represents the behavior of the CLOSED state of a\n  \
    \       connection.  All incoming packets are discarded.  If the packet\n    \
    \     had the RST flag set take no action.  Otherwise it is necessary\n      \
    \   to build a RST packet.  Since this end is closed the other end\n         of\
    \ the connection has incorrect data about the state of the\n         connection\
    \ and should be so informed.\n            If the ACK flag was set then send:\n\
    \               <SN=received AN><CTL=RST>\n"
- title: RFC 916                                                     October 1984
  contents:
  - 'RFC 916                                                     October 1984

    '
- title: Reliable Asynchronous Transfer Protocol
  contents:
  - "Reliable Asynchronous Transfer Protocol\n            If the ACK flag was not\
    \ set then send:\n               <SN=0><AN=received SN+1 modulo 2><CTL=RST, ACK>\n\
    \         After sending the reset packet return to the current state\n       \
    \  without any further processing.\n      H1 --------------------------------------------------------\n\
    \         Our SYN has been acknowledged.  At this point we are\n         technically\
    \ in the ESTABLISHED state.  Send any initial data\n         which is queued to\
    \ send:\n            <SN=received AN><AN=received SN+1 modulo 2><CTL=ACK><DATA>\n\
    \         Go to the ESTABLISHED state and execute procedure I1 to process\n  \
    \       any data which might be in this packet.\n         Any packet not satisfying\
    \ the above tests is discarded and\n         ignored.  Return to the current state\
    \ without any further\n         processing.\n      H2 --------------------------------------------------------\n\
    \         Check the presence of the FIN flag.  If FIN is not set then\n      \
    \   continue the processing associated with this state.\n         We now assume\
    \ that the FIN flag was set.  This means the other\n         end has decided to\
    \ close the connection.  Flush the\n         retransmission queue.  If any data\
    \ remains to be sent then\n         inform the user \"Warning: Data left unsent.\"\
    \  The user must\n         also be informed \"Connection closing.\"  An acknowledgment\
    \ for\n         the FIN must be sent which also indicates this end is closing:\n\
    \            <SN=received AN><AN=received SN + 1 modulo 2><CTL=FIN, ACK>\n   \
    \      Go to the LAST-ACK state without any further processing.\n"
- title: RFC 916                                                     October 1984
  contents:
  - 'RFC 916                                                     October 1984

    '
- title: Reliable Asynchronous Transfer Protocol
  contents:
  - "Reliable Asynchronous Transfer Protocol\n      H3 --------------------------------------------------------\n\
    \         This state represents the final behavior of the FIN-WAIT state.\n  \
    \       If the packet did not contain a FIN we assume this packet is a\n     \
    \    duplicate and that the other end of the connection has not seen\n       \
    \  the FIN packet we sent earlier.  Rely upon retransmission of\n         our\
    \ earlier FIN packet to inform the other end of our desire to\n         close.\
    \  Discard the packet and return without any further\n         processing.\n \
    \        At this point we have a packet which should contain a FIN.  By\n    \
    \     the rules of this protocol an ACK of a FIN requires a FIN, ACK\n       \
    \  in response and no data.  If the packet contains data we have\n         detected\
    \ an illegal condition.  Send a reset:\n         <SN=received AN><AN=received\
    \ SN+1 modulo 2><CTL=RST, ACK>\n         Discard the packet, flush the retransmission\
    \ queue, inform the\n         user \"Error: Connection reset.\", delete the TCB,\
    \ and go to the\n         CLOSED state without any further processing.\n     \
    \    We now assume that the FIN flag was set and no data was\n         contained\
    \ in the packet.  If the AN field value was expected\n         then this packet\
    \ acknowledges a previously sent FIN packet.\n         The other end of the connection\
    \ is then also assumed to be\n         closing and expects an acknowledgment.\
    \  Send an acknowledgment\n         of the FIN:\n            <SN=received AN><AN=received\
    \ SN+1 modulo 2><CTL=ACK>\n         Start the 2*SRTT timer associated with the\
    \ TIME-WAIT state,\n         discard the packet, and go to the TIME-WAIT state\
    \ without any\n         further processing.\n         Otherwise the AN field value\
    \ was unexpected.  This indicates a\n         simultaneous closing by both sides\
    \ of the connection.  Send an\n         acknowledgment of the FIN:\n         \
    \   <SN=received AN><AN=received SN+1 modulo 2><CTL=ACK>\n         Discard the\
    \ packet, and go to the CLOSING state without any\n         further processing.\n"
- title: RFC 916                                                     October 1984
  contents:
  - 'RFC 916                                                     October 1984

    '
- title: Reliable Asynchronous Transfer Protocol
  contents:
  - "Reliable Asynchronous Transfer Protocol\n      H4 --------------------------------------------------------\n\
    \         This state represents the final behavior of the LAST-ACK state.\n  \
    \       If the AN field value is expected then this ACK is in response\n     \
    \    to the FIN, ACK packet recently sent.  This is the final\n         acknowledging\
    \ message indicating both side's agreement to close\n         the connection.\
    \  Discard the packet, flush all queues, delete\n         the TCB, and go to the\
    \ CLOSED state without any further\n         processing.\n         Otherwise the\
    \ AN field value was unexpected.  Discard the\n         packet and remain in the\
    \ current state without any further\n         processing.\n      H5 --------------------------------------------------------\n\
    \         This state represents the final behavior of the CLOSING state.\n   \
    \      If the AN field value was expected then this packet\n         acknowledges\
    \ the FIN packet recently sent.  This is the final\n         acknowledging message\
    \ indicating both side's agreement to close\n         the connection.  Start the\
    \ 2*SRTT timer associated with the\n         TIME-WAIT state, discard the packet,\
    \ and go to the TIME-WAIT\n         state without any further processing.\n  \
    \       Otherwise the AN field value was unexpected.  Discard the\n         packet\
    \ and remain in the current state without any further\n         processing.\n\
    \      H6 --------------------------------------------------------\n         This\
    \ state represents the behavior of the TIME-WAIT state.\n         Check the presence\
    \ of the ACK flag.  If ACK is not set then\n         discard the packet and return\
    \ without any further processing.\n         Check the presence of the FIN flag.\
    \  If FIN is not set then\n         discard the packet and return without any\
    \ further processing.\n         We now assume that the FIN flag was set.  This\
    \ situation\n         indicates that the last acknowledgment of the FIN packet\
    \ sent\n         by the other end of the connection did not arrive.  Resend the\n\
    \         acknowledgment:\n            <SN=received AN><AN=received SN+1 modulo\
    \ 2><CTL=ACK>\n"
- title: RFC 916                                                     October 1984
  contents:
  - 'RFC 916                                                     October 1984

    '
- title: Reliable Asynchronous Transfer Protocol
  contents:
  - "Reliable Asynchronous Transfer Protocol\n         Restart the 2*SRTT timer, discard\
    \ the packet, and remain in the\n         current state without any further processing.\n\
    \      I1 --------------------------------------------------------\n         This\
    \ represents that stage of processing in the ESTABLISHED\n         state in which\
    \ all the flag bits have been processed and only\n         data may remain.  The\
    \ packet is examined to see if it contains\n         data.  If not the packet\
    \ is now discarded, return to the\n         current state without any further\
    \ processing.\n         We assume the packet contained data, that either the SO\
    \ flag\n         was set or LENGTH is positive.  That data is placed into the\n\
    \         user's receive buffers.  As these become full the user should\n    \
    \     be informed \"Receive buffer full.\"  An acknowledgment is sent:\n     \
    \       <SN=received AN><AN=received SN+1 modulo 2><CTL=ACK>\n         If data\
    \ is queued to send then it is most efficient to\n         'piggyback' this acknowledgment\
    \ on that data packet.\n         The packet is now discarded, return to the ESTABLISHED\
    \ state\n         without any further processing.\n   5.4. Timers\n      There\
    \ are three timers associated with this protocol.  Their\n      purpose will now\
    \ be briefly discussed as will the actions taken\n      when a timer expires.\
    \  The particular nature these timeouts take\n      and the methods by which they\
    \ are set is the responsibility of the\n      protocol implementation.\n     \
    \ 5.4.1. User Timeout\n         For practical implementation reasons it is desirable\
    \ to have a\n         user controllable timeout associated with the successful\n\
    \         opening of a connection, successful acknowledgment of data, and\n  \
    \       successful closing of a connection.  Consider the situations in\n    \
    \     which a connection is so noisy that no data gets through, or a\n       \
    \  connection is physically cut.  Without an overriding timeout\n         these\
    \ situations would result in unbounded retransmissions.\n         When this timeout\
    \ expires the user is informed \"Error:\n         Connection aborted due to user\
    \ timeout.\", all queues are\n         flushed, the TCB is deleted, and the CLOSED\
    \ state is entered.\n"
- title: RFC 916                                                     October 1984
  contents:
  - 'RFC 916                                                     October 1984

    '
- title: Reliable Asynchronous Transfer Protocol
  contents:
  - "Reliable Asynchronous Transfer Protocol\n      5.4.2. Retransmission Timeout\n\
    \         This timer ensures that any packet sent for which the SN is\n      \
    \   significant is acknowledged.  When such a packet is sent it is\n         placed\
    \ in a retransmission queue and the retransmission timer\n         is begun. \
    \ If an acknowledgment has not arrived within the\n         timer's period then\
    \ the packet is retransmitted and the timer\n         is restarted.  If the acknowledgment\
    \ does arrive in time then\n         the timer is stopped and the packet is removed\
    \ from the\n         retransmission queue.  The next packet with a significant\
    \ SN\n         may now be sent.\n         This timeout is expected to operate\
    \ in conjunction with a\n         counter which keeps track of the number of times\
    \ a packet has\n         been retransmitted.  Normally an upper limit is set on\n\
    \         retransmissions.  If that limit is exceeded then the connection\n  \
    \       is aborted.  This event is similar to the user timeout.  The\n       \
    \  user is informed \"Error: Connection aborted due to\n         retransmission\
    \ failure\", all queues are flushed, the TCB is\n         deleted, and the CLOSED\
    \ state is entered.\n      5.4.3. TIME-WAIT Timeout\n         This timeout is\
    \ used to catch any FIN packets which might be\n         retransmitted from the\
    \ other end of a connection in response to\n         a dropped acknowledgment\
    \ packet.  The timeout period should be\n         at least as long as 2*SRTT.\
    \  After this timeout expires the\n         other end of the connection is assumed\
    \ to be closed, the TCB is\n         deleted, and this end enters the CLOSED state\
    \ also.\n"
- title: RFC 916                                                     October 1984
  contents:
  - 'RFC 916                                                     October 1984

    '
- title: Reliable Asynchronous Transfer Protocol
  contents:
  - 'Reliable Asynchronous Transfer Protocol

    '
- title: 6. Data Error Handling
  contents:
  - "6. Data Error Handling\n   This chapter discusses in detail the types of data\
    \ errors an\n   established connection may encounter.  These are distinct from\n\
    \   protocol errors discussed above.  In order of discussion these are:\n    \
    \  - Framing Errors\n      - Missing SYNCH pattern\n      - Unacknowledged packets\n\
    \      - Bad packets\n      - Duplicate packets\n      - Outside flow control\n\
    \      - Packets that are too large\n      - Packets that are too small\n   6.1.\
    \ Framing Errors\n      The RS-232 specification provides framing only for an\
    \ individual\n      octet.  Link level protocols for computer networking normally\n\
    \      provide framing for each packet.  The SYNCH pattern provides a\n      boundary\
    \ for the beginning of a packet.  No similar pattern was\n      chosen to mark\
    \ the end and completely frame the packet.\n      Any bit pattern can appear in\
    \ the data portion of a packet.  For\n      any particular pattern to reliably\
    \ mark the end of a packet that\n      terminating pattern cannot be allowed to\
    \ appear in the data.  This\n      is usually accomplished by the sender altering\
    \ any occurrence of\n      the terminating pattern in the data so that it is both\
    \ no longer\n      recognizable as that pattern and also restorable upon receipt.\n\
    \      Both the sender and the receiver are required by this technique to\n  \
    \    examine all the data.  In the absence of a protocol chip to\n      perform\
    \ this function, it is a source of some overhead.\n      6.1.1. Synthetic Framing\n\
    \         In the absence of framing, the end of the packet must be\n         synthetically\
    \ determined.  The start of a packet is indicated\n         by the SYNCH pattern.\
    \  The expected end of a packet can now\n         only be determined by examining\
    \ the LENGTH octet of the header.\n         It is important to know whether or\
    \ not the LENGTH data can be\n"
- title: RFC 916                                                     October 1984
  contents:
  - 'RFC 916                                                     October 1984

    '
- title: Reliable Asynchronous Transfer Protocol
  contents:
  - "Reliable Asynchronous Transfer Protocol\n         trusted.  This is accomplished\
    \ by employing a one octet header\n         checksum to cover the first two octets\
    \ following the SYNCH\n         pattern.  If the header passes the checksum test\
    \ and neither\n         the SYN, FIN, RST, nor SO flag bits were set then LENGTH\
    \ is\n         trusted and the number of octets expected beyond the header is\n\
    \         LENGTH+2. (For those packets in which any of the above flag\n      \
    \   bits are set the packet length is fixed and includes only a\n         header\
    \ portion.)\n         If the header fails the checksum test we are in some\n \
    \        difficulty.  The length is incorrect so it may be too small or\n    \
    \     too large.  To recover from this error do the following.\n         Beginning\
    \ immediately after the SYNCH pattern rescan looking\n         for the next SYNCH\
    \ pattern.  Throw away all octets until a\n         SYNCH is seen and then attempt\
    \ to reinterpret it as a packet.\n         The sender's retransmission timeout\
    \ guarantees that a new copy\n         of the packet will be transmitted.  This\
    \ ensures that in\n         discarding the initial SYNCH pattern, the SYNCH pattern\
    \ from\n         the beginning of the retransmitted packet will eventually be\n\
    \         seen.\n      6.1.2. Costs of Synthetic Framing\n         This framing\
    \ strategy causes no overhead unless data errors\n         occur in the packet.\
    \  This is presumed to be a low probability\n         occurrence.  In addition\
    \ it removes the overhead of both sender\n         and receiver passing over the\
    \ data to process any termination\n         pattern which might appear in the\
    \ data.\n         The worst case behavior would require a packet header to fail\n\
    \         its checksum, a new SYNCH pattern to appear in the next few\n      \
    \   octets, that header failing its checksum, etc., until the SYNCH\n        \
    \ pattern of the retransmitted packet were finally seen.\n         Consistently\
    \ bad behavior of this type indicates an extremely\n         noisy communications\
    \ link.\n   6.2. Missing SYNCH Pattern\n      Any valid packet must begin with\
    \ the SYNCH pattern.  Any receiver\n      must discard all input octets until\
    \ the SYNCH pattern is seen.\n      The data which immediately follows a SYNCH\
    \ pattern is interpreted\n      as a packet.  The header checksum test is applied,\
    \ then LENGTH+2\n      octets are read, the data checksum test is applied, etc.\n"
- title: RFC 916                                                     October 1984
  contents:
  - 'RFC 916                                                     October 1984

    '
- title: Reliable Asynchronous Transfer Protocol
  contents:
  - "Reliable Asynchronous Transfer Protocol\n   6.3. Unacknowledged Packets\n   \
    \   If an ACK for a packet is not obtained within the retransmission\n      timeout\
    \ interval that packet is retransmitted.  Because\n      significant variability\
    \ in response can be expected from either\n      end of a connection it is best\
    \ to dynamically calculate the\n      retransmission timeout interval.  An example\
    \ of such a calculation\n      is provided below.  The protocol will operate successfully,\n\
    \      although not with as high an effective transmission rate, if a\n      realistic\
    \ upper bound time is used instead.\n      A realistic upper bound time depends\
    \ upon the packet size and line\n      speed.  If the baud rate of the connection\
    \ is 300 or above let B\n      be the baud rate (for clarity assume it is the\
    \ same in both\n      directions), let L be the MDL of the receiver, let P be\
    \ the packet\n      processing time of the receiver.  Then an Upper Bound for\
    \ the\n      Reception Time (UBRT) is:\n         UBRT = L/(B/10) seconds + P seconds\n\
    \      and a realistic upper bound time is 2*UBRT seconds.\n      6.3.1. Calculation\
    \ of Retransmission Timeout Interval\n         For the purpose of detecting retransmission\
    \ time out the\n         protocol must have access to a clock which provides at\
    \ least\n         single second resolution.  One technique for calculating the\n\
    \         round trip time is:\n            Measure the elapsed time between sending\
    \ a packet with a\n            particular SN and receiving an ACK with an AN which\
    \ covers\n            that SN.  The measured elapsed time is the Round Trip Time\n\
    \            (RTT).  Next a Smoothed Round Trip Time (SRTT) is calculated\n  \
    \          as:\n               SRTT = (ALPHA * SRTT) + ((1- ALPHA) * RTT)\n  \
    \          and based upon this you compute the Retransmission Time Out\n     \
    \       (RTO) as:\n               RTO = min[UBOUND, max[LBOUND, (BETA * SRTT)]]\n\
    \            where UBOUND is an upper bound on the timeout (e.g., 1\n        \
    \    minute), LBOUND is a lower bound on the timeout (e.g., 1\n            second),\
    \ ALPHA is a smoothing factor (e.g., .8 to .9), and\n            BETA is a delay\
    \ variance factor (e.g., 1.3 to 2.0).\n"
- title: RFC 916                                                     October 1984
  contents:
  - 'RFC 916                                                     October 1984

    '
- title: Reliable Asynchronous Transfer Protocol
  contents:
  - "Reliable Asynchronous Transfer Protocol\n   6.4. Bad Packets\n      A bad packet\
    \ is received when it fails either the header or data\n      checksum tests. \
    \ When this happens the sender will retransmit the\n      packet after the retransmission\
    \ timeout interval.\n   6.5. Duplicate Packets\n      A duplicate packet is a\
    \ packet which passes the checksum tests but\n      for which the SN received\
    \ is significant but not the expected\n      value.  This is normally caused when\
    \ the sender did not get the\n      ACK last sent by the receiver.  This situation\
    \ is diagrammed\n      below.\n      Side A                                  \
    \           Side B\n      ESTABLISHED                                        ESTABLISHED\n\
    \      1.      --> <SN=1><AN=0><CTL=ACK><DATA>       ...\n                   \
    \                                 -->\n      2.      XXX <SN=0><AN=0><CTL=ACK><OTHER-DATA>\
    \ <--\n      3. (after SRTT)\n              --> <SN=1><AN=0><CTL=ACK><DATA>  \
    \     ...\n      4.                                            -->\n         \
    \     ... <SN=0><AN=0><CTL=ACK><OTHER-DATA> <--\n      5.      <--\n      In line\
    \ 2, B's packet was lost in transit, it may have failed its\n      checksum tests\
    \ when it reached A or its initial SYNCH pattern was\n      smashed, etc..  In\
    \ line 3 side A comes to the decision that its\n      packet from line 1 was not\
    \ received after SRTT time passes and\n      retransmits that packet.\n      In\
    \ line 4 side B receives the packet.  It detects a duplicate\n      because it\
    \ already sent a packet acknowledging A's SN=1 (although\n      that packet was\
    \ lost).  B now discards the duplicate and\n      immediately retransmits its\
    \ last packet to A. Side A finally\n      receives the retransmitted packet in\
    \ line 5.\n"
- title: RFC 916                                                     October 1984
  contents:
  - 'RFC 916                                                     October 1984

    '
- title: Reliable Asynchronous Transfer Protocol
  contents:
  - "Reliable Asynchronous Transfer Protocol\n   6.6. Outside Flow Control\n     \
    \ There are many large computer systems which make use of flow\n      control\
    \ to regulate their input side of an RS-232 link.  Flow\n      control based upon\
    \ two special characters such as <Ctrl-S> (ASCII\n      DC3) and <Ctrl-Q> (ASCII\
    \ DC1) is almost universally in use today.\n      So it becomes important for\
    \ the protocol to be able to either:\n         (1) Recognize and obey the flow\
    \ control of the host\n             computer(s), or\n         (2) Ignore the flow\
    \ control but still guarantee reliable data\n             reception.\n      It\
    \ is the latter approach which this protocol takes.  This\n      decision was\
    \ made because the number of differing flow control\n      characters in use would\
    \ make it difficult to obey them all.\n         There is a particular type of\
    \ flow control with which this\n         protocol will not operate.  The ENQUIRE,\
    \ ACKNOWLEDGE method of\n         flow control requires that the receiver of an\
    \ inquiry respond\n         with an acknowledge before any more data will be sent\
    \ to it.\n         This type of flow control also usually prohibits unrestricted\n\
    \         8-bit data transmission because the inquiry character is\n         forbidden\
    \ as a data byte.\n      For the other class of flow control methods a proof is\
    \ required\n      that data may still be reliably transmitted and received if\
    \ flow\n      control is ignored.  For the purposes of this discussion assume\n\
    \      <Ctrl-S> is sent when the receiving end of the connection wishes\n    \
    \  the sender to stop transmitting.  A <Ctrl-Q> is sent when the\n      receiver\
    \ wishes the sender to resume.  The choice of these\n      particular two characters\
    \ is arbitrary.  If the sender does not\n      immediately cease transmission\
    \ upon receipt of the <Ctrl-S>,\n      characters may be discarded.  Since this\
    \ protocol chooses to\n      ignore the flow control characters any part of a\
    \ packet may be\n      discarded.\n      More precisely stated consider X to be\
    \ the receiver and Y to be\n      the sender.  The packet sent is represented\
    \ by the string abc\n      where a, b, and c are data segments of unspecified\
    \ size.  X may\n      receive one of:\n         1. abc\n         2. ab\n     \
    \    3. ac\n         4. bc\n"
- title: RFC 916                                                     October 1984
  contents:
  - 'RFC 916                                                     October 1984

    '
- title: Reliable Asynchronous Transfer Protocol
  contents:
  - "Reliable Asynchronous Transfer Protocol\n      For case [1] the correct data\
    \ is received and no special action\n      need be taken.\n      For cases [2],\
    \ [3], and [4] we have a situation identical to data\n      dropped during transmission.\
    \  This is handled by the same\n      checksum, time-out and retransmission strategy\
    \ already described.\n      Assume Y is not now in the act of receiving a packet,\
    \ then Y sees\n      the two characters <Ctrl-S> and <Ctrl-Q> appear as input\
    \ in that\n      order.  Y is waiting for a message to appear and so expects to\
    \ see\n      a SYNCH pattern.  If the two characters \"<Ctrl-S><Ctrl-Q>\" are\
    \ not\n      part of a SYNCH pattern then they will be immediately discarded.\n\
    \      If Y is receiving a packet then the <Ctrl-S> and <Ctrl-Q> are seen\n  \
    \    to be added noise characters and would be detected by the checksum\n    \
    \  tests.  The packet being received would require retransmission.\n      The\
    \ question of which character to pick for the SYNCH pattern is\n      slightly\
    \ muddied by the above observation.  To the author's\n      knowledge <SOH> is\
    \ rarely if ever picked for flow control.  This\n      is part of the motivation\
    \ in using it as the SYNCH pattern.\n      How does one guarantee that any data\
    \ will actually arrive\n      successfully?  The initial choice of maximum data\
    \ counts during\n      connection establishment is very important.  Some knowledge\
    \ of\n      one's own operating system must be assumed.  If it is known for\n\
    \      example, that streams of data in excess of a certain length will\n    \
    \  often trigger flow control at the connection baud rate, then the\n      maximum\
    \ data count should be chosen sufficiently lower that flow\n      control rarely\
    \ will be employed.  An intelligent choice of the\n      maximum data count will\
    \ guarantee that some packets will arrive\n      without encountering flow control.\n\
    \   6.7. Packets that are too Large\n      Assume a packet arrives which passes\
    \ its header checksum test but\n      whose LENGTH is larger than the MDL of the\
    \ receiver.  In such a\n      case the sender has violated the protocol or a packet\
    \ has a data\n      error in the LENGTH octet and has passed the header checksum\
    \ test.\n      The latter is unlikely so that we assume the former.  The receiver\n\
    \      will abort his connection.  The sender must inform the user\n      \"Error:\
    \ Connection aborted due to MDL error\", and go to the CLOSED\n      state.\n\
    \      When the MDL is exceeded the receiver will transmit a legal reset:\n  \
    \       <SN=received AN><CTL=RST>\n"
- title: RFC 916                                                     October 1984
  contents:
  - 'RFC 916                                                     October 1984

    '
- title: Reliable Asynchronous Transfer Protocol
  contents:
  - "Reliable Asynchronous Transfer Protocol\n   6.8. Packets that are too Small\n\
    \      Assume that a packet has passed its header checksum test but some\n   \
    \   of the data octets have been dropped by the link.  In such a case\n      the\
    \ receiver's routine which reads data and builds packets is\n      expecting octets\
    \ which do not arrive.  After SRTT the sender will\n      retransmit this packet\
    \ to the receiver.  The receiver will now\n      have enough data to complete\
    \ the packet.  Almost certainly however\n      it will fail the data checksum\
    \ test.  As with any bad packet the\n      receiver will rescan from the octet\
    \ immediately following the\n      SYNCH pattern for the next SYNCH pattern. \
    \ In this manner the\n      receiver will eventually see the SYNCH pattern of\
    \ the\n      retransmitted packet.\n"
- title: RFC 916                                                     October 1984
  contents:
  - 'RFC 916                                                     October 1984

    '
- title: Reliable Asynchronous Transfer Protocol
  contents:
  - 'Reliable Asynchronous Transfer Protocol

    '
- title: I.  Inability to Transmit/Receive 8-bit Data
  contents:
  - "I.  Inability to Transmit/Receive 8-bit Data\n   There are some older operating\
    \ systems and devices which do not\n   permit 8-bit communication over an RS-232\
    \ link.  Most of these allow\n   restricted 7-bit communication.  Where this is\
    \ an unavoidable problem\n   both ends of the connection must have a protocol\
    \ layer beneath this\n   protocol.  This lower layer will unpack packets it sends\
    \ over the\n   RS-232 link.  It will also repack packets it receives over the\
    \ RS-232\n   link.  RATP will automatically determine whether or not full 8-bit\
    \ or\n   restricted 7-bit communication is being used (see below).\n   The strategy\
    \ chosen for restricted 7-bit communication is called 4/8\n   packing.  That is,\
    \ each octet to be sent will be broken up into two\n   4-bit nibbles.  The order\
    \ of transmission is the high order four bits\n   followed by the low order bits.\
    \  Each octet to be received will be\n   repacked by the inverse function.  The\
    \ high order nibble will be\n   received first then the low order nibble.  These\
    \ two nibbles will be\n   reassembled into an octet.\n   I.1.  Encoding for Transmission\n\
    \      For those systems which are incapable of 8-bit data transmission\n    \
    \  over RS-232 links, there are operating systems which in addition\n      place\
    \ special restrictions on the non-printable ASCII characters.\n      The encoding\
    \ for 4/8 packing should restrict itself to\n      transmitting data only in the\
    \ printable 7-bit ASCII range.\n   I.2.  Framing an Octet\n      The seventh and\
    \ highest order bit of a transmitted 7-bit ASCII\n      byte is a flag used to\
    \ indicate whether the high or low order\n      nibble of an octet is contained\
    \ in this character.  This flag bit\n      if set implies that a new octet is\
    \ being received and that this\n      printable ASCII character contains the high\
    \ order nibble of an\n      octet in its four low order bits.  In addition it\
    \ implies the next\n      ASCII character received should not have its highest\
    \ order bit\n      set.\n      This high order flag bit is set by adding the ASCII\
    \ character \"@\"\n      (octal 100) to a data byte.  Thus the first nibble of\
    \ an octet is\n      always transmitted with \"@\" added to its value.  The high\
    \ order\n      nibble will be transformed into the characters \"@\" through letter\n\
    \      \"O\".\n      The lower order nibble of an octet is transmitted with zero\
    \ \"0\"\n      added to its value.  The low order nibble will be transformed into\n"
- title: RFC 916                                                     October 1984
  contents:
  - 'RFC 916                                                     October 1984

    '
- title: Reliable Asynchronous Transfer Protocol
  contents:
  - "Reliable Asynchronous Transfer Protocol\n      characters \"0\" through \"?\"\
    .  When receiving 4/8 packed data, any\n      characters not within the range\
    \ \"0\" through letter \"O\" are\n      discarded.\n      The octet whose octal\
    \ value is 45 will be transmitted as two 7-bit\n      printable ASCII characters:\n\
    \                 +-------------+\n      High order |1|0|0|0|1|0|0| First transmitted\
    \ (\"@\" + data) = D\n                 +-------------+\n      Low order  |0|1|1|0|1|0|1|\
    \ Second transmitted (\"0\" + data) = 5\n                 +-------------+\n  \
    \    Since data bytes may be dropped or added at any time it is\n      important\
    \ to know always which portion of an octet is expected and\n      to deliver only\
    \ complete octets to the higher protocol level.  If\n      a single 7-bit character\
    \ were completely dropped without being\n      noticed the data stream delivered\
    \ to the higher level could be\n      shifted by an odd multiple of four bits.\
    \  In the worst case this\n      condition could remain indefinitely and the higher\
    \ level would\n      never receive an octet correctly.  In such a case no packets\
    \ would\n      be correctly received, leading to an unusable connection.\n   \
    \   To avoid this problem octets are assembled using a state machine\n      driven\
    \ by the presence of the high order flag bit.  The presence\n      of that bit\
    \ in the 7-bit printable character indicates the\n      beginning of a new octet.\
    \  The two state machine which assembles\n      octets is described below.  A\
    \ byte received with the high order\n      flag bit set is called \"HIGH\", the\
    \ byte without \"LOW\".\n         State 0\n            [Start state] Read a byte\
    \ from the legal restricted set.\n            This is determined by seeing if\
    \ the byte is in the legal\n            range \"@\" to the letter \"O\".  If it\
    \ was not discard the byte\n            and return to this state.\n          \
    \  A HIGH byte was read.  Place the four low order bits of the\n            byte\
    \ into the four high order bits of the assembled octet\n            and go to\
    \ state 1.  Otherwise discard the byte and return to\n            this state.\n"
- title: RFC 916                                                     October 1984
  contents:
  - 'RFC 916                                                     October 1984

    '
- title: Reliable Asynchronous Transfer Protocol
  contents:
  - "Reliable Asynchronous Transfer Protocol\n         State 1\n            Read a\
    \ byte from the legal restricted set.  This is\n            determined by seeing\
    \ if the byte is in the legal range zero\n            \"0\" to the letter \"O\"\
    .  If it was not discard the byte and\n            return to this state.\n   \
    \         If a LOW byte was read subtract zero \"0\" from the byte\n         \
    \   placing the four low order bits of the result into the four\n            low\
    \ order bits of the assembled octet.  A full octet has now\n            been assembled.\
    \  Pass the octet to the higher level and go\n            to state 0.\n      \
    \      Otherwise a HIGH byte was read.  Place the four low order\n           \
    \ bits of the byte into the four high order bits of the\n            assembled\
    \ octet and return to this state.\n      Utilizing this state machine to receive\
    \ 4/8 packed data ensures\n      that the data stream delivered to the higher\
    \ level will not\n      permanently remain shifted an odd multiple of four bits.\
    \  The\n      restriction placed upon bytes read removes obviously bad data and\n\
    \      in some cases would handle uncontrolled padding or blocking\n      insertion.\n\
    \   I.3.  Automatic Detection of 8-bit or 4/8 Packed Data\n      It is an unavoidable\
    \ problem that some machines cannot handle\n      unrestricted 8-bit data.  Since\
    \ this is given, it is desirable to\n      be able to automatically detect whether\
    \ unrestricted 8-bit or\n      restricted 4/8 packing is being used to transmit\
    \ data on a\n      connection.  For the purposes of this discussion those machines\n\
    \      capable of transmitting and receiving both unrestricted 8-bit and\n   \
    \   4/8 packed data are called smart.  Machines are called dumb if\n      they\
    \ can only transmit and receive 4/8 packed data.\n      When initiating a connection\
    \ there are four possible machine\n      configurations and they are:\n      \
    \   1. A (smart) opens a connection to B (smart).\n         2. A (dumb) opens\
    \ a connection to B (smart).\n         3. A (dumb) opens a connection to B (dumb).\n\
    \         4. A (smart) opens a connection to B (dumb).\n"
- title: RFC 916                                                     October 1984
  contents:
  - 'RFC 916                                                     October 1984

    '
- title: Reliable Asynchronous Transfer Protocol
  contents:
  - "Reliable Asynchronous Transfer Protocol\n      Each case is examined and extensions\
    \ to the behavior for the\n      LISTEN and SYN-SENT states are provided which\
    \ allow both types of\n      machines to initiate or receive a connection.\n \
    \     Cases 1 and 2: LISTEN Behavior for a Smart Machine\n         In these cases\
    \ machine A initiates a connection to B who is\n         assumed to be in the\
    \ LISTEN state.  B must be able to passively\n         detect whether 8-bit or\
    \ 4/8 packing is being used and respond\n         accordingly.  The method B uses\
    \ relies upon the detection of a\n         valid first packet.  In the LISTEN\
    \ state B attempts to\n         simultaneously treat the incoming data as if it\
    \ were both\n         unrestricted 8-bit and 4/8 packed.\n         The incoming\
    \ data is in effect fed to two different receiving\n         algorithms.  The\
    \ detection of a valid header will occur to one\n         of these algorithms\
    \ before the other.  If the first valid\n         header was read assuming unrestricted\
    \ 8-bit data then any\n         resulting connection is assumed to use unrestricted\
    \ 8-bit data\n         for the life of the connection.  If the first valid header\n\
    \         assumed 4/8 packing then the resulting connection is assumed to\n  \
    \       use 4/8 packing for the life of the connection.  In the case of\n    \
    \     the detection of illegal condition in the LISTEN state the\n         protocol\
    \ will reply with a RST packet in kind.\n      Case 3: LISTEN Behavior for a Dumb\
    \ Machine\n         In this case machine B is the recipient of a connection request\n\
    \         and is capable of handling only 4/8 packed data.  The LISTEN\n     \
    \    behavior for machine B assumes that all connections are 4/8\n         packed.\
    \  It never deals with unrestricted 8-bit data.  As a\n         result it will\
    \ refuse to open a connection request from a smart\n         machine (see case\
    \ 4 below).\n      Case 4: SYN-SENT Behavior for a Smart Machine\n         In\
    \ this case machine A attempts to open a connection to machine\n         B. However,\
    \ A has no knowledge of B's capabilities.  A will\n         send its connection\
    \ request assuming B is smart using\n         unrestricted 8-bit transmission.\
    \  It will await a reply\n         assuming the response will be unrestricted\
    \ 8-bit also.  If B is\n         in fact dumb it will not return a SYN-ACK because\
    \ of the\n         restriction imposed by case 3 above.  If no connection is made\n\
    \         with B using 8-bit data the entire connection initiation is\n      \
    \   restarted assuming B is dumb, 4/8 packing is used and the\n         response\
    \ is assumed to be 4/8 packed as well.\n"
- title: RFC 916                                                     October 1984
  contents:
  - 'RFC 916                                                     October 1984

    '
- title: Reliable Asynchronous Transfer Protocol
  contents:
  - "Reliable Asynchronous Transfer Protocol\n         The cost of this approach is\
    \ a longer time to determine whether\n         or not it is possible to open a\
    \ connection to B. It is twice as\n         long.  The advantages of being able\
    \ to automatically adjust to\n         either unrestricted 8-bit or 4/8 packed\
    \ data out weigh this\n         disadvantage.  RATP will not exhibit the schizophrenic\
    \ behavior\n         of many other asynchronous protocols when dealing with both\n\
    \         classes of machines.\n"
- title: RFC 916                                                     October 1984
  contents:
  - 'RFC 916                                                     October 1984

    '
- title: Reliable Asynchronous Transfer Protocol
  contents:
  - 'Reliable Asynchronous Transfer Protocol

    '
- title: II.  A Brief Survey of Some Asynchronous Link Protocols
  contents:
  - "II.  A Brief Survey of Some Asynchronous Link Protocols\n   II.1.  DDCMP\n  \
    \    DDCMP, Copyright (c) 1978 Digital Equipment Corporation [DDCMP\n      78],\
    \ is a reliable point-to-point and multi-point transmission\n      protocol is\
    \ used by many of that manufacturer's computers.  DDCMP\n      does provide reliable\
    \ asynchronous two way data transmission.\n      Some of the decisions taken in\
    \ the design of DDCMP reflect its\n      orientation toward multi-point data links.\
    \  This leads to headers\n      which are substantially longer than needed for\
    \ two way\n      point-to-point communications.\n      DDCMP allows as many as\
    \ 255 outstanding unacknowledged messages.\n      DDCMP does specifically mention\
    \ that a particular end of a\n      connection may choose to limit the send queue\
    \ to one outstanding\n      unacknowledged message.  It also allows sending a\
    \ stream of\n      outstanding unacknowledged packets.  Unless all RS-232\n  \
    \    implementations of DDCMP were limited to a single outstanding\n      packet,\
    \ the collision with existing flow control restrictions\n      could lead to very\
    \ low thruput. (DDCMP is assumed to have control\n      over the link driver.\
    \  Dealing with various differing flow control\n      mechanisms is not a consideration.)\n\
    \      DDCMP uses a CRC polynomial for data protection which is difficult\n  \
    \    to calculate for many machines without special hardware [TCP\n      Checksum\
    \ 78].  Many Digital Equipment computers have such\n      hardware.\n      DDCMP\
    \ does not provide the receiver with the ability to restrict\n      incoming packet\
    \ size.  It is true that all the higher level\n      protocols built on top of\
    \ DDCMP could separately negotiate packet\n      size.  But this burden would\
    \ then be moved away from the link\n      level where it properly resides.\n \
    \     Generally, a full implementation of DDCMP is too complex for\n      consideration.\
    \  If one were to implement 'part' of the protocol\n      then issues of compatibility\
    \ with already existing implementations\n      on other computers are raised.\n"
- title: RFC 916                                                     October 1984
  contents:
  - 'RFC 916                                                     October 1984

    '
- title: Reliable Asynchronous Transfer Protocol
  contents:
  - "Reliable Asynchronous Transfer Protocol\n   II.2.  MODEM Protocol\n      This\
    \ is a protocol in common use amongst microcomputers.  The\n      description\
    \ here comes from\n         MODEM/XMODEM Protocol Explained by Kelly Smith, CP/M-Net\n\
    \         \"SYSOP\" January 8,1980\n         .... Data is sent in 128-byte sequentially\
    \ numbered blocks,\n         with a single checksum byte appended to the end of\
    \ each block.\n         As the receiving computer acquires the incoming data,\
    \ it\n         performs its own checksum and upon each completion of a block,\n\
    \         it compares its checksum result with that of the sending\n         computers.\
    \  If the receiving computer matches the checksum of\n         the sending computer,\
    \ it transmits an ACK (ASCII code protocol\n         character for ACKNOWLEDGE\
    \ (06 Hex, Control-F)) back to the\n         sending computer.  The ACK therefore\
    \ means \"all's well on this\n         end, send some more...\".\n         The\
    \ sending computer will transmit an \"initial NAK\" (ASCII\n         protocol\
    \ character for NEGATIVE ACKNOWLEDGE (15 Hex,\n         Control-U))...or, \"that\
    \ wasn't quite right, please send again\".\n         Due to the asynchronous nature\
    \ of the initial \"hook-up\" between\n         the two computers, the receiving\
    \ computer will \"time-out\"\n         looking for data, and send the NAK as the\
    \ \"cue\" for the sending\n         computer to begin transmission.  The sending\
    \ computer knows\n         that the receiving computer will \"time-out\", and\
    \ uses this fact\n         to \"get in sync\"...  The sending computer responds\
    \ to the\n         \"initial NAK\" with a SOH (ASCII code protocol character for\n\
    \         START OF HEADING (01 Hex, Control-A)), sends the first block\n     \
    \    number, sends the 1's complement of the block number, sends 128\n       \
    \  bytes of 8 bit data, and finally a checksum, where the checksum\n         is\
    \ calculated by summing the SOH, the block number, the block\n         number\
    \ 1's complement, and the 128 bytes of data.\n         Receiving Computer:\n \
    \           ---/NAK/------------------------/ACK/------------------\n        \
    \        15H                          06H\n         Sending Computer:\n      \
    \      ---/SOH/BLK#/BLK#/DATA/CSUM/---/SOH/BLK#/BLK#/DATA/etc.\n             \
    \   01H 01H  FEH  8bit 8bit     01H 02H  FDH  8bit ....\n"
- title: RFC 916                                                     October 1984
  contents:
  - 'RFC 916                                                     October 1984

    '
- title: Reliable Asynchronous Transfer Protocol
  contents:
  - "Reliable Asynchronous Transfer Protocol\n         This process continues, with\
    \ the next 128 bytes.  If the block\n         was ACK'ed by the receiving computer,\
    \ and then the next\n         sequential block number and its 1's complement,\
    \ etc. ....\n      As can be seen from this partial description the MODEM protocol\
    \ is\n      unidirectional, data can only pass from the sender to the receiver\n\
    \      in a stream.  In order for data to flow simultaneously in the\n      other\
    \ direction another connection over another RS-232 line would\n      be required.\n\
    \      In addition this protocol is restricted to a fixed 128 octet\n      packet\
    \ size.  Many front-end concentrators are unable to service\n      such large\
    \ incoming packets.  It has been observed many times that\n      the concentrator\
    \ of a busy DECsystem-20 can invoke flow control on\n      input at 1200 baud\
    \ for packets as small as 64 characters.\n   II.3.  KERMIT System\n      The KERMIT\
    \ system, Copyright (c) 1981 Columbia University, is a\n      file transfer environment\
    \ developed recently.  It has\n      implementations which run on DECsystem-20,\
    \ IBM 370 VM/CMS, 8080\n      CP/M based systems, and the IBM PC among others.\n\
    \      KERMIT combines both the reliable transfer and file transfer into\n   \
    \   a single package.  Extension to other applications and higher\n      level\
    \ protocols would be possible but the boundary between the\n      reliable transfer\
    \ and application layers is very indistinct.  It\n      violates the layering\
    \ design strategy the Internet employs.\n      There is a limitation of transmission\
    \ to the restricted printable\n      ASCII set for certain computers but not for\
    \ others.  This leads to\n      confusion.  KERMIT allows both restricted ASCII\
    \ and 8-bit\n      transmission.\n      The KERMIT protocol does have a method\
    \ of setting MDL at\n      connection initiation.  It is limited to a smaller\
    \ maximum packet\n      size, 96 as opposed to 261 octets.  Kermit originally\
    \ used a\n      checksumming algorithm limited to six bits.  This is considered\
    \ to\n      provide too low a level of error detection capability for data\n \
    \     packets.  Kermit now allows two other checksumming algorithms in\n     \
    \ addition to the original.  There must be a negotiation between\n      sender\
    \ and receiver regarding which algorithm to use.\n      The KERMIT protocol does\
    \ not appear to make provision for both\n      sides of a connection attempting\
    \ an active open simultaneously.\n      One side must be an initial \"sending\
    \ Kermit\" and the other a\n      \"receiving Kermit\".  The code published as\
    \ a KERMIT implementation\n"
- title: RFC 916                                                     October 1984
  contents:
  - 'RFC 916                                                     October 1984

    '
- title: Reliable Asynchronous Transfer Protocol
  contents:
  - "Reliable Asynchronous Transfer Protocol\n      guide cannot recover from simultaneous\
    \ active opens, it\n      immediately ABORTs.  This reflects a bias towards unidirectional\n\
    \      data flow.\n      The KERMIT packet type (similar to RATP control flags)\
    \ specifies\n      whether an ACK/NAK is contained in the packet, or data, etc.\n\
    \      These are mutually exclusive and piggybacking an ACK on a data\n      packet\
    \ is not possible.  This can be a source of overhead.  In\n      addition KERMIT\
    \ restricts the sender to a single outstanding\n      unacknowledged packet as\
    \ does RATP.  It allocates an entire byte\n      to the sequence number which\
    \ is unnecessary.\n      On the subject of error recovery, the size of a packet\
    \ is\n      contained in the second byte of the packet and is not protected by\n\
    \      a header checksum.  If the length field was in error due to noise\n   \
    \   on the link, it could be longer than the correct packet size.  The\n     \
    \ code published as the KERMIT implementation guide relies upon the\n      detection\
    \ of the <SOH> character anywhere in a packet to indicate\n      the beginning\
    \ of a packet header.  It re-SYNCHs using this\n      technique.  This is only\
    \ possible if binary data in a packet is\n      quoted.  If full eight bit data\
    \ is transmitted it does not appear\n      that the KERMIT protocol rescans for\
    \ a new MARK (SYNCH) character\n      within the bad packet data just consumed.\
    \  It will under these\n      circumstances throw away the retransmitted packet\
    \ or portions\n      thereof.  Re-SYNCHing under such conditions is problematical.\n"
- title: RFC 916                                                     October 1984
  contents:
  - 'RFC 916                                                     October 1984

    '
- title: Reliable Asynchronous Transfer Protocol
  contents:
  - 'Reliable Asynchronous Transfer Protocol

    '
- title: REFERENCES
  contents:
  - "REFERENCES\n   [Cohen 81]\n      Cohen, D. On Holy Wars and a Plea for Peace.\
    \ IEEE Computer,\n      October, 1981.\n   [DDCMP 78]\n      DDCMP AA-D599A-TC\
    \ edition, Digital Equipment Corporation, 1978.\n      Version 4.0.\n   [IP 81]\n\
    \      Postel, J. DOD Standard Internet Protocol [RFC-791] Defense\n      Advanced\
    \ Research Projects Agency, 1981.\n   [TCP 81]\n      Postel, J. Transmission\
    \ Control Protocol [RFC-793] Defense\n      Advanced Research Projects Agency,\
    \ 1981.\n   [TCP Checksum 78]\n      Plummer, W. W. TCP Checksum Function Design.\
    \ Technical Report,\n      Bolt Beranek and Newman, Inc., 1978.\n"
- title: EDITORS NOTES
  contents:
  - "EDITORS NOTES\n   This memo was prepared in essentially this form in June 1983,\
    \ and set\n   aside.  Distribution at this time is prompted by the the \"Thinwire\"\
    \n   proposal described in RFC-914.\n   --jon postel\n"
