- title: __initial_text__
  contents:
  - "               Internet X.509 Public Key Infrastructure:\n                  \
    \    Certification Path Building\n"
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This memo provides information for the Internet community.\
    \  It does\n   not specify an Internet standard of any kind.  Distribution of\
    \ this\n   memo is unlimited.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (C) The Internet Society (2005).\n"
- title: Abstract
  contents:
  - "Abstract\n   This document provides guidance and recommendations to developers\n\
    \   building X.509 public-key certification paths within their\n   applications.\
    \  By following the guidance and recommendations defined\n   in this document,\
    \ an application developer is more likely to develop\n   a robust X.509 certificate-enabled\
    \ application that can build valid\n   certification paths across a wide range\
    \ of PKI environments.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   2. Certification Path Building ....................................15\n\
    \      2.1. Introduction to Certification Path Building ...............15\n  \
    \    2.2. Criteria for Path Building ................................16\n    \
    \  2.3. Path-Building Algorithms ..................................17\n      2.4.\
    \ How to Build a Certification Path .........................21\n           2.4.1.\
    \ Certificate Repetition .............................23\n           2.4.2. Introduction\
    \ to Path-Building Optimization .........24\n      2.5. Building Certification\
    \ Paths for Revocation Signer\n           Certificates ..............................................30\n\
    \      2.6. Suggested Path-Building Software Components ...............31\n  \
    \    2.7. Inputs to the Path-Building Module ........................33\n    \
    \       2.7.1. Required Inputs ....................................33\n      \
    \     2.7.2. Optional Inputs ....................................34\n   3. Optimizing\
    \ Path Building .......................................35\n      3.1. Optimized\
    \ Path Building ...................................35\n      3.2. Sorting vs.\
    \ Elimination ...................................38\n      3.3. Representing the\
    \ Decision Tree ............................41\n           3.3.1. Node Representation\
    \ for CA Entities ................41\n           3.3.2. Using Nodes to Iterate\
    \ Over All Paths ..............42\n      3.4. Implementing Path-Building Optimization\
    \ ...................45\n      3.5. Selected Methods for Sorting Certificates\
    \ .................46\n           3.5.1. basicConstraints Is Present and cA Equals\
    \ True .....47\n           3.5.2. Recognized Signature Algorithms ....................48\n\
    \           3.5.3. keyUsage Is Correct ................................48\n  \
    \         3.5.4. Time (T) Falls within the Certificate Validity .....48\n    \
    \       3.5.5. Certificate Was Previously Validated ...............49\n      \
    \     3.5.6. Previously Verified Signatures .....................49\n        \
    \   3.5.7. Path Length Constraints ............................50\n          \
    \ 3.5.8. Name Constraints ...................................50\n           3.5.9.\
    \ Certificate Is Not Revoked .........................51\n           3.5.10. Issuer\
    \ Found in the Path Cache ....................52\n           3.5.11. Issuer Found\
    \ in the Application Protocol ..........52\n           3.5.12. Matching Key Identifiers\
    \ (KIDs) ...................52\n           3.5.13. Policy Processing .................................53\n\
    \           3.5.14. Policies Intersect the Sought Policy Set ..........54\n  \
    \         3.5.15. Endpoint Distinguished Name (DN) Matching .........55\n    \
    \       3.5.16. Relative Distinguished Name (RDN) Matching ........55\n      \
    \     3.5.17. Certificates are Retrieved from\n                   cACertificate\
    \ Directory Attribute .................56\n           3.5.18. Consistent Public\
    \ Key and Signature Algorithms ....56\n           3.5.19. Similar Issuer and Subject\
    \ Names ..................57\n           3.5.20. Certificates in the Certification\
    \ Cache ...........57\n           3.5.21. Current CRL Found in Local Cache ..................58\n\
    \      3.6. Certificate Sorting Methods for Revocation Signer\n           Certification\
    \ Paths .......................................58\n           3.6.1. Identical\
    \ Trust Anchors ............................58\n           3.6.2. Endpoint Distinguished\
    \ Name (DN) Matching ..........59\n           3.6.3. Relative Distinguished Name\
    \ (RDN) Matching .........59\n           3.6.4. Identical Intermediate Names .......................60\n\
    \   4. Forward Policy Chaining ........................................60\n  \
    \    4.1. Simple Intersection .......................................61\n    \
    \  4.2. Policy Mapping ............................................62\n      4.3.\
    \ Assigning Scores for Forward Policy Chaining ..............63\n   5. Avoiding\
    \ Path-Building Errors ..................................64\n      5.1. Dead Ends\
    \ .................................................64\n      5.2. Loop Detection\
    \ ............................................65\n      5.3. Use of Key Identifiers\
    \ ....................................66\n      5.4. Distinguished Name Encoding\
    \ ...............................66\n   6. Retrieval Methods ..............................................67\n\
    \      6.1. Directories Using LDAP ....................................67\n  \
    \    6.2. Certificate Store Access via HTTP .........................69\n    \
    \  6.3. Authority Information Access ..............................69\n      6.4.\
    \ Subject Information Access ................................70\n      6.5. CRL\
    \ Distribution Points ...................................70\n      6.6. Data Obtained\
    \ via Application Protocol ....................71\n      6.7. Proprietary Mechanisms\
    \ ....................................71\n   7. Improving Retrieval Performance\
    \ ................................71\n      7.1. Caching ...................................................72\n\
    \      7.2. Retrieval Order ...........................................73\n  \
    \    7.3. Parallel Fetching and Prefetching .........................73\n   8.\
    \ Security Considerations ........................................74\n      8.1.\
    \ General Considerations for Building a Certification Path ..74\n      8.2. Specific\
    \ Considerations for Building Revocation\n           Signer Paths ..............................................75\n\
    \   9. Acknowledgements ...............................................78\n  \
    \ 10. Normative References ..........................................78\n   11.\
    \ Informative References ........................................78\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   [X.509] public key certificates have become an accepted\
    \ method for\n   securely binding the identity of an individual or device to a\
    \ public\n   key, in order to support public key cryptographic operations such\
    \ as\n   digital signature verification and public key-based encryption.\n   However,\
    \ prior to using the public key contained in a certificate, an\n   application\
    \ first has to determine the authenticity of that\n   certificate, and specifically,\
    \ the validity of all the certificates\n   leading to a trusted public key, called\
    \ a trust anchor.  Through\n   validating this certification path, the assertion\
    \ of the binding made\n   between the identity and the public key in each of the\
    \ certificates\n   can be traced back to a single trust anchor.\n   The process\
    \ by which an application determines this authenticity of a\n   certificate is\
    \ called certification path processing.  Certification\n   path processing establishes\
    \ a chain of trust between a trust anchor\n   and a certificate.  This chain of\
    \ trust is composed of a series of\n   certificates known as a certification path.\
    \  A certification path\n   begins with a certificate whose signature can be verified\
    \ using a\n   trust anchor and ends with the target certificate.  Path processing\n\
    \   entails building and validating the certification path to determine\n   whether\
    \ a target certificate is appropriate for use in a particular\n   application\
    \ context.  See Section 3.2 of [RFC3280] for more\n   information on certification\
    \ paths and trust.\n"
- title: 1.1.  Motivation
  contents:
  - "1.1.  Motivation\n   Many other documents (such as [RFC3280]) cover certification\
    \ path\n   validation requirements and procedures in detail but do not discuss\n\
    \   certification path building because the means used to find the path\n   does\
    \ not affect its validation.  This document therefore is an effort\n   to provide\
    \ useful guidance for developers of certification path-\n   building implementations.\n\
    \   Additionally, the need to develop complex certification paths is\n   increasing.\
    \  Many PKIs are now using complex structures (see Section\n   1.5) rather than\
    \ simple hierarchies.  Additionally, some enterprises\n   are gradually moving\
    \ away from trust lists filled with many trust\n   anchors, and toward an infrastructure\
    \ with one trust anchor and many\n   cross-certified relationships.  This document\
    \ provides helpful\n   information for developing certification paths in these\
    \ more\n   complicated situations.\n"
- title: 1.2.  Purpose
  contents:
  - "1.2.  Purpose\n   This document provides information and guidance for certification\n\
    \   path building.  There are no requirements or protocol specifications\n   in\
    \ this document.  This document provides many options for performing\n   certification\
    \ path building, as opposed to just one particular way.\n   This document draws\
    \ upon the authors' experiences with existing\n   complex certification paths\
    \ to offer insights and recommendations to\n   developers who are integrating\
    \ support for [X.509] certificates into\n   their applications.\n   In addition,\
    \ this document suggests using an effective general\n   approach to path building\
    \ that involves a depth first tree traversal.\n   While the authors believe this\
    \ approach offers the balance of\n   simplicity in design with very effective\
    \ and infrastructure-neutral\n   path-building capabilities, the algorithm is\
    \ no more than a suggested\n   approach.  Other approaches (e.g., breadth first\
    \ tree traversals)\n   exist and may be shown to be more effective under certain\
    \ conditions.\n   Certification path validation is described in detail in both\
    \ [X.509]\n   and [RFC3280] and is not repeated in this document.\n   This document\
    \ does not provide guidance for building the\n   certification path from an end\
    \ entity certificate to a proxy\n   certificate as described in [RFC3820].\n"
- title: 1.3.  Terminology
  contents:
  - "1.3.  Terminology\n   Terms used throughout this document will be used in the\
    \ following\n   ways:\n   Building in the Forward direction: The process of building\
    \ a\n      certification path from the target certificate to a trust anchor.\n\
    \      'Forward' is the former name of the crossCertificatePair element\n    \
    \  'issuedToThisCA'.\n   Building in the Reverse direction: The process of building\
    \ a\n      certification path from a trust anchor to the target certificate.\n\
    \      'Reverse' is the former name of the crossCertificatePair element\n    \
    \  'issuedByThisCA'.\n   Certificate:  A digital binding that cannot be counterfeited\
    \ between\n      a named entity and a public key.\n   Certificate Graph:  A graph\
    \ that represents the entire PKI (or all\n      cross-certified PKIs) in which\
    \ all named entities are viewed as\n      nodes and all certificates are viewed\
    \ as arcs between nodes.\n   Certificate Processing System:  An application or\
    \ device that\n      performs the functions of certification path building and\n\
    \      certification path validation.\n   Certification Authority (CA):  An entity\
    \ that issues and manages\n      certificates.\n   Certification Path:  An ordered\
    \ list of certificates starting with a\n      certificate signed by a trust anchor\
    \ and ending with the target\n      certificate.\n   Certification Path Building:\
    \  The process used to assemble the\n      certification path between the trust\
    \ anchor and the target\n      certificate.\n   Certification Path Validation:\
    \  The process that verifies the binding\n      between the subject and the subject-public-key\
    \ defined in the\n      target certificate, using a trust anchor and set of known\n\
    \      constraints.\n   Certificate Revocation List (CRL):  A signed, time stamped\
    \ list\n      identifying a set of certificates that are no longer considered\n\
    \      valid by the certificate issuer.\n   CRL Signer Certificate: The specific\
    \ certificate that may be used for\n      verifying the signature on a CRL issued\
    \ by, or on behalf of, a\n      specific CA.\n   Cross-Certificate:  A certificate\
    \ issued by one CA to another CA for\n      the purpose of establishing a trust\
    \ relationship between the two\n      CAs.\n   Cross-Certification:  The act of\
    \ issuing cross-certificates.\n   Decision Tree:  When the path-building software\
    \ has multiple\n      certificates to choose from, and must make a decision, the\n\
    \      collection of possible choices is called a decision tree.\n   Directory:\
    \  Generally used to refer an LDAP accessible repository for\n      certificates\
    \ and PKI information.  The term may also be used\n      generically to refer\
    \ to any certificate storing repository.\n   End Entity:  The holder of a private\
    \ key and corresponding\n      certificate, whose identity is defined as the Subject\
    \ of the\n      certificate.  Human end entities are often called \"subscribers\"\
    .\n   Is-revocation-signer indicator:  A boolean flag furnished to the\n     \
    \ path-building software.  If set, this indicates that the target\n      certificate\
    \ is a Revocation Signer certificate for a specific CA.\n      For example, if\
    \ building a certification path for an indirect CRL\n      Signer certificate,\
    \ this flag would be set.\n   Local PKI:  The set of PKI components and data (certificates,\n\
    \      directories, CRLs, etc.) that are created and used by the\n      certificate\
    \ using organization.  In general, this concept refers\n      to the components\
    \ that are in close proximity to the certificate\n      using application.  The\
    \ assumption is that the local data is more\n      easily accessible and/or inexpensive\
    \ to retrieve than non-local\n      PKI data.\n   Local Realm: See Local PKI.\n\
    \   Node (in a certificate graph): The collection of certificates having\n   \
    \   identical subject distinguished names.\n   Online Certificate Status Protocol\
    \ (OCSP): An Internet protocol used\n      by a client to obtain the revocation\
    \ status of a certificate from\n      a server.\n   OCSP Response Signer Certificate:\
    \  The specific certificate that may\n      be used for verifying the signature\
    \ on an OCSP response.  This\n      response may be provided by the CA, on behalf\
    \ of the CA, or by a\n      different signer as determined by the Relying Party's\
    \ local\n      policy.\n   Public Key Infrastructure (PKI):  The set of hardware,\
    \ software,\n      personnel, policy, and procedures used by a CA to issue and\
    \ manage\n      certificates.\n   Relying Party (RP):  An application or entity\
    \ that processes\n      certificates for the purpose of 1) verifying a digital\
    \ signature,\n      2) authenticating another entity, or 3) establishing confidential\n\
    \      communications.\n   Revocation Signer Certificate:  Refers collectively\
    \ to either a CRL\n      Signer Certificate or OCSP Response Signer Certificate.\n\
    \   Target Certificate:  The certificate that is to be validated by a\n      Relying\
    \ Party.  It is the \"Certificate targeted for validation\".\n      Although frequently\
    \ this is the End Entity or a leaf node in the\n      PKI structure, this could\
    \ also be a CA certificate if a CA\n      certificate is being validated. (e.g.,\
    \ This could be for the\n      purpose of building and validating a certification\
    \ path for the\n      signer of a CRL.)\n   Trust (of public keys): In the scope\
    \ of this document, a public key\n      is considered trustworthy if the certificate\
    \ containing the public\n      key can be validated according to the procedures\
    \ in [RFC3280].\n   Trust List: A list of trust anchors.\n   Trust Anchor: The\
    \ combination of a trusted public key and the name of\n      the entity to which\
    \ the corresponding private key belongs.\n   Trust Anchor Certificate:  A self-signed\
    \ certificate for a trust\n      anchor that is used in certification path processing.\n\
    \   User:  An individual that is using a certificate processing system.\n    \
    \  This document refers to some cases in which users may or may not\n      be\
    \ prompted with information or requests, depending upon the\n      implementation\
    \ of the certificate processing system.\n"
- title: 1.4.  Notation
  contents:
  - "1.4.  Notation\n   This document makes use of a few common notations that are\
    \ used in\n   the diagrams and examples.\n   The first is the arrow symbol (->)\
    \ which represents the issuance of a\n   certificate from one entity to another.\
    \  For example, if entity H\n   were to issue a certificate to entity K, this\
    \ is denoted as H->K.\n   Sometimes it is necessary to specify the subject and\
    \ issuer of a\n   given certificate.  If entity H were to issue a certificate\
    \ to entity\n   K this can be denoted as K(H).\n   These notations can be combined\
    \ to denote complicated certification\n   paths such as C(D)->B(C)->A(B).\n"
- title: 1.5.  Overview of PKI Structures
  contents:
  - "1.5.  Overview of PKI Structures\n   When verifying [X.509] public key certificates,\
    \ often the application\n   performing the verification has no knowledge of the\
    \ underlying Public\n   Key Infrastructure (PKI) that issued the certificate.\
    \  PKI structures\n   can range from very simple, hierarchical structures to complex\n\
    \   structures such as mesh architectures involving multiple bridges (see\n  \
    \ Section 1.5.4).  These structures define the types of certification\n   paths\
    \ that might be built and validated by an application [MINHPKIS].\n   This section\
    \ describes four common PKI structures.\n"
- title: 1.5.1.  Hierarchical Structures
  contents:
  - "1.5.1.  Hierarchical Structures\n   A hierarchical PKI, depicted in Figure 1,\
    \ is one in which all of the\n   end entities and relying parties use a single\
    \ \"Root CA\" as their\n   trust anchor.  If the hierarchy has multiple levels,\
    \ the Root CA\n   certifies the public keys of intermediate CAs (also known as\n\
    \   subordinate CAs).  These CAs then certify end entities'\n   (subscribers')\
    \ public keys or may, in a large PKI, certify other CAs.\n   In this architecture,\
    \ certificates are issued in only one direction,\n   and a CA never certifies\
    \ another CA \"superior\" to itself.  Typically,\n   only one superior CA certifies\
    \ each CA.\n                               +---------+\n                     \
    \      +---| Root CA |---+\n                           |   +---------+   |\n \
    \                          |                 |\n                           | \
    \                |\n                           v                 v\n         \
    \               +----+            +----+\n                  +-----| CA |     \
    \ +-----| CA |------+\n                  |     +----+      |     +----+      |\n\
    \                  |                 |                 |\n                  v\
    \                 v                 v\n               +----+            +----+\
    \            +----+\n            +--| CA |-----+      | CA |-+      +---| CA |---+\n\
    \            |  +----+     |      +----+ |      |   +----+   |\n            |\
    \     |       |       |     |      |    |       |\n            |     |       |\
    \       |     |      |    |       |\n            v     v       v       v     v\
    \      v    v       v\n         +----+ +----+ +----+ +----+ +----+ +----+ +----+\
    \ +----+\n         | EE | | EE | | EE | | EE | | EE | | EE | | EE | | EE |\n \
    \        +----+ +----+ +----+ +----+ +----+ +----+ +----+ +----+\n           \
    \         Figure 1 - Sample Hierarchical PKI\n   Certification path building in\
    \ a hierarchical PKI is a\n   straightforward process that simply requires the\
    \ relying party to\n   successively retrieve issuer certificates until a certificate\
    \ that\n   was issued by the trust anchor (the \"Root CA\" in Figure 1) is\n \
    \  located.\n   A widely used variation on the single-rooted hierarchical PKI\
    \ is the\n   inclusion of multiple CAs as trust anchors.  (See Figure 2.)  Here,\n\
    \   end entity certificates are validated using the same approach as with\n  \
    \ any hierarchical PKI.  The difference is that a certificate will be\n   accepted\
    \ if it can be verified back to any of the set of trust\n   anchors.  Popular\
    \ web browsers use this approach, and are shipped\n   with trust lists containing\
    \ dozens to more than one hundred CAs.\n   While this approach simplifies the\
    \ implementation of a limited form\n   of certificate verification, it also may\
    \ introduce certain security\n   vulnerabilities.  For example, the user may have\
    \ little or no idea of\n   the policies or operating practices of the various\
    \ trust anchors, and\n   may not be aware of which root was used to verify a given\n\
    \   certificate.  Additionally, the compromise of any trusted CA private\n   key\
    \ or the insertion of a rogue CA certificate to the trust list may\n   compromise\
    \ the entire system.  Conversely, if the trust list is\n   properly managed and\
    \ kept to a reasonable size, it can be an\n   efficient solution to building and\
    \ validating certification paths.\n            +-------------------------------------------------------+\n\
    \            |                      Trust List                       |\n     \
    \       |                                                       |\n          \
    \  |     +---------+     +---------+      +---------+      |\n            |  +--|\
    \ Root CA |     | Root CA |      | Root CA |      |\n            |  |  +---------+\
    \     +---------+      +---------+      |\n            |  |      |           \
    \     |                 |          |\n            +--|------|----------------|----------------\
    \ |----------+\n               |      |                |                 |\n \
    \              |      |                |                 |\n               | \
    \     |                v                 |\n               |      |          \
    \   +----+               |\n               |      |        +----| CA |---+   \
    \        |\n               |      |        |    +----+   |           |\n     \
    \          |      |        |             |           |\n               |     \
    \ |        v             v           v\n               |      |     +----+   \
    \     +----+      +----+\n               |      |     | CA |---+    | CA |-+ \
    \   | CA |---+\n               |      |     +----+   |    +----+ |    +----+ \
    \  |\n               |      |       |      |    |      |       |     |\n     \
    \          |      |       |      |    |      |       |     |\n               v\
    \      v       v      v    v      v       v     v\n            +----+ +----+ +----+\
    \ +----+ +----+ +----+ +----+ +----+\n            | EE | | EE | | EE | | EE |\
    \ | EE | | EE | | EE | | EE |\n            +----+ +----+ +----+ +----+ +----+\
    \ +----+ +----+ +----+\n                 Figure 2 - Multi-Rooted Hierarchical\
    \ PKI\n"
- title: 1.5.2.  Mesh Structures
  contents:
  - "1.5.2.  Mesh Structures\n   In a typical mesh style PKI (depicted in Figure 3),\
    \ each end entity\n   trusts the CA that issued their own certificate(s).  Thus,\
    \ there is\n   no 'Root CA' for the entire PKI.  The CAs in this environment have\n\
    \   peer relationships; they are neither superior nor subordinate to one\n   another.\
    \  In a mesh, CAs in the PKI cross-certify.  That is, each CA\n   issues a certificate\
    \ to, and is issued a certificate by, peer CAs in\n   the PKI.  The figure depicts\
    \ a mesh PKI that is fully cross-certified\n   (sometimes called a full mesh).\
    \  However, it is possible to architect\n   and deploy a mesh PKI with a mixture\
    \ of uni-directional and bi-\n   directional cross-certifications (called a partial\
    \ mesh).  Partial\n   meshes may also include CAs that are not cross-certified\
    \ with other\n   CAs in the mesh.\n                          +---------------------------------+\n\
    \                          |                                 |\n             \
    \ +-----------+----------------------+          |\n              |           v\
    \                      v          |\n              |       +-------+         \
    \      +------+      |\n              |  +--->| CA B  |<------------->| CA C |<--+\
    \  |\n              |  |    +-------+               +------+   |  |\n        \
    \      |  |      |    ^                  ^  |     |  |\n              |  |   \
    \   v    |                  |  |     |  |\n              |  |   +----+  |    \
    \              |  |     |  |\n              |  |   | EE |  +----+    +--------+\
    \  v     |  |\n              |  |   +----+       |    |         +----+  |  |\n\
    \              |  |                |    |         | EE |  |  |\n             \
    \ v  v                v    v         +----+  v  v\n            +------+      \
    \       +------+             +------+\n            | CA E |<----------->| CA A\
    \ |<----------->| CA D |\n            +------+             +------+          \
    \   +------+\n             |  ^  ^                                    ^ ^  |\n\
    \             |  |  |                                    | |  |\n            \
    \ v  |  +------------------------------------+ |  v\n         +----+ |       \
    \                                  | +----+\n         | EE | |               \
    \ +------+                 | | EE |\n         +----+ +----------------| CA F |-----------------+\
    \ +----+\n                                 +------+\n                        \
    \   Figure 3 - Mesh PKI\n   Certification path building in a mesh PKI is more\
    \ complex than in a\n   hierarchical PKI due to the likely existence of multiple\
    \ paths\n   between a relying party's trust anchor and the certificate to be\n\
    \   verified.  These multiple paths increase the potential for creating\n   \"\
    loops\", \"dead ends\", or invalid paths while building the\n   certification\
    \ path between a trust anchor and a target certificate.\n   In addition, in cases\
    \ where no valid path exists, the total number of\n   paths traversed by the path-building\
    \ software in order to conclude\n   \"no path exists\" can grow exceedingly large.\
    \  For example, if\n   ignoring everything except the structure of the graph,\
    \ the Mesh PKI\n   figure above has 22 non-self issued CA certificates and a total\
    \ of\n   5,092,429 certification paths between CA F and the EE issued by CA D\n\
    \   without repeating any certificates.\n"
- title: 1.5.3.  Bi-Lateral Cross-Certified Structures
  contents:
  - "1.5.3.  Bi-Lateral Cross-Certified Structures\n   PKIs can be connected via cross-certification\
    \ to enable the relying\n   parties of each to verify and accept certificates\
    \ issued by the other\n   PKI.  If the PKIs are hierarchical, cross-certification\
    \ will\n   typically be accomplished by each Root CA issuing a certificate for\n\
    \   the other PKI's Root CA.  This results in a slightly more complex,\n   but\
    \ still essentially hierarchical environment.  If the PKIs are mesh\n   style,\
    \ then a CA within each PKI is selected, more or less\n   arbitrarily, to establish\
    \ the cross-certification, effectively\n   creating a larger mesh PKI.  Figure\
    \ 4 depicts a hybrid situation\n   resulting from a hierarchical PKI cross-certifying\
    \ with a mesh PKI.\n                       PKI 1 and 2 cross-certificates\n  \
    \                    +-------------------------------+\n                     \
    \ |                               |\n                      |                 \
    \              v\n                      |                           +---------+\n\
    \                      |                      +----| Root CA |---+\n         \
    \             |                      |    +---------+   |\n                  \
    \    |                      |       PKI 1      |\n                      |    \
    \                  v                  v\n                      |             \
    \        +------+         +------+\n                      v PKI 2            \
    \ +-|  CA  |-+       |  CA  |\n                     +------+             | +------+\
    \ |       +------+\n            +------->|  CA  |<-----+      |     |    |   \
    \      |   |\n            |        +------+      |      |     |    |         |\
    \   |\n            |         |    |       |      v     v    v         v   v\n\
    \            |         |    |       |  +----+ +----+ +----+ +----+ +----+\n  \
    \          |         v    v       |  | EE | | EE | | EE | | EE | | EE |\n    \
    \        |      +----+ +----+   |  +----+ +----+ +----+ +----+ +----+\n      \
    \      |      | EE | | EE |   |\n            |      +----+ +----+   |\n      \
    \      v                      v\n         +------+                +------+\n \
    \        |  CA  |<-------------->|  CA  |------+\n         +------+          \
    \      +------+      |\n          |    |                  |    |       |\n   \
    \       |    |                  |    |       |\n          v    v             \
    \     v    v       v\n      +----+ +----+            +----+ +----+ +----+\n  \
    \    | EE | | EE |            | EE | | EE | | EE |\n      +----+ +----+      \
    \      +----+ +----+ +----+\n                          Figure 4 - Hybrid PKI\n\
    \   In current implementations, this situation creates a concern that the\n  \
    \ applications used under the hierarchical PKIs will not have path\n   building\
    \ capabilities robust enough to handle this more complex\n   certificate graph.\
    \  As the number of cross-certified PKIs grows, the\n   number of the relationships\
    \ between them grows exponentially.  Two\n   principal concerns about cross-certification\
    \ are the creation of\n   unintended certification paths through transitive trust,\
    \ and the\n   dilution of assurance when a high-assurance PKI with restrictive\n\
    \   operating policies is cross-certified with a PKI with less\n   restrictive\
    \ policies.  (Proper name constraints and certificate\n   policies processing\
    \ can help mitigate the problem of assurance\n   dilution.)\n"
- title: 1.5.4.  Bridge Structures
  contents:
  - "1.5.4.  Bridge Structures\n   Another approach to the interconnection of PKIs\
    \ is the use of a\n   \"bridge\" certification authority (BCA).  A BCA is a nexus\
    \ to\n   establish trust paths among multiple PKIs.  The BCA cross-certifies\n\
    \   with one CA in each participating PKI.  Each PKI only cross-certifies\n  \
    \ with one other CA (i.e., the BCA), and the BCA cross-certifies only\n   once\
    \ with each participating PKI.  As a result, the number of cross\n   certified\
    \ relationships in the bridged environment grows linearly\n   with the number\
    \ of PKIs whereas the number of cross-certified\n   relationships in mesh architectures\
    \ grows exponentially.  However,\n   when connecting PKIs in this way, the number\
    \ and variety of PKIs\n   involved results in a non-hierarchical environment,\
    \ such as the one\n   as depicted in Figure 5.  (Note: as discussed in Section\
    \ 2.3, non-\n   hierarchical PKIs can be considered hierarchical, depending upon\n\
    \   perspective.)\n                      PKI 1 cross-certified with Bridge\n \
    \                     +-------------------------------+\n                    \
    \  |                               |\n                      v                \
    \               v\n                +-----------+                    +---------+\n\
    \                | Bridge CA |                +---| Root CA |-----+\n        \
    \        +-----------+                |   +---------+     |\n                \
    \      ^                      |      PKI 1        |\n           PKI 2 cross|cert\
    \ with Bridge      v                   v\n                      |            \
    \         +------+         +------+\n                      v PKI 2           \
    \  +-|  CA  |-+       |  CA  |\n                     +------+             | +------+\
    \ |       +------+\n            +------->|  CA  |<-----+      |     |    |   \
    \      |   |\n            |        +------+      |      |     |    |         |\
    \   |\n            |         |    |       |      v     v    v         v   v\n\
    \            |         |    |       |  +----+ +----+ +----+ +----+ +----+\n  \
    \          |         v    v       |  | EE | | EE | | EE | | EE | | EE |\n    \
    \        |      +----+ +----+   |  +----+ +----+ +----+ +----+ +----+\n      \
    \      |      | EE | | EE |   |\n            |      +----+ +----+   |\n      \
    \      v                      v\n         +------+                +------+\n \
    \        |  CA  |<-------------->|  CA  |------+\n         +------+          \
    \      +------+      |\n          |    |                  |    |       |\n   \
    \       |    |                  |    |       |\n          v    v             \
    \     v    v       v\n      +----+ +----+            +----+ +----+ +----+\n  \
    \    | EE | | EE |            | EE | | EE | | EE |\n      +----+ +----+      \
    \      +----+ +----+ +----+\n             Figure 5 - Cross-Certification with\
    \ a Bridge CA\n"
- title: 1.6.  Bridge Structures and Certification Path Processing
  contents:
  - "1.6.  Bridge Structures and Certification Path Processing\n   Developers building\
    \ certificate-enabled applications intended for\n   widespread use throughout\
    \ various sectors are encouraged to consider\n   supporting a Bridge PKI structure\
    \ because implementation of\n   certification path processing functions to support\
    \ a Bridge PKI\n   structure requires support of all the PKI structures (e.g.,\n\
    \   hierarchical, mesh, hybrid) which the Bridge may connect.  An\n   application\
    \ that can successfully build valid certification paths in\n   all Bridge PKIs\
    \ will therefore have implemented all of the processing\n   logic required to\
    \ support the less complicated PKI structures.  Thus,\n   if an application fully\
    \ supports the Bridge PKI structure, it can be\n   deployed in any standards-compliant\
    \ PKI environment and will perform\n   the required certification path processing\
    \ properly.\n"
- title: 2.  Certification Path Building
  contents:
  - "2.  Certification Path Building\n   Certification path building is the process\
    \ by which the certificate\n   processing system obtains the certification path\
    \ between a trust\n   anchor and the target certificate.  Different implementations\
    \ can\n   build the certification path in different ways; therefore, it is not\n\
    \   the intent of this document to recommend a single \"best\" way to\n   perform\
    \ this function.  Rather, guidance is provided on the technical\n   issues that\
    \ surround the path-building process, and on the\n   capabilities path-building\
    \ implementations need in order to build\n   certification paths successfully,\
    \ irrespective of PKI structures.\n"
- title: 2.1.  Introduction to Certification Path Building
  contents:
  - "2.1.  Introduction to Certification Path Building\n   A certification path is\
    \ an ordered list of certificates starting with\n   a certificate that can be\
    \ validated by one of the relying party's\n   trust anchors, and ending with the\
    \ certificate to be validated.  (The\n   certificate to be validated is referred\
    \ to as the \"target\n   certificate\" throughout this document.)  Though not\
    \ required, as a\n   matter of convenience these trust anchors are typically stored\
    \ in\n   trust anchor certificates.  The intermediate certificates that\n   comprise\
    \ the certification path may be retrieved by any means\n   available to the validating\
    \ application.  These sources may include\n   LDAP, HTTP, SQL, a local cache or\
    \ certificate store, or as part of\n   the security protocol itself as is common\
    \ practice with signed S/MIME\n   messages and SSL/TLS sessions.\n   Figure 6\
    \ shows an example of a certification path.  In this figure,\n   the horizontal\
    \ arrows represent certificates, and the notation B(A)\n   signifies a certificate\
    \ issued to B, signed by A.\n      +---------+      +-----+     +-----+     +-----+\
    \     +--------+\n      |  Trust  |----->| CA  |---->| CA  |---->| CA  |---->|\
    \ Target |\n      | Anchor  |  :   |  A  |  :  |  B  |  :  |  C  |  :  |   EE\
    \   |\n      +---------+  :   +-----+  :  +-----+  :  +-----+  :  +--------+\n\
    \                   :            :           :           :\n                 \
    \  :            :           :           :\n                 Cert 1       Cert\
    \ 2      Cert 3      Cert 4\n            A(Trust Anchor)    B(A)        C(B) \
    \     Target(C)\n                  Figure 6 - Example Certification Path\n   Unlike\
    \ certification path validation, certification path building is\n   not addressed\
    \ by the standards that define the semantics and\n   structure of a PKI.  This\
    \ is because the validation of a\n   certification path is unaffected by the method\
    \ in which the\n   certification path was built.  However, the ability to build\
    \ a valid\n   certification path is of paramount importance for applications that\n\
    \   rely on a PKI.  Without valid certification paths, certificates\n   cannot\
    \ be validated according to [RFC3280] and therefore cannot be\n   trusted.  Thus,\
    \ the ability to build a path is every bit as important\n   as the ability to\
    \ validate it properly.\n   There are many issues that can complicate the path-building\
    \ process.\n   For example, building a path through a cross-certified environment\n\
    \   could require the path-building module to traverse multiple PKI\n   domains\
    \ spanning multiple directories, using multiple algorithms, and\n   employing\
    \ varying key lengths.  A path-building client may also need\n   to manage a number\
    \ of trust anchors, partially populated directory\n   entries (e.g., missing issuedToThisCA\
    \ entries in the\n   crossCertificatePair attribute), parsing of certain certificate\n\
    \   extensions (e.g., authorityInformationAccess) and directory\n   attributes\
    \ (e.g., crossCertificatePair), and error handling such as\n   loop detection.\n\
    \   In addition, a developer has to decide whether to build paths from a\n   trust\
    \ anchor (the reverse direction) to the target certificate or\n   from the target\
    \ certificate (the forward direction) to a trust\n   anchor.  Some implementations\
    \ may even decide to use both.  The\n   choice a developer makes should be dependent\
    \ on the environment and\n   the underlying PKI for that environment.  More information\
    \ on making\n   this choice can be found in Section 2.3.\n"
- title: 2.2.  Criteria for Path Building
  contents:
  - "2.2.  Criteria for Path Building\n   From this point forward, this document will\
    \ be discussing specific\n   algorithms and mechanisms to assist developers of\
    \ certification\n   path-building implementations.  To provide justification for\
    \ these\n   mechanisms, it is important to denote what the authors considered\
    \ the\n   criteria for a path-building implementation.\n   Criterion 1: The implementation\
    \ is able to find all possible paths,\n   excepting paths containing repeated\
    \ subject name/public key pairs.\n   This means that all potentially valid certification\
    \ paths between the\n   trust anchor and the target certificate which may be valid\
    \ paths can\n   be built by the algorithm.  As discussed in Section 2.4.2, we\n\
    \   recommend that subject names and public key pairs are not repeated in\n  \
    \ paths.\n   Criterion 2: The implementation is as efficient as possible.  An\n\
    \   efficient certification path-building implementation is defined to be\n  \
    \ one that builds paths that are more likely to validate following\n   [RFC3280],\
    \ before building paths that are not likely to validate,\n   with the understanding\
    \ that there is no way to account for all\n   possible configurations and infrastructures.\
    \  This criterion is\n   intended to ensure implementations that can produce useful\
    \ error\n   information.  If a particular path is entirely valid except for a\n\
    \   single expired certificate, this is most likely the 'right' path.  If\n  \
    \ other paths are developed that are invalid for multiple obscure\n   reasons,\
    \ this provides little useful information.\n   The algorithms and mechanisms discussed\
    \ henceforth are chosen because\n   the authors consider them to be good methods\
    \ for meeting the above\n   criteria.\n"
- title: 2.3.  Path-Building Algorithms
  contents:
  - "2.3.  Path-Building Algorithms\n   It is intuitive for people familiar with the\
    \ Bridge CA concept or\n   mesh type PKIs to view path building as traversing\
    \ a complex graph.\n   However, from the simplest viewpoint, writing a path-building\
    \ module\n   can be nothing more than traversal of a spanning tree, even in a\
    \ very\n   complex cross-certified environment.  Complex environments as well\
    \ as\n   hierarchical PKIs can be represented as trees because certificates\n\
    \   are not permitted to repeat in a path.  If certificates could be\n   repeated,\
    \ loops can be formed such that the number of paths and\n   number of certificates\
    \ in a path both increase without bound (e.g., A\n   issues to B, B issues to\
    \ C, and C issues to A).  Figure 7 below\n   illustrates this concept from the\
    \ trust anchor's perspective.\n            +---------+                       \
    \ +---------+\n            |  Trust  |                        |  Trust  |\n  \
    \          | Anchor  |                        |  Anchor |\n            +---------+\
    \                        +---------+\n             |       |                 \
    \        |         |\n             v       v                         v       \
    \  v\n          +---+    +---+                     +---+      +---+\n        \
    \  | A |<-->| C |                  +--| A |      | C |--+\n          +---+   \
    \ +---+                  |  +---+      +---+  |\n           |         |      \
    \              |     |       |      |\n           |  +---+  |                \
    \    v     v       v      v\n           +->| B |<-+                  +---+  +---+\
    \  +---+  +---+\n              +---+                     | B |  | C |  | A | \
    \ | B |\n                |                       +---+  +---+  +---+  +---+\n\
    \                v                         |      |      |       |\n         \
    \     +----+                      v      v      v       v\n              | EE\
    \ |                  +----+   +---+  +---+  +----+\n              +----+     \
    \             | EE |   | B |  | B |  | EE |\n                                \
    \      +----+   +---+  +---+  +----+\n         A certificate graph with      \
    \         |        |\n         bi-directional cross-cert.             v      \
    \  v\n         between CAs A and C.                 +----+  +----+\n         \
    \                                     | EE |  | EE |\n                       \
    \                       +----+  +----+\n                                     \
    \    The same certificate graph\n                                         rendered\
    \ as a tree - the\n                                         way path-building\
    \ software\n                                         could see it.\n     Figure\
    \ 7 - Simple Certificate Graph - From Anchor Tree Depiction\n   When viewed from\
    \ this perspective, all PKIs look like hierarchies\n   emanating from the trust\
    \ anchor.  An infrastructure can be depicted\n   in this way regardless of its\
    \ complexity.  In Figure 8, the same\n   graph is depicted from the end entity\
    \ (EE) (the target certificate in\n   this example).  It would appear this way\
    \ if building in the forward\n   (from EE or from target) direction.  In this\
    \ example, without knowing\n   any particulars of the certificates, it appears\
    \ at first that\n   building from EE has a smaller decision tree than building\
    \ from the\n   trust anchor.  While it is true that there are fewer nodes in the\n\
    \   tree, it is not necessarily more efficient in this example.\n            \
    \          +---------+         +---------+\n                      |  Trust  |\
    \         |  Trust  |\n                      | Anchor  |         |  Anchor |\n\
    \                      +---------+         +---------+\n                     \
    \      ^                   ^\n                           |                   |\n\
    \                           |                   |\n                         +---+\
    \               +---+\n                         | A |               | C |\n  \
    \                       +---+               +---+\n            +---------+   \
    \ ^                   ^      +---------+\n            |  Trust  |    |       \
    \            |      |  Trust  |\n            | Anchor  |    |                \
    \   |      |  Anchor |\n            +---------+    |                   |     \
    \ +---------+\n                 ^         |                   |           ^\n\
    \                 |       +---+               +---+         |\n              \
    \   +-------| C |               | A |---------+\n                         +---+\
    \               +---+\n                          ^                    ^\n    \
    \                      |                    |\n                          |   \
    \      +---+      |\n                          +---------| B |------+\n      \
    \                              +---+\n                                      ^\n\
    \                                      |\n                                   \
    \   |\n                                   +----+\n                           \
    \        | EE |\n                                   +----+\n                 \
    \  The same certificate graph rendered\n                    as a tree but from\
    \ the end entity\n                      rather than the trust anchor.\n     Figure\
    \ 8 - Certificate Graph - From Target Certificate Depiction\n   Suppose a path-building\
    \ algorithm performed no optimizations.  That\n   is, the algorithm is only capable\
    \ of detecting that the current\n   certificate in the tree was issued by the\
    \ trust anchor, or that it\n   issued the target certificate (EE).  From the tree\
    \ above, building\n   from the target certificate will require going through two\n\
    \   intermediate certificates before encountering a certificate issued by\n  \
    \ the trust anchor 100% of the time (e.g., EE chains to B, which then\n   chains\
    \ to C, which is issued by the Trust Anchor).  The path-building\n   module would\
    \ not chain C to A because it can recognize that C has a\n   certificate issued\
    \ by the Trust Anchor (TA).\n   On the other hand, in the first tree (Figure 7:\
    \ from anchor\n   depiction), there is a 50% probability of building a path longer\
    \ than\n   needed (e.g., TA to A to C to B to EE rather than the shorter TA to\
    \ A\n   to B to EE).  However, even given our simplistic example, the path-\n\
    \   building software, when at A, could be designed to recognize that B's\n  \
    \ subject distinguished name (DN) matches the issuer DN of the EE.\n   Given this\
    \ one optimization, the builder could prefer B to C.  (B's\n   subject DN matches\
    \ that of the EE's issuer whereas C's subject DN\n   does not.)  So, for this\
    \ example, assuming the issuedByThisCA\n   (reverse) and issuedToThisCA (forward)\
    \ elements were fully populated\n   in the directory and our path-building module\
    \ implemented the\n   aforementioned DN matching optimization method, path building\
    \ from\n   either the trust anchor or the target certificate could be made\n \
    \  roughly equivalent.  A list of possible optimization methods is\n   provided\
    \ later in this document.\n   A more complicated example is created when the path-building\
    \ software\n   encounters a situation when there are multiple certificates from\n\
    \   which to choose while building a path.  We refer to this as a large\n   decision\
    \ tree, or a situation with high fan-out.  This might occur if\n   an implementation\
    \ has multiple trust anchors to choose from, and is\n   building in the reverse\
    \ (from trust anchor) direction.  Or, it may\n   occur in either direction if\
    \ a Bridge CA is encountered.  Large\n   decision trees are the enemy of efficient\
    \ path-building software.  To\n   combat this problem, implementations should\
    \ make careful decisions\n   about the path-building direction, and should utilize\
    \ optimizations\n   such as those discussed in Section 3.1 when confronted with\
    \ a large\n   decision tree.\n   Irrespective of the path-building approach for\
    \ any path-building\n   algorithm, cases can be constructed that make the algorithm\
    \ perform\n   poorly.  The following questions should help a developer decide\
    \ from\n   which direction to build certification paths for their application:\n\
    \   1) What is required to accommodate the local PKI environment and the\n   \
    \   PKI environments with which interoperability will be required?\n      a. If\
    \ using a directory, is the directory [RFC2587] compliant\n         (specifically,\
    \ are the issuedToThisCA [forward] cross-\n         certificates and/or the cACertificate\
    \ attributes fully\n         populated in the directory)?  If yes, you are able\
    \ to build in\n         the forward direction.\n      b. If using a directory,\
    \ does the directory contain all the\n         issuedByThisCA (reverse) cross-certificates\
    \ in the\n         crossCertificatePair attribute, or, alternately, are all\n\
    \         certificates issued from each CA available via some other\n        \
    \ means?  If yes, it is possible to build in the reverse\n         direction.\
    \  Note: [RFC2587] does not require the issuedByThisCA\n         (reverse) cross-certificates\
    \ to be populated; if they are\n         absent it will not be possible to build\
    \ solely in the reverse\n         direction.\n      c. Are all issuer certificates\
    \ available via some means other than\n         a directory (e.g., the authorityInformationAccess\
    \ extension is\n         present and populated in all certificates)?  If yes,\
    \ you are\n         able to build in the forward direction.\n   2) How many trust\
    \ anchors will the path-building and validation\n      software be using?\n  \
    \    a. Are there (or will there be) multiple trust anchors in the\n         local\
    \ PKI?  If yes, forward path building may offer better\n         performance.\n\
    \      b. Will the path-building and validation software need to place\n     \
    \    trust in trust anchors from PKIs that do not populate reverse\n         cross-certificates\
    \ for all intermediate CAs?  If no, and the\n         local PKI populates reverse\
    \ cross-certificates, reverse path\n         building is an option.\n"
- title: 2.4.  How to Build a Certification Path
  contents:
  - "2.4.  How to Build a Certification Path\n   As was discussed in the prior section,\
    \ path building is essentially a\n   tree traversal.  It was easy to see how this\
    \ is true in a simple\n   example, but how about a more complicated one? Before\
    \ taking a look\n   at more a complicated scenario, it is worthwhile to address\
    \ loops and\n   what constitutes a loop in a certification path.  [X.509] specifies\n\
    \   that the same certificate may not repeat in a path.  In a strict\n   sense,\
    \ this works well as it is not possible to create an endless\n   loop without\
    \ repeating one or more certificates in the path.\n   However, this requirement\
    \ fails to adequately address Bridged PKI\n   environments.\n            +---+\
    \    +---+\n            | F |--->| H |\n            +---+    +---+\n         \
    \    ^ ^       ^\n             |  \\       \\\n             |   \\       \\\n\
    \             |    v       v\n             |  +---+    +---+\n             | \
    \ | G |--->| I |\n             |  +---+    +---+\n             |   ^\n       \
    \      |  /\n             | /\n         +------+       +-----------+        +------+\
    \   +---+   +---+\n         | TA W |<----->| Bridge CA |<------>| TA X |-->| L\
    \ |-->| M |\n         +------+       +-----------+        +------+   +---+   +---+\n\
    \                           ^      ^               \\        \\\n            \
    \              /        \\               \\        \\\n                      \
    \   /          \\               \\        \\\n                        v      \
    \      v               v        v\n                  +------+         +------+\
    \        +---+    +---+\n                  | TA Y |         | TA Z |        |\
    \ J |    | N |\n                  +------+         +------+        +---+    +---+\n\
    \                   /   \\              / \\            |        |\n         \
    \         /     \\            /   \\           |        |\n                 /\
    \       \\          /     \\          v        v\n                v         v\
    \        v       v       +---+    +----+\n              +---+     +---+    +---+\
    \   +---+     | K |    | EE |\n              | A |<--->| C |    | O |   | P |\
    \     +---+    +----+\n              +---+     +---+    +---+   +---+\n      \
    \           \\         /      /  \\       \\\n                  \\       /   \
    \   /    \\       \\\n                   \\     /      v      v       v\n    \
    \                v   v    +---+    +---+   +---+\n                    +---+  \
    \  | Q |    | R |   | S |\n                    | B |    +---+    +---+   +---+\n\
    \                    +---+               |\n                      /\\        \
    \        |\n                     /  \\               |\n                    v\
    \    v              v\n                 +---+  +---+         +---+\n         \
    \        | E |  | D |         | T |\n                 +---+  +---+         +---+\n\
    \                       Figure 9 - Four Bridged PKIs\n   Figure 9 depicts four\
    \ root certification authorities cross-certified\n   with a Bridge CA (BCA). \
    \ While multiple trust anchors are shown in\n   the Figure, our examples all consider\
    \ TA Z as the trust anchor.  The\n   other trust anchors serve different relying\
    \ parties.  By building\n   certification paths through the BCA, trust can be\
    \ extended across the\n   four infrastructures.  In Figure 9, the BCA has four\
    \ certificates\n   issued to it; one issued from each of the trust anchors in\
    \ the graph.\n   If stored in the BCA directory system, the four certificates\
    \ issued\n   to the BCA would be stored in the issuedToThisCA (forward) entry\
    \ of\n   four different crossCertificatePair structures.  The BCA also has\n \
    \  issued four certificates, one to each of the trust anchors.  If\n   stored\
    \ in the BCA directory system, those certificates would be\n   stored in the issuedByThisCA\
    \ (reverse) entry of the same four\n   crossCertificatePair structures.  (Note\
    \ that the cross-certificates\n   are stored as matched pairs in the crossCertificatePair\
    \ attribute.\n   For example, a crossCertificatePair structure might contain both\
    \ A(B)\n   and B(A), but not contain A(C) and B(A).)  The four\n   crossCertificatePair\
    \ structures would then be stored in the BCA's\n   directory entry in the crossCertificatePair\
    \ attribute.\n"
- title: 2.4.1.  Certificate Repetition
  contents:
  - "2.4.1.  Certificate Repetition\n   [X.509] requires that certificates are not\
    \ repeated when building\n   paths.  For instance, from the figure above, do not\
    \ build the path TA\n   Z->BCA->Y->A->C->A->C->B->D.  Not only is the repetition\
    \ unnecessary\n   to build the path from Z to D, but it also requires the reuse\
    \ of a\n   certificate (the one issued from C to A), which makes the path non-\n\
    \   compliant with [X.509].\n   What about the following path from TA Z to EE?\n\
    \               TA Z->BCA->Y->BCA->W->BCA->X->L->N->EE\n   Unlike the first example,\
    \ this path does not require a developer to\n   repeat any certificates; therefore,\
    \ it is compliant with [X.509].\n   Each of the BCA certificates is issued from\
    \ a different source and is\n   therefore a different certificate.  Suppose now\
    \ that the bottom left\n   PKI (in Figure 9) had double arrows between Y and C,\
    \ as well as\n   between Y and A.  The following path could then be built:\n \
    \              TA Z->BCA->Y->A->C->Y->BCA->W->BCA->X->L->N->EE\n   A path such\
    \ as this could become arbitrarily complex and traverse\n   every cross-certified\
    \ CA in every PKI in a cross-certified\n   environment while still remaining compliant\
    \ with [X.509].  As a\n   practical matter, the path above is not something an\
    \ application\n   would typically want or need to build for a variety of reasons:\n\
    \      - First, certification paths like the example above are generally\n   \
    \     not intended by the PKI designers and should not be necessary in\n     \
    \   order to validate any given certificate.  If a convoluted path\n        such\
    \ as the example above is required (there is no corresponding\n        simple\
    \ path) in order to validate a given certificate, this is\n        most likely\
    \ indicative of a flaw in the PKI design.\n      - Second, the longer a path becomes,\
    \ the greater the potential\n        dilution of trust in the certification path.\
    \  That is, with each\n        successive link in the infrastructure (i.e., certification\
    \ by\n        CAs and cross-certification between CAs) some amount of\n      \
    \  assurance may be considered lost.\n      - Third, the longer and more complicated\
    \ a path, the less likely\n        it is to validate because of basic constraints,\
    \ policies or\n        policy constraints, name constraints, CRL availability,\
    \ or even\n        revocation.\n      - Lastly, and certainly not least important\
    \ from a developer's or\n        user's perspective, is performance.  Allowing\
    \ paths like the one\n        above dramatically increases the number of possible\
    \ paths for\n        every certificate in a mesh or cross-certified environment.\n\
    \        Every path built may require one or more of the following:\n        validation\
    \ of certificate properties, CPU intensive signature\n        validations, CRL\
    \ retrievals, increased network load, and local\n        memory caching.  Eliminating\
    \ the superfluous paths can greatly\n        improve performance, especially in\
    \ the case where no path\n        exists.\n   There is a special case involving\
    \ certificates with the same\n   distinguished names but differing encodings required\
    \ by [RFC3280].\n   This case should not be considered a repeated certificate.\
    \  See\n   Section 5.4 for more information.\n"
- title: 2.4.2.  Introduction to Path-Building Optimization
  contents:
  - "2.4.2.  Introduction to Path-Building Optimization\n   How can these superfluous\
    \ paths be eliminated?  Rather than only\n   disallowing identical certificates\
    \ from repeating, it is recommended\n   that a developer disallow the same public\
    \ key and subject name pair\n   from being repeated.  For maximum flexibility,\
    \ the subject name\n   should collectively include any subject alternative names.\
    \  Using\n   this approach, all of the intended and needed paths should be\n \
    \  available, and the excess and diluted paths should be eliminated.\n   For example,\
    \ using this approach, only one path exists from the TA Z\n   to EE in the diagram\
    \ above: TA Z->BCA->X->L->N->EE.\n   Given the simplifying rule of not repeating\
    \ pairs of subject names\n   (including subject alternative names) and public\
    \ keys, and only using\n   certificates found in the cACertificate and forward\
    \ (issuedToThisCA)\n   element of the crossCertificatePair attributes, Figure\
    \ 10 depicts the\n   forward path-building decision tree from the EE to all reachable\n\
    \   nodes in the graph.  This is the ideal graph for a path builder\n   attempting\
    \ to build a path from TA Z to EE.\n        +------+       +-----------+     \
    \   +------+   +---+\n        | TA W |<------| Bridge CA |<-------| TA X |<--|\
    \ L |\n        +------+       +-----------+        +------+   +---+\n        \
    \                  /     \\                        ^\n                       \
    \  /       \\                        \\\n                        /         \\\
    \                        \\\n                       v           v            \
    \            \\\n                 +------+         +------+                 +---+\n\
    \                 | TA Y |         | TA Z |                 | N |\n          \
    \       +------+         +------+                 +---+\n                    \
    \                                         ^\n                                \
    \                              \\\n                                          \
    \                     \\\n                                                   \
    \          +----+\n                                                          \
    \   | EE |\n                                                             +----+\n\
    \             Figure 10 - Forward (From Entity) Decision Tree\n   It is not possible\
    \ to build forward direction paths into the\n   infrastructures behind CAs W,\
    \ Y, and Z, because W, Y, and Z have not\n   been issued certificates by their\
    \ subordinate CAs.  (The subordinate\n   CAs are F and G, A and C, and O and P,\
    \ respectively.)  If simplicity\n   and speed are desirable, the graph in Figure\
    \ 10 is a very appealing\n   way to structure the path-building algorithm.  Finding\
    \ a path from\n   the EE to one of the four trust anchors is reasonably simple.\n\
    \   Alternately, a developer could choose to build in the opposite\n   direction,\
    \ using the reverse cross-certificates from any one of the\n   four trust anchors\
    \ around the BCA.  The graph in Figure 11 depicts\n   all possible paths as a\
    \ tree emanating from TA Z.  (Note: it is not\n   recommended that implementations\
    \ attempt to determine all possible\n   paths, this would require retrieval and\
    \ storage of all PKI data\n   including certificates and CRLs!  This example is\
    \ provided to\n   demonstrate the complexity which might be encountered.)\n  \
    \   +---+    +---+\n     | I |--->| H |\n     +---+    +---+\n       ^\n     \
    \  |      +---+    +---+\n       |      | H |--->| I |\n       |      +---+  \
    \  +---+\n     +---+     ^\n     | G |    /      +---+    +---+    +---+\n   \
    \  +---+   /       | F |--->| H |--->| I |\n       ^    /        +---+    +---+\
    \    +---+\n        \\  /          ^\n         \\/          /\n        +---+ \
    \   +---+    +---+    +---+                +---+\n        | F |    | G |--->|\
    \ I |--->| H |                | M |\n        +---+    +---+    +---+    +---+\
    \                +---+\n          ^      ^                                   \
    \     ^\n          |     /                                         |\n       \
    \ +------+       +-----------+         +------+   +---+\n        | TA W |<------|\
    \ Bridge CA |-------->| TA X |-->| L |\n        +------+       +-----------+ \
    \        +------+   +---+\n                        /          ^              \\\
    \         \\\n                       v            \\              v         v\n\
    \                 +------+            +------+     +---+     +---+\n         \
    \        | TA Y |            | TA Z |     | J |     | N |\n                 +------+\
    \            +------+     +---+     +---+\n                /       \\        \
    \      /     \\        \\       \\\n               v         v            v  \
    \     v        v       v\n            +---+      +---+        +---+   +---+  \
    \  +---+  +----+\n            | A |      | C |        | O |   | P |    | K | \
    \ | EE |\n            +---+      +---+        +---+   +---+    +---+  +----+\n\
    \            /   \\       /   \\       /   \\        \\\n           v     v  \
    \   v     v     v     v        v\n        +---+ +---+ +---+ +---+ +---+ +---+\
    \     +---+\n        | B | | C | | A | | B | | Q | | R |     | S |\n        +---+\
    \ +---+ +---+ +---+ +---+ +---+     +---+\n        /    \\     \\    \\    \\\
    \      \\     \\\n       v      v     v    v    v      v     v\n     +---+ +---+\
    \ +---+ +---+ +---+  +---+  +---+\n     | E | | D | | B | | B | | E |  | D | \
    \ | T |\n     +---+ +---+ +---+ +---+ +---+  +---+  +---+\n                 /\
    \  |    |  \\\n               v    v    v   v\n           +---+ +---+ +---+ +---+\n\
    \           | E | | D | | E | | D |\n           +---+ +---+ +---+ +---+\n    \
    \         Figure 11 - Reverse (From Anchor) Decision Tree\n   Given the relative\
    \ complexity of this decision tree, it becomes clear\n   that making the right\
    \ choices while navigating the tree can make a\n   large difference in how quickly\
    \ a valid path is returned.  The path-\n   building software could potentially\
    \ traverse the entire graph before\n   choosing the shortest path:  TA Z->BCA->X->L->N->EE.\
    \  With a decision\n   tree like the one above, the basic depth first traversal\
    \ approach\n   introduces obvious inefficiencies in the path-building process.\
    \  To\n   compensate for this, a path-building module needs to decide not only\n\
    \   in which direction to traverse the tree, but also which branches of\n   the\
    \ tree are more likely to yield a valid path.\n   The path-building algorithm\
    \ then ideally becomes a tree traversal\n   algorithm with weights or priorities\
    \ assigned to each branch point to\n   guide the decision making.  If properly\
    \ designed, such an approach\n   would effectively yield the \"best path first\"\
    \ more often than not.\n   (The terminology \"best path first\" is quoted because\
    \ the definition\n   of the \"best\" path may differ from PKI to PKI.  That is\
    \ ultimately to\n   be determined by the developer, not by this document.)  Finding\
    \ the\n   \"best path first\" is an effort to make the implementation efficient,\n\
    \   which is one of our criteria as stated in Section 2.2.\n   So how would a\
    \ developer go about finding the best path first?  Given\n   the simplifying idea\
    \ of addressing path building as a tree traversal,\n   path building could be\
    \ structured as a depth first search.  A simple\n   example of depth first tree\
    \ traversal path building is depicted in\n   Figure 12, with no preference given\
    \ to sort order.\n   Note: The arrows in the lower portion of the figure do not\
    \ indicate\n   the direction of certificate issuance; they indicate the direction\
    \ of\n   the tree traversal from the target certificate (EE).\n              \
    \ +----+                        +----+  +----+\n               | TA |        \
    \                | TA |  | TA |\n               +----+                       \
    \ +----+  +----+\n                /  \\                           ^     ^\n  \
    \             /    \\                           |     |\n              v     \
    \ v                        +---+ +---+\n            +---+   +---+            \
    \         | A | | C |\n            | A |<->| C |                     +---+ +---+\n\
    \            +---+   +---+                        ^   ^\n              ^     \
    \ ^                   +----+  |   |  +----+\n               \\    /          \
    \          | TA |  |   |  | TA |\n                v  v                     +----+\
    \  |   |  +----+\n               +---+                         ^   |   |   ^\n\
    \               | B |                          \\  |   |  /\n               +---+\
    \                           \\ |   | /\n                / \\                 \
    \          +---+ +---+\n               /   \\                          | C | |\
    \ A |\n              v     v                         +---+ +---+\n           \
    \ +---+ +---+                          ^    ^\n            | E | | D |       \
    \                   |   /\n            +---+ +---+                          |\
    \  /\n                                                +---+\n          Infrastructure\
    \                        | B |\n                                             \
    \   +---+\n                                                  ^\n             \
    \                                     |\n                                    \
    \           +----+\n                                               | EE |\n  \
    \                                             +----+\n                       \
    \               The Same Infrastructure\n                                    \
    \   Represented as a Tree\n                    +----+               +----+\n \
    \                   | TA |               | TA |\n                    +----+  \
    \             +----+\n                       ^                    ^\n        \
    \               |                    |\n                      +---+          \
    \     +---+\n                      | A |               | C |\n               \
    \       +---+               +---+\n   +----+                ^                \
    \ ^                 +----+\n   | TA |                |                 |     \
    \            | TA |\n   +----+                |                 |            \
    \     +----+\n      ^                  |                 |                   ^\n\
    \       \\                 |                 |                  /\n      +---+\
    \           +---+                +---+           +---+\n      | C |          \
    \ | C |                | A |           | A |\n      +---+           +---+    \
    \            +---+           +---+\n         ^               ^               \
    \     ^               ^\n         |               |                   /      \
    \         /\n         |               |                  /               /\n \
    \       +---+           +---+          +---+           +---+\n        | B |  \
    \         | B |          | B |           | B |\n        +---+           +---+\
    \          +---+           +---+\n          ^               ^              ^ \
    \              ^\n          |               |              |               |\n\
    \          |               |              |               |\n        +----+  \
    \        +----+         +----+          +----+\n        | EE |          | EE |\
    \         | EE |          | EE |\n        +----+          +----+         +----+\
    \          +----+\n                     All possible paths from EE to TA\n   \
    \             using a depth first decision tree traversal\n       Figure 12 -\
    \ Path Building Using a Depth First Tree Traversal\n   Figure 12 illustrates that\
    \ four possible paths exist for this\n   example.  Suppose that the last path\
    \ (TA->A->B->EE) is the only path\n   that will validate.  This could be for any\
    \ combination of reasons\n   such as name constraints, policy processing, validity\
    \ periods, or\n   path length constraints.  The goal of an efficient path-building\n\
    \   component is to select the fourth path first by testing properties of\n  \
    \ the certificates as the tree is traversed.  For example, when the\n   path-building\
    \ software is at entity B in the graph, it should examine\n   both choices A and\
    \ C to determine which certificate is the most\n   likely best choice.  An efficient\
    \ module would conclude that A is the\n   more likely correct path.  Then, at\
    \ A, the module compares\n   terminating the path at TA, or moving to C.  Again,\
    \ an efficient\n   module will make the better choice (TA) and thereby find the\
    \ \"best\n   path first\".\n   What if the choice between CA certificates is not\
    \ binary as it was in\n   the previous example?  What if the path-building software\
    \ encounters\n   a branch point with some arbitrary number of CA certificates\
    \ thereby\n   creating the same arbitrary number of tree branches?  (This would\
    \ be\n   typical in a mesh style PKI CA, or at a Bridge CA directory entry, as\n\
    \   each will have multiple certificates issued to itself from other\n   CAs.)\
    \  This situation actually does not change the algorithm at all,\n   if it is\
    \ structured properly.  In our example, rather than treating\n   each decision\
    \ as binary (i.e., choosing A or C), the path-building\n   software should sort\
    \ all the available possibilities at any given\n   branch point, and then select\
    \ the best choice from the list.  In the\n   event the path could not be built\
    \ through the first choice, then the\n   second choice should be tried next upon\
    \ traversing back to that point\n   in the tree.  Continue following this pattern\
    \ until a path is found\n   or all CA nodes in the tree have been traversed. \
    \ Note that the\n   certificates at any given point in the tree should only be\
    \ sorted at\n   the time a decision is first made.  Specifically, in the example,\
    \ the\n   sorting of A and C is done when the algorithm reached B.  There is no\n\
    \   memory resident representation of the entire tree.  Just like any\n   other\
    \ recursive depth first search algorithm, the only information\n   the algorithm\
    \ needs to keep track of is what nodes (entities) in the\n   tree lie behind it\
    \ on the current path, and for each of those nodes,\n   which arcs (certificates)\
    \ have already been tried.\n"
- title: 2.5.  Building Certification Paths for Revocation Signer Certificates
  contents:
  - "2.5.  Building Certification Paths for Revocation Signer Certificates\n   Special\
    \ consideration is given to building a certification path for\n   the Revocation\
    \ Signer certificate because it may or may not be the\n   same as the Certification\
    \ Authority certificate.  For example, after\n   a CA performs a key rollover,\
    \ the new CA certificate will be the CRL\n   Signer certificate, whereas the old\
    \ CA certificate is the\n   Certification Authority certificate for previously\
    \ issued\n   certificates.  In the case of indirect CRLs, the CRL Signer\n   certificate\
    \ will contain a different name and key than the\n   Certification Authority certificate.\
    \  In the case of OCSP, the\n   Revocation Signer certificate may represent an\
    \ OCSP Responder that is\n   not the same entity as the Certification Authority.\n\
    \   When the Revocation Signer certificate and the Certification\n   Authority\
    \ certificate are identical, no additional consideration is\n   required from\
    \ a certification path-building standpoint.  That is, the\n   certification path\
    \ built (and validated) for the Certification\n   Authority certificate can also\
    \ be used as the certification path for\n   the Revocation Signer certificate.\
    \  In this case, the signature on\n   the revocation data (e.g., CRL or OCSP response)\
    \ is verified using\n   the same certificate, and no other certification path\
    \ building is\n   required.  An efficient certification path validation algorithm\n\
    \   should first try all possible CRLs issued by the Certification\n   Authority\
    \ to determine if any of the CRLs (a) cover the certificate\n   in question, (b)\
    \ are current, and (c) are signed using the same key\n   used to sign the certificate.\n\
    \   When the Revocation Signer certificate is not identical to the\n   Certification\
    \ Authority certificate, a certification path must be\n   built (and validated)\
    \ for the Revocation Signer certificate.  In\n   general, the certification path-building\
    \ software may build the path\n   as it would for any other certificate.  However,\
    \ this document also\n   outlines methods in later sections for greatly improving\
    \ path\n   building efficiency for Revocation Signer certificate case.\n"
- title: 2.6.  Suggested Path-Building Software Components
  contents:
  - "2.6.  Suggested Path-Building Software Components\n   There is no single way\
    \ to define an interface to a path-building\n   module.  It is not the intent\
    \ of this document to prescribe a\n   particular method or semantic; rather, it\
    \ is up to the implementer to\n   decide.  There are many ways this could be done.\
    \  For example, a\n   path-building module could build every conceivable path\
    \ and return\n   the entire list to the caller.  Or, the module could build until\
    \ it\n   finds just one that validates and then terminate the procedure.  Or,\n\
    \   it could build paths in an iterative fashion, depending on validation\n  \
    \ outside of the builder and successive calls to the builder to get\n   more paths\
    \ until one valid path is found or all possible paths have\n   been found.  All\
    \ of these are possible approaches, and each of these\n   may offer different\
    \ benefits to a particular environment or\n   application.\n   Regardless of semantics,\
    \ a path-building module needs to contain the\n   following components:\n   1)\
    \ The logic for building and traversing the certificate graph.\n   2) Logic for\
    \ retrieving the necessary certificates (and CRLs and/or\n      other revocation\
    \ status information if the path is to be\n      validated) from the available\
    \ source(s).\n   Assuming a more efficient and agile path-building module is desired,\n\
    \   the following is a good starting point and will tie into the\n   remainder\
    \ of this document.  For a path-building module to take full\n   advantage of\
    \ all the suggested optimizations listed in this document,\n   it will need all\
    \ of the components listed below.\n   1) A local certificate and CRL cache.\n\
    \      a. This may be used by all certificate-using components; it does\n    \
    \     not need to be specific to the path-building software.  A local\n      \
    \   cache could be memory resident, stored in an operating system\n         or\
    \ application certificate store, stored in a database, or even\n         stored\
    \ in individual files on the hard disk.  While the\n         implementation of\
    \ this cache is beyond the scope of this\n         document, some design considerations\
    \ are listed below.\n   2) The logic for building and traversing the certificate\
    \ graph/tree.\n      a. This performs sorting functionality for prioritizing\n\
    \         certificates (thereby optimizing path building) while\n         traversing\
    \ the tree.\n      b. There is no need to build a complete graph prior to commencing\n\
    \         path building.  Since path building can be implemented as a\n      \
    \   depth first tree traversal, the path builder only needs to\n         store\
    \ the current location in the tree along with the points\n         traversed to\
    \ the current location.  All completed branches can\n         be discarded from\
    \ memory and future branches are discovered as\n         the tree is traversed.\n\
    \   3) Logic for retrieving the necessary certificates from the available\n  \
    \    certificate source(s):\n      a. Local cache.\n            i. Be able to\
    \ retrieve all certificates for an entity by\n               subject name, as\
    \ well as individual certificates by\n               issuer and serial number\
    \ tuple.\n           ii. Tracking which directory attribute (including\n     \
    \          issuedToThisCA <forward> and issuedByThisCA <reverse>\n           \
    \    for split crossCertificatePair attributes) each\n               certificate\
    \ was found in may be useful.  This allows for\n               functionality such\
    \ as retrieving only forward cross-\n               certificates, etc.\n     \
    \     iii. A \"freshness\" timestamp (cache expiry time) can be used\n       \
    \        to determine when the directory should be searched\n               again.\n\
    \      b. LDAPv3 directory for certificates and CRLs.\n            i. Consider\
    \ supporting multiple directories for general\n               queries.\n     \
    \      ii. Consider supporting dynamic LDAP connections for\n               retrieving\
    \ CRLs using an LDAP URI [RFC3986] in the CRL\n               distribution point\
    \ certificate extension.\n          iii. Support LDAP referrals.  This is typically\
    \ only a matter\n               of activating the appropriate flag in the LDAP\
    \ API.\n      c. HTTP support for CRL distribution points and authority\n    \
    \     information access (AIA) support.\n          i. Consider HTTPS support,\
    \ but be aware that this may create\n             an unbounded recursion when\
    \ the implementation tries to\n             build a certification path for the\
    \ server's certificate if\n             this in turn requires an additional HTTPS\
    \ lookup.\n   4) A certification path cache that stores previously validated\n\
    \      relationships between certificates.  This cache should include:\n     \
    \ a. A configurable expiration date for each entry.  This date can\n         be\
    \ configured based upon factors such as the expiry of the\n         information\
    \ used to determine the validity of an entry,\n         bandwidth, assurance level,\
    \ storage space, etc.\n      b. Support to store previously verified issuer certificate\
    \ to\n         subject certificate relationships.\n          i. Since the issuer\
    \ DN and serial number tuple uniquely\n             identifies a certificate,\
    \ a pair of these tuples (one for\n             both the issuer and subject) is\
    \ an effective method of\n             storing this relationship.\n      c. Support\
    \ for storing \"known bad\" paths and certificates.  Once a\n         certificate\
    \ is determined to be invalid, implementations can\n         decide not to retry\
    \ path development and validation.\n"
- title: 2.7.  Inputs to the Path-Building Module
  contents:
  - "2.7.  Inputs to the Path-Building Module\n   [X.509] specifically addresses the\
    \ list of inputs required for path\n   validation but makes no specific suggestions\
    \ concerning useful inputs\n   to path building.  However, given that the goal\
    \ of path building is\n   to find certification paths that will validate, it follows\
    \ that the\n   same inputs used for validation could be used to optimize path\n\
    \   building.\n"
- title: 2.7.1.  Required Inputs
  contents:
  - "2.7.1.  Required Inputs\n   Setting aside configuration information such as repository\
    \ or cache\n   locations, the following are required inputs to the certification\n\
    \   path-building process:\n   1) The Target Certificate: The certificate that\
    \ is to be validated.\n      This is one endpoint for the path.  (It is also possible\
    \ to\n      provide information used to retrieve a certificate for a target,\n\
    \      rather than the certificate itself.)\n   2) Trust List: This is the other\
    \ endpoint of the path, and can\n      consist of either:\n      a. Trusted CA\
    \ certificates\n      b. Trusted keys and DNs; a certificate is not necessarily\
    \ required\n"
- title: 2.7.2.  Optional Inputs
  contents:
  - "2.7.2.  Optional Inputs\n   In addition to the inputs listed in Section 2.7.1,\
    \ the following\n   optional inputs can also be useful for optimizing path building.\n\
    \   However, if the path-building software takes advantage of all of the\n   optimization\
    \ methods described later in this document, all of the\n   following optional\
    \ inputs will be required.\n   1) Time (T): The time for which the certificate\
    \ is to be validated\n      (e.g., if validating a historical signature from one\
    \ year ago, T\n      is needed to build a valid path)\n      a. If not included\
    \ as an input, the path-building software should\n         always build for T\
    \ equal to the current system time.\n   2) Initial-inhibit-policy-mapping indicator\n\
    \   3) Initial-require-explicit-policy indicator\n   4) Initial-any-policy-inhibit\
    \ indicator\n   5) Initial user acceptable policy set\n   6) Error handlers (call\
    \ backs or virtual classes)\n   7) Handlers for custom certificate extensions\n\
    \   8) Is-revocation-provider indicator\n      a. IMPORTANT:  When building a\
    \ certification path for an OCSP\n         Responder certificate specified as\
    \ part of the local\n         configuration, this flag should not be set.  It\
    \ is set when\n         building a certification path for a CRL Signer certificate\
    \ or\n         for an OCSP Responder Signer certificate discovered using the\n\
    \         information asserted in an authorityInformationAccess\n         certificate\
    \ extension.\n   9) The complete certification path for the Certification Authority\n\
    \      (if Is-revocation-provider is set)\n   10) Collection of certificates that\
    \ may be useful in building the\n       path\n   11) Collection of certificate\
    \ revocation lists and/or other\n       revocation data\n   The last two items\
    \ are a matter of convenience.  Alternately,\n   certificates and revocation information\
    \ could be placed in a local\n   cache accessible to the path-building module\
    \ prior to attempting to\n   build a path.\n"
- title: 3.  Optimizing Path Building
  contents:
  - "3.  Optimizing Path Building\n   This section recommends methods for optimizing\
    \ path-building\n   processes.\n"
- title: 3.1.  Optimized Path Building
  contents:
  - "3.1.  Optimized Path Building\n   Path building can be optimized by sorting the\
    \ certificates at every\n   decision point (at every node in the tree) and then\
    \ selecting the\n   most promising certificate not yet selected as described in\
    \ Section\n   2.4.2.  This process continues until the path terminates.  This\
    \ is\n   roughly equivalent to the concept of creating a weighted edge tree,\n\
    \   where the edges are represented by certificates and nodes represent\n   subject\
    \ DNs.  However, unlike the weighted edge graph concept, a\n   certification path\
    \ builder need not have the entire graph available\n   in order to function efficiently.\
    \  In addition, the path builder can\n   be stateless with respect to nodes of\
    \ the graph not present in the\n   current path, so the working data set can be\
    \ relatively small.\n   The concept of statelessness with respect to nodes not\
    \ in the current\n   path is instrumental to using the sorting optimizations listed\
    \ in\n   this document.  Initially, it may seem that sorting a given group of\n\
    \   certificates for a CA once and then preserving that sorted order for\n   later\
    \ use would be an efficient way to write the path builder.\n   However, maintaining\
    \ this state can quickly eliminate the efficiency\n   that sorting provides. \
    \ Consider the following diagram:\n            +---+\n            | R |\n    \
    \        +---+\n             ^\n            /\n           v\n         +---+  \
    \     +---+      +---+    +---+    +----+\n         | A |<----->| E |<---->| D\
    \ |--->| Z |--->| EE |\n         +---+       +---+      +---+    +---+    +----+\n\
    \            ^         ^ ^        ^\n             \\       /   \\      /\n   \
    \           \\     /     \\    /\n               v   v       v  v\n          \
    \     +---+       +---+\n               | B |<----->| C |\n               +---+\
    \       +---+\n            Figure 13 - Example of Path-Building Optimization\n\
    \   In this example, the path builder is building in the forward (from\n   target)\
    \ direction for a path between R and EE.  The path builder has\n   also opted\
    \ to allow subject name and key to repeat.  (This will allow\n   multiple traversals\
    \ through any of the cross-certified CAs, creating\n   enough complexity in this\
    \ small example to illustrate proper state\n   maintenance.  Note that a similarly\
    \ complex example could be designed\n   by using multiple keys for each entity\
    \ and prohibiting repetition.)\n   The first step is simple; the builder builds\
    \ the path Z(D)->EE(Z).\n   Next the builder adds D and faces a decision between\
    \ two\n   certificates. (Choose between D(C) or D(E)).  The builder now sorts\n\
    \   the two choices in order of priority.  The sorting is partially based\n  \
    \ upon what is currently in the path.\n   Suppose the order the builder selects\
    \ is [D(E), D(C)].  The current\n   path is now D(E)->Z(D)->EE(Z).  Currently\
    \ the builder has three nodes\n   in the graph (EE, Z, and D) and should maintain\
    \ the state, including\n   sort order of the certificates at D, when adding the\
    \ next node, E.\n   When E is added, the builder now has four certificates to\
    \ sort: E(A),\n   E(B), E(C), and E(D).  In this case, the example builder opts\
    \ for the\n   order [E(C), E(B), E(A), E(D)].  The current path is now E(C)->D(E)->\n\
    \   Z(D)->EE(Z) and the path has four nodes; EE, Z, D, and E.\n   Upon adding\
    \ the fifth node, C, the builder sorts the certificates\n   (C(B), C(D), and C(E))\
    \ at C, and selects C(E).  The path is now\n   C(E)->E(C)->D(E)->Z(D)->EE(Z) and\
    \ the path has five nodes: EE, Z, D,\n   E, and C.\n   Now the builder finds itself\
    \ back at node E with four certificates.\n   If the builder were to use the prior\
    \ sort order from the first\n   encounter with E, it would have [E(C), E(B), E(A),\
    \ E(D)].  In the\n   current path's context, this ordering may be inappropriate.\
    \  To begin\n   with, the certificate E(C) is already in the path so it certainly\n\
    \   does not deserve first place.\n   The best way to handle this situation is\
    \ for the path builder to\n   handle this instance of E as a new (sixth) node\
    \ in the tree.  In\n   other words, there is no state information for this new\
    \ instance of E\n   - it is treated just as any other new node.  The certificates\
    \ at the\n   new node are sorted based upon the current path content and the first\n\
    \   certificate is then selected.  For example, the builder may examine\n   E(B)\
    \ and note that it contains a name constraint prohibiting \"C\".  At\n   this\
    \ point in the decision tree, E(B) could not be added to the path\n   and produce\
    \ a valid result since \"C\" is already in the path.  As a\n   result, the certificate\
    \ E(B) should placed at the bottom of the\n   prioritized list.\n   Alternatively,\
    \ E(B) could be eliminated from this new node in the\n   tree.  It is very important\
    \ to see that this certificate is\n   eliminated only at this node and only for\
    \ the current path.  If path\n   building fails through C and traverses back up\
    \ the tree to the first\n   instance of E, E(B) could still produce a valid path\
    \ that does not\n   include C; specifically R->A->B->E->D->Z->EE.  Thus the state\
    \ at any\n   node should not alter the state of previous or subsequent nodes.\n\
    \   (Except for prioritizing certificates in the subsequent nodes.)\n   In this\
    \ example, the builder should also note that E(C) is already in\n   the path and\
    \ should make it last or eliminate it from this node since\n   certificates cannot\
    \ be repeated in a path.\n   If the builder eliminates both certificates E(B)\
    \ and E(C) at this\n   node, it is now only left to select between E(A) and E(D).\
    \  Now the\n   path has six nodes: EE, Z, D, E(1), C, and E(2).  E(1) has four\n\
    \   certificates, and E(2) has two, which the builder sorts to yield\n   [E(A),\
    \ E(D)].  The current path is now E(A)->C(E)->E(C)->D(E)->\n   Z(D)->EE(Z).  A(R)\
    \ will be found when the seventh node is added to\n   the path and the path terminated\
    \ because one of the trust anchors has\n   been found.\n   In the event the first\
    \ path fails to validate, the path builder will\n   still have the seven nodes\
    \ and associated state information to work\n   with.  On the next iteration, the\
    \ path builder is able to traverse\n   back up the tree to a working decision\
    \ point, such as A, and select\n   the next certificate in the sorted list at\
    \ A.  In this example, that\n   would be A(B).  (A(R) has already been tested.)\
    \  This would dead end,\n   and the builder traverse back up to the next decision\
    \ point, E(2)\n   where it would try D(E).  This process repeats until the traversal\n\
    \   backs all the way up to EE or a valid path is found.  If the tree\n   traversal\
    \ returns to EE, all possible paths have been exhausted and\n   the builder can\
    \ conclude no valid path exists.\n   This approach of sorting certificates in\
    \ order to optimize path\n   building will yield better results than not optimizing\
    \ the tree\n   traversal.  However, the path-building process can be further\n\
    \   streamlined by eliminating certificates, and entire branches of the\n   tree\
    \ as a result, as paths are built.\n"
- title: 3.2.  Sorting vs. Elimination
  contents:
  - "3.2.  Sorting vs. Elimination\n   Consider a situation when building a path in\
    \ which three CA\n   certificates are found for a given target certificate and\
    \ must be\n   prioritized.  When the certificates are examined, as in the previous\n\
    \   example, one of the three has a name constraint present that will\n   invalidate\
    \ the path built thus far.  When sorting the three\n   certificates, that one\
    \ would certainly go to the back of the line.\n   However, the path-building software\
    \ could decide that this condition\n   eliminates the certificate from consideration\
    \ at this point in the\n   graph, thereby reducing the number of certificate choices\
    \ by 33% at\n   this point.\n   NOTE: It is important to understand that the elimination\
    \ of a\n   certificate only applies to a single decision point during the tree\n\
    \   traversal.  The same certificate may appear again at another point in\n  \
    \ the tree; at that point it may or may not be eliminated.  The\n   previous section\
    \ details an example of this behavior.\n   Elimination of certificates could potentially\
    \ eliminate the traversal\n   of a large, time-consuming infrastructure that will\
    \ never lead to a\n   valid path.  The question of whether to sort or eliminate\
    \ is one that\n   pits the flexibility of the software interface against efficiency.\n\
    \   To be clear, if one eliminates invalid paths as they are built,\n   returning\
    \ only likely valid paths, the end result will be an\n   efficient path-building\
    \ module.  The drawback to this is that unless\n   the software makes allowances\
    \ for it, the calling application will\n   not be able to see what went wrong.\
    \  The user may only see the\n   unrevealing error message: \"No certification\
    \ path found.\"\n   On the other hand, the path-building module could opt to not\
    \ rule out\n   any certification paths.  The path-building software could then\n\
    \   return any and all paths it can build from the certificate graph.  It\n  \
    \ is then up to the validation engine to determine which are valid and\n   which\
    \ are invalid.  The user or calling application can then have\n   complete details\
    \ on why each and every path fails to validate.  The\n   drawback is obviously\
    \ one of performance, as an application or end\n   user may wait for an extended\
    \ period of time while cross-certified\n   PKIs are navigated in order to build\
    \ paths that will never validate.\n   Neither option is a very desirable approach.\
    \  One option provides\n   good performance for users, which is beneficial.  The\
    \ other option\n   though allows administrators to diagnose problems with the\
    \ PKI,\n   directory, or software.  Below are some recommendations to reach a\n\
    \   middle ground on this issue.\n   First, developers are strongly encouraged\
    \ to output detailed log\n   information from the path-building software.  The\
    \ log should\n   explicitly indicate every choice the builder makes and why. \
    \ It\n   should clearly identify which certificates are found and used at each\n\
    \   step in building the path.  If care is taken to produce a useful log,\n  \
    \ PKI administrators and help desk personnel will have ample\n   information to\
    \ diagnose a problem with the PKI.  Ideally, there would\n   be a mechanism for\
    \ turning this logging on and off, so that it is not\n   running all the time.\
    \  Additionally, it is recommended that the log\n   contain information so that\
    \ a developer or tester can recreate the\n   paths tried by the path-building\
    \ software, to assist with diagnostics\n   and testing.\n   Secondly, it is desirable\
    \ to return something useful to the user.\n   The easiest approach is probably\
    \ to implement a \"dual mode\" path-\n   building module.  In the first mode [mode\
    \ 1], the software eliminates\n   any and all paths that will not validate, making\
    \ it very efficient.\n   In the second mode [mode 2], all the sorting methods\
    \ are still\n   applied, but no paths are eliminated based upon the sorting methods.\n\
    \   Having this dual mode allows the module to first fail to find a valid\n  \
    \ path, but still return one invalid path (assuming one exists) by\n   switching\
    \ over to the second mode long enough to generate a single\n   path.  This provides\
    \ a middle ground -- the software is very fast,\n   but still returns something\
    \ that gives the user a more specific error\n   than \"no path found\".\n   Third,\
    \ it may be useful to not rule out any paths, but instead limit\n   the number\
    \ of paths that may be built given a particular input.\n   Assuming the path-building\
    \ module is designed to return the \"best\n   path first\", the paths most likely\
    \ to validate would be returned\n   before this limit is reached.  Once the limit\
    \ is reached the module\n   can stop building paths, providing a more rapid response\
    \ to the\n   caller than one which builds all possible paths.\n   Ultimately,\
    \ the developer determines how to handle the trade-off\n   between efficiency\
    \ and provision of information.  A developer could\n   choose the middle ground\
    \ by opting to implement some optimizations as\n   elimination rules and others\
    \ as not.  A developer could validate\n   certificate signatures, or even check\
    \ revocation status while\n   building the path, and then make decisions based\
    \ upon the outcome of\n   those checks as to whether to eliminate the certificate\
    \ in question.\n   This document suggests the following approach:\n   1) While\
    \ building paths, eliminate any and all certificates that do\n      not satisfy\
    \ all path validation requirements with the following\n      exceptions:\n   \
    \   a. Do not check revocation status if it requires a directory\n         lookup\
    \ or network access\n      b. Do not check digital signatures (see Section 8.1,\
    \ General\n         Considerations for Building A Certification Path, for\n  \
    \       additional considerations).\n      c. Do not check anything that cannot\
    \ be checked as part of the\n         iterative process of traversing the tree.\n\
    \      d. Create a detailed log, if this feature is enabled.\n      e. If a path\
    \ cannot be found, the path builder shifts to \"mode 2\"\n         and allows\
    \ the building of a single bad path.\n            i. Return the path with a failure\
    \ indicator, as well as\n               error information detailing why the path\
    \ is bad.\n   2) If path building succeeds, validate the path in accordance with\n\
    \      [X.509] and [RFC3280] with the following recommendations:\n      a. For\
    \ a performance boost, do not re-check items already checked\n         by the\
    \ path builder. (Note: if pre-populated paths are supplied\n         to the path-building\
    \ system, the entire path has to be fully\n         re-validated.)\n      b. If\
    \ the path validation failed, call the path builder again to\n         build another\
    \ path.\n            i. Always store the error information and path from the\n\
    \               first iteration and return this to the user in the event\n   \
    \            that no valid path is found.  Since the path-building\n         \
    \      software was designed to return the \"best path first\",\n            \
    \   this path should be shown to the user.\n   As stated above, this document\
    \ recommends that developers do not\n   validate digital signatures or check revocation\
    \ status as part of the\n   path-building process.  This recommendation is based\
    \ on two\n   assumptions about PKI and its usage.  First, signatures in a working\n\
    \   PKI are usually good.  Since signature validation is costly in terms\n   of\
    \ processor time, it is better to delay signature checking until a\n   complete\
    \ path is found and then check the signatures on each\n   certificate in the certification\
    \ path starting with the trust anchor\n   (see Section 8.1).  Second, it is fairly\
    \ uncommon in typical\n   application environments to encounter a revoked certificate;\n\
    \   therefore, most certificates validated will not be revoked.  As a\n   result,\
    \ it is better to delay retrieving CRLs or other revocation\n   status information\
    \ until a complete path has been found.  This\n   reduces the probability of retrieving\
    \ unneeded revocation status\n   information while building paths.\n"
- title: 3.3.  Representing the Decision Tree
  contents:
  - "3.3.  Representing the Decision Tree\n   There are a multitude of ways to implement\
    \ certification path\n   building and as many ways to represent the decision tree\
    \ in memory.\n   The method described below is an approach that will work well\
    \ with\n   the optimization methods listed later in this document.  Although\n\
    \   this approach is the best the authors of this document have\n   implemented,\
    \ it is by no means the only way to implement it.\n   Developers should tailor\
    \ this approach to their own requirements or\n   may find that another approach\
    \ suits their environment, programming\n   language, or programming style.\n"
- title: 3.3.1.  Node Representation for CA Entities
  contents:
  - "3.3.1.  Node Representation for CA Entities\n   A \"node\" in the certification\
    \ graph is a collection of CA\n   certificates with identical subject DNs.  Minimally,\
    \ for each node,\n   in order to fully implement the optimizations to follow,\
    \ the path-\n   building module will need to be able to keep track of the following\n\
    \   information:\n   1. Certificates contained in the node\n   2. Sorted order\
    \ of the certificates\n   3. \"Current\" certificate indicator\n   4. The current\
    \ policy set (It may be split into authority and user\n      constrained sets,\
    \ if desired.)\n      - It is suggested that encapsulating the policy set in an\
    \ object\n        with logic for manipulating the set such as performing\n   \
    \     intersections, mappings, etc., will simplify implementation.\n   5. Indicators\
    \ (requireExplicitPolicy, inhibitPolicyMapping,\n      anyPolicyInhibit) and corresponding\
    \ skipCert values\n   6. A method for indicating which certificates are eliminated\
    \ or\n      removing them from the node.\n      - If nodes are recreated from\
    \ the cache on demand, it may be\n        simpler to remove eliminated certificates\
    \ from the node.\n   7. A \"next\" indicator that points to the next node in the\
    \ current\n      path\n   8. A \"previous\" indicator that points to the previous\
    \ node in the\n      current path\n"
- title: 3.3.2.  Using Nodes to Iterate Over All Paths
  contents:
  - "3.3.2.  Using Nodes to Iterate Over All Paths\n   In simplest form, a node is\
    \ created, the certificates are sorted, the\n   next subject DN required is determined\
    \ from the first certificate,\n   and a new node is attached to the certification\
    \ path via the next\n   indicator (Number 7 above).  This process continues until\
    \ the path\n   terminates.  (Note: end entity certificates may not contain subject\n\
    \   DNs as allowed by [RFC3280].  Since end entity certificates by\n   definition\
    \ do not issue certificates, this has no impact on the\n   process.)\n   Keeping\
    \ in mind that the following algorithm is designed to be\n   implemented using\
    \ recursion, consider the example in Figure 12 and\n   assume that the only path\
    \ in the diagram is valid for E is TA->A->\n   B->E:\n   If our path-building\
    \ module is building a path in the forward\n   direction for E, a node is first\
    \ created for E.  There are no\n   certificates to sort because only one certificate\
    \ exists, so all\n   initial values are loaded into the node from E.  For example,\
    \ the\n   policy set is extracted from the certificate and stored in the node.\n\
    \   Next, the issuer DN (B) is read from E, and new node is created for B\n  \
    \ containing both certificates issued to B -- B(A) and B(C).  The\n   sorting\
    \ rules are applied to these two certificates and the sorting\n   algorithm returns\
    \ B(C);B(A).  This sorted order is stored and the\n   current indicator is set\
    \ to B(C).  Indicators are set and the policy\n   sets are calculated to the extent\
    \ possible with respect to B(C).  The\n   following diagram illustrates the current\
    \ state with the current\n   certificate indicated with a \"*\".\n   +-------------+\
    \    +---------------+\n   | Node 1      |    | Node 2        |\n   | Subject:\
    \ E  |--->| Subject: B    |\n   | Issuers: B* |    | Issuers: C*,A |\n   +-------------+\
    \    +---------------+\n   Next, a node is created for C and all three certificates\
    \ are added to\n   it.  The sorting algorithm happens to return the certificates\
    \ sorted\n   in the following order: C(TA);C(A);C(B)\n   +-------------+    +---------------+\
    \    +------------------+\n   | Node 1      |    | Node 2        |    | Node 3\
    \           |\n   | Subject: E  |--->| Subject: B    |--->| Subject: C       |\n\
    \   | Issuers: B  |    | Issuers: C*,A |    | Issuers: TA*,A,B |\n   +-------------+\
    \    +---------------+    +------------------+\n   Recognizing that the trust\
    \ anchor has been found, the path\n   (TA->C->B->E) is validated but fails. (Remember\
    \ that the only valid\n   path happens to be TA->A->B->E.)  The path-building\
    \ module now moves\n   the current certificate indicator in node 3 to C(A), and\
    \ adds the\n   node for A.\n      +-------------+    +---------------+    +------------------+\n\
    \      | Node 1      |    | Node 2        |    | Node 3           |\n      | Subject:\
    \ E  |--->| Subject: B    |--->| Subject: C       |\n      | Issuers: B  |   \
    \ | Issuers: C*,A |    | Issuers: TA,A*,B |\n      +-------------+    +---------------+\
    \    +------------------+\n                                                  \
    \      |\n                                                        v\n        \
    \                                      +------------------+\n                \
    \                              | Node 4           |\n                        \
    \                      | Subject: A       |\n                                \
    \              | Issuers: TA*,C,B |\n                                        \
    \      +------------------+\n   The path TA->A->C->B->E is validated and it fails.\
    \  The path-building\n   module now moves the current indicator in node 4 to A(C)\
    \ and adds a\n   node for C.\n   +-------------+    +---------------+    +------------------+\n\
    \   | Node 1      |    | Node 2        |    | Node 3           |\n   | Subject:\
    \ E  |--->| Subject: B    |--->| Subject: C       |\n   | Issuers: B  |    | Issuers:\
    \ C*,A |    | Issuers: TA,A*,B |\n   +-------------+    +---------------+    +------------------+\n\
    \                                                     |\n                    \
    \                                 v\n                   +------------------+ \
    \   +------------------+\n                   | Node 5           |    | Node 4\
    \           |\n                   | Subject: C       |<---| Subject: A       |\n\
    \                   | Issuers: TA*,A,B |    | Issuers: TA,C*,B |\n           \
    \        +------------------+    +------------------+\n   At this juncture, the\
    \ decision of whether to allow repetition of name\n   and key comes to the forefront.\
    \  If the certification path-building\n   module will NOT allow repetition of\
    \ name and key, there are no\n   certificates in node 5 that can be used. (C and\
    \ the corresponding\n   public key is already in the path at node 3.)  At this\
    \ point, node 5\n   is removed from the current path and the current certificate\n\
    \   indicator on node 4 is moved to A(B).\n   If instead, the module is only disallowing\
    \ repetition of\n   certificates, C(A) is eliminated from node 5 since it is in\
    \ use in\n   node 3, and path building continues by first validating TA->C->A->\n\
    \   C->B->E, and then continuing to try to build paths through C(B).\n   After\
    \ this also fails to provide a valid path, node 5 is removed from\n   the current\
    \ path and the current certificate indicator on node 4 is\n   moved to A(B).\n\
    \      +-------------+    +---------------+    +------------------+\n      | Node\
    \ 1      |    | Node 2        |    | Node 3           |\n      | Subject: E  |--->|\
    \ Subject: B    |--->| Subject: C       |\n      | Issuers: B  |    | Issuers:\
    \ C*,A |    | Issuers: TA,A*,B |\n      +-------------+    +---------------+ \
    \   +------------------+\n                                                   \
    \     |\n                                                        v\n         \
    \                                     +------------------+\n                 \
    \                             | Node 4           |\n                         \
    \                     | Subject: A       |\n                                 \
    \             | Issuers: TA,C,B* |\n                                         \
    \     +------------------+\n   Now a new node 5 is created for B.  Just as with\
    \ the prior node 5, if\n   not repeating name and key, B also offers no certificates\
    \ that can be\n   used (B and B's public key is in use in node 2) so the new node\
    \ 5 is\n   also removed from the path.  At this point all certificates in node\
    \ 4\n   have now been tried, so node 4 is removed from the path, and the\n   current\
    \ indicator on node 3 is moved to C(B).\n   Also as above, if allowing repetition\
    \ of name and key, B(C) is\n   removed from the new node 5 (B(C) is already in\
    \ use in node 3) and\n   paths attempted through the remaining certificate B(A).\
    \  After this\n   fails, it will lead back to removing node 5 from the path. \
    \ At this\n   point all certificates in node 4 have now been tried, so node 4\
    \ is\n   removed from the path, and the current indicator on node 3 is moved\n\
    \   to C(B).\n   This process continues until all certificates in node 1 (if there\n\
    \   happened to be more than one) have been tried, or until a valid path\n   has\
    \ been found.  Once the process ends and in the event no valid path\n   was found,\
    \ it may be concluded that no path can be found from E to\n   TA.\n"
- title: 3.4.  Implementing Path-Building Optimization
  contents:
  - "3.4.  Implementing Path-Building Optimization\n   The following section describes\
    \ methods that may be used for\n   optimizing the certification path-building\
    \ process by sorting\n   certificates.  Optimization as described earlier seeks\
    \ to prioritize\n   a list of certificates, effectively prioritizing (weighting)\
    \ branches\n   of the graph/tree.  The optimization methods can be used to assign\
    \ a\n   cumulative score to each certificate.  The process of scoring the\n  \
    \ certificates amounts to testing each certificate against the\n   optimization\
    \ methods a developer chooses to implement, and then\n   adding the score for\
    \ each test to a cumulative score for each\n   certificate.  After this is completed\
    \ for each certificate at a given\n   branch point in the builder's decision tree,\
    \ the certificates can be\n   sorted so that the highest scoring certificate is\
    \ selected first, the\n   second highest is selected second, etc.\n   For example,\
    \ suppose the path builder has only these two simple\n   sorting methods:\n  \
    \ 1) If the certificate has a subject key ID, +5 to score.\n   2) If the certificate\
    \ has an authority key ID, +10 to score.\n   And it then examined three certificates:\n\
    \   1) Issued by CA 1; has authority key ID; score is 10.\n   2) Issued by CA\
    \ 2; has subject key ID; score is 5.\n   3) Issued by CA 1; has subject key ID\
    \ and authority key ID; score is\n      15.\n   The three certificates are sorted\
    \ in descending order starting with\n   the highest score: 3, 1, and 2.  The path-building\
    \ software should\n   first try building the path through certificate 3.  Failing\
    \ that, it\n   should try certificate 1.  Lastly, it should try building a path\n\
    \   through certificate 2.\n   The following optimization methods specify tests\
    \ developers may\n   choose to perform, but does not suggest scores for any of\
    \ the\n   methods.  Rather, developers should evaluate each method with respect\n\
    \   to the environment in which the application will operate, and assign\n   weights\
    \ to each accordingly in the path-building software.\n   Additionally, many of\
    \ the optimization methods are not binary in\n   nature.  Some are tri-valued,\
    \ and some may be well suited to sliding\n   or exponential scales.  Ultimately,\
    \ the implementer decides the\n   relative merits of each optimization with respect\
    \ to his or her own\n   software or infrastructure.\n   Over and above the scores\
    \ for each method, many methods can be used\n   to eliminate branches during the\
    \ tree traversal rather than simply\n   scoring and weighting them.  All cases\
    \ where certificates could be\n   eliminated based upon an optimization method\
    \ are noted with the\n   method descriptions.\n   Many of the sorting methods\
    \ described below are based upon what has\n   been perceived by the authors as\
    \ common in PKIs.  Many of the methods\n   are aimed at making path building for\
    \ the common PKI fast, but there\n   are cases where most any sorting method could\
    \ lead to inefficient\n   path building.  The desired behavior is that although\
    \ one method may\n   lead the algorithm in the wrong direction for a given situation\
    \ or\n   configuration, the remaining methods will overcome the errant\n   method(s)\
    \ and send the path traversal down the correct branch of the\n   tree more often\
    \ than not.  This certainly will not be true for every\n   environment and configuration,\
    \ and these methods may need to be\n   tweaked for further optimization in the\
    \ application's target\n   operating environment.\n   As a final note, the list\
    \ contained in this document is not intended\n   to be exhaustive.  A developer\
    \ may desire to define additional\n   sorting methods if the operating environment\
    \ dictates the need.\n"
- title: 3.5.  Selected Methods for Sorting Certificates
  contents:
  - "3.5.  Selected Methods for Sorting Certificates\n   The reader should draw no\
    \ specific conclusions as to the relative\n   merits or scores for each of the\
    \ following methods based upon the\n   order in which they appear.  The relative\
    \ merit of any sorting\n   criteria is completely dependent on the specifics of\
    \ the operating\n   environment.  For most any method, an example can be created\
    \ to\n   demonstrate the method is effective and a counter-example could be\n\
    \   designed to demonstrate that it is ineffective.\n   Each sorting method is\
    \ independent and may (or may not) be used to\n   assign additional scores to\
    \ each certificate tested.  The implementer\n   decides which methods to use and\
    \ what weights to assign them.  As\n   noted previously, this list is also not\
    \ exhaustive.\n   In addition, name chaining (meaning the subject name of the\
    \ issuer\n   certificate matches the issuer name of the issued certificate) is\
    \ not\n   addressed as a sorting method since adherence to this is required in\n\
    \   order to build the decision tree to which these methods will be\n   applied.\
    \  Also, unaddressed in the sorting methods is the prevention\n   of repeating\
    \ certificates.  Path builders should handle name chaining\n   and certificate\
    \ repetition irrespective of the optimization approach.\n   Each sorting method\
    \ description specifies whether the method may be\n   used to eliminate certificates,\
    \ the number of possible numeric values\n   (sorting weights) for the method,\
    \ components from Section 2.6 that\n   are required for implementing the method,\
    \ forward and reverse methods\n   descriptions, and finally a justification for\
    \ inclusion of the\n   method.\n   With regard to elimination of certificates,\
    \ it is important to\n   understand that certificates are eliminated only at a\
    \ given decision\n   point for many methods.  For example, the path built up to\n\
    \   certificate X may be invalidated due to name constraints by the\n   addition\
    \ of certificate Y.  At this decision point only, Y could be\n   eliminated from\
    \ further consideration.  At some future decision\n   point, while building this\
    \ same path, the addition of Y may not\n   invalidate the path.\n   For some other\
    \ sorting methods, certificates could be eliminated from\n   the process entirely.\
    \  For example, certificates with unsupported\n   signature algorithms could not\
    \ be included in any path and validated.\n   Although the path builder may certainly\
    \ be designed to operate in\n   this fashion, it is sufficient to always discard\
    \ certificates only\n   for a given decision point regardless of cause.\n"
- title: 3.5.1.  basicConstraints Is Present and cA Equals True
  contents:
  - "3.5.1.  basicConstraints Is Present and cA Equals True\n   May be used to eliminate\
    \ certificates: Yes\n   Number of possible values: Binary\n   Components required:\
    \ None\n   Forward Method:  Certificates with basicConstraints present and\n \
    \  cA=TRUE, or those designated as CA certificates out-of-band have\n   priority.\
    \  Certificates without basicConstraints, with\n   basicConstraints and cA=FALSE,\
    \ or those that are not designated as CA\n   certificates out-of-band may be eliminated\
    \ or have zero priority.\n   Reverse Method:  Same as forward except with regard\
    \ to end entity\n   certificates at the terminus of the path.\n   Justification:\
    \  According to [RFC3280], basicConstraints is required\n   to be present with\
    \ cA=TRUE in all CA certificates, or must be\n   verified via an out-of-band mechanism.\
    \  A valid path cannot be built\n   if this condition is not met.\n"
- title: 3.5.2.  Recognized Signature Algorithms
  contents:
  - "3.5.2.  Recognized Signature Algorithms\n   May be used to eliminate certificates:\
    \ Yes\n   Number of possible values: Binary\n   Components required: None\n  \
    \ Forward Method:  Certificates containing recognized signature and\n   public\
    \ key algorithms [PKIXALGS] have priority.\n   Reverse Method:  Same as forward.\n\
    \   Justification:  If the path-building software is not capable of\n   processing\
    \ the signatures associated with the certificate, the\n   certification path cannot\
    \ be validated.\n"
- title: 3.5.3.  keyUsage Is Correct
  contents:
  - "3.5.3.  keyUsage Is Correct\n   May be used to eliminate certificates:  Yes\n\
    \   Number of possible values:  Binary\n   Components required:  None\n   Forward\
    \ Method:  If keyUsage is present, certificates with\n   keyCertSign set have\
    \ 100% priority.  If keyUsage is present and\n   keyCertSign is not set, the certificate\
    \ may be eliminated or have\n   zero priority.  All others have zero priority.\n\
    \   Reverse Method:  Same as forward except with regard to end entity\n   certificates\
    \ at the terminus of the path.\n   Justification:  A valid certification path\
    \ cannot be built through a\n   CA certificate with inappropriate keyUsage.  Note\
    \ that\n   digitalSignature is not required to be set in a CA certificate.\n"
- title: 3.5.4.  Time (T) Falls within the Certificate Validity
  contents:
  - "3.5.4.  Time (T) Falls within the Certificate Validity\n   May be used to eliminate\
    \ certificates:  Yes\n   Number of possible values:  Binary\n   Components required:\
    \  None\n   Forward Method:  Certificates that contain the required time (T)\n\
    \   within their validity period have 100% priority.  Otherwise, the\n   certificate\
    \ is eliminated or has priority zero.\n   Reverse Method:  Same as forward.\n\
    \   Justification:  A valid certification path cannot be built if T falls\n  \
    \ outside of the certificate validity period.\n   NOTE: Special care should be\
    \ taken to return a meaningful error to\n   the caller, especially in the event\
    \ the target certificate does not\n   meet this criterion, if this sorting method\
    \ is used for elimination.\n   (e.g., the certificate is expired or is not yet\
    \ valid).\n"
- title: 3.5.5.  Certificate Was Previously Validated
  contents:
  - "3.5.5.  Certificate Was Previously Validated\n   May be used to eliminate certificates:\
    \  No\n   Number of possible values:  Binary\n   Components required:  Certification\
    \ Path Cache\n   Forward Method:  A certificate that is present in the certification\n\
    \   path cache has priority.\n   Reverse Method:  Does not apply. (The validity\
    \ of a certificate vs.\n   unknown validity does not infer anything about the\
    \ correct direction\n   in the decision tree.  In other words, knowing the validity\
    \ of a CA\n   certificate does not indicate that the target is more likely found\n\
    \   through that path than another.)\n   Justification:  Certificates in the path\
    \ cache have been validated\n   previously.  Assuming the initial constraints\
    \ have not changed, it is\n   highly likely that the path from that certificate\
    \ to a trust anchor\n   is still valid.  (Changes to the initial constraints may\
    \ cause a\n   certificate previously considered valid to no longer be considered\n\
    \   valid.)\n   Note:  It is important that items in the path cache have appropriate\n\
    \   life times.  For example, it could be inappropriate to cache a\n   relationship\
    \ beyond the period the related CRL will be trusted by the\n   application.  It\
    \ is also critical to consider certificates and CRLs\n   farther up the path when\
    \ setting cache lifetimes.  For example, if\n   the issuer certificate expires\
    \ in ten days, but the issued\n   certificate is valid for 20 days, caching the\
    \ relationship beyond 10\n   days would be inappropriate.\n"
- title: 3.5.6.  Previously Verified Signatures
  contents:
  - "3.5.6.  Previously Verified Signatures\n   May be used to eliminate certificates:\
    \  Yes\n   Number of possible values:  Binary\n   Components required:  Path Cache\n\
    \   Forward Method:   If a previously verified relationship exists in the\n  \
    \ path cache between the subject certificate and a public key present\n   in one\
    \ or more issuer certificates, all the certificates containing\n   said public\
    \ key have higher priority.  Other certificates may be\n   eliminated or set to\
    \ zero priority.\n   Reverse Method:  If known bad signature relationships exist\
    \ between\n   certificates, these relationships can be used to eliminate potential\n\
    \   certificates from the decision tree.  Nothing can be concluded about\n   the\
    \ likelihood of finding a given target certificate down one branch\n   versus\
    \ another using known good signature relationships.\n   Justification: If the\
    \ public key in a certificate (A) was previously\n   used to verify a signature\
    \ on a second certificate (B), any and all\n   certificates containing the same\
    \ key as (A) may be used to verify the\n   signature on (B).  Likewise, any certificates\
    \ that do not contain the\n   same key as (A) cannot be used to verify the signature\
    \ on (B).  This\n   forward direction method is especially strong for multiply\
    \ cross-\n   certified CAs after a key rollover has occurred.\n"
- title: 3.5.7.  Path Length Constraints
  contents:
  - "3.5.7.  Path Length Constraints\n   May be used to eliminate certificates: Yes\n\
    \   Number of possible values: Binary\n   Components required: None\n   Forward\
    \ Method:  Certificates with basic constraints present and\n   containing a path\
    \ length constraint that would invalidate the current\n   path (the current length\
    \ is known since the software is building from\n   the target certificate) may\
    \ be eliminated or set to zero priority.\n   Otherwise, the priority is 100%.\n\
    \   Reverse Method:  This method may be applied in reverse.  To apply it,\n  \
    \ the builder keeps a current path length constraint variable and then\n   sets\
    \ zero priority for (or eliminates) certificates that would\n   violate the constraint.\n\
    \   Justification:  A valid path cannot be built if the path length\n   constraint\
    \ has been violated.\n"
- title: 3.5.8.  Name Constraints
  contents:
  - "3.5.8.  Name Constraints\n   May be used to eliminate certificates:  Yes\n  \
    \ Number of possible values:  Binary\n   Components required:  None\n   Forward\
    \ Method:  Certificates that contain nameConstraints that would\n   be violated\
    \ by certificates already in the path to this point are\n   given zero priority\
    \ or eliminated.\n   Reverse Method:  Certificates that will allow successful\
    \ processing\n   of any name constraints present in the path to this point are\
    \ given\n   higher priority.\n   Justification:  A valid path cannot be built\
    \ if name constraints are\n   violated.\n"
- title: 3.5.9.  Certificate Is Not Revoked
  contents:
  - "3.5.9.  Certificate Is Not Revoked\n   May be used to eliminate certificates:\
    \ No\n   Number of possible values:  Three\n   Components required:  CRL Cache\n\
    \   Forward Method:  If a current CRL for a certificate is present in the\n  \
    \ CRL cache, and the certificate serial number is not on the CRL, the\n   certificate\
    \ has priority.  If the certificate serial number is\n   present on the CRL, it\
    \ has zero priority.  If an (acceptably fresh)\n   OCSP response is available\
    \ for a certificate, and identifies the\n   certificate as valid, the certificate\
    \ has priority.  If an OCSP\n   response is available for a certificate, and identifies\
    \ the\n   certificate as invalid, the certificate has zero priority.\n   Reverse\
    \ Method:  Same as Forward.\n   Alternately, the certificate may be eliminated\
    \ if the CRL or OCSP\n   response is verified.  That is, fully verify the CRL\
    \ or OCSP response\n   signature and relationship to the certificate in question\
    \ in\n   accordance with [RFC3280].  While this is viable, the signature\n   verification\
    \ required makes it less attractive as an elimination\n   method.  It is suggested\
    \ that this method only be used for sorting\n   and that CRLs and OCSP responses\
    \ are validated post path building.\n   Justification:  Certificates known to\
    \ be not revoked can be\n   considered more likely to be valid than certificates\
    \ for which the\n   revocation status is unknown.  This is further justified if\
    \ CRL or\n   OCSP response validation is performed post path validation - CRLs\
    \ or\n   OCSP responses are only retrieved when complete paths are found.\n  \
    \ NOTE:  Special care should be taken to allow meaningful errors to\n   propagate\
    \ to the caller, especially in cases where the target\n   certificate is revoked.\
    \  If a path builder eliminates certificates\n   using CRLs or OCSP responses,\
    \ some status information should be\n   preserved so that a meaningful error may\
    \ be returned in the event no\n   path is found.\n"
- title: 3.5.10.  Issuer Found in the Path Cache
  contents:
  - "3.5.10.  Issuer Found in the Path Cache\n   May be used to eliminate certificates:\
    \ No\n   Number of possible values: Binary\n   Components required:  Certification\
    \ Path Cache\n   Forward Method:  A certificate whose issuer has an entry (or\
    \ entries)\n   in the path cache has priority.\n   Reverse Method:  Does not apply.\n\
    \   Justification:  Since the path cache only contains entries for\n   certificates\
    \ that were previously validated back to a trust anchor,\n   it is more likely\
    \ than not that the same or a new path may be built\n   from that point to the\
    \ (or one of the) trust anchor(s).  For\n   certificates whose issuers are not\
    \ found in the path cache, nothing\n   can be concluded.\n   NOTE: This method\
    \ is not the same as the method named \"Certificate\n   Was Previously Validated\"\
    .  It is possible for this sorting method to\n   evaluate to true while the other\
    \ method could evaluate to zero.\n"
- title: 3.5.11.  Issuer Found in the Application Protocol
  contents:
  - "3.5.11.  Issuer Found in the Application Protocol\n   May be used to eliminate\
    \ certificates: No\n   Number of possible values: Binary\n   Components required:\
    \  Certification Path Cache\n   Forward Method:  If the issuer of a certificate\
    \ sent by the target\n   through the application protocol (SSL/TLS, S/MIME, etc.),\
    \ matches the\n   signer of the certificate you are looking at, then that certificate\n\
    \   has priority.\n   Reverse Method:  If the subject of a certificate matches\
    \ the issuer\n   of a certificate sent by the target through the application protocol\n\
    \   (SSL/TLS, S/MIME, etc.), then that certificate has priority.\n   Justification:\
    \  The application protocol may contain certificates\n   that the sender considers\
    \ valuable to certification path building,\n   and are more likely to lead to\
    \ a path to the target certificate.\n"
- title: 3.5.12.  Matching Key Identifiers (KIDs)
  contents:
  - "3.5.12.  Matching Key Identifiers (KIDs)\n   May be used to eliminate certificates:\
    \  No\n   Number of possible values:  Three\n   Components required:  None\n \
    \  Forward Method:  Certificates whose subject key identifier (SKID)\n   matches\
    \ the current certificate's authority key identifier (AKID)\n   have highest priority.\
    \  Certificates without a SKID have medium\n   priority.  Certificates whose SKID\
    \ does not match the current\n   certificate's AKID (if both are present) have\
    \ zero priority.  If the\n   current certificate expresses the issuer name and\
    \ serial number in\n   the AKID, certificates that match both these identifiers\
    \ have highest\n   priority.  Certificates that match only the issuer name in\
    \ the AKID\n   have medium priority.\n   Reverse Method:  Certificates whose AKID\
    \ matches the current\n   certificate's SKID have highest priority.  Certificates\
    \ without an\n   AKID have medium priority.  Certificates whose AKID does not\
    \ match\n   the current certificate's SKID (if both are present) have zero\n \
    \  priority.  If the certificate expresses the issuer name and serial\n   number\
    \ in the AKID, certificates that match both these identifiers in\n   the current\
    \ certificate have highest priority.  Certificates that\n   match only the issuer\
    \ name in the AKID have medium priority.\n   Justification:  Key Identifier (KID)\
    \ matching is a very useful\n   mechanism for guiding path building (that is their\
    \ purpose in the\n   certificate) and should therefore be assigned a heavy weight.\n\
    \   NOTE:  Although required to be present by [RFC3280], it is extremely\n   important\
    \ that KIDs be used only as sorting criteria or as hints\n   during certification\
    \ path building.  KIDs are not required to match\n   during certification path\
    \ validation and cannot be used to eliminate\n   certificates.  This is of critical\
    \ importance for interoperating\n   across domains and multi-vendor implementations\
    \ where the KIDs may\n   not be calculated in the same fashion.\n"
- title: 3.5.13.  Policy Processing
  contents:
  - "3.5.13.  Policy Processing\n   May be used to eliminate certificates: Yes\n \
    \  Number of possible values: Three\n   Components required: None\n   Forward\
    \ Method:  Certificates that satisfy Forward Policy Chaining\n   have priority.\
    \  (See Section 4 entitled \"Forward Policy Chaining\" for\n   details.)  If the\
    \ caller provided an initial-policy-set and did not\n   set the initial-require-explicit\
    \ flag, the weight of this sorting\n   method should be increased.  If the initial-require-explicit-policy\n\
    \   flag was set by the caller or by a certificate, certificates may be\n   eliminated.\n\
    \   Reverse Method:  Certificates that contain policies/policy mappings\n   that\
    \ will allow successful policy processing of the path to this\n   point have priority.\
    \  If the caller provided an initial-policy-set\n   and did not set the initial-require-explicit\
    \ flag, the weight of this\n   sorting method should be increased.  Certificates\
    \ may be eliminated\n   only if initial-require-explicit was set by the caller\
    \ or if\n   require-explicit-policy was set by a certificate in the path to this\n\
    \   point.\n   Justification:  In a policy-using environment, certificates that\n\
    \   successfully propagate policies are more likely part of an intended\n   certification\
    \ path than those that do not.\n   When building in the forward direction, it\
    \ is always possible that a\n   certificate closer to the trust anchor will set\
    \ the require-\n   explicit-policy indicator; so giving preference to certification\n\
    \   paths that propagate policies may increase the probability of finding\n  \
    \ a valid path first.  If the caller (or a certificate in the current\n   path)\
    \ has specified or set the initial-require-explicit-policy\n   indicator as true,\
    \ this sorting method can also be used to eliminate\n   certificates when building\
    \ in the forward direction.\n   If building in reverse, it is always possible\
    \ that a certificate\n   farther along the path will set the require-explicit-policy\n\
    \   indicator; so giving preference to those certificates that propagate\n   policies\
    \ will serve well in that case.  In the case where require-\n   explicit-policy\
    \ is set by certificates or the caller, certificates\n   can be eliminated with\
    \ this method.\n"
- title: 3.5.14.  Policies Intersect the Sought Policy Set
  contents:
  - "3.5.14.  Policies Intersect the Sought Policy Set\n   May be used to eliminate\
    \ certificates: No\n   Number of possible values: Additive\n   Components required:\
    \ None\n   Forward Method:  Certificates that assert policies found in the\n \
    \  initial-acceptable-policy-set have priority.  Each additional\n   matching\
    \ policy could have an additive affect on the total score.\n   Alternately, this\
    \ could be binary; it matches 1 or more, or matches\n   none.\n   Reverse Method:\
    \  Certificates that assert policies found in the\n   target certificate or map\
    \ policies to those found in the target\n   certificate have priority.  Each additional\
    \ matching policy could\n   have an additive affect on the total score.  Alternately,\
    \ this could\n   be binary; it matches 1 or more, or matches none.\n   Justification:\
    \  In the forward direction, as the path draws near to\n   the trust anchor in\
    \ a cross-certified environment, the policies\n   asserted in the CA certificates\
    \ will match those in the caller's\n   domain.  Since the initial acceptable policy\
    \ set is specified in the\n   caller's domain, matches may indicate that the path\
    \ building is\n   drawing nearer to a desired trust anchor.  In the reverse direction,\n\
    \   finding policies that match those of the target certificate may\n   indicate\
    \ that the path is drawing near to the target's domain.\n"
- title: 3.5.15.  Endpoint Distinguished Name (DN) Matching
  contents:
  - "3.5.15.  Endpoint Distinguished Name (DN) Matching\n   May be used to eliminate\
    \ certificates: No\n   Number of possible values: Binary\n   Components required:\
    \ None\n   Forward Method:  Certificates whose issuer exactly matches a trust\n\
    \   anchor subject DN have priority.\n   Reverse Method:  Certificates whose subject\
    \ exactly matches the\n   target entity issuer DN have priority.\n   Justification:\
    \  In the forward direction, if a certificate's issuer\n   DN matches a trust\
    \ anchor's DN [X.501], then it may complete the\n   path.  In the reverse direction,\
    \ if the certificate's subject DN\n   matches the issuer DN of the target certificate,\
    \ it may be the last\n   certificate required to complete the path.\n"
- title: 3.5.16.  Relative Distinguished Name (RDN) Matching
  contents:
  - "3.5.16.  Relative Distinguished Name (RDN) Matching\n   May be used to eliminate\
    \ certificates: No\n   Number of possible values: Sliding Scale\n   Components\
    \ required: None\n   Forward Method:  Certificates that match more ordered RDNs\
    \ between\n   the issuer DN and a trust anchor DN have priority.  When all the\
    \ RDNs\n   match, this yields the highest priority.\n   Reverse Method: Certificates\
    \ with subject DNs that match more RDNs\n   with the target's issuer DN have higher\
    \ priority.  When all the RDNs\n   match, this yields the highest priority.\n\
    \   Justification:  In PKIs the DNs are frequently constructed in a tree\n   like\
    \ fashion.  Higher numbers of matches may indicate that the trust\n   anchor is\
    \ to be found in that direction within the tree.  Note that\n   in the case where\
    \ all the RDNs match [X.501], this sorting method\n   appears to mirror the preceding\
    \ one.  However, this sorting method\n   should be capable of producing a 100%\
    \ weight even if the issuer DN\n   has more RDNs than the trust anchor.  The Issuer\
    \ DN need only contain\n   all the RDNs (in order) of the trust anchor.\n   NOTE:\
    \ In the case where all RDNs match, this sorting method mirrors\n   the functionality\
    \ of the preceding one.  This allows for partial\n   matches to be weighted differently\
    \ from exact matches.  Additionally,\n   this method can require a lot of processing\
    \ if many trust anchors are\n   present.\n"
- title: 3.5.17.  Certificates are Retrieved from cACertificate Directory
  contents:
  - "3.5.17.  Certificates are Retrieved from cACertificate Directory\n         Attribute\n\
    \   May be used to eliminate certificates: No\n   Number of possible values: Binary\n\
    \   Components required: Certificate Cache with flags for the attribute\n   from\
    \ where the certificate was retrieved and Remote Certificate\n   Storage/Retrieval\
    \ using a directory\n   Forward Method:   Certificates retrieved from the cACertificate\n\
    \   directory attribute have priority over certificates retrieved from\n   the\
    \ crossCertificatePair attribute. (See [RFC2587].)\n   Reverse Method:  Does not\
    \ apply.\n   Justification:  The cACertificate directory attribute contains\n\
    \   certificates issued from local sources and self issued certificates.\n   By\
    \ using the cACertificate directory attribute before the\n   crossCertificatePair\
    \ attribute, the path-building algorithm will\n   (depending on the local PKI\
    \ configuration) tend to demonstrate a\n   preference for the local PKI before\
    \ venturing to external cross-\n   certified PKIs.  Most of today's PKI applications\
    \ spend most of their\n   time processing information from the local (user's own)\
    \ PKI, and the\n   local PKI is usually very efficient to traverse due to proximity\
    \ and\n   network speed.\n"
- title: 3.5.18.  Consistent Public Key and Signature Algorithms
  contents:
  - "3.5.18.  Consistent Public Key and Signature Algorithms\n   May be used to eliminate\
    \ certificates: Yes\n   Number of possible values: Binary\n   Components required:\
    \ None\n   Forward Method:  If the public key in the issuer certificate matches\n\
    \   the algorithm used to sign the subject certificate, then it has\n   priority.\
    \  (Certificates with unmatched public key and signature\n   algorithms may be\
    \ eliminated.)\n   Reverse Method:  If the public key in the current certificate\
    \ matches\n   the algorithm used to sign the subject certificate, then it has\n\
    \   priority.  (Certificates with unmatched public key and signature\n   algorithms\
    \ may be eliminated.)\n   Justification:  Since the public key and signature algorithms\
    \ are not\n   consistent, the signature on the subject certificate will not verify\n\
    \   successfully.  For example, if the issuer certificate contains an RSA\n  \
    \ public key, then it could not have issued a subject certificate\n   signed with\
    \ the DSA-with-SHA-1 algorithm.\n"
- title: 3.5.19.  Similar Issuer and Subject Names
  contents:
  - "3.5.19.  Similar Issuer and Subject Names\n   May be used to eliminate certificates:\
    \  No\n   Number of possible values:  Sliding Scale\n   Components required: \
    \ None\n   Forward Method:  Certificates encountered with a subject DN that\n\
    \   matches more RDNs with the issuer DN of the target certificate have\n   priority.\n\
    \   Reverse Method:  Same as forward.\n   Justification:  As it is generally more\
    \ efficient to search the local\n   domain prior to branching to cross-certified\
    \ domains, using\n   certificates with similar names first tends to make a more\
    \ efficient\n   path builder.  Cross-certificates issued from external domains\
    \ will\n   generally match fewer RDNs (if any), whereas certificates in the\n\
    \   local domain will frequently match multiple RDNs.\n"
- title: 3.5.20.  Certificates in the Certification Cache
  contents:
  - "3.5.20.  Certificates in the Certification Cache\n   May be used to eliminate\
    \ certificates:  No\n   Number of possible values:  Three\n   Components required:\
    \  Local Certificate Cache and Remote Certificate\n   Storage/Retrieval (e.g.,\
    \ LDAP directory as the repository)\n   Forward Method:  A certificate whose issuer\
    \ certificate is present in\n   the certificate cache and populated with certificates\
    \ has higher\n   priority.  A certificate whose issuer's entry is fully populated\
    \ with\n   current data (all certificate attributes have been searched within\n\
    \   the timeout period) has higher priority.\n   Reverse Method:  If the subject\
    \ of a certificate is present in the\n   certificate cache and populated with\
    \ certificates, then it has higher\n   priority.  If the entry is fully populated\
    \ with current data (all\n   certificate attributes have been searched within\
    \ the timeout period)\n   then it has higher priority.\n   Justification:  The\
    \ presence of required directory values populated\n   in the cache increases the\
    \ likelihood that all the required\n   certificates and CRLs needed to complete\
    \ the path from this\n   certificate to the trust anchor (or target if building\
    \ in reverse)\n   are present in the cache from a prior path being developed,\
    \ thereby\n   eliminating the need for directory access to complete the path.\
    \  In\n   the event no path can be found, the performance cost is low since the\n\
    \   certificates were likely not retrieved from the network.\n"
- title: 3.5.21.  Current CRL Found in Local Cache
  contents:
  - "3.5.21.  Current CRL Found in Local Cache\n   May be used to eliminate certificates:\
    \ No\n   Number of possible values:  Binary\n   Components Required:  CRL Cache\n\
    \   Forward Method:  Certificates have priority if the issuer's CRL entry\n  \
    \ exists and is populated with current data in the CRL cache.\n   Reverse Method:\
    \  Certificates have priority if the subject's CRL\n   entry exists and is populated\
    \ with current data in the CRL cache.\n   Justification:  If revocation is checked\
    \ only after a complete path\n   has been found, this indicates that a complete\
    \ path has been found\n   through this entity at some past point, so a path still\
    \ likely\n   exists.  This also helps reduce remote retrievals until necessary.\n"
- title: 3.6.  Certificate Sorting Methods for Revocation Signer Certification
  contents:
  - "3.6.  Certificate Sorting Methods for Revocation Signer Certification\n     \
    \ Paths\n   Unless using a locally-configured OCSP responder or some other\n \
    \  locally-configured trusted revocation status service, certificate\n   revocation\
    \ information is expected to be provided by the PKI that\n   issued the certificate.\
    \  It follows that when building a\n   certification path for a Revocation Signer\
    \ certificate, it is\n   desirable to confine the building algorithm to the PKI\
    \ that issued\n   the certificate.  The following sorting methods seek to order\n\
    \   possible paths so that the intended Revocation Signer certification\n   path\
    \ is found first.\n   These sorting methods are not intended to be used in lieu\
    \ of the ones\n   described in the previous section; they are most effective when\
    \ used\n   in conjunction with those in Section 3.5. Some sorting criteria below\n\
    \   have identical names as those in the preceding section.  This\n   indicates\
    \ that the sorting criteria described in the preceding\n   section are modified\
    \ slightly when building the Revocation Signer\n   certification path.\n"
- title: 3.6.1.  Identical Trust Anchors
  contents:
  - "3.6.1.  Identical Trust Anchors\n   May be used to eliminate certificates: No\n\
    \   Number of possible values: Binary\n   Components required: Is-revocation-signer\
    \ indicator and the\n   Certification Authority's trust anchor\n   Forward Method:\
    \  Not applicable.\n   Reverse Method:  Path building should begin from the same\
    \ trust\n   anchor used to validate the Certification Authority before trying\
    \ any\n   other trust anchors.  If any trust anchors exist with a different\n\
    \   public key but an identical subject DN to that of the Certification\n   Authority's\
    \ trust anchor, they should be tried prior to those with\n   mismatched names.\n\
    \   Justification:  The revocation information for a given certificate\n   should\
    \ be produced by the PKI that issues the certificate.\n   Therefore, building\
    \ a path from a different trust anchor than the\n   Certification Authority's\
    \ is not desirable.\n"
- title: 3.6.2.  Endpoint Distinguished Name (DN) Matching
  contents:
  - "3.6.2.  Endpoint Distinguished Name (DN) Matching\n   May be used to eliminate\
    \ certificates: No\n   Number of possible values: Binary\n   Components required:\
    \ Is-revocation-signer indicator and the\n   Certification Authority's trust anchor\n\
    \   Forward Method:  Operates identically to the sorting method described\n  \
    \ in 3.5.15, except that instead of performing the matching against all\n   trust\
    \ anchors, the DN matching is performed only against the trust\n   anchor DN used\
    \ to validate the CA certificate.\n   Reverse Method:  No change for Revocation\
    \ Signer's certification\n   path.\n   Justification:  The revocation information\
    \ for a given certificate\n   should be produced by the PKI that issues the certificate.\n\
    \   Therefore, building a path to a different trust anchor than the CA's\n   is\
    \ not desirable.  This sorting method helps to guide forward\n   direction path\
    \ building toward the trust anchor used to validate the\n   CA certificate.\n"
- title: 3.6.3.  Relative Distinguished Name (RDN) Matching
  contents:
  - "3.6.3.  Relative Distinguished Name (RDN) Matching\n   May be used to eliminate\
    \ certificates: No\n   Number of possible values: Sliding Scale\n   Components\
    \ required: Is-revocation-signer indicator and the\n   Certification Authority's\
    \ trust anchor\n   Forward Method:  Operates identically to the sorting method\
    \ described\n   in 3.5.16 except that instead of performing the RDN matching against\n\
    \   all trust anchors, the matching is performed only against the trust\n   anchor\
    \ DN used to validate the CA certificate.\n   Reverse Method:  No change for Revocation\
    \ Signer's certification\n   path.\n   Justification:  The revocation information\
    \ for a given certificate\n   should be produced by the PKI that issues the certificate.\n\
    \   Therefore, building a path to a different trust anchor than the CA's\n   is\
    \ not desirable.  This sorting method helps to guide forward\n   direction path\
    \ building toward the trust anchor used to validate the\n   CA certificate.\n"
- title: 3.6.4.  Identical Intermediate Names
  contents:
  - "3.6.4.  Identical Intermediate Names\n   May be used to eliminate certificates:\
    \ No\n   Number of possible values: Binary\n   Components required: Is-revocation-signer\
    \ indicator and the\n   Certification Authority's complete certification path\n\
    \   Forward Method:  If the issuer DN in the certificate matches the\n   issuer\
    \ DN of a certificate in the Certification Authority's path, it\n   has higher\
    \ priority.\n   Reverse Method:  If the subject DN in the certificate matches\
    \ the\n   subject DN of a certificate in the Certification Authority's path, it\n\
    \   has higher priority.\n   Justification:  Following the same path as the Certificate\
    \ should\n   deter the path-building algorithm from wandering in an inappropriate\n\
    \   direction.  Note that this sorting method is indifferent to whether\n   the\
    \ certificate is self-issued.  This is beneficial in this situation\n   because\
    \ it would be undesirable to lower the priority of a re-key\n   certificate.\n"
- title: 4.  Forward Policy Chaining
  contents:
  - "4.  Forward Policy Chaining\n   It is tempting to jump to the conclusion that\
    \ certificate policies\n   offer little assistance to path building when building\
    \ from the\n   target certificate.  It's easy to understand the \"validate as\
    \ you go\"\n   approach from the trust anchor, and much less obvious that any\
    \ value\n   can be derived in the other direction.  However, since policy\n  \
    \ validation consists of the intersection of the issuer policy set with\n   the\
    \ subject policy set and the mapping of policies from the issuer\n   set to the\
    \ subject set, policy validation can be done while building\n   a path in the\
    \ forward direction as well as the reverse.  It is simply\n   a matter of reversing\
    \ the procedure.  That is not to say this is as\n   ideal as policy validation\
    \ when building from the trust anchor, but\n   it does offer a method that can\
    \ be used to mostly eliminate what has\n   long been considered a weakness inherent\
    \ to building in the forward\n   (from the target certificate) direction.\n"
- title: 4.1.  Simple Intersection
  contents:
  - "4.1.  Simple Intersection\n   The most basic form of policy processing is the\
    \ intersection of the\n   policy sets from the first CA certificate through the\
    \ target\n   certificate.  Fortunately, the intersection of policy sets will\n\
    \   always yield the same final set regardless of the order of\n   intersection.\
    \  This allows processing of policy set intersections in\n   either direction.\
    \  For example, if the trust anchor issues a CA\n   certificate (A) with policies\
    \ {X,Y,Z}, and that CA issues another CA\n   certificate (B) with policies {X,Y},\
    \ and CA B then issues a third CA\n   certificate (C) with policy set {Y,G}, one\
    \ normally calculates the\n   policy set from the trust anchor as follows:\n \
    \  1) Intersect A{X,Y,Z} with B{X,Y} to yield the set {X,Y}\n   2) Intersect that\
    \ result, {X,Y} with C{Y,G} to yield the final set\n      {Y}\n   Now it has been\
    \ shown that certificate C is good for policy Y.\n   The other direction is exactly\
    \ the same procedure, only in reverse:\n   1) Intersect C{Y,G} with B{X,Y} to\
    \ yield the set {Y}\n   2) Intersect that result, {Y} with A{X,Y,Z} to yield the\
    \ final set\n      {Y}\n   Just like in the reverse direction, it has been shown\
    \ that\n   certificate C is good for policy Y, but this time in the forward\n\
    \   direction.\n   When building in the forward direction, policy processing is\
    \ handled\n   much like it is in reverse -- the software lends preference to\n\
    \   certificates that propagate policies.  Neither approach guarantees\n   that\
    \ a path with valid policies will be found, but rather both\n   approaches help\
    \ guide the path in the direction it should go in order\n   for the policies to\
    \ propagate.\n   If the caller has supplied an initial-acceptable-policy set,\
    \ there is\n   less value in using it when building in the forward direction unless\n\
    \   the caller also set inhibit-policy-mapping.  In that case, the path\n   builder\
    \ can further constrain the path building to propagating\n   policies that exist\
    \ in the initial-acceptable-policy-set.  However,\n   even if the inhibit-policy-mapping\
    \ is not set, the initial-policy-set\n   can still be used to guide the path building\
    \ toward the desired trust\n   anchor.\n"
- title: 4.2.  Policy Mapping
  contents:
  - "4.2.  Policy Mapping\n   When a CA issues a certificate into another domain,\
    \ an environment\n   with disparate policy identifiers to its own, the CA may\
    \ make use of\n   policy mappings to map equivalence from the local domain's policy\
    \ to\n   the non-local domain's policy.  If in the prior example, A had\n   included\
    \ a policy mapping that mapped X to G in the certificate it\n   issued to B, C\
    \ would be good for X and Y:\n   1) Intersect A{X,Y,Z} with B{X,Y} to yield the\
    \ set {X,Y}\n   2) Process Policy Mappings in B's certificate (X maps to G) to\
    \ yield\n      {G,Y} (same as {Y,G})\n   3) Intersect that result, {G,Y} with\
    \ C{Y,G} to yield the final set\n      {G,Y}\n   Since policies are always expressed\
    \ in the relying party's domain,\n   the certificate C is said to be good for\
    \ {X, Y}, not {Y, G}.  This is\n   because \"G\" doesn't mean anything in the\
    \ context of the trust anchor\n   that issued A without the policy mapping.\n\
    \   When building in the forward direction, policies can be \"unmapped\" by\n\
    \   reversing the mapping procedure.  This procedure is limited by one\n   important\
    \ aspect: if policy mapping has occurred in the forward\n   direction, there is\
    \ no mechanism by which it can be known in advance\n   whether or not a future\
    \ addition to the current path will invalidate\n   the policy chain (assuming\
    \ one exists) by setting inhibit-policy-\n   mapping.  Fortunately, it is uncommon\
    \ practice to set this flag.  The\n   following is the procedure for processing\
    \ policy mapping in the\n   forward direction:\n   1) Begin with C's policy set\
    \ {Y,G}\n   2) Apply the policy mapping in B's certificate (X maps to G) in\n\
    \      reverse to yield {Y,X} (same as {X,Y})\n   3) Intersect the result {X,Y}\
    \ with B{X,Y} to yield the set {X,Y}\n   4) Intersect that result, {X,Y}, with\
    \ A{X,Y,Z} to yield the final set\n      {X,Y}\n   Just like in the reverse direction,\
    \ it is determined in the forward\n   direction that certificate C is good for\
    \ policies {X,Y}.  If during\n   this procedure, an inhibit-policy-mapping flag\
    \ was encountered, what\n   should be done?  This is reasonably easy to keep track\
    \ of as well.\n   The software simply maintains a flag on any policies that were\n\
    \   propagated as a result of a mapping; just a simple Boolean kept with\n   the\
    \ policies in the set.  Imagine now that the certificate issued to\n   A has the\
    \ inhibit-policy-mapping constraint expressed with a skip\n   certificates value\
    \ of zero.\n   1) Begin with C's policy set {Y,G}\n   2) Apply the policy mapping\
    \ in B's certificate and mark X as\n      resulting from a mapping. (X maps to\
    \ G) in reverse to yield {Y,Xm}\n      (same as {Xm,Y})\n   3) Intersect the result\
    \ {Xm,Y} with B{X,Y} to yield the set {Xm,Y}\n   4) A's certificate expresses\
    \ the inhibit policy mapping constraint,\n      so eliminate any policies in the\
    \ current set that were propagated\n      due to mapping (which is Xm) to yield\
    \ {Y}\n   5) Intersect that result, {Y} with A{X,Y,Z} to yield the final set\n\
    \      {Y}\n   If in our example, the policy set had gone to empty at any point\
    \ (and\n   require-explicit-policy was set), the path building would back up and\n\
    \   try to traverse another branch of the tree.  This is analogous to the\n  \
    \ path-building functionality utilized in the reverse direction when\n   the policy\
    \ set goes to empty.\n"
- title: 4.3.  Assigning Scores for Forward Policy Chaining
  contents:
  - "4.3.  Assigning Scores for Forward Policy Chaining\n   Assuming the path-building\
    \ module is maintaining the current forward\n   policy set, weights may be assigned\
    \ using the following procedure:\n   1) For each CA certificate being scored:\n\
    \      a. Copy the current forward policy set.\n      b. Process policy mappings\
    \ in the CA certificate in order to\n         \"un-map\" policies, if any.\n \
    \     c. Intersect the resulting set with CA certificate's policies.\n   The larger\
    \ the policy set yielded, the larger the score for that CA\n   certificate.\n\
    \   2) If an initial acceptable set was supplied, intersect this set with\n  \
    \    the resulting set for each CA certificate from (1).\n   The larger the resultant\
    \ set, the higher the score is for this\n   certificate.\n   Other scoring schemes\
    \ may work better if the operating environment\n   dictates.\n"
- title: 5.  Avoiding Path-Building Errors
  contents:
  - "5.  Avoiding Path-Building Errors\n   This section defines some errors that may\
    \ occur during the path-\n   building process, as well as ways to avoid these\
    \ errors when\n   developing path-building functions.\n"
- title: 5.1.  Dead Ends
  contents:
  - "5.1.  Dead Ends\n   When building certification paths in a non-hierarchical PKI\n\
    \   structure, a simple path-building algorithm could fail prematurely\n   without\
    \ finding an existing path due to a \"dead end\".  Consider the\n   example in\
    \ Figure 14.\n            +----+      +---+\n            | TA |      | Z |\n \
    \           +----+      +---+\n               |          |\n               | \
    \         |\n               V          V\n             +---+      +---+\n    \
    \         | C |<-----| Y |\n             +---+      +---+\n               |\n\
    \               |\n               V\n             +--------+\n             | Target\
    \ |\n             +--------+\n      Figure 14 - Dead End Example\n   Note that\
    \ in the example, C has two certificates: one issued by Y,\n   and the other issued\
    \ by the Trust Anchor.  Suppose that a simple\n   \"find issuer\" algorithm is\
    \ used, and the order in which the path\n   builder found the certificates was\
    \ Target(C), C(Y), Y(Z), Z(Z).  In\n   this case, Z has no certificates issued\
    \ by any other entities, and so\n   the simplistic path-building process stops.\
    \  Since Z is not the\n   relying party's trust anchor, the certification path\
    \ is not complete,\n   and will not validate.  This example shows that in anything\
    \ but the\n   simplest PKI structure, additional path-building logic will need\
    \ to\n   handle the cases in which entities are issued multiple certificates\n\
    \   from different issuers.  The path-building algorithm will also need\n   to\
    \ have the ability to traverse back up the decision tree and try\n   another path\
    \ in order to be robust.\n"
- title: 5.2.  Loop Detection
  contents:
  - "5.2.  Loop Detection\n   In a non-hierarchical PKI structure, a path-building\
    \ algorithm may\n   become caught in a loop without finding an existing path.\
    \  Consider\n   the example below:\n             +----+\n             | TA |\n\
    \             +----+\n               |\n               |\n             +---+ \
    \     +---+\n             | A |    ->| Z |\n             +---+   /  +---+\n  \
    \             |    /     |\n               |   /      |\n               V  / \
    \      V\n             +---+      +---+\n             | B |<-----| Y |\n     \
    \        +---+      +---+\n               |\n               |\n              \
    \ V\n             +--------+\n             | Target |\n             +--------+\n\
    \      Figure 15 - Loop Example\n   Let us suppose that in this example the simplest\
    \ \"find issuer\"\n   algorithm is used, and the order in which certificates are\
    \ retrieved\n   is Target(B), B(Y), Y(Z), Z(B), B(Y), Y(Z), Z(B), B(Y), ... A\
    \ loop\n   has formed that will cause the correct path (Target, B, A) to never\n\
    \   be found.  The certificate processing system will need to recognize\n   loops\
    \ created by duplicate certificates (which are prohibited in a\n   path by [X.509])\
    \ before they form to allow the certification path-\n   building process to continue\
    \ and find valid paths.  The authors of\n   this document recommend that the loop\
    \ detection not only detect the\n   repetition of a certificate in the path, but\
    \ also detect the presence\n   of the same subject name / subject alternative\
    \ name/ subject public\n   key combination occurring twice in the path.  A name/key\
    \ pair should\n   only need to appear once in the path.  (See Section 2.4.2 for\
    \ more\n   information on the reasoning behind this recommendation.)\n"
- title: 5.3.  Use of Key Identifiers
  contents:
  - "5.3.  Use of Key Identifiers\n   Inconsistent and/or incompatible approaches\
    \ to computing the subject\n   key identifier and authority key identifier in\
    \ public key\n   certificates can cause failures in certification path-building\n\
    \   algorithms that use those fields to identify certificates, even\n   though\
    \ otherwise valid certification paths may exist.  Path-building\n   implementations\
    \ should use existing key identifiers and not attempt\n   to re-compute subject\
    \ key identifiers.  It is extremely important\n   that Key Identifiers be used\
    \ only as sorting criteria or hints.  KIDs\n   are not required to match during\
    \ certification path validation and\n   cannot be used to eliminate certificates.\
    \  This is of critical\n   importance for interoperating across domains and multi-vendor\n\
    \   implementations where the KIDs may not be calculated in the same\n   fashion.\n\
    \   Path-building and processing implementations should not rely on the\n   form\
    \ of authority key identifier that uses the authority DN and\n   serial number\
    \ as a restrictive matching rule, because cross-\n   certification can lead to\
    \ this value not being matched by the cross-\n   certificates.\n"
- title: 5.4.  Distinguished Name Encoding
  contents:
  - "5.4.  Distinguished Name Encoding\n   Certification path-building software should\
    \ not rely on DNs being\n   encoded as PrintableString.  Although frequently encoded\
    \ as\n   PrintableString, DNs may also appear as other types, including\n   BMPString\
    \ or UTF8String.  As a result, software systems that are\n   unable to process\
    \ BMPString and UTF8String encoded DNs may be unable\n   to build and validate\
    \ some certification paths.\n   Furthermore, [RFC3280] compliant certificates\
    \ are required to encode\n   DNs as UTF8String as of January 1, 2004.  Certification\
    \ path-building\n   software should be prepared to handle \"name rollover\" certificates\
    \ as\n   described in [RFC3280].  Note that the inclusion of a \"name rollover\"\
    \n   certificate in a certification path does not constitute repetition of\n \
    \  a DN and key.  Implementations that include the \"name rollover\"\n   certificate\
    \ in the path should ensure that the DNs with differing\n   encoding are regarded\
    \ as dissimilar.  (Implementations may instead\n   handle matching DNs of different\
    \ encodings and will therefore not\n   need to include \"name rollover\" certificates\
    \ in the path.)\n"
- title: 6.  Retrieval Methods
  contents:
  - "6.  Retrieval Methods\n   Building a certification path requires the availability\
    \ of the\n   certificates and CRLs that make up the path.  There are many\n  \
    \ different methods for obtaining these certificates and CRLs.  This\n   section\
    \ lists a few of the common ways to perform this retrieval, as\n   well as some\
    \ suggested approaches for improving performance.  This\n   section is not intended\
    \ to provide a complete reference for\n   certificate and CRL retrieval methods\
    \ or optimizations that would be\n   useful in certification path building.\n"
- title: 6.1.  Directories Using LDAP
  contents:
  - "6.1.  Directories Using LDAP\n   Most applications utilize the Lightweight Directory\
    \ Access Protocol\n   (LDAP) when retrieving data from directories following the\
    \ X.500\n   model.  Applications may encounter directories which support either\n\
    \   LDAP v2 [RFC1777] or LDAP v3 [RFC3377].\n   The LDAP v3 specification defines\
    \ one attribute retrieval option, the\n   \"binary\" option.  When specified in\
    \ an LDAP retrieval request, this\n   option was intended to force the directory\
    \ to ignore any string-based\n   representations of BER-encoded directory information,\
    \ and send the\n   requested attribute(s) in BER format.  Since all PKI objects\
    \ of\n   concern are BER-encoded objects, the \"binary\" option should be used.\n\
    \   However, not all directories support the \"binary\" option.  Therefore,\n\
    \   applications should be capable of requesting attributes with and\n   without\
    \ the \"binary\" option.  For example, if an application wishes\n   to retrieve\
    \ the userCertificate attribute, the application should\n   request \"userCertificate;binary\"\
    .  If the desired information is not\n   returned, robust implementations may\
    \ opt to request \"userCertificate\"\n   as well.\n   The following attributes\
    \ should be considered by PKI application\n   developers when performing certificate\
    \ retrieval from LDAP sources:\n   userCertificate: contains certificates issued\
    \ by one or more\n      certification authorities with a subject DN that matches\
    \ that of\n      the directory entry.  This is a multi-valued attribute and all\n\
    \      values should be received and considered during path building.\n      Although\
    \ typically it is expected that only end entity\n      certificates will be stored\
    \ in this attribute, (e.g., this is the\n      attribute an application would\
    \ request to find a person's\n      encryption certificate) implementers may opt\
    \ to search this\n      attribute when looking in CA entries to make their path\
    \ builder\n      more robust.  If it is empty, the overhead added by including\
    \ this\n      attribute when already requesting one or both of the two below is\n\
    \      marginal.\n   cACertificate: contains self-issued certificates (if any)\
    \ and any\n      certificates issued to this certification authority by other\n\
    \      certification authorities in the same realm.  (Realm is dependent\n   \
    \   upon local policy.)  This is a multi-valued attribute and all\n      values\
    \ should be received and considered during path building.\n   crossCertificatePair:\
    \ in conformant implementations, the\n      crossCertificatePair is used to contain\
    \ all, except self-issued\n      certificates issued to this certification authority,\
    \ as well as\n      certificates issued by this certification authority to other\n\
    \      certification authorities.  Each attribute value is a structure\n     \
    \ containing two elements.  The issuedToThisCA element contains\n      certificates\
    \ issued to this certification authority by other\n      certification authorities.\
    \  The issuedByThisCA element contains\n      certificates issued by this certification\
    \ authority to other\n      certification authorities.  Both elements of the\n\
    \      crossCertificatePair are labeled optional in the ASN.1 definition.\n  \
    \    If both elements are present in a single value, the issuer name in\n    \
    \  one certificate is required to match the subject name in the other\n      and\
    \ vice versa, and the subject public key in one certificate\n      shall be capable\
    \ of verifying the digital signature on the other\n      certificate and vice\
    \ versa.  As this technology has evolved,\n      different standards have had\
    \ differing requirements on where\n      information could be found.  For example,\
    \ the LDAP v2 schema\n      [RFC2587] states that the issuedToThisCA (once called\
    \ 'forward')\n      element of the crossCertificatePair attribute is mandatory\
    \ and the\n      issuedByThisCA (once called 'reverse') element is optional. \
    \ In\n      contrast, Section 11.2.3 of [X.509] requires the issuedByThisCA\n\
    \      element to be present if the CA issues a certificate to another CA\n  \
    \    if the subject is not a subordinate CA in a hierarchy.  Conformant\n    \
    \  directories behave as required by [X.509], but robust path-\n      building\
    \ implementations may want to retrieve all certificates\n      from the cACertificate\
    \ and crossCertificatePair attributes to\n      ensure all possible certification\
    \ authority certificates are\n      obtained.\n   certificateRevocationList: the\
    \ certificateRevocationList attribute\n      contains a certificate revocation\
    \ list (CRL).  A CRL is defined in\n      [RFC3280] as a time stamped list identifying\
    \ revoked certificates,\n      which is signed by a CA or CRL issuer and made\
    \ freely available in\n      a public repository.  Each revoked certificate is\
    \ identified in a\n      CRL by its certificate serial number.  There may be one\
    \ or more\n      CRLs in this attribute, and the values should be processed in\n\
    \      accordance with [RFC3280].\n   authorityRevocationList: the authorityRevocationList\
    \ attribute also\n      contains CRLs.  These CRLs contain revocation information\n\
    \      regarding certificates issued to other CAs.  There may be one or\n    \
    \  more CRLs in this attribute, and the values should be processed in\n      accordance\
    \ with [RFC3280].\n   Certification path processing systems that plan to interoperate\
    \ with\n   varying PKI structures and directory designs should at a minimum be\n\
    \   able to retrieve and process the userCertificate, cACertificate,\n   crossCertificatePair,\
    \ certificateRevocationList, and\n   authorityRevocationList attributes from directory\
    \ entries.\n"
- title: 6.2.  Certificate Store Access via HTTP
  contents:
  - "6.2.  Certificate Store Access via HTTP\n   Another possible method of certificate\
    \ retrieval is using HTTP as an\n   interface mechanism for retrieving certificates\
    \ and CRLs from PKI\n   repositories.  A current PKIX document [CERTSTORE] provides\
    \ a\n   protocol for a general-purpose interface capability for retrieving\n \
    \  certificates and CRLs from PKI repositories.  Since the [CERTSTORE]\n   document\
    \ is a work in progress as of the writing of this document, no\n   details are\
    \ given here on how to utilize this mechanism for\n   certificate and CRL retrieval.\
    \  Instead, refer to the [CERTSTORE]\n   document or its current version.  Certification\
    \ path processing\n   systems may wish to implement support for this interface\
    \ capability,\n   especially if they will be used in environments that will provide\n\
    \   HTTP-based access to certificates and CRLs.\n"
- title: 6.3.  Authority Information Access
  contents:
  - "6.3.  Authority Information Access\n   The authority information access (AIA)\
    \ extension, defined within\n   [RFC3280], indicates how to access CA information\
    \ and services for\n   the issuer of the certificate in which the extension appears.\
    \  If a\n   certificate with an AIA extension contains an accessMethod defined\n\
    \   with the id-ad-caIssuers OID, the AIA may be used to retrieve one or\n   more\
    \ certificates for the CA that issued the certificate containing\n   the AIA extension.\
    \  The AIA will provide a uniform resource\n   identifier (URI) [RFC3986] when\
    \ certificates can be retrieved via\n   LDAP, HTTP, or FTP.  The AIA will provide\
    \ a directoryName when\n   certificates can be retrieved via directory access\
    \ protocol (DAP).\n   The AIA will provide an rfc822Name when certificates can\
    \ be retrieved\n   via electronic mail.  Additionally, the AIA may specify the\
    \ location\n   of an OCSP [RFC2560] responder that is able to provide revocation\n\
    \   information for the certificate.\n   If present, AIA may provide forward path-building\
    \ implementations\n   with a direct link to a certificate for the issuer of a\
    \ given\n   certificate.  Therefore, implementations may wish to provide support\n\
    \   for decoding the AIA extension and processing the LDAP, HTTP, FTP,\n   DAP,\
    \ or e-mail locators.  Support for AIA is optional; [RFC3280]\n   compliant implementations\
    \ are not required to populate the AIA\n   extension.  However, implementers of\
    \ path-building and validation\n   modules are strongly encouraged to support\
    \ AIA, especially the HTTP\n   transport; this will provide for usability and\
    \ interoperability with\n   many existing PKIs.\n"
- title: 6.4.  Subject Information Access
  contents:
  - "6.4.  Subject Information Access\n   The subject information access (SIA) extension,\
    \ defined within\n   [RFC3280], indicates how to access information and services\
    \ for the\n   subject of the certificate in which the extension appears.  If a\n\
    \   certificate with an SIA extension contains an accessMethod defined\n   with\
    \ the id-ad-caRepository OID, the SIA may be used to locate one or\n   more certificates\
    \ (and possibly CRLs) for entities issued\n   certificates by the subject.  The\
    \ SIA will provide a uniform resource\n   identifier (URI) [RFC3986] when data\
    \ can be retrieved via LDAP, HTTP,\n   or FTP.  The SIA will provide a directoryName\
    \ when data can be\n   retrieved via directory access protocol (DAP).  The SIA\
    \ will provide\n   an rfc822Name when data can be retrieved via electronic mail.\n\
    \   If present, the SIA extension may provide reverse path-building\n   implementations\
    \ with the certificates required to continue building\n   the path.  Therefore,\
    \ implementations may wish to provide support for\n   decoding the SIA extension\
    \ and processing the LDAP, HTTP, FTP, DAP,\n   or e-mail locators.  Support for\
    \ SIA is optional; [RFC3280] compliant\n   implementations are not required to\
    \ populate the SIA extension.\n   However, implementers of path-building and validation\
    \ modules are\n   strongly encouraged to support SIA, especially the HTTP transport;\n\
    \   this will provide for usability and interoperability with many\n   existing\
    \ PKIs.\n"
- title: 6.5.  CRL Distribution Points
  contents:
  - "6.5.  CRL Distribution Points\n   The CRL distribution points (CRLDP) extension,\
    \ defined within\n   [RFC3280], indicates how to access CRL information.  If a\
    \ CRLDP\n   extension appears within a certificate, the CRL(s) to which the CRLDP\n\
    \   refer are generally the CRLs that would contain revocation\n   information\
    \ for the certificate.  The CRLDP extension may point to\n   multiple distribution\
    \ points from which the CRL information may be\n   obtained; the certificate processing\
    \ system should process the CRLDP\n   extension in accordance with [RFC3280].\
    \  The most common distribution\n   points contain URIs from which the appropriate\
    \ CRL may be downloaded,\n   and directory names, which can be queried in a directory\
    \ to retrieve\n   the CRL attributes from the corresponding entry.\n   If present,\
    \ CRLDP can provide certificate processing implementations\n   with a link to\
    \ CRL information for a given certificate.  Therefore,\n   implementations may\
    \ wish to provide support for decoding the CRLDP\n   extension and using the information\
    \ to retrieve CRLs.  Support for\n   CRLDP is optional and [RFC3280] compliant\
    \ implementations need not\n   populate the CRLDP extension.  However, implementers\
    \ of path-building\n   and validation modules are strongly encouraged to support\
    \ CRLDPs.  At\n   a minimum, developers are encouraged to consider supporting\
    \ the LDAP\n   and HTTP transports; this will provide for interoperability across\
    \ a\n   wide range of existing PKIs.\n"
- title: 6.6.  Data Obtained via Application Protocol
  contents:
  - "6.6.  Data Obtained via Application Protocol\n   Many application protocols,\
    \ such as SSL/TLS and S/MIME, allow one\n   party to provide certificates and\
    \ CRLs to another.  Data provided in\n   this method is generally very valuable\
    \ to path-building software\n   (will provide direction toward valid paths), and\
    \ should be stored and\n   used accordingly.  Note: self-signed certificates obtained\
    \ via\n   application protocol are not trustworthy; implementations should only\n\
    \   consider the relying party's trust anchors when building paths.\n"
- title: 6.7.  Proprietary Mechanisms
  contents:
  - "6.7.  Proprietary Mechanisms\n   Some certificate issuing systems and certificate\
    \ processing systems\n   may utilize proprietary retrieval mechanisms, such as\
    \ network mapped\n   drives, databases, or other methods that are not directly\
    \ referenced\n   via the IETF standards.  Certificate processing systems may wish\
    \ to\n   support other proprietary mechanisms, but should only do so in\n   addition\
    \ to supporting standard retrieval mechanisms such as LDAP,\n   AIA, and CRLDP\
    \ (unless functioning in a closed environment).\n"
- title: 7.  Improving Retrieval Performance
  contents:
  - "7.  Improving Retrieval Performance\n   Retrieval performance can be improved\
    \ through a few different\n   mechanisms, including the use of caches and setting\
    \ a specific\n   retrieval order.  This section discusses a few methods by which\
    \ the\n   performance of a certificate processing system may be improved during\n\
    \   the retrieval of PKI objects.  Certificate processing systems that\n   are\
    \ consistently very slow during processing will be disliked by\n   users and will\
    \ be slow to be adopted into organizations.  Certificate\n   processing systems\
    \ are encouraged to do whatever possible to reduce\n   the delays associated with\
    \ requesting and retrieving data from\n   external sources.\n"
- title: 7.1.  Caching
  contents:
  - "7.1.  Caching\n   Certificate processing systems operating in a non-hierarchical\
    \ PKI\n   will often need to retrieve certificates and certificate revocation\n\
    \   lists (CRLs) from a source outside the application protocol.\n   Typically,\
    \ these objects are retrieved from an X.500 or LDAP\n   repository, an Internet\
    \ URI [RFC3986], or some other non-local\n   source.  Due to the delays associated\
    \ with establishing connections\n   as well as network transfers, certificate\
    \ processing systems ought to\n   be as efficient as possible when retrieving\
    \ data from external\n   sources.  Perhaps the best way to improve retrieval efficiency\
    \ is by\n   using a caching mechanism.  Certificate processing systems can cache\n\
    \   data retrieved from external sources for some period of time, but not\n  \
    \ to exceed the useful period of the data (i.e., an expired certificate\n   need\
    \ not be cached).  Although this comes at a cost of increased\n   memory/disk\
    \ consumption by the system, the cost and performance\n   benefit of reducing\
    \ network transmissions is great.  Also, CRLs are\n   often issued and available\
    \ in advance of the nextUpdate date in the\n   CRL.  Implementations may wish\
    \ to obtain these \"fresher\" CRLs before\n   the nextUpdate date has passed.\n\
    \   There are a number of different ways in which caching can be\n   implemented;\
    \ the specifics of these methods can be used as\n   distinguishing characteristics\
    \ between certificate processing\n   systems.  However, some things that implementers\
    \ may wish to consider\n   when developing caching systems are as follows:\n \
    \     - If PKI objects are cached, the certification path-building\n        mechanism\
    \ should be able to examine and retrieve from the cache\n        during path building.\
    \  This will allow the certificate\n        processing system to find or eliminate\
    \ one or more paths quickly\n        without requiring external contact with a\
    \ directory or other\n        retrieval mechanism.\n      - Sharing caches between\
    \ multiple users (via a local area network\n        or LAN) may be useful if many\
    \ users in one organization\n        consistently perform PKI operations with\
    \ another organization.\n      - Caching not only PKI objects (such as certificates\
    \ and CRLs) but\n        also relationships between PKI objects (storing a link\
    \ between a\n        certificate and the issuer's certificate) may be useful.\
    \  This\n        linking may not always lead to the most correct or best\n   \
    \     relationship, but could represent a linking that worked in\n        another\
    \ scenario.\n      - Previously built paths and partial paths are quite useful\
    \ to\n        cache, because they will provide information on previous\n     \
    \   successes or failures.  Additionally, if the cache is safe from\n        unauthorized\
    \ modifications, caching validation and signature\n        checking status for\
    \ certificates, CRLs, and paths can also be\n        stored.\n"
- title: 7.2.  Retrieval Order
  contents:
  - "7.2.  Retrieval Order\n   To optimize efficiency, certificate processing systems\
    \ are encouraged\n   to also consider the order in which different PKI objects\
    \ are\n   retrieved, as well as the mechanism from which they are retrieved.\n\
    \   If caching is utilized, the caches can be consulted for PKI objects\n   before\
    \ attempting other retrieval mechanisms.  If multiple caches are\n   present (such\
    \ as local disk and network), the caches can be consulted\n   in the order in\
    \ which they can be expected to return their result\n   from fastest to slowest.\
    \  For example, if a certificate processing\n   system wishes to retrieve a certificate\
    \ with a particular subject DN,\n   the system might first consult the local cache,\
    \ then the network\n   cache, and then attempt directory retrieval.  The specifics\
    \ of the\n   types of retrieval mechanisms and their relative costs are left to\n\
    \   the implementer.\n   In addition to ordering retrieval mechanisms, the certificate\n\
    \   processing system ought to order the relative merits of the different\n  \
    \ external sources from which a PKI object can be retrieved.  If the\n   AIA is\
    \ present within a certificate, with a URI [RFC3986] for the\n   issuer's certificate,\
    \ the certificate processing system (if able) may\n   wish to attempt to retrieve\
    \ the certificate first from local cache\n   and then by using that URI (because\
    \ it is expected to point directly\n   to the desired certificate) before attempting\
    \ to retrieve the\n   certificates that may exist within a directory.\n   If a\
    \ directory is being consulted, it may be desirable to retrieve\n   attributes\
    \ in a particular order.  A highly cross-certified PKI\n   structure will lead\
    \ to multiple possibilities for certification\n   paths, which may mean multiple\
    \ validation attempts before a\n   successful path is retrieved.  Therefore, cACertificate\
    \ and\n   userCertificate (which typically contain certificates from within the\n\
    \   same 'realm') could be consulted before attempting to retrieve the\n   crossCertificatePair\
    \ values for an entry.  Alternately, all three\n   attributes could be retrieved\
    \ in one query, but cross-certificates\n   then tagged as such and used only after\
    \ exhausting the possibilities\n   from the cACertificate attribute.  The best\
    \ approach will depend on\n   the nature of the application and PKI environment.\n"
- title: 7.3.  Parallel Fetching and Prefetching
  contents:
  - "7.3.  Parallel Fetching and Prefetching\n   Much of this document has focused\
    \ on a path-building algorithm that\n   minimizes the performance impact of network\
    \ retrievals, by preventing\n   those retrievals and utilization of caches.  Another\
    \ way to improve\n   performance would be to allow network retrievals to be performed\
    \ in\n   advance (prefetching) or at the same time that other operations are\n\
    \   performed (parallel fetching).  For example, if an email application\n   receives\
    \ a signed email message, it could download the required\n   certificates and\
    \ CRLs prior to the recipient viewing (or attempting\n   to verify) the message.\
    \  Implementations that provide the capability\n   of parallel fetching and/or\
    \ prefetching, along with a robust cache,\n   can lead to greatly improved performance\
    \ or user experience.\n"
- title: 8.  Security Considerations
  contents:
  - '8.  Security Considerations

    '
- title: 8.1.  General Considerations for Building a Certification Path
  contents:
  - "8.1.  General Considerations for Building a Certification Path\n   Although certification\
    \ path building deals directly with security\n   relevant PKI data, the PKI data\
    \ itself needs no special handling\n   because its integrity is secured with the\
    \ digital signature applied\n   to it.  The only exception to this is the appropriate\
    \ protection of\n   the trust anchor public keys.  These are to be kept safe and\
    \ obtained\n   out of band (e.g., not from an electronic mail message or a\n \
    \  directory) with respect to the path-building module.\n   The greatest security\
    \ risks associated with this document revolve\n   around performing certification\
    \ path validation while certification\n   paths are built.  It is therefore noted\
    \ here that fully implemented\n   certification path validation in accordance\
    \ with [RFC3280] and\n   [X.509] is required in order for certification path building,\n\
    \   certification path validation, and the certificate using application\n   to\
    \ be properly secured.  All of the Security Considerations listed in\n   Section\
    \ 9 of [RFC3280] apply equally here.\n   In addition, as with any application\
    \ that consumes data from\n   potentially untrusted network locations, certification\
    \ path-building\n   components should be carefully implemented so as to reduce\
    \ or\n   eliminate the possibility of network based exploits.  For example, a\n\
    \   poorly implemented path-building module may not check the length of\n   the\
    \ CRLDP URI [RFC3986] before using the C language strcpy() function\n   to place\
    \ the address in a 1024 byte buffer.  A hacker could use such\n   a flaw to create\
    \ a buffer overflow exploit by encoding malicious\n   assembly code into the CRLDP\
    \ of a certificate and then use the\n   certificate to attempt an authentication.\
    \  Such an attack could yield\n   system level control to the attacker and expose\
    \ the sensitive data\n   the PKI was meant to protect.\n   Path building may be\
    \ used to mount a denial of service (DOS) attack.\n   This might occur if multiple\
    \ simple requests could be performed that\n   cause a server to perform a number\
    \ of path developments, each taking\n   time and resources from the server.  Servers\
    \ can help avoid this by\n   limiting the resources they are willing to devote\
    \ to path building,\n   and being able to further limit those resources when the\
    \ load is\n   heavy.  Standard DOS protections such as systems that identify and\n\
    \   block attackers can also be useful.\n   A DOS attack can be also created by\
    \ presenting spurious CA\n   certificates containing very large public keys. \
    \ When the system\n   attempts to use the large public key to verify the digital\
    \ signature\n   on additional certificates, a long processing delay may occur.\
    \  This\n   can be mitigated by either of two strategies.  The first strategy\
    \ is\n   to perform signature verifications only after a complete path is\n  \
    \ built, starting from the trust anchor.  This will eliminate the\n   spurious\
    \ CA certificate from consideration before the large public\n   key is used. \
    \ The second strategy is to recognize and simply reject\n   keys longer than a\
    \ certain size.\n   A similar DOS attack can occur with very large public keys\
    \ in end\n   entity certificates.  If a system uses the public key in a\n   certificate\
    \ before building and validating that certificate's\n   certification path, long\
    \ processing delays may occur.  To mitigate\n   this threat, the public key in\
    \ an end entity certificate should not\n   be used for any purpose until a complete\
    \ certification path for that\n   certificate is built and validated.\n"
- title: 8.2.  Specific Considerations for Building Revocation Signer
  contents:
  - "8.2.  Specific Considerations for Building Revocation Signer\n      Certification\
    \ Paths\n   If the CRL Signer certificate (and certification path) is not\n  \
    \ identical to the Certification Authority certificate (and\n   certification\
    \ path), special care should be exercised when building\n   the CRL Signer certification\
    \ path.\n   If special consideration is not given to building a CRL Signer\n \
    \  certification path, that path could be constructed such that it\n   terminates\
    \ with a different root or through a different certification\n   path to the same\
    \ root.  If this behavior is not prevented, the\n   relying party may end up checking\
    \ the wrong revocation data, or even\n   maliciously substituted data, resulting\
    \ in denial of service or\n   security breach.\n   For example, suppose the following\
    \ certification path is built for E\n   and is valid for an example \"high assurance\"\
    \ policy.\n      A->B->C->E\n   When the building/validation routine attempts\
    \ to verify that E is not\n   revoked, C is referred to as the Certification Authority\
    \ certificate.\n   The path builder finds that the CRL for checking the revocation\n\
    \   status of E is issued by C2; a certificate with the subject name \"C\",\n\
    \   but with a different key than the key that was used to sign E.  C2 is\n  \
    \ referred to as the CRL Signer.  An unrestrictive certification path\n   builder\
    \ might then build a path such as the following for the CRL\n   Signer C2 certificate:\n\
    \      X->Y->Z->C2\n   If a path such as the one above is permitted, nothing can\
    \ be\n   concluded about the revocation status of E since C2 is a different CA\n\
    \   from C.\n   Fortunately, preventing this security problem is not difficult\
    \ and\n   the solution also makes building CRL Signer certification paths very\n\
    \   efficient.  In the event the CRL Signer certificate is identical to\n   the\
    \ Certification Authority certificate, the Certification Authority\n   certification\
    \ path should be used to verify the CRL; no additional\n   path building is required.\
    \  If the CRL Signer certificate is not\n   identical to the Certification Authority\
    \ certificate, a second path\n   should be built for the CRL Signer certificate\
    \ in exactly the same\n   fashion as for any certificate, but with the following\
    \ additional\n   guidelines:\n   1.  Trust Anchor:  The CRL Signer's certification\
    \ path should start\n       with the same trust anchor as the Certification Authority's\n\
    \       certification path.  Any trust anchor certificate with a subject\n   \
    \    DN matching that of the Certification Authority's trust anchor\n       should\
    \ be considered acceptable though lower in priority than the\n       one with\
    \ a matching public key and subject DN.  While different\n       trust anchor\
    \ public keys are acceptable at the beginning of the\n       CRL signer's certification\
    \ path and the Certification Authority's\n       certification path, both keys\
    \ must be trusted by the relying\n       party per the recommendations in Section\
    \ 8.1.\n   2.  CA Name Matching:  The subject DNs for all CA certificates in the\n\
    \       two certification paths should match on a one-to-one basis\n       (ignoring\
    \ self-issued certificates) for the entire length of the\n       shorter of the\
    \ two paths.\n   3.  CRL Signer Certification Path Length:  The length of the\
    \ CRL\n       Signer certification path (ignoring self-issued certificates)\n\
    \       should be equal to or less than the length of the Certification\n    \
    \   Authority certification path plus (+) one.  This allows a given\n       Certification\
    \ Authority to issue a certificate to a\n       delegated/subordinate CRL Signer.\
    \  The latter configuration\n       represents the maximum certification path\
    \ length for a CRL Signer\n       certificate.\n   The reasoning behind the first\
    \ guideline is readily apparent.\n   Lacking this and the second guideline, any\
    \ trusted CA could issue\n   CRLs for any other CA, even if the PKIs are not related\
    \ in any\n   fashion.  For example, one company could revoke certificates issued\n\
    \   by another company if the relying party trusted the trust anchors\n   from\
    \ both companies.  The two guidelines also prevent erroneous CRL\n   checks since\
    \ Global uniqueness of names is not guaranteed.\n   The second guideline prevents\
    \ roaming certification paths such as the\n   previously described example CRL\
    \ Signer certification path for\n   A->B->C->E.  It is especially important that\
    \ the \"ignoring self-\n   issued certificates\" is implemented properly.  Self-issued\n\
    \   certificates are cast out of the one-to-one name comparison in order\n   to\
    \ allow for key rollover.  The path-building algorithm may be\n   optimized to\
    \ only consider certificates with the acceptable subject\n   DN for the given\
    \ point in the CRL Signer certification path while\n   building the path.\n  \
    \ The third and final guideline ensures that the CRL used is the\n   intended\
    \ one.  Without a restriction on the length of the CRL Signer\n   certification\
    \ path, the path could roam uncontrolled into another\n   domain and still meet\
    \ the first two guidelines.  For example, again\n   using the path A->B->C->E,\
    \ the Certification Authority C, and a CRL\n   Signer C2, a CRL Signer certification\
    \ path such as the following\n   could pass the first two guidelines:\n      A->B->C->D->X->Y->RogueCA->C2\n\
    \   In the preceding example, the trust anchor is identical for both\n   paths\
    \ and the one-to-one name matching test passes for A->B->C.\n   However, accepting\
    \ such a path has obvious security consequences, so\n   the third guideline is\
    \ used to prevent this situation.  Applying the\n   second and third guideline\
    \ to the certification path above, the path\n   builder could have immediately\
    \ detected this path was not acceptable\n   (prior to building it) by examining\
    \ the issuer DN in C2.  Given the\n   length and name guidelines, the path builder\
    \ could detect that\n   \"RogueCA\" is not in the set of possible names by comparing\
    \ it to the\n   set of possible CRL Signer issuer DNs, specifically, A, B, or\
    \ C.\n   Similar consideration should be given when building the path for the\n\
    \   OCSP Responder certificate when the CA is the OCSP Response Signer or\n  \
    \ the CA has delegated the OCSP Response signing to another entity.\n"
- title: 9.  Acknowledgements
  contents:
  - "9.  Acknowledgements\n   The authors extend their appreciation to David Lemire\
    \ for his efforts\n   coauthoring \"Managing Interoperability in Non-Hierarchical\
    \ Public Key\n   Infrastructures\" from which material was borrowed heavily for\
    \ use in\n   the introductory sections.\n   This document has also greatly benefited\
    \ from the review and\n   additional technical insight provided by Dr. Santosh\
    \ Chokhani, Carl\n   Wallace, Denis Pinkas, Steve Hanna, Alice Sturgeon, Russ\
    \ Housley, and\n   Tim Polk.\n"
- title: 10.  Normative References
  contents:
  - "10.  Normative References\n   [RFC3280]   Housley, R., Polk, W., Ford, W., and\
    \ D. Solo, \"Internet\n               X.509 Public Key Infrastructure Certificate\
    \ and\n               Certificate Revocation List (CRL) Profile\", RFC 3280,\n\
    \               April 2002.\n"
- title: 11.  Informative References
  contents:
  - "11.  Informative References\n   [MINHPKIS]  Hesse, P., and D. Lemire, \"Managing\
    \ Interoperability in\n               Non-Hierarchical Public Key Infrastructures\"\
    , 2002\n               Conference Proceedings of the Internet Society Network\n\
    \               and Distributed System Security Symposium, February 2002.\n  \
    \ [RFC1777]   Yeong, W., Howes, T., and S. Kille, \"Lightweight\n            \
    \   Directory Access Protocol\", RFC 1777, March 1995.\n   [RFC2560]   Myers,\
    \ M., Ankney, R., Malpani, A., Galperin, S., and C.\n               Adams, \"\
    X.509 Internet Public Key Infrastructure Online\n               Certificate Status\
    \ Protocol - OCSP\", RFC 2560, June 1999.\n   [RFC2587]   Boeyen, S., Howes, T.,\
    \ and P. Richard, \"Internet X.509\n               Public Key Infrastructure LDAPv2\
    \ Schema\", RFC 2587, June\n               1999.\n   [RFC3377]   Hodges, J. and\
    \ R. Morgan, \"Lightweight Directory Access\n               Protocol (v3): Technical\
    \ Specification\", RFC 3377,\n               September 2002.\n   [RFC3820]   Tuecke,\
    \ S., Welch, V., Engert, D., Pearlman, L., and M.\n               Thompson, \"\
    Internet X.509 Public Key Infrastructure (PKI)\n               Proxy Certificate\
    \ Profile\", RFC 3820, June 2004.\n   [RFC3986]   Berners-Lee, T., Fielding, R.,\
    \ and L. Masinter, \"Uniform\n               Resource Identifier (URI): Generic\
    \ Syntax\", STD 66, RFC\n               3986, January 2005.\n   [X.501]     ITU-T\
    \ Recommendation X.501: Information Technology - Open\n               Systems\
    \ Interconnection - The Directory: Models, 1993.\n   [X.509]     ITU-T Recommendation\
    \ X.509 (2000 E): Information\n               Technology - Open Systems Interconnection\
    \ - The\n               Directory: Authentication Framework, March 2000.\n   [PKIXALGS]\
    \  Bassham, L., Polk, W. and R. Housley, \"Algorithms and\n               Identifiers\
    \ for the Internet X.509 Public Key\n               Infrastructure Certificate\
    \ and Certificate Revocation\n               Lists (CRL) Profile\", RFC 3279,\
    \ April 2002.\n   [CERTSTORE] P. Gutmann, \"Internet X.509 Public Key Infrastructure\n\
    \               Operational Protocols: Certificate Store Access via\n        \
    \       HTTP\", Work in Progress, August 2004.\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Matt Cooper\n   Orion Security Solutions, Inc.\n   1489\
    \ Chain Bridge Rd, Ste. 300\n   McLean, VA  22101,  USA\n   Phone:  +1-703-917-0060\n\
    \   EMail:  mcooper@orionsec.com\n   Yuriy Dzambasow\n   A&N Associates, Inc.\n\
    \   999 Corporate Blvd Ste. 100\n   Linthicum, MD  21090,  USA\n   Phone:  +1-410-859-5449\
    \ x107\n   EMail:  yuriy@anassoc.com\n   Peter Hesse\n   Gemini Security Solutions,\
    \ Inc.\n   4451 Brookfield Corporate Dr. Ste. 200\n   Chantilly, VA  20151,  USA\n\
    \   Phone:  +1-703-378-5808 x105\n   EMail:  pmhesse@geminisecurity.com\n   Susan\
    \ Joseph\n   Van Dyke Technologies\n   6716 Alexander Bell Drive\n   Columbia,\
    \ MD 21046\n   EMail:  susan.joseph@vdtg.com\n   Richard Nicholas\n   BAE Systems\
    \ Information Technology\n   141 National Business Parkway, Ste. 210\n   Annapolis\
    \ Junction, MD  20701,  USA\n   Phone:  +1-301-939-2722\n   EMail:  richard.nicholas@it.baesystems.com\n"
- title: Full Copyright Statement
  contents:
  - "Full Copyright Statement\n   Copyright (C) The Internet Society (2005).\n   This\
    \ document is subject to the rights, licenses and restrictions\n   contained in\
    \ BCP 78, and except as set forth therein, the authors\n   retain all their rights.\n\
    \   This document and the information contained herein are provided on an\n  \
    \ \"AS IS\" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS\n  \
    \ OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY AND THE INTERNET\n   ENGINEERING\
    \ TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS OR IMPLIED,\n   INCLUDING BUT NOT\
    \ LIMITED TO ANY WARRANTY THAT THE USE OF THE\n   INFORMATION HEREIN WILL NOT\
    \ INFRINGE ANY RIGHTS OR ANY IMPLIED\n   WARRANTIES OF MERCHANTABILITY OR FITNESS\
    \ FOR A PARTICULAR PURPOSE.\n"
- title: Intellectual Property
  contents:
  - "Intellectual Property\n   The IETF takes no position regarding the validity or\
    \ scope of any\n   Intellectual Property Rights or other rights that might be\
    \ claimed to\n   pertain to the implementation or use of the technology described\
    \ in\n   this document or the extent to which any license under such rights\n\
    \   might or might not be available; nor does it represent that it has\n   made\
    \ any independent effort to identify any such rights.  Information\n   on the\
    \ procedures with respect to rights in RFC documents can be\n   found in BCP 78\
    \ and BCP 79.\n   Copies of IPR disclosures made to the IETF Secretariat and any\n\
    \   assurances of licenses to be made available, or the result of an\n   attempt\
    \ made to obtain a general license or permission for the use of\n   such proprietary\
    \ rights by implementers or users of this\n   specification can be obtained from\
    \ the IETF on-line IPR repository at\n   http://www.ietf.org/ipr.\n   The IETF\
    \ invites any interested party to bring to its attention any\n   copyrights, patents\
    \ or patent applications, or other proprietary\n   rights that may cover technology\
    \ that may be required to implement\n   this standard.  Please address the information\
    \ to the IETF at ietf-\n   ipr@ietf.org.\n"
- title: Acknowledgement
  contents:
  - "Acknowledgement\n   Funding for the RFC Editor function is currently provided\
    \ by the\n   Internet Society.\n"
