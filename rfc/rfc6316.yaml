- title: __initial_text__
  contents:
  - '    Sockets Application Program Interface (API) for Multihoming Shim

    '
- title: Abstract
  contents:
  - "Abstract\n   This document specifies sockets API extensions for the multihoming\n\
    \   shim layer.  The API aims to enable interactions between applications\n  \
    \ and the multihoming shim layer for advanced locator management, and\n   access\
    \ to information about failure detection and path exploration.\n   This document\
    \ is based on an assumption that a multihomed host is\n   equipped with a conceptual\
    \ sub-layer (hereafter called \"shim sub-\n   layer\") inside the IP layer that\
    \ maintains mappings between\n   identifiers and locators.  Examples of the shim\
    \ are Shim6 and the\n   Host Identity Protocol (HIP).\n"
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This document is not an Internet Standards Track specification;\
    \ it is\n   published for informational purposes.\n   This document is a product\
    \ of the Internet Engineering Task Force\n   (IETF).  It represents the consensus\
    \ of the IETF community.  It has\n   received public review and has been approved\
    \ for publication by the\n   Internet Engineering Steering Group (IESG).  Not\
    \ all documents\n   approved by the IESG are a candidate for any level of Internet\n\
    \   Standard; see Section 2 of RFC 5741.\n   Information about the current status\
    \ of this document, any errata,\n   and how to provide feedback on it may be obtained\
    \ at\n   http://www.rfc-editor.org/info/rfc6316.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (c) 2011 IETF Trust and the persons identified\
    \ as the\n   document authors.  All rights reserved.\n   This document is subject\
    \ to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n\
    \   (http://trustee.ietf.org/license-info) in effect on the date of\n   publication\
    \ of this document.  Please review these documents\n   carefully, as they describe\
    \ your rights and restrictions with respect\n   to this document.  Code Components\
    \ extracted from this document must\n   include Simplified BSD License text as\
    \ described in Section 4.e of\n   the Trust Legal Provisions and are provided\
    \ without warranty as\n   described in the Simplified BSD License.\n   This document\
    \ may contain material from IETF Documents or IETF\n   Contributions published\
    \ or made publicly available before November\n   10, 2008.  The person(s) controlling\
    \ the copyright in some of this\n   material may not have granted the IETF Trust\
    \ the right to allow\n   modifications of such material outside the IETF Standards\
    \ Process.\n   Without obtaining an adequate license from the person(s) controlling\n\
    \   the copyright in such materials, this document may not be modified\n   outside\
    \ the IETF Standards Process, and derivative works of it may\n   not be created\
    \ outside the IETF Standards Process, except to format\n   it for publication\
    \ as an RFC or to translate it into languages other\n   than English.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1. Introduction ....................................................3\n\
    \   2. Requirements Language ...........................................4\n  \
    \ 3. Terminology and Background ......................................4\n   4.\
    \ System Overview .................................................7\n   5. Requirements\
    \ ....................................................8\n   6. Socket Options\
    \ for Multihoming Shim Sub-Layer ..................10\n      6.1. SHIM_ASSOCIATED\
    \ ...........................................14\n      6.2. SHIM_DONTSHIM .............................................15\n\
    \      6.3. SHIM_HOT_STANDBY ..........................................16\n  \
    \    6.4. SHIM_LOC_LOCAL_PREF .......................................17\n    \
    \  6.5. SHIM_LOC_PEER_PREF ........................................18\n      6.6.\
    \ SHIM_LOC_LOCAL_RECV .......................................19\n      6.7. SHIM_LOC_PEER_RECV\
    \ ........................................20\n      6.8. SHIM_LOC_LOCAL_SEND .......................................20\n\
    \      6.9. SHIM_LOC_PEER_SEND ........................................22\n  \
    \    6.10. SHIM_LOCLIST_LOCAL .......................................23\n    \
    \  6.11. SHIM_LOCLIST_PEER ........................................25\n      6.12.\
    \ SHIM_APP_TIMEOUT .........................................26\n      6.13. SHIM_PATHEXPLORE\
    \ .........................................27\n      6.14. SHIM_DEFERRED_CONTEXT_SETUP\
    \ ..............................28\n      6.15. Applicability ............................................28\n\
    \      6.16. Error Handling ...........................................29\n  \
    \ 7. Ancillary Data for Multihoming Shim Sub-Layer ..................29\n    \
    \  7.1. Get Locator from Incoming Packet ..........................30\n      7.2.\
    \ Set Locator for Outgoing Packet ...........................30\n      7.3. Notification\
    \ from Application to Multihoming Shim\n           Sub-Layer .................................................31\n\
    \      7.4. Applicability .............................................31\n  \
    \ 8. Data Structures ................................................32\n    \
    \  8.1. Data Structure for Locator Information ....................32\n      \
    \     8.1.1. Handling Locator behind NAT ........................33\n      8.2.\
    \ Path Exploration Parameter ................................34\n      8.3. Feedback\
    \ Information ......................................35\n   9. System Requirements\
    \ ............................................36\n   10. Relation to Existing\
    \ Sockets API Extensions ...................36\n   11. Operational Considerations\
    \ ....................................37\n      11.1. Conflict Resolution ......................................37\n\
    \      11.2. Incompatibility between IPv4 and IPv6 ....................38\n  \
    \ 12. IANA Considerations ...........................................38\n   13.\
    \ Protocol Constant .............................................38\n   14. Security\
    \ Considerations .......................................38\n      14.1. Treatment\
    \ of Unknown Locator .............................39\n           14.1.1. Treatment\
    \ of Unknown Source Locator ...............39\n           14.1.2. Treatment of\
    \ Unknown Destination Locator ..........39\n   15. Acknowledgments ...............................................40\n\
    \   16. References ....................................................40\n  \
    \    16.1. Normative References .....................................40\n    \
    \  16.2. Informative References ...................................41\n   Appendix\
    \ A. Context Forking .......................................42\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   This document defines sockets API extensions by which upper-layer\n\
    \   protocols may be informed about and control the way in which a\n   multihoming\
    \ shim sub-layer in the IP layer manages the dynamic choice\n   of locators. \
    \ Initially, the multihoming shim sub-layer refers to\n   Shim6 and/or HIP, but\
    \ it is defined generically.\n   The role of the multihoming shim sub-layer (hereafter\
    \ called \"shim\n   sub-layer\" in this document) is to avoid impacts to upper-layer\n\
    \   protocols that may be caused when the endhost changes its attachment\n   point\
    \ to the Internet -- for instance, in the case of a rehoming\n   event under the\
    \ multihomed environment.  There is, however, a need\n   for an API in the cases\
    \ where 1) the upper-layer protocol is\n   particularly sensitive to impacts,\
    \ or 2) the upper-layer protocol\n   wants to benefit from better knowledge of\
    \ what is going on\n   underneath.\n   There are various kinds of technologies\
    \ that aim to solve the same\n   issue (the multihoming issue).  Note that there\
    \ will be conflict when\n   more than one shim sub-layer is active at the same\
    \ time.  The\n   assumption made in this document is that there is only a single\
    \ shim\n   sub-layer (HIP or Shim6) activated on the system.\n   The target readers\
    \ of this document are application programmers who\n   develop application software\
    \ that may benefit greatly from multihomed\n   environments.  In addition, this\
    \ document aims to provide necessary\n   information for developers of shim protocols\
    \ to implement APIs for\n   enabling advanced locator management.\n"
- title: 2.  Requirements Language
  contents:
  - "2.  Requirements Language\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\"\
    , \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"\
    MAY\", and \"OPTIONAL\" in this\n   document are to be interpreted as described\
    \ in [RFC2119].\n"
- title: 3.  Terminology and Background
  contents:
  - "3.  Terminology and Background\n   This section provides terminology used in\
    \ this document.  Basically,\n   most of the terms used in this document are taken\
    \ from the following\n   documents:\n   o  Shim6 Protocol Specification [RFC5533]\n\
    \   o  HIP Architecture [RFC4423]\n   o  Reachability Protocol (REAP) [RFC5534]\n\
    \   In this document, the term \"IP\" refers to both IPv4 and IPv6, unless\n \
    \  the protocol version is specifically mentioned.  The following are\n   definitions\
    \ of terms frequently used in this document:\n   o  Endpoint Identifier (EID)\
    \ -- The identifier used by the\n      application to specify the endpoint of\
    \ a given communication.\n      Applications may handle EIDs in various ways,\
    \ such as long-lived\n      connections, callbacks, and referrals [SHIM6-APP-REFER].\n\
    \      *  In the case of Shim6, an identifier called a ULID (Upper-Layer\n   \
    \      Identifier) serves as an EID.  A ULID is chosen from locators\n       \
    \  available on the host.\n      *  In the case of HIP, an identifier called a\
    \ Host Identifier\n         serves as an EID.  A Host Identifier is derived from\
    \ the public\n         key of a given host.  For the sake of backward compatibility\n\
    \         with the sockets API, the Host Identifier is represented in the\n  \
    \       form of a hash of a public key.\n      *  Note that the EID appears in\
    \ the standard sockets API as an\n         address, and does not appear in the\
    \ extensions defined in this\n         document, which only concern locators.\n\
    \   o  Locator - The IP address actually used to deliver IP packets.\n      Locators\
    \ are present in the source and destination fields of the\n      IP header of\
    \ a packet on the wire.  A locator as discussed in this\n      document could\
    \ be either an IPv4 address or an IPv6 address.  Note\n      that HIP can handle\
    \ both IPv4 and IPv6 locators, whereas Shim6 can\n      handle only IPv6 locators.\
    \  For the HIP case, a locator can be a\n      private IPv4 address when the host\
    \ is behind a NAT.  Section 8.1.1\n      gives a detailed description about the\
    \ handling of a locator\n      behind a NAT.\n      *  List of locators - A list\
    \ of locators associated with an EID.\n         There are two lists of locators\
    \ stored in a given context.  One\n         is associated with the local EID,\
    \ and the other is associated\n         with the remote EID.  As defined in [RFC5533],\
    \ the list of\n         locators associated with an EID 'A' is denoted as Ls(A).\n\
    \      *  Preferred locator - The (source/destination) locator currently\n   \
    \      used to send packets within a given context.\n      *  Unknown locator\
    \ - Any locator that does not appear in the\n         locator list of the shim\
    \ context associated with the socket.\n         When there is no shim context\
    \ associated with the socket, any\n         source and/or destination locator\
    \ requested by the application\n         is considered to be an unknown locator.\n\
    \      *  Valid locator - A valid locator means that the locator is\n        \
    \ considered to be valid in the security sense.  More\n         specifically,\
    \ the validity indicates whether the locator is\n         part of a Hash-Based\
    \ Address (HBA) set [RFC5535].\n      *  Verified locator - A verified locator\
    \ means that the locator is\n         considered to be reachable according to\
    \ the result of a REAP\n         return routability check.  Note that the verification\
    \ applies\n         only to the peer's locator.\n   o  Shim - The conceptual sub-layer\
    \ inside the IP layer.  This sub-\n      layer maintains mappings between EIDs\
    \ and locators.  An EID can be\n      associated with more than one locator at\
    \ a time when the host is\n      multihomed.  The term \"shim\" does not refer\
    \ to a specific protocol\n      but refers to the conceptual sub-layer inside\
    \ the IP layer.\n   o  Identifier/locator adaptation - The adaptation performed\
    \ at the\n      shim sub-layer.  This adaptation may end up re-writing the source\n\
    \      and/or destination addresses of an IP packet.  In the outbound\n      packet\
    \ processing, the EID pair is converted to the associated\n      locator pair.\
    \  In the inbound packet processing, the locator pair\n      is converted to the\
    \ EID pair.\n   o  Context - The state information shared by a given pair of peers.\n\
    \      Context stores a binding between the EID and associated locators.\n   \
    \   Contexts are maintained by the shim sub-layer.  Deferred context\n      setup\
    \ is a scenario where a context is established after the\n      communication\
    \ starts.  Deferred context setup is possible if the\n      ULID is routable,\
    \ such as in the case of Shim6.\n   o  Reachability detection - The procedure\
    \ to check reachability\n      between a given locator pair.\n   o  Path - The\
    \ sequence of routers that an IP packet goes through to\n      reach the destination.\n\
    \   o  Path exploration - The procedure to explore available paths for a\n   \
    \   given set of locator pairs.\n   o  Outage - The incident that prevents IP\
    \ packets flowing from the\n      source locator to the destination locator. \
    \ When there is an\n      outage, it means that there is no reachability between\
    \ a given\n      locator pair.  The outage may be caused by various reasons, such\n\
    \      as a shortage of network resources, congestion, and human error\n     \
    \ (faulty operation).\n   o  Working address pair - Considered to be \"working\"\
    \ if the packet\n      can safely travel from the source to the destination, where\
    \ the\n      packet contains the first address from the pair as the source\n \
    \     address and the second address from the pair as the destination\n      address.\
    \  If reachability is confirmed in both directions, the\n      address pair is\
    \ considered to be working bi-directionally.\n   o  Reachability Protocol (REAP)\
    \ - The protocol for detecting failure\n      and exploring reachability in a\
    \ multihomed environment.  REAP is\n      defined in [RFC5534].\n   In this document,\
    \ syntax and semantics of the API are given in the\n   same way as in the Portable\
    \ Operating System Interface (POSIX)\n   standard [POSIX].  The API specifies\
    \ how to use ancillary data (aka\n   cmsg) to access the locator information with\
    \ recvmsg() and/or\n   sendmsg() I/O calls.  The API is described in C language,\
    \ and data\n   types are defined in the POSIX format; intN_t means a signed integer\n\
    \   of exactly N bits (e.g., int16_t), and uintN_t means an unsigned\n   integer\
    \ of exactly N bits (e.g., uint32_t).\n   The distinction between \"connected\"\
    \ sockets and \"unconnected\" sockets\n   is important when discussing the applicability\
    \ of the sockets API\n   defined in this document.  A connected socket is bound\
    \ to a given\n   peer, whereas an unconnected socket is not bound to any specific\n\
    \   peers.  A TCP socket becomes a connected socket when the TCP\n   connection\
    \ establishment is completed.  UDP sockets are unconnected,\n   unless the application\
    \ uses the connect() system call.\n"
- title: 4.  System Overview
  contents:
  - "4.  System Overview\n   Figure 1 illustrates the system overview.  The shim sub-layer\
    \ and\n   REAP component exist inside the IP layer.  Applications use the\n  \
    \ sockets API defined in this document to interface with the shim\n   sub-layer\
    \ and the transport layer for locator management, failure\n   detection, and path\
    \ exploration.\n   It is also possible that the shim sub-layer interacts with\
    \ the\n   transport layer; however, such an interaction is outside the scope of\n\
    \   this document.\n                        +------------------------+\n     \
    \                   |       Application      |\n                        +------------------------+\n\
    \                           ^                 ^\n              ~~~~~~~~~~~~~|~Socket\
    \ Interface|~~~~~~~~~~~~~~\n                           |                 v\n \
    \              +-----------|------------------------------+\n               |\
    \           |  Transport Layer             |\n               +-----------|------------------------------+\n\
    \                     ^     |\n       +-------------|-----|-------------------------------------+\n\
    \       |             v     v                                     |\n       |\
    \   +-----------------------------+       +----------+    |  IP\n       |   |\
    \            Shim             |<----->|   REAP   |    | Layer\n       |   +-----------------------------+\
    \       +----------+    |\n       |                       ^                  \
    \    ^          |\n       +-----------------------|----------------------|----------+\n\
    \                               v                      v\n               +------------------------------------------+\n\
    \               |                Link Layer                |\n               +------------------------------------------+\n\
    \                         Figure 1: System Overview\n"
- title: 5.  Requirements
  contents:
  - "5.  Requirements\n   The following is a list of requirements from applications:\n\
    \   o  Turn on/off shim.  An application should be able to request to\n      turn\
    \ on or turn off the multihoming support by the shim layer:\n      *  Apply shim.\
    \  The application should be able to explicitly\n         request that the shim\
    \ sub-layer apply multihoming support.\n      *  Don't apply shim.  The application\
    \ should be able to request\n         that the shim sub-layer not apply the multihoming\
    \ support but\n         apply normal IP processing at the IP layer.\n      * \
    \ Note that this function is also required by other types of\n         multihoming\
    \ mechanisms, such as the Stream Control Transmission\n         Protocol (SCTP)\
    \ and multipath TCP, to avoid potential conflict\n         with the shim sub-layer.\n\
    \   o  Locator management.\n      *  It should be possible to set a preferred\
    \ source and/or\n         destination locator within a given context.\n      *\
    \  It should be possible to get a preferred source and/or\n         destination\
    \ locator within a given context.\n      *  It should be possible to set a list\
    \ of source and/or\n         destination locators within a given context: Ls(local)\
    \ and\n         Ls(remote).\n      *  It should be possible to get a list of source\
    \ and/or\n         destination locators within a given context: Ls(local) and\n\
    \         Ls(remote).\n   o  Notification from applications and upper-layer protocols\
    \ to the\n      shim sub-layer about the status of the communication.  The\n \
    \     notification occurs in an event-based manner.  Applications and/or\n   \
    \   upper-layer protocols may provide positive feedback or negative\n      feedback\
    \ to the shim sub-layer.  Note that these types of feedback\n      are mentioned\
    \ in [RFC5534]:\n      *  Applications and/or upper-layer protocols (e.g., TCP)\
    \ may\n         provide positive feedback to the shim sub-layer informing that\n\
    \         the communication is going well.\n      *  Applications and/or upper-layer\
    \ protocols (e.g., TCP) may\n         provide negative feedback to the shim sub-layer\
    \ informing that\n         the communication status is not satisfactory.  TCP\
    \ may detect a\n         problem when it does not receive any expected ACK message\
    \ from\n         the peer.  The REAP module may be triggered by the negative\n\
    \         feedback and invoke the path exploration procedure.\n   o  Feedback\
    \ from applications to the shim sub-layer.  Applications\n      should be able\
    \ to inform the shim sub-layer of the timeout values\n      for detecting failures,\
    \ sending keepalives, and starting the\n      exploration procedure.  In particular,\
    \ applications should be able\n      to suppress keepalives.\n   o  Hot-standby.\
    \  Applications may request the shim sub-layer for a\n      hot-standby capability.\
    \  This means that alternative paths are\n      known to be working in advance\
    \ of a failure detection.  In such a\n      case, it is possible for the shim\
    \ sub-layer to immediately replace\n      the current locator pair with an alternative\
    \ locator pair.\n   o  Eagerness for locator exploration.  An application should\
    \ be able\n      to inform the shim sub-layer of how aggressively it wants the\
    \ REAP\n      mechanism to perform a path exploration (e.g., by specifying the\n\
    \      number of concurrent attempts of discovery of working locator\n      pairs)\
    \ when an outage occurs on the path between the locator pair\n      in use.\n\
    \   o  Providing locator information to applications.  An application\n      should\
    \ be able to obtain information about the locator pair that\n      was actually\
    \ used to send or receive packets.\n      *  For inbound traffic, the application\
    \ may be interested in the\n         locator pair that was actually used to receive\
    \ the packet.\n      *  For outbound traffic, the application may be interested\
    \ in the\n         locator pair that was actually used to transmit the packet.\n\
    \      In this way, applications may have additional control of the\n      locator\
    \ management.  For example, an application becomes capable\n      of verifying\
    \ if its preference for a locator is actually applied\n      to the flow or not.\n\
    \   o  Applications should be able to know if the shim sub-layer supports\n  \
    \    deferred context setup or not.\n   o  An application should be able to know\
    \ if the communication is now\n      being served by the shim sub-layer or not.\n\
    \   o  An application should be able to use a common interface to access\n   \
    \   an IPv4 locator and an IPv6 locator.\n"
- title: 6.  Socket Options for Multihoming Shim Sub-Layer
  contents:
  - "6.  Socket Options for Multihoming Shim Sub-Layer\n   In this section, socket\
    \ options that are specific to the shim\n   sub-layer are defined.\n   Table 1\
    \ shows a list of the socket options that are specific to the\n   shim sub-layer.\
    \  All of these socket options are defined at the level\n   SOL_SHIM.  When an\
    \ application uses one of the socket options by\n   getsockopt() or setsockopt(),\
    \ the second argument MUST be set to\n   SOL_SHIM.\n   The first column of Table\
    \ 1 gives the name of the option.  The second\n   column indicates whether the\
    \ value for the socket option can be read\n   by getsockopt(), and the third column\
    \ indicates whether the value for\n   the socket option can be written by setsockopt().\
    \  The fourth column\n   provides a brief description of the socket option.  The\
    \ fifth column\n   shows the type of data structure specified along with the socket\n\
    \   option.  By default, the data structure type is an integer.\n   +-----------------------------+-----+-----+-----------------+-------+\n\
    \   | optname                     | get | set | description     | dtype |\n  \
    \ +-----------------------------+-----+-----+-----------------+-------+\n   |\
    \ SHIM_ASSOCIATED             | o   |     | Get the         | int   |\n   |  \
    \                           |     |     | parameter that  |       |\n   |    \
    \                         |     |     | indicates       |       |\n   |      \
    \                       |     |     | whether the     |       |\n   |        \
    \                     |     |     | socket is       |       |\n   |          \
    \                   |     |     | associated (1)  |       |\n   |            \
    \                 |     |     | with any shim   |       |\n   |              \
    \               |     |     | context or not  |       |\n   |                \
    \             |     |     | (0).            |       |\n   | SHIM_DONTSHIM    \
    \           | o   | o   | Get or set the  | int   |\n   |                    \
    \         |     |     | parameter that  |       |\n   |                      \
    \       |     |     | indicates       |       |\n   |                        \
    \     |     |     | whether or not  |       |\n   |                          \
    \   |     |     | to employ       |       |\n   |                            \
    \ |     |     | multihoming     |       |\n   |                             |\
    \     |     | support by the  |       |\n   |                             |  \
    \   |     | shim sub-layer. |       |\n   | SHIM_HOT_STANDBY            | o  \
    \ | o   | Get or set the  | int   |\n   |                             |     |\
    \     | parameter to    |       |\n   |                             |     |  \
    \   | request the     |       |\n   |                             |     |    \
    \ | shim sub-layer  |       |\n   |                             |     |     |\
    \ to prepare a    |       |\n   |                             |     |     | hot-standby\
    \     |       |\n   |                             |     |     | connection.  \
    \   |       |\n   | SHIM_LOC_LOCAL_PREF         | o   | o   | Set the        \
    \ | Note  |\n   |                             |     |     | preference      |\
    \ 1     |\n   |                             |     |     | value for a     |  \
    \     |\n   |                             |     |     | source locator  |    \
    \   |\n   |                             |     |     | for outbound    |      \
    \ |\n   |                             |     |     | traffic.  Get   |       |\n\
    \   |                             |     |     | the preferred   |       |\n  \
    \ |                             |     |     | locator for the |       |\n   |\
    \                             |     |     | source locator  |       |\n   |  \
    \                           |     |     | for outbound    |       |\n   |    \
    \                         |     |     | traffic.        |       |\n   | SHIM_LOC_PEER_PREF\
    \          | o   | o   | Set the         | Note  |\n   |                     \
    \        |     |     | preference      | 1     |\n   |                       \
    \      |     |     | value for a     |       |\n   |                         \
    \    |     |     | destination     |       |\n   |                           \
    \  |     |     | locator for     |       |\n   |                             |\
    \     |     | outbound        |       |\n   |                             |  \
    \   |     | traffic.  Get   |       |\n   |                             |    \
    \ |     | the preferred   |       |\n   |                             |     |\
    \     | locator for the |       |\n   |                             |     |  \
    \   | destination     |       |\n   |                             |     |    \
    \ | locator for     |       |\n   |                             |     |     |\
    \ outbound        |       |\n   |                             |     |     | traffic.\
    \        |       |\n   | SHIM_LOC_LOCAL_RECV         | o   | o   | Request the\
    \     | int   |\n   |                             |     |     | shim sub-layer\
    \  |       |\n   |                             |     |     | to store the    |\
    \       |\n   |                             |     |     | destination     |  \
    \     |\n   |                             |     |     | locator of the  |    \
    \   |\n   |                             |     |     | received IP     |      \
    \ |\n   |                             |     |     | packet in an    |       |\n\
    \   |                             |     |     | ancillary data  |       |\n  \
    \ |                             |     |     | object.         |       |\n   |\
    \ SHIM_LOC_PEER_RECV          | o   | o   | Request the     | int   |\n   |  \
    \                           |     |     | shim sub-layer  |       |\n   |    \
    \                         |     |     | to store the    |       |\n   |      \
    \                       |     |     | source locator  |       |\n   |        \
    \                     |     |     | of the received |       |\n   |          \
    \                   |     |     | IP packet in an |       |\n   |            \
    \                 |     |     | ancillary data  |       |\n   |              \
    \               |     |     | object.         |       |\n   | SHIM_LOC_LOCAL_SEND\
    \         | o   | o   | Get or set the  | Note  |\n   |                      \
    \       |     |     | source locator  | 1     |\n   |                        \
    \     |     |     | of outgoing IP  |       |\n   |                          \
    \   |     |     | packets.        |       |\n   | SHIM_LOC_PEER_SEND         \
    \ | o   | o   | Get or set the  | Note  |\n   |                             |\
    \     |     | destination     | 1     |\n   |                             |  \
    \   |     | locator of      |       |\n   |                             |    \
    \ |     | outgoing IP     |       |\n   |                             |     |\
    \     | packets.        |       |\n   | SHIM_LOCLIST_LOCAL          | o   | o\
    \   | Get or set the  | Note  |\n   |                             |     |    \
    \ | list of         | 2     |\n   |                             |     |     |\
    \ locators        |       |\n   |                             |     |     | associated\
    \ with |       |\n   |                             |     |     | the local EID.\
    \  |       |\n   | SHIM_LOCLIST_PEER           | o   | o   | Get or set the  |\
    \ Note  |\n   |                             |     |     | list of         | 2\
    \     |\n   |                             |     |     | locators        |    \
    \   |\n   |                             |     |     | associated with |      \
    \ |\n   |                             |     |     | the peer's EID. |       |\n\
    \   | SHIM_APP_TIMEOUT            | o   | o   | Get or set the  | int   |\n  \
    \ |                             |     |     | Send Timeout    |       |\n   |\
    \                             |     |     | value of REAP.  |       |\n   | SHIM_PATHEXPLORE\
    \            | o   | o   | Get or set      | Note  |\n   |                   \
    \          |     |     | parameters for  | 3     |\n   |                     \
    \        |     |     | path            |       |\n   |                       \
    \      |     |     | exploration and |       |\n   |                         \
    \    |     |     | failure         |       |\n   |                           \
    \  |     |     | detection.      |       |\n   | SHIM_CONTEXT_DEFERRED_SETUP |\
    \ o   |     | Get the         | int   |\n   |                             |  \
    \   |     | parameter that  |       |\n   |                             |    \
    \ |     | indicates       |       |\n   |                             |     |\
    \     | whether         |       |\n   |                             |     |  \
    \   | deferred        |       |\n   |                             |     |    \
    \ | context setup   |       |\n   |                             |     |     |\
    \ is supported or |       |\n   |                             |     |     | not.\
    \            |       |\n   +-----------------------------+-----+-----+-----------------+-------+\n\
    \          Table 1: Socket Options for Multihoming Shim Sub-Layer\n   Note 1:\
    \ Pointer to a shim_locator as defined in Section 8.\n   Note 2: Pointer to an\
    \ array of shim_locator data.\n   Note 3: Pointer to a shim_pathexplore as defined\
    \ in Section 8.\n   Figure 2 illustrates how the shim-specific socket options\
    \ fit into\n   the system model of sockets API.  The figure shows that the shim\
    \ sub-\n   layer and the additional protocol components (IPv4 and IPv6) below\n\
    \   the shim sub-layer are new to the system model.  As previously\n   mentioned,\
    \ all the shim-specific socket options are defined at the\n   SOL_SHIM level.\
    \  This design choice brings the following advantages:\n   1.  The existing sockets\
    \ APIs continue to work at the layer above the\n       shim sub-layer.  That is,\
    \ those legacy APIs handle IP addresses\n       as identifiers.\n   2.  With newly\
    \ defined socket options for the shim sub-layer, the\n       application obtains\
    \ additional control of locator management.\n   3.  The shim-specific socket options\
    \ can be kept independent from\n       address family (IPPROTO_IP or IPPROTO_IPV6)\
    \ and transport\n       protocol (IPPROTO_TCP or IPPROTO_UDP) settings.\n    \
    \                        s1 s2      s3 s4\n                             |  | \
    \      |  |\n            +----------------|--|-------|--|----------------+\n \
    \           |             +-------+   +-------+             |\n            | IPPROTO_TCP\
    \ |  TCP  |   |  UDP  |             |\n            |             +-------+   +-------+\
    \             |\n            |                |   \\     /   |               \
    \ |\n            |                |    -----    |                |\n         \
    \   |                |   /     \\   |                |\n            |        \
    \      +------+   +------+              |\n            |   IPPROTO_IP | IPv4 |\
    \   | IPv6 | IPPROTO_IPV6 |\n            |              +------+   +------+  \
    \            |\n            |                  \\         /             SOL_SOCKET\n\
    \            |          +--------\\-------/--------+          |\n            |\
    \ SOL_SHIM |          shim           |          |\n            |          +--------/-------\\\
    --------+          |\n            |                  /         \\            \
    \      |\n            |              +------+   +------+              |\n    \
    \        |              | IPv4 |   | IPv6 |              |\n            |    \
    \          +------+   +------+              |\n            |                 \
    \ |          |                 |\n            +------------------|----------|-----------------+\n\
    \                               |          |\n                             IPv4\
    \       IPv6\n                           Datagram   Datagram\n         Figure\
    \ 2: System Model of Sockets API with Shim Sub-Layer\n"
- title: 6.1.  SHIM_ASSOCIATED
  contents:
  - "6.1.  SHIM_ASSOCIATED\n   The SHIM_ASSOCIATED option is used to check whether\
    \ or not the socket\n   is associated with any shim context.\n   This option is\
    \ meaningful when the locator information of the\n   received IP packet does not\
    \ tell whether or not the identifier/\n   locator adaptation is performed.  Note\
    \ that the EID pair and the\n   locator pair may be identical in some cases.\n\
    \   Note that the socket option is read-only, and the option value can be\n  \
    \ read by getsockopt().  The result (0/1/2) is set in the option value\n   (the\
    \ fourth argument of getsockopt()).\n   When the application specifies the socket\
    \ option to an unconnected\n   socket, error code EOPNOTSUPP is returned to the\
    \ application.\n   The data type of the option value is an integer.  The option\
    \ value\n   indicates the presence of shim context.  A return value of 1 means\n\
    \   that the socket is associated with a shim context at the shim\n   sub-layer.\
    \  A return value of 0 indicates that there is no shim\n   context associated\
    \ with the socket.  A return value of 2 means that\n   it is not known whether\
    \ or not the socket is associated with a shim\n   context, and this MUST be returned\
    \ only when the socket is\n   unconnected.  In other words, the returned value\
    \ MUST be 0 or 1 when\n   the socket is connected.\n   For example, the option\
    \ can be used by the application as follows:\n       int optval;\n       int optlen\
    \ = sizeof(optval);\n       getsockopt(fd, SOL_SHIM, SHIM_ASSOCIATED, &optval,\
    \ &optlen);\n"
- title: 6.2.  SHIM_DONTSHIM
  contents:
  - "6.2.  SHIM_DONTSHIM\n   The SHIM_DONTSHIM option is used to request that the\
    \ shim layer not\n   provide the multihoming support for the communication established\n\
    \   over the socket.\n   The data type of the option value is an integer, and\
    \ it takes 0 or 1.\n   An option value of 0 means that the shim sub-layer is employed\
    \ if\n   available.  An option value of 1 means that the application does not\n\
    \   want the shim sub-layer to provide the multihoming support for the\n   communication\
    \ established over the socket.\n   The default value is set to 0, which means\
    \ that the shim sub-layer\n   performs identifier/locator adaptation if available.\n\
    \   Any attempt to disable the multihoming shim support MUST be made by\n   the\
    \ application before the socket is connected.  If an application\n   makes such\
    \ an attempt for a connected socket, error code EOPNOTSUPP\n   MUST be returned.\n\
    \   For example, an application can request that the system not apply the\n  \
    \ multihoming support as follows:\n       int optval;\n       optval = 1;\n  \
    \     setsockopt(fd, SOL_SHIM, SHIM_DONTSHIM, &optval, sizeof(optval));\n   For\
    \ example, the application can check the option value as follows:\n       int\
    \ optval;\n       int len;\n       len = sizeof(optval);\n       getsockopt(fd,\
    \ SOL_SHIM, SHIM_DONTSHIM, &optval, &len);\n"
- title: 6.3.  SHIM_HOT_STANDBY
  contents:
  - "6.3.  SHIM_HOT_STANDBY\n   The SHIM_HOT_STANDBY option is used to control whether\
    \ or not the\n   shim sub-layer employs a hot-standby connection for the socket.\
    \  A\n   hot-standby connection is an alternative working locator pair to the\n\
    \   current locator pair.  This option is effective only when there is a\n   shim\
    \ context associated with the socket.\n   The data type of the option value is\
    \ an integer.\n   The option value can be set by setsockopt().\n   The option\
    \ value can be read by getsockopt().\n   By default, the value is set to 0, meaning\
    \ that hot-standby\n   connection is disabled.\n   When the application specifies\
    \ the socket option to an unconnected\n   socket, error code EOPNOTSUPP is returned\
    \ to the application.\n   When there is no shim context associated with the socket,\
    \ error code\n   ENOENT is returned to the application.\n   For example, an application\
    \ can request establishment of a hot-\n   standby connection by using the socket\
    \ option as follows:\n       int optval;\n       optval = 1;\n       setsockopt(fd,\
    \ SOL_SHIM, SHIM_HOT_STANDBY, &optval,\n                  sizeof(optval));\n \
    \  For example, an application can get the option value by using the\n   socket\
    \ option as follows:\n       int optval;\n       int len;\n       len = sizeof(optval);\n\
    \       getsockopt(fd, SOL_SHIM, SHIM_HOT_STANDBY, &optval, &len);\n"
- title: 6.4.  SHIM_LOC_LOCAL_PREF
  contents:
  - "6.4.  SHIM_LOC_LOCAL_PREF\n   The SHIM_LOC_LOCAL_PREF option is used to set the\
    \ preference value\n   for a source locator for outbound traffic, or to get the\
    \ preference\n   value of the source locator for outbound traffic that has the\
    \ highest\n   preference value.\n   This option is effective only when there is\
    \ a shim context associated\n   with the socket.\n   By default, the option value\
    \ is set to NULL, meaning that the option\n   is disabled.\n   The preference\
    \ of a locator is defined by a combination of priority\n   and weight as per DNS\
    \ SRV [RFC2782].  Note that the Shim6 base\n   protocol defines the preference\
    \ of a locator in the same way.\n   The data type of the option value is a pointer\
    \ to the shim_locator\n   information data structure as defined in Section 8.1.\n\
    \   When an application specifies the socket option to an unconnected\n   socket,\
    \ error code EOPNOTSUPP is returned to the application.\n   When there is no shim\
    \ context associated with the socket, error code\n   ENOENT is returned to the\
    \ application.\n   Error code EINVALIDLOCATOR is returned when the validation\
    \ of the\n   specified locator fails.\n   An application can set the preference\
    \ value for a source locator for\n   outbound traffic by setsockopt() with the\
    \ socket option.  Note that\n   lc_ifidx and lc_flags (as defined in Section 8.1)\
    \ have no effect in a\n   set operation.  Below is an example of such a set operation.\n\
    \       struct shim_locator lc;\n       struct in6_addr ip6;\n       /* ...set\
    \ the locator (ip6)... */\n       memset(&lc, 0, sizeof(shim_locator));\n    \
    \   lc.lc_family = AF_INET6;  /* IPv6 */\n       lc.lc_ifidx = 0;\n       lc.lc_flags\
    \ = 0;\n       lc.lc_prio = 1;\n       lc.lc_weight = 10;\n       memcpy(&lc.lc_addr,\
    \ &ip6, sizeof(in6_addr));\n       setsockopt(fd, SOL_SHIM, SHIM_LOC_LOCAL_PREF,\
    \ &lc,\n                  sizeof(optval));\n   An application can get the source\
    \ locator for outbound traffic that\n   has the highest preference value by using\
    \ the socket option.  Below\n   is an example of such a get operation.\n     \
    \  struct shim_locator lc;\n       int len;\n       len = sizeof(lc);\n      \
    \ getsockopt(fd, SOL_SHIM, SHIM_LOC_LOCAL_PREF, &lc, &len);\n"
- title: 6.5.  SHIM_LOC_PEER_PREF
  contents:
  - "6.5.  SHIM_LOC_PEER_PREF\n   The SHIM_LOC_PEER_PREF option is used to set the\
    \ preference value for\n   a destination locator for outbound traffic, or to get\
    \ the preference\n   value of the destination locator for outbound traffic that\
    \ has the\n   highest preference value.\n   This option is effective only when\
    \ there is a shim context associated\n   with the socket.\n   By default, the\
    \ option value is set to NULL, meaning that the option\n   is disabled.\n   As\
    \ defined earlier, the preference of a locator is defined by a\n   combination\
    \ of priority and weight as per DNS SRV [RFC2782].  When\n   there is more than\
    \ one candidate destination locator, the shim\n   sub-layer makes a selection\
    \ based on the priority and weight\n   specified for each locator.\n   The data\
    \ type of the option value is a pointer to the shim_locator\n   information data\
    \ structure as defined in Section 8.1.\n   When the application specifies the\
    \ socket option to an unconnected\n   socket, error code EOPNOTSUPP is returned\
    \ to the application.\n   When there is no shim context associated with the socket,\
    \ error code\n   ENOENT is returned to the application.\n   Error code EINVALIDLOCATOR\
    \ is returned when the validation of the\n   requested locator fails.\n   Error\
    \ code EUNREACHABLELOCATOR is returned when the requested locator\n   is determined\
    \ to be unreachable according to a reachability check.\n   The usage of the option\
    \ is the same as that of SHIM_LOC_LOCAL_PREF.\n"
- title: 6.6.  SHIM_LOC_LOCAL_RECV
  contents:
  - "6.6.  SHIM_LOC_LOCAL_RECV\n   The SHIM_LOC_LOCAL_RECV option can be used to request\
    \ that the shim\n   sub-layer store the destination locator of the received IP\
    \ packet in\n   an ancillary data object that can be accessed by recvmsg().  This\n\
    \   option is effective only when there is a shim context associated with\n  \
    \ the socket.\n   The data type of the option value is an integer.  The option\
    \ value\n   MUST be binary (0 or 1).  By default, the option value is set to 0,\n\
    \   meaning that the option is disabled.\n   An application can set the option\
    \ value by setsockopt().\n   An application can get the option value by getsockopt().\n\
    \   See Section 7 for the procedure to access locator information stored\n   in\
    \ the ancillary data objects.\n   When the application specifies the socket option\
    \ to an unconnected\n   socket, error code EOPNOTSUPP is returned to the application.\n\
    \   When there is no shim context associated with the socket, error code\n   ENOENT\
    \ is returned to the application.\n   For example, an application can request\
    \ the shim sub-layer to store a\n   destination locator by using the socket option\
    \ as follows:\n       int optval;\n       optval = 1;\n       setsockopt(fd, SOL_SHIM,\
    \ SHIM_LOC_LOCAL_RECV, &optval,\n                  sizeof(optval));\n   For example,\
    \ an application can get the option value as follows:\n       int optval;\n  \
    \     int len;\n       len = sizeof(optval);\n       getsockopt(fd, SOL_SHIM,\
    \ SHIM_LOC_LOCAL_RECV, &optval, &len);\n"
- title: 6.7.  SHIM_LOC_PEER_RECV
  contents:
  - "6.7.  SHIM_LOC_PEER_RECV\n   The SHIM_LOC_PEER_RECV option is used to request\
    \ that the shim\n   sub-layer store the source locator of the received IP packet\
    \ in an\n   ancillary data object that can be accessed by recvmsg().  This option\n\
    \   is effective only when there is a shim context associated with the\n   socket.\n\
    \   The data type of the option value is an integer.  The option value\n   MUST\
    \ be binary (0 or 1).  By default, the option value is set to 0,\n   meaning that\
    \ the option is disabled.\n   The option value can be set by setsockopt().\n \
    \  The option value can be read by getsockopt().\n   See Section 7 for the procedure\
    \ to access locator information stored\n   in the ancillary data objects.\n  \
    \ When the application specifies the socket option to an unconnected\n   socket,\
    \ error code EOPNOTSUPP is returned to the application.\n   When there is no shim\
    \ context associated with the socket, error code\n   ENOENT is returned to the\
    \ application.\n   The usage of the option is the same as that of the\n   SHIM_LOC_LOCAL_RECV\
    \ option.\n"
- title: 6.8.  SHIM_LOC_LOCAL_SEND
  contents:
  - "6.8.  SHIM_LOC_LOCAL_SEND\n   The SHIM_LOC_LOCAL_SEND option is used to request\
    \ that the shim\n   sub-layer use a specific locator as the source locator for\
    \ the IP\n   packets to be sent from the socket.  This option is effective only\n\
    \   when there is a shim context associated with the socket.\n   The data type\
    \ of the option value is a pointer to the shim_locator\n   data structure.\n \
    \  An application can set the local locator by setsockopt(), providing a\n   locator\
    \ that is stored in a shim_locator data structure.  When a\n   zero-filled locator\
    \ is specified, the pre-existing setting of the\n   local locator is inactivated.\n\
    \   An application can get the local locator by getsockopt().\n   When the application\
    \ specifies the socket option to an unconnected\n   socket, error code EOPNOTSUPP\
    \ is returned to the application.\n   When there is no shim context associated\
    \ with the socket, error code\n   ENOENT is returned to the application.\n   Error\
    \ code EINVALIDLOCATOR is returned when an invalid locator is\n   specified.\n\
    \   For example, an application can request the shim sub-layer to use a\n   specific\
    \ local locator by using the socket option as follows:\n       struct shim_locator\
    \ locator;\n       struct in6_addr ia6;\n       /* an IPv6 address preferred for\
    \ the source locator is copied\n          to the parameter ia6 */\n       memset(&locator,\
    \ 0, sizeof(locator));\n       /* fill shim_locator data structure */\n      \
    \ locator.lc_family = AF_INET6;\n       locator.lc_ifidx = 0;\n       locator.lc_flags\
    \ = 0;\n       locator.lc_prio = 0;\n       locator.lc_weight = 0;\n       memcpy(&locator.lc_addr,\
    \ &ia6, sizeof(ia6));\n       setsockopt(fd, SOL_SHIM, SHIM_LOC_LOCAL_SEND, &locator,\n\
    \                  sizeof(locator));\n   For example, an application can get the\
    \ designated local locator by\n   using the socket option as follows:\n      \
    \ struct shim_locator locator;\n       memset(&locator, 0, sizeof(locator));\n\
    \       getsockopt(fd, SOL_SHIM, SHIM_LOC_LOCAL_SEND, &locator,\n            \
    \      sizeof(locator));\n       /* check locator */\n"
- title: 6.9.  SHIM_LOC_PEER_SEND
  contents:
  - "6.9.  SHIM_LOC_PEER_SEND\n   The SHIM_LOC_PEER_SEND option is used to request\
    \ that the shim\n   sub-layer use a specific locator for the destination locator\
    \ of IP\n   packets to be sent from the socket.  This option is effective only\n\
    \   when there is a shim context associated with the socket.\n   The data type\
    \ of the option value is a pointer to the shim_locator\n   data structure.\n \
    \  An application can set the remote locator by setsockopt(), providing\n   a\
    \ locator that is stored in a shim_locator data structure.  When a\n   zero-filled\
    \ locator is specified, the pre-existing setting of the\n   remote locator is\
    \ inactivated.\n   An application can get the specified remote locator by getsockopt().\n\
    \   The difference between the SHIM_LOC_PEER_SEND option and the\n   SHIM_LOC_PEER_PREF\
    \ option is that the former guarantees the use of a\n   requested locator when\
    \ applicable, whereas the latter does not.\n   When the application specifies\
    \ the socket option to an unconnected\n   socket, error code EOPNOTSUPP is returned\
    \ to the application.\n   When there is no shim context associated with the socket,\
    \ error code\n   ENOENT is returned to the application.\n   Error code EINVALIDLOCATOR\
    \ is returned when the validation of the\n   requested locator fails.\n   Error\
    \ code EUNVERIFIEDLOCATOR is returned when reachability for the\n   requested\
    \ locator has not been verified yet.\n   Error code EUNREACHABLELOCATOR is returned\
    \ when the requested locator\n   is determined to be unreachable according to\
    \ a reachability check.\n   The usage of the option is the same as that of the\n\
    \   SHIM_LOC_LOCAL_SEND option.\n"
- title: 6.10.  SHIM_LOCLIST_LOCAL
  contents:
  - "6.10.  SHIM_LOCLIST_LOCAL\n   The SHIM_LOCLIST_LOCAL option is used to get or\
    \ set the locator list\n   associated with the local EID of the shim context associated\
    \ with the\n   socket.  This option is effective only when there is a shim context\n\
    \   associated with the socket.\n   The data type of the option value is a pointer\
    \ to the buffer in which\n   a locator list is stored.  See Section 8 for the\
    \ data structure for\n   storing the locator information.  By default, the option\
    \ value is set\n   to NULL, meaning that the option is disabled.\n   An application\
    \ can get the locator list by getsockopt().  Note that\n   the size of the buffer\
    \ pointed to by the optval argument SHOULD be\n   large enough to store an array\
    \ of locator information.  The number of\n   the locator information is not known\
    \ beforehand.\n   The local locator list can be set by setsockopt().  The buffer\n\
    \   pointed to by the optval argument MUST contain an array of locator\n   structures.\n\
    \   When the application specifies the socket option to an unconnected\n   socket,\
    \ error code EOPNOTSUPP is returned to the application.\n   When there is no shim\
    \ context associated with the socket, error code\n   ENOENT is returned to the\
    \ application.\n   Error code EINVALIDLOCATOR is returned when the validation\
    \ of any of\n   the specified locators failed.\n   Error code ETOOMANYLOCATORS\
    \ is returned when the number of locators\n   specified exceeds the limit (SHIM_MAX_LOCATORS),\
    \ or when the size of\n   the buffer provided by the application is not large\
    \ enough to store\n   the locator list provided by the shim sub-layer.\n   For\
    \ example, an application can set a list of locators to be\n   associated with\
    \ the local EID by using the socket option as follows.\n   Note that an IPv4 locator\
    \ can be handled by HIP and not by Shim6.\n       struct shim_locator locators[SHIM_MAX_LOCATORS];\n\
    \       struct sockaddr_in *sin;\n       struct sockaddr_in6 *sin6;\n       memset(locators,\
    \ 0, sizeof(locators));\n       ...\n       /* obtain local IP addresses from\
    \ local interfaces */\n       ...\n       /* first locator (an IPv6 address) */\n\
    \       locators[0].lc_family = AF_INET6;\n       locators[0].lc_ifidx = 0;\n\
    \       locators[0].lc_flags = 0;\n       locators[0].lc_prio = 1;\n       locators[0].lc_weight\
    \ = 0;\n       memcpy(&locators[0].lc_addr, &sa6->sin6_addr,\n              sizeof(sa6->sin6_addr));\n\
    \       ...\n       /* second locator (an IPv4 address) */\n       locators[1].lc_family\
    \ = AF_INET;\n       locators[1].lc_ifidx = 0;\n       locators[1].lc_flags =\
    \ 0;\n       locators[1].lc_prio = 0;\n       locators[1].lc_weight = 0;\n   \
    \    memcpy(&locators[1].lc_addr, &sa->sin_addr,\n              sizeof(sa->sin_addr));\n\
    \       setsockopt(fd, SOL_SHIM, SHIM_LOCLIST_LOCAL, locators,\n             \
    \     sizeof(locators));\n   For example, an application can get a list of locators\
    \ that are\n   associated with the local EID by using the socket option as follows:\n\
    \       struct shim_locator locators[SHIM_MAX_LOCATORS];\n       memset(locators,\
    \ 0, sizeof(locators));\n       getsockopt(fd, SOL_SHIM, SHIM_LOC_LOCAL_RECV,\
    \ locators,\n                  sizeof(locators));\n       /* parse locators */\n\
    \       ...\n"
- title: 6.11.  SHIM_LOCLIST_PEER
  contents:
  - "6.11.  SHIM_LOCLIST_PEER\n   The SHIM_LOCLIST_PEER option is used to get or set\
    \ the locator list\n   associated with the peer EID of the shim context associated\
    \ with the\n   socket.  This option is effective only when there is a shim context\n\
    \   associated with the socket.\n   The data type of the option value is a pointer\
    \ to the buffer where a\n   locator list is stored.  See Section 8 for the data\
    \ structure for\n   storing the locator information.  By default, the option value\
    \ is set\n   to NULL, meaning that the option is disabled.\n   An application\
    \ can get the locator list by getsockopt().  Note that\n   the size of the buffer\
    \ pointed to by the optval argument SHOULD be\n   large enough to store an array\
    \ of locator information.  The number of\n   the locator information is not known\
    \ beforehand.\n   An application can set the locator list by setsockopt().  The\
    \ buffer\n   pointed to by the optval argument MUST contain an array of locator\n\
    \   list items.\n   When the application specifies the socket option to an unconnected\n\
    \   socket, error code EOPNOTSUPP is returned to the application.\n   When there\
    \ is no shim context associated with the socket, error code\n   ENOENT is returned\
    \ to the application.\n   Error code EINVALIDLOCATOR is returned when the validation\
    \ of any of\n   the specified locators failed.\n   Error code EUNVERIFIEDLOCATOR\
    \ is returned when reachability for the\n   requested locator has not been verified\
    \ yet.\n   Error code EUNREACHABLELOCATOR is returned when the requested locator\n\
    \   is determined to be unreachable according to a reachability check.\n   Error\
    \ code ETOOMANYLOCATORS is returned when the number of locators\n   specified\
    \ exceeds the limit (SHIM_MAX_LOCATORS), or when the size of\n   the buffer provided\
    \ by the application is not large enough to store\n   the locator list provided\
    \ by the shim sub-layer.\n   The usage of the option is the same as that of SHIM_LOCLIST_LOCAL.\n"
- title: 6.12.  SHIM_APP_TIMEOUT
  contents:
  - "6.12.  SHIM_APP_TIMEOUT\n   The SHIM_APP_TIMEOUT option is used to get or set\
    \ the Send Timeout\n   value of REAP [RFC5534].  This option is effective only\
    \ when there is\n   a shim context associated with the socket.\n   The data type\
    \ of the option value is an integer.  The value indicates\n   the period of timeout\
    \ in seconds to send a REAP Keepalive message\n   since the last outbound traffic.\
    \  By default, the option value is set\n   to 0, meaning that the option is disabled.\
    \  When the option is\n   disabled, the REAP mechanism follows its default Send\
    \ Timeout value\n   as specified in [RFC5534].\n   When the application specifies\
    \ the socket option to an unconnected\n   socket, error code EOPNOTSUPP is returned\
    \ to the application.\n   When there is no shim context associated with the socket,\
    \ error code\n   ENOENT is returned to the application.\n   When there is no REAP\
    \ instance on the system, error code EOPNOTSUPP\n   is returned to the application.\n\
    \   For example, an application can set the timeout value by using the\n   socket\
    \ option as follows:\n       int optval;\n       optval = 15; /* 15 seconds */\n\
    \       setsockopt(fd, SOL_SHIM, SHIM_APP_TIMEOUT, &optval,\n                \
    \  sizeof(optval));\n   For example, an application can get the timeout value\
    \ by using the\n   socket option as follows:\n       int optval;\n       int len;\n\
    \       len = sizeof(optval);\n       getsockopt(fd, SOL_SHIM, SHIM_APP_TIMEOUT,\
    \ &optval, &len);\n"
- title: 6.13.  SHIM_PATHEXPLORE
  contents:
  - "6.13.  SHIM_PATHEXPLORE\n   The application MAY use this socket option to get\
    \ or set parameters\n   concerning path exploration.  Path exploration is a procedure\
    \ to find\n   an alternative locator pair to the current locator pair.  As the\
    \ REAP\n   specification defines, a peer may send Probe messages to find an\n\
    \   alternative locator pair.\n   This option is effective only when there is\
    \ a shim context associated\n   with the socket.\n   The data type of the option\
    \ value is a pointer to the buffer where a\n   set of information for path exploration\
    \ is stored.  The data\n   structure is defined in Section 8.\n   By default,\
    \ the option value is set to NULL, meaning that the option\n   is disabled.\n\
    \   When the application specifies the socket option to an unconnected\n   socket,\
    \ error code EOPNOTSUPP is returned to the application.\n   When there is no shim\
    \ context associated with the socket, error code\n   ENOENT is returned to the\
    \ application.\n   For example, an application can set parameters for path exploration\n\
    \   by using the socket option as follows:\n       struct shim6_pathexplore pe;\n\
    \       pe.pe_probenum = 4;        /* times */\n       pe.pe_keepaliveto = 10;\
    \    /* seconds */\n       pe.pe_initprobeto = 500;   /* milliseconds */\n   \
    \    pe.pe_reserved = 0;\n       setsockopt(fd, SOL_SHIM, SHIM_PATHEXPLORE, &pe,\
    \ sizeof(pe));\n   For example, an application can get parameters for path exploration\n\
    \   by using the socket option as follows:\n       struct shim6_pathexplore pe;\n\
    \       int len;\n       len = sizeof(pe);\n       getsockopt(fd, SOL_SHIM, SHIM_PATHEXPLORE,\
    \ &pe, &len);\n"
- title: 6.14.  SHIM_DEFERRED_CONTEXT_SETUP
  contents:
  - "6.14.  SHIM_DEFERRED_CONTEXT_SETUP\n   The SHIM_DEFERRED_CONTEXT_SETUP option\
    \ is used to check whether or\n   not deferred context setup is possible.  Deferred\
    \ context setup means\n   that the context is established in parallel with the\
    \ data\n   communication.  Note that Shim6 supports deferred context setup and\n\
    \   HIP does not, because EIDs in HIP (i.e., Host Identifiers) are non-\n   routable.\n\
    \   Note that the socket option is read-only, and the option value can be\n  \
    \ read by getsockopt().\n   The data type for the option value is an integer.\
    \  The option value\n   MUST be binary (0 or 1).  The option value of 1 means\
    \ that the shim\n   sub-layer supports deferred context setup.\n   When the application\
    \ specifies the socket option to an unconnected\n   socket, error code EOPNOTSUPP\
    \ is returned to the application.\n   For example, an application can check whether\
    \ deferred context setup\n   is possible or not as follows:\n       int optval;\n\
    \       int len;\n       len = sizeof(optval);\n       getsockopt(fd, SOL_SHIM,\
    \ SHIM_DEFERRED_CONTEXT_SETUP,\n                  &optval, &len);\n"
- title: 6.15.  Applicability
  contents:
  - "6.15.  Applicability\n   All the socket options defined in this section except\
    \ for the\n   SHIM_DONTSHIM option are applicable to applications that use\n \
    \  connected sockets.\n   All the socket options defined in this section except\
    \ for the\n   SHIM_ASSOCIATED, SHIM_DONTSHIM, and SHIM_CONTEXT_DEFERRED_SETUP\n\
    \   options are effective only when there is a shim context associated\n   with\
    \ the socket.\n"
- title: 6.16.  Error Handling
  contents:
  - "6.16.  Error Handling\n   If successful, getsockopt() and setsockopt() return\
    \ 0; otherwise, the\n   functions return -1 and set errno to indicate an error.\n\
    \   The following are new error values defined for some shim-specific\n   socket\
    \ options indicating that the getsockopt() or setsockopt()\n   finished incompletely:\n\
    \   EINVALIDLOCATOR\n      This indicates that the locator is not part of the\
    \ HBA set\n      [RFC5535] within the shim context associated with the socket.\n\
    \   EUNVERIFIEDLOCATOR\n      This indicates that the reachability of the locator\
    \ has not been\n      confirmed.  This error is applicable to only the peer's\
    \ locator.\n   EUNREACHABLELOCATOR\n      This indicates that the locator is not\
    \ reachable according to the\n      result of the reachability check.  This error\
    \ is applicable to\n      only the peer's locator.\n"
- title: 7.  Ancillary Data for Multihoming Shim Sub-Layer
  contents:
  - "7.  Ancillary Data for Multihoming Shim Sub-Layer\n   This section provides definitions\
    \ of ancillary data to be used for\n   locator management and notification from/to\
    \ the shim sub-layer to/\n   from the application.\n   When the application performs\
    \ locator management by sendmsg() or\n   recvmsg(), a member of the msghdr structure\
    \ (given in Figure 3)\n   called msg_control holds a pointer to the buffer in\
    \ which one or more\n   shim-specific ancillary data objects may be stored.  An\
    \ ancillary\n   data object can store a single locator.  It should be possible\
    \ to\n   process the shim-specific ancillary data object by the existing\n   macros\
    \ defined in the POSIX standard and [RFC3542].\n        struct msghdr {\n    \
    \            caddr_t msg_name;       /* optional address */\n                u_int\
    \   msg_namelen;    /* size of address */\n                struct  iovec *msg_iov;\
    \ /* scatter/gather array */\n                u_int   msg_iovlen;     /* # elements\
    \ in msg_iov */\n                caddr_t msg_control;    /* ancillary data, see\
    \ below */\n                u_int   msg_controllen; /* ancillary data buffer len\
    \ */\n                int     msg_flags;      /* flags on received message */\n\
    \        };\n                        Figure 3: msghdr Structure\n   In the case\
    \ of an unconnected socket, msg_name stores the socket\n   address of the peer.\
    \  Note that the address is not a locator of the\n   peer but the identifier of\
    \ the peer.  SHIM_LOC_PEER_RECV can be used\n   to get the locator of the peer\
    \ node.\n   Table 2 is a list of the shim-specific ancillary data that can be\n\
    \   used for locator management by recvmsg() or sendmsg().  In any case,\n   the\
    \ value of cmsg_level MUST be set to SOL_SHIM.\n     +---------------------+-----------+-----------+-----------------+\n\
    \     | cmsg_type           | sendmsg() | recvmsg() |   cmsg_data[]   |\n    \
    \ +---------------------+-----------+-----------+-----------------+\n     | SHIM_LOC_LOCAL_RECV\
    \ |           |     o     |      Note 1     |\n     | SHIM_LOC_PEER_RECV  |  \
    \         |     o     |      Note 1     |\n     | SHIM_LOC_LOCAL_SEND |     o\
    \     |           |      Note 1     |\n     | SHIM_LOC_PEER_SEND  |     o    \
    \ |           |      Note 1     |\n     | SHIM_FEEDBACK       |     o     |  \
    \         | shim_feedback{} |\n     +---------------------+-----------+-----------+-----------------+\n\
    \                   Table 2: Shim-Specific Ancillary Data\n   Note 1: cmsg_data[]\
    \ within msg_control includes a single\n   sockaddr_in{} or sockaddr_in6{} and\
    \ padding if necessary\n"
- title: 7.1.  Get Locator from Incoming Packet
  contents:
  - "7.1.  Get Locator from Incoming Packet\n   An application can get locator information\
    \ from the received IP\n   packet by specifying the shim-specific socket options\
    \ for the socket.\n   When SHIM_LOC_LOCAL_RECV and/or SHIM_LOC_PEER_RECV socket\
    \ options are\n   set, the application can retrieve a local and/or remote locator\
    \ from\n   the ancillary data.\n   When there is no shim context associated with\
    \ the socket, the shim\n   sub-layer MUST return zero-filled locator information\
    \ to the\n   application.\n"
- title: 7.2.  Set Locator for Outgoing Packet
  contents:
  - "7.2.  Set Locator for Outgoing Packet\n   An application can specify the locators\
    \ to be used for transmitting\n   an IP packet by sendmsg().  When the ancillary\
    \ data of cmsg_type\n   SHIM_LOC_LOCAL_SEND and/or SHIM_LOC_PEER_SEND are specified,\
    \ the\n   application can explicitly specify the source and/or the destination\n\
    \   locators to be used for the communication over the socket.  If the\n   specified\
    \ locator pair is verified, the shim sub-layer overrides the\n   locator(s) of\
    \ the outgoing IP packet.  Note that the effect is\n   limited to the datagram\
    \ transmitted by the sendmsg().\n   When there is no shim context associated with\
    \ the socket, error code\n   ENOENT is returned to the application.\n   Error\
    \ code EINVALIDLOCATOR is returned when validation of the\n   specified locator\
    \ fails.\n   Error code EUNVERIFIEDLOCATOR is returned when reachability for the\n\
    \   requested locator has not been verified yet.  The application is\n   recommended\
    \ to use another destination locator until the reachability\n   check for the\
    \ requested locator is done.\n   Error code EUNREACHABLELOCATOR is returned when\
    \ the requested locator\n   is determined to be unreachable according to a reachability\
    \ check.\n   The application is recommended to use another destination locator\n\
    \   when receiving the error.\n"
- title: 7.3.  Notification from Application to Multihoming Shim Sub-Layer
  contents:
  - "7.3.  Notification from Application to Multihoming Shim Sub-Layer\n   An application\
    \ MAY provide feedback to the shim sub-layer about the\n   communication status.\
    \  Such feedback is useful for the shim sub-layer\n   to monitor the reachability\
    \ status of the currently used locator pair\n   in a given shim context.\n   The\
    \ notification can be made by sendmsg() specifying a new ancillary\n   data called\
    \ SHIM_FEEDBACK.  The ancillary data can be handled by\n   specifying the SHIM_FEEDBACK\
    \ option in cmsg_type.\n   When there is no shim context associated with the socket,\
    \ error code\n   ENOENT is returned to the application.\n   See Section 8.3 for\
    \ details of the data structure to be used.\n   It is outside the scope of this\
    \ document to describe how the shim\n   sub-layer would react when feedback is\
    \ provided by an application.\n"
- title: 7.4.  Applicability
  contents:
  - "7.4.  Applicability\n   All the ancillary data for the shim sub-layer is applicable\
    \ to\n   connected sockets.\n   Care is needed when the SHIM_LOC_*_RECV socket\
    \ option is used for\n   stream-oriented sockets (e.g., TCP sockets) because there\
    \ is no one-\n   to-one mapping between a single send or receive operation and\
    \ the\n   data (e.g., a TCP segment) being received.  In other words, there is\n\
    \   no guarantee that the locator(s) set in the SHIM_LOC_*_RECV ancillary\n  \
    \ data is identical to the locator(s) that appears in the IP packets\n   received.\
    \  The shim sub-layer SHOULD provide the latest locator\n   information to the\
    \ application in response to the SHIM_LOC_*_RECV\n   socket option.\n"
- title: 8.  Data Structures
  contents:
  - "8.  Data Structures\n   This section gives data structures for the shim sub-layer.\
    \  These\n   data structures are either used as a parameter for setsockopt() or\n\
    \   getsockopt() (as mentioned in Section 6), or as a parameter for\n   ancillary\
    \ data to be processed by sendmsg() or recvmsg() (as\n   mentioned in Section\
    \ 7).\n"
- title: 8.1.  Data Structure for Locator Information
  contents:
  - "8.1.  Data Structure for Locator Information\n   As defined in Section 6, the\
    \ SHIM_LOC_*_PREF, SHIM_LOC_*_SEND, and\n   SHIM_LOCLIST_* socket options need\
    \ to handle one or more locator\n   information points.  Locator information includes\
    \ not only the\n   locator itself but also additional information about the locator\
    \ that\n   is useful for locator management.  A new data structure is defined\
    \ to\n   serve as a placeholder for the locator information.\n   Figure 4 illustrates\
    \ the data structure called shim_locator, which\n   stores locator information.\n\
    \        struct shim_locator {\n                uint8_t    lc_family;       /*\
    \ address family */\n                uint8_t    lc_proto;        /* protocol */\n\
    \                uint16_t   lc_port;         /* port number */\n             \
    \   uint16_t   lc_prio;         /* preference value */\n                uint16_t\
    \   lc_weight;       /* weight */\n                uint32_t   lc_ifidx;      \
    \  /* interface index */\n                struct in6_addr lc_addr;    /* address\
    \ */\n                uint16_t   lc_flags;        /* flags */\n        };\n  \
    \                   Figure 4: Shim Locator Structure\n   lc_family\n      Address\
    \ family of the locator (e.g., AF_INET, AF_INET6).  It is\n      required that\
    \ the parameter contains a non-zero value indicating\n      the exact address\
    \ family of the locator.\n   lc_proto\n      Internet Protocol number for the\
    \ protocol that is used to handle a\n      locator behind a NAT.  The value MUST\
    \ be set to zero when there is\n      no NAT involved.  When the locator is behind\
    \ a NAT, the value MUST\n      be set to IPPROTO_UDP.\n   lc_port\n      Port\
    \ number that is used for handling a locator behind a NAT.\n   lc_prio\n     \
    \ Priority of the locator.  The range is 0-65535.  The lowest\n      priority\
    \ value means the highest priority.\n   lc_weight\n      Weight value indicates\
    \ a relative weight for locators with the\n      same priority value.  The range\
    \ is 0-65535.  A locator with higher\n      weight value is prioritized over the\
    \ other locators with lower\n      weight values.\n   lc_ifidx\n      Interface\
    \ index of the network interface to which the locator is\n      assigned.  This\
    \ field is applicable only to local locators, and\n      has no effect in set\
    \ operations.\n   lc_addr\n      Contains the locator.  In the case of IPv4, the\
    \ locator MUST be\n      formatted in the IPv4-mapped IPv6 address as defined\
    \ in [RFC4291].\n      The locator MUST be stored in network byte order.\n   lc_flags\n\
    \      Each bit of the flags represents a specific characteristic of the\n   \
    \   locator.  The Hash-Based Address (HBA) is defined as 0x01.  The\n      Cryptographically\
    \ Generated Address (CGA) is defined as 0x02.\n      This field has no effect\
    \ in set operations.\n"
- title: 8.1.1.  Handling Locator behind NAT
  contents:
  - "8.1.1.  Handling Locator behind NAT\n   Note that the locator information MAY\
    \ contain a locator behind a\n   Network Address Translator (NAT).  Such a situation\
    \ may arise when\n   the host is behind the NAT and uses a local address as a\
    \ source\n   locator to communicate with the peer.  Note that a NAT traversal\n\
    \   mechanism for HIP is defined, which allows a HIP host to tunnel\n   control\
    \ and data traffic over UDP [RFC5770].  Note also that the\n   locator behind\
    \ a NAT is not necessarily an IPv4 address and can be an\n   IPv6 address.  Below\
    \ is an example where the application sets a UDP\n   encapsulation interface as\
    \ a source locator when sending IP packets.\n          struct shim_locator locator;\n\
    \          struct in6_addr ia6;\n          /* copy the private IPv4 address to\
    \ the ia6 as an IPv4-mapped\n             IPv6 address */\n          memset(&locator,\
    \ 0, sizeof(locator));\n          /* fill shim_locator data structure */\n   \
    \       locator.lc_family = AF_INET;\n          locator.lc_proto = IPPROTO_UDP;\n\
    \          locator.lc_port = 50500;\n          locator.lc_ifidx = 0;\n       \
    \   locator.lc_flags = 0;\n          locator.lc_prio = 0;\n          locator.lc_weight\
    \ = 0;\n          memcpy(&locator.lc_addr, &ia6, sizeof(ia6));\n          setsockopt(fd,\
    \ SOL_SHIM, SHIM_LOC_LOCAL_SEND, &locator,\n                     sizeof(locator));\n\
    \                   Figure 5: Handling Locator behind NAT\n"
- title: 8.2.  Path Exploration Parameter
  contents:
  - "8.2.  Path Exploration Parameter\n   As defined in Section 6, SHIM_PATHEXPLORE\
    \ allows an application to\n   set or read the parameters for path exploration\
    \ and failure\n   detection.  A new data structure called shim_pathexplore is\
    \ defined\n   to store the necessary parameters.  Figure 6 illustrates the data\n\
    \   structure.  The data structure can be passed to getsockopt() or\n   setsockopt()\
    \ as an argument.\n        struct shim_pathexplore {\n                uint16_t\
    \  pe_probenum;      /* # of initial probes */\n                uint16_t  pe_keepaliveto;\
    \   /* Keepalive Timeout */\n                uint16_t  pe_keepaliveint;  /* Keepalive\
    \ Interval */\n                uint16_t  pe_initprobeto;   /* Initial Probe Timeout\
    \ */\n                uint32_t  pe_reserved;      /* reserved */\n        };\n\
    \                     Figure 6: Path Explore Structure\n   pe_probenum\n     \
    \ Indicates the number of initial Probe messages to be sent.  The\n      value\
    \ MUST be set as per [RFC5534].\n   pe_keepaliveto\n      Indicates the timeout\
    \ value in seconds for detecting a failure\n      when the host does not receive\
    \ any packets for a certain period of\n      time while there is outbound traffic.\
    \  When the timer expires, the\n      path exploration procedure will be carried\
    \ out by sending a REAP\n      Probe message.  The value MUST be set as per [RFC5534].\n\
    \   pe_keepaliveint\n      Indicates the interval of REAP Keepalive messages in\
    \ seconds to be\n      sent by the host when there is no outbound traffic to the\
    \ peer\n      host.  The value MUST be set as per [RFC5534].\n   pe_initprobeto\n\
    \      Indicates the retransmission timer of the REAP Probe message in\n     \
    \ milliseconds.  Note that this timer is applied before exponential\n      back-off\
    \ is started.  A REAP Probe message for the same locator\n      pair may be retransmitted.\
    \  The value MUST be set as per\n      [RFC5534].\n   pe_reserved\n      A reserved\
    \ field for future extension.  By default, the field MUST\n      be initialized\
    \ to zero.\n"
- title: 8.3.  Feedback Information
  contents:
  - "8.3.  Feedback Information\n   As mentioned in Section 7.3, applications can\
    \ inform the shim\n   sub-layer about the status of unicast reachability of the\
    \ locator\n   pair currently in use.  The feedback information can be handled\
    \ by\n   using ancillary data called SHIM_FEEDBACK.  A new data structure\n  \
    \ named shim_feedback is illustrated in Figure 7.\n        struct shim_feedback\
    \ {\n                uint8_t   fb_direction;    /* direction of traffic */\n \
    \               uint8_t   fb_indicator;    /* indicator (1-3) */\n           \
    \     uint16_t  fb_reserved;     /* reserved */\n        };\n                \
    \ Figure 7: Feedback Information Structure\n   fb_direction\n      Indicates the\
    \ direction of reachability between the locator pair\n      in question.  A value\
    \ of 0 indicates outbound direction, and a\n      value of 1 indicates inbound\
    \ direction.\n   fb_indicator\n      A value indicating the degree of satisfaction\
    \ of a unidirectional\n      reachability for a given locator pair.\n      * \
    \ 0: Default value.  Whenever this value is specified, the\n         feedback\
    \ information MUST NOT be processed by the shim\n         sub-layer.\n      *\
    \  1: Unable to connect.  There is no unidirectional reachability\n         between\
    \ the locator pair in question.\n      *  2: Unsatisfactory.  The application\
    \ is not satisfied with the\n         unidirectional reachability between the\
    \ locator pair in\n         question.\n      *  3: Satisfactory.  There is satisfactory\
    \ unidirectional\n         reachability between the locator pair in question.\n\
    \   fb_reserved\n      Reserved field.  MUST be ignored by the receiver.\n"
- title: 9.  System Requirements
  contents:
  - "9.  System Requirements\n   As addressed in Section 6, most of the socket options\
    \ and ancillary\n   data defined in this document are applicable to connected\
    \ sockets.\n   It is assumed that the kernel is capable of maintaining the\n \
    \  association between a connected socket and a shim context.  This\n   requirement\
    \ is considered to be reasonable because a pair of source\n   and destination\
    \ IP addresses is bound to a connected socket.\n"
- title: 10.  Relation to Existing Sockets API Extensions
  contents:
  - "10.  Relation to Existing Sockets API Extensions\n   This section explains the\
    \ relation between the sockets API defined in\n   this document and the existing\
    \ sockets API extensions.\n   As mentioned in Section 6, the basic assumption\
    \ is that the existing\n   sockets API continues to work above the shim sub-layer.\
    \  This means\n   that the existing sockets API deals with identifiers, and the\
    \ sockets\n   API defined in this document deals with locators.\n   SHIM_LOC_LOCAL_SEND\
    \ and SHIM_LOC_PEER_SEND socket options are\n   semantically similar to the IPV6_PKTINFO\
    \ sockets API in the sense\n   that both provide a means for an application to\
    \ set the source IP\n   address of outbound IP packets.\n   SHIM_LOC_LOCAL_RECV\
    \ and SHIM_LOC_PEER_RECV socket options are\n   semantically similar to the IP_RECVDSTADDR\
    \ and IPV6_PKTINFO sockets\n   APIs in the sense that both provide a means for\
    \ an application to get\n   the source and/or destination IP address of inbound\
    \ IP packets.\n   getsockname() and getpeername() enable an application to get\
    \ the\n   \"name\" of the communication endpoints, which is represented by a pair\n\
    \   of IP addresses and port numbers assigned to the socket.\n   getsockname()\
    \ gives the IP address and port number assigned to the\n   socket on the local\
    \ side, and getpeername() gives the IP address and\n   port number of the peer\
    \ side.\n"
- title: 11.  Operational Considerations
  contents:
  - "11.  Operational Considerations\n   This section gives operational considerations\
    \ of the sockets API\n   defined in this document.\n"
- title: 11.1.  Conflict Resolution
  contents:
  - "11.1.  Conflict Resolution\n   There can be a conflicting situation when different\
    \ applications\n   specify different preferences for the same shim context.  For\n\
    \   instance, suppose that applications A and B establish communication\n   with\
    \ the same EID pair while both applications have different\n   preferences in\
    \ their choice of local locator.  The notion of context\n   forking in Shim6 can\
    \ resolve the conflicting situation.\n   It is possible that socket options defined\
    \ in Section 6 cause a\n   conflicting situation when the target context is shared\
    \ by multiple\n   applications.  In such a case, the socket handler should inform\
    \ the\n   shim sub-layer that context forking is required.  In Shim6, when a\n\
    \   context is forked, a unique identifier called the Forked Instance\n   Identifier\
    \ (FII) is assigned to the newly forked context.  The forked\n   context is then\
    \ exclusively associated with the socket through which\n   a non-default preference\
    \ value was specified.  The forked context is\n   maintained by the shim sub-layer\
    \ during the lifetime of the\n   associated socket instance.  When the socket\
    \ is closed, the shim\n   sub-layer SHOULD delete the associated context.\n  \
    \ When the application specifies SHIM_LOC_*_SEND specifying a different\n   source\
    \ or destination locator that does not have the highest priority\n   and weight\
    \ specified by the SHIM_LOC_*_PREF, the shim sub-layer\n   SHOULD supersede the\
    \ request made by SHIM_LOC_*_SEND over the\n   preference specified by SHIM_LOC_*_PREF.\n\
    \   When the peer provides preferences of the locators (e.g., a Shim6\n   peer\
    \ sends a locator with a Locator Preferences Option) that conflict\n   with preferences\
    \ specified by the applications either by\n   SHIM_LOC_PEER_SEND or SHIM_LOC_PEER_PREF,\
    \ the shim sub-layer SHOULD\n   supersede the preferences made by the applications\
    \ over the\n   preferences specified by the peer.\n"
- title: 11.2.  Incompatibility between IPv4 and IPv6
  contents:
  - "11.2.  Incompatibility between IPv4 and IPv6\n   The shim sub-layer performs\
    \ identifier/locator adaptation.\n   Therefore, in some cases, the whole IP header\
    \ can be replaced with a\n   new IP header of a different address family (e.g.,\
    \ conversion from\n   IPv4 to IPv6 or vice versa).  Hence, there is an issue regarding\
    \ how\n   to make the conversion with minimum impact.  Note that this issue is\n\
    \   common in other protocol conversion techniques [RFC2765] [RFC6145].\n   As\
    \ studied in the previous works on protocol conversion [RFC2765],\n   [RFC6145]\
    \ some of the features (IPv6 routing headers, hop-by-hop\n   extension headers,\
    \ and destination headers) from IPv6 are not\n   convertible to IPv4.  In addition,\
    \ the notion of source routing is\n   not exactly the same in IPv4 and IPv6. \
    \ This means that an error may\n   occur during the conversion of the identifier\
    \ and locator.  It is\n   outside the scope of this document to describe how the\
    \ shim sub-layer\n   should behave in such erroneous cases.\n"
- title: 12.  IANA Considerations
  contents:
  - "12.  IANA Considerations\n   There are no IANA considerations for the socket\
    \ options (SHIM_*), the\n   ancillary data, and the socket level (SOL_SHIM) that\
    \ are defined in\n   this document.  All the numbers concerned are not under the\
    \ control\n   of the IETF or IANA, but they are platform-specific.\n"
- title: 13.  Protocol Constant
  contents:
  - "13.  Protocol Constant\n   This section defines a protocol constant.\n   SHIM_MAX_LOCATORS\
    \  The maximum number of locators to be included in a\n      locator list.  The\
    \ value is set to 32.\n"
- title: 14.  Security Considerations
  contents:
  - "14.  Security Considerations\n   This section gives security considerations of\
    \ the API defined in this\n   document.\n"
- title: 14.1.  Treatment of Unknown Locator
  contents:
  - "14.1.  Treatment of Unknown Locator\n   When sending IP packets, there is a possibility\
    \ that an application\n   will request the use of an unknown locator for the source\
    \ and/or\n   destination locators.  Note that the treatment of an unknown locator\n\
    \   can be a subject of security considerations, because the use of an\n   invalid\
    \ source and/or destination locator may cause a redirection\n   attack.\n"
- title: 14.1.1.  Treatment of Unknown Source Locator
  contents:
  - "14.1.1.  Treatment of Unknown Source Locator\n   The shim sub-layer checks to\
    \ determine if the requested locator is\n   available on any local interface.\
    \  If not, the shim sub-layer MUST\n   reject the request and return an error\
    \ message with the\n   EINVALIDLOCATOR code to the application.  If the locator\
    \ is confirmed\n   to be available, the shim sub-layer SHOULD initiate the procedure\
    \ to\n   update the locator list.\n   Use of the following socket options and\
    \ ancillary data requires\n   treatment of an unknown source locator:\n   o  SHIM_LOC_LOCAL_SEND\n\
    \   o  SHIM_LOC_LOCAL_PREF\n   o  SHIM_LOCLIST_LOCAL\n"
- title: 14.1.2.  Treatment of Unknown Destination Locator
  contents:
  - "14.1.2.  Treatment of Unknown Destination Locator\n   If the shim sub-layer turns\
    \ out to be Shim6, the Shim6 layer MUST\n   reject the request for using an unknown\
    \ destination locator.\n   If the shim sub-layer turns out to be HIP, the HIP\
    \ layer MUST reject\n   the request for using an unknown destination locator.\
    \  There is,\n   however, an exceptional case where the HIP layer SHOULD accept\
    \ the\n   request, provided that the HIP association is in the UNASSOCIATED\n\
    \   state.  Details of locator handling in HIP are described in\n   Section 4.6\
    \ of [RFC6317].\n   Use of the following socket options and ancillary data requires\n\
    \   treatment of an unknown destination locator:\n   o  SHIM_LOC_PEER_SEND\n \
    \  o  SHIM_LOC_PEER_PREF\n   o  SHIM_LOCLIST_PEER\n"
- title: 15.  Acknowledgments
  contents:
  - "15.  Acknowledgments\n   The authors would like to thank Jari Arkko, who participated\
    \ in the\n   discussion that led to the first version of this document, and Tatuya\n\
    \   Jinmei, who thoroughly reviewed the early draft version of this\n   document\
    \ and provided detailed comments on sockets API-related\n   issues.  Thomas Henderson\
    \ provided valuable comments, especially from\n   the HIP perspective.\n   The\
    \ authors sincerely thank the following people for their helpful\n   comments\
    \ regarding the document: Samu Varjonen, Dmitriy Kuptsov,\n   Brian Carpenter,\
    \ Michael Scharf, Sebastien Barre, and Roni Even.\n"
- title: 16.  References
  contents:
  - '16.  References

    '
- title: 16.1.  Normative References
  contents:
  - "16.1.  Normative References\n   [POSIX]     \"IEEE Std. 1003.1-2008 Standard\
    \ for Information\n               Technology -- Portable Operating System Interface\n\
    \               (POSIX).  Open group Technical Standard: Base\n              \
    \ Specifications, Issue 7\", September 2008,\n               <http://www.opengroup.org/austin>.\n\
    \   [RFC2119]   Bradner, S., \"Key words for use in RFCs to Indicate\n       \
    \        Requirement Levels\", BCP 14, RFC 2119, March 1997.\n   [RFC3542]   Stevens,\
    \ W., Thomas, M., Nordmark, E., and T.  Jinmei,\n               \"Advanced Sockets\
    \ Application Program Interface (API) for\n               IPv6\", RFC 3542, May\
    \ 2003.\n   [RFC4423]   Moskowitz, R. and P. Nikander, \"Host Identity Protocol\n\
    \               (HIP) Architecture\", RFC 4423, May 2006.\n   [RFC5533]   Nordmark,\
    \ E. and M. Bagnulo, \"Shim6: Level 3 Multihoming\n               Shim Protocol\
    \ for IPv6\", RFC 5533, June 2009.\n   [RFC5534]   Arkko, J. and I. van Beijnum,\
    \ \"Failure Detection and\n               Locator Pair Exploration Protocol for\
    \ IPv6 Multihoming\",\n               RFC 5534, June 2009.\n"
- title: 16.2.  Informative References
  contents:
  - "16.2.  Informative References\n   [RFC2765]   Nordmark, E., \"Stateless IP/ICMP\
    \ Translation Algorithm\n               (SIIT)\", RFC 2765, February 2000.\n \
    \  [RFC2782]   Gulbrandsen, A., Vixie, P., and L. Esibov, \"A DNS RR for\n   \
    \            specifying the location of services (DNS SRV)\", RFC 2782,\n    \
    \           February 2000.\n   [RFC4291]   Hinden, R. and S. Deering, \"IP Version\
    \ 6 Addressing\n               Architecture\", RFC 4291, February 2006.\n   [RFC5535]\
    \   Bagnulo, M., \"Hash-Based Addresses (HBA)\", RFC 5535,\n               June\
    \ 2009.\n   [RFC5770]   Komu, M., Henderson, T., Tschofenig, H., Melen, J., and\n\
    \               A. Keranen, Ed., \"Basic Host Identity Protocol (HIP)\n      \
    \         Extensions for Traversal of Network Address Translators\",\n       \
    \        RFC 5770, April 2010.\n   [RFC6145]   Li, X., Bao, C., and F. Baker,\
    \ \"IP/ICMP Translation\n               Algorithm\", RFC 6145, April 2011.\n \
    \  [RFC6317]   Komu, M. and T. Henderson, \"Basic Socket Interface\n         \
    \      Extensions for the Host Identity Protocol (HIP)\",\n               RFC\
    \ 6317, July 2011.\n   [SHIM6-APP-REFER]\n               Nordmark, E., \"Shim6\
    \ Application Referral Issues\", Work\n               in Progress, July 2005.\n"
- title: Appendix A.  Context Forking
  contents:
  - "Appendix A.  Context Forking\n   In this section, an issue concerning context\
    \ forking and its relation\n   to the multihoming shim API are discussed.\n  \
    \ Shim6 supports the notion of context forking.  A peer may decide to\n   fork\
    \ a context for a certain reason (e.g., an upper-layer protocol\n   prefers to\
    \ use a different locator pair than the one defined in an\n   available context).\
    \  The procedure of context forking is done\n   similarly to the normal context\
    \ establishment, performing the 4-way\n   message exchange.  A peer who has decided\
    \ to fork a context initiates\n   the context establishment.  Hereafter, we call\
    \ this peer the\n   \"initiator\".  The peer of the initiator is called the \"\
    responder\".\n   Once the forked context is established between the peers, on\
    \ the\n   initiator side, it is possible to apply forked context to the packet\n\
    \   flow, since the system maintains an association between the forked\n   context\
    \ and the socket owned by the application that has requested\n   the context forking.\
    \  How this association is maintained is an\n   implementation-specific issue.\
    \  However, on the responder side, there\n   is a question of how the outbound\
    \ packet can be multiplexed by the\n   shim sub-layer, because there is more than\
    \ one Shim6 context that\n   matches with the ULID pair of the packet flow.  There\
    \ is a need to\n   differentiate packet flows not only by the ULID pairs but by\
    \ some\n   other information and associate a given packet flow with a specific\n\
    \   context.\n   Figure 8 gives an example of a scenario where two communicating\
    \ peers\n   fork a context.  Initially, there has been a single transaction\n\
    \   between the peers, by the application 1 (App1).  Accordingly, another\n  \
    \ transaction is started, by application 2 (App2).  Both of the\n   transactions\
    \ are made based on the same ULID pair.  The first context\n   pair (Ctx1) is\
    \ established for the transaction of App1.  Given the\n   requests from App2,\
    \ the shim sub-layer on Peer 1 decides to fork a\n   context.  Accordingly, a\
    \ forked context (Ctx2) is established between\n   the peers, which should be\
    \ exclusively applied to the transaction of\n   App2.  Ideally, multiplexing and\
    \ demultiplexing of packet flows that\n   relate to App1 and App2 should be done\
    \ as illustrated in Figure 8.\n   However, as mentioned earlier, the responder\
    \ needs to multiplex\n   outbound flows of App1 and App2 somehow.  Note that if\
    \ a context\n   forking occurs on the initiator side, a context forking needs\
    \ to also\n   occur on the responder side.\n              Peer 1             \
    \                    Peer 2\n            (initiator)                         \
    \   (responder)\n       +----+         +----+                  +----+        \
    \ +----+\n       |App1|         |App2|                  |App1|         |App2|\n\
    \       +----+         +----+                  +----+         +----+\n       \
    \  |^             |^                      ^|             ^|\n         v|     \
    \        v|                      |v             |v\n    -----S1-------------S2-----\
    \            -----S1-------------S2-----\n         ||             ||         \
    \             ||             ||\n         ||             ||                  \
    \    ||             ||\n        Ctx1           Ctx2                    Ctx1  \
    \         Ctx2\n    ULID:<A1,B1>   ULID:<A1,B1>            ULID:<B1,A1>    ULID:<B1,A1>\n\
    \    Loc: <A1,B2>   Loc: <A1,B3>            Loc: <B2,A1>    Loc: <B3,A1>\n   \
    \ FII: 0         FII: 100                FII: 0          FII: 100\n         |^\
    \             |^                      ^|             ^|\n         ||         \
    \    ||                      ||             ||\n         ||             ||   \
    \                   ||             ||\n         \\..............||....................../|\
    \             ||\n          \\.............||......................./        \
    \     ||\n                        ||                                     ||\n\
    \                        \\|...................................../|\n        \
    \                 \\....................................../\n                \
    \         Figure 8: Context Forking\n   How to solve the issue described above\
    \ is a topic for further study.\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Miika Komu\n   Aalto University\n   Espoo\n   Finland\n\
    \   Phone: +358505734395\n   Fax:   +358947025014\n   EMail: miika@iki.fi\n  \
    \ URI:   http://cse.aalto.fi/research/groups/datacommunications/people/\n   Marcelo\
    \ Bagnulo\n   Universidad Carlos III de Madrid\n   Av. Universidad 30\n   Leganes\
    \  28911\n   SPAIN\n   Phone: +34 91 6248837\n   EMail: marcelo@it.uc3m.es\n \
    \  URI:   http://it.uc3m.es/marcelo\n   Kristian Slavov\n   Ericsson Research\
    \ Nomadiclab\n   Hirsalantie 11\n   Jorvas  FI-02420\n   Finland\n   Phone: +358\
    \ 9 299 3286\n   EMail: kristian.slavov@ericsson.com\n   Shinta Sugimoto (editor)\n\
    \   Nippon Ericsson K.K.\n   Koraku Mori Building\n   1-4-14, Koraku, Bunkyo-ku\n\
    \   Tokyo  112-0004\n   Japan\n   Phone: +81 3 3830 2241\n   EMail: shinta.sugimoto@ericsson.com\n"
