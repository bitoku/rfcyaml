- title: __initial_text__
  contents:
  - '   End-Host Mobility and Multihoming with the Host Identity Protocol

    '
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This memo defines an Experimental Protocol for the Internet\n\
    \   community.  It does not specify an Internet standard of any kind.\n   Discussion\
    \ and suggestions for improvement are requested.\n   Distribution of this memo\
    \ is unlimited.\n"
- title: Abstract
  contents:
  - "Abstract\n   This document defines mobility and multihoming extensions to the\
    \ Host\n   Identity Protocol (HIP).  Specifically, this document defines a\n \
    \  general \"LOCATOR\" parameter for HIP messages that allows for a HIP\n   host\
    \ to notify peers about alternate addresses at which it may be\n   reached.  This\
    \ document also defines elements of procedure for\n   mobility of a HIP host --\
    \ the process by which a host dynamically\n   changes the primary locator that\
    \ it uses to receive packets.  While\n   the same LOCATOR parameter can also be\
    \ used to support end-host\n   multihoming, detailed procedures are left for further\
    \ study.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1.  Introduction and Scope . . . . . . . . . . . . . .\
    \ . . . . . .  2\n   2.  Terminology and Conventions  . . . . . . . . . . . .\
    \ . . . . .  4\n   3.  Protocol Model . . . . . . . . . . . . . . . . . . . .\
    \ . . . .  5\n     3.1.  Operating Environment  . . . . . . . . . . . . . . .\
    \ . . .  5\n       3.1.1.  Locator  . . . . . . . . . . . . . . . . . . . . .\
    \ . .  7\n       3.1.2.  Mobility Overview  . . . . . . . . . . . . . . . . .\
    \ .  8\n       3.1.3.  Multihoming Overview . . . . . . . . . . . . . . . . .\
    \  8\n     3.2.  Protocol Overview  . . . . . . . . . . . . . . . . . . . .  9\n\
    \       3.2.1.  Mobility with a Single SA Pair (No Rekeying) . . . . .  9\n  \
    \     3.2.2.  Mobility with a Single SA Pair (Mobile-Initiated\n             \
    \  Rekey) . . . . . . . . . . . . . . . . . . . . . . . . 11\n       3.2.3.  Host\
    \ Multihoming . . . . . . . . . . . . . . . . . . . 11\n       3.2.4.  Site Multihoming\
    \ . . . . . . . . . . . . . . . . . . . 13\n       3.2.5.  Dual host multihoming\
    \  . . . . . . . . . . . . . . . . 14\n       3.2.6.  Combined Mobility and Multihoming\
    \  . . . . . . . . . . 14\n       3.2.7.  Using LOCATORs across Addressing Realms\
    \  . . . . . . . 14\n       3.2.8.  Network Renumbering  . . . . . . . . . . .\
    \ . . . . . . 15\n       3.2.9.  Initiating the Protocol in R1 or I2  . . . .\
    \ . . . . . 15\n     3.3.  Other Considerations . . . . . . . . . . . . . . .\
    \ . . . . 16\n       3.3.1.  Address Verification . . . . . . . . . . . . . .\
    \ . . . 16\n       3.3.2.  Credit-Based Authorization . . . . . . . . . . . .\
    \ . . 17\n       3.3.3.  Preferred Locator  . . . . . . . . . . . . . . . . .\
    \ . 18\n       3.3.4.  Interaction with Security Associations . . . . . . . .\
    \ 18\n   4.  LOCATOR Parameter Format . . . . . . . . . . . . . . . . . . . 21\n\
    \     4.1.  Traffic Type and Preferred Locator . . . . . . . . . . . . 23\n  \
    \   4.2.  Locator Type and Locator . . . . . . . . . . . . . . . . . 23\n    \
    \ 4.3.  UPDATE Packet with Included LOCATOR  . . . . . . . . . . . 24\n   5. \
    \ Processing Rules . . . . . . . . . . . . . . . . . . . . . . . 24\n     5.1.\
    \  Locator Data Structure and Status  . . . . . . . . . . . . 24\n     5.2.  Sending\
    \ LOCATORs . . . . . . . . . . . . . . . . . . . . . 25\n     5.3.  Handling Received\
    \ LOCATORs . . . . . . . . . . . . . . . . 28\n     5.4.  Verifying Address Reachability\
    \ . . . . . . . . . . . . . . 30\n     5.5.  Changing the Preferred Locator .\
    \ . . . . . . . . . . . . . 31\n     5.6.  Credit-Based Authorization . . . .\
    \ . . . . . . . . . . . . 32\n       5.6.1.  Handling Payload Packets . . . .\
    \ . . . . . . . . . . . 32\n       5.6.2.  Credit Aging . . . . . . . . . . .\
    \ . . . . . . . . . . 33\n   6.  Security Considerations  . . . . . . . . . .\
    \ . . . . . . . . . 34\n     6.1.  Impersonation Attacks  . . . . . . . . . .\
    \ . . . . . . . . 35\n     6.2.  Denial-of-Service Attacks  . . . . . . . . .\
    \ . . . . . . . 36\n       6.2.1.  Flooding Attacks . . . . . . . . . . . . .\
    \ . . . . . . 36\n       6.2.2.  Memory/Computational-Exhaustion DoS Attacks \
    \ . . . . . 36\n     6.3.  Mixed Deployment Environment . . . . . . . . . . .\
    \ . . . . 37\n   7.  IANA Considerations  . . . . . . . . . . . . . . . . . .\
    \ . . . 37\n   8.  Authors and Acknowledgments  . . . . . . . . . . . . . . .\
    \ . . 38\n   9.  References . . . . . . . . . . . . . . . . . . . . . . . . .\
    \ . 38\n     9.1.  Normative references . . . . . . . . . . . . . . . . . . .\
    \ 38\n     9.2.  Informative references . . . . . . . . . . . . . . . . . . 38\n"
- title: 1.  Introduction and Scope
  contents:
  - "1.  Introduction and Scope\n   The Host Identity Protocol [RFC4423] (HIP) supports\
    \ an architecture\n   that decouples the transport layer (TCP, UDP, etc.) from\
    \ the\n   internetworking layer (IPv4 and IPv6) by using public/private key\n\
    \   pairs, instead of IP addresses, as host identities.  When a host uses\n  \
    \ HIP, the overlying protocol sublayers (e.g., transport layer sockets\n   and\
    \ Encapsulating Security Payload (ESP) Security Associations (SAs))\n   are instead\
    \ bound to representations of these host identities, and\n   the IP addresses\
    \ are only used for packet forwarding.  However, each\n   host must also know\
    \ at least one IP address at which its peers are\n   reachable.  Initially, these\
    \ IP addresses are the ones used during\n   the HIP base exchange [RFC5201].\n\
    \   One consequence of such a decoupling is that new solutions to\n   network-layer\
    \ mobility and host multihoming are possible.  There are\n   potentially many\
    \ variations of mobility and multihoming possible.\n   The scope of this document\
    \ encompasses messaging and elements of\n   procedure for basic network-level\
    \ mobility and simple multihoming,\n   leaving more complicated scenarios and\
    \ other variations for further\n   study.  More specifically:\n      This document\
    \ defines a generalized LOCATOR parameter for use in\n      HIP messages.  The\
    \ LOCATOR parameter allows a HIP host to notify a\n      peer about alternate\
    \ addresses at which it is reachable.  The\n      LOCATORs may be merely IP addresses,\
    \ or they may have additional\n      multiplexing and demultiplexing context to\
    \ aid the packet handling\n      in the lower layers.  For instance, an IP address\
    \ may need to be\n      paired with an ESP Security Parameter Index (SPI) so that\
    \ packets\n      are sent on the correct SA for a given address.\n      This document\
    \ also specifies the messaging and elements of\n      procedure for end-host mobility\
    \ of a HIP host -- the sequential\n      change in the preferred IP address used\
    \ to reach a host.  In\n      particular, message flows to enable successful host\
    \ mobility,\n      including address verification methods, are defined herein.\n\
    \      However, while the same LOCATOR parameter is intended to support\n    \
    \  host multihoming (parallel support of a number of addresses), and\n      experimentation\
    \ is encouraged, detailed elements of procedure for\n      host multihoming are\
    \ left for further study.\n   While HIP can potentially be used with transports\
    \ other than the ESP\n   transport format [RFC5202], this document largely assumes\
    \ the use of\n   ESP and leaves other transport formats for further study.\n \
    \  There are a number of situations where the simple end-to-end\n   readdressing\
    \ functionality is not sufficient.  These include the\n   initial reachability\
    \ of a mobile host, location privacy, simultaneous\n   mobility of both hosts,\
    \ and some modes of NAT traversal.  In these\n   situations, there is a need for\
    \ some helper functionality in the\n   network, such as a HIP rendezvous server\
    \ [RFC5204].  Such\n   functionality is out of the scope of this document.  We\
    \ also do not\n   consider localized mobility management extensions (i.e., mobility\n\
    \   management techniques that do not involve directly signaling the\n   correspondent\
    \ node); this document is concerned with end-to-end\n   mobility.  Finally, making\
    \ underlying IP mobility transparent to the\n   transport layer has implications\
    \ on the proper response of transport\n   congestion control, path MTU selection,\
    \ and Quality of Service (QoS).\n   Transport-layer mobility triggers, and the\
    \ proper transport response\n   to a HIP mobility or multihoming address change,\
    \ are outside the\n   scope of this document.\n"
- title: 2.  Terminology and Conventions
  contents:
  - "2.  Terminology and Conventions\n   The key words \"MUST\", \"MUST NOT\", \"\
    REQUIRED\", \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\"\
    , \"MAY\", and \"OPTIONAL\" in this\n   document are to be interpreted as described\
    \ in RFC 2119 [RFC2119].\n   LOCATOR.  The name of a HIP parameter containing\
    \ zero or more Locator\n      fields.  This parameter's name is distinguished\
    \ from the Locator\n      fields embedded within it by the use of all capital\
    \ letters.\n   Locator.  A name that controls how the packet is routed through\
    \ the\n      network and demultiplexed by the end host.  It may include a\n  \
    \    concatenation of traditional network addresses such as an IPv6\n      address\
    \ and end-to-end identifiers such as an ESP SPI.  It may\n      also include transport\
    \ port numbers or IPv6 Flow Labels as\n      demultiplexing context, or it may\
    \ simply be a network address.\n   Address.  A name that denotes a point-of-attachment\
    \ to the network.\n      The two most common examples are an IPv4 address and\
    \ an IPv6\n      address.  The set of possible addresses is a subset of the set\
    \ of\n      possible locators.\n   Preferred locator.  A locator on which a host\
    \ prefers to receive\n      data.  With respect to a given peer, a host always\
    \ has one active\n      Preferred locator, unless there are no active locators.\
    \  By\n      default, the locators used in the HIP base exchange are the\n   \
    \   Preferred locators.\n   Credit Based Authorization.  A host must verify a\
    \ mobile or\n      multihomed peer's reachability at a new locator.  Credit-Based\n\
    \      Authorization authorizes the peer to receive a certain amount of\n    \
    \  data at the new locator before the result of such verification is\n      known.\n"
- title: 3.  Protocol Model
  contents:
  - "3.  Protocol Model\n   This section is an overview; more detailed specification\
    \ follows this\n   section.\n"
- title: 3.1.  Operating Environment
  contents:
  - "3.1.  Operating Environment\n   The Host Identity Protocol (HIP) [RFC5201] is\
    \ a key establishment and\n   parameter negotiation protocol.  Its primary applications\
    \ are for\n   authenticating host messages based on host identities, and\n   establishing\
    \ security associations (SAs) for the ESP transport format\n   [RFC5202] and possibly\
    \ other protocols in the future.\n    +--------------------+                 \
    \      +--------------------+\n    |                    |                    \
    \   |                    |\n    |   +------------+   |                       |\
    \   +------------+   |\n    |   |    Key     |   |         HIP           |   |\
    \    Key     |   |\n    |   | Management | <-+-----------------------+-> | Management\
    \ |   |\n    |   |  Process   |   |                       |   |  Process   | \
    \  |\n    |   +------------+   |                       |   +------------+   |\n\
    \    |         ^          |                       |         ^          |\n   \
    \ |         |          |                       |         |          |\n    | \
    \        v          |                       |         v          |\n    |   +------------+\
    \   |                       |   +------------+   |\n    |   |   IPsec    |   |\
    \        ESP            |   |   IPsec    |   |\n    |   |   Stack    | <-+-----------------------+->\
    \ |   Stack    |   |\n    |   |            |   |                       |   | \
    \           |   |\n    |   +------------+   |                       |   +------------+\
    \   |\n    |                    |                       |                    |\n\
    \    |                    |                       |                    |\n   \
    \ |     Initiator      |                       |     Responder      |\n    +--------------------+\
    \                       +--------------------+\n                      Figure 1:\
    \ HIP Deployment Model\n   The general deployment model for HIP is shown above,\
    \ assuming\n   operation in an end-to-end fashion.  This document specifies\n\
    \   extensions to the HIP protocol to enable end-host mobility and basic\n   multihoming.\
    \  In summary, these extensions to the HIP base protocol\n   enable the signaling\
    \ of new addressing information to the peer in HIP\n   messages.  The messages\
    \ are authenticated via a signature or keyed\n   hash message authentication code\
    \ (HMAC) based on its Host Identity.\n   This document specifies the format of\
    \ this new addressing (LOCATOR)\n   parameter, the procedures for sending and\
    \ processing this parameter\n   to enable basic host mobility, and procedures\
    \ for a concurrent\n   address verification mechanism.\n            ---------\n\
    \            | TCP   |  (sockets bound to HITs)\n            ---------\n     \
    \          |\n            ---------\n      ----> | ESP   |  {HIT_s, HIT_d} <->\
    \ SPI\n      |     ---------\n      |         |\n    ----    ---------\n   | MH\
    \ |-> | HIP   |  {HIT_s, HIT_d, SPI} <-> {IP_s, IP_d, SPI}\n    ----    ---------\n\
    \               |\n            ---------\n            |  IP   |\n            ---------\n\
    \       Figure 2: Architecture for HIP Mobility and Multihoming (MH)\n   Figure\
    \ 2 depicts a layered architectural view of a HIP-enabled stack\n   using the\
    \ ESP transport format.  In HIP, upper-layer protocols\n   (including TCP and\
    \ ESP in this figure) are bound to Host Identity\n   Tags (HITs) and not IP addresses.\
    \  The HIP sublayer is responsible\n   for maintaining the binding between HITs\
    \ and IP addresses.  The SPI\n   is used to associate an incoming packet with\
    \ the right HITs.  The\n   block labeled \"MH\" is introduced below.\n   Consider\
    \ first the case in which there is no mobility or multihoming,\n   as specified\
    \ in the base protocol specification [RFC5201].  The HIP\n   base exchange establishes\
    \ the HITs in use between the hosts, the SPIs\n   to use for ESP, and the IP addresses\
    \ (used in both the HIP signaling\n   packets and ESP data packets).  Note that\
    \ there can only be one such\n   set of bindings in the outbound direction for\
    \ any given packet, and\n   the only fields used for the binding at the HIP layer\
    \ are the fields\n   exposed by ESP (the SPI and HITs).  For the inbound direction,\
    \ the\n   SPI is all that is required to find the right host context.  ESP\n \
    \  rekeying events change the mapping between the HIT pair and SPI, but\n   do\
    \ not change the IP addresses.\n   Consider next a mobility event, in which a\
    \ host is still single-homed\n   but moves to another IP address.  Two things\
    \ must occur in this case.\n   First, the peer must be notified of the address\
    \ change using a HIP\n   UPDATE message.  Second, each host must change its local\
    \ bindings at\n   the HIP sublayer (new IP addresses).  It may be that both the\
    \ SPIs\n   and IP addresses are changed simultaneously in a single UPDATE; the\n\
    \   protocol described herein supports this.  However, simultaneous\n   movement\
    \ of both hosts, notification of transport layer protocols of\n   the path change,\
    \ and procedures for possibly traversing middleboxes\n   are not covered by this\
    \ document.\n   Finally, consider the case when a host is multihomed (has more\
    \ than\n   one globally routable address) and has multiple addresses available\n\
    \   at the HIP layer as alternative locators for fault tolerance.\n   Examples\
    \ include the use of (possibly multiple) IPv4 and IPv6\n   addresses on the same\
    \ interface, or the use of multiple interfaces\n   attached to different service\
    \ providers.  Such host multihoming\n   generally necessitates that a separate\
    \ ESP SA is maintained for each\n   interface in order to prevent packets that\
    \ arrive over different\n   paths from falling outside of the ESP anti-replay\
    \ window [RFC4303].\n   Multihoming thus makes it possible that the bindings shown\
    \ on the\n   right side of Figure 2 are one to many (in the outbound direction,\n\
    \   one HIT pair to multiple SPIs, and possibly then to multiple IP\n   addresses).\
    \  However, only one SPI and address pair can be used for\n   any given packet,\
    \ so the job of the \"MH\" block depicted above is to\n   dynamically manipulate\
    \ these bindings.  Beyond locally managing such\n   multiple bindings, the peer-to-peer\
    \ HIP signaling protocol needs to\n   be flexible enough to define the desired\
    \ mappings between HITs, SPIs,\n   and addresses, and needs to ensure that UPDATE\
    \ messages are sent\n   along the right network paths so that any HIP-aware middleboxes\
    \ can\n   observe the SPIs.  This document does not specify the \"MH\" block,\
    \ nor\n   does it specify detailed elements of procedure for how to handle\n \
    \  various multihoming (perhaps combined with mobility) scenarios.  The\n   \"\
    MH\" block may apply to more general problems outside of HIP.\n   However, this\
    \ document does describe a basic multihoming case (one\n   host adds one address\
    \ to its initial address and notifies the peer)\n   and leave more complicated\
    \ scenarios for experimentation and future\n   documents.\n"
- title: 3.1.1.  Locator
  contents:
  - "3.1.1.  Locator\n   This document defines a generalization of an address called\
    \ a\n   \"locator\".  A locator specifies a point-of-attachment to the network\n\
    \   but may also include additional end-to-end tunneling or per-host\n   demultiplexing\
    \ context that affects how packets are handled below the\n   logical HIP sublayer\
    \ of the stack.  This generalization is useful\n   because IP addresses alone\
    \ may not be sufficient to describe how\n   packets should be handled below HIP.\
    \  For example, in a host\n   multihoming context, certain IP addresses may need\
    \ to be associated\n   with certain ESP SPIs to avoid violating the ESP anti-replay\
    \ window.\n   Addresses may also be affiliated with transport ports in certain\n\
    \   tunneling scenarios.  Locators may simply be traditional network\n   addresses.\
    \  The format of the locator fields in the LOCATOR parameter\n   is defined in\
    \ Section 4.\n"
- title: 3.1.2.  Mobility Overview
  contents:
  - "3.1.2.  Mobility Overview\n   When a host moves to another address, it notifies\
    \ its peer of the new\n   address by sending a HIP UPDATE packet containing a\
    \ LOCATOR\n   parameter.  This UPDATE packet is acknowledged by the peer.  For\n\
    \   reliability in the presence of packet loss, the UPDATE packet is\n   retransmitted\
    \ as defined in the HIP protocol specification [RFC5201].\n   The peer can authenticate\
    \ the contents of the UPDATE packet based on\n   the signature and keyed hash\
    \ of the packet.\n   When using ESP Transport Format [RFC5202], the host may at\
    \ the same\n   time decide to rekey its security association and possibly generate\
    \ a\n   new Diffie-Hellman key; all of these actions are triggered by\n   including\
    \ additional parameters in the UPDATE packet, as defined in\n   the base protocol\
    \ specification [RFC5201] and ESP extension\n   [RFC5202].\n   When using ESP\
    \ (and possibly other transport modes in the future),\n   the host is able to\
    \ receive packets that are protected using a HIP\n   created ESP SA from any address.\
    \  Thus, a host can change its IP\n   address and continue to send packets to\
    \ its peers without necessarily\n   rekeying.  However, the peers are not able\
    \ to send packets to these\n   new addresses before they can reliably and securely\
    \ update the set of\n   addresses that they associate with the sending host. \
    \ Furthermore,\n   mobility may change the path characteristics in such a manner\
    \ that\n   reordering occurs and packets fall outside the ESP anti-replay window\n\
    \   for the SA, thereby requiring rekeying.\n"
- title: 3.1.3.  Multihoming Overview
  contents:
  - "3.1.3.  Multihoming Overview\n   A related operational configuration is host\
    \ multihoming, in which a\n   host has multiple locators simultaneously rather\
    \ than sequentially,\n   as in the case of mobility.  By using the LOCATOR parameter\
    \ defined\n   herein, a host can inform its peers of additional (multiple) locators\n\
    \   at which it can be reached, and can declare a particular locator as a\n  \
    \ \"preferred\" locator.  Although this document defines a basic\n   mechanism\
    \ for multihoming, it does not define detailed policies and\n   procedures, such\
    \ as which locators to choose when more than one pair\n   is available, the operation\
    \ of simultaneous mobility and multihoming,\n   source address selection policies\
    \ (beyond those specified in\n   [RFC3484]), and the implications of multihoming\
    \ on transport\n   protocols and ESP anti-replay windows.  Additional definitions\
    \ of\n   HIP-based multihoming are expected to be part of future documents.\n"
- title: 3.2.  Protocol Overview
  contents:
  - "3.2.  Protocol Overview\n   In this section, we briefly introduce a number of\
    \ usage scenarios for\n   HIP mobility and multihoming.  These scenarios assume\
    \ that HIP is\n   being used with the ESP transform [RFC5202], although other\
    \ scenarios\n   may be defined in the future.  To understand these usage scenarios,\n\
    \   the reader should be at least minimally familiar with the HIP\n   protocol\
    \ specification [RFC5201].  However, for the (relatively)\n   uninitiated reader,\
    \ it is most important to keep in mind that in HIP\n   the actual payload traffic\
    \ is protected with ESP, and that the ESP\n   SPI acts as an index to the right\
    \ host-to-host context.  More\n   specification details are found later in Section\
    \ 4 and Section 5.\n   The scenarios below assume that the two hosts have completed\
    \ a single\n   HIP base exchange with each other.  Both of the hosts therefore\
    \ have\n   one incoming and one outgoing SA.  Further, each SA uses the same\n\
    \   pair of IP addresses, which are the ones used in the base exchange.\n   The\
    \ readdressing protocol is an asymmetric protocol where a mobile or\n   multihomed\
    \ host informs a peer host about changes of IP addresses on\n   affected SPIs.\
    \  The readdressing exchange is designed to be\n   piggybacked on existing HIP\
    \ exchanges.  The majority of the packets\n   on which the LOCATOR parameters\
    \ are expected to be carried are UPDATE\n   packets.  However, some implementations\
    \ may want to experiment with\n   sending LOCATOR parameters also on other packets,\
    \ such as R1, I2, and\n   NOTIFY.\n   The scenarios below at times describe addresses\
    \ as being in either an\n   ACTIVE, VERIFIED, or DEPRECATED state.  From the perspective\
    \ of a\n   host, newly-learned addresses of the peer must be verified before put\n\
    \   into active service, and addresses removed by the peer are put into a\n  \
    \ deprecated state.  Under limited conditions described below\n   (Section 5.6),\
    \ an UNVERIFIED address may be used.  The addressing\n   states are defined more\
    \ formally in Section 5.1.\n   Hosts that use link-local addresses as source addresses\
    \ in their HIP\n   handshakes may not be reachable by a mobile peer.  Such hosts\
    \ SHOULD\n   provide a globally routable address either in the initial handshake\n\
    \   or via the LOCATOR parameter.\n"
- title: 3.2.1.  Mobility with a Single SA Pair (No Rekeying)
  contents:
  - "3.2.1.  Mobility with a Single SA Pair (No Rekeying)\n   A mobile host must sometimes\
    \ change an IP address bound to an\n   interface.  The change of an IP address\
    \ might be needed due to a\n   change in the advertised IPv6 prefixes on the link,\
    \ a reconnected PPP\n   link, a new DHCP lease, or an actual movement to another\
    \ subnet.  In\n   order to maintain its communication context, the host must inform\
    \ its\n   peers about the new IP address.  This first example considers the\n\
    \   case in which the mobile host has only one interface, IP address, a\n   single\
    \ pair of SAs (one inbound, one outbound), and no rekeying\n   occurs on the SAs.\
    \  We also assume that the new IP addresses are\n   within the same address family\
    \ (IPv4 or IPv6) as the first address.\n   This is the simplest scenario, depicted\
    \ in Figure 3.\n     Mobile Host                         Peer Host\n         \
    \    UPDATE(ESP_INFO, LOCATOR, SEQ)\n        ----------------------------------->\n\
    \             UPDATE(ESP_INFO, SEQ, ACK, ECHO_REQUEST)\n        <-----------------------------------\n\
    \             UPDATE(ACK, ECHO_RESPONSE)\n        ----------------------------------->\n\
    \       Figure 3: Readdress without Rekeying, but with Address Check\n   The steps\
    \ of the packet processing are as follows:\n   1.  The mobile host is disconnected\
    \ from the peer host for a brief\n       period of time while it switches from\
    \ one IP address to another.\n       Upon obtaining a new IP address, the mobile\
    \ host sends a LOCATOR\n       parameter to the peer host in an UPDATE message.\
    \  The UPDATE\n       message also contains an ESP_INFO parameter containing the\
    \ values\n       of the old and new SPIs for a security association.  In this\n\
    \       case, the OLD SPI and NEW SPI parameters both are set to the\n       value\
    \ of the preexisting incoming SPI; this ESP_INFO does not\n       trigger a rekeying\
    \ event but is instead included for possible\n       parameter-inspecting middleboxes\
    \ on the path.  The LOCATOR\n       parameter contains the new IP address (Locator\
    \ Type of \"1\",\n       defined below) and a locator lifetime.  The mobile host\
    \ waits for\n       this UPDATE to be acknowledged, and retransmits if necessary,\
    \ as\n       specified in the base specification [RFC5201].\n   2.  The peer host\
    \ receives the UPDATE, validates it, and updates any\n       local bindings between\
    \ the HIP association and the mobile host's\n       destination address.  The\
    \ peer host MUST perform an address\n       verification by placing a nonce in\
    \ the ECHO_REQUEST parameter of\n       the UPDATE message sent back to the mobile\
    \ host.  It also\n       includes an ESP_INFO parameter with the OLD SPI and NEW\
    \ SPI\n       parameters both set to the value of the preexisting incoming SPI,\n\
    \       and sends this UPDATE (with piggybacked acknowledgment) to the\n     \
    \  mobile host at its new address.  The peer MAY use the new address\n       immediately,\
    \ but it MUST limit the amount of data it sends to the\n       address until address\
    \ verification completes.\n   3.  The mobile host completes the readdress by processing\
    \ the UPDATE\n       ACK and echoing the nonce in an ECHO_RESPONSE.  Once the\
    \ peer\n       host receives this ECHO_RESPONSE, it considers the new address\
    \ to\n       be verified and can put the address into full use.\n   While the\
    \ peer host is verifying the new address, the new address is\n   marked as UNVERIFIED\
    \ in the interim, and the old address is\n   DEPRECATED.  Once the peer host has\
    \ received a correct reply to its\n   UPDATE challenge, it marks the new address\
    \ as ACTIVE and removes the\n   old address.\n"
- title: 3.2.2.  Mobility with a Single SA Pair (Mobile-Initiated Rekey)
  contents:
  - "3.2.2.  Mobility with a Single SA Pair (Mobile-Initiated Rekey)\n   The mobile\
    \ host may decide to rekey the SAs at the same time that it\n   notifies the peer\
    \ of the new address.  In this case, the above\n   procedure described in Figure\
    \ 3 is slightly modified.  The UPDATE\n   message sent from the mobile host includes\
    \ an ESP_INFO with the OLD\n   SPI set to the previous SPI, the NEW SPI set to\
    \ the desired new SPI\n   value for the incoming SA, and the KEYMAT Index desired.\
    \  Optionally,\n   the host may include a DIFFIE_HELLMAN parameter for a new Diffie-\n\
    \   Hellman key.  The peer completes the request for a rekey as is\n   normally\
    \ done for HIP rekeying, except that the new address is kept\n   as UNVERIFIED\
    \ until the UPDATE nonce challenge is received as\n   described above.  Figure\
    \ 4 illustrates this scenario.\n     Mobile Host                         Peer\
    \ Host\n             UPDATE(ESP_INFO, LOCATOR, SEQ, [DIFFIE_HELLMAN])\n      \
    \  ----------------------------------->\n             UPDATE(ESP_INFO, SEQ, ACK,\
    \ [DIFFIE_HELLMAN,] ECHO_REQUEST)\n        <-----------------------------------\n\
    \             UPDATE(ACK, ECHO_RESPONSE)\n        ----------------------------------->\n\
    \              Figure 4: Readdress with Mobile-Initiated Rekey\n"
- title: 3.2.3.  Host Multihoming
  contents:
  - "3.2.3.  Host Multihoming\n   A (mobile or stationary) host may sometimes have\
    \ more than one\n   interface or global address.  The host may notify the peer\
    \ host of\n   the additional interface or address by using the LOCATOR parameter.\n\
    \   To avoid problems with the ESP anti-replay window, a host SHOULD use\n   a\
    \ different SA for each interface or address used to receive packets\n   from\
    \ the peer host when multiple locator pairs are being used\n   simultaneously\
    \ rather than sequentially.\n   When more than one locator is provided to the\
    \ peer host, the host\n   SHOULD indicate which locator is preferred (the locator\
    \ on which the\n   host prefers to receive traffic).  By default, the addresses\
    \ used in\n   the base exchange are preferred until indicated otherwise.\n   In\
    \ the multihoming case, the sender may also have multiple valid\n   locators from\
    \ which to source traffic.  In practice, a HIP\n   association in a multihoming\
    \ configuration may have both a preferred\n   peer locator and a preferred local\
    \ locator, although rules for source\n   address selection should ultimately govern\
    \ the selection of the\n   source locator based on the destination locator.\n\
    \   Although the protocol may allow for configurations in which there is\n   an\
    \ asymmetric number of SAs between the hosts (e.g., one host has two\n   interfaces\
    \ and two inbound SAs, while the peer has one interface and\n   one inbound SA),\
    \ it is RECOMMENDED that inbound and outbound SAs be\n   created pairwise between\
    \ hosts.  When an ESP_INFO arrives to rekey a\n   particular outbound SA, the\
    \ corresponding inbound SA should be also\n   rekeyed at that time.  Although\
    \ asymmetric SA configurations might be\n   experimented with, their usage may\
    \ constrain interoperability at this\n   time.  However, it is recommended that\
    \ implementations attempt to\n   support peers that prefer to use non-paired SAs.\
    \  It is expected that\n   this section and behavior will be modified in future\
    \ revisions of\n   this protocol, once the issue and its implications are better\n\
    \   understood.\n   Consider the case between two hosts, one single-homed and\
    \ one\n   multihomed.  The multihomed host may decide to inform the single-\n\
    \   homed host about its other address.  It is RECOMMENDED that the\n   multihomed\
    \ host set up a new SA pair for use on this new address.  To\n   do this, the\
    \ multihomed host sends a LOCATOR with an ESP_INFO,\n   indicating the request\
    \ for a new SA by setting the OLD SPI value to\n   zero, and the NEW SPI value\
    \ to the newly created incoming SPI.  A\n   Locator Type of \"1\" is used to associate\
    \ the new address with the new\n   SPI.  The LOCATOR parameter also contains a\
    \ second Type \"1\" locator,\n   that of the original address and SPI.  To simplify\
    \ parameter\n   processing and avoid explicit protocol extensions to remove locators,\n\
    \   each LOCATOR parameter MUST list all locators in use on a connection\n   (a\
    \ complete listing of inbound locators and SPIs for the host).  The\n   multihomed\
    \ host waits for an ESP_INFO (new outbound SA) from the peer\n   and an ACK of\
    \ its own UPDATE.  As in the mobility case, the peer host\n   must perform an\
    \ address verification before actively using the new\n   address.  Figure 5 illustrates\
    \ this scenario.\n     Multi-homed Host                    Peer Host\n       \
    \       UPDATE(ESP_INFO, LOCATOR, SEQ, [DIFFIE_HELLMAN])\n        ----------------------------------->\n\
    \              UPDATE(ESP_INFO, SEQ, ACK, [DIFFIE_HELLMAN,] ECHO_REQUEST)\n  \
    \      <-----------------------------------\n              UPDATE(ACK, ECHO_RESPONSE)\n\
    \        ----------------------------------->\n                   Figure 5: Basic\
    \ Multihoming Scenario\n   In multihoming scenarios, it is important that hosts\
    \ receiving\n   UPDATEs associate them correctly with the destination address\
    \ used in\n   the packet carrying the UPDATE.  When processing inbound LOCATORs\n\
    \   that establish new security associations on an interface with\n   multiple\
    \ addresses, a host uses the destination address of the UPDATE\n   containing\
    \ the LOCATOR as the local address to which the LOCATOR plus\n   ESP_INFO is targeted.\
    \  This is because hosts may send UPDATEs with\n   the same (locator) IP address\
    \ to different peer addresses -- this has\n   the effect of creating multiple\
    \ inbound SAs implicitly affiliated\n   with different peer source addresses.\n"
- title: 3.2.4.  Site Multihoming
  contents:
  - "3.2.4.  Site Multihoming\n   A host may have an interface that has multiple globally\
    \ routable IP\n   addresses.  Such a situation may be a result of the site having\n\
    \   multiple upper Internet Service Providers, or just because the site\n   provides\
    \ all hosts with both IPv4 and IPv6 addresses.  The host\n   should stay reachable\
    \ at all or any subset of the currently available\n   global routable addresses,\
    \ independent of how they are provided.\n   This case is handled the same as if\
    \ there were different IP\n   addresses, described above in Section 3.2.3.  Note\
    \ that a single\n   interface may experience site multihoming while the host itself\
    \ may\n   have multiple interfaces.\n   Note that a host may be multihomed and\
    \ mobile simultaneously, and\n   that a multihomed host may want to protect the\
    \ location of some of\n   its interfaces while revealing the real IP address of\
    \ some others.\n   This document does not presently specify additional site multihoming\n\
    \   extensions to HIP; further alignment with the IETF shim6 working\n   group\
    \ may be considered in the future.\n"
- title: 3.2.5.  Dual host multihoming
  contents:
  - "3.2.5.  Dual host multihoming\n   Consider the case in which both hosts would\
    \ like to add an additional\n   address after the base exchange completes.  In\
    \ Figure 6, consider\n   that host1, which used address addr1a in the base exchange\
    \ to set up\n   SPI1a and SPI2a, wants to add address addr1b.  It would send an\n\
    \   UPDATE with LOCATOR (containing the address addr1b) to host2, using\n   destination\
    \ address addr2a, and a new set of SPIs would be added\n   between hosts 1 and\
    \ 2 (call them SPI1b and SPI2b -- not shown in the\n   figure).  Next, consider\
    \ host2 deciding to add addr2b to the\n   relationship.  Host2 must select one\
    \ of host1's addresses towards\n   which to initiate an UPDATE.  It may choose\
    \ to initiate an UPDATE to\n   addr1a, addr1b, or both.  If it chooses to send\
    \ to both, then a full\n   mesh (four SA pairs) of SAs would exist between the\
    \ two hosts.  This\n   is the most general case; it often may be the case that\
    \ hosts\n   primarily establish new SAs only with the peer's Preferred locator.\n\
    \   The readdressing protocol is flexible enough to accommodate this\n   choice.\n\
    \              -<- SPI1a --                         -- SPI2a ->-\n      host1\
    \ <              > addr1a <---> addr2a <              > host2\n              ->-\
    \ SPI2a --                         -- SPI1a -<-\n                            \
    \ addr1b <---> addr2a  (second SA pair)\n                             addr1a <--->\
    \ addr2b  (third SA pair)\n                             addr1b <---> addr2b  (fourth\
    \ SA pair)\n    Figure 6: Dual Multihoming Case in Which Each Host Uses LOCATOR\
    \ to\n                           Add a Second Address\n"
- title: 3.2.6.  Combined Mobility and Multihoming
  contents:
  - "3.2.6.  Combined Mobility and Multihoming\n   It looks likely that in the future,\
    \ many mobile hosts will be\n   simultaneously mobile and multihomed, i.e., have\
    \ multiple mobile\n   interfaces.  Furthermore, if the interfaces use different\
    \ access\n   technologies, it is fairly likely that one of the interfaces may\n\
    \   appear stable (retain its current IP address) while some other(s) may\n  \
    \ experience mobility (undergo IP address change).\n   The use of LOCATOR plus\
    \ ESP_INFO should be flexible enough to handle\n   most such scenarios, although\
    \ more complicated scenarios have not\n   been studied so far.\n"
- title: 3.2.7.  Using LOCATORs across Addressing Realms
  contents:
  - "3.2.7.  Using LOCATORs across Addressing Realms\n   It is possible for HIP associations\
    \ to migrate to a state in which\n   both parties are only using locators in different\
    \ addressing realms.\n   For example, the two hosts may initiate the HIP association\
    \ when both\n   are using IPv6 locators, then one host may loose its IPv6\n  \
    \ connectivity and obtain an IPv4 address.  In such a case, some type\n   of mechanism\
    \ for interworking between the different realms must be\n   employed; such techniques\
    \ are outside the scope of the present text.\n   The basic problem in this example\
    \ is that the host readdressing to\n   IPv4 does not know a corresponding IPv4\
    \ address of the peer.  This\n   may be handled (experimentally) by possibly configuring\
    \ this address\n   information manually or in the DNS, or the hosts exchange both\
    \ IPv4\n   and IPv6 addresses in the locator.\n"
- title: 3.2.8.  Network Renumbering
  contents:
  - "3.2.8.  Network Renumbering\n   It is expected that IPv6 networks will be renumbered\
    \ much more often\n   than most IPv4 networks.  From an end-host point of view,\
    \ network\n   renumbering is similar to mobility.\n"
- title: 3.2.9.  Initiating the Protocol in R1 or I2
  contents:
  - "3.2.9.  Initiating the Protocol in R1 or I2\n   A Responder host MAY include\
    \ a LOCATOR parameter in the R1 packet\n   that it sends to the Initiator.  This\
    \ parameter MUST be protected by\n   the R1 signature.  If the R1 packet contains\
    \ LOCATOR parameters with\n   a new Preferred locator, the Initiator SHOULD directly\
    \ set the new\n   Preferred locator to status ACTIVE without performing address\n\
    \   verification first, and MUST send the I2 packet to the new Preferred\n   locator.\
    \  The I1 destination address and the new Preferred locator\n   may be identical.\
    \  All new non-preferred locators must still undergo\n   address verification\
    \ once the base exchange completes.\n            Initiator                   \
    \             Responder\n                              R1 with LOCATOR\n     \
    \             <-----------------------------------\n   record additional addresses\n\
    \   change responder address\n                     I2 sent to newly indicated\
    \ preferred address\n                  ----------------------------------->\n\
    \                                                     (process normally)\n   \
    \                               R2\n                  <-----------------------------------\n\
    \   (process normally, later verification of non-preferred locators)\n       \
    \              Figure 7: LOCATOR Inclusion in R1\n   An Initiator MAY include\
    \ one or more LOCATOR parameters in the I2\n   packet, independent of whether\
    \ or not there was a LOCATOR parameter\n   in the R1.  These parameters MUST be\
    \ protected by the I2 signature.\n   Even if the I2 packet contains LOCATOR parameters,\
    \ the Responder MUST\n   still send the R2 packet to the source address of the\
    \ I2.  The new\n   Preferred locator SHOULD be identical to the I2 source address.\
    \  If\n   the I2 packet contains LOCATOR parameters, all new locators must\n \
    \  undergo address verification as usual, and the ESP traffic that\n   subsequently\
    \ follows should use the Preferred locator.\n            Initiator           \
    \                     Responder\n                             I2 with LOCATOR\n\
    \                  ----------------------------------->\n                    \
    \                                 (process normally)\n                       \
    \                      record additional addresses\n                       R2\
    \ sent to source address of I2\n                  <-----------------------------------\n\
    \   (process normally)\n                     Figure 8: LOCATOR Inclusion in I2\n\
    \   The I1 and I2 may be arriving from different source addresses if the\n   LOCATOR\
    \ parameter is present in R1.  In this case, implementations\n   simultaneously\
    \ using multiple pre-created R1s, indexed by Initiator\n   IP addresses, may inadvertently\
    \ fail the puzzle solution of I2\n   packets due to a perceived puzzle mismatch.\
    \  See, for instance, the\n   example in Appendix A of [RFC5201].  As a solution,\
    \ the Responder's\n   puzzle indexing mechanism must be flexible enough to accommodate\
    \ the\n   situation when R1 includes a LOCATOR parameter.\n"
- title: 3.3.  Other Considerations
  contents:
  - '3.3.  Other Considerations

    '
- title: 3.3.1.  Address Verification
  contents:
  - "3.3.1.  Address Verification\n   When a HIP host receives a set of locators from\
    \ another HIP host in a\n   LOCATOR, it does not necessarily know whether the\
    \ other host is\n   actually reachable at the claimed addresses.  In fact, a malicious\n\
    \   peer host may be intentionally giving bogus addresses in order to\n   cause\
    \ a packet flood towards the target addresses [RFC4225].\n   Likewise, viral software\
    \ may have compromised the peer host,\n   programming it to redirect packets to\
    \ the target addresses.  Thus,\n   the HIP host must first check that the peer\
    \ is reachable at the new\n   address.\n   An additional potential benefit of\
    \ performing address verification is\n   to allow middleboxes in the network along\
    \ the new path to obtain the\n   peer host's inbound SPI.\n   Address verification\
    \ is implemented by the challenger sending some\n   piece of unguessable information\
    \ to the new address, and waiting for\n   some acknowledgment from the Responder\
    \ that indicates reception of\n   the information at the new address.  This may\
    \ include the exchange of\n   a nonce, or the generation of a new SPI and observation\
    \ of data\n   arriving on the new SPI.\n"
- title: 3.3.2.  Credit-Based Authorization
  contents:
  - "3.3.2.  Credit-Based Authorization\n   Credit-Based Authorization (CBA) allows\
    \ a host to securely use a new\n   locator even though the peer's reachability\
    \ at the address embedded\n   in the locator has not yet been verified.  This\
    \ is accomplished based\n   on the following three hypotheses:\n   1.  A flooding\
    \ attacker typically seeks to somehow multiply the\n       packets it generates\
    \ for the purpose of its attack because\n       bandwidth is an ample resource\
    \ for many victims.\n   2.  An attacker can often cause unamplified flooding by\
    \ sending\n       packets to its victim, either by directly addressing the victim\n\
    \       in the packets, or by guiding the packets along a specific path\n    \
    \   by means of an IPv6 Routing header, if Routing headers are not\n       filtered\
    \ by firewalls.\n   3.  Consequently, the additional effort required to set up\
    \ a\n       redirection-based flooding attack (without CBA and return\n      \
    \ routability checks) would pay off for the attacker only if\n       amplification\
    \ could be obtained this way.\n   On this basis, rather than eliminating malicious\
    \ packet redirection\n   in the first place, Credit-Based Authorization prevents\n\
    \   amplifications.  This is accomplished by limiting the data a host can\n  \
    \ send to an unverified address of a peer by the data recently received\n   from\
    \ that peer.  Redirection-based flooding attacks thus become less\n   attractive\
    \ than, for example, pure direct flooding, where the\n   attacker itself sends\
    \ bogus packets to the victim.\n   Figure 9 illustrates Credit-Based Authorization:\
    \ Host B measures the\n   amount of data recently received from peer A and, when\
    \ A readdresses,\n   sends packets to A's new, unverified address as long as the\
    \ sum of\n   the packet sizes does not exceed the measured, received data volume.\n\
    \   When insufficient credit is left, B stops sending further packets to\n   A\
    \ until A's address becomes ACTIVE.  The address changes may be due\n   to mobility,\
    \ multihoming, or any other reason.  Not shown in Figure 9\n   are the results\
    \ of credit aging (Section 5.6.2), a mechanism used to\n   dampen possible time-shifting\
    \ attacks.\n           +-------+                        +-------+\n          \
    \ |   A   |                        |   B   |\n           +-------+           \
    \             +-------+\n               |                                |\n \
    \      address |------------------------------->| credit += size(packet)\n   \
    \     ACTIVE |                                |\n               |------------------------------->|\
    \ credit += size(packet)\n               |<-------------------------------| do\
    \ not change credit\n               |                                |\n     \
    \          + address change                 |\n               + address verification\
    \ starts    |\n       address |<-------------------------------| credit -= size(packet)\n\
    \    UNVERIFIED |------------------------------->| credit += size(packet)\n  \
    \             |<-------------------------------| credit -= size(packet)\n    \
    \           |                                |\n               |<-------------------------------|\
    \ credit -= size(packet)\n               |                                X credit\
    \ < size(packet)\n               |                                | => do not\
    \ send packet!\n               + address verification concludes |\n       address\
    \ |                                |\n        ACTIVE |<-------------------------------|\
    \ do not change credit\n               |                                |\n  \
    \                    Figure 9: Readdressing Scenario\n"
- title: 3.3.3.  Preferred Locator
  contents:
  - "3.3.3.  Preferred Locator\n   When a host has multiple locators, the peer host\
    \ must decide which to\n   use for outbound packets.  It may be that a host would\
    \ prefer to\n   receive data on a particular inbound interface.  HIP allows a\n\
    \   particular locator to be designated as a Preferred locator and\n   communicated\
    \ to the peer (see Section 4).\n   In general, when multiple locators are used\
    \ for a session, there is\n   the question of using multiple locators for failover\
    \ only or for\n   load-balancing.  Due to the implications of load-balancing on\
    \ the\n   transport layer that still need to be worked out, this document\n  \
    \ assumes that multiple locators are used primarily for failover.  An\n   implementation\
    \ may use ICMP interactions, reachability checks, or\n   other means to detect\
    \ the failure of a locator.\n"
- title: 3.3.4.  Interaction with Security Associations
  contents:
  - "3.3.4.  Interaction with Security Associations\n   This document specifies a\
    \ new HIP protocol parameter, the LOCATOR\n   parameter (see Section 4), that\
    \ allows the hosts to exchange\n   information about their locator(s) and any\
    \ changes in their\n   locator(s).  The logical structure created with LOCATOR\
    \ parameters\n   has three levels: hosts, Security Associations (SAs) indexed\
    \ by\n   Security Parameter Indices (SPIs), and addresses.\n   The relation between\
    \ these levels for an association constructed as\n   defined in the base specification\
    \ [RFC5201] and ESP transform\n   [RFC5202] is illustrated in Figure 10.\n   \
    \           -<- SPI1a --                         -- SPI2a ->-\n      host1 < \
    \             > addr1a <---> addr2a <              > host2\n              ->-\
    \ SPI2a --                         -- SPI1a -<-\n                 Figure 10: Relation\
    \ between Hosts, SPIs,\n                    and Addresses (Base Specification)\n\
    \   In Figure 10, host1 and host2 negotiate two unidirectional SAs, and\n   each\
    \ host selects the SPI value for its inbound SA.  The addresses\n   addr1a and\
    \ addr2a are the source addresses that the hosts use in the\n   base HIP exchange.\
    \  These are the \"preferred\" (and only) addresses\n   conveyed to the peer for\
    \ use on each SA.  That is, although packets\n   sent to any of the hosts' interfaces\
    \ may be accepted on the inbound\n   SA, the peer host in general knows of only\
    \ the single destination\n   address learned in the base exchange (e.g., for host1,\
    \ it sends a\n   packet on SPI2a to addr2a to reach host2), unless other mechanisms\n\
    \   exist to learn of new addresses.\n   In general, the bindings that exist in\
    \ an implementation\n   corresponding to this document can be depicted as shown\
    \ in Figure 11.\n   In this figure, a host can have multiple inbound SPIs (and,\
    \ not\n   shown, multiple outbound SPIs) associated with another host.\n   Furthermore,\
    \ each SPI may have multiple addresses associated with it.\n   These addresses\
    \ that are bound to an SPI are not used to lookup the\n   incoming SA.  Rather,\
    \ the addresses are those that are provided to\n   the peer host, as hints for\
    \ which addresses to use to reach the host\n   on that SPI.  The LOCATOR parameter\
    \ is used to change the set of\n   addresses that a peer associates with a particular\
    \ SPI.\n                            address11\n                          /\n \
    \                  SPI1   - address12\n                 /\n                / \
    \          address21\n           host -- SPI2   <\n                \\        \
    \   address22\n                 \\\n                   SPI3   - address31\n  \
    \                        \\\n                            address32\n   Figure\
    \ 11: Relation between Hosts, SPIs, and Addresses (General Case)\n   A host may\
    \ establish any number of security associations (or SPIs)\n   with a peer.  The\
    \ main purpose of having multiple SPIs with a peer is\n   to group the addresses\
    \ into collections that are likely to experience\n   fate sharing.  For example,\
    \ if the host needs to change its addresses\n   on SPI2, it is likely that both\
    \ address21 and address22 will\n   simultaneously become obsolete.  In a typical\
    \ case, such SPIs may\n   correspond with physical interfaces; see below.  Note,\
    \ however, that\n   especially in the case of site multihoming, one of the addresses\
    \ may\n   become unreachable while the other one still works.  In the typical\n\
    \   case, however, this does not require the host to inform its peers\n   about\
    \ the situation, since even the non-working address still\n   logically exists.\n\
    \   A basic property of HIP SAs is that the inbound IP address is not\n   used\
    \ to lookup the incoming SA.  Therefore, in Figure 11, it may seem\n   unnecessary\
    \ for address31, for example, to be associated only with\n   SPI3 -- in practice,\
    \ a packet may arrive to SPI1 via destination\n   address address31 as well. \
    \ However, the use of different source and\n   destination addresses typically\
    \ leads to different paths, with\n   different latencies in the network, and if\
    \ packets were to arrive via\n   an arbitrary destination IP address (or path)\
    \ for a given SPI, the\n   reordering due to different latencies may cause some\
    \ packets to fall\n   outside of the ESP anti-replay window.  For this reason,\
    \ HIP provides\n   a mechanism to affiliate destination addresses with inbound\
    \ SPIs,\n   when there is a concern that anti-replay windows might be violated.\n\
    \   In this sense, we can say that a given inbound SPI has an \"affinity\"\n \
    \  for certain inbound IP addresses, and this affinity is communicated\n   to\
    \ the peer host.  Each physical interface SHOULD have a separate SA,\n   unless\
    \ the ESP anti-replay window is loose.\n   Moreover, even when the destination\
    \ addresses used for a particular\n   SPI are held constant, the use of different\
    \ source interfaces may\n   also cause packets to fall outside of the ESP anti-replay\
    \ window,\n   since the path traversed is often affected by the source address\
    \ or\n   interface used.  A host has no way to influence the source interface\n\
    \   on which a peer sends its packets on a given SPI.  A host SHOULD\n   consistently\
    \ use the same source interface and address when sending\n   to a particular destination\
    \ IP address and SPI.  For this reason, a\n   host may find it useful to change\
    \ its SPI or at least reset its ESP\n   anti-replay window when the peer host\
    \ readdresses.\n   An address may appear on more than one SPI.  This creates no\n\
    \   ambiguity since the receiver will ignore the IP addresses during SA\n   lookup\
    \ anyway.  However, this document does not specify such cases.\n   When the LOCATOR\
    \ parameter is sent in an UPDATE packet, then the\n   receiver will respond with\
    \ an UPDATE acknowledgment.  When the\n   LOCATOR parameter is sent in an R1 or\
    \ I2 packet, the base exchange\n   retransmission mechanism will confirm its successful\
    \ delivery.\n   LOCATORs may experimentally be used in NOTIFY packets; in this\
    \ case,\n   the recipient MUST consider the LOCATOR as informational and not\n\
    \   immediately change the current preferred address, but can test the\n   additional\
    \ locators when the need arises.  The use of the LOCATOR in\n   a NOTIFY message\
    \ may not be compatible with middleboxes.\n"
- title: 4.  LOCATOR Parameter Format
  contents:
  - "4.  LOCATOR Parameter Format\n   The LOCATOR parameter is a critical parameter\
    \ as defined by\n   [RFC5201].  It consists of the standard HIP parameter Type\
    \ and Length\n   fields, plus zero or more Locator sub-parameters.  Each Locator\
    \ sub-\n   parameter contains a Traffic Type, Locator Type, Locator Length,\n\
    \   Preferred locator bit, Locator Lifetime, and a Locator encoding.  A\n   LOCATOR\
    \ containing zero Locator fields is permitted but has the\n   effect of deprecating\
    \ all addresses.\n        0                   1                   2          \
    \         3\n        0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8\
    \ 9 0 1\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \       |             Type              |            Length             |\n  \
    \     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n    \
    \   | Traffic Type   | Locator Type | Locator Length | Reserved   |P|\n      \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n       |\
    \                       Locator Lifetime                        |\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \       |                            Locator                            |\n  \
    \     |                                                               |\n    \
    \   |                                                               |\n      \
    \ |                                                               |\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \       .                                                               .\n  \
    \     .                                                               .\n    \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      \
    \ | Traffic Type   | Locator Type | Locator Length | Reserved   |P|\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \       |                       Locator Lifetime                        |\n  \
    \     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n    \
    \   |                            Locator                            |\n      \
    \ |                                                               |\n       |\
    \                                                               |\n       |  \
    \                                                             |\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                    Figure 12: LOCATOR Parameter Format\n   Type:  193\n   Length:\
    \  Length in octets, excluding Type and Length fields, and\n      excluding padding.\n\
    \   Traffic Type:  Defines whether the locator pertains to HIP signaling,\n  \
    \    user data, or both.\n   Locator Type:  Defines the semantics of the Locator\
    \ field.\n   Locator Length:  Defines the length of the Locator field, in units\
    \ of\n      4-byte words (Locators up to a maximum of 4*255 octets are\n     \
    \ supported).\n   Reserved:  Zero when sent, ignored when received.\n   P: Preferred\
    \ locator.  Set to one if the locator is preferred for\n      that Traffic Type;\
    \ otherwise, set to zero.\n   Locator Lifetime:  Locator lifetime, in seconds.\n\
    \   Locator:  The locator whose semantics and encoding are indicated by\n    \
    \  the Locator Type field.  All Locator sub-fields are integral\n      multiples\
    \ of four octets in length.\n   The Locator Lifetime indicates how long the following\
    \ locator is\n   expected to be valid.  The lifetime is expressed in seconds.\
    \  Each\n   locator MUST have a non-zero lifetime.  The address is expected to\n\
    \   become deprecated when the specified number of seconds has passed\n   since\
    \ the reception of the message.  A deprecated address SHOULD NOT\n   be used as\
    \ a destination address if an alternate (non-deprecated) is\n   available and\
    \ has sufficient scope.\n"
- title: 4.1.  Traffic Type and Preferred Locator
  contents:
  - "4.1.  Traffic Type and Preferred Locator\n   The following Traffic Type values\
    \ are defined:\n   0:  Both signaling (HIP control packets) and user data.\n \
    \  1:  Signaling packets only.\n   2:  Data packets only.\n   The \"P\" bit, when\
    \ set, has scope over the corresponding Traffic Type.\n   That is, when a \"P\"\
    \ bit is set for Traffic Type \"2\", for example, it\n   means that the locator\
    \ is preferred for data packets.  If there is a\n   conflict (for example, if\
    \ the \"P\" bit is set for an address of Type\n   \"0\" and a different address\
    \ of Type \"2\"), the more specific Traffic\n   Type rule applies (in this case,\
    \ \"2\").  By default, the IP addresses\n   used in the base exchange are Preferred\
    \ locators for both signaling\n   and user data, unless a new Preferred locator\
    \ supersedes them.  If no\n   locators are indicated as preferred for a given\
    \ Traffic Type, the\n   implementation may use an arbitrary locator from the set\
    \ of active\n   locators.\n"
- title: 4.2.  Locator Type and Locator
  contents:
  - "4.2.  Locator Type and Locator\n   The following Locator Type values are defined,\
    \ along with the\n   associated semantics of the Locator field:\n   0:  An IPv6\
    \ address or an IPv4-in-IPv6 format IPv4 address [RFC4291]\n       (128 bits long).\
    \  This locator type is defined primarily for non-\n       ESP-based usage.\n\
    \   1:  The concatenation of an ESP SPI (first 32 bits) followed by an\n     \
    \  IPv6 address or an IPv4-in-IPv6 format IPv4 address (an\n       additional\
    \ 128 bits).  This IP address is defined primarily for\n       ESP-based usage.\n"
- title: 4.3.  UPDATE Packet with Included LOCATOR
  contents:
  - "4.3.  UPDATE Packet with Included LOCATOR\n   A number of combinations of parameters\
    \ in an UPDATE packet are\n   possible (e.g., see Section 3.2).  In this document,\
    \ procedures are\n   defined only for the case in which one LOCATOR and one ESP_INFO\n\
    \   parameter is used in any HIP packet.  Furthermore, the LOCATOR SHOULD\n  \
    \ list all of the locators that are active on the HIP association\n   (including\
    \ those on SAs not covered by the ESP_INFO parameter).  Any\n   UPDATE packet\
    \ that includes a LOCATOR parameter SHOULD include both\n   an HMAC and a HIP_SIGNATURE\
    \ parameter.  The relationship between the\n   announced Locators and any ESP_INFO\
    \ parameters present in the packet\n   is defined in Section 5.2.  The sending\
    \ of multiple LOCATOR and/or\n   ESP_INFO parameters is for further study; receivers\
    \ may wish to\n   experiment with supporting such a possibility.\n"
- title: 5.  Processing Rules
  contents:
  - "5.  Processing Rules\n   This section describes rules for sending and receiving\
    \ the LOCATOR\n   parameter, testing address reachability, and using Credit-Based\n\
    \   Authorization (CBA) on UNVERIFIED locators.\n"
- title: 5.1.  Locator Data Structure and Status
  contents:
  - "5.1.  Locator Data Structure and Status\n   In a typical implementation, each\
    \ outgoing locator is represented by\n   a piece of state that contains the following\
    \ data:\n   o  the actual bit pattern representing the locator,\n   o  the lifetime\
    \ (seconds),\n   o  the status (UNVERIFIED, ACTIVE, DEPRECATED),\n   o  the Traffic\
    \ Type scope of the locator, and\n   o  whether the locator is preferred for any\
    \ particular scope.\n   The status is used to track the reachability of the address\
    \ embedded\n   within the LOCATOR parameter:\n   UNVERIFIED  indicates that the\
    \ reachability of the address has not\n      been verified yet,\n   ACTIVE  indicates\
    \ that the reachability of the address has been\n      verified and the address\
    \ has not been deprecated,\n   DEPRECATED  indicates that the locator lifetime\
    \ has expired.\n   The following state changes are allowed:\n   UNVERIFIED to\
    \ ACTIVE  The reachability procedure completes\n      successfully.\n   UNVERIFIED\
    \ to DEPRECATED  The locator lifetime expires while the\n      locator is UNVERIFIED.\n\
    \   ACTIVE to DEPRECATED  The locator lifetime expires while the locator\n   \
    \   is ACTIVE.\n   ACTIVE to UNVERIFIED  There has been no traffic on the address\
    \ for\n      some time, and the local policy mandates that the address\n     \
    \ reachability must be verified again before starting to use it\n      again.\n\
    \   DEPRECATED to UNVERIFIED  The host receives a new lifetime for the\n     \
    \ locator.\n   A DEPRECATED address MUST NOT be changed to ACTIVE without first\n\
    \   verifying its reachability.\n   Note that the state of whether or not a locator\
    \ is preferred is not\n   necessarily the same as the value of the Preferred bit\
    \ in the Locator\n   sub-parameter received from the peer.  Peers may recommend\
    \ certain\n   locators to be preferred, but the decision on whether to actually\
    \ use\n   a locator as a preferred locator is a local decision, possibly\n   influenced\
    \ by local policy.\n"
- title: 5.2.  Sending LOCATORs
  contents:
  - "5.2.  Sending LOCATORs\n   The decision of when to send LOCATORs is basically\
    \ a local policy\n   issue.  However, it is RECOMMENDED that a host send a LOCATOR\n\
    \   whenever it recognizes a change of its IP addresses in use on an\n   active\
    \ HIP association, and assumes that the change is going to last\n   at least for\
    \ a few seconds.  Rapidly sending LOCATORs that force the\n   peer to change the\
    \ preferred address SHOULD be avoided.\n   When a host decides to inform its peers\
    \ about changes in its IP\n   addresses, it has to decide how to group the various\
    \ addresses with\n   SPIs.  The grouping should consider also whether middlebox\n\
    \   interaction requires sending the same LOCATOR in separate UPDATEs on\n   different\
    \ paths.  Since each SPI is associated with a different\n   Security Association,\
    \ the grouping policy may also be based on ESP\n   anti-replay protection considerations.\
    \  In the typical case, simply\n   basing the grouping on actual kernel level\
    \ physical and logical\n   interfaces may be the best policy.  Grouping policy\
    \ is outside of the\n   scope of this document.\n   Note that the purpose of announcing\
    \ IP addresses in a LOCATOR is to\n   provide connectivity between the communicating\
    \ hosts.  In most cases,\n   tunnels or virtual interfaces such as IPsec tunnel\
    \ interfaces or\n   Mobile IP home addresses provide sub-optimal connectivity.\n\
    \   Furthermore, it should be possible to replace most tunnels with HIP\n   based\
    \ \"non-tunneling\", therefore making most virtual interfaces\n   fairly unnecessary\
    \ in the future.  Therefore, virtual interfaces\n   SHOULD NOT be announced in\
    \ general.  On the other hand, there are\n   clearly situations where tunnels\
    \ are used for diagnostic and/or\n   testing purposes.  In such and other similar\
    \ cases announcing the IP\n   addresses of virtual interfaces may be appropriate.\n\
    \   Hosts MUST NOT announce broadcast or multicast addresses in LOCATORs.\n  \
    \ Link-local addresses MAY be announced to peers that are known to be\n   neighbors\
    \ on the same link, such as when the IP destination address\n   of a peer is also\
    \ link-local.  The announcement of link-local\n   addresses in this case is a\
    \ policy decision; link-local addresses\n   used as Preferred locators will create\
    \ reachability problems when the\n   host moves to another link.  In any case,\
    \ link-local addresses MUST\n   NOT be announced to a peer unless that peer is\
    \ known to be on the\n   same link.\n   Once the host has decided on the groups\
    \ and assignment of addresses\n   to the SPIs, it creates a LOCATOR parameter\
    \ that serves as a complete\n   representation of the addresses and affiliated\
    \ SPIs intended for\n   active use.  We now describe a few cases introduced in\
    \ Section 3.2.\n   We assume that the Traffic Type for each locator is set to\
    \ \"0\" (other\n   values for Traffic Type may be specified in documents that\
    \ separate\n   the HIP control plane from data plane traffic).  Other mobility\
    \ and\n   multihoming cases are possible but are left for further\n   experimentation.\n\
    \   1.  Host mobility with no multihoming and no rekeying.  The mobile\n     \
    \  host creates a single UPDATE containing a single ESP_INFO with a\n       single\
    \ LOCATOR parameter.  The ESP_INFO contains the current\n       value of the SPI\
    \ in both the OLD SPI and NEW SPI fields.  The\n       LOCATOR contains a single\
    \ Locator with a \"Locator Type\" of \"1\";\n       the SPI must match that of\
    \ the ESP_INFO.  The Preferred bit\n       SHOULD be set and the \"Locator Lifetime\"\
    \ is set according to\n       local policy.  The UPDATE also contains a SEQ parameter\
    \ as usual.\n       This packet is retransmitted as defined in the HIP protocol\n\
    \       specification [RFC5201].  The UPDATE should be sent to the peer's\n  \
    \     preferred IP address with an IP source address corresponding to\n      \
    \ the address in the LOCATOR parameter.\n   2.  Host mobility with no multihoming\
    \ but with rekeying.  The mobile\n       host creates a single UPDATE containing\
    \ a single ESP_INFO with a\n       single LOCATOR parameter (with a single address).\
    \  The ESP_INFO\n       contains the current value of the SPI in the OLD SPI and\
    \ the new\n       value of the SPI in the NEW SPI, and a KEYMAT Index as selected\n\
    \       by local policy.  Optionally, the host may choose to initiate a\n    \
    \   Diffie Hellman rekey by including a DIFFIE_HELLMAN parameter.\n       The\
    \ LOCATOR contains a single Locator with \"Locator Type\" of \"1\";\n       the\
    \ SPI must match that of the NEW SPI in the ESP_INFO.\n       Otherwise, the steps\
    \ are identical to the case in which no\n       rekeying is initiated.\n   3.\
    \  Host multihoming (addition of an address).  We only describe the\n       simple\
    \ case of adding an additional address to a (previously)\n       single-homed,\
    \ non-mobile host.  The host SHOULD set up a new SA\n       pair between this\
    \ new address and the preferred address of the\n       peer host.  To do this,\
    \ the multihomed host creates a new inbound\n       SA and creates a new SPI.\
    \  For the outgoing UPDATE message, it\n       inserts an ESP_INFO parameter with\
    \ an OLD SPI field of \"0\", a NEW\n       SPI field corresponding to the new\
    \ SPI, and a KEYMAT Index as\n       selected by local policy.  The host adds\
    \ to the UPDATE message a\n       LOCATOR with two Type \"1\" Locators: the original\
    \ address and SPI\n       active on the association, and the new address and new\
    \ SPI being\n       added (with the SPI matching the NEW SPI contained in the\n\
    \       ESP_INFO).  The Preferred bit SHOULD be set depending on the\n       policy\
    \ to tell the peer host which of the two locators is\n       preferred.  The UPDATE\
    \ also contains a SEQ parameter and\n       optionally a DIFFIE_HELLMAN parameter,\
    \ and follows rekeying\n       procedures with respect to this new address.  The\
    \ UPDATE message\n       SHOULD be sent to the peer's Preferred address with a\
    \ source\n       address corresponding to the new locator.\n   The sending of\
    \ multiple LOCATORs, locators with Locator Type \"0\", and\n   multiple ESP_INFO\
    \ parameters is for further study.  Note that the\n   inclusion of LOCATOR in\
    \ an R1 packet requires the use of Type \"0\"\n   locators since no SAs are set\
    \ up at that point.\n"
- title: 5.3.  Handling Received LOCATORs
  contents:
  - "5.3.  Handling Received LOCATORs\n   A host SHOULD be prepared to receive a LOCATOR\
    \ parameter in the\n   following HIP packets: R1, I2, UPDATE, and NOTIFY.\n  \
    \ This document describes sending both ESP_INFO and LOCATOR parameters\n   in\
    \ an UPDATE.  The ESP_INFO parameter is included when there is a\n   need to rekey\
    \ or key a new SPI, and is otherwise included for the\n   possible benefit of\
    \ HIP-aware middleboxes.  The LOCATOR parameter\n   contains a complete map of\
    \ the locators that the host wishes to make\n   or keep active for the HIP association.\n\
    \   In general, the processing of a LOCATOR depends upon the packet type\n   in\
    \ which it is included.  Here, we describe only the case in which\n   ESP_INFO\
    \ is present and a single LOCATOR and ESP_INFO are sent in an\n   UPDATE message;\
    \ other cases are for further study.  The steps below\n   cover each of the cases\
    \ described in Section 5.2.\n   The processing of ESP_INFO and LOCATOR parameters\
    \ is intended to be\n   modular and support future generalization to the inclusion\
    \ of\n   multiple ESP_INFO and/or multiple LOCATOR parameters.  A host SHOULD\n\
    \   first process the ESP_INFO before the LOCATOR, since the ESP_INFO may\n  \
    \ contain a new SPI value mapped to an existing SPI, while a Type \"1\"\n   locator\
    \ will only contain a reference to the new SPI.\n   When a host receives a validated\
    \ HIP UPDATE with a LOCATOR and\n   ESP_INFO parameter, it processes the ESP_INFO\
    \ as follows.  The\n   ESP_INFO parameter indicates whether an SA is being rekeyed,\
    \ created,\n   deprecated, or just identified for the benefit of middleboxes.\
    \  The\n   host examines the OLD SPI and NEW SPI values in the ESP_INFO\n   parameter:\n\
    \   1.  (no rekeying) If the OLD SPI is equal to the NEW SPI and both\n      \
    \ correspond to an existing SPI, the ESP_INFO is gratuitous\n       (provided\
    \ for middleboxes) and no rekeying is necessary.\n   2.  (rekeying) If the OLD\
    \ SPI indicates an existing SPI and the NEW\n       SPI is a different non-zero\
    \ value, the existing SA is being\n       rekeyed and the host follows HIP ESP\
    \ rekeying procedures by\n       creating a new outbound SA with an SPI corresponding\
    \ to the NEW\n       SPI, with no addresses bound to this SPI.  Note that locators\
    \ in\n       the LOCATOR parameter will reference this new SPI instead of the\n\
    \       old SPI.\n   3.  (new SA) If the OLD SPI value is zero and the NEW SPI\
    \ is a new\n       non-zero value, then a new SA is being requested by the peer.\n\
    \       This case is also treated like a rekeying event; the receiving\n     \
    \  host must create a new SA and respond with an UPDATE ACK.\n   4.  (deprecating\
    \ the SA) If the OLD SPI indicates an existing SPI and\n       the NEW SPI is\
    \ zero, the SA is being deprecated and all locators\n       uniquely bound to\
    \ the SPI are put into the DEPRECATED state.\n   If none of the above cases apply,\
    \ a protocol error has occurred and\n   the processing of the UPDATE is stopped.\n\
    \   Next, the locators in the LOCATOR parameter are processed.  For each\n   locator\
    \ listed in the LOCATOR parameter, check that the address\n   therein is a legal\
    \ unicast or anycast address.  That is, the address\n   MUST NOT be a broadcast\
    \ or multicast address.  Note that some\n   implementations MAY accept addresses\
    \ that indicate the local host,\n   since it may be allowed that the host runs\
    \ HIP with itself.\n   The below assumes that all locators are of Type \"1\" with\
    \ a Traffic\n   Type of \"0\"; other cases are for further study.\n   For each\
    \ Type \"1\" address listed in the LOCATOR parameter, the host\n   checks whether\
    \ the address is already bound to the SPI indicated.  If\n   the address is already\
    \ bound, its lifetime is updated.  If the status\n   of the address is DEPRECATED,\
    \ the status is changed to UNVERIFIED.\n   If the address is not already bound,\
    \ the address is added, and its\n   status is set to UNVERIFIED.  Mark all addresses\
    \ corresponding to the\n   SPI that were NOT listed in the LOCATOR parameter as\
    \ DEPRECATED.\n   As a result, at the end of processing, the addresses listed\
    \ in the\n   LOCATOR parameter have either a state of UNVERIFIED or ACTIVE, and\n\
    \   any old addresses on the old SA not listed in the LOCATOR parameter\n   have\
    \ a state of DEPRECATED.\n   Once the host has processed the locators, if the\
    \ LOCATOR parameter\n   contains a new Preferred locator, the host SHOULD initiate\
    \ a change\n   of the Preferred locator.  This requires that the host first verifies\n\
    \   reachability of the associated address, and only then changes the\n   Preferred\
    \ locator; see Section 5.5.\n   If a host receives a locator with an unsupported\
    \ Locator Type, and\n   when such a locator is also declared to be the Preferred\
    \ locator for\n   the peer, the host SHOULD send a NOTIFY error with a Notify\
    \ Message\n   Type of LOCATOR_TYPE_UNSUPPORTED, with the Notification Data field\n\
    \   containing the locator(s) that the receiver failed to process.\n   Otherwise,\
    \ a host MAY send a NOTIFY error if a (non-preferred)\n   locator with an unsupported\
    \ Locator Type is received in a LOCATOR\n   parameter.\n"
- title: 5.4.  Verifying Address Reachability
  contents:
  - "5.4.  Verifying Address Reachability\n   A host MUST verify the reachability\
    \ of an UNVERIFIED address.  The\n   status of a newly learned address MUST initially\
    \ be set to UNVERIFIED\n   unless the new address is advertised in a R1 packet\
    \ as a new\n   Preferred locator.  A host MAY also want to verify the reachability\n\
    \   of an ACTIVE address again after some time, in which case it would\n   set\
    \ the status of the address to UNVERIFIED and reinitiate address\n   verification.\n\
    \   A host typically starts the address-verification procedure by sending\n  \
    \ a nonce to the new address.  For example, when the host is changing\n   its\
    \ SPI and sending an ESP_INFO to the peer, the NEW SPI value SHOULD\n   be random\
    \ and the value MAY be copied into an ECHO_REQUEST sent in\n   the rekeying UPDATE.\
    \  However, if the host is not changing its SPI,\n   it MAY still use the ECHO_REQUEST\
    \ parameter in an UPDATE message sent\n   to the new address.  A host MAY also\
    \ use other message exchanges as\n   confirmation of the address reachability.\n\
    \   Note that in the case of receiving a LOCATOR in an R1 and replying\n   with\
    \ an I2 to the new address in the LOCATOR, receiving the\n   corresponding R2\
    \ is sufficient proof of reachability for the\n   Responder's preferred address.\
    \  Since further address verification of\n   such an address can impede the HIP-base\
    \ exchange, a host MUST NOT\n   separately verify reachability of a new Preferred\
    \ locator that was\n   received on an R1.\n   In some cases, it MAY be sufficient\
    \ to use the arrival of data on a\n   newly advertised SA as implicit address\
    \ reachability verification as\n   depicted in Figure 13, instead of waiting for\
    \ the confirmation via a\n   HIP packet.  In this case, a host advertising a new\
    \ SPI as part of\n   its address reachability check SHOULD be prepared to receive\
    \ traffic\n   on the new SA.\n     Mobile host                               \
    \    Peer host\n                                                   prepare incoming\
    \ SA\n                      NEW SPI in ESP_INFO (UPDATE)\n                <-----------------------------------\n\
    \   switch to new outgoing SA\n                           data on new SA\n   \
    \             ----------------------------------->\n                         \
    \                          mark address ACTIVE\n             Figure 13: Address\
    \ Activation Via Use of a New SA\n   When address verification is in progress\
    \ for a new Preferred locator,\n   the host SHOULD select a different locator\
    \ listed as ACTIVE, if one\n   such locator is available, to continue communications\
    \ until address\n   verification completes.  Alternatively, the host MAY use the\
    \ new\n   Preferred locator while in UNVERIFIED status to the extent Credit-\n\
    \   Based Authorization permits.  Credit-Based Authorization is explained\n  \
    \ in Section 5.6.  Once address verification succeeds, the status of\n   the new\
    \ Preferred locator changes to ACTIVE.\n"
- title: 5.5.  Changing the Preferred Locator
  contents:
  - "5.5.  Changing the Preferred Locator\n   A host MAY want to change the Preferred\
    \ outgoing locator for\n   different reasons, e.g., because traffic information\
    \ or ICMP error\n   messages indicate that the currently used preferred address\
    \ may have\n   become unreachable.  Another reason may be due to receiving a LOCATOR\n\
    \   parameter that has the \"P\" bit set.\n   To change the Preferred locator,\
    \ the host initiates the following\n   procedure:\n   1.  If the new Preferred\
    \ locator has ACTIVE status, the Preferred\n       locator is changed and the\
    \ procedure succeeds.\n   2.  If the new Preferred locator has UNVERIFIED status,\
    \ the host\n       starts to verify its reachability.  The host SHOULD use a\n\
    \       different locator listed as ACTIVE until address verification\n      \
    \ completes if one such locator is available.  Alternatively, the\n       host\
    \ MAY use the new Preferred locator, even though in UNVERIFIED\n       status,\
    \ to the extent Credit-Based Authorization permits.  Once\n       address verification\
    \ succeeds, the status of the new Preferred\n       locator changes to ACTIVE\
    \ and its use is no longer governed by\n       Credit-Based Authorization.\n \
    \  3.  If the peer host has not indicated a preference for any address,\n    \
    \   then the host picks one of the peer's ACTIVE addresses randomly\n       or\
    \ according to policy.  This case may arise if, for example,\n       ICMP error\
    \ messages that deprecate the Preferred locator arrive,\n       but the peer has\
    \ not yet indicated a new Preferred locator.\n   4.  If the new Preferred locator\
    \ has DEPRECATED status and there is\n       at least one non-deprecated address,\
    \ the host selects one of the\n       non-deprecated addresses as a new Preferred\
    \ locator and\n       continues.  If the selected address is UNVERIFIED, the address\n\
    \       verification procedure described above will apply.\n"
- title: 5.6.  Credit-Based Authorization
  contents:
  - "5.6.  Credit-Based Authorization\n   To prevent redirection-based flooding attacks,\
    \ the use of a Credit-\n   Based Authorization (CBA) approach is mandatory when\
    \ a host sends\n   data to an UNVERIFIED locator.  The following algorithm meets\
    \ the\n   security considerations for prevention of amplification and time-\n\
    \   shifting attacks.  Other forms of credit aging, and other values for\n   the\
    \ CreditAgingFactor and CreditAgingInterval parameters in\n   particular, are\
    \ for further study, and so are the advanced CBA\n   techniques specified in [CBA-MIPv6].\n"
- title: 5.6.1.  Handling Payload Packets
  contents:
  - "5.6.1.  Handling Payload Packets\n   A host maintains a \"credit counter\" for\
    \ each of its peers.  Whenever\n   a packet arrives from a peer, the host SHOULD\
    \ increase that peer's\n   credit counter by the size of the received packet.\
    \  When the host has\n   a packet to be sent to the peer, and when the peer's\
    \ Preferred\n   locator is listed as UNVERIFIED and no alternative locator with\n\
    \   status ACTIVE is available, the host checks whether it can send the\n   packet\
    \ to the UNVERIFIED locator.  The packet SHOULD be sent if the\n   value of the\
    \ credit counter is higher than the size of the outbound\n   packet.  If the credit\
    \ counter is too low, the packet MUST be\n   discarded or buffered until address\
    \ verification succeeds.  When a\n   packet is sent to a peer at an UNVERIFIED\
    \ locator, the peer's credit\n   counter MUST be reduced by the size of the packet.\
    \  The peer's credit\n   counter is not affected by packets that the host sends\
    \ to an ACTIVE\n   locator of that peer.\n   Figure 14 depicts the actions taken\
    \ by the host when a packet is\n   received.  Figure 15 shows the decision chain\
    \ in the event a packet\n   is sent.\n       Inbound\n       packet\n        \
    \  |\n          |       +----------------+               +---------------+\n \
    \         |       |    Increase    |               |    Deliver    |\n       \
    \   +-----> | credit counter |-------------> |   packet to   |\n             \
    \     | by packet size |               |  application  |\n                  +----------------+\
    \               +---------------+\n       Figure 14: Receiving Packets with Credit-Based\
    \ Authorization\n    Outbound\n     packet\n        |          _________________\n\
    \        |         /                 \\                 +---------------+\n  \
    \      |        /  Is the preferred \\       No       |  Send packet  |\n    \
    \    +-----> | destination address |-------------> |  to preferred |\n       \
    \          \\    UNVERIFIED?    /                |    address    |\n         \
    \         \\_________________/                 +---------------+\n           \
    \                |\n                           | Yes\n                       \
    \    |\n                           v\n                   _________________\n \
    \                 /                 \\                 +---------------+\n   \
    \              /   Does an ACTIVE  \\      Yes       |  Send packet  |\n     \
    \           | destination address |-------------> |   to ACTIVE   |\n        \
    \         \\       exist?      /                |    address    |\n          \
    \        \\_________________/                 +---------------+\n            \
    \               |\n                           | No\n                         \
    \  |\n                           v\n                   _________________\n   \
    \               /                 \\                 +---------------+\n     \
    \            /   Credit counter  \\       No       |               |\n       \
    \         |          >=         |-------------> |  Drop packet  |\n          \
    \       \\    packet size?   /                |               |\n            \
    \      \\_________________/                 +---------------+\n              \
    \             |\n                           | Yes\n                          \
    \ |\n                           v\n                   +---------------+      \
    \            +---------------+\n                   | Reduce credit |         \
    \         |  Send packet  |\n                   |  counter by   |---------------->\
    \ | to preferred  |\n                   |  packet size  |                  | \
    \   address    |\n                   +---------------+                  +---------------+\n\
    \        Figure 15: Sending Packets with Credit-Based Authorization\n"
- title: 5.6.2.  Credit Aging
  contents:
  - "5.6.2.  Credit Aging\n   A host ensures that the credit counters it maintains\
    \ for its peers\n   gradually decrease over time.  Such \"credit aging\" prevents\
    \ a\n   malicious peer from building up credit at a very slow speed and using\n\
    \   this, all at once, for a severe burst of redirected packets.\n   Credit aging\
    \ may be implemented by multiplying credit counters with a\n   factor, CreditAgingFactor\
    \ (a fractional value less than one), in\n   fixed time intervals of CreditAgingInterval\
    \ length.  Choosing\n   appropriate values for CreditAgingFactor and CreditAgingInterval\
    \ is\n   important to ensure that a host can send packets to an address in\n \
    \  state UNVERIFIED even when the peer sends at a lower rate than the\n   host\
    \ itself.  When CreditAgingFactor or CreditAgingInterval are too\n   small, the\
    \ peer's credit counter might be too low to continue sending\n   packets until\
    \ address verification concludes.\n   The parameter values proposed in this document\
    \ are as follows:\n      CreditAgingFactor        7/8\n      CreditAgingInterval\
    \      5 seconds\n   These parameter values work well when the host transfers\
    \ a file to\n   the peer via a TCP connection and the end-to-end round-trip time\
    \ does\n   not exceed 500 milliseconds.  Alternative credit-aging algorithms may\n\
    \   use other parameter values or different parameters, which may even be\n  \
    \ dynamically established.\n"
- title: 6.  Security Considerations
  contents:
  - "6.  Security Considerations\n   The HIP mobility mechanism provides a secure\
    \ means of updating a\n   host's IP address via HIP UPDATE packets.  Upon receipt,\
    \ a HIP host\n   cryptographically verifies the sender of an UPDATE, so forging\
    \ or\n   replaying a HIP UPDATE packet is very difficult (see [RFC5201]).\n  \
    \ Therefore, security issues reside in other attack domains.  The two\n   we consider\
    \ are malicious redirection of legitimate connections as\n   well as redirection-based\
    \ flooding attacks using this protocol.  This\n   can be broken down into the\
    \ following:\n      Impersonation attacks\n         - direct conversation with\
    \ the misled victim\n         - man-in-the-middle attack\n      DoS attacks\n\
    \         - flooding attacks (== bandwidth-exhaustion attacks)\n            *\
    \ tool 1: direct flooding\n            * tool 2: flooding by zombies\n       \
    \     * tool 3: redirection-based flooding\n         - memory-exhaustion attacks\n\
    \         - computational-exhaustion attacks\n   We consider these in more detail\
    \ in the following sections.\n   In Section 6.1 and Section 6.2, we assume that\
    \ all users are using\n   HIP.  In Section 6.3 we consider the security ramifications\
    \ when we\n   have both HIP and non-HIP users.  Security considerations for Credit-\n\
    \   Based Authorization are discussed in [SIMPLE-CBA].\n"
- title: 6.1.  Impersonation Attacks
  contents:
  - "6.1.  Impersonation Attacks\n   An attacker wishing to impersonate another host\
    \ will try to mislead\n   its victim into directly communicating with them, or\
    \ carry out a man-\n   in-the-middle (MitM) attack between the victim and the\
    \ victim's\n   desired communication peer.  Without mobility support, both attack\n\
    \   types are possible only if the attacker resides on the routing path\n   between\
    \ its victim and the victim's desired communication peer, or if\n   the attacker\
    \ tricks its victim into initiating the connection over an\n   incorrect routing\
    \ path (e.g., by acting as a router or using spoofed\n   DNS entries).\n   The\
    \ HIP extensions defined in this specification change the situation\n   in that\
    \ they introduce an ability to redirect a connection (like\n   IPv6), both before\
    \ and after establishment.  If no precautionary\n   measures are taken, an attacker\
    \ could misuse the redirection feature\n   to impersonate a victim's peer from\
    \ any arbitrary location.  The\n   authentication and authorization mechanisms\
    \ of the HIP base exchange\n   [RFC5201] and the signatures in the UPDATE message\
    \ prevent this\n   attack.  Furthermore, ownership of a HIP association is securely\n\
    \   linked to a HIP HI/HIT.  If an attacker somehow uses a bug in the\n   implementation\
    \ or weakness in some protocol to redirect a HIP\n   connection, the original\
    \ owner can always reclaim their connection\n   (they can always prove ownership\
    \ of the private key associated with\n   their public HI).\n   MitM attacks are\
    \ always possible if the attacker is present during\n   the initial HIP base exchange\
    \ and if the hosts do not authenticate\n   each other's identities.  However,\
    \ once the opportunistic base\n   exchange has taken place, even a MitM cannot\
    \ steal the HIP connection\n   anymore because it is very difficult for an attacker\
    \ to create an\n   UPDATE packet (or any HIP packet) that will be accepted as\
    \ a\n   legitimate update.  UPDATE packets use HMAC and are signed.  Even\n  \
    \ when an attacker can snoop packets to obtain the SPI and HIT/HI, they\n   still\
    \ cannot forge an UPDATE packet without knowledge of the secret\n   keys.\n"
- title: 6.2.  Denial-of-Service Attacks
  contents:
  - '6.2.  Denial-of-Service Attacks

    '
- title: 6.2.1.  Flooding Attacks
  contents:
  - "6.2.1.  Flooding Attacks\n   The purpose of a denial-of-service attack is to\
    \ exhaust some resource\n   of the victim such that the victim ceases to operate\
    \ correctly.  A\n   denial-of-service attack can aim at the victim's network attachment\n\
    \   (flooding attack), its memory, or its processing capacity.  In a\n   flooding\
    \ attack, the attacker causes an excessive number of bogus or\n   unwanted packets\
    \ to be sent to the victim, which fills their\n   available bandwidth.  Note that\
    \ the victim does not necessarily need\n   to be a node; it can also be an entire\
    \ network.  The attack basically\n   functions the same way in either case.\n\
    \   An effective DoS strategy is distributed denial of service (DDoS).\n   Here,\
    \ the attacker conventionally distributes some viral software to\n   as many nodes\
    \ as possible.  Under the control of the attacker, the\n   infected nodes, or\
    \ \"zombies\", jointly send packets to the victim.\n   With such an 'army', an\
    \ attacker can take down even very high\n   bandwidth networks/victims.\n   With\
    \ the ability to redirect connections, an attacker could realize a\n   DDoS attack\
    \ without having to distribute viral code.  Here, the\n   attacker initiates a\
    \ large download from a server, and subsequently\n   redirects this download to\
    \ its victim.  The attacker can repeat this\n   with multiple servers.  This threat\
    \ is mitigated through reachability\n   checks and credit-based authorization.\
    \  Both strategies do not\n   eliminate flooding attacks per se, but they preclude:\
    \ (i) their use\n   from a location off the path towards the flooded victim; and\
    \ (ii) any\n   amplification in the number and size of the redirected packets.\
    \  As a\n   result, the combination of a reachability check and credit-based\n\
    \   authorization lowers a HIP redirection-based flooding attack to the\n   level\
    \ of a direct flooding attack in which the attacker itself sends\n   the flooding\
    \ traffic to the victim.\n"
- title: 6.2.2.  Memory/Computational-Exhaustion DoS Attacks
  contents:
  - "6.2.2.  Memory/Computational-Exhaustion DoS Attacks\n   We now consider whether\
    \ or not the proposed extensions to HIP add any\n   new DoS attacks (consideration\
    \ of DoS attacks using the base HIP\n   exchange and updates is discussed in [RFC5201]).\
    \  A simple attack is\n   to send many UPDATE packets containing many IP addresses\
    \ that are not\n   flagged as preferred.  The attacker continues to send such\
    \ packets\n   until the number of IP addresses associated with the attacker's\
    \ HI\n   crashes the system.  Therefore, there SHOULD be a limit to the number\n\
    \   of IP addresses that can be associated with any HI.  Other forms of\n   memory/computationally\
    \ exhausting attacks via the HIP UPDATE packet\n   are handled in the base HIP\
    \ document [RFC5201].\n   A central server that has to deal with a large number\
    \ of mobile\n   clients may consider increasing the SA lifetimes to try to slow\
    \ down\n   the rate of rekeying UPDATEs or increasing the cookie difficulty to\n\
    \   slow down the rate of attack-oriented connections.\n"
- title: 6.3.  Mixed Deployment Environment
  contents:
  - "6.3.  Mixed Deployment Environment\n   We now assume an environment with both\
    \ HIP and non-HIP aware hosts.\n   Four cases exist.\n   1.  A HIP host redirects\
    \ its connection onto a non-HIP host.  The\n       non-HIP host will drop the\
    \ reachability packet, so this is not a\n       threat unless the HIP host is\
    \ a MitM that could somehow respond\n       successfully to the reachability check.\n\
    \   2.  A non-HIP host attempts to redirect their connection onto a HIP\n    \
    \   host.  This falls into IPv4 and IPv6 security concerns, which are\n      \
    \ outside the scope of this document.\n   3.  A non-HIP host attempts to steal\
    \ a HIP host's session (assume\n       that Secure Neighbor Discovery is not active\
    \ for the following).\n       The non-HIP host contacts the service that a HIP\
    \ host has a\n       connection with and then attempts to change its IP address\
    \ to\n       steal the HIP host's connection.  What will happen in this case\n\
    \       is implementation dependent but such a request should fail by\n      \
    \ being ignored or dropped.  Even if the attack were successful,\n       the HIP\
    \ host could reclaim its connection via HIP.\n   4.  A HIP host attempts to steal\
    \ a non-HIP host's session.  A HIP\n       host could spoof the non-HIP host's\
    \ IP address during the base\n       exchange or set the non-HIP host's IP address\
    \ as its preferred\n       address via an UPDATE.  Other possibilities exist,\
    \ but a simple\n       solution is to prevent the use of HIP address check information\n\
    \       to influence non-HIP sessions.\n"
- title: 7.  IANA Considerations
  contents:
  - "7.  IANA Considerations\n   This document defines a LOCATOR parameter for the\
    \ Host Identity\n   Protocol [RFC5201].  This parameter is defined in Section\
    \ 4 with a\n   Type of 193.\n   This document also defines a LOCATOR_TYPE_UNSUPPORTED\
    \ Notify Message\n   Type as defined in the Host Identity Protocol specification\n\
    \   [RFC5201].  This parameter is defined in Section 5.3 with a value of\n   46.\n"
- title: 8.  Authors and Acknowledgments
  contents:
  - "8.  Authors and Acknowledgments\n   Pekka Nikander and Jari Arkko originated\
    \ this document, and Christian\n   Vogt and Thomas Henderson (editor) later joined\
    \ as co-authors.  Greg\n   Perkins contributed the initial draft of the security\
    \ section.  Petri\n   Jokela was a co-author of the initial individual submission.\n\
    \   The authors thank Miika Komu, Mika Kousa, Jeff Ahrenholz, and Jan\n   Melen\
    \ for many improvements to the document.\n"
- title: 9.  References
  contents:
  - '9.  References

    '
- title: 9.1.  Normative references
  contents:
  - "9.1.  Normative references\n   [RFC2119]     Bradner, S., \"Key words for use\
    \ in RFCs to Indicate\n                 Requirement Levels\", BCP 14, RFC 2119,\
    \ March 1997.\n   [RFC3484]     Draves, R., \"Default Address Selection for Internet\n\
    \                 Protocol version 6 (IPv6)\", RFC 3484, February 2003.\n   [RFC4291]\
    \     Hinden, R. and S. Deering, \"IP Version 6 Addressing\n                 Architecture\"\
    , RFC 4291, February 2006.\n   [RFC4303]     Kent, S., \"IP Encapsulating Security\
    \ Payload (ESP)\",\n                 RFC 4303, December 2005.\n   [RFC4423]  \
    \   Moskowitz, R. and P. Nikander, \"Host Identity Protocol\n                \
    \ (HIP) Architecture\", RFC 4423, May 2006.\n   [RFC5201]     Moskowitz, R., Nikander,\
    \ P., Jokela, P., Ed., and T.\n                 Henderson, \"Host Identity Protocol\"\
    , RFC 5201,\n                 April 2008.\n   [RFC5202]     Jokela, P., Moskowitz,\
    \ R., and P. Nikander, \"Using the\n                 ESP Transport Format with\
    \ the Host Identity Protocol\n                 (HIP)\", RFC 5202, April 2008.\n\
    \   [RFC5204]     Laganier, J. and L. Eggert, \"Host Identity Protocol\n     \
    \            (HIP) Rendezvous Extension\", RFC 5204, April 2008.\n"
- title: 9.2.  Informative references
  contents:
  - "9.2.  Informative references\n   [CBA-MIPv6]   Vogt, C. and J. Arkko, \"Credit-Based\
    \ Authorization for\n                 Mobile IPv6 Early Binding Updates\", Work\
    \ in Progress,\n                 February 2005.\n   [RFC4225]     Nikander, P.,\
    \ Arkko, J., Aura, T., Montenegro, G., and\n                 E. Nordmark, \"Mobile\
    \ IP Version 6 Route Optimization\n                 Security Design Background\"\
    , RFC 4225, December 2005.\n   [SIMPLE-CBA]  Vogt, C. and J. Arkko, \"Credit-Based\
    \ Authorization for\n                 Concurrent Reachability Verification\",\
    \ Work\n                 in Progress, February 2006.\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Pekka Nikander\n   Ericsson Research NomadicLab\n   JORVAS\
    \  FIN-02420\n   FINLAND\n   Phone: +358 9 299 1\n   EMail: pekka.nikander@nomadiclab.com\n\
    \   Thomas R. Henderson (editor)\n   The Boeing Company\n   P.O. Box 3707\n  \
    \ Seattle, WA\n   USA\n   EMail: thomas.r.henderson@boeing.com\n   Christian Vogt\n\
    \   Ericsson Research NomadicLab\n   Hirsalantie 11\n   JORVAS  FIN-02420\n  \
    \ FINLAND\n   Phone:\n   EMail: christian.vogt@ericsson.com\n   Jari Arkko\n \
    \  Ericsson Research NomadicLab\n   JORVAS  FIN-02420\n   FINLAND\n   Phone: +358\
    \ 40 5079256\n   EMail: jari.arkko@ericsson.com\n"
- title: Full Copyright Statement
  contents:
  - "Full Copyright Statement\n   Copyright (C) The IETF Trust (2008).\n   This document\
    \ is subject to the rights, licenses and restrictions\n   contained in BCP 78,\
    \ and except as set forth therein, the authors\n   retain all their rights.\n\
    \   This document and the information contained herein are provided on an\n  \
    \ \"AS IS\" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS\n  \
    \ OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY, THE IETF TRUST AND\n   THE\
    \ INTERNET ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS\n   OR IMPLIED,\
    \ INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF\n   THE INFORMATION\
    \ HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED\n   WARRANTIES OF MERCHANTABILITY\
    \ OR FITNESS FOR A PARTICULAR PURPOSE.\n"
- title: Intellectual Property
  contents:
  - "Intellectual Property\n   The IETF takes no position regarding the validity or\
    \ scope of any\n   Intellectual Property Rights or other rights that might be\
    \ claimed to\n   pertain to the implementation or use of the technology described\
    \ in\n   this document or the extent to which any license under such rights\n\
    \   might or might not be available; nor does it represent that it has\n   made\
    \ any independent effort to identify any such rights.  Information\n   on the\
    \ procedures with respect to rights in RFC documents can be\n   found in BCP 78\
    \ and BCP 79.\n   Copies of IPR disclosures made to the IETF Secretariat and any\n\
    \   assurances of licenses to be made available, or the result of an\n   attempt\
    \ made to obtain a general license or permission for the use of\n   such proprietary\
    \ rights by implementers or users of this\n   specification can be obtained from\
    \ the IETF on-line IPR repository at\n   http://www.ietf.org/ipr.\n   The IETF\
    \ invites any interested party to bring to its attention any\n   copyrights, patents\
    \ or patent applications, or other proprietary\n   rights that may cover technology\
    \ that may be required to implement\n   this standard.  Please address the information\
    \ to the IETF at\n   ietf-ipr@ietf.org.\n"
