- title: __initial_text__
  contents:
  - '                  Security Mechanisms for the Internet

    '
- title: Status of this Memo
  contents:
  - "Status of this Memo\n   This memo provides information for the Internet community.\
    \  It does\n   not specify an Internet standard of any kind.  Distribution of\
    \ this\n   memo is unlimited.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (C) The Internet Society (2003).  All Rights Reserved.\n"
- title: Abstract
  contents:
  - "Abstract\n   Security must be built into Internet Protocols for those protocols\
    \ to\n   offer their services securely.  Many security problems can be traced\n\
    \   to improper implementations.  However, even a proper implementation\n   will\
    \ have security problems if the fundamental protocol is itself\n   exploitable.\
    \  Exactly how security should be implemented in a\n   protocol will vary, because\
    \ of the structure of the protocol itself.\n   However, there are many protocols\
    \ for which standard Internet\n   security mechanisms, already developed, may\
    \ be applicable.  The\n   precise one that is appropriate in any given situation\
    \ can vary.  We\n   review a number of different choices, explaining the properties\
    \ of\n   each.\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   Internet Security compromises can be divided into several\
    \ classes,\n   ranging from Denial of Service to Host Compromise.  Denial of Service\n\
    \   attacks based on sheer volume of traffic are beyond the scope of this\n  \
    \ document, though they are the subject of much ongoing discussion and\n   research.\
    \  It is important to note that many such attacks are made\n   more difficult\
    \ by good security practices.  Host Compromise (most\n   commonly caused by undetected\
    \ Buffer Overflows) represent flaws in\n   individual implementations rather than\
    \ flaws in protocols.\n   Nevertheless, carefully designed protocols can make\
    \ such flaws less\n   likely to occur and harder to exploit.\n   However, there\
    \ are security compromises that are facilitated by the\n   very protocols that\
    \ are in use on the Internet.  If a security\n   problem is inherent in a protocol,\
    \ no manner of implementation will\n   be able to prevent the problem.\n   It\
    \ is therefore vitally important that protocols developed for the\n   Internet\
    \ provide this fundamental security.\n   Exactly how a protocol should be secured\
    \ depends on the protocol\n   itself as well as the security needs of the protocol.\
    \  However, we\n   have developed a number of standard security mechanisms in\
    \ the IETF.\n   In many cases appropriate application of these mechanisms can\
    \ provide\n   the necessary security for a protocol.\n   A number of possible\
    \ mechanisms can be used to provide security on\n   the Internet.  Which one should\
    \ be selected depends on many different\n   factors.  We attempt here to provide\
    \ guidance, spelling out the\n   factors and the currently-standardized (or about-to-be-standardized)\n\
    \   solutions, as discussed at the IAB Security Architecture Workshop\n   [RFC2316].\n\
    \   Security, however, is an art, not a science.  Attempting to follow a\n   recipe\
    \ blindly can lead to disaster.  As always, good taste in\n   protocol design\
    \ should be exercised.\n   Finally, security mechanisms are not magic pixie dust\
    \ that can be\n   sprinkled over completed protocols.  It is rare that security\
    \ can be\n   bolted on later.  Good designs -- that is, secure, clean, and\n \
    \  efficient designs -- occur when the security mechanisms are crafted\n   along\
    \ with the protocol.  No conceivable exercise in cryptography can\n   secure a\
    \ protocol with flawed semantic assumptions.\n"
- title: 2.  Decision Factors
  contents:
  - '2.  Decision Factors

    '
- title: 2.1.  Threat Model
  contents:
  - "2.1.  Threat Model\n   The most important factor in choosing a security mechanism\
    \ is the\n   threat model.  That is, who may be expected to attack what resource,\n\
    \   using what sorts of mechanisms?  A low-value target, such as a Web\n   site\
    \ that offers public information only, may not merit much\n   protection.  Conversely,\
    \ a resource that if compromised could expose\n   significant parts of the Internet\
    \ infrastructure, say, a major\n   backbone router or high-level Domain Name Server,\
    \ should be protected\n   by very strong mechanisms.  The value of a target to\
    \ an attacker\n   depends on the purpose of the attack.  If the purpose is to\
    \ access\n   sensitive information, all systems that handle this information or\n\
    \   mediate access to it are valuable.  If the purpose is to wreak havoc,\n  \
    \ systems on which large parts of the Internet depend are exceedingly\n   valuable.\
    \  Even if only public information is posted on a web site,\n   changing its contents\
    \ can cause embarrassment to its owner and could\n   result in substantial damage.\
    \  It is difficult when designing a\n   protocol to predict what uses that protocol\
    \ will someday have.\n   All Internet connected systems require a minimum amount\
    \ of\n   protection.  Starting in 2000 and continuing to the present, we have\n\
    \   witnessed the advent of a new type of Internet security attack: an\n   Internet\
    \ \"worm\" program that seeks out and automatically attacks\n   systems that are\
    \ vulnerable to compromise via a number of attacks\n   built into the worm program\
    \ itself.  These worm programs can\n   compromise literally thousands of systems\
    \ within a very short period\n   of time.  Note that the first Internet Worm was\
    \ the \"Morris\" worm of\n   1988.  However, it was not followed up with similar\
    \ programs for over\n   12 years!\n   As of the writing of this document, all\
    \ of these worms have taken\n   advantage of programming errors in the implementation\
    \ of otherwise\n   reasonably secure protocols.  However, it is not hard to envision\
    \ an\n   attack that targets a fundamental security flaw in a widely deployed\n\
    \   protocol.  It is therefore imperative that we strive to minimize such\n  \
    \ flaws in the protocols we design.\n   The value of a target to an attacker may\
    \ depend on where it is\n   located.  A network monitoring station that is physically\
    \ on a\n   backbone cable is a major target, since it could easily be turned\n\
    \   into an eavesdropping station.  The same machine, if located on a\n   stub\
    \ net and used for word processing, would be of much less use to a\n   sophisticated\
    \ attacker, and hence would be at significantly less\n   risk.\n   One must also\
    \ consider what sorts of attacks may be expected.  At a\n   minimum, eavesdropping\
    \ must be seen as a serious threat; there have\n   been very many such incidents\
    \ since at least 1993.  Often, active\n   attacks, that is, attacks that involve\
    \ insertion or deletion of\n   packets by the attacker, are a risk as well.  It\
    \ is worth noting that\n   such attacks can be launched with off-the-shelf tools,\
    \ and have in\n   fact been observed \"in the wild\".  Of particular interest\
    \ is a form\n   of attack called \"session hijacking\", where someone on a link\
    \ between\n   the two communicating parties wait for authentication to complete\
    \ and\n   then impersonate one of the parties and continue the connection with\n\
    \   the other.\n   One of the most important tools available to us for securing\n\
    \   protocols is cryptography.  Cryptography permits us to apply various\n   kinds\
    \ of protection to data as it traverses the network, without\n   having to depend\
    \ on any particular security properties of the network\n   itself.  This is important\
    \ because the Internet, by its distributed\n   management and control, cannot\
    \ be considered a trustworthy media in\n   and of itself.  Its security derives\
    \ from the mechanisms that we\n   build into the protocols themselves, independent\
    \ of the underlying\n   media or network operators.\n   Finally, of course, there\
    \ is the cost to the defender of using\n   cryptography.  This cost is dropping\
    \ rapidly; Moore's Law, plus the\n   easy availability of cryptographic components\
    \ and toolkits, makes it\n   relatively easy to use strong protective techniques.\
    \  Although there\n   are exceptions, public key operations are still expensive,\
    \ perhaps\n   prohibitively so if the cost of each public-key operation is spread\n\
    \   over too few transactions, careful engineering design can generally\n   let\
    \ us spread this cost over many transactions.\n   In general, the default today\
    \ should be to use the strongest\n   cryptography available in any protocol. \
    \ Strong cryptography often\n   costs no more, and sometimes less, then weaker\
    \ cryptography.  The\n   actual performance cost of an algorithm is often unrelated\
    \ to the\n   security it provides.  Depending on the hardware available,\n   cryptography\
    \ can be performed at very high rates (1+Gbps), and even\n   in software its performance\
    \ impact is shrinking over time.\n"
- title: 2.2.  A Word about Mandatory Mechanisms
  contents:
  - "2.2.  A Word about Mandatory Mechanisms\n   We have evolved in the IETF the notion\
    \ of \"mandatory to implement\"\n   mechanisms.  This philosophy evolves from\
    \ our primary desire to\n   ensure interoperability between different implementations\
    \ of a\n   protocol.  If a protocol offers many options for how to perform a\n\
    \   particular task, but fails to provide for at least one that all must\n   implement,\
    \ it may be possible that multiple, non-interoperable\n   implementations may\
    \ result.  This is the consequence of the selection\n   of non-overlapping mechanisms\
    \ being deployed in the different\n   implementations.\n   Although a given protocol\
    \ may make use of only one or a few security\n   mechanisms, these mechanisms\
    \ themselves often can make use of several\n   cryptographic systems.  The various\
    \ cryptographic systems vary in\n   strength and performance.  However, in many\
    \ protocols we need to\n   specify a \"mandatory to implement\" to ensure that\
    \ any two\n   implementations will eventually be able to negotiate a common\n\
    \   cryptographic system between them.\n   There are some protocols that were\
    \ originally designed to be run in a\n   very limited domain.  It is often argued\
    \ that the domain of\n   implementation for a particular protocol is sufficiently\
    \ well defined\n   and secure that the protocol itself need not provide any security\n\
    \   mechanisms.\n   History has shown this argument to be wrong.  Inevitably,\
    \ successful\n   protocols - even if developed for limited use - wind up used\
    \ in a\n   broader environment, where the initial security assumptions do not\n\
    \   hold.\n   To solve this problem, the IETF requires that *ALL* protocols provide\n\
    \   appropriate security mechanisms, even when their domain of\n   application\
    \ is at first believed to be very limited.\n   It is important to understand that\
    \ mandatory mechanisms are mandatory\n   to *implement*.  It is not necessarily\
    \ mandatory that end-users\n   actually use these mechanisms.  If an end-user\
    \ knows that they are\n   deploying a protocol over a \"secure\" network, then\
    \ they may choose to\n   disable security mechanisms that they believe are adding\
    \ insufficient\n   value as compared to their performance cost.  (We are generally\n\
    \   skeptical of the wisdom of disabling strong security even then, but\n   that\
    \ is beyond the scope of this document.)\n   Insisting that certain mechanisms\
    \ are mandatory to implement means\n   that those end-users who need the protocol\
    \ provided by the security\n   mechanism have it available when needed.  Particularly\
    \ with security\n   mechanisms, just because a mechanism is mandatory to implement\
    \ does\n   not imply that it should be the default mechanism or that it may not\n\
    \   be disabled by configuration.  If a mandatory to implement algorithm\n   is\
    \ old and weak, it is better to disable it when a stronger algorithm\n   is available.\n"
- title: 2.3.  Granularity of Protection
  contents:
  - "2.3.  Granularity of Protection\n   Some security mechanisms can protect an entire\
    \ network.  While this\n   economizes on hardware, it can leave the interior of\
    \ such networks\n   open to attacks from the inside.  Other mechanisms can provide\n\
    \   protection down to the individual user of a timeshared machine,\n   though\
    \ perhaps at risk of user impersonation if the machine has been\n   compromised.\n\
    \   When assessing the desired granularity of protection, protocol\n   designers\
    \ should take into account likely usage patterns,\n   implementation layers (see\
    \ below), and deployability.  If a protocol\n   is likely to be used only from\
    \ within a secure cluster of machines\n   (say, a Network Operations Center),\
    \ subnet granularity may be\n   appropriate.  By contrast, a security mechanism\
    \ peculiar to a single\n   application is best embedded in that application, rather\
    \ than inside\n   TCP; otherwise, deployment will be very difficult.\n"
- title: 2.4.  Implementation Layer
  contents:
  - "2.4.  Implementation Layer\n   Security mechanisms can be located at any layer.\
    \  In general, putting\n   a mechanism at a lower layer protects a wider variety\
    \ of higher-layer\n   protocols, but may not be able to protect them as well.\
    \  A link-layer\n   encryptor can protect not just IP, but even ARP packets. \
    \ However,\n   its reach is just that one link.  Conversely, a signed email message\n\
    \   is protected even if sent through many store-and-forward mail\n   gateways,\
    \ can identify the actual sender, and the signature can be\n   verified long after\
    \ the message is delivered.  However, only that one\n   type of message is protected.\
    \  Messages of similar formats, such as\n   some Netnews postings, are not protected\
    \ unless the mechanism is\n   specifically adapted and then implemented in the\
    \ news-handling\n   programs.\n"
- title: 3.  Standard Security Mechanisms
  contents:
  - '3.  Standard Security Mechanisms

    '
- title: 3.1.  One-Time Passwords
  contents:
  - "3.1.  One-Time Passwords\n   One-time password schemes, such as that described\
    \ in [RFC2289], are\n   very much stronger than conventional passwords.  The host\
    \ need not\n   store a copy of the user's password, nor is it ever transmitted\
    \ over\n   the network.  However, there are some risks.  Since the transmitted\n\
    \   string is derived from a user-typed password, guessing attacks may\n   still\
    \ be feasible.  (Indeed, a program to launch just this attack is\n   readily available.)\
    \  Furthermore, the user's ability to login\n   necessarily expires after a predetermined\
    \ number of uses.  While in\n   many cases this is a feature, an implementation\
    \ most likely needs to\n   provide a way to reinitialize the authentication database,\
    \ without\n   requiring that the new password be sent in the clear across the\n\
    \   network.\n   There are commercial hardware authentication tokens.  Apart from\
    \ the\n   session hijacking issue, support for such tokens (especially\n   challenge/response\
    \ tokens, where the server sends a different random\n   number for each authentication\
    \ attempt) may require extra protocol\n   messages.\n"
- title: 3.2.  HMAC
  contents:
  - "3.2.  HMAC\n   HMAC [RFC2104] is the preferred shared-secret authentication\n\
    \   technique.  If both sides know the same secret key, HMAC can be used\n   to\
    \ authenticate any arbitrary message.  This includes random\n   challenges, which\
    \ means that HMAC can be adapted to prevent replays\n   of old sessions.\n   An\
    \ unfortunate disadvantage of using HMAC for connection\n   authentication is\
    \ that the secret must be known in the clear by both\n   parties, making this\
    \ undesirable when keys are long-lived.\n   When suitable, HMAC should be used\
    \ in preference to older techniques,\n   notably keyed hash functions.  Simple\
    \ keyed hashes based on MD5\n   [RFC1321], such as that used in the BGP session\
    \ security mechanism\n   [RFC2385], are especially to be avoided in new protocols,\
    \ given the\n   hints of weakness in MD5.\n   HMAC can be implemented using any\
    \ secure hash function, including MD5\n   and SHA-1 [RFC3174].  SHA-1 is preferable\
    \ for new protocols because\n   it is more frequently used for this purpose and\
    \ may be more secure.\n   It is important to understand that an HMAC-based mechanism\
    \ needs to\n   be employed on every protocol data unit (aka packet).  It is a\n\
    \   mistake to use an HMAC-based system to authenticate the beginning of\n   a\
    \ TCP session and then send all remaining data without any\n   protection.\n \
    \  Attack programs exist that permit a TCP session to be stolen.  An\n   attacker\
    \ merely needs to use such a tool to steal a session after the\n   HMAC step is\
    \ performed.\n"
- title: 3.3.  IPsec
  contents:
  - "3.3.  IPsec\n   IPsec [RFC2401],[RFC2402],[RFC2406],[RFC2407],[RFC2411] is the\n\
    \   generic IP-layer encryption and authentication protocol.  As such, it\n  \
    \ protects all upper layers, including both TCP and UDP.  Its normal\n   granularity\
    \ of protection is host-to-host, host-to-gateway, and\n   gateway-to-gateway.\
    \  The specification does permit user-granularity\n   protection, but this is\
    \ comparatively rare.  As such, IPsec is\n   currently inappropriate when host-granularity\
    \ is too coarse.\n   Because IPsec is installed at the IP layer, it is rather\
    \ intrusive to\n   the networking code.  Implementing it generally requires either\
    \ new\n   hardware or a new protocol stack.  On the other hand, it is fairly\n\
    \   transparent to applications.  Applications running over IPsec can\n   have\
    \ improved security without changing their protocols at all.  But\n   at least\
    \ until IPsec is more widely deployed, most applications\n   should not assume\
    \ they are running atop IPsec as an alternative to\n   specifying their own security\
    \ mechanisms.  Most modern operating\n   systems have IPsec available; most routers\
    \ do not, at least for the\n   control path.  An application using TLS is more\
    \ likely to be able to\n   assert application-specific to take advantage of its\
    \ authentication.\n   The key management for IPsec can use either certificates\
    \ or shared\n   secrets.  For all the obvious reasons, certificates are preferred;\n\
    \   however, they may present more of a headache for the system manager.\n   There\
    \ is strong potential for conflict between IPsec and NAT\n   [RFC2993].  NAT does\
    \ not easily coexist with any protocol containing\n   embedded IP address; with\
    \ IPsec, every packet, for every protocol,\n   contains such addresses, if only\
    \ in the headers.  The conflict can\n   sometimes be avoided by using tunnel mode,\
    \ but that is not always an\n   appropriate choice for other reasons.  There is\
    \ ongoing work to make\n   IPsec pass through NAT more easily [NATIKE].\n   Most\
    \ current IPsec usage is for virtual private networks.  Assuming\n   that the\
    \ other constraints are met, IPsec is the security protocol of\n   choice for\
    \ VPN-like situations, including the remote access scenario\n   where a single\
    \ machine tunnels back into its home network over the\n   internet using IPsec.\n"
- title: 3.4.  TLS
  contents:
  - "3.4.  TLS\n   TLS [RFC2246] provides an encrypted, authenticated channel that\
    \ runs\n   on top of TCP.  While TLS was originally designed for use by Web\n\
    \   browsers, it is by no means restricted to such.  In general, though,\n   each\
    \ application that wishes to use TLS will need to be converted\n   individually.\n\
    \   Generally, the server side is always authenticated by a certificate.\n   Clients\
    \ may possess certificates, too, providing mutual\n   authentication, though this\
    \ is rarely deployed.  It's an unfortunate\n   reality that even server side authentication\
    \ it not as secure in\n   practice as the cryptography would imply because most\
    \ implementations\n   allow users to ignore authentication failures (by clicking\
    \ OK to a\n   warning) and most users routinely do so [Bell98].  Designers should\n\
    \   thus be wary of demanding plaintext passwords, even over TLS-\n   protected\
    \ connections.  (This requirement can be relaxed if it is\n   likely that implementations\
    \ will be able to verify the authenticity\n   and authorization of the server's\
    \ certificate.)\n   Although application modification is generally required to\
    \ make use\n   of TLS, there exist toolkits, both free and commercial, that provide\n\
    \   implementations.  These are designed to be incorporated into the\n   application's\
    \ code.  An application using TLS is more likely to be\n   able to assert application\
    \ specific certificate policies than one\n   using IPsec.\n"
- title: 3.5.  SASL
  contents:
  - "3.5.  SASL\n   SASL [RFC2222] is a framework for negotiating an authentication\
    \ and\n   encryption mechanism to be used over a TCP stream.  As such, its\n \
    \  security properties are those of the negotiated mechanism.\n   Specifically,\
    \ unless the negotiated mechanism authenticates all of\n   the subsequent messages\
    \ or underlying protection protocol such as TLS\n   is used, TCP connections are\
    \ vulnerable to session stealing.\n   If you need to use TLS (or IPSec) under\
    \ SASL, why bother with SASL in\n   the first place? Why not simply use the authentication\
    \ facilities of\n   TLS and be done with it?\n   The answer here is subtle.  TLS\
    \ makes extensive use of certificates\n   for authentication.  As commonly deployed,\
    \ only servers have\n   certificates, whereas clients go unauthenticated (at least\
    \ by the TLS\n   processing itself).\n   SASL permits the use of more traditional\
    \ client authentication\n   technologies, such as passwords (one-time or otherwise).\
    \  A powerful\n   combination is TLS for underlying protection and authentication\
    \ of\n   the server, and a SASL-based system for authenticating clients.  Care\n\
    \   must be taken to avoid man-in-the-middle vulnerabilities when\n   different\
    \ authentication techniques are used in different directions.\n"
- title: 3.6.  GSS-API
  contents:
  - "3.6.  GSS-API\n   GSS-API [RFC2744] provides a framework for applications to\
    \ use when\n   they require authentication, integrity, and/or confidentiality.\n\
    \   Unlike SASL, GSS-API can be used easily with UDP-based applications.\n   It\
    \ provides for the creation of opaque authentication tokens (aka\n   chunks of\
    \ memory) which may be embedded in a protocol's data units.\n   Note that the\
    \ security of GSS-API-protected protocols depends on the\n   underlying security\
    \ mechanism; this must be evaluated independently.\n   Similar considerations\
    \ apply to interoperability, of course.\n"
- title: 3.7.  DNSSEC
  contents:
  - "3.7.  DNSSEC\n   DNSSEC [RFC2535] digitally signs DNS records.  It is an essential\n\
    \   tool for protecting against DNS cache contamination attacks [Bell95];\n  \
    \ these in turn can be used to defeat name-based authentication and to\n   redirect\
    \ traffic to or past an attacker.  The latter makes DNSSEC an\n   essential component\
    \ of some other security mechanisms, notably IPsec.\n   Although not widely deployed\
    \ on the Internet at the time of the\n   writing of this document, it offers the\
    \ potential to provide a secure\n   mechanism for mapping domain names to IP protocol\
    \ addresses.  It may\n   also be used to securely associate other information\
    \ with a DNS name.\n   This information may be as simple as a service that is\
    \ supported on a\n   given node, or a key to be used with IPsec for negotiating\
    \ a secure\n   session.  Note that the concept of storing general purpose\n  \
    \ application keys in the DNS has been deprecated [RFC3445], but\n   standardization\
    \ of storing keys for particular applications - in\n   particular IPsec - is proceeding.\n"
- title: 3.8.  Security/Multipart
  contents:
  - "3.8.  Security/Multipart\n   Security/Multiparts [RFC1847] are the preferred\
    \ mechanism for\n   protecting email.  More precisely, it is the MIME framework\
    \ within\n   which encryption and/or digital signatures are embedded.  Both S/MIME\n\
    \   and OpenPGP (see below) use Security/Multipart for their encoding.\n   Conforming\
    \ mail readers can easily recognize and process the\n   cryptographic portions\
    \ of the mail.\n   Security/Multiparts represents one form of \"object security\"\
    , where\n   the object of interest to the end user is protected, independent of\n\
    \   transport mechanism, intermediate storage, etc.  Currently, there is\n   no\
    \ general form of object protection available in the Internet.\n   For a good\
    \ example of using S/MIME outside the context of email, see\n   Session Initiation\
    \ Protocol [RFC 3261].\n"
- title: 3.9.  Digital Signatures
  contents:
  - "3.9.  Digital Signatures\n   One of the strongest forms of challenge/response\
    \ authentication is\n   based on digital signatures.  Using public key cryptography\
    \ is\n   preferable to schemes based on secret key ciphers because no server\n\
    \   needs a copy of the client's secret.  Rather, the client has a\n   private\
    \ key; servers have the corresponding public key.\n   Using digital signatures\
    \ properly is tricky.  A client should never\n   sign the exact challenge sent\
    \ to it, since there are several subtle\n   number-theoretic attacks that can\
    \ be launched in such situations.\n   The Digital Signature Standard [DSS] and\
    \ RSA [RSA] are both good\n   choices; each has its advantages.  Signing with\
    \ DSA requires the use\n   of good random numbers [RFC1750].  If the enemy can\
    \ recover the\n   random number used for any given signature, or if you use the\
    \ same\n   random number for two different documents, your private key can be\n\
    \   recovered.  DSS has much better performance than RSA for generating\n   new\
    \ private keys, and somewhat better performance generating\n   signatures, while\
    \ RSA has much better performance for verifying\n   signatures.\n"
- title: 3.10.  OpenPGP and S/MIME
  contents:
  - "3.10.  OpenPGP and S/MIME\n   Digital signatures can be used to build \"object\
    \ security\"\n   applications which can be used to protect data in store and forward\n\
    \   protocols such as electronic mail.\n   At this writing, two different secure\
    \ mail protocols, OpenPGP\n   [OpenPGP] and S/MIME [S/MIME], have been proposed\
    \ to replace PEM\n   [PEM].  It is not clear which, if either, will succeed. \
    \ While\n   specified for use with secure mail, both can be adapted to protect\n\
    \   data carried by other protocols.  Both use certificates to identify\n   users;\
    \ both can provide secrecy and authentication of mail messages;\n   however, the\
    \ certificate formats are very different.  Historically,\n   the difference between\
    \ PGP-based mail and S/MIME-based mail has been\n   the style of certificate chaining.\
    \  In S/MIME, users possess X.509\n   certificates; the certification graph is\
    \ a tree with a very small\n   number of roots.  By contrast, PGP uses the so-called\
    \ \"web of trust\",\n   where any user can sign anyone else's certificate.  This\n\
    \   certification graph is really an arbitrary graph or set of graphs.\n   With\
    \ any certificate scheme, trust depends on two primary\n   characteristics.  First,\
    \ it must start from a known-reliable source,\n   either an X.509 root, or someone\
    \ highly trusted by the verifier,\n   often him or herself.  Second, the chain\
    \ of signatures must be\n   reliable.  That is, each node in the certification\
    \ graph is crucial;\n   if it is dishonest or has been compromised, any certificates\
    \ it has\n   vouched for cannot be trusted.  All other factors being equal (and\n\
    \   they rarely are), shorter chains are preferable.\n   Some of the differences\
    \ reflect a tension between two philosophical\n   positions represented by these\
    \ technologies.  Others resulted from\n   having separate design teams.\n   S/MIME\
    \ is designed to be \"fool proof\".  That is, very little end-user\n   configuration\
    \ is required. Specifically, end-users do not need to be\n   aware of trust relationships,\
    \ etc.  The idea is that if an S/MIME\n   client says, \"This signature is valid\"\
    , the user should be able to\n   \"trust\" that statement at face value without\
    \ needing to understand\n   the underlying implications.\n   To achieve this,\
    \ S/MIME is typically based on a limited number of\n   \"root\" Certifying Authorities\
    \ (CAs).  The goal is to build a global\n   trusted certificate infrastructure.\n\
    \   The down side to this approach is that it requires a deployed public\n   key\
    \ infrastructure before it will work.  Two end-users may not be\n   able to simply\
    \ obtain S/MIME-capable software and begin communicating\n   securely.  This is\
    \ not a limitation of the protocol, but a typical\n   configuration restriction\
    \ for commonly available software.  One or\n   both of them may need to obtain\
    \ a certificate from a mutually trusted\n   CA; furthermore, that CA must already\
    \ be trusted by their mail\n   handling software.  This process may involve cost\
    \ and legal\n   obligations.  This ultimately results in the technology being\
    \ harder\n   to deploy, particularly in an environment where end-users do not\n\
    \   necessarily appreciate the value received for the hassle incurred.\n   The\
    \ PGP \"web of trust\" approach has the advantage that two end-users\n   can just\
    \ obtain PGP software and immediately begin to communicate\n   securely.  No infrastructure\
    \ is required and no fees and legal\n   agreements need to be signed to proceed.\
    \  As such PGP appeals to\n   people who need to establish ad-hoc security associations.\n\
    \   The down side to PGP is that it requires end-users to have an\n   understanding\
    \ of the underlying security technology in order to make\n   effective use of\
    \ it.  Specifically it is fairly easy to fool a naive\n   users to accept a \"\
    signed\" message that is in fact a forgery.\n   To date PGP has found great acceptance\
    \ between security-aware\n   individuals who have a need for secure e-mail in\
    \ an environment\n   devoid of the necessary global infrastructure.\n   By contrast,\
    \ S/MIME works well in a corporate setting where a secure\n   internal CA system\
    \ can be deployed.  It does not require a lot of\n   end-user security knowledge.\
    \  S/MIME can be used between institutions\n   by carefully setting up cross certification,\
    \ but this is harder to do\n   than it seems.\n   As of this writing a global\
    \ certificate infrastructure continues to\n   elude us.  Questions about a suitable\
    \ business model, as well as\n   privacy considerations, may prevent one from\
    \ ever emerging.\n"
- title: 3.11.  Firewalls and Topology
  contents:
  - "3.11.  Firewalls and Topology\n   Firewalls are a topological defense mechanism.\
    \  That is, they rely on\n   a well-defined boundary between the good \"inside\"\
    \ and the bad\n   \"outside\" of some domain, with the firewall mediating the\
    \ passage of\n   information.  While firewalls can be very valuable if employed\n\
    \   properly, there are limits to their ability to protect a network.\n   The\
    \ first limitation, of course, is that firewalls cannot protect\n   against inside\
    \ attacks.  While the actual incidence rate of such\n   attacks is not known (and\
    \ is probably unknowable), there is no doubt\n   that it is substantial, and arguably\
    \ constitutes a majority of\n   security problems.  More generally, given that\
    \ firewalls require a\n   well-delimited boundary, to the extent that such a boundary\
    \ does not\n   exist, firewalls do not help.  Any external connections, whether\
    \ they\n   are protocols that are deliberately passed through the firewall,\n\
    \   links that are tunneled through, unprotected wireless LANs, or direct\n  \
    \ external connections from nominally-inside hosts, weaken the\n   protection.\
    \  Firewalls tend to become less effective over time as\n   users tunnel protocols\
    \ through them and may have inadequate security\n   on the tunnel endpoints. \
    \ If the tunnels are encrypted, there is no\n   way for the firewall to censor\
    \ them.  An oft-cited advantage of\n   firewalls is that they hide the existence\
    \ of internal hosts from\n   outside eyes.  Given the amount of leakage, however,\
    \ the likelihood\n   of successfully hiding machines is rather low.\n   In a more\
    \ subtle vein, firewalls hurt the end-to-end model of the\n   Internet and its\
    \ protocols.  Indeed, not all protocols can be passed\n   safely or easily through\
    \ firewalls.  Sites that rely on firewalls for\n   security may find themselves\
    \ cut off from new and useful aspects of\n   the Internet.\n   Firewalls work\
    \ best when they are used as one element of a total\n   security structure.  For\
    \ example, a strict firewall may be used to\n   separate an exposed Web server\
    \ from a back-end database, with the\n   only opening the communication channel\
    \ between the two.  Similarly, a\n   firewall that permitted only encrypted tunnel\
    \ traffic could be used\n   to secure a piece of a VPN.  On the other hand, in\
    \ that case the\n   other end of the VPN would need to be equally secured.\n"
- title: 3.12.  Kerberos
  contents:
  - "3.12.  Kerberos\n   Kerberos [RFC1510] provides a mechanism for two entities\
    \ to\n   authenticate each other and exchange keying material.  On the client\n\
    \   side, an application obtains a Kerberos \"ticket\" and \"authenticator\".\n\
    \   These items, which should be considered opaque data, are then\n   communicated\
    \ from client to server.  The server can then verify their\n   authenticity. \
    \ Both sides may then ask the Kerberos software to\n   provide them with a session\
    \ key which can be used to protect or\n   encrypt data.\n   Kerberos may be used\
    \ by itself in a protocol.  However, it is also\n   available as a mechanism under\
    \ SASL and GSSAPI.  It has some known\n   vulnerabilities [KRBATTACK] [KRBLIM]\
    \ [KRB4WEAK], but it can be used\n   securely.\n"
- title: 3.13.  SSH
  contents:
  - "3.13.  SSH\n   SSH provides a secure connection between client and server.  It\n\
    \   operates very much like TLS; however, it is optimized as a protocol\n   for\
    \ remote connections on terminal-like devices.  One of its more\n   innovative\
    \ features is its support for \"tunneling\" other protocols\n   over the SSH-protected\
    \ TCP connection.  This feature has permitted\n   knowledgeable security people\
    \ to perform such actions as reading and\n   sending e-mail or news via insecure\
    \ servers over an insecure network.\n   It is not a substitute for a true VPN,\
    \ but it can often be used in\n   place of one.\n"
- title: 4.  Insecurity Mechanisms
  contents:
  - "4.  Insecurity Mechanisms\n   Some common security mechanisms are part of the\
    \ problem rather than\n   part of the solution.\n"
- title: 4.1.  Plaintext Passwords
  contents:
  - "4.1.  Plaintext Passwords\n   Plaintext passwords are the most common security\
    \ mechanism in use\n   today.  Unfortunately, they are also the weakest.  When\
    \ not protected\n   by an encryption layer, they are completely unacceptable.\
    \  Even when\n   used with encryption, plaintext passwords are quite weak, since\
    \ they\n   must be transmitted to the remote system.  If that system has been\n\
    \   compromised or if the encryption layer does not include effective\n   authentication\
    \ of the server to the client, an enemy can collect the\n   passwords and possibly\
    \ use them against other targets.\n   Another weakness arises because of common\
    \ implementation techniques.\n   It is considered good form [MT79] for the host\
    \ to store a one-way\n   hash of the users' passwords, rather than their plaintext\
    \ form.\n   However, that may preclude migrating to stronger authentication\n\
    \   mechanisms, such as HMAC-based challenge/response.\n   The strongest attack\
    \ against passwords, other than eavesdropping, is\n   password-guessing.  With\
    \ a suitable program and dictionary (and these\n   are widely available), 20-30%\
    \ of passwords can be guessed in most\n   environments [Klein90].\n"
- title: 4.2.  Address-Based Authentication
  contents:
  - "4.2.  Address-Based Authentication\n   Another common security mechanism is address-based\
    \ authentication. At\n   best, it can work in highly constrained environments.\
    \  If your\n   environment consists of a small number of machines, all tightly\n\
    \   administered, secure systems run by trusted users, and if the network\n  \
    \ is guarded by a router that blocks source-routing and prevents\n   spoofing\
    \ of your source addresses, and you know there are no wireless\n   bridges, and\
    \ if you restrict address-based authentication to machines\n   on that network,\
    \ you are probably safe.  But these conditions are\n   rarely met.\n   Among the\
    \ threats are ARP-spoofing, abuse of local proxies,\n   renumbering, routing table\
    \ corruption or attacks, DHCP, IP address\n   spoofing (a particular risk for\
    \ UDP-based protocols), sequence number\n   guessing, and source-routed packets.\
    \  All of these can be quite\n   potent.\n"
- title: 4.3.  Name-Based Authentication
  contents:
  - "4.3.  Name-Based Authentication\n   Name-based authentication has all of the\
    \ problems of address-based\n   authentication and adds new ones: attacks on the\
    \ DNS [Bell95] and\n   lack of a one to one mapping between addresses and names.\
    \  At a\n   minimum, a process that retrieves a host name from the DNS should\n\
    \   retrieve the corresponding address records and cross-check.\n   Techniques\
    \ such as DNS cache contamination can often negate such\n   checks.\n   DNSSEC\
    \ provides protection against this sort of attack.  However, it\n   does nothing\
    \ to enhance the reliability of the underlying address.\n   Further, the technique\
    \ generates a lot of false alarms.  These\n   lookups do not provide reliable\
    \ information to a machine, though they\n   might be a useful debugging tool for\
    \ humans and could be useful in\n   logs when trying to reconstruct how and attack\
    \ took place.\n"
- title: 5.  Security Considerations
  contents:
  - "5.  Security Considerations\n   No security mechanisms are perfect.  If nothing\
    \ else, any network-\n   based security mechanism can be thwarted by compromise\
    \ of the\n   endpoints.  That said, each of the mechanisms described here has\
    \ its\n   own limitations.  Any decision to adopt a given mechanism should\n \
    \  weigh all of the possible failure modes.  These in turn should be\n   weighed\
    \ against the risks to the endpoint of a security failure.\n"
- title: 6.  IANA Considerations
  contents:
  - "6.  IANA Considerations\n   There are no IANA considerations regarding this document.\n"
- title: 7.  Acknowledgements
  contents:
  - "7.  Acknowledgements\n   Brian Carpenter, Tony Hain, and Marcus Leech made a\
    \ number of useful\n   suggestions.  Much of the substance comes from the participants\
    \ in\n   the IAB Security Architecture Workshop.\n"
- title: 8.  Informative References
  contents:
  - "8.  Informative References\n   [Bell95]    \"Using the Domain Name System for\
    \ System Break-Ins\".\n               Proc.  Fifth Usenix Security Conference,\
    \ 1995.\n   [Bell98]    \"Cryptography and the Internet\", S.M. Bellovin, in\n\
    \               Proceedings of CRYPTO '98, August 1998.\n   [DSS]       \"Digital\
    \ Signature Standard\".  NIST.  May 1994.  FIPS\n               186.\n   [Klein90]\
    \   \"Foiling the Cracker: A Survey of, and Implications to,\n               Password\
    \ Security\". D. Klein. Usenix UNIX Security\n               Workshop, August\
    \ 1990.\n   [KRBATTACK] \"A Real-World Analysis of Kerberos Password Security\"\
    .\n               T. Wu. Network and Distributed System Security Symposium\n \
    \              (NDSS '99).  January 1999.\n   [KRBLIM]    \"Limitations of the\
    \ Kerberos Authentication System\".\n               Proceedings of the 1991 Winter\
    \ USENIX Conference, 1991.\n   [KRB4WEAK]  \"Misplaced trust: Kerberos 4 session\
    \ keys\".  Proceedings\n               of the Internet Society Network and Distributed\
    \ Systems\n               Security Symposium, March 1997.\n   [MT79]      \"UNIX\
    \ Password Security\", R.H. Morris and K.  Thompson,\n               Communications\
    \ of the ACM. November 1979.\n   [NATIKE]    Kivinen, T., et al., \"Negotiation\
    \ of NAT-Traversal in the\n               IKE\", Work in Progress, June 2002.\n\
    \   [RFC1321]   Rivest, R., \"The MD5 Message-Digest Algorithm\", RFC 1321,\n\
    \               April 1992.\n   [RFC1510]   Kohl, J. and C. Neuman, \"The Kerberos\
    \ Network\n               Authentication Service (V5)\", RFC 1510, September 1993.\n\
    \   [RFC1750]   Eastlake, D., Crocker, S. and J. Schiller, \"Randomness\n    \
    \           Recommendations for Security\", RFC 1750, December 1994.\n   [RFC1847]\
    \   Galvin, J., Murphy, S., Crocker, S. and N. Freed,\n               \"Security\
    \ Multiparts for MIME: Multipart/Signed and\n               Multipart/Encrypted\"\
    , RFC 1847, October 1995.\n   [RFC2104]   Krawczyk, H., Bellare, M. and R. Canetti,\
    \ \"HMAC:  Keyed-\n               Hashing for Message Authentication\", RFC 2104,\
    \ February\n               1997.\n   [RFC2222]   Myers, J., \"Simple Authentication\
    \ and Security Layer\n               (SASL)\", RFC 2222, October 1997.\n   [RFC2246]\
    \   Dierks, T. and C. Allen, \"The TLS Protocol Version 1.0\",\n             \
    \  RFC 2246, January 1999.\n   [RFC2289]   Haller, N., Metz, C., Nesser, P. and\
    \ M. Straw, \"A One-\n               Time Password System\", STD 61, RFC 2289,\
    \ February 1998.\n   [RFC2316]   Bellovin, S., \"Report of the IAB Security Architecture\n\
    \               Workshop\", RFC 2316, April 1998.\n   [RFC2385]   Hefferman, A.,\
    \ \"Protection of BGP Sessions via the TCP\n               MD5 Signature Option\"\
    , RFC 2385, August 1998.\n   [RFC2401]   Kent, S. and R. Atkinson, \"Security\
    \ Architecture for the\n               Internet Protocol\", RFC 2401, November\
    \ 1998.\n   [RFC2402]   Kent, S. and R. Atkinson, \"IP Authentication Header\"\
    , RFC\n               2402, November 1998.\n   [RFC2406]   Kent, S. and R. Atkinson,\
    \ \"IP Encapsulating Security\n               Payload (ESP)\", RFC 2406, November\
    \ 1998.\n   [RFC2407]   Piper, D., \"The Internet IP Security Domain of\n    \
    \           Interpretation for ISAKMP\", RFC 2407, November 1998.\n   [RFC2411]\
    \   Thayer, R., Doraswamy, N. and R. Glenn, \"IP Security\n               Document\
    \ Roadmap\", RFC 2411, November 1998.\n   [RFC2535]   Eastlake, D., \"Domain Name\
    \ System Security Extensions\",\n               RFC 2535, March 1999.\n   [RFC2744]\
    \   Wray, J., \"Generic Security Service API Version 2:  C-\n               bindings\"\
    , RFC 2744, January 2000.\n   [RFC2993]   Hain, T., \"Architectural Implications\
    \ of NAT\", RFC 2993,\n               November 2000.\n   [RFC3174]   Eastlake,\
    \ D. and P. Jones, \"US Secure Hash Algorithm 1\n               (SHA1)\", RFC\
    \ 3174, September 2001.\n   [RFC3261]   Rosenberg, J., Schulzrinne, H., Camarillo,\
    \ R., Johnston,\n               A., Peterson, J., Sparks, R., Handley, M. and\
    \ E.\n               Schooler, \"SIP:  Session Initiation Protocol\", RFC 3261,\n\
    \               June 2002.\n   [RFC3445]   Massey, D. and S. Rose, \"Limiting\
    \ the Scope of the KEY\n               Resource Record (RR)\", RFC 3445, December\
    \ 2002.\n   [RSA]       Rivest, R., Shamir, A. and L. Adleman, \"A Method for\n\
    \               Obtaining Digital Signatures and Public-Key\n               Cryptosystems\"\
    , Communications of the ACM, February 1978.\n"
- title: 9.  Intellectual Property Statement
  contents:
  - "9.  Intellectual Property Statement\n   The IETF takes no position regarding\
    \ the validity or scope of any\n   intellectual property or other rights that\
    \ might be claimed to\n   pertain to the implementation or use of the technology\
    \ described in\n   this document or the extent to which any license under such\
    \ rights\n   might or might not be available; neither does it represent that it\n\
    \   has made any effort to identify any such rights.  Information on the\n   IETF's\
    \ procedures with respect to rights in standards-track and\n   standards-related\
    \ documentation can be found in BCP-11.  Copies of\n   claims of rights made available\
    \ for publication and any assurances of\n   licenses to be made available, or\
    \ the result of an attempt made to\n   obtain a general license or permission\
    \ for the use of such\n   proprietary rights by implementors or users of this\
    \ specification can\n   be obtained from the IETF Secretariat.\n   The IETF invites\
    \ any interested party to bring to its attention any\n   copyrights, patents or\
    \ patent applications, or other proprietary\n   rights which may cover technology\
    \ that may be required to practice\n   this standard.  Please address the information\
    \ to the IETF Executive\n   Director.\n"
- title: 10.  Author Information
  contents:
  - "10.  Author Information\n   This document is a publication of the Internet Architecture\
    \ Board.\n   Internet Architecture Board Members at the time this document was\n\
    \   completed were:\n   Bernard Aboba\n   Harald Alvestrand\n   Rob Austein\n\
    \   Leslie Daigle, Chair\n   Patrik Faltstrom\n   Sally Floyd\n   Jun-ichiro Itojun\
    \ Hagino\n   Mark Handley\n   Geoff Huston\n   Charlie Kaufman\n   James Kempf\n\
    \   Eric Rescorla\n   Michael StJohns\n   Internet Architecture Board\n   EMail:\
    \ iab@iab.org\n   Steven M. Bellovin, Editor\n   EMail: bellovin@acm.org\n   Jeffrey\
    \ I. Schiller, Editor\n   EMail: jis@mit.edu\n   Charlie Kaufman, Editor\n   EMail:\
    \ charliek@microsoft.com\n"
- title: 11.  Full Copyright Statement
  contents:
  - "11.  Full Copyright Statement\n   Copyright (C) The Internet Society (2003).\
    \  All Rights Reserved.\n   This document and translations of it may be copied\
    \ and furnished to\n   others, and derivative works that comment on or otherwise\
    \ explain it\n   or assist in its implementation may be prepared, copied, published\n\
    \   and distributed, in whole or in part, without restriction of any\n   kind,\
    \ provided that the above copyright notice and this paragraph are\n   included\
    \ on all such copies and derivative works.  However, this\n   document itself\
    \ may not be modified in any way, such as by removing\n   the copyright notice\
    \ or references to the Internet Society or other\n   Internet organizations, except\
    \ as needed for the purpose of\n   developing Internet standards in which case\
    \ the procedures for\n   copyrights defined in the Internet Standards process\
    \ must be\n   followed, or as required to translate it into languages other than\n\
    \   English.\n   The limited permissions granted above are perpetual and will\
    \ not be\n   revoked by the Internet Society or its successors or assignees.\n\
    \   This document and the information contained herein is provided on an\n   \"\
    AS IS\" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING\n   TASK FORCE\
    \ DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING\n   BUT NOT LIMITED\
    \ TO ANY WARRANTY THAT THE USE OF THE INFORMATION\n   HEREIN WILL NOT INFRINGE\
    \ ANY RIGHTS OR ANY IMPLIED WARRANTIES OF\n   MERCHANTABILITY OR FITNESS FOR A\
    \ PARTICULAR PURPOSE.\n"
- title: Acknowledgement
  contents:
  - "Acknowledgement\n   Funding for the RFC Editor function is currently provided\
    \ by the\n   Internet Society.\n"
