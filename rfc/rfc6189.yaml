- title: __initial_text__
  contents:
  - '         ZRTP: Media Path Key Agreement for Unicast Secure RTP

    '
- title: Abstract
  contents:
  - "Abstract\n   This document defines ZRTP, a protocol for media path Diffie-Hellman\n\
    \   exchange to agree on a session key and parameters for establishing\n   unicast\
    \ Secure Real-time Transport Protocol (SRTP) sessions for Voice\n   over IP (VoIP)\
    \ applications.  The ZRTP protocol is media path keying\n   because it is multiplexed\
    \ on the same port as RTP and does not\n   require support in the signaling protocol.\
    \  ZRTP does not assume a\n   Public Key Infrastructure (PKI) or require the complexity\
    \ of\n   certificates in end devices.  For the media session, ZRTP provides\n\
    \   confidentiality, protection against man-in-the-middle (MiTM) attacks,\n  \
    \ and, in cases where the signaling protocol provides end-to-end\n   integrity\
    \ protection, authentication.  ZRTP can utilize a Session\n   Description Protocol\
    \ (SDP) attribute to provide discovery and\n   authentication through the signaling\
    \ channel.  To provide best effort\n   SRTP, ZRTP utilizes normal RTP/AVP (Audio-Visual\
    \ Profile) profiles.\n   ZRTP secures media sessions that include a voice media\
    \ stream and can\n   also secure media sessions that do not include voice by using\
    \ an\n   optional digital signature.\n"
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This document is not an Internet Standards Track specification;\
    \ it is\n   published for informational purposes.\n   This document is a product\
    \ of the Internet Engineering Task Force\n   (IETF).  It represents the consensus\
    \ of the IETF community.  It has\n   received public review and has been approved\
    \ for publication by the\n   Internet Engineering Steering Group (IESG).  Not\
    \ all documents\n   approved by the IESG are a candidate for any level of Internet\n\
    \   Standard; see Section 2 of RFC 5741.\n   Information about the current status\
    \ of this document, any errata,\n   and how to provide feedback on it may be obtained\
    \ at\n   http://www.rfc-editor.org/info/rfc6189.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (c) 2011 IETF Trust and the persons identified\
    \ as the\n   document authors.  All rights reserved.\n   This document is subject\
    \ to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n\
    \   (http://trustee.ietf.org/license-info) in effect on the date of\n   publication\
    \ of this document.  Please review these documents\n   carefully, as they describe\
    \ your rights and restrictions with respect\n   to this document.  Code Components\
    \ extracted from this document must\n   include Simplified BSD License text as\
    \ described in Section 4.e of\n   the Trust Legal Provisions and are provided\
    \ without warranty as\n   described in the Simplified BSD License.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1. Introduction ....................................................4\n\
    \   2. Terminology .....................................................5\n  \
    \ 3. Overview ........................................................6\n    \
    \  3.1. Key Agreement Modes ........................................7\n      \
    \     3.1.1. Diffie-Hellman Mode Overview ........................7\n        \
    \   3.1.2. Preshared Mode Overview .............................9\n          \
    \ 3.1.3. Multistream Mode Overview ...........................9\n   4. Protocol\
    \ Description ...........................................10\n      4.1. Discovery\
    \ .................................................10\n           4.1.1. Protocol\
    \ Version Negotiation .......................11\n           4.1.2. Algorithm Negotiation\
    \ ..............................13\n      4.2. Commit Contention .........................................14\n\
    \      4.3. Matching Shared Secret Determination ......................15\n  \
    \         4.3.1. Calculation and Comparison of Hashes of\n                  Shared\
    \ Secrets .....................................17\n           4.3.2. Handling\
    \ a Shared Secret Cache Mismatch ............18\n      4.4. DH and Non-DH Key\
    \ Agreements ..............................19\n           4.4.1. Diffie-Hellman\
    \ Mode ................................19\n                  4.4.1.1. Hash Commitment\
    \ in Diffie-Hellman Mode ....20\n                  4.4.1.2. Responder Behavior\
    \ in\n                           Diffie-Hellman Mode .......................21\n\
    \                  4.4.1.3. Initiator Behavior in\n                          \
    \ Diffie-Hellman Mode .......................22\n                  4.4.1.4. Shared\
    \ Secret Calculation for DH Mode .....22\n           4.4.2. Preshared Mode .....................................25\n\
    \                  4.4.2.1. Commitment in Preshared Mode ..............25\n  \
    \                4.4.2.2. Initiator Behavior in Preshared Mode ......26\n    \
    \              4.4.2.3. Responder Behavior in Preshared Mode ......26\n      \
    \            4.4.2.4. Shared Secret Calculation for\n                        \
    \   Preshared Mode ............................27\n           4.4.3. Multistream\
    \ Mode ...................................28\n                  4.4.3.1. Commitment\
    \ in Multistream Mode ............29\n                  4.4.3.2. Shared Secret\
    \ Calculation for\n                           Multistream Mode ..........................29\n\
    \      4.5. Key Derivations ...........................................31\n  \
    \         4.5.1. The ZRTP Key Derivation Function ...................31\n    \
    \       4.5.2. Deriving ZRTPSess Key and SAS in DH or\n                  Preshared\
    \ Modes ....................................32\n           4.5.3. Deriving the\
    \ Rest of the Keys from s0 ..............33\n      4.6. Confirmation ..............................................35\n\
    \           4.6.1. Updating the Cache of Shared Secrets ...............35\n  \
    \                4.6.1.1. Cache Update Following a Cache Mismatch ...36\n    \
    \  4.7. Termination ...............................................37\n      \
    \     4.7.1. Termination via Error Message ......................37\n        \
    \   4.7.2. Termination via GoClear Message ....................37\n          \
    \        4.7.2.1. Key Destruction for GoClear Message .......39\n           4.7.3.\
    \ Key Destruction at Termination .....................40\n      4.8. Random Number\
    \ Generation ..................................40\n      4.9. ZID and Cache Operation\
    \ ...................................41\n           4.9.1. Cacheless Implementations\
    \ ..........................42\n   5. ZRTP Messages ..................................................42\n\
    \      5.1. ZRTP Message Formats ......................................44\n  \
    \         5.1.1. Message Type Block .................................44\n    \
    \       5.1.2. Hash Type Block ....................................45\n      \
    \            5.1.2.1. Negotiated Hash and MAC Algorithm .........46\n        \
    \          5.1.2.2. Implicit Hash and MAC Algorithm ...........47\n          \
    \ 5.1.3. Cipher Type Block ..................................47\n           5.1.4.\
    \ Auth Tag Type Block ................................48\n           5.1.5. Key\
    \ Agreement Type Block ...........................49\n           5.1.6. SAS Type\
    \ Block .....................................51\n           5.1.7. Signature Type\
    \ Block ...............................52\n      5.2. Hello Message .............................................53\n\
    \      5.3. HelloACK Message ..........................................56\n  \
    \    5.4. Commit Message ............................................56\n    \
    \  5.5. DHPart1 Message ...........................................60\n      5.6.\
    \ DHPart2 Message ...........................................62\n      5.7. Confirm1\
    \ and Confirm2 Messages ............................63\n      5.8. Conf2ACK Message\
    \ ..........................................66\n      5.9. Error Message .............................................66\n\
    \      5.10. ErrorACK Message .........................................68\n  \
    \    5.11. GoClear Message ..........................................68\n    \
    \  5.12. ClearACK Message .........................................69\n      5.13.\
    \ SASrelay Message .........................................69\n      5.14. RelayACK\
    \ Message .........................................72\n      5.15. Ping Message\
    \ .............................................72\n      5.16. PingACK Message\
    \ ..........................................73\n   6. Retransmissions ................................................74\n\
    \   7. Short Authentication String ....................................77\n  \
    \    7.1. SAS Verified Flag .........................................78\n    \
    \  7.2. Signing the SAS ...........................................79\n      \
    \     7.2.1. OpenPGP Signatures .................................81\n        \
    \   7.2.2. ECDSA Signatures with X.509v3 Certs ................82\n          \
    \ 7.2.3. Signing the SAS without a PKI ......................83\n      7.3. Relaying\
    \ the SAS through a PBX ............................84\n           7.3.1. PBX\
    \ Enrollment and the PBX Enrollment Flag .........87\n   8. Signaling Interactions\
    \ .........................................89\n      8.1. Binding the Media Stream\
    \ to the Signaling Layer\n           via the Hello Hash ........................................90\n\
    \           8.1.1. Integrity-Protected Signaling Enables\n                  Integrity-Protected\
    \ DH Exchange ....................92\n      8.2. Deriving the SRTP Secret (srtps)\
    \ from the\n           Signaling Layer ...........................................93\n\
    \      8.3. Codec Selection for Secure Media ..........................94\n  \
    \ 9. False ZRTP Packet Rejection ....................................95\n   10.\
    \ Intermediary ZRTP Devices .....................................97\n   11. The\
    \ ZRTP Disclosure Flag ......................................98\n      11.1. Guidelines\
    \ on Proper Implementation of the\n            Disclosure Flag .........................................100\n\
    \   12. Mapping between ZID and AOR (SIP URI) ........................100\n  \
    \ 13. IANA Considerations ..........................................102\n   14.\
    \ Media Security Requirements ..................................102\n   15. Security\
    \ Considerations ......................................104\n      15.1. Self-Healing\
    \ Key Continuity Feature .....................107\n   16. Acknowledgments ..............................................108\n\
    \   17. References ...................................................109\n  \
    \    17.1. Normative References ....................................109\n    \
    \  17.2. Informative References ..................................111\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   ZRTP is a key agreement protocol that performs a Diffie-Hellman\
    \ key\n   exchange during call setup in the media path and is transported over\n\
    \   the same port as the Real-time Transport Protocol (RTP) [RFC3550]\n   media\
    \ stream which has been established using a signaling protocol\n   such as Session\
    \ Initiation Protocol (SIP) [RFC3261].  This generates\n   a shared secret, which\
    \ is then used to generate keys and salt for a\n   Secure RTP (SRTP) [RFC3711]\
    \ session.  ZRTP borrows ideas from\n   [PGPfone].  A reference implementation\
    \ of ZRTP is available in\n   [Zfone].\n   The ZRTP protocol has some nice cryptographic\
    \ features lacking in\n   many other approaches to media session encryption. \
    \ Although it uses\n   a public key algorithm, it does not rely on a public key\n\
    \   infrastructure (PKI).  In fact, it does not use persistent public\n   keys\
    \ at all.  It uses ephemeral Diffie-Hellman (DH) with hash\n   commitment and\
    \ allows the detection of man-in-the-middle (MiTM)\n   attacks by displaying a\
    \ short authentication string (SAS) for the\n   users to read and verbally compare\
    \ over the phone.  It has Perfect\n   Forward Secrecy, meaning the keys are destroyed\
    \ at the end of the\n   call, which precludes retroactively compromising the call\
    \ by future\n   disclosures of key material.  But even if the users are too lazy\
    \ to\n   bother with short authentication strings, we still get reasonable\n \
    \  authentication against a MiTM attack, based on a form of key\n   continuity.\
    \  It does this by caching some key material to use in the\n   next call, to be\
    \ mixed in with the next call's DH shared secret,\n   giving it key continuity\
    \ properties analogous to Secure SHell (SSH).\n   All this is done without reliance\
    \ on a PKI, key certification, trust\n   models, certificate authorities, or key\
    \ management complexity that\n   bedevils the email encryption world.  It also\
    \ does not rely on SIP\n   signaling for the key management, and in fact, it does\
    \ not rely on\n   any servers at all.  It performs its key agreements and key\n\
    \   management in a purely peer-to-peer manner over the RTP packet\n   stream.\n\
    \   ZRTP can be used and discovered without being declared or indicated\n   in\
    \ the signaling path.  This provides a best effort SRTP capability.\n   Also,\
    \ this reduces the complexity of implementations and minimizes\n   interdependency\
    \ between the signaling and media layers.  However,\n   when ZRTP is indicated\
    \ in the signaling via the zrtp-hash SDP\n   attribute, ZRTP has additional useful\
    \ properties.  By sending a hash\n   of the ZRTP Hello message in the signaling,\
    \ ZRTP provides a useful\n   binding between the signaling and media paths, which\
    \ is explained in\n   Section 8.1.  When this is done through a signaling path\
    \ that has\n   end-to-end integrity protection, the DH exchange is automatically\n\
    \   protected from a MiTM attack, which is explained in Section 8.1.1.\n   ZRTP\
    \ is designed for unicast media sessions in which there is a voice\n   media stream.\
    \  For multiparty secure conferencing, separate ZRTP\n   sessions may be negotiated\
    \ between each party and the conference\n   bridge.  For sessions lacking a voice\
    \ media stream, MiTM protection\n   may be provided by the mechanisms in Sections\
    \ 8.1.1 or 7.2.  In terms\n   of the RTP topologies defined in [RFC5117], ZRTP\
    \ is designed for\n   Point-to-Point topologies only.\n"
- title: 2.  Terminology
  contents:
  - "2.  Terminology\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\"\
    , \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"NOT RECOMMENDED\"\
    , \"MAY\", and\n   \"OPTIONAL\" in this document are to be interpreted as described\
    \ in\n   [RFC2119].\n   In this document, a \"call\" is synonymous with a \"session\"\
    .\n"
- title: 3.  Overview
  contents:
  - "3.  Overview\n   This section provides a description of how ZRTP works.  This\n\
    \   description is non-normative in nature but is included to build\n   understanding\
    \ of the protocol.\n   ZRTP is negotiated the same way a conventional RTP session\
    \ is\n   negotiated in an offer/answer exchange using the standard RTP/AVP\n \
    \  profile.  The ZRTP protocol begins after two endpoints have utilized\n   a\
    \ signaling protocol, such as SIP, and are ready to exchange media.\n   If Interactive\
    \ Connectivity Establishment (ICE) [RFC5245] is being\n   used, ZRTP begins after\
    \ ICE has completed its connectivity checks.\n   ZRTP is multiplexed on the same\
    \ ports as RTP.  It uses a unique\n   header that makes it clearly differentiable\
    \ from RTP or Session\n   Traversal Utilities for NAT (STUN).\n   ZRTP support\
    \ can be discovered in the signaling path by the presence\n   of a ZRTP SDP attribute.\
    \  However, even in cases where this is not\n   received in the signaling, an\
    \ endpoint can still send ZRTP Hello\n   messages to see if a response is received.\
    \  If a response is not\n   received, no more ZRTP messages will be sent during\
    \ this session.\n   This is safe because ZRTP has been designed to be clearly\
    \ different\n   from RTP and have a similar structure to STUN packets received\n\
    \   (sometimes by non-supporting endpoints) during an ICE exchange.\n   Both ZRTP\
    \ endpoints begin the ZRTP exchange by sending a ZRTP Hello\n   message to the\
    \ other endpoint.  The purpose of the Hello message is\n   to confirm that the\
    \ endpoint supports the protocol and to see what\n   algorithms the two ZRTP endpoints\
    \ have in common.\n   The Hello message contains the SRTP configuration options\
    \ and the\n   ZID.  Each instance of ZRTP has a unique 96-bit random ZRTP ID or\
    \ ZID\n   that is generated once at installation time.  ZIDs are discovered\n\
    \   during the Hello message exchange.  The received ZID is used to look\n   up\
    \ retained shared secrets from previous ZRTP sessions with the\n   endpoint.\n\
    \   A response to a ZRTP Hello message is a ZRTP HelloACK message.  The\n   HelloACK\
    \ message simply acknowledges receipt of the Hello.  Since RTP\n   commonly uses\
    \ best effort UDP transport, ZRTP has retransmission\n   timers in case of lost\
    \ datagrams.  There are two timers, both with\n   exponential backoff mechanisms.\
    \  One timer is used for\n   retransmissions of Hello messages and the other is\
    \ used for\n   retransmissions of all other messages after receipt of a HelloACK.\n\
    \   If an integrity-protected signaling channel is available, a hash of\n   the\
    \ Hello message can be sent.  This allows rejection of false ZRTP\n   Hello messages\
    \ injected by an attacker.\n   Hello and other ZRTP messages also contain a hash\
    \ image that is used\n   to link the messages together.  This allows rejection\
    \ of false ZRTP\n   messages injected during an exchange.\n"
- title: 3.1.  Key Agreement Modes
  contents:
  - "3.1.  Key Agreement Modes\n   After both endpoints exchange Hello and HelloACK\
    \ messages, the key\n   agreement exchange can begin with the ZRTP Commit message.\
    \  ZRTP\n   supports a number of key agreement modes including both Diffie-\n\
    \   Hellman and non-Diffie-Hellman modes as described in the following\n   sections.\n\
    \   The Commit message may be sent immediately after both endpoints have\n   completed\
    \ the Hello/HelloACK discovery handshake, or it may be\n   deferred until later\
    \ in the call, after the participants engage in\n   some unencrypted conversation.\
    \  The Commit message may be manually\n   activated by a user interface element,\
    \ such as a GO SECURE button,\n   which becomes enabled after the Hello/HelloACK\
    \ discovery phase.  This\n   emulates the user experience of a number of secure\
    \ phones in the\n   Public Switched Telephone Network (PSTN) world [comsec]. \
    \ However, it\n   is expected that most simple ZRTP user agents will omit such\
    \ buttons\n   and proceed directly to secure mode by sending a Commit message\n\
    \   immediately after the Hello/HelloACK handshake.\n"
- title: 3.1.1.  Diffie-Hellman Mode Overview
  contents:
  - "3.1.1.  Diffie-Hellman Mode Overview\n   An example ZRTP call flow is shown in\
    \ Figure 1.  Note that the order\n   of the Hello/HelloACK exchanges in F1/F2\
    \ and F3/F4 may be reversed.\n   That is, either Alice or Bob might send the first\
    \ Hello message.\n   Note that the endpoint that sends the Commit message is considered\n\
    \   the initiator of the ZRTP session and drives the key agreement\n   exchange.\
    \  The Diffie-Hellman public values are exchanged in the\n   DHPart1 and DHPart2\
    \ messages.  SRTP keys and salts are then\n   calculated.\n   The initiator needs\
    \ to generate its ephemeral key pair before sending\n   the Commit, and the responder\
    \ generates its key pair before sending\n   DHPart1.\n   Alice               \
    \                                 Bob\n    |                                 \
    \                  |\n    |      Alice and Bob establish a media session.    \
    \ |\n    |         They initiate ZRTP on media ports         |\n    |        \
    \                                           |\n    | F1 Hello (version, options,\
    \ Alice's ZID)          |\n    |-------------------------------------------------->|\n\
    \    |                                       HelloACK F2 |\n    |<--------------------------------------------------|\n\
    \    |            Hello (version, options, Bob's ZID) F3 |\n    |<--------------------------------------------------|\n\
    \    | F4 HelloACK                                       |\n    |-------------------------------------------------->|\n\
    \    |                                                   |\n    |            \
    \ Bob acts as the initiator.            |\n    |                             \
    \                      |\n    |        Commit (Bob's ZID, options, hash value)\
    \ F5 |\n    |<--------------------------------------------------|\n    | F6 DHPart1\
    \ (pvr, shared secret hashes)            |\n    |-------------------------------------------------->|\n\
    \    |            DHPart2 (pvi, shared secret hashes) F7 |\n    |<--------------------------------------------------|\n\
    \    |                                                   |\n    |     Alice and\
    \ Bob generate SRTP session key.      |\n    |                               \
    \                    |\n    | F8 Confirm1 (MAC, D,A,V,E flags, sig)          \
    \   |\n    |-------------------------------------------------->|\n    |      \
    \       Confirm2 (MAC, D,A,V,E flags, sig) F9 |\n    |<--------------------------------------------------|\n\
    \    | F10 Conf2ACK                                      |\n    |-------------------------------------------------->|\n\
    \    |                    SRTP begins                    |\n    |<=================================================>|\n\
    \    |                                                   |\n           Figure\
    \ 1: Establishment of an SRTP Session Using ZRTP\n   ZRTP authentication uses\
    \ a Short Authentication String (SAS), which\n   is ideally displayed for the\
    \ human user.  Alternatively, the SAS can\n   be authenticated by exchanging an\
    \ optional digital signature (sig)\n   over the SAS in the Confirm1 or Confirm2\
    \ messages (described in\n   Section 7.2).\n   The ZRTP Confirm1 and Confirm2\
    \ messages are sent for a number of\n   reasons, not the least of which is that\
    \ they confirm that all the key\n   agreement calculations were successful and\
    \ thus the encryption will\n   work.  They also carry other information such as\
    \ the Disclosure flag\n   (D), the Allow Clear flag (A), the SAS Verified flag\
    \ (V), and the\n   Private Branch Exchange (PBX) Enrollment flag (E).  All flags\
    \ are\n   encrypted to shield them from a passive observer.\n"
- title: 3.1.2.  Preshared Mode Overview
  contents:
  - "3.1.2.  Preshared Mode Overview\n   In the Preshared mode, endpoints can skip\
    \ the DH calculation if they\n   have a shared secret from a previous ZRTP session.\
    \  Preshared mode is\n   indicated in the Commit message and results in the same\
    \ call flow as\n   Multistream mode.  The principal difference between Multistream\
    \ mode\n   and Preshared mode is that Preshared mode uses a previously cached\n\
    \   shared secret, rs1, instead of an active ZRTP Session key as the\n   initial\
    \ keying material.\n   This mode could be useful for slow processor endpoints\
    \ so that a DH\n   calculation does not need to be performed every session.  Or,\
    \ this\n   mode could be used to rapidly re-establish an earlier session that\n\
    \   was recently torn down or interrupted without the need to perform\n   another\
    \ DH calculation.\n   Preshared mode has forward secrecy properties.  If a phone's\
    \ cache is\n   captured by an opponent, the cached shared secrets cannot be used\
    \ to\n   recover earlier encrypted calls, because the shared secrets are\n   replaced\
    \ with new ones in each new call, as in DH mode.  However, the\n   captured secrets\
    \ can be used by a passive wiretapper in the media\n   path to decrypt the next\
    \ call, if the next call is in Preshared mode.\n   This differs from DH mode,\
    \ which requires an active MiTM wiretapper\n   to exploit captured secrets in\
    \ the next call.  However, if the next\n   call is missed by the wiretapper, he\
    \ cannot wiretap any further\n   calls.  Thus, it preserves most of the self-healing\
    \ properties\n   (Section 15.1) of key continuity enjoyed by DH mode.\n"
- title: 3.1.3.  Multistream Mode Overview
  contents:
  - "3.1.3.  Multistream Mode Overview\n   Multistream mode is an alternative key\
    \ agreement method used when two\n   endpoints have an established SRTP media\
    \ stream between them with an\n   active ZRTP Session key.  ZRTP can derive multiple\
    \ SRTP keys from a\n   single DH exchange.  For example, an established secure\
    \ voice call\n   that adds a video stream uses Multistream mode to quickly initiate\n\
    \   the video stream without a second DH exchange.\n   When Multistream mode is\
    \ indicated in the Commit message, a call flow\n   similar to Figure 1 is used,\
    \ but no DH calculation is performed by\n   either endpoint and the DHPart1 and\
    \ DHPart2 messages are omitted.\n   The Confirm1, Confirm2, and Conf2ACK messages\
    \ are still sent.  Since\n   the cache is not affected during this mode, multiple\
    \ Multistream ZRTP\n   exchanges can be performed in parallel between two endpoints.\n\
    \   When adding additional media streams to an existing call, only\n   Multistream\
    \ mode is used.  Only one DH operation is performed, just\n   for the first media\
    \ stream.\n"
- title: 4.  Protocol Description
  contents:
  - "4.  Protocol Description\n   This section begins the normative description of\
    \ the protocol.\n   ZRTP MUST be multiplexed on the same ports as the RTP media\
    \ packets.\n   To support best effort encryption from the Media Security\n   Requirements\
    \ [RFC5479], ZRTP uses normal RTP/AVP profile (AVP) media\n   lines in the initial\
    \ offer/answer exchange.  The ZRTP SDP attribute\n   a=zrtp-hash defined in Section\
    \ 8 SHOULD be used in all offers and\n   answers to indicate support for the ZRTP\
    \ protocol.\n      ZRTP can be utilized by endpoints that do not have a common\n\
    \      signaling protocol but both support SRTP and are relying on a\n      gateway\
    \ for conversion.  As such, it is not always possible for\n      the signaling\
    \ protocol to relay the zrtp-hash as can be done using\n      SIP.\n   The Secure\
    \ RTP/AVP (SAVP) profile MAY be used in subsequent offer/\n   answer exchanges\
    \ after a successful ZRTP exchange has resulted in an\n   SRTP session, or if\
    \ it is known that the other endpoint supports this\n   profile.  Other profiles\
    \ MAY also be used.\n      The use of the RTP/SAVP profile has caused failures\
    \ in negotiating\n      best effort SRTP due to the limitations on negotiating\
    \ profiles\n      using SDP.  This is why ZRTP supports the RTP/AVP profile and\n\
    \      includes its own discovery mechanisms.\n   In all key agreement modes,\
    \ the initiator SHOULD NOT send RTP media\n   after sending the Commit message,\
    \ and it MUST NOT send SRTP media\n   before receiving either the Conf2ACK or\
    \ the first SRTP media (with a\n   valid SRTP auth tag) from the responder.  The\
    \ responder SHOULD NOT\n   send RTP media after receiving the Commit message,\
    \ and MUST NOT send\n   SRTP media before receiving the Confirm2 message.\n"
- title: 4.1.  Discovery
  contents:
  - "4.1.  Discovery\n   During the ZRTP discovery phase, a ZRTP endpoint discovers\
    \ if the\n   other endpoint supports ZRTP and the supported algorithms and\n \
    \  options.  This information is transported in a Hello message, which\n   is\
    \ described in Section 5.2.\n   ZRTP endpoints SHOULD include the SDP attribute\
    \ a=zrtp-hash in offers\n   and answers, as defined in Section 8.\n   The Hello\
    \ message includes the ZRTP version, Hash Type, Cipher Type,\n   SRTP authentication\
    \ tag type, Key Agreement Type, and Short\n   Authentication String (SAS) algorithms\
    \ that are supported.  The Hello\n   message also includes a hash image as described\
    \ in Section 9.  In\n   addition, each endpoint sends and discovers ZIDs.  The\
    \ received ZID\n   is used later in the protocol as an index into a cache of shared\n\
    \   secrets that were previously negotiated and retained between the two\n   parties.\n\
    \   A Hello message can be sent at any time, but it is usually sent at\n   the\
    \ start of an RTP session to determine if the other endpoint\n   supports ZRTP\
    \ and also if the SRTP implementations are compatible.  A\n   Hello message is\
    \ retransmitted using timer T1 and an exponential\n   backoff mechanism detailed\
    \ in Section 6 until the receipt of a\n   HelloACK message or a Commit message.\n\
    \   The use of the a=zrtp-hash SDP attribute to authenticate the Hello\n   message\
    \ is described in Section 8.1.\n   If a Hello message, or any other ZRTP message,\
    \ indicates that there\n   is a synchronization source (SSRC) collision, an Error\
    \ message\n   (Section 5.9) MUST be sent with the Error Code indicating SSRC\n\
    \   collision, and the ZRTP negotiation MUST be terminated.  The\n   procedures\
    \ of RFC 3550, Section 8.2 [RFC3550], SHOULD be followed by\n   both endpoints\
    \ to resolve this condition, and if it is resolved, a\n   new ZRTP secure session\
    \ SHOULD be negotiated.\n"
- title: 4.1.1.  Protocol Version Negotiation
  contents:
  - "4.1.1.  Protocol Version Negotiation\n   This specification defines ZRTP version\
    \ 1.10.  Since new versions of\n   ZRTP may be developed in the future, this specification\
    \ defines a\n   protocol version negotiation in this section.\n   Each party declares\
    \ what version of the ZRTP protocol they support\n   via the version field in\
    \ the Hello message (Section 5.2).  If both\n   parties have the same version\
    \ number in their Hello messages, they\n   can proceed with the rest of the protocol.\
    \  To facilitate both\n   parties reaching this state of protocol version agreement\
    \ in their\n   Hello messages, ZRTP should use information provided in the signaling\n\
    \   layer, if available.  If a ZRTP endpoint supports more than one\n   version\
    \ of the protocol, it SHOULD declare them all in a list of SIP\n   SDP a=zrtp-hash\
    \ attributes (defined in Section 8), listing separate\n   hashes, with separate\
    \ ZRTP version numbers in each item in the list.\n   Both parties should inspect\
    \ the list of ZRTP version numbers supplied\n   by the other party in the SIP\
    \ SDP a=zrtp-hash attributes.  Both\n   parties SHOULD choose the highest version\
    \ number that appears in both\n   parties' list of a=zrtp-hash version numbers,\
    \ and use that version\n   for their Hello messages.  If both parties use the\
    \ SIP signaling in\n   this manner, their initial Hello messages will have the\
    \ same ZRTP\n   version number, provided they both have at least one supported\n\
    \   protocol version in common.  Before the ZRTP key agreement can\n   proceed,\
    \ an endpoint MUST have sent and received Hellos with the same\n   protocol version.\n\
    \   It is best if the signaling layer is used to negotiate the protocol\n   version\
    \ number.  However, the a=zrtp-hash SDP attribute is not always\n   present in\
    \ the SIP packet, as explained in Section 8.1.  In the\n   absence of any guidance\
    \ from the signaling layer, an endpoint MUST\n   send the highest supported version\
    \ in initial Hello messages.  If the\n   two parties send different protocol version\
    \ numbers in their Hello\n   messages, they can reach an agreement to use a common\
    \ version, if one\n   exists.  They iteratively apply the following rules until\
    \ they both\n   have matching version fields in their Hello messages and the key\n\
    \   agreement can proceed:\n   o  If an endpoint receives a Hello message with\
    \ an unsupported\n      version number that is higher than the endpoint's current\
    \ Hello\n      message version, the received Hello message MUST be ignored.  The\n\
    \      endpoint continues to retransmit Hello messages on the standard\n     \
    \ retry schedule (Section 6).\n   o  If an endpoint receives a Hello message with\
    \ a version number that\n      is lower than the endpoint's current Hello message,\
    \ and the\n      endpoint supports a version that is less than or equal to the\n\
    \      received version number, the endpoint MUST stop retransmitting the\n  \
    \    old version number and MUST start sending a Hello message with the\n    \
    \  highest supported version number that is less than or equal to the\n      received\
    \ version number.\n   o  If an endpoint receives a Hello message with an unsupported\n\
    \      version number that is lower than the endpoint's current Hello\n      message,\
    \ the endpoint MUST send an Error message (Section 5.9)\n      indicating failure\
    \ to support this ZRTP version.\n   The above comparisons are iterated until the\
    \ version numbers match,\n   or until it exits on a failure to match.\n      For\
    \ example, assume that Alice supports protocol versions 1.10 and\n      2.00,\
    \ and Bob supports versions 1.10 and 1.20.  Alice initially\n      sends a Hello\
    \ with version 2.00, and Bob initially sends a Hello\n      with version 1.20.\
    \  Bob ignores Alice's 2.00 Hello and continues\n      to send his 1.20 Hellos.\
    \  Alice detects that Bob does not support\n      2.00 and she stops sending her\
    \ 2.00 Hellos and starts sending a\n      stream of 1.10 Hellos.  Bob sees the\
    \ 1.10 Hello from Alice and\n      stops sending his 1.20 Hellos and switches\
    \ to sending 1.10 Hellos.\n      At that point, they have converged on using version\
    \ 1.10 and the\n      protocol proceeds on that basis.\n   When comparing protocol\
    \ versions, a ZRTP endpoint MUST include only\n   the first three octets of the\
    \ version field in the comparison.  The\n   final octet is ignored, because it\
    \ is not significant for\n   interoperability.  For example, \"1.1 \", \"1.10\"\
    , \"1.11\", or \"1.1a\" are\n   all regarded as a version match, because they\
    \ would all be\n   interoperable versions.\n   Changes in protocol version numbers\
    \ are expected to be infrequent\n   after version 1.10.  Supporting multiple versions\
    \ adds code\n   complexity and may introduce security weaknesses in the\n   implementation.\
    \  The old adage about keeping it simple applies\n   especially to implementing\
    \ security protocols.  Endpoints SHOULD NOT\n   support protocol versions earlier\
    \ than version 1.10.\n"
- title: 4.1.2.  Algorithm Negotiation
  contents:
  - "4.1.2.  Algorithm Negotiation\n   A method is provided to allow the two parties\
    \ to mutually and\n   deterministically choose the same DH key size and algorithm\
    \ before a\n   Commit message is sent.\n   Each Hello message lists the algorithms\
    \ in the order of preference\n   for that ZRTP endpoint.  Endpoints eliminate\
    \ the non-intersecting\n   choices from each of their own lists, resulting in\
    \ each endpoint\n   having a list of algorithms in common that might or might\
    \ not be\n   ordered the same as the other endpoint's list.  Each endpoint\n \
    \  compares the first item on their own list with the first item on the\n   other\
    \ endpoint's list and SHOULD choose the faster of the two\n   algorithms.  For\
    \ example:\n   o  Alice's full list: DH2k, DH3k, EC25\n   o  Bob's full list:\
    \ EC38, EC25, DH3k\n   o  Alice's intersecting list: DH3k, EC25\n   o  Bob's intersecting\
    \ list: EC25, DH3k\n   o  Alice's first choice is DH3k, and Bob's first choice\
    \ is EC25.\n   o  Thus, both parties choose EC25 (ECDH-256) because it's faster.\n\
    \   To decide which DH algorithm is faster, the following ranking, from\n   fastest\
    \ to slowest is defined: DH-2048, ECDH-256, DH-3072, ECDH-384,\n   ECDH-521. \
    \ These are all defined in Section 5.1.5.\n   If both endpoints follow this method,\
    \ they may each start their DH\n   calculations as soon as they receive the Hello\
    \ message, and there\n   will be no need for either endpoint to discard their\
    \ DH calculation\n   if the other endpoint becomes the initiator.\n   This method\
    \ is used only to negotiate DH key size.  For the rest of\n   the algorithm choices,\
    \ it's simply whatever the initiator selects\n   from the algorithms in common.\
    \  Note that the DH key size influences\n   the Hash Type and the size of the\
    \ symmetric cipher key, as explained\n   in Section 5.1.5.\n   Unfavorable choices\
    \ will never be made by this method, because each\n   endpoint will omit from\
    \ their respective lists choices that are too\n   slow or not secure enough to\
    \ meet their security policy.\n"
- title: 4.2.  Commit Contention
  contents:
  - "4.2.  Commit Contention\n   After both parties have received compatible Hello\
    \ messages, a Commit\n   message (Section 5.4) can be sent to begin the ZRTP key\
    \ exchange.\n   The endpoint that sends the Commit is known as the initiator,\
    \ while\n   the receiver of the Commit is known as the responder.\n   If both\
    \ sides send Commit messages initiating a secure session at the\n   same time,\
    \ the following rules are used to break the tie:\n   o  If one Commit is for a\
    \ DH mode while the other is for Preshared\n      mode, then the Preshared Commit\
    \ MUST be discarded and the DH\n      Commit proceeds.\n   o  If the two Commits\
    \ are both Preshared mode, and one party has set\n      the MiTM (M) flag in the\
    \ Hello message and the other has not, the\n      Commit message from the party\
    \ who set the (M) flag MUST be\n      discarded, and the one who has not set the\
    \ (M) flag becomes the\n      initiator, regardless of the nonce values.  In other\
    \ words, for\n      Preshared mode, the phone is the initiator and the PBX is\
    \ the\n      responder.\n   o  If the two Commits are either both DH modes or\
    \ both non-DH modes,\n      then the Commit message with the lowest hvi (hash\
    \ value of\n      initiator) value (for DH Commits), or lowest nonce value (for\n\
    \      non-DH Commits), MUST be discarded and the other side is the\n      initiator,\
    \ and the protocol proceeds with the initiator's Commit.\n      The two hvi or\
    \ nonce values are compared as large unsigned\n      integers in network byte\
    \ order.\n   If one Commit is for Multistream mode while the other is for non-\n\
    \   Multistream (DH or Preshared) mode, a software error has occurred and\n  \
    \ the ZRTP negotiation should be terminated.  This should never occur\n   because\
    \ of the constraints on Multistream mode described in\n   Section 4.4.3.\n   In\
    \ the event that Commit messages are sent by both ZRTP endpoints at\n   the same\
    \ time, but are received in different media streams, the same\n   resolution rules\
    \ apply as if they were received on the same stream.\n   The media stream in which\
    \ the Commit was received or sent will\n   proceed through the ZRTP exchange while\
    \ the media stream with the\n   discarded Commit must wait for the completion\
    \ of the other ZRTP\n   exchange.\n   If a commit contention forces a DH Commit\
    \ message to be discarded,\n   the responder's DH public value should only be\
    \ discarded if it does\n   not match the initiator's DH key size.  This will not\
    \ happen if both\n   endpoints choose a common key size via the method described\
    \ in\n   Section 4.1.2.\n"
- title: 4.3.  Matching Shared Secret Determination
  contents:
  - "4.3.  Matching Shared Secret Determination\n   The following sections describe\
    \ how ZRTP endpoints generate and/or\n   use the set of shared secrets s1, auxsecret,\
    \ and pbxsecret through\n   the exchange of the DHPart1 and DHPart2 messages.\
    \  This doesn't cover\n   the Diffie-Hellman calculations.  It only covers the\
    \ method whereby\n   the two parties determine if they already have shared secrets\
    \ in\n   common in their caches.\n   Each ZRTP endpoint maintains a long-term\
    \ cache of shared secrets that\n   it has previously negotiated with the other\
    \ party.  The ZID of the\n   other party, received in the other party's Hello\
    \ message, is used as\n   an index into this cache to find the set of shared secrets,\
    \ if any\n   exist.  This cache entry may contain previously retained shared\n\
    \   secrets, rs1 and rs2, which give ZRTP its key continuity features.\n   If\
    \ the other party is a PBX, the cache may also contain a trusted\n   MiTM PBX\
    \ shared secret, called pbxsecret, defined in Section 7.3.1.\n   The DHPart1 and\
    \ DHPart2 messages contain a list of hashes of these\n   shared secrets to allow\
    \ the two endpoints to compare the hashes with\n   what they have in their caches\
    \ to detect whether the two sides share\n   any secrets that can be used in the\
    \ calculation of the session key.\n   The use of this shared secret cache is described\
    \ in Section 4.9.\n   If no secret of a given type is available, a random value\
    \ is\n   generated and used for that secret to ensure a mismatch in the hash\n\
    \   comparisons in the DHPart1 and DHPart2 messages.  This prevents an\n   eavesdropper\
    \ from knowing which types of shared secrets are available\n   between the endpoints.\n\
    \   Section 4.3.1 refers to the auxiliary shared secret auxsecret.  The\n   auxsecret\
    \ shared secret may be defined by the VoIP user agent out-of-\n   band from the\
    \ ZRTP protocol.  In some cases, it may be provided by\n   the signaling layer\
    \ as srtps, which is defined in Section 8.2.  If it\n   is not provided by the\
    \ signaling layer, the auxsecret shared secret\n   may be manually provisioned\
    \ in other application-specific ways that\n   are out of band, such as computed\
    \ from a hashed pass phrase by prior\n   agreement between the two parties or\
    \ supplied by a hardware token.\n   Or, it may be a family key used by an institution\
    \ to which the two\n   parties both belong.  It is a generalized mechanism for\
    \ providing a\n   shared secret that is agreed to between the two parties out\
    \ of scope\n   of the ZRTP protocol.  It is expected that most typical ZRTP\n\
    \   endpoints will rarely use auxsecret.\n   For both the initiator and the responder,\
    \ the shared secrets s1, s2,\n   and s3 will be calculated so that they can all\
    \ be used later to\n   calculate s0 in Section 4.4.1.4.  Here is how s1, s2, and\
    \ s3 are\n   calculated by both parties.\n   The shared secret s1 will be either\
    \ the initiator's rs1 or the\n   initiator's rs2, depending on which of them can\
    \ be found in the\n   responder's cache.  If the initiator's rs1 matches the responder's\n\
    \   rs1 or rs2, then s1 MUST be set to the initiator's rs1.  If and only\n   if\
    \ that match fails, then if the initiator's rs2 matches the\n   responder's rs1\
    \ or rs2, then s1 MUST be set to the initiator's rs2.\n   If that match also fails,\
    \ then s1 MUST be set to null.  The\n   complexity of the s1 calculation is to\
    \ recover from any loss of cache\n   sync from an earlier aborted session, due\
    \ to the Two Generals'\n   Problem [Byzantine].\n   The shared secret s2 MUST\
    \ be set to the value of auxsecret if and\n   only if both parties have matching\
    \ values for auxsecret, as\n   determined by comparing the hashes of auxsecret\
    \ sent in the DH\n   messages.  If they don't match, s2 MUST be set to null.\n\
    \   The shared secret s3 MUST be set to the value of pbxsecret if and\n   only\
    \ if both parties have matching values for pbxsecret, as\n   determined by comparing\
    \ the hashes of pbxsecret sent in the DH\n   messages.  If they don't match, s3\
    \ MUST be set to null.\n   If s1, s2, or s3 have null values, they are assumed\
    \ to have a zero\n   length for the purposes of hashing them later during the\
    \ s0\n   calculation in Section 4.4.1.4.\n   The comparison of hashes of rs1,\
    \ rs2, auxsecret, and pbxsecret is\n   described in Section 4.3.1.\n"
- title: 4.3.1.  Calculation and Comparison of Hashes of Shared Secrets
  contents:
  - "4.3.1.  Calculation and Comparison of Hashes of Shared Secrets\n   Both parties\
    \ calculate a set of non-invertible hashes (implemented\n   via the MAC defined\
    \ in Section 5.1.2.1) of shared secrets that may be\n   present in each of their\
    \ caches.  These hashes are truncated to the\n   leftmost 64 bits:\n      rs1IDr\
    \ = MAC(rs1, \"Responder\")\n      rs2IDr = MAC(rs2, \"Responder\")\n      auxsecretIDr\
    \ = MAC(auxsecret, Responder's H3)\n      pbxsecretIDr = MAC(pbxsecret, \"Responder\"\
    )\n      rs1IDi = MAC(rs1, \"Initiator\")\n      rs2IDi = MAC(rs2, \"Initiator\"\
    )\n      auxsecretIDi = MAC(auxsecret, Initiator's H3)\n      pbxsecretIDi = MAC(pbxsecret,\
    \ \"Initiator\")\n   The responder sends rs1IDr, rs2IDr, auxsecretIDr, and pbxsecretIDr\
    \ in\n   the DHPart1 message.  The initiator sends rs1IDi, rs2IDi,\n   auxsecretIDi,\
    \ and pbxsecretIDi in the DHPart2 message.\n   The responder uses the locally\
    \ computed rs1IDi, rs2IDi, auxsecretIDi,\n   and pbxsecretIDi to compare against\
    \ the corresponding fields in the\n   received DHPart2 message.  The initiator\
    \ uses the locally computed\n   rs1IDr, rs2IDr, auxsecretIDr, and pbxsecretIDr\
    \ to compare against the\n   corresponding fields in the received DHPart1 message.\n\
    \   From these comparisons, s1, s2, and s3 are calculated per the methods\n  \
    \ described in Section 4.3.  The secrets corresponding to matching\n   hashes\
    \ are kept while the secrets corresponding to the non-matching\n   ones are replaced\
    \ with a null, which is assumed to have a zero length\n   for the purposes of\
    \ hashing them later.  The resulting s1, s2, and s3\n   values are used later\
    \ to calculate s0 in Section 4.4.1.4.\n   For example, consider two ZRTP endpoints\
    \ who share secrets rs1 and\n   pbxsecret (defined in Section 7.3.1).  During\
    \ the comparison, rs1ID\n   and pbxsecretID will match but auxsecretID will not.\
    \  As a result,\n   s1 = rs1, s2 will be null, and s3 = pbxsecret.\n"
- title: 4.3.2.  Handling a Shared Secret Cache Mismatch
  contents:
  - "4.3.2.  Handling a Shared Secret Cache Mismatch\n   A shared secret cache mismatch\
    \ is defined to mean that we expected a\n   cache match because rs1 exists in\
    \ our local cache, but we computed a\n   null value for s1 (per the method described\
    \ in Section 4.3).\n   If one party has a cached shared secret and the other party\
    \ does not,\n   this indicates one of two possible situations.  Either there is\
    \ a\n   MiTM attack or one of the legitimate parties has lost their cached\n \
    \  shared secret by some mishap.  Perhaps they inadvertently deleted\n   their\
    \ cache or their cache was lost or disrupted due to restoring\n   their disk from\
    \ an earlier backup copy.  The party that has the\n   surviving cache entry can\
    \ easily detect that a cache mismatch has\n   occurred, because they expect their\
    \ own cached secret to match the\n   other party's cached secret, but it does\
    \ not match.  It is possible\n   for both parties to detect this condition if\
    \ both parties have\n   surviving cached secrets that have fallen out of sync,\
    \ due perhaps to\n   one party restoring from a disk backup.\n   If either party\
    \ discovers a cache mismatch, the user agent who makes\n   this discovery must\
    \ treat this as a possible security event and MUST\n   alert their own user that\
    \ there is a heightened risk of a MiTM\n   attack, and that the user should verbally\
    \ compare the SAS with the\n   other party to ascertain that no MiTM attack has\
    \ occurred.  If a\n   cache mismatch is detected and it is not possible to compare\
    \ the SAS,\n   either because the user interface does not support it or because\
    \ one\n   or both endpoints are unmanned devices, and no other SAS comparison\n\
    \   mechanism is available, the session MAY be terminated.\n   The session need\
    \ not be terminated on a cache mismatch event if:\n   o  the mechanism described\
    \ in Section 8.1.1 is available, which\n      allows authentication of the DH\
    \ exchange without human assistance,\n      or\n   o  any mechanism is available\
    \ to determine if the SAS matches.  This\n      would require either circumstances\
    \ that allow human verbal\n      comparisons of the SAS or by use of the OPTIONAL\
    \ digital signature\n      feature on the SAS hash, as described in Section 7.2.\n\
    \   Even if the user interface does not permit an SAS comparison, the\n   human\
    \ user MUST be warned and may elect to proceed with the call at\n   their own\
    \ risk.\n   If and only if a cache mismatch event occurs, the cache update\n \
    \  mechanism in Section 4.6.1 is affected, requiring the user to verify\n   the\
    \ SAS before the cache is updated.  The user will thus be alerted\n   of this\
    \ security condition on every call until the SAS is verified.\n   This is described\
    \ in Section 4.6.1.1.\n   Here is a non-normative example of a cache-mismatch\
    \ alert message\n   from a ZRTP user agent (specifically, [Zfone]), designed for\
    \ a\n   desktop PC graphical user interface environment.  It is by no means\n\
    \   required that the alert be this detailed:\n      We expected the other party\
    \ to have a shared secret cached from a\n      previous call, but they don't have\
    \ it.  This may mean your partner\n      simply lost his cache of shared secrets,\
    \ but it could also mean\n      someone is trying to wiretap you.  To resolve\
    \ this question you\n      must check the authentication string with your partner.\
    \  If it\n      doesn't match, it indicates the presence of a wiretapper.\n  \
    \ If the alert is rendered by a robot voice instead of a GUI, brevity\n   may\
    \ be more important:\n      Something's wrong.  You must check the authentication\
    \ string with\n      your partner.  If it doesn't match, it indicates the presence\
    \ of a\n      wiretapper.\n   A mismatch of auxsecret is handled differently than\
    \ a mismatch of\n   rs1.  An auxsecret mismatch is defined to mean that auxsecret\
    \ exists\n   locally, but we computed a null value for s2 (per the method\n  \
    \ described in Section 4.3).  This mismatch should be made visible to\n   whichever\
    \ user has auxsecret defined.  The mismatch should be made\n   visible to both\
    \ users if they both have auxsecret defined but they\n   fail to match.  The severity\
    \ of the user notification is\n   implementation dependent.  Aborting the session\
    \ is not required.  If\n   auxsecret matches, it should not excuse a mismatch\
    \ of rs1, which\n   still requires a strong warning to the user.\n"
- title: 4.4.  DH and Non-DH Key Agreements
  contents:
  - "4.4.  DH and Non-DH Key Agreements\n   The next step is the generation of a secret\
    \ for deriving SRTP keying\n   material.  ZRTP uses Diffie-Hellman and two non-Diffie-Hellman\
    \ modes,\n   described in the following subsections.\n"
- title: 4.4.1.  Diffie-Hellman Mode
  contents:
  - "4.4.1.  Diffie-Hellman Mode\n   The purpose of the Diffie-Hellman (either Finite\
    \ Field Diffie-Hellman\n   or Elliptic Curve Diffie-Hellman) exchange is for the\
    \ two ZRTP\n   endpoints to generate a new shared secret, s0.  In addition, the\n\
    \   endpoints discover if they have any cached or previously stored\n   shared\
    \ secrets in common, and it uses them as part of the calculation\n   of the session\
    \ keys.\n   Because the DH exchange affects the state of the retained shared\n\
    \   secret cache, only one in-process ZRTP DH exchange may occur at a\n   time\
    \ between two ZRTP endpoints.  Otherwise, race conditions and\n   cache integrity\
    \ problems will result.  When multiple media streams\n   are established in parallel\
    \ between the same pair of ZRTP endpoints\n   (determined by the ZIDs in the Hello\
    \ messages), only one can be\n   processed.  Once that exchange completes with\
    \ Confirm2 and Conf2ACK\n   messages, another ZRTP DH exchange can begin.  This\
    \ constraint does\n   not apply when Multistream mode key agreement is used since\
    \ the\n   cached shared secrets are not affected.\n"
- title: 4.4.1.1.  Hash Commitment in Diffie-Hellman Mode
  contents:
  - "4.4.1.1.  Hash Commitment in Diffie-Hellman Mode\n   From the intersection of\
    \ the algorithms in the sent and received\n   Hello messages, the initiator chooses\
    \ a hash, cipher, auth tag, Key\n   Agreement Type, and SAS Type to be used.\n\
    \   A Diffie-Hellman mode is selected by setting the Key Agreement Type\n   in\
    \ the Commit to one of the DH or Elliptic Curve Diffie-Hellman\n   (ECDH) values\
    \ from the table in Section 5.1.5.  In this mode, the key\n   agreement begins\
    \ with the initiator choosing a fresh random Diffie-\n   Hellman (DH) secret value\
    \ (svi) based on the chosen Key Agreement\n   Type value, and computing the public\
    \ value.  (Note that to speed up\n   processing, this computation can be done\
    \ in advance.)  For guidance\n   on generating random numbers, see Section 4.8.\n\
    \   For Finite Field Diffie-Hellman, the value for the DH generator g,\n   the\
    \ DH prime p, and the length of the DH secret value, svi, are\n   defined in Section\
    \ 5.1.5.\n      pvi = g^svi mod p\n   where g and p are determined by the Key\
    \ Agreement Type value.  The DH\n   public value pvi value is formatted as a big-endian\
    \ octet string and\n   fixed to the bit-length of the DH prime; leading zeros\
    \ MUST NOT be\n   truncated.\n   For Elliptic Curve DH, pvi is calculated and\
    \ formatted according to\n   the ECDH specification in Section 5.1.5, which refers\
    \ in detail to\n   certain sections of NIST SP 800-56A [NIST-SP800-56A].\n   The\
    \ hash commitment is performed by the initiator of the ZRTP\n   exchange.  The\
    \ hash value of the initiator, hvi, includes a hash of\n   the entire DHPart2\
    \ message as shown in Figure 9 (which includes the\n   Diffie-Hellman public value,\
    \ pvi), and the responder's Hello message\n   (where '||' means concatenation).\
    \  The hvi hash is truncated to 256\n   bits:\n       hvi = hash(initiator's DHPart2\
    \ message ||\n                            responder's Hello message)\n   Note\
    \ that the Hello message includes the fields shown in Figure 3.\n   The information\
    \ from the responder's Hello message is included in the\n   hash calculation to\
    \ prevent a bid-down attack by modification of the\n   responder's Hello message.\n\
    \   The initiator sends the hvi in the Commit message.\n   The use of hash commitment\
    \ in the DH exchange constrains the attacker\n   to only one guess to generate\
    \ the correct Short Authentication String\n   (SAS) (Section 7) in his attack,\
    \ which means the SAS can be quite\n   short.  A 16-bit SAS, for example, provides\
    \ the attacker only one\n   chance out of 65536 of not being detected.  Without\
    \ this hash\n   commitment feature, a MiTM attacker would acquire both the pvi\
    \ and\n   pvr public values from the two parties before having to choose his\n\
    \   own two DH public values for his MiTM attack.  He could then use that\n  \
    \ information to quickly perform a bunch of trial DH calculations for\n   both\
    \ sides until he finds two with a matching SAS.  To raise the cost\n   of this\
    \ birthday attack, the SAS would have to be much longer.  The\n   Short Authentication\
    \ String would have to become a Long\n   Authentication String, which would be\
    \ unacceptable to the user.  A\n   hash commitment precludes this attack by forcing\
    \ the MiTM to choose\n   his own two DH public values before learning the public\
    \ values of\n   either of the two parties.\n"
- title: 4.4.1.2.  Responder Behavior in Diffie-Hellman Mode
  contents:
  - "4.4.1.2.  Responder Behavior in Diffie-Hellman Mode\n   Upon receipt of the Commit\
    \ message, the responder generates its own\n   fresh random DH secret value, svr,\
    \ and computes the public value.\n   (Note that to speed up processing, this computation\
    \ can be done in\n   advance, with no need to discard this computation if both\
    \ endpoints\n   chose the same algorithm via Section 4.1.2.)  For guidance on\
    \ random\n   number generation, see Section 4.8.\n   For Finite Field Diffie-Hellman,\
    \ the value for the DH generator g,\n   the DH prime p, and the length of the\
    \ DH secret value, svr, are\n   defined in Section 5.1.5.\n      pvr = g^svr mod\
    \ p\n   The pvr value is formatted as a big-endian octet string, fixed to the\n\
    \   bit-length of the DH prime; leading zeros MUST NOT be truncated.\n   For Elliptic\
    \ Curve DH, pvr is calculated and formatted according to\n   the ECDH specification\
    \ in Section 5.1.5, which refers in detail to\n   certain sections of NIST SP\
    \ 800-56A.\n   Upon receipt of the DHPart2 message, the responder checks that\
    \ the\n   initiator's DH public value is not equal to 1 or p-1.  An attacker\n\
    \   might inject a false DHPart2 message with a value of 1 or p-1 for\n   g^svi\
    \ mod p, which would cause a disastrously weak final DH result to\n   be computed.\
    \  If pvi is 1 or p-1, the user SHOULD be alerted of the\n   attack and the protocol\
    \ exchange MUST be terminated.  Otherwise, the\n   responder computes its own\
    \ value for the hash commitment using the DH\n   public value (pvi) received in\
    \ the DHPart2 message and its own Hello\n   message and compares the result with\
    \ the hvi received in the Commit\n   message.  If they are different, a MiTM attack\
    \ is taking place and\n   the user is alerted and the protocol exchange terminated.\n\
    \   The responder then calculates the Diffie-Hellman result:\n      DHResult =\
    \ pvi^svr mod p\n"
- title: 4.4.1.3.  Initiator Behavior in Diffie-Hellman Mode
  contents:
  - "4.4.1.3.  Initiator Behavior in Diffie-Hellman Mode\n   Upon receipt of the DHPart1\
    \ message, the initiator checks that the\n   responder's DH public value is not\
    \ equal to 1 or p-1.  An attacker\n   might inject a false DHPart1 message with\
    \ a value of 1 or p-1 for\n   g^svr mod p, which would cause a disastrously weak\
    \ final DH result to\n   be computed.  If pvr is 1 or p-1, the user should be\
    \ alerted of the\n   attack and the protocol exchange MUST be terminated.\n  \
    \ The initiator then sends a DHPart2 message containing the initiator's\n   DH\
    \ public value and the set of calculated shared secret IDs as\n   defined in Section\
    \ 4.3.1.\n   The initiator calculates the same Diffie-Hellman result using:\n\
    \      DHResult = pvr^svi mod p\n"
- title: 4.4.1.4.  Shared Secret Calculation for DH Mode
  contents:
  - "4.4.1.4.  Shared Secret Calculation for DH Mode\n   A hash of the received and\
    \ sent ZRTP messages in the current ZRTP\n   exchange in the following order is\
    \ calculated by both parties:\n     total_hash = hash(Hello of responder || Commit\
    \ || DHPart1 ||\n                          DHPart2)\n   Note that only the ZRTP\
    \ messages (Figures 3, 5, 8, and 9), not the\n   entire ZRTP packets, are included\
    \ in the total_hash.\n   For both the initiator and responder, the DHResult is\
    \ formatted as a\n   big-endian octet string and fixed to the width of the DH\
    \ prime;\n   leading zeros MUST NOT be truncated.  For example, for a 3072-bit\
    \ p,\n   DHResult would be a 384 octet value, with the first octet the most\n\
    \   significant.  DHResult may also be the result of an ECDH calculation,\n  \
    \ which is discussed in Section 5.1.5.\n   Key        | Size of\n   Agreement\
    \  | DHResult\n   ------------------------\n   DH-3072    | 384 octets\n   ------------------------\n\
    \   DH-2048    | 256 octets\n   ------------------------\n   ECDH P-256 |  32\
    \ octets\n   ------------------------\n   ECDH P-384 |  48 octets\n   ------------------------\n\
    \   The authors believe the calculation of the final shared secret, s0,\n   is\
    \ in compliance with the recommendations in Sections 5.8.1 and\n   6.1.2.1 of\
    \ NIST SP 800-56A [NIST-SP800-56A].  This is done by hashing\n   a concatenation\
    \ of a number of items, including the DHResult, the\n   ZID's of the initiator\
    \ (ZIDi) and the responder (ZIDr), the\n   total_hash, and the set of non-null\
    \ shared secrets as described in\n   Section 4.3.\n   In Section 5.8.1 of [NIST-SP800-56A],\
    \ NIST requires certain\n   parameters to be hashed together in a particular order,\
    \ which NIST\n   refers to as: Z, AlgorithmID, PartyUInfo, PartyVInfo, SuppPubInfo,\n\
    \   and SuppPrivInfo.  In our implementation, our DHResult corresponds to\n  \
    \ Z, \"ZRTP-HMAC-KDF\" corresponds to AlgorithmID, our ZIDi and ZIDr\n   correspond\
    \ to PartyUInfo and PartyVInfo, our total_hash corresponds\n   to SuppPubInfo,\
    \ and the set of three shared secrets s1, s2, and s3\n   corresponds to SuppPrivInfo.\
    \  NIST also requires a 32-bit big-endian\n   integer counter to be included in\
    \ the hash each time the hash is\n   computed, which we have set to the fixed\
    \ value of 1 because we only\n   compute the hash once.  NIST refers to the final\
    \ hash output as\n   DerivedKeyingMaterial, which corresponds to our s0 in this\n\
    \   calculation.\n      s0 = hash(counter || DHResult || \"ZRTP-HMAC-KDF\" ||\
    \ ZIDi ||\n                ZIDr || total_hash || len(s1) || s1 || len(s2) ||\n\
    \                s2 || len(s3) || s3)\n   Note that temporary values s1, s2, and\
    \ s3 were calculated per the\n   methods described in Section 4.3.  DHResult,\
    \ s1, s2, and s3 MUST all\n   be erased from memory immediately after they are\
    \ used to calculate\n   s0.\n   The length of the DHResult field was implicitly\
    \ agreed to by the\n   negotiated DH prime size.  The length of total_hash is\
    \ implicitly\n   determined by the negotiated hash algorithm.  All of the explicit\n\
    \   length fields, len(), in the above hash are 32-bit big-endian\n   integers,\
    \ giving the length in octets of the field that follows.\n   Some members of the\
    \ set of shared secrets (s1, s2, and s3) may have\n   lengths of zero if they\
    \ are null (not shared) and are each preceded\n   by a 4-octet length field. \
    \ For example, if s2 is null, len(s2) is\n   0x00000000, and s2 itself would be\
    \ absent from the hash calculation,\n   which means len(s3) would immediately\
    \ follow len(s2).  While\n   inclusion of ZIDi and ZIDr may be redundant, because\
    \ they are\n   implicitly included in the total_hash, we explicitly include them\n\
    \   here to follow NIST SP 800-56A.  The fixed-length string \"ZRTP-HMAC-\n  \
    \ KDF\" (not null-terminated) identifies for what purpose the resulting\n   s0\
    \ will be used, which is to serve as the key derivation key for the\n   ZRTP HMAC-based\
    \ key derivation function (KDF) defined in\n   Section 4.5.1 and used in Section\
    \ 4.5.3.\n   The authors believe ZRTP DH mode is in full compliance with two\n\
    \   relevant NIST documents that cover key derivations.  First, Section\n   5.8.1\
    \ of [NIST-SP800-56A] computes what NIST refers to as\n   DerivedKeyingMaterial,\
    \ which ZRTP refers to as s0.  This s0 then\n   serves as the key derivation key,\
    \ which NIST refers to as KI in the\n   key derivation function described in Sections\
    \ 5 and 5.1 of\n   [NIST-SP800-108], to derive all the rest of the subkeys needed\
    \ by\n   ZRTP.  For ECDH mode, the authors believe the s0 calculation is also\n\
    \   in compliance with Section 3.1 of the National Security Agency's\n   (NSA's)\
    \ Suite B Implementer's Guide to NIST SP 800-56A\n   [NSA-Suite-B-Guide-56A].\n\
    \   The ZRTP key derivation function (KDF) (Section 4.5.1) requires the\n   use\
    \ of a KDF Context field (per [NIST-SP800-108] guidelines), which\n   should include\
    \ the ZIDi, ZIDr, and a nonce value known to both\n   parties.  The total_hash\
    \ qualifies as a nonce value, because its\n   computation included nonce material\
    \ from the initiator's Commit\n   message and the responder's Hello message.\n\
    \      KDF_Context = (ZIDi || ZIDr || total_hash)\n   At this point in DH mode,\
    \ the two endpoints proceed to the key\n   derivations of ZRTPSess and the rest\
    \ of the keys in Section 4.5.2,\n   now that there is a defined s0.\n"
- title: 4.4.2.  Preshared Mode
  contents:
  - "4.4.2.  Preshared Mode\n   The Preshared key agreement mode can be used to generate\
    \ SRTP keys\n   and salts without a DH calculation, instead relying on a shared\n\
    \   secret from previous DH calculations between the endpoints.\n   This key agreement\
    \ mode is useful to rapidly re-establish a secure\n   session between two parties\
    \ who have recently started and ended a\n   secure session that has already performed\
    \ a DH key agreement, without\n   performing another lengthy DH calculation, which\
    \ may be desirable on\n   slow processors in resource-limited environments.  Preshared\
    \ mode\n   MUST NOT be used for adding additional media streams to an existing\n\
    \   call.  Multistream mode MUST be used for this purpose.\n   In the most severe\
    \ resource-limited environments, Preshared mode may\n   be useful with processors\
    \ that cannot perform a DH calculation in an\n   ergonomically acceptable time\
    \ limit.  Shared key material may be\n   manually provisioned between two such\
    \ endpoints in advance and still\n   allow a limited subset of functionality.\
    \  Such a \"better than\n   nothing\" implementation would have to be regarded\
    \ as non-compliant\n   with the ZRTP specification, but it could interoperate\
    \ in Preshared\n   (and if applicable, Multistream) mode with a compliant ZRTP\
    \ endpoint.\n   Because Preshared mode affects the state of the retained shared\n\
    \   secret cache, only one in-process ZRTP Preshared exchange may occur\n   at\
    \ a time between two ZRTP endpoints.  This rule is explained in more\n   detail\
    \ in Section 4.4.1, and applies for the same reasons as in DH\n   mode.\n   Preshared\
    \ mode is only included in this specification to meet the\n   R-REUSE requirement\
    \ in the Media Security Requirements [RFC5479]\n   document.  A series of preshared-keyed\
    \ calls between two ZRTP\n   endpoints should use a DH key exchange periodically.\
    \  Preshared mode\n   is only used if a cached shared secret has been established\
    \ in an\n   earlier session by a DH exchange, as discussed in Section 4.9.\n"
- title: 4.4.2.1.  Commitment in Preshared Mode
  contents:
  - "4.4.2.1.  Commitment in Preshared Mode\n   Preshared mode is selected by setting\
    \ the Key Agreement Type to\n   Preshared in the Commit message.  This results\
    \ in the same call flow\n   as Multistream mode.  The principal difference between\
    \ Multistream\n   mode and Preshared mode is that Preshared mode uses a previously\n\
    \   cached shared secret, rs1, instead of an active ZRTP Session key,\n   ZRTPSess,\
    \ as the initial keying material.\n   Preshared mode depends on having a reliable\
    \ shared secret in its\n   cache.  Before Preshared mode is used, the initial\
    \ DH exchange that\n   gave rise to the shared secret SHOULD have used at least\
    \ one of these\n   anti-MiTM mechanisms: 1) A verbal comparison of the SAS, evidenced\
    \ by\n   the SAS Verified flag, or 2) an end-to-end integrity-protected\n   delivery\
    \ of the a=zrtp-hash in the signaling (Section 8.1.1), or 3) a\n   digital signature\
    \ on the sashash (Section 7.2).\n"
- title: 4.4.2.2.  Initiator Behavior in Preshared Mode
  contents:
  - "4.4.2.2.  Initiator Behavior in Preshared Mode\n   The Commit message (Figure\
    \ 7) is sent by the initiator of the ZRTP\n   exchange.  From the intersection\
    \ of the algorithms in the sent and\n   received Hello messages, the initiator\
    \ chooses a hash, cipher, auth\n   tag, Key Agreement Type, and SAS Type to be\
    \ used.\n   To assemble a Preshared commit, we must first construct a temporary\n\
    \   preshared_key, which is constructed from one of several possible\n   combinations\
    \ of cached key material, depending on what is available\n   in the shared secret\
    \ cache.  If rs1 is not available in the\n   initiator's cache, then Preshared\
    \ mode MUST NOT be used.\n  preshared_key = hash(len(rs1) || rs1 || len(auxsecret)\
    \ || auxsecret ||\n                       len(pbxsecret) || pbxsecret)\n   All\
    \ of the explicit length fields, len(), in the above hash are 32-\n   bit big-endian\
    \ integers, giving the length in octets of the field\n   that follows.  Some members\
    \ of the set of shared secrets (rs1,\n   auxsecret, and pbxsecret) may have lengths\
    \ of zero if they are null\n   (not available), and are each preceded by a 4-octet\
    \ length field.\n   For example, if auxsecret is null, len(auxsecret) is 0x00000000,\
    \ and\n   auxsecret itself would be absent from the hash calculation, which\n\
    \   means len(pbxsecret) would immediately follow len(auxsecret).\n   In place\
    \ of hvi in the Commit message, two smaller fields are\n   inserted by the initiator:\n\
    \      - A random nonce of length 4 words (16 octets).\n      - A keyID = MAC(preshared_key,\
    \ \"Prsh\") truncated to 64 bits.\n      Note: Since the nonce is used to calculate\
    \ different SRTP key and\n      salt pairs for each session, a duplication will\
    \ result in the same\n      key and salt being generated for the two sessions,\
    \ which would\n      have disastrous security consequences.\n"
- title: 4.4.2.3.  Responder Behavior in Preshared Mode
  contents:
  - "4.4.2.3.  Responder Behavior in Preshared Mode\n   The responder uses the received\
    \ keyID to search for matching key\n   material in its cache.  It does this by\
    \ computing a preshared_key\n   value and keyID value using the same formula as\
    \ the initiator,\n   depending on what is available in the responder's local cache.\
    \  If\n   the locally computed keyID does not match the received keyID in the\n\
    \   Commit, the responder recomputes a new preshared_key and keyID from a\n  \
    \ different subset of shared keys from the cache, dropping auxsecret,\n   pbxsecret,\
    \ or both from the hash calculation, until a matching\n   preshared_key is found\
    \ or it runs out of possibilities.  Note that\n   rs2 is not included in the process.\n\
    \   If it finds the appropriate matching shared key material, it is used\n   to\
    \ derive s0 and a new ZRTPSess key, as described in the next section\n   on shared\
    \ secret calculation, Section 4.4.2.4.\n   If the responder determines that it\
    \ does not have a cached shared\n   secret from a previous DH exchange, or it\
    \ fails to match the keyID\n   hash from the initiator with any combination of\
    \ its shared keys, it\n   SHOULD respond with its own DH Commit message.  This\
    \ would reverse\n   the roles and the responder would become the initiator, because\
    \ the\n   DH Commit must always \"trump\" the Preshared Commit message as\n  \
    \ described in Section 4.2.  The key exchange would then proceed using\n   DH\
    \ mode.  However, if a severely resource-limited responder lacks the\n   computing\
    \ resources to respond in a reasonable time with a DH Commit,\n   it MAY respond\
    \ with a ZRTP Error message (Section 5.9) indicating\n   that no shared secret\
    \ is available.\n   If both sides send Preshared Commit messages initiating a\
    \ secure\n   session at the same time, the contention is resolved and the\n  \
    \ initiator/responder roles are settled according to Section 4.2, and\n   the\
    \ protocol proceeds.\n   In Preshared mode, both the DHPart1 and DHPart2 messages\
    \ are skipped.\n   After receiving the Commit message from the initiator, the\
    \ responder\n   sends the Confirm1 message after calculating this stream's SRTP\
    \ keys,\n   as described below.\n"
- title: 4.4.2.4.  Shared Secret Calculation for Preshared Mode
  contents:
  - "4.4.2.4.  Shared Secret Calculation for Preshared Mode\n   Preshared mode requires\
    \ that the s0 and ZRTPSess keys be derived from\n   the preshared_key, and this\
    \ must be done in a way that guarantees\n   uniqueness for each session.  This\
    \ is done by using nonce material\n   from both parties: the explicit nonce in\
    \ the initiator's Preshared\n   Commit message (Figure 7) and the H3 field in\
    \ the responder's Hello\n   message (Figure 3).  Thus, both parties force the\
    \ resulting shared\n   secret to be unique for each session.\n   A hash of the\
    \ received and sent ZRTP messages in the current ZRTP\n   exchange for the current\
    \ media stream is calculated:\n      total_hash = hash(Hello of responder || Commit)\n\
    \   Note that only the ZRTP messages (Figures 3 and 7), not the entire\n   ZRTP\
    \ packets, are included in the total_hash.\n   The ZRTP key derivation function\
    \ (KDF) (Section 4.5.1) requires the\n   use of a KDF Context field (per [NIST-SP800-108]\
    \ guidelines), which\n   should include the ZIDi, ZIDr, and a nonce value known\
    \ to both\n   parties.  The total_hash qualifies as a nonce value, because its\n\
    \   computation included nonce material from the initiator's Commit\n   message\
    \ and the responder's Hello message.\n      KDF_Context = (ZIDi || ZIDr || total_hash)\n\
    \   The s0 key is derived via the ZRTP key derivation function\n   (Section 4.5.1)\
    \ from preshared_key and the nonces implicitly included\n   in the total_hash.\
    \  The nonces also ensure KDF_Context is unique for\n   each session, which is\
    \ critical for security.\n    s0 = KDF(preshared_key, \"ZRTP PSK\", KDF_Context,\n\
    \                 negotiated hash length)\n   The preshared_key MUST be erased\
    \ as soon as it has been used to\n   calculate s0.\n   At this point in Preshared\
    \ mode, the two endpoints proceed to the key\n   derivations of ZRTPSess and the\
    \ rest of the keys in Section 4.5.2,\n   now that there is a defined s0.\n"
- title: 4.4.3.  Multistream Mode
  contents:
  - "4.4.3.  Multistream Mode\n   The Multistream key agreement mode can be used to\
    \ generate SRTP keys\n   and salts for additional media streams established between\
    \ a pair of\n   endpoints.  Multistream mode cannot be used unless there is an\
    \ active\n   SRTP session established between the endpoints, which means a ZRTP\n\
    \   Session key is active.  This ZRTP Session key can be used to generate\n  \
    \ keys and salts without performing another DH calculation.  In this\n   mode,\
    \ the retained shared secret cache is not used or updated.  As a\n   result, multiple\
    \ ZRTP Multistream mode exchanges can be processed in\n   parallel between two\
    \ endpoints.\n   Multistream mode is also used to resume a secure call that has\
    \ gone\n   clear using a GoClear message as described in Section 4.7.2.1.\n  \
    \ When adding additional media streams to an existing call, Multistream\n   mode\
    \ MUST be used.  The first media stream MUST use either DH mode or\n   Preshared\
    \ mode.  Only one DH exchange or Preshared exchange is\n   performed, just for\
    \ the first media stream.  The DH exchange or\n   Preshared exchange MUST be completed\
    \ for the first media stream\n   before Multistream mode is used to add any other\
    \ media streams.  In a\n   Multistream session, a ZRTP endpoint MUST use the same\
    \ ZID for all\n   media streams, matching the ZID used in the first media stream.\n"
- title: 4.4.3.1.  Commitment in Multistream Mode
  contents:
  - "4.4.3.1.  Commitment in Multistream Mode\n   Multistream mode is selected by\
    \ the initiator setting the Key\n   Agreement Type to \"Mult\" in the Commit message\
    \ (Figure 6).  The\n   Cipher Type, Auth Tag Length, and Hash in Multistream mode\
    \ SHOULD be\n   set by the initiator to the same as the values as in the initial\
    \ DH\n   Mode Commit.  The SAS Type is ignored as there is no SAS\n   authentication\
    \ in this mode.\n      Note: This requirement is needed since some endpoints cannot\n\
    \      support different SRTP algorithms for different media streams.\n      However,\
    \ in the case of Multistream mode being used to go secure\n      after a GoClear,\
    \ the requirement to use the same SRTP algorithms\n      is relaxed if there are\
    \ no other active SRTP sessions.\n   In place of hvi in the Commit, a random nonce\
    \ of length 4 words (16\n   octets) is chosen.  Its value MUST be unique for all\
    \ nonce values\n   chosen for active ZRTP sessions between a pair of endpoints.\
    \  If a\n   Commit is received with a reused nonce value, the ZRTP exchange MUST\n\
    \   be immediately terminated.\n      Note: Since the nonce is used to calculate\
    \ different SRTP key and\n      salt pairs for each media stream, a duplication\
    \ will result in the\n      same key and salt being generated for the two media\
    \ streams, which\n      would have disastrous security consequences.\n   If a\
    \ Commit is received selecting Multistream mode, but the responder\n   does not\
    \ have a ZRTP Session Key available, the exchange MUST be\n   terminated.  Otherwise,\
    \ the responder proceeds to the next section on\n   shared secret calculation,\
    \ Section 4.4.3.2.\n   If both sides send Multistream Commit messages at the same\
    \ time, the\n   contention is resolved and the initiator/responder roles are settled\n\
    \   according to Section 4.2, and the protocol proceeds.\n   In Multistream mode,\
    \ both the DHPart1 and DHPart2 messages are\n   skipped.  After receiving the\
    \ Commit message from the initiator, the\n   responder sends the Confirm1 message\
    \ after calculating this stream's\n   SRTP keys, as described below.\n"
- title: 4.4.3.2.  Shared Secret Calculation for Multistream Mode
  contents:
  - "4.4.3.2.  Shared Secret Calculation for Multistream Mode\n   In Multistream mode,\
    \ each media stream requires that a set of keys be\n   derived from the ZRTPSess\
    \ key, and this must be done in a way that\n   guarantees uniqueness for each\
    \ media stream.  This is done by using\n   nonce material from both parties: the\
    \ explicit nonce in the\n   initiator's Multistream Commit message (Figure 6)\
    \ and the H3 field in\n   the responder's Hello message (Figure 3).  Thus, both\
    \ parties force\n   the resulting shared secret to be unique for each media stream.\n\
    \   A hash of the received and sent ZRTP messages in the current ZRTP\n   exchange\
    \ for the current media stream is calculated:\n      total_hash = hash(Hello of\
    \ responder || Commit)\n   This refers to the Hello and Commit messages for the\
    \ current media\n   stream, which is using Multistream mode, not the original\
    \ media\n   stream that included a full DH key agreement.  Note that only the\n\
    \   ZRTP messages (Figures 3 and 6), not the entire ZRTP packets, are\n   included\
    \ in the hash.\n   The ZRTP key derivation function (KDF) (Section 4.5.1) requires\
    \ the\n   use of a KDF Context field (per [NIST-SP800-108] guidelines), which\n\
    \   should include the ZIDi, ZIDr, and a nonce value known to both\n   parties.\
    \  The total_hash qualifies as a nonce value, because its\n   computation included\
    \ nonce material from the initiator's Commit\n   message and the responder's Hello\
    \ message.\n      KDF_Context = (ZIDi || ZIDr || total_hash)\n   The current stream's\
    \ SRTP keys and salts for the initiator and\n   responder are calculated using\
    \ the ZRTP Session Key ZRTPSess and the\n   nonces implicitly included in the\
    \ total_hash.  The nonces also ensure\n   that KDF_Context will be unique for\
    \ each media stream, which is\n   critical for security.  For each additional\
    \ media stream, a separate\n   s0 is derived from ZRTPSess via the ZRTP key derivation\
    \ function\n   (Section 4.5.1):\n     s0 = KDF(ZRTPSess, \"ZRTP MSK\", KDF_Context,\n\
    \                            negotiated hash length)\n   Note that the ZRTPSess\
    \ key was previously derived from material that\n   also includes a different\
    \ and more inclusive total_hash from the\n   entire packet sequence that performed\
    \ the original DH exchange for\n   the first media stream in this ZRTP session.\n\
    \   At this point in Multistream mode, the two endpoints begin key\n   derivations\
    \ in Section 4.5.3.\n"
- title: 4.5.  Key Derivations
  contents:
  - '4.5.  Key Derivations

    '
- title: 4.5.1.  The ZRTP Key Derivation Function
  contents:
  - "4.5.1.  The ZRTP Key Derivation Function\n   To derive keys from a shared secret,\
    \ ZRTP uses an HMAC-based key\n   derivation function, or KDF.  It is used throughout\
    \ Section 4.5.3 and\n   in other sections.  The HMAC function for the KDF is based\
    \ on the\n   negotiated hash algorithm defined in Section 5.1.2.\n   The authors\
    \ believe the ZRTP KDF is in full compliance with the\n   recommendations in NIST\
    \ SP 800-108 [NIST-SP800-108].  Section 7.5 of\n   the NIST document describes\
    \ \"key separation\", which is a security\n   requirement for the cryptographic\
    \ keys derived from the same key\n   derivation key.  The keys shall be separate\
    \ in the sense that the\n   compromise of some derived keys will not degrade the\
    \ security\n   strength of any of the other derived keys or the security strength\
    \ of\n   the key derivation key.  Strong preimage resistance is provided.\n  \
    \ The ZRTP KDF runs the NIST pseudorandom function (PRF) in counter\n   mode,\
    \ with only a single iteration of the counter.  The NIST PRF is\n   based on the\
    \ HMAC function.  The ZRTP KDF never has to generate more\n   than 256 bits (or\
    \ 384 bits for Suite B applications) of output key\n   material, so only a single\
    \ invocation of the HMAC function is needed.\n   The ZRTP KDF is defined in this\
    \ manner, per Sections 5 and 5.1 of\n   [NIST-SP800-108]:\n      KDF(KI, Label,\
    \ Context, L) = HMAC(KI, i || Label ||\n            0x00 || Context || L)\n  \
    \ The HMAC in the KDF is keyed by KI, which is a secret key derivation\n   key\
    \ that is unknown to the wiretapper (for example, s0).  The HMAC is\n   computed\
    \ on a concatenated set of nonsecret fields that are defined\n   as follows. \
    \ The first field is a 32-bit big-endian integer counter\n   (i) required by NIST\
    \ to be included in the HMAC each time the HMAC is\n   computed, which we have\
    \ set to the fixed value of 0x000001 because we\n   only compute the HMAC once.\
    \  Label is a string of nonzero octets that\n   identifies the purpose for the\
    \ derived keying material.  The octet\n   0x00 is a delimiter required by NIST.\
    \  The NIST KDF formula has a\n   \"Context\" field that includes ZIDi, ZIDr,\
    \ and some optional nonce\n   material known to both parties.  L is a 32-bit big-endian\
    \ positive\n   integer, not to exceed the length in bits of the output of the\
    \ HMAC.\n   The output of the KDF is truncated to the leftmost L bits.  If SHA-\n\
    \   384 is the negotiated hash algorithm, the HMAC would be HMAC-SHA-384;\n  \
    \ thus, the maximum value of L would be 384, the negotiated hash\n   length.\n\
    \   The ZRTP KDF is not to be confused with the SRTP KDF defined in\n   [RFC3711].\n"
- title: 4.5.2.  Deriving ZRTPSess Key and SAS in DH or Preshared Modes
  contents:
  - "4.5.2.  Deriving ZRTPSess Key and SAS in DH or Preshared Modes\n   Both DH mode\
    \ and Preshared mode (but not Multistream mode) come to\n   this common point\
    \ in the protocol to derive ZRTPSess and the SAS from\n   s0, via the ZRTP Key\
    \ Derivation Function (Section 4.5.1).  At this\n   point, s0 has been calculated,\
    \ as well as KDF_Context.  These\n   calculations are done only for the first\
    \ media stream, not for\n   Multistream mode.\n   The ZRTPSess key is used only\
    \ for these two purposes: 1) to generate\n   the additional s0 keys (Section 4.4.3.2)\
    \ for adding additional media\n   streams to this session in Multistream mode,\
    \ and 2) to generate the\n   pbxsecret (Section 7.3.1) that may be cached for\
    \ use in future\n   sessions.  The ZRTPSess key is kept for the duration of the\
    \ call\n   signaling session between the two ZRTP endpoints.  That is, if there\n\
    \   are two separate calls between the endpoints (in SIP terms, separate\n   SIP\
    \ dialogs), then a ZRTP Session Key MUST NOT be used across the two\n   call signaling\
    \ sessions.  ZRTPSess MUST be destroyed no later than\n   the end of the call\
    \ signaling session.\n      ZRTPSess = KDF(s0, \"ZRTP Session Key\", KDF_Context,\n\
    \                       negotiated hash length)\n   Note that KDF_Context is unique\
    \ for each media stream, but only the\n   first media stream is permitted to calculate\
    \ ZRTPSess.\n   There is only one Short Authentication String (SAS) (Section 7)\n\
    \   computed per call, which is applicable to all media streams derived\n   from\
    \ a single DH key agreement in a ZRTP session.  KDF_Context is\n   unique for\
    \ each media stream, but only the first media stream is\n   permitted to calculate\
    \ sashash.\n      sashash = KDF(s0, \"SAS\", KDF_Context, 256)\n      sasvalue\
    \ = sashash [truncated to leftmost 32 bits]\n   Despite the exposure of the SAS\
    \ to the two parties, the rest of the\n   keying material is protected by the\
    \ key separation properties of the\n   KDF (Section 4.5.1).\n   ZRTP-enabled VoIP\
    \ clients may need to support additional forms of\n   communication, such as text\
    \ chat, instant messaging, or file\n   transfers.  These other forms of communication\
    \ may need to be\n   encrypted, and would benefit from leveraging the ZRTP key\
    \ exchange\n   used for the VoIP part of the call.  In that case, more key material\n\
    \   MAY be derived and \"exported\" from the ZRTP protocol and provided as\n \
    \  a shared secret to the VoIP client for these non-VoIP purposes.  The\n   application\
    \ can use this exported key in application-specific ways,\n   outside the scope\
    \ of the ZRTP protocol.\n      ExportedKey = KDF(s0, \"Exported key\", KDF_Context,\n\
    \                           negotiated hash length)\n   Only one ExportedKey is\
    \ computed per call.  KDF_Context is unique for\n   each media stream, but only\
    \ the first media stream is permitted to\n   calculate ExportedKey.\n   The application\
    \ may use this exported key to derive other subkeys for\n   various non-ZRTP purposes,\
    \ via a KDF using separate KDF label strings\n   defined by the application. \
    \ This key or its derived subkeys can be\n   used for encryption, or used to authenticate\
    \ other key exchanges\n   carried out by the application, protected by ZRTP's\
    \ MiTM defense\n   umbrella.  The exported key and its descendants may be used\
    \ for as\n   long as needed by the application, maintained in a separate crypto\n\
    \   context that may outlast the VoIP session.\n   At this point in DH mode or\
    \ Preshared mode, the two endpoints proceed\n   on to the key derivations in Section\
    \ 4.5.3, now that there is a\n   defined s0 and ZRTPSess key.\n"
- title: 4.5.3.  Deriving the Rest of the Keys from s0
  contents:
  - "4.5.3.  Deriving the Rest of the Keys from s0\n   DH mode, Multistream mode,\
    \ and Preshared mode all come to this common\n   point in the protocol to derive\
    \ a set of keys from s0.  It can be\n   assumed that s0 has been calculated, as\
    \ well the ZRTPSess key and\n   KDF_Context.  A separate s0 key is associated\
    \ with each media stream.\n   Subkeys are not drawn directly from s0, as done\
    \ in NIST SP 800-56A.\n   To enhance key separation, ZRTP uses s0 to key a Key\
    \ Derivation\n   Function (Section 4.5.1) based on [NIST-SP800-108].  Since s0\
    \ already\n   included total_hash in its derivation, it is redundant to use\n\
    \   total_hash again in the KDF Context in all the invocations of the KDF\n  \
    \ keyed by s0.  Nonetheless, NIST SP 800-108 always requires KDF\n   Context to\
    \ be defined for the KDF, and nonce material is required in\n   some KDF invocations\
    \ (especially for Multistream mode and Preshared\n   mode), so total_hash is included\
    \ as a nonce in the KDF Context.\n   Separate SRTP master keys and master salts\
    \ are derived for use in\n   each direction for each media stream.  Unless otherwise\
    \ specified,\n   ZRTP uses SRTP with no Master Key Identifier (MKI), 32-bit\n\
    \   authentication using HMAC-SHA1, AES-CM 128 or 256-bit key length,\n   112-bit\
    \ session salt key length, 2^48 key derivation rate, and SRTP\n   prefix length\
    \ 0.  Secure RTCP (SRTCP) is also used, deriving the\n   SRTCP keys from the same\
    \ master keys and salts as SRTP, using the\n   mechanisms specified in [RFC3711],\
    \ without requiring a separate ZRTP\n   negotiation for RTCP.\n   The ZRTP initiator\
    \ encrypts and the ZRTP responder decrypts packets\n   by using srtpkeyi and srtpsalti,\
    \ while the ZRTP responder encrypts\n   and the ZRTP initiator decrypts packets\
    \ by using srtpkeyr and\n   srtpsaltr.  The SRTP key and salt values are truncated\
    \ (taking the\n   leftmost bits) to the length determined by the chosen SRTP profile.\n\
    \   These are generated by:\n     srtpkeyi = KDF(s0, \"Initiator SRTP master key\"\
    , KDF_Context,\n                     negotiated AES key length)\n     srtpsalti\
    \ = KDF(s0, \"Initiator SRTP master salt\", KDF_Context, 112)\n     srtpkeyr =\
    \ KDF(s0, \"Responder SRTP master key\", KDF_Context,\n                     negotiated\
    \ AES key length)\n     srtpsaltr = KDF(s0, \"Responder SRTP master salt\", KDF_Context,\
    \ 112)\n   The MAC keys are the same length as the output of the underlying hash\n\
    \   function in the KDF and are thus generated without truncation.  They\n   are\
    \ used only by ZRTP and not by SRTP.  Different MAC keys are needed\n   for the\
    \ initiator and the responder to ensure that GoClear messages\n   in each direction\
    \ are unique and can not be cached by an attacker and\n   reflected back to the\
    \ endpoint.\n      mackeyi = KDF(s0, \"Initiator HMAC key\", KDF_Context,\n  \
    \                    negotiated hash length)\n      mackeyr = KDF(s0, \"Responder\
    \ HMAC key\", KDF_Context,\n                      negotiated hash length)\n  \
    \ ZRTP keys are generated for the initiator and responder to use to\n   encrypt\
    \ the Confirm1 and Confirm2 messages.  They are truncated to\n   the same size\
    \ as the negotiated SRTP key size.\n      zrtpkeyi = KDF(s0, \"Initiator ZRTP\
    \ key\", KDF_Context,\n                      negotiated AES key length)\n    \
    \  zrtpkeyr = KDF(s0, \"Responder ZRTP key\", KDF_Context,\n                 \
    \     negotiated AES key length)\n   All key material is destroyed as soon as\
    \ it is no longer needed, no\n   later than the end of the call. s0 is erased\
    \ in Section 4.6.1, and\n   the rest of the session key material is erased in\
    \ Sections 4.7.2.1\n   and 4.7.3.\n"
- title: 4.6.  Confirmation
  contents:
  - "4.6.  Confirmation\n   The Confirm1 and Confirm2 messages (Figure 10) contain\
    \ the cache\n   expiration interval (defined in Section 4.9) for the newly generated\n\
    \   retained shared secret.  The flagoctet is an 8-bit unsigned integer\n   made\
    \ up of these flags: the PBX Enrollment flag (E) defined in\n   Section 7.3.1,\
    \ the SAS Verified flag (V) defined in Section 7.1, the\n   Allow Clear flag (A)\
    \ defined in Section 4.7.2, and the Disclosure\n   flag (D) defined in Section\
    \ 11.\n      flagoctet =  (E * 2^3) + (V * 2^2) + (A * 2^1) + (D * 2^0)\n   Part\
    \ of the Confirm1 and Confirm2 messages are encrypted using full-\n   block Cipher\
    \ Feedback Mode and contain a 128-bit random Cipher\n   FeedBack (CFB) Initialization\
    \ Vector (IV).  The Confirm1 and Confirm2\n   messages also contain a MAC covering\
    \ the encrypted part of the\n   Confirm1 or Confirm2 message that includes a string\
    \ of zeros, the\n   signature length, flag octet, cache expiration interval, signature\n\
    \   type block (if present), and signature (Section 7.2) (if present).\n   For\
    \ the responder:\n      confirm_mac = MAC(mackeyr, encrypted part of Confirm1)\n\
    \   For the initiator:\n      confirm_mac = MAC(mackeyi, encrypted part of Confirm2)\n\
    \   The mackeyi and mackeyr keys are computed in Section 4.5.3.\n   The exchange\
    \ is completed when the responder sends either the\n   Conf2ACK message or the\
    \ responder's first SRTP media packet (with a\n   valid SRTP auth tag).  The initiator\
    \ MUST treat the first valid SRTP\n   media from the responder as equivalent to\
    \ receiving a Conf2ACK.  The\n   responder may respond to Confirm2 with either\
    \ SRTP media, Conf2ACK,\n   or both, in whichever order the responder chooses\
    \ (or whichever order\n   the \"cloud\" chooses to deliver them).\n"
- title: 4.6.1.  Updating the Cache of Shared Secrets
  contents:
  - "4.6.1.  Updating the Cache of Shared Secrets\n   After receiving the Confirm\
    \ messages, both parties must now update\n   their retained shared secret rs1\
    \ in their respective caches, provided\n   the following conditions hold:\n  \
    \ (1)  This key exchange is either DH or Preshared mode, not\n        Multistream\
    \ mode, which does not update the cache.\n   (2)  Depending on the values of the\
    \ cache expiration intervals that\n        are received in the two Confirm messages,\
    \ there are some\n        scenarios that do not update the cache, as explained\
    \ in\n        Section 4.9.\n   (3)  The responder MUST receive the initiator's\
    \ Confirm2 message\n        before updating the responder's cache.\n   (4)  The\
    \ initiator MUST receive either the responder's Conf2ACK\n        message or the\
    \ responder's SRTP media (with a valid SRTP auth\n        tag) before updating\
    \ the initiator's cache.\n   The cache update may also be affected by a cache\
    \ mismatch, according\n   to Section 4.6.1.1.\n   For DH mode only, before updating\
    \ the retained shared secret rs1 in\n   the cache, each party first discards their\
    \ old rs2 and copies their\n   old rs1 to rs2.  The old rs1 is saved to rs2 because\
    \ of the risk of\n   session interruption after one party has updated his own\
    \ rs1 but\n   before the other party has enough information to update her own\
    \ rs1.\n   If that happens, they may regain cache sync in the next session by\n\
    \   using rs2 (per Section 4.3).  This mitigates the well-known Two\n   Generals'\
    \ Problem [Byzantine].  The old rs1 value is not saved in\n   Preshared mode.\n\
    \   For DH mode and Preshared mode, both parties compute a new rs1 value\n   from\
    \ s0 via the ZRTP key derivation function (Section 4.5.1):\n      rs1 = KDF(s0,\
    \ \"retained secret\", KDF_Context, 256)\n   Note that KDF_Context is unique for\
    \ each media stream, but only the\n   first media stream is permitted to update\
    \ rs1.\n   Each media stream has its own s0.  At this point in the protocol for\n\
    \   each media stream, the corresponding s0 MUST be erased.\n"
- title: 4.6.1.1.  Cache Update Following a Cache Mismatch
  contents:
  - "4.6.1.1.  Cache Update Following a Cache Mismatch\n   If a shared secret cache\
    \ mismatch (as defined in Section 4.3.2) is\n   detected in the current session,\
    \ it indicates a possible MiTM attack.\n   However, there may be evidence to the\
    \ contrary, if either one of the\n   following conditions are met:\n   o  Successful\
    \ use of the mechanism described in Section 8.1.1, but\n      only if fully supported\
    \ by end-to-end integrity-protected delivery\n      of the a=zrtp-hash in the\
    \ signaling via SIP Identity [RFC4474] or\n      better still, Dan Wing's SIP\
    \ Identity using Media Path\n      [SIP-IDENTITY].  This allows authentication\
    \ of the DH exchange\n      without human assistance.\n   o  A good signature\
    \ is received and verified using the digital\n      signature feature on the SAS\
    \ hash, as described in Section 7.2, if\n      this feature is supported.\n  \
    \ If there is a cache mismatch in the absence of the aforementioned\n   mitigating\
    \ evidence, the cache update MUST be delayed in the current\n   session until\
    \ the user verbally compares the SAS with his partner\n   during the call and\
    \ confirms a successful SAS verify via his user\n   interface as described in\
    \ Section 7.1.  If the session ends before\n   that happens, the cache update\
    \ is not performed, leaving the rs1/rs2\n   values unmodified in the cache.  Regardless\
    \ of whether a cache\n   mismatch occurs, s0 must still be erased.\n   If no cache\
    \ entry exists, as is the case in the initial call, the\n   cache update is handled\
    \ in the normal fashion.\n"
- title: 4.7.  Termination
  contents:
  - "4.7.  Termination\n   A ZRTP session is normally terminated at the end of a call,\
    \ but it\n   may be terminated early by either the Error message or the GoClear\n\
    \   message.\n"
- title: 4.7.1.  Termination via Error Message
  contents:
  - "4.7.1.  Termination via Error Message\n   The Error message (Section 5.9) is\
    \ used to terminate an in-progress\n   ZRTP exchange due to an error.  The Error\
    \ message contains an integer\n   Error Code for debugging purposes.  The termination\
    \ of a ZRTP key\n   agreement exchange results in no updates to the cached shared\
    \ secrets\n   and deletion of all crypto context for that media stream.  The ZRTP\n\
    \   Session key, ZRTPSess, is only deleted if all ZRTP media streams that\n  \
    \ are using it are terminated.\n   Because no key agreement has been reached,\
    \ the Error message cannot\n   use the same MAC protection as the GoClear message.\
    \  A denial of\n   service is possible by injecting fake Error messages.  (However,\
    \ even\n   if the Error message were somehow designed with integrity protection,\n\
    \   it would raise other questions.  What would a badly formed Error\n   message\
    \ mean if it were sent to report a badly formed message?  A\n   good message?)\n"
- title: 4.7.2.  Termination via GoClear Message
  contents:
  - "4.7.2.  Termination via GoClear Message\n   The GoClear message (Section 5.11)\
    \ is used to switch from SRTP to\n   RTP, usually because the user has chosen\
    \ to do that by pressing a\n   button.  The GoClear uses a MAC of the Message\
    \ Type Block sent in the\n   GoClear message computed with the mackey derived\
    \ from the shared\n   secret.  This MAC is truncated to the leftmost 64 bits.\
    \  When sent by\n   the initiator:\n      clear_mac = MAC(mackeyi, \"GoClear \"\
    )\n   When sent by the responder:\n      clear_mac = MAC(mackeyr, \"GoClear \"\
    )\n   Both of these MACs are calculated across the 8-octet \"GoClear \"\n   Message\
    \ Type Block, including the trailing space.\n   A GoClear message that does not\
    \ receive a ClearACK response must be\n   resent.  If a GoClear message is received\
    \ with a bad MAC, ClearACK\n   MUST NOT be sent and the GoClear MUST NOT be acted\
    \ on by the\n   recipient, but it MAY be processed as a security exception, perhaps\n\
    \   by logging or alerting the user.\n   A ZRTP endpoint MAY choose to accept\
    \ GoClear messages after the\n   session has switched to SRTP, allowing the session\
    \ to revert to RTP.\n   This is indicated in the Confirm1 or Confirm2 messages\
    \ (Figure 10) by\n   setting the Allow Clear flag (A).  If an endpoint sets the\
    \ Allow\n   Clear (A) flag in their Confirm message, it indicates that they\n\
    \   support receiving GoClear messages.\n   A ZRTP endpoint that receives a GoClear\
    \ MUST authenticate the message\n   by checking the clear_mac.  If the message\
    \ authenticates, the\n   endpoint stops sending SRTP packets, and generates a\
    \ ClearACK in\n   response.  It MUST also delete all the crypto key material for\
    \ all\n   the SRTP media streams, as defined in Section 4.7.2.1.\n   Until confirmation\
    \ from the user is received (e.g., clicking a\n   button, pressing a dual-tone\
    \ multi-frequency (DTMF) key, etc.), the\n   ZRTP endpoint MUST NOT resume sending\
    \ RTP packets.  The endpoint then\n   renders to the user an indication that the\
    \ media session has switched\n   to clear mode and waits for confirmation from\
    \ the user.  This blocks\n   the flow of sensitive discourse until the user is\
    \ forced to take\n   notice that he's no longer protected by encryption.  To prevent\n\
    \   pinholes from closing or NAT bindings from expiring, the ClearACK\n   message\
    \ MAY be resent at regular intervals (e.g., every 5 seconds)\n   while waiting\
    \ for confirmation from the user.  After confirmation of\n   the notification\
    \ is received from the user, the sending of RTP\n   packets may begin.\n   After\
    \ sending a GoClear message, the ZRTP endpoint stops sending SRTP\n   packets.\
    \  When a ClearACK is received, the ZRTP endpoint deletes the\n   crypto context\
    \ for the SRTP session, as defined in Section 4.7.2.1,\n   and may then resume\
    \ sending RTP packets.\n   In the event a ClearACK is not received before the\
    \ retransmissions of\n   GoClear are exhausted, the key material is deleted, as\
    \ defined in\n   Section 4.7.2.1.\n   After the users have transitioned from SRTP\
    \ media back to RTP media\n   (clear mode), they may decide later to return to\
    \ secure mode by\n   manual activation, usually by pressing a GO SECURE button.\
    \  In that\n   case, a new secure session is initiated by the party that presses\
    \ the\n   button, by sending a new Commit message, leading to a new session key\n\
    \   negotiation.  It is not necessary to send another Hello message, as\n   the\
    \ two parties have already done that at the start of the call and\n   thus have\
    \ already discovered each other's ZRTP capabilities.  It is\n   possible for users\
    \ to toggle back and forth between clear and secure\n   modes multiple times in\
    \ the same session, just as they could in the\n   old days of secure PSTN phones.\n"
- title: 4.7.2.1.  Key Destruction for GoClear Message
  contents:
  - "4.7.2.1.  Key Destruction for GoClear Message\n   All SRTP session key material\
    \ MUST be erased by the receiver of the\n   GoClear message upon receiving a properly\
    \ authenticated GoClear.  The\n   same key destruction MUST be done by the sender\
    \ of GoClear message,\n   upon receiving the ClearACK.  This must be done for\
    \ the key material\n   for all of the media streams.\n   All key material that\
    \ would have been erased at the end of the SIP\n   session MUST be erased, as\
    \ described in Section 4.7.3, with the\n   single exception of ZRTPSess.  In this\
    \ case, ZRTPSess is destroyed in\n   a manner different from the other key material.\
    \  Both parties replace\n   ZRTPSess with a KDF-derived non-invertible function\
    \ of itself:\n      ZRTPSess = KDF(ZRTPSess, \"New ZRTP Session\", (ZIDi || ZIDr),\n\
    \                       negotiated hash length)\n   ZRTPSess will be replaced\
    \ twice if a session generates separate\n   GoClear messages for both audio and\
    \ video streams, and the two\n   endpoints need not carry out the replacements\
    \ in the same order.\n   The destruction of key material meets the requirements\
    \ of Perfect\n   Forward Secrecy (PFS), but still preserves a new version of ZRTPSess,\n\
    \   so that the user can later re-initiate secure mode during the same\n   session\
    \ without performing another Diffie-Hellman calculation using\n   Multistream\
    \ mode, which requires and assumes the existence of\n   ZRTPSess with the same\
    \ value at both ZRTP endpoints.  A new key\n   negotiation after a GoClear SHOULD\
    \ use a Multistream Commit message.\n      Note: Multistream mode is preferred\
    \ over a Diffie-Hellman mode\n      since this does not require the generation\
    \ of a new hash chain and\n      a new signaling exchange to exchange new Hello\
    \ Hash values.\n   Later, at the end of the entire call, ZRTPSess is finally destroyed\n\
    \   along with the other key material, as described in Section 4.7.3.\n"
- title: 4.7.3.  Key Destruction at Termination
  contents:
  - "4.7.3.  Key Destruction at Termination\n   All SRTP session key material MUST\
    \ be erased by both parties at the\n   end of the call.  In particular, the destroyed\
    \ key material includes\n   the SRTP session keys and salts, SRTP master keys\
    \ and salts, and all\n   material sufficient to reconstruct the SRTP keys and\
    \ salts, including\n   ZRTPSess and s0 (although s0 should have been destroyed\
    \ earlier, in\n   Section 4.6.1).  This must be done for the key material for\
    \ all of\n   the media streams.  The only exceptions are the cached shared secrets\n\
    \   needed for future sessions, including rs1, rs2, and pbxsecret.\n"
- title: 4.8.  Random Number Generation
  contents:
  - "4.8.  Random Number Generation\n   The ZRTP protocol uses random numbers for\
    \ cryptographic key material,\n   notably for the DH secret exponents and nonces,\
    \ which must be freshly\n   generated with each session.  Whenever a random number\
    \ is needed, all\n   of the following criteria must be satisfied:\n   Random numbers\
    \ MUST be freshly generated, meaning that they must not\n   have been used in\
    \ a previous calculation.\n   When generating a random number k of L bits in length,\
    \ k MUST be\n   chosen with equal probability from the range of [1 < k < 2^L].\n\
    \   It MUST be derived from a physical entropy source, such as radio\n   frequency\
    \ (RF) noise, acoustic noise, thermal noise, high-resolution\n   timings of environmental\
    \ events, or other unpredictable physical\n   sources of entropy.  One possible\
    \ source of entropy for a VoIP client\n   would be microphone noise.  For a detailed\
    \ explanation of\n   cryptographic grade random numbers and guidance for collecting\n\
    \   suitable entropy, see [RFC4086] and Chapter 10 of \"Practical\n   Cryptography\"\
    \ [Ferguson].  The raw entropy must be distilled and\n   processed through a deterministic\
    \ random-bit generator (DRBG).\n   Examples of DRBGs may be found in [NIST-SP800-90],\
    \ in [Ferguson], and\n   in [RFC5869].  Failure to use true entropy from the physical\n\
    \   environment as a basis for generating random cryptographic key\n   material\
    \ would lead to a disastrous loss of security.\n"
- title: 4.9.  ZID and Cache Operation
  contents:
  - "4.9.  ZID and Cache Operation\n   Each instance of ZRTP has a unique 96-bit random\
    \ ZRTP ID, or ZID,\n   that is generated once at installation time.  It is used\
    \ to look up\n   retained shared secrets in a local cache.  A single global ZID\
    \ for a\n   single installation is the simplest way to implement ZIDs.  However,\n\
    \   it is specifically not precluded for an implementation to use\n   multiple\
    \ ZIDs, up to the limit of a separate one per callee.  This\n   then turns it\
    \ into a long-lived \"association ID\" that does not apply\n   to any other associations\
    \ between a different pair of parties.  It is\n   a goal of this protocol to permit\
    \ both options to interoperate\n   freely.  A PBX acting as a trusted man in the\
    \ middle will also\n   generate a single ZID and use that ZID for all endpoints\
    \ behind it,\n   as described in Section 10.\n   There is no protocol mechanism\
    \ to invalidate a previously used ZID.\n   An endpoint wishing to change ZIDs\
    \ would simply generate a new one\n   and begin using it.\n   The ZID should not\
    \ be hard coded or hard defined in the firmware of a\n   product.  It should be\
    \ randomly generated by the software and stored\n   at installation or initialization\
    \ time.  It should be randomly\n   generated rather than allocated from a preassigned\
    \ range of ZID\n   values, because 96 bits should be enough to avoid birthday\
    \ collisions\n   in realistic scenarios.\n   Each time a new s0 is calculated,\
    \ a new retained shared secret rs1 is\n   generated and stored in the cache, indexed\
    \ by the ZID of the other\n   endpoint.  This cache updating is described in Section\
    \ 4.6.1.  For\n   the new retained shared secret, each endpoint chooses a cache\n\
    \   expiration value that is an unsigned 32-bit integer of the number of\n   seconds\
    \ that this secret should be retained in the cache.  The time\n   interval is\
    \ relative to when the Confirm1 message is sent or\n   received.\n   The cache\
    \ intervals are exchanged in the Confirm1 and Confirm2\n   messages (Figure 10).\
    \  The actual cache interval used by both\n   endpoints is the minimum of the\
    \ values from the Confirm1 and Confirm2\n   messages.  A value of 0 seconds means\
    \ the newly computed shared\n   secret SHOULD NOT be stored in the cache, and\
    \ if a cache entry\n   already exists from an earlier call, the stored cache interval\
    \ should\n   be set to 0.  This means if either Confirm message contains a null\n\
    \   cache expiration interval, and there is no cache entry already\n   defined,\
    \ no new cache entry is created.  A value of 0xffffffff means\n   the secret should\
    \ be cached indefinitely and is the recommended\n   value.  If the ZRTP exchange\
    \ is Multistream mode, the field in the\n   Confirm1 and Confirm2 is set to 0xffffffff\
    \ and is ignored; the cache\n   is not updated.\n   The expiration interval need\
    \ not be used to force the deletion of a\n   shared secret from the cache when\
    \ the interval has expired.  It just\n   means the shared secret MAY be deleted\
    \ from that cache at any point\n   after the interval has expired without causing\
    \ the other party to\n   note it as an unexpected security event when the next\
    \ key negotiation\n   occurs between the same two parties.  This means there need\
    \ not be\n   perfectly synchronized deletion of expired secrets from the two\n\
    \   caches, and makes it easy to avoid a race condition that might\n   otherwise\
    \ be caused by clock skew.\n   If the expiration interval is not properly agreed\
    \ to by both\n   endpoints, it may later result in false alarms of MiTM attacks,\
    \ due\n   to apparent cache mismatches (Section 4.3.2).\n   The relationship between\
    \ a ZID and a SIP AOR is explained in\n   Section 12.\n"
- title: 4.9.1.  Cacheless Implementations
  contents:
  - "4.9.1.  Cacheless Implementations\n   It is possible to implement a simplified\
    \ but nonetheless useful (and\n   still compliant) profile of the ZRTP protocol\
    \ that does not support\n   any caching of shared secrets.  In this case, the\
    \ users would have to\n   rely exclusively on the verbal SAS comparison for every\
    \ call.  That\n   is, unless MiTM protection is provided by the mechanisms in\
    \ Section\n   8.1.1 or 7.2, which introduce their own forms of complexity.\n \
    \  If a ZRTP endpoint does not support the caching of shared secrets, it\n   MUST\
    \ set the cache expiration interval to zero, and MUST set the SAS\n   Verified\
    \ (V) flag (Section 7.1) to false.  In addition, because the\n   ZID serves mainly\
    \ as a cache index, the ZID would not be required to\n   maintain the same value\
    \ across separate SIP sessions, although there\n   is no reason why it should\
    \ not.\n   Cacheless operation would sacrifice the key continuity (Section 15.1)\n\
    \   features, as well as Preshared mode (Section 4.4.2).  Further, if the\n  \
    \ pbxsecret is also not cached, there would be no PBX trusted MiTM\n   (Section\
    \ 7.3) features, including the PBX security enrollment\n   (Section 7.3.1) mechanism.\n"
- title: 5.  ZRTP Messages
  contents:
  - "5.  ZRTP Messages\n   All ZRTP messages use the message format defined in Figure\
    \ 2.  All\n   word lengths referenced in this specification are 32 bits, or 4\n\
    \   octets.  All integer fields are carried in network byte order, that\n   is,\
    \ most-significant byte (octet) first, commonly known as big-\n   endian.\n  \
    \  0                   1                   2                   3\n    0 1 2 3\
    \ 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |0 0 0 1|Not Used (set to zero) |         Sequence Number       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                 Magic Cookie 'ZRTP' (0x5a525450)              |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                        Source Identifier                      |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                                                               |\n   |  \
    \         ZRTP Message (length depends on Message Type)       |\n   |        \
    \                    . . .                              |\n   |              \
    \                                                 |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                          CRC (1 word)                         |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                       Figure 2: ZRTP Packet Format\n   The Sequence Number is\
    \ a count that is incremented for each ZRTP\n   packet sent.  The count is initialized\
    \ to a random value.  This is\n   useful in estimating ZRTP packet loss and also\
    \ detecting when ZRTP\n   packets arrive out of sequence.\n   The ZRTP Magic Cookie\
    \ is a 32-bit string that uniquely identifies a\n   ZRTP packet and has the value\
    \ 0x5a525450.\n   Source Identifier is the SSRC number of the RTP stream to which\
    \ this\n   ZRTP packet relates.  For cases of forking or forwarding, RTP, and\n\
    \   hence ZRTP, may arrive at the same port from several different\n   sources\
    \ -- each of these sources will have a different SSRC and may\n   initiate an\
    \ independent ZRTP protocol session.  SSRC collisions would\n   be disruptive\
    \ to ZRTP.  SSRC collision handling procedures are\n   described in Section 4.1.\n\
    \   This format is clearly identifiable as non-RTP due to the first two\n   bits\
    \ being zero, which looks like RTP version 0, which is not a valid\n   RTP version\
    \ number.  It is clearly distinguishable from STUN since\n   the Magic Cookies\
    \ are different.  The 12 unused bits are set to zero\n   and MUST be ignored when\
    \ received.  In early versions of this spec,\n   ZRTP messages were encapsulated\
    \ in RTP header extensions, which made\n   ZRTP an eponymous variant of RTP. \
    \ In later versions, the packet\n   format changed to make it syntactically distinguishable\
    \ from RTP.\n   The ZRTP messages are defined in Figures 3 to 17 and are of variable\n\
    \   length.\n   The ZRTP protocol uses a 32-bit Cyclic Redundancy Check (CRC)\
    \ as\n   defined in RFC 4960, Appendix B [RFC4960], in each ZRTP packet to\n \
    \  detect transmission errors.  ZRTP packets are typically transported\n   by\
    \ UDP, which carries its own built-in 16-bit checksum for integrity,\n   but ZRTP\
    \ does not rely on it.  This is because of the effect of an\n   undetected transmission\
    \ error in a ZRTP message.  For example, an\n   undetected error in the DH exchange\
    \ could appear to be an active man-\n   in-the-middle attack.  A false announcement\
    \ of this by ZRTP clients\n   can be psychologically distressing.  The probability\
    \ of such a false\n   alarm hinges on a mere 16-bit checksum that usually protects\
    \ UDP\n   packets, so more error detection is needed.  For these reasons, this\n\
    \   belt-and-suspenders approach is used to minimize the chance of a\n   transmission\
    \ error affecting the ZRTP key agreement.\n   The CRC is calculated across the\
    \ entire ZRTP packet shown in\n   Figure 2, including the ZRTP header and the\
    \ ZRTP message, but not\n   including the CRC field.  If a ZRTP message fails\
    \ the CRC check, it\n   is silently discarded.\n"
- title: 5.1.  ZRTP Message Formats
  contents:
  - "5.1.  ZRTP Message Formats\n   ZRTP messages are designed to simplify endpoint\
    \ parsing requirements\n   and to reduce the opportunities for buffer overflow\
    \ attacks (a good\n   goal of any security extension should be to not introduce\
    \ new attack\n   vectors).\n   ZRTP uses a block of 8 octets (2 words) to encode\
    \ the Message Type.\n   4-octet (1 word) blocks are used to encode Hash Type,\
    \ Cipher Type,\n   Key Agreement Type, and Authentication Tag Type.  The values\
    \ in the\n   blocks are ASCII strings that are extended with spaces (0x20) to\
    \ make\n   them the desired length.  Currently defined block values are listed\n\
    \   in Tables 1-6.\n   Additional block values may be defined and used.\n   ZRTP\
    \ uses this ASCII encoding to simplify debugging and make it\n   \"Wireshark (Ethereal)\
    \ friendly\".\n"
- title: 5.1.1.  Message Type Block
  contents:
  - "5.1.1.  Message Type Block\n   Currently, 16 Message Type Blocks are defined\
    \ -- they represent the\n   set of ZRTP message primitives.  ZRTP endpoints MUST\
    \ support the\n   Hello, HelloACK, Commit, DHPart1, DHPart2, Confirm1, Confirm2,\n\
    \   Conf2ACK, SASrelay, RelayACK, Error, ErrorACK, and PingACK message\n   types.\
    \  ZRTP endpoints MAY support the GoClear, ClearACK, and Ping\n   messages.  In\
    \ order to generate a PingACK message, it is necessary to\n   parse a Ping message.\
    \  Additional messages may be defined in\n   extensions to ZRTP.\n   Message Type\
    \ Block   |  Meaning\n   ---------------------------------------------------\n\
    \   \"Hello   \"           |  Hello Message\n   ---------------------------------------------------\n\
    \   \"HelloACK\"           |  HelloACK Message\n   ---------------------------------------------------\n\
    \   \"Commit  \"           |  Commit Message\n   ---------------------------------------------------\n\
    \   \"DHPart1 \"           |  DHPart1 Message\n   ---------------------------------------------------\n\
    \   \"DHPart2 \"           |  DHPart2 Message\n   ---------------------------------------------------\n\
    \   \"Confirm1\"           |  Confirm1 Message\n   ---------------------------------------------------\n\
    \   \"Confirm2\"           |  Confirm2 Message\n   ---------------------------------------------------\n\
    \   \"Conf2ACK\"           |  Conf2ACK Message\n   ---------------------------------------------------\n\
    \   \"Error   \"           |  Error Message\n   ---------------------------------------------------\n\
    \   \"ErrorACK\"           |  ErrorACK Message\n   ---------------------------------------------------\n\
    \   \"GoClear \"           |  GoClear Message\n   ---------------------------------------------------\n\
    \   \"ClearACK\"           |  ClearACK Message\n   ---------------------------------------------------\n\
    \   \"SASrelay\"           |  SASrelay Message\n   ---------------------------------------------------\n\
    \   \"RelayACK\"           |  RelayACK Message\n   ---------------------------------------------------\n\
    \   \"Ping    \"           |  Ping Message\n   ---------------------------------------------------\n\
    \   \"PingACK \"           |  PingACK Message\n   ---------------------------------------------------\n\
    \   Table 1. Message Type Block Values\n"
- title: 5.1.2.  Hash Type Block
  contents:
  - "5.1.2.  Hash Type Block\n   The hash algorithm and its related MAC algorithm\
    \ are negotiated via\n   the Hash Type Block found in the Hello message (Section\
    \ 5.2) and the\n   Commit message (Section 5.4).\n   All ZRTP endpoints MUST support\
    \ a Hash Type of SHA-256 [FIPS-180-3].\n   SHA-384 SHOULD be supported and MUST\
    \ be supported if ECDH-384 is\n   used.  Additional Hash Types MAY be used, such\
    \ as the NIST SHA-3 hash\n   [SHA-3] when it becomes available.  Note that the\
    \ Hash Type refers to\n   the hash algorithm that will be used throughout the\
    \ ZRTP key\n   exchange, not the hash algorithm to be used in the SRTP\n   Authentication\
    \ Tag.\n   The choice of the negotiated Hash Type is coupled to the Key\n   Agreement\
    \ Type, as explained in Section 5.1.5.\n   Hash Type Block | Meaning\n   ----------------------------------------------------------\n\
    \   \"S256\"          | SHA-256 Hash defined in FIPS 180-3\n   ----------------------------------------------------------\n\
    \   \"S384\"          | SHA-384 Hash defined in FIPS 180-3\n   ----------------------------------------------------------\n\
    \   \"N256\"          | NIST SHA-3 256-bit hash (when published)\n   ----------------------------------------------------------\n\
    \   \"N384\"          | NIST SHA-3 384-bit hash (when published)\n   ----------------------------------------------------------\n\
    \   Table 2. Hash Type Block Values\n   At the time of this writing, the NIST\
    \ SHA-3 hashes [SHA-3] are not\n   yet available.  NIST is expected to publish\
    \ SHA-3 in 2012, as a\n   successor to the SHA-2 hashes in [FIPS-180-3].\n"
- title: 5.1.2.1.  Negotiated Hash and MAC Algorithm
  contents:
  - "5.1.2.1.  Negotiated Hash and MAC Algorithm\n   ZRTP makes use of message authentication\
    \ codes (MACs) that are keyed\n   hashes based on the negotiated Hash Type.  For\
    \ the SHA-2 and SHA-3\n   hashes, the negotiated MAC is the HMAC based on the\
    \ negotiated hash.\n   This MAC function is also used in the ZRTP key derivation\
    \ function\n   (Section 4.5.1).\n   The HMAC function is defined in [FIPS-198-1].\
    \  A discussion of the\n   general security of the HMAC construction may be found\
    \ in [RFC2104].\n   Test vectors for HMAC-SHA-256 and HMAC-SHA-384 may be found\
    \ in\n   [RFC4231].\n   The negotiated Hash Type does not apply to the hash used\
    \ in the\n   digital signature defined in Section 7.2.  For example, even if the\n\
    \   negotiated Hash Type is SHA-256, the digital signature may use SHA-\n   384\
    \ if an Elliptic Curve Digital Signature Algorithm (ECDSA) P-384\n   signature\
    \ key is used.  Digital signatures are optional in ZRTP.\n   Except for the aforementioned\
    \ digital signatures, and the special\n   cases noted in Section 5.1.2.2, all\
    \ the other hashes and MACs used\n   throughout the ZRTP protocol will use the\
    \ negotiated Hash Type.\n   A future hash may include its own built-in MAC, not\
    \ based on the HMAC\n   construct, for example, the Skein hash function [Skein].\
    \  If NIST\n   chooses such a hash as the SHA-3 winner, Hash Types \"N256\", and\n\
    \   \"N384\" will still use the related HMAC as the negotiated MAC.  If an\n \
    \  implementer wishes to use Skein and its built-in MAC as the\n   negotiated\
    \ MAC, new Hash Types must be used.\n"
- title: 5.1.2.2.  Implicit Hash and MAC Algorithm
  contents:
  - "5.1.2.2.  Implicit Hash and MAC Algorithm\n   While most of the hash and MAC\
    \ usage in ZRTP is defined by the\n   negotiated Hash Type (Section 5.1.2), some\
    \ hashes and MACs must be\n   precomputed prior to negotiations, and thus cannot\
    \ have their\n   algorithms negotiated during the ZRTP exchange.  They are implicitly\n\
    \   predetermined to use SHA-256 [FIPS-180-3] and HMAC-SHA-256.\n   These are\
    \ the hashes and MACs that MUST use the Implicit hash and MAC\n   algorithm:\n\
    \      The hash chain H0-H3 defined in Section 9.\n      The MACs that are keyed\
    \ by this hash chain, as defined in\n      Section 8.1.1.\n      The Hello Hash\
    \ in the a=zrtp-hash attribute defined in\n      Section 8.1.\n   ZRTP defines\
    \ a method for negotiating different ZRTP protocol\n   versions (Section 4.1.1).\
    \  SHA-256 is the Implicit Hash and HMAC-SHA-\n   256 is the Implicit MAC for\
    \ ZRTP protocol version 1.10.  Future ZRTP\n   protocol versions may, if appropriate,\
    \ use another hash algorithm as\n   the Implicit Hash, such as the NIST SHA-3\
    \ hash [SHA-3], when it\n   becomes available.  For example, a future SIP packet\
    \ may list two\n   a=zrtp-hash SDP attributes, one based on SHA-256 for ZRTP version\n\
    \   1.10, and another based on SHA-3 for ZRTP version 2.00.\n"
- title: 5.1.3.  Cipher Type Block
  contents:
  - "5.1.3.  Cipher Type Block\n   The block cipher algorithm is negotiated via the\
    \ Cipher Type Block\n   found in the Hello message (Section 5.2) and the Commit\
    \ message\n   (Section 5.4).\n   All ZRTP endpoints MUST support AES-128 (AES1)\
    \ and MAY support AES-\n   192 (AES2), AES-256 (AES3), or other Cipher Types.\
    \  The Advanced\n   Encryption Standard is defined in [FIPS-197].\n   The use\
    \ of AES-128 in SRTP is defined by [RFC3711].  The use of AES-\n   192 and AES-256\
    \ in SRTP is defined by [RFC6188].  The choice of the\n   AES key length is coupled\
    \ to the Key Agreement Type, as explained in\n   Section 5.1.5.\n   Other block\
    \ ciphers may be supported that have the same block size\n   and key sizes as\
    \ AES.  If implemented, they may be used anywhere in\n   ZRTP or SRTP in place\
    \ of the AES, in the same modes of operation and\n   key size.  Notably, in counter\
    \ mode to replace AES-CM in [RFC3711]\n   and [RFC6188], as well as in CFB mode\
    \ to encrypt a portion of the\n   Confirm message (Figure 10) and SASrelay message\
    \ (Figure 16).  ZRTP\n   endpoints MAY support the TwoFish [TwoFish] block cipher.\n\
    \    Cipher Type Block  |  Meaning\n   -------------------------------------------------\n\
    \   \"AES1\"              |  AES with 128-bit keys\n   -------------------------------------------------\n\
    \   \"AES2\"              |  AES with 192-bit keys\n   -------------------------------------------------\n\
    \   \"AES3\"              |  AES with 256-bit keys\n   -------------------------------------------------\n\
    \   \"2FS1\"              |  TwoFish with 128-bit keys\n   -------------------------------------------------\n\
    \   \"2FS2\"              |  TwoFish with 192-bit keys\n   -------------------------------------------------\n\
    \   \"2FS3\"              |  TwoFish with 256-bit keys\n   -------------------------------------------------\n\
    \   Table 3. Cipher Type Block Values\n"
- title: 5.1.4.  Auth Tag Type Block
  contents:
  - "5.1.4.  Auth Tag Type Block\n   All ZRTP endpoints MUST support HMAC-SHA1 authentication\
    \ tags for\n   SRTP, with both 32-bit and 80-bit length tags as defined in\n \
    \  [RFC3711].\n   ZRTP endpoints MAY support 32-bit and 64-bit SRTP authentication\
    \ tags\n   based on the Skein hash function [Skein].  The Skein-512-MAC key\n\
    \   length is fixed at 256 bits for this application, and the output\n   length\
    \ is adjustable.  The Skein MAC is defined in Sections 2.6 and\n   4.3 of [Skein]\
    \ and is not based on the HMAC construct.  Reference\n   implementations for Skein\
    \ may be found at [Skein1].  A Skein-based\n   MAC is significantly more efficient\
    \ than HMAC-SHA1, especially for\n   short SRTP payloads.\n   The Skein MAC key\
    \ is computed by the SRTP key derivation function,\n   which is also referred\
    \ to as the AES-CM PRF, or pseudorandom\n   function.  This is defined either\
    \ in [RFC3711] or in [RFC6188],\n   depending on the selected SRTP AES key length.\
    \  To compute a Skein\n   MAC key, the SRTP PRF output for the authentication\
    \ key is left\n   untruncated at 256 bits, instead of the usual truncated length\
    \ of 160\n   bits (the key length used by HMAC-SHA1).\n   Auth Tag Type Block\
    \  |  Meaning\n   ----------------------------------------------------------\n\
    \   \"HS32\"               |  32-bit authentication tag based on\n           \
    \             |  HMAC-SHA1 as defined in RFC 3711.\n   ----------------------------------------------------------\n\
    \   \"HS80\"               |  80-bit authentication tag based on\n           \
    \             |  HMAC-SHA1 as defined in RFC 3711.\n   ----------------------------------------------------------\n\
    \   \"SK32\"               |  32-bit authentication tag based on\n           \
    \             |  Skein-512-MAC as defined in [Skein],\n                      \
    \  |  with 256-bit key, 32-bit MAC length.\n   ----------------------------------------------------------\n\
    \   \"SK64\"               |  64-bit authentication tag based on\n           \
    \             |  Skein-512-MAC as defined in [Skein],\n                      \
    \  |  with 256-bit key, 64-bit MAC length.\n   ----------------------------------------------------------\n\
    \   Table 4. Auth Tag Type Values\n   Implementers should be aware that AES-GCM\
    \ and AES-CCM for SRTP are\n   expected to become available when [SRTP-AES-GCM]\
    \ is published as an\n   RFC.  If an implementer wishes to use these modes when\
    \ they become\n   available, new Auth Tag Types must be added.\n"
- title: 5.1.5.  Key Agreement Type Block
  contents:
  - "5.1.5.  Key Agreement Type Block\n   All ZRTP endpoints MUST support DH3k, SHOULD\
    \ support Preshared, and\n   MAY support EC25, EC38, and DH2k.\n   If a ZRTP endpoint\
    \ supports multiple concurrent media streams, such\n   as audio and video, it\
    \ MUST support Multistream (Section 4.4.3) mode.\n   Also, if a ZRTP endpoint\
    \ supports the GoClear message\n   (Section 4.7.2), it SHOULD support Multistream,\
    \ to be used if the two\n   parties choose to return to the secure state after\
    \ going Clear (as\n   explained in Section 4.7.2.1).\n   For Finite Field Diffie-Hellman,\
    \ ZRTP endpoints MUST use the DH\n   parameters defined in [RFC3526], as follows.\
    \  DH3k uses the 3072-bit\n   modular exponentiation group (MODP).  DH2k uses\
    \ the 2048-bit MODP\n   group.  The DH generator g is 2.  The random Diffie-Hellman\
    \ secret\n   exponent SHOULD be twice as long as the AES key length.  If AES-128\n\
    \   is used, the DH secret value SHOULD be 256 bits long.  If AES-256 is\n   used,\
    \ the secret value SHOULD be 512 bits long.\n   If Elliptic Curve DH is used,\
    \ the ECDH algorithm and key generation\n   is from [NIST-SP800-56A].  The curves\
    \ used are from [NSA-Suite-B],\n   which uses the same curves as ECDSA defined\
    \ by [FIPS-186-3], and can\n   also be found in RFC 5114, Sections 2.6 through\
    \ 2.8 [RFC5114].  ECDH\n   test vectors may be found in RFC 5114, appendices A.6\
    \ through A.8\n   [RFC5114].  The validation procedures are from [NIST-SP800-56A],\n\
    \   Section 5.6.2.6, method 3, Elliptic Curve Cryptography (ECC) Partial\n   Validation.\
    \  Both the X and Y coordinates of the point on the curve\n   are sent, in the\
    \ first and second half of the ECDH public value,\n   respectively.  The ECDH\
    \ result returns only the X coordinate, as\n   specified in SP 800-56A.  Useful\
    \ strategies for implementing ECC may\n   be found in [RFC6090].\n   The choice\
    \ of the negotiated hash algorithm (Section 5.1.2) is\n   coupled to the choice\
    \ of Key Agreement Type.  If ECDH-384 (EC38) is\n   chosen as the key agreement,\
    \ the negotiated hash algorithm MUST be\n   either SHA-384 or the corresponding\
    \ SHA-3 successor.\n   The choice of AES key length is coupled to the choice of\
    \ Key\n   Agreement Type.  If EC38 is chosen as the key agreement, AES-256\n \
    \  (AES3) SHOULD be used but AES-192 MAY be used.  If DH3k or EC25 is\n   chosen,\
    \ any AES key size MAY be used.  Note that SRTP as defined in\n   [RFC3711] only\
    \ supports AES-128.\n   DH2k is intended to provide acceptable security for low\
    \ power\n   applications, or for applications that require faster key\n   negotiations.\
    \  NIST asserts in Table 4 of [NIST-SP800-131A] that DH-\n   2048 is safe to use\
    \ through 2013.  The security of DH2k can be\n   augmented by implementing ZRTP's\
    \ key continuity features\n   (Section 15.1).  DH2k SHOULD use AES-128.  If an\
    \ implementor must use\n   slow hardware, DH2k should precede DH3k in the Hello\
    \ message.\n   ECDH-521 SHOULD NOT be used, due to disruptive computational delays.\n\
    \   These delays may lead to exhaustion of the retransmission schedule,\n   unless\
    \ both endpoints have very fast hardware.  Note that ECDH-521 is\n   not part\
    \ of NSA Suite B.\n   ZRTP also defines two non-DH modes, Multistream and Preshared,\
    \ in\n   which the SRTP key is derived from a shared secret and some nonce\n \
    \  material.\n   The table below lists the pv length in words and DHPart1 and\
    \ DHPart2\n   message length in words for each Key Agreement Type Block.\n   Key\
    \ Agreement |  pv   | message | Meaning\n   Type Block    | words |  words  |\n\
    \   -----------------------------------------------------------\n   \"DH3k\" \
    \       |   96  |   117   |  DH mode with p=3072 bit prime\n                 |\
    \       |         |  per RFC 3526, Section 4.\n   -----------------------------------------------------------\n\
    \   \"DH2k\"        |   64  |    85   |  DH mode with p=2048 bit prime\n     \
    \            |       |         |  per RFC 3526, Section 3.\n   -----------------------------------------------------------\n\
    \   \"EC25\"        |   16  |    37   |  Elliptic Curve DH, P-256\n          \
    \       |       |         |  per RFC 5114, Section 2.6\n   -----------------------------------------------------------\n\
    \   \"EC38\"        |   24  |    45   |  Elliptic Curve DH, P-384\n          \
    \       |       |         |  per RFC 5114, Section 2.7\n   -----------------------------------------------------------\n\
    \   \"EC52\"        |   33  |    54   |  Elliptic Curve DH, P-521\n          \
    \       |       |         |  per RFC 5114, Section 2.8\n                 |   \
    \    |         |  (deprecated - do not use)\n   -----------------------------------------------------------\n\
    \   \"Prsh\"        |    -  |     -   |  Preshared Non-DH mode\n   -----------------------------------------------------------\n\
    \   \"Mult\"        |    -  |     -   |  Multistream Non-DH mode\n   -----------------------------------------------------------\n\
    \   Table 5. Key Agreement Type Block Values\n"
- title: 5.1.6.  SAS Type Block
  contents:
  - "5.1.6.  SAS Type Block\n   The SAS Type determines how the SAS is rendered to\
    \ the user so that\n   the user may verbally compare it with his partner over\
    \ the voice\n   channel.  This allows detection of a MiTM attack.\n   All ZRTP\
    \ endpoints MUST support the base32 and MAY support the\n   base256 rendering\
    \ schemes for the Short Authentication String, and\n   other SAS rendering schemes.\
    \  See Section 4.5.2 for how the sasvalue\n   is computed and Section 7 for how\
    \ the SAS is used.\n    SAS Type Block   |  Meaning\n   ---------------------------------------------------\n\
    \    \"B32 \"           |  Short Authentication String using\n               \
    \      |  base32 encoding\n   ---------------------------------------------------\n\
    \    \"B256\"           |  Short Authentication String using\n               \
    \      |  base256 encoding (PGP Word List)\n   ---------------------------------------------------\n\
    \   Table 6. SAS Type Block Values\n   For the SAS Type of \"B256\", the most-significant\
    \ (leftmost) 16 bits\n   of the 32-bit sasvalue are rendered in network byte order\
    \ using the\n   PGP Word List [pgpwordlist] [Juola1][Juola2].\n   For the SAS\
    \ Type of \"B32 \", the most-significant (leftmost) 20 bits\n   of the 32-bit\
    \ sasvalue are rendered as a form of base32 encoding.\n   The leftmost 20 bits\
    \ of the sasvalue results in four base32\n   characters that are rendered, most-significant\
    \ quintet first, to both\n   ZRTP endpoints.  Here is a normative pseudocode implementation\
    \ of the\n   base32 function:\n   char[4] base32(uint32 bits)\n   {   int i, n,\
    \ shift;\n       char result[4];\n       for (i=0,shift=27; i!=4; ++i,shift-=5)\n\
    \       {   n = (bits>>shift) & 31;\n           result[i] = \"ybndrfg8ejkmcpqxot1uwisza345h769\"\
    [n];\n       }\n       return result;\n   }\n   This base32 encoding scheme differs\
    \ from RFC 4648, and was designed\n   (by Bryce Wilcox-O'Hearn) to represent bit\
    \ sequences in a form that\n   is convenient for human users to manipulate with\
    \ minimal ambiguity.\n   The unusually permuted character ordering was designed\
    \ for other\n   applications that use bit sequences that do not end on quintet\n\
    \   boundaries.\n"
- title: 5.1.7.  Signature Type Block
  contents:
  - "5.1.7.  Signature Type Block\n   The Signature Type Block specifies what signature\
    \ algorithm is used\n   to sign the SAS as discussed in Section 7.2.  The 4-octet\
    \ Signature\n   Type Block, along with the accompanying signature block, are OPTIONAL\n\
    \   and may be present in the Confirm message (Figure 10) or the SASrelay\n  \
    \ message (Figure 16).  The signature types are given in the table\n   below.\n\
    \   Signature   | Meaning\n   Type Block  |\n   ------------------------------------------------\n\
    \   \"PGP \"      | OpenPGP Signature, per RFC 4880\n               |\n   ------------------------------------------------\n\
    \   \"X509\"      | ECDSA, with X.509v3 cert\n               | per RFC 5759 and\
    \ FIPS-186-3\n   ------------------------------------------------\n   Table 7.\
    \ Signature Type Block Values\n   Additional details on the signature and signing\
    \ key format may be\n   found in Section 7.2.  OpenPGP signatures (Signature Type\
    \ \"PGP \") are\n   discussed in Section 7.2.1.  The ECDSA curves are over prime\
    \ fields\n   only, drawn from Appendix D.1.2 of [FIPS-186-3].  X.509v3 ECDSA\n\
    \   Signatures (Signature Type \"X509\") are discussed in Section 7.2.2.\n"
- title: 5.2.  Hello Message
  contents:
  - "5.2.  Hello Message\n   The Hello message has the format shown in Figure 3.\n\
    \   All ZRTP messages begin with the preamble value 0x505a, then a 16-bit\n  \
    \ length in 32-bit words.  This length includes only the ZRTP message\n   (including\
    \ the preamble and the length) but not the ZRTP packet\n   header or CRC.  The\
    \ 8-octet Message Type follows the length field.\n   Next, there is a 4-character\
    \ string containing the version (ver) of\n   the ZRTP protocol, which is \"1.10\"\
    \ for this specification.  Next,\n   there is the Client Identifier string (cid),\
    \ which is 4 words long\n   and identifies the vendor and release of the ZRTP\
    \ software.  The 256-\n   bit hash image H3 is defined in Section 9.  The next\
    \ parameter is the\n   ZID, the 96-bit-long unique identifier for the ZRTP endpoint,\
    \ defined\n   in Section 4.9.\n   The next four bits include three flag bits:\n\
    \   o  The Signature-capable flag (S) indicates this Hello message is\n      sent\
    \ from a ZRTP endpoint which is able to parse and verify\n      digital signatures,\
    \ as described in Section 7.2.  If signatures\n      are not supported, the (S)\
    \ flag MUST be set to zero.\n   o  The MiTM flag (M) is a Boolean that is set\
    \ to true if and only if\n      this Hello message is sent from a device, usually\
    \ a PBX, that has\n      the capability to send an SASrelay message (Section 5.13).\n\
    \   o  The Passive flag (P) is a Boolean normally set to false, and is\n     \
    \ set to true if and only if this Hello message is sent from a\n      device that\
    \ is configured to never send a Commit message\n      (Section 5.4).  This would\
    \ mean it cannot initiate secure\n      sessions, but may act as a responder.\n\
    \   The next 8 bits are unused and SHOULD be set to zero when sent and\n   MUST\
    \ be ignored on receipt.\n   Next is a list of supported Hash algorithms, Cipher\
    \ algorithms, SRTP\n   Auth Tag Types, Key Agreement Types, and SAS Types.  The\
    \ number of\n   listed algorithms are listed for each type: hc=hash count, cc=cipher\n\
    \   count, ac=auth tag count, kc=key agreement count, and sc=sas count.\n   The\
    \ values for these algorithms are defined in Tables 2, 3, 4, 5, and\n   6.  A\
    \ count of zero means that only the mandatory-to-implement\n   algorithms are\
    \ supported.  Mandatory algorithms MAY be included in\n   the list.  The order\
    \ of the list indicates the preferences of the\n   endpoint.  If a mandatory algorithm\
    \ is not included in the list, it\n   is implicitly added to the end of the list\
    \ for preference.\n   The 64-bit MAC at the end of the message is computed across\
    \ the whole\n   message, not including the MAC, using the MAC algorithm defined\
    \ in\n   Section 5.1.2.2.  The MAC key is the sender's H2 (defined in\n   Section\
    \ 9), and thus the MAC cannot be checked by the receiving party\n   until the\
    \ sender's H2 value is known to the receiving party later in\n   the protocol.\n\
    \    0                   1                   2                   3\n    0 1 2\
    \ 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |0 1 0 1 0 0 0 0 0 1 0 1 1 0 1 0|             length            |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |            Message Type Block=\"Hello   \" (2 words)            |\n   |\
    \                                                               |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                   version=\"1.10\" (1 word)                     |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                                                               |\n   |  \
    \              Client Identifier (4 words)                    |\n   |        \
    \                                                       |\n   |              \
    \                                                 |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                                                               |\n   |  \
    \                 Hash image H3 (8 words)                     |\n   |        \
    \                     . . .                             |\n   |              \
    \                                                 |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                                                               |\n   |  \
    \                       ZID  (3 words)                        |\n   |        \
    \                                                       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |0|S|M|P| unused (zeros)|  hc   |  cc   |  ac   |  kc   |  sc   |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                 hash algorithms (0 to 7 values)               |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |               cipher algorithms (0 to 7 values)               |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                  auth tag types (0 to 7 values)               |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |               Key Agreement Types (0 to 7 values)             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                    SAS Types (0 to 7 values)                  |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                         MAC (2 words)                         |\n   |  \
    \                                                             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                      Figure 3: Hello Message Format\n"
- title: 5.3.  HelloACK Message
  contents:
  - "5.3.  HelloACK Message\n   The HelloACK message is used to stop retransmissions\
    \ of a Hello\n   message.  A HelloACK is sent regardless if the version number\
    \ in the\n   Hello is supported or the algorithm list supported.  The receipt\
    \ of a\n   HelloACK stops retransmission of the Hello message.  The format is\n\
    \   shown in the figure below.  A Commit message may be sent in place of\n   a\
    \ HelloACK by an Initiator, if a Commit message is ready to be sent\n   promptly.\n\
    \    0                   1                   2                   3\n    0 1 2\
    \ 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |0 1 0 1 0 0 0 0 0 1 0 1 1 0 1 0|         length=3 words        |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |              Message Type Block=\"HelloACK\" (2 words)          |\n   |\
    \                                                               |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                     Figure 4: HelloACK Message Format\n"
- title: 5.4.  Commit Message
  contents:
  - "5.4.  Commit Message\n   The Commit message is sent to initiate the key agreement\
    \ process\n   after both sides have received a Hello message, which means it can\n\
    \   only be sent after receiving both a Hello message and a HelloACK\n   message.\
    \  There are three subtypes of Commit messages, whose formats\n   are shown in\
    \ Figures 5, 6, and 7.\n   The Commit message contains the Message Type Block,\
    \ then the 256-bit\n   hash image H2, which is defined in Section 9.  The next\
    \ parameter is\n   the initiator's ZID, the 96-bit-long unique identifier for\
    \ the ZRTP\n   endpoint, which MUST have the same value as was used in the Hello\n\
    \   message.\n   Next, there is a list of algorithms selected by the initiator\
    \ (hash,\n   cipher, auth tag type, key agreement, sas type).  For a DH Commit,\n\
    \   the hash value hvi is a hash of the DHPart2 of the Initiator and the\n   Responder's\
    \ Hello message, as explained in Section 4.4.1.1.\n   The 64-bit MAC at the end\
    \ of the message is computed across the whole\n   message, not including the MAC,\
    \ using the MAC algorithm defined in\n   Section 5.1.2.2.  The MAC key is the\
    \ sender's H1 (defined in\n   Section 9), and thus the MAC cannot be checked by\
    \ the receiving party\n   until the sender's H1 value is known to the receiving\
    \ party later in\n   the protocol.\n       0                   1             \
    \      2                   3\n       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0\
    \ 1 2 3 4 5 6 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |0 1 0 1 0 0 0 0 0 1 0 1 1 0 1 0|        length=29 words        |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |\
    \              Message Type Block=\"Commit  \" (2 words)          |\n      | \
    \                                                              |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |                                                               |\n   \
    \   |                   Hash image H2 (8 words)                     |\n      |\
    \                             . . .                             |\n      |   \
    \                                                            |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |                                                               |\n   \
    \   |                         ZID  (3 words)                        |\n      |\
    \                                                               |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |                       hash algorithm                          |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |\
    \                      cipher algorithm                         |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |                       auth tag type                           |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |\
    \                     Key Agreement Type                        |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |                         SAS Type                              |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |\
    \                                                               |\n      |   \
    \                    hvi (8 words)                           |\n      |      \
    \                     . . .                               |\n      |         \
    \                                                      |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |                         MAC (2 words)                         |\n   \
    \   |                                                               |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                    Figure 5: DH Commit Message Format\n       0            \
    \       1                   2                   3\n       0 1 2 3 4 5 6 7 8 9\
    \ 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |0 1 0 1 0 0 0 0 0 1 0 1 1 0 1 0|        length=25 words        |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |\
    \              Message Type Block=\"Commit  \" (2 words)          |\n      | \
    \                                                              |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |                                                               |\n   \
    \   |                   Hash image H2 (8 words)                     |\n      |\
    \                             . . .                             |\n      |   \
    \                                                            |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |                                                               |\n   \
    \   |                         ZID  (3 words)                        |\n      |\
    \                                                               |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |                       hash algorithm                          |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |\
    \                      cipher algorithm                         |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |                       auth tag type                           |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |\
    \                  Key Agreement Type = \"Mult\"                  |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |                         SAS Type                              |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |\
    \                                                               |\n      |   \
    \                    nonce (4 words)                         |\n      |      \
    \                     . . .                               |\n      |         \
    \                                                      |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |                         MAC (2 words)                         |\n   \
    \   |                                                               |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                Figure 6: Multistream Commit Message Format\n       0       \
    \            1                   2                   3\n       0 1 2 3 4 5 6 7\
    \ 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |0 1 0 1 0 0 0 0 0 1 0 1 1 0 1 0|        length=27 words        |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |\
    \              Message Type Block=\"Commit  \" (2 words)          |\n      | \
    \                                                              |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |                                                               |\n   \
    \   |                   Hash image H2 (8 words)                     |\n      |\
    \                             . . .                             |\n      |   \
    \                                                            |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |                                                               |\n   \
    \   |                         ZID  (3 words)                        |\n      |\
    \                                                               |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |                       hash algorithm                          |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |\
    \                      cipher algorithm                         |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |                       auth tag type                           |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |\
    \                   Key Agreement Type = \"Prsh\"                 |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |                         SAS Type                              |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |\
    \                                                               |\n      |   \
    \                    nonce (4 words)                         |\n      |      \
    \                     . . .                               |\n      |         \
    \                                                      |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |                        keyID (2 words)                        |\n   \
    \   |                                                               |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |                         MAC (2 words)                         |\n   \
    \   |                                                               |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                 Figure 7: Preshared Commit Message Format\n"
- title: 5.5.  DHPart1 Message
  contents:
  - "5.5.  DHPart1 Message\n   The DHPart1 message shown in Figure 8 begins the DH\
    \ exchange.  It is\n   sent by the Responder if a valid Commit message is received\
    \ from the\n   Initiator.  The length of the pvr value and the length of the DHPart1\n\
    \   message depends on the Key Agreement Type chosen.  This information\n   is\
    \ contained in the table in Section 5.1.5.  Note that for both\n   Multistream\
    \ and Preshared modes, no DHPart1 or DHPart2 message will\n   be sent.\n   The\
    \ 256-bit hash image H1 is defined in Section 9.\n   The next four parameters\
    \ are non-invertible hashes (computed in\n   Section 4.3.1) of potential shared\
    \ secrets used in generating the\n   ZRTP secret s0.  The first two, rs1IDr and\
    \ rs2IDr, are the hashes of\n   the responder's two retained shared secrets, truncated\
    \ to 64 bits.\n   Next, there is auxsecretIDr, a hash of the responder's auxsecret\n\
    \   (defined in Section 4.3), truncated to 64 bits.  The last parameter\n   is\
    \ a hash of the trusted MiTM PBX shared secret pbxsecret, defined in\n   Section\
    \ 7.3.1.\n   The 64-bit MAC at the end of the message is computed across the whole\n\
    \   message, not including the MAC, using the MAC algorithm defined in\n   Section\
    \ 5.1.2.2.  The MAC key is the sender's H0 (defined in\n   Section 9), and thus\
    \ the MAC cannot be checked by the receiving party\n   until the sender's H0 value\
    \ is known to the receiving party later in\n   the protocol.\n       0       \
    \            1                   2                   3\n       0 1 2 3 4 5 6 7\
    \ 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |0 1 0 1 0 0 0 0 0 1 0 1 1 0 1 0|   length=depends on KA Type   |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |\
    \              Message Type Block=\"DHPart1 \" (2 words)          |\n      | \
    \                                                              |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |                                                               |\n   \
    \   |                   Hash image H1 (8 words)                     |\n      |\
    \                             . . .                             |\n      |   \
    \                                                            |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |                        rs1IDr (2 words)                       |\n   \
    \   |                                                               |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |                        rs2IDr (2 words)                       |\n   \
    \   |                                                               |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |                     auxsecretIDr (2 words)                    |\n   \
    \   |                                                               |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |                     pbxsecretIDr (2 words)                    |\n   \
    \   |                                                               |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |                                                               |\n   \
    \   |                  pvr (length depends on KA Type)              |\n      |\
    \                               . . .                           |\n      |   \
    \                                                            |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |                         MAC (2 words)                         |\n   \
    \   |                                                               |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                     Figure 8: DHPart1 Message Format\n"
- title: 5.6.  DHPart2 Message
  contents:
  - "5.6.  DHPart2 Message\n   The DHPart2 message, shown in Figure 9, completes the\
    \ DH exchange.\n   It is sent by the Initiator if a valid DHPart1 message is received\n\
    \   from the Responder.  The length of the pvi value and the length of\n   the\
    \ DHPart2 message depends on the Key Agreement Type chosen.  This\n   information\
    \ is contained in the table in Section 5.1.5.  Note that\n   for both Multistream\
    \ and Preshared modes, no DHPart1 or DHPart2\n   message will be sent.\n   The\
    \ 256-bit hash image H1 is defined in Section 9.\n   The next four parameters\
    \ are non-invertible hashes (computed in\n   Section 4.3.1) of potential shared\
    \ secrets used in generating the\n   ZRTP secret s0.  The first two, rs1IDi and\
    \ rs2IDi, are the hashes of\n   the initiator's two retained shared secrets, truncated\
    \ to 64 bits.\n   Next, there is auxsecretIDi, a hash of the initiator's auxsecret\n\
    \   (defined in Section 4.3), truncated to 64 bits.  The last parameter\n   is\
    \ a hash of the trusted MiTM PBX shared secret pbxsecret, defined in\n   Section\
    \ 7.3.1.\n   The 64-bit MAC at the end of the message is computed across the whole\n\
    \   message, not including the MAC, using the MAC algorithm defined in\n   Section\
    \ 5.1.2.2.  The MAC key is the sender's H0 (defined in\n   Section 9), and thus\
    \ the MAC cannot be checked by the receiving party\n   until the sender's H0 value\
    \ is known to the receiving party later in\n   the protocol.\n       0       \
    \            1                   2                   3\n       0 1 2 3 4 5 6 7\
    \ 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |0 1 0 1 0 0 0 0 0 1 0 1 1 0 1 0|   length=depends on KA Type   |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |\
    \              Message Type Block=\"DHPart2 \" (2 words)          |\n      | \
    \                                                              |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |                                                               |\n   \
    \   |                   Hash image H1 (8 words)                     |\n      |\
    \                             . . .                             |\n      |   \
    \                                                            |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |                        rs1IDi (2 words)                       |\n   \
    \   |                                                               |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |                        rs2IDi (2 words)                       |\n   \
    \   |                                                               |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |                     auxsecretIDi (2 words)                    |\n   \
    \   |                                                               |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |                     pbxsecretIDi (2 words)                    |\n   \
    \   |                                                               |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |                                                               |\n   \
    \   |                  pvi (length depends on KA Type)              |\n      |\
    \                               . . .                           |\n      |   \
    \                                                            |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |                         MAC (2 words)                         |\n   \
    \   |                                                               |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                     Figure 9: DHPart2 Message Format\n"
- title: 5.7.  Confirm1 and Confirm2 Messages
  contents:
  - "5.7.  Confirm1 and Confirm2 Messages\n   The Confirm1 message is sent by the\
    \ Responder in response to a valid\n   DHPart2 message after the SRTP session\
    \ key and parameters have been\n   negotiated.  The Confirm2 message is sent by\
    \ the Initiator in\n   response to a Confirm1 message.  The format is shown in\
    \ Figure 10.\n   The message contains the Message Type Block \"Confirm1\" or \"\
    Confirm2\".\n   Next, there is the confirm_mac, a MAC computed over the encrypted\n\
    \   part of the message (shown enclosed by \"====\" in Figure 10).  This\n   confirm_mac\
    \ is keyed and computed according to Section 4.6.  The next\n   16 octets contain\
    \ the CFB Initialization Vector.  The rest of the\n   message is encrypted using\
    \ CFB and protected by the confirm_mac.\n   The first field inside the encrypted\
    \ region is the hash preimage H0,\n   which is defined in detail in Section 9.\n\
    \   The next 15 bits are not used and SHOULD be set to zero when sent and\n  \
    \ MUST be ignored when received in Confirm1 or Confirm2 messages.\n   The next\
    \ 9 bits contain the signature length.  If no SAS signature\n   (described in\
    \ Section 7.2) is present, all bits are set to zero.  The\n   signature length\
    \ is in words and includes the signature type block.\n   If the calculated signature\
    \ octet count is not a multiple of 4, zeros\n   are added to pad it out to a word\
    \ boundary.  If no signature is\n   present, the overall length of the Confirm1\
    \ or Confirm2 message will\n   be set to 19 words.\n   The next 8 bits are used\
    \ for flags.  Undefined flags are set to zero\n   and ignored.  Four flags are\
    \ currently defined.  The PBX Enrollment\n   flag (E) is a Boolean bit defined\
    \ in Section 7.3.1.  The SAS Verified\n   flag (V) is a Boolean bit defined in\
    \ Section 7.1.  The Allow Clear\n   flag (A) is a Boolean bit defined in Section\
    \ 4.7.2.  The Disclosure\n   Flag (D) is a Boolean bit defined in Section 11.\
    \  The cache\n   expiration interval is defined in Section 4.9.\n   If the signature\
    \ length (in words) is non-zero, a signature type\n   block will be present along\
    \ with a signature block.  Next, there is\n   the signature block.  The signature\
    \ block includes the signature and\n   the key (or a link to the key) used to\
    \ generate the signature\n   (Section 7.2).\n   CFB mode [NIST-SP800-38A] is applied\
    \ with a feedback length of 128\n   bits, a full cipher block, and the final block\
    \ is truncated to match\n   the exact length of the encrypted data.  The CFB Initialization\n\
    \   Vector is a 128-bit random nonce.  The block cipher algorithm and the\n  \
    \ key size are the same as the negotiated block cipher (Section 5.1.3)\n   for\
    \ media encryption.  CFB is used to encrypt the part of the\n   Confirm1 message\
    \ beginning after the CFB IV to the end of the message\n   (the encrypted region\
    \ is enclosed by \"====\" in Figure 10).\n   The responder uses the zrtpkeyr to\
    \ encrypt the Confirm1 message.  The\n   initiator uses the zrtpkeyi to encrypt\
    \ the Confirm2 message.\n       0                   1                   2    \
    \               3\n       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5\
    \ 6 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |0 1 0 1 0 0 0 0 0 1 0 1 1 0 1 0|         length=variable       |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |\
    \      Message Type Block=\"Confirm1\" or \"Confirm2\" (2 words)    |\n      |\
    \                                                               |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |                     confirm_mac (2 words)                     |\n   \
    \   |                                                               |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |                                                               |\n   \
    \   |                CFB Initialization Vector (4 words)            |\n      |\
    \                                                               |\n      |   \
    \                                                            |\n      +===============================================================+\n\
    \      |                                                               |\n   \
    \   |                  Hash preimage H0 (8 words)                   |\n      |\
    \                             . . .                             |\n      |   \
    \                                                            |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      | Unused (15 bits of zeros)   | sig len (9 bits)|0 0 0 0|E|V|A|D|\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |\
    \              cache expiration interval (1 word)               |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |      optional signature type block (1 word if present)        |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |\
    \                                                               |\n      |   \
    \        optional signature block (variable length)          |\n      |      \
    \                      . . .                              |\n      |         \
    \                                                      |\n      |            \
    \                                                   |\n      +===============================================================+\n\
    \              Figure 10: Confirm1 and Confirm2 Message Format\n"
- title: 5.8.  Conf2ACK Message
  contents:
  - "5.8.  Conf2ACK Message\n   The Conf2ACK message is sent by the Responder in response\
    \ to a valid\n   Confirm2 message.  The message format for the Conf2ACK is shown\
    \ in\n   the figure below.  The receipt of a Conf2ACK stops retransmission of\n\
    \   the Confirm2 message.  Note that the first SRTP media (with a valid\n   SRTP\
    \ auth tag) from the responder also stops retransmission of the\n   Confirm2 message.\n\
    \       0                   1                   2                   3\n      \
    \ 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |0 1 0 1 0 0 0 0 0 1 0 1 1 0 1 0|         length=3 words        |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |\
    \              Message Type Block=\"Conf2ACK\" (2 words)          |\n      | \
    \                                                              |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                    Figure 11: Conf2ACK Message Format\n"
- title: 5.9.  Error Message
  contents:
  - "5.9.  Error Message\n   The Error message is sent to terminate an in-process\
    \ ZRTP key\n   agreement exchange due to an error.  The format is shown in the\n\
    \   figure below.  The use of the Error message is described in\n   Section 4.7.1.\n\
    \       0                   1                   2                   3\n      \
    \ 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |0 1 0 1 0 0 0 0 0 1 0 1 1 0 1 0|        length=4 words         |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |\
    \              Message Type Block=\"Error   \" (2 words)          |\n      | \
    \                                                              |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |               Integer Error Code (1 word)                     |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      \
    \                Figure 12: Error Message Format\n   Defined hexadecimal values\
    \ for the Error Code are listed in the table\n   below.\n   Error Code |  Meaning\n\
    \   -----------------------------------------------------------\n    0x10    \
    \  | Malformed packet (CRC OK, but wrong structure)\n   -----------------------------------------------------------\n\
    \    0x20      | Critical software error\n   -----------------------------------------------------------\n\
    \    0x30      | Unsupported ZRTP version\n   -----------------------------------------------------------\n\
    \    0x40      | Hello components mismatch\n   -----------------------------------------------------------\n\
    \    0x51      | Hash Type not supported\n   -----------------------------------------------------------\n\
    \    0x52      | Cipher Type not supported\n   -----------------------------------------------------------\n\
    \    0x53      | Public key exchange not supported\n   -----------------------------------------------------------\n\
    \    0x54      | SRTP auth tag not supported\n   -----------------------------------------------------------\n\
    \    0x55      | SAS rendering scheme not supported\n   -----------------------------------------------------------\n\
    \    0x56      | No shared secret available, DH mode required\n   -----------------------------------------------------------\n\
    \    0x61      | DH Error: bad pvi or pvr ( == 1, 0, or p-1)\n   -----------------------------------------------------------\n\
    \    0x62      | DH Error: hvi != hashed data\n   -----------------------------------------------------------\n\
    \    0x63      | Received relayed SAS from untrusted MiTM\n   -----------------------------------------------------------\n\
    \    0x70      | Auth Error: Bad Confirm pkt MAC\n   -----------------------------------------------------------\n\
    \    0x80      | Nonce reuse\n   -----------------------------------------------------------\n\
    \    0x90      | Equal ZIDs in Hello\n   -----------------------------------------------------------\n\
    \    0x91      | SSRC collision\n   -----------------------------------------------------------\n\
    \    0xA0      | Service unavailable\n   -----------------------------------------------------------\n\
    \    0xB0      | Protocol timeout error\n   -----------------------------------------------------------\n\
    \    0x100     | GoClear message received, but not allowed\n   -----------------------------------------------------------\n\
    \   Table 8. ZRTP Error Codes\n"
- title: 5.10.  ErrorACK Message
  contents:
  - "5.10.  ErrorACK Message\n   The ErrorACK message is sent in response to an Error\
    \ message.  The\n   receipt of an ErrorACK stops retransmission of the Error message.\n\
    \   The format is shown in the figure below.\n       0                   1   \
    \                2                   3\n       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5\
    \ 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |0 1 0 1 0 0 0 0 0 1 0 1 1 0 1 0|        length=3 words         |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |\
    \              Message Type Block=\"ErrorACK\" (2 words)          |\n      | \
    \                                                              |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                    Figure 13: ErrorACK Message Format\n"
- title: 5.11.  GoClear Message
  contents:
  - "5.11.  GoClear Message\n   Support for the GoClear message is OPTIONAL in the\
    \ protocol, and it\n   is sent to switch from SRTP to RTP.  The format is shown\
    \ in the\n   figure below.  The clear_mac is used to authenticate the GoClear\n\
    \   message so that bogus GoClear messages introduced by an attacker can\n   be\
    \ detected and discarded.  The use of GoClear is described in\n   Section 4.7.2.\n\
    \       0                   1                   2                   3\n      \
    \ 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |0 1 0 1 0 0 0 0 0 1 0 1 1 0 1 0|        length=5 words         |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |\
    \              Message Type Block=\"GoClear \" (2 words)          |\n      | \
    \                                                              |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |                       clear_mac (2 words)                     |\n   \
    \   |                                                               |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                     Figure 14: GoClear Message Format\n"
- title: 5.12.  ClearACK Message
  contents:
  - "5.12.  ClearACK Message\n   Support for the ClearACK message is OPTIONAL in the\
    \ protocol, and it\n   is sent to acknowledge receipt of a GoClear.  A ClearACK\
    \ is only sent\n   if the clear_mac from the GoClear message is authenticated.\n\
    \   Otherwise, no response is returned.  The format is shown in the\n   figure\
    \ below.\n       0                   1                   2                   3\n\
    \       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n    \
    \  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |0\
    \ 1 0 1 0 0 0 0 0 1 0 1 1 0 1 0|        length=3 words         |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |              Message Type Block=\"ClearACK\" (2 words)          |\n \
    \     |                                                               |\n    \
    \  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n       \
    \             Figure 15: ClearACK Message Format\n"
- title: 5.13.  SASrelay Message
  contents:
  - "5.13.  SASrelay Message\n   The SASrelay message is sent by a trusted MiTM, most\
    \ often a PBX.  It\n   is not sent as a response to a packet, but is sent as a\
    \ self-\n   initiated packet by the trusted MiTM (Section 7.3).  It can only be\n\
    \   sent after the rest of the ZRTP key negotiations have completed,\n   after\
    \ the Confirm messages and their ACKs.  It can only be sent after\n   the trusted\
    \ MiTM has finished key negotiations with the other party,\n   because it is the\
    \ other party's SAS that is being relayed.  It is\n   sent with retry logic until\
    \ a RelayACK message (Section 5.14) is\n   received or the retry schedule has\
    \ been exhausted.\n   If a device, usually a PBX, sends an SASrelay message, it\
    \ MUST have\n   previously declared itself as a MiTM device by setting the MiTM\
    \ (M)\n   flag in the Hello message (Section 5.2).  If the receiver of the\n \
    \  SASrelay message did not previously receive a Hello message with the\n   MiTM\
    \ (M) flag set, the Relayed SAS SHOULD NOT be rendered.  A\n   RelayACK is still\
    \ sent, but no Error message is sent.\n   The SASrelay message format is shown\
    \ in Figure 16.  The message\n   contains the Message Type Block \"SASrelay\"\
    .  Next, there is a MAC\n   computed over the encrypted part of the message (shown\
    \ enclosed by\n   \"====\" in Figure 16).  This MAC is keyed the same way as the\n\
    \   confirm_mac in the Confirm messages (see Section 4.6).  The next 16\n   octets\
    \ contain the CFB Initialization Vector.  The rest of the\n   message is encrypted\
    \ using CFB and protected by the MAC.\n   The next 15 bits are not used and SHOULD\
    \ be set to zero when sent,\n   and they MUST be ignored when received in SASrelay\
    \ messages.\n   The next 9 bits contain the signature length.  The trusted MiTM\
    \ MAY\n   compute a digital signature on the SAS hash, as described in\n   Section\
    \ 7.2, using a persistent signing key owned by the trusted\n   MiTM.  If no SAS\
    \ signature is present, all bits are set to zero.  The\n   signature length is\
    \ in words and includes the signature type block.\n   If the calculated signature\
    \ octet count is not a multiple of 4, zeros\n   are added to pad it out to a word\
    \ boundary.  If no signature block is\n   present, the overall length of the SASrelay\
    \ message will be set to 19\n   words.\n   The next 8 bits are used for flags.\
    \  Undefined flags are set to zero\n   and ignored.  Three flags are currently\
    \ defined.  The Disclosure Flag\n   (D) is a Boolean bit defined in Section 11.\
    \  The Allow Clear flag (A)\n   is a Boolean bit defined in Section 4.7.2.  The\
    \ SAS Verified flag (V)\n   is a Boolean bit defined in Section 7.1.  These flags\
    \ are updated\n   values to the same flags provided earlier in the Confirm message,\
    \ but\n   they are updated to reflect the new flag information relayed by the\n\
    \   PBX from the other party.\n   The next 32-bit word contains the SAS rendering\
    \ scheme for the\n   relayed sashash, which will be the same rendering scheme\
    \ used by the\n   other party on the other side of the trusted MiTM.  Section\
    \ 7.3\n   describes how the PBX determines whether the ZRTP client regards the\n\
    \   PBX as a trusted MiTM.  If the PBX determines that the ZRTP client\n   trusts\
    \ the PBX, the next 8 words contain the sashash relayed from the\n   other party.\
    \  The first 32-bit word of the sashash contains the\n   sasvalue, which may be\
    \ rendered to the user using the specified SAS\n   rendering scheme.  If this\
    \ SASrelay message is being sent to a ZRTP\n   client that does not trust this\
    \ MiTM, the sashash will be ignored by\n   the recipient and should be set to\
    \ zeros by the PBX.\n   If the signature length (in words) is non-zero, a signature\
    \ type\n   block will be present along with a signature block.  Next, there is\n\
    \   the signature block.  The signature block includes the signature and\n   the\
    \ key (or a link to the key) used to generate the signature\n   (Section 7.2).\n\
    \   CFB mode [NIST-SP800-38A] is applied with a feedback length of 128\n   bits,\
    \ a full cipher block, and the final block is truncated to match\n   the exact\
    \ length of the encrypted data.  The CFB Initialization\n   Vector is a 128-bit\
    \ random nonce.  The block cipher algorithm and the\n   key size is same as the\
    \ negotiated block cipher (Section 5.1.3) for\n   media encryption.  CFB is used\
    \ to encrypt the part of the SASrelay\n   message beginning after the CFB IV to\
    \ the end of the message (the\n   encrypted region is enclosed by \"====\" in\
    \ Figure 16).\n   Depending on whether the trusted MiTM had taken the role of\
    \ the\n   initiator or the responder during the ZRTP key negotiation, the\n  \
    \ SASrelay message is encrypted with zrtpkeyi or zrtpkeyr.\n       0         \
    \          1                   2                   3\n       0 1 2 3 4 5 6 7 8\
    \ 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |0 1 0 1 0 0 0 0 0 1 0 1 1 0 1 0|         length=variable       |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |\
    \             Message Type Block=\"SASrelay\" (2 words)           |\n      | \
    \                                                              |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |                         MAC (2 words)                         |\n   \
    \   |                                                               |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |                                                               |\n   \
    \   |                CFB Initialization Vector (4 words)            |\n      |\
    \                                                               |\n      |   \
    \                                                            |\n      +===============================================================+\n\
    \      | Unused (15 bits of zeros)   | sig len (9 bits)|0 0 0 0|0|V|A|D|\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |\
    \           rendering scheme of relayed SAS (1 word)            |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |                                                               |\n   \
    \   |            Trusted MiTM relayed sashash (8 words)             |\n      |\
    \                             . . .                             |\n      |   \
    \                                                            |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |      optional signature type block (1 word if present)        |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |\
    \                                                               |\n      |   \
    \        optional signature block (variable length)          |\n      |      \
    \                      . . .                              |\n      |         \
    \                                                      |\n      |            \
    \                                                   |\n      +===============================================================+\n\
    \                    Figure 16: SASrelay Message Format\n"
- title: 5.14.  RelayACK Message
  contents:
  - "5.14.  RelayACK Message\n   The RelayACK message is sent in response to a valid\
    \ SASrelay message.\n   The message format for the RelayACK is shown in the figure\
    \ below.\n   The receipt of a RelayACK stops retransmission of the SASrelay\n\
    \   message.\n       0                   1                   2               \
    \    3\n       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n\
    \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   \
    \   |0 1 0 1 0 0 0 0 0 1 0 1 1 0 1 0|         length=3 words        |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |              Message Type Block=\"RelayACK\" (2 words)          |\n \
    \     |                                                               |\n    \
    \  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n       \
    \             Figure 17: RelayACK Message Format\n"
- title: 5.15.  Ping Message
  contents:
  - "5.15.  Ping Message\n   The Ping and PingACK messages are unrelated to the rest\
    \ of the ZRTP\n   protocol.  No ZRTP endpoint is required to generate a Ping message,\n\
    \   but every ZRTP endpoint MUST respond to a Ping message with a PingACK\n  \
    \ message.\n   Although Ping and PingACK messages have no effect on the rest of\
    \ the\n   ZRTP protocol, their inclusion in this specification simplifies the\n\
    \   design of \"bump-in-the-wire\" ZRTP proxies (Section 10) (notably,\n   [Zfone]).\
    \  It enables proxies to be designed that do not rely on\n   assistance from the\
    \ signaling layer to map out the associations\n   between media streams and ZRTP\
    \ endpoints.\n   Before sending a ZRTP Hello message, a ZRTP proxy MAY send a\
    \ Ping\n   message as a means to sort out which RTP media streams are connected\n\
    \   to particular ZRTP endpoints.  Ping messages are generated only by\n   ZRTP\
    \ proxies.  If neither party is a ZRTP proxy, no Ping messages\n   will be encountered.\
    \  Ping retransmission behavior is discussed in\n   Section 6.\n   The Ping message\
    \ (Figure 18) contains an \"EndpointHash\", defined in\n   Section 5.16.\n   The\
    \ Ping message contains a version number that defines what version\n   of PingACK\
    \ is requested.  If that version number is supported by the\n   Ping responder,\
    \ a PingACK with a format that matches that version\n   will be received.  Otherwise,\
    \ a PingACK with a lower version number\n   may be received.\n       0       \
    \            1                   2                   3\n       0 1 2 3 4 5 6 7\
    \ 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |0 1 0 1 0 0 0 0 0 1 0 1 1 0 1 0|        length=6 words         |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |\
    \             Message Type Block=\"Ping    \" (2 words)           |\n      | \
    \                                                              |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |                   version=\"1.10\" (1 word)                     |\n \
    \     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n    \
    \  |                    EndpointHash (2 words)                     |\n      |\
    \                                                               |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                      Figure 18: Ping Message Format\n"
- title: 5.16.  PingACK Message
  contents:
  - "5.16.  PingACK Message\n   A PingACK message is sent only in response to a Ping.\
    \  A ZRTP\n   endpoint MUST respond to a Ping with a PingACK message.  The version\n\
    \   of PingACK requested is contained in the Ping message.  If that\n   version\
    \ number is supported, a PingACK with a format that matches\n   that version MUST\
    \ be sent.  Otherwise, if the version number of the\n   Ping is not supported,\
    \ a PingACK SHOULD be sent in the format of the\n   highest supported version\
    \ known to the Ping responder.  Only version\n   \"1.10\" is supported in this\
    \ specification.\n   The PingACK message carries its own 64-bit EndpointHash,\
    \ distinct\n   from the EndpointHash of the other party's Ping message.  It is\n\
    \   REQUIRED that it be highly improbable for two participants in a call\n   to\
    \ have the same EndpointHash and that an EndpointHash maintains a\n   persistent\
    \ value between calls.  For a normal ZRTP endpoint, such as\n   a ZRTP-enabled\
    \ VoIP client, the EndpointHash can be just the\n   truncated ZID.  For a ZRTP\
    \ endpoint such as a PBX that has multiple\n   endpoints behind it, the EndpointHash\
    \ must be a distinct value for\n   each endpoint behind it.  It is recommended\
    \ that the EndpointHash be\n   a truncated hash of the ZID of the ZRTP endpoint\
    \ concatenated with\n   something unique about the actual endpoint or phone behind\
    \ the PBX.\n   This may be the SIP URI of the phone, the PBX extension number,\
    \ or\n   the local IP address of the phone, whichever is more readily\n   available\
    \ in the application environment:\n     EndpointHash = hash(ZID || SIP URI of\
    \ the endpoint)\n     EndpointHash = hash(ZID || PBX extension number of the endpoint)\n\
    \     EndpointHash = hash(ZID || local IP address of the endpoint)\n   Any of\
    \ these formulae confer uniqueness for the simple case of\n   terminating the\
    \ ZRTP connection at the VoIP client, or the more\n   complex case of a PBX terminating\
    \ the ZRTP connection for multiple\n   VoIP phones in a conference call, all sharing\
    \ the PBX's ZID, but with\n   separate IP addresses behind the PBX.  There is\
    \ no requirement for\n   the same hash function to be used by both parties.\n\
    \   The PingACK message contains the EndpointHash of the sender of the\n   PingACK\
    \ as well as the EndpointHash of the sender of the Ping.  The\n   Source Identifier\
    \ (SSRC) received in the ZRTP header from the Ping\n   packet (Figure 2) is copied\
    \ into the PingACK message body\n   (Figure 19).  This SSRC is not the SSRC of\
    \ the sender of the PingACK.\n      0                   1                   2\
    \                   3\n      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4\
    \ 5 6 7 8 9 0 1\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |0 1 0 1 0 0 0 0 0 1 0 1 1 0 1 0|        length=9 words         |\n    \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     |  \
    \           Message Type Block=\"PingACK \" (2 words)           |\n     |    \
    \                                                           |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |                   version=\"1.10\" (1 word)                     |\n  \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     |\
    \           EndpointHash of PingACK Sender (2 words)            |\n     |    \
    \                                                           |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |            EndpointHash of Received Ping (2 words)            |\n    \
    \ |                                                               |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |       Source Identifier (SSRC) of Received Ping (1 word)      |\n    \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n        \
    \             Figure 19: PingACK Message Format\n"
- title: 6.  Retransmissions
  contents:
  - "6.  Retransmissions\n   ZRTP uses two retransmission timers T1 and T2.  T1 is\
    \ used for\n   retransmission of Hello messages, when the support of ZRTP by the\n\
    \   other endpoint may not be known.  T2 is used in retransmissions of\n   all\
    \ the other ZRTP messages.\n   All message retransmissions MUST be identical to\
    \ the initial message\n   including nonces, public values, etc; otherwise, hashes\
    \ of the\n   message sequences may not agree.\n   Practical experience has shown\
    \ that RTP packet loss at the start of\n   an RTP session can be extremely high.\
    \  Since the entire ZRTP message\n   exchange occurs during this period, the defined\
    \ retransmission scheme\n   is defined to be aggressive.  Since ZRTP packets with\
    \ the exception\n   of the DHPart1 and DHPart2 messages are small, this should\
    \ have\n   minimal effect on overall bandwidth utilization of the media session.\n\
    \   ZRTP endpoints MUST NOT exceed the bandwidth of the resulting media\n   session\
    \ as determined by the offer/answer exchange in the signaling\n   layer.\n   The\
    \ Ping message (Section 5.15) may follow the same retransmission\n   schedule\
    \ as the Hello message, but this is not required in this\n   specification.  Ping\
    \ message retransmission is subject to\n   application-specific ZRTP proxy heuristics.\n\
    \   Hello ZRTP messages are retransmitted at an interval that starts at\n   T1\
    \ seconds and doubles after every retransmission, capping at 200 ms.\n   T1 has\
    \ a recommended initial value of 50 ms.  A Hello message is\n   retransmitted\
    \ 20 times before giving up, which means the entire retry\n   schedule for Hello\
    \ messages is exhausted after 3.75 seconds (50 + 100\n   + 18*200 ms).  Retransmission\
    \ of a Hello ends upon receipt of a\n   HelloACK or Commit message.\n   The post-Hello\
    \ ZRTP messages are retransmitted only by the session\n   initiator -- that is,\
    \ only Commit, DHPart2, and Confirm2 are\n   retransmitted if the corresponding\
    \ message from the responder,\n   DHPart1, Confirm1, and Conf2ACK, are not received.\
    \  Note that the\n   Confirm2 message retransmission can also be stopped by receiving\
    \ the\n   first SRTP media (with a valid SRTP auth tag) from the responder.\n\
    \   The GoClear, Error, and SASrelay messages may be initiated and\n   retransmitted\
    \ by either party, and responded to by the other party,\n   regardless of which\
    \ party is the overall session initiator.  They are\n   retransmitted if the corresponding\
    \ response message ClearACK,\n   ErrorACK, and RelayACK are not received.\n  \
    \ Non-Hello (and non-Ping) ZRTP messages are retransmitted at an\n   interval\
    \ that starts at T2 seconds and doubles after every\n   retransmission, capping\
    \ at 1200 ms.  T2 has a recommended initial\n   value of 150 ms.  Each non-Hello\
    \ message is retransmitted 10 times\n   before giving up, which means the entire\
    \ retry schedule is exhausted\n   after 9.45 seconds (150 + 300 + 600 + 7*1200\
    \ ms).  Only the initiator\n   performs retransmissions.  Each message has a response\
    \ message that\n   stops retransmissions, as shown in the table below.  The higher\n\
    \   values of T2 means that retransmissions will likely occur only in the\n  \
    \ event of packet loss.\n      Message      Acknowledgement Message\n      -------\
    \      -----------------------\n      Hello        HelloACK or Commit\n      Commit\
    \       DHPart1 or Confirm1\n      DHPart2      Confirm1\n      Confirm2     Conf2ACK\
    \ or SRTP media\n      GoClear      ClearACK\n      Error        ErrorACK\n  \
    \    SASrelay     RelayACK\n      Ping         PingACK\n     Table 9. Retransmitted\
    \ ZRTP Messages and Responses\n   The retry schedule must handle not only packet\
    \ loss, but also slow or\n   heavily loaded peers that need additional time to\
    \ perform their DH\n   calculations.  The following mitigations are recommended:\n\
    \   o  Slow or heavily loaded ZRTP endpoints that are at risk of taking\n    \
    \  too long to perform their DH calculation SHOULD use a HelloACK\n      message\
    \ instead of a Commit message to reply to a Hello from the\n      other party.\n\
    \   o  If a ZRTP endpoint has evidence that the other party is a ZRTP\n      endpoint,\
    \ by receiving a Hello message or Ping message, or by\n      receiving a Hello\
    \ Hash in the signaling layer, it SHOULD extend\n      its own Hello retry schedule\
    \ to span at least 12 seconds of\n      retries.  If this extended Hello retry\
    \ schedule is exhausted\n      without receiving a HelloACK or Commit message,\
    \ a late Commit\n      message from the peer SHOULD still be accepted.\n   These\
    \ recommended retransmission intervals are designed for a typical\n   broadband\
    \ Internet connection.  In some high-latency communication\n   channels, such\
    \ as those provided by some mobile phone environments or\n   geostationary satellites,\
    \ a different retransmission schedule may be\n   used.  The initial value for\
    \ the T1 or T2 retransmission timer should\n   be increased to be no less than\
    \ the round-trip time provided by the\n   communications channel.  It should take\
    \ into account the time\n   required to transmit the entire message and the entire\
    \ reply, as well\n   as a reasonable time estimate to perform the DH calculation.\n\
    \   ZRTP has its own retransmission schedule because it is carried along\n   with\
    \ RTP, usually over UDP.  In unusual cases, RTP can run over a\n   non-UDP transport,\
    \ such as TCP or DCCP, which provides its own\n   built-in retransmission mechanism.\
    \  It may be hard for the ZRTP\n   endpoint to detect that TCP is being used if\
    \ media relays are\n   involved.  The ZRTP endpoint may be sending only UDP, but\
    \ there may\n   be a media relay along the media path that converts from UDP to\
    \ TCP\n   for part of the journey.  Or, if the ZRTP endpoint is sending TCP,\n\
    \   the media relay might be converting from TCP to UDP.  There have been\n  \
    \ empirical observations of this in the wild.  In cases where TCP is\n   used,\
    \ ZRTP and TCP might together generate some extra\n   retransmissions.  It is\
    \ tempting to avoid this effect by eliminating\n   the ZRTP retransmission schedule\
    \ when connected to a TCP channel, but\n   that would risk failure of the protocol,\
    \ because it may not be TCP\n   all the way to the remote ZRTP endpoint.  It only\
    \ takes a few packets\n   to complete a ZRTP exchange, so trying to optimize out\
    \ the extra\n   retransmissions in that scenario is not worth the risk.\n   After\
    \ receiving a Commit message, but before receiving a Confirm2\n   message, if\
    \ a ZRTP responder receives no ZRTP messages for more than\n   10 seconds, the\
    \ responder MAY send a protocol timeout Error message\n   and terminate the ZRTP\
    \ protocol.\n"
- title: 7.  Short Authentication String
  contents:
  - "7.  Short Authentication String\n   This section will discuss the implementation\
    \ of the Short\n   Authentication String, or SAS in ZRTP.  The SAS can be verbally\n\
    \   compared by the human users reading the string aloud, or it can be\n   compared\
    \ by validating an OPTIONAL digital signature (described in\n   Section 7.2) exchanged\
    \ in the Confirm1 or Confirm2 messages.\n   The use of hash commitment in the\
    \ DH exchange (Section 4.4.1.1)\n   constrains the attacker to only one guess\
    \ to generate the correct SAS\n   in his attack, which means the SAS can be quite\
    \ short.  A 16-bit SAS,\n   for example, provides the attacker only one chance\
    \ out of 65536 of\n   not being detected.  How the hash commitment enables the\
    \ SAS to be so\n   short is explained in Section 4.4.1.1.\n   There is only one\
    \ SAS value computed per call.  That is the SAS value\n   for the first media\
    \ stream established, which is calculated in\n   Section 4.5.2.  This SAS applies\
    \ to all media streams for the same\n   session.\n   The SAS SHOULD be rendered\
    \ to the user for authentication.  The\n   rendering of the SAS value through\
    \ the user interface at both\n   endpoints depends on the SAS Type agreed upon\
    \ in the Commit message.\n   See Section 5.1.6 for a description of how the SAS\
    \ is rendered to the\n   user.\n   The SAS is not treated as a secret value, but\
    \ it must be compared to\n   see if it matches at both ends of the communications\
    \ channel.  The\n   two users verbally compare it using their human voices, human\
    \ ears,\n   and human judgement.  If it doesn't match, it indicates the presence\n\
    \   of a MiTM attack.\n   It is worse than useless and absolutely unsafe to rely\
    \ on a robot\n   voice from the remote endpoint to compare the SAS, because a\
    \ robot\n   voice can be trivially forged by a MiTM.  The SAS verbal comparison\n\
    \   can only be done with a real live human at the remote endpoint.\n"
- title: 7.1.  SAS Verified Flag
  contents:
  - "7.1.  SAS Verified Flag\n   The SAS Verified flag (V) is set based on the user\
    \ indicating that\n   SAS comparison has been successfully performed.  The SAS\
    \ Verified\n   flag is exchanged securely in the Confirm1 and Confirm2 messages\n\
    \   (Figure 10) of the next session.  In other words, each party sends\n   the\
    \ SAS Verified flag from the previous session in the Confirm\n   message of the\
    \ current session.  It is perfectly reasonable to have a\n   ZRTP endpoint that\
    \ never sets the SAS Verified flag, because it would\n   require adding complexity\
    \ to the user interface to allow the user to\n   set it.  The SAS Verified flag\
    \ is not required to be set, but if it\n   is available to the client software,\
    \ it allows for the possibility\n   that the client software could render to the\
    \ user that the SAS verify\n   procedure was carried out in a previous session.\n\
    \   Regardless of whether there is a user interface element to allow the\n   user\
    \ to set the SAS Verified flag, it is worth caching a shared\n   secret, because\
    \ doing so reduces opportunities for an attacker in the\n   next call.\n   If\
    \ at any time the users carry out the SAS comparison procedure, and\n   it actually\
    \ fails to match, then this means there is a very\n   resourceful MiTM.  If this\
    \ is the first call, the MiTM was there on\n   the first call, which is impressive\
    \ enough.  If it happens in a later\n   call, it also means the MiTM must also\
    \ know the cached shared secret,\n   because you could not have carried out any\
    \ voice traffic at all\n   unless the session key was correctly computed and is\
    \ also known to\n   the attacker.  This implies the MiTM must have been present\
    \ in all\n   the previous sessions, since the initial establishment of the first\n\
    \   shared secret.  This is indeed a resourceful attacker.  It also means\n  \
    \ that if at any time he ceases his participation as a MiTM on one of\n   your\
    \ calls, the protocol will detect that the cached shared secret is\n   no longer\
    \ valid -- because it was really two different shared secrets\n   all along, one\
    \ of them between Alice and the attacker, and the other\n   between the attacker\
    \ and Bob.  The continuity of the cached shared\n   secrets makes it possible\
    \ for us to detect the MiTM when he inserts\n   himself into the ongoing relationship,\
    \ as well as when he leaves.\n   Also, if the attacker tries to stay with a long\
    \ lineage of calls, but\n   fails to execute a DH MiTM attack for even one missed\
    \ call, he is\n   permanently excluded.  He can no longer resynchronize with the\
    \ chain\n   of cached shared secrets.\n   A user interface element (i.e., a checkbox\
    \ or button) is needed to\n   allow the user to tell the software the SAS verify\
    \ was successful,\n   causing the software to set the SAS Verified flag (V), which\n\
    \   (together with our cached shared secret) obviates the need to perform\n  \
    \ the SAS procedure in the next call.  An additional user interface\n   element\
    \ can be provided to let the user tell the software he detected\n   an actual\
    \ SAS mismatch, which indicates a MiTM attack.  The software\n   can then take\
    \ appropriate action, clearing the SAS Verified flag, and\n   erase the cached\
    \ shared secret from this session.  It is up to the\n   implementer to decide\
    \ if this added user interface complexity is\n   warranted.\n   If the SAS matches,\
    \ it means there is no MiTM, which also implies it\n   is now safe to trust a\
    \ cached shared secret for later calls.  If\n   inattentive users don't bother\
    \ to check the SAS, it means we don't\n   know whether there is or is not a MiTM,\
    \ so even if we do establish a\n   new cached shared secret, there is a risk that\
    \ our potential attacker\n   may have a subsequent opportunity to continue inserting\
    \ himself in\n   the call, until we finally get around to checking the SAS.  If\
    \ the\n   SAS matches, it means no attacker was present for any previous\n   session\
    \ since we started propagating cached shared secrets, because\n   this session\
    \ and all the previous sessions were also authenticated\n   with a continuous\
    \ lineage of shared secrets.\n"
- title: 7.2.  Signing the SAS
  contents:
  - "7.2.  Signing the SAS\n   In most applications, it is desirable to avoid the\
    \ added complexity\n   of a PKI-backed digital signature, which is why ZRTP is\
    \ designed not\n   to require it.  Nonetheless, in some applications, it may be\
    \ hard to\n   arrange for two human users to verbally compare the SAS.  Or, an\n\
    \   application may already be using an existing PKI and wants to use it\n   to\
    \ augment ZRTP.\n   To handle these cases, ZRTP allows for an OPTIONAL signature\
    \ feature,\n   which allows the SAS to be checked without human participation.\
    \  The\n   SAS MAY be signed and the signature sent inside the Confirm1,\n   Confirm2\
    \ (Figure 10), or SASrelay (Figure 16) messages.  The\n   signature type (Section\
    \ 5.1.7), length of the signature, and the key\n   used to create the signature\
    \ (or a link to it) are all sent along\n   with the signature.  The signature\
    \ is calculated across the entire\n   SAS hash result (sashash), from which the\
    \ sasvalue was derived.  The\n   signatures exchanged in the encrypted Confirm1,\
    \ Confirm2, or SASrelay\n   messages MAY be used to authenticate the ZRTP exchange.\
    \  A signature\n   may be sent only in the initial media stream in a DH or ECDH\
    \ ZRTP\n   exchange, not in Multistream mode.\n   Although the signature is sent,\
    \ the material that is signed, the\n   sashash, is not sent with it in the Confirm\
    \ message, since both\n   parties have already independently calculated the sashash.\
    \  That is\n   not the case for the SASrelay message, which must relay the sashash.\n\
    \   To avoid unnecessary signature calculations, a signature SHOULD NOT\n   be\
    \ sent if the other ZRTP endpoint did not set the (S) flag in the\n   Hello message\
    \ (Section 5.2).\n   Note that the choice of hash algorithm used in the digital\
    \ signature\n   is independent of the hash used in the sashash.  The sashash is\n\
    \   determined by the negotiated Hash Type (Section 5.1.2), while the\n   hash\
    \ used by the digital signature is separately defined by the\n   digital signature\
    \ algorithm.  For example, the sashash may be based\n   on SHA-256, while the\
    \ digital signature might use SHA-384, if an\n   ECDSA P-384 key is used.\n  \
    \ If the sashash (which is always truncated to 256 bits) is shorter\n   than the\
    \ signature hash, the security is not weakened because the\n   hash commitment\
    \ precludes the attacker from searching for sashash\n   collisions.\n   ECDSA\
    \ algorithms may be used with either OpenPGP-formatted keys, or\n   X.509v3 certificates.\
    \  If the ZRTP key exchange is ECDH, and the SAS\n   is signed, then the signature\
    \ SHOULD be ECDSA, and SHOULD use the\n   same size curve as the ECDH exchange\
    \ if an ECDSA key of that size is\n   available.\n   If a ZRTP endpoint supports\
    \ incoming signatures (evidenced by setting\n   the (S) flag in the Hello message),\
    \ it SHOULD be able to parse\n   signatures from the other endpoint in OpenPGP\
    \ format and MUST be able\n   to parse them in X.509v3 format.  If the incoming\
    \ signature is in an\n   unsupported format, or the trust model does not lead\
    \ to a trusted\n   introducer or a trusted certificate authority (CA), another\n\
    \   authentication method may be used if available, such as the SAS\n   compare,\
    \ or a cached shared secret from a previous session.  If none\n   of these methods\
    \ are available, it is up to the ZRTP user agent and\n   the user to decide whether\
    \ to proceed with the call, after the user\n   is informed.\n   Both ECDSA and\
    \ DSA [FIPS-186-3] have a feature that allows most of\n   the signature calculation\
    \ to be done in advance of the session,\n   reducing latency during call setup.\
    \  This is useful for low-power\n   mobile handsets.\n   ECDSA is preferred because\
    \ it has compact keys as well as compact\n   signatures.  If the signature along\
    \ with its public key certificate\n   are insufficiently compact, the Confirm\
    \ message may become too long\n   for the maximum transmission unit (MTU) size,\
    \ and UDP fragmentation\n   may result.  Some firewalls and NATs may discard fragmented\
    \ UDP\n   packets, which would cause the ZRTP exchange to fail.  It is\n   RECOMMENDED\
    \ that a ZRTP endpoint avoid sending signatures if they\n   would cause UDP fragmentation.\
    \  For a discussion on MTU size and PMTU\n   discovery, see [RFC1191] and [RFC1981].\n\
    \   From a packet-size perspective, ECDSA and DSA both produce equally\n   compact\
    \ signatures for a given signature strength.  DSA keys are much\n   bigger than\
    \ ECDSA keys, but in the case of OpenPGP signatures, the\n   public key is not\
    \ sent along with the signature.\n   All signatures generated MUST use only NIST-approved\
    \ hash algorithms,\n   and MUST avoid using SHA1.  This applies to both OpenPGP\
    \ and X.509v3\n   signatures.  NIST-approved hash algorithms are found in [FIPS-180-3]\n\
    \   or its SHA-3 successor.  All ECDSA curves used throughout this spec\n   are\
    \ over prime fields, drawn from Appendix D.1.2 of [FIPS-186-3].\n"
- title: 7.2.1.  OpenPGP Signatures
  contents:
  - "7.2.1.  OpenPGP Signatures\n   If the SAS Signature Type (Section 5.1.7) specifies\
    \ an OpenPGP\n   signature (\"PGP \"), the signature-related fields are arranged\
    \ as\n   follows.\n   The first field after the 4-octet Signature Type Block is\
    \ the OpenPGP\n   signature.  The format of this signature and the algorithms\
    \ that\n   create it are specified by [RFC4880].  The signature is comprised of\n\
    \   a complete OpenPGP version 4 signature in binary form (not Radix-64),\n  \
    \ as specified in RFC 4880, Section 5.2.3, enclosed in the full OpenPGP\n   packet\
    \ syntax.  The length of the OpenPGP signature is parseable from\n   the signature,\
    \ and depends on the type and length of the signing key.\n   If OpenPGP signatures\
    \ are supported, an implementation SHOULD NOT\n   generate signatures using any\
    \ other signature algorithm except DSA or\n   ECDSA (ECDSA is a reserved algorithm\
    \ type in RFC 4880), but MAY\n   accept other signature types from the other party.\
    \  DSA signatures\n   with keys shorter than 2048 bits or longer than 3072 bits\
    \ MUST NOT be\n   generated.\n   Implementers should be aware that ECDSA signatures\
    \ for OpenPGP are\n   expected to become available when the work in progress [ECC-OpenPGP]\n\
    \   becomes an RFC.  Any use of ECDSA signatures in ZRTP SHOULD NOT\n   generate\
    \ signatures using ECDSA key sizes other than P-224, P-256,\n   and P-384, as\
    \ defined in [FIPS-186-3].\n   RFC 4880, Section 5.2.3.18, specifies a way to\
    \ embed, in an OpenPGP\n   signature, a URI of the preferred key server.  The\
    \ URI should be\n   fully specified to obtain the public key of the signing key\
    \ that\n   created the signature.  This URI MUST be present.  It is up to the\n\
    \   recipient of the signature to obtain the public key of the signing\n   key\
    \ and determine its validity status using the OpenPGP trust model\n   discussed\
    \ in [RFC4880].\n   The contents of Figure 20 lie inside the encrypted region\
    \ of the\n   Confirm message (Figure 10) or the SASrelay message (Figure 16).\n\
    \   The total length of all the material in Figure 20, including the key\n   server\
    \ URI, must not exceed 511 32-bit words (2044 octets).  This\n   length, in words,\
    \ is stored in the signature length field in the\n   Confirm or SASrelay message\
    \ containing the signature.  It is\n   desirable to avoid UDP fragmentation, so\
    \ the URI should be kept\n   short.\n       0                   1            \
    \       2                   3\n       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9\
    \ 0 1 2 3 4 5 6 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |             Signature Type Block = \"PGP \" (1 word)            |\n \
    \     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n    \
    \  |                                                               |\n      |\
    \                       OpenPGP signature                       |\n      |   \
    \                    (variable length)                       |\n      |      \
    \                       . . .                             |\n      |         \
    \                                                      |\n      +===============================================================+\n\
    \                    Figure 20: OpenPGP Signature Format\n"
- title: 7.2.2.  ECDSA Signatures with X.509v3 Certs
  contents:
  - "7.2.2.  ECDSA Signatures with X.509v3 Certs\n   If the SAS Signature Type (Section\
    \ 5.1.7) is \"X509\", the ECDSA\n   signature-related fields are arranged as follows.\n\
    \   The first field after the 4-octet Signature Type Block is the DER\n   encoded\
    \ X.509v3 certificate (the signed public key) of the ECDSA\n   signing key that\
    \ created the signature.  The format of this\n   certificate is specified by the\
    \ NSA's Suite B Certificate and CRL\n   Profile [RFC5759].\n   Following the X.509v3\
    \ certificate at the next word boundary is the\n   ECDSA signature itself.  The\
    \ size of this field depends on the size\n   and type of the public key in the\
    \ aforementioned certificate.  The\n   format of this signature and the algorithms\
    \ that create it are\n   specified by [FIPS-186-3].  The signature is comprised\
    \ of the ECDSA\n   signature output parameters (r, s) in binary form, concatenated,\
    \ in\n   network byte order, with no truncation of leading zeros.  The first\n\
    \   half of the signature is r and the second half is s.  If ECDSA P-256\n   is\
    \ specified, the signature fills 16 words (64 octets), 32 octets\n   each for\
    \ r and s.  If ECDSA P-384 is specified, the signature fills\n   24 words (96\
    \ octets), 48 octets each for r and s.\n   It is up to the recipient of the signature\
    \ to use information in the\n   certificate and path discovery mechanisms to trace\
    \ the chain back to\n   the root CA.  It is recommended that end user certificates\
    \ issued for\n   secure telephony should contain appropriate path discovery links\
    \ to\n   facilitate this.\n   Figure 21 shows a certificate and an ECDSA signature.\
    \  All this\n   material lies inside the encrypted region of the Confirm message\n\
    \   (Figure 10) or the SASrelay message (Figure 16).\n   The total length of all\
    \ the material in Figure 21, including the\n   X.509v3 certificate, must not exceed\
    \ 511 32-bit words (2044 octets).\n   This length, in words, is stored in the\
    \ signature length field in the\n   Confirm or SASrelay message containing the\
    \ signature.  It is\n   desirable to avoid UDP fragmentation, so the certificate\
    \ material\n   should be kept to a much smaller size than this.  End user certs\n\
    \   issued for this purpose should minimize the size of extraneous\n   material\
    \ such as legal notices.\n       0                   1                   2   \
    \                3\n       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5\
    \ 6 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |             Signature Type Block = \"X509\" (1 word)            |\n \
    \     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n    \
    \  |                                                               |\n      |\
    \                Signing key's X.509v3 certificate              |\n      |   \
    \                     (variable length)                      |\n      |      \
    \                       . . .                             |\n      |         \
    \                                                      |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |                                                               |\n   \
    \   |                ECDSA P-256 or P-384 signature                 |\n      |\
    \                    (16 words or 24 words)                     |\n      |   \
    \                          . . .                             |\n      |      \
    \                                                         |\n      +===============================================================+\n\
    \                 Figure 21: X.509v3 ECDSA Signature Format\n"
- title: 7.2.3.  Signing the SAS without a PKI
  contents:
  - "7.2.3.  Signing the SAS without a PKI\n   It's not strictly necessary to use\
    \ a PKI to back the public key that\n   signs the SAS.  For example, it is possible\
    \ to use a self-signed\n   X.509v3 certificate or an OpenPGP key that is not signed\
    \ by any other\n   key.  In this scenario, the same key continuity technique used\
    \ by SSH\n   [RFC4251] may be used.  The public key is cached locally the first\n\
    \   time it is encountered, and when the same public key is encountered\n   again\
    \ in subsequent sessions, it's deemed not to be a MiTM attack.\n   If there is\
    \ no MiTM attack in the first session, there cannot be a\n   MiTM attack in any\
    \ subsequent session.  This is exactly how SSH does\n   it.\n   Of course, the\
    \ security rests on the assumption that the MiTM did not\n   attack in the first\
    \ session.  That assumption seems to work most of\n   the time in the SSH world.\
    \  The user would have to be warned the\n   first time a public key is encountered,\
    \ just as in SSH.  If possible,\n   the SAS should be checked before the user\
    \ consents to caching the new\n   public key.  If the SAS matches in the first\
    \ session, there is no\n   MiTM, and it's safe to cache the public key.  If no\
    \ SAS comparison is\n   possible, it's up to the user, or up to the application,\
    \ to decide\n   whether to take a leap of faith and proceed.  That's how SSH works\n\
    \   most of the time, because SSH users don't have the chance to verbally\n  \
    \ compare an SAS with anyone.\n   For a phone that is SIP-registered to a PBX,\
    \ it may be provisioned\n   with the public key of the PBX, using a trusted automated\n\
    \   provisioning process.  Even without a PKI, the phone knows that the\n   public\
    \ key is the correct one, since it was provisioned into the\n   phone by a trusted\
    \ provisioning mechanism.  This makes it easy for\n   the phone to access several\
    \ automated services commonly offered by a\n   PBX, such as voice mail or a conference\
    \ bridge, where there is no\n   human at the PBX to do a verbal SAS compare. \
    \ The same provisioning\n   may be used to preload the pbxsecret into the phone,\
    \ which is\n   discussed in Section 7.3.1.\n"
- title: 7.3.  Relaying the SAS through a PBX
  contents:
  - "7.3.  Relaying the SAS through a PBX\n   ZRTP is designed to use end-to-end encryption.\
    \  The two parties'\n   verbal comparison of the short authentication string (SAS)\
    \ depends on\n   this assumption.  But in some PBX environments, such as Asterisk,\n\
    \   there are usage scenarios that have the PBX acting as a trusted MiTM,\n  \
    \ which means there are two back-to-back ZRTP connections with separate\n   session\
    \ keys and separate SASs.\n   For example, imagine that Bob has a ZRTP-enabled\
    \ VoIP phone that has\n   been registered with his company's PBX, so that it is\
    \ regarded as an\n   extension of the PBX.  Alice, whose phone is not associated\
    \ with the\n   PBX, might dial the PBX from the outside, and a ZRTP connection\
    \ is\n   negotiated between her phone and the PBX.  She then selects Bob's\n \
    \  extension from the company directory in the PBX.  The PBX makes a\n   call\
    \ to Bob's phone (which might be offsite, many miles away from the\n   PBX through\
    \ the Internet) and a separate ZRTP connection is\n   negotiated between the PBX\
    \ and Bob's phone.  The two ZRTP sessions\n   have different session keys and\
    \ different SASs, which would render\n   the SAS useless for verbal comparison\
    \ between Alice and Bob.  They\n   might even mistakenly believe that a wiretapper\
    \ is present because of\n   the SAS mismatch, causing undue alarm.\n   ZRTP has\
    \ a mechanism for solving this problem by having the PBX relay\n   the Alice/PBX\
    \ SAS to Bob, sending it through to Bob in a special\n   SASrelay message as defined\
    \ in Section 5.13, which is sent after the\n   PBX/Bob ZRTP negotiation is complete,\
    \ after the Confirm messages.\n   Only the PBX, acting as a special trusted MiTM\
    \ (trusted by the\n   recipient of the SASrelay message), will relay the SAS.\
    \  The SASrelay\n   message protects the relayed SAS from tampering via an included\
    \ MAC,\n   similar to how the Confirm message is protected.  Bob's ZRTP-enabled\n\
    \   phone accepts the relayed SAS for rendering only because Bob's phone\n   had\
    \ previously been configured to trust the PBX.  This special\n   trusted relationship\
    \ with the PBX can be established through a\n   special security enrollment procedure\
    \ (Section 7.3.1).  After that\n   enrollment procedure, the PBX is treated by\
    \ Bob as a special trusted\n   MiTM.  This results in Alice's SAS being rendered\
    \ to Bob, so that\n   Alice and Bob may verbally compare them and thus prevent\
    \ a MiTM\n   attack by any other untrusted MiTM.\n   A real \"bad-guy\" MiTM cannot\
    \ exploit this protocol feature to mount a\n   MiTM attack and relay Alice's SAS\
    \ to Bob, because Bob has not\n   previously carried out a special registration\
    \ ritual with the bad\n   guy.  The relayed SAS would not be rendered by Bob's\
    \ phone, because\n   it did not come from a trusted PBX.  The recognition of the\
    \ special\n   trust relationship is achieved with the prior establishment of a\n\
    \   special shared secret between Bob and his PBX, which is called\n   pbxsecret\
    \ (defined in Section 7.3.1), also known as the trusted MiTM\n   key.\n   The\
    \ trusted MiTM key can be stored in a special cache at the time of\n   the initial\
    \ enrollment (which is carried out only once for Bob's\n   phone), and Bob's phone\
    \ associates this key with the ZID of the PBX,\n   while the PBX associates it\
    \ with the ZID of Bob's phone.  After the\n   enrollment has established and stored\
    \ this trusted MiTM key, it can\n   be detected during subsequent ZRTP session\
    \ negotiations between the\n   PBX and Bob's phone, because the PBX and the phone\
    \ MUST pass the hash\n   of the trusted MiTM key in the DH message.  It is then\
    \ used as part\n   of the key agreement to calculate s0.\n   The PBX can determine\
    \ whether it is trusted by the ZRTP user agent of\n   a phone.  The presence of\
    \ a shared trusted MiTM key in the key\n   negotiation sequence indicates that\
    \ the phone has been enrolled with\n   this PBX and therefore trusts it to act\
    \ as a trusted MiTM.  During a\n   key agreement with two other ZRTP endpoints,\
    \ the PBX may have a\n   shared trusted MiTM key with both endpoints, only one\
    \ endpoint, or\n   neither endpoint.  If the PBX has a shared trusted MiTM key\
    \ with\n   neither endpoint, the PBX MUST NOT relay the SAS.  If the PBX has a\n\
    \   shared trusted MiTM key with only one endpoint, the PBX MUST relay\n   the\
    \ SAS from one party to the other by sending an SASrelay message to\n   the endpoint\
    \ with which it shares a trusted MiTM key.  If the PBX has\n   a (separate) shared\
    \ trusted MiTM key with each of the endpoints, the\n   PBX MUST relay the SAS\
    \ to only one endpoint, not both endpoints.\n      Note: In the case of a PBX\
    \ sharing trusted MiTM keys with both\n      endpoints, it does not matter which\
    \ endpoint receives the relayed\n      SAS as long as only one endpoint receives\
    \ it.\n   The relayed SAS fields contain the SAS rendering type and the\n   complete\
    \ sashash.  The receiver absolutely MUST NOT render the\n   relayed SAS if it\
    \ does not come from a specially trusted ZRTP\n   endpoint.  The security of the\
    \ ZRTP protocol depends on not rendering\n   a relayed SAS from an untrusted MiTM,\
    \ because it may be relayed by a\n   MiTM attacker.  See the SASrelay message\
    \ definition (Figure 16) for\n   further details.\n   To ensure that both Alice\
    \ and Bob will use the same SAS rendering\n   scheme after the keys are negotiated,\
    \ the PBX also sends the SASrelay\n   message to the unenrolled party (which does\
    \ not regard this PBX as a\n   trusted MiTM), conveying the SAS rendering scheme,\
    \ but not the\n   sashash, which it sets to zero.  The unenrolled party will ignore\
    \ the\n   relayed SAS field, but will use the specified SAS rendering scheme.\n\
    \   It is possible to route a call through two ZRTP-enabled PBXs using\n   this\
    \ scheme.  Assume Alice is a ZRTP endpoint who trusts her local\n   PBX in Atlanta,\
    \ and Bob is a ZRTP endpoint who trusts his local PBX\n   in Biloxi.  The call\
    \ is routed from Alice to the Atlanta PBX to the\n   Biloxi PBX to Bob.  Atlanta\
    \ would relay the Atlanta-Biloxi SAS to\n   Alice because Alice is enrolled with\
    \ Atlanta, and Biloxi would relay\n   the Atlanta-Biloxi SAS to Bob because Bob\
    \ is enrolled with Biloxi.\n   The two PBXs are not assumed to be enrolled with\
    \ each other in this\n   example.  Both Alice and Bob would view and verbally\
    \ compare the same\n   relayed SAS, the Atlanta-Biloxi SAS.  No more than two\
    \ trusted MiTM\n   nodes can be traversed with this relaying scheme.  This behavior\
    \ is\n   extended to two PBXs that are enrolled with each other, via this\n  \
    \ rule: In the case of a PBX sharing trusted MiTM keys with both\n   endpoints\
    \ (i.e., both enrolled with this PBX), one of which is\n   another PBX (evidenced\
    \ by the M-flag) and one of which is a non-PBX,\n   the MiTM PBX must always relay\
    \ the PBX-to-PBX SAS to the non-PBX\n   endpoint.\n   A ZRTP endpoint phone that\
    \ trusts a PBX to act as a trusted MiTM is\n   effectively delegating its own\
    \ policy decisions of algorithm\n   negotiation to the PBX.\n   When a PBX is\
    \ between two ZRTP endpoints and is terminating their\n   media streams at the\
    \ PBX, the PBX presents its own ZID to the two\n   parties, eclipsing the ZIDs\
    \ of the two parties from each other.  For\n   example, if several different calls\
    \ are routed through such a PBX to\n   several different ZRTP-enabled phones behind\
    \ the PBX, only a single\n   ZID is presented to the calling party in every case\
    \ -- the ZID of the\n   PBX itself.\n   The next section describes the initial\
    \ enrollment procedure that\n   establishes a special shared secret, a trusted\
    \ MiTM key, between a\n   PBX and a phone, so that the phone will learn to recognize\
    \ the PBX as\n   a trusted MiTM.\n"
- title: 7.3.1.  PBX Enrollment and the PBX Enrollment Flag
  contents:
  - "7.3.1.  PBX Enrollment and the PBX Enrollment Flag\n   Both the PBX and the endpoint\
    \ need to know when enrollment is taking\n   place.  One way of doing this is\
    \ to set up an enrollment extension on\n   the PBX that a newly configured endpoint\
    \ would call and establish a\n   ZRTP session.  The PBX would then play audio\
    \ media that offers the\n   user an opportunity to configure his phone to trust\
    \ this PBX as a\n   trusted MiTM.  The PBX calculates and stores the trusted MiTM\
    \ shared\n   secret in its cache and associates it with this phone, indexed by\
    \ the\n   phone's ZID.  The trusted MiTM PBX shared secret is derived from\n \
    \  ZRTPSess via the ZRTP key derivation function (Section 4.5.1) in this\n   manner:\n\
    \      pbxsecret = KDF(ZRTPSess, \"Trusted MiTM key\", (ZIDi || ZIDr), 256)\n\
    \   The pbxsecret is calculated for the whole ZRTP session, not for each\n   stream\
    \ within a session, thus the KDF Context field in this case does\n   not include\
    \ any stream-specific nonce material.\n   The PBX signals the enrollment process\
    \ by setting the PBX Enrollment\n   flag (E) in the Confirm message (Figure 10).\
    \  This flag is used to\n   trigger the ZRTP endpoint's user interface to prompt\
    \ the user to see\n   if it wants to trust this PBX and calculate and store the\
    \ pbxsecret\n   in the cache.  If the user decides to respond by activating the\n\
    \   appropriate user interface element (a menu item, checkbox, or\n   button),\
    \ his ZRTP user agent calculates pbxsecret using the same\n   formula, and saves\
    \ it in a special cache entry associated with this\n   PBX.\n   During a PBX enrollment,\
    \ the GoClear features are disabled.  If the\n   (E) flag is set by the PBX, the\
    \ PBX MUST NOT set the Allow Clear (A)\n   flag.  Thus, (E) implies not (A). \
    \ If a received Confirm message has\n   the (E) flag set, the (A) flag MUST be\
    \ disregarded and treated as\n   false.\n   If the user elects not to enroll,\
    \ perhaps because he dialed a wrong\n   number or does not yet feel comfortable\
    \ with this PBX, he can simply\n   hang up and not save the pbxsecret in his cache.\
    \  The PBX will have\n   it saved in the PBX cache, but that will do no harm.\
    \  The SASrelay\n   scheme does not depend on the PBX trusting the phone.  It\
    \ only\n   depends on the phone trusting the PBX.  It is the phone (the user)\n\
    \   who is at risk if the PBX abuses its MiTM privileges.\n   An endpoint MUST\
    \ NOT store the pbxsecret in the cache without\n   explicit user authorization.\n\
    \   After this enrollment process, the PBX and the ZRTP-enabled phone\n   both\
    \ share a secret that enables the phone to recognize the PBX as a\n   trusted\
    \ MiTM in future calls.  This means that when a future call\n   from an outside\
    \ ZRTP-enabled caller is relayed through the PBX to\n   this phone, the phone\
    \ will render a relayed SAS from the PBX.  If the\n   SASrelay message comes from\
    \ a MiTM that does not know the pbxsecret,\n   the phone treats it as a bad-guy\
    \ MiTM, and refuses to render the\n   relayed SAS.  Regardless of which party\
    \ initiates any future phone\n   calls through the PBX, the enrolled phone or\
    \ the outside phone, the\n   PBX will relay the SAS to the enrolled phone.\n \
    \  This enrollment procedure is designed primarily for phones that are\n   already\
    \ associated with the PBX -- enterprise phones that are\n   \"behind\" the PBX.\
    \  It is not intended for the countless outside\n   phones that are not registered\
    \ to this PBX's SIP server.  It should\n   be regarded as part of the installation\
    \ and provisioning process for\n   a new phone in the organization.\n   There\
    \ are more streamlined methods to configure ZRTP user agents to\n   trust a PBX.\
    \  In large scale deployments, the pbxsecret may be\n   configured into the phone\
    \ by an automated provisioning process, which\n   may be less burdensome for the\
    \ users and less error prone.  This\n   specification does not require a manual\
    \ enrollment process.  Any\n   process that results in a pbxsecret to be computed\
    \ and shared between\n   the PBX and the phone will suffice, as long as the user\
    \ is made aware\n   that this puts the PBX in a position to wiretap the calls.\n\
    \   It is recommended that a ZRTP client not proceed with the PBX\n   enrollment\
    \ procedure without evidence that a MiTM attack is not\n   taking place during\
    \ the enrollment session.  It would be especially\n   damaging if a MiTM tricks\
    \ the client into enrolling with the wrong\n   PBX.  That would enable the malevolent\
    \ MiTM to wiretap all future\n   calls without arousing suspicion, because he\
    \ would appear to be\n   trusted.\n"
- title: 8.  Signaling Interactions
  contents:
  - "8.  Signaling Interactions\n   This section discusses how ZRTP, SIP, and SDP\
    \ work together.\n   Note that ZRTP may be implemented without coupling with the\
    \ SIP\n   signaling.  For example, ZRTP can be implemented as a \"bump in the\n\
    \   wire\" or as a \"bump in the stack\" in which RTP sent by the SIP User\n \
    \  Agent (UA) is converted to ZRTP.  In these cases, the SIP UA will\n   have\
    \ no knowledge of ZRTP.  As a result, the signaling path discovery\n   mechanisms\
    \ introduced in this section should not be definitive --\n   they are a hint.\
    \  Despite the absence of an indication of ZRTP\n   support in an offer or answer,\
    \ a ZRTP endpoint SHOULD still send\n   Hello messages.\n   ZRTP endpoints that\
    \ have control over the signaling path include a\n   ZRTP SDP attributes in their\
    \ SDP offers and answers.  The ZRTP\n   attribute, a=zrtp-hash, is used to indicate\
    \ support for ZRTP and to\n   convey a hash of the Hello message.  The hash is\
    \ computed according\n   to Section 8.1.\n   Aside from the advantages described\
    \ in Section 8.1, there are a\n   number of potential uses for this attribute.\
    \  It is useful when\n   signaling elements would like to know when ZRTP may be\
    \ utilized by\n   endpoints.  It is also useful if endpoints support multiple\
    \ methods\n   of SRTP key management.  The ZRTP attribute can be used to ensure\n\
    \   that these key management approaches work together instead of against\n  \
    \ each other.  For example, if only one endpoint supports ZRTP, but\n   both support\
    \ another method to key SRTP, then the other method will\n   be used instead.\
    \  When used in parallel, an SRTP secret carried in an\n   a=keymgt [RFC4567]\
    \ or a=crypto [RFC4568] attribute can be used as a\n   shared secret for the srtps\
    \ computation defined in Section 8.2.  The\n   ZRTP attribute is also used to\
    \ signal to an intermediary ZRTP device\n   not to act as a ZRTP endpoint, as\
    \ discussed in Section 10.\n   The a=zrtp-hash attribute can only be included\
    \ in the SDP at the\n   media level since Hello messages sent in different media\
    \ streams will\n   have unique hashes.\n   The ABNF for the ZRTP attribute is\
    \ as follows:\n       zrtp-attribute   = \"a=zrtp-hash:\" zrtp-version zrtp-hash-value\n\
    \       zrtp-version     = token\n       zrtp-hash-value  = 1*(HEXDIG)\n   Here's\
    \ an example of the ZRTP attribute in an initial SDP offer or\n   answer used\
    \ at the media level, using the <allOneLine> convention\n   defined in RFC 4475,\
    \ Section 2.1 [RFC4475]:\n     v=0\n     o=bob 2890844527 2890844527 IN IP4 client.biloxi.example.com\n\
    \     s=\n     c=IN IP4 client.biloxi.example.com\n     t=0 0\n     m=audio 3456\
    \ RTP/AVP 97 33\n     a=rtpmap:97 iLBC/8000\n     a=rtpmap:33 no-op/8000\n   <allOneLine>\n\
    \     a=zrtp-hash:1.10 fe30efd02423cb054e50efd0248742ac7a52c8f91bc2\n     df881ae642c371ba46df\n\
    \   </allOneLine>\n   A mechanism for carrying this same zrtp-hash information\
    \ in the\n   Jingle signaling protocol is defined in [XEP-0262].\n   It should\
    \ be safe to send ZRTP messages even when there is no\n   evidence in the signaling\
    \ that the other party supports it, because\n   ZRTP has been designed to be clearly\
    \ different from RTP, having a\n   similar structure to STUN packets sent during\
    \ an ICE exchange.\n"
- title: 8.1.  Binding the Media Stream to the Signaling Layer via the Hello Hash
  contents:
  - "8.1.  Binding the Media Stream to the Signaling Layer via the Hello Hash\n  \
    \ Tying the media stream to the signaling channel can help prevent a\n   third\
    \ party from inserting false media packets.  If the signaling\n   layer contains\
    \ information that ties it to the media stream, false\n   media streams can be\
    \ rejected.\n   To accomplish this, the entire Hello message (Figure 3) is hashed,\n\
    \   using the hash algorithm defined in Section 5.1.2.2.  The ZRTP packet\n  \
    \ framing from Figure 2 is not included in the hash.  The resulting\n   hash image\
    \ is made available without truncation to the signaling\n   layer, where it is\
    \ transmitted as a hexadecimal value in the SIP\n   channel using the SDP attribute\
    \ a=zrtp-hash, defined in this\n   specification.  Assuming Section 5.1.2.2 defines\
    \ a 256-bit hash\n   length, the a=zrtp-hash field in the SDP attribute carries\
    \ 64\n   hexadecimal digits.  Each media stream (audio or video) will have a\n\
    \   separate Hello message, and thus will require a separate a=zrtp-hash\n   in\
    \ an SDP attribute.  The recipient of the SIP/SDP message can then\n   use this\
    \ hash image to detect and reject false Hello messages in the\n   media channel,\
    \ as well as identify which media stream is associated\n   with this SIP call.\
    \  Each Hello message hashes uniquely, because it\n   contains the H3 field derived\
    \ from a random nonce, defined in\n   Section 9.\n   The Hello Hash as an SDP\
    \ attribute is not a REQUIRED feature, because\n   some ZRTP endpoints do not\
    \ have the ability to add SDP attributes to\n   the signaling.  For example, if\
    \ ZRTP is implemented in a hardware\n   bump-in-the-wire device, it might only\
    \ have the ability to modify the\n   media packets, not the SIP packets, especially\
    \ if the SIP packets are\n   integrity protected and thus cannot be modified on\
    \ the wire.  If the\n   SDP has no hash image of the ZRTP Hello message, the recipient's\
    \ ZRTP\n   user agent cannot check it, and thus will not be able to reject Hello\n\
    \   messages based on this hash.\n   After the Hello Hash is used to properly\
    \ identify the ZRTP Hello\n   message as belonging to this particular SIP call,\
    \ the rest of the\n   ZRTP message sequence is protected from false packet injection\
    \ by\n   other protection mechanisms, such as the hash chaining mechanism\n  \
    \ defined in Section 9.\n   An attacker who controls only the signaling layer,\
    \ such as an\n   uncooperative VoIP service provider, may be able to deny service\
    \ by\n   corrupting the hash of the Hello message in the SDP attribute, which\n\
    \   would force ZRTP to reject perfectly good Hello messages.  If there\n   is\
    \ reason to believe this is happening, the ZRTP endpoint MAY allow\n   Hello messages\
    \ to be accepted that do not match the hash image in the\n   SDP attribute.\n\
    \   Even in the absence of SIP integrity protection, the inclusion of the\n  \
    \ a=zrtp-hash SDP attribute, when coupled with the hash chaining\n   mechanism\
    \ defined in Section 9, meets the R-ASSOC requirement in the\n   Media Security\
    \ Requirements [RFC5479], which requires:\n      ...a mechanism for associating\
    \ key management messages with both\n      the signaling traffic that initiated\
    \ the session and with\n      protected media traffic.  It is useful to associate\
    \ key management\n      messages with call signaling messages, as this allows\
    \ the SDP\n      offerer to avoid performing CPU-consuming operations (e.g.,\n\
    \      Diffie-Hellman or public key operations) with attackers that have\n   \
    \   not seen the signaling messages.\n   The a=zrtp-hash SDP attribute becomes\
    \ especially useful if the SDP is\n   integrity-protected end-to-end by SIP Identity\
    \ [RFC4474] or better\n   still, Dan Wing's SIP Identity using Media Path [SIP-IDENTITY].\
    \  This\n   leads to an ability to stop MiTM attacks independent of ZRTP's SAS\n\
    \   mechanism, as explained in Section 8.1.1.\n"
- title: 8.1.1.  Integrity-Protected Signaling Enables Integrity-Protected DH
  contents:
  - "8.1.1.  Integrity-Protected Signaling Enables Integrity-Protected DH\n      \
    \  Exchange\n   If and only if the signaling path and the SDP is protected by\
    \ some\n   form of end-to-end integrity protection, such as one of the\n   abovementioned\
    \ mechanisms, so that it can guarantee delivery of the\n   a=zrtp-hash attribute\
    \ without any tampering by a third party, and if\n   there is good reason to trust\
    \ the signaling layer to protect the\n   interests of the end user, it is possible\
    \ to authenticate the key\n   exchange and prevent a MiTM attack.  This can be\
    \ done without\n   requiring the users to verbally compare the SAS, by using the\
    \ hash\n   chaining mechanism defined in Section 9 to provide a series of MAC\n\
    \   keys that protect the entire ZRTP key exchange.  Thus, an end-to-end\n   integrity-protected\
    \ signaling layer automatically enables an\n   integrity-protected Diffie-Hellman\
    \ exchange in ZRTP, which in turn\n   means immunity from a MiTM attack.  Here's\
    \ how it works.\n   The integrity-protected SIP SDP contains a hash commitment\
    \ to the\n   entire Hello message.  The Hello message contains H3, which provides\n\
    \   a hash commitment for the rest of the hash chain H0-H2 (Section 9).\n   The\
    \ Hello message is protected by a 64-bit MAC, keyed by H2.  The\n   Commit message\
    \ is protected by a 64-bit MAC, keyed by H1.  The\n   DHPart1 or DHPart2 messages\
    \ are protected by a 64-bit MAC, keyed by\n   H0.  The MAC protecting the Confirm\
    \ messages is computed by a\n   different MAC key derived from the resulting key\
    \ agreement.  Each\n   message's MAC is checked when the MAC key is received in\
    \ the next\n   message.  If a bad MAC is discovered, it MUST be treated as a\n\
    \   security exception indicating a MiTM attack, perhaps by logging or\n   alerting\
    \ the user, and MUST NOT be treated as a random error.  Random\n   errors are\
    \ already discovered and quietly rejected by bad CRCs\n   (Figure 2).\n   The\
    \ Hello message must be assembled before any hash algorithms are\n   negotiated,\
    \ so an implicit predetermined hash algorithm and MAC\n   algorithm (both defined\
    \ in Section 5.1.2.2) must be used.  All of the\n   aforementioned MACs keyed\
    \ by the hashes in the aforementioned hash\n   chain MUST be computed with the\
    \ MAC algorithm defined in\n   Section 5.1.2.2, with the MAC truncated to 64 bits.\n\
    \   The Media Security Requirements [RFC5479] R-EXISTING requirement can\n   be\
    \ fully met by leveraging a certificate-backed PKI in the signaling\n   layer\
    \ to integrity protect the delivery of the a=zrtp-hash SDP\n   attribute.  This\
    \ would thereby protect ZRTP against a MiTM attack,\n   without requiring the\
    \ user to check the SAS, without adding any\n   explicit signatures or signature\
    \ keys to the ZRTP key exchange and\n   without any extra public key operations\
    \ or extra packets.\n   Without an end-to-end integrity-protection mechanism in\
    \ the signaling\n   layer to guarantee delivery of the a=zrtp-hash SDP attribute\
    \ without\n   modification by a third party, these MACs alone will not prevent\
    \ a\n   MiTM attack.  In that case, ZRTP's built-in SAS mechanism will still\n\
    \   have to be used to authenticate the key exchange.  At the time of\n   this\
    \ writing, very few deployed VoIP clients offer a fully\n   implemented SIP stack\
    \ that provides end-to-end integrity protection\n   for the delivery of SDP attributes.\
    \  Also, end-to-end signaling\n   integrity becomes more problematic if E.164\
    \ numbers [RFC3824] are\n   used in SIP.  Thus, real-world implementations of\
    \ ZRTP endpoints will\n   continue to depend on SAS authentication for quite some\
    \ time.  Even\n   after there is widespread availability of SIP user agents that\
    \ offer\n   integrity protected delivery of SDP attributes, many users will still\n\
    \   be faced with the fact that the signaling path may be controlled by\n   institutions\
    \ that do not have the best interests of the end user in\n   mind.  In those cases,\
    \ SAS authentication will remain the gold\n   standard for the prudent user.\n\
    \   Even without SIP integrity protection, the Media Security\n   Requirements\
    \ [RFC5479] R-ACT-ACT requirement can be met by ZRTP's SAS\n   mechanism.  Although\
    \ ZRTP may benefit from an integrity-protected SIP\n   layer, it is fortunate\
    \ that ZRTP's self-contained MiTM defenses do\n   not actually require an integrity-protected\
    \ SIP layer.  ZRTP can\n   bypass the delays and problems that SIP integrity faces,\
    \ such as\n   E.164 number usage, and the complexity of building and maintaining\
    \ a\n   PKI.\n   In contrast, DTLS-SRTP [RFC5764] appears to depend heavily on\
    \ end-to-\n   end integrity protection in the SIP layer.  Further, DTLS-SRTP must\n\
    \   bear the additional cost of a signature calculation of its own, in\n   addition\
    \ to the signature calculation the SIP layer uses to achieve\n   its integrity\
    \ protection.  ZRTP needs no signature calculation of its\n   own to leverage\
    \ the signature calculation carried out in the SIP\n   layer.\n"
- title: 8.2.  Deriving the SRTP Secret (srtps) from the Signaling Layer
  contents:
  - "8.2.  Deriving the SRTP Secret (srtps) from the Signaling Layer\n   The shared\
    \ secret calculations defined in Section 4.3 make use of the\n   SRTP secret (srtps),\
    \ if it is provided by the signaling layer.\n   It is desirable for only one SRTP\
    \ key negotiation protocol to be\n   used, and that protocol should be ZRTP. \
    \ But in the event the\n   signaling layer negotiates its own SRTP master key\
    \ and salt, using\n   the SDP Security Descriptions (SDES [RFC4568]) or [RFC4567],\
    \ it can\n   be passed from the signaling to the ZRTP layer and mixed into ZRTP's\n\
    \   own shared secret calculations, without compromising security by\n   creating\
    \ a dependency on the signaling for media encryption.\n   ZRTP computes srtps\
    \ from the SRTP master key and salt parameters\n   provided by the signaling layer\
    \ in this manner, truncating the result\n   to 256 bits:\n      srtps = KDF(SRTP\
    \ master key, \"SRTP Secret\", (ZIDi || ZIDr ||\n                    SRTP master\
    \ salt), 256)\n   It is expected that the srtps parameter will be rarely computed\
    \ or\n   used in typical ZRTP endpoints, because it is likely and desirable\n\
    \   that ZRTP will be the sole means of negotiating SRTP keys, needing no\n  \
    \ help from [RFC4568] or [RFC4567].  If srtps is computed, it will be\n   stored\
    \ in the auxiliary shared secret auxsecret, defined in\n   Section 4.3 and used\
    \ in Section 4.3.1.\n"
- title: 8.3.  Codec Selection for Secure Media
  contents:
  - "8.3.  Codec Selection for Secure Media\n   Codec selection is negotiated in the\
    \ signaling layer.  If the\n   signaling layer determines that ZRTP is supported\
    \ by both endpoints,\n   this should provide guidance in codec selection to avoid\
    \ variable\n   bitrate (VBR) codecs that leak information.\n   When voice is compressed\
    \ with a VBR codec, the packet lengths vary\n   depending on the types of sounds\
    \ being compressed.  This leaks a lot\n   of information about the content even\
    \ if the packets are encrypted,\n   regardless of what encryption protocol is\
    \ used [Wright1].  It is\n   RECOMMENDED that VBR codecs be avoided in encrypted\
    \ calls.  It is not\n   a problem if the codec adapts the bitrate to the available\
    \ channel\n   bandwidth.  The vulnerable codecs are the ones that change their\n\
    \   bitrate depending on the type of sound being compressed.\n   It also appears\
    \ that voice activity detection (VAD) leaks information\n   about the content\
    \ of the conversation, but to a lesser extent than\n   VBR.  This effect can be\
    \ mitigated by lengthening the VAD hangover\n   time by a random amount between\
    \ 1 and 2 seconds, if this is feasible\n   in your application.  Only short bursts\
    \ of speech would benefit from\n   lengthening the VAD hangover time.\n   The\
    \ security problems of VBR and VAD are addressed in detail by the\n   guidelines\
    \ in [VBR-AUDIO].  It is RECOMMENDED that ZRTP endpoints\n   follow these guidelines.\n"
- title: 9.  False ZRTP Packet Rejection
  contents:
  - "9.  False ZRTP Packet Rejection\n   An attacker who is not in the media path\
    \ may attempt to inject false\n   ZRTP protocol packets, possibly to effect a\
    \ denial-of-service attack\n   or to inject his own media stream into the call.\
    \  VoIP, by its\n   nature, invites various forms of denial-of-service attacks\
    \ and\n   requires protocol features to reject such attacks.  While bogus SRTP\n\
    \   packets may be easily rejected via the SRTP auth tag field, that can\n   only\
    \ be applied after a key agreement is completed.  During the ZRTP\n   key negotiation\
    \ phase, other false packet rejection mechanisms are\n   needed.  One such mechanism\
    \ is the use of the total_hash in the final\n   shared secret calculation, but\
    \ that can only detect false packets\n   after performing the computationally\
    \ expensive Diffie-Hellman\n   calculation.\n   A lot of work has been done on\
    \ the analysis of denial-of-service\n   attacks, especially from attackers who\
    \ are not in the media path.\n   Such an attacker might inject false ZRTP packets\
    \ to force a ZRTP\n   endpoint to engage in an endless series of pointless and\
    \ expensive DH\n   calculations.  To detect and reject false packets cheaply and\
    \ rapidly\n   as soon as they are received, ZRTP uses a one-way hash chain, which\n\
    \   is a series of successive hash images.  Before each session, the\n   following\
    \ values are computed:\n      H0 = 256-bit random nonce (different for each party)\n\
    \      H1 = hash (H0)\n      H2 = hash (H1)\n      H3 = hash (H2)\n   This one-way\
    \ hash chain MUST use the hash algorithm defined in\n   Section 5.1.2.2, truncated\
    \ to 256 bits.  Each 256-bit hash image is\n   the preimage of the next, and the\
    \ sequence of images is sent in\n   reverse order in the ZRTP packet sequence.\
    \  The hash image H3 is sent\n   in the Hello message, H2 is sent in the Commit\
    \ message, H1 is sent in\n   the DHPart1 or DHPart2 messages, and H0 is sent in\
    \ the Confirm1 or\n   Confirm2 messages.  The initial random H0 nonces that each\
    \ party\n   generates MUST be unpredictable to an attacker and unique within a\n\
    \   ZRTP session, which thereby forces the derived hash images H1-H3 to\n   also\
    \ be unique and unpredictable.\n   The recipient checks if the packet has the\
    \ correct hash preimage, by\n   hashing it and comparing the result with the hash\
    \ image for the\n   preceding packet.  Packets that contain an incorrect hash\
    \ preimage\n   MUST NOT be used by the recipient, but they MAY be processed as\n\
    \   security exceptions, perhaps by logging or alerting the user.  As\n   long\
    \ as these bogus packets are not used, and correct packets are\n   still being\
    \ received, the protocol SHOULD be allowed to run to\n   completion, thereby rendering\
    \ ineffective this denial-of-service\n   attack.\n   Note that since H2 is sent\
    \ in the Commit message, and the initiator\n   does not receive a Commit message,\
    \ the initiator computes the\n   responder's missing H2 by hashing the responder's\
    \ H1.  An analogous\n   interpolation is performed by both parties to handle the\
    \ skipped\n   DHPart1 and DHPart2 messages in Preshared (Section 3.1.2) or\n \
    \  Multistream (Section 3.1.3) modes.\n   Because these hash images alone do not\
    \ protect the rest of the\n   contents of the packet they reside in, this scheme\
    \ assumes the\n   attacker cannot modify the packet contents from a legitimate\
    \ party,\n   which is a reasonable assumption for an attacker who is not in the\n\
    \   media path.  This covers an important range of denial-of-service\n   attacks.\
    \  For dealing with the remaining set of attacks that involve\n   packet modification,\
    \ other mechanisms are used, such as the\n   total_hash in the final shared secret\
    \ calculation, and the hash\n   commitment in the Commit message.\n   Hello messages\
    \ injected by an attacker may be detected and rejected\n   by the inclusion of\
    \ a hash of the Hello message in the signaling, as\n   described in Section 8.\
    \  This mechanism requires that each Hello\n   message be unique, and the inclusion\
    \ of the H3 hash image meets that\n   requirement.\n   If and only if an integrity-protected\
    \ signaling channel is available,\n   the MACs that are keyed by this hash chaining\
    \ scheme can be used to\n   authenticate the entire ZRTP key exchange, and thereby\
    \ prevent a MiTM\n   attack, without relying on the users verbally comparing the\
    \ SAS.  See\n   Section 8.1.1 for details.\n   Some ZRTP user agents allow the\
    \ user to manually switch to clear mode\n   (via the GoClear message) in the middle\
    \ of a secure call, and then\n   later initiate secure mode again.  Many consumer\
    \ client products will\n   omit this feature, but those that allow it may return\
    \ to secure mode\n   again in the same media stream.  Although the same chain\
    \ of hash\n   images will be reused and thus rendered ineffective the second time,\n\
    \   no real harm is done because the new SRTP session keys will be\n   derived\
    \ in part from a cached shared secret, which was safely\n   protected from the\
    \ MiTM in the previous DH exchange earlier in the\n   same session.\n"
- title: 10.  Intermediary ZRTP Devices
  contents:
  - "10.  Intermediary ZRTP Devices\n   This section discusses the operation of a\
    \ ZRTP endpoint that is\n   actually an intermediary.  For example, consider a\
    \ device that\n   proxies both signaling and media between endpoints.  There are\
    \ three\n   possible ways in which such a device could support ZRTP.\n   An intermediary\
    \ device can act transparently to the ZRTP protocol.\n   To do this, a device\
    \ MUST pass non-RTP protocols multiplexed on the\n   same port as RTP (to allow\
    \ ZRTP and STUN).  This is the RECOMMENDED\n   behavior for intermediaries as\
    \ ZRTP and SRTP are best when done end-\n   to-end.\n   An intermediary device\
    \ could implement the ZRTP protocol and act as a\n   ZRTP endpoint on behalf of\
    \ non-ZRTP endpoints behind the intermediary\n   device.  The intermediary could\
    \ determine on a call-by-call basis\n   whether the endpoint behind it supports\
    \ ZRTP based on the presence or\n   absence of the ZRTP SDP attribute flag (a=zrtp-hash).\
    \  For non-ZRTP\n   endpoints, the intermediary device could act as the ZRTP endpoint\n\
    \   using its own ZID and cache.  This approach SHOULD only be used when\n   there\
    \ is some other security method protecting the confidentiality of\n   the media\
    \ between the intermediary and the inside endpoint, such as\n   IPsec or physical\
    \ security.\n   The third mode, which is NOT RECOMMENDED, is for the intermediary\n\
    \   device to attempt to back-to-back the ZRTP protocol.  The only\n   exception\
    \ to this case is where the intermediary device is a trusted\n   element providing\
    \ services to one of the endpoints -- e.g., a Private\n   Branch Exchange or PBX.\
    \  In this mode, the intermediary would attempt\n   to act as a ZRTP endpoint\
    \ towards both endpoints of the media\n   session.  This approach MUST NOT be\
    \ used except as described in\n   Section 7.3 as it will always result in a detected\
    \ MiTM attack and\n   will generate alarms on both endpoints and likely result\
    \ in the\n   immediate termination of the session.  The PBX MUST uses a single\
    \ ZID\n   for all endpoints behind it.\n   In cases where centralized media mixing\
    \ is taking place, the SAS will\n   not match when compared by the humans.  This\
    \ situation can sometimes\n   be known in the SIP signaling by the presence of\
    \ the isfocus feature\n   tag [RFC4579].  As a result, when the isfocus feature\
    \ tag is present,\n   the DH exchange can be authenticated by the mechanism defined\
    \ in\n   Section 8.1.1 or by validating signatures (Section 7.2) in the\n   Confirm\
    \ or SASrelay messages.  For example, consider an audio\n   conference call with\
    \ three participants Alice, Bob, and Carol hosted\n   on a conference bridge in\
    \ Dallas.  There will be three ZRTP encrypted\n   media streams, one encrypted\
    \ stream between each participant and\n   Dallas.  Each will have a different\
    \ SAS.  Each participant will be\n   able to validate their SAS with the conference\
    \ bridge by using\n   signatures optionally present in the Confirm messages (described\
    \ in\n   Section 7.2).  Or, if the signaling path has end-to-end integrity\n \
    \  protection, each DH exchange will have automatic MiTM protection by\n   using\
    \ the mechanism in Section 8.1.1.\n   SIP feature tags can also be used to detect\
    \ if a session is\n   established with an automaton such as an Interactive Voice\
    \ Response\n   (IVR), voicemail system, or speech recognition system.  The display\n\
    \   of SAS strings to users should be disabled in these cases.\n   It is possible\
    \ that an intermediary device acting as a ZRTP endpoint\n   might still receive\
    \ ZRTP Hello and other messages from the inside\n   endpoint.  This could occur\
    \ if there is another inline ZRTP device\n   that does not include the ZRTP SDP\
    \ attribute flag.  An intermediary\n   acting as a ZRTP endpoint receiving ZRTP\
    \ Hello and other messages\n   from the inside endpoint MUST NOT pass these ZRTP\
    \ messages.\n"
- title: 11.  The ZRTP Disclosure Flag
  contents:
  - "11.  The ZRTP Disclosure Flag\n   There are no back doors defined in the ZRTP\
    \ protocol specification.\n   The designers of ZRTP would like to discourage back\
    \ doors in ZRTP-\n   enabled products.  However, despite the lack of back doors\
    \ in the\n   actual ZRTP protocol, it must be recognized that a ZRTP implementer\n\
    \   might still deliberately create a rogue ZRTP-enabled product that\n   implements\
    \ a back door outside the scope of the ZRTP protocol.  For\n   example, they could\
    \ create a product that discloses the SRTP session\n   key generated using ZRTP\
    \ out-of-band to a third party.  They may even\n   have a legitimate business\
    \ reason to do this for some customers.\n   For example, some environments have\
    \ a need to monitor or record\n   calls, such as stock brokerage houses who want\
    \ to discourage insider\n   trading, or special high-security environments with\
    \ special needs to\n   monitor their own phone calls.  We've all experienced automated\n\
    \   messages telling us that \"This call may be monitored for quality\n   assurance\"\
    .  A ZRTP endpoint in such an environment might\n   unilaterally disclose the\
    \ session key to someone monitoring the call.\n   ZRTP-enabled products that perform\
    \ such out-of-band disclosures of\n   the session key can undermine public confidence\
    \ in the ZRTP protocol,\n   unless we do everything we can in the protocol to\
    \ alert the other\n   user that this is happening.\n   If one of the parties is\
    \ using a product that is designed to disclose\n   their session key, ZRTP requires\
    \ them to confess this fact to the\n   other party through a protocol message\
    \ to the other party's ZRTP\n   client, which can properly alert that user, perhaps\
    \ by rendering it\n   in a graphical user interface.  The disclosing party does\
    \ this by\n   sending a Disclosure flag (D) in Confirm1 and Confirm2 messages\
    \ as\n   described in Section 5.7.\n   Note that the intention here is to have\
    \ the Disclosure flag identify\n   products that are designed to disclose their\
    \ session keys, not to\n   identify which particular calls are compromised on\
    \ a call-by-call\n   basis.  This is an important legal distinction, because most\n\
    \   government sanctioned wiretap regulations require a VoIP service\n   provider\
    \ to not reveal which particular calls are wiretapped.  But\n   there is nothing\
    \ illegal about revealing that a product is designed\n   to be wiretap-friendly.\
    \  The ZRTP protocol mandates that such a\n   product \"out\" itself.\n   You\
    \ might be using a ZRTP-enabled product with no back doors, but if\n   your own\
    \ graphical user interface tells you the call is (mostly)\n   secure, except that\
    \ the other party is using a product that is\n   designed in such a way that it\
    \ may have disclosed the session key for\n   monitoring purposes, you might ask\
    \ him what brand of secure telephone\n   he is using, and make a mental note not\
    \ to purchase that brand\n   yourself.  If we create a protocol environment that\
    \ requires such\n   back-doored phones to confess their nature, word will spread\
    \ quickly,\n   and the \"invisible hand\" of the free market will act.  The free\n\
    \   market has effectively dealt with this in the past.\n   Of course, a ZRTP\
    \ implementer can lie about his product having a back\n   door, but the ZRTP standard\
    \ mandates that ZRTP-compliant products\n   MUST adhere to the requirement that\
    \ a back door be confessed by\n   sending the Disclosure flag to the other party.\n\
    \   There will be inevitable comparisons to Steve Bellovin's 2003 April\n   fool\
    \ joke, when he submitted RFC 3514 [RFC3514], which defined the\n   \"Evil bit\"\
    \ in the IPv4 header, for packets with \"evil intent\".  But\n   we submit that\
    \ a similar idea can actually have some merit for\n   securing VoIP.  Sure, one\
    \ can always imagine that some implementer\n   will not be fazed by the rules\
    \ and will lie, but they would have lied\n   anyway even without the Disclosure\
    \ flag.  There are good reasons to\n   believe that it will improve the overall\
    \ percentage of\n   implementations that at least tell us if they put a back door\
    \ in\n   their products, and may even get some of them to decide not to put in\n\
    \   a back door at all.  From a civic hygiene perspective, we are better\n   off\
    \ with having the Disclosure flag in the protocol.\n   If an endpoint stores or\
    \ logs SRTP keys or information that can be\n   used to reconstruct or recover\
    \ SRTP keys after they are no longer in\n   use (i.e., the session is active),\
    \ or otherwise discloses or passes\n   SRTP keys or information that can be used\
    \ to reconstruct or recover\n   SRTP keys to another application or device, the\
    \ Disclosure flag D\n   MUST be set in the Confirm1 or Confirm2 message.\n"
- title: 11.1.  Guidelines on Proper Implementation of the Disclosure Flag
  contents:
  - "11.1.  Guidelines on Proper Implementation of the Disclosure Flag\n   Some implementers\
    \ have asked for guidance on implementing the\n   Disclosure flag.  Some people\
    \ have incorrectly thought that a\n   connection secured with ZRTP cannot be used\
    \ in a call center, with\n   voluntary voice recording, or even with a voicemail\
    \ system.\n   Similarly, some potential users of ZRTP have over considered the\n\
    \   protection that ZRTP can give them.  These guidelines clarify both\n   concerns.\n\
    \   The ZRTP Disclosure flag only governs the ZRTP/SRTP stream itself.\n   It\
    \ does not govern the underlying RTP media stream, nor the actual\n   media itself.\
    \  Consequently, a PBX that uses ZRTP may provide\n   conference calls, call monitoring,\
    \ call recording, voicemail, or\n   other PBX features and still say that it does\
    \ not disclose the ZRTP\n   key material.  A video system may provide DVR features\
    \ and still say\n   that it does not disclose the ZRTP key material.  The ZRTP\
    \ Disclosure\n   flag, when not set, means only that the ZRTP cryptographic key\n\
    \   material stays within the bounds of the ZRTP subsystem.\n   If an application\
    \ has a need to disclose the ZRTP cryptographic key\n   material, the easiest\
    \ way to comply with the protocol is to set the\n   flag to the proper value.\
    \  The next easiest way is to overestimate\n   disclosure.  For example, a call\
    \ center that commonly records calls\n   might choose to set the Disclosure flag\
    \ even though all recording is\n   an analog recording of a call (and thus outside\
    \ the ZRTP scope)\n   because it sets an expectation with clients that their calls\
    \ might be\n   recorded.\n   Note also that the ZRTP Disclosure Flag does not\
    \ require an\n   implementation to preclude hacking or malware.  Malware that\
    \ leaks\n   ZRTP cryptographic key material does not create a liability for the\n\
    \   implementer from non-compliance with the ZRTP specification.\n   A user of\
    \ ZRTP should note that ZRTP is not a panacea against\n   unauthorized recording.\
    \  ZRTP does not and cannot protect against an\n   untrustworthy partner who holds\
    \ a microphone up to the speaker.  It\n   does not protect against someone else\
    \ being in the room.  It does not\n   protect against analog wiretaps in the phone\
    \ or in the room.  It does\n   not mean your partner has not been hacked with\
    \ spyware.  It does not\n   mean that the software has no flaws.  It means that\
    \ the ZRTP\n   subsystem is not knowingly leaking ZRTP cryptographic key material.\n"
- title: 12.  Mapping between ZID and AOR (SIP URI)
  contents:
  - "12.  Mapping between ZID and AOR (SIP URI)\n   The role of the ZID in the management\
    \ of the local cache of shared\n   secrets is explained in Section 4.9.  A particular\
    \ ZID is associated\n   with a particular ZRTP endpoint, typically a VoIP client.\
    \  A single\n   SIP URI (also known as an Address-of-Record, or AOR) may be hosted\
    \ on\n   several different soft VoIP clients, desktop phones, and mobile\n   handsets,\
    \ and each of them will have a different ZID.  Further, a\n   single VoIP client\
    \ may have several SIP URIs configured into its\n   profiles, but only one ZID.\
    \  There is not a one-to-one mapping\n   between a ZID and a SIP URI.  A single\
    \ SIP URI may be associated with\n   several ZIDs, and a single ZID may be associated\
    \ with several SIP\n   URIs on the same client.\n   Not only that, but ZRTP is\
    \ independent of which signaling protocol is\n   used.  It works equally well\
    \ with SIP, Jingle, H.323, or any\n   proprietary signaling protocol.  Thus, a\
    \ ZRTP ZID has little to do\n   with SIP, per se, which means it has little to\
    \ do with a SIP URI.\n   Even though a ZID is associated with a device, not a\
    \ human, it is\n   often the case that a ZRTP endpoint is controlled mainly by\
    \ a\n   particular human.  For example, it may be a mobile phone.  To get the\n\
    \   full benefit of the key continuity features, a local cache entry (and\n  \
    \ thus a ZID) should be associated with some sort of name of the remote\n   party.\
    \  That name could be a human name, or it could be made more\n   precise by specifying\
    \ which ZRTP endpoint he's using.  For example\n   \"Jon Callas\", or \"Jon Callas\
    \ on his iPhone\", or \"Jon on his iPad\", or\n   \"Alice on her office phone\"\
    .  These name strings can be stored in the\n   local cache, indexed by ZID, and\
    \ may have been initially provided by\n   the local user by hand.  Or the local\
    \ cache entry may contain a\n   pointer to an entry in the local address book.\
    \  When a secure session\n   is established, if a prior session has established\
    \ a cache entry, and\n   the new session has a matching cache entry indexed by\
    \ the same ZID,\n   and the SAS has been previously verified, the person's name\
    \ stored in\n   that cache entry should be displayed.\n   If the remote ZID originates\
    \ from a PBX, the displayed name would be\n   the name of that PBX, which might\
    \ be the name of the company who owns\n   that PBX.\n   If it is desirable to\
    \ associate some key material with a particular\n   AOR, digital signatures (Section\
    \ 7.2) may be used, with public key\n   certificates that associate the signature\
    \ key with an AOR.  If more\n   than one ZRTP endpoint shares the same AOR, they\
    \ may all use the same\n   signature key and provide the same public key certificate\
    \ with their\n   signatures.\n"
- title: 13.  IANA Considerations
  contents:
  - "13.  IANA Considerations\n   This specification defines a new SDP [RFC4566] attribute\
    \ in\n   Section 8.\n     Contact name:          Philip Zimmermann <prz@mit.edu>\n\
    \     Attribute name:        \"zrtp-hash\"\n     Type of attribute:     Media\
    \ level\n     Subject to charset:    Not\n     Purpose of attribute:  The 'zrtp-hash'\
    \ indicates that a UA supports\n                            the ZRTP protocol\
    \ and provides a hash of the\n                            ZRTP Hello message.\
    \  The ZRTP protocol\n                            version number is also specified.\n\
    \     Allowed attribute values:  Hex\n"
- title: 14.  Media Security Requirements
  contents:
  - "14.  Media Security Requirements\n   This section discuses how ZRTP meets all\
    \ RTP security requirements\n   discussed in the Media Security Requirements [RFC5479]\
    \ document\n   without any dependencies on other protocols or extensions, unlike\n\
    \   DTLS-SRTP [RFC5764] which requires additional protocols and\n   mechanisms.\n\
    \      R-FORK-RETARGET is met since ZRTP is a media path key agreement\n     \
    \ protocol.\n      R-DISTINCT is met since ZRTP uses ZIDs and allows multiple\n\
    \      independent ZRTP exchanges to proceed.\n      R-HERFP is met since ZRTP\
    \ is a media path key agreement protocol.\n      R-REUSE is met using the Multistream\
    \ and Preshared modes.\n      R-AVOID-CLIPPING is met since ZRTP is a media path\
    \ key agreement\n      protocol.\n      R-RTP-CHECK is met since the ZRTP packet\
    \ format does not pass the\n      RTP validity check.\n      R-ASSOC is met using\
    \ the a=zrtp-hash SDP attribute in INVITEs and\n      responses (Section 8.1).\n\
    \      R-NEGOTIATE is met using the Commit message.\n      R-PSTN is met since\
    \ ZRTP can be implemented in Gateways.\n      R-PFS is met using ZRTP Diffie-Hellman\
    \ key agreement methods.\n      R-COMPUTE is met using the Hello/Commit ZRTP exchange.\n\
    \      R-CERTS is met using the verbal comparison of the SAS.\n      R-FIPS is\
    \ met since ZRTP uses only FIPS-approved algorithms in all\n      relevant categories.\
    \  The authors believe ZRTP is compliant with\n      [NIST-SP800-56A], [NIST-SP800-108],\
    \ [FIPS-198-1], [FIPS-180-3],\n      [NIST-SP800-38A], [FIPS-197], and [NSA-Suite-B],\
    \ which should meet\n      the FIPS-140 validation requirements set by [FIPS-140-2-Annex-A]\n\
    \      and [FIPS-140-2-Annex-D].\n      R-DOS is met since ZRTP does not introduce\
    \ any new denial-of-\n      service attacks.\n      R-EXISTING is met since ZRTP\
    \ can support the use of certificates\n      or keys.\n      R-AGILITY is met\
    \ since the set of hash, cipher, SRTP\n      authentication tag type, key agreement\
    \ method, SAS type, and\n      signature type can all be extended and negotiated.\n\
    \      R-DOWNGRADE is met since ZRTP has protection against downgrade\n      attacks.\n\
    \      R-PASS-MEDIA is met since ZRTP prevents a passive adversary with\n    \
    \  access to the media path from gaining access to keying material\n      used\
    \ to protect SRTP media packets.\n      R-PASS-SIG is met since ZRTP prevents\
    \ a passive adversary with\n      access to the signaling path from gaining access\
    \ to keying\n      material used to protect SRTP media packets.\n      R-SIG-MEDIA\
    \ is met using the a=zrtp-hash SDP attribute in INVITEs\n      and responses.\n\
    \      R-ID-BINDING is met using the a=zrtp-hash SDP attribute\n      (Section\
    \ 8.1).\n      R-ACT-ACT is met using the a=zrtp-hash SDP attribute in INVITEs\n\
    \      and responses.\n      R-BEST-SECURE is met since ZRTP utilizes the RTP/AVP\
    \ profile and\n      hence best effort SRTP in every case.\n      R-OTHER-SIGNALING\
    \ is met since ZRTP can utilize modes in which\n      there is no dependency on\
    \ the signaling path.\n      R-RECORDING is met using the ZRTP Disclosure flag.\n\
    \      R-TRANSCODER is met if the transcoder operates as a trusted MitM\n    \
    \  (i.e., a PBX).\n      R-ALLOW-RTP is met due to ZRTP's best effort encryption.\n"
- title: 15.  Security Considerations
  contents:
  - "15.  Security Considerations\n   This document is all about securely keying SRTP\
    \ sessions.  As such,\n   security is discussed in every section.\n   Most secure\
    \ phones rely on a Diffie-Hellman exchange to agree on a\n   common session key.\
    \  But since DH is susceptible to a MiTM attack, it\n   is common practice to\
    \ provide a way to authenticate the DH exchange.\n   In some military systems,\
    \ this is done by depending on digital\n   signatures backed by a centrally managed\
    \ PKI.  A decade of industry\n   experience has shown that deploying centrally\
    \ managed PKIs can be a\n   painful and often futile experience.  PKIs are just\
    \ too messy and\n   require too much activation energy to get them started.  Setting\
    \ up a\n   PKI requires somebody to run it, which is not practical for an\n  \
    \ equipment provider.  A service provider, like a carrier, might\n   venture down\
    \ this path, but even then you have to deal with cross-\n   carrier authentication,\
    \ certificate revocation lists, and other\n   complexities.  It is much simpler\
    \ to avoid PKIs altogether,\n   especially when developing secure commercial products.\
    \  It is\n   therefore more common for commercial secure phones in the PSTN world\n\
    \   to augment the DH exchange with a Short Authentication String (SAS)\n   combined\
    \ with a hash commitment at the start of the key exchange, to\n   shorten the\
    \ length of SAS material that must be read aloud.  No PKI\n   is required for\
    \ this approach to authenticating the DH exchange.  The\n   AT&T TSD 3600, Eric\
    \ Blossom's COMSEC secure phones [comsec],\n   [PGPfone], and the GSMK CryptoPhone\
    \ are all examples of products that\n   took this simpler lightweight approach.\
    \  The main problem with this\n   approach is inattentive users who may not execute\
    \ the voice\n   authentication procedure.\n   Some questions have been raised\
    \ about voice spoofing during the short\n   authentication string (SAS) comparison.\
    \  But it is a mistake to think\n   this is simply an exercise in voice impersonation\
    \ (perhaps this could\n   be called the \"Rich Little\" attack).  Although there\
    \ are digital\n   signal processing techniques for changing a person's voice,\
    \ that does\n   not mean a MiTM attacker can safely break into a phone conversation\n\
    \   and inject his own SAS at just the right moment.  He doesn't know\n   exactly\
    \ when or in what manner the users will choose to read aloud\n   the SAS, or in\
    \ what context they will bring it up or say it, or even\n   which of the two speakers\
    \ will say it, or if indeed they both will\n   say it.  In addition, some methods\
    \ of rendering the SAS involve using\n   a list of words such as the PGP word\
    \ list[Juola2], in a manner\n   analogous to how pilots use the NATO phonetic\
    \ alphabet to convey\n   information.  This can make it even more complicated\
    \ for the\n   attacker, because these words can be worked into the conversation\
    \ in\n   unpredictable ways.  If the session also includes video (an\n   increasingly\
    \ common usage scenario), the MiTM may be further deterred\n   by the difficulty\
    \ of making the lips sync with the voice-spoofed SAS.\n   The PGP word list is\
    \ designed to make each word phonetically\n   distinct, which also tends to create\
    \ distinctive lip movements.\n   Remember that the attacker places a very high\
    \ value on not being\n   detected, and if he makes a mistake, he doesn't get to\
    \ do it over.\n   A question has been raised regarding the safety of the SAS procedure\n\
    \   for people who don't know each other's voices, because it may allow\n   an\
    \ attack from a MiTM even if he lacks voice impersonation\n   capabilities.  This\
    \ is not as much of a problem as it seems, because\n   it isn't necessary that\
    \ users recognize each other by their voice.\n   It is only necessary that they\
    \ detect that the voice used for the SAS\n   procedure doesn't match the voice\
    \ in the rest of the phone\n   conversation.\n   Special consideration must be\
    \ given to secure phone calls with\n   automated systems that cannot perform a\
    \ verbal SAS comparison between\n   two humans (e.g., a voice mail system).  If\
    \ a well-functioning PKI is\n   available to all parties, it is recommended that\
    \ credentials be\n   provisioned at the automated system sufficient to use one\
    \ of the\n   automatic MiTM detection mechanisms from Section 8.1.1 or\n   Section\
    \ 7.2.  Or rely on a previously established cached shared\n   secret (pbxsecret\
    \ or rs1 or both), backed by a human-executed SAS\n   comparison during an initial\
    \ call.  Note that it is worse than\n   useless and absolutely unsafe to rely\
    \ on a robot voice from the\n   remote endpoint to compare the SAS, because a\
    \ robot voice can be\n   trivially forged by a MiTM.  However, a robot voice may\
    \ be safe to\n   use strictly locally for a different purpose.  A ZRTP user agent\
    \ may\n   render its locally computed SAS to the local user via a robot voice\n\
    \   if no visual display is available, provided the user can readily\n   determine\
    \ that the robot voice is generated locally, not from the\n   remote endpoint.\n\
    \   A popular and field-proven approach to MiTM protection is used by SSH\n  \
    \ (Secure Shell) [RFC4251], which Peter Gutmann likes to call the \"baby\n   duck\"\
    \ security model.  SSH establishes a relationship by exchanging\n   public keys\
    \ in the initial session, when we assume no attacker is\n   present, and this\
    \ makes it possible to authenticate all subsequent\n   sessions.  A successful\
    \ MiTM attacker has to have been present in all\n   sessions all the way back\
    \ to the first one, which is assumed to be\n   difficult for the attacker.  ZRTP's\
    \ key continuity features are\n   actually better than SSH, at least for VoIP,\
    \ for reasons described in\n   Section 15.1.  All this is accomplished without\
    \ resorting to a\n   centrally managed PKI.\n   We use an analogous baby duck\
    \ security model to authenticate the DH\n   exchange in ZRTP.  We don't need to\
    \ exchange persistent public keys,\n   we can simply cache a shared secret and\
    \ re-use it to authenticate a\n   long series of DH exchanges for secure phone\
    \ calls over a long period\n   of time.  If we verbally compare just one SAS,\
    \ and then cache a\n   shared secret for later calls to use for authentication,\
    \ no new voice\n   authentication rituals need to be executed.  We just have to\
    \ remember\n   we did one already.\n   If one party ever loses this cached shared\
    \ secret, it is no longer\n   available for authentication of DH exchanges.  This\
    \ cache mismatch\n   situation is easy to detect by the party that still has a\
    \ surviving\n   shared secret cache entry.  If it fails to match, either there\
    \ is a\n   MiTM attack or one side has lost their shared secret cache entry.\n\
    \   The user agent that discovers the cache mismatch must alert the user\n   that\
    \ a cache mismatch has been detected, and that he must do a verbal\n   comparison\
    \ of the SAS to distinguish if the mismatch is because of a\n   MiTM attack or\
    \ because of the other party losing her cache (normative\n   language is in Section\
    \ 4.3.2).  Voice confirmation is absolutely\n   essential in this situation. \
    \ From that point on, the two parties\n   start over with a new cached shared\
    \ secret.  Then, they can go back\n   to omitting the voice authentication on\
    \ later calls.\n   Precautions must be observed when using a trusted MiTM device\
    \ such as\n   a trusted PBX, as described in Section 7.3.  Make sure you really\n\
    \   trust that this PBX will never be compromised before establishing it\n   as\
    \ a trusted MiTM, because it is in a position to wiretap calls for\n   any phone\
    \ that trusts it.  It is \"licensed\" to be in a position to\n   wiretap.  You\
    \ are safer to try to arrange the connection topology to\n   route the media directly\
    \ between the two ZRTP peers, not through a\n   trusted PBX.  Real end-to-end\
    \ encryption is preferred.\n   The security of the SAS mechanism depends on the\
    \ user verifying it\n   verbally with his peer at the other endpoint.  There is\
    \ some risk the\n   user will not be so diligent and may ignore the SAS.  For\
    \ a\n   discussion on how users become habituated to security warnings in the\n\
    \   PKI certificate world, see [Sunshine].  Part of the problems\n   discussed\
    \ in that paper are from the habituation syndrome common to\n   most warning messages,\
    \ and part of them are from the fact that users\n   simply don't understand trust\
    \ models.  Fortunately, ZRTP doesn't need\n   a trust model to use the SAS mechanism,\
    \ so it's easier for the user\n   to grasp the idea of comparing the SAS verbally\
    \ with the other party;\n   it's easier than understanding a trust model, at least.\
    \  Also, the\n   verbal comparison of the SAS gets both users involved, and they\
    \ will\n   notice a mismatch of the SAS.  Also, the ZRTP user agent will know\n\
    \   when the SAS has been previously verified because of the SAS verified\n  \
    \ flag (V) (Section 7.1), and only ask the user to verify it when\n   needed.\
    \  After it has been verified once, the key continuity features\n   make it unnecessary\
    \ to verify it again.\n"
- title: 15.1.  Self-Healing Key Continuity Feature
  contents:
  - "15.1.  Self-Healing Key Continuity Feature\n   The key continuity features of\
    \ ZRTP are analogous to those provided\n   by SSH (Secure Shell) [RFC4251], but\
    \ they differ in one respect.  SSH\n   caches public signature keys that never\
    \ change, and uses a permanent\n   private signature key that must be guarded\
    \ from disclosure.  If\n   someone steals your SSH private signature key, they\
    \ can impersonate\n   you in all future sessions and can mount a successful MiTM\
    \ attack any\n   time they want.\n   ZRTP caches symmetric key material used to\
    \ compute secret session\n   keys, and these values change with each session.\
    \  If someone steals\n   your ZRTP shared secret cache, they only get one chance\
    \ to mount a\n   MiTM attack, in the very next session.  If they miss that chance,\
    \ the\n   retained shared secret is refreshed with a new value, and the window\n\
    \   of vulnerability heals itself, which means they are locked out of any\n  \
    \ future opportunities to mount a MiTM attack.  This gives ZRTP a\n   \"self-healing\"\
    \ feature if any cached key material is compromised.\n   A MiTM attacker must\
    \ always be in the media path.  This presents a\n   significant operational burden\
    \ for the attacker in many VoIP usage\n   scenarios, because being in the media\
    \ path for every call is often\n   harder than being in the signaling path.  This\
    \ will likely create\n   coverage gaps in the attacker's opportunities to mount\
    \ a MiTM attack.\n   ZRTP's self-healing key continuity features are better than\
    \ SSH at\n   exploiting any temporary gaps in MiTM attack opportunities.  Thus,\n\
    \   ZRTP quickly recovers from any disclosure of cached key material.\n   In systems\
    \ that use a persistent private signature key, such as SSH,\n   the stored signature\
    \ key is usually protected from disclosure by\n   encryption that requires a user-supplied\
    \ high-entropy passphrase.\n   This arrangement may be acceptable for a diligent\
    \ user with a desktop\n   computer sitting in an office with a full ASCII keyboard.\
    \  But it\n   would be prohibitively inconvenient and unsafe to type a high-entropy\n\
    \   passphrase on a mobile phone's numeric keypad while driving a car.\n   Users\
    \ will reject any scheme that requires the use of a passphrase on\n   such a platform,\
    \ which means mobile phones carry an elevated risk of\n   compromise of stored\
    \ key material, and thus would especially benefit\n   from the self-healing aspects\
    \ of ZRTP's key continuity features.\n   The infamous Debian OpenSSL weak key\
    \ vulnerability [dsa-1571]\n   (discovered and patched in May 2008) offers a real-world\
    \ example of\n   why ZRTP's self-healing scheme is a good way to do key continuity.\n\
    \   The Debian bug resulted in the production of a lot of weak SSH (and\n   TLS/SSL)\
    \ keys, which continued to compromise security even after the\n   bug had been\
    \ patched.  In contrast, ZRTP's key continuity scheme adds\n   new entropy to\
    \ the cached key material with every call, so old\n   deficiencies in entropy\
    \ are washed away with each new session.\n   It should be noted that the addition\
    \ of shared secret entropy from\n   previous sessions can extend the strength\
    \ of the new session key to\n   AES-256 levels, even if the new session uses Diffie-Hellman\
    \ keys no\n   larger than DH-3072 or ECDH-256, provided the cached shared secrets\n\
    \   were initially established when the wiretapper was not present.  This\n  \
    \ is why AES-256 MAY be used with the smaller DH key sizes in\n   Section 5.1.5,\
    \ despite the key strength comparisons in Table 2 of\n   [NIST-SP800-57-Part1].\n\
    \   Caching shared symmetric key material is also less CPU intensive\n   compared\
    \ with using digital signatures, which may be important for\n   low-power mobile\
    \ platforms.\n   Unlike the long-lived non-updated key material used by SSH, the\n\
    \   dynamically updated shared secrets of ZRTP may lose sync if\n   traditional\
    \ backup/restore mechanisms are used.  This limitation is a\n   consequence of\
    \ the otherwise beneficial aspects of this approach to\n   key continuity, and\
    \ it is partially mitigated by ZRTP's built-in\n   cache backup logic (Section\
    \ 4.6.1).\n"
- title: 16.  Acknowledgments
  contents:
  - "16.  Acknowledgments\n   The authors would like to thank Bryce \"Zooko\" Wilcox-O'Hearn\
    \ and\n   Colin Plumb for their contributions to the design of this protocol.\n\
    \   Also, thanks to Hal Finney, Viktor Krikun, Werner Dittmann, Dan Wing,\n  \
    \ Sagar Pai, David McGrew, Colin Perkins, Dan Harkins, David Black, Tim\n   Polk,\
    \ Richard Harris, Roni Even, Jon Peterson, and Robert Sparks for\n   their helpful\
    \ comments and suggestions.  Thanks to Lily Chen at NIST\n   for her assistance\
    \ in ensuring compliance with NIST SP800-56A and\n   SP800-108.\n   The use of\
    \ one-way hash chains to key HMACs in ZRTP is similar to\n   Adrian Perrig's TESLA\
    \ protocol [TESLA].\n"
- title: 17.  References
  contents:
  - '17.  References

    '
- title: 17.1.  Normative References
  contents:
  - "17.1.  Normative References\n   [RFC2104]  Krawczyk, H., Bellare, M., and R.\
    \ Canetti, \"HMAC: Keyed-\n              Hashing for Message Authentication\"\
    , RFC 2104,\n              February 1997.\n   [RFC2119]  Bradner, S., \"Key words\
    \ for use in RFCs to Indicate\n              Requirement Levels\", BCP 14, RFC\
    \ 2119, March 1997.\n   [RFC3526]  Kivinen, T. and M. Kojo, \"More Modular Exponential\
    \ (MODP)\n              Diffie-Hellman groups for Internet Key Exchange (IKE)\"\
    ,\n              RFC 3526, May 2003.\n   [RFC3550]  Schulzrinne, H., Casner, S.,\
    \ Frederick, R., and V.\n              Jacobson, \"RTP: A Transport Protocol for\
    \ Real-Time\n              Applications\", STD 64, RFC 3550, July 2003.\n   [RFC3711]\
    \  Baugher, M., McGrew, D., Naslund, M., Carrara, E., and K.\n              Norrman,\
    \ \"The Secure Real-time Transport Protocol (SRTP)\",\n              RFC 3711,\
    \ March 2004.\n   [RFC4231]  Nystrom, M., \"Identifiers and Test Vectors for HMAC-SHA-\n\
    \              224, HMAC-SHA-256, HMAC-SHA-384, and HMAC-SHA-512\",\n        \
    \      RFC 4231, December 2005.\n   [RFC4566]  Handley, M., Jacobson, V., and\
    \ C. Perkins, \"SDP: Session\n              Description Protocol\", RFC 4566,\
    \ July 2006.\n   [RFC4880]  Callas, J., Donnerhacke, L., Finney, H., Shaw, D.,\
    \ and R.\n              Thayer, \"OpenPGP Message Format\", RFC 4880, November\
    \ 2007.\n   [RFC4960]  Stewart, R., \"Stream Control Transmission Protocol\",\n\
    \              RFC 4960, September 2007.\n   [RFC5114]  Lepinski, M. and S. Kent,\
    \ \"Additional Diffie-Hellman\n              Groups for Use with IETF Standards\"\
    , RFC 5114,\n              January 2008.\n   [RFC5479]  Wing, D., Fries, S., Tschofenig,\
    \ H., and F. Audet,\n              \"Requirements and Analysis of Media Security\
    \ Management\n              Protocols\", RFC 5479, April 2009.\n   [RFC5759] \
    \ Solinas, J. and L. Zieglar, \"Suite B Certificate and\n              Certificate\
    \ Revocation List (CRL) Profile\", RFC 5759,\n              January 2010.\n  \
    \ [RFC6188]  McGrew, D., \"The Use of AES-192 and AES-256 in Secure\n        \
    \      RTP\", RFC 6188, March 2011.\n   [FIPS-140-2-Annex-A]\n              \"\
    Annex A: Approved Security Functions for FIPS PUB 140-2\",\n              NIST\
    \ FIPS PUB 140-2 Annex A, January 2011.\n   [FIPS-140-2-Annex-D]\n           \
    \   \"Annex D: Approved Key Establishment Techniques for FIPS\n              PUB\
    \ 140-2\", NIST FIPS PUB 140-2 Annex D, January 2011.\n   [FIPS-180-3]\n     \
    \         \"Secure Hash Standard (SHS)\", NIST FIPS PUB 180-3, October\n     \
    \         2008.\n   [FIPS-186-3]\n              \"Digital Signature Standard (DSS)\"\
    , NIST FIPS PUB 186-\n              3, June 2009.\n   [FIPS-197] \"Advanced Encryption\
    \ Standard (AES)\", NIST FIPS PUB\n              197, November 2001.\n   [FIPS-198-1]\n\
    \              \"The Keyed-Hash Message Authentication Code (HMAC)\", NIST\n \
    \             FIPS PUB 198-1, July 2008.\n   [NIST-SP800-38A]\n              Dworkin,\
    \ M., \"Recommendation for Block Cipher Modes of\n              Operation\", NIST\
    \ Special Publication 800-38A, 2001\n              Edition.\n   [NIST-SP800-56A]\n\
    \              Barker, E., Johnson, D., and M. Smid, \"Recommendation for\n  \
    \            Pair-Wise Key Establishment Schemes Using Discrete\n            \
    \  Logarithm Cryptography\", NIST Special Publication 800-\n              56A\
    \ Revision 1, March 2007.\n   [NIST-SP800-90]\n              Barker, E. and J.\
    \ Kelsey, \"Recommendation for Random\n              Number Generation Using Deterministic\
    \ Random Bit\n              Generators\", NIST Special Publication 800-90 (Revised),\n\
    \              March 2007.\n   [NIST-SP800-108]\n              Chen, L., \"Recommendation\
    \ for Key Derivation Using\n              Pseudorandom Functions\", NIST Special\
    \ Publication 800-\n              108, October 2009.\n   [NSA-Suite-B]\n     \
    \         \"NSA Suite B Cryptography\", NSA Information Assurance\n          \
    \    Directorate, NSA Suite B Cryptography.\n   [NSA-Suite-B-Guide-56A]\n    \
    \          \"Suite B Implementer's Guide to NIST SP 800-56A\", Suite B\n     \
    \         Implementer's Guide to NIST SP 800-56A, 28 July 2009.\n   [TwoFish]\
    \  Schneier, B., Kelsey, J., Whiting, D., Hall, C., and N.\n              Ferguson,\
    \ \"Twofish: A 128-Bit Block Cipher\", June 1998,\n              <http://www.schneier.com/paper-twofish-paper.html>.\n\
    \   [Skein]    Ferguson, N., Lucks, S., Schneier, B., Whiting, D.,\n         \
    \     Bellare, M., Kohno, T., Callas, J., and J. Walker, \"The\n             \
    \ Skein Hash Function Family, Version 1.3 - 1 Oct 2010\", <ht\n              tp://www.skein-hash.info/sites/default/files/\n\
    \              skein1.3.pdf>.\n   [pgpwordlist]\n              \"PGP Word List\"\
    , December 2010, <http://en.wikipedia.org/\n              w/index.php?title=PGP_word_list&oldid=400752943>.\n"
- title: 17.2.  Informative References
  contents:
  - "17.2.  Informative References\n   [RFC1191]  Mogul, J. and S. Deering, \"Path\
    \ MTU discovery\", RFC 1191,\n              November 1990.\n   [RFC1981]  McCann,\
    \ J., Deering, S., and J. Mogul, \"Path MTU Discovery\n              for IP version\
    \ 6\", RFC 1981, August 1996.\n   [RFC3261]  Rosenberg, J., Schulzrinne, H., Camarillo,\
    \ G., Johnston,\n              A., Peterson, J., Sparks, R., Handley, M., and\
    \ E.\n              Schooler, \"SIP: Session Initiation Protocol\", RFC 3261,\n\
    \              June 2002.\n   [RFC3514]  Bellovin, S., \"The Security Flag in\
    \ the IPv4 Header\",\n              RFC 3514, April 1 2003.\n   [RFC3824]  Peterson,\
    \ J., Liu, H., Yu, J., and B. Campbell, \"Using\n              E.164 numbers with\
    \ the Session Initiation Protocol (SIP)\",\n              RFC 3824, June 2004.\n\
    \   [RFC4086]  Eastlake, D., Schiller, J., and S. Crocker, \"Randomness\n    \
    \          Requirements for Security\", BCP 106, RFC 4086, June 2005.\n   [RFC4251]\
    \  Ylonen, T. and C. Lonvick, \"The Secure Shell (SSH)\n              Protocol\
    \ Architecture\", RFC 4251, January 2006.\n   [RFC4474]  Peterson, J. and C. Jennings,\
    \ \"Enhancements for\n              Authenticated Identity Management in the Session\n\
    \              Initiation Protocol (SIP)\", RFC 4474, August 2006.\n   [RFC4475]\
    \  Sparks, R., Hawrylyshen, A., Johnston, A., Rosenberg, J.,\n              and\
    \ H. Schulzrinne, \"Session Initiation Protocol (SIP)\n              Torture Test\
    \ Messages\", RFC 4475, May 2006.\n   [RFC4567]  Arkko, J., Lindholm, F., Naslund,\
    \ M., Norrman, K., and E.\n              Carrara, \"Key Management Extensions\
    \ for Session\n              Description Protocol (SDP) and Real Time Streaming\n\
    \              Protocol (RTSP)\", RFC 4567, July 2006.\n   [RFC4568]  Andreasen,\
    \ F., Baugher, M., and D. Wing, \"Session\n              Description Protocol\
    \ (SDP) Security Descriptions for Media\n              Streams\", RFC 4568, July\
    \ 2006.\n   [RFC4579]  Johnston, A. and O. Levin, \"Session Initiation Protocol\n\
    \              (SIP) Call Control - Conferencing for User Agents\",\n        \
    \      BCP 119, RFC 4579, August 2006.\n   [RFC5117]  Westerlund, M. and S. Wenger,\
    \ \"RTP Topologies\", RFC 5117,\n              January 2008.\n   [RFC5245]  Rosenberg,\
    \ J., \"Interactive Connectivity Establishment\n              (ICE): A Protocol\
    \ for Network Address Translator (NAT)\n              Traversal for Offer/Answer\
    \ Protocols\", RFC 5245,\n              April 2010.\n   [RFC5764]  McGrew, D.\
    \ and E. Rescorla, \"Datagram Transport Layer\n              Security (DTLS) Extension\
    \ to Establish Keys for the Secure\n              Real-time Transport Protocol\
    \ (SRTP)\", RFC 5764, May 2010.\n   [RFC5869]  Krawczyk, H. and P. Eronen, \"\
    HMAC-based Extract-and-Expand\n              Key Derivation Function (HKDF)\"\
    , RFC 5869, May 2010.\n   [RFC6090]  McGrew, D., Igoe, K., and M. Salter, \"Fundamental\
    \ Elliptic\n              Curve Cryptography Algorithms\", RFC 6090, February\
    \ 2011.\n   [SRTP-AES-GCM]\n              McGrew, D., \"AES-GCM and AES-CCM Authenticated\
    \ Encryption\n              in Secure RTP (SRTP)\", Work in Progress, January\
    \ 2011.\n   [ECC-OpenPGP]\n              Jivsov, A., \"ECC in OpenPGP\", Work\
    \ in Progress,\n              March 2011.\n   [VBR-AUDIO]\n              Perkins,\
    \ C. and J. Valin, \"Guidelines for the use of\n              Variable Bit Rate\
    \ Audio with Secure RTP\", Work\n              in Progress, December 2010.\n \
    \  [SIP-IDENTITY]\n              Wing, D. and H. Kaplan, \"SIP Identity using\
    \ Media Path\",\n              Work in Progress, February 2008.\n   [NIST-SP800-57-Part1]\n\
    \              Barker, E., Barker, W., Burr, W., Polk, W., and M. Smid,\n    \
    \          \"Recommendation for Key Management - Part 1: General\n           \
    \   (Revised)\", NIST Special Publication 800-57 - Part\n              1 Revised\
    \ March 2007.\n   [NIST-SP800-131A]\n              Barker, E. and A. Roginsky,\
    \ \"Recommendation for the\n              Transitioning of Cryptographic Algorithms\
    \ and Key\n              Lengths\", NIST Special Publication 800-131A January\
    \ 2011.\n   [SHA-3]    \"Cryptographic Hash Algorithm Competition\", NIST Computer\n\
    \              Security Resource Center Cryptographic Hash Project.\n   [Skein1]\
    \   \"The Skein Hash Function Family - Web site\",\n              <http://www.skein-hash.info/>.\n\
    \   [XEP-0262] Saint-Andre, P., \"Use of ZRTP in Jingle RTP Sessions\", XSF\n\
    \              XEP 0262, August 2010.\n   [Ferguson] Ferguson, N. and B. Schneier,\
    \ \"Practical Cryptography\",\n              Wiley Publishing, 2003.\n   [Juola1]\
    \   Juola, P. and P. Zimmermann, \"Whole-Word Phonetic\n              Distances\
    \ and the PGPfone Alphabet\", Proceedings of the\n              International\
    \ Conference of Spoken Language Processing\n              (ICSLP-96), 1996.\n\
    \   [Juola2]   Juola, P., \"Isolated Word Confusion Metrics and the\n        \
    \      PGPfone Alphabet\", Proceedings of New Methods in Language\n          \
    \    Processing, 1996.\n   [PGPfone]  Zimmermann, P., \"PGPfone\", July 1996,\n\
    \              <http://philzimmermann.com/docs/pgpfone10b7.pdf>.\n   [Zfone] \
    \   Zimmermann, P., \"Zfone Project\", 2006,\n              <http://www.philzimmermann.com/zfone>.\n\
    \   [Byzantine]\n              \"The Two Generals' Problem\", March 2011, <http://\n\
    \              en.wikipedia.org/w/\n              index.php?title=Two_Generals%27_Problem&oldid=417855753>.\n\
    \   [TESLA]    Perrig, A., Canetti, R., Tygar, J., and D. Song, \"The\n      \
    \        TESLA Broadcast Authentication Protocol\", October 2002, <h\n       \
    \       ttp://www.ece.cmu.edu/~adrian/projects/tesla-cryptobytes/\n          \
    \    tesla-cryptobytes.pdf>.\n   [comsec]   Blossom, E., \"The VP1 Protocol for\
    \ Voice Privacy Devices\n              Version 1.2\", <http://www.comsec.com/vp1-protocol.pdf>.\n\
    \   [Wright1]  Wright, C., Ballard, L., Coull, S., Monrose, F., and G.\n     \
    \         Masson, \"Spot me if you can: Uncovering spoken phrases in\n       \
    \       encrypted VoIP conversations\", Proceedings of the 2008\n            \
    \  IEEE Symposium on Security and Privacy 2008,\n              <http://cs.jhu.edu/~cwright/oakland08.pdf>.\n\
    \   [Sunshine] Sunshine, J., Egelman, S., Almuhimedi, H., Atri, N., and\n    \
    \          L. Cranor, \"Crying Wolf: An Empirical Study of SSL Warning\n     \
    \         Effectiveness\", USENIX Security Symposium 2009,\n              <http://lorrie.cranor.org/pubs/sslwarnings.pdf>.\n\
    \   [dsa-1571] \"Debian Security Advisory - OpenSSL predictable random\n     \
    \         number generator\", May 2008,\n              <http://www.debian.org/security/2008/dsa-1571>.\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Philip Zimmermann\n   Zfone Project\n   Santa Cruz, California\n\
    \   EMail: prz@mit.edu\n   URI:   http://philzimmermann.com\n   Alan Johnston\
    \ (editor)\n   Avaya\n   St. Louis, MO  63124\n   EMail: alan.b.johnston@gmail.com\n\
    \   Jon Callas\n   Apple, Inc.\n   EMail: jon@callas.org\n"
