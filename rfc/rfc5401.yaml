- contents:
  - '        Multicast Negative-Acknowledgment (NACK) Building Blocks

    '
  title: __initial_text__
- contents:
  - "Status of This Memo\n   This document specifies an Internet standards track protocol
    for the\n   Internet community, and requests discussion and suggestions for\n
    \  improvements.  Please refer to the current edition of the \"Internet\n   Official
    Protocol Standards\" (STD 1) for the standardization state\n   and status of this
    protocol.  Distribution of this memo is unlimited.\n"
  title: Status of This Memo
- contents:
  - "Copyright Notice\n   Copyright (c) 2008 IETF Trust and the persons identified
    as the\n   document authors.  All rights reserved.\n   This document is subject
    to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents
    (http://trustee.ietf.org/\n   license-info) in effect on the date of publication
    of this document.\n   Please review these documents carefully, as they describe
    your rights\n   and restrictions with respect to this document.\n"
  title: Copyright Notice
- contents:
  - "Abstract\n   This document discusses the creation of reliable multicast protocols\n
    \  that utilize negative-acknowledgment (NACK) feedback.  The rationale\n   for
    protocol design goals and assumptions are presented.  Technical\n   challenges
    for NACK-based (and in some cases general) reliable\n   multicast protocol operation
    are identified.  These goals and\n   challenges are resolved into a set of functional
    \"building blocks\"\n   that address different aspects of reliable multicast protocol\n
    \  operation.  It is anticipated that these building blocks will be\n   useful
    in generating different instantiations of reliable multicast\n   protocols.  This
    document obsoletes RFC 3941.\n"
  title: Abstract
- contents:
  - "Table of Contents\n   1. Introduction ....................................................2\n
    \     1.1. Requirements Language ......................................4\n   2.
    Rationale .......................................................4\n      2.1.
    Delivery Service Model .....................................5\n      2.2. Group
    Membership Dynamics ..................................6\n      2.3. Sender/Receiver
    Relationships ..............................6\n      2.4. Group Size Scalability
    .....................................6\n      2.5. Data Delivery Performance ..................................7\n
    \     2.6. Network Environments .......................................7\n      2.7.
    Intermediate System Assistance .............................8\n   3. Functionality
    ...................................................8\n      3.1. Multicast Sender
    Transmission .............................11\n      3.2. NACK Repair Process .......................................13\n
    \     3.3. Multicast Receiver Join Policies and Procedures ...........26\n      3.4.
    Node (Member) Identification ..............................26\n      3.5. Data
    Content Identification ...............................27\n      3.6. Forward Error
    Correction (FEC) ............................28\n      3.7. Round-Trip Timing
    Collection ..............................29\n      3.8. Group Size Determination/Estimation
    .......................33\n      3.9. Congestion Control Operation ..............................34\n
    \     3.10. Intermediate System Assistance ...........................34\n   4.
    NACK-Based Reliable Multicast Applicability ....................35\n   5. Security
    Considerations ........................................36\n   6. Changes from
    RFC 3941 ..........................................38\n   7. Acknowledgements
    ...............................................38\n   8. References .....................................................39\n
    \     8.1. Normative References ......................................39\n      8.2.
    Informative References ....................................39\n"
  title: Table of Contents
- contents:
  - "1.  Introduction\n   Reliable multicast transport is a desirable technology for
    efficient\n   and reliable distribution of data to a group on the Internet.  The\n
    \  complexities of group communication paradigms necessitate different\n   protocol
    types and instantiations to meet the range of performance\n   and scalability
    requirements of different potential reliable\n   multicast applications and users
    (see [RFC2357]).  This document\n   addresses the creation of reliable multicast
    protocols that utilize\n   negative-acknowledgment (NACK) feedback.  NACK-based
    protocols\n   generally entail less frequent feedback messaging than reliability\n
    \  protocols based on positive acknowledgment (ACK).  The less frequent\n   feedback
    messaging helps simplify the problem of feedback implosion\n   as group size grows
    larger.  While different protocol instantiations\n   may be required to meet specific
    application and network architecture\n   demands [ArchConsiderations], there are
    a number of fundamental\n   components that may be common to these different instantiations.\n
    \  This document describes the framework and common \"building block\"\n   components
    relevant to multicast protocols that are based primarily\n   on NACK operation
    for reliable transport.  While this document\n   discusses a large set of reliable
    multicast components and issues\n   relevant to NACK-based reliable multicast
    protocol design, it\n   specifically addresses in detail the following building
    blocks, which\n   are not addressed in other IETF documents:\n   1.  NACK-based
    multicast sender transmission strategies,\n   2.  NACK repair process with timer-based
    feedback suppression, and\n   3.  Round-trip timing for adapting NACK and other
    timers.\n   NACK-based reliable multicast implementations SHOULD make use of\n
    \  Forward Error Correction (FEC) erasure coding techniques, as\n   described
    in the FEC Building Block [RFC5052] document.  Packet-level\n   erasure coding
    allows missing packets from a given FEC block to be\n   recovered using the parity
    packets instead of classical,\n   individualized retransmission of original source
    data content.  For\n   this reason, this document refers to the protocol mechanisms
    for\n   reliability as a \"repair process.\"  Note that NACK-based protocols\n
    \  can reactively provide the parity packets in response to receiver\n   requests
    for repair rather than just proactively sending added FEC\n   parity content as
    part of the original transmission.  Hybrid\n   proactive/reactive use of FEC content
    is also possible with the\n   mechanisms described in this document.  Some classes
    of FEC coding,\n   such as Maximal Separable Distance (MDS) codes, allow senders
    to\n   dynamically implement deterministic, highly efficient receiver group\n
    \  repair strategies as part of a NACK-based, selective automated\n   repeat-request
    (ARQ) scheme.\n   The potential relationships to other reliable multicast transport\n
    \  building blocks (e.g., FEC, congestion control) and general issues\n   with
    NACK-based reliable multicast protocols are also discussed.\n   This document
    follows the guidelines provided in [RFC3269].\n   Statement of Intent\n   This
    memo contains descriptions of building blocks that can be\n   applied in the design
    of reliable multicast protocols utilizing\n   negative-acknowledgement (NACK)
    feedback.  [RFC3941] contains a\n   previous description of this specification.
    \ RFC 3941 was published\n   in the \"Experimental\" category.  It was the stated
    intent of the\n   Reliable Multicast Transport (RMT) working group at that time
    to\n   resubmit this specification as an IETF Proposed Standard in due\n   course.\n
    \  This Proposed Standard specification is thus based on [RFC3941] and\n   has
    been updated according to accumulated experience and growing\n   protocol maturity
    since the publication of RFC 3941.  Said experience\n   applies both to this specification
    itself and to congestion control\n   strategies related to the use of this specification.\n
    \  The differences between [RFC3941] and this document are listed in\n   Section
    6.\n"
  - contents:
    - "1.1.  Requirements Language\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\",
      \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\",
      and \"OPTIONAL\" in this\n   document are to be interpreted as described in
      [RFC2119].\n"
    title: 1.1.  Requirements Language
  title: 1.  Introduction
- contents:
  - "2.  Rationale\n   Each potential protocol instantiation using the building blocks\n
    \  presented here (and in other applicable building block documents)\n   will
    have specific criteria that may influence individual protocol\n   design.  To
    support the development of applicable building blocks, it\n   is useful to identify
    and summarize driving general protocol design\n   goals and assumptions.  These
    are areas that each protocol\n   instantiation will need to address in detail.
    \ Each building block\n   description in this document will include a discussion
    of the impact\n   of these design criteria.  The categories of design criteria\n
    \  considered here include:\n   1.  Delivery Service Model,\n   2.  Group Membership
    Dynamics,\n   3.  Sender/Receiver Relationships,\n   4.  Group Size Scalability,\n
    \  5.  Data Delivery Performance, and\n   6.  Network Environments.\n   All of
    these areas are at least briefly discussed.  Additionally,\n   other reliable
    multicast transport building block documents, such as\n   [RFC5052], have been
    created to address areas outside of the scope of\n   this document.  NACK-based
    reliable multicast protocol instantiations\n   may depend upon these other building
    blocks as well as the ones\n   presented here.  This document focuses on areas
    that are unique to\n   NACK-based reliable multicast but may be used in concert
    with the\n   other building block areas.  In some cases, a building block may
    be\n   able to address a wide range of assumptions, while in other cases\n   there
    will be trade-offs required to meet different application needs\n   or operating
    environments.  Where necessary, building block features\n   are designed to be
    parametric to meet different requirements.  Of\n   course, an underlying goal
    will be to minimize design complexity and\n   to at least recommend default values
    for any such parameters that\n   meet a general purpose \"bulk data transfer\"
    requirement in a typical\n   Internet environment.  The forms of \"bulk data transfer\"
    covered here\n   include reliable transport of bulky, fixed-length, a priori static\n
    \  content and also transmission of non-predetermined, perhaps streamed,\n   content
    of indefinite length.  Section 3.5 discusses these different\n   forms of bulk
    data content in further detail.\n"
  - contents:
    - "2.1.  Delivery Service Model\n   The implicit goal of a reliable multicast
      transport protocol is the\n   reliable delivery of data among a group of members
      communicating\n   using IP multicast datagram service.  However, the specific
      service\n   the application is attempting to provide can impact design decisions.\n
      \  The most basic service model for reliable multicast transport is that\n   of
      \"bulk transfer\", which is a primary focus of this and other\n   related RMT
      working group documents.  However, the same principles in\n   protocol design
      may also be applied to other service models, e.g.,\n   more interactive exchanges
      of small messages such as with white-\n   boarding or text chat.  Within these
      different models there are\n   issues such as the sender's ability to cache
      transmitted data (or\n   state referencing it) for retransmission or repair.
      \ The needs for\n   ordering and/or causality in the sequence of transmissions
      and\n   receptions among members in the group may be different depending upon\n
      \  data content.  The group communication paradigm differs significantly\n   from
      the point-to-point model in that, depending upon the data\n   content type,
      some receivers may complete reception of a portion of\n   data content and be
      able to act upon it before other members have\n   received the content.  This
      may be acceptable (or even desirable) for\n   some applications but not for
      others.  These varying requirements\n   drive the need for a number of different
      protocol instantiation\n   designs.  A significant challenge in developing generally
      useful\n   building block mechanisms is accommodating even a limited range of\n
      \  these capabilities without defining specific application-level\n   details.\n
      \  Another factor impacting the delivery service model is the potential\n   for
      different receivers in the multicast group to have significantly\n   differing
      quality of network connectivity.  This may involve\n   receivers with very limited
      goodput due to connection rate or\n   substantial packet loss.  NACK-based protocol
      implementations may\n   wish to provide policies by which extremely poor-performing
      receivers\n   are excluded from the main group or migrated to a separate delivery\n
      \  group.  Note that some application models may require that the entire\n   group
      be constrained to the performance of the \"weakest member\" to\n   satisfy operational
      requirements.  In either case, protocol designs\n   should consider this aspect
      of the reliable multicast delivery\n   service model.\n"
    title: 2.1.  Delivery Service Model
  - contents:
    - "2.2.  Group Membership Dynamics\n   One area where group communication can
      differ from point-to-point\n   communications is that even if the composition
      of the group changes,\n   the \"thread\" of communication can still exist.  This
      contrasts with\n   the point-to-point communication model where, if either of
      the two\n   parties leave, the communication process (exchange of data) is\n
      \  terminated (or at least paused).  Depending upon application goals,\n   senders
      and receivers participating in a reliable multicast transport\n   \"session\"
      may be able to join late, leave, and/or potentially rejoin\n   while the ongoing
      group communication \"thread\" still remains\n   functional and useful.  Also
      note that this can impact protocol\n   message content.  If \"late joiners\"
      are supported, some amount of\n   additional information may be placed in message
      headers to\n   accommodate this functionality.  Alternatively, the information
      may\n   be sent in its own message (on demand or intermittently) if the\n   impact
      to the overhead of typical message transmissions is deemed too\n   great.  Group
      dynamics can also impact other protocol mechanisms such\n   as NACK timing,
      congestion control operation, etc.\n"
    title: 2.2.  Group Membership Dynamics
  - contents:
    - "2.3.  Sender/Receiver Relationships\n   The relationship of senders and receivers
      among group members\n   requires consideration.  In some applications, there
      may be a single\n   sender multicasting to a group of receivers.  In other cases,
      there\n   may be more than one sender or the potential for everyone in the\n
      \  group to be a sender and receiver of data may exist.\n"
    title: 2.3.  Sender/Receiver Relationships
  - contents:
    - "2.4.  Group Size Scalability\n   Native IP multicast [RFC1112] may scale to
      extremely large group\n   sizes.  It may be desirable for some applications
      to scale along with\n   the multicast infrastructure's ability to scale.  In
      its simplest\n   form, there are limits to the group size to which a NACK-based\n
      \  protocol can be applied without the potential for the volume of NACK\n   feedback
      messages to overwhelm network capacity.  This is often\n   referred to as \"feedback
      implosion\".  Research suggests that NACK-\n   based reliable multicast group
      sizes on the order of tens of\n   thousands of receivers may operate with acceptable
      levels of feedback\n   to the sender using probabilistic, timer-based suppression
      techniques\n   [NormFeedback].  Instead of receivers immediately transmitting\n
      \  feedback messages when loss is detected, these techniques specify use\n   of
      purposefully-scaled, random back-off timeouts such that some\n   potential NACKing
      receivers can self-suppress their feedback upon\n   hearing messages from other
      receivers that have selected shorter\n   random timeout intervals.  However,
      there may be additional NACK\n   suppression heuristics that can be applied
      to enable these protocols\n   to scale to even larger group sizes.  In large
      scale cases, it may be\n   prohibitive for members to maintain state on all
      other members (in\n   particular, other receivers) in the group.  The impact
      of group size\n   needs to be considered in the development of applicable building\n
      \  blocks.\n   Group size scalability may also be aided by intermediate system\n
      \  assistance; see section 2.7 below.\n"
    title: 2.4.  Group Size Scalability
  - contents:
    - "2.5.  Data Delivery Performance\n   There is a trade-off between scalability
      and data delivery latency\n   when designing NACK-oriented protocols.  If probabilistic,
      timer-\n   based NACK suppression is to be used, there will be some delays built\n
      \  into the NACK process to allow suppression to occur and to allow the\n   sender
      of data to identify appropriate content for efficient repair\n   transmission.
      \ For example, back-off timeouts can be used to ensure\n   efficient NACK suppression
      and repair transmission, but this comes at\n   the cost of increased delivery
      latency and increased buffering\n   requirements for both senders and receivers.
      \ The building blocks\n   SHOULD allow applications to establish bounds for
      data delivery\n   performance.  Note that application designers must be aware
      of the\n   scalability trade-off that is made when such bounds are applied.\n"
    title: 2.5.  Data Delivery Performance
  - contents:
    - "2.6.  Network Environments\n   The Internet Protocol has historically assumed
      a role of providing\n   service across heterogeneous network topologies.  It
      is desirable\n   that a reliable multicast protocol be capable of effectively\n
      \  operating across a wide range of the networks to which general\n   purpose
      IP service applies.  The bandwidth available on the links\n   between the members
      of a single group today may vary between low\n   numbers of kbit/s for wireless
      links and multiple Gbit/s for high\n   speed LAN connections, with varying degrees
      of contention from other\n   flows.  Recently, a number of asymmetric network
      services including\n   56K/ADSL modems, CATV Internet service, satellite, and
      other wireless\n   communication services have begun to proliferate.  Many of
      these are\n   inherently broadcast media with potentially large \"fan-out\"
      to which\n   IP multicast service is highly applicable.  Additionally, policy\n
      \  and/or technical issues may result in topologies where multicast\n   connectivity
      is limited to a source-specific multicast (SSM) model\n   from a specific source
      [RFC4607].  Receivers in the group may be\n   restricted to unicast feedback
      for NACKs and other messages.\n   Consideration must be given, in building block
      development and\n   protocol design, to the nature of the underlying networks.\n"
    title: 2.6.  Network Environments
  - contents:
    - "2.7.  Intermediate System Assistance\n   Intermediate assistance from devices/systems
      with direct knowledge of\n   the underlying network topology may be used to
      increase the\n   performance and scalability of NACK-based reliable multicast\n
      \  protocols.  Feedback aggregation and filtering of sender repair data\n   may
      be possible with NACK-based protocols using FEC-based repair\n   strategies
      as described in the present and other reliable multicast\n   transport building
      block documents.  However, there will continue to\n   be a number of instances
      where intermediate system assistance is not\n   available or practical.  Any
      building block components for NACK-\n   oriented reliable multicast SHALL be
      capable of operating without\n   such assistance.  However, it is RECOMMENDED
      that such protocols also\n   consider utilizing these features when available.\n"
    title: 2.7.  Intermediate System Assistance
  title: 2.  Rationale
- contents:
  - "3.  Functionality\n   The previous section has presented the role of protocol
    building\n   blocks and some of the criteria that may affect NACK-based reliable\n
    \  multicast building block identification/design.  This section\n   describes
    different building block areas applicable to NACK-based\n   reliable multicast
    protocols.  Some of these areas are specific to\n   NACK-based protocols.  Detailed
    descriptions of such areas are\n   provided.  In other cases, the areas (e.g.,
    node identifiers, forward\n   error correction (FEC), etc.) may be applicable
    to other forms of\n   reliable multicast.  In those cases, the discussion below
    describes\n   requirements placed on those general building block areas from the\n
    \  standpoint of NACK-based reliable multicast.  Where applicable, other\n   building
    block documents are referenced for possible contribution to\n   NACK-based reliable
    multicast protocols.\n   For each building block, a notional \"interface description\"
    is\n   provided to illustrate any dependencies of one building block\n   component
    upon another or upon other protocol parameters.  A building\n   block component
    may require some form of \"input\" from another\n   building block component or
    other source to perform its function.\n   Any \"inputs\" required by a building
    block component and/or any\n   resultant \"output\" provided will be defined and
    described in each\n   building block component's interface description.  Note
    that the set\n   of building blocks presented here do not fully satisfy each other's\n
    \  \"input\" and \"output\" needs.  In some cases, \"inputs\" for the building\n
    \  blocks here must come from other building blocks external to this\n   document
    (e.g., congestion control or FEC).  In other cases NACK-\n   based reliable multicast
    building block \"inputs\" must be satisfied by\n   the specific protocol instantiation
    or implementation (e.g.,\n   application data and control).\n   The following
    building block components relevant to NACK-based\n   reliable multicast are identified:\n
    \  NORM (NACK-Oriented Reliable Multicast)-Specific\n   1.  Multicast Sender Transmission\n
    \  2.  NACK Repair Process\n   3.  Multicast Receiver Join Policies and Procedures\n
    \  General Purpose\n   1.  Node (Member) Identification\n   2.  Data Content Identification\n
    \  3.  Forward Error Correction (FEC)\n   4.  Round-Trip Timing Collection\n   5.
    \ Group Size Determination/Estimation\n   6.  Congestion Control Operation\n   7.
    \ Intermediate System Assistance\n   8.  Ancillary Protocol Mechanisms\n   Figure
    1 provides a pictorial overview of these building block areas\n   and some of
    their relationships.  For example, the content of the\n   data messages that a
    sender initially transmits depends upon the\n   \"Node Identification\", \"Data
    Content Identification\", and \"FEC\"\n   components, while the rate of message
    transmission will generally\n   depend upon the \"Congestion Control\" component.
    \ Subsequently, the\n   receivers' response to these transmissions (e.g., NACKing
    for repair)\n   will depend upon the data message content and inputs from other\n
    \  building block components.  Finally, the sender's processing of\n   receiver
    responses will feed back into its transmission strategy.\n   The components on
    the left side of this figure are areas that may be\n   applicable beyond NACK-based
    reliable multicast.  The more\n   significant of these components are discussed
    in other building block\n   documents, such as the FEC Building Block [RFC5052].
    \ Brief\n   descriptions of these areas and their roles in NACK-based reliable\n
    \  multicast protocols are given below, and \"RTT Collection\" is\n   discussed
    in detail in Section 3.7 of this document.\n   The components on the right are
    seen as specific to NACK-based\n   reliable multicast protocols, most notably
    the NACK repair process.\n   These areas are discussed in detail below (most notably,
    \"Multicast\n   Sender Transmission\" and \"NACK Repair Process\" in Sections
    3.1 and\n   3.2).  Some other components (e.g., \"Security\") impact many aspects\n
    \  of the protocol, and others may be more transparent to the core\n   protocol
    processing.  Where applicable, specific technical\n   recommendations are made
    for mechanisms that will properly satisfy\n   the goals of NACK-based reliable
    multicast transport for the\n   Internet.\n                                 Application
    Data and Control\n                                              |\n                                              v\n
    \      .---------------------.           .-----------------------.\n       | Node
    Identification |-------+-->|  Sender Transmission  |<---.\n       `---------------------'
    \      |   `-----------------------'    |\n       .---------------------.       |
    \       |  .------------------. |\n       | Data Identification |-------+        |
    \ | Rcvr Join Policy | |\n       `---------------------'       |        V  `------------------'
    |\n       .---------------------.       |   .----------------------.     |\n    .->|
    Congestion Control  |-------+   | Receiver NACK        |     |\n    |  `---------------------'
    \      |   | Repair Process       |     |\n    |  .---------------------.       |
    \  | .------------------. |     |\n    |  |                     |-------'   |
    | NACK Initiation  | |     |\n    |  |        FEC          |-----.     | `------------------'
    |     |\n    |  |                     |--.  |     | .------------------. |     |\n
    \   |  `---------------------'  |  |     | | NACK Content     | |     |\n    |
    \ .---------------------.  |  |     | `------------------' |     |\n    `--|    RTT
    Collection   |--|--+---->| .------------------. |     |\n       |                     |--+
    \ |     | | NACK Suppression | |     |\n       `---------------------'  |  |     |
    `------------------' |     |\n       .---------------------.  |  |     `----------------------'
    \    |\n       |    Group Size Est.  |--|--'          |  .-----------------.  |\n
    \      |                     |--+             |  |  Intermediate   |  |\n       `---------------------'
    \ |             |  |  System Assist  |  |\n       .---------------------.  |             v
    \ `-----------------'  |\n       |       Other         |  |        .-------------------------.
    \ |\n       `---------------------'  `------->| Sender NACK Processing  |--'\n
    \                                        |   and Repair Response   |\n                                         `-------------------------'\n
    \                      ^                         ^\n                       |                         |\n
    \                    .-----------------------------.\n                     |         (Security)
    \         |\n                     `-----------------------------'\n     Figure
    1: NACK-Based Reliable Multicast Building Block Framework\n"
  - contents:
    - "3.1.  Multicast Sender Transmission\n   Reliable multicast senders will transmit
      data content to the\n   multicast session.  The data content will be application
      dependent.\n   The sender will transmit data content at a rate, and with message\n
      \  sizes, determined by application and/or network architecture\n   requirements.
      \ Any FEC encoding of sender transmissions SHOULD\n   conform with the guidelines
      of the FEC Building Block [RFC5052].\n   When congestion control mechanisms
      are needed (REQUIRED for general\n   Internet operation), the sender transmission
      rate SHALL be controlled\n   by the congestion control mechanism.  In any case,
      it is RECOMMENDED\n   that all data transmissions from multicast senders be
      subject to rate\n   limitations determined by the application or congestion
      control\n   algorithm.  The sender's transmissions SHOULD make good utilization\n
      \  of the available capacity (which may be limited by the application\n   and/or
      by congestion control).  As a result, it is expected there\n   will be overlap
      and multiplexing of new data content transmission\n   with repair content.  Other
      factors related to application operation\n   may determine sender transmission
      formats and methods.  For example,\n   some consideration needs to be given
      to the sender's behavior during\n   intermittent idle periods when it has no
      data to transmit.\n   In addition to data content, other sender messages or
      commands may be\n   employed as part of protocol operation.  These messages
      may occur\n   outside of the scope of application data transfer.  In NACK-based\n
      \  reliable multicast protocols, reliability of such protocol messages\n   may
      be attempted by redundant transmission when positive\n   acknowledgement is
      prohibitive due to group size scalability\n   concerns.  Note that protocol
      design SHOULD provide mechanisms for\n   dealing with cases where such messages
      are not received by the group.\n   As an example, a command message might be
      redundantly transmitted by\n   a sender to indicate that it is temporarily (or
      permanently) halting\n   transmission.  At this time, it may be appropriate
      for receivers to\n   respond with NACKs for any outstanding repairs they require,\n
      \  following the rules of the NACK procedure.  For efficiency, the\n   sender
      should allow sufficient time between the redundant\n   transmissions to receive
      any NACK responses from the receivers to\n   this command.\n   In general, when
      there is any resultant NACK or other feedback\n   operation, the timing of redundant
      transmission of control messages\n   issued by a sender and other NACK-based
      reliable multicast protocol\n   timeouts should be dependent upon the group
      greatest round-trip\n   timing (GRTT) estimate and any expected resultant NACK
      or other\n   feedback operation.  The sender GRTT is an estimate of the worst-case\n
      \  round-trip timing from a given sender to any receivers in the group.\n   It
      is assumed that the GRTT interval is a conservative estimate of\n   the maximum
      span (with respect to delay) of the multicast group\n   across a network topology
      with respect to a given sender.  NACK-based\n   reliable multicast instantiations
      SHOULD be able to dynamically adapt\n   to a wide range of multicast network
      topologies.\n   Inputs:\n   1.  Application data and control.\n   2.  Sender
      node identifier.\n   3.  Data identifiers.\n   4.  Segmentation and FEC parameters.\n
      \  5.  Transmission rate.\n   6.  Application controls.\n   7.  Receiver feedback
      messages (e.g., NACKs).\n   Outputs:\n   1.  Controlled transmission of messages
      with headers uniquely\n       identifying data or repair content within the
      context of the\n       reliable multicast session.\n   2.  Commands indicating
      sender's status or other transport control\n       actions to be taken.\n"
    title: 3.1.  Multicast Sender Transmission
  - contents:
    - "3.2.  NACK Repair Process\n   A critical component of NACK-based reliable multicast
      protocols is\n   the NACK repair process.  This includes both the receiver's
      role in\n   detecting and requesting repair needs and the sender's response
      to\n   such requests.  There are four primary elements of the NACK repair\n
      \  process:\n   1.  Receiver NACK process initiation,\n   2.  NACK suppression,\n
      \  3.  NACK message content,\n   4.  Sender NACK processing and repair response.\n"
    - contents:
      - "3.2.1.  Receiver NACK Process Initiation\n   The NACK process (cycle) will
        be initiated by receivers that detect a\n   need for repair transmissions
        from a specific sender to achieve\n   reliable reception.  When FEC is applied,
        a receiver should initiate\n   the NACK process only when it is known its
        repair requirements exceed\n   the amount of pending FEC transmission for
        a given coding block of\n   data content.  This can be determined at the end
        of the current\n   transmission block (if it is indicated) or upon the start
        of\n   reception of a subsequent coding block or transmission object.  This\n
        \  implies the sender data content is marked to identify its FEC block\n   number
        and that ordinal relationship is preserved in order of\n   transmission.\n
        \  Alternatively, if the sender's transmission advertises the quantity\n   of
        repair packets it is already planning to send for a block, the\n   receiver
        may be able to initiate the NACK process earlier.  Allowing\n   receivers
        to initiate NACK cycles at any time they detect their\n   repair needs have
        exceeded pending repair transmissions may result in\n   slightly quicker repair
        cycles.  However, it may be useful to limit\n   NACK process initiation to
        specific events, such as at the end-of-\n   transmission of an FEC coding
        block or upon detection of subsequent\n   coding blocks.  This can allow receivers
        to aggregate NACK content\n   into a smaller number of NACK messages and provide
        some implicit\n   loose synchronization among the receiver set to help facilitate\n
        \  effective probabilistic suppression of NACK feedback.  The receiver\n   MUST
        maintain a history of data content received from the sender to\n   determine
        its current repair needs.  When FEC is employed, it is\n   expected that the
        history will correspond to a record of pending or\n   partially-received coding
        blocks.\n   For probabilistic, timer-based suppression of feedback, the NACK\n
        \  cycle should begin with receivers observing backoff timeouts.  In\n   conjunction
        with initiating this backoff timeout, it is important\n   that the receivers
        record the position in the sender's transmission\n   sequence at which they
        initiate the NACK cycle.  When the suppression\n   backoff timeout expires,
        the receivers should only consider their\n   repair needs up to this recorded
        transmission position in making the\n   decision to transmit or suppress a
        NACK.  Without this restriction,\n   suppression is greatly reduced as additional
        content is received from\n   the sender during the time a NACK message propagates
        across the\n   network to the sender and other receivers.\n   Inputs:\n   1.
        \ Sender data content with sequencing identifiers from sender\n       transmissions.\n
        \  2.  History of content received from sender.\n   Outputs:\n   1.  NACK
        process initiation decision.\n   2.  Recorded sender transmission sequence
        position.\n"
      title: 3.2.1.  Receiver NACK Process Initiation
    - contents:
      - "3.2.2.  NACK Suppression\n   An effective feedback suppression mechanism
        is the use of random\n   backoff timeouts prior to NACK transmission by receivers
        requiring\n   repairs [SrmFramework].  Upon expiration of the backoff timeout,
        a\n   receiver will request repairs unless its pending repair needs have\n
        \  been completely superseded by NACK messages heard from other\n   receivers
        (when receivers are multicasting NACKs) or from some\n   indicator from the
        sender.  When receivers are unicasting NACK\n   messages, the sender may facilitate
        NACK suppression by forwarding a\n   representation of NACK content it has
        received to the group at large\n   or by providing some other indicator of
        the repair information it\n   will be subsequently transmitting.\n   For effective
        and scalable suppression performance, the backoff\n   timeout periods used
        by receivers should be independently, randomly\n   picked by receivers with
        a truncated exponential distribution\n   [McastFeedback].  This results in
        the majority of the receiver set\n   holding off transmission of NACK messages
        under the assumption that\n   the smaller number of \"early NACKers\" will
        supersede the repair needs\n   of the remainder of the group.  The mean of
        the distribution should\n   be determined as a function of the current estimate
        of the sender's\n   GRTT assessment and a group size estimate that is either
        determined\n   by other mechanisms within the protocol or is preset by the
        multicast\n   application.\n   A simple algorithm can be constructed to generate
        random backoff\n   timeouts with the appropriate distribution.  Additionally,
        the\n   algorithm may be designed to optimize the backoff distribution given\n
        \  the number of receivers (\"R\") potentially generating feedback.  This\n
        \  \"optimization\" minimizes the number of feedback messages (e.g., NACK)\n
        \  in the worst-case situation where all receivers generate a NACK.  The\n
        \  maximum backoff timeout (\"T_maxBackoff\") can be set to control\n   reliable
        delivery latency versus volume of feedback traffic.  A\n   larger value of
        \"T_maxBackoff\" will result in a lower density of\n   feedback traffic for
        a given repair cycle.  A smaller value of\n   \"T_maxBackoff\" results in
        shorter latency, which also reduces the\n   buffering requirements of senders
        and receivers for reliable\n   transport.\n   In the functions below, the
        \"log()\" function specified refers to the\n   \"natural logarithm\" and the
        \"exp()\" function is similarly based upon\n   the mathematical constant 'e'
        (a.k.a.  Euler's number) where \"exp(x)\"\n   corresponds to '\"e\"' raised
        to the power of '\"x\"'.  Given the\n   receiver group size (\"groupSize\")
        and maximum allowed backoff timeout\n   (\"T_maxBackoff\"), random backoff
        timeouts (\"t'\") with a truncated\n   exponential distribution can be picked
        with the following algorithm:\n   1.  Establish an optimal mean (\"L\") for
        the exponential backoff based\n       on the \"groupSize\":\n                           L
        = log(groupSize) + 1\n   2.  Pick a random number (\"x\") from a uniform distribution
        over a\n       range of:\n                L                          L                   L\n
        \       --------------------  to --------------------  +  ----------\n       T_maxBackoff*(exp(L)-1)
        \ T_maxBackoff*(exp(L)-1)  T_maxBackoff\n   3.  Transform this random variate
        to generate the desired random\n       backoff time (\"t'\") with the following
        equation:\n       t' = T_maxBackoff/L * log(x * (exp(L) - 1) * (T_maxBackoff/L))\n
        \  This \"C\" language function can be used to generate an appropriate\n   random
        backoff time interval:\n        double RandomBackoff(double T_maxBackoff,
        double groupSize)\n        {\n            double lambda = log(groupSize) +
        1;\n            double x = UniformRand(lambda/T_maxBackoff) +\n                       lambda
        / (T_maxBackoff*(exp(lambda)-1));\n            return ((T_maxBackoff/lambda)
        *\n                    log(x*(exp(lambda)-1)*(T_maxBackoff/lambda)));\n        }
        \ // end RandomBackoff()\n   where \"UniformRand(double max)\" returns random
        numbers with a uniform\n   distribution from the range of \"0..max\".  For
        example, based on the\n   POSIX \"rand()\" function, the following \"C\" code
        can be used:\n           double UniformRand(double max)\n           {\n               return
        (max * ((double)rand()/(double)RAND_MAX));\n           }\n   The number of
        expected NACK messages generated (\"N\") within the first\n   round-trip time
        for a single feedback event is approximately:\n                  N = exp(1.2
        * L / (2*T_maxBackoff/GRTT))\n   Thus, the maximum backoff time can be adjusted
        to trade off worst-\n   case NACK feedback volume versus latency.  This is
        derived from the\n   equations given in [McastFeedback] and assumes \"T_maxBackoff
        >=\n   GRTT\", and \"L\" is the mean of the distribution optimized for the\n
        \  given group size as shown in the algorithm above.  Note that other\n   mechanisms
        within the protocol may work to reduce redundant NACK\n   generation further.
        \ It is suggested that \"T_maxBackoff\" be selected\n   as an integer multiple
        of the sender's current advertised GRTT\n   estimate such that:\n                   T_maxBackoff
        = K * GRTT; where K >= 1\n   For general Internet operation, a default value
        of \"K=4\" is\n   RECOMMENDED for operation with multicast (to the group at
        large) NACK\n   delivery; a value of \"K=6\" is the RECOMMENDED default for
        unicast\n   NACK delivery.  Alternate values may be used to achieve desired\n
        \  buffer utilization, reliable delivery latency, and group size\n   scalability
        trade-offs.\n   Given that (\"K*GRTT\") is the maximum backoff time used by
        the\n   receivers to initiate NACK transmission, other timeout periods\n   related
        to the NACK repair process can be scaled accordingly.  One of\n   those timeouts
        is the amount of time a receiver should wait after\n   generating a NACK message
        before allowing itself to initiate another\n   NACK backoff/transmission cycle
        (\"T_rcvrHoldoff\").  This delay should\n   be sufficient for the sender to
        respond to the received NACK with\n   repair messages.  An appropriate value
        depends upon the amount of\n   time for the NACK to reach the sender and the
        sender to provide a\n   repair response.  This MUST include any amount of
        sender NACK\n   aggregation period during which possible multiple NACKs are\n
        \  accumulated to determine an efficient repair response.  These\n   timeouts
        are further discussed in Section 3.2.4.\n   There are also secondary measures
        that can be applied to improve the\n   performance of feedback suppression.
        \ For example, the sender's data\n   content transmissions can follow an ordinal
        sequence of transmission.\n   When repairs for data content occur, the receiver
        can note that the\n   sender has \"rewound\" its data content transmission
        position by\n   observing the data object, FEC block number, and FEC symbol\n
        \  identifiers.  Receivers SHOULD limit transmission of NACKs to only\n   when
        the sender's current transmission position exceeds the point to\n   which
        the receiver has incomplete reception.  This reduces premature\n   requests
        for repair of data the sender may be planning to provide in\n   response to
        other receiver requests.  This mechanism can be very\n   effective for protocol
        convergence in high loss conditions when\n   transmissions of NACKs from other
        receivers (or indicators from the\n   sender) are lost.  Another mechanism
        (particularly applicable when\n   FEC is used) is for the sender to embed
        an indication of impending\n   repair transmissions in current packets sent.
        \ For example, the\n   indication may be as simple as an advertisement of
        the number of FEC\n   packets to be sent for the current applicable coding
        block.\n   Finally, some consideration might be given to using the NACKing\n
        \  history of receivers to bias their selection of NACK backoff timeout\n
        \  intervals.  For example, if a receiver has historically been\n   experiencing
        the greatest degree of loss, it may promote itself to\n   statistically NACK
        sooner than other receivers.  Note this requires\n   correlation over successive
        intervals of time in the loss experienced\n   by a receiver.  Such correlation
        MAY not always be present in\n   multicast networks.  This adjustment of backoff
        timeout selection may\n   require the creation of an \"early NACK\" slot for
        these historical\n   NACKers.  This additional slot in the NACK backoff window
        will result\n   in a longer repair cycle process that may not be desirable
        for some\n   applications.  The resolution of these trade-offs may be dependent\n
        \  upon the protocol's target application set or network.\n   After the random
        backoff timeout has expired, the receiver will make\n   a decision on whether
        to generate a NACK repair request or not (i.e.,\n   it has been suppressed).
        \ The NACK will be suppressed when any of the\n   following conditions has
        occurred:\n   1.  The accumulated state of NACKs heard from other receivers
        (or\n       forwarding of this state by the sender) is equal to or supersedes\n
        \      the repair needs of the local receiver.  Note that the local\n       receiver
        should consider its repair needs only up to the sender\n       transmission
        position recorded at the NACK cycle initiation (when\n       the backoff timer
        was activated).\n   2.  The sender's data content transmission position \"rewinds\"
        to a\n       point ordinally less than that of the lowest sequence position
        of\n       the local receiver's repair needs.  (This detection of sender\n
        \      \"rewind\" indicates the sender has already responded to other\n       receiver
        repair needs of which the local receiver may not have\n       been aware).
        \ This \"rewind\" event can occur any time between 1)\n       when the NACK
        cycle was initiated with the backoff timeout\n       activation and 2) the
        current moment when the backoff timeout has\n       expired to suppress the
        NACK.  Another NACK cycle must be\n       initiated by the receiver when the
        sender's transmission sequence\n       position exceeds the receiver's lowest
        ordinal repair point.\n       Note it is possible that the local receiver
        may have had its\n       repair needs satisfied as a result of the sender's
        response to\n       the repair needs of other receivers and no further NACKing
        is\n       required.\n   If these conditions have not occurred and the receiver
        still has\n   pending repair needs, a NACK message is generated and transmitted.\n
        \  The NACK should consist of an accumulation of repair needs from the\n   receiver's
        lowest ordinal repair point up to the current sender\n   transmission sequence
        position.  A single NACK message should be\n   generated and the NACK message
        content should be truncated if it\n   exceeds the payload size of single protocol
        message.  When such NACK\n   payload limits occur, the NACK content SHOULD
        contain requests for\n   the ordinally lowest repair content needed from the
        sender.\n   Inputs:\n   1.  NACK process initiation decision.\n   2.  Recorded
        sender transmission sequence position.\n   3.  Sender GRTT.\n   4.  Sender
        group size estimate.\n   5.  Application-defined bound on backoff timeout
        period.\n   6.  NACKs from other receivers.\n   7.  Pending repair indication
        from sender (may be forwarded NACKs).\n   8.  Current sender transmission
        sequence position.\n   Outputs:\n   1.  Yes/no decision to generate NACK message
        upon backoff timer\n       expiration.\n"
      title: 3.2.2.  NACK Suppression
    - contents:
      - "3.2.3.  NACK Message Content\n   The content of NACK messages generated by
        reliable multicast\n   receivers will include information detailing their
        current repair\n   needs.  The specific information depends on the use and
        type of FEC\n   in the NACK repair process.  The identification of repair
        needs is\n   dependent upon the data content identification (see Section 3.5\n
        \  below).  At the highest level, the NACK content will identify the\n   sender
        to which the NACK is addressed and the data transport object\n   (or stream)
        within the sender's transmission that needs repair.  For\n   the indicated
        transport entity, the NACK content will then identify\n   the specific FEC
        coding blocks and/or symbols it requires to\n   reconstruct the complete transmitted
        data.  This content may consist\n   of FEC block erasure counts and/or explicit
        indication of missing\n   blocks or symbols (segments) of data and FEC content.
        \ It should also\n   be noted that NACK-based reliable multicast can be effectively\n
        \  instantiated without a requirement for reliable NACK delivery using\n   the
        techniques discussed here.\n"
      - contents:
        - "3.2.3.1.  NACK and FEC Repair Strategies\n   Where FEC-based repair is
          used, the NACK message content will\n   minimally need to identify the coding
          block(s) for which repair is\n   needed and a count of erasures (missing
          packets) for the coding\n   block.  An exact count of erasures implies the
          FEC algorithm is\n   capable of repairing any loss combination within the
          coding block.\n   This count may need to be adjusted for some FEC algorithms.\n
          \  Considering that multiple repair rounds may be required to\n   successfully
          complete repair, an erasure count also implies that the\n   quantity of
          unique FEC parity packets the server has available to\n   transmit is essentially
          unlimited (i.e., the server will always be\n   able to provide new, unique,
          previously unsent parity packets in\n   response to any subsequent repair
          requests for the same coding\n   block).  Alternatively, the sender may
          \"round-robin\" transmit through\n   its available set of FEC symbols for
          a given coding block, and\n   eventually effect repair.  For the most efficient
          repair strategy,\n   the NACK content will need to also explicitly identify
          which symbols\n   (information and/or parity) the receiver requires to successfully\n
          \  reconstruct the content of the coding block.  This will be\n   particularly
          true of small- to medium-size block FEC codes (e.g.,\n   Reed Solomon [FecSchemes])
          that are capable of providing a limited\n   number of parity symbols per
          FEC coding block.\n   When FEC is not used as part of the repair process,
          or the protocol\n   instantiation is required to provide reliability even
          when the sender\n   has transmitted all available parity for a given coding
          block (or the\n   sender's ability to buffer transmission history is exceeded
          by the\n   \"(delay*bandwidth*loss)\" characteristics of the network topology),\n
          \  the NACK content will need to contain explicit coding block and/or\n
          \  segment loss information so that the sender can provide appropriate\n
          \  repair packets and/or data retransmissions.  Explicit loss\n   information
          in NACK content may also potentially serve other\n   purposes.  For example,
          it may be useful for decorrelating loss\n   characteristics among a group
          of receivers to help differentiate\n   candidate congestion control bottlenecks
          among the receiver set.\n   When FEC is used and NACK content is designed
          to contain explicit\n   repair requests, there is a strategy where the receivers
          can NACK for\n   specific content that will help facilitate NACK suppression
          and\n   repair efficiency.  The assumptions for this strategy are that the\n
          \  sender may potentially exhaust its supply of new, unique parity\n   packets
          available for a given coding block and be required to\n   explicitly retransmit
          some data or parity symbols to complete\n   reliable transfer.  Another
          assumption is that an FEC algorithm where\n   any parity packet can fill
          any erasure within the coding block (e.g.,\n   Reed Solomon) is used.  The
          goal of this strategy is to make maximum\n   use of the available parity
          and provide the minimal amount of data\n   and repair transmissions during
          reliable transfer of data content to\n   the group.\n   When systematic
          FEC codes are used, the sender transmits the data\n   content of the coding
          block (and optionally some quantity of parity\n   packets) in its initial
          transmission.  Note that a systematic FEC\n   coding block is considered
          to be logically made up of the contiguous\n   set of source data vectors
          plus parity vectors for the given FEC\n   algorithm used.  For example,
          a systematic coding scheme that\n   provides for 64 data symbols and 32
          parity symbols per coding block\n   would contain FEC symbol identifiers
          in the range of 0 to 95.\n   Receivers then can construct NACK messages
          requesting sufficient\n   content to satisfy their repair needs.  For example,
          if the receiver\n   has three erasures in a given received coding block,
          it will request\n   transmission of the three lowest ordinal parity vectors
          in the coding\n   block.  In our example coding scheme from the previous
          paragraph, the\n   receiver would explicitly request parity symbols 64 to
          66 to fill its\n   three erasures for the coding block.  Note that if the
          receiver's\n   loss for the coding block exceeds the available parity quantity\n
          \  (i.e., greater than 32 missing symbols in our example), the receiver\n
          \  will be required to construct a NACK requesting all (32) of the\n   available
          parity symbols plus some additional portions of its missing\n   data symbols
          in order to reconstruct the block.  If this is done\n   consistently across
          the receiver group, the resulting NACKs will\n   comprise a minimal set
          of sender transmissions to satisfy their\n   repair needs.\n   In summary,
          the rule is to request the lower ordinal portion of the\n   parity content
          for the FEC coding block to satisfy the erasure repair\n   needs on the
          first NACK cycle.  If the available number of parity\n   symbols is insufficient,
          the receiver will also request the subset of\n   ordinally highest missing
          data symbols to cover what the parity\n   symbols will not fill.  Note this
          strategy assumes FEC codes such as\n   Reed-Solomon for which a single parity
          symbol can repair any erased\n   symbol.  This strategy would need minor
          modification to take into\n   account the possibly limited repair capability
          of other FEC types.\n   On subsequent NACK repair cycles where the receiver
          may receive some\n   portion of its previously requested repair content,
          the receiver will\n   use the same strategy, but only NACK for the set of
          parity and/or\n   data symbols it has not yet received.  Optionally, the
          receivers\n   could also provide a count of erasures as a convenience to
          the\n   sender.\n   Other types of FEC schemes may require alteration to
          the NACK and\n   repair strategy described here.  For example, some of the
          large block\n   or expandable FEC codes described in [RFC3453] may be less\n
          \  deterministic with respect to defining optimal repair requests by\n   receivers
          or repair transmission strategies by senders.  For these\n   types of codes,
          it may be sufficient for receivers to NACK with an\n   estimate of the quantity
          of additional FEC symbols required to\n   complete reliable reception and
          for the sender to respond\n   accordingly.  This apparent disadvantage,
          as compared to codes such\n   as Reed Solomon, may be offset by the reduced
          computational\n   requirements and/or ability to support large coding blocks
          for\n   increased repair efficiency that these codes can offer.\n   After
          receipt and accumulation of NACK messages during the\n   aggregation period,
          the sender can begin transmission of fresh\n   (previously untransmitted)
          parity symbols for the coding block based\n   on the highest receiver erasure
          count if it has a sufficient quantity\n   of parity symbols that were not
          previously transmitted.  Otherwise,\n   the sender MUST resort to transmitting
          the explicit set of repair\n   vectors requested.  With this approach, the
          sender needs to maintain\n   very little state on requests it has received
          from the group without\n   need for synchronization of repair requests from
          the group.  Since\n   all receivers use the same consistent algorithm to
          express their\n   explicit repair needs, NACK suppression among receivers
          is simplified\n   over the course of multiple repair cycles.  The receivers
          can simply\n   compare NACKs heard from other receivers against their own
          calculated\n   repair needs to determine whether they should transmit or
          suppress\n   their pending NACK messages.\n"
        title: 3.2.3.1.  NACK and FEC Repair Strategies
      - contents:
        - "3.2.3.2.  NACK Content Format\n   The format of NACK content will depend
          on the protocol's data service\n   model and the format of data content
          identification the protocol\n   uses.  This NACK format also depends upon
          the type of FEC encoding\n   (if any) used.  Figure 2 illustrates a logical,
          hierarchical\n   transmission content identification scheme, denoting that
          the notion\n   of objects (or streams) and/or FEC blocking is optional at
          the\n   protocol instantiation's discretion.  Note that the identification
          of\n   objects is with respect to a given sender.  It is recommended that\n
          \  transport data content identification is done within the context of a\n
          \  sender in a given session.  Since the notion of session \"streams\" and\n
          \  \"blocks\" is optional, the framework degenerates to that of typical\n
          \  transport data segmentation and reassembly in its simplest form.\n       Session_\n
          \              \\_\n                 Sender_\n                        \\_\n
          \                         [Object/Stream(s)]_\n                                             \\_\n
          \                                              [FEC Blocks]_\n                                                            \\_\n
          \                                                             Symbols\n
          \   Figure 2: Reliable Multicast Data Content Identification Hierarchy\n
          \  The format of NACK messages should enable the following:\n   1.  Identification
          of transport data units required to repair the\n       received content,
          whether this is an entire missing object/stream\n       (or range), entire
          FEC coding block(s), or sets of symbols,\n   2.  Simple processing for NACK
          aggregation and suppression,\n   3.  Inclusion of NACKs for multiple objects,
          FEC coding blocks,\n       and/or symbols in a single message, and\n   4.
          \ A reasonably compact format.\n   If the reliable multicast transport object/stream
          is identified with\n   an <objectId> and the FEC symbol being transmitted
          is identified with\n   an <fecPayloadId>, the concatenation of <objectId::fecPayloadId>\n
          \  comprises a basic transport protocol data unit (TPDU) identifier for\n
          \  symbols from a given source.  NACK content can be composed of lists\n
          \  and/or ranges of these TPDU identifiers to build up NACK messages to\n
          \  describe the receiver's repair needs.  If no hierarchical object\n   delineation
          or FEC blocking is used, the TPDU is a simple linear\n   representation
          of the data symbols transmitted by the sender.  When\n   the TPDU represents
          a hierarchy for purposes of object/stream\n   delineation and/or FEC blocking,
          the NACK content unit may require\n   flags to indicate which portion of
          the TPDU is applicable.  For\n   example, if an entire \"object\" (or range
          of objects) is missing in\n   the received data, the receiver will not necessarily
          know the\n   appropriate range of <sourceBlockNumbers> or <encodingSymbolIds>
          for\n   which to request repair and thus requires some mechanism to request\n
          \  repair (or retransmission) of the entire unit represented by an\n   <objectId>.
          \ The same is true if entire FEC coding blocks represented\n   by one or
          a range of <sourceBlockNumbers> have been lost.\n   Inputs:\n   1.  Sender
          identification.\n   2.  Sender data identification.\n   3.  Sender FEC object
          transmission information.\n   4.  Recorded sender transmission sequence
          position.\n   5.  Current sender transmission sequence position.  History
          of repair\n       needs for this sender.\n   Outputs:\n   1.  NACK message
          with repair requests.\n"
        title: 3.2.3.2.  NACK Content Format
      title: 3.2.3.  NACK Message Content
    - contents:
      - "3.2.4.  Sender NACK Processing and Repair Response\n   Upon reception of
        a repair request from a receiver in the group, the\n   sender will initiate
        a repair response procedure.  The sender may\n   wish to delay transmission
        of repair content until it has had\n   sufficient time to accumulate potentially
        multiple NACKs from the\n   receiver set.  This allows the sender to determine
        the most efficient\n   repair strategy for a given transport stream/object
        or FEC coding\n   block.  Depending upon the approach used, some protocols
        may find it\n   beneficial for the sender to provide an indicator of pending
        repair\n   transmissions as part of its current transmitted message content.\n
        \  This can aid some NACK suppression mechanisms.  The amount of time to\n
        \  perform this NACK aggregation should be sufficient to allow for the\n   maximum
        receiver NACK backoff window (\"\"T_maxBackoff\"\" from Section\n   3.2.2)
        and propagation of NACK messages from the receivers to the\n   sender.  Note
        the maximum transmission delay of a message from a\n   receiver to the sender
        may be approximately \"(1*GRTT)\" in the case of\n   very asymmetric network
        topology with respect to transmission delay.\n   Thus, if the maximum receiver
        NACK backoff time is \"T_maxBackoff =\n   K*GRTT\", the sender NACK aggregation
        period should be equal to at\n   least:\n            T_sndrAggregate = T_maxBackoff
        + 1*GRTT = (K+1)*GRTT\n   Immediately after the sender NACK aggregation period,
        the sender will\n   begin transmitting repair content determined from the
        aggregate NACK\n   state and continue with any new transmission.  Also, at
        this time,\n   the sender should observe a \"hold-off\" period where it constrains\n
        \  itself from initiating a new NACK aggregation period to allow\n   propagation
        of the new transmission sequence position due to the\n   repair response to
        the receiver group.  To allow for worst case\n   asymmetry, this \"hold-off\"
        time should be:\n                           T_sndrHoldoff = 1*GRTT\n   Recall
        that the receivers will also employ a \"hold-off\" timeout after\n   generating
        a NACK message to allow time for the sender's response.\n   Given a sender
        \"<T_sndrAggregate>\" plus \"<T_sndrHoldoff>\" time of\n   \"(K+1)*GRTT\",
        the receivers should use hold-off timeouts of:\n        T_rcvrHoldoff = T_sndrAggregate
        + T_sndrHoldoff = (K+2)*GRTT\n   This allows for a worst-case propagation
        time of the receiver's NACK\n   to the sender, the sender's aggregation time,
        and propagation of the\n   sender's response back to the receiver.  Additionally,
        in the case of\n   unicast feedback from the receiver set, it may be useful
        for the\n   sender to forward (via multicast) a representation of its aggregated\n
        \  NACK content to the group to allow for NACK suppression when there is\n
        \  not multicast connectivity among the receiver set.\n   At the expiration
        of the \"<T_sndrAggregate>\" timeout, the sender will\n   begin transmitting
        repair messages according to the accumulated\n   content of NACKs received.
        \ There are some guidelines with regards to\n   FEC-based repair and the ordering
        of the repair response from the\n   sender that can improve reliable multicast
        efficiency:\n   When FEC is used, it is beneficial that the sender transmit\n
        \  previously untransmitted parity content as repair messages whenever\n   possible.
        \ This maximizes the receiving nodes' ability to reconstruct\n   the entire
        transmitted content from their individual subsets of\n   received messages.\n
        \  The transmitted object and/or stream data and repair content should\n   be
        indexed with monotonically increasing sequence numbers (within a\n   reasonably
        large ordinal space).  If the sender observes the\n   discipline of transmitting
        repair for the earliest content (e.g.,\n   ordinally lowest FEC blocks) first,
        the receivers can use a strategy\n   of withholding repair requests for later
        content until the sender\n   once again returns to that point in the object/stream
        transmission\n   sequence.  This can increase overall message efficiency among
        the\n   group and help keep repair cycles relatively synchronized without\n
        \  dependence upon strict time synchronization among the sender and\n   receivers.
        \ This also helps minimize the buffering requirements of\n   receivers and
        senders and reduces redundant transmission of data to\n   the group at large.\n
        \  Inputs:\n   1.  Receiver NACK messages.\n   2.  Group timing information.\n
        \  Outputs:\n   1.  Repair messages (FEC and/or Data content retransmission).\n
        \  2.  Advertisement of current pending repair transmissions when\n       unicast
        receiver feedback is detected.\n"
      title: 3.2.4.  Sender NACK Processing and Repair Response
    title: 3.2.  NACK Repair Process
  - contents:
    - "3.3.  Multicast Receiver Join Policies and Procedures\n   Consideration should
      be given to the policies and procedures by which\n   new receivers join a group
      (perhaps where reliable transmission is\n   already in progress) and begin requesting
      repair.  If receiver joins\n   are unconstrained, the dynamics of group membership
      may impede the\n   application's ability to meet its goals for forward progression
      of\n   data transmission.  Policies that limit the opportunities for\n   receivers
      to begin participating in the NACK process may be used to\n   achieve the desired
      behavior.  For example, it may be beneficial for\n   receivers to attempt reliable
      reception from a newly-heard sender\n   only upon non-repair transmissions of
      data in the first FEC block of\n   an object or logical portion of a stream.
      \ The sender may also\n   implement policies limiting the receivers from which
      it will accept\n   NACK requests, but this may be prohibitive for scalability
      reasons in\n   some situations.  Alternatively, it may be desirable to have
      a looser\n   transport synchronization policy and rely upon session management\n
      \  mechanisms to limit group dynamics that can cause poor performance in\n   some
      types of bulk transfer applications (or for potential\n   interactive reliable
      multicast applications).\n   Inputs:\n   1.  Current object/stream data/repair
      content and sequencing\n       identifiers from sender transmissions.\n   Outputs:\n
      \  1.  Receiver yes/no decision to begin receiving and NACKing for\n       reliable
      reception of data.\n"
    title: 3.3.  Multicast Receiver Join Policies and Procedures
  - contents:
    - "3.4.  Node (Member) Identification\n   In a NACK-based reliable multicast protocol
      (or other multicast\n   protocols) where there is the potential for multiple
      sources of data,\n   it is necessary to provide some mechanism to uniquely identify
      the\n   sources (and possibly some or all receivers) within the group.\n   Receivers
      that send NACK messages to the group will need to identify\n   the sender to
      which the NACK is intended.  Identity based on arriving\n   packet source addresses
      is insufficient for several reasons.  These\n   reasons include routing changes
      for hosts with multiple interfaces\n   that result in different packet source
      addresses for a given host\n   over time, network address translation (NAT)
      or firewall devices, or\n   other transport/network bridging approaches.  As
      a result, some type\n   of unique source identifier <sourceId> field SHOULD
      be present in\n   packets transmitted by reliable multicast session members.\n"
    title: 3.4.  Node (Member) Identification
  - contents:
    - "3.5.  Data Content Identification\n   The data and repair content transmitted
      by a NACK-based reliable\n   multicast sender requires some form of identification
      in the protocol\n   header fields.  This identification is required to facilitate
      the\n   reliable NACK-oriented repair process.  These identifiers will also\n
      \  be used in NACK messages generated.  This building block document\n   assumes
      two very general types of data that may comprise bulk\n   transfer session content.
      \ One type is static, discrete objects of\n   finite size and the other is continuous
      non-finite streams.  A given\n   application may wish to reliably multicast
      data content using either\n   one or both of these paradigms.  While it may
      be possible for some\n   applications to further generalize this model and provide
      mechanisms\n   to encapsulate static objects as content embedded within a stream,\n
      \  there are advantages in many applications to provide distinct support\n   for
      static bulk objects and messages with the context of a reliable\n   multicast
      session.  These applications may include content caching\n   servers, file transfer,
      or collaborative tools with bulk content.\n   Applications with requirements
      for these static object types can then\n   take advantage of transport layer
      mechanisms (i.e., segmentation/\n   reassembly, caching, integrated forward
      error correction coding,\n   etc.) rather than being required to provide their
      own mechanisms for\n   these functions at the application layer.\n   As noted,
      some applications may alternatively desire to transmit bulk\n   content in the
      form of one or more streams of non-finite size.\n   Example streams include
      continuous quasi-real-time message broadcasts\n   (e.g., stock ticker) or some
      content types that are part of\n   collaborative tools or other applications.
      \ And, as indicated above,\n   some applications may wish to encapsulate other
      bulk content (e.g.,\n   files) into one or more streams within a multicast session.\n
      \  The components described within this building block document are\n   envisioned
      to be applicable to both of these models with the\n   potential for a mix of
      both types within a single multicast session.\n   To support this requirement,
      the normal data content identification\n   should include a field to uniquely
      identify the object or stream\n   (e.g., <objectId>) within some reasonable
      temporal or ordinal\n   interval.  Note that it is not expected that this data
      content\n   identification will be globally unique.  It is expected that the\n
      \  object/stream identifier will be unique with respect to a given\n   sender
      within the reliable multicast session and during the time that\n   sender is
      supporting a specific transport instance of that object or\n   stream.\n   Since
      \"bulk\" object/stream content usually requires segmentation,\n   some form
      of segment identification must also be provided.  This\n   segment identifier
      will be relative to any object or stream\n   identifier that has been provided.
      \ Thus, in some cases, NACK-based\n   reliable multicast protocol instantiations
      may be able to receive\n   transmissions and request repair for multiple streams
      and one or more\n   sets of static objects in parallel.  For protocol instantiations\n
      \  employing FEC, the segment identification portion of the data content\n   identifier
      may consist of a logical concatenation of a coding block\n   identifier <sourceBlockNumber>
      and an identifier for the specific\n   data or parity symbol <encodingSymbolId>
      of the code block.  The FEC\n   Basic Schemes building block [FECSchemes] and
      descriptions of\n   additional FEC schemes that may be documented later provide
      a\n   standard message format for identifying FEC transmission content.\n   NACK-based
      reliable multicast protocol instantiations using FEC\n   SHOULD follow such
      guidelines.\n   Additionally, flags to determine the usage of the content identifier\n
      \  fields (e.g., stream vs. object) may be applicable.  Flags may also\n   serve
      other purposes in data content identification.  It is expected\n   that any
      flags defined will be dependent upon individual protocol\n   instantiations.\n
      \  In summary, the following data content identification fields may be\n   required
      for NACK-based reliable multicast protocol data content\n   messages:\n   1.
      \ Source node identifier (<sourceId>).\n   2.  Object/Stream identifier (<objectId>),
      if applicable.\n   3.  FEC Block identifier (<sourceBlockNumber>), if applicable.\n
      \  4.  FEC Symbol identifier (<encodingSymbolId>).\n   5.  Flags to differentiate
      interpretation of identifier fields or\n       identifier structure that implicitly
      indicates usage.\n   6.  Additional FEC transmission content fields per FEC
      Building\n       Block.\n   These fields have been identified because any generated
      NACK messages\n   will use these identifiers in requesting repair or retransmission
      of\n   data.\n"
    title: 3.5.  Data Content Identification
  - contents:
    - "3.6.  Forward Error Correction (FEC)\n   Multiple forward error correction
      (FEC) approaches using erasure\n   coding techniques have been identified that
      can provide great\n   performance enhancements to the repair process of NACK-oriented
      and\n   other reliable multicast protocols [FecBroadcast], [RmFec],\n   [RFC3453].
      \ NACK-based reliable multicast protocols can reap\n   additional benefits since
      FEC-based repair does not generally require\n   explicit knowledge of repair
      content within the bounds of its coding\n   block size (in symbols).  In NACK-based
      reliable multicast, parity\n   repair packets generated will generally be transmitted
      only in\n   response to NACK repair requests from receiving nodes.  However,\n
      \  there are benefits in some network environments for transmitting some\n   predetermined
      quantity of FEC repair packets multiplexed with the\n   regular data symbol
      transmissions [FecHybrid].  This can reduce the\n   amount of NACK traffic generated
      with relatively little overhead cost\n   when group sizes are very large or
      the network connectivity has a\n   large \"delay*bandwidth\" product with some
      nominal level of expected\n   packet loss.  While the application of FEC is
      not unique to NACK-\n   based reliable multicast, these sorts of requirements
      may dictate the\n   types of algorithms and protocol approaches that are applicable.\n
      \  A specific issue related to the use of FEC with NACK-based reliable\n   multicast
      is the mechanism used to identify the portion(s) of\n   transmitted data content
      to which specific FEC packets are\n   applicable.  It is expected that FEC algorithms
      will be based on\n   generating a set of parity repair packets for a corresponding
      block\n   of transmitted data packets.  Since data content packets are uniquely\n
      \  identified by the concatenation of <sourceId::objectId::\n   sourceBlockNumber::encodingSymbolId>
      during transport, it is expected\n   that FEC packets will be identified in
      a similar manner.  The FEC\n   Building Block document [RFC5052] provides detailed
      recommendations\n   concerning application of FEC and standard formats for related\n
      \  reliable multicast protocol messages.\n"
    title: 3.6.  Forward Error Correction (FEC)
  - contents:
    - "3.7.  Round-Trip Timing Collection\n   The measurement of packet propagation
      round-trip time (RTT) among\n   members of the group is required to support
      timer-based NACK\n   suppression algorithms, timing of sender commands or certain
      repair\n   functions, and congestion control operation.  The nature of the\n
      \  round-trip information collected is dependent upon the type of\n   interaction
      among the members of the group.  In the case of \"one-to-\n   many\" transmission,
      it may be that only the sender requires RTT\n   knowledge of the GRTT and/or
      RTT knowledge of only a portion of the\n   group.  Here, the GRTT information
      might be collected in a reasonably\n   scalable manner.  For congestion control
      operation, it is possible\n   that each receiver in the group may need knowledge
      of its individual\n   RTT.  In this case, an alternative RTT collection scheme
      may be\n   utilized where receivers collect individual RTT measurements with\n
      \  respect to the sender(s) and advertise them to the group or\n   sender(s).
      \ Where it is likely that exchange of reliable multicast\n   data will occur
      among the group on a \"many-to-many\" basis, there are\n   alternative measurement
      techniques that might be employed for\n   increased efficiency [DelayEstimation].
      \ In some cases, there might\n   be absolute time synchronization available
      among the participating\n   hosts that may simplify RTT measurement.  There
      are trade-offs in\n   multicast congestion control design that require further\n
      \  consideration before a universal recommendation on RTT (or GRTT)\n   measurement
      can be specified.  Regardless of how the RTT information\n   is collected (and
      more specifically GRTT) with respect to congestion\n   control or other requirements,
      the sender will need to advertise its\n   current GRTT estimate to the group
      for various NACK timeouts used by\n   receivers.\n"
    - contents:
      - "3.7.1.  One-to-Many Sender GRTT Measurement\n   The goal of this form of
        RTT measurement is for the sender to\n   estimate the GRTT among the receivers
        who are actively participating\n   in NACK-based reliable multicast operation.
        \ The set of receivers\n   participating in this process may be the entire
        group or some subset\n   of the group determined from another mechanism within
        the protocol\n   instantiation.  An approach to collect this GRTT information
        follows.\n   The sender periodically polls the group with a message (independent\n
        \  or \"piggy-backed\" with other transmissions) containing a \"<sendTime>\"\n
        \  timestamp relative to an internal clock at the sender.  Upon\n   reception
        of this message, the receivers will record this\n   \"<sendTime>\" timestamp
        and the time (referenced to their own clocks)\n   at which it was received
        \"<recvTime>\".  When the receiver provides\n   feedback to the sender (either
        explicitly or as part of other\n   feedback messages depending upon protocol
        instantiation\n   specification), it will construct a \"response\" using the
        formula:\n             grttResponse = sendTime + (currentTime - recvTime)\n
        \  where the \"<sendTime>\" is the timestamp from the last probe message\n
        \  received from the source and the (\"<currentTime> - <recvTime>\") is\n
        \  the amount of time differential since that request was received until\n
        \  the receiver generated the response.\n   The sender processes each receiver
        response by calculating a current\n   RTT measurement for the receiver from
        whom the response was received\n   using the following formula:\n                   RTT_rcvr
        = currentTime - grttResponse\n   During each periodic \"GRTT\" probing interval,
        the source keeps the\n   peak round-trip timing measurement (\"RTT_peak\")
        from the set of\n   responses it has received.  A conservative estimate of
        \"GRTT\" is kept\n   to maximize the efficiency of redundant NACK suppression
        and repair\n   aggregation.  The update to the source's ongoing estimate of
        \"GRTT\"\n   is done observing the following rules:\n   1.  If a receiver's
        response round-trip time (\"RTT_rcvr\") is greater\n       than the current
        \"GRTT\" estimate, the \"GRTT\" is immediately\n       updated to this new
        peak value:\n                              GRTT = RTT_rcvr\n   2.  At the
        end of the response collection period (i.e., the GRTT\n       probe interval),
        if the recorded \"peak\" response (\"RTT_peak\") is\n       less than the
        current GRTT estimate, the GRTT is updated to:\n                       GRTT
        = MAX(0.9*GRTT, RTT_peak)\n   3.  If no feedback is received, the sender \"GRTT\"
        estimate remains\n       unchanged.\n   4.  At the end of the response collection
        period, the peak tracking\n       value (\"RTT_peak\") is reset to ZERO for
        subsequent peak\n       detection.\n   The GRTT collection period (i.e., period
        of probe transmission) could\n   be fixed at a value on the order of that
        expected for group\n   membership and/or network topology dynamics.  For robustness,
        more\n   rapid probing could be used at protocol startup before settling to
        a\n   less frequent, steady-state interval.  Optionally, an algorithm may\n
        \  be developed to adjust the GRTT collection period dynamically in\n   response
        to the current estimate of GRTT (or variations in it) and to\n   an estimation
        of packet loss.  The overhead of probing messages could\n   then be reduced
        when the GRTT estimate is stable and unchanging, but\n   be adjusted to track
        more dynamically during periods of variation\n   with correspondingly shorter
        GRTT collection periods.  GRTT\n   collection MAY also be coupled with collection
        of other information\n   for congestion control purposes.\n   In summary,
        although NACK repair cycle timeouts are based on GRTT, it\n   should be noted
        that convergent operation of the protocol does not\n   depend upon highly
        accurate GRTT estimation.  The current mechanism\n   has proved sufficient
        in simulations and in the environments where\n   NACK-based reliable multicast
        protocols have been deployed to date.\n   The estimate provided by the given
        algorithm tracks the peak envelope\n   of actual GRTT (including operating
        system effect as well as network\n   delays) even in relatively high loss
        connectivity.  The steady-state\n   probing/update interval may potentially
        be varied to accommodate\n   different levels of expected network dynamics
        in different\n   environments.\n"
      title: 3.7.1.  One-to-Many Sender GRTT Measurement
    - contents:
      - "3.7.2.  One-to-Many Receiver RTT Measurement\n   In this approach, receivers
        send messages with timestamps to the\n   sender.  To control the volume of
        these receiver-generated messages,\n   a suppression mechanism similar to
        that described for NACK\n   suppression my be used.  The \"age\" of receivers'
        RTT measurement\n   should be kept by receivers and used as a metric in competing
        for\n   feedback opportunities in the suppression scheme.  For example,\n
        \  receiver who have not made any RTT measurement or whose RTT\n   measurement
        has aged most should have precedence over other\n   receivers.  In turn, the
        sender may have limited capacity to provide\n   an \"echo\" of the receiver
        timestamps back to the group, and it could\n   use this RTT \"age\" metric
        to determine which receivers get\n   precedence.  The sender can determine
        the \"GRTT\" as described in\n   3.7.1 if it provides sender timestamps to
        the group.  Alternatively,\n   receivers who note their RTT is greater than
        the sender GRTT can\n   compete in the feedback opportunity/suppression scheme
        to provide the\n   sender and group with this information.\n"
      title: 3.7.2.  One-to-Many Receiver RTT Measurement
    - contents:
      - "3.7.3.  Many-to-Many RTT Measurement\n   For reliable multicast sessions
        that involve multiple senders, it may\n   be useful to have RTT measurements
        occur on a true \"many-to-many\"\n   basis rather than have each sender independently
        tracking RTT.  Some\n   protocol efficiency can be gained when receivers can
        infer an\n   approximation of their RTT with respect to a sender based on
        RTT\n   information they have on another sender and that other sender's RTT\n
        \  with respect to the new sender of interest.  For example, for\n   receiver
        \"a\" and senders \"b\" and \"c\", it is likely that:\n                    RTT(a<->b)
        <= RTT(a<->c)) + RTT(b<->c)\n   Further refinement of this estimate can be
        conducted if RTT\n   information is available to a node concerning its own
        RTT with\n   respect to a small subset of other group members and if information\n
        \  concerning RTT among those other group members is learned by the node\n
        \  during protocol operation.\n"
      title: 3.7.3.  Many-to-Many RTT Measurement
    - contents:
      - "3.7.4.  Sender GRTT Advertisement\n   To facilitate deterministic protocol
        operation, the sender should\n   robustly advertise its current estimation
        of \"GRTT\" to the receiver\n   set.  Common, robust knowledge of the sender's
        current operating GRTT\n   estimate among the group will allow the protocol
        to progress in its\n   most efficient manner.  The sender's GRTT estimate
        can be robustly\n   advertised to the group by simply embedding the estimate
        into all\n   pertinent messages transmitted by the sender.  The overhead of
        this\n   can be made quite small by quantizing (compressing) the GRTT estimate\n
        \  to a single byte of information.  The following C-language functions\n
        \  allow this to be done over a wide range (\"RTT_MIN\" through \"RTT_MAX\")\n
        \  of GRTT values while maintaining a greater range of precision for\n   small
        values and less precision for large values.  Values of 1.0e-06\n   seconds
        and 1000 seconds are RECOMMENDED for \"RTT_MIN\" and \"RTT_MAX\"\n   respectively.
        \ NACK-based reliable multicast applications may wish to\n   place an additional,
        smaller upper limit on the GRTT advertised by\n   senders to meet application
        data delivery latency constraints at the\n   expense of greater feedback volume
        in some network environments.\n       unsigned char QuantizeGrtt(double grtt)\n
        \      {\n           if (grtt > RTT_MAX)\n               grtt = RTT_MAX;\n
        \          else if (grtt < RTT_MIN)\n               grtt = RTT_MIN;\n           if
        (grtt < (33*RTT_MIN))\n               return ((unsigned char)(grtt / RTT_MIN)
        - 1);\n           else\n               return ((unsigned char)(ceil(255.0
        -\n                                       (13.0 * log(RTT_MAX/grtt)))));\n
        \      }\n       double UnquantizeRtt(unsigned char qrtt)\n       {\n           return
        ((qrtt <= 31) ?\n                   (((double)(qrtt+1))*(double)RTT_MIN) :\n
        \                  (RTT_MAX/exp(((double)(255-qrtt))/(double)13.0)));\n       }\n
        \  Note that this function is useful for quantizing GRTT times in the\n   range
        of 1 microsecond to 1000 seconds.  Of course, NACK-based\n   reliable multicast
        protocol implementations may wish to further\n   constrain advertised GRTT
        estimates (e.g., limit the maximum value)\n   for practical reasons.\n"
      title: 3.7.4.  Sender GRTT Advertisement
    title: 3.7.  Round-Trip Timing Collection
  - contents:
    - "3.8.  Group Size Determination/Estimation\n   When NACK-based reliable multicast
      protocol operation includes\n   mechanisms that excite feedback from the group
      at large (e.g.,\n   congestion control), it may be possible to roughly estimate
      the group\n   size based on the number of feedback messages received with respect\n
      \  to the distribution of the probabilistic suppression mechanism used.\n   Note
      the timer-based suppression mechanism described in this document\n   does not
      require a very accurate estimate of group size to perform\n   adequately.  Thus,
      a rough estimate, particularly if conservatively\n   managed, may suffice.  Group
      size may also be determined\n   administratively.  In absence of any group size
      determination\n   mechanism, a default group size value of 10,000 is RECOMMENDED
      for\n   reasonable management of feedback given the scalability of expected\n
      \  NACK-based reliable multicast usage.  This conservative estimate\n   (over-estimate)
      of group size in the algorithms described above will\n   result in some added
      latency to the NACK repair process if the actual\n   group size is smaller but
      with a guarantee of feedback implosion\n   protection.  The study of the timer-based
      feedback suppression\n   mechanism described in [McastFeedback] and [NormFeedback]
      showed that\n   the group size estimate need only be with an order-of-magnitude
      to\n   provide effective suppression performance.\n"
    title: 3.8.  Group Size Determination/Estimation
  - contents:
    - "3.9.  Congestion Control Operation\n   Congestion control that fairly shares
      available network capacity with\n   other reliable multicast and TCP instantiations
      is REQUIRED for\n   general Internet operation.  The TCP-Friendly Multicast
      Congestion\n   Control (TFMCC) [TfmccPaper] or Pragmatic General Multicast\n
      \  Congestion Control (PGMCC) [PgmccPaper] techniques can be applied to\n   NACK-based
      reliable multicast operation to meet this requirement.\n   The former technique
      has been further documented in [RFC4654] and has\n   been successfully applied
      in the NACK-Oriented Reliable Multicast\n   Protocol (NORM) [RFC3940].\n"
    title: 3.9.  Congestion Control Operation
  - contents:
    - "3.10.  Intermediate System Assistance\n   NACK-based multicast protocols may
      benefit from general purpose\n   intermediate system assistance.  In particular,
      additional NACK\n   suppression where intermediate systems can aggregate NACK
      content (or\n   filter duplicate NACK content) from receivers as it is relayed
      toward\n   the sender could enhance NORM group size scalability.  For NACK-based\n
      \  reliable multicast protocols using FEC, it is possible that\n   intermediate
      systems may be able to filter FEC repair messages to\n   provide an intelligent
      \"subcast\" of repair content to different legs\n   of the multicast topology
      depending on the repair needs learned from\n   previous receiver NACKs.  Similarly,
      intermediate systems could\n   monitor receiver NACKs and provide repair transmissions
      on-demand in\n   response if sufficient state on the content being transmitted
      was\n   being maintained.  This can reduce the latency and volume of repair\n
      \  transmissions when the intermediate system is associated with a\n   network
      link that is particularly problematic with respect to packet\n   loss.  These
      types of assist functions would require intermediate\n   system interpretation
      of transport data unit content identifiers and\n   flags.  NACK-based protocol
      designs should consider the potential for\n   intermediate system assistance
      in the specification of protocol\n   messages and operations.  It is likely
      that intermediate systems\n   assistance will be more pragmatic if message parsing
      requirements are\n   modest and if the amount of state an intermediate system
      is required\n   to maintain is relatively small.\n"
    title: 3.10.  Intermediate System Assistance
  title: 3.  Functionality
- contents:
  - "4.  NACK-Based Reliable Multicast Applicability\n   The Multicast NACK building
    block applies to protocols wishing to\n   employ negative acknowledgement to achieve
    reliable data transfer.\n   Properly designed NACK-based reliable multicast protocols
    offer\n   scalability advantages for applications and/or network topologies\n
    \  where, for various reasons, it is prohibitive to construct a higher\n   order
    delivery infrastructure above the basic Layer 3 IP multicast\n   service (e.g.,
    unicast or hybrid unicast/multicast data distribution\n   trees).  Additionally,
    the multicast scalability property of NACK-\n   based protocols [RmComparison],
    [RmClasses] is applicable where broad\n   \"fan-out\" is expected for a single
    network hop (e.g., cable-TV data\n   delivery, satellite, or other broadcast communication
    services).\n   Furthermore, the simplicity of a protocol based on \"flat\" group-wide\n
    \  multicast distribution may offer advantages for a broad range of\n   distributed
    services or dynamic networks and applications.  NACK-\n   based reliable multicast
    protocols can make use of reciprocal (among\n   senders and receivers) multicast
    communication under the any-source\n   multicast (ASM) model defined in RFC 1112
    [RFC1112], and are capable\n   of scalable operation in asymmetric topologies,
    such as source-\n   specific multicast (SSM) [RFC4607], where there may only be
    unicast\n   routing service from the receivers to the sender(s).\n   NACK-based
    reliable multicast protocol operation is compatible with\n   transport layer forward
    error correction coding techniques as\n   described in [RFC3453] and congestion
    control mechanisms such as\n   those described in [TfmccPaper] and [PgmccPaper].
    \ A principal\n   limitation of NACK-based reliable multicast operation involves
    group\n   size scalability when network capacity for receiver feedback is very\n
    \  limited.  It is possible that, with proper protocol design, the\n   intermediate
    system assistance techniques mentioned in Section 2.4\n   and described further
    in Section 3.10 can allow NACK-based approaches\n   to scale to larger group sizes.
    \ NACK-based reliable multicast\n   operation is also governed by implementation
    buffering constraints.\n   Buffering greater than that required for typical point-to-point\n
    \  reliable transport (e.g., TCP) is recommended to allow for disparity\n   in
    the receiver group connectivity and to allow for the feedback\n   delays required
    to attain group size scalability.\n   Prior experimental work included various
    protocol instantiations that\n   implemented some of the concepts described in
    this building block\n   document.  This includes the Pragmatic General Multicast
    (PGM)\n   protocol described in [RFC3208] as well as others that were\n   documented
    or deployed outside of IETF activities.  While the PGM\n   protocol specification
    and some other approaches encompassed many of\n   the goals of bulk data delivery
    as described here, this NACK-based\n   building block provides a more generalized
    framework so that\n   different application needs can be met by different protocol\n
    \  instantiation variants.  The NACK-based building block approach\n   described
    here includes compatibility with the other protocol\n   mechanisms including FEC
    and congestion control that are described in\n   other IETF reliable multicast
    building block documents.  The NACK\n   repair process described in this document
    can provide performance\n   advantages compared to PGM when both are deployed
    on a pure end-to-\n   end basis without intermediate system assistance.  The round-trip\n
    \  timing estimation described here and its use in the NACK repair\n   process
    allow protocol operation to more automatically adapt to\n   different network
    environments or operate within environments where\n   connectivity is dynamic.
    \ Use of the FEC payload identification\n   techniques described in the FEC building
    block [RFC5052] and specific\n   FEC instantiations allow protocol instantiations
    more flexibility as\n   FEC techniques evolve than the specific sequence number
    data\n   identification scheme described in the PGM specification.  Similar\n
    \  flexibility is expected if protocol instantiations are designed to\n   modularly
    invoke (at design time, if not run-time) the appropriate\n   congestion control
    building block for different application or\n   deployment purposes.\n"
  title: 4.  NACK-Based Reliable Multicast Applicability
- contents:
  - "5.  Security Considerations\n   NACK-based reliable multicast protocols are expected
    to be subject to\n   the same security vulnerabilities as other IP and IP multicast\n
    \  protocols.  However, unlike point-to-point (unicast) transport\n   protocols,
    it is possible that one badly behaving participant can\n   impact the transport
    service experience of others in the group.  For\n   example, a malicious receiver
    node could intentionally transmit NACK\n   messages to cause the sender(s) to
    unnecessarily transmit repairs\n   instead of making forward progress with reliable
    transfer.  Also,\n   group-wise messaging to support congestion control or other
    aspects\n   of protocol operation may be subject to similar vulnerabilities.\n
    \  Thus, it is highly RECOMMENDED that security techniques such as\n   authentication
    and data integrity checks be applied for NACK-based\n   reliable multicast deployments.
    \ Protocol instantiations using this\n   building block MUST identify approaches
    to security that can be used\n   to address these and other security considerations.\n
    \  NACK-based reliable multicast is compatible with IP security (IPsec)\n   authentication
    mechanisms [RFC4301] that are RECOMMENDED for\n   protection against session intrusion
    and denial of service attacks.\n   A particular threat for NACK-based protocols
    is that of NACK replay\n   attacks, which could prevent a multicast sender from
    making forward\n   progress in transmission.  Any standard IPsec mechanisms that
    can\n   provide protection against such replay attacks are RECOMMENDED for\n   use.
    \ The IETF Multicast Security (MSEC) Working Group has developed\n   a set of
    recommendations in its \"Multicast Extensions to the Security\n   Architecture
    for the Internet Protocol\" [IpsecExtensions] that can be\n   applied to appropriately
    extend IPsec mechanisms to multicast\n   operation.  An appendix of this document
    specifically addresses the\n   NACK-Oriented Reliable Multicast protocol service
    model.  As complete\n   support for IPsec multicast operation may potentially
    follow reliable\n   multicast deployment, NACK-based reliable multicast protocol\n
    \  instantiations SHOULD consider providing support for their own NACK\n   replay
    attack protection when network layer mechanisms are not\n   available.  This MAY
    be necessary when IPsec implementations are used\n   that do not provide multicast
    replay attack protection when multiple\n   sources are present.\n   For NACK-based
    multicast deployments with large receiver groups using\n   IPsec, approaches might
    be developed that use shared, common keys for\n   receiver-originated protocol
    messages to maintain a practical number\n   of IPsec Security Associations (SAs).
    \ However, such group-based\n   authentication may not be sufficient unless the
    receiver population\n   can be completely trusted.  Additionally, this can make\n
    \  identification of badly behaving (although authenticated) receiver\n   nodes
    problematic as such nodes could potentially masquerade as other\n   receivers
    in the group.  In deployments such as this, one SHOULD\n   consider use of source-specific
    multicast (SSM) instead of any-source\n   multicast (ASM) models of multicast
    operation.  SSM operation can\n   simplify security challenges in a couple of
    ways:\n   1.  A NACK-based protocol supporting SSM operation can eliminate\n       direct
    receiver-to-receiver signaling.  This dramatically reduces\n       the number
    of security associations that need to be established.\n   2.  The SSM sender(s)
    can provide a centralized management point for\n       secure group operation
    for its respective data flow as the sender\n       alone is required to conduct
    individual host authentication for\n       each receiver when group-based authentication
    does not suffice or\n       is not pragmatic to deploy.\n   When individual host
    authentication is required, then it is possible\n   receivers could use a digital
    signature on the IPsec Encapsulating\n   Security Protocol (ESP) payload as described
    in [RFC4359].  Either an\n   identity-based signature system or a group-specific
    public key\n   infrastructure could avoid per-receiver state at the sender(s).\n
    \  Additionally, implementations MUST also support policies to limit the\n   impact
    of extremely or exceptionally poor-performing (due to bad\n   behavior or otherwise)
    receivers upon overall group operation if this\n   is acceptable for the relevant
    application.\n   As described in Section 3.4, deployment of NACK-based reliable\n
    \  multicast in some network environments may require identification of\n   group
    members beyond that of IP addressing.  If protocol-specific\n   security mechanisms
    are developed, then it is RECOMMENDED that\n   protocol group member identifiers
    are used as selectors (as defined\n   in [RFC4301]) for the applicable security
    associations.  When IPsec\n   is used, it is RECOMMENDED that the protocol implementation
    verify\n   that the source IP addresses of received packets are valid for the\n
    \  given protocol source identifier in addition to usual IPsec\n   authentication.
    \ This would prevent a badly behaving (although\n   authorized) member from spoofing
    messages from other legitimate\n   members, provided that individual host authentication
    is supported.\n   The MSEC Working Group has also developed automated group keying\n
    \  solutions that are applicable to NACK-based reliable multicast\n   security.
    \ For example, to support IPsec or other security\n   mechanisms, the Group Secure
    Association Key Management Protocol\n   [RFC4535] MAY be used for automated group
    key management.  The\n   technique it identifies for \"Group Establishment for
    Receive-Only\n   Members\" may be application NACK-based reliable multicast SSM\n
    \  operation.\n"
  title: 5.  Security Considerations
- contents:
  - "6.  Changes from RFC 3941\n   This section lists the changes between the Experimental
    version of\n   this specification, [RFC3941], and this version:\n   1.  Change
    of title to avoid confusion with NORM Protocol\n       specification,\n   2.  Updated
    references to related, updated RMT Building Block\n       documents, and\n   3.
    \ More detailed security considerations.\n"
  title: 6.  Changes from RFC 3941
- contents:
  - "7.  Acknowledgements\n   (and these are not Negative)\n   The authors would like
    to thank George Gross, Rick Jones, and Joerg\n   Widmer for their valuable comments
    on this document.  The authors\n   would also like to thank the RMT working group
    chairs, Roger Kermode\n   and Lorenzo Vicisano, for their support in development
    of this\n   specification, and Sally Floyd for her early inputs into this\n   document.\n"
  title: 7.  Acknowledgements
- contents:
  - '8.  References

    '
  - contents:
    - "8.1.  Normative References\n   [RFC1112]             Deering, S., \"Host extensions
      for IP\n                         multicasting\", STD 5, RFC 1112, August 1989.\n
      \  [RFC2119]             Bradner, S., \"Key words for use in RFCs to\n                         Indicate
      Requirement Levels\", BCP 14, RFC 2119,\n                         March 1997.\n
      \  [RFC4607]             Holbrook, H. and B. Cain, \"Source-Specific\n                         Multicast
      for IP\", RFC 4607, August 2006.\n"
    title: 8.1.  Normative References
  - contents:
    - "8.2.  Informative References\n   [ArchConsiderations]  Clark, D. and D. Tennenhouse,
      \"Architectural\n                         Considerations for a New Generation
      of\n                         Protocols\", Proc. ACM SIGCOMM, pp. 201-208,\n
      \                        September 1990.\n   [DelayEstimation]     Ozdemir,
      V., Muthukrishnan, S., and I. Rhee,\n                         \"Scalable, Low-Overhead
      Network Delay\n                         Estimation\", NCSU/AT&T White Paper,\n
      \                        February 1999.\n   [FECSchemes]          Watson, M.,
      \"Basic Forward Error Correction\n                         (FEC) Schemes\",
      Work in Progress, July 2008.\n   [FecBroadcast]        Metzner, J., \"An Improved
      Broadcast\n                         Retransmission Protocol\", IEEE Transactions
      on\n                         Communications Vol. Com-32, No. 6, June 1984.\n
      \  [FecHybrid]           Gossink, D. and J. Macker, \"Reliable Multicast\n                         and
      Integrated Parity Retransmission with\n                         Channel Estimation\",
      IEEE Globecomm 1998, 1998.\n   [FecSchemes]          Lacan, J., Roca, V., Peltotalo,
      J., and S.\n                         Peltotalo, \"Reed-Solomon Forward Error\n
      \                        Correction (FEC) Schemes\", Work in Progress,\n                         November
      2007.\n   [IpsecExtensions]     Weis, B., Gross, G., and D. Ignjatic,\n                         \"Multicast
      Extensions to the Security\n                         Architecture for the Internet
      Protocol\", Work\n                         in Progress, June 2008.\n   [McastFeedback]
      \      Nonnenmacher, J. and E. Biersack, \"Optimal\n                         Multicast
      Feedback\", IEEE Infocom p. 964,\n                         March/April 1998.\n
      \  [NormFeedback]        Adamson, B. and J. Macker, \"Quantitative\n                         Prediction
      of NACK-Oriented Reliable Multicast\n                         (NORM) Feedback\",
      IEEE MILCOM 2002,\n                         October 2002.\n   [PgmccPaper]          Rizzo,
      L., \"pgmcc: A TCP-Friendly Single-Rate\n                         Multicast
      Congestion Control Scheme\", ACM\n                         SIGCOMM 2000, August
      2000.\n   [RFC2357]             Mankin, A., Romanov, A., Bradner, S., and V.\n
      \                        Paxson, \"IETF Criteria for Evaluating Reliable\n                         Multicast
      Transport and Application Protocols\",\n                         RFC 2357, June
      1998.\n   [RFC3208]             Speakman, T., Crowcroft, J., Gemmell, J.,\n
      \                        Farinacci, D., Lin, S., Leshchiner, D., Luby,\n                         M.,
      Montgomery, T., Rizzo, L., Tweedly, A.,\n                         Bhaskar, N.,
      Edmonstone, R., Sumanasekera, R.,\n                         and L. Vicisano,
      \"PGM Reliable Transport\n                         Protocol Specification\",
      RFC 3208,\n                         December 2001.\n   [RFC3269]             Kermode,
      R. and L. Vicisano, \"Author Guidelines\n                         for Reliable
      Multicast Transport (RMT) Building\n                         Blocks and Protocol
      Instantiation documents\",\n                         RFC 3269, April 2002.\n
      \  [RFC3453]             Luby, M., Vicisano, L., Gemmell, J., Rizzo, L.,\n                         Handley,
      M., and J. Crowcroft, \"The Use of\n                         Forward Error Correction
      (FEC) in Reliable\n                         Multicast\", RFC 3453, December
      2002.\n   [RFC3940]             Adamson, B., Bormann, C., Handley, M., and J.\n
      \                        Macker, \"Negative-acknowledgment (NACK)-\n                         Oriented
      Reliable Multicast (NORM) Protocol\",\n                         RFC 3940, November
      2004.\n   [RFC3941]             Adamson, B., Bormann, C., Handley, M., and J.\n
      \                        Macker, \"Negative-Acknowledgment (NACK)-\n                         Oriented
      Reliable Multicast (NORM) Building\n                         Blocks\", RFC 3941,
      November 2004.\n   [RFC4301]             Kent, S. and K. Seo, \"Security Architecture
      for\n                         the Internet Protocol\", RFC 4301,\n                         December
      2005.\n   [RFC4359]             Weis, B., \"The Use of RSA/SHA-1 Signatures\n
      \                        within Encapsulating Security Payload (ESP) and\n                         Authentication
      Header (AH)\", RFC 4359,\n                         January 2006.\n   [RFC4535]
      \            Harney, H., Meth, U., Colegrove, A., and G.\n                         Gross,
      \"GSAKMP: Group Secure Association Key\n                         Management
      Protocol\", RFC 4535, June 2006.\n   [RFC4654]             Widmer, J. and M.
      Handley, \"TCP-Friendly\n                         Multicast Congestion Control
      (TFMCC): Protocol\n                         Specification\", RFC 4654, August
      2006.\n   [RFC5052]             Watson, M., Luby, M., and L. Vicisano, \"Forward\n
      \                        Error Correction (FEC) Building Block\",\n                         RFC
      5052, August 2007.\n   [RmClasses]           Levine, B. and J. Garcia-Luna-Aceves,
      \"A\n                         Comparison of Known Classes of Reliable\n                         Multicast
      Protocols\", Proc. International\n                         Conference on Network
      Protocols (ICNP-\n                         96) Columbus, OH, October 1996.\n
      \  [RmComparison]        Pingali, S., Towsley, D., and J. Kurose, \"A\n                         Comparison
      of Sender-Initiated and Receiver-\n                         Initiated Reliable
      Multicast Protocols\", Proc.\n                         INFOCOMM San Francisco,
      CA, October 1993.\n   [RmFec]               Macker, J., \"Reliable Multicast
      Transport and\n                         Integrated Erasure-based Forward Error\n
      \                        Correction\", IEEE MILCOM 1997, October 1997.\n   [SrmFramework]
      \       Floyd, S., Jacobson, V., McCanne, S., Liu, C.,\n                         and
      L. Zhang, \"A Reliable Multicast Framework\n                         for Light-weight
      Sessions and Application Level\n                         Framing\", Proc. ACM
      SIGCOMM, August 1995.\n   [TfmccPaper]          Widmer, J. and M. Handley, \"Extending
      Equation-\n                         Based Congestion Control to Multicast\n
      \                        Applications\", ACM SIGCOMM 2001, August 2001.\n"
    title: 8.2.  Informative References
  title: 8.  References
- contents:
  - "Authors' Addresses\n   Brian Adamson\n   Naval Research Laboratory\n   Washington,
    DC  20375\n   EMail: adamson@itd.nrl.navy.mil\n   Carsten Bormann\n   Universitaet
    Bremen TZI\n   Postfach 330440\n   D-28334 Bremen, Germany\n   EMail: cabo@tzi.org\n
    \  Mark Handley\n   University College London\n   Gower Street\n   London,   WC1E
    6BT\n   UK\n   EMail: M.Handley@cs.ucl.ac.uk\n   Joe Macker\n   Naval Research
    Laboratory\n   Washington, DC  20375\n   EMail: macker@itd.nrl.navy.mil\n"
  title: Authors' Addresses
