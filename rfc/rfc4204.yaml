- title: __initial_text__
  contents:
  - '                     Link Management Protocol (LMP)

    '
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This document specifies an Internet standards track protocol\
    \ for the\n   Internet community, and requests discussion and suggestions for\n\
    \   improvements.  Please refer to the current edition of the \"Internet\n   Official\
    \ Protocol Standards\" (STD 1) for the standardization state\n   and status of\
    \ this protocol.  Distribution of this memo is unlimited.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (C) The Internet Society (2005).\n"
- title: Abstract
  contents:
  - "Abstract\n   For scalability purposes, multiple data links can be combined to\
    \ form\n   a single traffic engineering (TE) link.  Furthermore, the management\n\
    \   of TE links is not restricted to in-band messaging, but instead can\n   be\
    \ done using out-of-band techniques.  This document specifies a link\n   management\
    \ protocol (LMP) that runs between a pair of nodes and is\n   used to manage TE\
    \ links.  Specifically, LMP will be used to maintain\n   control channel connectivity,\
    \ verify the physical connectivity of the\n   data links, correlate the link property\
    \ information, suppress\n   downstream alarms, and localize link failures for\n\
    \   protection/restoration purposes in multiple kinds of networks.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n      6.4. Channel Activation Indication .............................22\n\
    \      6.5. Channel Deactivation Indication ...........................23\n  \
    \ 7. Message_Id Usage ...............................................23\n   8.\
    \ Graceful Restart ...............................................24\n   9. Addressing\
    \ .....................................................25\n   10. Exponential\
    \ Back-off Procedures ...............................26\n       10.1. Operation\
    \ ...............................................26\n       10.2. Retransmission\
    \ Algorithm ................................27\n   11. LMP Finite State Machines\
    \ .....................................28\n       11.1. Control Channel FSM .....................................28\n\
    \       11.2. TE Link FSM .............................................32\n  \
    \     11.3. Data Link FSM ...........................................34\n   12.\
    \ LMP Message Formats ...........................................38\n       12.1.\
    \ Common Header ...........................................39\n       12.2. LMP\
    \ Object Format .......................................41\n       12.3. Parameter\
    \ Negotiation Messages ..........................42\n       12.4. Hello Message\
    \ (Msg Type = 4) ............................43\n       12.5. Link Verification\
    \ Messages ..............................43\n       12.6. Link Summary Messages\
    \ ...................................47\n       12.7. Fault Management Messages\
    \ ...............................49\n   13. LMP Object Definitions ........................................50\n\
    \       13.1. CCID (Control Channel ID) Class .........................50\n  \
    \     13.2. NODE_ID Class ...........................................51\n    \
    \   13.3. LINK_ID Class ...........................................52\n      \
    \ 13.4. INTERFACE_ID Class ......................................53\n       13.5.\
    \ MESSAGE_ID Class ........................................54\n       13.6. CONFIG\
    \ Class ............................................55\n       13.7. HELLO Class\
    \ .............................................56\n       13.8. BEGIN_VERIFY Class\
    \ ......................................56\n       13.9. BEGIN_VERIFY_ACK Class\
    \ ..................................58\n       13.10. VERIFY_ID Class ........................................59\n\
    \       13.11. TE_LINK Class ..........................................59\n  \
    \     13.12. DATA_LINK Class ........................................61\n    \
    \   13.13. CHANNEL_STATUS Class ...................................65\n      \
    \ 13.14. CHANNEL_STATUS_REQUEST Class ...........................68\n       13.15.\
    \ ERROR_CODE Class .......................................70\n   14. References\
    \ ....................................................71\n       14.1. Normative\
    \ References ....................................71\n       14.2. Informative\
    \ References ..................................72\n   15. Security Considerations\
    \ .......................................73\n       15.1. Security Requirements\
    \ ...................................73\n       15.2. Security Mechanisms .....................................74\n\
    \   16. IANA Considerations ...........................................76\n  \
    \ 17. Acknowledgements ..............................................83\n   18.\
    \ Contributors ..................................................83\n"
- title: 1. Introduction
  contents:
  - "1. Introduction\n   Networks are being developed with routers, switches, crossconnects,\n\
    \   dense wavelength division multiplexed (DWDM) systems, and add-drop\n   multiplexors\
    \ (ADMs) that use a common control plane, e.g.,\n   Generalized MPLS (GMPLS),\
    \ to dynamically allocate resources and to\n   provide network survivability using\
    \ protection and restoration\n   techniques.  A pair of nodes may have thousands\
    \ of interconnects,\n   where each interconnect may consist of multiple data links\
    \ when\n   multiplexing (e.g., Frame Relay DLCIs at Layer 2, time division\n \
    \  multiplexed (TDM) slots or wavelength division multiplexed (WDM)\n   wavelengths\
    \ at Layer 1) is used.  For scalability purposes, multiple\n   data links may\
    \ be combined into a single traffic-engineering (TE)\n   link.\n   To enable communication\
    \ between nodes for routing, signaling, and\n   link management, there must be\
    \ a pair of IP interfaces that are\n   mutually reachable.  We call such a pair\
    \ of interfaces a control\n   channel.  Note that \"mutually reachable\" does\
    \ not imply that these\n   two interfaces are (directly) connected by an IP link;\
    \ there may be\n   an IP network between the two.  Furthermore, the interface\
    \ over which\n   the control messages are sent/received may not be the same interface\n\
    \   over which the data flows.  This document specifies a link management\n  \
    \ protocol (LMP) that runs between a pair of nodes and is used to\n   manage TE\
    \ links and verify reachability of the control channel.  For\n   the purposes\
    \ of this document, such nodes are considered \"LMP\n   neighbors\" or simply\
    \ \"neighboring nodes\".\n   In GMPLS, the control channels between two adjacent\
    \ nodes are no\n   longer required to use the same physical medium as the data\
    \ links\n   between those nodes.  For example, a control channel could use a\n\
    \   separate virtual circuit, wavelength, fiber, Ethernet link, an IP\n   tunnel\
    \ routed over a separate management network, or a multi-hop IP\n   network.  A\
    \ consequence of allowing the control channel(s) between\n   two nodes to be logically\
    \ or physically diverse from the associated\n   data links is that the health\
    \ of a control channel does not\n   necessarily correlate to the health of the\
    \ data links, and vice-\n   versa.  Therefore, a clean separation between the\
    \ fate of the control\n   channel and data links must be made.  New mechanisms\
    \ must be\n   developed to manage the data links, both in terms of link\n   provisioning\
    \ and fault management.\n   Among the tasks that LMP accomplishes is checking\
    \ that the grouping\n   of links into TE links, as well as the properties of those\
    \ links, are\n   the same at both end points of the links -- this is called \"\
    link\n   property correlation\".  Also, LMP can communicate these link\n   properties\
    \ to the IGP module, which can then announce them to other\n   nodes in the network.\
    \  LMP can also tell the signaling module the\n   mapping between TE links and\
    \ control channels.  Thus, LMP performs a\n   valuable \"glue\" function in the\
    \ control plane.\n   Note that while the existence of the control network (single\
    \ or\n   multi-hop) is necessary for enabling communication, it is by no means\n\
    \   sufficient.  For example, if the two interfaces are separated by an\n   IP\
    \ network, faults in the IP network may result in the lack of an IP\n   path from\
    \ one interface to another, and therefore an interruption of\n   communication\
    \ between the two interfaces.  On the other hand, not\n   every failure in the\
    \ control network affects a given control channel,\n   hence the need for establishing\
    \ and managing control channels.\n   For the purposes of this document, a data\
    \ link may be considered by\n   each node that it terminates on as either a 'port'\
    \ or a 'component\n   link', depending on the multiplexing capability of the endpoint\
    \ on\n   that link; component links are multiplex capable, whereas ports are\n\
    \   not multiplex capable.  This distinction is important since the\n   management\
    \ of such links (including, for example, resource\n   allocation, label assignment,\
    \ and their physical verification) is\n   different based on their multiplexing\
    \ capability.  For example, a\n   Frame Relay switch is able to demultiplex an\
    \ interface into virtual\n   circuits based on DLCIs; similarly, a SONET crossconnect\
    \ with OC-192\n   interfaces may be able to demultiplex the OC-192 stream into\
    \ four\n   OC-48 streams.  If multiple interfaces are grouped together into a\n\
    \   single TE link using link bundling [RFC4201], then the link resources\n  \
    \ must be identified using three levels: Link_Id, component interface\n   Id,\
    \ and label identifying virtual circuit, timeslot, etc.  Resource\n   allocation\
    \ happens at the lowest level (labels), but physical\n   connectivity happens\
    \ at the component link level.  As another\n   example, consider the case where\
    \ an optical switch (e.g., PXC)\n   transparently switches OC-192 lightpaths.\
    \  If multiple interfaces are\n   once again grouped together into a single TE\
    \ link, then link bundling\n   [RFC4201] is not required and only two levels of\
    \ identification are\n   required: Link_Id and Port_Id.  In this case, both resource\n\
    \   allocation and physical connectivity happen at the lowest level\n   (i.e.,\
    \ port level).\n   To ensure interworking between data links with different multiplexing\n\
    \   capabilities, LMP-capable devices SHOULD allow sub-channels of a\n   component\
    \ link to be locally configured as (logical) data links.  For\n   example, if\
    \ a Router with 4 OC-48 interfaces is connected through a\n   4:1 MUX to a cross-connect\
    \ with OC-192 interfaces, the cross-connect\n   should be able to configure each\
    \ sub-channel (e.g., STS-48c SPE if\n   the 4:1 MUX is a SONET MUX) as a data\
    \ link.\n   LMP is designed to support aggregation of one or more data links into\n\
    \   a TE link (either ports into TE links, or component links into TE\n   links).\
    \  The purpose of forming a TE link is to group/map the\n   information about\
    \ certain physical resources (and their properties)\n   into the information that\
    \ is used by Constrained SPF for the purpose\n   of path computation, and by GMPLS\
    \ signaling.\n"
- title: 1.1.  Terminology
  contents:
  - "1.1.  Terminology\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"\
    SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\"\
    , and \"OPTIONAL\" in this\n   document are to be interpreted as described in\
    \ [RFC2119].\n   The reader is assumed to be familiar with the terminology in\n\
    \   [RFC3471], [RFC4202], and [RFC4201].\n   Bundled Link:\n      As defined in\
    \ [RFC4201], a bundled link is a TE link such that,\n      for the purpose of\
    \ GMPLS signaling, a combination of <link\n      identifier, label> is not sufficient\
    \ to unambiguously identify the\n      appropriate resources used by an LSP. \
    \ A bundled link is composed\n      of two or more component links.\n   Control\
    \ Channel:\n      A control channel is a pair of mutually reachable interfaces\
    \ that\n      are used to enable communication between nodes for routing,\n  \
    \    signaling, and link management.\n   Component Link:\n      As defined in\
    \ [RFC4201], a component link is a subset of resources\n      of a TE Link such\
    \ that (a) the partition is minimal, and (b)\n      within each subset a label\
    \ is sufficient to unambiguously identify\n      the appropriate resources used\
    \ by an LSP.\n   Data Link:\n      A data link is a pair of interfaces that are\
    \ used to transfer user\n      data.  Note that in GMPLS, the control channel(s)\
    \ between two\n      adjacent nodes are no longer required to use the same physical\n\
    \      medium as the data links between those nodes.\n   Link Property Correlation:\n\
    \      This is a procedure to correlate the local and remote properties\n    \
    \  of a TE link.\n   Multiplex Capability:\n      The ability to multiplex/demultiplex\
    \ a data stream into sub-rate\n      streams for switching purposes.\n   Node_Id:\n\
    \      For a node running OSPF, the LMP Node_Id is the same as the\n      address\
    \ contained in the OSPF Router Address TLV.  For a node\n      running IS-IS and\
    \ advertising the TE Router ID TLV, the Node_Id is\n      the same as the advertised\
    \ Router ID.\n   Port:\n      An interface that terminates a data link.\n   TE\
    \ Link:\n      As defined in [RFC4202], a TE link is a logical construct that\n\
    \      represents a way to group/map the information about certain\n      physical\
    \ resources (and their properties) that interconnect LSRs\n      into the information\
    \ that is used by Constrained SPF for the\n      purpose of path computation,\
    \ and by GMPLS signaling.\n   Transparent:\n      A device is called X-transparent\
    \ if it forwards incoming signals\n      from input to output without examining\
    \ or modifying the X aspect\n      of the signal.  For example, a Frame Relay\
    \ switch is network-layer\n      transparent; an all-optical switch is electrically\
    \ transparent.\n"
- title: 2.  LMP Overview
  contents:
  - "2.  LMP Overview\n   The two core procedures of LMP are control channel management\
    \ and\n   link property correlation.  Control channel management is used to\n\
    \   establish and maintain control channels between adjacent nodes.  This\n  \
    \ is done using a Config message exchange and a fast keep-alive\n   mechanism\
    \ between the nodes.  The latter is required if lower-level\n   mechanisms are\
    \ not available to detect control channel failures.\n   Link property correlation\
    \ is used to synchronize the TE link\n   properties and verify the TE link configuration.\n\
    \   LMP requires that a pair of nodes have at least one active bi-\n   directional\
    \ control channel between them.  Each direction of the\n   control channel is\
    \ identified by a Control Channel Id (CC_Id), and\n   the two directions are coupled\
    \ together using the LMP Config message\n   exchange.  Except for Test messages,\
    \ which may be limited by the\n   transport mechanism for in-band messaging, all\
    \ LMP packets are run\n   over UDP with an LMP port number.  The link level encoding\
    \ of the\n   control channel is outside the scope of this document.\n   An \"\
    LMP adjacency\" is formed between two nodes when at least one bi-\n   directional\
    \ control channel is established between them.  Multiple\n   control channels\
    \ may be active simultaneously for each adjacency;\n   control channel parameters,\
    \ however, MUST be individually negotiated\n   for each control channel.  If the\
    \ LMP fast keep-alive is used over a\n   control channel, LMP Hello messages MUST\
    \ be exchanged over the\n   control channel.  Other LMP messages MAY be transmitted\
    \ over any of\n   the active control channels between a pair of adjacent nodes.\
    \  One or\n   more active control channels may be grouped into a logical control\n\
    \   channel for signaling, routing, and link property correlation\n   purposes.\n\
    \   The link property correlation function of LMP is designed to\n   aggregate\
    \ multiple data links (ports or component links) into a TE\n   link and to synchronize\
    \ the properties of the TE link.  As part of\n   the link property correlation\
    \ function, a LinkSummary message\n   exchange is defined.  The LinkSummary message\
    \ includes the local and\n   remote Link_Ids, a list of all data links that comprise\
    \ the TE link,\n   and various link properties.  A LinkSummaryAck or LinkSummaryNack\n\
    \   message MUST be sent in response to the receipt of a LinkSummary\n   message\
    \ indicating agreement or disagreement on the link properties.\n   LMP messages\
    \ are transmitted reliably using Message_Ids and\n   retransmissions.  Message_Ids\
    \ are carried in MESSAGE_ID objects.  No\n   more than one MESSAGE_ID object may\
    \ be included in an LMP message.\n   For control-channel-specific messages, the\
    \ Message_Id is within the\n   scope of the control channel over which the message\
    \ is sent.  For\n   TE-link-specific messages, the Message_Id is within the scope\
    \ of the\n   LMP adjacency.  The value of the Message_Id is monotonically\n  \
    \ increasing and wraps when the maximum value is reached.\n   In this document,\
    \ two additional LMP procedures are defined: link\n   connectivity verification\
    \ and fault management.  These procedures are\n   particularly useful when the\
    \ control channels are physically diverse\n   from the data links.  Link connectivity\
    \ verification is used for data\n   plane discovery, Interface_Id exchange (Interface_Ids\
    \ are used in\n   GMPLS signaling, either as port labels or component link identifiers,\n\
    \   depending on the configuration), and physical connectivity\n   verification.\
    \  This is done by sending Test messages over the data\n   links and TestStatus\
    \ messages back over the control channel.  Note\n   that the Test message is the\
    \ only LMP message that must be\n   transmitted over the data link.  The ChannelStatus\
    \ message exchange\n   is used between adjacent nodes for both the suppression\
    \ of downstream\n   alarms and the localization of faults for protection and restoration.\n\
    \   For LMP link connectivity verification, the Test message is\n   transmitted\
    \ over the data links.  For X-transparent devices, this\n   requires examining\
    \ and modifying the X aspect of the signal.  The LMP\n   link connectivity verification\
    \ procedure is coordinated using a\n   BeginVerify message exchange over a control\
    \ channel.  To support\n   various aspects of transparency, a Verify Transport\
    \ Mechanism is\n   included in the BeginVerify and BeginVerifyAck messages.  Note\
    \ that\n   there is no requirement that all data links must lose their\n   transparency\
    \ simultaneously; but, at a minimum, it must be possible\n   to terminate them\
    \ one at a time.  There is also no requirement that\n   the control channel and\
    \ TE link use the same physical medium;\n   however, the control channel MUST\
    \ be terminated by the same two\n   control elements that control the TE link.\
    \  Since the BeginVerify\n   message exchange coordinates the Test procedure,\
    \ it also naturally\n   coordinates the transition of the data links in and out\
    \ of the\n   transparent mode.\n   The LMP fault management procedure is based\
    \ on a ChannelStatus\n   message exchange that uses the following messages: ChannelStatus,\n\
    \   ChannelStatusAck, ChannelStatusRequest, and ChannelStatusResponse.\n   The\
    \ ChannelStatus message is sent unsolicited and is used to notify\n   an LMP neighbor\
    \ about the status of one or more data channels of a TE\n   link.  The ChannelStatusAck\
    \ message is used to acknowledge receipt of\n   the ChannelStatus message.  The\
    \ ChannelStatusRequest message is used\n   to query an LMP neighbor for the status\
    \ of one or more data channels\n   of a TE Link.  The ChannelStatusResponse message\
    \ is used to\n   acknowledge receipt of the ChannelStatusRequest message and indicate\n\
    \   the states of the queried data links.\n"
- title: 3.  Control Channel Management
  contents:
  - "3.  Control Channel Management\n   To initiate an LMP adjacency between two nodes,\
    \ one or more bi-\n   directional control channels MUST be activated.  The control\
    \ channels\n   can be used to exchange control-plane information such as link\n\
    \   provisioning and fault management information (implemented using a\n   messaging\
    \ protocol such as LMP, proposed in this document), path\n   management and label\
    \ distribution information (implemented using a\n   signaling protocol such as\
    \ RSVP-TE [RFC3209]), and network topology\n   and state distribution information\
    \ (implemented using traffic\n   engineering extensions of protocols such as OSPF\
    \ [RFC3630] and IS-IS\n   [RFC3784]).\n   For the purposes of LMP, the exact implementation\
    \ of the control\n   channel is not specified; it could be, for example, a separate\n\
    \   wavelength or fiber, an Ethernet link, an IP tunnel through a\n   separate\
    \ management network, or the overhead bytes of a data link.\n   Each node assigns\
    \ a node-wide, unique, 32-bit, non-zero integer\n   control channel identifier\
    \ (CC_Id).  This identifier comes from the\n   same space as the unnumbered interface\
    \ Id.  Furthermore, LMP packets\n   are run over UDP with an LMP port number.\
    \  Thus, the link level\n   encoding of the control channel is not part of the\
    \ LMP specification.\n   To establish a control channel, the destination IP address\
    \ on the far\n   end of the control channel must be known.  This knowledge may\
    \ be\n   manually configured or automatically discovered.  Note that for in-\n\
    \   band signaling, a control channel could be explicitly configured on a\n  \
    \ particular data link.  In this case, the Config message exchange can\n   be\
    \ used to dynamically learn the IP address on the far end of the\n   control channel.\
    \  This is done by sending the Config message with the\n   unicast IP source address\
    \ and the multicast IP destination address\n   (224.0.0.1 or ff02::1).  The ConfigAck\
    \ and ConfigNack messages MUST\n   be sent to the source IP address found in the\
    \ IP header of the\n   received Config message.\n   Control channels exist independently\
    \ of TE links and multiple control\n   channels may be active simultaneously between\
    \ a pair of nodes.\n   Individual control channels can be realized in different\
    \ ways; one\n   might be implemented in-fiber while another one may be implemented\n\
    \   out-of-fiber.  As such, control channel parameters MUST be negotiated\n  \
    \ over each individual control channel, and LMP Hello packets MUST be\n   exchanged\
    \ over each control channel to maintain LMP connectivity if\n   other mechanisms\
    \ are not available.  Since control channels are\n   electrically terminated at\
    \ each node, it may be possible to detect\n   control channel failures using lower\
    \ layers (e.g., SONET/SDH).\n   There are four LMP messages that are used to manage\
    \ individual\n   control channels.  They are the Config, ConfigAck, ConfigNack,\
    \ and\n   Hello messages.  These messages MUST be transmitted on the channel to\n\
    \   which they refer.  All other LMP messages may be transmitted over any\n  \
    \ of the active control channels between a pair of LMP adjacent nodes.\n   In\
    \ order to maintain an LMP adjacency, it is necessary to have at\n   least one\
    \ active control channel between a pair of adjacent nodes\n   (recall that multiple\
    \ control channels can be active simultaneously\n   between a pair of nodes).\
    \  In the event of a control channel failure,\n   alternate active control channels\
    \ can be used and it may be possible\n   to activate additional control channels\
    \ as described below.\n"
- title: 3.1.  Parameter Negotiation
  contents:
  - "3.1.  Parameter Negotiation\n   Control channel activation begins with a parameter\
    \ negotiation\n   exchange using Config, ConfigAck, and ConfigNack messages. \
    \ The\n   contents of these messages are built using LMP objects, which can be\n\
    \   either negotiable or non-negotiable (identified by the N bit in the\n   object\
    \ header).  Negotiable objects can be used to let LMP peers\n   agree on certain\
    \ values.  Non-negotiable objects are used for the\n   announcement of specific\
    \ values that do not need, or do not allow,\n   negotiation.\n   To activate a\
    \ control channel, a Config message MUST be transmitted\n   to the remote node,\
    \ and in response, a ConfigAck message MUST be\n   received at the local node.\
    \  The Config message contains the Local\n   Control Channel Id (CC_Id), the sender's\
    \ Node_Id, a Message_Id for\n   reliable messaging, and a CONFIG object.  It is\
    \ possible that both\n   the local and remote nodes initiate the configuration\
    \ procedure at\n   the same time.  To avoid ambiguities, the node with the higher\n\
    \   Node_Id wins the contention; the node with the lower Node_Id MUST\n   stop\
    \ transmitting the Config message and respond to the Config\n   message it received.\
    \  If the Node_Ids are equal, then one (or both)\n   nodes have been misconfigured.\
    \  The nodes MAY continue to retransmit\n   Config messages in hopes that the\
    \ misconfiguration is corrected.\n   Note that the problem may be solved by an\
    \ operator changing the\n   Node_Ids on one or both nodes.\n   The ConfigAck message\
    \ is used to acknowledge receipt of the Config\n   message and express agreement\
    \ on ALL of the configured parameters\n   (both negotiable and non-negotiable).\n\
    \   The ConfigNack message is used to acknowledge receipt of the Config\n   message,\
    \ indicate which (if any) non-negotiable CONFIG objects are\n   unacceptable,\
    \ and to propose alternate values for the negotiable\n   parameters.\n   If a\
    \ node receives a ConfigNack message with acceptable alternate\n   values for\
    \ negotiable parameters, the node SHOULD transmit a Config\n   message using these\
    \ values for those parameters.\n   If a node receives a ConfigNack message with\
    \ unacceptable alternate\n   values, the node MAY continue to retransmit Config\
    \ messages in hopes\n   that the misconfiguration is corrected.  Note that the\
    \ problem may be\n   solved by an operator changing parameters on one or both\
    \ nodes.\n   In the case where multiple control channels use the same physical\n\
    \   interface, the parameter negotiation exchange is performed for each\n   control\
    \ channel.  The various LMP parameter negotiation messages are\n   associated\
    \ with their corresponding control channels by their node-\n   wide unique identifiers\
    \ (CC_Ids).\n"
- title: 3.2.  Hello Protocol
  contents:
  - "3.2.  Hello Protocol\n   Once a control channel is activated between two adjacent\
    \ nodes, the\n   LMP Hello protocol can be used to maintain control channel\n\
    \   connectivity between the nodes and to detect control channel\n   failures.\
    \  The LMP Hello protocol is intended to be a lightweight\n   keep-alive mechanism\
    \ that will react to control channel failures\n   rapidly so that IGP Hellos are\
    \ not lost and the associated link-state\n   adjacencies are not removed unnecessarily.\n"
- title: 3.2.1.  Hello Parameter Negotiation
  contents:
  - "3.2.1.  Hello Parameter Negotiation\n   Before sending Hello messages, the HelloInterval\
    \ and\n   HelloDeadInterval parameters MUST be agreed upon by the local and\n\
    \   remote nodes.  These parameters are exchanged in the Config message.\n   The\
    \ HelloInterval indicates how frequently LMP Hello messages will be\n   sent,\
    \ and is measured in milliseconds (ms).  For example, if the\n   value were 150,\
    \ then the transmitting node would send the Hello\n   message at least every 150\
    \ ms.  The HelloDeadInterval indicates how\n   long a device should wait to receive\
    \ a Hello message before declaring\n   a control channel dead, and is measured\
    \ in milliseconds (ms).\n   The HelloDeadInterval MUST be greater than the HelloInterval,\
    \ and\n   SHOULD be at least 3 times the value of HelloInterval.  If the fast\n\
    \   keep-alive mechanism of LMP is not used, the HelloInterval and\n   HelloDeadInterval\
    \ parameters MUST be set to zero.\n   The values for the HelloInterval and HelloDeadInterval\
    \ should be\n   selected carefully to provide rapid response time to control channel\n\
    \   failures without causing congestion.  As such, different values will\n   likely\
    \ be configured for different control channel implementations.\n   When the control\
    \ channel is implemented over a directly connected\n   link, the suggested default\
    \ values for the HelloInterval is 150 ms\n   and for the HelloDeadInterval is\
    \ 500 ms.\n   When a node has either sent or received a ConfigAck message, it\
    \ may\n   begin sending Hello messages.  Once it has sent a Hello message and\n\
    \   received a valid Hello message (i.e., with expected sequence numbers;\n  \
    \ see Section 3.2.2), the control channel moves to the up state.  (It\n   is also\
    \ possible to move to the up state without sending Hellos if\n   other methods\
    \ are used to indicate bi-directional control-channel\n   connectivity.  For example,\
    \ indication of bi-directional connectivity\n   may be learned from the transport\
    \ layer.)  If, however, a node\n   receives a ConfigNack message instead of a\
    \ ConfigAck message, the\n   node MUST not send Hello messages and the control\
    \ channel SHOULD NOT\n   move to the up state.  See Section 11.1 for the complete\
    \ control\n   channel FSM.\n"
- title: 3.2.2.  Fast Keep-alive
  contents:
  - "3.2.2.  Fast Keep-alive\n   Each Hello message contains two sequence numbers:\
    \ the first sequence\n   number (TxSeqNum) is the sequence number for the Hello\
    \ message being\n   sent and the second sequence number (RcvSeqNum) is the sequence\n\
    \   number of the last Hello message received from the adjacent node over\n  \
    \ this control channel.\n   There are two special sequence numbers.  TxSeqNum\
    \ MUST NOT ever be 0.\n   TxSeqNum = 1 is used to indicate that the sender has\
    \ just started or\n   has restarted and has no recollection of the last TxSeqNum\
    \ that was\n   sent.  Thus, the first Hello sent has a TxSeqNum of 1 and an RxSeqNum\n\
    \   of 0.  When TxSeqNum reaches (2^32)-1, the next sequence number used\n   is\
    \ 2, not 0 or 1, as these have special meanings.\n   Under normal operation, the\
    \ difference between the RcvSeqNum in a\n   Hello message that is received and\
    \ the local TxSeqNum that is\n   generated will be at most 1.  This difference\
    \ can be more than one\n   only when a control channel restarts or when the values\
    \ wrap.\n   Since the 32-bit sequence numbers may wrap, the following expression\n\
    \   may be used to test if a newly received TxSeqNum value is less than a\n  \
    \ previously received value:\n   If ((int) old_id - (int) new_id > 0) {\n    \
    \  New value is less than old value;\n   }\n   Having sequence numbers in the\
    \ Hello messages allows each node to\n   verify that its peer is receiving its\
    \ Hello messages.  By including\n   the RcvSeqNum in Hello packets, the local\
    \ node will know which Hello\n   packets the remote node has received.\n   The\
    \ following example illustrates how the sequence numbers operate.\n   Note that\
    \ only the operation at one node is shown, and alternative\n   scenarios are possible:\n\
    \   1) After completing the configuration stage, Node A sends Hello\n      messages\
    \ to Node B with {TxSeqNum=1;RcvSeqNum=0}.\n   2) Node A receives a Hello from\
    \ Node B with {TxSeqNum=1;RcvSeqNum=1}.\n      When the HelloInterval expires\
    \ on Node A, it sends Hellos to Node\n      B with {TxSeqNum=2;RcvSeqNum=1}.\n\
    \   3) Node A receives a Hello from Node B with {TxSeqNum=2;RcvSeqNum=2}.\n  \
    \    When the HelloInterval expires on Node A, it sends Hellos to Node\n     \
    \ B with {TxSeqNum=3;RcvSeqNum=2}.\n"
- title: 3.2.3.  Control Channel Down
  contents:
  - "3.2.3.  Control Channel Down\n   To allow bringing a control channel down gracefully\
    \ for\n   administration purposes, a ControlChannelDown flag is available in\n\
    \   the Common Header of LMP packets.  When data links are still in use\n   between\
    \ a pair of nodes, a control channel SHOULD only be taken down\n   administratively\
    \ when there are other active control channels that\n   can be used to manage\
    \ the data links.\n   When bringing a control channel down administratively, a\
    \ node MUST\n   set the ControlChannelDown flag in all LMP messages sent over\
    \ the\n   control channel.  The node that initiated the control channel down\n\
    \   procedure may stop sending Hello messages after HelloDeadInterval\n   seconds\
    \ have passed, or if it receives an LMP message over the same\n   control channel\
    \ with the ControlChannelDown flag set.\n   When a node receives an LMP packet\
    \ with the ControlChannelDown flag\n   set, it SHOULD send a Hello message with\
    \ the ControlChannelDown flag\n   set and move the control channel to the down\
    \ state.\n"
- title: 3.2.4.  Degraded State
  contents:
  - "3.2.4.  Degraded State\n   A consequence of allowing the control channels to\
    \ be physically\n   diverse from the associated data links is that there may not\
    \ be any\n   active control channels available while the data links are still\
    \ in\n   use.  For many applications, it is unacceptable to tear down a link\n\
    \   that is carrying user traffic simply because the control channel is\n   no\
    \ longer available; however, the traffic that is using the data\n   links may\
    \ no longer be guaranteed the same level of service.  Hence,\n   the TE link is\
    \ in a Degraded state.\n   When a TE link is in the Degraded state, routing and\
    \ signaling SHOULD\n   be notified so that new connections are not accepted and\
    \ the TE link\n   is advertised with no unreserved resources.\n"
- title: 4.  Link Property Correlation
  contents:
  - "4.  Link Property Correlation\n   As part of LMP, a link property correlation\
    \ exchange is defined for\n   TE links using the LinkSummary, LinkSummaryAck,\
    \ and LinkSummaryNack\n   messages.  The contents of these messages are built\
    \ using LMP\n   objects, which can be either negotiable or non-negotiable (identified\n\
    \   by the N flag in the object header).  Negotiable objects can be used\n   to\
    \ let both sides agree on certain link parameters.  Non-negotiable\n   objects\
    \ are used for announcement of specific values that do not\n   need, or do not\
    \ allow, negotiation.\n   Each TE link has an identifier (Link_Id) that is assigned\
    \ at each end\n   of the link.  These identifiers MUST be the same type (i.e,\
    \ IPv4,\n   IPv6, unnumbered) at both ends.  If a LinkSummary message is received\n\
    \   with different local and remote TE link types, then a LinkSummaryNack\n  \
    \ message MUST be sent with Error Code \"Bad TE Link Object\".\n   Similarly,\
    \ each data link is assigned an identifier (Interface_Id) at\n   each end.  These\
    \ identifiers MUST also be the same type at both ends.\n   If a LinkSummary message\
    \ is received with different local and remote\n   Interface_Id types, then a LinkSummaryNack\
    \ message MUST be sent with\n   Error Code \"Bad Data Link Object\".\n   Link\
    \ property correlation SHOULD be done before the link is brought\n   up and MAY\
    \ be done any time a link is up and not in the Verification\n   process.\n   The\
    \ LinkSummary message is used to verify for consistency the TE and\n   data link\
    \ information on both sides.  Link Summary messages are also\n   used (1) to aggregate\
    \ multiple data links (either ports or component\n   links) into a TE link; (2)\
    \ to exchange, correlate (to determine\n   inconsistencies), or change TE link\
    \ parameters; and (3) to exchange,\n   correlate (to determine inconsistencies),\
    \ or change Interface_Ids\n   (either Port_Ids or component link identifiers).\n\
    \   The LinkSummary message includes a TE_LINK object followed by one or\n   more\
    \ DATA_LINK objects.  The TE_LINK object identifies the TE link's\n   local and\
    \ remote Link_Id and indicates support for fault management\n   and link verification\
    \ procedures for that TE link.  The DATA_LINK\n   objects are used to characterize\
    \ the data links that comprise the TE\n   link.  These objects include the local\
    \ and remote Interface_Ids, and\n   may include one or more sub-objects further\
    \ describing the properties\n   of the data links.\n   If the LinkSummary message\
    \ is received from a remote node, and the\n   Interface_Id mappings match those\
    \ that are stored locally, then the\n   two nodes have agreement on the Verification\
    \ procedure (see Section\n   5) and data link identification configuration.  If\
    \ the verification\n   procedure is not used, the LinkSummary message can be used\
    \ to verify\n   agreement on manual configuration.\n   The LinkSummaryAck message\
    \ is used to signal agreement on the\n   Interface_Id mappings and link property\
    \ definitions.  Otherwise, a\n   LinkSummaryNack message MUST be transmitted,\
    \ indicating which\n   Interface mappings are not correct and/or which link properties\
    \ are\n   not accepted.  If a LinkSummaryNack message indicates that the\n   Interface_Id\
    \ mappings are not correct and the link verification\n   procedure is enabled,\
    \ the link verification process SHOULD be\n   repeated for all mismatched, free\
    \ data links; if an allocated data\n   link has a mapping mismatch, it SHOULD\
    \ be flagged and verified when\n   it becomes free.  If a LinkSummaryNack message\
    \ includes negotiable\n   parameters, then acceptable values for those parameters\
    \ MUST be\n   included.  If a LinkSummaryNack message is received and includes\n\
    \   negotiable parameters, then the initiator of the LinkSummary message\n   SHOULD\
    \ send a new LinkSummary message.  The new LinkSummary message\n   SHOULD include\
    \ new values for the negotiable parameters.  These\n   values SHOULD take into\
    \ account the acceptable values received in the\n   LinkSummaryNack message.\n\
    \   It is possible that the LinkSummary message could grow quite large\n   due\
    \ to the number of DATA LINK objects.  An LMP implementation SHOULD\n   be able\
    \ to fragment when transmitting LMP messages, and MUST be able\n   to re-assemble\
    \ IP fragments when receiving LMP messages.\n"
- title: 5.  Verifying Link Connectivity
  contents:
  - "5.  Verifying Link Connectivity\n   In this section, an optional procedure is\
    \ described that may be used\n   to verify the physical connectivity of the data\
    \ links and dynamically\n   learn (i.e., discover) the TE link and Interface_Id\
    \ associations.\n   The procedure SHOULD be done when establishing a TE link,\
    \ and\n   subsequently, on a periodic basis for all unallocated (free) data\n\
    \   links of the TE link.\n   Support for this procedure is indicated by setting\
    \ the \"Link\n   Verification Supported\" flag in the TE_LINK object of the LinkSummary\n\
    \   message.\n   If a BeginVerify message is received and link verification is\
    \ not\n   supported for the TE link, then a BeginVerifyNack message MUST be\n\
    \   transmitted with Error Code indicating, \"Link Verification Procedure\n  \
    \ not supported for this TE Link.\"\n   A unique characteristic of transparent\
    \ devices is that the data is\n   not modified or examined during normal operation.\
    \  This\n   characteristic poses a challenge for validating the connectivity of\n\
    \   the data links and establishing the label mappings.  Therefore, to\n   ensure\
    \ proper verification of data link connectivity, it is required\n   that, until\
    \ the data links are allocated for user traffic, they must\n   be opaque (i.e.,\
    \ lose their transparency).  To support various\n   degrees of opaqueness (e.g.,\
    \ examining overhead bytes, terminating\n   the IP payload, etc.) and, hence,\
    \ different mechanisms to transport\n   the Test messages, a Verify Transport\
    \ Mechanism field is included in\n   the BeginVerify and BeginVerifyAck messages.\n\
    \   There is no requirement that all data links be terminated\n   simultaneously;\
    \ but, at a minimum, the data links MUST be able to be\n   terminated one at a\
    \ time.  Furthermore, for the link verification\n   procedure it is assumed that\
    \ the nodal architecture is designed so\n   that messages can be sent and received\
    \ over any data link.  Note that\n   this requirement is trivial for opaque devices\
    \ since each data link\n   is electrically terminated and processed before being\
    \ forwarded to\n   the next opaque device; but that in transparent devices this\
    \ is an\n   additional requirement.\n   To interconnect two nodes, a TE link is\
    \ defined between them, and at\n   a minimum, there MUST be at least one active\
    \ control channel between\n   the nodes.  For link verification, a TE link MUST\
    \ include at least\n   one data link.\n   Once a control channel has been established\
    \ between the two nodes,\n   data link connectivity can be verified by exchanging\
    \ Test messages\n   over each of the data links specified in the TE link.  It\
    \ should be\n   noted that all LMP messages except the Test message are exchanged\n\
    \   over the control channels and that Hello messages continue to be\n   exchanged\
    \ over each control channel during the data link verification\n   process.  The\
    \ Test message is sent over the data link that is being\n   verified.  Data links\
    \ are tested in the transmit direction because\n   they are unidirectional; therefore,\
    \ it may be possible for both nodes\n   to (independently) exchange the Test messages\
    \ simultaneously.\n   To initiate the link verification procedure, the local node\
    \ MUST send\n   a BeginVerify message over a control channel.  To limit the scope\
    \ of\n   Link Verification to a particular TE Link, the local Link_Id MUST be\n\
    \   non-zero.  If this field is zero, the data links can span multiple TE\n  \
    \ links and/or they may comprise a TE link that is yet to be\n   configured. \
    \ For the case where the local Link_Id field is zero, the\n   \"Verify all Links\"\
    \ flag of the BEGIN_VERIFY object is used to\n   distinguish between data links\
    \ that span multiple TE links and those\n   that have not yet been assigned to\
    \ a TE link.  Specifically,\n   verification of data links that span multiple\
    \ TE links is indicated\n   by setting the local Link_Id field to zero and setting\
    \ the \"Verify\n   all Links\" flag.  Verification of data links that have not\
    \ yet been\n   assigned to a TE link is indicated by setting the local Link_Id\
    \ field\n   to zero and clearing the \"Verify all Links\" flag.\n   The BeginVerify\
    \ message also contains the number of data links that\n   are to be verified;\
    \ the interval (called VerifyInterval) at which the\n   Test messages will be\
    \ sent; the encoding scheme and transport\n   mechanisms that are supported; the\
    \ data rate for Test messages; and,\n   when the data links correspond to fibers,\
    \ the wavelength identifier\n   over which the Test messages will be transmitted.\n\
    \   If the remote node receives a BeginVerify message and it is ready to\n   process\
    \ Test messages, it MUST send a BeginVerifyAck message back to\n   the local node\
    \ specifying the desired transport mechanism for the\n   TEST messages.  The remote\
    \ node includes a 32-bit, node-unique\n   Verify_Id in the BeginVerifyAck message.\
    \  The Verify_Id MAY be\n   randomly selected; however, it MUST NOT overlap any\
    \ other Verify_Id\n   currently being used by the node selecting it.  The Verify_Id\
    \ is then\n   used in all corresponding verification messages to differentiate\
    \ them\n   from different LMP peers and/or parallel Test procedures.  When the\n\
    \   local node receives a BeginVerifyAck message from the remote node, it\n  \
    \ may begin testing the data links by transmitting periodic Test\n   messages\
    \ over each data link.  The Test message includes the\n   Verify_Id and the local\
    \ Interface_Id for the associated data link.\n   The remote node MUST send either\
    \ a TestStatusSuccess or a\n   TestStatusFailure message in response for each\
    \ data link.  A\n   TestStatusAck message MUST be sent to confirm receipt of the\n\
    \   TestStatusSuccess and TestStatusFailure messages.  Unacknowledged\n   TestStatusSuccess\
    \ and TestStatusFailure messages SHOULD be\n   retransmitted until the message\
    \ is acknowledged or until a retry\n   limit is reached (see also Section 10).\n\
    \   It is also permissible for the sender to terminate the Test procedure\n  \
    \ anytime after sending the BeginVerify message.  An EndVerify message\n   SHOULD\
    \ be sent for this purpose.\n   Message correlation is done using message identifiers\
    \ and the\n   Verify_Id; this enables verification of data links, belonging to\n\
    \   different link bundles or LMP sessions, in parallel.\n   When the Test message\
    \ is received, the received Interface_Id (used in\n   GMPLS as either a Port label\
    \ or component link identifier, depending\n   on the configuration) is recorded\
    \ and mapped to the local\n   Interface_Id for that data link, and a TestStatusSuccess\
    \ message MUST\n   be sent.  The TestStatusSuccess message includes the local\n\
    \   Interface_Id along with the Interface_Id and Verify_Id received in\n   the\
    \ Test message.  The receipt of a TestStatusSuccess message\n   indicates that\
    \ the Test message was detected at the remote node and\n   the physical connectivity\
    \ of the data link has been verified.  When\n   the TestStatusSuccess message\
    \ is received, the local node SHOULD mark\n   the data link as up and send a TestStatusAck\
    \ message to the remote\n   node.  If, however, the Test message is not detected\
    \ at the remote\n   node within an observation period (specified by the\n   VerifyDeadInterval),\
    \ the remote node MUST send a TestStatusFailure\n   message over the control channel,\
    \ which indicates that the\n   verification of the physical connectivity of the\
    \ data link has\n   failed.  When the local node receives a TestStatusFailure\
    \ message, it\n   SHOULD mark the data link as FAILED and send a TestStatusAck\
    \ message\n   to the remote node.  When all the data links on the list have been\n\
    \   tested, the local node SHOULD send an EndVerify message to indicate\n   that\
    \ testing is complete on this link.\n   If the local/remote data link mappings\
    \ are known, then the link\n   verification procedure can be optimized by testing\
    \ the data links in\n   a defined order known to both nodes.  The suggested criterion\
    \ for\n   this ordering is by increasing the value of the remote Interface_Id.\n\
    \   Both the local and remote nodes SHOULD maintain the complete list of\n   Interface_Id\
    \ mappings for correlation purposes.\n"
- title: 5.1.  Example of Link Connectivity Verification
  contents:
  - "5.1.  Example of Link Connectivity Verification\n   Figure 1 shows an example\
    \ of the link verification scenario that is\n   executed when a link between Node\
    \ A and Node B is added.  In this\n   example, the TE link consists of three free\
    \ ports (each transmitted\n   along a separate fiber) and is associated with a\
    \ bi-directional\n   control channel (indicated by a \"c\").  The verification\
    \ process is as\n   follows:\n   o  A sends a BeginVerify message over the control\
    \ channel to B,\n      indicating it will begin verifying the ports that form\
    \ the TE\n      link.  The LOCAL_LINK_ID object carried in the BeginVerify message\n\
    \      carries the identifier (IP address or interface index) that A\n      assigns\
    \ to the link.\n   o  Upon receipt of the BeginVerify message, B creates a Verify_Id\
    \ and\n      binds it to the TE Link from A.  This binding is used later when\
    \ B\n      receives the Test messages from A, and these messages carry the\n \
    \     Verify_Id.  B discovers the identifier (IP address or interface\n      index)\
    \ that A assigns to the TE link by examining the\n      LOCAL_LINK_ID object carried\
    \ in the received BeginVerify message.\n      (If the data ports are not yet assigned\
    \ to the TE Link, the\n      binding is limited to the Node_Id of A.) In response\
    \ to the\n      BeginVerify message, B sends the BeginVerifyAck message to A.\
    \  The\n      LOCAL_LINK_ID object carried in the BeginVerifyAck message is used\n\
    \      to carry the identifier (IP address or interface index) that B\n      assigns\
    \ to the TE link.  The REMOTE_LINK_ID object carried in the\n      BeginVerifyAck\
    \ message is used to bind the Link_Ids assigned by\n      both A and B.  The Verify_Id\
    \ is returned to A in the\n      BeginVerifyAck message over the control channel.\n\
    \   o  When A receives the BeginVerifyAck message, it begins transmitting\n  \
    \    periodic Test messages over the first port (Interface Id=1).  The\n     \
    \ Test message includes the Interface_Id for the port and the\n      Verify_Id\
    \ that was assigned by B.\n   o  When B receives the Test messages, it maps the\
    \ received\n      Interface_Id to its own local Interface_Id = 10 and transmits\
    \ a\n      TestStatusSuccess message over the control channel back to Node A.\n\
    \      The TestStatusSuccess message includes both the local and received\n  \
    \    Interface_Ids for the port as well as the Verify_Id.  The\n      Verify_Id\
    \ is used to determine the local/remote TE link\n      identifiers (IP addresses\
    \ or interface indices) to which the data\n      links belong.\n   o  A will send\
    \ a TestStatusAck message over the control channel back\n      to B, indicating\
    \ it received the TestStatusSuccess message.\n   o  The process is repeated until\
    \ all of the ports are verified.\n   o  At this point, A will send an EndVerify\
    \ message over the control\n      channel to B, indicating that testing is complete.\n\
    \   o  B will respond by sending an EndVerifyAck message over the control\n  \
    \    channel back to A.\n      Note that this procedure can be used to \"discover\"\
    \ the\n      connectivity of the data ports.\n   +---------------------+     \
    \                 +---------------------+\n   +                     +        \
    \              +                     +\n   +      Node A         +<-------- c\
    \ --------->+        Node B       +\n   +                     +              \
    \        +                     +\n   +                     +                 \
    \     +                     +\n   +                   1 +--------------------->+\
    \ 10                  +\n   +                     +                      +   \
    \                  +\n   +                     +                      +      \
    \               +\n   +                   2 +                /---->+ 11      \
    \            +\n   +                     +          /----/      +            \
    \         +\n   +                     +     /---/            +               \
    \      +\n   +                   3 +----/                 + 12               \
    \   +\n   +                     +                      +                     +\n\
    \   +                     +                      +                     +\n   +\
    \                   4 +--------------------->+ 14                  +\n   +   \
    \                  +                      +                     +\n   +---------------------+\
    \                      +---------------------+\n    Figure 1:  Example of link\
    \ connectivity between Node A and Node B.\n"
- title: 6.  Fault Management
  contents:
  - "6.  Fault Management\n   In this section, an optional LMP procedure is described\
    \ that is used\n   to manage failures by rapid notification of the status of one\
    \ or more\n   data channels of a TE Link.  The scope of this procedure is within\
    \ a\n   TE link, and as such, the use of this procedure is negotiated as part\n\
    \   of the LinkSummary exchange.  The procedure can be used to rapidly\n   isolate\
    \ data link and TE link failures, and is designed to work for\n   both unidirectional\
    \ and bi-directional LSPs.\n   An important implication of using transparent devices\
    \ is that\n   traditional methods that are used to monitor the health of allocated\n\
    \   data links may no longer be appropriate.  Instead of fault detection\n   being\
    \ in layer 2 or layer 3, it is delegated to the physical layer\n   (i.e., loss\
    \ of light or optical monitoring of the data).\n   Recall that a TE link connecting\
    \ two nodes may consist of a number of\n   data links.  If one or more data links\
    \ fail between two nodes, a\n   mechanism must be used for rapid failure notification\
    \ so that\n   appropriate protection/restoration mechanisms can be initiated.\
    \  If\n   the failure is subsequently cleared, then a mechanism must be used to\n\
    \   notify that the failure is clear and the channel status is OK.\n"
- title: 6.1.  Fault Detection
  contents:
  - "6.1.  Fault Detection\n   Fault detection should be handled at the layer closest\
    \ to the\n   failure; for optical networks, this is the physical (optical) layer.\n\
    \   One measure of fault detection at the physical layer is detecting\n   loss\
    \ of light (LOL).  Other techniques for monitoring optical signals\n   are still\
    \ being developed and will not be further considered in this\n   document.  However,\
    \ it should be clear that the mechanism used for\n   fault notification in LMP\
    \ is independent of the mechanism used to\n   detect the failure, and simply relies\
    \ on the fact that a failure is\n   detected.\n"
- title: 6.2.  Fault Localization Procedure
  contents:
  - "6.2.  Fault Localization Procedure\n   In some situations, a data link failure\
    \ between two nodes is\n   propagated downstream such that all the downstream\
    \ nodes detect the\n   failure without localizing the failure.  To avoid multiple\
    \ alarms\n   stemming from the same failure, LMP provides failure notification\n\
    \   through the ChannelStatus message.  This message may be used to\n   indicate\
    \ that a single data channel has failed, multiple data\n   channels have failed,\
    \ or an entire TE link has failed.  Failure\n   correlation is done locally at\
    \ each node upon receipt of the failure\n   notification.\n   To localize a fault\
    \ to a particular link between adjacent nodes, a\n   downstream node (downstream\
    \ in terms of data flow) that detects data\n   link failures will send a ChannelStatus\
    \ message to its upstream\n   neighbor indicating that a failure has been detected\
    \ (bundling\n   together the notification of all the failed data links).  An upstream\n\
    \   node that receives the ChannelStatus message MUST send a\n   ChannelStatusAck\
    \ message to the downstream node indicating it has\n   received the ChannelStatus\
    \ message.  The upstream node should\n   correlate the failure to see if the failure\
    \ is also detected locally\n   for the corresponding LSP(s).  If, for example,\
    \ the failure is clear\n   on the input of the upstream node or internally, then\
    \ the upstream\n   node will have localized the failure.  Once the failure is\n\
    \   correlated, the upstream node SHOULD send a ChannelStatus message to\n   the\
    \ downstream node indicating that the channel is failed or is OK.\n   If a ChannelStatus\
    \ message is not received by the downstream node, it\n   SHOULD send a ChannelStatusRequest\
    \ message for the channel in\n   question.  Once the failure has been localized,\
    \ the signaling\n   protocols may be used to initiate span or path protection\
    \ and\n   restoration procedures.\n   If all of the data links of a TE link have\
    \ failed, then the upstream\n   node MAY be notified of the TE link failure without\
    \ specifying each\n   data link of the failed TE link.  This is done by sending\
    \ failure\n   notification in a ChannelStatus message identifying the TE Link\n\
    \   without including the Interface_Ids in the CHANNEL_STATUS object.\n"
- title: 6.3.  Examples of Fault Localization
  contents:
  - "6.3.  Examples of Fault Localization\n   In Figure 2, a sample network is shown\
    \ where four nodes are connected\n   in a linear array configuration.  The control\
    \ channels are bi-\n   directional and are labeled with a \"c\".  All LSPs are\
    \ also bi-\n   directional.\n   In the first example [see Fig. 2(a)], there is\
    \ a failure on one\n   direction of the bi-directional LSP.  Node 4 will detect\
    \ the failure\n   and will send a ChannelStatus message to Node 3 indicating the\n\
    \   failure (e.g., LOL) to the corresponding upstream node.  When Node 3\n   receives\
    \ the ChannelStatus message from Node 4, it returns a\n   ChannelStatusAck message\
    \ back to Node 4 and correlates the failure\n   locally.  When Node 3 correlates\
    \ the failure and verifies that the\n   failure is clear, it has localized the\
    \ failure to the data link\n   between Node 3 and Node 4.  At that time, Node\
    \ 3 should send a\n   ChannelStatus message to Node 4 indicating that the failure\
    \ has been\n   localized.\n   In the second example [see Fig. 2(b)], a single\
    \ failure (e.g., fiber\n   cut) affects both directions of the bi-directional\
    \ LSP.  Node 2 (Node\n   3) will detect the failure of the upstream (downstream)\
    \ direction and\n   send a ChannelStatus message to the upstream (in terms of\
    \ data flow)\n   node indicating the failure (e.g., LOL).  Simultaneously (ignoring\n\
    \   propagation delays), Node 1 (Node 4) will detect the failure on the\n   upstream\
    \ (downstream) direction, and will send a ChannelStatus\n   message to the corresponding\
    \ upstream (in terms of data flow) node\n   indicating the failure.  Node 2 and\
    \ Node 3 will have localized the\n   two directions of the failure.\n       +-------+\
    \        +-------+        +-------+        +-------+\n       + Node1 +       \
    \ + Node2 +        + Node3 +        + Node4 +\n       +       +-- c ---+     \
    \  +-- c ---+       +-- c ---+       +\n   ----+---\\   +        +       +   \
    \     +       +        +       +\n   <---+---\\\\--+--------+-------+---\\   \
    \ +       +        +    /--+--->\n       +    \\--+--------+-------+---\\\\---+-------+---##---+---//--+----\n\
    \       +       +        +       +    \\---+-------+--------+---/   +\n      \
    \ +       +        +       +        +       +  (a)   +       +\n   ----+-------+--------+---\\\
    \   +        +       +        +       +\n   <---+-------+--------+---\\\\--+---##---+--\\\
    \    +        +       +\n       +       +        +    \\--+---##---+--\\\\   +\
    \        +       +\n       +       +        +       +  (b)   +   \\\\--+--------+-------+--->\n\
    \       +       +        +       +        +    \\--+--------+-------+----\n  \
    \     +       +        +       +        +       +        +       +\n       +-------+\
    \        +-------+        +-------+        +-------+\n         Figure 2: Two types\
    \ of data link failures are shown (indicated\n         by ## in the figure):\n\
    \         (A) a data link corresponding to the downstream direction of a\n   \
    \          bi-directional LSP fails,\n         (B) two data links corresponding\
    \ to both directions of a bi-\n             directional LSP fail.  The control\
    \ channel connecting two\n             nodes is indicated with a \"c\".\n"
- title: 6.4. Channel Activation Indication
  contents:
  - "6.4. Channel Activation Indication\n   The ChannelStatus message may also be\
    \ used to notify an LMP neighbor\n   that the data link should be actively monitored.\
    \  This is called\n   Channel Activation Indication.  This is particularly useful\
    \ in\n   networks with transparent nodes where the status of data links may\n\
    \   need to be triggered using control channel messages.  For example, if\n  \
    \ a data link is pre-provisioned and the physical link fails after\n   verification\
    \ and before inserting user traffic, a mechanism is needed\n   to indicate the\
    \ data link should be active, otherwise the failure may\n   not be detectable.\n\
    \   The ChannelStatus message is used to indicate that a channel or group\n  \
    \ of channels are now active.  The ChannelStatusAck message MUST be\n   transmitted\
    \ upon receipt of a ChannelStatus message.  When a\n   ChannelStatus message is\
    \ received, the corresponding data link(s)\n   MUST be put into the Active state.\
    \  If upon putting them into the\n   Active state, a failure is detected, the\
    \ ChannelStatus message SHOULD\n   be transmitted as described in Section 6.2.\n"
- title: 6.5.  Channel Deactivation Indication
  contents:
  - "6.5.  Channel Deactivation Indication\n   The ChannelStatus message may also\
    \ be used to notify an LMP neighbor\n   that the data link no longer needs to\
    \ be actively monitored.  This is\n   the counterpart to the Channel Active Indication.\n\
    \   When a ChannelStatus message is received with Channel Deactive\n   Indication,\
    \ the corresponding data link(s) MUST be taken out of the\n   Active state.\n"
- title: 7. Message_Id Usage
  contents:
  - "7. Message_Id Usage\n   The MESSAGE_ID and MESSAGE_ID_ACK objects are included\
    \ in LMP\n   messages to support reliable message delivery.  This section\n  \
    \ describes the usage of these objects.  The MESSAGE_ID and\n   MESSAGE_ID_ACK\
    \ objects contain a Message_Id field.\n   Only one MESSAGE_ID/MESSAGE_ID_ACK object\
    \ may be included in any LMP\n   message.\n   For control-channel-specific messages,\
    \ the Message_Id field is within\n   the scope of the CC_Id.  For TE link specific\
    \ messages, the\n   Message_Id field is within the scope of the LMP adjacency.\n\
    \   The Message_Id field of the MESSAGE_ID object contains a generator-\n   selected\
    \ value.  This value MUST be monotonically increasing.  A\n   value is considered\
    \ to be previously used when it has been sent in an\n   LMP message with the same\
    \ CC_Id (for control channel specific\n   messages) or LMP adjacency (for TE Link\
    \ specific messages).  The\n   Message_Id field of the MESSAGE_ID_ACK object contains\
    \ the Message_Id\n   field of the message being acknowledged.\n   Unacknowledged\
    \ messages sent with the MESSAGE_ID object SHOULD be\n   retransmitted until the\
    \ message is acknowledged or until a retry\n   limit is reached (see also Section\
    \ 10).\n   Note that the 32-bit Message_Id value may wrap.  The following\n  \
    \ expression may be used to test if a newly received Message_Id value\n   is less\
    \ than a previously received value:\n   If ((int) old_id - (int) new_id > 0) {\n\
    \      New value is less than old value;\n   }\n   Nodes processing incoming messages\
    \ SHOULD check to see if a newly\n   received message is out of order and can\
    \ be ignored.  Out-of-order\n   messages can be identified by examining the value\
    \ in the Message_Id\n   field.  If a message is determined to be out-of-order,\
    \ that message\n   should be silently dropped.\n   If the message is a Config\
    \ message, and the Message_Id value is less\n   than the largest Message_Id value\
    \ previously received from the sender\n   for the CC_Id, then the message SHOULD\
    \ be treated as being out-of-\n   order.\n   If the message is a LinkSummary message\
    \ and the Message_Id value is\n   less than the largest Message_Id value previously\
    \ received from the\n   sender for the TE Link, then the message SHOULD be treated\
    \ as being\n   out-of-order.\n   If the message is a ChannelStatus message and\
    \ the Message_Id value is\n   less than the largest Message_Id value previously\
    \ received from the\n   sender for the specified TE link, then the receiver SHOULD\
    \ check the\n   Message_Id value previously received for the state of each data\n\
    \   channel included in the ChannelStatus message.  If the Message_Id\n   value\
    \ is greater than the most recently received Message_Id value\n   associated with\
    \ at least one of the data channels included in the\n   message, the message MUST\
    \ NOT be treated as out of order; otherwise,\n   the message SHOULD be treated\
    \ as being out of order.  However, the\n   state of any data channel MUST NOT\
    \ be updated if the Message_Id value\n   is less than the most recently received\
    \ Message_Id value associated\n   with the data channel.\n   All other messages\
    \ MUST NOT be treated as out-of-order.\n"
- title: 8. Graceful Restart
  contents:
  - "8. Graceful Restart\n   This section describes the mechanism to resynchronize\
    \ the LMP state\n   after a control plane restart.  A control plane restart may\
    \ occur\n   when bringing up the first control channel after a control\n   communications\
    \ failure.  A control communications failure may be the\n   result of an LMP adjacency\
    \ failure or a nodal failure wherein the LMP\n   control state is lost, but the\
    \ data plane is unaffected.  The latter\n   is detected by setting the \"LMP Restart\"\
    \ bit in the Common Header of\n   the LMP messages.  When the control plane fails\
    \ due to the loss of\n   the control channel, the LMP link information should\
    \ be retained.  It\n   is possible that a node may be capable of retaining the\
    \ LMP link\n   information across a nodal failure.  However, in both cases the\n\
    \   status of the data channels MUST be synchronized.\n   It is assumed the Node_Id\
    \ and Local Interface_Ids remain stable\n   across a control plane restart.\n\
    \   After the control plane of a node restarts, the control channel(s)\n   must\
    \ be re-established using the procedures of Section 3.1.  When\n   re-establishing\
    \ control channels, the Config message SHOULD be sent\n   using the unicast IP\
    \ source and destination addresses.\n   If the control plane failure was the result\
    \ of a nodal failure where\n   the LMP control state is lost, then the \"LMP Restart\"\
    \ flag MUST be\n   set in LMP messages until a Hello message is received with\
    \ the\n   RcvSeqNum equal to the local TxSeqNum.  This indicates that the\n  \
    \ control channel is up and the LMP neighbor has detected the restart.\n   The\
    \ following assumes that the LMP component restart only occurred on\n   one end\
    \ of the TE Link.  If the LMP component restart occurred on\n   both ends of the\
    \ TE Link, the normal procedures for LinkSummary\n   should be used, as described\
    \ in Section 4.\n   Once a control channel is up, the LMP neighbor MUST send a\n\
    \   LinkSummary message for each TE Link across the adjacency.  All the\n   objects\
    \ of the LinkSummary message MUST have the N-bit set to 0,\n   indicating that\
    \ the parameters are non-negotiable.  This provides the\n   local/remote Link_Id\
    \ and Interface_Id mappings, the associated data\n   link parameters, and indication\
    \ of which data links are currently\n   allocated to user traffic.  When a node\
    \ receives the LinkSummary\n   message, it checks its local configuration.  If\
    \ the node is capable\n   of retaining the LMP link information across a restart,\
    \ it must\n   process the LinkSummary message as described in Section 4 with the\n\
    \   exception that the allocated/de-allocated flag of the DATA_LINK\n   object\
    \ received in the LinkSummary message MUST take precedence over\n   any local\
    \ value.  If, however, the node was not capable of retaining\n   the LMP link\
    \ information across a restart, the node MUST accept the\n   data link parameters\
    \ of the received LinkSummary message and respond\n   with a LinkSummaryAck message.\n\
    \   Upon completion of the LinkSummary exchange, the node that has\n   restarted\
    \ the control plane SHOULD send a ChannelStatusRequest\n   message for that TE\
    \ link.  The node SHOULD also verify the\n   connectivity of all unallocated data\
    \ channels.\n"
- title: 9. Addressing
  contents:
  - "9. Addressing\n   All LMP messages are run over UDP with an LMP port number (except,\
    \ in\n   some cases, the Test messages, which may be limited by the transport\n\
    \   mechanism for in-band messaging).  The destination address of the IP\n   packet\
    \ MAY be either the address learned in the Configuration\n   procedure (i.e.,\
    \ the Source IP address found in the IP header of the\n   received Config message),\
    \ an IP address configured on the remote\n   node, or the Node_Id.  The Config\
    \ message is an exception as\n   described below.\n   The manner in which a Config\
    \ message is addressed may depend on the\n   signaling transport mechanism.  When\
    \ the transport mechanism is a\n   point-to-point link, Config messages SHOULD\
    \ be sent to the Multicast\n   address (224.0.0.1 or ff02::1).  Otherwise, Config\
    \ messages MUST be\n   sent to an IP address on the neighboring node.  This may\
    \ be\n   configured at both ends of the control channel or may be\n   automatically\
    \ discovered.\n"
- title: 10.  Exponential Back-off Procedures
  contents:
  - "10.  Exponential Back-off Procedures\n   This section is based on [RFC2961] and\
    \ provides exponential back-off\n   procedures for message retransmission.  Implementations\
    \ MUST use the\n   described procedures or their equivalent.\n"
- title: 10.1. Operation
  contents:
  - "10.1. Operation\n   The following operation is one possible mechanism for exponential\n\
    \   back-off retransmission of unacknowledged LMP messages.  The sending\n   node\
    \ retransmits the message until an acknowledgement message is\n   received or\
    \ until a retry limit is reached.  When the sending node\n   receives the acknowledgement,\
    \ retransmission of the message is\n   stopped.  The interval between message\
    \ retransmission is governed by\n   a rapid retransmission timer.  The rapid retransmission\
    \ timer starts\n   at a small interval and increases exponentially until it reaches\
    \ a\n   threshold.\n   The following time parameters are useful to characterize\
    \ the\n   procedures:\n   Rapid retransmission interval Ri:\n      Ri is the initial\
    \ retransmission interval for unacknowledged\n      messages.  After sending the\
    \ message for the first time, the\n      sending node will schedule a retransmission\
    \ after Ri milliseconds.\n   Rapid retry limit Rl:\n      Rl is the maximum number\
    \ of times a message will be transmitted\n      without being acknowledged.\n\
    \   Increment value Delta:\n      Delta governs the speed with which the sender\
    \ increases the\n      retransmission interval.  The ratio of two successive\n\
    \      retransmission intervals is (1 + Delta).\n   Suggested default values for\
    \ an initial retransmission interval (Ri)\n   of 500 ms are a power of 2 exponential\
    \ back-off (Delta = 1) and a\n   retry limit of 3.\n"
- title: 10.2. Retransmission Algorithm
  contents:
  - "10.2. Retransmission Algorithm\n   After a node transmits a message requiring\
    \ acknowledgement, it should\n   immediately schedule a retransmission after Ri\
    \ seconds.  If a\n   corresponding acknowledgement message is received before\
    \ Ri seconds,\n   then message retransmission SHOULD be canceled.  Otherwise,\
    \ it will\n   retransmit the message after (1+Delta)*Ri seconds.  The\n   retransmission\
    \ will continue until either an appropriate\n   acknowledgement message is received\
    \ or the rapid retry limit, Rl, has\n   been reached.\n   A sending node can use\
    \ the following algorithm when transmitting a\n   message that requires acknowledgement:\n\
    \      Prior to initial transmission, initialize Rk = Ri and Rn = 0.\n      while\
    \ (Rn++ < Rl) {\n        transmit the message;\n        wake up after Rk milliseconds;\n\
    \        Rk = Rk * (1 + Delta);\n      }\n      /* acknowledged message or no\
    \ reply from receiver and Rl\n      reached*/\n      do any needed clean up;\n\
    \      exit;\n   Asynchronously, when a sending node receives a corresponding\n\
    \   acknowledgment message, it will change the retry count, Rn, to Rl.\n   Note\
    \ that the transmitting node does not advertise or negotiate the\n   use of the\
    \ described exponential back-off procedures in the Config or\n   LinkSummary messages.\n"
- title: 11.  LMP Finite State Machines
  contents:
  - '11.  LMP Finite State Machines

    '
- title: 11.1.  Control Channel FSM
  contents:
  - "11.1.  Control Channel FSM\n   The control channel FSM defines the states and\
    \ logics of operation of\n   an LMP control channel.\n"
- title: 11.1.1.  Control Channel States
  contents:
  - "11.1.1.  Control Channel States\n   A control channel can be in one of the states\
    \ described below.  Every\n   state corresponds to a certain condition of the\
    \ control channel and\n   is usually associated with a specific type of LMP message\
    \ that is\n   periodically transmitted to the far end.\n   Down:       This is\
    \ the initial control channel state.  In this\n               state, no attempt\
    \ is being made to bring the control\n               channel up and no LMP messages\
    \ are sent.  The control\n               channel parameters should be set to the\
    \ initial values.\n   ConfSnd:    The control channel is in the parameter negotiation\n\
    \               state.  In this state the node periodically sends a\n        \
    \       Config message, and is expecting the other side to reply\n           \
    \    with either a ConfigAck or ConfigNack message.  The FSM\n               does\
    \ not transition into the Active state until the\n               remote side positively\
    \ acknowledges the parameters.\n   ConfRcv:    The control channel is in the parameter\
    \ negotiation\n               state.  In this state, the node is waiting for acceptable\n\
    \               configuration parameters from the remote side.  Once such\n  \
    \             parameters are received and acknowledged, the FSM can\n        \
    \       transition to the Active state.\n   Active:     In this state the node\
    \ periodically sends a Hello message\n               and is waiting to receive\
    \ a valid Hello message.  Once a\n               valid Hello message is received,\
    \ it can transition to the\n               up state.\n   Up:         The CC is\
    \ in an operational state.  The node receives\n               valid Hello messages\
    \ and sends Hello messages.\n   GoingDown:  A CC may go into this state because\
    \ of administrative\n               action.  While a CC is in this state, the\
    \ node sets the\n               ControlChannelDown bit in all the messages it\
    \ sends.\n"
- title: 11.1.2.  Control Channel Events
  contents:
  - "11.1.2.  Control Channel Events\n   Operation of the LMP control channel is described\
    \ in terms of FSM\n   states and events.  Control channel events are generated\
    \ by the\n   underlying protocols and software modules, as well as by the packet\n\
    \   processing routines and FSMs of associated TE links.  Every event has\n  \
    \ its number and a symbolic name.  Description of possible control\n   channel\
    \ events is given below.\n   1 : evBringUp:    This is an externally triggered\
    \ event indicating\n                     that the control channel negotiation\
    \ should begin.\n                     This event, for example, may be triggered\
    \ by an\n                     operator command, by the successful completion of\
    \ a\n                     control channel bootstrap procedure, or by\n       \
    \              configuration.  Depending on the configuration,\n             \
    \        this will trigger either\n                         1a)  the sending of\
    \ a Config message,\n                         1b)  a period of waiting to receive\
    \ a Config\n                              message from the remote node.\n   2\
    \ : evCCDn:       This event is generated when there is indication\n         \
    \            that the control channel is no longer available.\n   3 : evConfDone:\
    \   This event indicates a ConfigAck message has been\n                     received,\
    \ acknowledging the Config parameters.\n   4 : evConfErr:    This event indicates\
    \ a ConfigNack message has been\n                     received, rejecting the\
    \ Config parameters.\n   5 : evNewConfOK:  New Config message was received from\
    \ neighbor and\n                     positively acknowledged.\n   6 : evNewConfErr:\
    \ New Config message was received from neighbor and\n                     rejected\
    \ with a ConfigNack message.\n   7 : evContenWin:  New Config message was received\
    \ from neighbor at\n                     the same time a Config message was sent\
    \ to the\n                     neighbor.  The local node wins the contention.\
    \  As\n                     a result, the received Config message is ignored.\n\
    \   8 : evContenLost: New Config message was received from neighbor at\n     \
    \                the same time a Config message was sent to the\n            \
    \         neighbor.  The local node loses the contention.\n                  \
    \       8a)  The Config message is positively\n                              acknowledged.\n\
    \                         8b)  The Config message is negatively\n            \
    \                  acknowledged.\n   9 : evAdminDown:  The administrator has requested\
    \ that the control\n                     channel is brought down administratively.\n\
    \   10: evNbrGoesDn:  A packet with ControlChannelDown flag is received\n    \
    \                 from the neighbor.\n   11: evHelloRcvd:  A Hello packet with\
    \ expected SeqNum has been\n                     received.\n   12: evHoldTimer:\
    \  The HelloDeadInterval timer has expired indicating\n                     that\
    \ no Hello packet has been received.  This moves\n                     the control\
    \ channel back into the Negotiation\n                     state, and depending\
    \ on the local configuration,\n                     this will trigger either\n\
    \                         12a) the sending of periodic Config messages,\n    \
    \                     12b) a period of waiting to receive Config\n           \
    \                   messages from the remote node.\n   13: evSeqNumErr:  A Hello\
    \ with unexpected SeqNum received and\n                     discarded.\n   14:\
    \ evReconfig:   Control channel parameters have been reconfigured\n          \
    \           and require renegotiation.\n   15: evConfRet:    A retransmission\
    \ timer has expired and a Config\n                     message is resent.\n  \
    \ 16: evHelloRet:   The HelloInterval timer has expired and a Hello\n        \
    \             packet is sent.\n   17: evDownTimer:  A timer has expired and no\
    \ messages have been\n                     received with the ControlChannelDown\
    \ flag set.\n"
- title: 11.1.3.  Control Channel FSM Description
  contents:
  - "11.1.3.  Control Channel FSM Description\n   Figure 3 illustrates operation of\
    \ the control channel FSM in a form\n   of FSM state transition diagram.\n   \
    \                            +--------+\n            +----------------->|    \
    \    |<--------------+\n            |       +--------->|  Down  |<----------+\
    \   |\n            |       |+---------|        |<-------+  |   |\n           \
    \ |       ||         +--------+        |  |   |\n            |       ||      \
    \     |    ^       2,9| 2|  2|\n            |       ||1b       1a|    |      \
    \    |  |   |\n            |       ||           v    |2,9       |  |   |\n   \
    \         |       ||         +--------+        |  |   |\n            |       ||\
    \      +->|        |<------+|  |   |\n            |       ||  4,7,|  |ConfSnd\
    \ |       ||  |   |\n            |       || 14,15+--|        |<----+ ||  |   |\n\
    \            |       ||         +--------+     | ||  |   |\n            |    \
    \   ||       3,8a| |          | ||  |   |\n            |       || +---------+\
    \ |8b  14,12a| ||  |   |\n            |       || |           v          | || \
    \ |   |\n            |       |+-|------>+--------+     | ||  |   |\n         \
    \   |       |  |    +->|        |-----|-|+  |   |\n            |       |  |6,14|\
    \  |ConfRcv |     | |   |   |\n            |       |  |    +--|        |<--+ |\
    \ |   |   |\n            |       |  |       +--------+   | | |   |   |\n     \
    \       |       |  |          5| ^      | | |   |   |\n            |       | \
    \ +---------+ | |      | | |   |   |\n            |       |            | | | \
    \     | | |   |   |\n            |       |            v v |6,12b | | |   |   |\n\
    \            |       |10        +--------+   | | |   |   |\n            |    \
    \   +----------|        |   | | |   |   |\n            |       |       +--| Active\
    \ |---|-+ |   |   |\n       10,17|       |   5,16|  |        |-------|---+   |\n\
    \        +-------+ 9 |   13  +->|        |   |   |       |\n        | Going |<--|----------+--------+\
    \   |   |       |\n        | Down  |   |           11| ^       |   |       |\n\
    \        +-------+   |             | |5      |   |       |\n            ^    \
    \   |             v |  6,12b|   |       |\n            |9      |10        +--------+\
    \   |   |12a,14 |\n            |       +----------|        |---+   |       |\n\
    \            |                  |   Up   |-------+       |\n            +------------------|\
    \        |---------------+\n                               +--------+\n      \
    \                           |   ^\n                                 |   |\n  \
    \                               +---+\n                                11,13,16\n\
    \                       Figure 3: Control Channel FSM\n   Event evCCDn always\
    \ forces the FSM to the down state.  Events\n   evHoldTimer and evReconfig always\
    \ force the FSM to the Negotiation\n   state (either ConfSnd or ConfRcv).\n"
- title: 11.2. TE Link FSM
  contents:
  - "11.2. TE Link FSM\n   The TE Link FSM defines the states and logics of operation\
    \ of the LMP\n   TE Link.\n"
- title: 11.2.1. TE Link States
  contents:
  - "11.2.1. TE Link States\n   An LMP TE link can be in one of the states described\
    \ below.  Every\n   state corresponds to a certain condition of the TE link and\
    \ is\n   usually associated with a specific type of LMP message that is\n   periodically\
    \ transmitted to the far end via the associated control\n   channel or in-band\
    \ via the data links.\n   Down:       There are no data links allocated to the\
    \ TE link.\n   Init:       Data links have been allocated to the TE link, but\
    \ the\n               configuration has not yet been synchronized with the LMP\n\
    \               neighbor.  The LinkSummary message is periodically\n         \
    \      transmitted to the LMP neighbor.\n   Up:         This is the normal operational\
    \ state of the TE link.  At\n               least one LMP control channel is required\
    \ to be\n               operational between the nodes sharing the TE link.  As\n\
    \               part of normal operation, the LinkSummary message may be\n   \
    \            periodically transmitted to the LMP neighbor or generated\n     \
    \          by an external request.\n   Degraded:   In this state, all LMP control\
    \ channels are down, but the\n               TE link still includes some data\
    \ links that are allocated\n               to user traffic.\n"
- title: 11.2.2.  TE Link Events
  contents:
  - "11.2.2.  TE Link Events\n   Operation of the LMP TE link is described in terms\
    \ of FSM states and\n   events.  TE Link events are generated by the packet processing\n\
    \   routines and by the FSMs of the associated control channel(s) and the\n  \
    \ data links.  Every event has its number and a symbolic name.\n   Descriptions\
    \ of possible events are given below.\n   1 : evDCUp:       One or more data channels\
    \ have been enabled and\n                     assigned to the TE Link.\n   2 :\
    \ evSumAck:     LinkSummary message received and positively\n                \
    \     acknowledged.\n   3 : evSumNack:    LinkSummary message received and negatively\n\
    \                     acknowledged.\n   4 : evRcvAck:     LinkSummaryAck message\
    \ received acknowledging the\n                     TE Link Configuration.\n  \
    \ 5 : evRcvNack:    LinkSummaryNack message received.\n   6 : evSumRet:     Retransmission\
    \ timer has expired and LinkSummary\n                     message is resent.\n\
    \   7 : evCCUp:       First active control channel goes up.\n   8 : evCCDown:\
    \     Last active control channel goes down.\n   9 : evDCDown:     Last data channel\
    \ of TE Link has been removed.\n"
- title: 11.2.3.  TE Link FSM Description
  contents:
  - "11.2.3.  TE Link FSM Description\n   Figure 4 illustrates operation of the LMP\
    \ TE Link FSM in a form of\n   FSM state transition diagram.\n               \
    \                   3,7,8\n                                   +--+\n         \
    \                          |  |\n                                   |  v\n   \
    \                             +--------+\n                                |  \
    \      |\n                  +------------>|  Down  |<---------+\n            \
    \      |             |        |          |\n                  |             +--------+\
    \          |\n                  |                |  ^             |\n        \
    \          |               1|  |9            |\n                  |          \
    \      v  |             |\n                  |             +--------+        \
    \  |\n                  |             |        |<-+       |\n                \
    \  |             |  Init  |  |3,5,6  |9\n                  |             |   \
    \     |--+ 7,8   |\n                 9|             +--------+          |\n  \
    \                |                  |              |\n                  |    \
    \           2,4|              |\n                  |                  v      \
    \        |\n               +--------+   7   +--------+          |\n          \
    \     |        |------>|        |----------+\n               |  Deg   |      \
    \ |   Up   |\n               |        |<------|        |\n               +--------+\
    \   8   +--------+\n                                   |  ^\n                \
    \                   |  |\n                                   +--+\n          \
    \                       2,3,4,5,6\n                       Figure 4: LMP TE Link\
    \ FSM\n   In the above FSM, the sub-states that may be implemented when the\n\
    \   link verification procedure is used have been omitted.\n"
- title: 11.3.  Data Link FSM
  contents:
  - "11.3.  Data Link FSM\n   The data link FSM defines the states and logics of operation\
    \ of a\n   data link within an LMP TE link.  Operation of a data link is\n   described\
    \ in terms of FSM states and events.  Data links can either\n   be in the active\
    \ (transmitting) mode, where Test messages are\n   transmitted from them, or the\
    \ passive (receiving) mode, where Test\n   messages are received through them.\
    \  For clarity, separate FSMs are\n   defined for the active/passive data links;\
    \ however, a single set of\n   data link states and events are defined.\n"
- title: 11.3.1.  Data Link States
  contents:
  - "11.3.1.  Data Link States\n   Any data link can be in one of the states described\
    \ below.  Every\n   state corresponds to a certain condition of the data link.\n\
    \   Down:          The data link has not been put in the resource pool\n     \
    \             (i.e., the link is not 'in service')\n   Test:          The data\
    \ link is being tested.  An LMP Test message is\n                  periodically\
    \ sent through the link.\n   PasvTest:      The data link is being checked for\
    \ incoming test\n                  messages.\n   Up/Free:       The link has been\
    \ successfully tested and is now put\n                  in the pool of resources\
    \ (in-service).  The link has\n                  not yet been allocated to data\
    \ traffic.\n   Up/Alloc:      The link is up and has been allocated for data\n\
    \                  traffic.\n"
- title: 11.3.2.  Data Link Events
  contents:
  - "11.3.2.  Data Link Events\n   Data link events are generated by the packet processing\
    \ routines and\n   by the FSMs of the associated control channel and the TE link.\n\
    \   Every event has its number and a symbolic name.  Description of\n   possible\
    \ data link events is given below:\n   1 :evCCUp:         First active control\
    \ channel goes up.\n   2 :evCCDown:       LMP neighbor connectivity is lost. \
    \ This indicates\n                      the last LMP control channel has failed\
    \ between\n                      neighboring nodes.\n   3 :evStartTst:     This\
    \ is an external event that triggers the\n                      sending of Test\
    \ messages over the data link.\n   4 :evStartPsv:     This is an external event\
    \ that triggers the\n                      listening for Test messages over the\
    \ data link.\n   5 :evTestOK:       Link verification was successful and the link\
    \ can\n                      be used for path establishment.\n               \
    \          (a)  This event indicates the Link Verification\n                 \
    \             procedure (see Section 5) was successful\n                     \
    \         for this data link and a TestStatusSuccess\n                       \
    \       message was received over the control\n                              channel.\n\
    \                         (b)  This event indicates the link is ready for\n  \
    \                            path establishment, but the Link\n              \
    \                Verification procedure was not used.  For\n                 \
    \             in-band signaling of the control channel,\n                    \
    \          the control channel establishment may be\n                        \
    \      sufficient to verify the link.\n   6 :evTestRcv:      Test message was\
    \ received over the data port and a\n                      TestStatusSuccess message\
    \ is transmitted over the\n                      control channel.\n   7 :evTestFail:\
    \     Link verification returned negative results.  This\n                   \
    \   could be because (a) a TestStatusFailure message\n                      was\
    \ received, or (b) the Verification procedure\n                      has ended\
    \ without receiving a TestStatusSuccess or\n                      TestStatusFailure\
    \ message for the data link.\n   8 :evPsvTestFail:  Link verification returned\
    \ negative results.  This\n                      indicates that a Test message\
    \ was not detected and\n                      either (a) the VerifyDeadInterval\
    \ has expired or\n                      (b) the Verification procedure has ended\
    \ and the\n                      VerifyDeadInterval has not yet expired.\n   9\
    \ :evLnkAlloc:     The data link has been allocated.\n   10:evLnkDealloc:   The\
    \ data link has been de-allocated.\n   11:evTestRet:      A retransmission timer\
    \ has expired and the Test\n                      message is resent.\n   12:evSummaryFail:\
    \  The LinkSummary did not match for this data port.\n   13:evLocalizeFail: A\
    \ Failure has been localized to this data link.\n   14:evdcDown:      The data\
    \ channel is no longer available.\n"
- title: 11.3.3.  Active Data Link FSM Description
  contents:
  - "11.3.3.  Active Data Link FSM Description\n   Figure 5 illustrates operation\
    \ of the LMP active data link FSM in a\n   form of FSM state transition diagram.\n\
    \                             +------+\n                             |      |<-------+\n\
    \                  +--------->| Down |        |\n                  |     +----|\
    \      |<-----+ |\n                  |     |    +------+      | |\n          \
    \        |     |5b   3|  ^        | |\n                  |     |      |  |7  \
    \     | |\n                  |     |      v  |        | |\n                  |\
    \     |    +------+      | |\n                  |     |    |      |<-+   | |\n\
    \                  |     |    | Test |  |11 | |\n                  |     |   \
    \ |      |--+   | |\n                  |     |    +------+      | |\n        \
    \          |     |     5a| 3^       | |\n                  |     |       |  |\
    \       | |\n                  |     |       v  |       | |\n                \
    \  |12   |   +---------+    | |\n                  |     +-->|         |14  |\
    \ |\n                  |         | Up/Free |----+ |\n                  +---------|\
    \         |      |\n                            +---------+      |\n         \
    \                      9| ^          |\n                                | |  \
    \        |\n                                v |10        |\n                 \
    \           +---------+      |\n                            |         |13    |\n\
    \                            |Up/Alloc |------+\n                            |\
    \         |\n                            +---------+\n                    Figure\
    \ 5: Active LMP Data Link FSM\n"
- title: 11.3.4.  Passive Data Link FSM Description
  contents:
  - "11.3.4.  Passive Data Link FSM Description\n   Figure 6 illustrates operation\
    \ of the LMP passive data link FSM in a\n   form of FSM state transition diagram.\n\
    \                             +------+\n                             |      |<------+\n\
    \                 +---------->| Down |       |\n                 |     +-----|\
    \      |<----+ |\n                 |     |     +------+     | |\n            \
    \     |     |5b    4|  ^       | |\n                 |     |       |  |8     \
    \ | |\n                 |     |       v  |       | |\n                 |     |\
    \    +----------+  | |\n                 |     |    | PasvTest |  | |\n      \
    \           |     |    +----------+  | |\n                 |     |       6|  4^\
    \     | |\n                 |     |        |   |     | |\n                 | \
    \    |        v   |     | |\n                 |12   |    +---------+   | |\n \
    \                |     +--->| Up/Free |14 | |\n                 |          | \
    \        |---+ |\n                 +----------|         |     |\n            \
    \                +---------+     |\n                                9| ^     \
    \   |\n                                 | |        |\n                       \
    \          v |10      |\n                            +---------+     |\n     \
    \                       |         |13   |\n                            |Up/Alloc\
    \ |-----+\n                            |         |\n                         \
    \   +---------+\n                    Figure 6: Passive LMP Data Link FSM\n"
- title: 12.  LMP Message Formats
  contents:
  - "12.  LMP Message Formats\n   All LMP messages (except, in some cases, the Test\
    \ messages, which are\n   limited by the transport mechanism for in-band messaging)\
    \ are run\n   over UDP with an LMP port number (701).\n"
- title: 12.1.  Common Header
  contents:
  - "12.1.  Common Header\n   In addition to the UDP header and standard IP header,\
    \ all LMP\n   messages (except, in some cases, the Test messages which may be\n\
    \   limited by the transport mechanism for in-band messaging) have the\n   following\
    \ common header:\n    0                   1                   2              \
    \     3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n\
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   | Vers\
    \  |      (Reserved)       |    Flags      |    Msg Type   |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |          LMP Length           |          (Reserved)           |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   The Reserved field should be sent as zero and ignored on receipt.\n   All\
    \ values are defined in network byte order (i.e., big-endian byte\n   order).\n\
    \   Vers: 4 bits\n      Protocol version number.  This is version 1.\n   Flags:\
    \ 8 bits\n      The following bit-values are defined.  All other bits are reserved\n\
    \      and should be sent as zero and ignored on receipt.\n      0x01: ControlChannelDown\n\
    \      0x02: LMP Restart\n         This bit is set to indicate that a nodal failure\
    \ has occurred\n         and the LMP control state has been lost.  This flag may\
    \ be\n         reset to 0 when a Hello message is received with RcvSeqNum\n  \
    \       equal to the local TxSeqNum.\n   Msg Type: 8 bits\n      The following\
    \ values are defined.  All other values are reserved\n      1  = Config\n    \
    \  2  = ConfigAck\n      3  = ConfigNack\n      4  = Hello\n      5  = BeginVerify\n\
    \      6  = BeginVerifyAck\n      7  = BeginVerifyNack\n      8  = EndVerify\n\
    \      9  = EndVerifyAck\n      10 = Test\n      11 = TestStatusSuccess\n    \
    \  12 = TestStatusFailure\n      13 = TestStatusAck\n      14 = LinkSummary\n\
    \      15 = LinkSummaryAck\n      16 = LinkSummaryNack\n      17 = ChannelStatus\n\
    \      18 = ChannelStatusAck\n      19 = ChannelStatusRequest\n      20 = ChannelStatusResponse\n\
    \      All of the messages are sent over the control channel EXCEPT the\n    \
    \  Test message, which is sent over the data link that is being\n      tested.\n\
    \   LMP Length: 16 bits\n      The total length of this LMP message in bytes,\
    \ including the\n      common header and any variable-length objects that follow.\n"
- title: 12.2.  LMP Object Format
  contents:
  - "12.2.  LMP Object Format\n   LMP messages are built using objects.  Each object\
    \ is identified by\n   its Object Class and Class-type.  Each object has a name,\
    \ which is\n   always capitalized in this document.  LMP objects can be either\n\
    \   negotiable or non-negotiable (identified by the N bit in the object\n   header).\
    \  Negotiable objects can be used to let the devices agree on\n   certain values.\
    \  Non-negotiable objects are used for announcement of\n   specific values that\
    \ do not need or do not allow negotiation.\n   All values are defined in network\
    \ byte order (i.e., big-endian byte\n   order).\n   The format of the LMP object\
    \ is as follows:\n    0                   1                   2              \
    \     3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n\
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   |N|\
    \   C-Type    |     Class     |            Length             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                                                               |\n   // \
    \                      (object contents)                     //\n   |        \
    \                                                       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   N: 1 bit\n      The N flag indicates if the object is negotiable (N=1) or\
    \ non-\n      negotiable (N=0).\n   C-Type: 7 bits\n      Class-type, unique within\
    \ an Object Class.  Values are defined in\n      Section 13.\n   Class: 8 bits\n\
    \      The Class indicates the object type.  Each object has a name,\n      which\
    \ is always capitalized in this document.\n   Length: 16 bits\n      The Length\
    \ field indicates the length of the object in bytes,\n      including the N, C-Type,\
    \ Class, and Length fields.\n"
- title: 12.3.  Parameter Negotiation Messages
  contents:
  - '12.3.  Parameter Negotiation Messages

    '
- title: 12.3.1.  Config Message (Msg Type = 1)
  contents:
  - "12.3.1.  Config Message (Msg Type = 1)\n   The Config message is used in the\
    \ control channel negotiation phase\n   of LMP.  The contents of the Config message\
    \ are built using LMP\n   objects.  The format of the Config message is as follows:\n\
    \   <Config Message> ::= <Common Header> <LOCAL_CCID> <MESSAGE_ID>\n         \
    \               <LOCAL_NODE_ID> <CONFIG>\n   The above transmission order SHOULD\
    \ be followed.\n   The MESSAGE_ID object is within the scope of the LOCAL_CCID\
    \ object.\n   The Config message MUST be periodically transmitted until (1) it\n\
    \   receives a ConfigAck or ConfigNack message, (2) a retry limit has\n   been\
    \ reached and no ConfigAck or ConfigNack message has been\n   received, or (3)\
    \ it receives a Config message from the remote node\n   and has lost the contention\
    \ (e.g., the Node_Id of the remote node is\n   higher than the Node_Id of the\
    \ local node).  Both the retransmission\n   interval and the retry limit are local\
    \ configuration parameters.\n"
- title: 12.3.2.  ConfigAck Message (Msg Type = 2)
  contents:
  - "12.3.2.  ConfigAck Message (Msg Type = 2)\n   The ConfigAck message is used to\
    \ acknowledge receipt of the Config\n   message and indicate agreement on all\
    \ parameters.\n   <ConfigAck Message> ::= <Common Header> <LOCAL_CCID> <LOCAL_NODE_ID>\n\
    \                           <REMOTE_CCID> <MESSAGE_ID_ACK>\n                 \
    \          <REMOTE_NODE_ID>\n   The above transmission order SHOULD be followed.\n\
    \   The contents of the REMOTE_CCID, MESSAGE_ID_ACK, and REMOTE_NODE_ID\n   objects\
    \ MUST be obtained from the Config message being acknowledged.\n"
- title: 12.3.3.  ConfigNack Message (Msg Type = 3)
  contents:
  - "12.3.3.  ConfigNack Message (Msg Type = 3)\n   The ConfigNack message is used\
    \ to acknowledge receipt of the Config\n   message and indicate disagreement on\
    \ non-negotiable parameters or\n   propose other values for negotiable parameters.\
    \  Parameters where\n   agreement was reached MUST NOT be included in the ConfigNack\
    \ Message.\n   The format of the ConfigNack message is as follows:\n   <ConfigNack\
    \ Message> ::= <Common Header> <LOCAL_CCID>\n                            <LOCAL_NODE_ID>\
    \  <REMOTE_CCID>\n                            <MESSAGE_ID_ACK> <REMOTE_NODE_ID>\
    \ <CONFIG>\n   The above transmission order SHOULD be followed.\n   The contents\
    \ of the REMOTE_CCID, MESSAGE_ID_ACK, and REMOTE_NODE_ID\n   objects MUST be obtained\
    \ from the Config message being negatively\n   acknowledged.\n   It is possible\
    \ that multiple parameters may be invalid in the Config\n   message.\n   If a\
    \ negotiable CONFIG object is included in the ConfigNack message,\n   it MUST\
    \ include acceptable values for the parameters.\n   If the ConfigNack message\
    \ includes CONFIG objects for non-negotiable\n   parameters, they MUST be copied\
    \ from the CONFIG objects received in\n   the Config message.\n   If the ConfigNack\
    \ message is received and only includes CONFIG\n   objects that are negotiable,\
    \ then a new Config message SHOULD be\n   sent.  The values in the CONFIG object\
    \ of the new Config message\n   SHOULD take into account the acceptable values\
    \ included in the\n   ConfigNack message.\n   If a node receives a Config message\
    \ and recognizes the CONFIG object,\n   but does not recognize the C-Type, a ConfigNack\
    \ message including the\n   unknown CONFIG object MUST be sent.\n"
- title: 12.4.  Hello Message (Msg Type = 4)
  contents:
  - "12.4.  Hello Message (Msg Type = 4)\n   The format of the Hello message is as\
    \ follows:\n   <Hello Message> ::= <Common Header> <LOCAL_CCID> <HELLO>\n   The\
    \ above transmission order SHOULD be followed.\n   The Hello message MUST be periodically\
    \ transmitted at least once\n   every HelloInterval msec.  If no Hello message\
    \ is received within the\n   HelloDeadInterval, the control channel is assumed\
    \ to have failed.\n"
- title: 12.5.  Link Verification Messages
  contents:
  - '12.5.  Link Verification Messages

    '
- title: 12.5.1.  BeginVerify Message (Msg Type = 5)
  contents:
  - "12.5.1.  BeginVerify Message (Msg Type = 5)\n   The BeginVerify message is sent\
    \ over the control channel and is used\n   to initiate the link verification process.\
    \  The format is as follows:\n   <BeginVerify Message> ::= <Common Header> <LOCAL_LINK_ID>\n\
    \                             <MESSAGE_ID> [<REMOTE_LINK_ID>]\n              \
    \               <BEGIN_VERIFY>\n   The above transmission order SHOULD be followed.\n\
    \   To limit the scope of Link Verification to a particular TE Link, the\n   Link_Id\
    \ field of the LOCAL_LINK_ID object MUST be non-zero.  If this\n   field is zero,\
    \ the data links can span multiple TE links and/or they\n   may comprise a TE\
    \ link that is yet to be configured.  In the special\n   case where the local\
    \ Link_Id field is zero, the \"Verify all Links\"\n   flag of the BEGIN_VERIFY\
    \ object is used to distinguish between data\n   links that span multiple TE links\
    \ and those that have not yet been\n   assigned to a TE link (see Section 5).\n\
    \   The REMOTE_LINK_ID object may be included if the local/remote Link_Id\n  \
    \ mapping is known.\n   The Link_Id field of the REMOTE_LINK_ID object MUST be\
    \ non-zero if\n   included.\n   The BeginVerify message MUST be periodically transmitted\
    \ until (1)\n   the node receives either a BeginVerifyAck or BeginVerifyNack message\n\
    \   to accept or reject the verify process or (2) a retry limit has been\n   reached\
    \ and no BeginVerifyAck or BeginVerifyNack message has been\n   received.  Both\
    \ the retransmission interval and the retry limit are\n   local configuration\
    \ parameters.\n"
- title: 12.5.2.  BeginVerifyAck Message (Msg Type = 6)
  contents:
  - "12.5.2.  BeginVerifyAck Message (Msg Type = 6)\n   When a BeginVerify message\
    \ is received and Test messages are ready to\n   be processed, a BeginVerifyAck\
    \ message MUST be transmitted.\n   <BeginVerifyAck Message> ::= <Common Header>\
    \ [<LOCAL_LINK_ID>]\n                                <MESSAGE_ID_ACK> <BEGIN_VERIFY_ACK>\n\
    \                                <VERIFY_ID>\n   The above transmission order\
    \ SHOULD be followed.\n   The LOCAL_LINK_ID object may be included if the local/remote\
    \ Link_Id\n   mapping is known or learned through the BeginVerify message.\n \
    \  The Link_Id field of the LOCAL_LINK_ID MUST be non-zero if included.\n   The\
    \ contents of the MESSAGE_ID_ACK object MUST be obtained from the\n   BeginVerify\
    \ message being acknowledged.\n   The VERIFY_ID object contains a node-unique\
    \ value that is assigned by\n   the generator of the BeginVerifyAck message. \
    \ This value is used to\n   uniquely identify the Verification process from multiple\
    \ LMP\n   neighbors and/or parallel Test procedures between the same LMP\n   neighbors.\n"
- title: 12.5.3.  BeginVerifyNack Message (Msg Type = 7)
  contents:
  - "12.5.3.  BeginVerifyNack Message (Msg Type = 7)\n   If a BeginVerify message\
    \ is received and a node is unwilling or\n   unable to begin the Verification\
    \ procedure, a BeginVerifyNack message\n   MUST be transmitted.\n   <BeginVerifyNack\
    \ Message> ::= <Common Header> [<LOCAL_LINK_ID>]\n                           \
    \      <MESSAGE_ID_ACK> <ERROR_CODE>\n   The above transmission order SHOULD be\
    \ followed.\n   The contents of the MESSAGE_ID_ACK object MUST be obtained from\
    \ the\n   BeginVerify message being negatively acknowledged.\n   If the Verification\
    \ process is not supported, the ERROR_CODE MUST\n   indicate \"Link Verification\
    \ Procedure not supported\".\n   If Verification is supported, but the node is\
    \ unable to begin the\n   procedure, the ERROR_CODE MUST indicate \"Unwilling\
    \ to verify\".  If a\n   BeginVerifyNack message is received with such an ERROR_CODE,\
    \ the node\n   that originated the BeginVerify SHOULD schedule a BeginVerify\n\
    \   retransmission after Rf seconds, where Rf is a locally defined\n   parameter.\n\
    \   If the Verification Transport mechanism is not supported, the\n   ERROR_CODE\
    \ MUST indicate \"Unsupported verification transport\n   mechanism\".\n   If remote\
    \ configuration of the Link_Id is not supported and the\n   content of the REMOTE_LINK_ID\
    \ object (included in the BeginVerify\n   message) does not match any configured\
    \ values, the ERROR_CODE MUST\n   indicate \"Link_Id configuration error\".\n\
    \   If a node receives a BeginVerify message and recognizes the\n   BEGIN_VERIFY\
    \ object but does not recognize the C-Type, the ERROR_CODE\n   MUST indicate \"\
    Unknown object C-Type\".\n"
- title: 12.5.4.  EndVerify Message (Msg Type = 8)
  contents:
  - "12.5.4.  EndVerify Message (Msg Type = 8)\n   The EndVerify message is sent over\
    \ the control channel and is used to\n   terminate the link verification process.\
    \  The EndVerify message may\n   be sent any time the initiating node desires\
    \ to end the Verify\n   procedure.  The format is as follows:\n   <EndVerify Message>\
    \ ::=<Common Header> <MESSAGE_ID> <VERIFY_ID>\n   The above transmission order\
    \ SHOULD be followed.\n   The EndVerify message will be periodically transmitted\
    \ until (1) an\n   EndVerifyAck message has been received or (2) a retry limit\
    \ has been\n   reached and no EndVerifyAck message has been received.  Both the\n\
    \   retransmission interval and the retry limit are local configuration\n   parameters.\n"
- title: 12.5.5.  EndVerifyAck Message (Msg Type =9)
  contents:
  - "12.5.5.  EndVerifyAck Message (Msg Type =9)\n   The EndVerifyAck message is sent\
    \ over the control channel and is used\n   to acknowledge the termination of the\
    \ link verification process.  The\n   format is as follows:\n   <EndVerifyAck\
    \ Message> ::= <Common Header> <MESSAGE_ID_ACK>\n                            \
    \  <VERIFY_ID>\n   The above transmission order SHOULD be followed.\n   The contents\
    \ of the MESSAGE_ID_ACK object MUST be obtained from the\n   EndVerify message\
    \ being acknowledged.\n"
- title: 12.5.6.  Test Message (Msg Type = 10)
  contents:
  - "12.5.6.  Test Message (Msg Type = 10)\n   The Test message is transmitted over\
    \ the data link and is used to\n   verify its physical connectivity.  Unless explicitly\
    \ stated, these\n   messages MUST be transmitted over UDP like all other LMP messages.\n\
    \   The format of the Test messages is as follows:\n   <Test Message> ::= <Common\
    \ Header> <LOCAL_INTERFACE_ID> <VERIFY_ID>\n   The above transmission order SHOULD\
    \ be followed.\n   Note that this message is sent over a data link and NOT over\
    \ the\n   control channel.  The transport mechanism for the Test message is\n\
    \   negotiated using the Verify Transport Mechanism field of the\n   BEGIN_VERIFY\
    \ object and the Verify Transport Response field of the\n   BEGIN_VERIFY_ACK object\
    \ (see Sections 13.8 and 13.9).\n   The local (transmitting) node sends a given\
    \ Test message periodically\n   (at least once every VerifyInterval ms) on the\
    \ corresponding data\n   link until (1) it receives a correlating TestStatusSuccess\
    \ or\n   TestStatusFailure message on the control channel from the remote\n  \
    \ (receiving) node or (2) all active control channels between the two\n   nodes\
    \ have failed.  The remote node will send a given TestStatus\n   message periodically\
    \ over the control channel until it receives\n   either a correlating TestStatusAck\
    \ message or an EndVerify message.\n"
- title: 12.5.7.  TestStatusSuccess Message (Msg Type = 11)
  contents:
  - "12.5.7.  TestStatusSuccess Message (Msg Type = 11)\n   The TestStatusSuccess\
    \ message is transmitted over the control channel\n   and is used to transmit\
    \ the mapping between the local Interface_Id\n   and the Interface_Id that was\
    \ received in the Test message.\n   <TestStatusSuccess Message> ::= <Common Header>\
    \ <LOCAL_LINK_ID>\n                                   <MESSAGE_ID> <LOCAL_INTERFACE_ID>\n\
    \                                   <REMOTE_INTERFACE_ID> <VERIFY_ID>\n   The\
    \ above transmission order SHOULD be followed.\n   The contents of the REMOTE_INTERFACE_ID\
    \ object MUST be obtained from\n   the corresponding Test message being positively\
    \ acknowledged.\n"
- title: 12.5.8.  TestStatusFailure Message (Msg Type = 12)
  contents:
  - "12.5.8.  TestStatusFailure Message (Msg Type = 12)\n   The TestStatusFailure\
    \ message is transmitted over the control channel\n   and is used to indicate\
    \ that the Test message was not received.\n   <TestStatusFailure Message> ::=\
    \ <Common Header> <MESSAGE_ID>\n                                   <VERIFY_ID>\n\
    \   The above transmission order SHOULD be followed.\n"
- title: 12.5.9.  TestStatusAck Message (Msg Type = 13)
  contents:
  - "12.5.9.  TestStatusAck Message (Msg Type = 13)\n   The TestStatusAck message\
    \ is used to acknowledge receipt of the\n   TestStatusSuccess or TestStatusFailure\
    \ messages.\n   <TestStatusAck Message> ::= <Common Header> <MESSAGE_ID_ACK>\n\
    \                               <VERIFY_ID>\n   The above transmission order SHOULD\
    \ be followed.\n   The contents of the MESSAGE_ID_ACK object MUST be obtained\
    \ from the\n   TestStatusSuccess or TestStatusFailure message being acknowledged.\n"
- title: 12.6.  Link Summary Messages
  contents:
  - '12.6.  Link Summary Messages

    '
- title: 12.6.1.  LinkSummary Message (Msg Type = 14)
  contents:
  - "12.6.1.  LinkSummary Message (Msg Type = 14)\n   The LinkSummary message is used\
    \ to synchronize the Interface_Ids and\n   correlate the properties of the TE\
    \ link.  The format of the\n   LinkSummary message is as follows:\n   <LinkSummary\
    \ Message> ::= <Common Header> <MESSAGE_ID> <TE_LINK>\n                      \
    \       <DATA_LINK> [<DATA_LINK>...]\n   The above transmission order SHOULD be\
    \ followed.\n   The LinkSummary message can be exchanged any time a link is not\
    \ in\n   the Verification process.  The LinkSummary message MUST be\n   periodically\
    \ transmitted until (1) the node receives a LinkSummaryAck\n   or LinkSummaryNack\
    \ message or (2) a retry limit has been reached and\n   no LinkSummaryAck or LinkSummaryNack\
    \ message has been received.  Both\n   the retransmission interval and the retry\
    \ limit are local\n   configuration parameters.\n"
- title: 12.6.2.  LinkSummaryAck Message (Msg Type = 15)
  contents:
  - "12.6.2.  LinkSummaryAck Message (Msg Type = 15)\n   The LinkSummaryAck message\
    \ is used to indicate agreement on the\n   Interface_Id synchronization and acceptance/agreement\
    \ on all the link\n   parameters.  It is on the reception of this message that\
    \ the local\n   node makes the Link_Id associations.\n   <LinkSummaryAck Message>\
    \ ::=  <Common Header> <MESSAGE_ID_ACK>\n   The above transmission order SHOULD\
    \ be followed.\n"
- title: 12.6.3.  LinkSummaryNack Message (Msg Type = 16)
  contents:
  - "12.6.3.  LinkSummaryNack Message (Msg Type = 16)\n   The LinkSummaryNack message\
    \ is used to indicate disagreement on non-\n   negotiated parameters or propose\
    \ other values for negotiable\n   parameters.  Parameters on which agreement was\
    \ reached MUST NOT be\n   included in the LinkSummaryNack message.\n   <LinkSummaryNack\
    \ Message> ::= <Common Header> <MESSAGE_ID_ACK>\n                            \
    \     <ERROR_CODE> [<DATA_LINK>...]\n   The above transmission order SHOULD be\
    \ followed.\n   The DATA_LINK objects MUST include acceptable values for all\n\
    \   negotiable parameters.  If the LinkSummaryNack includes DATA_LINK\n   objects\
    \ for non-negotiable parameters, they MUST be copied from the\n   DATA_LINK objects\
    \ received in the LinkSummary message.\n   If the LinkSummaryNack message is received\
    \ and only includes\n   negotiable parameters, then a new LinkSummary message\
    \ SHOULD be sent.\n   The values received in the new LinkSummary message SHOULD\
    \ take into\n   account the acceptable parameters included in the LinkSummaryNack\n\
    \   message.\n   If the LinkSummary message is received with unacceptable, non-\n\
    \   negotiable parameters, the ERROR_CODE MUST indicate \"Unacceptable\n   non-negotiable\
    \ LINK_SUMMARY parameters.\"\n   If the LinkSummary message is received with unacceptable\
    \ negotiable\n   parameters, the ERROR_CODE MUST indicate \"Renegotiate LINK_SUMMARY\n\
    \   parameters.\"\n   If the LinkSummary message is received with an invalid TE_LINK\n\
    \   object, the ERROR_CODE MUST indicate \"Invalid TE_LINK object.\"\n   If the\
    \ LinkSummary message is received with an invalid DATA_LINK\n   object, the ERROR_CODE\
    \ MUST indicate \"Invalid DATA_LINK object.\"\n   If the LinkSummary message is\
    \ received with a TE_LINK object but the\n   C-Type is unknown, the ERROR_CODE\
    \ MUST indicate, \"Unknown TE_LINK\n   object C-Type.\"\n   If the LinkSummary\
    \ message is received with a DATA_LINK object but\n   the C-Type is unknown, the\
    \ ERROR_CODE MUST indicate, \"Unknown\n   DATA_LINK object C-Type.\"\n"
- title: 12.7.  Fault Management Messages
  contents:
  - '12.7.  Fault Management Messages

    '
- title: 12.7.1.  ChannelStatus Message (Msg Type = 17)
  contents:
  - "12.7.1.  ChannelStatus Message (Msg Type = 17)\n   The ChannelStatus message\
    \ is sent over the control channel and is\n   used to notify an LMP neighbor of\
    \ the status of a data link.  A node\n   that receives a ChannelStatus message\
    \ MUST respond with a\n   ChannelStatusAck message.  The format is as follows:\n\
    \   <ChannelStatus Message> ::= <Common Header> <LOCAL_LINK_ID>\n            \
    \                   <MESSAGE_ID> <CHANNEL_STATUS>\n   The above transmission order\
    \ SHOULD be followed.\n   If the CHANNEL_STATUS object does not include any Interface_Ids,\
    \ then\n   this indicates the entire TE Link has failed.\n"
- title: 12.7.2.  ChannelStatusAck Message (Msg Type = 18)
  contents:
  - "12.7.2.  ChannelStatusAck Message (Msg Type = 18)\n   The ChannelStatusAck message\
    \ is used to acknowledge receipt of the\n   ChannelStatus Message.  The format\
    \ is as follows:\n   <ChannelStatusAck Message> ::= <Common Header> <MESSAGE_ID_ACK>\n\
    \   The above transmission order SHOULD be followed.\n   The contents of the MESSAGE_ID_ACK\
    \ object MUST be obtained from the\n   ChannelStatus message being acknowledged.\n"
- title: 12.7.3.  ChannelStatusRequest Message (Msg Type = 19)
  contents:
  - "12.7.3.  ChannelStatusRequest Message (Msg Type = 19)\n   The ChannelStatusRequest\
    \ message is sent over the control channel and\n   is used to request the status\
    \ of one or more data link(s).  A node\n   that receives a ChannelStatusRequest\
    \ message MUST respond with a\n   ChannelStatusResponse message.  The format is\
    \ as follows:\n   <ChannelStatusRequest Message> ::= <Common Header> <LOCAL_LINK_ID>\n\
    \                                      <MESSAGE_ID>\n                        \
    \              [<CHANNEL_STATUS_REQUEST>]\n   The above transmission order SHOULD\
    \ be followed.\n   If the CHANNEL_STATUS_REQUEST object is not included, then\
    \ the\n   ChannelStatusRequest is being used to request the status of ALL of\n\
    \   the data link(s) of the TE Link.\n"
- title: 12.7.4.  ChannelStatusResponse Message (Msg Type = 20)
  contents:
  - "12.7.4.  ChannelStatusResponse Message (Msg Type = 20)\n   The ChannelStatusResponse\
    \ message is used to acknowledge receipt of\n   the ChannelStatusRequest Message\
    \ and notify the LMP neighbor of the\n   status of the data channel(s).  The format\
    \ is as follows:\n   <ChannelStatusResponse Message> ::= <Common Header> <MESSAGE_ID_ACK>\n\
    \                                       <CHANNEL_STATUS>\n   The above transmission\
    \ order SHOULD be followed.\n   The contents of the MESSAGE_ID_ACK objects MUST\
    \ be obtained from the\n   ChannelStatusRequest message being acknowledged.\n"
- title: 13.  LMP Object Definitions
  contents:
  - '13.  LMP Object Definitions

    '
- title: 13.1.  CCID (Control Channel ID) Class
  contents:
  - "13.1.  CCID (Control Channel ID) Class\n   Class = 1\n   o    C-Type = 1, LOCAL_CCID\n\
    \    0                   1                   2                   3\n    0 1 2\
    \ 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                            CC_Id                              |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   CC_Id:  32 bits\n      This MUST be node-wide unique and non-zero.  The CC_Id\
    \ identifies\n      the control channel of the sender associated with the message.\n\
    \   This object is non-negotiable.\n   o    C-Type = 2, REMOTE_CCID\n    0   \
    \                1                   2                   3\n    0 1 2 3 4 5 6\
    \ 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                             CC_Id                             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   CC_Id:  32 bits\n      This identifies the remote node's CC_Id and MUST be\
    \ non-zero.\n   This object is non-negotiable.\n"
- title: 13.2.  NODE_ID Class
  contents:
  - "13.2.  NODE_ID Class\n   Class = 2\n   o    C-Type = 1, LOCAL_NODE_ID\n    0\
    \                   1                   2                   3\n    0 1 2 3 4 5\
    \ 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                        Node_Id (4 bytes)                      |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   Node_Id:\n      This identities the node that originated the LMP packet.\n\
    \   This object is non-negotiable.\n   o    C-Type = 2, REMOTE_NODE_ID\n    0\
    \                   1                   2                   3\n    0 1 2 3 4 5\
    \ 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                        Node_Id (4 bytes)                      |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   Node_Id:\n      This identities the remote node.\n   This object is non-negotiable.\n"
- title: 13.3.  LINK_ID Class
  contents:
  - "13.3.  LINK_ID Class\n   Class = 3\n   o    C-Type = 1, IPv4 LOCAL_LINK_ID\n\
    \   o    C-Type = 2, IPv4 REMOTE_LINK_ID\n    0                   1          \
    \         2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0\
    \ 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                        Link_Id (4 bytes)                      |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   o    C-Type = 3, IPv6 LOCAL_LINK_ID\n   o    C-Type = 4, IPv6 REMOTE_LINK_ID\n\
    \    0                   1                   2                   3\n    0 1 2\
    \ 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                                                               |\n   +  \
    \                                                             +\n   |        \
    \                                                       |\n   +              \
    \          Link_Id (16 bytes)                     +\n   |                    \
    \                                           |\n   +                          \
    \                                     +\n   |                                \
    \                               |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   o    C-Type = 5, Unnumbered LOCAL_LINK_ID\n   o    C-Type = 6, Unnumbered\
    \ REMOTE_LINK_ID\n    0                   1                   2              \
    \     3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n\
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   |  \
    \                      Link_Id (4 bytes)                      |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   Link_Id:\n      For LOCAL_LINK_ID, this identifies the sender's Link associated\n\
    \      with the message.  This value MUST be non-zero.\n      For REMOTE_LINK_ID,\
    \ this identifies the remote node's Link_Id and\n      MUST be non-zero.\n   This\
    \ object is non-negotiable.\n"
- title: 13.4.  INTERFACE_ID Class
  contents:
  - "13.4.  INTERFACE_ID Class\n   Class = 4\n   o    C-Type = 1, IPv4 LOCAL_INTERFACE_ID\n\
    \   o    C-Type = 2, IPv4 REMOTE_INTERFACE_ID\n    0                   1     \
    \              2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7\
    \ 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                       Interface_Id (4 bytes)                  |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   o    C-Type = 3, IPv6 LOCAL_INTERFACE_ID\n   o    C-Type = 4, IPv6 REMOTE_INTERFACE_ID\n\
    \    0                   1                   2                   3\n    0 1 2\
    \ 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                                                               |\n   +  \
    \                                                             +\n   |        \
    \                                                       |\n   +              \
    \         Interface_Id (16 bytes)                 +\n   |                    \
    \                                           |\n   +                          \
    \                                     +\n   |                                \
    \                               |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   o    C-Type = 5, Unnumbered LOCAL_INTERFACE_ID\n   o    C-Type = 6, Unnumbered\
    \ REMOTE_INTERFACE_ID\n    0                   1                   2         \
    \          3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9\
    \ 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                      Interface_Id (4 bytes)                   |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   Interface_Id:\n      For the LOCAL_INTERFACE_ID, this identifies the data\
    \ link.  This\n      value MUST be node-wide unique and non-zero.\n      For the\
    \ REMOTE_INTERFACE_ID, this identifies the remote node's\n      data link.  The\
    \ Interface_Id MUST be non-zero.\n   This object is non-negotiable.\n"
- title: 13.5.  MESSAGE_ID Class
  contents:
  - "13.5.  MESSAGE_ID Class\n   Class = 5\n   o    C-Type=1, MessageId\n    0   \
    \                1                   2                   3\n    0 1 2 3 4 5 6\
    \ 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                          Message_Id                           |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   Message_Id:\n      The Message_Id field is used to identify a message.  This\
    \ value is\n      incremented and only decreases when the value wraps.  This is\
    \ used\n      for message acknowledgment.\n   This object is non-negotiable.\n\
    \   o    C-Type = 2, MessageIdAck\n    0                   1                 \
    \  2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3\
    \ 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                          Message_Id                           |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   Message_Id:\n      The Message_Id field is used to identify the message being\n\
    \      acknowledged.  This value is copied from the MESSAGE_ID object of\n   \
    \   the message being acknowledged.\n   This object is non-negotiable.\n"
- title: 13.6.  CONFIG Class
  contents:
  - "13.6.  CONFIG Class\n   Class = 6.\n   o    C-Type = 1, HelloConfig\n    0  \
    \                 1                   2                   3\n    0 1 2 3 4 5 6\
    \ 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |         HelloInterval         |      HelloDeadInterval        |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   HelloInterval:  16 bits.\n      Indicates how frequently the Hello packets\
    \ will be sent and is\n      measured in milliseconds (ms).\n   HelloDeadInterval:\
    \  16 bits.\n      If no Hello packets are received within the HelloDeadInterval,\
    \ the\n      control channel is assumed to have failed.  The HelloDeadInterval\n\
    \      is measured in milliseconds (ms).  The HelloDeadInterval MUST be\n    \
    \  greater than the HelloInterval, and SHOULD be at least 3 times the\n      value\
    \ of HelloInterval.\n   If the fast keep-alive mechanism of LMP is not used, the\n\
    \   HelloInterval and HelloDeadInterval MUST be set to zero.\n"
- title: 13.7.  HELLO Class
  contents:
  - "13.7.  HELLO Class\n   Class = 7\n   o    C-Type = 1, Hello\n    0          \
    \         1                   2                   3\n    0 1 2 3 4 5 6 7 8 9 0\
    \ 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                           TxSeqNum                            |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                           RcvSeqNum                           |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   TxSeqNum:  32 bits\n      This is the current sequence number for this Hello\
    \ message.  This\n      sequence number will be incremented when the sequence\
    \ number is\n      reflected in the RcvSeqNum of a Hello packet that is received\
    \ over\n      the control channel.\n      TxSeqNum=0 is not allowed.  TxSeqNum=1\
    \ is used to indicate that\n      this is the first Hello message sent over the\
    \ control channel.\n   RcvSeqNum:  32 bits\n      This is the sequence number\
    \ of the last Hello message received\n      over the control channel.  RcvSeqNum=0\
    \ is used to indicate that a\n      Hello message has not yet been received.\n\
    \   This object is non-negotiable.\n"
- title: 13.8.  BEGIN_VERIFY Class
  contents:
  - "13.8.  BEGIN_VERIFY Class\n   Class = 8\n   o    C-Type = 1\n    0          \
    \         1                   2                   3\n    0 1 2 3 4 5 6 7 8 9 0\
    \ 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |    Flags                      |         VerifyInterval        |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                       Number of Data Links                    |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |    EncType    |  (Reserved)   |  Verify Transport Mechanism   |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                       TransmissionRate                        |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                          Wavelength                           |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   The Reserved field should be sent as zero and ignored on receipt.\n   Flags:\
    \  16 bits\n      The following flags are defined:\n      0x0001 Verify all Links\n\
    \            If this bit is set, the verification process checks all\n       \
    \     unallocated links; else it only verifies new ports or\n            component\
    \ links that are to be added to this TE link.\n         0x0002 Data Link Type\n\
    \            If set, the data links to be verified are ports, otherwise\n    \
    \        they are component links\n   VerifyInterval:  16 bits\n      This is\
    \ the interval between successive Test messages and is\n      measured in milliseconds\
    \ (ms).\n   Number of Data Links:  32 bits\n      This is the number of data links\
    \ that will be verified.\n   EncType:  8 bits\n      This is the encoding type\
    \ of the data link.  The defined EncType\n      values are consistent with the\
    \ LSP Encoding Type values of\n      [RFC3471].\n   Verify Transport Mechanism:\
    \  16 bits\n      This defines the transport mechanism for the Test Messages.\
    \  The\n      scope of this bit mask is restricted to each encoding type.  The\n\
    \      local node will set the bits corresponding to the various\n      mechanisms\
    \ it can support for transmitting LMP test messages.  The\n      receiver chooses\
    \ the appropriate mechanism in the BeginVerifyAck\n      message.\n      The following\
    \ flag is defined across all Encoding Types.  All\n      other flags are dependent\
    \ on the Encoding Type.\n      0x8000 Payload:Test Message transmitted in the\
    \ payload\n               Capable of transmitting Test messages in the payload.\n\
    \               The Test message is sent as an IP packet as defined\n        \
    \       above.\n   TransmissionRate:  32 bits\n      This is the transmission\
    \ rate of the data link over which the Test\n      messages will be transmitted.\
    \  This is expressed in bytes per\n      second and represented in IEEE floating-point\
    \ format.\n   Wavelength:  32 bits\n      When a data link is assigned to a port\
    \ or component link that is\n      capable of transmitting multiple wavelengths\
    \ (e.g., a fiber or\n      waveband-capable port), it is essential to know which\
    \ wavelength\n      the test messages will be transmitted over.  This value\n\
    \      corresponds to the wavelength at which the Test messages will be\n    \
    \  transmitted over and has local significance.  If there is no\n      ambiguity\
    \ as to the wavelength over which the message will be\n      sent, then this value\
    \ SHOULD be set to 0.\n"
- title: 13.9.  BEGIN_VERIFY_ACK Class
  contents:
  - "13.9.  BEGIN_VERIFY_ACK Class\n   Class = 9\n   o    C-Type = 1\n    0      \
    \             1                   2                   3\n    0 1 2 3 4 5 6 7 8\
    \ 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |      VerifyDeadInterval       |   Verify_Transport_Response   |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   VerifyDeadInterval:  16 bits\n      If a Test message is not detected within\
    \ the\n      VerifyDeadInterval, then a node will send the TestStatusFailure\n\
    \      message for that data link.\n   Verify_Transport_Response:  16 bits\n \
    \     The recipient of the BeginVerify message (and the future\n      recipient\
    \ of the TEST messages) chooses the transport mechanism\n      from the various\
    \ types that are offered by the transmitter of\n      the Test messages.  One\
    \ and only one bit MUST be set in the\n      verification transport response.\n\
    \   This object is non-negotiable.\n"
- title: 13.10.  VERIFY_ID Class
  contents:
  - "13.10.  VERIFY_ID Class\n   Class = 10\n   o    C-Type = 1\n    0           \
    \        1                   2                   3\n    0 1 2 3 4 5 6 7 8 9 0\
    \ 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                          Verify_Id                            |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   Verify_Id:  32 bits\n      This is used to differentiate Test messages from\
    \ different TE\n      links and/or LMP peers.  This is a node-unique value that\
    \ is\n      assigned by the recipient of the BeginVerify message.\n   This object\
    \ is non-negotiable.\n"
- title: 13.11.  TE_LINK Class
  contents:
  - "13.11.  TE_LINK Class\n   Class = 11\n   o    C-Type = 1, IPv4 TE_LINK\n    0\
    \                   1                   2                   3\n    0 1 2 3 4 5\
    \ 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |     Flags     |                   (Reserved)                  |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                      Local_Link_Id (4 bytes)                  |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                      Remote_Link_Id (4 bytes)                 |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   o    C-Type = 2, IPv6 TE_LINK\n    0                   1                 \
    \  2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3\
    \ 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |     Flags     |                   (Reserved)                  |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                                                               |\n   +  \
    \                                                             +\n   |        \
    \                                                       |\n   +              \
    \        Local_Link_Id (16 bytes)                 +\n   |                    \
    \                                           |\n   +                          \
    \                                     +\n   |                                \
    \                               |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                                                               |\n   +  \
    \                                                             +\n   |        \
    \                                                       |\n   +              \
    \        Remote_Link_Id (16 bytes)                +\n   |                    \
    \                                           |\n   +                          \
    \                                     +\n   |                                \
    \                               |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   o    C-Type = 3, Unnumbered TE_LINK\n    0                   1           \
    \        2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0\
    \ 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |     Flags     |                   (Reserved)                  |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                      Local_Link_Id (4 bytes)                  |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                      Remote_Link_Id (4 bytes)                 |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   The Reserved field should be sent as zero and ignored on receipt.\n   Flags:\
    \ 8 bits\n      The following flags are defined.  All other bit-values are\n \
    \     reserved and should be sent as zero and ignored on receipt.\n      0x01\
    \ Fault Management Supported.\n      0x02 Link Verification Supported.\n   Local_Link_Id:\n\
    \      This identifies the node's local Link_Id and MUST be non-zero.\n   Remote_Link_Id:\n\
    \      This identifies the remote node's Link_Id and MUST be non-zero.\n"
- title: 13.12.  DATA_LINK Class
  contents:
  - "13.12.  DATA_LINK Class\n   Class = 12\n   o    C-Type = 1, IPv4 DATA_LINK\n\
    \    0                   1                   2                   3\n    0 1 2\
    \ 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |     Flags     |                   (Reserved)                  |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                   Local_Interface_Id (4 bytes)                |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                   Remote_Interface_Id (4 bytes)               |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                                                               |\n   // \
    \                       (Subobjects)                         //\n   |        \
    \                                                       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   o    C-Type = 2, IPv6 DATA_LINK\n    0                   1               \
    \    2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2\
    \ 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |     Flags     |                   (Reserved)                  |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                                                               |\n   +  \
    \                                                             +\n   |        \
    \                                                       |\n   +              \
    \     Local_Interface_Id (16 bytes)               +\n   |                    \
    \                                           |\n   +                          \
    \                                     +\n   |                                \
    \                               |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                                                               |\n   +  \
    \                                                             +\n   |        \
    \                                                       |\n   +              \
    \     Remote_Interface_Id (16 bytes)              +\n   |                    \
    \                                           |\n   +                          \
    \                                     +\n   |                                \
    \                               |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                                                               |\n   // \
    \                       (Subobjects)                         //\n   |        \
    \                                                       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   o    C-Type = 3, Unnumbered DATA_LINK\n    0                   1         \
    \          2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9\
    \ 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |     Flags     |                   (Reserved)                  |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                   Local_Interface_Id (4 bytes)                |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                   Remote_Interface_Id (4 bytes)               |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                                                               |\n   // \
    \                       (Subobjects)                         //\n   |        \
    \                                                       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   The Reserved field should be sent as zero and ignored on receipt.\n   Flags:\
    \ 8 bits\n      The following flags are defined.  All other bit-values are\n \
    \     reserved and should be sent as zero and ignored on receipt.\n      0x01\
    \ Interface Type: If set, the data link is a port, otherwise it\n            \
    \               is a component link.\n      0x02 Allocated Link: If set, the data\
    \ link is currently allocated\n                           for user traffic.  If\
    \ a single Interface_Id\n                           is used for both the transmit\
    \ and receive\n                           data links, then this bit only applies\
    \ to the\n                           transmit interface.\n      0x04 Failed Link:\
    \    If set, the data link is failed and not\n                           suitable\
    \ for user traffic.\n   Local_Interface_Id:\n      This is the local identifier\
    \ of the data link.  This MUST be\n      node-wide unique and non-zero.\n   Remote_Interface_Id:\n\
    \      This is the remote identifier of the data link.  This MUST be\n      non-zero.\n\
    \   Subobjects\n      The contents of the DATA_LINK object consist of a series\
    \ of\n      variable-length data items called subobjects.  The subobjects are\n\
    \      defined in Section 13.12.1 below.\n   A DATA_LINK object may contain more\
    \ than one subobject.  More than\n   one subobject of the same Type may appear\
    \ if multiple capabilities\n   are supported over the data link.\n"
- title: 13.12.1.  Data Link Subobjects
  contents:
  - "13.12.1.  Data Link Subobjects\n   The contents of the DATA_LINK object include\
    \ a series of variable-\n   length data items called subobjects.  Each subobject\
    \ has the form:\n    0                   1\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4\
    \ 5\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+---------------//--------------+\n  \
    \ |    Type       |    Length     |      (Subobject contents)     |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+--------------//---------------+\n\
    \   Type: 8 bits\n      The Type indicates the type of contents of the subobject.\n\
    \      Currently defined values are:\n      Type = 1, Interface Switching Type\n\
    \      Type = 2, Wavelength\n   Length: 8 bits\n      The Length contains the\
    \ total length of the subobject in bytes,\n      including the Type and Length\
    \ fields.  The Length MUST be at\n      least 4, and MUST be a multiple of 4.\n"
- title: '13.12.1.1.  Subobject Type 1: Interface Switching Type'
  contents:
  - "13.12.1.1.  Subobject Type 1: Interface Switching Type\n    0               \
    \    1                   2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2\
    \ 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |    Type       |    Length     | Switching Type|   EncType     |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                  Minimum Reservable Bandwidth                 |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                  Maximum Reservable Bandwidth                 |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   Switching Type: 8 bits\n      This is used to identify the local Interface\
    \ Switching Type of the\n      TE link as defined in [RFC3471].\n   EncType: 8\
    \ bits\n      This is the encoding type of the data link.  The defined EncType\n\
    \      values are consistent with the LSP Encoding Type values of\n      [RFC3471].\n\
    \   Minimum Reservable Bandwidth: 32 bits\n      This is measured in bytes per\
    \ second and represented in IEEE\n      floating point format.\n   Maximum Reservable\
    \ Bandwidth: 32 bits\n      This is measured in bytes per second and represented\
    \ in IEEE\n      floating point format.\n   If the interface only supports a fixed\
    \ rate, the minimum and maximum\n   bandwidth fields are set to the same value.\n"
- title: '13.12.1.2.  Subobject Type 2: Wavelength'
  contents:
  - "13.12.1.2.  Subobject Type 2: Wavelength\n    0                   1         \
    \          2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9\
    \ 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |    Type       |    Length     |         (Reserved)            |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                         Wavelength                            |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   The Reserved field should be sent as zero and ignored on receipt.\n   Wavelength:\
    \ 32 bits\n      This value indicates the wavelength carried over the port.  Values\n\
    \      used in this field only have significance between two neighbors.\n"
- title: 13.13.   CHANNEL_STATUS Class
  contents:
  - "13.13.   CHANNEL_STATUS Class\n   Class = 13\n   o    C-Type = 1, IPv4 INTERFACE_ID\n\
    \    0                   1                   2                   3\n    0 1 2\
    \ 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                       Interface_Id (4 bytes)                  |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |A|D|                     Channel Status                        |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                              :                                |\n   // \
    \                            :                               //\n   |        \
    \                      :                                |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                       Interface_Id (4 bytes)                  |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |A|D|                     Channel Status                        |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   o    C-Type = 2, IPv6 INTERFACE_ID\n    0                   1            \
    \       2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\
    \ 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                                                               |\n   +  \
    \                                                             +\n   |        \
    \                                                       |\n   +              \
    \         Interface_Id (16 bytes)                 +\n   |                    \
    \                                           |\n   +                          \
    \                                     +\n   |                                \
    \                               |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |A|D|                     Channel Status                        |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                              :                                |\n   // \
    \                            :                               //\n   |        \
    \                      :                                |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                                                               |\n   +  \
    \                                                             +\n   |        \
    \                                                       |\n   +              \
    \         Interface_Id (16 bytes)                 +\n   |                    \
    \                                           |\n   +                          \
    \                                     +\n   |                                \
    \                               |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |A|D|                     Channel Status                        |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   o    C-Type = 3, Unnumbered INTERFACE_ID\n    0                   1      \
    \             2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8\
    \ 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                      Interface_Id (4 bytes)                   |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |A|D|                     Channel Status                        |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                              :                                |\n   // \
    \                            :                               //\n   |        \
    \                      :                                |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                      Interface_Id (4 bytes)                   |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |A|D|                     Channel_Status                        |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   Active bit: 1 bit\n      This indicates that the Channel is allocated to user\
    \ traffic and\n      the data link should be actively monitored.\n   Direction\
    \ bit: 1 bit\n      This indicates the direction (transmit/receive) of the data\n\
    \      channel referred to in the CHANNEL_STATUS object.  If set, this\n     \
    \ indicates the data channel is in the transmit direction.\n   Channel_Status:\
    \ 30 bits\n      This indicates the status condition of a data channel.  The\n\
    \      following values are defined.  All other values are reserved.\n      1\
    \   Signal Okay (OK):    Channel is operational\n      2   Signal Degrade (SD):\
    \ A soft failure caused by a BER exceeding\n                               a preselected\
    \ threshold.  The specific\n                               BER used to define\
    \ the threshold is\n                               configured.\n      3   Signal\
    \ Fail (SF):    A hard signal failure including (but not\n                   \
    \            limited to) loss of signal (LOS), loss of\n                     \
    \          frame (LOF), or Line AIS.\n   This object contains one or more Interface_Ids\
    \ followed by a\n   Channel_Status field.\n   To indicate the status of the entire\
    \ TE Link, there MUST be only one\n   Interface_Id, and it MUST be zero.\n   This\
    \ object is non-negotiable.\n"
- title: 13.14.  CHANNEL_STATUS_REQUEST Class
  contents:
  - "13.14.  CHANNEL_STATUS_REQUEST Class\n   Class = 14\n   o    C-Type = 1, IPv4\
    \ INTERFACE_ID\n    0                   1                   2                \
    \   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n \
    \  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   |   \
    \                    Interface_Id (4 bytes)                  |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                              :                                |\n   // \
    \                            :                               //\n   |        \
    \                      :                                |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                       Interface_Id (4 bytes)                  |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   This object contains one or more Interface_Ids.\n   The Length of this object\
    \ is 4 + 4N in bytes, where N is the number\n   of Interface_Ids.\n   o    C-Type\
    \ = 2, IPv6 INTERFACE_ID\n    0                   1                   2      \
    \             3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8\
    \ 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                                                               |\n   +  \
    \                                                             +\n   |        \
    \                                                       |\n   +              \
    \         Interface_Id (16 bytes)                 +\n   |                    \
    \                                           |\n   +                          \
    \                                     +\n   |                                \
    \                               |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                              :                                |\n   // \
    \                            :                               //\n   |        \
    \                      :                                |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                                                               |\n   +  \
    \                                                             +\n   |        \
    \                                                       |\n   +              \
    \         Interface_Id (16 bytes)                 +\n   |                    \
    \                                           |\n   +                          \
    \                                     +\n   |                                \
    \                               |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   This object contains one or more Interface_Ids.\n   The Length of this object\
    \ is 4 + 16N in bytes, where N is the number\n   of Interface_Ids.\n   o    C-Type\
    \ = 3, Unnumbered INTERFACE_ID\n    0                   1                   2\
    \                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5\
    \ 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                      Interface_Id (4 bytes)                   |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                              :                                |\n   // \
    \                            :                               //\n   |        \
    \                      :                                |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                      Interface_Id (4 bytes)                   |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   This object contains one or more Interface_Ids.\n   The Length of this object\
    \ is 4 + 4N in bytes, where N is the number\n   of Interface_Ids.\n   This object\
    \ is non-negotiable.\n"
- title: 13.15.  ERROR_CODE Class
  contents:
  - "13.15.  ERROR_CODE Class\n   Class = 20\n   o    C-Type = 1, BEGIN_VERIFY_ERROR\n\
    \    0                   1                   2                   3\n    0 1 2\
    \ 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                          ERROR CODE                           |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      The following bit-values are defined in network byte order (i.e.,\n   \
    \   big-endian byte order):\n      0x01 = Link Verification Procedure not supported.\n\
    \      0x02 = Unwilling to verify.\n      0x04 = Unsupported verification transport\
    \ mechanism.\n      0x08 = Link_Id configuration error.\n      0x10 = Unknown\
    \ object C-Type.\n      All other bit-values are reserved and should be sent as\
    \ zero and\n      ignored on receipt.\n      Multiple bits may be set to indicate\
    \ multiple errors.\n      This object is non-negotiable.\n   If a BeginVerifyNack\
    \ message is received with Error Code 2, the node\n   that originated the BeginVerify\
    \ SHOULD schedule a BeginVerify\n   retransmission after Rf seconds, where Rf\
    \ is a locally defined\n   parameter.\n   o    C-Type = 2, LINK_SUMMARY_ERROR\n\
    \    0                   1                   2                   3\n    0 1 2\
    \ 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                          ERROR CODE                           |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      The following bit-values are defined in network byte order (i.e.,\n   \
    \   big-endian byte order):\n      0x01 = Unacceptable non-negotiable LINK_SUMMARY\
    \ parameters.\n      0x02 = Renegotiate LINK_SUMMARY parameters.\n      0x04 =\
    \ Invalid TE_LINK Object.\n      0x08 = Invalid DATA_LINK Object.\n      0x10\
    \ = Unknown TE_LINK object C-Type.\n      0x20 = Unknown DATA_LINK object C-Type.\n\
    \      All other bit-values are reserved and should be sent as zero and\n    \
    \  ignored on receipt.\n      Multiple bits may be set to indicate multiple errors.\n\
    \      This object is non-negotiable.\n"
- title: 14.  References
  contents:
  - '14.  References

    '
- title: 14.1.  Normative References
  contents:
  - "14.1.  Normative References\n   [RFC2119]   Bradner, S., \"Key words for use\
    \ in RFCs to Indicate\n               Requirement Levels\", BCP 14, RFC 2119,\
    \ March 1997.\n   [RFC4201]   Kompella, K., Rekhter, Y., and L. Berger, \"Link\
    \ Bundling\n               in MPLS Traffic Engineering (TE)\", RFC 4201, October\n\
    \               2005.\n   [RFC4202]   Kompella, K., Ed. and Y. Rekhter, Ed., \"\
    Routing\n               Extensions in Support of Generalized Multi-Protocol Label\n\
    \               Switching (GMPLS)\", RFC 4202, October 2005.\n   [RFC2961]   Berger,\
    \ L., Gan, D., Swallow, G., Pan, P., Tommasi, F.,\n               and S. Molendini,\
    \ \"RSVP Refresh Overhead Reduction\n               Extensions\", RFC 2961, April\
    \ 2001.\n   [RFC2402]   Kent, S. and R. Atkinson, \"IP Authentication Header\"\
    , RFC\n               2402, November 1998.\n   [RFC2406]   Kent, S. and R. Atkinson,\
    \ \"IP Encapsulating Security\n               Payload (ESP)\", RFC 2406, November\
    \ 1998.\n   [RFC2407]   Piper, D., \"The Internet IP Security Domain of\n    \
    \           Interpretation for ISAKMP\", RFC 2407, November 1998.\n   [RFC2409]\
    \   Harkins, D. and D. Carrel, \"The Internet Key Exchange\n               (IKE)\"\
    , RFC 2409, November 1998.\n   [RFC3471]   Berger, L., Ed.,  \"Generalized MPLS\
    \ - Signaling\n               Functional Description\", RFC 3471, January 2003.\n"
- title: 14.2.  Informative References
  contents:
  - "14.2.  Informative References\n   [RFC3630]   Katz, D., Kompella, K., and D.\
    \ Yeung, \"Traffic\n               Engineering (TE) Extensions to OSPF Version\
    \ 2\", RFC 3630,\n               September 2003.\n   [RFC3784]   Smit, H. and\
    \ T. Li, \"Intermediate System to Intermediate\n               System (IS-IS)\
    \ Extensions for Traffic Engineering (TE)\",\n               RFC 3784, June 2004.\n\
    \   [RFC2401]   Kent, S. and R. Atkinson, \"Security Architecture for the\n  \
    \             Internet Protocol\", RFC 2401, November 1998.\n   [RFC2434]   Narten,\
    \ T. and H. Alvestrand, \"Guidelines for Writing an\n               IANA Considerations\
    \ Section in RFCs\", BCP 26, RFC 2434,\n               October 1998.\n   [RFC3209]\
    \   Awduche, D., Berger, L., Gan, D., Li, T., Srinivasan, V.,\n              \
    \ and G. Swallow, \"RSVP-TE: Extensions to RSVP for LSP\n               Tunnels\"\
    , RFC 3209, December 2001.\n"
- title: 15.  Security Considerations
  contents:
  - "15.  Security Considerations\n   There are number of attacks that an LMP protocol\
    \ session can\n   potentially experience.  Some examples include:\n      o  an\
    \ adversary may spoof control packets;\n      o  an adversary may modify the control\
    \ packets in transit;\n      o  an adversary may replay control packets;\n   \
    \   o  an adversary may study a number of control packets and try to\n       \
    \  break the key using cryptographic tools.  If the\n         hash/encryption\
    \ algorithm used has known weaknesses, then it\n         becomes easy for the\
    \ adversary to discover the key using simple\n         tools.\n   This section\
    \ specifies an IPsec-based security mechanism for LMP.\n"
- title: 15.1.  Security Requirements
  contents:
  - "15.1.  Security Requirements\n   The following requirements are applied to the\
    \ mechanism described in\n   this section.\n      o  LMP security MUST be able\
    \ to provide authentication, integrity,\n         and replay protection.\n   \
    \   o  For LMP traffic, confidentiality is not needed.  Only\n         authentication\
    \ is needed to ensure that the control packets\n         (packets sent along the\
    \ LMP Control Channel) are originating\n         from the right place and have\
    \ not been modified in transit.\n         LMP Test packets exchanged through the\
    \ data links do not need\n         to be protected.\n      o  For LMP traffic,\
    \ protecting the identity of LMP end-points is\n         not commonly required.\n\
    \      o  The security mechanism should provide for well defined key\n       \
    \  management schemes.  The key management schemes should be well\n         analyzed\
    \ to be cryptographically secure.  The key management\n         schemes should\
    \ be scalable.  In addition, the key management\n         system should be automatic.\n\
    \      o  The algorithms used for authentication MUST be\n         cryptographically\
    \ sound.  Also, the security protocol MUST\n         allow for negotiating and\
    \ using different authentication\n         algorithms.\n"
- title: 15.2.  Security Mechanisms
  contents:
  - "15.2.  Security Mechanisms\n   IPsec is a protocol suite that is used to secure\
    \ communication at the\n   network layer between two peers.  This protocol is\
    \ comprised of IP\n   Security architecture document [RFC2401], IKE [RFC2409],\
    \ IPsec AH\n   [RFC2402], and IPsec ESP [RFC2406].  IKE is the key management\n\
    \   protocol for IP networks, while AH and ESP are used to protect IP\n   traffic.\
    \  IKE is defined specific to IP domain of interpretation.\n   Considering the\
    \ requirements described in Section 15.1, it is\n   recommended that, where security\
    \ is needed for LMP, implementations\n   use IPsec as described below:\n   1.\
    \ Implementations of LMP over IPsec protocol SHOULD support manual\n      keying\
    \ mode.\n      Manual keying mode provides an easy way to set up and diagnose\n\
    \      IPsec functionality.\n      However, note that manual keying mode cannot\
    \ effectively support\n      features such as replay protection and automatic\
    \ re-keying.  An\n      implementer using manual keys must be aware of these limits.\n\
    \      It is recommended that an implementer use manual keying only for\n    \
    \  diagnostic purposes and use dynamic keying protocol to make use of\n      features\
    \ such as replay protection and automatic re-keying.\n   2. IPsec ESP with trailer\
    \ authentication in tunnel mode MUST be\n      supported.\n   3. Implementations\
    \ MUST support authenticated key exchange protocols.\n      IKE [RFC2409] MUST\
    \ be used as the key exchange protocol if keys\n      are dynamically negotiated\
    \ between peers.\n   4. Implementation MUST use the IPsec DOI [RFC2407].\n   5.\
    \ For IKE protocol, the identities of the SAs negotiated in Quick\n      Mode\
    \ represent the traffic that the peers agree to protect and are\n      comprised\
    \ of address space, protocol, and port information.\n      For LMP over IPsec,\
    \ it is recommended that the identity payload\n      for Quick mode contain the\
    \ following information:\n      The identities MUST be of type IP addresses and\
    \ the value of the\n      identities SHOULD be the IP addresses of the communicating\
    \ peers.\n      The protocol field MUST be UDP.  The port field SHOULD be set\
    \ to\n      zero to indicate port fields should be ignored.  This implies all\n\
    \      UDP traffic between the peers must be sent through the IPsec\n      tunnel.\
    \  If an implementation supports port-based selectors, it\n      can opt for a\
    \ more finely grained selector by specifying the port\n      field to the LMP\
    \ port.  If, however, the peer does not use port-\n      based selectors, the\
    \ implementation MUST fall back to using a port\n      selector value of 0.\n\
    \   6. Aggressive mode of IKE negotiation MUST be supported.\n      When IPsec\
    \ is configured to be used with a peer, all LMP messages\n      are expected to\
    \ be sent over the IPsec tunnel (crypto channel).\n      Similarly, an LMP receiver\
    \ configured to use Ipsec with a peer\n      should reject any LMP traffic that\
    \ does not come through the\n      crypto channel.\n      The crypto channel can\
    \ be pre-setup with the LMP neighbor, or the\n      first LMP message sent to\
    \ the peer can trigger the creation of the\n      IPsec tunnel.\n      A set of\
    \ control channels can share the same crypto channel.  When\n      LMP Hellos\
    \ are used to monitor the status of the control channel,\n      it is important\
    \ to keep in mind that the keep-alive failure in a\n      control channel may\
    \ also be due to a failure in the crypto\n      channel.  The following method\
    \ is recommended to ensure that an\n      LMP communication path between two peers\
    \ is working properly.\n      o  If LMP Hellos detect a failure on a control channel,\
    \ switch to\n         an alternate control channel and/or try to establish a new\n\
    \         control channel.\n      o  Ensure the health of the control channels\
    \ using LMP Hellos.  If\n         all control channels indicate a failure and\
    \ it is not possible\n         to bring up a new control channel, tear down all\
    \ existing\n         control channels.  Also, tear down the crypto channel (both\
    \ the\n         IKE SA and IPsec SAs).\n      o  Reestablish the crypto channel.\
    \  Failure to establish a crypto\n         channel indicates a fatal failure for\
    \ LMP communication.\n      o  Bring up the control channel.  Failure to bring\
    \ up the control\n         channel indicates a fatal failure for LMP communication.\n\
    \      When LMP peers are dynamically discovered (particularly the\n      initiator),\
    \ the following points should be noted:\n         When using pre-shared key authentication\
    \ in identity protection\n         mode (main mode), the pre-shared key is required\
    \ to compute the\n         value of SKEYID (used for deriving keys to encrypt\
    \ messages\n         during key exchange).  In main mode of IKE, the pre-shared\
    \ key\n         to be used has to be identified before receiving the peer's\n\
    \         identity payload.  The pre-shared key is required for\n         calculating\
    \ SKEYID.  The only information available about the\n         peer at this point\
    \ is its IP address from which the negotiation\n         came from.  Keying off\
    \ the IP address of a peer to get the\n         pre-shared key is not possible\
    \ since the addresses are dynamic\n         and not known beforehand.\n      \
    \   Aggressive mode key exchange can be used since identification\n         payloads\
    \ are sent in the first message.\n         Note, however, that aggressive mode\
    \ is prone to passive denial\n         of service attacks.  Using a shared secret\
    \ (group shared\n         secret) among a number of peers is strongly discouraged\
    \ because\n         this opens up the solution to man-in-the-middle attacks.\n\
    \         Digital-signature-based authentication is not prone to such\n      \
    \   problems.  It is RECOMMENDED that a digital-signature-based\n         authentication\
    \ mechanism be used where possible.\n         If pre-shared-key-based authentication\
    \ is required, then\n         aggressive mode SHOULD be used.  IKE pre-shared\
    \ authentication\n         key values SHOULD be protected in a manner similar\
    \ to the\n         user's account password.\n"
- title: 16.  IANA Considerations
  contents:
  - "16.  IANA Considerations\n   The IANA has assigned port number 701 to LMP.\n\
    \   In the following, guidelines are given for IANA assignment for each\n   LMP\
    \ name space.  Ranges are specified for Private Use, to be assigned\n   by Expert\
    \ Review, and to be assigned by Standards Action (as defined\n   in [RFC2434].\n\
    \   Assignments made from LMP number spaces set aside for Private Use\n   (i.e.,\
    \ for proprietary extensions) need not be documented.\n   Independent LMP implementations\
    \ using the same Private Use code\n   points will in general not interoperate,\
    \ so care should be exercised\n   in using these code points in a multi-vendor\
    \ network.\n   Assignments made from LMP number spaces to be assigned by Expert\n\
    \   Review are to be reviewed by an Expert designated by the IESG.  The\n   intent\
    \ in this document is that code points from these ranges are\n   used for Experimental\
    \ extensions; as such, assignments MUST be\n   accompanied by Experimental RFCs.\
    \  If deployment suggests that these\n   extensions are useful, then they should\
    \ be described in Standards\n   Track RFCs, and new code points from the Standards\
    \ Action ranges MUST\n   be assigned.\n   Assignments from LMP number spaces to\
    \ be assigned by Standards Action\n   MUST be documented by a Standards Track\
    \ RFC, typically submitted to\n   an IETF Working Group, but in any case following\
    \ the usual IETF\n   procedures for Proposed Standards.\n   The Reserved bits\
    \ of the LMP Common Header should be allocated by\n   Standards Action, pursuant\
    \ to the policies outlined in [RFC2434].\n   LMP defines the following name spaces\
    \ that require management:\n   -  LMP Message Type.\n   -  LMP Object Class.\n\
    \   -  LMP Object Class type (C-Type).  These are unique within the\n      Object\
    \ Class.\n   -  LMP Sub-object Class type (Type).  These are unique within the\n\
    \      Object Class.\n   The LMP Message Type name space should be allocated as\
    \ follows:\n   pursuant to the policies outlined in [RFC2434], the numbers in\
    \ the\n   range 0-127 are allocated by Standards Action, 128-240 are allocated\n\
    \   through an Expert Review, and 241-255 are reserved for Private Use.\n   The\
    \ LMP Object Class name space should be allocated as follows:\n   pursuant to\
    \ the policies outlined in [RFC2434], the numbers in the\n   range of 0-127 are\
    \ allocated by Standards Action, 128-247 are\n   allocated through an Expert Review,\
    \ and 248-255 are reserved for\n   Private Use.\n   The policy for allocating\
    \ values out of the LMP Object Class name\n   space is part of the definition\
    \ of the specific Class instance.  When\n   a Class is defined, its definition\
    \ must also include a description of\n   the policy under which the Object Class\
    \ names are allocated.\n   The policy for allocating values out of the LMP Sub-object\
    \ Class name\n   space is part of the definition of the specific Class instance.\
    \  When\n   a Class is defined, its definition must also include a description\
    \ of\n   the policy under which sub-objects are allocated.\n   The following name\
    \ spaces have been assigned by IANA:\n   ------------------------------------------------------------------\n\
    \   LMP Message Type name space\n   o Config message                     (Message\
    \ type = 1)\n   o ConfigAck message                  (Message type = 2)\n   o\
    \ ConfigNack message                 (Message type = 3)\n   o Hello message  \
    \                    (Message type = 4)\n   o BeginVerify message            \
    \    (Message type = 5)\n   o BeginVerifyAck message             (Message type\
    \ = 6)\n   o BeginVerifyNack message            (Message type = 7)\n   o EndVerify\
    \ message                  (Message type = 8)\n   o EndVerifyAck message     \
    \          (Message type = 9)\n   o Test message                       (Message\
    \ type = 10)\n   o TestStatusSuccess message          (Message type = 11)\n  \
    \ o TestStatusFailure message          (Message type = 12)\n   o TestStatusAck\
    \ message              (Message type = 13)\n   o LinkSummary message         \
    \       (Message type = 14)\n   o LinkSummaryAck message             (Message\
    \ type = 15)\n   o LinkSummaryNack message            (Message type = 16)\n  \
    \ o ChannelStatus message              (Message type = 17)\n   o ChannelStatusAck\
    \ message           (Message type = 18)\n   o ChannelStatusRequest message   \
    \    (Message type = 19)\n   o ChannelStatusResponse message      (Message type\
    \ = 20)\n   ------------------------------------------------------------------\n\
    \   LMP Object Class name space and Class type (C-Type)\n   o CCID           \
    \       Class name (1)\n   The CCID Object Class type name space should be allocated\
    \ as follows:\n   pursuant to the policies outlined in [RFC2434], the numbers\
    \ in the\n   range 0-111 are allocated by Standards Action, 112-119 are allocated\n\
    \   through an Expert Review, and 120-127 are reserved for Private Use.\n    \
    \ - LOCAL_CCID                      (C-Type = 1)\n     - REMOTE_CCID         \
    \            (C-Type = 2)\n   o NODE_ID               Class name (2)\n   The NODE\
    \ ID Object Class type name space should be allocated as\n   follows: pursuant\
    \ to the policies outlined in [RFC2434], the numbers\n   in the range 0-111 are\
    \ allocated by Standards Action, 112-119 are\n   allocated through an Expert Review,\
    \ and 120-127 are reserved for\n   Private Use.\n     - LOCAL_NODE_ID        \
    \           (C-Type = 1)\n     - REMOTE_NODE_ID                  (C-Type = 2)\n\
    \   o LINK_ID               Class name (3)\n   The LINK_ID Object Class type name\
    \ space should be allocated as\n   follows: pursuant to the policies outlined\
    \ in [RFC2434], the numbers\n   in the range 0-111 are allocated by Standards\
    \ Action, 112-119 are\n   allocated through an Expert Review, and 120-127 are\
    \ reserved for\n   Private Use.\n     - IPv4 LOCAL_LINK_ID              (C-Type\
    \ = 1)\n     - IPv4 REMOTE_LINK_ID             (C-Type = 2)\n     - IPv6 LOCAL_LINK_ID\
    \              (C-Type = 3)\n     - IPv6 REMOTE_LINK_ID             (C-Type =\
    \ 4)\n     - Unnumbered LOCAL_LINK_ID        (C-Type = 5)\n     - Unnumbered REMOTE_LINK_ID\
    \       (C-Type = 6)\n   o INTERFACE_ID          Class name (4)\n   The INTERFACE_ID\
    \ Object Class type name space should be allocated as\n   follows: pursuant to\
    \ the policies outlined in [RFC2434], the numbers\n   in the range 0-111 are allocated\
    \ by Standards Action, 112-119 are\n   allocated through an Expert Review, and\
    \ 120-127 are reserved for\n   Private Use.\n     - IPv4 LOCAL_INTERFACE_ID  \
    \       (C-Type = 1)\n     - IPv4 REMOTE_INTERFACE_ID        (C-Type = 2)\n  \
    \   - IPv6 LOCAL_INTERFACE_ID         (C-Type = 3)\n     - IPv6 REMOTE_INTERFACE_ID\
    \        (C-Type = 4)\n     - Unnumbered LOCAL_INTERFACE_ID   (C-Type = 5)\n \
    \    - Unnumbered REMOTE_INTERFACE_ID  (C-Type = 6)\n   o MESSAGE_ID         \
    \   Class name (5)\n   The MESSAGE_ID Object Class type name space should be allocated\
    \ as\n   follows: pursuant to the policies outlined in [RFC2434], the numbers\n\
    \   in the range 0-111 are allocated by Standards Action, 112-119 are\n   allocated\
    \ through an Expert Review, and 120-127 are reserved for\n   Private Use.\n  \
    \   - MESSAGE_ID                      (C-Type = 1)\n     - MESSAGE_ID_ACK    \
    \              (C-Type = 2)\n   o CONFIG                Class name (6)\n   The\
    \ CONFIG Object Class type name space should be allocated as\n   follows: pursuant\
    \ to the policies outlined in [RFC2434], the numbers\n   in the range 0-111 are\
    \ allocated by Standards Action, 112-119 are\n   allocated through an Expert Review,\
    \ and 120-127 are reserved for\n   Private Use.\n     - HELLO_CONFIG         \
    \           (C-Type = 1)\n   o HELLO                 Class name (7)\n   The HELLO\
    \ Object Class type name space should be allocated as\n   follows: pursuant to\
    \ the policies outlined in [RFC2434], the numbers\n   in the range 0-111 are allocated\
    \ by Standards Action, 112-119 are\n   allocated through an Expert Review, and\
    \ 120-127 are reserved for\n   Private Use.\n     - HELLO                    \
    \       (C-Type = 1)\n   o BEGIN_VERIFY          Class name (8)\n   The BEGIN_VERIFY\
    \ Object Class type name space should be allocated as\n   follows: pursuant to\
    \ the policies outlined in [RFC2434], the numbers\n   in the range 0-111 are allocated\
    \ by Standards Action, 112-119 are\n   allocated through an Expert Review, and\
    \ 120-127 are reserved for\n   Private Use.\n     - Type 1                   \
    \       (C-Type = 1)\n   o BEGIN_VERIFY_ACK      Class name (9)\n   The BEGIN_VERIFY_ACK\
    \ Object Class type name space should be allocated\n   as follows: pursuant to\
    \ the policies outlined in [RFC2434], the\n   numbers in the range 0-111 are allocated\
    \ by Standards Action, 112-119\n   are allocated through an Expert Review, and\
    \ 120-127 are reserved for\n   Private Use.\n     - Type 1                   \
    \       (C-Type = 1)\n   o VERIFY_ID             Class name (10)\n   The VERIFY_ID\
    \ Object Class type name space should be allocated as\n   follows: pursuant to\
    \ the policies outlined in [RFC2434], the numbers\n   in the range 0-111 are allocated\
    \ by Standards Action, 112-119 are\n   allocated through an Expert Review, and\
    \ 120-127 are reserved for\n   Private Use.\n     - Type 1                   \
    \       (C-Type = 1)\n   o TE_LINK               Class name (11)\n   The TE_LINK\
    \ Object Class type name space should be allocated as\n   follows: pursuant to\
    \ the policies outlined in [RFC2434], the numbers\n   in the range 0-111 are allocated\
    \ by Standards Action, 112-119 are\n   allocated through an Expert Review, and\
    \ 120-127 are reserved for\n   Private Use.\n     - IPv4 TE_LINK             \
    \       (C-Type = 1)\n     - IPv6 TE_LINK                    (C-Type = 2)\n  \
    \   - Unnumbered TE_LINK              (C-Type = 3)\n   o DATA_LINK           \
    \  Class name (12)\n   The DATA_LINK Object Class type name space should be allocated\
    \ as\n   follows: pursuant to the policies outlined in [RFC2434], the numbers\n\
    \   in the range 0-111 are allocated by Standards Action, 112-119 are\n   allocated\
    \ through an Expert Review, and 120-127 are reserved for\n   private Use.\n  \
    \  - IPv4 DATA_LINK                  (C-Type = 1)\n    - IPv6 DATA_LINK      \
    \            (C-Type = 2)\n    - Unnumbered DATA_LINK            (C-Type = 3)\n\
    \   The DATA_LINK Sub-object Class name space should be allocated as\n   follows:\
    \ pursuant to the policies outlined in [RFC2434], the numbers\n   in the range\
    \ of 0-127 are allocated by Standards Action, 128-247 are\n   allocated through\
    \ an Expert Review, and 248-255 are reserved for\n   private Use.\n    - Interface\
    \ Switching Type        (sub-object Type = 1)\n    - Wavelength              \
    \        (sub-object Type = 2)\n   o CHANNEL_STATUS        Class name (13)\n \
    \  The CHANNEL_STATUS Object Class type name space should be allocated\n   as\
    \ follows: pursuant to the policies outlined in [RFC2434], the\n   numbers in\
    \ the range 0-111 are allocated by Standards Action, 112-119\n   are allocated\
    \ through an Expert Review, and 120-127 are reserved for\n   Private Use.\n  \
    \  - IPv4 INTERFACE_ID               (C-Type = 1)\n    - IPv6 INTERFACE_ID   \
    \            (C-Type = 2)\n    - Unnumbered INTERFACE_ID         (C-Type = 3)\n\
    \   o CHANNEL_STATUS_REQUESTClass name (14)\n   The CHANNEL_STATUS_REQUEST Object\
    \ Class type name space should be\n   allocated as follows: pursuant to the policies\
    \ outlined in [RFC2434],\n   the numbers in the range 0-111 are allocated by Standards\
    \ Action,\n   112-119 are allocated through an Expert Review, and 120-127 are\n\
    \   reserved for Private Use.\n    - IPv4 INTERFACE_ID               (C-Type =\
    \ 1)\n    - IPv6 INTERFACE_ID               (C-Type = 2)\n    - Unnumbered INTERFACE_ID\
    \         (C-Type = 3)\n   o ERROR_CODE            Class name (20)\n   The ERROR_CODE\
    \ Object Class type name space should be allocated as\n   follows: pursuant to\
    \ the policies outlined in [RFC2434], the numbers\n   in the range 0-111 are allocated\
    \ by Standards Action, 112-119 are\n   allocated through an Expert Review, and\
    \ 120-127 are reserved for\n   private Use.\n    - BEGIN_VERIFY_ERROR        \
    \      (C-Type = 1)\n    - LINK_SUMMARY_ERROR              (C-Type = 2)\n"
- title: 17.  Acknowledgements
  contents:
  - "17.  Acknowledgements\n   The authors would like to thank Andre Fredette for\
    \ his many\n   contributions to this document.  We would also like to thank Ayan\n\
    \   Banerjee, George Swallow, Adrian Farrel, Dimitri Papadimitriou, Vinay\n  \
    \ Ravuri, and David Drysdale for their insightful comments and\n   suggestions.\
    \  We would also like to thank John Yu, Suresh Katukam,\n   and Greg Bernstein\
    \ for their helpful suggestions for the in-band\n   control channel applicability.\n"
- title: 18.  Contributors
  contents:
  - "18.  Contributors\n   Jonathan P. Lang\n   Sonos, Inc.\n   223 E. De La Guerra\
    \ St.\n   Santa Barbara, CA 93101\n   EMail: jplang@ieee.org\n   Krishna Mitra\n\
    \   Independent Consultant\n   EMail: kmitra@earthlink.net\n   John Drake\n  \
    \ Calient Networks\n   5853 Rue Ferrari\n   San Jose, CA 95138\n   EMail: jdrake@calient.net\n\
    \   Kireeti Kompella\n   Juniper Networks, Inc.\n   1194 North Mathilda Avenue\n\
    \   Sunnyvale, CA 94089\n   EMail: kireeti@juniper.net\n   Yakov Rekhter\n   Juniper\
    \ Networks, Inc.\n   1194 North Mathilda Avenue\n   Sunnyvale, CA 94089\n   EMail:\
    \ yakov@juniper.net\n   Lou Berger\n   Movaz Networks\n   EMail: lberger@movaz.com\n\
    \   Debanjan Saha\n   IBM Watson Research Center\n   EMail: dsaha@us.ibm.com\n\
    \   Debashis Basak\n   Accelight Networks\n   70 Abele Road, Suite 1201\n   Bridgeville,\
    \ PA 15017-3470\n   EMail: dbasak@accelight.com\n   Hal Sandick\n   Shepard M.S.\n\
    \   2401 Dakota Street\n   Durham, NC 27705\n   EMail: sandick@nc.rr.com\n   Alex\
    \ Zinin\n   Alcatel\n   EMail: alex.zinin@alcatel.com\n   Bala Rajagopalan\n \
    \  Intel Corp.\n   2111 NE 25th Ave\n   Hillsboro, OR 97123\n   EMail: bala.rajagopalan@intel.com\n\
    \   Sankar Ramamoorthi\n   Juniper Networks, Inc.\n   1194 North Mathilda Avenue\n\
    \   Sunnyvale, CA 94089\n   EMail: sankarr@juniper.net\n"
- title: Contact Address
  contents:
  - "Contact Address\n   Jonathan P. Lang\n   Sonos, Inc.\n   829 De La Vina, Suite\
    \ 220\n   Santa Barbara, CA 93101\n   EMail: jplang@ieee.org\n"
- title: Full Copyright Statement
  contents:
  - "Full Copyright Statement\n   Copyright (C) The Internet Society (2005).\n   This\
    \ document is subject to the rights, licenses and restrictions\n   contained in\
    \ BCP 78, and except as set forth therein, the authors\n   retain all their rights.\n\
    \   This document and the information contained herein are provided on an\n  \
    \ \"AS IS\" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS\n  \
    \ OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY AND THE INTERNET\n   ENGINEERING\
    \ TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS OR IMPLIED,\n   INCLUDING BUT NOT\
    \ LIMITED TO ANY WARRANTY THAT THE USE OF THE\n   INFORMATION HEREIN WILL NOT\
    \ INFRINGE ANY RIGHTS OR ANY IMPLIED\n   WARRANTIES OF MERCHANTABILITY OR FITNESS\
    \ FOR A PARTICULAR PURPOSE.\n"
- title: Intellectual Property
  contents:
  - "Intellectual Property\n   The IETF takes no position regarding the validity or\
    \ scope of any\n   Intellectual Property Rights or other rights that might be\
    \ claimed to\n   pertain to the implementation or use of the technology described\
    \ in\n   this document or the extent to which any license under such rights\n\
    \   might or might not be available; nor does it represent that it has\n   made\
    \ any independent effort to identify any such rights.  Information\n   on the\
    \ procedures with respect to rights in RFC documents can be\n   found in BCP 78\
    \ and BCP 79.\n   Copies of IPR disclosures made to the IETF Secretariat and any\n\
    \   assurances of licenses to be made available, or the result of an\n   attempt\
    \ made to obtain a general license or permission for the use of\n   such proprietary\
    \ rights by implementers or users of this\n   specification can be obtained from\
    \ the IETF on-line IPR repository at\n   http://www.ietf.org/ipr.\n   The IETF\
    \ invites any interested party to bring to its attention any\n   copyrights, patents\
    \ or patent applications, or other proprietary\n   rights that may cover technology\
    \ that may be required to implement\n   this standard.  Please address the information\
    \ to the IETF at ietf-\n   ipr@ietf.org.\n"
- title: Acknowledgement
  contents:
  - "Acknowledgement\n   Funding for the RFC Editor function is currently provided\
    \ by the\n   Internet Society.\n"
