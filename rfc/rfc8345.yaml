- contents:
  - '                A YANG Data Model for Network Topologies

    '
  title: __initial_text__
- contents:
  - "Abstract\n   This document defines an abstract (generic, or base) YANG data model\n
    \  for network/service topologies and inventories.  The data model\n   serves
    as a base model that is augmented with technology-specific\n   details in other,
    more specific topology and inventory data models.\n"
  title: Abstract
- contents:
  - "Status of This Memo\n   This is an Internet Standards Track document.\n   This
    document is a product of the Internet Engineering Task Force\n   (IETF).  It represents
    the consensus of the IETF community.  It has\n   received public review and has
    been approved for publication by the\n   Internet Engineering Steering Group (IESG).
    \ Further information on\n   Internet Standards is available in Section 2 of RFC
    7841.\n   Information about the current status of this document, any errata,\n
    \  and how to provide feedback on it may be obtained at\n   https://www.rfc-editor.org/info/rfc8345.\n"
  title: Status of This Memo
- contents:
  - "Copyright Notice\n   Copyright (c) 2018 IETF Trust and the persons identified
    as the\n   document authors.  All rights reserved.\n   This document is subject
    to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n
    \  (https://trustee.ietf.org/license-info) in effect on the date of\n   publication
    of this document.  Please review these documents\n   carefully, as they describe
    your rights and restrictions with respect\n   to this document.  Code Components
    extracted from this document must\n   include Simplified BSD License text as described
    in Section 4.e of\n   the Trust Legal Provisions and are provided without warranty
    as\n   described in the Simplified BSD License.\n"
  title: Copyright Notice
- contents:
  - "Table of Contents\n   1. Introduction ....................................................4\n
    \  2. Key Words .......................................................8\n   3.
    Definitions and Abbreviations ...................................9\n   4. Model
    Structure Details .........................................9\n      4.1. Base
    Network Model .........................................9\n      4.2. Base Network
    Topology Data Model ..........................12\n      4.3. Extending the Data
    Model ..................................13\n      4.4. Discussion and Selected
    Design Decisions ..................14\n           4.4.1. Container Structure ................................14\n
    \          4.4.2. Underlay Hierarchies and Mappings ..................14\n           4.4.3.
    Dealing with Changes in Underlay Networks ..........15\n           4.4.4. Use
    of Groupings ...................................15\n           4.4.5. Cardinality
    and Directionality of Links ............16\n           4.4.6. Multihoming and
    Link Aggregation ...................16\n           4.4.7. Mapping Redundancy .................................16\n
    \          4.4.8. Typing .............................................17\n           4.4.9.
    Representing the Same Device in Multiple Networks ..17\n           4.4.10. Supporting
    Client-Configured and\n                   System-Controlled Network Topologies
    ..............18\n           4.4.11. Identifiers of String or URI Type .................19\n
    \  5. Interactions with Other YANG Modules ...........................19\n   6.
    YANG Modules ...................................................20\n      6.1.
    Defining the Abstract Network: ietf-network ...............20\n      6.2. Creating
    Abstract Network Topology:\n           ietf-network-topology .....................................25\n
    \  7. IANA Considerations ............................................32\n   8.
    Security Considerations ........................................33\n   9. References
    .....................................................35\n      9.1. Normative
    References ......................................35\n      9.2. Informative References
    ....................................36\n   Appendix A. Model Use Cases .......................................38\n
    \    A.1. Fetching Topology from a Network Element ...................38\n     A.2.
    Modifying TE Topology Imported from an Optical Controller ..38\n     A.3. Annotating
    Topology for Local Computation ..................39\n     A.4. SDN Controller-Based
    Configuration of Overlays on Top of\n          Underlays ..................................................39\n
    \  Appendix B. Companion YANG Data Models for Implementations Not\n               Compliant
    with NMDA ...................................39\n     B.1. YANG Module for Network
    State ..............................40\n     B.2. YANG Module for Network Topology
    State .....................45\n   Appendix C. An Example ............................................52\n
    \  Acknowledgments ...................................................56\n   Contributors
    ......................................................56\n   Authors' Addresses
    ................................................57\n"
  title: Table of Contents
- contents:
  - "1.  Introduction\n   This document introduces an abstract (base) YANG [RFC7950]
    data model\n   [RFC3444] to represent networks and topologies.  The data model
    is\n   divided into two parts: The first part of the data model defines a\n   network
    data model that enables the definition of network\n   hierarchies, or network
    stacks (i.e., networks that are layered on\n   top of each other) and maintenance
    of an inventory of nodes contained\n   in a network.  The second part of the data
    model augments the basic\n   network data model with information to describe topology
    information.\n   Specifically, it adds the concepts of \"links\" and\n   \"termination
    points\" to describe how nodes in a network are connected\n   to each other.  Moreover,
    the data model introduces vertical layering\n   relationships between networks
    that can be augmented to cover both\n   network inventories and network/service
    topologies.\n   Although it would be possible to combine both parts into a single\n
    \  data model, the separation facilitates integration of network\n   topology
    and network inventory data models, because it allows network\n   inventory information
    to be augmented separately, and without concern\n   for topology, into the network
    data model.\n   The data model can be augmented to describe the specifics of\n
    \  particular types of networks and topologies.  For example, an\n   augmenting
    data model can provide network node information with\n   attributes that are specific
    to a particular network type.  Examples\n   of augmenting models include data
    models for Layer 2 network\n   topologies; Layer 3 network topologies such as
    unicast IGP, IS-IS\n   [RFC1195], and OSPF [RFC2328]; traffic engineering (TE)
    data\n   [RFC3209]; or any of the variety of transport and service topologies.\n
    \  Information specific to particular network types will be captured in\n   separate,
    technology-specific data models.\n   The basic data models introduced in this
    document are generic in\n   nature and can be applied to many network and service
    topologies and\n   inventories.  The data models allow applications to operate
    on an\n   inventory or topology of any network at a generic level, where the\n
    \  specifics of particular inventory/topology types are not required.\n   At the
    same time, where data specific to a network type comes into\n   play and the data
    model is augmented, the instantiated data still\n   adheres to the same structure
    and is represented in a consistent\n   fashion.  This also facilitates the representation
    of network\n   hierarchies and dependencies between different network components
    and\n   network types.\n   The abstract (base) network YANG module introduced
    in this document,\n   entitled \"ietf-network\" (Section 6.1), contains a list
    of abstract\n   network nodes and defines the concept of \"network hierarchy\"
    (network\n   stack).  The abstract network node can be augmented in inventory
    and\n   topology data models with inventory-specific and topology-specific\n   attributes.
    \ The network hierarchy (stack) allows any given network\n   to have one or more
    \"supporting networks\".  The relationship between\n   the base network data model,
    the inventory data models, and the\n   topology data models is shown in Figure
    1 (dotted lines in the figure\n   denote possible augmentations to models defined
    in this document).\n                         +------------------------+\n                         |
    \                       |\n                         | Abstract Network Model |\n
    \                        |                        |\n                         +------------------------+\n
    \                                     |\n                              +-------+-------+\n
    \                             |               |\n                              V
    \              V\n                       +------------+  ..............\n                       |
    \ Abstract  |  : Inventory  :\n                       |  Topology  |  :  Model(s)
    \ :\n                       |   Model    |  :            :\n                       +------------+
    \ ''''''''''''''\n                              |\n                +-------------+-------------+-------------+\n
    \               |             |             |             |\n                V
    \            V             V             V\n          ............  ............
    \ ............  ............\n          :    L1    :  :    L2    :  :    L3    :
    \ :  Service :\n          : Topology :  : Topology :  : Topology :  : Topology
    :\n          :   Model  :  :   Model  :  :   Model  :  :   Model  :\n          ''''''''''''
    \ ''''''''''''  ''''''''''''  ''''''''''''\n                Figure 1: The Network
    Data Model Structure\n   The network-topology YANG module introduced in this document,\n
    \  entitled \"ietf-network-topology\" (Section 6.2), defines a generic\n   topology
    data model at its most general level of abstraction.  The\n   module defines a
    topology graph and components from which it is\n   composed: nodes, edges, and
    termination points.  Nodes (from the\n   \"ietf-network\" module) represent graph
    vertices and links represent\n   graph edges.  Nodes also contain termination
    points that anchor the\n   links.  A network can contain multiple topologies --
    for example,\n   topologies at different layers and overlay topologies.  The data\n
    \  model therefore allows relationships between topologies, as well as\n   dependencies
    between nodes and termination points across topologies,\n   to be captured.  An
    example of a topology stack is shown in Figure 2.\n                    +---------------------------------------+\n
    \                  /            _[X1]_          \"Service\"  /\n                  /
    \          _/  :   \\_                  /\n                 /          _/     :
    \   \\_               /\n                /         _/        :     \\_            /\n
    \              /         /           :      \\          /\n              /       [X2]__________________[X3]
    \     /\n             +---------:--------------:------:-------+\n                        :
    \             :     :\n                    +----:--------------:----:--------------+\n
    \                  /      :              :   :        \"L3\" /\n                  /
    \       :              :  :            /\n                 /         :               :
    :           /\n                /         [Y1]_____________[Y2]         /\n               /
    \          *               * *         /\n              /            *              *
    \ *        /\n             +--------------*-------------*--*-------+\n                             *
    \          *   *\n                    +--------*----------*----*--------------+\n
    \                  /     [Z1]_______________[Z2] \"Optical\" /\n                  /
    \        \\_         *   _/             /\n                 /            \\_      *
    \ _/              /\n                /               \\_   * _/               /\n
    \              /                  \\ * /                /\n              /                    [Z]
    \               /\n             +---------------------------------------+\n               Figure
    2: Topology Hierarchy (Stack) Example\n   Figure 2 shows three topology levels.
    \ At the top, the \"Service\"\n   topology shows relationships between service
    entities, such as\n   service functions in a service chain.  The \"L3\" topology
    shows\n   network elements at Layer 3 (IP), and the \"Optical\" topology shows\n
    \  network elements at Layer 1.  Service functions in the \"Service\"\n   topology
    are mapped onto network elements in the \"L3\" topology, which\n   in turn are
    mapped onto network elements in the \"Optical\" topology.\n   Two service functions
    (X1 and X3) are mapped onto a single L3 network\n   element (Y2); this could happen,
    for example, if two service\n   functions reside in the same Virtual Machine (VM)
    (or server) and\n   share the same set of network interfaces.  A single \"L3\"
    network\n   element (Y2) is mapped onto two \"Optical\" network elements (Z2 and\n
    \  Z).  This could happen, for example, if a single IP router attaches\n   to
    multiple Reconfigurable Optical Add/Drop Multiplexers (ROADMs) in\n   the optical
    domain.\n   Another example of a service topology stack is shown in Figure 3.\n
    \                                VPN1                       VPN2\n               +---------------------+
    \   +---------------------+\n              /   [Y5]...           /    / [Z5]______[Z3]
    \     /\n             /    /  \\  :          /    /  : \\_       / :     /\n            /
    \   /    \\  :        /    /   :   \\_    /  :    /\n           /    /      \\
    \ :      /    /   :      \\  /   :   /\n          /   [Y4]____[Y1] :    /    /
    \  :       [Z2]   :  /\n         +------:-------:---:--+    +---:---------:-----:-+\n
    \               :        :   :         :          :     :\n                :         :
    \  :       :           :     :\n                :  +-------:---:-----:------------:-----:-----+\n
    \               : /       [X1]__:___:___________[X2]   :     /\n                :/
    \        / \\_  : :       _____/ /   :     /\n                :         /    \\_
    :  _____/      /   :     /\n               /:        /       \\: /           /
    \  :     /\n              / :       /        [X5]          /   :     /\n             /
    \  :     /       __/ \\__        /   :     /\n            /     :   /    ___/
    \      \\__    /   :     /\n           /       : / ___/              \\  /   :
    \    /\n          /        [X4]__________________[X3]..:     /\n         +------------------------------------------+\n
    \                                       L3 Topology\n               Figure 3:
    Topology Hierarchy (Stack) Example\n   Figure 3 shows two VPN service topologies
    (VPN1 and VPN2)\n   instantiated over a common L3 topology.  Each VPN service
    topology is\n   mapped onto a subset of nodes from the common L3 topology.\n   There
    are multiple applications for such a data model.  For example,\n   within the
    context of Interface to the Routing System (I2RS), nodes\n   within the network
    can use the data model to capture their\n   understanding of the overall network
    topology and expose it to a\n   network controller.  A network controller can
    then use the\n   instantiated topology data to compare and reconcile its own view
    of\n   the network topology with that of the network elements that it\n   controls.
    \ Alternatively, nodes within the network could propagate\n   this understanding
    to compare and reconcile this understanding either\n   among themselves or with
    the help of a controller.  Beyond the\n   network element and the immediate context
    of I2RS itself, a network\n   controller might even use the data model to represent
    its view of the\n   topology that it controls and expose it to applications north
    of\n   itself.  Further use cases where the data model can be applied are\n   described
    in [USECASE-REQS].\n   In this data model, a network is categorized as either
    system\n   controlled or not.  If a network is system controlled, then it is\n
    \  automatically populated by the server and represents dynamically\n   learned
    information that can be read from the operational state\n   datastore.  The data
    model can also be used to create or modify\n   network topologies that might be
    associated with an inventory model\n   or with an overlay network.  Such a network
    is not system controlled;\n   rather, it is configured by a client.\n   The data
    model allows a network to refer to a supporting network,\n   supporting nodes,
    supporting links, etc.  The data model also allows\n   the layering of a network
    that is configured on top of a network that\n   is system controlled.  This permits
    the configuration of overlay\n   networks on top of networks that are discovered.
    \ Specifically, this\n   data model is structured to support being implemented
    as part of the\n   ephemeral datastore [RFC8342], the requirements for which are
    defined\n   in Section 3 of [RFC8242].  This allows network topology data that
    is\n   written, i.e., configured by a client and not system controlled, to\n   refer
    to dynamically learned data that is controlled by the system,\n   not configured
    by a client.  A simple use case might involve creating\n   an overlay network
    that is supported by the dynamically discovered\n   IP-routed network topology.
    \ When an implementation places written\n   data for this data model in the ephemeral
    datastore, such a network\n   MAY refer to another network that is system controlled.\n"
  title: 1.  Introduction
- contents:
  - "2.  Key Words\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\",
    \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"NOT RECOMMENDED\",
    \"MAY\", and\n   \"OPTIONAL\" in this document are to be interpreted as described
    in\n   BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all\n   capitals,
    as shown here.\n"
  title: 2.  Key Words
- contents:
  - "3.  Definitions and Abbreviations\n   Datastore:  A conceptual place to store
    and access information.  A\n      datastore might be implemented, for example,
    using files, a\n      database, flash memory locations, or combinations thereof.
    \ A\n      datastore maps to an instantiated YANG data tree (definition from\n
    \     [RFC8342]).\n   Data subtree:  An instantiated data node and the data nodes
    that are\n      hierarchically contained within it.\n   IGP:  Interior Gateway
    Protocol.\n   IS-IS:  Intermediate System to Intermediate System.\n   OSPF:  Open
    Shortest Path First (a link-state routing protocol).\n   SDN:  Software-Defined
    Networking.\n   URI:  Uniform Resource Identifier.\n   VM:  Virtual Machine.\n"
  title: 3.  Definitions and Abbreviations
- contents:
  - '4.  Model Structure Details

    '
  - contents:
    - "4.1.  Base Network Model\n   The abstract (base) network data model is defined
      in the\n   \"ietf-network\" module.  Its structure is shown in Figure 4.  The\n
      \  notation syntax follows the syntax used in [RFC8340].\n   module: ietf-network\n
      \    +--rw networks\n        +--rw network* [network-id]\n           +--rw network-id
      \           network-id\n           +--rw network-types\n           +--rw supporting-network*
      [network-ref]\n           |  +--rw network-ref    -> /networks/network/network-id\n
      \          +--rw node* [node-id]\n              +--rw node-id            node-id\n
      \             +--rw supporting-node* [network-ref node-ref]\n                 +--rw
      network-ref\n                 |       -> ../../../supporting-network/network-ref\n
      \                +--rw node-ref       -> /networks/network/node/node-id\n     Figure
      4: The Structure of the Abstract (Base) Network Data Model\n   The data model
      contains a container with a list of networks.  Each\n   network is captured
      in its own list entry, distinguished via a\n   network-id.\n   A network has
      a certain type, such as L2, L3, OSPF, or IS-IS.  A\n   network can even have
      multiple types simultaneously.  The type or\n   types are captured underneath
      the container \"network-types\".  In this\n   model, it serves merely as an
      augmentation target; network-specific\n   modules will later introduce new data
      nodes to represent new network\n   types below this target, i.e., will insert
      them below \"network-types\"\n   via YANG augmentation.\n   When a network is
      of a certain type, it will contain a corresponding\n   data node.  Network types
      SHOULD always be represented using presence\n   containers, not leafs of type
      \"empty\".  This allows the\n   representation of hierarchies of network subtypes
      within the instance\n   information.  For example, an instance of an OSPF network
      (which, at\n   the same time, is a Layer 3 unicast IGP network) would contain\n
      \  underneath \"network-types\" another presence container\n   \"l3-unicast-igp-network\",
      which in turn would contain a presence\n   container \"ospf-network\".  Actual
      examples of this pattern can be\n   found in [RFC8346].\n   A network can in
      turn be part of a hierarchy of networks, building on\n   top of other networks.
      \ Any such networks are captured in the list\n   \"supporting-network\".  A
      supporting network is, in effect, an\n   underlay network.\n   Furthermore,
      a network contains an inventory of nodes that are part\n   of the network.  The
      nodes of a network are captured in their own\n   list.  Each node is identified
      relative to its containing network by\n   a node-id.\n   It should be noted
      that a node does not exist independently of a\n   network; instead, it is a
      part of the network that contains it.  In\n   cases where the same device or
      entity takes part in multiple\n   networks, or at multiple layers of a networking
      stack, the same\n   device or entity will be represented by multiple nodes,
      one for each\n   network.  In other words, the node represents an abstraction
      of the\n   device for the particular network of which it is a part.  To indicate\n
      \  that the same entity or device is part of multiple topologies or\n   networks,
      it is possible to create one \"physical\" network with a list\n   of nodes for
      each of the devices or entities.  This (physical)\n   network -- the nodes (entities)
      in that network -- can then be\n   referred to as an underlay network and as
      nodes from the other\n   (logical) networks and nodes, respectively.  Note that
      the data model\n   allows for the definition of more than one underlay network
      (and\n   node), allowing for simultaneous representation of layered network\n
      \  topologies and service topologies, and their physical instantiation.\n   Similar
      to a network, a node can be supported by other nodes and map\n   onto one or
      more other nodes in an underlay network.  This is\n   captured in the list \"supporting-node\".
      \ The resulting hierarchy of\n   nodes also allows for the representation of
      device stacks, where a\n   node at one level is supported by a set of nodes
      at an underlying\n   level.  For example:\n   o  a \"router\" node might be
      supported by a node representing a route\n      processor and separate nodes
      for various line cards and service\n      modules,\n   o  a virtual router might
      be supported or hosted on a physical device\n      represented by a separate
      node,\n   and so on.\n   Network data of a network at a particular layer can
      come into being\n   in one of two ways: (1) the network data is configured by
      client\n   applications -- for example, in the case of overlay networks that
      are\n   configured by an SDN Controller application, or (2) the network data\n
      \  is automatically controlled by the system, in the case of networks\n   that
      can be discovered.  It is possible for a configured (overlay)\n   network to
      refer to a (discovered) underlay network.\n   The revised datastore architecture
      [RFC8342] is used to account for\n   those possibilities.  Specifically, for
      each network, the origin of\n   its data is indicated per the \"origin\" metadata
      [RFC7952] annotation\n   (as defined in [RFC8342]) -- \"intended\" for data
      that was configured\n   by a client application and \"learned\" for data that
      is discovered.\n   Network data that is discovered is automatically populated
      as part of\n   the operational state datastore.  Network data that is configured
      is\n   part of the configuration and intended datastores, respectively.\n   Configured
      network data that is actually in effect is, in addition,\n   reflected in the
      operational state datastore.  Data in the\n   operational state datastore will
      always have complete referential\n   integrity.  Should a configured data item
      (such as a node) have a\n   dangling reference that refers to a non-existing
      data item (such as a\n   supporting node), the configured data item will automatically
      be\n   removed from the operational state datastore and thus only appear in\n
      \  the intended datastore.  It will be up to the client application\n   (such
      as an SDN Controller) to resolve the situation and ensure that\n   the reference
      to the supporting resources is configured properly.\n"
    title: 4.1.  Base Network Model
  - contents:
    - "4.2.  Base Network Topology Data Model\n   The abstract (base) network topology
      data model is defined in the\n   \"ietf-network-topology\" module.  It builds
      on the network data model\n   defined in the \"ietf-network\" module, augmenting
      it with links\n   (defining how nodes are connected) and termination points
      (which\n   anchor the links and are contained in nodes).  The structure of the\n
      \  network topology module is shown in Figure 5.  The notation syntax\n   follows
      the syntax used in [RFC8340].\n   module: ietf-network-topology\n     augment
      /nw:networks/nw:network:\n       +--rw link* [link-id]\n          +--rw link-id
      \           link-id\n          +--rw source\n          |  +--rw source-node?
      \  -> ../../../nw:node/node-id\n          |  +--rw source-tp?     leafref\n
      \         +--rw destination\n          |  +--rw dest-node?   -> ../../../nw:node/node-id\n
      \         |  +--rw dest-tp?     leafref\n          +--rw supporting-link* [network-ref
      link-ref]\n             +--rw network-ref\n             |       -> ../../../nw:supporting-network/network-ref\n
      \            +--rw link-ref       leafref\n     augment /nw:networks/nw:network/nw:node:\n
      \      +--rw termination-point* [tp-id]\n          +--rw tp-id                           tp-id\n
      \         +--rw supporting-termination-point*\n                  [network-ref
      node-ref tp-ref]\n             +--rw network-ref\n             |       -> ../../../nw:supporting-node/network-ref\n
      \            +--rw node-ref\n             |       -> ../../../nw:supporting-node/node-ref\n
      \            +--rw tp-ref         leafref\n      Figure 5: The Structure of
      the Abstract (Base) Network Topology\n                                Data Model\n
      \  A node has a list of termination points that are used to terminate\n   links.
      \ An example of a termination point might be a physical or\n   logical port
      or, more generally, an interface.\n   Like a node, a termination point can in
      turn be supported by an\n   underlying termination point, contained in the supporting
      node of the\n   underlay network.\n   A link is identified by a link-id that
      uniquely identifies the link\n   within a given topology.  Links are point-to-point
      and\n   unidirectional.  Accordingly, a link contains a source and a\n   destination.
      \ Both source and destination reference a corresponding\n   node, as well as
      a termination point on that node.  Similar to a\n   node, a link can map onto
      one or more links (which are terminated by\n   the corresponding underlay termination
      points) in an underlay\n   topology.  This is captured in the list \"supporting-link\".\n"
    title: 4.2.  Base Network Topology Data Model
  - contents:
    - "4.3.  Extending the Data Model\n   In order to derive a data model for a specific
      type of network, the\n   base data model can be extended.  This can be done
      roughly as\n   follows: a new YANG module for the new network type is introduced.\n
      \  In this module, a number of augmentations are defined against the\n   \"ietf-network\"
      and \"ietf-network-topology\" modules.\n   We start with augmentations against
      the \"ietf-network\" module.\n   First, a new network type needs to be defined;
      this is done by\n   defining a presence container that represents the new network
      type.\n   The new network type is inserted, by means of augmentation, below
      the\n   network-types container.  Subsequently, data nodes for any node\n   parameters
      that are specific to a network type are defined and\n   augmented into the node
      list.  The new data nodes can be defined as\n   conditional (\"when\") on the
      presence of the corresponding network\n   type in the containing network.  In
      cases where there are any\n   requirements or restrictions in terms of network
      hierarchies, such as\n   when a network of a new network type requires a specific
      type of\n   underlay network, it is possible to define corresponding constraints\n
      \  as well and augment the supporting-network list accordingly.\n   However,
      care should be taken to avoid excessive definitions of\n   constraints.\n   Subsequently,
      augmentations are defined against the\n   \"ietf-network-topology\" module.
      \ Data nodes are defined for link\n   parameters, as well as termination point
      parameters, that are\n   specific to the new network type.  Those data nodes
      are inserted via\n   augmentation into the link and termination-point lists,
      respectively.\n   Again, data nodes can be defined as conditional on the presence
      of\n   the corresponding network type in the containing network, by adding a\n
      \  corresponding \"when\" statement.\n   It is possible, but not required, to
      group data nodes for a given\n   network type under a dedicated container.  Doing
      so introduces\n   additional structure but lengthens data node path names.\n
      \  In cases where a hierarchy of network types is defined, augmentations\n   can
      in turn be applied against augmenting modules, with the module of\n   a network
      whose type is more specific augmenting the module of a\n   network whose type
      is more general.\n"
    title: 4.3.  Extending the Data Model
  - contents:
    - '4.4.  Discussion and Selected Design Decisions

      '
    - contents:
      - "4.4.1.  Container Structure\n   Rather than maintaining lists in separate
        containers, the data model\n   is kept relatively flat in terms of its containment
        structure.  Lists\n   of nodes, links, termination points, and supporting
        nodes; supporting\n   links; and supporting termination points are not kept
        in separate\n   containers.  Therefore, path identifiers that are used to
        refer to\n   specific nodes -- in management operations or in specifications
        of\n   constraints -- can remain relatively compact.  Of course, this means\n
        \  that there is no separate structure in instance information that\n   separates
        elements of different lists from one another.  Such a\n   structure is semantically
        not required, but it might provide enhanced\n   \"human readability\" in some
        cases.\n"
      title: 4.4.1.  Container Structure
    - contents:
      - "4.4.2.  Underlay Hierarchies and Mappings\n   To minimize assumptions regarding
        what a particular entity might\n   actually represent, mappings between networks,
        nodes, links, and\n   termination points are kept strictly generic.  For example,
        no\n   assumptions are made regarding whether a termination point actually\n
        \  refers to an interface or whether a node refers to a specific\n   \"system\"
        or device; the data model at this generic level makes no\n   provisions for
        these.\n   Where additional specifics about mappings between upper and lower\n
        \  layers are required, the information can be captured in augmenting\n   modules.
        \ For example, to express that a termination point in a\n   particular network
        type maps to an interface, an augmenting module\n   can introduce an augmentation
        to the termination point.  The\n   augmentation introduces a leaf of type
        \"interface-ref\".  That leaf\n   references the corresponding interface [RFC8343].
        \ Similarly, if a\n   node maps to a particular device or network element,
        an augmenting\n   module can augment the node data with a leaf that references
        the\n   network element.\n   It is possible for links at one level of a hierarchy
        to map to\n   multiple links at another level of the hierarchy.  For example,
        a VPN\n   topology might model VPN tunnels as links.  Where a VPN tunnel maps\n
        \  to a path that is composed of a chain of several links, the link will\n
        \  contain a list of those supporting links.  Likewise, it is possible\n   for
        a link at one level of a hierarchy to aggregate a bundle of links\n   at another
        level of the hierarchy.\n"
      title: 4.4.2.  Underlay Hierarchies and Mappings
    - contents:
      - "4.4.3.  Dealing with Changes in Underlay Networks\n   It is possible for
        a network to undergo churn even as other networks\n   are layered on top of
        it.  When a supporting node, link, or\n   termination point is deleted, the
        supporting leafrefs in the overlay\n   will be left dangling.  To allow for
        this possibility, the data model\n   makes use of the \"require-instance\"
        construct of YANG 1.1 [RFC7950].\n   A dangling leafref of a configured object
        leaves the corresponding\n   instance in a state in which it lacks referential
        integrity,\n   effectively rendering it nonoperational.  Any corresponding
        object\n   instance is therefore removed from the operational state datastore\n
        \  until the situation has been resolved, i.e., until either (1) the\n   supporting
        object is added to the operational state datastore or\n   (2) the instance
        is reconfigured to refer to another object that is\n   actually reflected
        in the operational state datastore.  It will\n   remain part of the intended
        datastore.\n   It is the responsibility of the application maintaining the
        overlay\n   to deal with the possibility of churn in the underlay network.
        \ When\n   a server receives a request to configure an overlay network, it\n
        \  SHOULD validate whether supporting nodes / links / termination points\n
        \  refer to nodes in the underlay that actually exist, i.e., verify that\n
        \  the nodes are reflected in the operational state datastore.\n   Configuration
        requests in which supporting nodes / links /\n   termination points refer
        to objects currently not in existence SHOULD\n   be rejected.  It is the responsibility
        of the application to update\n   the overlay when a supporting node / link
        / termination point is\n   deleted at a later point in time.  For this purpose,
        an application\n   might subscribe to updates when changes to the underlay
        occur -- for\n   example, using mechanisms defined in [YANG-Push].\n"
      title: 4.4.3.  Dealing with Changes in Underlay Networks
    - contents:
      - "4.4.4.  Use of Groupings\n   The data model makes use of groupings instead
        of simply defining data\n   nodes \"inline\".  This makes it easier to include
        the corresponding\n   data nodes in notifications, which then do not need
        to respecify each\n   data node that is to be included.  The trade-off is
        that it makes the\n   specification of constraints more complex, because constraints\n
        \  involving data nodes outside the grouping need to be specified in\n   conjunction
        with a \"uses\" statement where the grouping is applied.\n   This also means
        that constraints and XML Path Language (XPath)\n   statements need to be specified
        in such a way that they navigate\n   \"down\" first and select entire sets
        of nodes, as opposed to being\n   able to simply specify them against individual
        data nodes.\n"
      title: 4.4.4.  Use of Groupings
    - contents:
      - "4.4.5.  Cardinality and Directionality of Links\n   The topology data model
        includes links that are point-to-point and\n   unidirectional.  It does not
        directly support multipoint and\n   bidirectional links.  Although this may
        appear as a limitation, the\n   decision to do so keeps the data model simple
        and generic, and it\n   allows it to be very easily subjected to applications
        that make use\n   of graph algorithms.  Bidirectional connections can be represented\n
        \  through pairs of unidirectional links.  Multipoint networks can be\n   represented
        through pseudonodes (similar to IS-IS, for example).  By\n   introducing hierarchies
        of nodes with nodes at one level mapping onto\n   a set of other nodes at
        another level and by introducing new links\n   for nodes at that level, topologies
        with connections representing\n   non-point-to-point communication patterns
        can be represented.\n"
      title: 4.4.5.  Cardinality and Directionality of Links
    - contents:
      - "4.4.6.  Multihoming and Link Aggregation\n   Links are terminated by a single
        termination point, not sets of\n   termination points.  Connections involving
        multihoming or link\n   aggregation schemes need to be represented using multiple
        point-to-\n   point links and then defining a link at a higher layer that
        is\n   supported by those individual links.\n"
      title: 4.4.6.  Multihoming and Link Aggregation
    - contents:
      - "4.4.7.  Mapping Redundancy\n   In a hierarchy of networks, there are nodes
        mapping to nodes, links\n   mapping to links, and termination points mapping
        to termination\n   points.  Some of this information is redundant.  Specifically,
        if the\n   mapping of a link to one or more other links is known and the\n
        \  termination points of each link are known, the mapping information\n   for
        the termination points can be derived via transitive closure and\n   does
        not have to be explicitly configured.  Nonetheless, in order to\n   not constrain
        applications regarding which mappings they want to\n   configure and which
        should be derived, the data model provides the\n   option to configure this
        information explicitly.  The data model\n   includes integrity constraints
        to allow for validating for\n   consistency.\n"
      title: 4.4.7.  Mapping Redundancy
    - contents:
      - "4.4.8.  Typing\n   A network's network types are represented using a container
        that\n   contains a data node for each of its network types.  A network can\n
        \  encompass several types of networks simultaneously; hence, a\n   container
        is used instead of a case construct, with each network type\n   in turn represented
        by a dedicated presence container.  The reason\n   for not simply using an
        empty leaf, or (even more simply) even doing\n   away with the network container
        and just using a leaf-list of\n   \"network-type\" instead, is to be able
        to represent \"class\n   hierarchies\" of network types, with one network
        type \"refining\" the\n   other.  Containers specific to a network type are
        to be defined in\n   the network-specific modules, augmenting the network-types
        container.\n"
      title: 4.4.8.  Typing
    - contents:
      - "4.4.9.  Representing the Same Device in Multiple Networks\n   One common
        requirement concerns the ability to indicate that the same\n   device can
        be part of multiple networks and topologies.  However, the\n   data model
        defines a node as relative to the network that contains\n   it.  The same
        node cannot be part of multiple topologies.  In many\n   cases, a node will
        be the abstraction of a particular device in a\n   network.  To reflect that
        the same device is part of multiple\n   topologies, the following approach
        might be chosen: a new type of\n   network to represent a \"physical\" (or
        \"device\") network is\n   introduced, with nodes representing devices.  This
        network forms an\n   underlay network for logical networks above it, with
        nodes of the\n   logical network mapping onto nodes in the physical network.\n
        \  This scenario is depicted in Figure 6.  This figure depicts three\n   networks
        with two nodes each.  A physical network (\"P\" in the figure)\n   consists
        of an inventory of two nodes (D1 and D2), each representing\n   a device.
        \ A second network, X, has a third network, Y, as its\n   underlay.  Both
        X and Y also have the physical network (P) as their\n   underlay.  X1 has
        both Y1 and D1 as underlay nodes, while Y1 has D1\n   as its underlay node.
        \ Likewise, X2 has both Y2 and D2 as underlay\n   nodes, while Y2 has D2 as
        its underlay node.  The fact that X1 and Y1\n   are both instantiated on the
        same physical node (D1) can be\n   easily seen.\n                         +---------------------+\n
        \                       /   [X1]____[X2]      /  X(Service Overlay)\n                       +----:--:----:--------+\n
        \                        ..:    :..: :\n                ........:     ....:
        : :....\n         +-----:-------------:--+    :     :...\n        /   [Y1]____[Y2]....:
        \ /      :..      :\n       +------|-------|-------+          :..    :...\n
        \       Y(L3) |       +---------------------:-----+ :\n              |                         +----:----|-:----------+\n
        \             +------------------------/---[D1]  [D2]         /\n                                      +----------------------+\n
        \                                       P (Physical Network)\n         Figure
        6: Topology Hierarchy Example - Multiple Underlays\n   In the case of a physical
        network, nodes represent physical devices\n   and termination points represent
        physical ports.  It should be noted\n   that it is also possible to augment
        the data model for a physical\n   network type, defining augmentations that
        have nodes reference system\n   information and termination points reference
        physical interfaces, in\n   order to provide a bridge between network and
        device models.\n"
      title: 4.4.9.  Representing the Same Device in Multiple Networks
    - contents:
      - "4.4.10.  Supporting Client-Configured and System-Controlled Network\n         Topologies\n
        \  YANG requires data nodes to be designated as either configuration\n   data
        (\"config true\") or operational data (\"config false\"), but not\n   both,
        yet it is important to have all network information, including\n   vertical
        cross-network dependencies, captured in one coherent data\n   model.  In most
        cases, network topology information about a network\n   is discovered; the
        topology is considered a property of the network\n   that is reflected in
        the data model.  That said, certain types of\n   topologies need to also be
        configurable by an application, e.g., in\n   the case of overlay topologies.\n
        \  The YANG data model for network topologies designates all data as\n   \"config
        true\".  The distinction between data that is actually\n   configured and
        data that is in effect, including network data that is\n   discovered, is
        provided through the datastores introduced as part of\n   the Network Management
        Datastore Architecture (NMDA) [RFC8342].\n   Network topology data that is
        discovered is automatically populated\n   as part of the operational state
        datastore, i.e., <operational>.  It\n   is \"system controlled\".  Network
        topology that is configured is\n   instantiated as part of a configuration
        datastore, e.g., <intended>.\n   Only when it has actually taken effect will
        it also be instantiated\n   as part of the operational state datastore, i.e.,
        <operational>.\n   In general, a configured network topology will refer to
        an underlay\n   topology and include layering information, such as the supporting\n
        \  node(s) underlying a node, supporting link(s) underlying a link, and\n
        \  supporting termination point(s) underlying a termination point.  The\n
        \  supporting objects must be instantiated in the operational state\n   datastore
        in order for the dependent overlay object to be reflected\n   in the operational
        state datastore.  Should a configured data item\n   (such as a node) have
        a dangling reference that refers to a\n   nonexistent data item (such as a
        supporting node), the configured\n   data item will automatically be removed
        from <operational> and show\n   up only in <intended>.  It will be up to the
        client application to\n   resolve the situation and ensure that the reference
        to the supporting\n   resources is configured properly.\n   For each network,
        the origin of its data is indicated per the\n   \"origin\" metadata [RFC7952]
        annotation defined in [RFC8342].  In\n   general, the origin of discovered
        network data is \"learned\"; the\n   origin of configured network data is
        \"intended\".\n"
      title: 4.4.10.  Supporting Client-Configured and System-Controlled Network
    - contents:
      - "4.4.11.  Identifiers of String or URI Type\n   The current data model defines
        identifiers of nodes, networks, links,\n   and termination points as URIs.
        \ Alternatively, they could have been\n   defined as strings.\n   The case
        for strings is that they will be easier to implement.  The\n   reason for
        choosing URIs is that the topology / node / termination\n   point exists in
        a larger context; hence, it is useful to be able to\n   correlate identifiers
        across systems.  Although strings -- being the\n   universal data type --
        are easier for human beings, they also muddle\n   things.  What typically
        happens is that strings have some structure\n   that is magically assigned,
        and the knowledge of this structure has\n   to be communicated to each system
        working with the data.  A URI makes\n   the structure explicit and also attaches
        additional semantics: the\n   URI, unlike a free-form string, can be fed into
        a URI resolver, which\n   can point to additional resources associated with
        the URI.  This\n   property is important when the topology data is integrated
        into a\n   larger and more complex system.\n"
      title: 4.4.11.  Identifiers of String or URI Type
    title: 4.4.  Discussion and Selected Design Decisions
  title: 4.  Model Structure Details
- contents:
  - "5.  Interactions with Other YANG Modules\n   The data model makes use of data
    types that have been defined in\n   [RFC6991].\n   This is a protocol-independent
    YANG data model with topology\n   information.  It is separate from, and not linked
    with, data models\n   that are used to configure routing protocols or routing
    information.\n   This includes, for example, the \"ietf-routing\" YANG module
    [RFC8022].\n   The data model obeys the requirements for the ephemeral state as\n
    \  specified in [RFC8242].  For ephemeral topology data that is system\n   controlled,
    the process tasked with maintaining topology information\n   will load information
    from the routing process (such as OSPF) into\n   the operational state datastore
    without relying on a configuration\n   datastore.\n"
  title: 5.  Interactions with Other YANG Modules
- contents:
  - '6.  YANG Modules

    '
  - contents:
    - "6.1.  Defining the Abstract Network: ietf-network\n   <CODE BEGINS> file \"ietf-network@2018-02-26.yang\"\n
      \  module ietf-network {\n     yang-version 1.1;\n     namespace \"urn:ietf:params:xml:ns:yang:ietf-network\";\n
      \    prefix nw;\n     import ietf-inet-types {\n       prefix inet;\n       reference\n
      \        \"RFC 6991: Common YANG Data Types\";\n     }\n     organization\n
      \      \"IETF I2RS (Interface to the Routing System) Working Group\";\n     contact\n
      \      \"WG Web:    <https://datatracker.ietf.org/wg/i2rs/>\n        WG List:
      \  <mailto:i2rs@ietf.org>\n        Editor:    Alexander Clemm\n                   <mailto:ludwig@clemm.org>\n
      \       Editor:    Jan Medved\n                   <mailto:jmedved@cisco.com>\n
      \       Editor:    Robert Varga\n                   <mailto:robert.varga@pantheon.tech>\n
      \       Editor:    Nitin Bahadur\n                   <mailto:nitin_bahadur@yahoo.com>\n
      \       Editor:    Hariharan Ananthakrishnan\n                   <mailto:hari@packetdesign.com>\n
      \       Editor:    Xufeng Liu\n                   <mailto:xufeng.liu.ietf@gmail.com>\";\n
      \    description\n       \"This module defines a common base data model for
      a collection\n        of nodes in a network.  Node definitions are further used\n
      \       in network topologies and inventories.\n        Copyright (c) 2018 IETF
      Trust and the persons identified as\n        authors of the code.  All rights
      reserved.\n        Redistribution and use in source and binary forms, with or\n
      \       without modification, is permitted pursuant to, and subject\n        to
      the license terms contained in, the Simplified BSD License\n        set forth
      in Section 4.c of the IETF Trust's Legal Provisions\n        Relating to IETF
      Documents\n        (https://trustee.ietf.org/license-info).\n        This version
      of this YANG module is part of RFC 8345;\n        see the RFC itself for full
      legal notices.\";\n     revision 2018-02-26 {\n       description\n         \"Initial
      revision.\";\n       reference\n         \"RFC 8345: A YANG Data Model for Network
      Topologies\";\n     }\n     typedef node-id {\n       type inet:uri;\n       description\n
      \        \"Identifier for a node.  The precise structure of the node-id\n          will
      be up to the implementation.  For example, some\n          implementations MAY
      pick a URI that includes the network-id\n          as part of the path.  The
      identifier SHOULD be chosen\n          such that the same node in a real network
      topology will\n          always be identified through the same identifier, even
      if\n          the data model is instantiated in separate datastores.  An\n          implementation
      MAY choose to capture semantics in the\n          identifier -- for example,
      to indicate the type of node.\";\n     }\n     typedef network-id {\n       type
      inet:uri;\n       description\n         \"Identifier for a network.  The precise
      structure of the\n          network-id will be up to the implementation.  The
      identifier\n          SHOULD be chosen such that the same network will always
      be\n          identified through the same identifier, even if the data model\n
      \         is instantiated in separate datastores.  An implementation MAY\n          choose
      to capture semantics in the identifier -- for example,\n          to indicate
      the type of network.\";\n     }\n     grouping network-ref {\n       description\n
      \        \"Contains the information necessary to reference a network --\n          for
      example, an underlay network.\";\n       leaf network-ref {\n         type leafref
      {\n           path \"/nw:networks/nw:network/nw:network-id\";\n         require-instance
      false;\n         }\n         description\n           \"Used to reference a network
      -- for example, an underlay\n            network.\";\n       }\n     }\n     grouping
      node-ref {\n       description\n         \"Contains the information necessary
      to reference a node.\";\n       leaf node-ref {\n         type leafref {\n           path
      \"/nw:networks/nw:network[nw:network-id=current()/../\"+\n             \"network-ref]/nw:node/nw:node-id\";\n
      \          require-instance false;\n         }\n         description\n           \"Used
      to reference a node.\n            Nodes are identified relative to the network
      that\n            contains them.\";\n       }\n       uses network-ref;\n     }\n
      \    container networks {\n       description\n         \"Serves as a top-level
      container for a list of networks.\";\n       list network {\n         key \"network-id\";\n
      \        description\n           \"Describes a network.\n            A network
      typically contains an inventory of nodes,\n            topological information
      (augmented through the\n            network-topology data model), and layering
      information.\";\n         leaf network-id {\n           type network-id;\n           description\n
      \            \"Identifies a network.\";\n         }\n         container network-types
      {\n           description\n             \"Serves as an augmentation target.\n
      \             The network type is indicated through corresponding\n              presence
      containers augmented into this container.\";\n         }\n         list supporting-network
      {\n           key \"network-ref\";\n           description\n             \"An
      underlay network, used to represent layered network\n              topologies.\";\n
      \          leaf network-ref {\n             type leafref {\n               path
      \"/nw:networks/nw:network/nw:network-id\";\n             require-instance false;\n
      \            }\n             description\n               \"References the underlay
      network.\";\n           }\n         }\n         list node {\n           key
      \"node-id\";\n           description\n             \"The inventory of nodes
      of this network.\";\n           leaf node-id {\n             type node-id;\n
      \            description\n               \"Uniquely identifies a node within
      the containing\n                network.\";\n           }\n           list supporting-node
      {\n             key \"network-ref node-ref\";\n             description\n               \"Represents
      another node that is in an underlay network\n                and that supports
      this node.  Used to represent layering\n                structure.\";\n             leaf
      network-ref {\n               type leafref {\n                 path \"../../../nw:supporting-network/nw:network-ref\";\n
      \              require-instance false;\n               }\n               description\n
      \                \"References the underlay network of which the\n                  underlay
      node is a part.\";\n             }\n             leaf node-ref {\n               type
      leafref {\n                 path \"/nw:networks/nw:network/nw:node/nw:node-id\";\n
      \              require-instance false;\n               }\n               description\n
      \                \"References the underlay node itself.\";\n             }\n
      \          }\n         }\n       }\n     }\n   }\n   <CODE ENDS>\n"
    title: '6.1.  Defining the Abstract Network: ietf-network'
  - contents:
    - "6.2.  Creating Abstract Network Topology: ietf-network-topology\n   <CODE BEGINS>
      file \"ietf-network-topology@2018-02-26.yang\"\n   module ietf-network-topology
      {\n     yang-version 1.1;\n     namespace \"urn:ietf:params:xml:ns:yang:ietf-network-topology\";\n
      \    prefix nt;\n     import ietf-inet-types {\n       prefix inet;\n       reference\n
      \        \"RFC 6991: Common YANG Data Types\";\n     }\n     import ietf-network
      {\n       prefix nw;\n       reference\n         \"RFC 8345: A YANG Data Model
      for Network Topologies\";\n     }\n     organization\n       \"IETF I2RS (Interface
      to the Routing System) Working Group\";\n     contact\n       \"WG Web:    <https://datatracker.ietf.org/wg/i2rs/>\n
      \       WG List:   <mailto:i2rs@ietf.org>\n        Editor:    Alexander Clemm\n
      \                  <mailto:ludwig@clemm.org>\n        Editor:    Jan Medved\n
      \                  <mailto:jmedved@cisco.com>\n        Editor:    Robert Varga\n
      \                  <mailto:robert.varga@pantheon.tech>\n        Editor:    Nitin
      Bahadur\n                   <mailto:nitin_bahadur@yahoo.com>\n        Editor:
      \   Hariharan Ananthakrishnan\n                   <mailto:hari@packetdesign.com>\n
      \       Editor:    Xufeng Liu\n                   <mailto:xufeng.liu.ietf@gmail.com>\";\n
      \    description\n       \"This module defines a common base model for a network
      topology,\n        augmenting the base network data model with links to connect\n
      \       nodes, as well as termination points to terminate links\n        on
      nodes.\n        Copyright (c) 2018 IETF Trust and the persons identified as\n
      \       authors of the code.  All rights reserved.\n        Redistribution and
      use in source and binary forms, with or\n        without modification, is permitted
      pursuant to, and subject\n        to the license terms contained in, the Simplified
      BSD License\n        set forth in Section 4.c of the IETF Trust's Legal Provisions\n
      \       Relating to IETF Documents\n        (https://trustee.ietf.org/license-info).\n
      \       This version of this YANG module is part of RFC 8345;\n        see the
      RFC itself for full legal notices.\";\n     revision 2018-02-26 {\n       description\n
      \        \"Initial revision.\";\n       reference\n         \"RFC 8345: A YANG
      Data Model for Network Topologies\";\n     }\n     typedef link-id {\n       type
      inet:uri;\n       description\n         \"An identifier for a link in a topology.
      \ The precise\n          structure of the link-id will be up to the implementation.\n
      \         The identifier SHOULD be chosen such that the same link in a\n          real
      network topology will always be identified through the\n          same identifier,
      even if the data model is instantiated in\n          separate datastores.  An
      implementation MAY choose to capture\n          semantics in the identifier
      -- for example, to indicate the\n          type of link and/or the type of topology
      of which the link is\n          a part.\";\n     }\n     typedef tp-id {\n       type
      inet:uri;\n       description\n         \"An identifier for termination points
      on a node.  The precise\n          structure of the tp-id will be up to the
      implementation.\n          The identifier SHOULD be chosen such that the same
      termination\n          point in a real network topology will always be identified\n
      \         through the same identifier, even if the data model is\n          instantiated
      in separate datastores.  An implementation MAY\n          choose to capture
      semantics in the identifier -- for example,\n          to indicate the type
      of termination point and/or the type of\n          node that contains the termination
      point.\";\n     }\n     grouping link-ref {\n       description\n         \"This
      grouping can be used to reference a link in a specific\n          network.  Although
      it is not used in this module, it is\n          defined here for the convenience
      of augmenting modules.\";\n       leaf link-ref {\n         type leafref {\n
      \          path \"/nw:networks/nw:network[nw:network-id=current()/../\"+\n             \"network-ref]/nt:link/nt:link-id\";\n
      \          require-instance false;\n         }\n         description\n           \"A
      type for an absolute reference to a link instance.\n            (This type should
      not be used for relative references.\n            In such a case, a relative
      path should be used instead.)\";\n       }\n       uses nw:network-ref;\n     }\n
      \    grouping tp-ref {\n       description\n         \"This grouping can be
      used to reference a termination point\n          in a specific node.  Although
      it is not used in this module,\n          it is defined here for the convenience
      of augmenting\n          modules.\";\n       leaf tp-ref {\n         type leafref
      {\n           path \"/nw:networks/nw:network[nw:network-id=current()/../\"+\n
      \            \"network-ref]/nw:node[nw:node-id=current()/../\"+\n             \"node-ref]/nt:termination-point/nt:tp-id\";\n
      \          require-instance false;\n         }\n         description\n           \"A
      type for an absolute reference to a termination point.\n            (This type
      should not be used for relative references.\n            In such a case, a relative
      path should be used instead.)\";\n       }\n       uses nw:node-ref;\n     }\n
      \    augment \"/nw:networks/nw:network\" {\n       description\n         \"Add
      links to the network data model.\";\n       list link {\n         key \"link-id\";\n
      \        description\n           \"A network link connects a local (source)
      node and\n            a remote (destination) node via a set of the respective\n
      \           node's termination points.  It is possible to have several\n            links
      between the same source and destination nodes.\n            Likewise, a link
      could potentially be re-homed between\n            termination points.  Therefore,
      in order to ensure that we\n            would always know to distinguish between
      links, every link\n            is identified by a dedicated link identifier.
      \ Note that a\n            link models a point-to-point link, not a multipoint
      link.\";\n         leaf link-id {\n           type link-id;\n           description\n
      \            \"The identifier of a link in the topology.\n              A link
      is specific to a topology to which it belongs.\";\n         }\n         container
      source {\n           description\n             \"This container holds the logical
      source of a particular\n              link.\";\n           leaf source-node
      {\n             type leafref {\n               path \"../../../nw:node/nw:node-id\";\n
      \              require-instance false;\n             }\n             description\n
      \              \"Source node identifier.  Must be in the same topology.\";\n
      \          }\n           leaf source-tp {\n             type leafref {\n               path
      \"../../../nw:node[nw:node-id=current()/../\"+\n                 \"source-node]/termination-point/tp-id\";\n
      \              require-instance false;\n             }\n             description\n
      \              \"This termination point is located within the source node\n
      \               and terminates the link.\";\n           }\n         }\n         container
      destination {\n           description\n             \"This container holds the
      logical destination of a\n              particular link.\";\n           leaf
      dest-node {\n             type leafref {\n               path \"../../../nw:node/nw:node-id\";\n
      \            require-instance false;\n             }\n             description\n
      \              \"Destination node identifier.  Must be in the same\n                network.\";\n
      \          }\n           leaf dest-tp {\n             type leafref {\n               path
      \"../../../nw:node[nw:node-id=current()/../\"+\n                 \"dest-node]/termination-point/tp-id\";\n
      \              require-instance false;\n             }\n             description\n
      \              \"This termination point is located within the\n                destination
      node and terminates the link.\";\n           }\n         }\n         list supporting-link
      {\n           key \"network-ref link-ref\";\n           description\n             \"Identifies
      the link or links on which this link depends.\";\n           leaf network-ref
      {\n             type leafref {\n               path \"../../../nw:supporting-network/nw:network-ref\";\n
      \            require-instance false;\n             }\n             description\n
      \              \"This leaf identifies in which underlay topology\n                the
      supporting link is present.\";\n           }\n           leaf link-ref {\n             type
      leafref {\n               path \"/nw:networks/nw:network[nw:network-id=current()/\"+\n
      \                \"../network-ref]/link/link-id\";\n               require-instance
      false;\n             }\n             description\n               \"This leaf
      identifies a link that is a part\n                of this link's underlay.  Reference
      loops in which\n                a link identifies itself as its underlay, either\n
      \               directly or transitively, are not allowed.\";\n           }\n
      \        }\n       }\n     }\n     augment \"/nw:networks/nw:network/nw:node\"
      {\n       description\n         \"Augments termination points that terminate
      links.\n          Termination points can ultimately be mapped to interfaces.\";\n
      \      list termination-point {\n         key \"tp-id\";\n         description\n
      \          \"A termination point can terminate a link.\n            Depending
      on the type of topology, a termination point\n            could, for example,
      refer to a port or an interface.\";\n         leaf tp-id {\n           type
      tp-id;\n           description\n             \"Termination point identifier.\";\n
      \        }\n         list supporting-termination-point {\n           key \"network-ref
      node-ref tp-ref\";\n           description\n             \"This list identifies
      any termination points on which a\n              given termination point depends
      or onto which it maps.\n              Those termination points will themselves
      be contained\n              in a supporting node.  This dependency information
      can be\n              inferred from the dependencies between links.  Therefore,\n
      \             this item is not separately configurable.  Hence, no\n              corresponding
      constraint needs to be articulated.\n              The corresponding information
      is simply provided by the\n              implementing system.\";\n           leaf
      network-ref {\n             type leafref {\n               path \"../../../nw:supporting-node/nw:network-ref\";\n
      \            require-instance false;\n             }\n             description\n
      \              \"This leaf identifies in which topology the\n                supporting
      termination point is present.\";\n           }\n           leaf node-ref {\n
      \            type leafref {\n               path \"../../../nw:supporting-node/nw:node-ref\";\n
      \            require-instance false;\n             }\n             description\n
      \              \"This leaf identifies in which node the supporting\n                termination
      point is present.\";\n           }\n           leaf tp-ref {\n             type
      leafref {\n               path \"/nw:networks/nw:network[nw:network-id=current()/\"+\n
      \                \"../network-ref]/nw:node[nw:node-id=current()/../\"+\n                 \"node-ref]/termination-point/tp-id\";\n
      \              require-instance false;\n             }\n             description\n
      \              \"Reference to the underlay node (the underlay node must\n                be
      in a different topology).\";\n           }\n         }\n       }\n     }\n   }\n
      \  <CODE ENDS>\n"
    title: '6.2.  Creating Abstract Network Topology: ietf-network-topology'
  title: 6.  YANG Modules
- contents:
  - "7.  IANA Considerations\n   This document registers the following namespace URIs
    in the \"IETF XML\n   Registry\" [RFC3688]:\n   URI: urn:ietf:params:xml:ns:yang:ietf-network\n
    \  Registrant Contact: The IESG.\n   XML: N/A; the requested URI is an XML namespace.\n
    \  URI: urn:ietf:params:xml:ns:yang:ietf-network-topology\n   Registrant Contact:
    The IESG.\n   XML: N/A; the requested URI is an XML namespace.\n   URI: urn:ietf:params:xml:ns:yang:ietf-network-state\n
    \  Registrant Contact: The IESG.\n   XML: N/A; the requested URI is an XML namespace.\n
    \  URI: urn:ietf:params:xml:ns:yang:ietf-network-topology-state\n   Registrant
    Contact: The IESG.\n   XML: N/A; the requested URI is an XML namespace.\n   This
    document registers the following YANG modules in the \"YANG\n   Module Names\"
    registry [RFC6020]:\n   Name:      ietf-network\n   Namespace: urn:ietf:params:xml:ns:yang:ietf-network\n
    \  Prefix:    nw\n   Reference: RFC 8345\n   Name:      ietf-network-topology\n
    \  Namespace: urn:ietf:params:xml:ns:yang:ietf-network-topology\n   Prefix:    nt\n
    \  Reference: RFC 8345\n   Name:      ietf-network-state\n   Namespace: urn:ietf:params:xml:ns:yang:ietf-network-state\n
    \  Prefix:    nw-s\n   Reference: RFC 8345\n   Name:      ietf-network-topology-state\n
    \  Namespace: urn:ietf:params:xml:ns:yang:ietf-network-topology-state\n   Prefix:
    \   nt-s\n   Reference: RFC 8345\n"
  title: 7.  IANA Considerations
- contents:
  - "8.  Security Considerations\n   The YANG modules specified in this document define
    a schema for data\n   that is designed to be accessed via network management protocols
    such\n   as NETCONF [RFC6241] or RESTCONF [RFC8040].  The lowest NETCONF layer\n
    \  is the secure transport layer, and the mandatory-to-implement secure\n   transport
    is Secure Shell (SSH) [RFC6242].  The lowest RESTCONF layer\n   is HTTPS, and
    the mandatory-to-implement secure transport is TLS\n   [RFC5246].\n   The NETCONF
    access control model [RFC8341] provides the means to\n   restrict access for particular
    NETCONF or RESTCONF users to a\n   preconfigured subset of all available NETCONF
    or RESTCONF protocol\n   operations and content.\n   The network topology and
    inventory created by these modules reveal\n   information about the structure
    of networks that could be very\n   helpful to an attacker.  As a privacy consideration,
    although there\n   is no personally identifiable information defined in these
    modules,\n   it is possible that some node identifiers may be associated with\n
    \  devices that are in turn associated with specific users.\n   The YANG modules
    define information that can be configurable in\n   certain instances -- for example,
    in the case of overlay topologies\n   that can be created by client applications.
    \ In such cases, a\n   malicious client could introduce topologies that are undesired.\n
    \  Specifically, a malicious client could attempt to remove or add a\n   node,
    a link, or a termination point by creating or deleting\n   corresponding elements
    in node, link, or termination point lists,\n   respectively.  In the case of a
    topology that is learned, the server\n   will automatically prohibit such misconfiguration
    attempts.  In the\n   case of a topology that is configured, i.e., whose origin
    is\n   \"intended\", the undesired configuration could become effective and be\n
    \  reflected in the operational state datastore, leading to disruption\n   of
    services provided via this topology.  For example, the topology\n   could be \"cut\"
    or could be configured in a suboptimal way, leading to\n   increased consumption
    of resources in the underlay network due to the\n   routing and bandwidth utilization
    inefficiencies that would result.\n   Likewise, it could lead to degradation of
    service levels as well as\n   possible disruption of service.  For those reasons,
    it is important\n   that the NETCONF access control model be vigorously applied
    to\n   prevent topology misconfiguration by unauthorized clients.\n   There are
    a number of data nodes defined in these YANG modules that\n   are writable/creatable/deletable
    (i.e., config true, which is the\n   default).  These data nodes may be considered
    sensitive or vulnerable\n   in some network environments.  Write operations (e.g.,
    edit-config)\n   to these data nodes without proper protection can have a negative\n
    \  effect on network operations.  These are the subtrees and data nodes\n   and
    their sensitivity/vulnerability:\n   In the \"ietf-network\" module:\n   o  network:
    A malicious client could attempt to remove or add a\n      network in an effort
    to remove an overlay topology or to create an\n      unauthorized overlay.\n   o
    \ supporting network: A malicious client could attempt to disrupt\n      the logical
    structure of the model, resulting in a lack of overall\n      data integrity and
    making it more difficult to, for example,\n      troubleshoot problems rooted
    in the layering of network\n      topologies.\n   o  node: A malicious client
    could attempt to remove or add a node\n      from the network -- for example,
    in order to sabotage the topology\n      of a network overlay.\n   o  supporting
    node: A malicious client could attempt to change the\n      supporting node in
    order to sabotage the layering of an overlay.\n   In the \"ietf-network-topology\"
    module:\n   o  link: A malicious client could attempt to remove a link from a\n
    \     topology, add a new link, manipulate the way the link is layered\n      over
    supporting links, or modify the source or destination of the\n      link.  In
    each case, the structure of the topology would be\n      sabotaged, and this scenario
    could, for example, result in an\n      overlay topology that is less than optimal.\n
    \  o  termination point: A malicious client could attempt to remove\n      termination
    points from a node, add \"phantom\" termination points\n      to a node, or change
    the layering dependencies of termination\n      points, again in an effort to
    sabotage the integrity of a topology\n      and potentially disrupt orderly operations
    of an overlay.\n"
  title: 8.  Security Considerations
- contents:
  - '9.  References

    '
  - contents:
    - "9.1.  Normative References\n   [RFC2119]  Bradner, S., \"Key words for use
      in RFCs to Indicate\n              Requirement Levels\", BCP 14, RFC 2119,\n
      \             DOI 10.17487/RFC2119, March 1997,\n              <https://www.rfc-editor.org/info/rfc2119>.\n
      \  [RFC3688]  Mealling, M., \"The IETF XML Registry\", BCP 81, RFC 3688,\n              DOI
      10.17487/RFC3688, January 2004,\n              <https://www.rfc-editor.org/info/rfc3688>.\n
      \  [RFC5246]  Dierks, T. and E. Rescorla, \"The Transport Layer Security\n              (TLS)
      Protocol Version 1.2\", RFC 5246,\n              DOI 10.17487/RFC5246, August
      2008,\n              <https://www.rfc-editor.org/info/rfc5246>.\n   [RFC6020]
      \ Bjorklund, M., Ed., \"YANG - A Data Modeling Language for\n              the
      Network Configuration Protocol (NETCONF)\", RFC 6020,\n              DOI 10.17487/RFC6020,
      October 2010,\n              <https://www.rfc-editor.org/info/rfc6020>.\n   [RFC6241]
      \ Enns, R., Ed., Bjorklund, M., Ed., Schoenwaelder, J., Ed.,\n              and
      A. Bierman, Ed., \"Network Configuration Protocol\n              (NETCONF)\",
      RFC 6241, DOI 10.17487/RFC6241, June 2011,\n              <https://www.rfc-editor.org/info/rfc6241>.\n
      \  [RFC6242]  Wasserman, M., \"Using the NETCONF Protocol over Secure\n              Shell
      (SSH)\", RFC 6242, DOI 10.17487/RFC6242, June 2011,\n              <https://www.rfc-editor.org/info/rfc6242>.\n
      \  [RFC6991]  Schoenwaelder, J., Ed., \"Common YANG Data Types\",\n              RFC
      6991, DOI 10.17487/RFC6991, July 2013,\n              <https://www.rfc-editor.org/info/rfc6991>.\n
      \  [RFC7950]  Bjorklund, M., Ed., \"The YANG 1.1 Data Modeling Language\",\n
      \             RFC 7950, DOI 10.17487/RFC7950, August 2016,\n              <https://www.rfc-editor.org/info/rfc7950>.\n
      \  [RFC8040]  Bierman, A., Bjorklund, M., and K. Watsen, \"RESTCONF\n              Protocol\",
      RFC 8040, DOI 10.17487/RFC8040, January 2017,\n              <https://www.rfc-editor.org/info/rfc8040>.\n
      \  [RFC8174]  Leiba, B., \"Ambiguity of Uppercase vs Lowercase in\n              RFC
      2119 Key Words\", BCP 14, RFC 8174,\n              DOI 10.17487/RFC8174, May
      2017,\n              <https://www.rfc-editor.org/info/rfc8174>.\n   [RFC8341]
      \ Bierman, A. and M. Bjorklund, \"Network Configuration\n              Access
      Control Model\", STD 91, RFC 8341,\n              DOI 10.17487/RFC8341, March
      2018,\n              <https://www.rfc-editor.org/info/rfc8341>.\n   [RFC8342]
      \ Bjorklund, M., Schoenwaelder, J., Shafer, P., Watsen, K.,\n              and
      R. Wilton, \"Network Management Datastore Architecture\n              (NMDA)\",
      RFC 8342, DOI 10.17487/RFC8342, March 2018,\n              <https://www.rfc-editor.org/info/rfc8342>.\n"
    title: 9.1.  Normative References
  - contents:
    - "9.2.  Informative References\n   [RFC1195]  Callon, R., \"Use of OSI IS-IS
      for routing in TCP/IP and\n              dual environments\", RFC 1195, DOI
      10.17487/RFC1195,\n              December 1990, <https://www.rfc-editor.org/info/rfc1195>.\n
      \  [RFC2328]  Moy, J., \"OSPF Version 2\", STD 54, RFC 2328,\n              DOI
      10.17487/RFC2328, April 1998,\n              <https://www.rfc-editor.org/info/rfc2328>.\n
      \  [RFC3209]  Awduche, D., Berger, L., Gan, D., Li, T., Srinivasan, V.,\n              and
      G. Swallow, \"RSVP-TE: Extensions to RSVP for LSP\n              Tunnels\",
      RFC 3209, DOI 10.17487/RFC3209, December 2001,\n              <https://www.rfc-editor.org/info/rfc3209>.\n
      \  [RFC3444]  Pras, A. and J. Schoenwaelder, \"On the Difference between\n              Information
      Models and Data Models\", RFC 3444,\n              DOI 10.17487/RFC3444, January
      2003,\n              <https://www.rfc-editor.org/info/rfc3444>.\n   [RFC7951]
      \ Lhotka, L., \"JSON Encoding of Data Modeled with YANG\",\n              RFC
      7951, DOI 10.17487/RFC7951, August 2016,\n              <https://www.rfc-editor.org/info/rfc7951>.\n
      \  [RFC7952]  Lhotka, L., \"Defining and Using Metadata with YANG\",\n              RFC
      7952, DOI 10.17487/RFC7952, August 2016,\n              <https://www.rfc-editor.org/info/rfc7952>.\n
      \  [RFC8022]  Lhotka, L. and A. Lindem, \"A YANG Data Model for Routing\n              Management\",
      RFC 8022, DOI 10.17487/RFC8022,\n              November 2016, <https://www.rfc-editor.org/info/rfc8022>.\n
      \  [RFC8242]  Haas, J. and S. Hares, \"Interface to the Routing System\n              (I2RS)
      Ephemeral State Requirements\", RFC 8242,\n              DOI 10.17487/RFC8242,
      September 2017,\n              <https://www.rfc-editor.org/info/rfc8242>.\n
      \  [RFC8340]  Bjorklund, M. and L. Berger, Ed., \"YANG Tree Diagrams\",\n              BCP
      215, RFC 8340, DOI 10.17487/RFC8340, March 2018,\n              <https://www.rfc-editor.org/info/rfc8340>.\n
      \  [RFC8343]  Bjorklund, M., \"A YANG Data Model for Interface\n              Management\",
      RFC 8343, DOI 10.17487/RFC8343, March 2018,\n              <https://www.rfc-editor.org/info/rfc8343>.\n
      \  [RFC8346]  Clemm, A., Medved, J., Varga, R., Liu, X.,\n              Ananthakrishnan,
      H., and N. Bahadur, \"A YANG Data Model\n              for Layer 3 Topologies\",
      RFC 8346, DOI 10.17487/RFC8346,\n              March 2018, <https://www.rfc-editor.org/info/rfc8346>.\n
      \  [USECASE-REQS]\n              Hares, S. and M. Chen, \"Summary of I2RS Use
      Case\n              Requirements\", Work in Progress, draft-ietf-i2rs-usecase-\n
      \             reqs-summary-03, November 2016.\n   [YANG-Push]\n              Clemm,
      A., Voit, E., Gonzalez Prieto, A., Tripathy, A.,\n              Nilsen-Nygaard,
      E., Bierman, A., and B. Lengyel, \"YANG\n              Datastore Subscription\",
      Work in Progress,\n              draft-ietf-netconf-yang-push-15, February 2018.\n"
    title: 9.2.  Informative References
  title: 9.  References
- contents:
  - 'Appendix A.  Model Use Cases

    '
  - contents:
    - "A.1.  Fetching Topology from a Network Element\n   In its simplest form, topology
      is learned by a network element (e.g.,\n   a router) through its participation
      in peering protocols (IS-IS, BGP,\n   etc.).  This learned topology can then
      be exported (e.g., to a\n   Network Management System) for external utilization.
      \ Typically, any\n   network element in a domain can be queried for its topology
      and be\n   expected to return the same result.\n   In a slightly more complex
      form, the network element may be a\n   controller.  It could be a network element
      with satellite or\n   subtended devices hanging off of it, or it could be a
      controller in\n   the more classical sense -- that is, a special device designated
      to\n   orchestrate the activities of a number of other devices (e.g., an\n   Optical
      Controller).  In this case, the controller device is\n   logically a singleton
      and must be queried distinctly.\n   It is worth noting that controllers can
      be built on top of other\n   controllers to establish a topology incorporating
      all of the domains\n   within an entire network.\n   In all of the cases above,
      the topology learned by the network\n   element is considered to be operational
      state data.  That is, the\n   data is accumulated purely by the network element's
      interactions with\n   other systems and is subject to change dynamically without
      input or\n   consent.\n"
    title: A.1.  Fetching Topology from a Network Element
  - contents:
    - "A.2.  Modifying TE Topology Imported from an Optical Controller\n   Consider
      a scenario where an Optical Controller presents its\n   topology, in abstract
      TE terms, to a client packet controller.  This\n   customized topology (which
      gets merged into the client's native\n   topology) contains sufficient information
      for the path-computing\n   client to select paths across the optical domain
      according to its\n   policies.  If the client determines (at any given point
      in time) that\n   this imported topology does not cater exactly to its requirements,
      it\n   may decide to request modifications to the topology.  Such\n   customization
      requests may include the addition or deletion of\n   topological elements or
      the modification of attributes associated\n   with existing topological elements.
      \ From the perspective of the\n   Optical Controller, these requests translate
      into configuration\n   changes to the exported abstract topology.\n"
    title: A.2.  Modifying TE Topology Imported from an Optical Controller
  - contents:
    - "A.3.  Annotating Topology for Local Computation\n   In certain scenarios, the
      topology learned by a controller needs to\n   be augmented with additional attributes
      before running a computation\n   algorithm on it.  Consider the case where a
      path-computation\n   application on the controller needs to take the geographic\n
      \  coordinates of the nodes into account while computing paths on the\n   learned
      topology.  If the learned topology does not contain these\n   coordinates, then
      these additional attributes must be configured on\n   the corresponding topological
      elements.\n"
    title: A.3.  Annotating Topology for Local Computation
  - contents:
    - "A.4.  SDN Controller-Based Configuration of Overlays on Top of Underlays\n
      \  In this scenario, an SDN Controller (for example, Open Daylight)\n   maintains
      a view of the topology of the network that it controls\n   based on information
      that it discovers from the network.  In\n   addition, it provides an application
      in which it configures and\n   maintains an overlay topology.\n   The SDN Controller
      thus maintains two roles:\n   o  It is a client to the network.\n   o  It is
      a server to its own northbound applications and clients,\n      e.g., an Operations
      Support System (OSS).\n   In other words, one system's client (or controller,
      in this case) may\n   be another system's server (or managed system).\n   In
      this scenario, the SDN Controller maintains a consolidated data\n   model of
      multiple layers of topology.  This includes the lower layers\n   of the network
      topology, built from information that is discovered\n   from the network.  It
      also includes upper layers of topology overlay,\n   configurable by the controller's
      client, i.e., the OSS.  To the OSS,\n   the lower topology layers constitute
      \"read-only\" information.  The\n   upper topology layers need to be read-writable.\n"
    title: A.4.  SDN Controller-Based Configuration of Overlays on Top of Underlays
  title: Appendix A.  Model Use Cases
- contents:
  - "Appendix B.  Companion YANG Data Models for Implementations Not\n             Compliant
    with NMDA\n   The YANG modules defined in this document are designed to be used
    in\n   conjunction with implementations that support the Network Management\n
    \  Datastore Architecture (NMDA) as defined in [RFC8342].  In order to\n   allow
    implementations to use the data model even in cases when NMDA\n   is not supported,
    the following two companion modules --\n   \"ietf-network-state\" and \"ietf-network-topology-state\"
    -- are\n   defined; they represent the operational state of networks and network\n
    \  topologies, respectively.  These modules mirror the \"ietf-network\"\n   and
    \"ietf-network-topology\" modules (defined in Sections 6.1 and 6.2\n   of this
    document); however, in the case of these modules, all data\n   nodes are non-configurable.
    \ They represent state that comes into\n   being by either (1) learning topology
    information from the network or\n   (2) applying configuration from the mirrored
    modules.\n   The \"ietf-network-state\" and \"ietf-network-topology-state\" companion\n
    \  modules are redundant and SHOULD NOT be supported by implementations\n   that
    support NMDA; therefore, we define these modules in\n   Appendices B.1 and B.2
    (below) instead of the main body of this\n   document.\n   As the structure of
    both modules mirrors that of their underlying\n   modules, the YANG tree is not
    depicted separately.\n"
  - contents:
    - 'B.1.  YANG Module for Network State

      '
    - '<CODE BEGINS> file "ietf-network-state@2018-02-26.yang"

      '
    - "module ietf-network-state {\n  yang-version 1.1;\n  namespace \"urn:ietf:params:xml:ns:yang:ietf-network-state\";\n
      \ prefix nw-s;\n  import ietf-network {\n    prefix nw;\n    reference\n      \"RFC
      8345: A YANG Data Model for Network Topologies\";\n  }\n  organization\n    \"IETF
      I2RS (Interface to the Routing System) Working Group\";\n  contact\n    \"WG
      Web:    <https://datatracker.ietf.org/wg/i2rs/>\n     WG List:   <mailto:i2rs@ietf.org>\n
      \    Editor:    Alexander Clemm\n                <mailto:ludwig@clemm.org>\n
      \    Editor:    Jan Medved\n                <mailto:jmedved@cisco.com>\n     Editor:
      \   Robert Varga\n                <mailto:robert.varga@pantheon.tech>\n     Editor:
      \   Nitin Bahadur\n                <mailto:nitin_bahadur@yahoo.com>\n     Editor:
      \   Hariharan Ananthakrishnan\n                <mailto:hari@packetdesign.com>\n
      \    Editor:    Xufeng Liu\n                <mailto:xufeng.liu.ietf@gmail.com>\";\n
      \ description\n    \"This module defines a common base data model for a collection\n
      \    of nodes in a network.  Node definitions are further used\n     in network
      topologies and inventories.  It represents\n     information that either (1)
      is learned and automatically\n     populated or (2) results from applying network
      information\n     that has been configured per the 'ietf-network' data model,\n
      \    mirroring the corresponding data nodes in this data model.\n     The data
      model mirrors 'ietf-network' but contains only\n     read-only state data.  The
      data model is not needed when the\n     underlying implementation infrastructure
      supports the Network\n     Management Datastore Architecture (NMDA).\n     Copyright
      (c) 2018 IETF Trust and the persons identified as\n     authors of the code.
      \ All rights reserved.\n     Redistribution and use in source and binary forms,
      with or\n     without modification, is permitted pursuant to, and subject\n
      \    to the license terms contained in, the Simplified BSD License\n     set
      forth in Section 4.c of the IETF Trust's Legal Provisions\n     Relating to
      IETF Documents\n     (https://trustee.ietf.org/license-info).\n     This version
      of this YANG module is part of RFC 8345;\n     see the RFC itself for full legal
      notices.\";\n  revision 2018-02-26 {\n    description\n      \"Initial revision.\";\n
      \   reference\n      \"RFC 8345: A YANG Data Model for Network Topologies\";\n
      \ }\n  grouping network-ref {\n    description\n      \"Contains the information
      necessary to reference a network --\n       for example, an underlay network.\";\n
      \   leaf network-ref {\n      type leafref {\n        path \"/nw-s:networks/nw-s:network/nw-s:network-id\";\n
      \     require-instance false;\n      }\n      description\n        \"Used to
      reference a network -- for example, an underlay\n         network.\";\n    }\n
      \ }\n  grouping node-ref {\n    description\n      \"Contains the information
      necessary to reference a node.\";\n    leaf node-ref {\n      type leafref {\n
      \       path \"/nw-s:networks/nw-s:network[nw-s:network-id=current()\"+\n          \"/../network-ref]/nw-s:node/nw-s:node-id\";\n
      \       require-instance false;\n      }\n      description\n        \"Used
      to reference a node.\n         Nodes are identified relative to the network
      that\n         contains them.\";\n    }\n    uses network-ref;\n  }\n  container
      networks {\n    config false;\n    description\n      \"Serves as a top-level
      container for a list of networks.\";\n    list network {\n      key \"network-id\";\n
      \     description\n        \"Describes a network.\n         A network typically
      contains an inventory of nodes,\n         topological information (augmented
      through the\n         network-topology data model), and layering information.\";\n
      \     container network-types {\n        description\n          \"Serves as
      an augmentation target.\n           The network type is indicated through corresponding\n
      \          presence containers augmented into this container.\";\n      }\n
      \     leaf network-id {\n        type nw:network-id;\n        description\n
      \         \"Identifies a network.\";\n      }\n      list supporting-network
      {\n        key \"network-ref\";\n        description\n          \"An underlay
      network, used to represent layered network\n           topologies.\";\n        leaf
      network-ref {\n          type leafref {\n            path \"/nw-s:networks/nw-s:network/nw-s:network-id\";\n
      \         require-instance false;\n          }\n          description\n            \"References
      the underlay network.\";\n        }\n      }\n      list node {\n        key
      \"node-id\";\n        description\n          \"The inventory of nodes of this
      network.\";\n        leaf node-id {\n          type nw:node-id;\n          description\n
      \           \"Uniquely identifies a node within the containing\n             network.\";\n
      \       }\n        list supporting-node {\n          key \"network-ref node-ref\";\n
      \         description\n            \"Represents another node that is in an underlay
      network\n             and that supports this node.  Used to represent layering\n
      \            structure.\";\n          leaf network-ref {\n            type leafref
      {\n              path \"../../../nw-s:supporting-network/nw-s:network-ref\";\n
      \           require-instance false;\n            }\n            description\n
      \             \"References the underlay network of which the\n               underlay
      node is a part.\";\n          }\n          leaf node-ref {\n            type
      leafref {\n              path \"/nw-s:networks/nw-s:network/nw-s:node/nw-s:node-id\";\n
      \           require-instance false;\n            }\n            description\n
      \             \"References the underlay node itself.\";\n          }\n        }\n
      \     }\n    }\n  }\n"
    - '}

      '
    - '<CODE ENDS>

      '
    title: B.1.  YANG Module for Network State
  - contents:
    - "B.2.  YANG Module for Network Topology State\n  <CODE BEGINS> file \"ietf-network-topology-state@2018-02-26.yang\"\n
      \ module ietf-network-topology-state {\n    yang-version 1.1;\n    namespace
      \"urn:ietf:params:xml:ns:yang:ietf-network-topology-state\";\n    prefix nt-s;\n
      \   import ietf-network-state {\n      prefix nw-s;\n      reference\n        \"RFC
      8345: A YANG Data Model for Network Topologies\";\n    }\n    import ietf-network-topology
      {\n      prefix nt;\n      reference\n        \"RFC 8345: A YANG Data Model
      for Network Topologies\";\n    }\n    organization\n      \"IETF I2RS (Interface
      to the Routing System) Working Group\";\n    contact\n      \"WG Web:    <https://datatracker.ietf.org/wg/i2rs/>\n
      \      WG List:   <mailto:i2rs@ietf.org>\n       Editor:    Alexander Clemm\n
      \                 <mailto:ludwig@clemm.org>\n       Editor:    Jan Medved\n
      \                 <mailto:jmedved@cisco.com>\n       Editor:    Robert Varga\n
      \                 <mailto:robert.varga@pantheon.tech>\n       Editor:    Nitin
      Bahadur\n                  <mailto:nitin_bahadur@yahoo.com>\n       Editor:
      \   Hariharan Ananthakrishnan\n                  <mailto:hari@packetdesign.com>\n
      \      Editor:    Xufeng Liu\n                  <mailto:xufeng.liu.ietf@gmail.com>\";\n
      \   description\n      \"This module defines a common base data model for network\n
      \      topology state, representing topology that either (1) is learned\n       or
      (2) results from applying topology that has been configured\n       per the
      'ietf-network-topology' data model, mirroring the\n       corresponding data
      nodes in this data model.  It augments the\n       base network state data model
      with links to connect nodes, as\n       well as termination points to terminate
      links on nodes.\n       The data model mirrors 'ietf-network-topology' but contains
      only\n       read-only state data.  The data model is not needed when the\n
      \      underlying implementation infrastructure supports the Network\n       Management
      Datastore Architecture (NMDA).\n       Copyright (c) 2018 IETF Trust and the
      persons identified as\n       authors of the code.  All rights reserved.\n       Redistribution
      and use in source and binary forms, with or\n       without modification, is
      permitted pursuant to, and subject\n       to the license terms contained in,
      the Simplified BSD License\n       set forth in Section 4.c of the IETF Trust's
      Legal Provisions\n       Relating to IETF Documents\n       (https://trustee.ietf.org/license-info).\n
      \      This version of this YANG module is part of RFC 8345;\n       see the
      RFC itself for full legal notices.\";\n    revision 2018-02-26 {\n      description\n
      \       \"Initial revision.\";\n      reference\n        \"RFC 8345: A YANG
      Data Model for Network Topologies\";\n    }\n    grouping link-ref {\n      description\n
      \       \"References a link in a specific network.  Although this\n         grouping
      is not used in this module, it is defined here for\n         the convenience
      of augmenting modules.\";\n      leaf link-ref {\n        type leafref {\n          path
      \"/nw-s:networks/nw-s:network[nw-s:network-id=current()\"+\n            \"/../network-ref]/nt-s:link/nt-s:link-id\";\n
      \         require-instance false;\n        }\n        description\n          \"A
      type for an absolute reference to a link instance.\n           (This type should
      not be used for relative references.\n           In such a case, a relative
      path should be used instead.)\";\n      }\n      uses nw-s:network-ref;\n    }\n
      \   grouping tp-ref {\n      description\n        \"References a termination
      point in a specific node.  Although\n         this grouping is not used in this
      module, it is defined here\n         for the convenience of augmenting modules.\";\n
      \     leaf tp-ref {\n        type leafref {\n          path \"/nw-s:networks/nw-s:network[nw-s:network-id=current()\"+\n
      \           \"/../network-ref]/nw-s:node[nw-s:node-id=current()/../\"+\n            \"node-ref]/nt-s:termination-point/nt-s:tp-id\";\n
      \         require-instance false;\n        }\n        description\n          \"A
      type for an absolute reference to a termination point.\n           (This type
      should not be used for relative references.\n           In such a case, a relative
      path should be used instead.)\";\n      }\n      uses nw-s:node-ref;\n    }\n
      \   augment \"/nw-s:networks/nw-s:network\" {\n      description\n        \"Add
      links to the network data model.\";\n      list link {\n        key \"link-id\";\n
      \       description\n          \"A network link connects a local (source) node
      and\n           a remote (destination) node via a set of the respective\n           node's
      termination points.  It is possible to have several\n           links between
      the same source and destination nodes.\n           Likewise, a link could potentially
      be re-homed between\n           termination points.  Therefore, in order to
      ensure that we\n           would always know to distinguish between links, every
      link\n           is identified by a dedicated link identifier.  Note that a\n
      \          link models a point-to-point link, not a multipoint link.\";\n        container
      source {\n          description\n            \"This container holds the logical
      source of a particular\n             link.\";\n          leaf source-node {\n
      \           type leafref {\n              path \"../../../nw-s:node/nw-s:node-id\";\n
      \             require-instance false;\n            }\n            description\n
      \             \"Source node identifier.  Must be in the same topology.\";\n
      \         }\n          leaf source-tp {\n            type leafref {\n              path
      \"../../../nw-s:node[nw-s:node-id=current()/../\"+\n                \"source-node]/termination-point/tp-id\";\n
      \             require-instance false;\n            }\n            description\n
      \             \"This termination point is located within the source node\n               and
      terminates the link.\";\n          }\n        }\n        container destination
      {\n          description\n            \"This container holds the logical destination
      of a\n             particular link.\";\n          leaf dest-node {\n            type
      leafref {\n              path \"../../../nw-s:node/nw-s:node-id\";\n            require-instance
      false;\n            }\n            description\n              \"Destination
      node identifier.  Must be in the same\n               network.\";\n          }\n
      \         leaf dest-tp {\n            type leafref {\n              path \"../../../nw-s:node[nw-s:node-id=current()/../\"+\n
      \               \"dest-node]/termination-point/tp-id\";\n              require-instance
      false;\n            }\n            description\n              \"This termination
      point is located within the\n               destination node and terminates
      the link.\";\n          }\n        }\n        leaf link-id {\n          type
      nt:link-id;\n          description\n            \"The identifier of a link in
      the topology.\n             A link is specific to a topology to which it belongs.\";\n
      \       }\n        list supporting-link {\n          key \"network-ref link-ref\";\n
      \         description\n            \"Identifies the link or links on which this
      link depends.\";\n          leaf network-ref {\n            type leafref {\n
      \             path \"../../../nw-s:supporting-network/nw-s:network-ref\";\n
      \           require-instance false;\n            }\n            description\n
      \             \"This leaf identifies in which underlay topology\n               the
      supporting link is present.\";\n          }\n          leaf link-ref {\n            type
      leafref {\n              path \"/nw-s:networks/nw-s:network[nw-s:network-id=\"+\n
      \               \"current()/../network-ref]/link/link-id\";\n              require-instance
      false;\n            }\n            description\n              \"This leaf identifies
      a link that is a part\n               of this link's underlay.  Reference loops
      in which\n               a link identifies itself as its underlay, either\n
      \              directly or transitively, are not allowed.\";\n          }\n
      \       }\n      }\n    }\n    augment \"/nw-s:networks/nw-s:network/nw-s:node\"
      {\n      description\n        \"Augments termination points that terminate links.\n
      \        Termination points can ultimately be mapped to interfaces.\";\n      list
      termination-point {\n        key \"tp-id\";\n        description\n          \"A
      termination point can terminate a link.\n           Depending on the type of
      topology, a termination point\n           could, for example, refer to a port
      or an interface.\";\n        leaf tp-id {\n          type nt:tp-id;\n          description\n
      \           \"Termination point identifier.\";\n        }\n        list supporting-termination-point
      {\n          key \"network-ref node-ref tp-ref\";\n          description\n            \"This
      list identifies any termination points on which a\n             given termination
      point depends or onto which it maps.\n             Those termination points
      will themselves be contained\n             in a supporting node.  This dependency
      information can be\n             inferred from the dependencies between links.
      \ Therefore,\n             this item is not separately configurable.  Hence,
      no\n             corresponding constraint needs to be articulated.\n             The
      corresponding information is simply provided by the\n             implementing
      system.\";\n          leaf network-ref {\n            type leafref {\n              path
      \"../../../nw-s:supporting-node/nw-s:network-ref\";\n            require-instance
      false;\n            }\n            description\n              \"This leaf identifies
      in which topology the\n               supporting termination point is present.\";\n
      \         }\n          leaf node-ref {\n            type leafref {\n              path
      \"../../../nw-s:supporting-node/nw-s:node-ref\";\n            require-instance
      false;\n            }\n            description\n              \"This leaf identifies
      in which node the supporting\n               termination point is present.\";\n
      \         }\n          leaf tp-ref {\n            type leafref {\n              path
      \"/nw-s:networks/nw-s:network[nw-s:network-id=\"+\n                \"current()/../network-ref]/nw-s:node[nw-s:node-id=\"+\n
      \               \"current()/../node-ref]/termination-point/tp-id\";\n              require-instance
      false;\n            }\n            description\n              \"Reference to
      the underlay node (the underlay node must\n               be in a different
      topology).\";\n          }\n        }\n      }\n    }\n  }\n  <CODE ENDS>\n"
    title: B.2.  YANG Module for Network Topology State
  title: Appendix B.  Companion YANG Data Models for Implementations Not
- contents:
  - "Appendix C.  An Example\n   This section contains an example of an instance data
    tree in JSON\n   encoding [RFC7951].  The example instantiates \"ietf-network-topology\"\n
    \  (and \"ietf-network\", which \"ietf-network-topology\" augments) for the\n
    \  topology depicted in Figure 7.  There are three nodes: D1, D2, and\n   D3.
    \ D1 has three termination points (1-0-1, 1-2-1, and 1-3-1).\n   D2 has three
    termination points as well (2-1-1, 2-0-1, and 2-3-1).\n   D3 has two termination
    points (3-1-1 and 3-2-1).  In addition, there\n   are six links, two between each
    pair of nodes with one going in each\n   direction.\n                +------------+
    \                  +------------+\n                |     D1     |                   |
    \    D2     |\n               /-\\          /-\\                 /-\\          /-\\\n
    \              | | 1-0-1    | |---------------->| | 2-1-1    | |\n               |
    |    1-2-1 | |<----------------| |    2-0-1 | |\n               \\-/  1-3-1   \\-/
    \                \\-/  2-3-1   \\-/\n                |   /----\\   |                   |
    \  /----\\   |\n                +---|    |---+                   +---|    |---+\n
    \                   \\----/                           \\----/\n                     A
    \ |                             A  |\n                     |  |                             |
    \ |\n                     |  |                             |  |\n                     |
    \ |       +------------+        |  |\n                     |  |       |     D3
    \    |        |  |\n                     |  |      /-\\          /-\\       |
    \ |\n                     |  +----->| | 3-1-1    | |-------+  |\n                     +---------|
    |    3-2-1 | |<---------+\n                               \\-/          \\-/\n
    \                               |            |\n                                +------------+\n
    \                  Figure 7: A Network Topology Example\n   The corresponding
    instance data tree is depicted in Figure 8:\n   {\n     \"ietf-network:networks\":
    {\n       \"network\": [\n         {\n           \"network-types\": {\n           },\n
    \          \"network-id\": \"otn-hc\",\n           \"node\": [\n             {\n
    \              \"node-id\": \"D1\",\n               \"termination-point\": [\n
    \                {\n                   \"tp-id\": \"1-0-1\"\n                 },\n
    \                {\n                   \"tp-id\": \"1-2-1\"\n                 },\n
    \                {\n                   \"tp-id\": \"1-3-1\"\n                 }\n
    \              ]\n             },\n             {\n               \"node-id\":
    \"D2\",\n               \"termination-point\": [\n                 {\n                   \"tp-id\":
    \"2-0-1\"\n                 },\n                 {\n                   \"tp-id\":
    \"2-1-1\"\n                 },\n                 {\n                   \"tp-id\":
    \"2-3-1\"\n                 }\n               ]\n             },\n             {\n
    \              \"node-id\": \"D3\",\n               \"termination-point\": [\n
    \                {\n                   \"tp-id\": \"3-1-1\"\n                 },\n
    \                {\n                   \"tp-id\": \"3-2-1\"\n                 }\n
    \              ]\n             }\n           ],\n           \"ietf-network-topology:link\":
    [\n             {\n               \"link-id\": \"D1,1-2-1,D2,2-1-1\",\n               \"source\":
    {\n                 \"source-node\": \"D1\",\n                 \"source-tp\":
    \"1-2-1\"\n               }\n               \"destination\": {\n                 \"dest-node\":
    \"D2\",\n                 \"dest-tp\": \"2-1-1\"\n               }\n             },\n
    \            {\n               \"link-id\": \"D2,2-1-1,D1,1-2-1\",\n               \"source\":
    {\n                 \"source-node\": \"D2\",\n                 \"source-tp\":
    \"2-1-1\"\n               }\n               \"destination\": {\n                 \"dest-node\":
    \"D1\",\n                 \"dest-tp\": \"1-2-1\"\n               }\n             },\n
    \            {\n               \"link-id\": \"D1,1-3-1,D3,3-1-1\",\n               \"source\":
    {\n                 \"source-node\": \"D1\",\n                 \"source-tp\":
    \"1-3-1\"\n               }\n               \"destination\": {\n                 \"dest-node\":
    \"D3\",\n                 \"dest-tp\": \"3-1-1\"\n               }\n             },\n
    \            {\n               \"link-id\": \"D3,3-1-1,D1,1-3-1\",\n               \"source\":
    {\n                 \"source-node\": \"D3\",\n                 \"source-tp\":
    \"3-1-1\"\n               }\n               \"destination\": {\n                 \"dest-node\":
    \"D1\",\n                 \"dest-tp\": \"1-3-1\"\n               }\n             },\n
    \            {\n               \"link-id\": \"D2,2-3-1,D3,3-2-1\",\n               \"source\":
    {\n                 \"source-node\": \"D2\",\n                 \"source-tp\":
    \"2-3-1\"\n               }\n               \"destination\": {\n                 \"dest-node\":
    \"D3\",\n                 \"dest-tp\": \"3-2-1\"\n               }\n             },\n
    \            {\n               \"link-id\": \"D3,3-2-1,D2,2-3-1\",\n               \"source\":
    {\n                 \"source-node\": \"D3\",\n                 \"source-tp\":
    \"3-2-1\"\n               }\n               \"destination\": {\n                 \"dest-node\":
    \"D2\",\n                 \"dest-tp\": \"2-3-1\"\n               }\n             }\n
    \          ]\n         }\n       ]\n     }\n   }\n                       Figure
    8: Instance Data Tree\n"
  title: Appendix C.  An Example
- contents:
  - "Acknowledgments\n   We wish to acknowledge the helpful contributions, comments,
    and\n   suggestions that were received from Alia Atlas, Andy Bierman, Martin\n
    \  Bjorklund, Igor Bryskin, Benoit Claise, Susan Hares, Ladislav Lhotka,\n   Carlos
    Pignataro, Juergen Schoenwaelder, Robert Wilton, Qin Wu, and\n   Xian Zhang.\n"
  title: Acknowledgments
- contents:
  - "Contributors\n   More people contributed to the data model presented in this
    paper\n   than can be listed in the \"Authors' Addresses\" section.  Additional\n
    \  contributors include:\n   o  Vishnu Pavan Beeram, Juniper\n   o  Ken Gray,
    Cisco\n   o  Tom Nadeau, Brocade\n   o  Tony Tkacik\n   o  Kent Watsen, Juniper\n
    \  o  Aleksandr Zhdankin, Cisco\n"
  title: Contributors
- contents:
  - "Authors' Addresses\n   Alexander Clemm\n   Huawei USA - Futurewei Technologies
    Inc.\n   Santa Clara, CA\n   United States of America\n   Email: ludwig@clemm.org,
    alexander.clemm@huawei.com\n   Jan Medved\n   Cisco\n   Email: jmedved@cisco.com\n
    \  Robert Varga\n   Pantheon Technologies SRO\n   Email: robert.varga@pantheon.tech\n
    \  Nitin Bahadur\n   Bracket Computing\n   Email: nitin_bahadur@yahoo.com\n   Hariharan
    Ananthakrishnan\n   Packet Design\n   Email: hari@packetdesign.com\n   Xufeng
    Liu\n   Jabil\n   Email: xufeng.liu.ietf@gmail.com\n"
  title: Authors' Addresses
