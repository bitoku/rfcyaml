- title: __initial_text__
  contents:
  - '       Thoughts on Address Resolution for Dual MAC FDDI Networks

    '
- title: Status of this Memo
  contents:
  - "Status of this Memo\n   This memo provides information for the Internet community.\
    \  It does\n   not specify an Internet standard.  Distribution of this memo is\n\
    \   unlimited.\n"
- title: 1. Abstract
  contents:
  - "1. Abstract\n   In this document an idea is submitted how IP and ARP can be used\
    \ on\n   inhomogeneous FDDI networks (FDDI networks with single MAC and dual\n\
    \   MAC stations) by introducing a new protocol layer in the protocol\n   suite\
    \ of the dual MAC stations.  Thus two dual MAC stations are able\n   to do a load\
    \ splitting across the two rings and use the double\n   bandwidth of 200 Mbits/s\
    \ as single MAC stations.  The new layer is an\n   extension of layer 3.  For\
    \ the user, the higher layer protocols, IP\n   and ARP the property \"dual MAC\"\
    \ is transparent.  No modification is\n   required in the protocol suite of single\
    \ MAC stations and transparent\n   bridges.\n"
- title: 2. Acknowledgements
  contents:
  - "2. Acknowledgements\n   This paper is a result of a diploma thesis prepared at\
    \ the Technical\n   University of Munich, Lehrstuhl fuer Kommunikationsnetze,\
    \ in co-\n   operation with the Siemens Nixdorf AG.  The author would like to\n\
    \   thank Jrg Eberspher and Bernhard Edmaier from the university, Andreas\n  \
    \ Thimmel and Jens Horstmeier from the SNI AG at Augsburg for the\n   helpful\
    \ comments and discussions.\n"
- title: 3. Conventions
  contents:
  - "3. Conventions\n   Primary MAC, P-MAC           MAC, placed on the primary ring\n\
    \   Secondary MAC, S-MAC         MAC, placed on the secondary ring\n   Inhomogeneous\
    \ ring           configuration of a dual FDDI ring with\n   DMARP            \
    \            Dual MAC Address Resolution Protocol\n"
- title: 4. Assumptions
  contents:
  - "4. Assumptions\n   When a dual FDDI ring wraps, both MACs in a dual MAC station\
    \ are\n   assumed to remain connected to the ring.  ANSI is just investigating\n\
    \   whether the Configuration Management in the Station Management of a\n   FDDI\
    \ station can be modified to allow this.  According to the FDDI\n   SMT standard\
    \ [1], different addresses are required for all MACs on\n   the primary and the\
    \ secondary ring.\n   In this paper, the MAC in a single MAC station is assumed\
    \ to reside\n   on the primary ring.  The application of single MAC stations which\n\
    \   have their MAC attached to the secondary ring is not precluded, but\n   therefor\
    \ additional connectivity between the two rings is required.\n   These configurations\
    \ are beyond the scope of this document.\n"
- title: 5. The Application of Transparent Bridges
  contents:
  - "5. The Application of Transparent Bridges\n   Transparent bridges can provide\
    \ links to other 802 LANs or further\n   inhomogeneous FDDI rings.  The connection\
    \ between two inhomogeneous\n   FDDI rings can be realized by one or two transparent\
    \ bridges. When\n   two transparent bridges are used, one transparent bridge links\
    \ the\n   primary rings, the other the secondary rings.  If two secondary rings\n\
    \   are connected by a transparent bridge, a path of transparent bridges\n   must\
    \ exist between the two primary rings.  No transparent bridges are\n   allowed\
    \ between the primary and the secondary ring.\n"
- title: 6. Protocol Layers in Single MAC Stations
  contents:
  - "6. Protocol Layers in Single MAC Stations\n   The new protocol layer, named load\
    \ sharing layer, is drafted to be\n   introduced only in dual MAC stations.  In\
    \ single MAC stations, IP and\n   ARP are working on top of the Subnetwork Access\
    \ Protocol (SNAP) 04]\n   and the Logical Link Control protocol (802.2 LLC) [3].\
    \  LLC type 1 is\n   used because connectionless services are investigated only.\n\
    \      +--------------------------+\n      |   IP                     |\n    \
    \  +--------------------------+\n      +--------------------------+\n      | \
    \  ARP                    |\n      +--------------------------+\n       |    \
    \         |\n       | ARP frames  | IP frames\n       |             |\n      +--------------------------+\n\
    \      |   SNAP                   |\n      +--------------------------+\n    \
    \  +--------------------------+\n      |   LLC                    |\n      +--------------------------+\n\
    \      +--------------------------++-------+\n      |   FDDI-MAC             \
    \  || F     |\n      +--------------------------+| D  S  |\n      +--------------------------+|\
    \ D  M  |\n      |   FDDI PHY and PMD       || I  T  |\n      +--------------------------++-------+\n\
    \   For the ARP layer, the following model is assumed:\n   +-------------------------------------------------------X-----------+\n\
    \   |  - ARP entity -                                       |           |\n  \
    \ |                                                       | IP frames |\n   |\
    \ +----------------+   +----------------+ read          |           |\n   | |\
    \ Cache          |   |                | entries +-------------+   |\n   | | Administration\
    \ |->-|  Address Cache |------>--| Address     |   |\n   | +----------------+\
    \   |                |         | Conversion  |   |\n   |     |               \
    \ +----------------+         | Unit        |   |\n   |     | ARP frames      \
    \                          +-------------+   |\n   |     |                   \
    \                            / |           |\n   |     | ___________ <- ARP requests\
    \ _________________/  | IP frames |\n   |     |/                             \
    \                   |           |\n   +-----X-------------------------------------------------X-----------+\n\
    \   The Address Conversion Unit handles the actual conversion of IP\n   addresses\
    \ to hardware addresses.  For this purpose, it uses the\n   information in the\
    \ ARP cache.  The cache administration communicates\n   with other ARP entities\
    \ by ARP and creates, deletes and renews the\n   entries in the cache.\n"
- title: 7. Protocol Layers in Dual MAC Stations
  contents:
  - "7. Protocol Layers in Dual MAC Stations\n   The load sharing layer provides the\
    \ same interface to ARP as SNAP\n   does.  To exchange information about addresses\
    \ and reachability, the\n   load sharing entities in dual MAC stations communicate\
    \ with the Dual\n   MAC Address Resolution Protocol (DMARP).  For the transmission\
    \ of\n   DMARP frames the SNAP SAP of LLC is used, as for IP and ARP, too.\n \
    \  The Organizationally Unique Identifier (OUI) in the SNAP header is\n   set\
    \ to zero (24 bit), the EtherType field (16 bit) contains a new\n   number indicating\
    \ DMARP, which is not defined yet.\n   +---------------------------------------------------------+\n\
    \   |                         IP                              |\n   +---------------------------------------------------------+\n\
    \   +---------------------------------------------------------+\n   |        \
    \                 ARP                             |\n   +---------------------------------------------------------+\n\
    \             | ARP frames                 | IP frames\n   +---------------------------------------------------------+\n\
    \   |                 Load Sharing Layer                      |\n   +---------------------------------------------------------+\n\
    \    |        |        |          |        |        |\n    | ARP    | DMARP  |\
    \ IP       | ARP    | DMARP  | IP\n    | frames | frames | frames   | frames |\
    \ frames | frames\n    |        |        |          |        |        |\n   +-------------------------+\
    \  +----------------------------+\n   |   SNAP 1                |  |    SNAP 2\
    \                  |\n   +-------------------------+  +----------------------------+\n\
    \   +-------------------------+  +----------------------------+\n   |   LLC 1\
    \                 |  |    LLC 2                   |\n   +-------------------------+\
    \  +----------------------------+\n   +-------------------------+  +----------------------------++-------+\n\
    \   |   Primary MAC           |  |    Secondary MAC           || F     |\n   +-------------------------+\
    \  +----------------------------+| D  S  |\n   +---------------------------------------------------------+|\
    \ D  M  |\n   |                  FDDI PHY and PMD                       || I \
    \ T  |\n   +---------------------------------------------------------++-------+\n"
- title: 8. Running Inhomogeneous FDDI Rings
  contents:
  - '8. Running Inhomogeneous FDDI Rings

    '
- title: 8.1. Exchange of Primary MAC Addresses between Stations
  contents:
  - "8.1. Exchange of Primary MAC Addresses between Stations\n   IP and higher layer\
    \ protocols only use the network independent IP\n   addresses.  The ARP entity\
    \ takes upon the conversion of an IP address\n   to the appropriate hardware address.\
    \  To make the property dual MAC\"\n   transparent, ARP may only know the addresses\
    \ of MACs on the primary\n   ring. Therefore, the load sharing entity always delivers\
    \ ARP frames\n   to SNAP 1 for transmission.  By this way, communication with\
    \ ARP is\n   done over the primary ring in normal state.  A secondary MAC can\n\
    \   receive an ARP frame when the dual ring is wrapped and the\n   destination\
    \ hardware address is a multicast or broadcast address.\n   These frames will\
    \ be discarded because they were received twice.\n   By this way, the associations\
    \ of IP addresses to primary MAC\n   addresses for the single MAC and dual MAC\
    \ stations are stored in the\n   ARP cache.  The ARP cache contains no secondary\
    \ MAC addresses.\n"
- title: 8.2. Exchange of Secondary MAC Addresses between Dual MAC Stations
  contents:
  - "8.2. Exchange of Secondary MAC Addresses between Dual MAC Stations\n   The load\
    \ sharing layer needs to know the secondary MAC addresses of\n   the other dual\
    \ MAC stations.  The DMARP is used to get these\n   addresses.  Whenever the load\
    \ sharing entity delivers an ARP frame to\n   SNAP 1, a DMARP reply frame will\
    \ be sent on the secondary ring,\n   containing the stations primary and secondary\
    \ MAC address. The\n   destination hardware address in this DMARP frame is the\
    \ broadcast MAC\n   address, the EtherType field in the SNAP header identifies\
    \ DMARP.\n   The IP destination address is copied from the ARP frame.  If the\
    \ ARP\n   frame that was transmitted parallel to the DMARP reply was a request,\n\
    \   an ARP reply frame will be sent back to the sending station by the\n   ARP\
    \ entity in the receiving station. When the load sharing layer in\n   the receiving\
    \ station delivers this ARP reply frame to SNAP 1, it\n   sends a DMARP reply\
    \ frame on the secondary ring.\n   By this way, DMARP exchanges the additionally\
    \ required secondary MAC\n   addresses between the dual MAC stations.  This is\
    \ done parallel to\n   the exchange of the ARP frames.\n"
- title: 8.3. Communication of Dual MAC Stations on Different Dual FDDI Rings
  contents:
  - "8.3. Communication of Dual MAC Stations on Different Dual FDDI Rings\n   If two\
    \ inhomogeneous dual FDDI rings are connected by one transparent\n   bridge, dual\
    \ MAC stations placed on different dual FDDI rings cannot\n   perform a load sharing.\
    \  If both dual FDDI rings remain in normal\n   state, no DMARP reply frames get\
    \ from one secondary ring to the other\n   secondary ring.  A dual MAC station\
    \ realizes another dual MAC station\n   placed on the other dual ring as a single\
    \ MAC station, because it\n   only receives ARP frames from it.  If one of the\
    \ dual rings is\n   wrapped, a DMARP reply frame can get on the primary ring of\
    \ the other\n   dual ring.  A target station on the unwrapped ring receives this\n\
    \   DMARP frame by the primary MAC and the load sharing entity stores the\n  \
    \ contained addresses in an entry in the address cache.  This entry is\n   marked\
    \ with a control bit, named the OR-bit Other ring bit\").  No\n   load sharing\
    \ will be done with a station related to an entry with the\n   OR-bit set.\n \
    \  If both dual FDDI rings are wrapped, the MACs of all stations reside\n   on\
    \ one ring.  Now, dual MAC stations placed on different dual rings\n   can communicate\
    \ with DMARP.  If a DMARP reply frame is received by\n   the primary MAC and no\
    \ entry exists for the sending station, a new\n   entry with OR-Bit set will be\
    \ created.  Otherwise, the OR-bit will be\n   set in the existing entry.  If a\
    \ DMARP reply frame is received by the\n   secondary MAC and an entry with OR-bit\
    \ set already exists for the\n   sending station, the bit will not be reset.\n\
    \   This mechanism provides that no load sharing will be done between\n   Dual\
    \ MAC stations on different dual rings if the dual rings are\n   linked with one\
    \ transparent bridge.  An additional DMARP error frame\n   is used to provide\
    \ against errors when a DMARP reply frame gets lost\n   on the ring.\n"
- title: 8.4. Timeout of Entries Marked with OR-Bit Set
  contents:
  - "8.4. Timeout of Entries Marked with OR-Bit Set\n   If a FDDI ring is wrapped,\
    \ the DMARP reply frames are received by the\n   primary and secondary MACs of\
    \ the target dual MAC stations.  In that\n   case, the entries for dual MAC stations\
    \ on the same dual ring are\n   also marked with the OR-bit, although the load\
    \ sharing is possible\n   between these stations.\n   When an OR-bit in an entry\
    \ is set for the first time, a timer entity\n   is started. If the timer entity\
    \ runs out, a DMARP request frame is\n   sent over SNAP 2 to the secondary MAC\
    \ of the associated target)\n   station.  Then the entry will be discarded.\n\
    \   If the request cannot be received by the target station because the\n   network\
    \ configuration has changed, there is no entry in the address\n   cache for this\
    \ station any more and no load sharing is computed.  If\n   the target station\
    \ receives the DMARP request frame, it sends back a\n   DMARP reply frame.\n"
- title: 8.5. Problems with the Application of Large FDDI Networks
  contents:
  - "8.5. Problems with the Application of Large FDDI Networks\n   With an increasing\
    \ number of dual FDDI rings, each one linked\n   together by two transparent bridges,\
    \ the probability increases, that\n   one of these inhomogeneous dual FDDI rings\
    \ is wrapped in the moment\n   when two dual MAC stations exchange ARP frames\
    \ and DMARP replies.\n   If two dual MAC stations are communicating for the first\
    \ time, the\n   probability decreases that a load sharing is really computed after\n\
    \   the exchange of DMARP replies, although this would be possible\n   according\
    \ to the network configuration.  It relies upon the fact,\n   that DMARP replies\
    \ get to the primary ring over the wrapped dual ring\n   and only entries marked\
    \ with the OR-bit set are created. To solve\n   this problem further expedients\
    \ are invented:\n   At first, entries in the address cache can be marked read-only\
    \ by the\n   setting of the R-bit.  In dual MAC stations, entries can be written\n\
    \   manually for other dual MAC stations that are frequently talked to or\n  \
    \ that have a special importance.  The control bits of these entries\n   cannot\
    \ be changed by DMARP.\n   Next, additional control bits are introduced.  One\
    \ of these bits is\n   the Hold-bit (H-bit). When two dual MAC stations exchange\
    \ ARP frames\n   and DMARP replies to create entries in their address caches,\
    \ one\n   station starts sending a DMARP reply, first.  According to the\n   network\
    \ state, it sends an additional DMARP error frame, a moment\n   later.  Within\
    \ a maximum period of time (see \"Configuring the Timer\n   Parameters\"), all\
    \ frames arrive at the neighbour station and are\n   received by the primary and/or\
    \ secondary MAC.  If the OR-bit was not\n   set for an entry within this period\
    \ of time, it is clear, that no\n   further DMARP frames will be received, which\
    \ result in setting the\n   OR-bit.  For such an entry the H-bit is set.  As the\
    \ reception of\n   reply and error frames is not sufficient for setting the OR-bit\
    \ when\n   the H-bit is set, the load sharing is assumed to be sure.  The\n  \
    \ correctness of the H-bit will be verified in relatively long time\n   periods\
    \ by queries (query and hold frames) at the station associated.\n   For two communicating\
    \ stations there exists a possibility to get\n   information from a third station.\
    \  Always, when the OR-bit is set for\n   an entry in a dual MAC station, a search\
    \ frame is transmitted by the\n   secondary MAC, containing the own primary MAC\
    \ address and the primary\n   MAC address of the counter station.  If a third\
    \ station can compute a\n   sure load sharing with both stations (the H-bit is\
    \ set for the\n   associated entries), the stations can perform a load sharing\
    \ between\n   them, too.  The third station informs these stations by sending\
    \ found\n   frames to them.\n"
- title: 8.6. Multicast and Broadcast Addresses in IP Frames
  contents:
  - "8.6. Multicast and Broadcast Addresses in IP Frames\n   If the destination hardware\
    \ address of an IP frame is a multicast or\n   broadcast hardware address, the\
    \ frame is always delivered to SNAP 1\n   and sent on the primary ring, because\
    \ one of the addressed stations\n   could be a single MAC station.  IP frames\
    \ which are delivered to the\n   load sharing entity by SNAP 2 are discarded by\
    \ the load sharing\n   entity.  Thus, the duplication of these frames can be prevented.\n"
- title: 9. Internal Structure
  contents:
  - "9. Internal Structure\n   One load Sharing entity exists in the load sharing\
    \ layer.  This load\n   sharing entity consists of the address cache, the cache\n\
    \   administration and the multiplexer.\n   to ARP                           \
    \                          to ARP\n   +----X----------------------------------------------------X--------+\n\
    \   |    |                                                   | IP      |\n   |\
    \    | ARP frames                            read        | frames  |\n   |   \
    \ |                                       entries     |         |\n   | +----------------------------+\
    \   +---------+       +----------+  |\n   | | Cache Administration       |->-|\
    \ Address |---->--|  Multi-  |  |\n   | +----------------------------|->-| Cache\
    \   |       |  plexer  |  |\n   |  |        |        |        |    +---------+\
    \       |          |  |\n   |  |        |        |        |                  \
    \    +----------+  |\n   |  | ARP    | DMARP  | ARP    | DMARP               \
    \ |        |    |\n   |  | frames | frames | frames | frames            IP | \
    \    IP |    |\n   |  |        |        |        |               frames | frames\
    \ |    |\n   |  |        |        |        |                      |        | \
    \   |\n   +--X--------X--------X--------X-----------------------X--------X---+\n\
    \   to SNAP 1         to SNAP 2                    to SNAP 1   to SNAP 2\n"
- title: 9.1. The Address Cache
  contents:
  - "9.1. The Address Cache\n   In the address cache, the associations of primary\
    \ MAC addresses to\n   secondary MAC addresses are stored for other dual MAC stations\
    \ on the\n   network.  There are no entries for single MAC stations.\n   Because\
    \ the OR- and the LS-bit (see table) always have inverted\n   values, one of the\
    \ bits is redundant.  Afterwards the examination of\n   an entry state gets easier\
    \ by the introduction of both bits, they are\n   defined together.  The ARP is\
    \ able to support other protocol address\n   formats than the IP format.  To support\
    \ this ARP property by DMARP,\n   the protocol type number as used in the ARP\
    \ frames is stored in every\n   entry of the address cache.  So, a dual MAC station\
    \ is able to\n   communicate with another station with DMARP, even if the other\n\
    \   station does not use IP.  The numbers used in DMARP frames and the\n   address\
    \ cache for the protocol type and the address length are taken\n   over from ARP.\n\
    \   name               length     comment\n   --------------------------------------------------------------------\n\
    \   P-MAC address      48 bit     Address of the primary MAC\n               \
    \                  in an other dual MAC station\n   S-MAC address      48 bit\
    \     Address of the secondary MAC\n                                 in that station\n\
    \   LS-bit             1 bit      A load sharing can be performed\n          \
    \                       with that station\n                                 (\"\
    Load sharing bit\")\n   OR-bit             1 bit      No load sharing may be done\n\
    \                                 with that station\n                        \
    \         (\"Other ring bit\")\n   H-bit              1 bit      The load sharing\
    \ with that\n                                 station is trusty.\n           \
    \                      (\"Hold bit\")\n   Q-bit              1 bit      A query\
    \ frame was sent to that\n                                 station, no hold frame\
    \ was\n                                 received yet (\"Query bit\")\n   R-bit\
    \              1 bit      This entry cannot be changed by\n                  \
    \               DMARP (\"Read-only bit\")\n   V-bit              1 bit      The\
    \ entry is valid\n                                 (\"Valid bit\")\n   subscript\
    \          32 bit     Unique number, identifying this\n                      \
    \           entry\n   protocol type      16 bit     Number of the protocol type\n\
    \                                 that was last used in that\n               \
    \                  station\n"
- title: 9.2. The Multiplexer
  contents:
  - "9.2. The Multiplexer\n   The multiplexer deals with multiplexing the IP frames\
    \ upon the two\n   FDDI rings.  Broadcast and multicast frames are always sent\
    \ on the\n   primary ring.  Otherwise, the contents of the address cache and a\
    \ load\n   sharing criteria are used to decide on which of the rings an IP frame\n\
    \   has to be transmitted.  If there is no entry for the primary MAC\n   address\
    \ of the destination station in the cache, the IP frame is\n   transmitted on\
    \ the primary ring.  If there is an entry for the\n   destination station and\
    \ the LS-bit is set, a load sharing can be done\n   with this station.  Later\
    \ on a load sharing criteria, which is beyond\n   the scope of this document,\
    \ decides, which one of the rings is used\n   for transmission.  An example for\
    \ a load sharing criteria is the\n   length of the transmit queues in the MACs.\
    \  The multiplexer requires an\n   abstract function only, which returns the appropriate\
    \ ring for the\n   transmission of an actual IP frame.\n   Additionally, the multiplexer\
    \ filters the received IP frames:\n   multicast or broadcast frames received from\
    \ the secondary MAC are\n   discarded.\n"
- title: 9.3. The Cache Administration
  contents:
  - "9.3. The Cache Administration\n   The cache administration creates and deletes\
    \ the entries in the\n   address cache.  For this purpose, it communicates with\
    \ other load\n   sharing entities in other dual MAC stations with the DMARP. \
    \ The\n   cache administration handles the delivery of ARP frames to the ARP\n\
    \   and the SNAP entity in the station, respectively.\n   The cache administration\
    \ needs three timers for the communication with\n   the DMARP, which have to be\
    \ supported by the system environment.  Each\n   of these timers must support\
    \ a timer entity for each entry in the\n   address cache, whereby a single one\
    \ is running at a time.\n   Supported timer services:\n      TIMER_request(time,\
    \ name, subscript)\n      TIMER_response(name, subscript)\n      TIMER_cancel(name,\
    \ subscript):\n   A timer entity is started by the service TIMER_request and cancelled\n\
    \   by the TIMER_cancel service request. The TIMER_response service\n   indicates\
    \ that a timer entity has run out.  The parameter name is the\n   name of a timer:\
    \ OR-Entry-Timer, Hold-Timer, or Query-Timer.  Each\n   entry in the address cache\
    \ is uniquely identified by a number\n   subscript).  This number is also the\
    \ number of an associated timer\n   entity.  How to dispose these numbers is a\
    \ question of\n   implementation.  The parameter time determines the time period\
    \ when\n   the timer runs out.  This parameter has the value OR-set-timeout for\n\
    \   the OR-Entry-Timer, Hold-time for the Hold-Timer and Query-time for\n   the\
    \ Query-Timer.\n"
- title: 9.4. Configuring the Timer Parameters
  contents:
  - "9.4. Configuring the Timer Parameters\n   The OR-set-timeout parameter for the\
    \ OR-Entry-Timer\n      The period of time, determined by this parameter, should\
    \ be\n      essentially longer than the maximum time for a frame to travel\n \
    \     around the entire network.  The expression entire network means\n      the\
    \ network which is constituted by the subnetworks linked\n      together with\
    \ transparent bridges.  When entries with OR-bit set\n      are created continuously\
    \ for a dual MAC station by the timeout\n      mechanism, this parameter determines\
    \ the periods of time between\n      the consecutive requests that are sent to\
    \ this station.  If the\n      state of the dual FDDI ring changes and an entry\
    \ with LS-bit set\n      could be created, this parameter additionally determines\
    \ the\n      maximum time until the new entry is created.  (If an entry could\n\
    \      not be created by transmission of search frames.)  Therefore, the\n   \
    \   OR-set-timeout parameter should be set to some 10 seconds.\n   The Hold-time\
    \ parameter for the Hold-Timer\n      The period of time, determined by this parameter,\
    \ should as well\n      be essentially longer than the maximum time for a frame\
    \ to travel\n      around the entire network.  When two stations communicate for\
    \ the\n      first time, they exchange ARP frames and DMARP replies.  The\n  \
    \    Hold-time parameter determines the period of time until the load\n      sharing\
    \ is assumed to be accomplished after the setting of the\n      LS-bit.  In this\
    \ period of time, the frames mentioned above must\n      have reached its destination.\
    \  If an entry would be marked with\n      the H-bit incorrectly, the time until\
    \ it gets corrected will be\n      relatively long (Query time).  Proposed dimension:\
    \ several\n      minutes.\n   The Query-time parameter for the Query-Timer\n \
    \     When an entry is marked with LS- and H-bit it is assumed, that\n      load\
    \ sharing can be performed with the associated station.  To\n      allow the correction\
    \ of a wrong value of the H-bit, the\n      correctness of the H-bit is tested\
    \ in periods of time, determined\n      by the parameter Query-time.  It is tested\
    \ whether a frame is\n      received, which was sent by the secondary MAC to the\
    \ secondary MAC\n      address of the target station.  (The target station acknowledges\n\
    \      the reception of the query frame by a hold frame.)  To limit the\n    \
    \  traffic caused by the query and hold frames, the parameter Query-\n      time\
    \ should be set to several minutes.\n"
- title: 9.5. Format of DMARP Frames
  contents:
  - "9.5. Format of DMARP Frames\n   fieldname            length            comment\n\
    \   --------------------------------------------------------------------\n   hardware\
    \ type        16 bit            1 = \"ethernet\"\n   protocol type        16 bit\
    \            2048D = \"Internet\n                                          Protocol\"\
    \n   length of hardware   8 bit             Value in octets,\n   addresses   \
    \                           6 for 48 bit MAC addresses\n   length of protocol\
    \   8 bit             Value in octets,\n   addresses                         \
    \     4 for Internet addresses\n   operation            16 bit            1: \"\
    reply\"\n                                          2: \"request\"\n          \
    \                                3: \"error\"\n                              \
    \            4: \"search\"\n                                          5: \"found\"\
    \n                                          6: \"query\"\n                   \
    \                       7: \"hold\"\n   1. hardware address  ... octets\n   2.\
    \ hardware address  ... octets\n   protocol address     ... octets\n   sender\n\
    \   protocol address     ... octets\n   receiver\n   --------------------------------------------------------------------\n\
    \   The value for the field \"protocol type\" is the same as in ARP frames.\n"
- title: 9.6. Contents of DMARP Frames
  contents:
  - "9.6. Contents of DMARP Frames\n   In the following tables of DMARP frames, the\
    \ fields containing the\n   length and type of protocol and hardware addresses\
    \ are omitted.\n   Format:\n   +-------------------------------------------------------------+\n\
    \   | Operation | 1. hardware | 2. hardware | protocol | protocol |\n   |    \
    \       | address     |    address  | address  | address  |\n   |           |\
    \             |             | sender   | receiver |\n   +-------------------------------------------------------------+\n\
    \   Operation = 1 (reply), 2 (request), 3 (error):\n   +-----------------------------------------------------------------+\n\
    \   | Operation | P-MAC address | S-MAC address | protocol | protocol |\n   |\
    \           | sender        | sender        | address  | address  |\n   |    \
    \       |               |               | sender   | receiver |\n   +-----------------------------------------------------------------+\n\
    \   +-------------------------------------------------------------------+\n  \
    \ | Operation=4 | P-MAC        | P-MAC address | protocol | broadcast |\n   |\
    \ (search)    | address      | counter-      | address  | protocol  |\n   |  \
    \           | sender       | station       | sender   | address   |\n   +-------------------------------------------------------------------+\n\
    \   +-------------------------------------------------------------------+\n  \
    \ | Operation=5 | P-MAC        | S-MAC address | protocol | broadcast |\n   |\
    \ (found)     | address      | counter-      | address  | protocol  |\n   |  \
    \           | sender       | station       | sender   | address   |\n   +-------------------------------------------------------------------+\n\
    \   +-------------------------------------------------------------------+\n  \
    \ | Operation=6 | S-MAC        | P-MAC address | protocol | broadcast |\n   |\
    \ (query)     | address      | counter-      | address  | protocol  |\n   |  \
    \           | sender       | station       | sender   | address   |\n   +-------------------------------------------------------------------+\n\
    \   +-------------------------------------------------------------------+\n  \
    \ | Operation=7 | P-MAC address | S-MAC address | protocol | protocol |\n   |\
    \ (hold)      | sender        | sender        | address  | address  |\n   |  \
    \           |               |               | sender   | receiver |\n   +-------------------------------------------------------------------+\n\
    \   Apart from the error frames all frames are sent on the secondary\n   ring.\
    \  The reply, error and search frames are addressed to the\n   broadcast hardware\
    \ address.  The request, found, query and hold\n   frames are addressed to an\
    \ individual secondary MAC address.\n"
- title: 10. Formal Description
  contents:
  - "10. Formal Description\n   The following description is written in ESTELLE.\n"
- title: 10.1. Global Constants, Variables and Types
  contents:
  - '10.1. Global Constants, Variables and Types

    '
- title: default individual queue;
  contents:
  - 'default individual queue;

    '
- title: timescale ...;
  contents:
  - 'timescale ...;

    '
- title: type
  contents:
  - "type\n PDU_type        = ... ; (* format of a Protocol Data Unit:\n         \
    \                    String of variable length               *)\n HW_addr_type\
    \    = ... ; (* format of a 48 bit MAC address           *)\n PR_addr_type   \
    \ = ... ; (* General: format of a protocol address\n                         \
    \   in an ARP or DMARP frame                 *)\n IP_addr_type    = ... ; (* General:\
    \ format of an IP address         *)\n QoS_type        = ... ; (* General: format\
    \ of a Quality-of-\n                             -Service statement          \
    \            *)\n timer_name_type = ... ; (* Type for the name of a system timer\
    \      *)\n flag = (reset,set);\n"
- title: var
  contents:
  - 'var

    '
- title: (*
  contents:
  - "(*\n  The values of these variables are set in the initialization part or\n \
    \ by external management functions.\n"
- title: '*)'
  contents:
  - '*)

    '
- title: 'My_P_MAC_addr      : HW_addr_type; (* Address of the MAC, placed on'
  contents:
  - "My_P_MAC_addr      : HW_addr_type; (* Address of the MAC, placed on\n       \
    \                               the primary ring               *)\n"
- title: 'My_S_MAC_addr      : HW_addr_type; (* Address of the MAC, placed on'
  contents:
  - "My_S_MAC_addr      : HW_addr_type; (* Address of the MAC, placed on\n       \
    \                               the secondary ring             *)\n"
- title: 'My_IP_address      : IP_addr_type; (* IP address of this station     *)'
  contents:
  - 'My_IP_address      : IP_addr_type; (* IP address of this station     *)

    '
- title: 'Broadcast_HW_addr  : HW_addr_type; (* Broadcast MAC address (48 bit) *)'
  contents:
  - 'Broadcast_HW_addr  : HW_addr_type; (* Broadcast MAC address (48 bit) *)

    '
- title: 'Broadcast_IP_addr  : IP_addr_type; (* Broadcast IP address           *)'
  contents:
  - 'Broadcast_IP_addr  : IP_addr_type; (* Broadcast IP address           *)

    '
- title: 'dmarp_QoS          : QoS_type;     (* Quality_of_Service-statement'
  contents:
  - "dmarp_QoS          : QoS_type;     (* Quality_of_Service-statement\n        \
    \                              for DMARP frames               *)\n"
- title: 'ethernet         : integer; (* Type statement in DMARP frames        *)'
  contents:
  - 'ethernet         : integer; (* Type statement in DMARP frames        *)

    '
- title: 'ip               : integer; (* Number for IP as protocol type        *)'
  contents:
  - 'ip               : integer; (* Number for IP as protocol type        *)

    '
- title: 'fddi_addr_length : integer; (* Length of a MAC address in octetts    *)'
  contents:
  - 'fddi_addr_length : integer; (* Length of a MAC address in octetts    *)

    '
- title: 'ip_addr_length   : integer; (* Length of a IP address in octetts     *)'
  contents:
  - 'ip_addr_length   : integer; (* Length of a IP address in octetts     *)

    '
- title: 'OR_set_timeout   : integer; (* Parameter for the OR-Entry-Timer      *)'
  contents:
  - 'OR_set_timeout   : integer; (* Parameter for the OR-Entry-Timer      *)

    '
- title: 'Query_time       : integer; (* Parameter for the Hold-Timer          *)'
  contents:
  - 'Query_time       : integer; (* Parameter for the Hold-Timer          *)

    '
- title: 'Hold_time        : integer; (* Parameter for the Query-Timer         *)'
  contents:
  - 'Hold_time        : integer; (* Parameter for the Query-Timer         *)

    '
- title: 10.2. Channels
  contents:
  - "10.2. Channels\n   channel SAPchn(User,Provider);\n   by User :\n    UNITDATA_request\n\
    \    (\n      Source_addr  : HW_addr_type;\n      Dest_addr    : HW_addr_type;\n\
    \      QoS          : QoS_type;\n      PDU          : PDU_type;\n    )\n   by\
    \ Provider :\n    UNITDATA_indication\n    (\n      Source_addr  : HW_addr_type;\n\
    \      Dest_addr    : HW_addr_type;\n      QoS          : QoS_type;\n      PDU\
    \          : PDU_type;\n    )\n   channel System_Access_Point_chn(User,Provider);\n\
    \   by User:\n    TIMER_request(Time       : integer;\n                  Timer_id\
    \   : timer_name_type;\n                  subscript  : integer);\n    TIMER_cancel(Timer_id\
    \    : timer_name_type;\n                 subscript   : integer);\n   by Provider:\n\
    \    TIMER_response(Timer_id  : timer_name_type;\n                   subscript\
    \ : integer);\n"
- title: 10.3. The Module Header and Interaction Points
  contents:
  - "10.3. The Module Header and Interaction Points\n   module LS_module systemprocess;\n\
    \    ip LS_ARPSAP     : SAPchn(Provider);\n       LS_IPSAP      : SAPchn(Provider);\n\
    \       SNAP1_ARPSAP  : SAPchn(User);\n       SNAP1_LSSAP   : SAPchn(User);\n\
    \       SNAP1_IPSAP   : SAPchn(User);\n       SNAP2_ARPSAP  : SAPchn(User);\n\
    \       SNAP2_LSSAP   : SAPchn(User);\n       SNAP2_IPSAP   : SAPchn(User);\n\
    \       LS_System_Access_Point : System_Access_Point_chn(User);\n   end;\n"
- title: 10.4. The Modulebody of the Load Sharing Entity
  contents:
  - "10.4. The Modulebody of the Load Sharing Entity\n   body LS_body for LS_module;\n\
    \   module multiplexer_module process;\n    ip LS_IPSAP    : SAPchn(Provider);\n\
    \       SNAP1_IPSAP : SAPchn(User);\n       SNAP2_IPSAP : SAPchn(User);\n   end;\n\
    \   module cache_administration_module process;\n    ip LS_ARPSAP    : SAPchn(Provider);\n\
    \       SNAP1_ARPSAP : SAPchn(User);\n       SNAP1_LSSAP  : SAPchn(User);\n  \
    \     SNAP2_ARPSAP : SAPchn(User);\n       SNAP2_LSSAP  : SAPchn(User);\n    \
    \   LS_System_Access_Point : System_Access_Point_chn(User);\n   end;\n   body\
    \ cache_administration_body for cache_administration_module;\n     (* defined\
    \ later *)\n   end;\n   body multiplexer_body for multiplexer_module;\n     (*\
    \ defined later *)\n   end;\n   modvar\n    cache_administration : cache_administration_module;\n\
    \    multiplexer          : multiplexer_module;\n   initialize\n   begin\n   \
    \ ethernet         := 1;\n    ip               := 2048;\n    fddi_addr_length\
    \ := 6;\n    ip_addr_length   := 4;\n    init cache_administration      with cache_administration_body;\n\
    \    init multiplexer               with multiplexer_body;\n    attach LS_IPSAP\
    \                to multiplexer.LS_IPSAP;\n    attach SNAP1_IPSAP            \
    \ to multiplexer.SNAP1_IPSAP;\n    attach SNAP2_IPSAP             to multiplexer.SNAP2_IPSAP;\n\
    \    attach LS_ARPSAP               to cache_administration.LS_ARPSAP;\n    attach\
    \ SNAP1_ARPSAP            to cache_administration.SNAP1_ARPSAP;\n    attach SNAP1_LSSAP\
    \             to cache_administration.SNAP1_LSSAP;\n    attach SNAP2_ARPSAP  \
    \          to cache_administration.SNAP2_ARPSAP;\n    attach SNAP2_LSSAP     \
    \        to cache_administration.SNAP2_LSSAP;\n    attach LS_System_Access_Point\
    \  to cache_administration.\n                                       LS_System_Access_Point;\n\
    \   end; end;\n"
- title: 10.5. The Modulebody for the Multiplexer
  contents:
  - '10.5. The Modulebody for the Multiplexer

    '
- title: body multiplexer_body for multiplexer_module;
  contents:
  - 'body multiplexer_body for multiplexer_module;

    '
- title: type
  contents:
  - "type\n  Type_of_addr_type = (individual, multi, broad);\n  ring_type        \
    \ = (primary, secondary);\n"
- title: var
  contents:
  - "var\n  act_S_MAC_addr : HW_addr_type;\n"
- title: 'function determ_addrtype(HW_addr: HW_addr_type): Type_of_addr_type;'
  contents:
  - 'function determ_addrtype(HW_addr: HW_addr_type): Type_of_addr_type;

    '
- title: primitive;
  contents:
  - 'primitive;

    '
- title: (*
  contents:
  - "(*\n  Returns the type of a hardware address.\n  (Individual, multicast or broadcast\
    \ address)\n"
- title: '*)'
  contents:
  - '*)

    '
- title: 'function get_cacheentry(prtype: integer; P_MAC_addr: HW_addr_type;'
  contents:
  - "function get_cacheentry(prtype: integer; P_MAC_addr: HW_addr_type;\n var S_MAC_addr\
    \ : HW_addr_type): boolean;\n"
- title: primitive;
  contents:
  - 'primitive;

    '
- title: (*
  contents:
  - "(*\n Returns the associated secondary MAC address for a given primary MAC\n address\
    \ and protocol type. If an entry exists, the value TRUE is\n returned.\n"
- title: '*)'
  contents:
  - '*)

    '
- title: 'function ls_criteria : ring_type;'
  contents:
  - 'function ls_criteria : ring_type;

    '
- title: (*
  contents:
  - "(*\n Returns the ring on which the actual frame should be transmitted.\n"
- title: '*)'
  contents:
  - '*)

    '
- title: primitive;
  contents:
  - 'primitive;

    '
- title: trans
  contents:
  - 'trans

    '
- title: when LS_IPSAP.UNITDATA_request(Source_addr,Dest_addr,QoS,PDU) begin
  contents:
  - "when LS_IPSAP.UNITDATA_request(Source_addr,Dest_addr,QoS,PDU) begin\n if determ_addrtype(Dest_addr)\
    \ <> individual then\n output SNAP1_IPSAP.UNITDATA_request(Source_addr,Dest_addr,QoS,PDU);\n\
    \ else begin\n  if get_cacheentry(ip,Dest_addr,act_S_MAC_addr) and\n   (ls_criteria=secondary)\
    \ then\n  output SNAP2_IPSAP.UNITDATA_request(My_S_MAC_addr,\n   act_S_MAC_addr,QoS,PDU);\n\
    \  else\n  output SNAP1_IPSAP.UNITDATA_request(Source_addr,Dest_addr,QoS,PDU);\n\
    \ end;\n"
- title: end;
  contents:
  - 'end;

    '
- title: when SNAP1_IPSAP.UNITDATA_indication(Source_addr,Dest_addr,QoS,PDU)
  contents:
  - 'when SNAP1_IPSAP.UNITDATA_indication(Source_addr,Dest_addr,QoS,PDU)

    '
- title: begin
  contents:
  - "begin\n output LS_IPSAP.UNITDATA_indication(Source_addr,Dest_addr,QoS,PDU);\n"
- title: end;
  contents:
  - 'end;

    '
- title: when SNAP2_IPSAP.UNITDATA_indication(Source_addr,Dest_addr,QoS,PDU)
  contents:
  - 'when SNAP2_IPSAP.UNITDATA_indication(Source_addr,Dest_addr,QoS,PDU)

    '
- title: begin
  contents:
  - "begin\n if determ_addrtype(Dest_addr) = individual then begin\n  Dest_addr :=\
    \ My_P_MAC_addr;\n  output LS_IPSAP.UNITDATA_indication(Source_addr,Dest_addr,QoS,PDU);\n\
    \ end;\n"
- title: end;
  contents:
  - 'end;

    '
- title: 10.6. The Modulebody for the Cache Administration
  contents:
  - '10.6. The Modulebody for the Cache Administration

    '
- title: body cache_administration_body for cache_administration_module;
  contents:
  - 'body cache_administration_body for cache_administration_module;

    '
- title: type
  contents:
  - "type\n arp_pdu_type = record\n  hwtype        : integer;\n  prtype        : integer;\n\
    \  HW_length     : integer;\n  PR_length     : integer;\n  operation     : (request,reply);\n\
    \  HW_sender     : HW_addr_type;\n  PR_sender     : PR_addr_type;\n  HW_receiver\
    \   : HW_addr_type;\n  PR_receiver   : PR_addr_type;\n end;\n dmarp_operation_type\
    \ = (request,reply,error,search,found,query,hold);\n dmarp_pdu_type = record\n\
    \  hwtype        : integer;\n  prtype        : integer;\n  HW_length     : integer;\n\
    \  PR_length     : integer;\n  operation     : dmarpoperation_type;\n  HW_1  \
    \        : HW_addr_type;\n  HW_2          : HW_addr_type;\n  PR_sender     : PR_addr_type;\n\
    \  PR_receiver   : PR_addr_type;\n end;\n"
- title: var
  contents:
  - "var\n arp_pdu        : arp_pdu_type;\n dmarp_pdu      : dmarp_pdu_type;\n send_pdu\
    \       : dmarp_pdu_type;\n act_P_MAC_addr : HW_addr_type;\n"
- title: 'function my_pr_address(prtype : integer ; praddr : PR_addr_type):'
  contents:
  - 'function my_pr_address(prtype : integer ; praddr : PR_addr_type):

    '
- title: boolean;
  contents:
  - 'boolean;

    '
- title: (*
  contents:
  - "(*\n Returns TRUE, if praddr is my station address, the protocol type is\n prtype.\
    \ (2048d for the Internet protocol)\n"
- title: '*)'
  contents:
  - '*)

    '
- title: primitive;
  contents:
  - 'primitive;

    '
- title: 'function get_my_pr_addr(prtype : integer) : PR_addr_type;'
  contents:
  - 'function get_my_pr_addr(prtype : integer) : PR_addr_type;

    '
- title: (*
  contents:
  - "(*\n Returns my station address, the protocol has the number prtype.\n"
- title: '*)'
  contents:
  - '*)

    '
- title: 'function extract_arp_pdu(PDU : PDU_type) : arp_pdu_type;'
  contents:
  - 'function extract_arp_pdu(PDU : PDU_type) : arp_pdu_type;

    '
- title: (*
  contents:
  - "(*\n Returns the data contained in an ARP PDU as a record.\n"
- title: '*)'
  contents:
  - '*)

    '
- title: primitive;
  contents:
  - 'primitive;

    '
- title: 'function extract_dmarp_pdu(PDU : PDU_type) : dmarp_pdu_type;'
  contents:
  - 'function extract_dmarp_pdu(PDU : PDU_type) : dmarp_pdu_type;

    '
- title: (*
  contents:
  - "(*\n Returns the data contained in an DMARP PDU as a record.\n"
- title: '*)'
  contents:
  - '*)

    '
- title: primitive;
  contents:
  - 'primitive;

    '
- title: 'function assemble_dmarp_pdu(dmarp_pdu : dmarp_pdu_type): PDU;'
  contents:
  - 'function assemble_dmarp_pdu(dmarp_pdu : dmarp_pdu_type): PDU;

    '
- title: (*
  contents:
  - "(*\n Returns a DMARP PDU from the data in the record.\n"
- title: '*)'
  contents:
  - '*)

    '
- title: primitive;
  contents:
  - 'primitive;

    '
- title: 'procedure create_entry(prtype: integer; P_MAC_addr: HW_addr_type;'
  contents:
  - "procedure create_entry(prtype: integer; P_MAC_addr: HW_addr_type;\n S_MAC_addr:\
    \ HW_addr_type; LS_Bit: flag; OR_Bit: flag;\n H_Bit: flag; Q_Bit: flag; R_Bit:\
    \ flag; V_Bit: flag);\n"
- title: (*
  contents:
  - "(*\n Creates a new entry in the address cache, if no entry with the given\n primary\
    \ MAC address or R-bit set to one exists. The protocol type has\n the number prtype.\
    \ The control bits are set as given in the parameters,\n the LS-bit is set last.\n"
- title: '*)'
  contents:
  - '*)

    '
- title: primitive;
  contents:
  - 'primitive;

    '
- title: 'function search_entry(prtype : integer; P_MAC_addr : HW_addr_type):'
  contents:
  - 'function search_entry(prtype : integer; P_MAC_addr : HW_addr_type):

    '
- title: boolean;
  contents:
  - 'boolean;

    '
- title: (*
  contents:
  - "(*\n Returns TRUE if an entry with the primary MAC address P_MAC_addr and\n the\
    \ given protocol type was found in the address cache.\n"
- title: '*)'
  contents:
  - '*)

    '
- title: primitive;
  contents:
  - 'primitive;

    '
- title: 'procedure update_entry(prtype: integer; P_MAC_addr: HW_addr_type;'
  contents:
  - "procedure update_entry(prtype: integer; P_MAC_addr: HW_addr_type;\n S_MAC_addr:\
    \ HW_addr_type);\n"
- title: (*
  contents:
  - "(*\n Searches an entry with the given primary MAC address P_MAC_address and\n\
    \ updates the secondary MAC address in the entry if the R-bit is set to\n zero.\n"
- title: '*)'
  contents:
  - '*)

    '
- title: primitive;
  contents:
  - 'primitive;

    '
- title: 'procedure reset_LS_bit(prtype: integer; P_MAC_addr : HW_addr_type);'
  contents:
  - 'procedure reset_LS_bit(prtype: integer; P_MAC_addr : HW_addr_type);

    '
- title: (*
  contents:
  - "(*\n Searches an entry with the given primary MAC address P_MAC_address and\n\
    \ resets the LS-bit if the R-bit is reset.\n"
- title: '*)'
  contents:
  - '*)

    '
- title: primitive;
  contents:
  - 'primitive;

    '
- title: 'procedure set_Q_bit(prtype: integer; P_MAC_addr : HW_addr_type);'
  contents:
  - 'procedure set_Q_bit(prtype: integer; P_MAC_addr : HW_addr_type);

    '
- title: (*
  contents:
  - "(*\n Searches an entry with the given primary MAC address P_MAC_address and\n\
    \ sets the Q-bit if the R-bit is reset.\n"
- title: '*)'
  contents:
  - '*)

    '
- title: primitive;
  contents:
  - 'primitive;

    '
- title: 'function H_bit_set(prtype: integer; P_MAC_addr : HW_addr_type):'
  contents:
  - 'function H_bit_set(prtype: integer; P_MAC_addr : HW_addr_type):

    '
- title: boolean;
  contents:
  - 'boolean;

    '
- title: (*
  contents:
  - "(*\n Returns TRUE if an entry exists with H-bit set to one and the given\n P-MAC\
    \ address.\n"
- title: '*)'
  contents:
  - '*)

    '
- title: primitive;
  contents:
  - 'primitive;

    '
- title: 'function OR_bit_set(prtype: integer; P_MAC_addr : HW_addr_type):'
  contents:
  - 'function OR_bit_set(prtype: integer; P_MAC_addr : HW_addr_type):

    '
- title: boolean;
  contents:
  - 'boolean;

    '
- title: (*
  contents:
  - "(*\n Returns TRUE if an entry exists with OR-bit set to one and the given\n P-MAC\
    \ address.\n"
- title: '*)'
  contents:
  - '*)

    '
- title: primitive;
  contents:
  - 'primitive;

    '
- title: 'function LS_bit_set(prtype: integer; P_MAC_addr : HW_addr_type):'
  contents:
  - 'function LS_bit_set(prtype: integer; P_MAC_addr : HW_addr_type):

    '
- title: boolean;
  contents:
  - 'boolean;

    '
- title: (*
  contents:
  - "(*\n Returns TRUE if an entry exists with LS-bit set to one and the given\n P-MAC\
    \ address.\n"
- title: '*)'
  contents:
  - '*)

    '
- title: primitive;
  contents:
  - 'primitive;

    '
- title: 'function Q_bit_set(prtype: integer; P_MAC_addr : HW_addr_type):'
  contents:
  - 'function Q_bit_set(prtype: integer; P_MAC_addr : HW_addr_type):

    '
- title: boolean;
  contents:
  - 'boolean;

    '
- title: (*
  contents:
  - "(*\n Returns TRUE if an entry exists with Q-bit set to one and the given\n P-MAC\
    \ address.\n"
- title: '*)'
  contents:
  - '*)

    '
- title: primitive;
  contents:
  - 'primitive;

    '
- title: 'function get_subscript(prtype: integer; P_MAC_addr : HW_addr_type):'
  contents:
  - 'function get_subscript(prtype: integer; P_MAC_addr : HW_addr_type):

    '
- title: integer;
  contents:
  - 'integer;

    '
- title: (*
  contents:
  - "(*\n Returns the subscipt number of an entry with the given primary MAC\n address.\n"
- title: '*)'
  contents:
  - '*)

    '
- title: primitive;
  contents:
  - 'primitive;

    '
- title: 'function get_broadcast_addr(prtype : integer): PR_addr_type;'
  contents:
  - 'function get_broadcast_addr(prtype : integer): PR_addr_type;

    '
- title: (*
  contents:
  - "(*\n Returns the broadcast protocol address for the given protocol type.\n"
- title: '*)'
  contents:
  - '*)

    '
- title: 'function get_P_MAC_addr(subscript : integer) : HW_addr_type;'
  contents:
  - 'function get_P_MAC_addr(subscript : integer) : HW_addr_type;

    '
- title: (*
  contents:
  - "(*\n Returns the primary MAC address of the entry with the given subscript\n\
    \ number.\n"
- title: '*)'
  contents:
  - '*)

    '
- title: primitive;
  contents:
  - 'primitive;

    '
- title: 'function get_S_MAC_addr(prtype: integer; P_MAC_addr: HW_addr_type):'
  contents:
  - "function get_S_MAC_addr(prtype: integer; P_MAC_addr: HW_addr_type):\n HW_addr_type;\n"
- title: (*
  contents:
  - "(*\n Returns the secondary MAC address of the station with the given primary\n\
    \ MAC address.\n"
- title: '*)'
  contents:
  - '*)

    '
- title: primitive;
  contents:
  - 'primitive;

    '
- title: 'procedure delete_entry(subscript : integer);'
  contents:
  - 'procedure delete_entry(subscript : integer);

    '
- title: (*
  contents:
  - "(*\n Deletes the entry with the given subscript number if the R-bit is\n reset.\n"
- title: '*)'
  contents:
  - '*)

    '
- title: primitive;
  contents:
  - 'primitive;

    '
- title: 'function get_pr_type(subscript : integer) : integer;'
  contents:
  - 'function get_pr_type(subscript : integer) : integer;

    '
- title: (*
  contents:
  - "(*\n Returns the protocol type for the entry with the given subscript\n number.\n"
- title: '*)'
  contents:
  - '*)

    '
- title: primitive;
  contents:
  - 'primitive;

    '
- title: 'function get_pr_length(prtype : integer) : integer;'
  contents:
  - 'function get_pr_length(prtype : integer) : integer;

    '
- title: (*
  contents:
  - "(*\n Returns the length of a protocol address.\n"
- title: '*)'
  contents:
  - '*)

    '
- title: primitive;
  contents:
  - 'primitive;

    '
- title: trans
  contents:
  - 'trans

    '
- title: when LS_ARPSAP.UNITDATA_request(Source_addr,Dest_addr,QoS,PDU)
  contents:
  - 'when LS_ARPSAP.UNITDATA_request(Source_addr,Dest_addr,QoS,PDU)

    '
- title: begin
  contents:
  - "begin\n arp_pdu := extract_arp_pdu(PDU);\n output SNAP1_ARPSAP.UNITDATA_request(Source_addr,Dest_addr,QoS,PDU);\n\
    \ dmarp_pdu.hwtype               := ethernet;\n dmarp_pdu.prtype             \
    \  := arp_pdu.prtype;\n dmarp_pdu.HW_length            := fddi_addr_length;\n\
    \ dmarp_pdu.PR_length            := arp_pdu.PR_length;\n dmarp_pdu.operation \
    \           := reply;\n dmarp_pdu.HW_1                 := My_P_MAC_addr;\n dmarp_pdu.HW_2\
    \                 := My_S_MAC_addr;\n dmarp_pdu.PR_sender            := arp_pdu.PR_sender;\n\
    \ dmarp_pdu.PR_receiver          := arp_pdu.PR_receiver;\n PDU := assemble_dmarp_pdu(dmarp_pdu);\n\
    \ output SNAP2_LSSAP.UNITDATA_request(My_S_MAC_addr,Broadcast_HW_addr,\n  dmarp_QoS,PDU);\n"
- title: end;
  contents:
  - 'end;

    '
- title: when SNAP1_ARPSAP.UNITDATA_indication(Source_addr,Dest_addr,QoS,PDU)
  contents:
  - 'when SNAP1_ARPSAP.UNITDATA_indication(Source_addr,Dest_addr,QoS,PDU)

    '
- title: begin
  contents:
  - "begin\n output LS_ARPSAP.UNITDATA_indication(Source_addr,Dest_addr,QoS,PDU);\n"
- title: end;
  contents:
  - 'end;

    '
- title: when SNAP2_ARPSAP.UNITDATA_indication(Source_addr,Dest_addr,QoS,PDU)
  contents:
  - 'when SNAP2_ARPSAP.UNITDATA_indication(Source_addr,Dest_addr,QoS,PDU)

    '
- title: begin end;
  contents:
  - 'begin end;

    '
- title: when SNAP1_LSSAP.UNITDATA_indication(Source_addr,Dest_addr,QoS,PDU)
  contents:
  - 'when SNAP1_LSSAP.UNITDATA_indication(Source_addr,Dest_addr,QoS,PDU)

    '
- title: begin
  contents:
  - "begin\n dmarp_pdu := extract_dmarp_pdu(PDU);\n if ((dmarp_pdu.operation = error)\
    \ or (dmarp_pdu.operation = reply))\n then begin\n  if my_pr_address(dmarp_pdu.prtype,dmarp_pdu.PR_receiver)\
    \ then begin\n   if not H_bit_set(dmarp_pdu.prtype,dmarp_pdu.HW_1) then begin\n\
    \    if not OR_bit_set(dmarp_pdu.prtype,dmarp_pdu.HW_1) then begin\n     if LS_bit_set(dmarp_pdu.prtype,dmarp_pdu.HW_1)\
    \ then begin\n      output LS_System_Access_point.TIMER_cancel(\n       \"Hold_Timer\"\
    ,get_subscript(dmarp_pdu.prtype,dmarp_pdu.HW_1));\n      create_entry(dmarp_pdu.prtype,dmarp_pdu.HW_1,dmarp_pdu.HW_2,\n\
    \       reset,set,reset,reset,reset,set);\n     end;\n     output LS_System_Access_point.TIMER_request(\n\
    \      OR_set_timeout,\"OR_Entry_Timer\",\n      get_subscript(dmarp_pdu.prtype,dmarp_pdu.HW_1));\n\
    \     send_pdu.hwtype    := ethernet;\n     send_pdu.prtype    := dmarp_pdu.prtype;\n\
    \     send_pdu.HW_length := fddi_addr_length;\n     send_pdu.PR_length := dmarp_pdu.PR_length;\n\
    \     send_pdu.operation := search;\n     send_pdu.HW_1      := My_P_MAC_addr;\n\
    \     send_pdu.HW_2      := dmarp_pdu.HW_1;\n     send_pdu.PR_sender := get_my_pr_addr(dmarp_pdu.prtype);\n\
    \     send_pdu.PR_receiver := get_broadcast_addr(dmarp_pdu.prtype);\n     PDU\
    \ := assemble_dmarp_pdu(dmarp_pdu);\n     output SNAP2_LSSAP.UNITDATA_request(\n\
    \      My_S_MAC_addr,Broadcast_HW_addr,dmarp_QoS,PDU);\n    end else begin\n \
    \    if dmarp_pdu.operation=error then\n     update_entry(dmarp_pdu.prtype,dmarp_pdu.HW_1,dmarp_pdu.HW_2);\n\
    \    end;\n   end else begin\n    if dmarp_pdu.operation = error then\n    update_entry(dmarp_pdu.prtype,dmarp_pdu.HW_1,dmarp_pdu.HW_2);\n\
    \   end;\n  end else begin\n   if my_pr_address(dmarp_pdu.prtype,dmarp_pdu.PR_sender)\
    \ and\n    (dmarp_pdu.operation = reply) then begin\n    dmarp_pdu.operation :=\
    \ error;\n    PDU := assemble_dmarp_pdu(dmarp_pdu);\n    output SNAP1_LSSAP.UNITDATA_request(\n\
    \     My_P_MAC_addr,Broadcast_HW_addr,dmarp_QoS,PDU);\n   end else begin\n   \
    \ if dmarp_pdu.operation=error and\n     search_entry(dmarp_pdu.prtype,dmarp_pdu.HW_1)\
    \ then\n    update_entry(dmarp_pdu.prtype,dmarp_pdu.HW_1,dmarp_pdu.HW_2);\n"
- title: end; end; end; end;
  contents:
  - 'end; end; end; end;

    '
- title: when SNAP2_LSSAP.UNITDATA_indication(Source_addr,Dest_addr,QoS,PDU)
  contents:
  - 'when SNAP2_LSSAP.UNITDATA_indication(Source_addr,Dest_addr,QoS,PDU)

    '
- title: begin
  contents:
  - "begin\n dmarp_pdu := extract_dmarp_pdu(PDU);\n if (dmarp_pdu.operation = found)\
    \ and\n  my_pr_address(dmarp_pdu.prtype,dmarp_pdu.PR_receiver) then begin\n  if\
    \ not H_bit_set(dmarp_pdu.prtype,dmarp_pdu.HW_1) then begin\n   if OR_bit_set(dmarp_pdu.prtype,dmarp_pdu.HW_1)\
    \ then begin\n    output LS_System_Access_Point.\n     TIMER_cancel(\"OR_Entry_Timer\"\
    ,\n     get_subscript(dmarp_pdu.prtype,dmarp_pdu.HW_1));\n   end;\n   if LS_bit_set(dmarp_pdu.prtype,dmarp_pdu.HW_1)\
    \ then begin\n    output LS_System_Access_Point.\n     TIMER_cancel(\"Hold_Timer\"\
    ,\n     get_subscript(dmarp_pdu.prtype,dmarp_pdu.HW_1));\n   end;\n   create_entry(dmarp_pdu.prtype,dmarp_pdu.HW_1,dmarp_pdu.HW_2,\n\
    \    set,reset,set,reset,reset,set);\n   output LS_System_Access_Point.TIMER_request(Query_time,\"\
    Query_Timer\",\n    get_subscript(dmarp_pdu.prtype,dmarp_pdu.HW_1));\n  end;\n\
    \ end else begin\n  if (dmarp_pdu.operation = reply) or\n   (dmarp_pdu.operation\
    \ = request) then begin\n   if search_entry(dmarp_pdu.prtype,dmarp_pdu.HW_1) then\n\
    \    update_entry(dmarp_pdu.prtype,dmarp_pdu.HW_1,dmarp_pdu.HW_2);\n  end;\n \
    \ if (dmarp_pdu.operation=request) and\n   my_pr_address(dmarp_pdu.prtype,dmarp_pdu.PR_receiver)\
    \ then begin\n   send_pdu.hwtype      := dmarp_pdu.hwtype;\n   send_pdu.prtype\
    \      := dmarp_pdu.prtype;\n   send_pdu.HW_length   := fddi_addr_length;\n  \
    \ send_pdu.PR_length   := dmarp_pdu.PR_length;\n   send_pdu.operation   := reply;\n\
    \   send_pdu.HW_1        := My_P_MAC_addr;\n   send_pdu.HW_2        := My_S_MAC_addr;\n\
    \   send_pdu.PR_sender   := get_my_pr_addr(dmarp_pdu.prtype);\n   send_pdu.PR_receiver\
    \ := dmarp_pdu.PR_sender;\n   PDU := assemble_dmarp_pdu(dmarp_pdu);\n   output\
    \ SNAP2_LSSAP.UNITDATA_request(\n    My_S_MAC_addr,Broadcast_HW_addr,dmarp_QoS,PDU);\n\
    \  end else begin\n   if my_pr_address(dmarp_pdu.prtype,dmarp_pdu.pr_receiver)\
    \ then begin\n    case dmarp_pdu.operation of\n     reply: begin\n      if not\
    \ ( OR_bit_set(dmarp_pdu.prtype,dmarp_pdu.HW_1) or\n       LS_bit_set(dmarp_pdu.prtype,dmarp_pdu.HW_1)\
    \ )then begin\n       create_entry(dmarp_pdu.prtype,dmarp_pdu.HW_1,dmarp_pdu.HW_2,\n\
    \        set,reset,reset,reset,reset,set);\n       output LS_System_Access_Point.TIMER_request(Hold_time,\n\
    \        \"Hold_Timer\",get_subscript(dmarp_pdu.prtype,dmarp_pdu.HW_1));\n   \
    \   end;\n     end;\n     error: begin\n      if not ( OR_bit_set(dmarp_pdu.prtype,dmarp_pdu.HW_1)\
    \ or\n       H_bit_set(dmarp_pdu.prtype,dmarp_pdu.HW_1) ) then begin\n       if\
    \ LS_bit_set(dmarp_pdu.prtype,dmarp_pdu.HW_1) then\n       output LS_System_access_point.TIMER_cancel(\n\
    \        \"Hold_Timer\",get_subscript(dmarp_pdu.prtype,dmarp_pdu.HW_1));\n   \
    \    create_entry(dmarp_pdu.prtype,dmarp_pdu.HW_1,dmarp_pdu.HW_2,\n        reset,set,reset,reset,reset,set);\n\
    \       output LS_System_access_point.TIMER_request(\n        OR_set_timeout,\"\
    OR_Entry_Timer\",\n        get_subscript(dmarp_pdu.prtype,dmarp_pdu.HW_1));\n\
    \       send_pdu.hwtype          := ethernet;\n       send_pdu.prtype        \
    \  := dmarp_pdu.prtype;\n       send_pdu.HW_length       := fddi_addr_length;\n\
    \       send_pdu.PR_length       := dmarp_pdu.PR_length;\n       send_pdu.operation\
    \       := search;\n       send_pdu.HW_1            := My_P_MAC_addr;\n      \
    \ send_pdu.HW_2            := dmarp_pdu.HW_1;\n       send_pdu.PR_sender     \
    \  := get_my_pr_addr(dmarp_pdu.prtype);\n       send_pdu.PR_receiver     := get_broadcast_addr(dmarp_pdu.prtype);\n\
    \       PDU := assemble_dmarp_pdu(dmarp_pdu);\n       output SNAP2_LSSAP.UNITDATA_request(\n\
    \        My_S_MAC_addr,Broadcast_HW_addr,dmarp_QoS,PDU);\n      end;\n     end;\n\
    \     search: begin\n      if not (dmarp_pdu.HW_1=My_P_MAC_addr or\n       dmarp_pdu.HW_2=My_P_MAC_addr)\
    \ then begin\n       if H_bit_set(dmarp_pdu.prtype,dmarp_pdu.HW_1) and\n     \
    \   H_bit_set(dmarp_pdu.prtype,dmarp_pdu.HW_2) then begin\n        send_pdu.hwtype\
    \      := ethernet;\n        send_pdu.prtype      := dmarp_pdu.prtype;\n     \
    \   send_pdu.HW_length   := fddi_addr_length;\n        send_pdu.PR_length   :=\
    \ dmarp_pdu.PR_length;\n        send_pdu.operation   := found;\n        send_pdu.HW_1\
    \        := dmarp_pdu.HW_2;\n        send_pdu.HW_2        := get_S_MAC_addr(dmarp_pdu.prtype,\n\
    \                                 dmarp_pdu.HW_2);\n        send_pdu.PR_sender\
    \   := get_my_pr_addr(dmarp_pdu.prtype);\n        send_pdu.PR_receiver := get_broadcast_addr(dmarp_pdu.prtype);\n\
    \        PDU := assemble_dmarp_pdu(send_pdu);\n        output SNAP2_LSSAP.UNITDATA_request(My_S_MAC_addr,\n\
    \         get_S_MAC_addr(dmarp_pdu.prtype,dmarp_pdu.HW_1),dmarp_QoS,PDU);\n  \
    \      send_pdu.HW_1 := dmarp_pdu.HW_1;\n        send_pdu.HW_2 := get_S_MAC_addr(dmarp_pdu.prtype,\n\
    \         dmarp_pdu.HW_1);\n        PDU := assemble_dmarp_pdu(send_pdu);\n   \
    \     output SNAP2_LSSAP.UNITDATA_request(My_S_MAC_addr,\n         get_S_MAC_addr(dmarp_pdu.prtype,dmarp_pdu.HW_2),dmarp_QoS,PDU);\n\
    \       end;\n      end;\n     end;\n     Query: begin\n      if dmarp_pdu.HW_2\
    \ = My_P_MAC_addr then begin\n       send_pdu.hwtype          := ethernet;\n \
    \      send_pdu.prtype          := dmarp_pdu.prtype;\n       send_pdu.HW_length\
    \       := dmarp_pdu.HW_length;\n       send_pdu.PR_length       := dmarp_pdu.PR_length;\n\
    \       send_pdu.operation       := hold;\n       send_pdu.HW_1            :=\
    \ My_P_MAC_addr;\n       send_pdu.HW_2            := My_S_MAC_addr;\n       send_pdu.PR_sender\
    \       := get_my_pr_addr(dmarp_pdu.prtype);\n       send_pdu.PR_receiver    \
    \ := dmarp_pdu.PR_sender;\n       PDU := assemble_dmarp_pdu(send_pdu);\n     \
    \  output SNAP2_LSSAP.UNITDATA_request(\n        My_S_MAC_addr,dmarp_pdu.HW_1,dmarp_QoS,PDU);\n\
    \      end;\n     end;\n     Hold: begin\n      if H_bit_set(dmarp_pdu.prtype,dmarp_pdu.HW_1)\
    \ then\n      reset_Q_bit(dmarp_pdu.prtype,dmarp_pdu.HW_1);\n     end;\n    end;\n\
    \   end;\n  end;\n end;\n"
- title: end;
  contents:
  - 'end;

    '
- title: when LS_System_Access_Point.TIMER_response(Timer_name,subscript) begin
  contents:
  - 'when LS_System_Access_Point.TIMER_response(Timer_name,subscript) begin

    '
- title: case Timer_name of
  contents:
  - "case Timer_name of\n \"OR_Entry_Timer\": begin\n  act_P_MAC_addr := get_P_MAC_addr(subscript);\n\
    \  if OR_bit_set(get_pr_type(subscript),act_P_MAC_addr) then begin\n   send_pdu.hwtype\
    \      := ethernet;\n   send_pdu.prtype      := get_pr_type(subscript);\n   send_pdu.HW_length\
    \   := fddi_addr_length;\n   send_pdu.PR_length   := get_pr_length(send_pdu.prtype);\n\
    \   send_pdu.operation   := request;\n   send_pdu.HW_1        := My_P_MAC_addr;\n\
    \   send_pdu.HW_2        := My_S_MAC_addr;\n   send_pdu.PR_sender   := get_my_pr_addr(send_pdu.prtype);\n\
    \   send_pdu.PR_receiver := get_broadcast_addr(send_pdu.prtype);\n   PDU := assemble_dmarp_pdu(send_pdu);\n\
    \   output SNAP2_LSSAP.UNITDATA_request(\n    My_S_MAC_addr,get_S_MAC_addr(send_pdu.prtype,act_P_MAC_addr),\n\
    \    dmarp_QoS,PDU);\n   delete_entry(subscript);\n  end;\n end;\n \"Hold_Timer\"\
    : begin\n  act_P_MAC_addr := get_P_MAC_addr(subscript);\n  if (not H_bit_set(get_pr_type(subscript),act_P_MAC_addr))\
    \ and\n   LS_bit_set(get_pr_type(subscript),act_P_MAC_addr) then begin\n   set_H_bit(get_pr_type(subscript),act_P_MAC_addr);\n\
    \   output LS_System_Access_point.TIMER_request(\n    Query_time,\"Query_Timer\"\
    ,subscript);\n  end;\n end;\n \"Query_Timer\": begin\n  act_P_MAC_addr       :=\
    \ get_P_MAC_addr(subscript);\n  send_pdu.hwtype      := ethernet;\n  send_pdu.prtype\
    \      := get_pr_type(subscript);\n  send_pdu.HW_length   := fddi_addr_length;\n\
    \  send_pdu.PR_length   := get_pr_length(send_pdu.prtype);\n  send_pdu.PR_sender\
    \   := get_my_pr_addr(send_pdu.prtype);\n  send_pdu.PR_receiver := get_broadcast_addr(send_pdu.prtype);\n\
    \  if Q_bit_set(get_pr_type(subscript),act_P_MAC_addr) then begin\n   send_pdu.HW_1\
    \      := My_P_MAC_addr;\n   send_pdu.HW_2      := My_S_MAC_addr;\n   send_pdu.operation\
    \ := request;\n   PDU := assemble_dmarp_pdu(send_pdu);\n   output SNAP2_LSSAP.UNITDATA_request(\n\
    \    My_S_MAC_addr,get_S_MAC_addr(send_pdu.prtype,act_P_MAC_addr),\n    dmarp_QoS,PDU);\n\
    \   delete_entry(subscript);\n  end else begin\n   send_pdu.HW_1      := My_S_MAC_addr;\n\
    \   send_pdu.HW_2      := get_P_MAC_addr(subscript);\n   send_pdu.operation :=\
    \ query;\n   PDU := assemble_dmarp_pdu(send_pdu);\n   output SNAP2_LSSAP.UNITDATA_request(\n\
    \    My_S_MAC_addr,get_S_MAC_addr(send_pdu.prtype,send_pdu.HW_2),\n    dmarp_QoS,PDU);\n\
    \   set_Q_bit(send_pdu.prtype,send_pdu.HW_2);\n"
- title: end; end; end; end; end; (* body *)
  contents:
  - 'end; end; end; end; end; (* body *)

    '
- title: 11. Summary
  contents:
  - "11. Summary\n   The introduction of the load sharing layer in the protocol layering\n\
    \   of the dual MAC stations allows the application of IP and ARP on\n   inhomogeneous\
    \ FDDI rings. The protocol suite of single MAC stations\n   needs no modification.\n\
    \   By the load sharing layer, the property \"dual MAC\" is transparent for\n\
    \   ARP, IP and the higher layer protocols.\n   In dual MAC stations, any load\
    \ sharing criteria may be implemented in\n   the multiplexer of the load sharing\
    \ entity.  The conversion of\n   addresses, the exchange of address and reachability\
    \ information\n   between dual MAC stations and the proper transmission of multicast\n\
    \   and broadcast frames is taken upon by the load sharing entity.\n"
- title: 12. References
  contents:
  - "12. References\n    [1] ANSI, \"FDDI Station Management (SMT)\", ANSI\n     \
    \   X3T9/90-X3T9.5/84-49 Rev 6.2, May 1990.\n    [2] ANSI, \"FDDI Media Access\
    \ Control (MAC-2)\",\n        X3T9/90-X3T9.5/88-139 Rev 3.2, June 1990.\n    [3]\
    \ ISO, \"Information processing systems- Local area networks-\n        Part 2:\
    \ Logical link control\", ISO 8802-2:1989, August 1989.\n    [4] IEEE, \"Draft\
    \ Standard P802.1A Overview and Architecture\",\n        P802.1A/D9-89/74, September\
    \ 1989.\n    [5] Plummer, C., \"An Ethernet Address Resolution Protocol --or--\n\
    \        Converting Network Protocol Addresses to 48.bit Ethernet\n        Address\
    \ for Transmission on Ethernet Hardware\", RFC 826, MIT,\n        November 1982.\n\
    \    [6] Reynolds, J., and Postel, J., \"Assigned Numbers\", RFC 1060,\n     \
    \   USC/Information Sciences Institute, March 1990.\n    [7] Postel, J., \"Internet\
    \ Protocol\", RFC 791, USC/Information\n        Sciences Institute, September\
    \ 1981.\n    [8] Katz, D., \"A Proposed Standard for the Transmission of IP\n\
    \        Datagrams over FDDI Networks\", RFC 1188, Merit/NSFNET,\n        October\
    \ 1990.\n    [9] Internet Engineering Task Force, Braden, R., Editor,\n      \
    \  \"Requirements for Internet Hosts -- Communication Layers\",\n        RFC 1122,\
    \ IETF, October 1989.\n   [10] Katz, D., \"The Use of Connectionless Network Layer\
    \ Protocols\n        over FDDI Networks\", Merit/NSFNET, 1990.\n"
- title: 13.  Security Considerations
  contents:
  - "13.  Security Considerations\n   Security issues are not discussed in this memo.\n"
- title: 14. Author's Address
  contents:
  - "14. Author's Address\n   Peter Kuehn\n   Raiffeisenstrasse 9b\n   8933 Untermeitingen\n\
    \   Germany\n   Phone: .. 82 32 / 7 46 02\n   EMail: thimmela@sniabg.wa.sni.de\n"
