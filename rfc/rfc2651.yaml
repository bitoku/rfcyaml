- contents:
  - '         The Architecture of the Common Indexing Protocol (CIP)

    '
  title: __initial_text__
- contents:
  - "Status of this Memo\n   This document specifies an Internet standards track protocol
    for the\n   Internet community, and requests discussion and suggestions for\n
    \  improvements.  Please refer to the current edition of the \"Internet\n   Official
    Protocol Standards\" (STD 1) for the standardization state\n   and status of this
    protocol.  Distribution of this memo is unlimited.\n"
  title: Status of this Memo
- contents:
  - "Copyright Notice\n   Copyright (C) The Internet Society (1999).  All Rights Reserved.\n"
  title: Copyright Notice
- contents:
  - "Abstract\n   The Common Indexing Protocol (CIP) is used to pass indexing\n   information
    from server to server in order to facilitate query\n   routing. Query routing
    is the process of redirecting and replicating\n   queries through a distributed
    database system towards servers holding\n   the desired results. This document
    describes the CIP framework,\n   including its architecture and the protocol specifics
    of exchanging\n   indices.\n"
  title: Abstract
- contents:
  - '1. Introduction

    '
  - contents:
    - "1.1. History and Motivation\n   The Common Indexing Protocol (CIP) is an evolution
      and refinement of\n   distributed indexing concepts first introduced in the
      Whois++\n   Directory Service [RFC1913, RFC1914]. While indexing proved useful
      in\n   that system to promote query routing, the centroid index object which\n
      \  is passed among Whois++ servers is specifically designed for\n   template-based
      databases searchable by token-based matching.  With\n   alternative index objects,
      the index-passing technology will prove\n   useful to many more application
      domains, not simply Directory\n   Services and those applications which can
      be cast into the form of\n   template collections.\n   The indexing part of
      Whois++ is integrated with the data access\n   protocol. The goal in designing
      CIP is to extract the indexing\n   portion of Whois++, while abstracting the
      index objects to apply more\n   broadly to information retrieval. In addition,
      another kind of\n   technology reuse has been undertaken by converting the ad-hoc
      data\n   representations used by Whois++ into structures based on the MIME\n
      \  specification for structured Internet mail.\n   Whois++ used a version number
      field in centroid objects to facilitate\n   future growth. The initial version
      was \"1\". Version 1 of CIP (then\n   embedded in Whois++, and not referred
      to separately as CIP) had\n   support for only ISO-8895-1 characters, and for
      only the centroid\n   index object type.\n   Version 2 of the Whois++ centroid
      was used in the Digger software by\n   Bunyip Information Systems to notify
      recipients that the centroid\n   carried extra character set information. Digger's
      centroids can carry\n   UTF-8 encoded 16-bit Unicode characters, or ISO-8859-1
      characters,\n   determined by a field in the headers.\n   This specification
      is for CIP version 3.  Version 3 is a major\n   overhaul to the protocol.  However,
      by using of a short negotiation\n   sequence, CIP version 3 servers can interoperate
      with earlier servers\n   in an index-passing mesh.\n   For unclear terms the
      reader is referred to the glossary in Appendix\n   A.\n"
    title: 1.1. History and Motivation
  - contents:
    - "1.2 CIP's place in the Information Retrieval world\n   CIP facilitates query
      routing. CIP is a protocol used between servers\n   in a network to pass hints
      which make data access by clients at a\n   later date more efficient. Query
      routing is the act of redirecting\n   and replicating queries through a distributed
      database system towards\n   the servers holding the actual results via reference
      to indexing\n   information.\n   CIP is a \"backend\" protocol -- it is implemented
      in and \"spoken\" only\n   among network servers. These same servers must also
      speak some kind\n   of data access protocol to communicate with clients. During
      query\n   resolution in the native protocol implementation, the server will\n
      \  refer to the indexing information collected by the CIP implementation\n   for
      guidance on how to route the query.\n   Data access protocols used with CIP
      must have some provision for\n   control information in the form of a referral.
      The syntax and\n   semantics of these referrals are outside the scope of this\n
      \  specification.\n"
    title: 1.2 CIP's place in the Information Retrieval world
  title: 1. Introduction
- contents:
  - "2. Related Documents\n   This document is one of three documents. This document
    describes the\n   fundamental concepts and framework of CIP.\n   The document
    \"MIME Object Definitions for the Common Indexing\n   Protocol\" [CIP-MIME] describes
    the MIME objects that make up the\n   items that are passed by the transport system.\n
    \  Requirements and examples of several transport systems are specified\n   in
    the \"CIP Transport Protocols\" [CIP-TRANSPORT] document.\n   A second set of
    document describe the various specifications for\n   specific index types.\n"
  title: 2. Related Documents
- contents:
  - '3. Architecture

    '
  - contents:
    - '3.1 CIP in the Information Retrieval World

      '
    - contents:
      - "3.1.1 Information Retrieval in the Abstract\n   In order to better understand
        how CIP fits into the information\n   retrieval world, we need to first understand
        the unifying abstract\n   features of existing information retrieval technology.
        Next, we\n   discuss why adding indexing technology to this model results
        in a\n   system capable of query routing, and why query routing is useful.\n
        \  An abstract view of the client/server data retrieval process includes\n
        \  data sets and data access protocols. An individual server is\n   responsible
        for handling queries over a fixed domain of data. For the\n   purposes of
        CIP, we call this domain of data the dataset. Clients\n   make searches in
        the dataset and retrieve parts of it via a data\n   access protocol. There
        are many data access protocols, each optimized\n   for the data in question.
        For instance, LDAP and Whois++ are access\n   protocols that reflect the needs
        of the directory services\n   application domain. Other data access protocols
        include HTTP and\n   Z39.50.\n"
      title: 3.1.1 Information Retrieval in the Abstract
    - contents:
      - "3.1.2 Indexing Information Facilitates Query Routing\n   The above description
        reflects a world without indexing, where no\n   server knows about any other
        server. In some cases (as with X.500\n   referrals, and HTTP redirects) a
        server will, as part of its reply,\n   implicate another server in the process
        of resolving the query.\n   However, those servers generate replies based
        solely on their local\n   knowledge. When indexing information is introduced
        into a server's\n   local database, the server now knows not only answers
        based on the\n   local dataset, but also answers based on external indices.
        These\n   indices come from peer servers, via an indexing protocol. CIP is
        one\n   such indexing protocol.\n   Replies based on index information may
        not be the complete answer.\n   After all, an index is not a replicated version
        of the remote\n   dataset, but a possibly reduced version of it. Thus, in
        addition to\n   giving complete replies from the local dataset, the server
        may give\n   referrals to other datasets. These referrals are the core feature\n
        \  necessary for effective query routing. When servers use CIP to pass\n   indices
        from server to server, they make a kind of investment. At the\n   cost of
        some resources to create, transmit and store the indices,\n   query routing
        becomes possible.\n   Query Routing is the process of replicating and moving
        a query closer\n   to datasets which can satisfy the query. In some distributed
        systems,\n   widely distributed searches must be accomplished by replicating
        the\n   query to all sub-datasets. This approach can be wasteful of resources\n
        \  both in the network, and on the servers, and is thus sometimes\n   explicitly
        disabled. Using indexing in such a system opens the door\n   to more efficient
        distributed searching.\n   While CIP-equipped servers provide the referrals
        necessary to make\n   query routing work, it is always the client's responsibility
        to\n   collate, filter, and chase the referrals it receives. This gives the\n
        \  end-user (or agent, in the case that there's no human user involved\n   in
        the search) greatest control over the query resolution process.\n   The cost
        of the added client complexity is weighed against the\n   benefits of total
        control over query resolution. In some cases, it\n   may also be possible
        to decouple the referral chasing from the client\n   by introducing a proxy,
        allowing existing simple clients to make use\n   of query routing. Such a
        proxy would transparently resolve referrals\n   into concrete results before
        returning them to the simple-minded\n   client.\n"
      title: 3.1.2 Indexing Information Facilitates Query Routing
    - contents:
      - "3.1.3 Abstracting the CIP index object\n   As useful as indices seem, the
        fact remains that not all queries can\n   benefit from the same type of index.
        For example, say the index\n   consists of a simple list of keywords. With
        such an index, it is\n   impossible to answer queries about whether two keywords
        were near one\n   another, or if a keyword was present in a certain context
        (for\n   instance, in the title).\n   Because of the need for application
        domain specific indices, CIP\n   index objects are abstract; they must be
        defined by a separate\n   specification. The basic protocols for moving index
        objects are\n   widely applicable, but the specific design of the index, and
        the\n   structure of the mesh of servers which pass a particular type of\n
        \  index is dependent on the application domain. This document describes\n
        \  only the protocols for moving indices among servers. Companion\n   documents
        describe initial index objects.\n   The requirements that index type specifications
        must address are\n   specified in the [CIP-MIME] document.\n"
      title: 3.1.3 Abstracting the CIP index object
    title: 3.1 CIP in the Information Retrieval World
  - contents:
    - "3.2 Architectural Details\n   CIP implements index passing, providing the forward
      knowledge\n   necessary to generate the referrals used for query routing. The
      core\n   of the protocol is the index object. In the following sections, the\n
      \  structure of the index objects themselves is presented. Next, how and\n   why
      indices are passed from server to server is discussed. Finally,\n   the circumstances
      under which a server may synthesize an index object\n   based on incoming ones
      are discussed.\n"
    - contents:
      - "3.2.1 The CIP Index Object\n   A CIP index object is composed of two parts,
        the header and the\n   payload. The header contains metadata necessary to
        process and make\n   use of the index object being transmitted. The actual
        index resides\n   in the payload.\n   Three particular headers warrant specific
        mention at this point.  The\n   \"type\" of the index object selects one of
        many distinct CIP index\n   object specifications which define exactly how
        the index blocks are\n   to be created, parsed and used to facilitate query
        routing.  Another\n   header of note is the \"DSI\", or Dataset Identifier,
        which uniquely\n   identifies the dataset from which the index was created.
        \ Another\n   header that is crucial for generating referrals is the \"Base-URI\".\n
        \  The URI (or URI's) contained in this header form the basis of any\n   referrals
        generated based on this index block. The URI is also used\n   as input during
        the index aggregation process to constrain the kinds\n   of aggregation possible,
        due to multiprotocol constraints.  How that\n   URI is used is defined by
        the aggregation algorithm.  The exact\n   syntax of these headers is specified
        in the CIP MIME specification\n   document [CIP-MIME].\n   The payload is
        opaque to CIP itself. It is defined exclusively by the\n   index object specification
        associated with the object's MIME type.\n   Specifications on how to parse
        and use the payload are published\n   separately as \"CIP index object specifications\".
        This abstract\n   definition of the index object forms the basis of CIP's
        applicability\n   to indexing needs across multiple application domains.\n
        \  A precise definition of the content and form of a CIP index block can\n
        \  be found in the Protocol document [CIP-MIME]\n"
      title: 3.2.1 The CIP Index Object
    - contents:
      - "3.2.2 Moving Index Objects: How to Build a Mesh\n   Indices are transmitted
        among servers participating in a CIP mesh. By\n   distributing this information
        in anticipation of a query, efficient,\n   accurate query routing is possible
        at the time a query arrives.\n   A CIP mesh is a set of CIP servers which
        pass indices of the same\n   type among themselves. Typically, a mesh is arranged
        in a\n   hierarchical tree fashion, with servers nearer the root of the tree\n
        \  having larger and more comprehensive indices. See Figure 1. However,\n
        \  a CIP mesh is explicitly allowed to have lateral links in it, and\n   there
        may be more than one part of the mesh that has the properties\n   of a \"root\".
        Mesh administrators are encouraged to avoid loops in the\n   system, but they
        are not obliged to maintain a strict tree structure.\n   Clients wishing to
        completely resolve all referrals they receive\n   should protect against referral
        loops while attempting to traverse\n   the mesh to avoid wasting time and
        network resources.  See the\n   section on \"Navigating the Mesh\" for a discussion
        of this.\n     base level             index                    index\n     directory
        \            servers                  servers\n      servers                for
        \                     for\n                          base level               lower-level\n
        \                          servers                index servers\n     _______\n
        \   |       |\n    |   A   |__\n    |_______|  \\            _______\n                \\---CIP----|
        \      |\n     _______               |   D   |__\n    |       |   /---CIP----|_______|
        \ \\             ------\n    |   B   |__/                       \\--CIP------|
        \     |\n    |_______|                                      |  F   |\n                                       /--CIP------|______|\n
        \                                     /\n     _______                _______
        \ /\n    |       |              |       |-\n    |   C   |-------CIP----|   E
        \  |\n    |_______|              |_______|-\n                                |
        \   \\\n                                r     \\\n     _______                    e
        \     \\            ______\n    |       |                   f       \\--CIP-----|
        \     |\n    |   G   |-------CIP---------e------------------|  H   |\n    |_______|
        \                  r                  |______|\n            \\--referral---|
        \    r      --referral-/\n                          |     a     |\n                          |
        \    l     |\n                          \\ 3   | 2   | 1\n                            \\--------/\n
        \                           |        |\n                            | client
        |\n                            |        |\n                             --------\n
        \            Figure 1: Sample layout of the Index Service mesh\n   All indices
        passed in a given mesh are assumed, as of this writing,\n   to be of the same
        type (i.e. governed by the same CIP index object\n   specification). It may
        be possible to create gateways between meshes\n   carrying different index
        objects, but at this time that process is\n   undefined and declared to be
        outside the scope of this specification.\n   In the case where a CIP server
        receives an index of a type that it\n   does not understand it _can_ pass
        that index forward untouched.  In\n   the case where a server implementation
        decides not to accept unknown\n   indices it should return an appropriate
        error message to the server\n   sending the index. This behavior is to allow
        mesh implementations to\n   attempt heterogeneous meshes. As stated above
        heterogeneous meshes\n   are considered to be ill defined and as such should
        be considered\n   dangerous.\n   Experience suggests that this index passing
        activity should take\n   place among CIP servers as a parallel (and possibly
        lower-priority)\n   job to their primary job of answering queries. Index objects
        travel\n   among CIP servers by protocol exchanges explicitly defined in this\n
        \  document, not via the server's native protocol. This distinction is\n   important,
        and bears repeating:\n      Queries are answered (and referrals are sent)
        via the native data\n      access protocol.\n      Index objects are transferred
        via alternative means, as defined by\n      this document.\n   When two servers
        cooperate to move indexing information, the pair are\n   said to be in a \"polling
        relationship\". The server that holds the\n   data of interest, and generates
        the index is called the \"polled\n   server\".  The other server, which is
        the one that collects the\n   generated index, is the \"polling server\".\n
        \  In a polling relationship, the polled server is responsible for\n   notifying
        the polling server when it has a new index that the polling\n   server might
        be interested in. In response, the polling server may\n   immediately pick
        up the index object, or it may schedule a job to\n   pick up a copy of the
        new index at a more convenient time. But, a\n   polling server is not required
        to wait on the polled server to notify\n   it of changes. The polling server
        can request a new index at any\n   time.\n   Independent of the symmetric
        polling relationship, there's another\n   way that servers can pass indices
        using CIP. In an \"index pushing\"\n   relationship, a CIP server simply sends
        the index to a peer whenever\n   necessary, and allows the receiver to handle
        the index object as it\n   chooses. The receiving server may refuse it, may
        accept it, then\n   silently discard it, may accept only portions of it (by
        accepting it\n   as is, then filtering it), or may accept it without question.\n
        \  The index pushing relationship is intended for use by dumb leaf nodes\n
        \  which simply want to make their index available to the global mesh of\n
        \  servers, but have no interest in implementing the complete CIP\n   transaction
        protocol. It lowers the barriers to entry for CIP leaf\n   nodes. For more
        information on participating in a CIP mesh in this\n   restricted manner,
        see the section below on \"Protocol Conformance\".\n   CIP index passing operations
        take place across a reliable transport\n   mechanisms, including both TCP
        connections, and Internet mail\n   messages. The precise mechanisms are described
        in the Transport\n   document [CIP-Transport].\n"
      title: '3.2.2 Moving Index Objects: How to Build a Mesh'
    - contents:
      - "3.2.3 Index Object Synthesis\n   From the preceding discussion, it should
        be clear that indexing\n   servers read and write index objects as they pass
        them around the\n   mesh. However, a CIP server need not simply pass the in-bound
        indices\n   through as the out-bound ones. While it is always permissible
        to pass\n   an index object through to other servers, a server may choose
        to\n   aggregate two or more of them, thereby reducing redundancy in the\n
        \  index, at the cost of longer referral chains.\n   A basic premise of index
        passing is that even while collapsing a body\n   of data into an index by
        lossy compression methods, hints useful to\n   routing queries will survive
        in the resulting index. Since the index\n   is not a complete copy of the
        original dataset, it contains less\n   information. Index objects can be passed
        along unchanged, but as more\n   and more information collects in the resulting
        index object,\n   redundancy will creep in again, and it may prove useful
        to apply the\n   compression again, by aggregating two or more index objects
        into one.\n   This kind of aggregation should be performed without compromising
        the\n   ability to correctly route queries while avoiding excessive numbers\n
        \  of missed results. The acceptable likelihood of false negatives must\n
        \  be established on a per-application-domain basis, and is controlled\n   by
        the granularity of the index and the aggregation rules defined for\n   it
        by the particular specification.\n   However, when CIP is used in a multi-protocol
        application domain,\n   such as a Directory Service (with contenders including
        Whois++, LDAP,\n   and Ph), things get significantly trickier. The fundamental
        problem\n   is to avoid forcing a referral chain to pass through part of the
        mesh\n   which does not support the protocol by which that client made the\n
        \  query. If this ever happens, the client loses access to any hits\n   beyond
        that point in the referral chain, since it cannot resolve the\n   referral
        in its native data access protocol. This is a failure of\n   query routing,
        which should be avoided.\n   In addition to multi-protocol considerations,
        server managers may\n   choose not to allow index object aggregation for performance
        reasons.\n   As referral chains lengthen, a client needs to perform more\n
        \  transactions to resolve a query. As the number of transactions\n   increases,
        so do the user-perceived delays, the system loads, and the\n   global bandwidth
        demands. In general, there's a tradeoff between\n   aggressive aggregation
        (which leads to reductions in the indexing\n   overhead) and aggressive referral
        chain optimization. This tradeoff,\n   which is also sensitive to the particular
        application domain, needs\n   to be explored more in actual operational situations.\n
        \  Conceptually, a CIP index server has several index objects on hand at\n
        \  any given time. If it holds data in addition to indexing information,\n
        \  the server has an index object formed from its own data, called the\n   \"local
        index\". It may have one or more indices from remote servers\n   which it
        has collected via the index passing mechanisms. These are\n   called \"in-bound
        indices\".\n      Implementor's Note: It may not be necessary to keep all
        of these\n      structures intact and distinct in the local database. It is
        also\n      not required to keep the out-bound index (or indices) built and\n
        \     ready to distribute at all times. The previous paragraph merely\n      introduces
        a useful model for expressing the aggregation rules.\n      Implementors are
        free to model index objects internally however\n      they see fit.\n   The
        following two rules control how a CIP server formulates its\n   outgoing indices:\n
        \  1. An index server may pass any of the index objects in its local\n      index
        and its in-bound indices through unchanged to polling\n      servers.\n   2.
        If and only if the following three conditions are true, an index\n      server
        can aggregate two or more index objects into a single new\n      index object,
        to be added to the set of out-bound indices.\n      a. Each index object to
        be aggregated covers exactly the same set\n         of protocols, as defined
        by the scheme component of the Base-\n         URI's in each index object.\n
        \     b. The index server supports every one of the data access\n         protocols
        represented by the Base-URI's in the index objects to\n         be aggregated.\n
        \     c. The specification for the index object type specified by the\n         type
        header of the index objects explicitly defines the\n         aggregation operation.\n
        \     The resulting index object must have Base-URI's characteristic of\n
        \     the local server for each protocol it supports. The outgoing\n      objects
        should have the DSI of the local server.\n"
      title: 3.2.3 Index Object Synthesis
    title: 3.2 Architectural Details
  title: 3. Architecture
- contents:
  - "4. Navigating the mesh\n   With the CIP infrastructure in place to manage index
    objects, the\n   only problem remaining is how to successfully use the indexing\n
    \  information to do efficient searches. CIP facilitates query routing,\n   which
    is essentially a client activity. A client connects to one\n   server, which redirects
    the query to servers \"closer to\" the answer.\n   This redirection message is
    called a referral.\n"
  - contents:
    - "4.1 The Referral\n   The concept of a referral and the mechanism for deciding
      when they\n   should be issued is described by CIP. However, the referral itself\n
      \  must be transferred to the client in the native protocol, so its\n   syntax
      is not directly a CIP issue. The mechanism for deciding that a\n   referral
      needs to be made and generating that referral resides in the\n   CIP implementation
      in the server. The mechanism for sending the\n   referral to the client resides
      in the server's native protocol\n   implementation.\n   A referral is made when
      a search against the index objects held by\n   the server shows that there may
      be hits available in one of the\n   datasets represented by those index objects.
      If more that one index\n   object indicates that a referral must be generated
      to a given\n   dataset, the server should generate only one referral to the
      given\n   dataset, as the client may not be able to detect duplicates.\n   Though
      the format of the referral is dependent on the native\n   protocol(s) of the
      CIP server, the baseline contents of the referral\n   are constant across all
      protocols. At the least, a DSI and a URI must\n   be returned.  The DSI is the
      DSI associated with the dataset which\n   caused the hit.  This must be presented
      to the client so that it can\n   avoid referral loops. The Base-URI parameter
      which travels along with\n   index objects is used to provide the other required
      part of a\n   referral.\n   The additional information in the Base-URI may be
      necessary for the\n   server receiving the referred query to correctly handle
      it. A good\n   example of this is an LDAP server, which needs a base X.500\n
      \  distinguished name from which to search. When an LDAP server sends a\n   centroid-format
      index object up to a CIP indexing server, it sends a\n   Base-URI along with
      the name of the X.500 subtree for which the index\n   was made. When a referral
      is made, the Base-URI is passed back to the\n   client so that it can pass it
      to the original LDAP server.\n   As usual, in addition to sending the DSI, a
      DSI-Description header\n   can be optionally sent. Because a client may attempt
      to check with\n   the user before chasing the referral, and because this string
      is the\n   friendliest representation of the DSI that CIP has to offer, it\n
      \  should be included in referrals when available (i.e. when it was sent\n   along
      with the index object).\n"
    title: 4.1 The Referral
  - contents:
    - "4.2 Cross-protocol Mappings\n   Each data access protocol which uses CIP will
      need a clearly defined\n   set of rules to map queries in the native protocol
      to searches\n   against an index object. These rules will vary according to
      the data\n   domain. In principle, this could create a bit of a scaling\n   difficulty;
      for N protocols and M data domains, there would be N x M\n   mappings required.
      In practice, this should not be the case, since\n   some access protocols will
      be wholly unsuited to some data domains.\n   Consider for example, a LDAP server
      trying to make a search in an\n   index object composed from unorganized text
      based pages. What would\n   the results be? How would the client make sense
      of the results?\n   However, as pre-existing protocols are connected to CIP,
      and as new\n   ones are developed to work with CIP, this issue must be examined.
      In\n   the case of Whois++ and the CENTROID index type, there is an\n   extremely
      close mapping, since the two were designed together. When\n   hooking LDAP to
      the CENTROID index type, it will be necessary to map\n   the attribute names
      used in the LDAP system to attribute names which\n   are already being used
      in the CENTROID mesh. It will also be\n   necessary to tokenize the LDAP queries
      under the same rules as the\n   CENTROID indexing policy, so that searches will
      take place correctly.\n   These application- and protocol-specific actions must
      be specified in\n   the index object specification, as discussed in the [CIP-MIME]\n
      \  document.\n"
    title: 4.2 Cross-protocol Mappings
  - contents:
    - "4.3 Moving through the mesh\n   From a client's point of view, CIP simply pushes
      all the \"hard work\"\n   onto its shoulders. After all, it is the client which
      needs to track\n   down the real data.  While this is true, it is very misleading.\n
      \  Because the client has control over the query routing process, the\n   client
      has significant control over the size of the result set, the\n   speed with
      which the query progresses, and the depth of the search.\n   The simplest client
      implementation provides referrals to the user in\n   a raw, ready-to-reuse form,
      without attempting to follow them. For\n   instance, one Whois++ client, which
      interacts with the user via a\n   Web-based form, simply makes referrals into
      HTML hypertext links.\n   Encoded in the link via the HTML forms interface GET
      encoding rules\n   is the data of the referral: the hostname, port, and query.
      If a user\n   chooses to follow the referral link, he executes a new search
      on the\n   new host. A more savvy client might present the referrals to the
      user\n   and ask which should be followed. And, assuming appropriate limits\n
      \  were placed on search time and bandwidth usage, it might be\n   reasonable
      to program a client to follow all referrals automatically.\n   When following
      all referrals, a client must show a bit of\n   intelligence.  Remember that
      the mesh is defined as an interconnected\n   graph of CIP servers. This graph
      may have cycles, which could cause\n   an infinite loop of referrals, wasting
      the servers' time and the\n   client's too. When faced with the job of tacking
      down all referrals,\n   a client must use some form of a mesh traversal algorithm.
      Such an\n   algorithm has been documented for use with Whois++ in RFC-1914.
      The\n   same algorithm can be easily used with this version of CIP. In\n   Whois++
      the equivalent of a DSI is called a handle. With this\n   substitution, the
      Whois++ mesh traversal algorithm works unchanged\n   with CIP.\n   Finally,
      the mesh entry point (i.e. the first server queried) can\n   have an impact
      on the success of the query. To avoid scaling issues,\n   it is not acceptable
      to use a single \"root\" node, and force all\n   clients to connect to it. Instead,
      clients should connect to a\n   reasonably well connected (with respect to the
      CIP mesh, not the\n   Internet infrastructure) local server. If no match can
      be made from\n   this entry point, the client can expand the search by asking
      the\n   original server who polls it. In general, those servers will have a\n
      \  better \"vantage point\" on the mesh, and will turn up answers that the\n
      \  initial search didn't. The mechanism for dynamically determining the\n   mesh
      structure like this exists, but is not documented here for\n   brevity. See
      RFC-1913 for more information on the POLLED-BY and\n   POLLED-FOR commands.\n
      \  It still should be noted that, while these mesh operations are\n   important
      to optimizing the searches that a client should make, the\n   client still speaks
      its native protocol. This information must be\n   communicated to the client
      without causing the client to have to\n   understand CIP.\n"
    title: 4.3 Moving through the mesh
  title: 4. Navigating the mesh
- contents:
  - "5. Security Considerations\n   In this section, we discuss the security considerations
    necessary\n   when making use of this specification. There are at least three\n
    \  levels at which security considerations come into play. Indexing\n   information
    can leak undesirable amounts of proprietary information,\n   unless carefully
    controlled. At a more fundamental level, the CIP\n   protocol itself requires
    external security services to operate in a\n   safe manner. Lastly, CIP itself
    can be used to propogate false\n   information.\n"
  - contents:
    - "5.1 Secure Indexing\n   CIP is designed to index all kinds of data. Some of
      this data might\n   be considered valuable, proprietary, or even highly sensitive
      by the\n   data maintainer. Take, for example, a human resources database.\n
      \  Certain bits of data, in moderation, can be very helpful for a\n   company
      to make public. However, the database in its entirety is a\n   very valuable
      asset, which the company must protect. Much experience\n   has been gained in
      the directory service community over the years as\n   to how best to walk this
      fine line between completely revealing the\n   database and making useful pieces
      of it available. There are also\n   legal considerations regarding what data
      can be collected and shared.\n   Another example where security becomes a problem
      is for a data\n   publisher who'd like to participate in a CIP mesh. The data
      that\n   publisher creates and manages is the prime asset of the company.\n
      \  There is a financial incentive to participate in a CIP mesh, since\n   exporting
      indices of the data will make it more likely that people\n   will search your
      database. (Making profit off of the search activity\n   is left as an exercise
      to the entrepreneur.) Once again, the index\n   must be designed carefully to
      protect the database while providing a\n   useful synopsis of the data.\n   One
      of the basic premises of CIP is that data providers will be\n   willing to provide
      indices of their data to peer indexing servers.\n   Unless they are carefully
      constructed, these indices could constitute\n   a threat to the security of
      the database. Thus, security of the data\n   must be a prime consideration when
      developing a new index object\n   type. The risk of reverse engineering a database
      based only on the\n   index exported from it must be kept to a level consistent
      with the\n   value of the data and the need for fine-grained indexing.\n   Lastly,
      mesh organizers should be aware that the insertion of false\n   data into a
      mesh can be used as part of an attack. Depending on the\n   type of mesh and
      aggregation algorithms, an index can selectivly\n   prune parts of a mesh. Also,
      since CIP is used to discover\n   information, it will be the target for the
      advertisement of false\n   information. CIP does not provide a method for trusting
      the data that\n   it contains.\n"
    - "Acknowledgments\n   Thanks to the many helpful members of the FIND working
      group for\n   discussions leading to this specification.\n   Specific acknowledgment
      is given to Jeff Allen formerly of Bunyip\n   Information Systems. His original
      version of these documents helped\n   enormously in crystallizing the debate
      and consensus. Most of the\n   actual text in this document was originally authored
      by Jeff.  Jeff\n   is no longer involved with the FIND Working Group or with
      editing\n   this document. His authorship is preserved by a specific decision
      of\n   the current editor.\n"
    - "Authors' Addresses\n   Jeff R. Allen\n   246 Hawthorne St.\n   Palo Alto, CA
      94301\n   EMail: jeff.allen@acm.org\n   Michael Mealling\n   Network Solutions,
      Inc.\n   505 Huntmar Park Drive\n   Herndon, VA 22070\n   Phone: (703) 742-0400\n
      \  EMail: michael.mealling@RWhois.net\n"
    - "References\n   [RFC1913]       Weider, C., Fullton, J. and S. Spero, \"Architecture\n
      \                  of the Whois++Index Service\", RFC 1913, February\n                   1996.\n
      \  [RFC1914]       Faltstrom, P., Schoultz, R. and C. Weider, \"How to\n                   Interact
      with a Whois++ Mesh\", RFC 1914, February\n                   1996.\n   [CIP-MIME]
      \     Allen, J. and  M. Mealling, \"MIME Object Definitions\n                   for
      the Common Indexing Protocol (CIP)\", RFC 2652,\n                   August 1999.\n
      \  [CIP-TRANSPORT] Allen, J. and  P. Leach, \"CIP Transport Protocols\",\n                   RFC
      2653, August 1999.\n"
    title: 5.1 Secure Indexing
  title: 5. Security Considerations
- contents:
  - "Appendix A: Glossary\n   application domain:  A problem domain to which CIP is
    applied which\n      has indexing requirements which are not subsumed by any existing\n
    \     problem domain. Separate application domains require separate\n      index
    object specifications, and potentially separate CIP meshes.\n      See index object
    specification.\n   centroid:  An index object type used with Whois++. In CIP versions\n
    \     before version 3, the index was not extensible, and could only\n      take
    the form of a centroid. A centroid is a list of (template\n      name, attribute
    name, token) tuples with duplicate removed.\n   dataset:  A collection of data
    (real or virtual) over which an index\n      is created. When a CIP server aggregates
    two or more indices, the\n      resultant index represents the index from a \"virtual
    dataset\",\n      spanning the previous two datasets.\n   Dataset Identifier:
    \ An identifier chosen from any part of the\n      ISO/CCITT OID space which uniquely
    identifies a given dataset\n      among all datasets indexed by CIP.\n   DSI:
    \ See Dataset Identifier.\n   DSI-description:  A human readable string optionally
    carried along\n      with DSI's to make them more user-friendly. See dataset\n
    \     Identifier.\n   index:  A summary or compressed form of a body of data.
    Examples\n      include a unique list of words, a codified full text analysis,
    a\n      set of keywords, etc.\n   index object:  The embodiment of the indices
    passed by CIP. An index\n      object consists of some control attributes and
    an opaque payload.\n   index object specification:  A document describing an index
    object\n      type for use with the CIP system described in this document. See\n
    \     index object and payload.\n   index pushing:  The act of presenting, unsolicited,
    an index to a\n      peer CIP server.\n   MIME:  see Multipurpose Internet Mail
    Extensions\n   Multipurpose Internet Mail Extensions:  A set of rules for encoding\n
    \     Internet Mail messages that gives them richer structure. CIP uses\n      MIME
    rules to simplify object encoding issues. MIME is specified\n      in RFC-1521
    and RFC-1522.\n   payload:  The application domain specific indexing information
    stored\n      inside an index object. The format of the payload is specified\n
    \     externally to this document, and depends on the type of the\n      containing
    index object.\n   polled server:  A CIP server which receives a request to generate
    and\n      pass an index to a peer server.\n   polling server:  A CIP server which
    generates a request to a peer\n      server for its index.\n   referral chain:
    \ The set of referrals generated by the process of\n      routing a query. See
    query routing.\n   query routing:  Based on reference to indexing information,\n
    \     redirecting and replicating queries through a distributed database\n      system
    towards the servers holding the actual results.\n"
  title: 'Appendix A: Glossary'
- contents:
  - "6.  Full Copyright Statement\n   Copyright (C) The Internet Society (1999).  All
    Rights Reserved.\n   This document and translations of it may be copied and furnished
    to\n   others, and derivative works that comment on or otherwise explain it\n
    \  or assist in its implementation may be prepared, copied, published\n   and
    distributed, in whole or in part, without restriction of any\n   kind, provided
    that the above copyright notice and this paragraph are\n   included on all such
    copies and derivative works.  However, this\n   document itself may not be modified
    in any way, such as by removing\n   the copyright notice or references to the
    Internet Society or other\n   Internet organizations, except as needed for the
    purpose of\n   developing Internet standards in which case the procedures for\n
    \  copyrights defined in the Internet Standards process must be\n   followed,
    or as required to translate it into languages other than\n   English.\n   The
    limited permissions granted above are perpetual and will not be\n   revoked by
    the Internet Society or its successors or assigns.\n   This document and the information
    contained herein is provided on an\n   \"AS IS\" basis and THE INTERNET SOCIETY
    AND THE INTERNET ENGINEERING\n   TASK FORCE DISCLAIMS ALL WARRANTIES, EXPRESS
    OR IMPLIED, INCLUDING\n   BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE
    INFORMATION\n   HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES
    OF\n   MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.\n"
  title: Full Copyright Statement
- contents:
  - "Acknowledgement\n   Funding for the RFC Editor function is currently provided
    by the\n   Internet Society.\n"
  title: Acknowledgement
