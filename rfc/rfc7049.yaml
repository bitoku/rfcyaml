- title: __initial_text__
  contents:
  - '              Concise Binary Object Representation (CBOR)

    '
- title: Abstract
  contents:
  - "Abstract\n   The Concise Binary Object Representation (CBOR) is a data format\n\
    \   whose design goals include the possibility of extremely small code\n   size,\
    \ fairly small message size, and extensibility without the need\n   for version\
    \ negotiation.  These design goals make it different from\n   earlier binary serializations\
    \ such as ASN.1 and MessagePack.\n"
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This is an Internet Standards Track document.\n   This\
    \ document is a product of the Internet Engineering Task Force\n   (IETF).  It\
    \ represents the consensus of the IETF community.  It has\n   received public\
    \ review and has been approved for publication by the\n   Internet Engineering\
    \ Steering Group (IESG).  Further information on\n   Internet Standards is available\
    \ in Section 2 of RFC 5741.\n   Information about the current status of this document,\
    \ any errata,\n   and how to provide feedback on it may be obtained at\n   http://www.rfc-editor.org/info/rfc7049.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (c) 2013 IETF Trust and the persons identified\
    \ as the\n   document authors.  All rights reserved.\n   This document is subject\
    \ to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n\
    \   (http://trustee.ietf.org/license-info) in effect on the date of\n   publication\
    \ of this document.  Please review these documents\n   carefully, as they describe\
    \ your rights and restrictions with respect\n   to this document.  Code Components\
    \ extracted from this document must\n   include Simplified BSD License text as\
    \ described in Section 4.e of\n   the Trust Legal Provisions and are provided\
    \ without warranty as\n   described in the Simplified BSD License.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1.  Introduction  . . . . . . . . . . . . . . . . . . .\
    \ . . . . .   3\n     1.1.  Objectives  . . . . . . . . . . . . . . . . . . .\
    \ . . . .   4\n     1.2.  Terminology . . . . . . . . . . . . . . . . . . . .\
    \ . . .   5\n   2.  Specification of the CBOR Encoding  . . . . . . . . . . .\
    \ . .   6\n     2.1.  Major Types . . . . . . . . . . . . . . . . . . . . . .\
    \ .   7\n     2.2.  Indefinite Lengths for Some Major Types . . . . . . . . .\
    \   9\n       2.2.1.  Indefinite-Length Arrays and Maps . . . . . . . . . .  \
    \ 9\n       2.2.2.  Indefinite-Length Byte Strings and Text Strings . . .  11\n\
    \     2.3.  Floating-Point Numbers and Values with No Content . . . .  12\n  \
    \   2.4.  Optional Tagging of Items . . . . . . . . . . . . . . . .  14\n    \
    \   2.4.1.  Date and Time . . . . . . . . . . . . . . . . . . . .  16\n      \
    \ 2.4.2.  Bignums . . . . . . . . . . . . . . . . . . . . . . .  16\n       2.4.3.\
    \  Decimal Fractions and Bigfloats . . . . . . . . . . .  17\n       2.4.4.  Content\
    \ Hints . . . . . . . . . . . . . . . . . . . .  18\n         2.4.4.1.  Encoded\
    \ CBOR Data Item  . . . . . . . . . . . . .  18\n         2.4.4.2.  Expected Later\
    \ Encoding for CBOR-to-JSON\n                   Converters  . . . . . . . . .\
    \ . . . . . . . . . .  18\n         2.4.4.3.  Encoded Text  . . . . . . . . .\
    \ . . . . . . . . .  19\n       2.4.5.  Self-Describe CBOR  . . . . . . . . .\
    \ . . . . . . . .  19\n   3.  Creating CBOR-Based Protocols . . . . . . . . .\
    \ . . . . . . .  20\n     3.1.  CBOR in Streaming Applications  . . . . . . .\
    \ . . . . . .  20\n     3.2.  Generic Encoders and Decoders . . . . . . . . .\
    \ . . . . .  21\n     3.3.  Syntax Errors . . . . . . . . . . . . . . . . . .\
    \ . . . .  21\n       3.3.1.  Incomplete CBOR Data Items  . . . . . . . . . .\
    \ . . .  22\n       3.3.2.  Malformed Indefinite-Length Items . . . . . . . .\
    \ . .  22\n       3.3.3.  Unknown Additional Information Values . . . . . . .\
    \ .  23\n     3.4.  Other Decoding Errors . . . . . . . . . . . . . . . . . .\
    \  23\n     3.5.  Handling Unknown Simple Values and Tags . . . . . . . . .  24\n\
    \     3.6.  Numbers . . . . . . . . . . . . . . . . . . . . . . . . .  24\n  \
    \   3.7.  Specifying Keys for Maps  . . . . . . . . . . . . . . . .  25\n    \
    \ 3.8.  Undefined Values  . . . . . . . . . . . . . . . . . . . .  26\n     3.9.\
    \  Canonical CBOR  . . . . . . . . . . . . . . . . . . . . .  26\n     3.10. Strict\
    \ Mode . . . . . . . . . . . . . . . . . . . . . . .  28\n   4.  Converting Data\
    \ between CBOR and JSON . . . . . . . . . . . .  29\n     4.1.  Converting from\
    \ CBOR to JSON  . . . . . . . . . . . . . .  29\n     4.2.  Converting from JSON\
    \ to CBOR  . . . . . . . . . . . . . .  30\n   5.  Future Evolution of CBOR  .\
    \ . . . . . . . . . . . . . . . . .  31\n     5.1.  Extension Points  . . . .\
    \ . . . . . . . . . . . . . . . .  32\n     5.2.  Curating the Additional Information\
    \ Space . . . . . . . .  33\n   6.  Diagnostic Notation . . . . . . . . . . .\
    \ . . . . . . . . . .  33\n     6.1.  Encoding Indicators . . . . . . . . . .\
    \ . . . . . . . . .  34\n   7.  IANA Considerations . . . . . . . . . . . . .\
    \ . . . . . . . .  35\n     7.1.  Simple Values Registry  . . . . . . . . . .\
    \ . . . . . . .  35\n     7.2.  Tags Registry . . . . . . . . . . . . . . . .\
    \ . . . . . .  35\n     7.3.  Media Type (\"MIME Type\")  . . . . . . . . . .\
    \ . . . . . .  36\n     7.4.  CoAP Content-Format . . . . . . . . . . . . . .\
    \ . . . . .  37\n     7.5.  The +cbor Structured Syntax Suffix Registration .\
    \ . . . .  37\n   8.  Security Considerations . . . . . . . . . . . . . . . .\
    \ . . .  38\n   9.  Acknowledgements  . . . . . . . . . . . . . . . . . . . .\
    \ . .  38\n   10. References  . . . . . . . . . . . . . . . . . . . . . . . .\
    \ .  39\n     10.1.  Normative References . . . . . . . . . . . . . . . . . .\
    \  39\n     10.2.  Informative References . . . . . . . . . . . . . . . . .  40\n\
    \   Appendix A.  Examples . . . . . . . . . . . . . . . . . . . . . .  41\n  \
    \ Appendix B.  Jump Table . . . . . . . . . . . . . . . . . . . . .  45\n   Appendix\
    \ C.  Pseudocode . . . . . . . . . . . . . . . . . . . . .  48\n   Appendix D.\
    \  Half-Precision . . . . . . . . . . . . . . . . . . .  50\n   Appendix E.  Comparison\
    \ of Other Binary Formats to CBOR's Design\n                Objectives . . . .\
    \ . . . . . . . . . . . . . . . . .  51\n     E.1.  ASN.1 DER, BER, and PER .\
    \ . . . . . . . . . . . . . . . .  52\n     E.2.  MessagePack . . . . . . . .\
    \ . . . . . . . . . . . . . . .  52\n     E.3.  BSON  . . . . . . . . . . . .\
    \ . . . . . . . . . . . . . .  53\n     E.4.  UBJSON  . . . . . . . . . . . .\
    \ . . . . . . . . . . . . .  53\n     E.5.  MSDTP: RFC 713  . . . . . . . . .\
    \ . . . . . . . . . . . .  53\n     E.6.  Conciseness on the Wire . . . . . .\
    \ . . . . . . . . . . .  53\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   There are hundreds of standardized formats for binary representation\n\
    \   of structured data (also known as binary serialization formats).  Of\n   those,\
    \ some are for specific domains of information, while others are\n   generalized\
    \ for arbitrary data.  In the IETF, probably the best-known\n   formats in the\
    \ latter category are ASN.1's BER and DER [ASN.1].\n   The format defined here\
    \ follows some specific design goals that are\n   not well met by current formats.\
    \  The underlying data model is an\n   extended version of the JSON data model\
    \ [RFC4627].  It is important\n   to note that this is not a proposal that the\
    \ grammar in RFC 4627 be\n   extended in general, since doing so would cause a\
    \ significant\n   backwards incompatibility with already deployed JSON documents.\n\
    \   Instead, this document simply defines its own data model that starts\n   from\
    \ JSON.\n   Appendix E lists some existing binary formats and discusses how well\n\
    \   they do or do not fit the design objectives of the Concise Binary\n   Object\
    \ Representation (CBOR).\n"
- title: 1.1.  Objectives
  contents:
  - "1.1.  Objectives\n   The objectives of CBOR, roughly in decreasing order of importance,\n\
    \   are:\n   1.  The representation must be able to unambiguously encode most\n\
    \       common data formats used in Internet standards.\n       *  It must represent\
    \ a reasonable set of basic data types and\n          structures using binary\
    \ encoding.  \"Reasonable\" here is\n          largely influenced by the capabilities\
    \ of JSON, with the major\n          addition of binary byte strings.  The structures\
    \ supported are\n          limited to arrays and trees; loops and lattice-style\
    \ graphs\n          are not supported.\n       *  There is no requirement that\
    \ all data formats be uniquely\n          encoded; that is, it is acceptable that\
    \ the number \"7\" might\n          be encoded in multiple different ways.\n \
    \  2.  The code for an encoder or decoder must be able to be compact in\n    \
    \   order to support systems with very limited memory, processor\n       power,\
    \ and instruction sets.\n       *  An encoder and a decoder need to be implementable\
    \ in a very\n          small amount of code (for example, in class 1 constrained\n\
    \          nodes as defined in [CNN-TERMS]).\n       *  The format should use\
    \ contemporary machine representations of\n          data (for example, not requiring\
    \ binary-to-decimal\n          conversion).\n   3.  Data must be able to be decoded\
    \ without a schema description.\n       *  Similar to JSON, encoded data should\
    \ be self-describing so\n          that a generic decoder can be written.\n  \
    \ 4.  The serialization must be reasonably compact, but data\n       compactness\
    \ is secondary to code compactness for the encoder and\n       decoder.\n    \
    \   *  \"Reasonable\" here is bounded by JSON as an upper bound in\n         \
    \ size, and by implementation complexity maintaining a lower\n          bound.\
    \  Using either general compression schemes or extensive\n          bit-fiddling\
    \ violates the complexity goals.\n   5.  The format must be applicable to both\
    \ constrained nodes and high-\n       volume applications.\n       *  This means\
    \ it must be reasonably frugal in CPU usage for both\n          encoding and decoding.\
    \  This is relevant both for constrained\n          nodes and for potential usage\
    \ in applications with a very high\n          volume of data.\n   6.  The format\
    \ must support all JSON data types for conversion to and\n       from JSON.\n\
    \       *  It must support a reasonable level of conversion as long as\n     \
    \     the data represented is within the capabilities of JSON.  It\n         \
    \ must be possible to define a unidirectional mapping towards\n          JSON\
    \ for all types of data.\n   7.  The format must be extensible, and the extended\
    \ data must be\n       decodable by earlier decoders.\n       *  The format is\
    \ designed for decades of use.\n       *  The format must support a form of extensibility\
    \ that allows\n          fallback so that a decoder that does not understand an\n\
    \          extension can still decode the message.\n       *  The format must\
    \ be able to be extended in the future by later\n          IETF standards.\n"
- title: 1.2.  Terminology
  contents:
  - "1.2.  Terminology\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"\
    SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\"\
    , and \"OPTIONAL\" in this\n   document are to be interpreted as described in\
    \ RFC 2119, BCP 14\n   [RFC2119] and indicate requirement levels for compliant\
    \ CBOR\n   implementations.\n   The term \"byte\" is used in its now-customary\
    \ sense as a synonym for\n   \"octet\".  All multi-byte values are encoded in\
    \ network byte order\n   (that is, most significant byte first, also known as\
    \ \"big-endian\").\n   This specification makes use of the following terminology:\n\
    \   Data item:  A single piece of CBOR data.  The structure of a data\n      item\
    \ may contain zero, one, or more nested data items.  The term\n      is used both\
    \ for the data item in representation format and for\n      the abstract idea\
    \ that can be derived from that by a decoder.\n   Decoder:  A process that decodes\
    \ a CBOR data item and makes it\n      available to an application.  Formally\
    \ speaking, a decoder\n      contains a parser to break up the input using the\
    \ syntax rules of\n      CBOR, as well as a semantic processor to prepare the\
    \ data in a\n      form suitable to the application.\n   Encoder:  A process that\
    \ generates the representation format of a\n      CBOR data item from application\
    \ information.\n   Data Stream:  A sequence of zero or more data items, not further\n\
    \      assembled into a larger containing data item.  The independent\n      data\
    \ items that make up a data stream are sometimes also referred\n      to as \"\
    top-level data items\".\n   Well-formed:  A data item that follows the syntactic\
    \ structure of\n      CBOR.  A well-formed data item uses the initial bytes and\
    \ the byte\n      strings and/or data items that are implied by their values as\n\
    \      defined in CBOR and is not followed by extraneous data.\n   Valid:  A data\
    \ item that is well-formed and also follows the semantic\n      restrictions that\
    \ apply to CBOR data items.\n   Stream decoder:  A process that decodes a data\
    \ stream and makes each\n      of the data items in the sequence available to\
    \ an application as\n      they are received.\n   Where bit arithmetic or data\
    \ types are explained, this document uses\n   the notation familiar from the programming\
    \ language C, except that\n   \"**\" denotes exponentiation.  Similar to the \"\
    0x\" notation for\n   hexadecimal numbers, numbers in binary notation are prefixed\
    \ with\n   \"0b\".  Underscores can be added to such a number solely for\n   readability,\
    \ so 0b00100001 (0x21) might be written 0b001_00001 to\n   emphasize the desired\
    \ interpretation of the bits in the byte; in this\n   case, it is split into three\
    \ bits and five bits.\n"
- title: 2.  Specification of the CBOR Encoding
  contents:
  - "2.  Specification of the CBOR Encoding\n   A CBOR-encoded data item is structured\
    \ and encoded as described in\n   this section.  The encoding is summarized in\
    \ Table 5.\n   The initial byte of each data item contains both information about\n\
    \   the major type (the high-order 3 bits, described in Section 2.1) and\n   additional\
    \ information (the low-order 5 bits).  When the value of the\n   additional information\
    \ is less than 24, it is directly used as a\n   small unsigned integer.  When\
    \ it is 24 to 27, the additional bytes\n   for a variable-length integer immediately\
    \ follow; the values 24 to 27\n   of the additional information specify that its\
    \ length is a 1-, 2-,\n   4-, or 8-byte unsigned integer, respectively.  Additional\
    \ information\n   value 31 is used for indefinite-length items, described in\n\
    \   Section 2.2.  Additional information values 28 to 30 are reserved for\n  \
    \ future expansion.\n   In all additional information values, the resulting integer\
    \ is\n   interpreted depending on the major type.  It may represent the actual\n\
    \   data: for example, in integer types, the resulting integer is used\n   for\
    \ the value itself.  It may instead supply length information: for\n   example,\
    \ in byte strings it gives the length of the byte string data\n   that follows.\n\
    \   A CBOR decoder implementation can be based on a jump table with all\n   256\
    \ defined values for the initial byte (Table 5).  A decoder in a\n   constrained\
    \ implementation can instead use the structure of the\n   initial byte and following\
    \ bytes for more compact code (see\n   Appendix C for a rough impression of how\
    \ this could look).\n"
- title: 2.1.  Major Types
  contents:
  - "2.1.  Major Types\n   The following lists the major types and the additional\
    \ information\n   and other bytes associated with the type.\n   Major type 0:\
    \  an unsigned integer.  The 5-bit additional information\n      is either the\
    \ integer itself (for additional information values 0\n      through 23) or the\
    \ length of additional data.  Additional\n      information 24 means the value\
    \ is represented in an additional\n      uint8_t, 25 means a uint16_t, 26 means\
    \ a uint32_t, and 27 means a\n      uint64_t.  For example, the integer 10 is\
    \ denoted as the one byte\n      0b000_01010 (major type 0, additional information\
    \ 10).  The\n      integer 500 would be 0b000_11001 (major type 0, additional\n\
    \      information 25) followed by the two bytes 0x01f4, which is 500 in\n   \
    \   decimal.\n   Major type 1:  a negative integer.  The encoding follows the\
    \ rules\n      for unsigned integers (major type 0), except that the value is\n\
    \      then -1 minus the encoded unsigned integer.  For example, the\n      integer\
    \ -500 would be 0b001_11001 (major type 1, additional\n      information 25) followed\
    \ by the two bytes 0x01f3, which is 499 in\n      decimal.\n   Major type 2: \
    \ a byte string.  The string's length in bytes is\n      represented following\
    \ the rules for positive integers (major type\n      0).  For example, a byte\
    \ string whose length is 5 would have an\n      initial byte of 0b010_00101 (major\
    \ type 2, additional information\n      5 for the length), followed by 5 bytes\
    \ of binary content.  A byte\n      string whose length is 500 would have 3 initial\
    \ bytes of\n      0b010_11001 (major type 2, additional information 25 to indicate\
    \ a\n      two-byte length) followed by the two bytes 0x01f4 for a length of\n\
    \      500, followed by 500 bytes of binary content.\n   Major type 3:  a text\
    \ string, specifically a string of Unicode\n      characters that is encoded as\
    \ UTF-8 [RFC3629].  The format of this\n      type is identical to that of byte\
    \ strings (major type 2), that is,\n      as with major type 2, the length gives\
    \ the number of bytes.  This\n      type is provided for systems that need to\
    \ interpret or display\n      human-readable text, and allows the differentiation\
    \ between\n      unstructured bytes and text that has a specified repertoire and\n\
    \      encoding.  In contrast to formats such as JSON, the Unicode\n      characters\
    \ in this type are never escaped.  Thus, a newline\n      character (U+000A) is\
    \ always represented in a string as the byte\n      0x0a, and never as the bytes\
    \ 0x5c6e (the characters \"\\\" and \"n\")\n      or as 0x5c7530303061 (the characters\
    \ \"\\\", \"u\", \"0\", \"0\", \"0\", and\n      \"a\").\n   Major type 4:  an\
    \ array of data items.  Arrays are also called lists,\n      sequences, or tuples.\
    \  The array's length follows the rules for\n      byte strings (major type 2),\
    \ except that the length denotes the\n      number of data items, not the length\
    \ in bytes that the array takes\n      up.  Items in an array do not need to all\
    \ be of the same type.\n      For example, an array that contains 10 items of\
    \ any type would\n      have an initial byte of 0b100_01010 (major type of 4,\
    \ additional\n      information of 10 for the length) followed by the 10 remaining\n\
    \      items.\n   Major type 5:  a map of pairs of data items.  Maps are also\
    \ called\n      tables, dictionaries, hashes, or objects (in JSON).  A map is\n\
    \      comprised of pairs of data items, each pair consisting of a key\n     \
    \ that is immediately followed by a value.  The map's length follows\n      the\
    \ rules for byte strings (major type 2), except that the length\n      denotes\
    \ the number of pairs, not the length in bytes that the map\n      takes up. \
    \ For example, a map that contains 9 pairs would have an\n      initial byte of\
    \ 0b101_01001 (major type of 5, additional\n      information of 9 for the number\
    \ of pairs) followed by the 18\n      remaining items.  The first item is the\
    \ first key, the second item\n      is the first value, the third item is the\
    \ second key, and so on.\n      A map that has duplicate keys may be well-formed,\
    \ but it is not\n      valid, and thus it causes indeterminate decoding; see also\n\
    \      Section 3.7.\n   Major type 6:  optional semantic tagging of other major\
    \ types.  See\n      Section 2.4.\n   Major type 7:  floating-point numbers and\
    \ simple data types that need\n      no content, as well as the \"break\" stop\
    \ code.  See Section 2.3.\n   These eight major types lead to a simple table showing\
    \ which of the\n   256 possible values for the initial byte of a data item are\
    \ used\n   (Table 5).\n   In major types 6 and 7, many of the possible values\
    \ are reserved for\n   future specification.  See Section 7 for more information\
    \ on these\n   values.\n"
- title: 2.2.  Indefinite Lengths for Some Major Types
  contents:
  - "2.2.  Indefinite Lengths for Some Major Types\n   Four CBOR items (arrays, maps,\
    \ byte strings, and text strings) can be\n   encoded with an indefinite length\
    \ using additional information value\n   31.  This is useful if the encoding of\
    \ the item needs to begin before\n   the number of items inside the array or map,\
    \ or the total length of\n   the string, is known.  (The application of this is\
    \ often referred to\n   as \"streaming\" within a data item.)\n   Indefinite-length\
    \ arrays and maps are dealt with differently than\n   indefinite-length byte strings\
    \ and text strings.\n"
- title: 2.2.1.  Indefinite-Length Arrays and Maps
  contents:
  - "2.2.1.  Indefinite-Length Arrays and Maps\n   Indefinite-length arrays and maps\
    \ are simply opened without\n   indicating the number of data items that will\
    \ be included in the\n   array or map, using the additional information value\
    \ of 31.  The\n   initial major type and additional information byte is followed\
    \ by the\n   elements of the array or map, just as they would be in other arrays\n\
    \   or maps.  The end of the array or map is indicated by encoding a\n   \"break\"\
    \ stop code in a place where the next data item would normally\n   have been included.\
    \  The \"break\" is encoded with major type 7 and\n   additional information value\
    \ 31 (0b111_11111) but is not itself a\n   data item: it is just a syntactic feature\
    \ to close the array or map.\n   That is, the \"break\" stop code comes after\
    \ the last item in the array\n   or map, and it cannot occur anywhere else in\
    \ place of a data item.\n   In this way, indefinite-length arrays and maps look\
    \ identical to\n   other arrays and maps except for beginning with the additional\n\
    \   information value 31 and ending with the \"break\" stop code.\n   Arrays and\
    \ maps with indefinite lengths allow any number of items\n   (for arrays) and\
    \ key/value pairs (for maps) to be given before the\n   \"break\" stop code. \
    \ There is no restriction against nesting\n   indefinite-length array or map items.\
    \  A \"break\" only terminates a\n   single item, so nested indefinite-length\
    \ items need exactly as many\n   \"break\" stop codes as there are type bytes\
    \ starting an indefinite-\n   length item.\n   For example, assume an encoder\
    \ wants to represent the abstract array\n   [1, [2, 3], [4, 5]].  The definite-length\
    \ encoding would be\n   0x8301820203820405:\n   83        -- Array of length 3\n\
    \      01     -- 1\n      82     -- Array of length 2\n         02  -- 2\n   \
    \      03  -- 3\n      82     -- Array of length 2\n         04  -- 4\n      \
    \   05  -- 5\n   Indefinite-length encoding could be applied independently to\
    \ each of\n   the three arrays encoded in this data item, as required, leading\
    \ to\n   representations such as:\n   0x9f018202039f0405ffff\n   9F        --\
    \ Start indefinite-length array\n      01     -- 1\n      82     -- Array of length\
    \ 2\n         02  -- 2\n         03  -- 3\n      9F     -- Start indefinite-length\
    \ array\n         04  -- 4\n         05  -- 5\n         FF  -- \"break\" (inner\
    \ array)\n      FF     -- \"break\" (outer array)\n   0x9f01820203820405ff\n \
    \  9F        -- Start indefinite-length array\n      01     -- 1\n      82   \
    \  -- Array of length 2\n         02  -- 2\n         03  -- 3\n      82     --\
    \ Array of length 2\n         04  -- 4\n         05  -- 5\n      FF     -- \"\
    break\"\n   0x83018202039f0405ff\n   83        -- Array of length 3\n      01\
    \     -- 1\n      82     -- Array of length 2\n         02  -- 2\n         03\
    \  -- 3\n      9F     -- Start indefinite-length array\n         04  -- 4\n  \
    \       05  -- 5\n         FF  -- \"break\"\n   0x83019f0203ff820405\n   83  \
    \      -- Array of length 3\n      01     -- 1\n      9F     -- Start indefinite-length\
    \ array\n         02  -- 2\n         03  -- 3\n         FF  -- \"break\"\n   \
    \   82     -- Array of length 2\n         04  -- 4\n         05  -- 5\n   An example\
    \ of an indefinite-length map (that happens to have two\n   key/value pairs) might\
    \ be:\n   0xbf6346756ef563416d7421ff\n   BF           -- Start indefinite-length\
    \ map\n      63        -- First key, UTF-8 string length 3\n         46756e --\
    \   \"Fun\"\n      F5        -- First value, true\n      63        -- Second key,\
    \ UTF-8 string length 3\n         416d74 --   \"Amt\"\n      21        -- -2\n\
    \      FF        -- \"break\"\n"
- title: 2.2.2.  Indefinite-Length Byte Strings and Text Strings
  contents:
  - "2.2.2.  Indefinite-Length Byte Strings and Text Strings\n   Indefinite-length\
    \ byte strings and text strings are actually a\n   concatenation of zero or more\
    \ definite-length byte or text strings\n   (\"chunks\") that are together treated\
    \ as one contiguous string.\n   Indefinite-length strings are opened with the\
    \ major type and\n   additional information value of 31, but what follows are\
    \ a series of\n   byte or text strings that have definite lengths (the chunks).\
    \  The\n   end of the series of chunks is indicated by encoding the \"break\"\
    \ stop\n   code (0b111_11111) in a place where the next chunk in the series\n\
    \   would occur.  The contents of the chunks are concatenated together,\n   and\
    \ the overall length of the indefinite-length string will be the\n   sum of the\
    \ lengths of all of the chunks.  In summary, an indefinite-\n   length string\
    \ is encoded similarly to how an indefinite-length array\n   of its chunks would\
    \ be encoded, except that the major type of the\n   indefinite-length string is\
    \ that of a (text or byte) string and\n   matches the major types of its chunks.\n\
    \   For indefinite-length byte strings, every data item (chunk) between\n   the\
    \ indefinite-length indicator and the \"break\" MUST be a definite-\n   length\
    \ byte string item; if the parser sees any item type other than\n   a byte string\
    \ before it sees the \"break\", it is an error.\n   For example, assume the sequence:\n\
    \   0b010_11111 0b010_00100 0xaabbccdd 0b010_00011 0xeeff99 0b111_11111\n   5F\
    \              -- Start indefinite-length byte string\n      44           -- Byte\
    \ string of length 4\n         aabbccdd  -- Bytes content\n      43          \
    \ -- Byte string of length 3\n         eeff99    -- Bytes content\n      FF  \
    \         -- \"break\"\n   After decoding, this results in a single byte string\
    \ with seven\n   bytes: 0xaabbccddeeff99.\n   Text strings with indefinite lengths\
    \ act the same as byte strings\n   with indefinite lengths, except that all their\
    \ chunks MUST be\n   definite-length text strings.  Note that this implies that\
    \ the bytes\n   of a single UTF-8 character cannot be spread between chunks: a\
    \ new\n   chunk can only be started at a character boundary.\n"
- title: 2.3.  Floating-Point Numbers and Values with No Content
  contents:
  - "2.3.  Floating-Point Numbers and Values with No Content\n   Major type 7 is for\
    \ two types of data: floating-point numbers and\n   \"simple values\" that do\
    \ not need any content.  Each value of the\n   5-bit additional information in\
    \ the initial byte has its own separate\n   meaning, as defined in Table 1.  Like\
    \ the major types for integers,\n   items of this major type do not carry content\
    \ data; all the\n   information is in the initial bytes.\n    +-------------+--------------------------------------------------+\n\
    \    | 5-Bit Value | Semantics                                        |\n    +-------------+--------------------------------------------------+\n\
    \    | 0..23       | Simple value (value 0..23)                       |\n    |\
    \             |                                                  |\n    | 24 \
    \         | Simple value (value 32..255 in following byte)   |\n    |        \
    \     |                                                  |\n    | 25         \
    \ | IEEE 754 Half-Precision Float (16 bits follow)   |\n    |             |  \
    \                                                |\n    | 26          | IEEE 754\
    \ Single-Precision Float (32 bits follow) |\n    |             |             \
    \                                     |\n    | 27          | IEEE 754 Double-Precision\
    \ Float (64 bits follow) |\n    |             |                              \
    \                    |\n    | 28-30       | (Unassigned)                     \
    \                |\n    |             |                                      \
    \            |\n    | 31          | \"break\" stop code for indefinite-length\
    \ items    |\n    +-------------+--------------------------------------------------+\n\
    \        Table 1: Values for Additional Information in Major Type 7\n   As with\
    \ all other major types, the 5-bit value 24 signifies a single-\n   byte extension:\
    \ it is followed by an additional byte to represent the\n   simple value.  (To\
    \ minimize confusion, only the values 32 to 255 are\n   used.)  This maintains\
    \ the structure of the initial bytes: as for the\n   other major types, the length\
    \ of these always depends on the\n   additional information in the first byte.\
    \  Table 2 lists the values\n   assigned and available for simple types.\n   \
    \                    +---------+-----------------+\n                       | Value\
    \   | Semantics       |\n                       +---------+-----------------+\n\
    \                       | 0..19   | (Unassigned)    |\n                      \
    \ |         |                 |\n                       | 20      | False    \
    \       |\n                       |         |                 |\n            \
    \           | 21      | True            |\n                       |         |\
    \                 |\n                       | 22      | Null            |\n  \
    \                     |         |                 |\n                       |\
    \ 23      | Undefined value |\n                       |         |            \
    \     |\n                       | 24..31  | (Reserved)      |\n              \
    \         |         |                 |\n                       | 32..255 | (Unassigned)\
    \    |\n                       +---------+-----------------+\n               \
    \           Table 2: Simple Values\n   The 5-bit values of 25, 26, and 27 are\
    \ for 16-bit, 32-bit, and 64-bit\n   IEEE 754 binary floating-point values.  These\
    \ floating-point values\n   are encoded in the additional bytes of the appropriate\
    \ size.  (See\n   Appendix D for some information about 16-bit floating point.)\n"
- title: 2.4.  Optional Tagging of Items
  contents:
  - "2.4.  Optional Tagging of Items\n   In CBOR, a data item can optionally be preceded\
    \ by a tag to give it\n   additional semantics while retaining its structure.\
    \  The tag is major\n   type 6, and represents an integer number as indicated\
    \ by the tag's\n   integer value; the (sole) data item is carried as content data.\
    \  If a\n   tag requires structured data, this structure is encoded into the\n\
    \   nested data item.  The definition of a tag usually restricts what\n   kinds\
    \ of nested data item or items can be carried by a tag.\n   The initial bytes\
    \ of the tag follow the rules for positive integers\n   (major type 0).  The tag\
    \ is followed by a single data item of any\n   type.  For example, assume that\
    \ a byte string of length 12 is marked\n   with a tag to indicate it is a positive\
    \ bignum (Section 2.4.2).  This\n   would be marked as 0b110_00010 (major type\
    \ 6, additional information\n   2 for the tag) followed by 0b010_01100 (major\
    \ type 2, additional\n   information of 12 for the length) followed by the 12\
    \ bytes of the\n   bignum.\n   Decoders do not need to understand tags, and thus\
    \ tags may be of\n   little value in applications where the implementation creating\
    \ a\n   particular CBOR data item and the implementation decoding that stream\n\
    \   know the semantic meaning of each item in the data flow.  Their\n   primary\
    \ purpose in this specification is to define common data types\n   such as dates.\
    \  A secondary purpose is to allow optional tagging when\n   the decoder is a\
    \ generic CBOR decoder that might be able to benefit\n   from hints about the\
    \ content of items.  Understanding the semantic\n   tags is optional for a decoder;\
    \ it can just jump over the initial\n   bytes of the tag and interpret the tagged\
    \ data item itself.\n   A tag always applies to the item that is directly followed\
    \ by it.\n   Thus, if tag A is followed by tag B, which is followed by data item\n\
    \   C, tag A applies to the result of applying tag B on data item C.\n   That\
    \ is, a tagged item is a data item consisting of a tag and a\n   value.  The content\
    \ of the tagged item is the data item (the value)\n   that is being tagged.\n\
    \   IANA maintains a registry of tag values as described in Section 7.2.\n   Table\
    \ 3 provides a list of initial values, with definitions in the\n   rest of this\
    \ section.\n   +--------------+------------------+---------------------------------+\n\
    \   | Tag          | Data Item        | Semantics                       |\n  \
    \ +--------------+------------------+---------------------------------+\n   |\
    \ 0            | UTF-8 string     | Standard date/time string; see  |\n   |  \
    \            |                  | Section 2.4.1                   |\n   |    \
    \          |                  |                                 |\n   | 1    \
    \        | multiple         | Epoch-based date/time; see      |\n   |        \
    \      |                  | Section 2.4.1                   |\n   |          \
    \    |                  |                                 |\n   | 2          \
    \  | byte string      | Positive bignum; see Section    |\n   |              |\
    \                  | 2.4.2                           |\n   |              |  \
    \                |                                 |\n   | 3            | byte\
    \ string      | Negative bignum; see Section    |\n   |              |       \
    \           | 2.4.2                           |\n   |              |         \
    \         |                                 |\n   | 4            | array     \
    \       | Decimal fraction; see Section   |\n   |              |             \
    \     | 2.4.3                           |\n   |              |               \
    \   |                                 |\n   | 5            | array           \
    \ | Bigfloat; see Section 2.4.3     |\n   |              |                  |\
    \                                 |\n   | 6..20        | (Unassigned)     | (Unassigned)\
    \                    |\n   |              |                  |               \
    \                  |\n   | 21           | multiple         | Expected conversion\
    \ to          |\n   |              |                  | base64url encoding; see\
    \         |\n   |              |                  | Section 2.4.4.2          \
    \       |\n   |              |                  |                            \
    \     |\n   | 22           | multiple         | Expected conversion to base64\
    \   |\n   |              |                  | encoding; see Section 2.4.4.2  \
    \ |\n   |              |                  |                                 |\n\
    \   | 23           | multiple         | Expected conversion to base16   |\n  \
    \ |              |                  | encoding; see Section 2.4.4.2   |\n   |\
    \              |                  |                                 |\n   | 24\
    \           | byte string      | Encoded CBOR data item; see     |\n   |     \
    \         |                  | Section 2.4.4.1                 |\n   |       \
    \       |                  |                                 |\n   | 25..31  \
    \     | (Unassigned)     | (Unassigned)                    |\n   |           \
    \   |                  |                                 |\n   | 32          \
    \ | UTF-8 string     | URI; see Section 2.4.4.3        |\n   |              |\
    \                  |                                 |\n   | 33           | UTF-8\
    \ string     | base64url; see Section 2.4.4.3  |\n   |              |        \
    \          |                                 |\n   | 34           | UTF-8 string\
    \     | base64; see Section 2.4.4.3     |\n   |              |               \
    \   |                                 |\n   | 35           | UTF-8 string    \
    \ | Regular expression; see         |\n   |              |                  |\
    \ Section 2.4.4.3                 |\n   |              |                  |  \
    \                               |\n   | 36           | UTF-8 string     | MIME\
    \ message; see Section       |\n   |              |                  | 2.4.4.3\
    \                         |\n   |              |                  |          \
    \                       |\n   | 37..55798    | (Unassigned)     | (Unassigned)\
    \                    |\n   |              |                  |               \
    \                  |\n   | 55799        | multiple         | Self-describe CBOR;\
    \ see         |\n   |              |                  | Section 2.4.5        \
    \           |\n   |              |                  |                        \
    \         |\n   | 55800+       | (Unassigned)     | (Unassigned)             \
    \       |\n   +--------------+------------------+---------------------------------+\n\
    \                         Table 3: Values for Tags\n"
- title: 2.4.1.  Date and Time
  contents:
  - "2.4.1.  Date and Time\n   Tag value 0 is for date/time strings that follow the\
    \ standard format\n   described in [RFC3339], as refined by Section 3.3 of [RFC4287].\n\
    \   Tag value 1 is for numerical representation of seconds relative to\n   1970-01-01T00:00Z\
    \ in UTC time.  (For the non-negative values that the\n   Portable Operating System\
    \ Interface (POSIX) defines, the number of\n   seconds is counted in the same\
    \ way as for POSIX \"seconds since the\n   epoch\" [TIME_T].)  The tagged item\
    \ can be a positive or negative\n   integer (major types 0 and 1), or a floating-point\
    \ number (major type\n   7 with additional information 25, 26, or 27).  Note that\
    \ the number\n   can be negative (time before 1970-01-01T00:00Z) and, if a floating-\n\
    \   point number, indicate fractional seconds.\n"
- title: 2.4.2.  Bignums
  contents:
  - "2.4.2.  Bignums\n   Bignums are integers that do not fit into the basic integer\n\
    \   representations provided by major types 0 and 1.  They are encoded as\n  \
    \ a byte string data item, which is interpreted as an unsigned integer\n   n in\
    \ network byte order.  For tag value 2, the value of the bignum is\n   n.  For\
    \ tag value 3, the value of the bignum is -1 - n.  Decoders\n   that understand\
    \ these tags MUST be able to decode bignums that have\n   leading zeroes.\n  \
    \ For example, the number 18446744073709551616 (2**64) is represented\n   as 0b110_00010\
    \ (major type 6, tag 2), followed by 0b010_01001 (major\n   type 2, length 9),\
    \ followed by 0x010000000000000000 (one byte 0x01\n   and eight bytes 0x00). \
    \ In hexadecimal:\n   C2                        -- Tag 2\n      29           \
    \          -- Byte string of length 9\n         010000000000000000  -- Bytes content\n"
- title: 2.4.3.  Decimal Fractions and Bigfloats
  contents:
  - "2.4.3.  Decimal Fractions and Bigfloats\n   Decimal fractions combine an integer\
    \ mantissa with a base-10 scaling\n   factor.  They are most useful if an application\
    \ needs the exact\n   representation of a decimal fraction such as 1.1 because\
    \ there is no\n   exact representation for many decimal fractions in binary floating\n\
    \   point.\n   Bigfloats combine an integer mantissa with a base-2 scaling factor.\n\
    \   They are binary floating-point values that can exceed the range or\n   the\
    \ precision of the three IEEE 754 formats supported by CBOR\n   (Section 2.3).\
    \  Bigfloats may also be used by constrained\n   applications that need some basic\
    \ binary floating-point capability\n   without the need for supporting IEEE 754.\n\
    \   A decimal fraction or a bigfloat is represented as a tagged array\n   that\
    \ contains exactly two integer numbers: an exponent e and a\n   mantissa m.  Decimal\
    \ fractions (tag 4) use base-10 exponents; the\n   value of a decimal fraction\
    \ data item is m*(10**e).  Bigfloats (tag\n   5) use base-2 exponents; the value\
    \ of a bigfloat data item is\n   m*(2**e).  The exponent e MUST be represented\
    \ in an integer of major\n   type 0 or 1, while the mantissa also can be a bignum\
    \ (Section 2.4.2).\n   An example of a decimal fraction is that the number 273.15\
    \ could be\n   represented as 0b110_00100 (major type of 6 for the tag, additional\n\
    \   information of 4 for the type of tag), followed by 0b100_00010 (major\n  \
    \ type of 4 for the array, additional information of 2 for the length\n   of the\
    \ array), followed by 0b001_00001 (major type of 1 for the first\n   integer,\
    \ additional information of 1 for the value of -2), followed\n   by 0b000_11001\
    \ (major type of 0 for the second integer, additional\n   information of 25 for\
    \ a two-byte value), followed by\n   0b0110101010110011 (27315 in two bytes).\
    \  In hexadecimal:\n   C4             -- Tag 4\n      82          -- Array of\
    \ length 2\n         21       -- -2\n         19 6ab3  -- 27315\n   An example\
    \ of a bigfloat is that the number 1.5 could be represented\n   as 0b110_00101\
    \ (major type of 6 for the tag, additional information\n   of 5 for the type of\
    \ tag), followed by 0b100_00010 (major type of 4\n   for the array, additional\
    \ information of 2 for the length of the\n   array), followed by 0b001_00000 (major\
    \ type of 1 for the first\n   integer, additional information of 0 for the value\
    \ of -1), followed\n   by 0b000_00011 (major type of 0 for the second integer,\
    \ additional\n   information of 3 for the value of 3).  In hexadecimal:\n   C5\
    \             -- Tag 5\n      82          -- Array of length 2\n         20  \
    \     -- -1\n         03       -- 3\n   Decimal fractions and bigfloats provide\
    \ no representation of\n   Infinity, -Infinity, or NaN; if these are needed in\
    \ place of a\n   decimal fraction or bigfloat, the IEEE 754 half-precision\n \
    \  representations from Section 2.3 can be used.  For constrained\n   applications,\
    \ where there is a choice between representing a specific\n   number as an integer\
    \ and as a decimal fraction or bigfloat (such as\n   when the exponent is small\
    \ and non-negative), there is a quality-of-\n   implementation expectation that\
    \ the integer representation is used\n   directly.\n"
- title: 2.4.4.  Content Hints
  contents:
  - "2.4.4.  Content Hints\n   The tags in this section are for content hints that\
    \ might be used by\n   generic CBOR processors.\n"
- title: 2.4.4.1.  Encoded CBOR Data Item
  contents:
  - "2.4.4.1.  Encoded CBOR Data Item\n   Sometimes it is beneficial to carry an embedded\
    \ CBOR data item that\n   is not meant to be decoded immediately at the time the\
    \ enclosing data\n   item is being parsed.  Tag 24 (CBOR data item) can be used\
    \ to tag the\n   embedded byte string as a data item encoded in CBOR format.\n"
- title: 2.4.4.2.  Expected Later Encoding for CBOR-to-JSON Converters
  contents:
  - "2.4.4.2.  Expected Later Encoding for CBOR-to-JSON Converters\n   Tags 21 to\
    \ 23 indicate that a byte string might require a specific\n   encoding when interoperating\
    \ with a text-based representation.  These\n   tags are useful when an encoder\
    \ knows that the byte string data it is\n   writing is likely to be later converted\
    \ to a particular JSON-based\n   usage.  That usage specifies that some strings\
    \ are encoded as base64,\n   base64url, and so on.  The encoder uses byte strings\
    \ instead of doing\n   the encoding itself to reduce the message size, to reduce\
    \ the code\n   size of the encoder, or both.  The encoder does not know whether\
    \ or\n   not the converter will be generic, and therefore wants to say what it\n\
    \   believes is the proper way to convert binary strings to JSON.\n   The data\
    \ item tagged can be a byte string or any other data item.  In\n   the latter\
    \ case, the tag applies to all of the byte string data items\n   contained in\
    \ the data item, except for those contained in a nested\n   data item tagged with\
    \ an expected conversion.\n   These three tag types suggest conversions to three\
    \ of the base data\n   encodings defined in [RFC4648].  For base64url encoding,\
    \ padding is\n   not used (see Section 3.2 of RFC 4648); that is, all trailing\
    \ equals\n   signs (\"=\") are removed from the base64url-encoded string.  Later\n\
    \   tags might be defined for other data encodings of RFC 4648 or for\n   other\
    \ ways to encode binary data in strings.\n"
- title: 2.4.4.3.  Encoded Text
  contents:
  - "2.4.4.3.  Encoded Text\n   Some text strings hold data that have formats widely\
    \ used on the\n   Internet, and sometimes those formats can be validated and presented\n\
    \   to the application in appropriate form by the decoder.  There are\n   tags\
    \ for some of these formats.\n   o  Tag 32 is for URIs, as defined in [RFC3986];\n\
    \   o  Tags 33 and 34 are for base64url- and base64-encoded text strings,\n  \
    \    as defined in [RFC4648];\n   o  Tag 35 is for regular expressions in Perl\
    \ Compatible Regular\n      Expressions (PCRE) / JavaScript syntax [ECMA262].\n\
    \   o  Tag 36 is for MIME messages (including all headers), as defined in\n  \
    \    [RFC2045];\n   Note that tags 33 and 34 differ from 21 and 22 in that the\
    \ data is\n   transported in base-encoded form for the former and in raw byte\n\
    \   string form for the latter.\n"
- title: 2.4.5.  Self-Describe CBOR
  contents:
  - "2.4.5.  Self-Describe CBOR\n   In many applications, it will be clear from the\
    \ context that CBOR is\n   being employed for encoding a data item.  For instance,\
    \ a specific\n   protocol might specify the use of CBOR, or a media type is indicated\n\
    \   that specifies its use.  However, there may be applications where\n   such\
    \ context information is not available, such as when CBOR data is\n   stored in\
    \ a file and disambiguating metadata is not in use.  Here, it\n   may help to\
    \ have some distinguishing characteristics for the data\n   itself.\n   Tag 55799\
    \ is defined for this purpose.  It does not impart any\n   special semantics on\
    \ the data item that follows; that is, the\n   semantics of a data item tagged\
    \ with tag 55799 is exactly identical\n   to the semantics of the data item itself.\n\
    \   The serialization of this tag is 0xd9d9f7, which appears not to be in\n  \
    \ use as a distinguishing mark for frequently used file types.  In\n   particular,\
    \ it is not a valid start of a Unicode text in any Unicode\n   encoding if followed\
    \ by a valid CBOR data item.\n   For instance, a decoder might be able to parse\
    \ both CBOR and JSON.\n   Such a decoder would need to mechanically distinguish\
    \ the two\n   formats.  An easy way for an encoder to help the decoder would be\
    \ to\n   tag the entire CBOR item with tag 55799, the serialization of which\n\
    \   will never be found at the beginning of a JSON text.\n"
- title: 3.  Creating CBOR-Based Protocols
  contents:
  - "3.  Creating CBOR-Based Protocols\n   Data formats such as CBOR are often used\
    \ in environments where there\n   is no format negotiation.  A specific design\
    \ goal of CBOR is to not\n   need any included or assumed schema: a decoder can\
    \ take a CBOR item\n   and decode it with no other knowledge.\n   Of course, in\
    \ real-world implementations, the encoder and the decoder\n   will have a shared\
    \ view of what should be in a CBOR data item.  For\n   example, an agreed-to format\
    \ might be \"the item is an array whose\n   first value is a UTF-8 string, second\
    \ value is an integer, and\n   subsequent values are zero or more floating-point\
    \ numbers\" or \"the\n   item is a map that has byte strings for keys and contains\
    \ at least\n   one pair whose key is 0xab01\".\n   This specification puts no\
    \ restrictions on CBOR-based protocols.  An\n   encoder can be capable of encoding\
    \ as many or as few types of values\n   as is required by the protocol in which\
    \ it is used; a decoder can be\n   capable of understanding as many or as few\
    \ types of values as is\n   required by the protocols in which it is used.  This\
    \ lack of\n   restrictions allows CBOR to be used in extremely constrained\n \
    \  environments.\n   This section discusses some considerations in creating CBOR-based\n\
    \   protocols.  It is advisory only and explicitly excludes any language\n   from\
    \ RFC 2119 other than words that could be interpreted as \"MAY\" in\n   the sense\
    \ of RFC 2119.\n"
- title: 3.1.  CBOR in Streaming Applications
  contents:
  - "3.1.  CBOR in Streaming Applications\n   In a streaming application, a data stream\
    \ may be composed of a\n   sequence of CBOR data items concatenated back-to-back.\
    \  In such an\n   environment, the decoder immediately begins decoding a new data\
    \ item\n   if data is found after the end of a previous data item.\n   Not all\
    \ of the bytes making up a data item may be immediately\n   available to the decoder;\
    \ some decoders will buffer additional data\n   until a complete data item can\
    \ be presented to the application.\n   Other decoders can present partial information\
    \ about a top-level data\n   item to an application, such as the nested data items\
    \ that could\n   already be decoded, or even parts of a byte string that hasn't\n\
    \   completely arrived yet.\n   Note that some applications and protocols will\
    \ not want to use\n   indefinite-length encoding.  Using indefinite-length encoding\
    \ allows\n   an encoder to not need to marshal all the data for counting, but\
    \ it\n   requires a decoder to allocate increasing amounts of memory while\n \
    \  waiting for the end of the item.  This might be fine for some\n   applications\
    \ but not others.\n"
- title: 3.2.  Generic Encoders and Decoders
  contents:
  - "3.2.  Generic Encoders and Decoders\n   A generic CBOR decoder can decode all\
    \ well-formed CBOR data and\n   present them to an application.  CBOR data is\
    \ well-formed if it uses\n   the initial bytes, as well as the byte strings and/or\
    \ data items that\n   are implied by their values, in the manner defined by CBOR,\
    \ and no\n   extraneous data follows (Appendix C).\n   Even though CBOR attempts\
    \ to minimize these cases, not all well-\n   formed CBOR data is valid: for example,\
    \ the format excludes simple\n   values below 32 that are encoded with an extension\
    \ byte.  Also,\n   specific tags may make semantic constraints that may be violated,\n\
    \   such as by including a tag in a bignum tag or by following a byte\n   string\
    \ within a date tag.  Finally, the data may be invalid, such as\n   invalid UTF-8\
    \ strings or date strings that do not conform to\n   [RFC3339].  There is no requirement\
    \ that generic encoders and\n   decoders make unnatural choices for their application\
    \ interface to\n   enable the processing of invalid data.  Generic encoders and\
    \ decoders\n   are expected to forward simple values and tags even if their specific\n\
    \   codepoints are not registered at the time the encoder/decoder is\n   written\
    \ (Section 3.5).\n   Generic decoders provide ways to present well-formed CBOR\
    \ values,\n   both valid and invalid, to an application.  The diagnostic notation\n\
    \   (Section 6) may be used to present well-formed CBOR values to humans.\n  \
    \ Generic encoders provide an application interface that allows the\n   application\
    \ to specify any well-formed value, including simple values\n   and tags unknown\
    \ to the encoder.\n"
- title: 3.3.  Syntax Errors
  contents:
  - "3.3.  Syntax Errors\n   A decoder encountering a CBOR data item that is not well-formed\n\
    \   generally can choose to completely fail the decoding (issue an error\n   and/or\
    \ stop processing altogether), substitute the problematic data\n   and data items\
    \ using a decoder-specific convention that clearly\n   indicates there has been\
    \ a problem, or take some other action.\n"
- title: 3.3.1.  Incomplete CBOR Data Items
  contents:
  - "3.3.1.  Incomplete CBOR Data Items\n   The representation of a CBOR data item\
    \ has a specific length,\n   determined by its initial bytes and by the structure\
    \ of any data\n   items enclosed in the data items.  If less data is available,\
    \ this\n   can be treated as a syntax error.  A decoder may also implement\n \
    \  incremental parsing, that is, decode the data item as far as it is\n   available\
    \ and present the data found so far (such as in an event-\n   based interface),\
    \ with the option of continuing the decoding once\n   further data is available.\n\
    \   Examples of incomplete data items include:\n   o  A decoder expects a certain\
    \ number of array or map entries but\n      instead encounters the end of the\
    \ data.\n   o  A decoder processes what it expects to be the last pair in a map\n\
    \      and comes to the end of the data.\n   o  A decoder has just seen a tag\
    \ and then encounters the end of the\n      data.\n   o  A decoder has seen the\
    \ beginning of an indefinite-length item but\n      encounters the end of the\
    \ data before it sees the \"break\" stop\n      code.\n"
- title: 3.3.2.  Malformed Indefinite-Length Items
  contents:
  - "3.3.2.  Malformed Indefinite-Length Items\n   Examples of malformed indefinite-length\
    \ data items include:\n   o  Within an indefinite-length byte string or text,\
    \ a decoder finds\n      an item that is not of the appropriate major type before\
    \ it finds\n      the \"break\" stop code.\n   o  Within an indefinite-length\
    \ map, a decoder encounters the \"break\"\n      stop code immediately after reading\
    \ a key (the value is missing).\n   Another error is finding a \"break\" stop\
    \ code at a point in the data\n   where there is no immediately enclosing (unclosed)\
    \ indefinite-length\n   item.\n"
- title: 3.3.3.  Unknown Additional Information Values
  contents:
  - "3.3.3.  Unknown Additional Information Values\n   At the time of writing, some\
    \ additional information values are\n   unassigned and reserved for future versions\
    \ of this document (see\n   Section 5.2).  Since the overall syntax for these\
    \ additional\n   information values is not yet defined, a decoder that sees an\n\
    \   additional information value that it does not understand cannot\n   continue\
    \ parsing.\n"
- title: 3.4.  Other Decoding Errors
  contents:
  - "3.4.  Other Decoding Errors\n   A CBOR data item may be syntactically well-formed\
    \ but present a\n   problem with interpreting the data encoded in it in the CBOR\
    \ data\n   model.  Generally speaking, a decoder that finds a data item with\n\
    \   such a problem might issue a warning, might stop processing\n   altogether,\
    \ might handle the error and make the problematic value\n   available to the application\
    \ as such, or take some other type of\n   action.\n   Such problems might include:\n\
    \   Duplicate keys in a map:  Generic decoders (Section 3.2) make data\n     \
    \ available to applications using the native CBOR data model.  That\n      data\
    \ model includes maps (key-value mappings with unique keys),\n      not multimaps\
    \ (key-value mappings where multiple entries can have\n      the same key).  Thus,\
    \ a generic decoder that gets a CBOR map item\n      that has duplicate keys will\
    \ decode to a map with only one\n      instance of that key, or it might stop\
    \ processing altogether.  On\n      the other hand, a \"streaming decoder\" may\
    \ not even be able to\n      notice (Section 3.7).\n   Inadmissible type on the\
    \ value following a tag:  Tags (Section 2.4)\n      specify what type of data\
    \ item is supposed to follow the tag; for\n      example, the tags for positive\
    \ or negative bignums are supposed to\n      be put on byte strings.  A decoder\
    \ that decodes the tagged data\n      item into a native representation (a native\
    \ big integer in this\n      example) is expected to check the type of the data\
    \ item being\n      tagged.  Even decoders that don't have such native representations\n\
    \      available in their environment may perform the check on those tags\n  \
    \    known to them and react appropriately.\n   Invalid UTF-8 string:  A decoder\
    \ might or might not want to verify\n      that the sequence of bytes in a UTF-8\
    \ string (major type 3) is\n      actually valid UTF-8 and react appropriately.\n"
- title: 3.5.  Handling Unknown Simple Values and Tags
  contents:
  - "3.5.  Handling Unknown Simple Values and Tags\n   A decoder that comes across\
    \ a simple value (Section 2.3) that it does\n   not recognize, such as a value\
    \ that was added to the IANA registry\n   after the decoder was deployed or a\
    \ value that the decoder chose not\n   to implement, might issue a warning, might\
    \ stop processing\n   altogether, might handle the error by making the unknown\
    \ value\n   available to the application as such (as is expected of generic\n\
    \   decoders), or take some other type of action.\n   A decoder that comes across\
    \ a tag (Section 2.4) that it does not\n   recognize, such as a tag that was added\
    \ to the IANA registry after\n   the decoder was deployed or a tag that the decoder\
    \ chose not to\n   implement, might issue a warning, might stop processing altogether,\n\
    \   might handle the error and present the unknown tag value together\n   with\
    \ the contained data item to the application (as is expected of\n   generic decoders),\
    \ might ignore the tag and simply present the\n   contained data item only to\
    \ the application, or take some other type\n   of action.\n"
- title: 3.6.  Numbers
  contents:
  - "3.6.  Numbers\n   For the purposes of this specification, all number representations\n\
    \   for the same numeric value are equivalent.  This means that an\n   encoder\
    \ can encode a floating-point value of 0.0 as the integer 0.\n   It, however,\
    \ also means that an application that expects to find\n   integer values only\
    \ might find floating-point values if the encoder\n   decides these are desirable,\
    \ such as when the floating-point value is\n   more compact than a 64-bit integer.\n\
    \   An application or protocol that uses CBOR might restrict the\n   representations\
    \ of numbers.  For instance, a protocol that only deals\n   with integers might\
    \ say that floating-point numbers may not be used\n   and that decoders of that\
    \ protocol do not need to be able to handle\n   floating-point numbers.  Similarly,\
    \ a protocol or application that\n   uses CBOR might say that decoders need to\
    \ be able to handle either\n   type of number.\n   CBOR-based protocols should\
    \ take into account that different language\n   environments pose different restrictions\
    \ on the range and precision\n   of numbers that are representable.  For example,\
    \ the JavaScript\n   number system treats all numbers as floating point, which\
    \ may result\n   in silent loss of precision in decoding integers with more than\
    \ 53\n   significant bits.  A protocol that uses numbers should define its\n \
    \  expectations on the handling of non-trivial numbers in decoders and\n   receiving\
    \ applications.\n   A CBOR-based protocol that includes floating-point numbers\
    \ can\n   restrict which of the three formats (half-precision, single-\n   precision,\
    \ and double-precision) are to be supported.  For an\n   integer-only application,\
    \ a protocol may want to completely exclude\n   the use of floating-point values.\n\
    \   A CBOR-based protocol designed for compactness may want to exclude\n   specific\
    \ integer encodings that are longer than necessary for the\n   application, such\
    \ as to save the need to implement 64-bit integers.\n   There is an expectation\
    \ that encoders will use the most compact\n   integer representation that can\
    \ represent a given value.  However, a\n   compact application should accept values\
    \ that use a longer-than-\n   needed encoding (such as encoding \"0\" as 0b000_11101\
    \ followed by two\n   bytes of 0x00) as long as the application can decode an\
    \ integer of\n   the given size.\n"
- title: 3.7.  Specifying Keys for Maps
  contents:
  - "3.7.  Specifying Keys for Maps\n   The encoding and decoding applications need\
    \ to agree on what types of\n   keys are going to be used in maps.  In applications\
    \ that need to\n   interwork with JSON-based applications, keys probably should\
    \ be\n   limited to UTF-8 strings only; otherwise, there has to be a specified\n\
    \   mapping from the other CBOR types to Unicode characters, and this\n   often\
    \ leads to implementation errors.  In applications where keys are\n   numeric\
    \ in nature and numeric ordering of keys is important to the\n   application,\
    \ directly using the numbers for the keys is useful.\n   If multiple types of\
    \ keys are to be used, consideration should be\n   given to how these types would\
    \ be represented in the specific\n   programming environments that are to be used.\
    \  For example, in\n   JavaScript objects, a key of integer 1 cannot be distinguished\
    \ from a\n   key of string \"1\".  This means that, if integer keys are used,\
    \ the\n   simultaneous use of string keys that look like numbers needs to be\n\
    \   avoided.  Again, this leads to the conclusion that keys should be of\n   a\
    \ single CBOR type.\n   Decoders that deliver data items nested within a CBOR\
    \ data item\n   immediately on decoding them (\"streaming decoders\") often do\
    \ not keep\n   the state that is necessary to ascertain uniqueness of a key in\
    \ a\n   map.  Similarly, an encoder that can start encoding data items before\n\
    \   the enclosing data item is completely available (\"streaming encoder\")\n\
    \   may want to reduce its overhead significantly by relying on its data\n   source\
    \ to maintain uniqueness.\n   A CBOR-based protocol should make an intentional\
    \ decision about what\n   to do when a receiving application does see multiple\
    \ identical keys\n   in a map.  The resulting rule in the protocol should respect\
    \ the CBOR\n   data model: it cannot prescribe a specific handling of the entries\n\
    \   with the identical keys, except that it might have a rule that having\n  \
    \ identical keys in a map indicates a malformed map and that the\n   decoder has\
    \ to stop with an error.  Duplicate keys are also\n   prohibited by CBOR decoders\
    \ that are using strict mode\n   (Section 3.10).\n   The CBOR data model for maps\
    \ does not allow ascribing semantics to\n   the order of the key/value pairs in\
    \ the map representation.\n   Thus, it would be a very bad practice to define\
    \ a CBOR-based protocol\n   in such a way that changing the key/value pair order\
    \ in a map would\n   change the semantics, apart from trivial aspects (cache usage,\
    \ etc.).\n   (A CBOR-based protocol can prescribe a specific order of\n   serialization,\
    \ such as for canonicalization.)\n   Applications for constrained devices that\
    \ have maps with 24 or fewer\n   frequently used keys should consider using small\
    \ integers (and those\n   with up to 48 frequently used keys should consider also\
    \ using small\n   negative integers) because the keys can then be encoded in a\
    \ single\n   byte.\n"
- title: 3.8.  Undefined Values
  contents:
  - "3.8.  Undefined Values\n   In some CBOR-based protocols, the simple value (Section\
    \ 2.3) of\n   Undefined might be used by an encoder as a substitute for a data\
    \ item\n   with an encoding problem, in order to allow the rest of the enclosing\n\
    \   data items to be encoded without harm.\n"
- title: 3.9.  Canonical CBOR
  contents:
  - "3.9.  Canonical CBOR\n   Some protocols may want encoders to only emit CBOR in\
    \ a particular\n   canonical format; those protocols might also have the decoders\
    \ check\n   that their input is canonical.  Those protocols are free to define\n\
    \   what they mean by a canonical format and what encoders and decoders\n   are\
    \ expected to do.  This section lists some suggestions for such\n   protocols.\n\
    \   If a protocol considers \"canonical\" to mean that two encoder\n   implementations\
    \ starting with the same input data will produce the\n   same CBOR output, the\
    \ following four rules would suffice:\n   o  Integers must be as small as possible.\n\
    \      *  0 to 23 and -1 to -24 must be expressed in the same byte as the\n  \
    \       major type;\n      *  24 to 255 and -25 to -256 must be expressed only\
    \ with an\n         additional uint8_t;\n      *  256 to 65535 and -257 to -65536\
    \ must be expressed only with an\n         additional uint16_t;\n      *  65536\
    \ to 4294967295 and -65537 to -4294967296 must be expressed\n         only with\
    \ an additional uint32_t.\n   o  The expression of lengths in major types 2 through\
    \ 5 must be as\n      short as possible.  The rules for these lengths follow the\
    \ above\n      rule for integers.\n   o  The keys in every map must be sorted\
    \ lowest value to highest.\n      Sorting is performed on the bytes of the representation\
    \ of the key\n      data items without paying attention to the 3/5 bit splitting\
    \ for\n      major types.  (Note that this rule allows maps that have keys of\n\
    \      different types, even though that is probably a bad practice that\n   \
    \   could lead to errors in some canonicalization implementations.)\n      The\
    \ sorting rules are:\n      *  If two keys have different lengths, the shorter\
    \ one sorts\n         earlier;\n      *  If two keys have the same length, the\
    \ one with the lower value\n         in (byte-wise) lexical order sorts earlier.\n\
    \   o  Indefinite-length items must be made into definite-length items.\n   If\
    \ a protocol allows for IEEE floats, then additional\n   canonicalization rules\
    \ might need to be added.  One example rule\n   might be to have all floats start\
    \ as a 64-bit float, then do a test\n   conversion to a 32-bit float; if the result\
    \ is the same numeric\n   value, use the shorter value and repeat the process\
    \ with a test\n   conversion to a 16-bit float.  (This rule selects 16-bit float\
    \ for\n   positive and negative Infinity as well.)  Also, there are many\n   representations\
    \ for NaN.  If NaN is an allowed value, it must always\n   be represented as 0xf97e00.\n\
    \   CBOR tags present additional considerations for canonicalization.\n   The\
    \ absence or presence of tags in a canonical format is determined\n   by the optionality\
    \ of the tags in the protocol.  In a CBOR-based\n   protocol that allows optional\
    \ tagging anywhere, the canonical format\n   must not allow them.  In a protocol\
    \ that requires tags in certain\n   places, the tag needs to appear in the canonical\
    \ format.  A CBOR-\n   based protocol that uses canonicalization might instead\
    \ say that all\n   tags that appear in a message must be retained regardless of\
    \ whether\n   they are optional.\n"
- title: 3.10.  Strict Mode
  contents:
  - "3.10.  Strict Mode\n   Some areas of application of CBOR do not require canonicalization\n\
    \   (Section 3.9) but may require that different decoders reach the same\n   (semantically\
    \ equivalent) results, even in the presence of\n   potentially malicious data.\
    \  This can be required if one application\n   (such as a firewall or other protecting\
    \ entity) makes a decision\n   based on the data that another application, which\
    \ independently\n   decodes the data, relies on.\n   Normally, it is the responsibility\
    \ of the sender to avoid ambiguously\n   decodable data.  However, the sender\
    \ might be an attacker specially\n   making up CBOR data such that it will be\
    \ interpreted differently by\n   different decoders in an attempt to exploit that\
    \ as a vulnerability.\n   Generic decoders used in applications where this might\
    \ be a problem\n   need to support a strict mode in which it is also the responsibility\n\
    \   of the receiver to reject ambiguously decodable data.  It is expected\n  \
    \ that firewalls and other security systems that decode CBOR will only\n   decode\
    \ in strict mode.\n   A decoder in strict mode will reliably reject any data that\
    \ could be\n   interpreted by other decoders in different ways.  It will reliably\n\
    \   reject data items with syntax errors (Section 3.3).  It will also\n   expend\
    \ the effort to reliably detect other decoding errors\n   (Section 3.4).  In particular,\
    \ a strict decoder needs to have an API\n   that reports an error (and does not\
    \ return data) for a CBOR data item\n   that contains any of the following:\n\
    \   o  a map (major type 5) that has more than one entry with the same\n     \
    \ key\n   o  a tag that is used on a data item of the incorrect type\n   o  a\
    \ data item that is incorrectly formatted for the type given to\n      it, such\
    \ as invalid UTF-8 or data that cannot be interpreted with\n      the specific\
    \ tag that it has been tagged with\n   A decoder in strict mode can do one of\
    \ two things when it encounters\n   a tag or simple value that it does not recognize:\n\
    \   o  It can report an error (and not return data).\n   o  It can emit the unknown\
    \ item (type, value, and, for tags, the\n      decoded tagged data item) to the\
    \ application calling the decoder\n      with an indication that the decoder did\
    \ not recognize that tag or\n      simple value.\n   The latter approach, which\
    \ is also appropriate for non-strict\n   decoders, supports forward compatibility\
    \ with newly registered tags\n   and simple values without the requirement to\
    \ update the encoder at\n   the same time as the calling application.  (For this,\
    \ the API for the\n   decoder needs to have a way to mark unknown items so that\
    \ the calling\n   application can handle them in a manner appropriate for the\
    \ program.)\n   Since some of this processing may have an appreciable cost (in\n\
    \   particular with duplicate detection for maps), support of strict mode\n  \
    \ is not a requirement placed on all CBOR decoders.\n   Some encoders will rely\
    \ on their applications to provide input data\n   in such a way that unambiguously\
    \ decodable CBOR results.  A generic\n   encoder also may want to provide a strict\
    \ mode where it reliably\n   limits its output to unambiguously decodable CBOR,\
    \ independent of\n   whether or not its application is providing API-conformant\
    \ data.\n"
- title: 4.  Converting Data between CBOR and JSON
  contents:
  - "4.  Converting Data between CBOR and JSON\n   This section gives non-normative\
    \ advice about converting between CBOR\n   and JSON.  Implementations of converters\
    \ are free to use whichever\n   advice here they want.\n   It is worth noting\
    \ that a JSON text is a sequence of characters, not\n   an encoded sequence of\
    \ bytes, while a CBOR data item consists of\n   bytes, not characters.\n"
- title: 4.1.  Converting from CBOR to JSON
  contents:
  - "4.1.  Converting from CBOR to JSON\n   Most of the types in CBOR have direct\
    \ analogs in JSON.  However, some\n   do not, and someone implementing a CBOR-to-JSON\
    \ converter has to\n   consider what to do in those cases.  The following non-normative\n\
    \   advice deals with these by converting them to a single substitute\n   value,\
    \ such as a JSON null.\n   o  An integer (major type 0 or 1) becomes a JSON number.\n\
    \   o  A byte string (major type 2) that is not embedded in a tag that\n     \
    \ specifies a proposed encoding is encoded in base64url without\n      padding\
    \ and becomes a JSON string.\n   o  A UTF-8 string (major type 3) becomes a JSON\
    \ string.  Note that\n      JSON requires escaping certain characters (RFC 4627,\
    \ Section 2.5):\n      quotation mark (U+0022), reverse solidus (U+005C), and\
    \ the \"C0\n      control characters\" (U+0000 through U+001F).  All other characters\n\
    \      are copied unchanged into the JSON UTF-8 string.\n   o  An array (major\
    \ type 4) becomes a JSON array.\n   o  A map (major type 5) becomes a JSON object.\
    \  This is possible\n      directly only if all keys are UTF-8 strings.  A converter\
    \ might\n      also convert other keys into UTF-8 strings (such as by converting\n\
    \      integers into strings containing their decimal representation);\n     \
    \ however, doing so introduces a danger of key collision.\n   o  False (major\
    \ type 7, additional information 20) becomes a JSON\n      false.\n   o  True\
    \ (major type 7, additional information 21) becomes a JSON\n      true.\n   o\
    \  Null (major type 7, additional information 22) becomes a JSON\n      null.\n\
    \   o  A floating-point value (major type 7, additional information 25\n     \
    \ through 27) becomes a JSON number if it is finite (that is, it can\n      be\
    \ represented in a JSON number); if the value is non-finite (NaN,\n      or positive\
    \ or negative Infinity), it is represented by the\n      substitute value.\n \
    \  o  Any other simple value (major type 7, any additional information\n     \
    \ value not yet discussed) is represented by the substitute value.\n   o  A bignum\
    \ (major type 6, tag value 2 or 3) is represented by\n      encoding its byte\
    \ string in base64url without padding and becomes\n      a JSON string.  For tag\
    \ value 3 (negative bignum), a \"~\" (ASCII\n      tilde) is inserted before the\
    \ base-encoded value.  (The conversion\n      to a binary blob instead of a number\
    \ is to prevent a likely\n      numeric overflow for the JSON decoder.)\n   o\
    \  A byte string with an encoding hint (major type 6, tag value 21\n      through\
    \ 23) is encoded as described and becomes a JSON string.\n   o  For all other\
    \ tags (major type 6, any other tag value), the\n      embedded CBOR item is represented\
    \ as a JSON value; the tag value\n      is ignored.\n   o  Indefinite-length items\
    \ are made definite before conversion.\n"
- title: 4.2.  Converting from JSON to CBOR
  contents:
  - "4.2.  Converting from JSON to CBOR\n   All JSON values, once decoded, directly\
    \ map into one or more CBOR\n   values.  As with any kind of CBOR generation,\
    \ decisions have to be\n   made with respect to number representation.  In a suggested\n\
    \   conversion:\n   o  JSON numbers without fractional parts (integer numbers)\
    \ are\n      represented as integers (major types 0 and 1, possibly major type\n\
    \      6 tag value 2 and 3), choosing the shortest form; integers longer\n   \
    \   than an implementation-defined threshold (which is usually either\n      32\
    \ or 64 bits) may instead be represented as floating-point\n      values.  (If\
    \ the JSON was generated from a JavaScript\n      implementation, its precision\
    \ is already limited to 53 bits\n      maximum.)\n   o  Numbers with fractional\
    \ parts are represented as floating-point\n      values.  Preferably, the shortest\
    \ exact floating-point\n      representation is used; for instance, 1.5 is represented\
    \ in a\n      16-bit floating-point value (not all implementations will be\n \
    \     capable of efficiently finding the minimum form, though).  There\n     \
    \ may be an implementation-defined limit to the precision that will\n      affect\
    \ the precision of the represented values.  Decimal\n      representation should\
    \ only be used if that is specified in a\n      protocol.\n   CBOR has been designed\
    \ to generally provide a more compact encoding\n   than JSON.  One implementation\
    \ strategy that might come to mind is to\n   perform a JSON-to-CBOR encoding in\
    \ place in a single buffer.  This\n   strategy would need to carefully consider\
    \ a number of pathological\n   cases, such as that some strings represented with\
    \ no or very few\n   escapes and longer (or much longer) than 255 bytes may expand\
    \ when\n   encoded as UTF-8 strings in CBOR.  Similarly, a few of the binary\n\
    \   floating-point representations might cause expansion from some short\n   decimal\
    \ representations (1.1, 1e9) in JSON.  This may be hard to get\n   right, and\
    \ any ensuing vulnerabilities may be exploited by an\n   attacker.\n"
- title: 5.  Future Evolution of CBOR
  contents:
  - "5.  Future Evolution of CBOR\n   Successful protocols evolve over time.  New\
    \ ideas appear,\n   implementation platforms improve, related protocols are developed\
    \ and\n   evolve, and new requirements from applications and protocols are\n \
    \  added.  Facilitating protocol evolution is therefore an important\n   design\
    \ consideration for any protocol development.\n   For protocols that will use\
    \ CBOR, CBOR provides some useful\n   mechanisms to facilitate their evolution.\
    \  Best practices for this\n   are well known, particularly from JSON format development\
    \ of JSON-\n   based protocols.  Therefore, such best practices are outside the\n\
    \   scope of this specification.\n   However, facilitating the evolution of CBOR\
    \ itself is very well\n   within its scope.  CBOR is designed to both provide\
    \ a stable basis\n   for development of CBOR-based protocols and to be able to\
    \ evolve.\n   Since a successful protocol may live for decades, CBOR needs to\
    \ be\n   designed for decades of use and evolution.  This section provides\n \
    \  some guidance for the evolution of CBOR.  It is necessarily more\n   subjective\
    \ than other parts of this document.  It is also necessarily\n   incomplete, lest\
    \ it turn into a textbook on protocol development.\n"
- title: 5.1.  Extension Points
  contents:
  - "5.1.  Extension Points\n   In a protocol design, opportunities for evolution\
    \ are often included\n   in the form of extension points.  For example, there\
    \ may be a\n   codepoint space that is not fully allocated from the outset, and\
    \ the\n   protocol is designed to tolerate and embrace implementations that\n\
    \   start using more codepoints than initially allocated.\n   Sizing the codepoint\
    \ space may be difficult because the range\n   required may be hard to predict.\
    \  An attempt should be made to make\n   the codepoint space large enough so that\
    \ it can slowly be filled over\n   the intended lifetime of the protocol.\n  \
    \ CBOR has three major extension points:\n   o  the \"simple\" space (values in\
    \ major type 7).  Of the 24 efficient\n      (and 224 slightly less efficient)\
    \ values, only a small number have\n      been allocated.  Implementations receiving\
    \ an unknown simple data\n      item may be able to process it as such, given\
    \ that the structure\n      of the value is indeed simple.  The IANA registry\
    \ in Section 7.1\n      is the appropriate way to address the extensibility of\
    \ this\n      codepoint space.\n   o  the \"tag\" space (values in major type\
    \ 6).  Again, only a small\n      part of the codepoint space has been allocated,\
    \ and the space is\n      abundant (although the early numbers are more efficient\
    \ than the\n      later ones).  Implementations receiving an unknown tag can choose\n\
    \      to simply ignore it or to process it as an unknown tag wrapping\n     \
    \ the following data item.  The IANA registry in Section 7.2 is the\n      appropriate\
    \ way to address the extensibility of this codepoint\n      space.\n   o  the\
    \ \"additional information\" space.  An implementation receiving\n      an unknown\
    \ additional information value has no way to continue\n      parsing, so allocating\
    \ codepoints to this space is a major step.\n      There are also very few codepoints\
    \ left.\n"
- title: 5.2.  Curating the Additional Information Space
  contents:
  - "5.2.  Curating the Additional Information Space\n   The human mind is sometimes\
    \ drawn to filling in little perceived gaps\n   to make something neat.  We expect\
    \ the remaining gaps in the\n   codepoint space for the additional information\
    \ values to be an\n   attractor for new ideas, just because they are there.\n\
    \   The present specification does not manage the additional information\n   codepoint\
    \ space by an IANA registry.  Instead, allocations out of\n   this space can only\
    \ be done by updating this specification.\n   For an additional information value\
    \ of n >= 24, the size of the\n   additional data typically is 2**(n-24) bytes.\
    \  Therefore, additional\n   information values 28 and 29 should be viewed as\
    \ candidates for\n   128-bit and 256-bit quantities, in case a need arises to\
    \ add them to\n   the protocol.  Additional information value 30 is then the only\n\
    \   additional information value available for general allocation, and\n   there\
    \ should be a very good reason for allocating it before assigning\n   it through\
    \ an update of this protocol.\n"
- title: 6.  Diagnostic Notation
  contents:
  - "6.  Diagnostic Notation\n   CBOR is a binary interchange format.  To facilitate\
    \ documentation and\n   debugging, and in particular to facilitate communication\
    \ between\n   entities cooperating in debugging, this section defines a simple\n\
    \   human-readable diagnostic notation.  All actual interchange always\n   happens\
    \ in the binary format.\n   Note that this truly is a diagnostic format; it is\
    \ not meant to be\n   parsed.  Therefore, no formal definition (as in ABNF) is\
    \ given in\n   this document.  (Implementers looking for a text-based format for\n\
    \   representing CBOR data items in configuration files may also want to\n   consider\
    \ YAML [YAML].)\n   The diagnostic notation is loosely based on JSON as it is\
    \ defined in\n   RFC 4627, extending it where needed.\n   The notation borrows\
    \ the JSON syntax for numbers (integer and\n   floating point), True (>true<),\
    \ False (>false<), Null (>null<), UTF-8\n   strings, arrays, and maps (maps are\
    \ called objects in JSON; the\n   diagnostic notation extends JSON here by allowing\
    \ any data item in\n   the key position).  Undefined is written >undefined< as\
    \ in\n   JavaScript.  The non-finite floating-point numbers Infinity,\n   -Infinity,\
    \ and NaN are written exactly as in this sentence (this is\n   also a way they\
    \ can be written in JavaScript, although JSON does not\n   allow them).  A tagged\
    \ item is written as an integer number for the\n   tag followed by the item in\
    \ parentheses; for instance, an RFC 3339\n   (ISO 8601) date could be notated\
    \ as:\n      0(\"2013-03-21T20:04:00Z\")\n   or the equivalent relative time as\n\
    \      1(1363896240)\n   Byte strings are notated in one of the base encodings,\
    \ without\n   padding, enclosed in single quotes, prefixed by >h< for base16,\
    \ >b32<\n   for base32, >h32< for base32hex, >b64< for base64 or base64url (the\n\
    \   actual encodings do not overlap, so the string remains unambiguous).\n   For\
    \ example, the byte string 0x12345678 could be written h'12345678',\n   b32'CI2FM6A',\
    \ or b64'EjRWeA'.\n   Unassigned simple values are given as \"simple()\" with\
    \ the appropriate\n   integer in the parentheses.  For example, \"simple(42)\"\
    \ indicates\n   major type 7, value 42.\n"
- title: 6.1.  Encoding Indicators
  contents:
  - "6.1.  Encoding Indicators\n   Sometimes it is useful to indicate in the diagnostic\
    \ notation which\n   of several alternative representations were actually used;\
    \ for\n   example, a data item written >1.5< by a diagnostic decoder might have\n\
    \   been encoded as a half-, single-, or double-precision float.\n   The convention\
    \ for encoding indicators is that anything starting with\n   an underscore and\
    \ all following characters that are alphanumeric or\n   underscore, is an encoding\
    \ indicator, and can be ignored by anyone\n   not interested in this information.\
    \  Encoding indicators are always\n   optional.\n   A single underscore can be\
    \ written after the opening brace of a map\n   or the opening bracket of an array\
    \ to indicate that the data item was\n   represented in indefinite-length format.\
    \  For example, [_ 1, 2]\n   contains an indicator that an indefinite-length representation\
    \ was\n   used to represent the data item [1, 2].\n   An underscore followed by\
    \ a decimal digit n indicates that the\n   preceding item (or, for arrays and\
    \ maps, the item starting with the\n   preceding bracket or brace) was encoded\
    \ with an additional\n   information value of 24+n.  For example, 1.5_1 is a half-precision\n\
    \   floating-point number, while 1.5_3 is encoded as double precision.\n   This\
    \ encoding indicator is not shown in Appendix A.  (Note that the\n   encoding\
    \ indicator \"_\" is thus an abbreviation of the full form \"_7\",\n   which is\
    \ not used.)\n   As a special case, byte and text strings of indefinite length\
    \ can be\n   notated in the form (_ h'0123', h'4567') and (_ \"foo\", \"bar\"\
    ).\n"
- title: 7.  IANA Considerations
  contents:
  - "7.  IANA Considerations\n   IANA has created two registries for new CBOR values.\
    \  The registries\n   are separate, that is, not under an umbrella registry, and\
    \ follow the\n   rules in [RFC5226].  IANA has also assigned a new MIME media\
    \ type and\n   an associated Constrained Application Protocol (CoAP) Content-Format\n\
    \   entry.\n"
- title: 7.1.  Simple Values Registry
  contents:
  - "7.1.  Simple Values Registry\n   IANA has created the \"Concise Binary Object\
    \ Representation (CBOR)\n   Simple Values\" registry.  The initial values are\
    \ shown in Table 2.\n   New entries in the range 0 to 19 are assigned by Standards\
    \ Action.\n   It is suggested that these Standards Actions allocate values starting\n\
    \   with the number 16 in order to reserve the lower numbers for\n   contiguous\
    \ blocks (if any).\n   New entries in the range 32 to 255 are assigned by Specification\n\
    \   Required.\n"
- title: 7.2.  Tags Registry
  contents:
  - "7.2.  Tags Registry\n   IANA has created the \"Concise Binary Object Representation\
    \ (CBOR)\n   Tags\" registry.  The initial values are shown in Table 3.\n   New\
    \ entries in the range 0 to 23 are assigned by Standards Action.\n   New entries\
    \ in the range 24 to 255 are assigned by Specification\n   Required.  New entries\
    \ in the range 256 to 18446744073709551615 are\n   assigned by First Come First\
    \ Served.  The template for registration\n   requests is:\n   o  Data item\n \
    \  o  Semantics (short form)\n   In addition, First Come First Served requests\
    \ should include:\n   o  Point of contact\n   o  Description of semantics (URL)\n\
    \      This description is optional; the URL can point to something like\n   \
    \   an Internet-Draft or a web page.\n"
- title: 7.3.  Media Type ("MIME Type")
  contents:
  - "7.3.  Media Type (\"MIME Type\")\n   The Internet media type [RFC6838] for CBOR\
    \ data is application/cbor.\n   Type name: application\n   Subtype name: cbor\n\
    \   Required parameters: n/a\n   Optional parameters: n/a\n   Encoding considerations:\
    \  binary\n   Security considerations:  See Section 8 of this document\n   Interoperability\
    \ considerations: n/a\n   Published specification: This document\n   Applications\
    \ that use this media type:  None yet, but it is expected\n      that this format\
    \ will be deployed in protocols and applications.\n   Additional information:\n\
    \      Magic number(s): n/a\n      File extension(s): .cbor\n      Macintosh file\
    \ type code(s): n/a\n   Person & email address to contact for further information:\n\
    \      Carsten Bormann\n      cabo@tzi.org\n   Intended usage: COMMON\n   Restrictions\
    \ on usage: none\n   Author:\n      Carsten Bormann <cabo@tzi.org>\n   Change\
    \ controller:\n      The IESG <iesg@ietf.org>\n"
- title: 7.4.  CoAP Content-Format
  contents:
  - "7.4.  CoAP Content-Format\n   Media Type: application/cbor\n   Encoding: -\n\
    \   Id: 60\n   Reference: [RFC7049]\n"
- title: 7.5.  The +cbor Structured Syntax Suffix Registration
  contents:
  - "7.5.  The +cbor Structured Syntax Suffix Registration\n   Name: Concise Binary\
    \ Object Representation (CBOR)\n   +suffix: +cbor\n   References: [RFC7049]\n\
    \   Encoding Considerations: CBOR is a binary format.\n   Interoperability Considerations:\
    \ n/a\n   Fragment Identifier Considerations:\n      The syntax and semantics\
    \ of fragment identifiers specified for\n      +cbor SHOULD be as specified for\
    \ \"application/cbor\".  (At\n      publication of this document, there is no\
    \ fragment identification\n      syntax defined for \"application/cbor\".)\n \
    \     The syntax and semantics for fragment identifiers for a specific\n     \
    \ \"xxx/yyy+cbor\" SHOULD be processed as follows:\n      For cases defined in\
    \ +cbor, where the fragment identifier resolves\n      per the +cbor rules, then\
    \ process as specified in +cbor.\n      For cases defined in +cbor, where the\
    \ fragment identifier does not\n      resolve per the +cbor rules, then process\
    \ as specified in\n      \"xxx/yyy+cbor\".\n      For cases not defined in +cbor,\
    \ then process as specified in\n      \"xxx/yyy+cbor\".\n   Security Considerations:\
    \  See Section 8 of this document\n   Contact:\n      Apps Area Working Group\
    \ (apps-discuss@ietf.org)\n   Author/Change Controller:\n      The Apps Area Working\
    \ Group.\n      The IESG has change control over this registration.\n"
- title: 8.  Security Considerations
  contents:
  - "8.  Security Considerations\n   A network-facing application can exhibit vulnerabilities\
    \ in its\n   processing logic for incoming data.  Complex parsers are well known\n\
    \   as a likely source of such vulnerabilities, such as the ability to\n   remotely\
    \ crash a node, or even remotely execute arbitrary code on it.\n   CBOR attempts\
    \ to narrow the opportunities for introducing such\n   vulnerabilities by reducing\
    \ parser complexity, by giving the entire\n   range of encodable values a meaning\
    \ where possible.\n   Resource exhaustion attacks might attempt to lure a decoder\
    \ into\n   allocating very big data items (strings, arrays, maps) or exhaust the\n\
    \   stack depth by setting up deeply nested items.  Decoders need to have\n  \
    \ appropriate resource management to mitigate these attacks.  (Items\n   for which\
    \ very large sizes are given can also attempt to exploit\n   integer overflow\
    \ vulnerabilities.)\n   Applications where a CBOR data item is examined by a gatekeeper\n\
    \   function and later used by a different application may exhibit\n   vulnerabilities\
    \ when multiple interpretations of the data item are\n   possible.  For example,\
    \ an attacker could make use of duplicate keys\n   in maps and precision issues\
    \ in numbers to make the gatekeeper base\n   its decisions on a different interpretation\
    \ than the one that will be\n   used by the second application.  Protocols that\
    \ are used in a\n   security context should be defined in such a way that these\
    \ multiple\n   interpretations are reliably reduced to a single one.  To facilitate\n\
    \   this, encoder and decoder implementations used in such contexts\n   should\
    \ provide at least one strict mode of operation (Section 3.10).\n"
- title: 9.  Acknowledgements
  contents:
  - "9.  Acknowledgements\n   CBOR was inspired by MessagePack.  MessagePack was developed\
    \ and\n   promoted by Sadayuki Furuhashi (\"frsyuki\").  This reference to\n \
    \  MessagePack is solely for attribution; CBOR is not intended as a\n   version\
    \ of or replacement for MessagePack, as it has different design\n   goals and\
    \ requirements.\n   The need for functionality beyond the original MessagePack\n\
    \   Specification became obvious to many people at about the same time\n   around\
    \ the year 2012.  BinaryPack is a minor derivation of\n   MessagePack that was\
    \ developed by Eric Zhang for the binaryjs\n   project.  A similar, but different,\
    \ extension was made by Tim Caswell\n   for his msgpack-js and msgpack-js-browser\
    \ projects.  Many people have\n   contributed to the recent discussion about extending\
    \ MessagePack to\n   separate text string representation from byte string representation.\n\
    \   The encoding of the additional information in CBOR was inspired by\n   the\
    \ encoding of length information designed by Klaus Hartke for CoAP.\n   This document\
    \ also incorporates suggestions made by many people,\n   notably Dan Frost, James\
    \ Manger, Joe Hildebrand, Keith Moore, Matthew\n   Lepinski, Nico Williams, Phillip\
    \ Hallam-Baker, Ray Polk, Tim Bray,\n   Tony Finch, Tony Hansen, and Yaron Sheffer.\n"
- title: 10.  References
  contents:
  - '10.  References

    '
- title: 10.1.  Normative References
  contents:
  - "10.1.  Normative References\n   [ECMA262]  European Computer Manufacturers Association,\
    \ \"ECMAScript\n              Language Specification 5.1 Edition\", ECMA Standard\n\
    \              ECMA-262, June 2011, <http://www.ecma-international.org/\n    \
    \          publications/files/ecma-st/ECMA-262.pdf>.\n   [RFC2045]  Freed, N.\
    \ and N. Borenstein, \"Multipurpose Internet Mail\n              Extensions (MIME)\
    \ Part One: Format of Internet Message\n              Bodies\", RFC 2045, November\
    \ 1996.\n   [RFC2119]  Bradner, S., \"Key words for use in RFCs to Indicate\n\
    \              Requirement Levels\", BCP 14, RFC 2119, March 1997.\n   [RFC3339]\
    \  Klyne, G., Ed. and C. Newman, \"Date and Time on the\n              Internet:\
    \ Timestamps\", RFC 3339, July 2002.\n   [RFC3629]  Yergeau, F., \"UTF-8, a transformation\
    \ format of ISO\n              10646\", STD 63, RFC 3629, November 2003.\n   [RFC3986]\
    \  Berners-Lee, T., Fielding, R., and L. Masinter, \"Uniform\n              Resource\
    \ Identifier (URI): Generic Syntax\", STD 66, RFC\n              3986, January\
    \ 2005.\n   [RFC4287]  Nottingham, M., Ed. and R. Sayre, Ed., \"The Atom\n   \
    \           Syndication Format\", RFC 4287, December 2005.\n   [RFC4648]  Josefsson,\
    \ S., \"The Base16, Base32, and Base64 Data\n              Encodings\", RFC 4648,\
    \ October 2006.\n   [RFC5226]  Narten, T. and H. Alvestrand, \"Guidelines for\
    \ Writing an\n              IANA Considerations Section in RFCs\", BCP 26, RFC\
    \ 5226,\n              May 2008.\n   [TIME_T]   The Open Group Base Specifications,\
    \ \"Vol. 1: Base\n              Definitions, Issue 7\", Section 4.15 'Seconds\
    \ Since the\n              Epoch', IEEE Std 1003.1, 2013 Edition, 2013,\n    \
    \          <http://pubs.opengroup.org/onlinepubs/9699919799/\n              basedefs/V1_chap04.html#tag_04_15>.\n"
- title: 10.2.  Informative References
  contents:
  - "10.2.  Informative References\n   [ASN.1]    International Telecommunication\
    \ Union, \"Information\n              Technology -- ASN.1 encoding rules: Specification\
    \ of Basic\n              Encoding Rules (BER), Canonical Encoding Rules (CER)\
    \ and\n              Distinguished Encoding Rules (DER)\", ITU-T Recommendation\n\
    \              X.690, 1994.\n   [BSON]     Various, \"BSON - Binary JSON\", 2013,\n\
    \              <http://bsonspec.org/>.\n   [CNN-TERMS]\n              Bormann,\
    \ C., Ersue, M., and A. Keranen, \"Terminology for\n              Constrained\
    \ Node Networks\", Work in Progress, July 2013.\n   [MessagePack]\n          \
    \    Furuhashi, S., \"MessagePack\", 2013, <http://msgpack.org/>.\n   [RFC0713]\
    \  Haverty, J., \"MSDTP-Message Services Data Transmission\n              Protocol\"\
    , RFC 713, April 1976.\n   [RFC4627]  Crockford, D., \"The application/json Media\
    \ Type for\n              JavaScript Object Notation (JSON)\", RFC 4627, July\
    \ 2006.\n   [RFC6838]  Freed, N., Klensin, J., and T. Hansen, \"Media Type\n \
    \             Specifications and Registration Procedures\", BCP 13, RFC\n    \
    \          6838, January 2013.\n   [UBJSON]   The Buzz Media, \"Universal Binary\
    \ JSON Specification\",\n              2013, <http://ubjson.org/>.\n   [YAML]\
    \     Ben-Kiki, O., Evans, C., and I. Net, \"YAML Ain't Markup\n             \
    \ Language (YAML[TM]) Version 1.2\", 3rd Edition, October\n              2009,\
    \ <http://www.yaml.org/spec/1.2/spec.html>.\n"
- title: Appendix A.  Examples
  contents:
  - "Appendix A.  Examples\n   The following table provides some CBOR-encoded values\
    \ in hexadecimal\n   (right column), together with diagnostic notation for these\
    \ values\n   (left column).  Note that the string \"\\u00fc\" is one form of\n\
    \   diagnostic notation for a UTF-8 string containing the single Unicode\n   character\
    \ U+00FC, LATIN SMALL LETTER U WITH DIAERESIS (u umlaut).\n   Similarly, \"\\\
    u6c34\" is a UTF-8 string in diagnostic notation with a\n   single character U+6C34\
    \ (CJK UNIFIED IDEOGRAPH-6C34, often\n   representing \"water\"), and \"\\ud800\\\
    udd51\" is a UTF-8 string in\n   diagnostic notation with a single character U+10151\
    \ (GREEK ACROPHONIC\n   ATTIC FIFTY STATERS).  (Note that all these single-character\
    \ strings\n   could also be represented in native UTF-8 in diagnostic notation,\n\
    \   just not in an ASCII-only specification like the present one.)  In\n   the\
    \ diagnostic notation provided for bignums, their intended numeric\n   value is\
    \ shown as a decimal number (such as 18446744073709551616)\n   instead of showing\
    \ a tagged byte string (such as\n   2(h'010000000000000000')).\n   +------------------------------+------------------------------------+\n\
    \   | Diagnostic                   | Encoded                            |\n  \
    \ +------------------------------+------------------------------------+\n   |\
    \ 0                            | 0x00                               |\n   |  \
    \                            |                                    |\n   | 1  \
    \                          | 0x01                               |\n   |      \
    \                        |                                    |\n   | 10     \
    \                      | 0x0a                               |\n   |          \
    \                    |                                    |\n   | 23         \
    \                  | 0x17                               |\n   |              \
    \                |                                    |\n   | 24             \
    \              | 0x1818                             |\n   |                  \
    \            |                                    |\n   | 25                 \
    \          | 0x1819                             |\n   |                      \
    \        |                                    |\n   | 100                    \
    \      | 0x1864                             |\n   |                          \
    \    |                                    |\n   | 1000                       \
    \  | 0x1903e8                           |\n   |                              |\
    \                                    |\n   | 1000000                      | 0x1a000f4240\
    \                       |\n   |                              |               \
    \                     |\n   | 1000000000000                | 0x1b000000e8d4a51000\
    \               |\n   |                              |                       \
    \             |\n   | 18446744073709551615         | 0x1bffffffffffffffff    \
    \           |\n   |                              |                           \
    \         |\n   | 18446744073709551616         | 0xc249010000000000000000    \
    \       |\n   |                              |                               \
    \     |\n   | -18446744073709551616        | 0x3bffffffffffffffff            \
    \   |\n   |                              |                                   \
    \ |\n   | -18446744073709551617        | 0xc349010000000000000000           |\n\
    \   |                              |                                    |\n  \
    \ | -1                           | 0x20                               |\n   |\
    \                              |                                    |\n   | -10\
    \                          | 0x29                               |\n   |      \
    \                        |                                    |\n   | -100   \
    \                      | 0x3863                             |\n   |          \
    \                    |                                    |\n   | -1000      \
    \                  | 0x3903e7                           |\n   |              \
    \                |                                    |\n   | 0.0            \
    \              | 0xf90000                           |\n   |                  \
    \            |                                    |\n   | -0.0               \
    \          | 0xf98000                           |\n   |                      \
    \        |                                    |\n   | 1.0                    \
    \      | 0xf93c00                           |\n   |                          \
    \    |                                    |\n   | 1.1                        \
    \  | 0xfb3ff199999999999a               |\n   |                              |\
    \                                    |\n   | 1.5                          | 0xf93e00\
    \                           |\n   |                              |           \
    \                         |\n   | 65504.0                      | 0xf97bff    \
    \                       |\n   |                              |               \
    \                     |\n   | 100000.0                     | 0xfa47c35000    \
    \                   |\n   |                              |                   \
    \                 |\n   | 3.4028234663852886e+38       | 0xfa7f7fffff        \
    \               |\n   |                              |                       \
    \             |\n   | 1.0e+300                     | 0xfb7e37e43c8800759c    \
    \           |\n   |                              |                           \
    \         |\n   | 5.960464477539063e-8         | 0xf90001                    \
    \       |\n   |                              |                               \
    \     |\n   | 0.00006103515625             | 0xf90400                        \
    \   |\n   |                              |                                   \
    \ |\n   | -4.0                         | 0xf9c400                           |\n\
    \   |                              |                                    |\n  \
    \ | -4.1                         | 0xfbc010666666666666               |\n   |\
    \                              |                                    |\n   | Infinity\
    \                     | 0xf97c00                           |\n   |           \
    \                   |                                    |\n   | NaN         \
    \                 | 0xf97e00                           |\n   |               \
    \               |                                    |\n   | -Infinity       \
    \             | 0xf9fc00                           |\n   |                   \
    \           |                                    |\n   | Infinity            \
    \         | 0xfa7f800000                       |\n   |                       \
    \       |                                    |\n   | NaN                     \
    \     | 0xfa7fc00000                       |\n   |                           \
    \   |                                    |\n   | -Infinity                   \
    \ | 0xfaff800000                       |\n   |                              |\
    \                                    |\n   | Infinity                     | 0xfb7ff0000000000000\
    \               |\n   |                              |                       \
    \             |\n   | NaN                          | 0xfb7ff8000000000000    \
    \           |\n   |                              |                           \
    \         |\n   | -Infinity                    | 0xfbfff0000000000000        \
    \       |\n   |                              |                               \
    \     |\n   | false                        | 0xf4                            \
    \   |\n   |                              |                                   \
    \ |\n   | true                         | 0xf5                               |\n\
    \   |                              |                                    |\n  \
    \ | null                         | 0xf6                               |\n   |\
    \                              |                                    |\n   | undefined\
    \                    | 0xf7                               |\n   |            \
    \                  |                                    |\n   | simple(16)   \
    \                | 0xf0                               |\n   |                \
    \              |                                    |\n   | simple(24)       \
    \            | 0xf818                             |\n   |                    \
    \          |                                    |\n   | simple(255)          \
    \        | 0xf8ff                             |\n   |                        \
    \      |                                    |\n   | 0(\"2013-03-21T20:04:00Z\"\
    )    | 0xc074323031332d30332d32315432303a |\n   |                            \
    \  | 30343a30305a                       |\n   |                              |\
    \                                    |\n   | 1(1363896240)                | 0xc11a514b67b0\
    \                     |\n   |                              |                 \
    \                   |\n   | 1(1363896240.5)              | 0xc1fb41d452d9ec200000\
    \             |\n   |                              |                         \
    \           |\n   | 23(h'01020304')              | 0xd74401020304            \
    \         |\n   |                              |                             \
    \       |\n   | 24(h'6449455446')            | 0xd818456449455446            \
    \     |\n   |                              |                                 \
    \   |\n   | 32(\"http://www.example.com\") | 0xd82076687474703a2f2f7777772e6578\
    \ |\n   |                              | 616d706c652e636f6d                 |\n\
    \   |                              |                                    |\n  \
    \ | h''                          | 0x40                               |\n   |\
    \                              |                                    |\n   | h'01020304'\
    \                  | 0x4401020304                       |\n   |              \
    \                |                                    |\n   | \"\"           \
    \                | 0x60                               |\n   |                \
    \              |                                    |\n   | \"a\"            \
    \              | 0x6161                             |\n   |                  \
    \            |                                    |\n   | \"IETF\"           \
    \            | 0x6449455446                       |\n   |                    \
    \          |                                    |\n   | \"\\\"\\\\\"         \
    \              | 0x62225c                           |\n   |                  \
    \            |                                    |\n   | \"\\u00fc\"        \
    \             | 0x62c3bc                           |\n   |                   \
    \           |                                    |\n   | \"\\u6c34\"         \
    \            | 0x63e6b0b4                         |\n   |                    \
    \          |                                    |\n   | \"\\ud800\\udd51\"   \
    \            | 0x64f0908591                       |\n   |                    \
    \          |                                    |\n   | []                   \
    \        | 0x80                               |\n   |                        \
    \      |                                    |\n   | [1, 2, 3]                \
    \    | 0x83010203                         |\n   |                            \
    \  |                                    |\n   | [1, [2, 3], [4, 5]]          |\
    \ 0x8301820203820405                 |\n   |                              |  \
    \                                  |\n   | [1, 2, 3, 4, 5, 6, 7, 8, 9,  | 0x98190102030405060708090a0b0c0d0e\
    \ |\n   | 10, 11, 12, 13, 14, 15, 16,  | 0f101112131415161718181819         |\n\
    \   | 17, 18, 19, 20, 21, 22, 23,  |                                    |\n  \
    \ | 24, 25]                      |                                    |\n   |\
    \                              |                                    |\n   | {}\
    \                           | 0xa0                               |\n   |     \
    \                         |                                    |\n   | {1: 2,\
    \ 3: 4}                 | 0xa201020304                       |\n   |         \
    \                     |                                    |\n   | {\"a\": 1,\
    \ \"b\": [2, 3]}        | 0xa26161016162820203               |\n   |         \
    \                     |                                    |\n   | [\"a\", {\"\
    b\": \"c\"}]            | 0x826161a161626163                 |\n   |         \
    \                     |                                    |\n   | {\"a\": \"\
    A\", \"b\": \"B\", \"c\":    | 0xa5616161416162614261636143616461 |\n   | \"C\"\
    , \"d\": \"D\", \"e\": \"E\"}     | 4461656145                         |\n   |\
    \                              |                                    |\n   | (_\
    \ h'0102', h'030405')       | 0x5f42010243030405ff               |\n   |     \
    \                         |                                    |\n   | (_ \"strea\"\
    , \"ming\")          | 0x7f657374726561646d696e67ff       |\n   |            \
    \                  |                                    |\n   | [_ ]         \
    \                | 0x9fff                             |\n   |                \
    \              |                                    |\n   | [_ 1, [2, 3], [_ 4,\
    \ 5]]      | 0x9f018202039f0405ffff             |\n   |                      \
    \        |                                    |\n   | [_ 1, [2, 3], [4, 5]]  \
    \      | 0x9f01820203820405ff               |\n   |                          \
    \    |                                    |\n   | [1, [2, 3], [_ 4, 5]]      \
    \  | 0x83018202039f0405ff               |\n   |                              |\
    \                                    |\n   | [1, [_ 2, 3], [4, 5]]        | 0x83019f0203ff820405\
    \               |\n   |                              |                       \
    \             |\n   | [_ 1, 2, 3, 4, 5, 6, 7, 8,   | 0x9f0102030405060708090a0b0c0d0e0f\
    \ |\n   | 9, 10, 11, 12, 13, 14, 15,   | 101112131415161718181819ff         |\n\
    \   | 16, 17, 18, 19, 20, 21, 22,  |                                    |\n  \
    \ | 23, 24, 25]                  |                                    |\n   |\
    \                              |                                    |\n   | {_\
    \ \"a\": 1, \"b\": [_ 2, 3]}    | 0xbf61610161629f0203ffff           |\n   | \
    \                             |                                    |\n   | [\"\
    a\", {_ \"b\": \"c\"}]          | 0x826161bf61626163ff               |\n   | \
    \                             |                                    |\n   | {_\
    \ \"Fun\": true, \"Amt\": -2}   | 0xbf6346756ef563416d7421ff         |\n   +------------------------------+------------------------------------+\n\
    \               Table 4: Examples of Encoded CBOR Data Items\n"
- title: Appendix B.  Jump Table
  contents:
  - "Appendix B.  Jump Table\n   For brevity, this jump table does not show initial\
    \ bytes that are\n   reserved for future extension.  It also only shows a selection\
    \ of the\n   initial bytes that can be used for optional features.  (All unsigned\n\
    \   integers are in network byte order.)\n   +-----------------+-------------------------------------------------+\n\
    \   | Byte            | Structure/Semantics                             |\n  \
    \ +-----------------+-------------------------------------------------+\n   |\
    \ 0x00..0x17      | Integer 0x00..0x17 (0..23)                      |\n   |  \
    \               |                                                 |\n   | 0x18\
    \            | Unsigned integer (one-byte uint8_t follows)     |\n   |       \
    \          |                                                 |\n   | 0x19    \
    \        | Unsigned integer (two-byte uint16_t follows)    |\n   |           \
    \      |                                                 |\n   | 0x1a        \
    \    | Unsigned integer (four-byte uint32_t follows)   |\n   |               \
    \  |                                                 |\n   | 0x1b            |\
    \ Unsigned integer (eight-byte uint64_t follows)  |\n   |                 |  \
    \                                               |\n   | 0x20..0x37      | Negative\
    \ integer -1-0x00..-1-0x17 (-1..-24)     |\n   |                 |           \
    \                                      |\n   | 0x38            | Negative integer\
    \ -1-n (one-byte uint8_t for n   |\n   |                 | follows)          \
    \                              |\n   |                 |                     \
    \                            |\n   | 0x39            | Negative integer -1-n (two-byte\
    \ uint16_t for n  |\n   |                 | follows)                         \
    \               |\n   |                 |                                    \
    \             |\n   | 0x3a            | Negative integer -1-n (four-byte uint32_t\
    \ for n |\n   |                 | follows)                                   \
    \     |\n   |                 |                                              \
    \   |\n   | 0x3b            | Negative integer -1-n (eight-byte uint64_t for \
    \ |\n   |                 | n follows)                                      |\n\
    \   |                 |                                                 |\n  \
    \ | 0x40..0x57      | byte string (0x00..0x17 bytes follow)           |\n   |\
    \                 |                                                 |\n   | 0x58\
    \            | byte string (one-byte uint8_t for n, and then n |\n   |       \
    \          | bytes follow)                                   |\n   |         \
    \        |                                                 |\n   | 0x59      \
    \      | byte string (two-byte uint16_t for n, and then  |\n   |             \
    \    | n bytes follow)                                 |\n   |               \
    \  |                                                 |\n   | 0x5a            |\
    \ byte string (four-byte uint32_t for n, and then |\n   |                 | n\
    \ bytes follow)                                 |\n   |                 |    \
    \                                             |\n   | 0x5b            | byte string\
    \ (eight-byte uint64_t for n, and     |\n   |                 | then n bytes follow)\
    \                            |\n   |                 |                       \
    \                          |\n   | 0x5f            | byte string, byte strings\
    \ follow, terminated by |\n   |                 | \"break\"                  \
    \                       |\n   |                 |                            \
    \                     |\n   | 0x60..0x77      | UTF-8 string (0x00..0x17 bytes\
    \ follow)          |\n   |                 |                                 \
    \                |\n   | 0x78            | UTF-8 string (one-byte uint8_t for\
    \ n, and then  |\n   |                 | n bytes follow)                     \
    \            |\n   |                 |                                       \
    \          |\n   | 0x79            | UTF-8 string (two-byte uint16_t for n, and\
    \ then |\n   |                 | n bytes follow)                             \
    \    |\n   |                 |                                               \
    \  |\n   | 0x7a            | UTF-8 string (four-byte uint32_t for n, and     |\n\
    \   |                 | then n bytes follow)                            |\n  \
    \ |                 |                                                 |\n   |\
    \ 0x7b            | UTF-8 string (eight-byte uint64_t for n, and    |\n   |  \
    \               | then n bytes follow)                            |\n   |    \
    \             |                                                 |\n   | 0x7f \
    \           | UTF-8 string, UTF-8 strings follow, terminated  |\n   |        \
    \         | by \"break\"                                      |\n   |        \
    \         |                                                 |\n   | 0x80..0x97\
    \      | array (0x00..0x17 data items follow)            |\n   |             \
    \    |                                                 |\n   | 0x98          \
    \  | array (one-byte uint8_t for n, and then n data  |\n   |                 |\
    \ items follow)                                   |\n   |                 |  \
    \                                               |\n   | 0x99            | array\
    \ (two-byte uint16_t for n, and then n data |\n   |                 | items follow)\
    \                                   |\n   |                 |                \
    \                                 |\n   | 0x9a            | array (four-byte uint32_t\
    \ for n, and then n     |\n   |                 | data items follow)         \
    \                     |\n   |                 |                              \
    \                   |\n   | 0x9b            | array (eight-byte uint64_t for n,\
    \ and then n    |\n   |                 | data items follow)                 \
    \             |\n   |                 |                                      \
    \           |\n   | 0x9f            | array, data items follow, terminated by\
    \ \"break\" |\n   |                 |                                        \
    \         |\n   | 0xa0..0xb7      | map (0x00..0x17 pairs of data items follow)\
    \     |\n   |                 |                                              \
    \   |\n   | 0xb8            | map (one-byte uint8_t for n, and then n pairs  \
    \ |\n   |                 | of data items follow)                           |\n\
    \   |                 |                                                 |\n  \
    \ | 0xb9            | map (two-byte uint16_t for n, and then n pairs  |\n   |\
    \                 | of data items follow)                           |\n   |  \
    \               |                                                 |\n   | 0xba\
    \            | map (four-byte uint32_t for n, and then n pairs |\n   |       \
    \          | of data items follow)                           |\n   |         \
    \        |                                                 |\n   | 0xbb      \
    \      | map (eight-byte uint64_t for n, and then n      |\n   |             \
    \    | pairs of data items follow)                     |\n   |               \
    \  |                                                 |\n   | 0xbf            |\
    \ map, pairs of data items follow, terminated by  |\n   |                 | \"\
    break\"                                         |\n   |                 |    \
    \                                             |\n   | 0xc0            | Text-based\
    \ date/time (data item follows; see    |\n   |                 | Section 2.4.1)\
    \                                  |\n   |                 |                 \
    \                                |\n   | 0xc1            | Epoch-based date/time\
    \ (data item follows; see   |\n   |                 | Section 2.4.1)         \
    \                         |\n   |                 |                          \
    \                       |\n   | 0xc2            | Positive bignum (data item \"\
    byte string\"        |\n   |                 | follows)                      \
    \                  |\n   |                 |                                 \
    \                |\n   | 0xc3            | Negative bignum (data item \"byte string\"\
    \        |\n   |                 | follows)                                  \
    \      |\n   |                 |                                             \
    \    |\n   | 0xc4            | Decimal Fraction (data item \"array\" follows;\
    \    |\n   |                 | see Section 2.4.3)                            \
    \  |\n   |                 |                                                 |\n\
    \   | 0xc5            | Bigfloat (data item \"array\" follows; see        |\n\
    \   |                 | Section 2.4.3)                                  |\n  \
    \ |                 |                                                 |\n   |\
    \ 0xc6..0xd4      | (tagged item)                                   |\n   |  \
    \               |                                                 |\n   | 0xd5..0xd7\
    \      | Expected Conversion (data item follows; see     |\n   |             \
    \    | Section 2.4.4.2)                                |\n   |               \
    \  |                                                 |\n   | 0xd8..0xdb      |\
    \ (more tagged items, 1/2/4/8 bytes and then a    |\n   |                 | data\
    \ item follow)                               |\n   |                 |       \
    \                                          |\n   | 0xe0..0xf3      | (simple value)\
    \                                  |\n   |                 |                 \
    \                                |\n   | 0xf4            | False             \
    \                              |\n   |                 |                     \
    \                            |\n   | 0xf5            | True                  \
    \                          |\n   |                 |                         \
    \                        |\n   | 0xf6            | Null                      \
    \                      |\n   |                 |                             \
    \                    |\n   | 0xf7            | Undefined                     \
    \                  |\n   |                 |                                 \
    \                |\n   | 0xf8            | (simple value, one byte follows)  \
    \              |\n   |                 |                                     \
    \            |\n   | 0xf9            | Half-Precision Float (two-byte IEEE 754)\
    \        |\n   |                 |                                           \
    \      |\n   | 0xfa            | Single-Precision Float (four-byte IEEE 754) \
    \    |\n   |                 |                                               \
    \  |\n   | 0xfb            | Double-Precision Float (eight-byte IEEE 754)    |\n\
    \   |                 |                                                 |\n  \
    \ | 0xff            | \"break\" stop code                               |\n  \
    \ +-----------------+-------------------------------------------------+\n    \
    \               Table 5: Jump Table for Initial Byte\n"
- title: Appendix C.  Pseudocode
  contents:
  - "Appendix C.  Pseudocode\n   The well-formedness of a CBOR item can be checked\
    \ by the pseudocode\n   in Figure 1.  The data is well-formed if and only if:\n\
    \   o  the pseudocode does not \"fail\";\n   o  after execution of the pseudocode,\
    \ no bytes are left in the input\n      (except in streaming applications)\n \
    \  The pseudocode has the following prerequisites:\n   o  take(n) reads n bytes\
    \ from the input data and returns them as a\n      byte string.  If n bytes are\
    \ no longer available, take(n) fails.\n   o  uint() converts a byte string into\
    \ an unsigned integer by\n      interpreting the byte string in network byte order.\n\
    \   o  Arithmetic works as in C.\n   o  All variables are unsigned integers of\
    \ sufficient range.\n   well_formed (breakable = false) {\n     // process initial\
    \ bytes\n     ib = uint(take(1));\n     mt = ib >> 5;\n     val = ai = ib & 0x1f;\n\
    \     switch (ai) {\n       case 24: val = uint(take(1)); break;\n       case\
    \ 25: val = uint(take(2)); break;\n       case 26: val = uint(take(4)); break;\n\
    \       case 27: val = uint(take(8)); break;\n       case 28: case 29: case 30:\
    \ fail();\n       case 31:\n         return well_formed_indefinite(mt, breakable);\n\
    \     }\n     // process content\n     switch (mt) {\n       // case 0, 1, 7 do\
    \ not have content; just use val\n       case 2: case 3: take(val); break; //\
    \ bytes/UTF-8\n       case 4: for (i = 0; i < val; i++) well_formed(); break;\n\
    \       case 5: for (i = 0; i < val*2; i++) well_formed(); break;\n       case\
    \ 6: well_formed(); break;     // 1 embedded data item\n     }\n     return mt;\
    \                    // finite data item\n   }\n   well_formed_indefinite(mt,\
    \ breakable) {\n     switch (mt) {\n       case 2: case 3:\n         while ((it\
    \ = well_formed(true)) != -1)\n           if (it != mt)           // need finite\
    \ embedded\n             fail();               //    of same type\n         break;\n\
    \       case 4: while (well_formed(true) != -1); break;\n       case 5: while\
    \ (well_formed(true) != -1) well_formed(); break;\n       case 7:\n         if\
    \ (breakable)\n           return -1;              // signal break out\n      \
    \   else fail();              // no enclosing indefinite\n       default: fail();\
    \            // wrong mt\n     }\n     return 0;                     // no break\
    \ out\n   }\n              Figure 1: Pseudocode for Well-Formedness Check\n  \
    \ Note that the remaining complexity of a complete CBOR decoder is\n   about presenting\
    \ data that has been parsed to the application in an\n   appropriate form.\n \
    \  Major types 0 and 1 are designed in such a way that they can be\n   encoded\
    \ in C from a signed integer without actually doing an if-then-\n   else for positive/negative\
    \ (Figure 2).  This uses the fact that\n   (-1-n), the transformation for major\
    \ type 1, is the same as ~n\n   (bitwise complement) in C unsigned arithmetic;\
    \ ~n can then be\n   expressed as (-1)^n for the negative case, while 0^n leaves\
    \ n\n   unchanged for non-negative.  The sign of a number can be converted to\n\
    \   -1 for negative and 0 for non-negative (0 or positive) by arithmetic-\n  \
    \ shifting the number by one bit less than the bit length of the number\n   (for\
    \ example, by 63 for 64-bit numbers).\n   void encode_sint(int64_t n) {\n    \
    \ uint64t ui = n >> 63;    // extend sign to whole length\n     mt = ui & 0x20;\
    \          // extract major type\n     ui ^= n;                 // complement\
    \ negatives\n     if (ui < 24)\n       *p++ = mt + ui;\n     else if (ui < 256)\
    \ {\n       *p++ = mt + 24;\n       *p++ = ui;\n     } else\n          ...\n \
    \           Figure 2: Pseudocode for Encoding a Signed Integer\n"
- title: Appendix D.  Half-Precision
  contents:
  - "Appendix D.  Half-Precision\n   As half-precision floating-point numbers were\
    \ only added to IEEE 754\n   in 2008, today's programming platforms often still\
    \ only have limited\n   support for them.  It is very easy to include at least\
    \ decoding\n   support for them even without such support.  An example of a small\n\
    \   decoder for half-precision floating-point numbers in the C language\n   is\
    \ shown in Figure 3.  A similar program for Python is in Figure 4;\n   this code\
    \ assumes that the 2-byte value has already been decoded as\n   an (unsigned short)\
    \ integer in network byte order (as would be done\n   by the pseudocode in Appendix\
    \ C).\n   #include <math.h>\n   double decode_half(unsigned char *halfp) {\n \
    \    int half = (halfp[0] << 8) + halfp[1];\n     int exp = (half >> 10) & 0x1f;\n\
    \     int mant = half & 0x3ff;\n     double val;\n     if (exp == 0) val = ldexp(mant,\
    \ -24);\n     else if (exp != 31) val = ldexp(mant + 1024, exp - 25);\n     else\
    \ val = mant == 0 ? INFINITY : NAN;\n     return half & 0x8000 ? -val : val;\n\
    \   }\n               Figure 3: C Code for a Half-Precision Decoder\n   import\
    \ struct\n   from math import ldexp\n   def decode_single(single):\n       return\
    \ struct.unpack(\"!f\", struct.pack(\"!I\", single))[0]\n   def decode_half(half):\n\
    \       valu = (half & 0x7fff) << 13 | (half & 0x8000) << 16\n       if ((half\
    \ & 0x7c00) != 0x7c00):\n           return ldexp(decode_single(valu), 112)\n \
    \      return decode_single(valu | 0x7f800000)\n            Figure 4: Python Code\
    \ for a Half-Precision Decoder\n"
- title: Appendix E.  Comparison of Other Binary Formats to CBOR's Design
  contents:
  - "Appendix E.  Comparison of Other Binary Formats to CBOR's Design\n          \
    \   Objectives\n   The proposal for CBOR follows a history of binary formats that\
    \ is as\n   long as the history of computers themselves.  Different formats have\n\
    \   had different objectives.  In most cases, the objectives of the\n   format\
    \ were never stated, although they can sometimes be implied by\n   the context\
    \ where the format was first used.  Some formats were meant\n   to be universally\
    \ usable, although history has proven that no binary\n   format meets the needs\
    \ of all protocols and applications.\n   CBOR differs from many of these formats\
    \ due to it starting with a set\n   of objectives and attempting to meet just\
    \ those.  This section\n   compares a few of the dozens of formats with CBOR's\
    \ objectives in\n   order to help the reader decide if they want to use CBOR or\
    \ a\n   different format for a particular protocol or application.\n   Note that\
    \ the discussion here is not meant to be a criticism of any\n   format: to the\
    \ best of our knowledge, no format before CBOR was meant\n   to cover CBOR's objectives\
    \ in the priority we have assigned them.  A\n   brief recap of the objectives\
    \ from Section 1.1 is:\n   1.  unambiguous encoding of most common data formats\
    \ from Internet\n       standards\n   2.  code compactness for encoder or decoder\n\
    \   3.  no schema description needed\n   4.  reasonably compact serialization\n\
    \   5.  applicability to constrained and unconstrained applications\n   6.  good\
    \ JSON conversion\n   7.  extensibility\n"
- title: E.1.  ASN.1 DER, BER, and PER
  contents:
  - "E.1.  ASN.1 DER, BER, and PER\n   [ASN.1] has many serializations.  In the IETF,\
    \ DER and BER are the\n   most common.  The serialized output is not particularly\
    \ compact for\n   many items, and the code needed to decode numeric items can\
    \ be\n   complex on a constrained device.\n   Few (if any) IETF protocols have\
    \ adopted one of the several variants\n   of Packed Encoding Rules (PER).  There\
    \ could be many reasons for\n   this, but one that is commonly stated is that\
    \ PER makes use of the\n   schema even for parsing the surface structure of the\
    \ data stream,\n   requiring significant tool support.  There are different versions\
    \ of\n   the ASN.1 schema language in use, which has also hampered adoption.\n"
- title: E.2.  MessagePack
  contents:
  - "E.2.  MessagePack\n   [MessagePack] is a concise, widely implemented counted\
    \ binary\n   serialization format, similar in many properties to CBOR, although\n\
    \   somewhat less regular.  While the data model can be used to represent\n  \
    \ JSON data, MessagePack has also been used in many remote procedure\n   call\
    \ (RPC) applications and for long-term storage of data.\n   MessagePack has been\
    \ essentially stable since it was first published\n   around 2011; it has not\
    \ yet had a transition.  The evolution of\n   MessagePack is impeded by an imperative\
    \ to maintain complete\n   backwards compatibility with existing stored data,\
    \ while only few\n   bytecodes are still available for extension.  Repeated requests\
    \ over\n   the years from the MessagePack user community to separate out binary\n\
    \   and text strings in the encoding recently have led to an extension\n   proposal\
    \ that would leave MessagePack's \"raw\" data ambiguous between\n   its usages\
    \ for binary and text data.  The extension mechanism for\n   MessagePack remains\
    \ unclear.\n"
- title: E.3.  BSON
  contents:
  - "E.3.  BSON\n   [BSON] is a data format that was developed for the storage of\
    \ JSON-\n   like maps (JSON objects) in the MongoDB database.  Its major\n   distinguishing\
    \ feature is the capability for in-place update,\n   foregoing a compact representation.\
    \  BSON uses a counted\n   representation except for map keys, which are null-byte\
    \ terminated.\n   While BSON can be used for the representation of JSON-like objects\
    \ on\n   the wire, its specification is dominated by the requirements of the\n\
    \   database application and has become somewhat baroque.  The status of\n   how\
    \ BSON extensions will be implemented remains unclear.\n"
- title: E.4.  UBJSON
  contents:
  - "E.4.  UBJSON\n   [UBJSON] has a design goal to make JSON faster and somewhat\
    \ smaller,\n   using a binary format that is limited to exactly the data model\
    \ JSON\n   uses.  Thus, there is expressly no intention to support, for example,\n\
    \   binary data; however, there is a \"high-precision number\", expressed\n  \
    \ as a character string in JSON syntax.  UBJSON is not optimized for\n   code\
    \ compactness, and its type byte coding is optimized for human\n   recognition\
    \ and not for compact representation of native types such\n   as small integers.\
    \  Although UBJSON is mostly counted, it provides a\n   reserved \"unknown-length\"\
    \ value to support streaming of arrays and\n   maps (JSON objects).  Within these\
    \ containers, UBJSON also has a\n   \"Noop\" type for padding.\n"
- title: 'E.5.  MSDTP: RFC 713'
  contents:
  - "E.5.  MSDTP: RFC 713\n   Message Services Data Transmission (MSDTP) is a very\
    \ early example of\n   a compact message format; it is described in [RFC0713],\
    \ written in\n   1976.  It is included here for its historical value, not because\
    \ it\n   was ever widely used.\n"
- title: E.6.  Conciseness on the Wire
  contents:
  - "E.6.  Conciseness on the Wire\n   While CBOR's design objective of code compactness\
    \ for encoders and\n   decoders is a higher priority than its objective of conciseness\
    \ on\n   the wire, many people focus on the wire size.  Table 6 shows some\n \
    \  encoding examples for the simple nested array [1, [2, 3]]; where some\n   form\
    \ of indefinite-length encoding is supported by the encoding,\n   [_ 1, [2, 3]]\
    \ (indefinite length on the outer array) is also shown.\n   +---------------+-------------------------+-------------------------+\n\
    \   | Format        | [1, [2, 3]]             | [_ 1, [2, 3]]           |\n  \
    \ +---------------+-------------------------+-------------------------+\n   |\
    \ RFC 713       | c2 05 81 c2 02 82 83    |                         |\n   |  \
    \             |                         |                         |\n   | ASN.1\
    \ BER     | 30 0b 02 01 01 30 06 02 | 30 80 02 01 01 30 06 02 |\n   |        \
    \       | 01 02 02 01 03          | 01 02 02 01 03 00 00    |\n   |          \
    \     |                         |                         |\n   | MessagePack\
    \   | 92 01 92 02 03          |                         |\n   |              \
    \ |                         |                         |\n   | BSON          |\
    \ 22 00 00 00 10 30 00 01 |                         |\n   |               | 00\
    \ 00 00 04 31 00 13 00 |                         |\n   |               | 00 00\
    \ 10 30 00 02 00 00 |                         |\n   |               | 00 10 31\
    \ 00 03 00 00 00 |                         |\n   |               | 00 00     \
    \              |                         |\n   |               |             \
    \            |                         |\n   | UBJSON        | 61 02 42 01 61\
    \ 02 42 02 | 61 ff 42 01 61 02 42 02 |\n   |               | 42 03           \
    \        | 42 03 45                |\n   |               |                   \
    \      |                         |\n   | CBOR          | 82 01 82 02 03      \
    \    | 9f 01 82 02 03 ff       |\n   +---------------+-------------------------+-------------------------+\n\
    \           Table 6: Examples for Different Levels of Conciseness\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Carsten Bormann\n   Universitaet Bremen TZI\n   Postfach\
    \ 330440\n   D-28359 Bremen\n   Germany\n   Phone: +49-421-218-63921\n   EMail:\
    \ cabo@tzi.org\n   Paul Hoffman\n   VPN Consortium\n   EMail: paul.hoffman@vpnc.org\n"
