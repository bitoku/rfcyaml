- contents:
  - '                 Public Key Pinning Extension for HTTP

    '
  title: __initial_text__
- contents:
  - "Abstract\n   This document defines a new HTTP header that allows web host\n   operators
    to instruct user agents to remember (\"pin\") the hosts'\n   cryptographic identities
    over a period of time.  During that time,\n   user agents (UAs) will require that
    the host presents a certificate\n   chain including at least one Subject Public
    Key Info structure whose\n   fingerprint matches one of the pinned fingerprints
    for that host.  By\n   effectively reducing the number of trusted authorities
    who can\n   authenticate the domain during the lifetime of the pin, pinning may\n
    \  reduce the incidence of man-in-the-middle attacks due to compromised\n   Certification
    Authorities.\n"
  title: Abstract
- contents:
  - "Status of This Memo\n   This is an Internet Standards Track document.\n   This
    document is a product of the Internet Engineering Task Force\n   (IETF).  It represents
    the consensus of the IETF community.  It has\n   received public review and has
    been approved for publication by the\n   Internet Engineering Steering Group (IESG).
    \ Further information on\n   Internet Standards is available in Section 2 of RFC
    5741.\n   Information about the current status of this document, any errata,\n
    \  and how to provide feedback on it may be obtained at\n   http://www.rfc-editor.org/info/rfc7469.\n"
  title: Status of This Memo
- contents:
  - "Copyright Notice\n   Copyright (c) 2015 IETF Trust and the persons identified
    as the\n   document authors.  All rights reserved.\n   This document is subject
    to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n
    \  (http://trustee.ietf.org/license-info) in effect on the date of\n   publication
    of this document.  Please review these documents\n   carefully, as they describe
    your rights and restrictions with respect\n   to this document.  Code Components
    extracted from this document must\n   include Simplified BSD License text as described
    in Section 4.e of\n   the Trust Legal Provisions and are provided without warranty
    as\n   described in the Simplified BSD License.\n"
  title: Copyright Notice
- contents:
  - "Table of Contents\n   1.  Introduction  . . . . . . . . . . . . . . . . . . .
    . . . . .   4\n     1.1.  Requirements Language . . . . . . . . . . . . . . .
    . . .   5\n   2.  Server and Client Behavior  . . . . . . . . . . . . . . . .
    .   5\n     2.1.  Response Header Field Syntax  . . . . . . . . . . . . . .   5\n
    \      2.1.1.  The Pin Directive . . . . . . . . . . . . . . . . . .   6\n       2.1.2.
    \ The max-age Directive . . . . . . . . . . . . . . . .   7\n       2.1.3.  The
    includeSubDomains Directive . . . . . . . . . . .   7\n       2.1.4.  The report-uri
    Directive  . . . . . . . . . . . . . .   7\n       2.1.5.  Examples  . . . . .
    . . . . . . . . . . . . . . . . .   8\n     2.2.  Server Processing Model . .
    . . . . . . . . . . . . . . .   9\n       2.2.1.  HTTP-over-Secure-Transport Request
    Type . . . . . . .   9\n       2.2.2.  HTTP Request Type . . . . . . . . . . .
    . . . . . . .   9\n     2.3.  User Agent Processing Model . . . . . . . . . .
    . . . . .  10\n       2.3.1.  Public-Key-Pins Response Header Field Processing
    \ . .  10\n       2.3.2.  Interaction of Public-Key-Pins and Public-Key-Pins-\n
    \              Report-Only . . . . . . . . . . . . . . . . . . . . .  11\n       2.3.3.
    \ Noting a Pinned Host - Storage Model  . . . . . . . .  11\n       2.3.4.  HTTP-Equiv
    <Meta> Element Attribute . . . . . . . . .  13\n     2.4.  Semantics of Pins .
    . . . . . . . . . . . . . . . . . . .  13\n     2.5.  Noting Pins . . . . . .
    . . . . . . . . . . . . . . . . .  14\n     2.6.  Validating Pinned Connections
    . . . . . . . . . . . . . .  15\n     2.7.  Interactions with Preloaded Pin Lists
    . . . . . . . . . .  16\n     2.8.  Pinning Self-Signed End Entities  . . . .
    . . . . . . . .  16\n   3.  Reporting Pin Validation Failure  . . . . . . . .
    . . . . . .  16\n   4.  Security Considerations . . . . . . . . . . . . . . .
    . . . .  19\n     4.1.  Maximum max-age . . . . . . . . . . . . . . . . . . .
    . .  19\n     4.2.  Using includeSubDomains Safely  . . . . . . . . . . . . .
    \ 20\n     4.3.  Backup Pins . . . . . . . . . . . . . . . . . . . . . . .  21\n
    \    4.4.  Interactions With Cookie Scoping  . . . . . . . . . . . .  21\n     4.5.
    \ Hostile Pinning . . . . . . . . . . . . . . . . . . . . .  21\n   5.  Privacy
    Considerations  . . . . . . . . . . . . . . . . . . .  22\n   6.  IANA Considerations
    . . . . . . . . . . . . . . . . . . . . .  24\n   7.  Usability Considerations
    \ . . . . . . . . . . . . . . . . . .  24\n   8.  References  . . . . . . . .
    . . . . . . . . . . . . . . . . .  24\n     8.1.  Normative References  . . .
    . . . . . . . . . . . . . . .  24\n     8.2.  Informative References  . . . .
    . . . . . . . . . . . . .  26\n   Appendix A.  Fingerprint Generation . . . .
    . . . . . . . . . . .  27\n   Appendix B.  Deployment Guidance  . . . . . . .
    . . . . . . . . .  27\n   Acknowledgements  . . . . . . . . . . . . . . . . .
    . . . . . . .  28\n   Authors' Addresses  . . . . . . . . . . . . . . . . . .
    . . . . .  28\n"
  title: Table of Contents
- contents:
  - "1.  Introduction\n   This document defines a new HTTP header that enables UAs
    to determine\n   which Subject Public Key Info (SPKI) structures will be present
    in a\n   web host's certificate chain in future Transport Layer Security (TLS)\n
    \  [RFC5246] connections.\n   Deploying Public Key Pinning (PKP) safely will require
    operational\n   and organizational maturity due to the risk that hosts may make\n
    \  themselves unavailable by pinning to a set of SPKIs that becomes\n   invalid
    (see Section 4).  With care, host operators can greatly\n   reduce the risk of
    man-in-the-middle (MITM) attacks and other false-\n   authentication problems
    for their users without incurring undue risk.\n   PKP is meant to be used together
    with HTTP Strict Transport Security\n   (HSTS) [RFC6797], but it is possible to
    pin keys without requiring\n   HSTS.\n   A Pin is a relationship between a hostname
    and a cryptographic\n   identity (in this document, one or more of the public
    keys in a chain\n   of X.509 certificates).  Pin Validation is the process a UA
    performs\n   to ensure that a host is in fact authenticated with its previously\n
    \  established Pin.\n   Key pinning is a trust-on-first-use (TOFU) mechanism.
    \ The first time\n   a UA connects to a host, it lacks the information necessary
    to\n   perform Pin Validation; UAs can only apply their normal cryptographic\n
    \  identity validation.  (In this document, it is assumed that UAs apply\n   X.509
    certificate chain validation in accord with [RFC5280].)\n   The UA will not be
    able to detect and thwart a MITM attacking the\n   UA's first connection to the
    host.  (However, the requirement that\n   the MITM provide an X.509 certificate
    chain that can pass the UA's\n   validation requirements, without error, mitigates
    this risk\n   somewhat.)  Worse, such a MITM can inject its own PKP header into
    the\n   HTTP stream, and pin the UA to its own keys.  To avoid post facto\n   detection,
    the attacker would have to be in a position to intercept\n   all future requests
    to the host from that UA.\n   Thus, key pinning as described in this document
    is not a perfect\n   defense against MITM attackers capable of passing certificate
    chain\n   validation procedures -- nothing short of pre-shared keys can be.\n
    \  However, it provides significant value by allowing host operators to\n   limit
    the number of certification authorities that can vouch for the\n   host's identity,
    and allows UAs to detect in-process MITM attacks\n   after the initial communication.\n"
  - contents:
    - "1.1.  Requirements Language\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\",
      \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\",
      and \"OPTIONAL\" in this\n   document are to be interpreted as described in
      RFC 2119 [RFC2119].\n"
    title: 1.1.  Requirements Language
  title: 1.  Introduction
- contents:
  - '2.  Server and Client Behavior

    '
  - contents:
    - "2.1.  Response Header Field Syntax\n   The \"Public-Key-Pins\" and \"Public-Key-Pins-Report-Only\"
      header\n   fields, also referred to within this specification as the PKP and\n
      \  PKP-RO header fields, respectively, are new response headers defined\n   in
      this specification.  They are used by a server to indicate that a\n   UA should
      perform Pin Validation (Section 2.6) for the host emitting\n   the response
      message, and to provide the necessary information for\n   the UA to do so.\n
      \  Figure 1 describes the syntax (Augmented Backus-Naur Form) of the\n   header
      fields, using the grammar defined in [RFC5234] and the rules\n   defined in
      Section 3.2 of [RFC7230].  The field values of both header\n   fields conform
      to the same rules.\n   Public-Key-Directives = directive *( OWS \";\" OWS directive
      )\n   directive             = directive-name [ \"=\" directive-value ]\n   directive-name
      \       = token\n   directive-value       = token\n                         /
      quoted-string\n                       Figure 1: HPKP Header Syntax\n   Optional
      white space (OWS) is used as defined in Section 3.2.3 of\n   [RFC7230]. token
      and quoted-string are used as defined in\n   Section 3.2.6 of [RFC7230].\n   The
      directives defined in this specification are described below.\n   The overall
      requirements for directives are:\n   1.  The order of appearance of directives
      is not significant.\n   2.  With the exception of pin-directives with the same
      pin-directive-\n       name (see below), a given directive MUST NOT appear more
      than\n       once in a given header field.  Directives are either optional or\n
      \      required, as stipulated in their definitions.\n   3.  Directive names
      are case insensitive.\n   4.  UAs MUST ignore any header fields containing directives,
      or other\n       header field value data, that do not conform to the syntax\n
      \      defined in this specification.  In particular, UAs must not\n       attempt
      to fix malformed header fields.\n   5.  If a header field contains any directive(s)
      the UA does not\n       recognize, the UA MUST ignore those directives.\n   6.
      \ If the PKP or PKP-RO header field otherwise satisfies the above\n       requirements
      (1 through 5), the UA MUST process the directives it\n       recognizes.\n   Additional
      directives extending the semantic functionality of the\n   header fields can
      be defined in other specifications.  The first such\n   specification will need
      to define a registry for such directives.\n   Such future directives will be
      ignored by UAs implementing only this\n   specification, as well as by generally
      non-conforming UAs.\n   When a connection passes Pin Validation using the UA's
      noted Pins for\n   the host at the time, the host becomes a Known Pinned Host.\n"
    - contents:
      - "2.1.1.  The Pin Directive\n   The pin directive specifies a way for web host
        operators to indicate\n   a cryptographic identity that should be bound to
        a given web host.\n   The syntax of a pin directive is as follows:\n   pin-directive
        \      = pin-directive-name \"=\" pin-directive-value\n   pin-directive-name
        \ = \"pin-\" token\n   pin-directive-value = quoted-string\n                      Figure
        2: Pin Directive Syntax\n   In the pin-directive, the token is the name of
        a cryptographic hash\n   algorithm.  The only algorithm allowed at this time
        is \"sha256\",\n   i.e., the hash algorithm SHA256 [RFC6234]; additional algorithms
        may\n   be allowed for use in this context in the future.  The quoted-string\n
        \  is a sequence of base 64 digits: the base64-encoded SPKI Fingerprint\n
        \  [RFC4648] (see Section 2.4).\n   According to the processing rules of Section
        2.1, the UA MUST ignore\n   pin-directives with tokens naming hash algorithms
        it does not\n   recognize.  If the set of remaining effective pin-directives
        is\n   empty, and if the host is a Known Pinned Host, the UA MUST cease to\n
        \  consider the host as a Known Pinned Host (the UA should fail open).\n   The
        UA should indicate to users that the host is no longer a Known\n   Pinned
        Host.\n   Note, per the processing rules of Section 2.1, the pin-directive-name\n
        \  is case insensitive.\n"
      title: 2.1.1.  The Pin Directive
    - contents:
      - "2.1.2.  The max-age Directive\n   The \"max-age\" directive specifies the
        number of seconds after the\n   reception of the PKP header field during which
        the UA SHOULD regard\n   the host (from whom the message was received) as
        a Known Pinned Host.\n   The \"max-age\" directive is REQUIRED to be present
        within a \"Public-\n   Key-Pins\" header field.  The \"max-age\" directive
        is meaningless\n   within a \"Public-Key-Pins-Report-Only\" header field,
        and UAs MUST\n   ignore it and not cache the header.  See Section 2.3.3.\n
        \  The max-age directive is REQUIRED to have a directive value, for\n   which
        the syntax (after quoted-string unescaping, if necessary) is\n   defined as:\n
        \  max-age-value = delta-seconds\n   delta-seconds = 1*DIGIT\n                      Figure
        3: max-age Value Syntax\n   delta-seconds is used as defined in [RFC7234],
        Section 1.2.1.\n   See Section 2.3.3 for limitations on the range of values
        for max-age.\n"
      title: 2.1.2.  The max-age Directive
    - contents:
      - "2.1.3.  The includeSubDomains Directive\n   The OPTIONAL includeSubDomains
        directive is a valueless directive\n   that, if present (i.e., it is \"asserted\"),
        signals to the UA that the\n   Pinning Policy applies to this Pinned Host
        as well as any subdomains\n   of the host's domain name.\n"
      title: 2.1.3.  The includeSubDomains Directive
    - contents:
      - "2.1.4.  The report-uri Directive\n   The OPTIONAL report-uri directive indicates
        the URI to which the UA\n   SHOULD report Pin Validation failures (Section
        2.6).  The UA POSTs\n   the reports to the given URI as described in Section
        3.\n   When used in the PKP or PKP-RO headers, the presence of a report-uri\n
        \  directive indicates to the UA that in the event of Pin Validation\n   failure
        it SHOULD POST a report to the report-uri.  If the header is\n   Public-Key-Pins,
        the UA should do this in addition to terminating the\n   connection (as described
        in Section 2.6).\n   Hosts may set report-uris that use HTTP or HTTPS.  If
        the scheme in\n   the report-uri is one that uses TLS (e.g., HTTPS), UAs MUST
        perform\n   Pinning Validation when the host in the report-uri is a Known
        Pinned\n   Host; similarly, UAs MUST apply HSTS if the host in the report-uri
        is\n   a Known HSTS Host.\n   Note that the report-uri need not necessarily
        be in the same Internet\n   domain or web origin as the host being reported
        about.\n   UAs SHOULD make their best effort to report Pin Validation failures\n
        \  to the report-uri, but they may fail to report in exceptional\n   conditions.
        \ For example, if connecting the report-uri itself incurs\n   a Pinning Validation
        failure or other certificate validation failure,\n   the UA MUST cancel the
        connection.  Similarly, if Known Pinned Host A\n   sets a report-uri referring
        to Known Pinned Host B, and if B sets a\n   report-uri referring to A, and
        if both hosts fail Pin Validation, the\n   UA SHOULD detect and break the
        loop by failing to send reports to and\n   about those hosts.\n   In any case
        of report failure, the UA MAY attempt to re-send the\n   report later.\n   UAs
        SHOULD limit the rate at which they send reports.  For example,\n   it is
        unnecessary to send the same report to the same report-uri more\n   than once
        per distinct set of declared Pins.\n"
      title: 2.1.4.  The report-uri Directive
    - contents:
      - "2.1.5.  Examples\n   Figure 4 shows some example PKP and PKP-RO response
        header fields.\n   (Lines are folded to fit.)\n   Public-Key-Pins: max-age=3000;\n
        \      pin-sha256=\"d6qzRu9zOECb90Uez27xWltNsj0e1Md7GkYYkVoZWmM=\";\n       pin-sha256=\"E9CZ9INDbd+2eRQozYqqbQ2yXLVKB9+xcprMF+44U1g=\"\n
        \  Public-Key-Pins: max-age=2592000;\n       pin-sha256=\"E9CZ9INDbd+2eRQozYqqbQ2yXLVKB9+xcprMF+44U1g=\";\n
        \      pin-sha256=\"LPJNul+wow4m6DsqxbninhsWHlwfp0JecwQzYpOLmCQ=\"\n   Public-Key-Pins:
        max-age=2592000;\n       pin-sha256=\"E9CZ9INDbd+2eRQozYqqbQ2yXLVKB9+xcprMF+44U1g=\";\n
        \      pin-sha256=\"LPJNul+wow4m6DsqxbninhsWHlwfp0JecwQzYpOLmCQ=\";\n       report-uri=\"http://example.com/pkp-report\"\n
        \  Public-Key-Pins-Report-Only: max-age=2592000;\n       pin-sha256=\"E9CZ9INDbd+2eRQozYqqbQ2yXLVKB9+xcprMF+44U1g=\";\n
        \      pin-sha256=\"LPJNul+wow4m6DsqxbninhsWHlwfp0JecwQzYpOLmCQ=\";\n       report-uri=\"https://other.example.net/pkp-report\"\n
        \  Public-Key-Pins:\n       pin-sha256=\"d6qzRu9zOECb90Uez27xWltNsj0e1Md7GkYYkVoZWmM=\";\n
        \      pin-sha256=\"LPJNul+wow4m6DsqxbninhsWHlwfp0JecwQzYpOLmCQ=\";\n       max-age=259200\n
        \  Public-Key-Pins:\n       pin-sha256=\"d6qzRu9zOECb90Uez27xWltNsj0e1Md7GkYYkVoZWmM=\";\n
        \      pin-sha256=\"E9CZ9INDbd+2eRQozYqqbQ2yXLVKB9+xcprMF+44U1g=\";\n       pin-sha256=\"LPJNul+wow4m6DsqxbninhsWHlwfp0JecwQzYpOLmCQ=\";\n
        \      max-age=10000; includeSubDomains\n         Figure 4: HTTP Public Key
        Pinning (HPKP) Header Examples\n"
      title: 2.1.5.  Examples
    title: 2.1.  Response Header Field Syntax
  - contents:
    - "2.2.  Server Processing Model\n   This section describes the processing model
      that Pinned Hosts\n   implement.  The model has 2 parts: (1) the processing
      rules for HTTP\n   request messages received over a secure transport (e.g.,\n
      \  authenticated, non-anonymous TLS); and (2) the processing rules for\n   HTTP
      request messages received over non-secure transports, such as\n   TCP.\n"
    - contents:
      - "2.2.1.  HTTP-over-Secure-Transport Request Type\n   When replying to an HTTP
        request that was conveyed over a secure\n   transport, a Pinned Host SHOULD
        include in its response exactly one\n   PKP header field, exactly one PKP-RO
        header field, or one of each.\n   Each instance of either header field MUST
        satisfy the grammar\n   specified in Section 2.1.\n   Establishing a given
        host as a Known Pinned Host, in the context of a\n   given UA, is accomplished
        as follows:\n   1.  Over the HTTP protocol running over secure transport,
        by\n       correctly returning (per this specification) at least one valid\n
        \      PKP header field to the UA.\n   2.  Through other mechanisms, such
        as a client-side preloaded Known\n       Pinned Host List.\n"
      title: 2.2.1.  HTTP-over-Secure-Transport Request Type
    - contents:
      - "2.2.2.  HTTP Request Type\n   Pinned Hosts SHOULD NOT include the PKP header
        field in HTTP\n   responses conveyed over non-secure transport.  UAs MUST
        ignore any\n   PKP header received in an HTTP response conveyed over non-secure\n
        \  transport.\n"
      title: 2.2.2.  HTTP Request Type
    title: 2.2.  Server Processing Model
  - contents:
    - "2.3.  User Agent Processing Model\n   The UA processing model relies on parsing
      domain names.  Note that\n   internationalized domain names SHALL be canonicalized
      according to\n   the scheme in Section 10 of [RFC6797].\n"
    - contents:
      - "2.3.1.  Public-Key-Pins Response Header Field Processing\n   If the UA receives,
        over a secure transport, an HTTP response that\n   includes a PKP header field
        conforming to the grammar specified in\n   Section 2.1, and there are no underlying
        secure transport errors or\n   warnings (see Section 2.5), the UA MUST either:\n
        \  o  Note the host as a Known Pinned Host if it is not already so noted\n
        \     (see Section 2.3.3),\n   or,\n   o  Update the UA's cached information
        for the Known Pinned Host if\n      any of the max-age, includeSubDomains,
        or report-uri header field\n      value directives convey information different
        from that already\n      maintained by the UA.\n   The max-age value is essentially
        a \"time to live\" value relative to\n   the time of the most recent observation
        of the PKP header field.  If\n   the max-age header field value token has
        a value of 0, the UA MUST\n   remove its cached Pinning Policy information
        (including the\n   includeSubDomains directive, if asserted) if the Pinned
        Host is\n   Known, or, MUST NOT note this Pinned Host if it is not yet Known.\n
        \  If a UA receives more than one PKP header field or more than one PKP-\n
        \  RO header field in an HTTP response message over secure transport,\n   then
        the UA MUST process only the first PKP header field (if present)\n   and only
        the first PKP-RO header field (if present).\n   If the UA receives the HTTP
        response over insecure transport, or if\n   the PKP header is not a Valid
        Pinning Header (see Section 2.5), the\n   UA MUST ignore any present PKP header
        field(s).  Similarly, if the UA\n   receives the HTTP response over insecure
        transport, the UA MUST\n   ignore any present PKP-RO header field(s).  The
        UA MUST ignore any\n   PKP or PKP-RO header fields not conforming to the grammar
        specified\n   in Section 2.1.\n"
      title: 2.3.1.  Public-Key-Pins Response Header Field Processing
    - contents:
      - "2.3.2.  Interaction of Public-Key-Pins and Public-Key-Pins-Report-Only\n
        \  A server MAY set both the \"Public-Key-Pins\" and \"Public-Key-Pins-\n
        \  Report-Only\" headers simultaneously.  The headers do not interact\n   with
        one another, but the UA MUST process the PKP header and SHOULD\n   process
        both.\n   The headers are processed according to Section 2.3.1.\n   When the
        PKP-RO header is used with a report-uri, the UA SHOULD POST\n   reports for
        Pin Validation failures to the indicated report-uri,\n   although the UA MUST
        NOT enforce Pin Validation.  That is, in the\n   event of Pin Validation failure
        when the host has set the PKP-RO\n   header, the UA performs Pin Validation
        to check whether or not it\n   should POST a report, but not whether it should
        cause a connection\n   failure.\n   Note: There is no purpose to using the
        PKP-RO header without the\n   report-uri directive.  User Agents MAY discard
        such headers without\n   interpreting them further.\n   When the PKP header
        is used with a report-uri, the UA SHOULD POST\n   reports for Pin Validation
        failures to the indicated report-uri, as\n   well as enforce Pin Validation.\n
        \  If a host sets the PKP-RO header, the UA SHOULD note the Pins and\n   directives
        given in the PKP-RO header, ignoring any max-age\n   directive.  If the UA
        does note the Pins and directives in the PKP-RO\n   header, it SHOULD evaluate
        the specified policy and SHOULD report any\n   would-be Pin Validation failures
        that would occur if the report-only\n   policy were enforced.\n   If a host
        sets both the PKP header and the PKP-RO header, the UA MUST\n   note and enforce
        Pin Validation as specified by the PKP header, and\n   SHOULD process the
        Pins and directives given in the PKP-RO header.\n   If the UA does process
        the Pins and directives in the PKP-RO header,\n   it SHOULD evaluate the specified
        policy and SHOULD report any would-\n   be Pin Validation failures that would
        occur if the report-only policy\n   were enforced.\n"
      title: 2.3.2.  Interaction of Public-Key-Pins and Public-Key-Pins-Report-Only
    - contents:
      - "2.3.3.  Noting a Pinned Host - Storage Model\n   The Effective Pin Date of
        a Known Pinned Host is the time that the UA\n   observed a Valid Pinning Header
        for the host.  The Effective\n   Expiration Date of a Known Pinned Host is
        the Effective Pin Date plus\n   the max-age.  A Known Pinned Host is \"expired\"
        if the Effective\n   Expiration Date refers to a date in the past.  The UA
        MUST ignore any\n   expired Known Pinned Hosts in its cache.\n   For example,
        if a UA is beginning to perform Pin Validation for a\n   Known Pinned Host
        and finds that the cached pinning information for\n   the host indicates an
        Effective Expiration Date in the past, the UA\n   MUST NOT continue with Pin
        Validation for the host, and MUST consider\n   the host to no longer be a
        Known Pinned Host.\n   Known Pinned Hosts are identified only by domain names,
        and never IP\n   addresses.  If the substring matching the host production
        from the\n   Request-URI (of the message to which the host responded)\n   syntactically
        matches the IP-literal or IPv4address productions from\n   Section 3.2.2 of
        [RFC3986], then the UA MUST NOT note this host as a\n   Known Pinned Host.\n
        \  Otherwise, if the substring does not congruently match an existing\n   Known
        Pinned Host's domain name, per the matching procedure specified\n   in Section
        8.2 of [RFC6797], then the UA MUST add this host to the\n   Known Pinned Host
        cache.  The UA caches:\n   o  the Pinned Host's domain name,\n   o  the Effective
        Expiration Date, or enough information to calculate\n      it (the Effective
        Pin Date and the value of the max-age\n      directive),\n   o  whether or
        not the includeSubDomains directive is asserted, and\n   o  the value of the
        report-uri directive, if present.\n   If any other metadata from optional
        or future PKP header directives\n   are present in the Valid Pinning Header,
        and the UA understands them,\n   the UA MAY note them as well.\n   UAs MAY
        set an upper limit on the value of max-age, so that UAs that\n   have noted
        erroneous Pins (whether by accident or due to attack) have\n   some chance
        of recovering over time.  If the server sets a max-age\n   greater than the
        UA's upper limit, the UA MAY behave as if the server\n   set the max-age to
        the UA's upper limit.  For example, if the UA caps\n   max-age at 5,184,000
        seconds (60 days), and a Pinned Host sets a max-\n   age directive of 90 days
        in its Valid Pinning Header, the UA MAY\n   behave as if the max-age were
        effectively 60 days.  (One way to\n   achieve this behavior is for the UA
        to simply store a value of 60\n   days instead of the 90-day value provided
        by the Pinned Host.)  For\n   UA implementation guidance on how to select
        a maximum max-age, see\n   Section 4.1.\n   The UA MUST NOT modify any pinning
        metadata of any superdomain\n   matched Known Pinned Host.\n   The UA MUST
        NOT cache information derived from a PKP-RO header.\n   (PKP-RO headers are
        useful only at the time of receipt and\n   processing.)\n"
      title: 2.3.3.  Noting a Pinned Host - Storage Model
    - contents:
      - "2.3.4.  HTTP-Equiv <Meta> Element Attribute\n   UAs MUST NOT heed http-equiv=\"Public-Key-Pins\"
        or\n   http-equiv=\"Public-Key-Pins-Report-Only\" attribute settings on <meta>\n
        \  elements [W3C.REC-html401-19991224] in received content.\n"
      title: 2.3.4.  HTTP-Equiv <Meta> Element Attribute
    title: 2.3.  User Agent Processing Model
  - contents:
    - "2.4.  Semantics of Pins\n   An SPKI Fingerprint is defined as the output of
      a known cryptographic\n   hash algorithm whose input is the DER-encoded ASN.1
      representation of\n   the Subject Public Key Info (SPKI) of an X.509 certificate.
      \ A Pin is\n   defined as the combination of the known algorithm identifier
      and the\n   SPKI Fingerprint computed using that algorithm.\n   The SPKI Fingerprint
      is encoded in base 64 for use in an HTTP header\n   [RFC4648].\n   In this version
      of the specification, the known cryptographic hash\n   algorithm is SHA-256,
      identified as \"sha256\" [RFC6234].  (Future\n   specifications may add new
      algorithms and deprecate old ones.)  UAs\n   MUST ignore Pins for which they
      do not recognize the algorithm\n   identifier.  UAs MUST continue to process
      the rest of a PKP response\n   header field and note Pins for algorithms they
      do recognize.\n   Figure 5 reproduces the definition of the SubjectPublicKeyInfo\n
      \  structure in [RFC5280].\n   SubjectPublicKeyInfo  ::=  SEQUENCE  {\n       algorithm
      \           AlgorithmIdentifier,\n       subjectPublicKey     BIT STRING  }\n
      \  AlgorithmIdentifier  ::=  SEQUENCE  {\n       algorithm            OBJECT
      IDENTIFIER,\n       parameters           ANY DEFINED BY algorithm OPTIONAL  }\n
      \                        Figure 5: SPKI Definition\n   If the certificate's
      Subject Public Key Info is incomplete when taken\n   in isolation, such as when
      holding a DSA key without domain\n   parameters, a public key pin cannot be
      formed.\n   We pin public keys, rather than entire certificates, to enable\n
      \  operators to generate new certificates containing old public keys\n   (see
      [why-pin-key]).\n   See Appendix A for an example non-normative program that
      generates\n   SPKI Fingerprints from certificates.\n"
    title: 2.4.  Semantics of Pins
  - contents:
    - "2.5.  Noting Pins\n   Upon receipt of the PKP response header field, the UA
      notes the host\n   as a Known Pinned Host, storing the Pins and their associated\n
      \  directives in non-volatile storage (for example, along with the HSTS\n   metadata).
      \ The Pins and their associated directives are collectively\n   known as Pinning
      Metadata.\n   The UA MUST note the Pins for a Host if and only if all three
      of the\n   following conditions hold:\n   o  It received the PKP response header
      field over an error-free TLS\n      connection.  If the host is a Pinned Host,
      this includes the\n      validation added in Section 2.6.\n   o  The TLS connection
      was authenticated with a certificate chain\n      containing at least one of
      the SPKI structures indicated by at\n      least one of the given SPKI Fingerprints
      (see Section 2.6).\n   o  The given set of Pins contains at least one Pin that
      does NOT\n      refer to an SPKI in the certificate chain.  (That is, the host\n
      \     must set a Backup Pin; see Section 4.3.)\n   If the PKP response header
      field does not meet all three of these\n   criteria, the UA MUST NOT note the
      host as a Pinned Host.  A PKP\n   response header field that meets all these
      criteria is known as a\n   Valid Pinning Header.\n   Whenever a UA receives
      a Valid Pinning Header, it MUST set its\n   Pinning Metadata to the exact Pins,
      Effective Expiration Date\n   (computed from max-age), and (if any) report-uri
      given in the most\n   recently received Valid Pinning Header.\n   For forward
      compatibility, the UA MUST ignore any unrecognized PKP\n   and PKP-RO header
      directives, while still processing those directives\n   it does recognize.  Section
      2.1 specifies the directives max-age,\n   Pins, includeSubDomains, and report-uri,
      but future specifications\n   and implementations might use additional directives.\n
      \  Upon receipt of a PKP-RO response header field, the UA SHOULD\n   evaluate
      the policy expressed in the field, and SHOULD generate and\n   send a report
      (see Section 3).  However, failure to validate the Pins\n   in the field MUST
      have no effect on the validity or non-validity of\n   the policy expressed in
      the PKP field or in previously noted Pins for\n   the Known Pinned Host.\n   The
      UA need not note any Pins or other policy expressed in the PKP-RO\n   response
      header field, except for the purpose of determining that it\n   has already
      sent a report for a given policy.  UAs SHOULD make a best\n   effort not to
      inundate report-uris with redundant reports.\n"
    title: 2.5.  Noting Pins
  - contents:
    - "2.6.  Validating Pinned Connections\n   When a UA connects to a Pinned Host
      using a TLS connection, if the\n   TLS connection has errors, the UA MUST terminate
      the connection\n   without allowing the user to proceed anyway.  (This behavior
      is the\n   same as that required by [RFC6797].)\n   If the connection has no
      errors, then the UA will determine whether\n   to apply a new, additional correctness
      check: Pin Validation.  A UA\n   SHOULD perform Pin Validation whenever connecting
      to a Known Pinned\n   Host, as soon as possible (e.g., immediately after receiving
      the\n   Server Certificate message).  It is acceptable to allow Pin\n   Validation
      to be disabled for some Hosts according to local policy.\n   For example, a
      UA may disable Pin Validation for Pinned Hosts whose\n   validated certificate
      chain terminates at a user-defined trust\n   anchor, rather than a trust anchor
      built-in to the UA (or underlying\n   platform).\n   To perform Pin Validation,
      the UA will compute the SPKI Fingerprints\n   for each certificate in the Pinned
      Host's validated certificate\n   chain, using each supported hash algorithm
      for each certificate.  (As\n   described in Section 2.4, certificates whose
      SPKI cannot be taken in\n   isolation cannot be pinned.)  The UA MUST ignore
      superfluous\n   certificates in the chain that do not form part of the validating\n
      \  chain.  The UA will then check that the set of these SPKI\n   Fingerprints
      intersects the set of SPKI Fingerprints in that Pinned\n   Host's Pinning Metadata.
      \ If there is set intersection, the UA\n   continues with the connection as
      normal.  Otherwise, the UA MUST\n   treat this Pin Validation failure as a non-recoverable
      error.  Any\n   procedure that matches the results of this Pin Validation procedure\n
      \  is considered equivalent.\n   A UA that has previously noted a host as a
      Known Pinned Host MUST\n   perform Pin Validation when setting up the TLS session,
      before\n   beginning an HTTP conversation over the TLS channel.\n   UAs send
      validation failure reports only when Pin Validation is\n   actually in effect.
      \ Pin Validation might not be in effect, e.g.,\n   because the user has elected
      to disable it, or because a presented\n   certificate chain chains up to a user-defined
      trust anchor.  In such\n   cases, UAs SHOULD NOT send reports.\n"
    title: 2.6.  Validating Pinned Connections
  - contents:
    - "2.7.  Interactions with Preloaded Pin Lists\n   UAs MAY choose to implement
      additional sources of pinning\n   information, such as through built-in lists
      of pinning information.\n   Such UAs should allow users to override such additional
      sources,\n   including disabling them from consideration.\n   The effective
      policy for a Known Pinned Host that has both built-in\n   Pins and Pins from
      previously observed PKP header response fields is\n   implementation-defined.\n"
    title: 2.7.  Interactions with Preloaded Pin Lists
  - contents:
    - "2.8.  Pinning Self-Signed End Entities\n   If UAs accept hosts that authenticate
      themselves with self-signed end\n   entity certificates, they MAY also allow
      hosts to pin the public keys\n   in such certificates.  The usability and security
      implications of\n   this practice are outside the scope of this specification.\n"
    title: 2.8.  Pinning Self-Signed End Entities
  title: 2.  Server and Client Behavior
- contents:
  - "3.  Reporting Pin Validation Failure\n   When a Known Pinned Host has set the
    report-uri directive, the UA\n   SHOULD report Pin Validation failures to the
    indicated URI.  The UA\n   does this by POSTing a JSON [RFC7159] message to the
    URI; the JSON\n   message takes this form:\n   {\n     \"date-time\": date-time,\n
    \    \"hostname\": hostname,\n     \"port\": port,\n     \"effective-expiration-date\":
    expiration-date,\n     \"include-subdomains\": include-subdomains,\n     \"noted-hostname\":
    noted-hostname,\n     \"served-certificate-chain\": [\n       pem1, ... pemN\n
    \    ],\n     \"validated-certificate-chain\": [\n       pem1, ... pemN\n     ],\n
    \    \"known-pins\": [\n       known-pin1, ... known-pinN\n     ]\n   }\n                       Figure
    6: JSON Report Format\n   Whitespace outside of quoted strings is not significant.
    \ The key/\n   value pairs may appear in any order, but each MUST appear only
    once.\n   The date-time indicates the time the UA observed the Pin Validation\n
    \  failure.  It is provided as a string formatted according to\n   Section 5.6,
    \"Internet Date/Time Format\", of [RFC3339].\n   The hostname is the hostname
    to which the UA made the original\n   request that failed Pin Validation.  It
    is provided as a string.\n   The port is the port to which the UA made the original
    request that\n   failed Pin Validation.  It is provided as an integer.\n   The
    effective-expiration-date is the Effective Expiration Date for\n   the noted Pins.
    \ It is provided as a string formatted according to\n   Section 5.6, \"Internet
    Date/Time Format\", of [RFC3339].\n   include-subdomains indicates whether or
    not the UA has noted the\n   includeSubDomains directive for the Known Pinned
    Host.  It is\n   provided as one of the JSON identifiers \"true\" or \"false\".\n
    \  noted-hostname indicates the hostname that the UA noted when it noted\n   the
    Known Pinned Host.  This field allows operators to understand why\n   Pin Validation
    was performed for, e.g., foo.example.com when the\n   noted Known Pinned Host
    was example.com with includeSubDomains set.\n   The served-certificate-chain is
    the certificate chain, as served by\n   the Known Pinned Host during TLS session
    setup.  It is provided as an\n   array of strings; each string pem1, ... pemN
    is the Privacy-Enhanced\n   Mail (PEM) representation of each X.509 certificate
    as described in\n   [RFC7468].\n   The validated-certificate-chain is the certificate
    chain, as\n   constructed by the UA during certificate chain verification.  (This\n
    \  may differ from the served-certificate-chain.)  It is provided as an\n   array
    of strings; each string pem1, ... pemN is the PEM\n   representation of each X.509
    certificate as described in [RFC7468].\n   UAs that build certificate chains in
    more than one way during the\n   validation process SHOULD send the last chain
    built.  In this way,\n   they can avoid keeping too much state during the validation
    process.\n   The known-pins are the Pins that the UA has noted for the Known\n
    \  Pinned Host.  They are provided as an array of strings with the\n   syntax:\n
    \  known-pin = token \"=\" quoted-string\n                        Figure 7: Known
    Pin Syntax\n   As in Section 2.4, the token refers to the algorithm name, and
    the\n   quoted-string refers to the base64 encoding of the SPKI Fingerprint.\n
    \  When formulating the JSON POST body, the UA MUST either use single-\n   quoted
    JSON strings or use double-quoted JSON strings and backslash-\n   escape the embedded
    double quotes in the quoted-string part of the\n   known-pin.\n   Figure 8 shows
    an example of a Pin Validation failure report.  (PEM\n   strings are shown on
    multiple lines for readability.)\n  {\n    \"date-time\": \"2014-04-06T13:00:50Z\",\n
    \   \"hostname\": \"www.example.com\",\n    \"port\": 443,\n    \"effective-expiration-date\":
    \"2014-05-01T12:40:50Z\"\n    \"include-subdomains\": false,\n    \"served-certificate-chain\":
    [\n      \"-----BEGIN CERTIFICATE-----\\n\n      MIIEBDCCAuygAwIBAgIDAjppMA0GCSqGSIb3DQEBBQUAMEIxCzAJBgNVBAYTAlVT\\n\n
    \     ...\n      HFa9llF7b1cq26KqltyMdMKVvvBulRP/F/A8rLIQjcxz++iPAsbw+zOzlTvjwsto\\n\n
    \     WHPbqCRiOwY1nQ2pM714A5AuTHhdUDqB1O6gyHA43LL5Z/qHQF1hwFGPa4NrzQU6\\n\n      yuGnBXj8ytqU0CwIPX4WecigUCAkVDNx\\n\n
    \     -----END CERTIFICATE-----\",\n      ...\n    ],\n    \"validated-certificate-chain\":
    [\n      \"-----BEGIN CERTIFICATE-----\\n\n      MIIEBDCCAuygAwIBAgIDAjppMA0GCSqGSIb3DQEBBQUAMEIxCzAJBgNVBAYTAlVT\\n\n
    \     ...\n      HFa9llF7b1cq26KqltyMdMKVvvBulRP/F/A8rLIQjcxz++iPAsbw+zOzlTvjwsto\\n\n
    \     WHPbqCRiOwY1nQ2pM714A5AuTHhdUDqB1O6gyHA43LL5Z/qHQF1hwFGPa4NrzQU6\\n\n      yuGnBXj8ytqU0CwIPX4WecigUCAkVDNx\\n\n
    \     -----END CERTIFICATE-----\",\n      ...\n    ],\n    \"known-pins\": [\n
    \     'pin-sha256=\"d6qzRu9zOECb90Uez27xWltNsj0e1Md7GkYYkVoZWmM=\"',\n      \"pin-sha256=\\\"E9CZ9INDbd+2eRQozYqqbQ2yXLVKB9+xcprMF+44U1g=\\\"\"\n
    \   ]\n  }\n              Figure 8: Pin Validation Failure Report Example\n"
  title: 3.  Reporting Pin Validation Failure
- contents:
  - "4.  Security Considerations\n   Pinning public keys helps hosts strongly assert
    their cryptographic\n   identity even in the face of issuer error, malfeasance,
    or\n   compromise.  But, there is some risk that a host operator could lose\n
    \  (or lose control of) their host's private key (such as by operator\n   error
    or host compromise).  If the operator had pinned only the key\n   of the host's
    end-entity certificate, the operator would not be able\n   to serve their web
    site or application in a way that UAs would trust\n   for the duration of their
    pin's max-age.  (Recall that UAs MUST close\n   the connection to a host upon
    Pin Failure.)\n   Therefore, there is a necessary trade-off between two competing\n
    \  goods: pin specificity and maximal reduction of the scope of issuers\n   on
    the one hand; and flexibility and resilience of the host's\n   cryptographic identity
    on the other hand.  One way to resolve this\n   trade-off is to compromise by
    pinning to the key(s) of the issuer(s)\n   of the host's end-entity certificate(s).
    \ Often, a valid certificate\n   chain will have at least two certificates above
    the end-entity\n   certificate: the intermediate issuer and the trust anchor.
    \ Operators\n   can pin any one or more of the public keys in this chain, and
    indeed\n   MUST pin to issuers not in the chain (as, for example, a Backup Pin).\n
    \  Pinning to an intermediate issuer, or even to a trust anchor or root,\n   still
    significantly reduces the number of issuers who can issue end-\n   entity certificates
    for the Known Pinned Host, while still giving\n   that host flexibility to change
    keys without a disruption of service.\n"
  - contents:
    - "4.1.  Maximum max-age\n   As mentioned in Section 2.3.3, UAs MAY cap the max-age
      value at some\n   upper limit.  There is a security trade-off in that low maximum\n
      \  values provide a narrow window of protection for users who visit the\n   Known
      Pinned Host only infrequently, while high maximum values might\n   result in
      a UA's inability to successfully perform Pin Validation for\n   a Known Pinned
      Host if the UA's noted Pins and the host's true Pins\n   diverge.\n   Such divergence
      could occur for several reasons, including: UA error;\n   host operator error;
      network attack; or a Known Pinned Host that\n   intentionally migrates all pinned
      keys, combined with a UA that has\n   noted true Pins with a high max-age value
      and has not had a chance to\n   observe the new true Pins for the host.  (This
      last example\n   underscores the importance for host operators to phase in new
      keys\n   gradually and to set the max-age value in accordance with their\n   planned
      key migration schedule.)\n   There is probably no ideal upper limit to the max-age
      directive that\n   would satisfy all use cases.  However, a value on the order
      of 60\n   days (5,184,000 seconds) may be considered a balance between the two\n
      \  competing security concerns.\n"
    title: 4.1.  Maximum max-age
  - contents:
    - "4.2.  Using includeSubDomains Safely\n   It may happen that Pinned Hosts whose
      hostnames share a parent domain\n   use different Valid Pinning Headers.  If
      a host whose hostname is a\n   parent domain for another host sets the includeSubDomains
      directive,\n   the two hosts' Pins may conflict with each other.  For example,\n
      \  consider two Known Pinned Hosts, example.com and\n   subdomain.example.com.
      \ Assume example.com sets a Valid Pinning\n   Header such as this:\n   Public-Key-Pins:
      max-age=12000; pin-sha256=\"ABC...\";\n       pin-sha256=\"DEF...\"; includeSubDomains\n
      \               Figure 9: example.com Valid Pinning Header\n   Assume subdomain.example.com
      sets a Valid Pinning Header such as\n   this:\n   Public-Key-Pins: pin-sha256=\"GHI...\";
      pin-sha256=\"JKL...\"\n           Figure 10: subdomain.example.com Valid Pinning
      Header\n   Assume a UA that has not previously noted any Pins for either of\n
      \  these hosts.  If the UA first contacts subdomain.example.com, it will\n   note
      the Pins in the Valid Pinning Header, and perform Pin Validation\n   as normal
      on subsequent connections.  If the UA then contacts\n   example.com, again it
      will note the Pins and perform Pin Validation\n   on future connections.\n   However,
      if the UA happened to visit example.com before\n   subdomain.example.com, the
      UA would, due to example.com's use of the\n   includeSubDomains directive, attempt
      to perform Pin Validation for\n   subdomain.example.com using the SPKI hashes
      ABC... and DEF..., which\n   are not valid for the certificate chains subdomain.example.com
      (which\n   uses certificates with SPKIs GHI... and JLK...).  Thus, depending
      on\n   the order in which the UA observes the Valid Pinning Headers for\n   hosts
      example.com and subdomain.example.com, Pin Validation might or\n   might not
      fail for subdomain.example.com, even if the certificate\n   chain the UA receives
      for subdomain.example.com is perfectly valid.\n   Thus, Pinned Host operators
      must use the includeSubDomains directive\n   with care.  For example, they may
      choose to use overlapping pin sets\n   for hosts under a parent domain that
      uses includeSubDomains, or to\n   not use the includeSubDomains directive in
      their effective-second-\n   level domains, or to simply use the same pin set
      for all hosts under\n   a given parent domain.\n"
    title: 4.2.  Using includeSubDomains Safely
  - contents:
    - "4.3.  Backup Pins\n   The primary way to cope with the risk of inadvertent
      Pin Validation\n   failure is to keep a Backup Pin.  A Backup Pin is a fingerprint
      for\n   the public key of a secondary, not-yet-deployed key pair.  The\n   operator
      keeps the backup key pair offline, and sets a pin for it in\n   the PKP header.
      \ Then, in case the operator loses control of their\n   primary private key,
      they can deploy the backup key pair.  UAs, who\n   have had the backup key pair
      pinned (when it was set in previous\n   Valid Pinning Headers), can connect
      to the host without error.\n   Because having a backup key pair is so important
      to recovery, UAs\n   MUST require that hosts set a Backup Pin (see Section 2.5).
      \ The down\n   side of keeping a not-yet-deployed key pair is that, if an attacker\n
      \  gains control of the private key, she will be able to perform a MITM\n   attack
      without being discovered.  Operators must take care to avoid\n   leaking the
      key such as keeping it offline.\n"
    title: 4.3.  Backup Pins
  - contents:
    - "4.4.  Interactions With Cookie Scoping\n   HTTP cookies [RFC6265] set by a
      Known Pinned Host can be stolen by a\n   network attacker who can forge web
      and DNS responses so as to cause a\n   client to send the cookies to a phony
      subdomain of the host.  To\n   prevent this, hosts SHOULD set the \"secure\"
      attribute and precisely\n   scope the \"domain\" attribute on all security-sensitive
      cookies, such\n   as session cookies.  These settings tell the browser that
      the cookie\n   should only be sent back to the specific host(s) (and not, e.g.,
      all\n   subdomains of a given domain), and should only be sent over HTTPS\n
      \  (not HTTP).\n"
    title: 4.4.  Interactions With Cookie Scoping
  - contents:
    - "4.5.  Hostile Pinning\n   An attacker who is able to obtain a valid certificate
      for a domain,\n   either through misissuance by a Certification Authority or
      through\n   other means, such as being the prior owner of a given domain, may\n
      \  attempt to perform 'hostile' pinning.  In this scenario, the attacker\n   provides
      a Valid Pinning Header that pins to a set of SPKIs of the\n   attacker's choice.
      \ If a UA has not previously noted pins for that\n   host, it may note the attacker's
      pins, preventing access to the\n   legitimate site.\n   This attack is mitigated
      through several means.  Most prominently,\n   the attack can only persist for
      the maximum max-age (see\n   Section 4.1).  Web host operators can reduce the
      opportunity for\n   attack by working to preload the host's pins within the
      UA.\n   Operators may further detect such misissuance through other means,\n
      \  such as certificate transparency ([RFC6962]).\n"
    title: 4.5.  Hostile Pinning
  title: 4.  Security Considerations
- contents:
  - "5.  Privacy Considerations\n   Hosts can use HSTS or HPKP as a \"super-cookie\",
    by setting distinct\n   policies for a number of subdomains.  For example, assume
    example.com\n   wishes to track distinct UAs without explicitly setting a cookie,
    or\n   that a previously set cookie is deleted from the UA's cookie store.\n   Here
    are two attack scenarios.\n   o  example.com can use report-uri and the ability
    to pin arbitrary\n      identifiers to distinguish UAs.\n      1.  example.com
    sets a Valid Pinning Header in its response to\n          requests.  The header
    asserts the includeSubDomains directive\n          and specifies a report-uri
    directive as well.  Pages served by\n          the host also include references
    to subresource\n          https://bad.example.com/foo.png.\n      2.  The Valid
    Pinning Header includes a \"pin\" that is not really\n          the hash of an
    SPKI but is instead an arbitrary distinguishing\n          string sent only in
    response to a particular request.  For\n          each request, the host creates
    a new, distinct distinguishing\n          string and sets it as if it were a pin.\n
    \     3.  The certificate chain served by bad.example.com does not pass\n          Pin
    Validation given the pin set the host asserted in step\n          (1).  The HPKP-conforming
    UA attempts to report the Pin\n          Validation failure to the specified report-uri,
    including the\n          certificate chain it observed and the SPKI hashes it
    expected\n          to see.  Among the SPKI hashes is the distinguishing string
    in\n          step (2).\n   o  Different site operators/origins can optionally
    collaborate by\n      setting the report-uri to be in an origin they share\n      administrative
    control of.  UAs MAY, therefore, refuse to send\n      reports outside of the
    origin that set the PKP or PKP-RO header.\n   o  example.com can use server name
    indication (SNI; [RFC3546]) and\n      subdomains to distinguish UAs.\n      1.
    \ example.com sets a Valid Pinning Header in its response to\n          requests.
    \ The header asserts the includeSubDomains directive.\n      2.  On a subsequent
    page view, the host responds with a page\n          including the subresource
    https://0.fingerprint.example.com/\n          foo.png, and the server responds
    using a certificate chain\n          that does not pass Pin Validation for the
    pin-set defined in\n          the Valid Pinning Header in step (1).  The HPKP-conforming
    UA\n          will close the connection, never completing the request to\n          0.fingerprint.example.com.
    \ The host may thus note that this\n          particular UA had noted the (good)
    Pins for that subdomain.\n      3.  example.com can distinguish 2^N UAs by serving
    Valid Pinning\n          Headers from an arbitrary number N distinct subdomains.
    \ For\n          any given subdomain n.fingerprint.example.com, the host may\n
    \         deliver a Valid Pinning Header to one UA, but not deliver it\n          to
    a different UA.  The server may then change the\n          configuration for n.fingerprint.example.com.
    \ If the UA fails\n          to connect, it was in the set of UAs that were pinned,
    which\n          can be distinguished from the UAs that were not pinned, as\n
    \         they will succeed in connecting.  The host may repeat this for\n          a
    sufficient number of subdomains necessary to distinguish\n          individual
    UAs.\n   o  Conforming implementations (as well as implementations conforming\n
    \     to [RFC6797]) must store state about which domains have set\n      policies,
    hence which domains the UA has contacted.  Because these\n      policies cause
    remotely detectable behaviors, it is advisable that\n      UAs have a way for
    privacy-sensitive users to clear current Pins\n      for Pinned Hosts and that
    UAs allow users to query the current\n      state of Pinned Hosts.  In addition,
    note that because pinning a\n      host implies a degree of persistent state,
    an attacker with\n      physical access to a device may be able to recover information\n
    \     about hosts a user has visited, even if the user has cleared other\n      parts
    of the UA's state.\n   o  Pin reports, as noted in Section 3, contains information
    about the\n      certificate chain that has failed pin validation.  In some cases,\n
    \     such as organization-wide compromise of the end-to-end security of\n      TLS,
    this may include information about the interception tools and\n      design used
    by the organization that the organization would\n      otherwise prefer not be
    disclosed.\n"
  title: 5.  Privacy Considerations
- contents:
  - "6.  IANA Considerations\n   IANA has registered the response headers described
    in this document\n   under \"Permanent Message Header Field Names\" in the \"Message
    Headers\"\n   registry [message-headers] with the following parameters:\n   o
    \ Header Field Names: Public-Key-Pins and Public-Key-Pins-Report-\n      Only\n
    \  o  Protocol: http\n   o  Status: standard\n   o  Reference: RFC 7469\n"
  title: 6.  IANA Considerations
- contents:
  - "7.  Usability Considerations\n   When pinning works to detect impostor Pinned
    Hosts, users will\n   experience denial of service.  It is advisable for UAs to
    explain the\n   reason why, i.e., that it was impossible to verify the confirmed\n
    \  cryptographic identity of the host.\n   It is advisable that UAs have a way
    for users to clear current Pins\n   for Pinned Hosts and that UAs allow users
    to query the current state\n   of Pinned Hosts.\n"
  title: 7.  Usability Considerations
- contents:
  - '8.  References

    '
  - contents:
    - "8.1.  Normative References\n   [RFC2119]  Bradner, S., \"Key words for use
      in RFCs to Indicate\n              Requirement Levels\", BCP 14, RFC 2119, March
      1997,\n              <http://www.rfc-editor.org/info/rfc2119>.\n   [RFC3339]
      \ Klyne, G. and C. Newman, \"Date and Time on the Internet:\n              Timestamps\",
      RFC 3339, July 2002,\n              <http://www.rfc-editor.org/info/rfc3339>.\n
      \  [RFC3986]  Berners-Lee, T., Fielding, R., and L. Masinter, \"Uniform\n              Resource
      Identifier (URI): Generic Syntax\", STD 66, RFC\n              3986, January
      2005,\n              <http://www.rfc-editor.org/info/rfc3986>.\n   [RFC4648]
      \ Josefsson, S., \"The Base16, Base32, and Base64 Data\n              Encodings\",
      RFC 4648, October 2006,\n              <http://www.rfc-editor.org/info/rfc4648>.\n
      \  [RFC5234]  Crocker, D., Ed. and P. Overell, \"Augmented BNF for Syntax\n
      \             Specifications: ABNF\", STD 68, RFC 5234, January 2008,\n              <http://www.rfc-editor.org/info/rfc5234>.\n
      \  [RFC5246]  Dierks, T. and E. Rescorla, \"The Transport Layer Security\n              (TLS)
      Protocol Version 1.2\", RFC 5246, August 2008,\n              <http://www.rfc-editor.org/info/rfc5246>.\n
      \  [RFC5280]  Cooper, D., Santesson, S., Farrell, S., Boeyen, S.,\n              Housley,
      R., and W. Polk, \"Internet X.509 Public Key\n              Infrastructure Certificate
      and Certificate Revocation List\n              (CRL) Profile\", RFC 5280, May
      2008,\n              <http://www.rfc-editor.org/info/rfc5280>.\n   [RFC6234]
      \ Eastlake 3rd, D. and T. Hansen, \"US Secure Hash Algorithms\n              (SHA
      and SHA-based HMAC and HKDF)\", RFC 6234, May 2011,\n              <http://www.rfc-editor.org/info/rfc6234>.\n
      \  [RFC6265]  Barth, A., \"HTTP State Management Mechanism\", RFC 6265,\n              April
      2011, <http://www.rfc-editor.org/info/rfc6265>.\n   [RFC6797]  Hodges, J., Jackson,
      C., and A. Barth, \"HTTP Strict\n              Transport Security (HSTS)\",
      RFC 6797, November 2012,\n              <http://www.rfc-editor.org/info/rfc6797>.\n
      \  [RFC7159]  Bray, T., Ed., \"The JavaScript Object Notation (JSON) Data\n
      \             Interchange Format\", RFC 7159, March 2014,\n              <http://www.rfc-editor.org/info/rfc7159>.\n
      \  [RFC7230]  Fielding, R., Ed. and J. Reschke, Ed., \"Hypertext Transfer\n
      \             Protocol (HTTP/1.1): Message Syntax and Routing\", RFC\n              7230,
      June 2014, <http://www.rfc-editor.org/info/rfc7230>.\n   [RFC7234]  Fielding,
      R., Ed., Nottingham, M., Ed., and J. Reschke,\n              Ed., \"Hypertext
      Transfer Protocol (HTTP/1.1): Caching\",\n              RFC 7234, June 2014,\n
      \             <http://www.rfc-editor.org/info/rfc7234>.\n   [RFC7468]  Josefsson,
      S. and S. Leonard, \"Textual Encodings of PKIX,\n              PKCS, and CMS
      Structures\", RFC 7468, April 2015,\n              <http://www.rfc-editor.org/info/rfc7468>.\n
      \  [W3C.REC-html401-19991224]\n              Raggett, D., Hors, A., and I. Jacobs,
      \"HTML 4.01\n              Specification\", World Wide Web Consortium Recommendation\n
      \             REC-html401-19991224, December 1999,\n              <http://www.w3.org/TR/1999/REC-html401-19991224>.\n
      \  [message-headers]\n              IANA, \"Message Headers\",\n              <http://www.iana.org/assignments/message-headers/>.\n"
    title: 8.1.  Normative References
  - contents:
    - "8.2.  Informative References\n   [RFC3546]  Blake-Wilson, S., Nystrom, M.,
      Hopwood, D., Mikkelsen, J.,\n              and T. Wright, \"Transport Layer
      Security (TLS)\n              Extensions\", RFC 3546, June 2003,\n              <http://www.rfc-editor.org/info/rfc3546>.\n
      \  [RFC6962]  Laurie, B., Langley, A., and E. Kasper, \"Certificate\n              Transparency\",
      RFC 6962, June 2013,\n              <http://www.rfc-editor.org/info/rfc6962>.\n
      \  [TACK]     Marlinspike, M., \"Trust Assertions for Certificate Keys\",\n
      \             Work in Progress, draft-perrin-tls-tack-02, January 2013.\n   [why-pin-key]\n
      \             Langley, A., \"Public Key Pinning\", Imperial Violet: Adam\n              Langley's
      Weblog, May 2011,\n              <https://www.imperialviolet.org/2011/05/04/pinning.html>.\n"
    title: 8.2.  Informative References
  title: 8.  References
- contents:
  - "Appendix A.  Fingerprint Generation\n   This Portable Operating System Interface
    (POSIX) shell program\n   generates SPKI Fingerprints, suitable for use in pinning,
    from PEM-\n   encoded certificates.  It is non-normative.\n   openssl x509 -noout
    -in certificate.pem -pubkey | \\\n       openssl asn1parse -noout -inform pem
    -out public.key\n   openssl dgst -sha256 -binary public.key | openssl enc -base64\n
    \           Figure 11: Example SPKI Fingerprint Generation Code\n"
  title: Appendix A.  Fingerprint Generation
- contents:
  - "Appendix B.  Deployment Guidance\n   This section is non-normative guidance that
    may smooth the adoption\n   of public key pinning.\n   o  Operators should get
    the backup public key signed by a different\n      (root and/or intermediary)
    CA than their primary certificate, and\n      store the backup key pair safely
    offline.  The semantics of an\n      SPKI Fingerprint do not require the issuance
    of a certificate to\n      construct a valid Pin. However, in many deployment
    scenarios, in\n      order to make a Backup Pin operational, the server operator
    will\n      need to have a certificate to deploy TLS on the host.  Failure to\n
    \     obtain a certificate through prior arrangement will leave clients\n      that
    recognize the site as a Known Pinned Host unable to\n      successfully perform
    Pin Validation until such a time as the\n      operator can obtain a new certificate
    from their desired\n      certificate issuer.\n   o  It is most economical to
    have the backup certificate signed by a\n      completely different signature
    chain than the live certificate, to\n      maximize recoverability in the event
    of compromise of either the\n      root or intermediary signer.\n   o  Operators
    should periodically exercise their Backup Pin plan -- an\n      untested backup
    is no backup at all.\n   o  Operators should start small.  Operators should first
    deploy\n      public key pinning by using the report-only mode together with a\n
    \     report-uri directive that points to a reliable report collection\n      endpoint.
    \ When moving out of report-only mode, operators should\n      start by setting
    a max-age of minutes or a few hours and gradually\n      increase max-age as they
    gain confidence in their operational\n      capability.\n"
  title: Appendix B.  Deployment Guidance
- contents:
  - "Acknowledgements\n   Thanks to Tobias Gondrom, Jeff Hodges, Paul Hoffman, Ivan
    Krstic,\n   Adam Langley, Barry Leiba, Nicolas Lidzborski, SM, James Manger, Yoav\n
    \  Nir, Trevor Perrin, Eric Rescorla, Pete Resnick, Tom Ritter, and Yan\n   Zhu
    for suggestions and edits that clarified the text.\n   TACK [TACK] is a fruitful
    source of alternative design\n   considerations.\n"
  title: Acknowledgements
- contents:
  - "Authors' Addresses\n   Chris Evans\n   Google, Inc.\n   1600 Amphitheatre Pkwy\n
    \  Mountain View, CA  94043\n   United States\n   EMail: cevans@google.com\n   Chris
    Palmer\n   Google, Inc.\n   1600 Amphitheatre Pkwy\n   Mountain View, CA  94043\n
    \  United States\n   EMail: palmer@google.com\n   Ryan Sleevi\n   Google, Inc.\n
    \  1600 Amphitheatre Pkwy\n   Mountain View, CA  94043\n   United States\n   EMail:
    sleevi@google.com\n"
  title: Authors' Addresses
