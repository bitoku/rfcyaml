- title: __initial_text__
  contents:
  - "         Low Density Parity Check (LDPC) Staircase and Triangle\n           \
    \      Forward Error Correction (FEC) Schemes\n"
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This document specifies an Internet standards track protocol\
    \ for the\n   Internet community, and requests discussion and suggestions for\n\
    \   improvements.  Please refer to the current edition of the \"Internet\n   Official\
    \ Protocol Standards\" (STD 1) for the standardization state\n   and status of\
    \ this protocol.  Distribution of this memo is unlimited.\n"
- title: Abstract
  contents:
  - "Abstract\n   This document describes two Fully-Specified Forward Error Correction\n\
    \   (FEC) Schemes, Low Density Parity Check (LDPC) Staircase and LDPC\n   Triangle,\
    \ and their application to the reliable delivery of data\n   objects on the packet\
    \ erasure channel (i.e., a communication path\n   where packets are either received\
    \ without any corruption or discarded\n   during transmission).  These systematic\
    \ FEC codes belong to the well-\n   known class of \"Low Density Parity Check\"\
    \ codes, and are large block\n   FEC codes in the sense of RFC 3453.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1.  Introduction . . . . . . . . . . . . . . . . . . .\
    \ . . . . . .  3\n   2.  Requirements Notation  . . . . . . . . . . . . . . .\
    \ . . . . .  3\n   3.  Definitions, Notations, and Abbreviations  . . . . . .\
    \ . . . .  3\n     3.1.  Definitions  . . . . . . . . . . . . . . . . . . . .\
    \ . . .  3\n     3.2.  Notations  . . . . . . . . . . . . . . . . . . . . . .\
    \ . .  4\n     3.3.  Abbreviations  . . . . . . . . . . . . . . . . . . . . .\
    \ .  5\n   4.  Formats and Codes  . . . . . . . . . . . . . . . . . . . . . .\
    \  6\n     4.1.  FEC Payload IDs  . . . . . . . . . . . . . . . . . . . . .  6\n\
    \     4.2.  FEC Object Transmission Information  . . . . . . . . . . .  6\n  \
    \     4.2.1.  Mandatory Element  . . . . . . . . . . . . . . . . . .  6\n    \
    \   4.2.2.  Common Elements  . . . . . . . . . . . . . . . . . . .  6\n      \
    \ 4.2.3.  Scheme-Specific Elements . . . . . . . . . . . . . . .  7\n       4.2.4.\
    \  Encoding Format  . . . . . . . . . . . . . . . . . . .  8\n   5.  Procedures\
    \ . . . . . . . . . . . . . . . . . . . . . . . . . .  9\n     5.1.  General \
    \ . . . . . . . . . . . . . . . . . . . . . . . . .  9\n     5.2.  Determining\
    \ the Maximum Source Block Length (B)  . . . . . 11\n     5.3.  Determining the\
    \ Encoding Symbol Length (E) and Number\n           of Encoding Symbols per Group\
    \ (G)  . . . . . . . . . . . . 12\n     5.4.  Determining the Maximum Number of\
    \ Encoding Symbols\n           Generated for Any Source Block (max_n) . . . .\
    \ . . . . . . 13\n     5.5.  Determining the Number of Encoding Symbols of a Block\n\
    \           (n)  . . . . . . . . . . . . . . . . . . . . . . . . . . . 14\n  \
    \   5.6.  Identifying the G Symbols of an Encoding Symbol Group  . . 14\n    \
    \ 5.7.  Pseudo-Random Number Generator . . . . . . . . . . . . . . 17\n   6. \
    \ Full Specification of the LDPC-Staircase Scheme  . . . . . . . 19\n     6.1.\
    \  General  . . . . . . . . . . . . . . . . . . . . . . . . . 19\n     6.2.  Parity\
    \ Check Matrix Creation . . . . . . . . . . . . . . . 19\n     6.3.  Encoding\
    \ . . . . . . . . . . . . . . . . . . . . . . . . . 21\n     6.4.  Decoding .\
    \ . . . . . . . . . . . . . . . . . . . . . . . . 21\n   7.  Full Specification\
    \ of the LDPC-Triangle Scheme . . . . . . . . 22\n     7.1.  General  . . . .\
    \ . . . . . . . . . . . . . . . . . . . . . 22\n     7.2.  Parity Check Matrix\
    \ Creation . . . . . . . . . . . . . . . 22\n     7.3.  Encoding . . . . . . .\
    \ . . . . . . . . . . . . . . . . . . 23\n     7.4.  Decoding . . . . . . . .\
    \ . . . . . . . . . . . . . . . . . 23\n   8.  Security Considerations  . . .\
    \ . . . . . . . . . . . . . . . . 24\n     8.1.  Problem Statement  . . . . .\
    \ . . . . . . . . . . . . . . . 24\n     8.2.  Attacks Against the Data Flow \
    \ . . . . . . . . . . . . . . 24\n       8.2.1.  Access to Confidential Objects\
    \ . . . . . . . . . . . . 24\n       8.2.2.  Content Corruption . . . . . . .\
    \ . . . . . . . . . . . 25\n     8.3.  Attacks Against the FEC Parameters . .\
    \ . . . . . . . . . . 26\n   9.  IANA Considerations  . . . . . . . . . . . .\
    \ . . . . . . . . . 27\n   10. Acknowledgments  . . . . . . . . . . . . . . .\
    \ . . . . . . . . 27\n   11. References . . . . . . . . . . . . . . . . . . .\
    \ . . . . . . . 27\n     11.1. Normative References . . . . . . . . . . . . .\
    \ . . . . . . 27\n     11.2. Informative References . . . . . . . . . . . . .\
    \ . . . . . 27\n   Appendix A.  Trivial Decoding Algorithm (Informative Only)\
    \ . . . . 30\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   [RFC3453] introduces large block FEC codes as an alternative\
    \ to small\n   block FEC codes like Reed-Solomon.  The main advantage of such\
    \ large\n   block codes is the possibility to operate efficiently on source\n\
    \   blocks with a size of several tens of thousands (or more) of source\n   symbols.\
    \  The present document introduces the Fully-Specified FEC\n   Encoding ID 3 that\
    \ is intended to be used with the LDPC-Staircase FEC\n   codes, and the Fully-Specified\
    \ FEC Encoding ID 4 that is intended to\n   be used with the LDPC-Triangle FEC\
    \ codes [RN04][MK03].  Both schemes\n   belong to the broad class of large block\
    \ codes.  For a definition of\n   the term Fully-Specified Scheme, see Section\
    \ 4 of [RFC5052].\n   LDPC codes rely on a dedicated matrix, called a \"parity\
    \ check\n   matrix\", at the encoding and decoding ends.  The parity check matrix\n\
    \   defines relationships (or constraints) between the various encoding\n   symbols\
    \ (i.e., source symbols and repair symbols), which are later\n   used by the decoder\
    \ to reconstruct the original k source symbols if\n   some of them are missing.\
    \  These codes are systematic, in the sense\n   that the encoding symbols include\
    \ the source symbols in addition to\n   the repair symbols.\n   Since the encoder\
    \ and decoder must operate on the same parity check\n   matrix, information must\
    \ be communicated between them as part of the\n   FEC Object Transmission Information.\n\
    \   A publicly available reference implementation of these codes is\n   available\
    \ and distributed under a GNU/LGPL (Lesser General Public\n   License) [LDPC-codec].\
    \  Besides, the code extracts included in this\n   document are directly contributed\
    \ to the IETF process by the authors\n   of this document and by Radford M. Neal.\n"
- title: 2.  Requirements Notation
  contents:
  - "2.  Requirements Notation\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\"\
    , \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"\
    MAY\", and \"OPTIONAL\" in this\n   document are to be interpreted as described\
    \ in [RFC2119].\n"
- title: 3.  Definitions, Notations, and Abbreviations
  contents:
  - '3.  Definitions, Notations, and Abbreviations

    '
- title: 3.1.  Definitions
  contents:
  - "3.1.  Definitions\n   This document uses the same terms and definitions as those\
    \ specified\n   in [RFC5052].  Additionally, it uses the following definitions:\n\
    \      Source Symbol: a unit of data used during the encoding process\n      Encoding\
    \ Symbol: a unit of data generated by the encoding process\n      Repair Symbol:\
    \ an encoding symbol that is not a source symbol\n      Code Rate: the k/n ratio,\
    \ i.e., the ratio between the number of\n      source symbols and the number of\
    \ encoding symbols.  The code rate\n      belongs to a ]0; 1] interval.  A code\
    \ rate close to 1 indicates\n      that a small number of repair symbols have\
    \ been produced during\n      the encoding process\n      Systematic Code: FEC\
    \ code in which the source symbols are part of\n      the encoding symbols\n \
    \     Source Block: a block of k source symbols that are considered\n      together\
    \ for the encoding\n      Encoding Symbol Group: a group of encoding symbols that\
    \ are sent\n      together, within the same packet, and whose relationships to\
    \ the\n      source object can be derived from a single Encoding Symbol ID\n \
    \     Source Packet: a data packet containing only source symbols\n      Repair\
    \ Packet: a data packet containing only repair symbols\n      Packet Erasure Channel:\
    \ a communication path where packets are\n      either dropped (e.g., by a congested\
    \ router or because the number\n      of transmission errors exceeds the correction\
    \ capabilities of the\n      physical layer codes) or received.  When a packet\
    \ is received, it\n      is assumed that this packet is not corrupted\n"
- title: 3.2.  Notations
  contents:
  - "3.2.  Notations\n   This document uses the following notations:\n      L denotes\
    \ the object transfer length in bytes.\n      k denotes the source block length\
    \ in symbols, i.e., the number of\n      source symbols of a source block.\n \
    \     n denotes the encoding block length, i.e., the number of encoding\n    \
    \  symbols generated for a source block.\n      E denotes the encoding symbol\
    \ length in bytes.\n      B denotes the maximum source block length in symbols,\
    \ i.e., the\n      maximum number of source symbols per source block.\n      N\
    \ denotes the number of source blocks into which the object shall\n      be partitioned.\n\
    \      G denotes the number of encoding symbols per group, i.e., the\n      number\
    \ of symbols sent in the same packet.\n      CR denotes the \"code rate\", i.e.,\
    \ the k/n ratio.\n      max_n denotes the maximum number of encoding symbols generated\
    \ for\n      any source block.  This is in particular the number of encoding\n\
    \      symbols generated for a source block of size B.\n      H denotes the parity\
    \ check matrix.\n      N1 denotes the target number of \"1s\" per column in the\
    \ left side\n      of the parity check matrix.\n      N1m3 denotes the value N1\
    \ - 3, where N1 is the target number of\n      \"1s\" per column in the left side\
    \ of the parity check matrix.\n      pmms_rand(m) denotes the pseudo-random number\
    \ generator defined in\n      Section 5.7 that returns a new random integer in\
    \ [0; m-1] each\n      time it is called.\n"
- title: 3.3.  Abbreviations
  contents:
  - "3.3.  Abbreviations\n   This document uses the following abbreviations:\n   \
    \   ESI: Encoding Symbol ID\n      FEC OTI: FEC Object Transmission Information\n\
    \      FPI: FEC Payload ID\n      LDPC: Low Density Parity Check\n      PRNG:\
    \ Pseudo-Random Number Generator\n"
- title: 4.  Formats and Codes
  contents:
  - '4.  Formats and Codes

    '
- title: 4.1.  FEC Payload IDs
  contents:
  - "4.1.  FEC Payload IDs\n   The FEC Payload ID is composed of the Source Block\
    \ Number and the\n   Encoding Symbol ID:\n      The Source Block Number (12-bit\
    \ field) identifies from which\n      source block of the object the encoding\
    \ symbol(s) in the packet\n      payload is(are) generated.  There is a maximum\
    \ of 2^^12 blocks per\n      object.  Source block numbering starts at 0.\n  \
    \    The Encoding Symbol ID (20-bit field) identifies which encoding\n      symbol(s)\
    \ generated from the source block is(are) carried in the\n      packet payload.\
    \  There is a maximum of 2^^20 encoding symbols per\n      block.  The first k\
    \ values (0 to k-1) identify source symbols, the\n      remaining n-k values (k\
    \ to n-k-1) identify repair symbols.\n   There MUST be exactly one FEC Payload\
    \ ID per packet.  In the case of\n   an Encoding Symbol Group, when multiple encoding\
    \ symbols are sent in\n   the same packet, the FEC Payload ID refers to the first\
    \ symbol of the\n   packet.  The other symbols can be deduced from the ESI of\
    \ the first\n   symbol thanks to a dedicated function, as explained in Section\
    \ 5.6\n    0                   1                   2                   3\n   \
    \ 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |  Source Block Number  |      Encoding Symbol ID (20 bits)     |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   Figure 1: FEC Payload ID encoding format for FEC Encoding ID 3 and 4\n"
- title: 4.2.  FEC Object Transmission Information
  contents:
  - '4.2.  FEC Object Transmission Information

    '
- title: 4.2.1.  Mandatory Element
  contents:
  - "4.2.1.  Mandatory Element\n   o  FEC Encoding ID: the LDPC-Staircase and LDPC-Triangle\
    \ Fully-\n      Specified FEC Schemes use the FEC Encoding ID 3 (Staircase) and\
    \ 4\n      (Triangle), respectively.\n"
- title: 4.2.2.  Common Elements
  contents:
  - "4.2.2.  Common Elements\n   The following elements MUST be defined with the present\
    \ FEC Schemes:\n   o  Transfer-Length (L): a non-negative integer indicating the\
    \ length\n      of the object in bytes.  There are some restrictions on the\n\
    \      maximum Transfer-Length that can be supported:\n         maximum transfer\
    \ length = 2^^12 * B * E\n      For instance, if B=2^^19 (because of a code rate\
    \ of 1/2,\n      Section 5.2), and if E=1024 bytes, then the maximum transfer\n\
    \      length is 2^^41 bytes (or 2 TB).  The upper limit, with symbols of\n  \
    \    size 2^^16-1 bytes and a code rate larger or equal to 1/2, amounts\n    \
    \  to 2^^47 bytes (or 128 TB).\n   o  Encoding-Symbol-Length (E): a non-negative\
    \ integer indicating the\n      length of each encoding symbol in bytes.\n   o\
    \  Maximum-Source-Block-Length (B): a non-negative integer indicating\n      the\
    \ maximum number of source symbols in a source block.  There are\n      some restrictions\
    \ on the maximum B value, as explained in\n      Section 5.2.\n   o  Max-Number-of-Encoding-Symbols\
    \ (max_n): a non-negative integer\n      indicating the maximum number of encoding\
    \ symbols generated for\n      any source block.  There are some restrictions\
    \ on the maximum\n      max_n value.  In particular max_n is at most equal to\
    \ 2^^20.\n   Section 5 explains how to define the values of each of these\n  \
    \ elements.\n"
- title: 4.2.3.  Scheme-Specific Elements
  contents:
  - "4.2.3.  Scheme-Specific Elements\n   The following elements MUST be defined with\
    \ the present FEC Scheme:\n   o  N1m3: an integer between 0 (default) and 7, inclusive.\
    \  The target\n      number of \"1s\" per column in the left side of the parity\
    \ check\n      matrix, N1, is then equal to N1m3 + 3 (see Sections 6.2 and 7.2).\n\
    \      Using the default value of 0 for N1m3 is recommended when the\n      sender\
    \ has no information on the decoding scheme used by the\n      receivers.  A value\
    \ greater than 0 for N1m3 can be a good choice\n      in specific situations,\
    \ e.g., with LDPC-staircase codes when the\n      sender knows that all the receivers\
    \ use a Gaussian elimination\n      decoding scheme.  Nevertheless, the current\
    \ document does not\n      mandate any specific value.  This choice is left to\
    \ the codec\n      developer.\n   o  G: an integer between 1 (default) and 31,\
    \ inclusive, indicating\n      the number of encoding symbols per group (i.e.,\
    \ per packet).  The\n      default value is 1, meaning that each packet contains\
    \ exactly one\n      symbol.  Values greater than 1 can also be defined, as explained\n\
    \      in Section 5.3.\n   o  PRNG seed: the seed is a 32-bit unsigned integer\
    \ between 1 and\n      0x7FFFFFFE (i.e., 2^^31-2) inclusive.  This value is used\
    \ to\n      initialize the Pseudo-Random Number Generator (Section 5.7).\n"
- title: 4.2.4.  Encoding Format
  contents:
  - "4.2.4.  Encoding Format\n   This section shows two possible encoding formats\
    \ of the above FEC\n   OTI.  The present document does not specify when or how\
    \ these\n   encoding formats should be used.\n"
- title: 4.2.4.1.  Using the General EXT_FTI Format
  contents:
  - "4.2.4.1.  Using the General EXT_FTI Format\n   The FEC OTI binary format is the\
    \ following when the EXT_FTI mechanism\n   is used (e.g., within the Asynchronous\
    \ Layer Coding (ALC)\n   [RMT-PI-ALC] or NACK-Oriented Reliable Multicast (NORM)\
    \ [RMT-PI-NORM]\n   protocols).\n    0                   1                   2\
    \                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5\
    \ 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |   HET = 64    |    HEL = 5    |                               |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\
    \                               +\n   |                      Transfer-Length (L)\
    \                      |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |   Encoding Symbol Length (E)  | N1m3|    G    |   B (MSB)     |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |        B (LSB)        |   Max Nb of Enc. Symbols  (max_n)     |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                           PRNG seed                           |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \           Figure 2: EXT_FTI Header for FEC Encoding ID 3 and 4\n   In particular:\n\
    \   o  The Transfer-Length (L) field size (48 bits) is larger than the\n     \
    \ size required to store the maximum transfer length (Section 4.2.2)\n      for\
    \ field alignment purposes.\n   o  The Maximum-Source-Block-Length (B) field (20\
    \ bits) is split into\n      two parts: the 8 most significant bits (MSB) are\
    \ in the third 32-\n      bit word of the EXT_FTI, and the remaining 12 least\
    \ significant\n      bits (LSB) are in the fourth 32-bit word.\n"
- title: 4.2.4.2.  Using the FDT Instance (FLUTE-Specific)
  contents:
  - "4.2.4.2.  Using the FDT Instance (FLUTE-Specific)\n   When it is desired that\
    \ the FEC OTI be carried in the File Delivery\n   Table (FDT) Instance of a File\
    \ Delivery over Unidirectional Transport\n   (FLUTE) session [RMT-FLUTE], the\
    \ following XML attributes must be\n   described for the associated object:\n\
    \   o  FEC-OTI-FEC-Encoding-ID\n   o  FEC-OTI-Transfer-length\n   o  FEC-OTI-Encoding-Symbol-Length\n\
    \   o  FEC-OTI-Maximum-Source-Block-Length\n   o  FEC-OTI-Max-Number-of-Encoding-Symbols\n\
    \   o  FEC-OTI-Scheme-Specific-Info\n   The FEC-OTI-Scheme-Specific-Info contains\
    \ the string resulting from\n   the Base64 encoding [RFC4648] of the following\
    \ value:\n    0                   1                   2                   3\n\
    \    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                        PRNG seed                              |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   | N1m3|    G    |\n   +-+-+-+-+-+-+-+-+\n    Figure 3: FEC OTI Scheme-Specific\
    \ Information to be Included in the\n                 FDT Instance for FEC Encoding\
    \ ID 3 and 4\n   During Base64 encoding, the 5 bytes of the FEC OTI Scheme-Specific\n\
    \   Information are transformed into a string of 8 printable characters\n   (in\
    \ the 64-character alphabet) that is added to the FEC-OTI-Scheme-\n   Specific-Info\
    \ attribute.\n"
- title: 5.  Procedures
  contents:
  - "5.  Procedures\n   This section defines procedures that are common to FEC Encoding\
    \ IDs 3\n   and 4.\n"
- title: 5.1.  General
  contents:
  - "5.1.  General\n   The B (maximum source block length in symbols), E (encoding\
    \ symbol\n   length in bytes), and G (number of encoding symbols per group)\n\
    \   parameters are first determined.  The algorithms of Section 5.2 and\n   Section\
    \ 5.3 MAY be used to that purpose.  Using other algorithms is\n   possible without\
    \ compromising interoperability since the B, E, and G\n   parameters are communicated\
    \ to the receiver by means of the FEC OTI.\n   Then, the source object MUST be\
    \ partitioned using the block\n   partitioning algorithm specified in [RFC5052].\
    \  To that purpose, the\n   B, L (object transfer length in bytes), and E arguments\
    \ are provided.\n   As a result, the object is partitioned into N source blocks.\
    \  These\n   blocks are numbered consecutively from 0 to N-1.  The first I source\n\
    \   blocks consist of A_large source symbols, the remaining N-I source\n   blocks\
    \ consist of A_small source symbols.  Each source symbol is E\n   bytes in length,\
    \ except perhaps the last symbol, which may be\n   shorter.\n   Then, the max_n\
    \ (maximum number of encoding symbols generated for any\n   source block) parameter\
    \ is determined.  The algorithm in Section 5.4\n   MAY be used to that purpose.\
    \  Using another algorithm is possible\n   without compromising interoperability\
    \ since the max_n parameter is\n   communicated to the receiver by means of the\
    \ FEC OTI.\n   For each block, the actual number of encoding symbols, n, MUST\
    \ then\n   be determined using the \"n-algorithm\" detailed in Section 5.5.\n\
    \   Then, FEC encoding and decoding can be done block per block,\n   independently.\
    \  To that purpose, a parity check matrix is created,\n   that forms a system\
    \ of linear equations between the source and repair\n   symbols of a given block,\
    \ where the basic operator is XOR.\n   This parity check matrix is logically divided\
    \ into two parts: the\n   left side (from column 0 to k-1) describes the occurrences\
    \ of each\n   source symbol in the system of linear equations; the right side\
    \ (from\n   column k to n-1) describes the occurrences of each repair symbol in\n\
    \   the system of linear equations.  The only difference between the\n   LDPC-Staircase\
    \ and LDPC-Triangle schemes is the construction of this\n   right sub-matrix.\
    \  An entry (a \"1\") in the matrix at position (i,j)\n   (i.e., at row i and\
    \ column j) means that the symbol with ESI j\n   appears in equation i of the\
    \ system.\n   When the parity symbols have been created, the sender transmits\n\
    \   source and parity symbols.  The way this transmission occurs can\n   largely\
    \ impact the erasure recovery capabilities of the LDPC-* FEC.\n   In particular,\
    \ sending parity symbols in sequence is suboptimal.\n   Instead, it is usually\
    \ recommended to shuffle these symbols.  The\n   interested reader will find more\
    \ details in [NRFF05].\n   The following sections detail how the B, E, G, max_n,\
    \ and n\n   parameters are determined (in Sections 5.2, 5.3, 5.4 and 5.5,\n  \
    \ respectively).  Section 5.6 details how Encoding Symbol Groups are\n   created,\
    \ and finally, Section 5.7 covers the PRNG.\n"
- title: 5.2.  Determining the Maximum Source Block Length (B)
  contents:
  - "5.2.  Determining the Maximum Source Block Length (B)\n   The B parameter (maximum\
    \ source block length in symbols) depends on\n   several parameters: the code\
    \ rate (CR), the Encoding Symbol ID field\n   length of the FEC Payload ID (20\
    \ bits), as well as possible internal\n   codec limitations.\n   The B parameter\
    \ cannot be larger than the following values, derived\n   from the FEC Payload\
    \ ID limitations, for a given code rate:\n      max1_B = 2^^(20 - ceil(Log2(1/CR)))\n\
    \   Some common max1_B values are:\n   o  CR == 1 (no repair symbol): max1_B =\
    \ 2^^20 = 1,048,576\n   o  1/2 <= CR < 1: max1_B = 2^^19 = 524,288 symbols\n \
    \  o  1/4 <= CR < 1/2: max1_B = 2^^18 = 262,144 symbols\n   o  1/8 <= CR < 1/4:\
    \ max1_B = 2^^17 = 131,072 symbols\n   Additionally, a codec MAY impose other\
    \ limitations on the maximum\n   block size.  For instance, this is the case when\
    \ the codec uses\n   internally 16-bit unsigned integers to store the Encoding\
    \ Symbol ID,\n   since it does not enable to store all the possible values of\
    \ a 20-bit\n   field.  In that case, if for instance, 1/2 <= CR < 1, then the\n\
    \   maximum source block length is 2^^15.  Other limitations may also\n   apply,\
    \ for instance, because of a limited working memory size.  This\n   decision MUST\
    \ be clarified at implementation time, when the target\n   use case is known.\
    \  This results in a max2_B limitation.\n   Then, B is given by:\n      B = min(max1_B,\
    \ max2_B)\n   Note that this calculation is only required at the coder, since\
    \ the B\n   parameter is communicated to the decoder through the FEC OTI.\n"
- title: 5.3.  Determining the Encoding Symbol Length (E) and Number of Encoding
  contents:
  - "5.3.  Determining the Encoding Symbol Length (E) and Number of Encoding\n   \
    \   Symbols per Group (G)\n   The E parameter usually depends on the maximum transmission\
    \ unit on\n   the path (PMTU) from the source to each receiver.  In order to\n\
    \   minimize the protocol header overhead (e.g., the Layered Coding\n   Transport\
    \ (LCT), UDP, IPv4, or IPv6 headers in the case of ALC), E is\n   chosen to be\
    \ as large as possible.  In that case, E is chosen so that\n   the size of a packet\
    \ composed of a single symbol (G=1) remains below\n   but close to the PMTU.\n\
    \   However, other considerations can exist.  For instance, the E\n   parameter\
    \ can be made a function of the object transfer length.\n   Indeed, LDPC codes\
    \ are known to offer better protection for large\n   blocks.  In the case of small\
    \ objects, it can be advantageous to\n   reduce the encoding symbol length (E)\
    \ in order to artificially\n   increase the number of symbols and therefore the\
    \ block size.\n   In order to minimize the protocol header overhead, several symbols\n\
    \   can be grouped in the same Encoding Symbol Group (i.e., G > 1).\n   Depending\
    \ on how many symbols are grouped (G) and on the packet loss\n   rate (G symbols\
    \ are lost for each packet erasure), this strategy\n   might or might not be appropriate.\
    \  A balance must therefore be\n   found.\n   The current specification does not\
    \ mandate any value for either E or\n   G.  The current specification only provides\
    \ an example of possible\n   choices for E and G.  Note that this choice is made\
    \ by the sender,\n   and the E and G parameters are then communicated to the receiver\n\
    \   thanks to the FEC OTI.  Note also that the decoding algorithm used\n   influences\
    \ the choice of the E and G parameters.  Indeed, increasing\n   the number of\
    \ symbols will negatively impact the processing load when\n   decoding is based\
    \ (in part or totally) on Gaussian elimination,\n   whereas the impacts will be\
    \ rather low when decoding is based on the\n   trivial algorithm sketched in Section\
    \ 6.4.\n   Example:\n   Let us assume that the trivial decoding algorithm sketched\
    \ in\n   Section 6.4 is used.  First, define the target packet payload size,\n\
    \   pkt_sz (at most equal to the PMTU minus the size of the various\n   protocol\
    \ headers).  The pkt_sz must be chosen in such a way that the\n   symbol size\
    \ is an integer.  This can require that pkt_sz be a\n   multiple of 4, 8, or 16\
    \ (see the table below).  Then calculate the\n   number of packets in the object:\
    \ nb_pkts = ceil(L / pkt_sz).\n   Finally, thanks to nb_pkts, use the following\
    \ table to find a\n   possible G value.\n     +------------------------+----+-------------+-------------------+\n\
    \     |    Number of packets   |  G | Symbol size |         k         |\n    \
    \ +------------------------+----+-------------+-------------------+\n     |  \
    \   4000 <= nb_pkts    |  1 |    pkt_sz   |     4000 <= k     |\n     |      \
    \                  |    |             |                   |\n     | 1000 <= nb_pkts\
    \ < 4000 |  4 |  pkt_sz / 4 | 4000 <= k < 16000 |\n     |                    \
    \    |    |             |                   |\n     |  500 <= nb_pkts < 1000 |\
    \  8 |  pkt_sz / 8 |  4000 <= k < 8000 |\n     |                        |    |\
    \             |                   |\n     |   1 <= nb_pkts < 500   | 16 | pkt_sz\
    \ / 16 |   16 <= k < 8000  |\n     +------------------------+----+-------------+-------------------+\n"
- title: 5.4.  Determining the Maximum Number of Encoding Symbols Generated for
  contents:
  - "5.4.  Determining the Maximum Number of Encoding Symbols Generated for\n    \
    \  Any Source Block (max_n)\n   The following algorithm MAY be used by a sender\
    \ to determine the\n   maximum number of encoding symbols generated for any source\
    \ block\n   (max_n) as a function of B and the target code rate.  Since the max_n\n\
    \   parameter is communicated to the decoder by means of the FEC OTI,\n   another\
    \ method MAY be used to determine max_n.\n   Input:\n      B: Maximum source block\
    \ length, for any source block.  Section 5.2\n      MAY be used to determine its\
    \ value.\n      CR: FEC code rate, which is provided by the user (e.g., when\n\
    \      starting a FLUTE sending application).  It is expressed as a\n      floating\
    \ point value.  The CR value must be such that the\n      resulting number of\
    \ encoding symbols per block is at most equal to\n      2^^20 (Section 4.1).\n\
    \   Output:\n      max_n: Maximum number of encoding symbols generated for any\
    \ source\n      block.\n   Algorithm:\n      max_n = ceil(B / CR);\n      if (max_n\
    \ > 2^^20), then return an error (\"invalid code rate\");\n      (NB: if B has\
    \ been defined as explained in Section 5.2, this error\n      should never happen.)\n"
- title: 5.5.  Determining the Number of Encoding Symbols of a Block (n)
  contents:
  - "5.5.  Determining the Number of Encoding Symbols of a Block (n)\n   The following\
    \ algorithm, also called \"n-algorithm\", MUST be used by\n   the sender and the\
    \ receiver to determine the number of encoding\n   symbols for a given block (n)\
    \ as a function of B, k, and max_n.\n   Input:\n      B: Maximum source block\
    \ length, for any source block.  At a\n      sender, Section 5.2 MAY be used to\
    \ determine its value.  At a\n      receiver, this value MUST be extracted from\
    \ the received FEC OTI.\n      k: Current source block length.  At a sender or\
    \ receiver, the\n      block partitioning algorithm MUST be used to determine\
    \ its value.\n      max_n: Maximum number of encoding symbols generated for any\
    \ source\n      block.  At a sender, Section 5.4 MAY be used to determine its\n\
    \      value.  At a receiver, this value MUST be extracted from the\n      received\
    \ FEC OTI.\n   Output:\n      n: Number of encoding symbols generated for this\
    \ source block.\n   Algorithm:\n      n = floor(k * max_n / B);\n"
- title: 5.6.  Identifying the G Symbols of an Encoding Symbol Group
  contents:
  - "5.6.  Identifying the G Symbols of an Encoding Symbol Group\n   When multiple\
    \ encoding symbols are sent in the same packet, the FEC\n   Payload ID information\
    \ of the packet MUST refer to the first encoding\n   symbol.  It MUST then be\
    \ possible to identify each symbol from this\n   single FEC Payload ID.  To that\
    \ purpose, the symbols of an Encoding\n   Symbol Group (i.e., packet):\n   o \
    \ MUST all be either source symbols or repair symbols.  Therefore,\n      only\
    \ source packets and repair packets are permitted, not mixed\n      ones.\n  \
    \ o  are identified by a function, sender(resp.\n      receiver)_find_ESIs_of_group(),\
    \ that takes as argument:\n      *  for a sender, the index of the Encoding Symbol\
    \ Group (i.e.,\n         packet) that the application wants to create,\n     \
    \ *  for a receiver, the ESI information contained in the FEC\n         Payload\
    \ ID.\n      and returns a list of G Encoding Symbol IDs.  In the case of a\n\
    \      source packet, the G Encoding Symbol IDs are chosen consecutively,\n  \
    \    by incrementing the ESI.  In the case of a repair packet, the G\n      repair\
    \ symbols are chosen randomly, as explained below.\n   o  are stored in sequence\
    \ in the packet, without any padding.  In\n      other words, the last byte of\
    \ the i-th symbol is immediately\n      followed by the first byte of (i+1)-th\
    \ symbol.\n   The system must first be initialized by creating a random permutation\n\
    \   of the n-k indexes.  This initialization function MUST be called\n   immediately\
    \ after creating the parity check matrix.  More precisely,\n   since the PRNG\
    \ seed is not re-initialized, there must not have been a\n   call to the PRNG\
    \ function between the time the parity check matrix\n   has been initialized and\
    \ the time the following initialization\n   function is called.  This is true\
    \ both at a sender and at a receiver.\n   int *txseqToID;\n   int *IDtoTxseq;\n\
    \   /*\n    * Initialization function.\n    * Warning: use only when G > 1.\n\
    \    */\n   void\n   initialize_tables ()\n   {\n       int i;\n       int randInd;\n\
    \       int backup;\n       txseqToID = malloc((n-k) * sizeof(int));\n       IDtoTxseq\
    \ = malloc((n-k) * sizeof(int));\n       if (txseqToID == NULL || IDtoTxseq ==\
    \ NULL)\n           handle the malloc failures as appropriate...\n       /* initialize\
    \ the two tables that map ID\n        * (i.e., ESI-k) to/from TxSequence. */\n\
    \       for (i = 0; i < n - k; i++) {\n           IDtoTxseq[i] = i;\n        \
    \   txseqToID[i] = i;\n       }\n       /* now randomize everything */\n     \
    \  for (i = 0; i < n - k; i++) {\n           randInd = pmms_rand(n - k);\n   \
    \        backup  = IDtoTxseq[i];\n           IDtoTxseq[i] = IDtoTxseq[randInd];\n\
    \           IDtoTxseq[randInd] = backup;\n           txseqToID[IDtoTxseq[i]] =\
    \  i;\n           txseqToID[IDtoTxseq[randInd]] = randInd;\n       }\n       return;\n\
    \   }\n   It is then possible, at the sender, to determine the sequence of G\n\
    \   Encoding Symbol IDs that will be part of the group.\n   /*\n    * Determine\
    \ the sequence of ESIs for the packet under construction\n    * at a sender.\n\
    \    * Warning: use only when G > 1.\n    * PktIdx (IN):  index of the packet,\
    \ in\n    *               {0..ceil(k/G)+ceil((n-k)/G)} range\n    * ESIs[] (OUT):\
    \ list of ESIs for the packet\n    */\n   void\n   sender_find_ESIs_of_group (int\
    \      PktIdx,\n                              ESI_t    ESIs[])\n   {\n       int\
    \ i;\n       if (PktIdx < nbSourcePkts) {\n           /* this is a source packet\
    \ */\n           ESIs[0] = PktIdx * G;\n           for (i = 1; i < G; i++) {\n\
    \                   ESIs[i] = (ESIs[0] + i) % k;\n           }\n       } else\
    \ {\n           /* this is a repair packet */\n           for (i = 0; i < G; i++)\
    \ {\n               ESIs[i] =\n                   k +\n                   txseqToID[(i\
    \ + (PktIdx - nbSourcePkts) * G)\n                             % (n - k)];\n \
    \          }\n       }\n       return;\n   }\n   Similarly, upon receiving an\
    \ Encoding Symbol Group (i.e., packet), a\n   receiver can determine the sequence\
    \ of G Encoding Symbol IDs from the\n   first ESI, esi0, that is contained in\
    \ the FEC Payload ID.\n   /*\n    * Determine the sequence of ESIs for the packet\
    \ received.\n    * Warning: use only when G > 1.\n    * esi0 (IN):  : ESI contained\
    \ in the FEC Payload ID\n    * ESIs[] (OUT): list of ESIs for the packet\n   \
    \ */\n   void\n   receiver_find_ESIs_of_group (ESI_t    esi0,\n              \
    \                  ESI_t    ESIs[])\n   {\n       int i;\n       if (esi0 < k)\
    \ {\n           /* this is a source packet */\n           ESIs[0] = esi0;\n  \
    \         for (i = 1; i < G; i++) {\n               ESIs[i] = (esi0 + i) % k;\n\
    \           }\n       } else {\n           /* this is a repair packet */\n   \
    \        for (i = 0; i < G; i++) {\n               ESIs[i] =\n               \
    \    k +\n                   txseqToID[(i + IDtoTxseq[esi0 - k])\n           \
    \                  % (n - k)];\n           }\n       }\n   }\n"
- title: 5.7.  Pseudo-Random Number Generator
  contents:
  - "5.7.  Pseudo-Random Number Generator\n   The FEC Encoding IDs 3 and 4 rely on\
    \ a pseudo-random number generator\n   (PRNG) that must be fully specified, in\
    \ particular in order to enable\n   the receivers and the senders to build the\
    \ same parity check matrix.\n   The Park-Miler \"minimal standard\" PRNG [PM88]\
    \ MUST be used.  It\n   defines a simple multiplicative congruential algorithm:\
    \ Ij+1 = A * Ij\n   (modulo M), with the following choices: A = 7^^5 = 16807 and\
    \ M =\n   2^^31 - 1 = 2147483647.  A validation criteria of such a PRNG is the\n\
    \   following: if seed = 1, then the 10,000th value returned MUST be\n   equal\
    \ to 1043618065.\n   Several implementations of this PRNG are known and discussed\
    \ in the\n   literature.  An optimized implementation of this algorithm, using\n\
    \   only 32-bit mathematics, and which does not require any division, can\n  \
    \ be found in [rand31pmc].  It uses the Park and Miller algorithm\n   [PM88] with\
    \ the optimization suggested by D. Carta in [CA90].  The\n   history behind this\
    \ algorithm is detailed in [WI08].  Yet, any other\n   implementation of the PRNG\
    \ algorithm that matches the above\n   validation criteria, like the ones detailed\
    \ in [PM88], is\n   appropriate.\n   This PRNG produces, natively, a 31-bit value\
    \ between 1 and 0x7FFFFFFE\n   (2^^31-2) inclusive.  Since it is desired to scale\
    \ the pseudo-random\n   number between 0 and maxv-1 inclusive, one must keep the\
    \ most\n   significant bits of the value returned by the PRNG (the least\n   significant\
    \ bits are known to be less random, and modulo-based\n   solutions should be avoided\
    \ [PTVF92]).  The following algorithm MUST\n   be used:\n   Input:\n      raw_value:\
    \ random integer generated by the inner PRNG algorithm,\n      between 1 and 0x7FFFFFFE\
    \ (2^^31-2) inclusive.\n      maxv: upper bound used during the scaling operation.\n\
    \   Output:\n      scaled_value: random integer between 0 and maxv-1 inclusive.\n\
    \   Algorithm:\n      scaled_value = (unsigned long) ((double)maxv * (double)raw_value\
    \ /\n      (double)0x7FFFFFFF);\n      (NB: the above C type casting to unsigned\
    \ long is equivalent to\n      using floor() with positive floating point values.)\n\
    \   In this document, pmms_rand(maxv) denotes the PRNG function that\n   implements\
    \ the Park-Miller \"minimal standard\" algorithm, defined\n   above, and that\
    \ scales the raw value between 0 and maxv-1 inclusive,\n   using the above scaling\
    \ algorithm.  Additionally, a function should\n   be provided to enable the initialization\
    \ of the PRNG with a seed\n   (i.e., a 31-bit integer between 1 and 0x7FFFFFFE\
    \ inclusive) before\n   calling pmms_rand(maxv) the first time.\n"
- title: 6.  Full Specification of the LDPC-Staircase Scheme
  contents:
  - '6.  Full Specification of the LDPC-Staircase Scheme

    '
- title: 6.1.  General
  contents:
  - "6.1.  General\n   The LDPC-Staircase scheme is identified by the Fully-Specified\
    \ FEC\n   Encoding ID 3.\n   The PRNG used by the LDPC-Staircase scheme must be\
    \ initialized by a\n   seed.  This PRNG seed is an instance-specific FEC OTI attribute\n\
    \   (Section 4.2.3).\n"
- title: 6.2.  Parity Check Matrix Creation
  contents:
  - "6.2.  Parity Check Matrix Creation\n   The LDPC-Staircase matrix can be divided\
    \ into two parts: the left\n   side of the matrix defines in which equations the\
    \ source symbols are\n   involved; the right side of the matrix defines in which\
    \ equations the\n   repair symbols are involved.\n   The left side MUST be generated\
    \ by using the following function:\n"
- title: /*
  contents:
  - "/*\n * Initialize the left side of the parity check matrix.\n * This function\
    \ assumes that an empty matrix of size n-k * k has\n * previously been allocated/reset\
    \ and that the matrix_has_entry(),\n * matrix_insert_entry() and degree_of_row()\
    \ functions can access it.\n * (IN): the k, n and N1 parameters.\n */\n"
- title: void left_matrix_init (int k, int n, int N1)
  contents:
  - 'void left_matrix_init (int k, int n, int N1)

    '
- title: '{'
  contents:
  - "{\n    int i;      /* row index or temporary variable */\n    int j;      /*\
    \ column index */\n    int h;      /* temporary variable */\n    int t;      /*\
    \ left limit within the list of possible choices u[] */\n    int u[N1*MAX_K];\
    \ /* table used to have a homogeneous 1 distrib. */\n    /* Initialize a list\
    \ of all possible choices in order to\n     * guarantee a homogeneous \"1\" distribution\
    \ */\n    for (h = N1*k-1; h >= 0; h--) {\n        u[h] = h % (n-k);\n    }\n\
    \    /* Initialize the matrix with N1 \"1s\" per column, homogeneously */\n  \
    \  t = 0;\n    for (j = 0; j < k; j++) { /* for each source symbol column */\n\
    \        for (h = 0; h < N1; h++) { /* add N1 \"1s\" */\n            /* check\
    \ that valid available choices remain */\n            for (i = t; i < N1*k &&\
    \ matrix_has_entry(u[i], j); i++);\n            if (i < N1*k) {\n            \
    \    /* choose one index within the list of possible\n                 * choices\
    \ */\n                do {\n                    i = t + pmms_rand(N1*k-t);\n \
    \               } while (matrix_has_entry(u[i], j));\n                matrix_insert_entry(u[i],\
    \ j);\n                /* replace with u[t] which has never been chosen */\n \
    \               u[i] = u[t];\n                t++;\n            } else {\n   \
    \             /* no choice left, choose one randomly */\n                do {\n\
    \                    i = pmms_rand(n-k);\n                } while (matrix_has_entry(i,\
    \ j));\n                matrix_insert_entry(i, j);\n            }\n        }\n\
    \    }\n    /* Add extra bits to avoid rows with less than two \"1s\".\n     *\
    \ This is needed when the code rate is smaller than 2/(2+N1) */\n    for (i =\
    \ 0; i < n-k; i++) { /* for each row */\n        if (degree_of_row(i) == 0) {\n\
    \            j = pmms_rand(k);\n            matrix_insert_entry(i, j);\n     \
    \   }\n        if (degree_of_row(i) == 1) {\n            do {\n              \
    \  j = pmms_rand(k);\n            } while (matrix_has_entry(i, j));\n        \
    \    matrix_insert_entry(i, j);\n        }\n    }\n"
- title: '}'
  contents:
  - "}\n   The right side (the staircase) MUST be generated by using the\n   following\
    \ function:\n   /*\n    * Initialize the right side of the parity check matrix\
    \ with a\n    * staircase structure.\n    * (IN): the k and n parameters.\n  \
    \  */\n   void right_matrix_staircase_init (int k, int n)\n   {\n       int i;\
    \      /* row index */\n       matrix_insert_entry(0, k);    /* first row */\n\
    \       for (i = 1; i < n-k; i++) {   /* for the following rows */\n         \
    \  matrix_insert_entry(i, k+i);   /* identity */\n           matrix_insert_entry(i,\
    \ k+i-1); /* staircase */\n       }\n   }\n   Note that just after creating this\
    \ parity check matrix, when Encoding\n   Symbol Groups are used (i.e., G > 1),\
    \ the function initializing the\n   two random permutation tables (Section 5.6)\
    \ MUST be called.  This is\n   true both at a sender and at a receiver.\n"
- title: 6.3.  Encoding
  contents:
  - "6.3.  Encoding\n   Thanks to the staircase matrix, repair symbol creation is\n\
    \   straightforward: each repair symbol is equal to the sum of all source\n  \
    \ symbols in the associated equation, plus the previous repair symbol\n   (except\
    \ for the first repair symbol).  Therefore, encoding MUST\n   follow the natural\
    \ repair symbol order: start with the first repair\n   symbol and generate a repair\
    \ symbol with ESI i before a symbol with\n   ESI i+1.\n"
- title: 6.4.  Decoding
  contents:
  - "6.4.  Decoding\n   Decoding basically consists in solving a system of n-k linear\n\
    \   equations whose variables are the n source and repair symbols.  Of\n   course,\
    \ the final goal is to recover the value of the k source\n   symbols only.\n \
    \  To that purpose, many techniques are possible.  One of them is the\n   following\
    \ trivial algorithm [ZP74]: given a set of linear equations,\n   if one of them\
    \ has only one remaining unknown variable, then the\n   value of this variable\
    \ is that of the constant term.  So, replace\n   this variable by its value in\
    \ all the remaining linear equations and\n   reiterate.  The value of several\
    \ variables can therefore be found\n   recursively.  Applied to LDPC FEC codes\
    \ working over an erasure\n   channel, the parity check matrix defines a set of\
    \ linear equations\n   whose variables are the source symbols and repair symbols.\
    \  Receiving\n   or decoding a symbol is equivalent to having the value of a variable.\n\
    \   Appendix A sketches a possible implementation of this algorithm.\n   A Gaussian\
    \ elimination (or any optimized derivative) is another\n   possible decoding technique.\
    \  Hybrid solutions that start by using\n   the trivial algorithm above and finish\
    \ with a Gaussian elimination\n   are also possible [CR08].\n   Because interoperability\
    \ does not depend on the decoding algorithm\n   used, the current document does\
    \ not recommend any particular\n   technique.  This choice is left to the codec\
    \ developer.\n   However, choosing a decoding technique will have great practical\n\
    \   impacts.  It will impact the erasure capabilities: a Gaussian\n   elimination\
    \ enables to solve the system with a smaller number of\n   known symbols compared\
    \ to the trivial technique.  It will also impact\n   the CPU load: a Gaussian\
    \ elimination requires more processing than\n   the above trivial algorithm. \
    \ Depending on the target use case, the\n   codec developer will favor one feature\
    \ or the other.\n"
- title: 7.   Full Specification of the LDPC-Triangle Scheme
  contents:
  - '7.   Full Specification of the LDPC-Triangle Scheme

    '
- title: 7.1.  General
  contents:
  - "7.1.  General\n   LDPC-Triangle is identified by the Fully-Specified FEC Encoding\
    \ ID 4.\n   The PRNG used by the LDPC-Triangle scheme must be initialized by a\n\
    \   seed.  This PRNG seed is an instance-specific FEC OTI attribute\n   (Section\
    \ 4.2.3).\n"
- title: 7.2.  Parity Check Matrix Creation
  contents:
  - "7.2.  Parity Check Matrix Creation\n   The LDPC-Triangle matrix can be divided\
    \ into two parts: the left side\n   of the matrix defines in which equations the\
    \ source symbols are\n   involved; the right side of the matrix defines in which\
    \ equations the\n   repair symbols are involved.\n   The left side MUST be generated\
    \ by using the same left_matrix_init()\n   function as with LDPC-Staircase (Section\
    \ 6.2).\n   The right side (the triangle) MUST be generated by using the\n   following\
    \ function:\n   /*\n    * Initialize the right side of the parity check matrix\
    \ with a\n    * triangle structure.\n    * (IN): the k and n parameters.\n   \
    \ */\n   void right_matrix_staircase_init (int k, int n)\n   {\n       int i;\
    \      /* row index */\n       int j;      /* randomly chosen column indexes in\
    \ 0..n-k-2 */\n       int l;      /* limitation of the # of \"1s\" added per row\
    \ */\n       matrix_insert_entry(0, k);    /* first row */\n       for (i = 1;\
    \ i < n-k; i++) {   /* for the following rows */\n           matrix_insert_entry(i,\
    \ k+i);   /* identity */\n           matrix_insert_entry(i, k+i-1); /* staircase\
    \ */\n           /* now fill the triangle */\n           j = i-1;\n          \
    \ for (l = 0; l < j; l++) { /* limit the # of \"1s\" added */\n              \
    \ j = pmms_rand(j);\n               matrix_insert_entry(i, k+j);\n           }\n\
    \       }\n   }\n   Note that just after creating this parity check matrix, when\
    \ Encoding\n   Symbol Groups are used (i.e., G > 1), the function initializing\
    \ the\n   two random permutation tables (Section 5.6) MUST be called.  This is\n\
    \   true both at a sender and at a receiver.\n"
- title: 7.3.  Encoding
  contents:
  - "7.3.  Encoding\n   Here also, repair symbol creation is straightforward: each\
    \ repair\n   symbol of ESI i is equal to the sum of all source and repair symbols\n\
    \   (with ESI lower than i) in the associated equation.  Therefore,\n   encoding\
    \ MUST follow the natural repair symbol order: start with the\n   first repair\
    \ symbol, and generate repair symbol with ESI i before\n   symbol with ESI i+1.\n"
- title: 7.4.  Decoding
  contents:
  - "7.4.  Decoding\n   Decoding basically consists in solving a system of n-k linear\n\
    \   equations, whose variables are the n source and repair symbols.  Of\n   course,\
    \ the final goal is to recover the value of the k source\n   symbols only.  To\
    \ that purpose, many techniques are possible, as\n   explained in Section 6.4.\n\
    \   Because interoperability does not depend on the decoding algorithm\n   used,\
    \ the current document does not recommend any particular\n   technique.  This\
    \ choice is left to the codec implementer.\n"
- title: 8.  Security Considerations
  contents:
  - '8.  Security Considerations

    '
- title: 8.1.  Problem Statement
  contents:
  - "8.1.  Problem Statement\n   A content delivery system is potentially subject\
    \ to many attacks:\n   some of them target the network (e.g., to compromise the\
    \ routing\n   infrastructure, by compromising the congestion control component),\n\
    \   others target the Content Delivery Protocol (CDP) (e.g., to\n   compromise\
    \ its normal behavior), and finally some attacks target the\n   content itself.\
    \  Since this document focuses on an FEC building block\n   independently of any\
    \ particular CDP (even if ALC and NORM are two\n   natural candidates), this section\
    \ only discusses the additional\n   threats that an arbitrary CDP may be exposed\
    \ to when using this\n   building block.\n   More specifically, several kinds\
    \ of attacks exist:\n   o  those that are meant to give access to a confidential\
    \ content\n      (e.g., in case of a non-free content),\n   o  those that try\
    \ to corrupt the object being transmitted (e.g., to\n      inject malicious code\
    \ within an object, or to prevent a receiver\n      from using an object), and\n\
    \   o  those that try to compromise the receiver's behavior (e.g., by\n      making\
    \ the decoding of an object computationally expensive).\n   These attacks can\
    \ be launched either against the data flow itself\n   (e.g., by sending forged\
    \ symbols) or against the FEC parameters that\n   are sent either in-band (e.g.,\
    \ in an EXT_FTI or FDT Instance) or out-\n   of-band (e.g., in a session description).\n"
- title: 8.2.  Attacks Against the Data Flow
  contents:
  - "8.2.  Attacks Against the Data Flow\n   First of all, let us consider the attacks\
    \ against the data flow.\n"
- title: 8.2.1.  Access to Confidential Objects
  contents:
  - "8.2.1.  Access to Confidential Objects\n   Access control to a confidential object\
    \ being transmitted is\n   typically provided by means of encryption.  This encryption\
    \ can be\n   done over the whole object (e.g., by the content provider, before\
    \ the\n   FEC encoding process), or be done on a packet per packet basis (e.g.,\n\
    \   when IPsec/ESP is used [RFC4303]).  If confidentiality is a concern,\n   it\
    \ is RECOMMENDED that one of these solutions be used.  Even if we\n   mention\
    \ these attacks here, they are not related or facilitated by\n   the use of FEC.\n"
- title: 8.2.2.  Content Corruption
  contents:
  - "8.2.2.  Content Corruption\n   Protection against corruptions (e.g., after sending\
    \ forged packets)\n   is achieved by means of a content integrity verification/sender\n\
    \   authentication scheme.  This service can be provided at the object\n   level,\
    \ but in that case a receiver has no way to identify which\n   symbol(s) is(are)\
    \ corrupted if the object is detected as corrupted.\n   This service can also\
    \ be provided at the packet level.  In this case,\n   after removing all forged\
    \ packets, the object may be, in some cases,\n   recovered.  Several techniques\
    \ can provide this source\n   authentication/content integrity service:\n   o\
    \  at the object level, the object MAY be digitally signed (with\n      public\
    \ key cryptography), for instance, by using RSASSA-PKCS1-v1_5\n      [RFC3447].\
    \  This signature enables a receiver to check the object\n      integrity, once\
    \ the latter has been fully decoded.  Even if\n      digital signatures are computationally\
    \ expensive, this calculation\n      occurs only once per object, which is usually\
    \ acceptable;\n   o  at the packet level, each packet can be digitally signed.\
    \  A major\n      limitation is the high computational and transmission overheads\n\
    \      that this solution requires (unless perhaps if Elliptic Curve\n      Cryptography\
    \ (ECC) is used).  To avoid this problem, the signature\n      may span a set\
    \ of symbols (instead of a single one) in order to\n      amortize the signature\
    \ calculation.  But if a single symbol is\n      missing, the integrity of the\
    \ whole set cannot be checked;\n   o  at the packet level, a Group Message Authentication\
    \ Code (MAC)\n      [RFC2104] scheme can be used, for instance, by using HMAC-SHA-1\n\
    \      with a secret key shared by all the group members, senders, and\n     \
    \ receivers.  This technique creates a cryptographically secured\n      (thanks\
    \ to the secret key) digest of a packet that is sent along\n      with the packet.\
    \  The Group MAC scheme does not create a\n      prohibitive processing load or\
    \ transmission overhead, but it has a\n      major limitation: it only provides\
    \ a group authentication/\n      integrity service since all group members share\
    \ the same secret\n      group key, which means that each member can send a forged\
    \ packet.\n      It is therefore restricted to situations where group members\
    \ are\n      fully trusted (or in association with another technique such as a\n\
    \      pre-check);\n   o  at the packet level, Timed Efficient Stream Loss-Tolerant\n\
    \      Authentication (TESLA) [RFC4082] is an attractive solution that is\n  \
    \    robust to losses, provides a true authentication/integrity\n      service,\
    \ and does not create any prohibitive processing load or\n      transmission overhead.\
    \  Yet, checking a packet requires a small\n      delay (a second or more) after\
    \ its reception.\n   Techniques relying on public key cryptography (digital signatures\
    \ and\n   TESLA during the bootstrap process, when used) require that public\n\
    \   keys be securely associated to the entities.  This can be achieved by\n  \
    \ a Public Key Infrastructure (PKI), or by a PGP Web of Trust, or by\n   pre-distributing\
    \ the public keys of each group member.\n   Techniques relying on symmetric key\
    \ cryptography (Group MAC) require\n   that a secret key be shared by all group\
    \ members.  This can be\n   achieved by means of a group key management protocol,\
    \ or simply by\n   pre-distributing the secret key (but this manual solution has\
    \ many\n   limitations).\n   It is up to the CDP developer, who knows the security\
    \ requirements\n   and features of the target application area, to define which\
    \ solution\n   is the most appropriate.  Nonetheless, in case there is any concern\n\
    \   of the threat of object corruption, it is RECOMMENDED that at least\n   one\
    \ of these techniques be used.\n"
- title: 8.3.  Attacks Against the FEC Parameters
  contents:
  - "8.3.  Attacks Against the FEC Parameters\n   Let us now consider attacks against\
    \ the FEC parameters (or FEC OTI).\n   The FEC OTI can either be sent in-band\
    \ (i.e., in an EXT_FTI or in an\n   FDT Instance containing FEC OTI for the object)\
    \ or out-of-band (e.g.,\n   in a session description).  Attacks on these FEC parameters\
    \ can\n   prevent the decoding of the associated object: for instance,\n   modifying\
    \ the B parameter will lead to a different block\n   partitioning.\n   It is therefore\
    \ RECOMMENDED that security measures be taken to\n   guarantee the FEC OTI integrity.\
    \  To that purpose, the packets\n   carrying the FEC parameters sent in-band in\
    \ an EXT_FTI header\n   extension SHOULD be protected by one of the per-packet\
    \ techniques\n   described above: digital signature, Group MAC, or TESLA.  When\
    \ FEC\n   OTI is contained in an FDT Instance, this object SHOULD be protected,\n\
    \   for instance, by digitally signing it with XML digital signatures\n   [RFC3275].\
    \  Finally, when FEC OTI is sent out-of-band (e.g., in a\n   session description)\
    \ the latter SHOULD be protected, for instance, by\n   digitally signing it with\
    \ [RFC3852].\n   The same considerations concerning the key management aspects\
    \ apply\n   here, also.\n"
- title: 9.  IANA Considerations
  contents:
  - "9.  IANA Considerations\n   Values of FEC Encoding IDs and FEC Instance IDs are\
    \ subject to IANA\n   registration.  For general guidelines on IANA considerations\
    \ as they\n   apply to this document, see [RFC5052].\n   This document assigns\
    \ the Fully-Specified FEC Encoding ID 3 under the\n   \"ietf:rmt:fec:encoding\"\
    \ name-space to \"LDPC Staircase Codes\".\n   This document assigns the Fully-Specified\
    \ FEC Encoding ID 4 under the\n   \"ietf:rmt:fec:encoding\" name-space to \"LDPC\
    \ Triangle Codes\".\n"
- title: 10.  Acknowledgments
  contents:
  - "10.  Acknowledgments\n   Section 5.5 is derived from an earlier document, and\
    \ we would like to\n   thank S. Peltotalo and J. Peltotalo for their contribution.\
    \  We would\n   also like to thank Pascal Moniot, Laurent Fazio, Mathieu Cunche,\n\
    \   Aurelien Francillon, Shao Wenjian, Magnus Westerlund, Brian\n   Carpenter,\
    \ Tim Polk, Jari Arkko, Chris Newman, Robin Whittle, and\n   Alfred Hoenes for\
    \ their comments.\n   Last but not least, the authors are grateful to Radford\
    \ M. Neal\n   (University of Toronto) whose LDPC software\n   (http://www.cs.toronto.edu/~radford/ldpc.software.html)\
    \ inspired this\n   work.\n"
- title: 11.  References
  contents:
  - '11.  References

    '
- title: 11.1.  Normative References
  contents:
  - "11.1.  Normative References\n   [RFC2119]      Bradner, S., \"Key words for use\
    \ in RFCs to Indicate\n                  Requirement Levels\", RFC 2119, BCP 14,\
    \ March 1997.\n   [RFC5052]      Watson, M., Luby, M., and L. Vicisano, \"Forward\
    \ Error\n                  Correction (FEC) Building Block\", RFC 5052,\n    \
    \              August 2007.\n"
- title: 11.2.  Informative References
  contents:
  - "11.2.  Informative References\n   [ZP74]         Zyablov, V. and M. Pinsker,\
    \ \"Decoding Complexity of\n                  Low-Density Codes for Transmission\
    \ in a Channel with\n                  Erasures\", Translated from Problemy Peredachi\n\
    \                  Informatsii, Vol.10, No. 1, pp.15-28, January-\n          \
    \        March 1974.\n   [RN04]         Roca, V. and C. Neumann, \"Design, Evaluation\
    \ and\n                  Comparison of Four Large Block FEC Codecs: LDPC, LDGM,\n\
    \                  LDGM-Staircase and LDGM-Triangle, Plus a Reed-Solomon\n   \
    \               Small Block FEC Codec\", INRIA Research Report RR-5225,\n    \
    \              June 2004.\n   [NRFF05]       Neumann, C., Roca, V., Francillon,\
    \ A., and D. Furodet,\n                  \"Impacts of Packet Scheduling and Packet\
    \ Loss\n                  Distribution on FEC Performances: Observations and\n\
    \                  Recommendations\", ACM CoNEXT'05 Conference, Toulouse,\n  \
    \                France (an extended version is available as INRIA\n         \
    \         Research Report RR-5578), October 2005.\n   [CR08]         Cunche, M.\
    \ and V. Roca, \"Improving the Decoding of\n                  LDPC Codes for the\
    \ Packet Erasure Channel with a\n                  Hybrid Zyablov Iterative Decoding/Gaussian\
    \ Elimination\n                  Scheme\", INRIA Research Report RR-6473, March\
    \ 2008.\n   [LDPC-codec]   Roca, V., Neumann, C., Cunche, M., and J. Laboure,\n\
    \                  \"LDPC-Staircase/LDPC-Triangle Codec Reference\n          \
    \        Implementation\", INRIA Rhone-Alpes and\n                  STMicroelectronics,\n\
    \                  <http://planete-bcast.inrialpes.fr/>.\n   [MK03]         MacKay,\
    \ D., \"Information Theory, Inference and\n                  Learning Algorithms\"\
    , Cambridge University\n                  Press, ISBN: 0-521-64298-1, 2003.\n\
    \   [PM88]         Park, S. and K. Miller, \"Random Number Generators:\n     \
    \             Good Ones are Hard to Find\", Communications of the\n          \
    \        ACM, Vol. 31, No. 10, pp.1192-1201, 1988.\n   [CA90]         Carta, D.,\
    \ \"Two Fast Implementations of the Minimal\n                  Standard Random\
    \ Number Generator\", Communications of\n                  the ACM, Vol. 33, No.\
    \ 1, pp.87-88, January 1990.\n   [WI08]         Whittle, R., \"Park-Miller-Carta\
    \ Pseudo-Random Number\n                  Generator\", January 2008,\n       \
    \           <http://www.firstpr.com.au/dsp/rand31/>.\n   [rand31pmc]    Whittle,\
    \ R., \"31 bit pseudo-random number generator\",\n                  September\
    \ 2005, <http://www.firstpr.com.au/dsp/rand31/\n                  rand31-park-miller-carta.cc.txt>.\n\
    \   [PTVF92]       Press, W., Teukolsky, S., Vetterling, W., and B.\n        \
    \          Flannery, \"Numerical Recipes in C; Second Edition\",\n           \
    \       Cambridge University Press, ISBN: 0-521-43108-5, 1992.\n   [RMT-PI-ALC]\
    \   Luby, M., Watson, M., and L. Vicisano, \"Asynchronous\n                  Layered\
    \ Coding (ALC) Protocol Instantiation\", Work\n                  in Progress,\
    \ November 2007.\n   [RMT-PI-NORM]  Adamson, B., Bormann, C., Handley, M., and\
    \ J. Macker,\n                  \"Negative-acknowledgment (NACK)-Oriented Reliable\n\
    \                  Multicast (NORM) Protocol\", Work in Progress,\n          \
    \        January 2008.\n   [RMT-FLUTE]    Paila, T., Walsh, R., Luby, M., Lehtonen,\
    \ R., and V.\n                  Roca, \"FLUTE - File Delivery over Unidirectional\n\
    \                  Transport\", Work in Progress, October 2007.\n   [RFC3447]\
    \      Jonsson, J. and B. Kaliski, \"Public-Key Cryptography\n               \
    \   Standards (PKCS) #1: RSA Cryptography Specifications\n                  Version\
    \ 2.1\", RFC 3447, February 2003.\n   [RFC4303]      Kent, S., \"IP Encapsulating\
    \ Security Payload (ESP)\",\n                  RFC 4303, December 2005.\n   [RFC2104]\
    \      \"HMAC: Keyed-Hashing for Message Authentication\",\n                 \
    \ RFC 2104, February 1997.\n   [RFC4082]      \"Timed Efficient Stream Loss-Tolerant\
    \ Authentication\n                  (TESLA): Multicast Source Authentication Transform\n\
    \                  Introduction\", RFC 4082, June 2005.\n   [RFC3275]      Eastlake,\
    \ D., Reagle, J., and D. Solo, \"(Extensible\n                  Markup Language)\
    \ XML-Signature Syntax and Processing\",\n                  RFC 3275, March 2002.\n\
    \   [RFC3453]      Luby, M., Vicisano, L., Gemmell, J., Rizzo, L.,\n         \
    \         Handley, M., and J. Crowcroft, \"The Use of Forward\n              \
    \    Error Correction (FEC) in Reliable Multicast\",\n                  RFC 3453,\
    \ December 2002.\n   [RFC3852]      Housley, R., \"Cryptographic Message Syntax\
    \ (CMS)\",\n                  RFC 3852, July 2004.\n   [RFC4648]      Josefsson,\
    \ S., \"The Base16, Base32, and Base64 Data\n                  Encodings\", RFC\
    \ 4648, October 2006.\n"
- title: Appendix A.  Trivial Decoding Algorithm (Informative Only)
  contents:
  - "Appendix A.  Trivial Decoding Algorithm (Informative Only)\n   A trivial decoding\
    \ algorithm is sketched below (please see\n   [LDPC-codec] for the details omitted\
    \ here):\n   Initialization: allocate a table partial_sum[n-k] of buffers, each\n\
    \                   buffer being of size the symbol size.  There's one\n     \
    \              entry per equation since the buffers are meant to\n           \
    \        store the partial sum of each equation; Reset all\n                 \
    \  the buffers to zero;\n   /*\n    * For each newly received or decoded symbol,\
    \ try to make progress\n    * in the decoding of the associated source block.\n\
    \    * NB: in case of a symbol group (G>1), this function is called for\n    *\
    \ each symbol of the received packet.\n    * NB: a callback function indicates\
    \ to the caller that new symbol(s)\n    *     has(have) been decoded.\n    * new_esi\
    \  (IN):  ESI of the new symbol received or decoded\n    * new_symb (IN):  Buffer\
    \ of the new symbol received or decoded\n    */\n   void\n   decoding_step(ESI_t\
    \     new_esi,\n                 symbol_t  *new_symb)\n   {\n       If (new_symb\
    \ is an already decoded or received symbol) {\n           Return;        /* don't\
    \ waste time with this symbol */\n       }\n       If (new_symb is the last missing\
    \ source symbol) {\n           Remember that decoding is finished;\n         \
    \  Return;        /* work is over now... */\n       }\n       Create an empty\
    \ list of equations having symbols decoded\n       during this decoding step;\n\
    \       /*\n        * First add this new symbol to the partial sum of all the\n\
    \        * equations where the symbol appears.\n        */\n       For (each equation\
    \ eq in which new_symb is a variable and\n            having more than one unknown\
    \ variable) {\n           Add new_symb to partial_sum[eq];\n           Remove\
    \ entry(eq, new_esi) from the H matrix;\n           If (the new degree of equation\
    \ eq == 1) {\n               /* a new symbol can be decoded, remember the\n  \
    \              * equation */\n               Append eq to the list of equations\
    \ having symbols\n               decoded during this decoding step;\n        \
    \   }\n       }\n       /*\n        * Then finish with recursive calls to decoding_step()\
    \ for each\n        * newly decoded symbol.\n        */\n       For (each equation\
    \ eq in the list of equations having symbols\n            decoded during this\
    \ decoding step) {\n           /*\n            * Because of the recursion below,\
    \ we need to check that\n            * decoding is not finished, and that the\
    \ equation is\n            * __still__ of degree 1\n            */\n         \
    \  If (decoding is finished) {\n               break;        /* exit from the\
    \ loop */\n           }\n           If ((degree of equation eq == 1) {\n     \
    \          Let dec_esi be the ESI of the newly decoded symbol in\n           \
    \    equation eq;\n               Remove entry(eq, dec_esi);\n               Allocate\
    \ a buffer, dec_symb, for this symbol and\n               copy partial_sum[eq]\
    \ to dec_symb;\n               Inform the caller that a new symbol has been\n\
    \               decoded via a callback function;\n               /* finally, call\
    \ this function recursively */\n               decoding_step(dec_esi, dec_symb);\n\
    \           }\n       }\n       Free the list of equations having symbols decoded;\n\
    \       Return;\n   }\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Vincent Roca\n   INRIA\n   655, av. de l'Europe\n   Inovallee;\
    \ Montbonnot\n   ST ISMIER cedex  38334\n   France\n   EMail: vincent.roca@inria.fr\n\
    \   URI:   http://planete.inrialpes.fr/people/roca/\n   Christoph Neumann\n  \
    \ Thomson\n   12, bd de Metz\n   Rennes  35700\n   France\n   EMail: christoph.neumann@thomson.net\n\
    \   URI:   http://planete.inrialpes.fr/people/chneuman/\n   David Furodet\n  \
    \ STMicroelectronics\n   12, Rue Jules Horowitz\n   BP217\n   Grenoble Cedex \
    \ 38019\n   France\n   EMail: david.furodet@st.com\n   URI:   http://www.st.com/\n"
- title: Full Copyright Statement
  contents:
  - "Full Copyright Statement\n   Copyright (C) The IETF Trust (2008).\n   This document\
    \ is subject to the rights, licenses and restrictions\n   contained in BCP 78,\
    \ and except as set forth therein, the authors\n   retain all their rights.\n\
    \   This document and the information contained herein are provided on an\n  \
    \ \"AS IS\" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS\n  \
    \ OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY, THE IETF TRUST AND\n   THE\
    \ INTERNET ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS\n   OR IMPLIED,\
    \ INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF\n   THE INFORMATION\
    \ HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED\n   WARRANTIES OF MERCHANTABILITY\
    \ OR FITNESS FOR A PARTICULAR PURPOSE.\n"
- title: Intellectual Property
  contents:
  - "Intellectual Property\n   The IETF takes no position regarding the validity or\
    \ scope of any\n   Intellectual Property Rights or other rights that might be\
    \ claimed to\n   pertain to the implementation or use of the technology described\
    \ in\n   this document or the extent to which any license under such rights\n\
    \   might or might not be available; nor does it represent that it has\n   made\
    \ any independent effort to identify any such rights.  Information\n   on the\
    \ procedures with respect to rights in RFC documents can be\n   found in BCP 78\
    \ and BCP 79.\n   Copies of IPR disclosures made to the IETF Secretariat and any\n\
    \   assurances of licenses to be made available, or the result of an\n   attempt\
    \ made to obtain a general license or permission for the use of\n   such proprietary\
    \ rights by implementers or users of this\n   specification can be obtained from\
    \ the IETF on-line IPR repository at\n   http://www.ietf.org/ipr.\n   The IETF\
    \ invites any interested party to bring to its attention any\n   copyrights, patents\
    \ or patent applications, or other proprietary\n   rights that may cover technology\
    \ that may be required to implement\n   this standard.  Please address the information\
    \ to the IETF at\n   ietf-ipr@ietf.org.\n"
