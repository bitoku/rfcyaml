- title: __initial_text__
  contents:
  - '            Network Management Datastore Architecture (NMDA)

    '
- title: Abstract
  contents:
  - "Abstract\n   Datastores are a fundamental concept binding the data models written\n\
    \   in the YANG data modeling language to network management protocols\n   such\
    \ as the Network Configuration Protocol (NETCONF) and RESTCONF.\n   This document\
    \ defines an architectural framework for datastores based\n   on the experience\
    \ gained with the initial simpler model, addressing\n   requirements that were\
    \ not well supported in the initial model.  This\n   document updates RFC 7950.\n"
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This is an Internet Standards Track document.\n   This\
    \ document is a product of the Internet Engineering Task Force\n   (IETF).  It\
    \ represents the consensus of the IETF community.  It has\n   received public\
    \ review and has been approved for publication by the\n   Internet Engineering\
    \ Steering Group (IESG).  Further information on\n   Internet Standards is available\
    \ in Section 2 of RFC 7841.\n   Information about the current status of this document,\
    \ any errata,\n   and how to provide feedback on it may be obtained at\n   https://www.rfc-editor.org/info/rfc8342.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (c) 2018 IETF Trust and the persons identified\
    \ as the\n   document authors.  All rights reserved.\n   This document is subject\
    \ to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n\
    \   (https://trustee.ietf.org/license-info) in effect on the date of\n   publication\
    \ of this document.  Please review these documents\n   carefully, as they describe\
    \ your rights and restrictions with respect\n   to this document.  Code Components\
    \ extracted from this document must\n   include Simplified BSD License text as\
    \ described in Section 4.e of\n   the Trust Legal Provisions and are provided\
    \ without warranty as\n   described in the Simplified BSD License.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1. Introduction ....................................................3\n\
    \   2. Objectives ......................................................4\n  \
    \ 3. Terminology .....................................................5\n   4.\
    \ Background ......................................................8\n      4.1.\
    \ Original Model of Datastores ...............................9\n   5. Architectural\
    \ Model of Datastores ..............................11\n      5.1. Conventional\
    \ Configuration Datastores .....................12\n           5.1.1. The Startup\
    \ Configuration Datastore (<startup>) ....12\n           5.1.2. The Candidate\
    \ Configuration Datastore\n                  (<candidate>) ......................................13\n\
    \           5.1.3. The Running Configuration Datastore (<running>) ....13\n  \
    \         5.1.4. The Intended Configuration Datastore (<intended>) ..13\n    \
    \  5.2. Dynamic Configuration Datastores ..........................14\n      5.3.\
    \ The Operational State Datastore (<operational>) ...........14\n           5.3.1.\
    \ Remnant Configuration ..............................16\n           5.3.2. Missing\
    \ Resources ..................................16\n           5.3.3. System-Controlled\
    \ Resources ........................16\n           5.3.4. Origin Metadata Annotation\
    \ .........................17\n   6. Implications on YANG ...........................................18\n\
    \      6.1. XPath Context .............................................18\n  \
    \    6.2. Invocation of Actions and RPCs ............................19\n   7.\
    \ YANG Modules ...................................................20\n   8. IANA\
    \ Considerations ............................................26\n      8.1. Updates\
    \ to the IETF XML Registry ..........................26\n      8.2. Updates to\
    \ the YANG Module Names Registry .................27\n   9. Security Considerations\
    \ ........................................27\n   10. References ....................................................28\n\
    \      10.1. Normative References .....................................28\n  \
    \    10.2. Informative References ...................................29\n   Appendix\
    \ A. Guidelines for Defining Datastores ....................31\n     A.1. Define\
    \ Which YANG Modules Can Be Used in the Datastore .....31\n     A.2. Define Which\
    \ Subset of YANG-Modeled Data Applies ...........31\n     A.3. Define How Data\
    \ Is Actualized ..............................31\n     A.4. Define Which Protocols\
    \ Can Be Used .........................31\n     A.5. Define YANG Identities for\
    \ the Datastore ...................32\n   Appendix B. Example of an Ephemeral\
    \ Dynamic Configuration\n               Datastore .............................................32\n\
    \   Appendix C. Example Data ..........................................33\n  \
    \   C.1. System Example .............................................34\n    \
    \ C.2. BGP Example ................................................37\n      \
    \ C.2.1. Datastores .............................................38\n       C.2.2.\
    \ Adding a Peer ..........................................38\n       C.2.3. Removing\
    \ a Peer ........................................39\n     C.3. Interface Example\
    \ ..........................................40\n       C.3.1. Pre-provisioned\
    \ Interfaces .............................41\n       C.3.2. System-Provided Interface\
    \ ..............................42\n   Acknowledgments ...................................................43\n\
    \   Authors' Addresses ................................................44\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   This document provides an architectural framework for datastores\
    \ as\n   they are used by network management protocols such as the Network\n \
    \  Configuration Protocol (NETCONF) [RFC6241], RESTCONF [RFC8040], and\n   the\
    \ YANG data modeling language [RFC7950].  Datastores are a\n   fundamental concept\
    \ binding network management data models to network\n   management protocols.\
    \  Agreement on a common architectural model of\n   datastores ensures that data\
    \ models can be written in a way that is\n   network management protocol agnostic.\
    \  This architectural framework\n   identifies a set of conceptual datastores,\
    \ but it does not mandate\n   that all network management protocols expose all\
    \ these conceptual\n   datastores.  This architecture is agnostic with regard\
    \ to the\n   encoding used by network management protocols.\n   This document\
    \ updates RFC 7950 by refining the definition of the\n   accessible tree for some\
    \ XML Path Language (XPath) context (see\n   Section 6.1) and the invocation context\
    \ of operations (see\n   Section 6.2).\n   The key words \"MUST\", \"MUST NOT\"\
    , \"REQUIRED\", \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\"\
    , \"NOT RECOMMENDED\", \"MAY\", and\n   \"OPTIONAL\" in this document are to be\
    \ interpreted as described in\n   BCP 14 [RFC2119] [RFC8174] when, and only when,\
    \ they appear in all\n   capitals, as shown here.\n"
- title: 2.  Objectives
  contents:
  - "2.  Objectives\n   Network management data objects can often take two different\
    \ values:\n   the value configured by the user or an application (configuration)\n\
    \   and the value that the device is actually using (operational state).\n   These\
    \ two values may be different for a number of reasons, e.g.,\n   system internal\
    \ interactions with hardware, interaction with\n   protocols or other devices,\
    \ or simply the time it takes to propagate\n   a configuration change to the software\
    \ and hardware components of a\n   system.  Furthermore, configuration and operational\
    \ state data\n   objects may have different lifetimes.\n   The original model\
    \ of datastores required these data objects to be\n   modeled twice in the YANG\
    \ schema -- as \"config true\" objects and as\n   \"config false\" objects.  The\
    \ convention adopted by the interfaces\n   data model [RFC8343] and the IP data\
    \ model [RFC8344] was to use two\n   separate branches rooted at the root of the\
    \ data tree: one branch for\n   configuration data objects and one branch for\
    \ operational state data\n   objects.\n   The duplication of definitions and the\
    \ ad hoc separation of\n   operational state data from configuration data lead\
    \ to a number of\n   problems.  Having configuration and operational state data\
    \ in\n   separate branches in the data model is operationally complicated and\n\
    \   impacts the readability of module definitions.  Furthermore, the\n   relationship\
    \ between the branches is not machine readable, and filter\n   expressions operating\
    \ on configuration and on related operational\n   state are different.\n   With\
    \ the revised architectural model of datastores defined in this\n   document,\
    \ the data objects are defined only once in the YANG schema\n   but independent\
    \ instantiations can appear in different datastores,\n   e.g., one for a configured\
    \ value and another for an operationally\n   used value.  This provides a more\
    \ elegant and simpler solution to the\n   problem.\n   The revised architectural\
    \ model of datastores supports additional\n   datastores for systems that support\
    \ more advanced processing chains\n   converting configuration to operational\
    \ state.  For example, some\n   systems support configuration that is not currently\
    \ used (so-called\n   \"inactive configuration\") or they support configuration\
    \ templates\n   that are used to expand configuration data via a common template.\n"
- title: 3.  Terminology
  contents:
  - "3.  Terminology\n   This document defines the following terminology.  Some of\
    \ the terms\n   are revised definitions of terms originally defined in [RFC6241]\
    \ and\n   [RFC7950] (see also Section 4).  The revised definitions are\n   semantically\
    \ equivalent to the definitions found in [RFC6241] and\n   [RFC7950].  It is expected\
    \ that the revised definitions provided in\n   this section will replace the definitions\
    \ in [RFC6241] and [RFC7950]\n   when these documents are revised.\n   o  datastore:\
    \ A conceptual place to store and access information.  A\n      datastore might\
    \ be implemented, for example, using files, a\n      database, flash memory locations,\
    \ or combinations thereof.  A\n      datastore maps to an instantiated YANG data\
    \ tree.\n   o  schema node: A node in the schema tree.  The formal definition\
    \ is\n      provided in RFC 7950.\n   o  datastore schema: The combined set of\
    \ schema nodes for all modules\n      supported by a particular datastore, taking\
    \ into consideration any\n      deviations and enabled features for that datastore.\n\
    \   o  configuration: Data that is required to get a device from its\n      initial\
    \ default state into a desired operational state.  This data\n      is modeled\
    \ in YANG using \"config true\" nodes.  Configuration can\n      originate from\
    \ different sources.\n   o  configuration datastore: A datastore holding configuration.\n\
    \   o  running configuration datastore: A configuration datastore holding\n  \
    \    the current configuration of the device.  It may include\n      configuration\
    \ that requires further transformations before it can\n      be applied.  This\
    \ datastore is referred to as \"<running>\".\n   o  candidate configuration datastore:\
    \ A configuration datastore that\n      can be manipulated without impacting the\
    \ device's running\n      configuration datastore and that can be committed to\
    \ the running\n      configuration datastore.  This datastore is referred to as\n\
    \      \"<candidate>\".\n   o  startup configuration datastore: A configuration\
    \ datastore holding\n      the configuration loaded by the device into the running\n\
    \      configuration datastore when it boots.  This datastore is referred\n  \
    \    to as \"<startup>\".\n   o  intended configuration: Configuration that is\
    \ intended to be used\n      by the device.  It represents the configuration after\
    \ all\n      configuration transformations to <running> have been performed and\n\
    \      is the configuration that the system attempts to apply.\n   o  intended\
    \ configuration datastore: A configuration datastore\n      holding the complete\
    \ intended configuration of the device.  This\n      datastore is referred to\
    \ as \"<intended>\".\n   o  configuration transformation: The addition, modification,\
    \ or\n      removal of configuration between the <running> and <intended>\n  \
    \    datastores.  Examples of configuration transformations include the\n    \
    \  removal of inactive configuration and the configuration produced\n      through\
    \ the expansion of templates.\n   o  conventional configuration datastore: One\
    \ of the following set of\n      configuration datastores: <running>, <startup>,\
    \ <candidate>, and\n      <intended>.  These datastores share a common datastore\
    \ schema, and\n      protocol operations allow copying data between these datastores.\n\
    \      The term \"conventional\" is chosen as a generic umbrella term for\n  \
    \    these datastores.\n   o  conventional configuration: Configuration that is\
    \ stored in any of\n      the conventional configuration datastores.\n   o  dynamic\
    \ configuration datastore: A configuration datastore holding\n      configuration\
    \ obtained dynamically during the operation of a\n      device through interaction\
    \ with other systems, rather than through\n      one of the conventional configuration\
    \ datastores.\n   o  dynamic configuration: Configuration obtained via a dynamic\n\
    \      configuration datastore.\n   o  learned configuration: Configuration that\
    \ has been learned via\n      protocol interactions with other systems and that\
    \ is neither\n      conventional nor dynamic configuration.\n   o  system configuration:\
    \ Configuration that is supplied by the device\n      itself.\n   o  default configuration:\
    \ Configuration that is not explicitly\n      provided but for which a value defined\
    \ in the data model is used.\n   o  applied configuration: Configuration that\
    \ is actively in use by a\n      device.  Applied configuration originates from\
    \ conventional,\n      dynamic, learned, system, and default configuration.\n\
    \   o  system state: The additional data on a system that is not\n      configuration,\
    \ such as read-only status information and collected\n      statistics.  System\
    \ state is transient and modified by\n      interactions with internal components\
    \ or other systems.  System\n      state is modeled in YANG using \"config false\"\
    \ nodes.\n   o  operational state: The combination of applied configuration and\n\
    \      system state.\n   o  operational state datastore: A datastore holding the\
    \ complete\n      operational state of the device.  This datastore is referred\
    \ to as\n      \"<operational>\".\n   o  origin: A metadata annotation indicating\
    \ the origin of a\n      data item.\n   o  remnant configuration: Configuration\
    \ that remains part of the\n      applied configuration for a period of time after\
    \ it has been\n      removed from the intended configuration or dynamic configuration.\n\
    \      The time period may be minimal or may last until all resources\n      used\
    \ by the newly deleted configuration (e.g., network\n      connections, memory\
    \ allocations, file handles) have been\n      deallocated.\n   The following additional\
    \ terms are not datastore specific, but they\n   are commonly used and are thus\
    \ defined here as well:\n   o  client: An entity that can access YANG-defined\
    \ data on a server,\n      over some network management protocol.\n   o  server:\
    \ An entity that provides access to YANG-defined data to a\n      client, over\
    \ some network management protocol.\n   o  notification: A server-initiated message\
    \ indicating that a certain\n      event has been recognized by the server.\n\
    \   o  remote procedure call: An operation that can be invoked by a\n      client\
    \ on a server.\n"
- title: 4.  Background
  contents:
  - "4.  Background\n   NETCONF [RFC6241] provides the following definitions:\n  \
    \ o  datastore: A conceptual place to store and access information.  A\n     \
    \ datastore might be implemented, for example, using files, a\n      database,\
    \ flash memory locations, or combinations thereof.\n   o  configuration datastore:\
    \ The datastore holding the complete set of\n      configuration that is required\
    \ to get a device from its initial\n      default state into a desired operational\
    \ state.\n   YANG 1.1 [RFC7950] provides the following refinements when NETCONF\
    \ is\n   used with YANG (which is the usual case, but note that NETCONF was\n\
    \   defined before YANG existed):\n   o  datastore: When modeled with YANG, a\
    \ datastore is realized as an\n      instantiated data tree.\n   o  configuration\
    \ datastore: When modeled with YANG, a configuration\n      datastore is realized\
    \ as an instantiated data tree with\n      configuration.\n   [RFC6244] defined\
    \ operational state data as follows:\n   o  Operational state data is a set of\
    \ data that has been obtained by\n      the system at runtime and influences the\
    \ system's behavior similar\n      to configuration data.  In contrast to configuration\
    \ data,\n      operational state is transient and modified by interactions with\n\
    \      internal components or other systems via specialized protocols.\n   Section\
    \ 4.3.3 of [RFC6244] discusses operational state and mentions,\n   among other\
    \ things, the option to consider operational state as being\n   stored in another\
    \ datastore.  Section 4.4 of [RFC6244] then concludes\n   that, at the time of\
    \ its writing, modeling state as distinct leafs\n   and distinct branches is the\
    \ recommended approach.\n   Implementation experience and requests from operators\
    \ [OpState-Reqs]\n   [OpState-Modeling] indicate that the datastore model initially\n\
    \   designed for NETCONF and refined by YANG needs to be extended.  In\n   particular,\
    \ the notion of intended configuration and applied\n   configuration has developed.\n"
- title: 4.1.  Original Model of Datastores
  contents:
  - "4.1.  Original Model of Datastores\n   The following drawing shows the original\
    \ model of datastores as it is\n   currently used by NETCONF [RFC6241]:\n    \
    \      +-------------+                 +-----------+\n          | <candidate>\
    \ |                 | <startup> |\n          |  (ct, rw)   |<---+       +--->|\
    \ (ct, rw)  |\n          +-------------+    |       |    +-----------+\n     \
    \            |           |       |           |\n                 |         +-----------+\
    \         |\n                 +-------->| <running> |<--------+\n            \
    \               | (ct, rw)  |\n                           +-----------+\n    \
    \                             |\n                                 v\n        \
    \                  operational state  <--- control plane\n                   \
    \           (cf, ro)\n          ct = config true; cf = config false\n        \
    \  rw = read-write; ro = read-only\n          boxes denote datastores\n      \
    \                           Figure 1\n   Note that this diagram simplifies the\
    \ model: \"read-only\" (ro) and\n   \"read-write\" (rw) are to be understood from\
    \ the client's perspective,\n   at a conceptual level.  In NETCONF, for example,\
    \ support for\n   <candidate> and <startup> is optional, and <running> does not\
    \ have to\n   be writable.  Furthermore, <startup> can only be modified by copying\n\
    \   <running> to <startup> in the standardized NETCONF datastore editing\n   model.\
    \  The RESTCONF protocol does not expose these differences and\n   instead provides\
    \ only a writable unified datastore, which hides\n   whether edits are done through\
    \ <candidate>, by directly modifying\n   <running>, or via some other implementation-specific\
    \ mechanism.\n   RESTCONF also hides how configuration is made persistent.  Note\
    \ that\n   implementations may also have additional datastores that can\n   propagate\
    \ changes to <running>.  NETCONF explicitly mentions\n   so-called \"named datastores\"\
    .\n   Some observations:\n   o  Operational state has not been defined as a datastore,\
    \ although\n      there were proposals in the past to introduce an operational\
    \ state\n      datastore.\n   o  The NETCONF <get> operation returns the contents\
    \ of <running>\n      together with the operational state.  It is therefore necessary\n\
    \      that \"config false\" data be in a different branch than the\n      \"\
    config true\" data if the operational state can have a different\n      lifetime\
    \ compared to configuration or if configuration is not\n      immediately or successfully\
    \ applied.\n   o  Several implementations have proprietary mechanisms that allow\n\
    \      clients to store inactive data in <running>.  Inactive data is\n      conceptually\
    \ removed before validation.\n   o  Some implementations have proprietary mechanisms\
    \ that allow\n      clients to define configuration templates in <running>.  These\n\
    \      templates are expanded automatically by the system, and the\n      resulting\
    \ configuration is applied internally.\n   o  Some operators have reported that\
    \ it is essential for them to be\n      able to retrieve the configuration that\
    \ has actually been\n      successfully applied, which may be a subset or a superset\
    \ of the\n      <running> configuration.\n"
- title: 5.  Architectural Model of Datastores
  contents:
  - "5.  Architectural Model of Datastores\n   Below is a new conceptual model of\
    \ datastores, extending the original\n   model in order to reflect the experience\
    \ gained with the original\n   model.\n     +-------------+                 +-----------+\n\
    \     | <candidate> |                 | <startup> |\n     |  (ct, rw)   |<---+\
    \       +--->| (ct, rw)  |\n     +-------------+    |       |    +-----------+\n\
    \            |           |       |           |\n            |         +-----------+\
    \         |\n            +-------->| <running> |<--------+\n                 \
    \     | (ct, rw)  |\n                      +-----------+\n                   \
    \         |\n                            |        // configuration transformations,\n\
    \                            |        // e.g., removal of nodes marked as\n  \
    \                          |        // \"inactive\", expansion of\n          \
    \                  |        // templates\n                            v\n    \
    \                  +------------+\n                      | <intended> | // subject\
    \ to validation\n                      | (ct, ro)   |\n                      +------------+\n\
    \                            |        // changes applied, subject to\n       \
    \                     |        // local factors, e.g., missing\n             \
    \               |        // resources, delays\n                            |\n\
    \       dynamic              |   +-------- learned configuration\n       configuration\
    \        |   +-------- system configuration\n       datastores -----+    |   +--------\
    \ default configuration\n                       |    |   |\n                 \
    \      v    v   v\n                    +---------------+\n                   \
    \ | <operational> | <-- system state\n                    | (ct + cf, ro) |\n\
    \                    +---------------+\n     ct = config true; cf = config false\n\
    \     rw = read-write; ro = read-only\n     boxes denote named datastores\n  \
    \                               Figure 2\n"
- title: 5.1.  Conventional Configuration Datastores
  contents:
  - "5.1.  Conventional Configuration Datastores\n   The conventional configuration\
    \ datastores are a set of configuration\n   datastores that share exactly the\
    \ same datastore schema, allowing\n   data to be copied between them.  The term\
    \ is meant as a generic\n   umbrella description of these datastores.  If a module\
    \ does not\n   contain any configuration data nodes and it is not needed to satisfy\n\
    \   any imports, then it MAY be omitted from the datastore schema for the\n  \
    \ conventional configuration datastores.  The set of datastores\n   include:\n\
    \   o  <running>\n   o  <candidate>\n   o  <startup>\n   o  <intended>\n   Other\
    \ conventional configuration datastores may be defined in future\n   documents.\n\
    \   The flow of data between these datastores is depicted in Section 5.\n   The\
    \ specific protocols may define explicit operations to copy between\n   these\
    \ datastores, e.g., NETCONF defines the <copy-config> operation.\n"
- title: 5.1.1.  The Startup Configuration Datastore (<startup>)
  contents:
  - "5.1.1.  The Startup Configuration Datastore (<startup>)\n   The startup configuration\
    \ datastore (<startup>) is a configuration\n   datastore holding the configuration\
    \ loaded by the device when it\n   boots.  <startup> is only present on devices\
    \ that separate the\n   startup configuration from the running configuration datastore.\n\
    \   The startup configuration datastore may not be supported by all\n   protocols\
    \ or implementations.\n   On devices that support non-volatile storage, the contents\
    \ of\n   <startup> will typically persist across reboots via that storage.  At\n\
    \   boot time, the device loads the saved startup configuration into\n   <running>.\
    \  To save a new startup configuration, data is copied to\n   <startup> via either\
    \ implicit or explicit protocol operations.\n"
- title: 5.1.2.  The Candidate Configuration Datastore (<candidate>)
  contents:
  - "5.1.2.  The Candidate Configuration Datastore (<candidate>)\n   The candidate\
    \ configuration datastore (<candidate>) is a\n   configuration datastore that\
    \ can be manipulated without impacting the\n   device's current configuration\
    \ and that can be committed to\n   <running>.\n   The candidate configuration\
    \ datastore may not be supported by all\n   protocols or implementations.\n  \
    \ <candidate> does not typically persist across reboots, even in the\n   presence\
    \ of non-volatile storage.  If <candidate> is stored using\n   non-volatile storage,\
    \ it is reset at boot time to the contents of\n   <running>.\n"
- title: 5.1.3.  The Running Configuration Datastore (<running>)
  contents:
  - "5.1.3.  The Running Configuration Datastore (<running>)\n   The running configuration\
    \ datastore (<running>) is a configuration\n   datastore that holds the current\
    \ configuration of the device.  It MAY\n   include configuration that requires\
    \ further transformation before it\n   can be applied, e.g., inactive configuration,\
    \ or template-mechanism-\n   oriented configuration that needs further expansion.\
    \  However,\n   <running> MUST always be a valid configuration data tree, as defined\n\
    \   in Section 8.1 of [RFC7950].\n   <running> MUST be supported if the device\
    \ can be configured via\n   conventional configuration datastores.\n   If a device\
    \ does not have a distinct <startup> and non-volatile\n   storage is available,\
    \ the device will typically use that non-volatile\n   storage to allow <running>\
    \ to persist across reboots.\n"
- title: 5.1.4.  The Intended Configuration Datastore (<intended>)
  contents:
  - "5.1.4.  The Intended Configuration Datastore (<intended>)\n   The intended configuration\
    \ datastore (<intended>) is a read-only\n   configuration datastore.  It represents\
    \ the configuration after all\n   configuration transformations to <running> are\
    \ performed (e.g.,\n   template expansion, removal of inactive configuration)\
    \ and is the\n   configuration that the system attempts to apply.\n   <intended>\
    \ is tightly coupled to <running>.  Whenever data is written\n   to <running>,\
    \ the server MUST also immediately update and validate\n   <intended>.\n   <intended>\
    \ MAY also be updated independently of <running> if the\n   effect of a configuration\
    \ transformation changes, but <intended> MUST\n   always be a valid configuration\
    \ data tree, as defined in Section 8.1\n   of [RFC7950].\n   For simple implementations,\
    \ <running> and <intended> are identical.\n   The contents of <intended> are also\
    \ related to the \"config true\"\n   subset of <operational>; hence, a client\
    \ can determine to what extent\n   the intended configuration is currently in\
    \ use by checking to see\n   whether the contents of <intended> also appear in\
    \ <operational>.\n   <intended> does not persist across reboots; its relationship\
    \ with\n   <running> makes that unnecessary.\n   Currently, there are no standard\
    \ mechanisms defined that affect\n   <intended> so that it would have different\
    \ content than <running>,\n   but this architecture allows for such mechanisms\
    \ to be defined.\n   One example of such a mechanism is support for marking nodes\
    \ as\n   inactive in <running>.  Inactive nodes are not copied to <intended>.\n\
    \   A second example is support for templates, which can perform\n   transformations\
    \ on the configuration from <running> to the\n   configuration written to <intended>.\n"
- title: 5.2.  Dynamic Configuration Datastores
  contents:
  - "5.2.  Dynamic Configuration Datastores\n   The model recognizes the need for\
    \ dynamic configuration datastores\n   that are, by definition, not part of the\
    \ persistent configuration of\n   a device.  In some contexts, these have been\
    \ termed \"ephemeral\n   datastores\", since the information is ephemeral, i.e.,\
    \ lost upon\n   reboot.  The dynamic configuration datastores interact with the\
    \ rest\n   of the system through <operational>.\n   The datastore schema for a\
    \ dynamic configuration datastore MAY differ\n   from the datastore schema used\
    \ for conventional configuration\n   datastores.  If a module does not contain\
    \ any configuration data\n   nodes and it is not needed to satisfy any imports,\
    \ then it MAY be\n   omitted from the datastore schema for the dynamic configuration\n\
    \   datastore.\n"
- title: 5.3.  The Operational State Datastore (<operational>)
  contents:
  - "5.3.  The Operational State Datastore (<operational>)\n   The operational state\
    \ datastore (<operational>) is a read-only\n   datastore that consists of all\
    \ \"config true\" and \"config false\" nodes\n   defined in the datastore's schema.\
    \  In the original NETCONF model,\n   the operational state only had \"config\
    \ false\" nodes.  The reason for\n   incorporating \"config true\" nodes here\
    \ is to be able to expose all\n   operational settings without having to replicate\
    \ definitions in the\n   data models.\n   <operational> contains system state\
    \ and all configuration actually\n   used by the system.  This includes all applied\
    \ configuration from\n   <intended>, learned configuration, system-provided configuration,\
    \ and\n   default values defined by any supported data models.  In addition,\n\
    \   <operational> also contains applied configuration from dynamic\n   configuration\
    \ datastores.\n   The datastore schema for <operational> MUST be a superset of\
    \ the\n   combined datastore schema used in all configuration datastores,\n  \
    \ except that configuration data nodes supported in a configuration\n   datastore\
    \ MAY be omitted from <operational> if a server is not able\n   to accurately\
    \ report them.\n   Requests to retrieve nodes from <operational> always return\
    \ the value\n   in use if the node exists, regardless of any default value specified\n\
    \   in the YANG module.  If no value is returned for a given node, then\n   this\
    \ implies that the node is not used by the device.\n   The interpretation of what\
    \ constitutes being \"in use\" by the system\n   is dependent on both the schema\
    \ definition and the device\n   implementation.  Generally, functionality that\
    \ is enabled and\n   operational on the system would be considered to be \"in\
    \ use\".\n   Conversely, functionality that is neither enabled nor operational\
    \ on\n   the system is considered not to be \"in use\"; hence, it SHOULD be\n\
    \   omitted from <operational>.\n   <operational> SHOULD conform to any constraints\
    \ specified in the data\n   model, but given the principal aim of returning \"\
    in use\" values, it\n   is possible that constraints MAY be violated under some\
    \ circumstances\n   (e.g., an abnormal value is \"in use\", the structure of a\
    \ list is\n   being modified, or remnant configuration (see Section 5.3.1) still\n\
    \   exists).  Note that deviations SHOULD be used when it is known in\n   advance\
    \ that a device does not fully conform to the <operational>\n   schema.\n   Only\
    \ semantic constraints MAY be violated.  These are the YANG\n   \"when\", \"must\"\
    , \"mandatory\", \"unique\", \"min-elements\", and\n   \"max-elements\" statements;\
    \ and the uniqueness of key values.\n   Syntactic constraints MUST NOT be violated,\
    \ including hierarchical\n   organization, identifiers, and type-based constraints.\
    \  If a node in\n   <operational> does not meet the syntactic constraints, then\
    \ it\n   MUST NOT be returned, and some other mechanism should be used to flag\n\
    \   the error.\n   <operational> does not persist across reboots.\n"
- title: 5.3.1.  Remnant Configuration
  contents:
  - "5.3.1.  Remnant Configuration\n   Changes to configuration may take time to percolate\
    \ through to\n   <operational>.  During this period, <operational> may contain\
    \ nodes\n   for both the previous and current configuration, as closely as\n \
    \  possible tracking the current operation of the device.  Such remnant\n   configuration\
    \ from the previous configuration persists until the\n   system has released resources\
    \ used by the newly deleted configuration\n   (e.g., network connections, memory\
    \ allocations, file handles).\n   Remnant configuration is a common example of\
    \ where the semantic\n   constraints defined in the data model cannot be relied\
    \ upon for\n   <operational>, since the system may have remnant configuration\
    \ whose\n   constraints were valid with the previous configuration and that are\n\
    \   not valid with the current configuration.  Since constraints on\n   \"config\
    \ false\" nodes may refer to \"config true\" nodes, remnant\n   configuration\
    \ may force the violation of those constraints.\n"
- title: 5.3.2.  Missing Resources
  contents:
  - "5.3.2.  Missing Resources\n   Configuration in <intended> can refer to resources\
    \ that are not\n   available or otherwise not physically present.  In these situations,\n\
    \   these parts of <intended> are not applied.  The data appears in\n   <intended>\
    \ but does not appear in <operational>.\n   A typical example is an interface\
    \ configuration that refers to an\n   interface that is not currently present.\
    \  In such a situation, the\n   interface configuration remains in <intended>\
    \ but the interface\n   configuration will not appear in <operational>.\n   Note\
    \ that configuration validity cannot depend on the current state\n   of such resources,\
    \ since that would imply that removing a resource\n   might render the configuration\
    \ invalid.  This is unacceptable,\n   especially given that rebooting such a device\
    \ would cause it to\n   restart with an invalid configuration.  Instead, we allow\n\
    \   configuration for missing resources to exist in <running> and\n   <intended>,\
    \ but it will not appear in <operational>.\n"
- title: 5.3.3.  System-Controlled Resources
  contents:
  - "5.3.3.  System-Controlled Resources\n   Sometimes, resources are controlled by\
    \ the device and the\n   corresponding system-controlled data appears in (and\
    \ disappears from)\n   <operational> dynamically.  If a system-controlled resource\
    \ has\n   matching configuration in <intended> when it appears, the system will\n\
    \   try to apply the configuration; this causes the configuration to\n   appear\
    \ in <operational> eventually (if application of the\n   configuration was successful).\n"
- title: 5.3.4.  Origin Metadata Annotation
  contents:
  - "5.3.4.  Origin Metadata Annotation\n   As configuration flows into <operational>,\
    \ it is conceptually marked\n   with a metadata annotation [RFC7952] that indicates\
    \ its origin.  The\n   origin applies to all configuration nodes except non-presence\n\
    \   containers.  The \"origin\" metadata annotation is defined in\n   Section\
    \ 7.  The values are YANG identities.  The following identities\n   are defined:\n\
    \   o  origin: abstract base identity from which the other origin\n      identities\
    \ are derived.\n   o  intended: represents configuration provided by <intended>.\n\
    \   o  dynamic: represents configuration provided by a dynamic\n      configuration\
    \ datastore.\n   o  system: represents configuration provided by the system itself.\n\
    \      Examples of system configuration include applied configuration for\n  \
    \    an always-existing loopback interface, or interface configuration\n     \
    \ that is auto-created due to the hardware currently present in the\n      device.\n\
    \   o  learned: represents configuration that has been learned via\n      protocol\
    \ interactions with other systems, including such protocols\n      as link-layer\
    \ negotiations, routing protocols, and DHCP.\n   o  default: represents configuration\
    \ using a default value specified\n      in the data model, using either values\
    \ in the \"default\" statement\n      or any values described in the \"description\"\
    \ statement.  The\n      default origin is only used when the configuration has\
    \ not been\n      provided by any other source.\n   o  unknown: represents configuration\
    \ for which the system cannot\n      identify the origin.\n   These identities\
    \ can be further refined, e.g., there could be\n   separate identities for particular\
    \ types or instances of dynamic\n   configuration datastores derived from \"dynamic\"\
    .\n   For all configuration data nodes in <operational>, the device SHOULD\n \
    \  report the origin that most accurately reflects the source of the\n   configuration\
    \ that is in use by the system.\n   In cases where it could be ambiguous as to\
    \ which origin should be\n   used, i.e., where the same data node value has originated\
    \ from\n   multiple sources, the \"description\" statement in the YANG module\n\
    \   SHOULD be used as guidance for choosing the appropriate origin.  For\n   example:\n\
    \   If, for a particular configuration node, the associated YANG\n   \"description\"\
    \ statement indicates that a protocol-negotiated value\n   overrides any configured\
    \ value, then the origin would be reported as\n   \"learned\", even when a learned\
    \ value is the same as the configured\n   value.\n   Conversely, if, for a particular\
    \ configuration node, the associated\n   YANG \"description\" statement indicates\
    \ that a protocol-negotiated\n   value does not override an explicitly configured\
    \ value, then the\n   origin would be reported as \"intended\", even when a learned\
    \ value is\n   the same as the configured value.\n   In the case that a device\
    \ cannot provide an accurate origin for a\n   particular configuration data node,\
    \ it SHOULD use the origin\n   \"unknown\".\n"
- title: 6.  Implications on YANG
  contents:
  - '6.  Implications on YANG

    '
- title: 6.1.  XPath Context
  contents:
  - "6.1.  XPath Context\n   This section updates Section 6.4.1 of RFC 7950.\n   If\
    \ a server implements the architecture defined in this document, the\n   accessible\
    \ trees for some XPath contexts are refined as follows:\n   o  If the XPath expression\
    \ is defined in a substatement to a data\n      node that represents system state,\
    \ the accessible tree is all\n      operational state in the server.  The root\
    \ node has all top-level\n      data nodes in all modules as children.\n   o \
    \ If the XPath expression is defined in a substatement to a\n      \"notification\"\
    \ statement, the accessible tree is the notification\n      instance and all operational\
    \ state in the server.  If the\n      notification is defined on the top level\
    \ in a module, then the\n      root node has the node representing the notification\
    \ being defined\n      and all top-level data nodes in all modules as children.\n\
    \      Otherwise, the root node has all top-level data nodes in all\n      modules\
    \ as children.\n   o  If the XPath expression is defined in a substatement to\
    \ an \"input\"\n      statement in an \"rpc\" or \"action\" statement, the accessible\
    \ tree\n      is the RPC or action operation instance and all operational state\n\
    \      in the server.  The root node has top-level data nodes in all\n      modules\
    \ as children.  Additionally, for an RPC, the root node also\n      has the node\
    \ representing the RPC operation being defined as a\n      child.  The node representing\
    \ the operation being defined has the\n      operation's input parameters as children.\n\
    \   o  If the XPath expression is defined in a substatement to an\n      \"output\"\
    \ statement in an \"rpc\" or \"action\" statement, the\n      accessible tree\
    \ is the RPC or action operation instance and all\n      operational state in\
    \ the server.  The root node has top-level data\n      nodes in all modules as\
    \ children.  Additionally, for an RPC, the\n      root node also has the node\
    \ representing the RPC operation being\n      defined as a child.  The node representing\
    \ the operation being\n      defined has the operation's output parameters as\
    \ children.\n"
- title: 6.2.  Invocation of Actions and RPCs
  contents:
  - "6.2.  Invocation of Actions and RPCs\n   This section updates Section 7.15 of\
    \ RFC 7950.\n   Actions are always invoked in the context of the operational state\n\
    \   datastore.  The node for which the action is invoked MUST exist in\n   the\
    \ operational state datastore.\n   Note that this document does not constrain\
    \ the result of invoking an\n   RPC or action in any way.  For example, an RPC\
    \ might be defined to\n   modify the contents of some datastore.\n"
- title: 7.  YANG Modules
  contents:
  - "7.  YANG Modules\n   <CODE BEGINS> file \"ietf-datastores@2018-02-14.yang\"\n\
    \   module ietf-datastores {\n     yang-version 1.1;\n     namespace \"urn:ietf:params:xml:ns:yang:ietf-datastores\"\
    ;\n     prefix ds;\n     organization\n       \"IETF Network Modeling (NETMOD)\
    \ Working Group\";\n     contact\n       \"WG Web:   <https://datatracker.ietf.org/wg/netmod/>\n\
    \        WG List:  <mailto:netmod@ietf.org>\n        Author:   Martin Bjorklund\n\
    \                  <mailto:mbj@tail-f.com>\n        Author:   Juergen Schoenwaelder\n\
    \                  <mailto:j.schoenwaelder@jacobs-university.de>\n        Author:\
    \   Phil Shafer\n                  <mailto:phil@juniper.net>\n        Author:\
    \   Kent Watsen\n                  <mailto:kwatsen@juniper.net>\n        Author:\
    \   Rob Wilton\n                  <rwilton@cisco.com>\";\n     description\n \
    \      \"This YANG module defines a set of identities for identifying\n      \
    \  datastores.\n        Copyright (c) 2018 IETF Trust and the persons identified\
    \ as\n        authors of the code.  All rights reserved.\n        Redistribution\
    \ and use in source and binary forms, with or\n        without modification, is\
    \ permitted pursuant to, and subject to\n        the license terms contained in,\
    \ the Simplified BSD License set\n        forth in Section 4.c of the IETF Trust's\
    \ Legal Provisions\n        Relating to IETF Documents\n        (https://trustee.ietf.org/license-info).\n\
    \        This version of this YANG module is part of RFC 8342\n        (https://www.rfc-editor.org/info/rfc8342);\
    \ see the RFC itself\n        for full legal notices.\";\n     revision 2018-02-14\
    \ {\n       description\n         \"Initial revision.\";\n       reference\n \
    \        \"RFC 8342: Network Management Datastore Architecture (NMDA)\";\n   \
    \  }\n     /*\n      * Identities\n      */\n     identity datastore {\n     \
    \  description\n         \"Abstract base identity for datastore identities.\"\
    ;\n     }\n     identity conventional {\n       base datastore;\n       description\n\
    \         \"Abstract base identity for conventional configuration\n          datastores.\"\
    ;\n     }\n     identity running {\n       base conventional;\n       description\n\
    \         \"The running configuration datastore.\";\n     }\n     identity candidate\
    \ {\n       base conventional;\n       description\n         \"The candidate configuration\
    \ datastore.\";\n     }\n     identity startup {\n       base conventional;\n\
    \       description\n         \"The startup configuration datastore.\";\n    \
    \ }\n     identity intended {\n       base conventional;\n       description\n\
    \         \"The intended configuration datastore.\";\n     }\n     identity dynamic\
    \ {\n       base datastore;\n       description\n         \"Abstract base identity\
    \ for dynamic configuration datastores.\";\n     }\n     identity operational\
    \ {\n       base datastore;\n       description\n         \"The operational state\
    \ datastore.\";\n     }\n     /*\n      * Type definitions\n      */\n     typedef\
    \ datastore-ref {\n       type identityref {\n         base datastore;\n     \
    \  }\n       description\n         \"A datastore identity reference.\";\n    \
    \ }\n   }\n   <CODE ENDS>\n   <CODE BEGINS> file \"ietf-origin@2018-02-14.yang\"\
    \n   module ietf-origin {\n     yang-version 1.1;\n     namespace \"urn:ietf:params:xml:ns:yang:ietf-origin\"\
    ;\n     prefix or;\n     import ietf-yang-metadata {\n       prefix md;\n    \
    \ }\n     organization\n       \"IETF Network Modeling (NETMOD) Working Group\"\
    ;\n     contact\n       \"WG Web:   <https://datatracker.ietf.org/wg/netmod/>\n\
    \        WG List:  <mailto:netmod@ietf.org>\n        Author:   Martin Bjorklund\n\
    \                  <mailto:mbj@tail-f.com>\n        Author:   Juergen Schoenwaelder\n\
    \                  <mailto:j.schoenwaelder@jacobs-university.de>\n        Author:\
    \   Phil Shafer\n                  <mailto:phil@juniper.net>\n        Author:\
    \   Kent Watsen\n                  <mailto:kwatsen@juniper.net>\n        Author:\
    \   Rob Wilton\n                  <rwilton@cisco.com>\";\n     description\n \
    \      \"This YANG module defines an 'origin' metadata annotation and a\n    \
    \    set of identities for the origin value.\n        Copyright (c) 2018 IETF\
    \ Trust and the persons identified as\n        authors of the code.  All rights\
    \ reserved.\n        Redistribution and use in source and binary forms, with or\n\
    \        without modification, is permitted pursuant to, and subject to\n    \
    \    the license terms contained in, the Simplified BSD License set\n        forth\
    \ in Section 4.c of the IETF Trust's Legal Provisions\n        Relating to IETF\
    \ Documents\n        (https://trustee.ietf.org/license-info).\n        This version\
    \ of this YANG module is part of RFC 8342\n        (https://www.rfc-editor.org/info/rfc8342);\
    \ see the RFC itself\n        for full legal notices.\";\n     revision 2018-02-14\
    \ {\n       description\n         \"Initial revision.\";\n       reference\n \
    \        \"RFC 8342: Network Management Datastore Architecture (NMDA)\";\n   \
    \  }\n     /*\n      * Identities\n      */\n     identity origin {\n       description\n\
    \         \"Abstract base identity for the origin annotation.\";\n     }\n   \
    \  identity intended {\n       base origin;\n       description\n         \"Denotes\
    \ configuration from the intended configuration\n          datastore.\";\n   \
    \  }\n     identity dynamic {\n       base origin;\n       description\n     \
    \    \"Denotes configuration from a dynamic configuration\n          datastore.\"\
    ;\n     }\n     identity system {\n       base origin;\n       description\n \
    \        \"Denotes configuration originated by the system itself.\n          Examples\
    \ of system configuration include applied configuration\n          for an always-existing\
    \ loopback interface, or interface\n          configuration that is auto-created\
    \ due to the hardware\n          currently present in the device.\";\n     }\n\
    \     identity learned {\n       base origin;\n       description\n         \"\
    Denotes configuration learned from protocol interactions with\n          other\
    \ devices, instead of via either the intended\n          configuration datastore\
    \ or any dynamic configuration\n          datastore.\n          Examples of protocols\
    \ that provide learned configuration\n          include link-layer negotiations,\
    \ routing protocols, and\n          DHCP.\";\n     }\n     identity default {\n\
    \       base origin;\n       description\n         \"Denotes configuration that\
    \ does not have a configured or\n          learned value but has a default value\
    \ in use.  Covers both\n          values defined in a 'default' statement and\
    \ values defined\n          via an explanation in a 'description' statement.\"\
    ;\n     }\n     identity unknown {\n       base origin;\n       description\n\
    \         \"Denotes configuration for which the system cannot identify the\n \
    \         origin.\";\n     }\n     /*\n      * Type definitions\n      */\n  \
    \   typedef origin-ref {\n       type identityref {\n         base origin;\n \
    \      }\n       description\n         \"An origin identity reference.\";\n  \
    \   }\n     /*\n      * Metadata annotations\n      */\n     md:annotation origin\
    \ {\n       type origin-ref;\n       description\n         \"The 'origin' annotation\
    \ can be present on any configuration\n          data node in the operational\
    \ state datastore.  It specifies\n          from where the node originated.  If\
    \ not specified for a given\n          configuration data node, then the origin\
    \ is the same as the\n          origin of its parent node in the data tree.  The\
    \ origin for\n          any top-level configuration data nodes must be specified.\"\
    ;\n     }\n   }\n   <CODE ENDS>\n"
- title: 8.  IANA Considerations
  contents:
  - '8.  IANA Considerations

    '
- title: 8.1.  Updates to the IETF XML Registry
  contents:
  - "8.1.  Updates to the IETF XML Registry\n   This document registers two URIs in\
    \ the \"IETF XML Registry\"\n   [RFC3688].  Following the format in [RFC3688],\
    \ the following\n   registrations have been made:\n      URI: urn:ietf:params:xml:ns:yang:ietf-datastores\n\
    \      Registrant Contact: The IESG.\n      XML: N/A; the requested URI is an\
    \ XML namespace.\n      URI: urn:ietf:params:xml:ns:yang:ietf-origin\n      Registrant\
    \ Contact: The IESG.\n      XML: N/A; the requested URI is an XML namespace.\n"
- title: 8.2.  Updates to the YANG Module Names Registry
  contents:
  - "8.2.  Updates to the YANG Module Names Registry\n   This document registers two\
    \ YANG modules in the \"YANG Module Names\"\n   registry [RFC6020].  Following\
    \ the format in [RFC6020], the following\n   registrations have been made:\n \
    \     name:         ietf-datastores\n      namespace:    urn:ietf:params:xml:ns:yang:ietf-datastores\n\
    \      prefix:       ds\n      reference:    RFC 8342\n      name:         ietf-origin\n\
    \      namespace:    urn:ietf:params:xml:ns:yang:ietf-origin\n      prefix:  \
    \     or\n      reference:    RFC 8342\n"
- title: 9.  Security Considerations
  contents:
  - "9.  Security Considerations\n   This document discusses an architectural model\
    \ of datastores for\n   network management using NETCONF/RESTCONF and YANG.  It\
    \ has no\n   security impact on the Internet.\n   Although this document specifies\
    \ several YANG modules, these modules\n   only define identities and a metadata\
    \ annotation; hence, the \"YANG\n   module security guidelines\" [YANG-SEC] do\
    \ not apply.\n   The origin metadata annotation exposes the origin of values in\
    \ the\n   applied configuration.  Origin information may provide hints that\n\
    \   certain control-plane protocols are active on a device.  Since origin\n  \
    \ information is tied to applied configuration values, it is only\n   accessible\
    \ to clients that have the permissions to read the applied\n   configuration values.\
    \  Security administrators should consider the\n   sensitivity of origin information\
    \ while defining access control\n   rules.\n"
- title: 10.  References
  contents:
  - '10.  References

    '
- title: 10.1.  Normative References
  contents:
  - "10.1.  Normative References\n   [RFC2119]  Bradner, S., \"Key words for use in\
    \ RFCs to Indicate\n              Requirement Levels\", BCP 14, RFC 2119,\n  \
    \            DOI 10.17487/RFC2119, March 1997,\n              <https://www.rfc-editor.org/info/rfc2119>.\n\
    \   [RFC6241]  Enns, R., Ed., Bjorklund, M., Ed., Schoenwaelder, J., Ed.,\n  \
    \            and A. Bierman, Ed., \"Network Configuration Protocol\n         \
    \     (NETCONF)\", RFC 6241, DOI 10.17487/RFC6241, June 2011,\n              <https://www.rfc-editor.org/info/rfc6241>.\n\
    \   [RFC7950]  Bjorklund, M., Ed., \"The YANG 1.1 Data Modeling Language\",\n\
    \              RFC 7950, DOI 10.17487/RFC7950, August 2016,\n              <https://www.rfc-editor.org/info/rfc7950>.\n\
    \   [RFC7952]  Lhotka, L., \"Defining and Using Metadata with YANG\",\n      \
    \        RFC 7952, DOI 10.17487/RFC7952, August 2016,\n              <https://www.rfc-editor.org/info/rfc7952>.\n\
    \   [RFC8040]  Bierman, A., Bjorklund, M., and K. Watsen, \"RESTCONF\n       \
    \       Protocol\", RFC 8040, DOI 10.17487/RFC8040, January 2017,\n          \
    \    <https://www.rfc-editor.org/info/rfc8040>.\n   [RFC8174]  Leiba, B., \"Ambiguity\
    \ of Uppercase vs Lowercase in\n              RFC 2119 Key Words\", BCP 14, RFC\
    \ 8174,\n              DOI 10.17487/RFC8174, May 2017,\n              <https://www.rfc-editor.org/info/rfc8174>.\n\
    \   [W3C.REC-xml-20081126]\n              Bray, T., Paoli, J., Sperberg-McQueen,\
    \ M., Maler, E., and\n              F. Yergeau, \"Extensible Markup Language (XML)\
    \ 1.0\n              (Fifth Edition)\", World Wide Web Consortium Recommendation\n\
    \              REC-xml-20081126, November 2008,\n              <https://www.w3.org/TR/2008/REC-xml-20081126>.\n"
- title: 10.2.  Informative References
  contents:
  - "10.2.  Informative References\n   [NETMOD-Operational]\n              Bjorklund,\
    \ M. and L. Lhotka, \"Operational Data in NETCONF\n              and YANG\", Work\
    \ in Progress, draft-bjorklund-netmod-\n              operational-00, October\
    \ 2012.\n   [OpState-Enhance]\n              Watsen, K., Bierman, A., Bjorklund,\
    \ M., and J.\n              Schoenwaelder, \"Operational State Enhancements for\
    \ YANG,\n              NETCONF, and RESTCONF\", Work in Progress, draft-kwatsen-\n\
    \              netmod-opstate-02, February 2016.\n   [OpState-Modeling]\n    \
    \          Shakir, R., Shaikh, A., and M. Hines, \"Consistent Modeling\n     \
    \         of Operational State Data in YANG\", Work in Progress,\n           \
    \   draft-openconfig-netmod-opstate-01, July 2015.\n   [OpState-Reqs]\n      \
    \        Watsen, K. and T. Nadeau, \"Terminology and Requirements\n          \
    \    for Enhanced Handling of Operational State\", Work in\n              Progress,\
    \ draft-ietf-netmod-opstate-reqs-04, January 2016.\n   [RFC3688]  Mealling, M.,\
    \ \"The IETF XML Registry\", BCP 81, RFC 3688,\n              DOI 10.17487/RFC3688,\
    \ January 2004,\n              <https://www.rfc-editor.org/info/rfc3688>.\n  \
    \ [RFC6020]  Bjorklund, M., Ed., \"YANG - A Data Modeling Language for\n     \
    \         the Network Configuration Protocol (NETCONF)\", RFC 6020,\n        \
    \      DOI 10.17487/RFC6020, October 2010,\n              <https://www.rfc-editor.org/info/rfc6020>.\n\
    \   [RFC6244]  Shafer, P., \"An Architecture for Network Management Using\n  \
    \            NETCONF and YANG\", RFC 6244, DOI 10.17487/RFC6244,\n           \
    \   June 2011, <https://www.rfc-editor.org/info/rfc6244>.\n   [RFC8343]  Bjorklund,\
    \ M., \"A YANG Data Model for Interface\n              Management\", RFC 8343,\
    \ DOI 10.17487/RFC8343, March 2018,\n              <https://www.rfc-editor.org/info/rfc8343>.\n\
    \   [RFC8344]  Bjorklund, M., \"A YANG Data Model for IP Management\",\n     \
    \         RFC 8344, DOI 10.17487/RFC8344, March 2018,\n              <https://www.rfc-editor.org/info/rfc8344>.\n\
    \   [With-config-state]\n              Wilton, R., \"\"With-config-state\" Capability\
    \ for\n              NETCONF/RESTCONF\", Work in Progress, draft-wilton-netmod-\n\
    \              opstate-yang-02, December 2015.\n   [YANG-SEC] IETF, \"YANG Security\
    \ Guidelines\", <https://trac.ietf.org/\n              trac/ops/wiki/yang-security-guidelines>.\n"
- title: Appendix A.  Guidelines for Defining Datastores
  contents:
  - "Appendix A.  Guidelines for Defining Datastores\n   The definition of a new datastore\
    \ in this architecture should be\n   provided in a document (e.g., an RFC) purposed\
    \ for defining the\n   datastore.  When it makes sense, more than one datastore\
    \ may be\n   defined in the same document (e.g., when the datastores are logically\n\
    \   connected).  Each datastore's definition should address the points\n   specified\
    \ in the subsections below.\n"
- title: A.1.  Define Which YANG Modules Can Be Used in the Datastore
  contents:
  - "A.1.  Define Which YANG Modules Can Be Used in the Datastore\n   Not all YANG\
    \ modules may be used in all datastores.  Some datastores\n   may constrain which\
    \ data models can be used in them.  If it is\n   desirable that a subset of all\
    \ modules can be targeted to the\n   datastore, then the documentation defining\
    \ the datastore must\n   indicate this.\n"
- title: A.2.  Define Which Subset of YANG-Modeled Data Applies
  contents:
  - "A.2.  Define Which Subset of YANG-Modeled Data Applies\n   By default, the data\
    \ in a datastore is modeled by all YANG statements\n   in the available YANG modules.\
    \  However, it is possible to specify\n   criteria that YANG statements must satisfy\
    \ in order to be present in\n   a datastore.  For instance, maybe only \"config\
    \ true\" nodes, or\n   \"config false\" nodes that also have a specific YANG extension,\
    \ are\n   present in the datastore.\n"
- title: A.3.  Define How Data Is Actualized
  contents:
  - "A.3.  Define How Data Is Actualized\n   The new datastore must specify how it\
    \ interacts with other\n   datastores.\n   For example, the diagram in Section\
    \ 5 depicts dynamic configuration\n   datastores feeding into <operational>. \
    \ How this interaction occurs\n   has to be defined by the particular dynamic\
    \ configuration datastores.\n   In some cases, it may occur implicitly, as soon\
    \ as the data is put\n   into the dynamic configuration datastore, while in other\
    \ cases an\n   explicit action (e.g., an RPC) may be required to trigger the\n\
    \   application of the datastore's data.\n"
- title: A.4.  Define Which Protocols Can Be Used
  contents:
  - "A.4.  Define Which Protocols Can Be Used\n   By default, it is assumed that both\
    \ the NETCONF and RESTCONF\n   protocols can be used to interact with a datastore.\
    \  However, it may\n   be that only a specific protocol can be used (e.g., Forwarding\
    \ and\n   Control Element Separation (ForCES)) or that a subset of all protocol\n\
    \   operations or capabilities are available (e.g., no locking or no\n   XPath-based\
    \ filtering).\n"
- title: A.5.  Define YANG Identities for the Datastore
  contents:
  - "A.5.  Define YANG Identities for the Datastore\n   The datastore must be defined\
    \ with a YANG identity that uses the\n   \"ds:datastore\" identity, or one of\
    \ its derived identities, as its\n   base.  This identity is necessary, so that\
    \ the datastore can be\n   referenced in protocol operations (e.g., <get-data>).\n\
    \   The datastore may also be defined with an identity that uses the\n   \"or:origin\"\
    \ identity, or one of its derived identities, as its base.\n   This identity is\
    \ needed if the datastore interacts with\n   <operational>, so that data originating\
    \ from the datastore can be\n   identified as such via the \"origin\" metadata\
    \ attribute defined in\n   Section 7.\n   An example of these guidelines in use\
    \ is provided in Appendix B.\n"
- title: Appendix B.  Example of an Ephemeral Dynamic Configuration Datastore
  contents:
  - "Appendix B.  Example of an Ephemeral Dynamic Configuration Datastore\n   This\
    \ section defines documentation for an example dynamic\n   configuration datastore\
    \ using the guidelines provided in Appendix A.\n   For brevity, only a terse example\
    \ is provided; it is expected that a\n   standalone RFC would be written when\
    \ this type of scenario is fully\n   considered.\n   This example defines a dynamic\
    \ configuration datastore called\n   \"ephemeral\", which is loosely modeled after\
    \ the work done in the I2RS\n   Working Group.\n   +--------------------+----------------------------------------------+\n\
    \   | Name               | Value                                        |\n  \
    \ +--------------------+----------------------------------------------+\n   |\
    \ Name               | ephemeral                                    |\n   |  \
    \                  |                                              |\n   | YANG\
    \ modules       | all (default)                                |\n   |       \
    \             |                                              |\n   | YANG nodes\
    \         | all \"config true\" data nodes                 |\n   |           \
    \         |                                              |\n   | How applied \
    \       | changes automatically propagated to          |\n   |               \
    \     | <operational>                                |\n   |                 \
    \   |                                              |\n   | Protocols         \
    \ | NETCONF/RESTCONF (default)                   |\n   |                    |\
    \                                              |\n   | Defining YANG      | \"\
    example-ds-ephemeral\"                       |\n   | module             |    \
    \                                          |\n   +--------------------+----------------------------------------------+\n\
    \              Properties of the Example \"ephemeral\" Datastore\n   module example-ds-ephemeral\
    \ {\n     yang-version 1.1;\n     namespace \"urn:example:ds-ephemeral\";\n  \
    \   prefix eph;\n     import ietf-datastores {\n       prefix ds;\n     }\n  \
    \   import ietf-origin {\n       prefix or;\n     }\n     // datastore identity\n\
    \     identity ds-ephemeral {\n       base ds:dynamic;\n       description\n \
    \        \"The ephemeral dynamic configuration datastore.\";\n     }\n     //\
    \ origin identity\n     identity or-ephemeral {\n       base or:dynamic;\n   \
    \    description\n         \"Denotes data from the ephemeral dynamic configuration\n\
    \          datastore.\";\n     }\n   }\n"
- title: Appendix C.  Example Data
  contents:
  - "Appendix C.  Example Data\n   The use of datastores is complex, and many of the\
    \ subtle effects are\n   more easily presented using examples.  This section presents\
    \ a series\n   of example data models with some sample contents of the various\n\
    \   datastores.\n   The XML [W3C.REC-xml-20081126] snippets that follow are provided\
    \ as\n   examples only.\n"
- title: C.1.  System Example
  contents:
  - "C.1.  System Example\n   In this example, the following fictional module is used:\n\
    \   module example-system {\n     yang-version 1.1;\n     namespace urn:example:system;\n\
    \     prefix sys;\n     import ietf-inet-types {\n       prefix inet;\n     }\n\
    \     container system {\n       leaf hostname {\n         type string;\n    \
    \   }\n       list interface {\n         key name;\n         leaf name {\n   \
    \        type string;\n         }\n         container auto-negotiation {\n   \
    \        leaf enabled {\n             type boolean;\n             default true;\n\
    \           }\n           leaf speed {\n             type uint32;\n          \
    \   units mbps;\n             description\n               \"The advertised speed,\
    \ in Mbps.\";\n           }\n         }\n         leaf speed {\n           type\
    \ uint32;\n           units mbps;\n           config false;\n           description\n\
    \             \"The speed of the interface, in Mbps.\";\n         }\n        \
    \ list address {\n           key ip;\n           leaf ip {\n             type\
    \ inet:ip-address;\n           }\n           leaf prefix-length {\n          \
    \   type uint8;\n           }\n         }\n       }\n     }\n   }\n   The operator\
    \ has configured the hostname and two interfaces, so the\n   contents of <intended>\
    \ are:\n   <system xmlns=\"urn:example:system\">\n     <hostname>foo.example.com</hostname>\n\
    \     <interface>\n       <name>eth0</name>\n       <auto-negotiation>\n     \
    \    <speed>1000</speed>\n       </auto-negotiation>\n       <address>\n     \
    \    <ip>2001:db8::10</ip>\n         <prefix-length>64</prefix-length>\n     \
    \  </address>\n     </interface>\n     <interface>\n       <name>eth1</name>\n\
    \       <address>\n         <ip>2001:db8::20</ip>\n         <prefix-length>64</prefix-length>\n\
    \       </address>\n     </interface>\n   </system>\n   The system has detected\
    \ that the hardware for one of the configured\n   interfaces (\"eth1\") is not\
    \ yet present, so the configuration for that\n   interface is not applied.  Further,\
    \ the system has received a\n   hostname and an additional IP address for \"eth0\"\
    \ over DHCP.  In\n   addition to filling in the default value for the auto-negotiation\n\
    \   enabled leaf, a loopback interface entry is also automatically\n   instantiated\
    \ by the system.  All of this is reflected in\n   <operational>.  Note how the\
    \ \"origin\" metadata attribute for several\n   \"config true\" data nodes is\
    \ inherited from their parent data nodes.\n   <system\n       xmlns=\"urn:example:system\"\
    \n       xmlns:or=\"urn:ietf:params:xml:ns:yang:ietf-origin\">\n     <hostname\
    \ or:origin=\"or:learned\">bar.example.com</hostname>\n     <interface or:origin=\"\
    or:intended\">\n       <name>eth0</name>\n       <auto-negotiation>\n        \
    \ <enabled or:origin=\"or:default\">true</enabled>\n         <speed>1000</speed>\n\
    \       </auto-negotiation>\n       <speed>100</speed>\n       <address>\n   \
    \      <ip>2001:db8::10</ip>\n         <prefix-length>64</prefix-length>\n   \
    \    </address>\n       <address or:origin=\"or:learned\">\n         <ip>2001:db8::1:100</ip>\n\
    \         <prefix-length>64</prefix-length>\n       </address>\n     </interface>\n\
    \     <interface or:origin=\"or:system\">\n       <name>lo0</name>\n       <address>\n\
    \         <ip>::1</ip>\n         <prefix-length>128</prefix-length>\n       </address>\n\
    \     </interface>\n   </system>\n"
- title: C.2.  BGP Example
  contents:
  - "C.2.  BGP Example\n   Consider the following fragment of a fictional BGP module:\n\
    \       container bgp {\n         leaf local-as {\n           type uint32;\n \
    \        }\n         leaf peer-as {\n           type uint32;\n         }\n   \
    \      list peer {\n           key name;\n           leaf name {\n           \
    \  type inet:ip-address;\n           }\n           leaf local-as {\n         \
    \    type uint32;\n             description\n               \"... Defaults to\
    \ ../local-as.\";\n           }\n           leaf peer-as {\n             type\
    \ uint32;\n             description\n               \"... Defaults to ../peer-as.\"\
    ;\n           }\n           leaf local-port {\n             type inet:port;\n\
    \           }\n           leaf remote-port {\n             type inet:port;\n \
    \            default 179;\n           }\n           leaf state {\n           \
    \  config false;\n             type enumeration {\n               enum init;\n\
    \               enum established;\n               enum closing;\n            \
    \ }\n           }\n         }\n       }\n   In this example model, both bgp/peer/local-as\
    \ and bgp/peer/peer-as\n   have complex hierarchical values, allowing the user\
    \ to specify\n   default values for all peers in a single location.\n   The model\
    \ also follows the pattern of fully integrating state\n   (\"config false\") nodes\
    \ with configuration (\"config true\") nodes.\n   There is no separate \"bgp-state\"\
    \ hierarchy, with the accompanying\n   repetition of containment and naming nodes.\
    \  This makes the model\n   simpler and more readable.\n"
- title: C.2.1.  Datastores
  contents:
  - "C.2.1.  Datastores\n   Each datastore represents differing views of these nodes.\
    \  <running>\n   will hold the configuration provided by the operator -- for example,\n\
    \   a single BGP peer.  <intended> will conceptually hold the data as\n   validated,\
    \ after the removal of data not intended for validation and\n   after any local\
    \ template mechanisms are performed.  <operational>\n   will show data from <intended>\
    \ as well as any \"config false\" nodes.\n"
- title: C.2.2.  Adding a Peer
  contents:
  - "C.2.2.  Adding a Peer\n   If the user configures a single BGP peer, then that\
    \ peer will be\n   visible in both <running> and <intended>.  It may also appear\
    \ in\n   <candidate> if the server supports the candidate configuration\n   datastore.\
    \  Retrieving the peer will return only the user-specified\n   values.\n   No\
    \ time delay should exist between the appearance of the peer in\n   <running>\
    \ and <intended>.\n   In this scenario, we've added the following to <running>:\n\
    \     <bgp>\n       <local-as>64501</local-as>\n       <peer-as>64502</peer-as>\n\
    \       <peer>\n         <name>2001:db8::2:3</name>\n       </peer>\n     </bgp>\n"
- title: C.2.2.1.  <operational>
  contents:
  - "C.2.2.1.  <operational>\n   The operational datastore will contain the fully\
    \ expanded peer data,\n   including \"config false\" nodes.  In our example, this\
    \ means that the\n   \"state\" node will appear.\n   In addition, <operational>\
    \ will contain the \"currently in use\" values\n   for all nodes.  This means\
    \ that local-as and peer-as will be\n   populated even if they are not given values\
    \ in <intended>.  The value\n   of bgp/local-as will be used if bgp/peer/local-as\
    \ is not provided;\n   bgp/peer-as and bgp/peer/peer-as will have the same relationship.\
    \  In\n   the operational view, this means that every peer will have values for\n\
    \   their local-as and peer-as, even if those values are not explicitly\n   configured\
    \ but are provided by bgp/local-as and bgp/peer-as.\n   Each BGP peer has a TCP\
    \ connection associated with it, using the\n   values of local-port and remote-port\
    \ from <intended>.  If those\n   values are not supplied, the system will select\
    \ values.  When the\n   connection is established, <operational> will contain\
    \ the current\n   values for the local-port and remote-port nodes regardless of\
    \ the\n   origin.  If the system has chosen the values, the \"origin\" attribute\n\
    \   will be set to \"system\".  Before the connection is established, one\n  \
    \ or both of the nodes may not appear, since the system may not yet\n   have their\
    \ values.\n     <bgp xmlns:or=\"urn:ietf:params:xml:ns:yang:ietf-origin\"\n  \
    \        or:origin=\"or:intended\">\n       <local-as>64501</local-as>\n     \
    \  <peer-as>64502</peer-as>\n       <peer>\n         <name>2001:db8::2:3</name>\n\
    \         <local-as or:origin=\"or:default\">64501</local-as>\n         <peer-as\
    \ or:origin=\"or:default\">64502</peer-as>\n         <local-port or:origin=\"\
    or:system\">60794</local-port>\n         <remote-port or:origin=\"or:default\"\
    >179</remote-port>\n         <state>established</state>\n       </peer>\n    \
    \ </bgp>\n"
- title: C.2.3.  Removing a Peer
  contents:
  - "C.2.3.  Removing a Peer\n   Changes to configuration may take time to percolate\
    \ through the\n   various software components involved.  During this period, it\
    \ is\n   imperative to continue to give an accurate view of the working of the\n\
    \   device.  <operational> will contain nodes for both the previous and\n   current\
    \ configuration, as closely as possible tracking the current\n   operation of\
    \ the device.\n   Consider the scenario where a client removes a BGP peer.  When\
    \ a peer\n   is removed, the operational state will continue to reflect the\n\
    \   existence of that peer until the peer's resources are released,\n   including\
    \ closing the peer's connection.  During this period, the\n   current data values\
    \ will continue to be visible in <operational>,\n   with the \"origin\" attribute\
    \ set to indicate the origin of the\n   original data.\n     <bgp xmlns:or=\"\
    urn:ietf:params:xml:ns:yang:ietf-origin\"\n          or:origin=\"or:intended\"\
    >\n       <local-as>64501</local-as>\n       <peer-as>64502</peer-as>\n      \
    \ <peer>\n         <name>2001:db8::2:3</name>\n         <local-as or:origin=\"\
    or:default\">64501</local-as>\n         <peer-as or:origin=\"or:default\">64502</peer-as>\n\
    \         <local-port or:origin=\"or:system\">60794</local-port>\n         <remote-port\
    \ or:origin=\"or:default\">179</remote-port>\n         <state>closing</state>\n\
    \       </peer>\n     </bgp>\n   Once resources are released and the connection\
    \ is closed, the peer's\n   data is removed from <operational>.\n"
- title: C.3.  Interface Example
  contents:
  - "C.3.  Interface Example\n   In this section, we will use this simple interface\
    \ data model:\n     container interfaces {\n       list interface {\n        \
    \ key name;\n         leaf name {\n           type string;\n         }\n     \
    \    leaf description {\n           type string;\n         }\n         leaf mtu\
    \ {\n           type uint16;\n         }\n         leaf-list ip-address {\n  \
    \         type inet:ip-address;\n         }\n       }\n     }\n"
- title: C.3.1.  Pre-provisioned Interfaces
  contents:
  - "C.3.1.  Pre-provisioned Interfaces\n   One common issue in networking devices\
    \ is the support of Field\n   Replaceable Units (FRUs) that can be inserted and\
    \ removed from the\n   device without requiring a reboot or interfering with normal\n\
    \   operation.  These FRUs are typically interface cards, and the devices\n  \
    \ support pre-provisioning of these interfaces.\n   If a client creates an interface\
    \ \"et-0/0/0\" but the interface does\n   not physically exist at this point,\
    \ then <intended> might contain the\n   following:\n     <interfaces>\n      \
    \ <interface>\n         <name>et-0/0/0</name>\n         <description>Test interface</description>\n\
    \       </interface>\n     </interfaces>\n   Since the interface does not exist,\
    \ this data does not appear in\n   <operational>.\n   When a FRU containing this\
    \ interface is inserted, the system will\n   detect it and process the associated\
    \ configuration.  <operational>\n   will contain the data from <intended>, as\
    \ well as nodes added by the\n   system, such as the current value of the interface's\
    \ MTU.\n     <interfaces xmlns:or=\"urn:ietf:params:xml:ns:yang:ietf-origin\"\n\
    \                 or:origin=\"or:intended\">\n       <interface>\n         <name>et-0/0/0</name>\n\
    \         <description>Test interface</description>\n         <mtu or:origin=\"\
    or:system\">1500</mtu>\n       </interface>\n     </interfaces>\n   If the FRU\
    \ is removed, the interface data is removed from\n   <operational>.\n"
- title: C.3.2.  System-Provided Interface
  contents:
  - "C.3.2.  System-Provided Interface\n   Imagine that the system provides a loopback\
    \ interface (named \"lo0\")\n   with a default IPv4 address of \"127.0.0.1\" and\
    \ a default IPv6 address\n   of \"::1\".  The system will only provide configuration\
    \ for this\n   interface if there is no data for it in <intended>.\n   When no\
    \ configuration for \"lo0\" appears in <intended>, <operational>\n   will show\
    \ the system-provided data:\n     <interfaces xmlns:or=\"urn:ietf:params:xml:ns:yang:ietf-origin\"\
    \n                 or:origin=\"or:intended\">\n       <interface or:origin=\"\
    or:system\">\n         <name>lo0</name>\n         <ip-address>127.0.0.1</ip-address>\n\
    \         <ip-address>::1</ip-address>\n       </interface>\n     </interfaces>\n\
    \   When configuration for \"lo0\" does appear in <intended>, <operational>\n\
    \   will show that data with the origin set to \"intended\".  If the\n   \"ip-address\"\
    \ is not provided, then the system-provided value will\n   appear as follows:\n\
    \     <interfaces xmlns:or=\"urn:ietf:params:xml:ns:yang:ietf-origin\"\n     \
    \            or:origin=\"or:intended\">\n       <interface>\n         <name>lo0</name>\n\
    \         <description>loopback</description>\n         <ip-address or:origin=\"\
    or:system\">127.0.0.1</ip-address>\n         <ip-address>::1</ip-address>\n  \
    \     </interface>\n     </interfaces>\n"
- title: Acknowledgments
  contents:
  - "Acknowledgments\n   This document grew out of many discussions that took place\
    \ since\n   2010.  Several documents ([NETMOD-Operational] [With-config-state]\n\
    \   [OpState-Reqs] [OpState-Enhance] [OpState-Modeling], as well as\n   [RFC6244]),\
    \ touched on some of the problems of the original datastore\n   model.  The following\
    \ people were authors of these works in progress\n   or were otherwise actively\
    \ involved in the discussions that led to\n   this document:\n   o  Lou Berger,\
    \ LabN Consulting, L.L.C., <lberger@labn.net>\n   o  Andy Bierman, YumaWorks,\
    \ <andy@yumaworks.com>\n   o  Marcus Hines, Google, <hines@google.com>\n   o \
    \ Christian Hopps, Deutsche Telekom, <chopps@chopps.org>\n   o  Balazs Lengyel,\
    \ Ericsson, <balazs.lengyel@ericsson.com>\n   o  Ladislav Lhotka, CZ.NIC, <lhotka@nic.cz>\n\
    \   o  Acee Lindem, Cisco Systems, <acee@cisco.com>\n   o  Thomas Nadeau, Brocade\
    \ Networks, <tnadeau@lucidvision.com>\n   o  Tom Petch, Engineering Networks Ltd,\
    \ <ietfc@btconnect.com>\n   o  Anees Shaikh, Google, <aashaikh@google.com>\n \
    \  o  Rob Shakir, Google, <robjs@google.com>\n   o  Jason Sterne, Nokia, <jason.sterne@nokia.com>\n\
    \   Juergen Schoenwaelder was partly funded by Flamingo, a Network of\n   Excellence\
    \ project (ICT-318488) supported by the European Commission\n   under its Seventh\
    \ Framework Programme.\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Martin Bjorklund\n   Tail-f Systems\n   Email: mbj@tail-f.com\n\
    \   Juergen Schoenwaelder\n   Jacobs University\n   Email: j.schoenwaelder@jacobs-university.de\n\
    \   Phil Shafer\n   Juniper Networks\n   Email: phil@juniper.net\n   Kent Watsen\n\
    \   Juniper Networks\n   Email: kwatsen@juniper.net\n   Robert Wilton\n   Cisco\
    \ Systems\n   Email: rwilton@cisco.com\n"
