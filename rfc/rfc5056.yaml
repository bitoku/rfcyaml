- title: __initial_text__
  contents:
  - '           On the Use of Channel Bindings to Secure Channels

    '
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This document specifies an Internet standards track protocol\
    \ for the\n   Internet community, and requests discussion and suggestions for\n\
    \   improvements.  Please refer to the current edition of the \"Internet\n   Official\
    \ Protocol Standards\" (STD 1) for the standardization state\n   and status of\
    \ this protocol.  Distribution of this memo is unlimited.\n"
- title: Abstract
  contents:
  - "Abstract\n   The concept of channel binding allows applications to establish\
    \ that\n   the two end-points of a secure channel at one network layer are the\n\
    \   same as at a higher layer by binding authentication at the higher\n   layer\
    \ to the channel at the lower layer.  This allows applications to\n   delegate\
    \ session protection to lower layers, which has various\n   performance benefits.\n\
    \   This document discusses and formalizes the concept of channel binding\n  \
    \ to secure channels.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1. Introduction ....................................................3\n\
    \      1.1. Conventions Used in This Document ..........................4\n  \
    \ 2. Definitions .....................................................4\n    \
    \  2.1. Properties of Channel Binding ..............................6\n      2.2.\
    \ EAP Channel Binding ........................................9\n   3. Authentication\
    \ and Channel Binding Semantics ...................10\n      3.1. The GSS-API\
    \ and Channel Binding ...........................10\n      3.2. SASL and Channel\
    \ Binding ..................................11\n   4. Channel Bindings Specifications\
    \ ................................11\n      4.1. Examples of Unique Channel Bindings\
    \ .......................11\n      4.2. Examples of End-Point Channel Bindings\
    \ ....................12\n   5. Uses of Channel Binding ........................................12\n\
    \   6. Benefits of Channel Binding to Secure Channels .................14\n  \
    \ 7. IANA Considerations ............................................15\n    \
    \  7.1. Registration Procedure ....................................15\n      7.2.\
    \ Comments on Channel Bindings Registrations ................16\n      7.3. Change\
    \ Control ............................................17\n   8. Security Considerations\
    \ ........................................17\n      8.1. Non-Unique Channel Bindings\
    \ and Channel Binding\n           Re-Establishment ..........................................18\n\
    \   9. References .....................................................19\n  \
    \    9.1. Normative References ......................................19\n    \
    \  9.2. Informative References ....................................19\n   Appendix\
    \ A. Acknowledgments .......................................22\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   In a number of situations, it is useful for an application\
    \ to be able\n   to handle authentication within the application layer, while\n\
    \   simultaneously being able to utilize session or transport security at\n  \
    \ a lower network layer.  For example, IPsec [RFC4301] [RFC4303]\n   [RFC4302]\
    \ is amenable to being accelerated in hardware to handle very\n   high link speeds,\
    \ but IPsec key exchange protocols and the IPsec\n   architecture are not as amenable\
    \ to use as a security mechanism\n   within applications, particularly applications\
    \ that have users as\n   clients.  A method of combining security at both layers\
    \ is therefore\n   attractive.  To enable this to be done securely, it is necessary\
    \ to\n   \"bind\" the mechanisms together -- so as to avoid man-in-the-middle\n\
    \   vulnerabilities and enable the mechanisms to be integrated in a\n   seamless\
    \ way.  This is the objective of \"Channel Bindings\".\n   The term \"channel\
    \ binding\", as used in this document, derives from\n   the Generic Security Service\
    \ Application Program Interface (GSS-API)\n   [RFC2743], which has a channel binding\
    \ facility that was intended for\n   binding GSS-API authentication to secure\
    \ channels at lower network\n   layers.  The purpose and benefits of the GSS-API\
    \ channel binding\n   facility were not discussed at length, and some details\
    \ were left\n   unspecified.  Now we find that this concept can be very useful,\n\
    \   therefore we begin with a generalization and formalization of\n   \"channel\
    \ binding\" independent of the GSS-API.\n   Although inspired by and derived from\
    \ the GSS-API, the notion of\n   channel binding described herein is not at all\
    \ limited to use by GSS-\n   API applications.  We envision use of channel binding\
    \ by applications\n   that utilize other security frameworks, such as Simple Authentication\n\
    \   and Security Layer (SASL) [RFC4422] and even protocols that provide\n   their\
    \ own authentication mechanisms (e.g., the Key Distribution\n   Center (KDC) exchanges\
    \ of Kerberos V [RFC4120]).  We also envision\n   use of the notion of channel\
    \ binding in the analysis of security\n   protocols.\n   The main goal of channel\
    \ binding is to be able to delegate\n   cryptographic session protection to network\
    \ layers below the\n   application in hopes of being able to better leverage hardware\n\
    \   implementations of cryptographic protocols.  Section 5 describes some\n  \
    \ intended uses of channel binding.  Also, some applications may\n   benefit by\
    \ reducing the amount of active cryptographic state, thus\n   reducing overhead\
    \ in accessing such state and, therefore, the impact\n   of security on latency.\n\
    \   The critical security problem to solve in order to achieve such\n   delegation\
    \ of session protection is ensuring that there is no man-\n   in-the-middle (MITM),\
    \ from the point of view the application, at the\n   lower network layer to which\
    \ session protection is to be delegated.\n   There may well be an MITM, particularly\
    \ if either the lower network\n   layer provides no authentication or there is\
    \ no strong connection\n   between the authentication or principals used at the\
    \ application and\n   those used at the lower network layer.\n   Even if such\
    \ MITM attacks seem particularly difficult to effect, the\n   attacks must be\
    \ prevented for certain applications to be able to make\n   effective use of technologies\
    \ such as IPsec [RFC2401] [RFC4301] or\n   HTTP with TLS [RFC4346] in certain\
    \ contexts (e.g., when there is no\n   authentication to speak of, or when one\
    \ node's set of trust anchors\n   is too weak to believe that it can authenticate\
    \ its peers).\n   Additionally, secure channels that are susceptible to MITM attacks\n\
    \   because they provide no useful end-point authentication are useful\n   when\
    \ combined with application-layer authentication (otherwise they\n   are only\
    \ somewhat \"better than nothing\" -- see Better Than Nothing\n   Security (BTNS)\
    \ [BTNS-AS]).\n   For example, Internet Small Computer Systems Interface (iSCSI)\n\
    \   [RFC3720] provides for application-layer authentication (e.g., using\n   Kerberos\
    \ V), but relies on IPsec for transport protection; iSCSI does\n   not provide\
    \ a binding between the two. iSCSI initiators have to be\n   careful to make sure\
    \ that the name of the server authenticated at the\n   application layer and the\
    \ name of the peer at the IPsec layer match\n   -- an informal form of channel\
    \ binding.\n   This document describes a solution: the use of \"channel binding\"\
    \ to\n   bind authentication at application layers to secure sessions at lower\n\
    \   layers in the network stack.\n"
- title: 1.1.  Conventions Used in This Document
  contents:
  - "1.1.  Conventions Used in This Document\n   The key words \"MUST\", \"MUST NOT\"\
    , \"REQUIRED\", \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\"\
    , \"MAY\", and \"OPTIONAL\" in this\n   document are to be interpreted as described\
    \ in [RFC2119].\n"
- title: 2.  Definitions
  contents:
  - "2.  Definitions\n   o  Secure channel: a packet, datagram, octet stream connection,\
    \ or\n      sequence of connections between two end-points that affords\n    \
    \  cryptographic integrity and, optionally, confidentiality to data\n      exchanged\
    \ over it.  We assume that the channel is secure -- if an\n      attacker can\
    \ successfully cryptanalyze a channel's session keys,\n      for example, then\
    \ the channel is not secure.\n   o  Channel binding: the process of establishing\
    \ that no man-in-the-\n      middle exists between two end-points that have been\
    \ authenticated\n      at one network layer but are using a secure channel at\
    \ a lower\n      network layer.  This term is used as a noun.\n   o  Channel bindings:\
    \ [See historical note below.]\n         Generally, some data that \"names\" a\
    \ channel or one or both of\n         its end-points such that if this data can\
    \ be shown, at a higher\n         network layer, to be the same at both ends of\
    \ a channel, then\n         there are no MITMs between the two end-points at that\
    \ higher\n         network layer.  This term is used as a noun.\n         More\
    \ formally, there are two types of channel bindings:\n         +  unique channel\
    \ bindings:\n            channel bindings that name a channel in a cryptographically\n\
    \            secure manner and uniquely in time;\n         +  end-point channel\
    \ bindings:\n            channel bindings that name the authenticated end-points,\
    \ or\n            even a single end-point, of a channel which are, in turn,\n\
    \            securely bound to the channel, but which do not identify a\n    \
    \        channel uniquely in time.\n   o  Cryptographic binding: (e.g., \"cryptographically\
    \ bound\") a\n      cryptographic operation that causes an object, such as a private\n\
    \      encryption or signing key, or an established secure channel, to\n     \
    \ \"speak for\" [Lampson91] some principal, such as a user, a\n      computer,\
    \ etcetera.  For example, a Public Key Infrastructure for\n      X.509 Certificates\
    \ (PKIX) certificate binds a private key to the\n      name of a principal in\
    \ the trust domain of the certificate's\n      issuer such that a possessor of\
    \ said private key can act on behalf\n      of the user (or other entity) named\
    \ by the certificate.\n      Cryptographic bindings are generally asymmetric in\
    \ nature (not to\n      be confused with symmetric or asymmetric key cryptography)\
    \ in that\n      an object is rendered capable of standing for another, but the\n\
    \      reverse is not usually the case (we don't say that a user speaks\n    \
    \  for their private keys, but we do say that the user's private keys\n      speak\
    \ for the user).\n   Note that there may be many instances of \"cryptographic\
    \ binding\" in\n   an application of channel binding.  The credentials that authenticate\n\
    \   principals at the application layer bind private or secret keys to\n   the\
    \ identities of those principals, such that said keys speak for\n   them.  A secure\
    \ channel typically consists of symmetric session keys\n   used to provide confidentiality\
    \ and integrity protection to data sent\n   over the channel; each end-point's\
    \ session keys speak for that end-\n   point of the channel.  Finally, each end-point\
    \ of a channel bound to\n   authentication at the application layer speaks for\
    \ the principal\n   authenticated at the application layer on the same side of\
    \ the\n   channel.\n   The terms defined above have been in use for many years\
    \ and have been\n   taken to mean, at least in some contexts, what is stated below.\n\
    \   Unfortunately this means that \"channel binding\" can refer to the\n   channel\
    \ binding operation and, sometimes to the name of a channel,\n   and \"channel\
    \ bindings\" -- a difference of only one letter --\n   generally refers to the\
    \ name of a channel.\n   Note that the Extensible Authentication Protocol (EAP)\
    \ [RFC3748] uses\n   \"channel binding\" to refer to a facility that may appear\
    \ to be\n   similar to the one decribed here, but it is, in fact, quite\n   different.\
    \  See Section 2.2 for mode details.\n"
- title: 2.1.  Properties of Channel Binding
  contents:
  - "2.1.  Properties of Channel Binding\n   Applications, authentication frameworks\
    \ (e.g., the GSS-API, SASL),\n   security mechanisms (e.g., the Kerberos V GSS-API\
    \ mechanism\n   [RFC1964]), and secure channels must meet the requirements and\
    \ should\n   follow the recommendations that are listed below.\n   Requirements:\n\
    \   o  In order to use channel binding, applications MUST verify that the\n  \
    \    same channel bindings are observed at either side of the channel.\n     \
    \ To do this, the application MUST use an authentication protocol at\n      the\
    \ application layer to authenticate one, the other, or both\n      application\
    \ peers (one at each end of the channel).\n      *  If the authentication protocol\
    \ used by the application supports\n         channel binding, the application\
    \ SHOULD use it.\n      *  An authentication protocol that supports channel binding\
    \ MUST\n         provide an input slot in its API for a \"handle\" to the channel,\n\
    \         or its channel bindings.\n      *  If the authentication protocol does\
    \ not support a channel\n         binding operation, but provides a \"security\
    \ layer\" with at\n         least integrity protection, then the application MUST\
    \ use the\n         authentication protocol's integrity protection facilities\
    \ to\n         exchange channel bindings, or cryptographic hashes thereof.\n \
    \     *  The name of the type of channel binding MUST be used by the\n       \
    \  application and/or authentication protocol to avoid ambiguity\n         about\
    \ which of several possible types of channels is being\n         bound.  If nested\
    \ instances of the same type of channel are\n         available, then the innermost\
    \ channel MUST be used.\n   o  Specifications of channel bindings for any secure\
    \ channels MUST\n      provide for a single, canonical octet string encoding of\
    \ the\n      channel bindings.  Under this framework, channel bindings MUST\n\
    \      start with the channel binding unique prefix followed by a colon\n    \
    \  (ASCII 0x3A).\n   o  The channel bindings for a given type of secure channel\
    \ MUST be\n      constructed in such a way that an MITM could not easily force\
    \ the\n      channel bindings of a given channel to match those of another.\n\
    \   o  Unique channel bindings MUST bind not only the key exchange for\n     \
    \ the secure channel, but also any negotiations and authentication\n      that\
    \ may have taken place to establish the channel.\n   o  End-point channel bindings\
    \ MUST be bound into the secure channel\n      and all its negotiations.  For\
    \ example, a public key as an end-\n      point channel binding should be used\
    \ to verify a signature of such\n      negotiations (or to encrypt them), including\
    \ the initial key\n      exchange and negotiation messages for that channel --\
    \ such a key\n      would then be bound into the channel.  A certificate name\
    \ as end-\n      point channel binding could also be bound into the channel in\
    \ a\n      similar way, though in the case of a certificate name, the binding\n\
    \      also depends on the strength of the authentication of that name\n     \
    \ (that is, the validation of the certificate, the trust anchors,\n      the algorithms\
    \ used in the certificate path construction and\n      validation, etcetera).\n\
    \   o  End-point channel bindings MAY be identifiers (e.g., certificate\n    \
    \  names) that must be authenticated through some infrastructure,\n      such\
    \ as a public key infrastructure (PKI).  In such cases,\n      applications MUST\
    \ ensure that the channel provides adequate\n      authentication of such identifiers\
    \ (e.g., that the certificate\n      validation policy and trust anchors used\
    \ by the channel satisfy\n      the application's requirements).  To avoid implementation\n\
    \      difficulties in addressing this requirement, applications SHOULD\n    \
    \  use cryptographic quantities as end-point channel bindings, such\n      as\
    \ certificate-subject public keys.\n   o  Applications that desire confidentiality\
    \ protection MUST use\n      application-layer session protection services for\
    \ confidentiality\n      protection when the bound channel does not provide confidentiality\n\
    \      protection.\n   o  The integrity of a secure channel MUST NOT be weakened\
    \ should\n      their channel bindings be revealed to an attacker.  That is, the\n\
    \      construction of the channel bindings for any type of secure\n      channel\
    \ MUST NOT leak secret information about the channel.  End-\n      point channel\
    \ bindings, however, MAY leak information about the\n      end-points of the channel\
    \ (e.g., their names).\n   o  The channel binding operation MUST be at least integrity\
    \ protected\n      in the security mechanism used at the application layer.\n\
    \   o  Authentication frameworks and mechanisms that support channel\n      binding\
    \ MUST communicate channel binding failure to applications.\n   o  Applications\
    \ MUST NOT send sensitive information, requiring\n      confidentiality protection,\
    \ over the underlying channel prior to\n      completing the channel binding operation.\n\
    \   Recommendations:\n   o  End-point channel bindings where the end-points are\
    \ meaningful\n      names SHOULD NOT be used when the channel does not provide\n\
    \      confidentiality protection and privacy protection is desired.\n      Alternatively,\
    \ channels that export such channel bindings SHOULD\n      provide for the use\
    \ of a digest and SHOULD NOT introduce new\n      digest/hash agility problems\
    \ as a result.\n   Options:\n   o  Authentication frameworks and mechanisms that\
    \ support channel\n      binding MAY fail to establish authentication if channel\
    \ binding\n      fails.\n   o  Applications MAY send information over the underlying\
    \ channel and\n      without integrity protection from the application-layer\n\
    \      authentication protocol prior to completing the channel binding\n     \
    \ operation if such information requires only integrity protection.\n      This\
    \ could be useful for optimistic negotiations.\n   o  A security mechanism MAY\
    \ exchange integrity-protected channel\n      bindings.\n   o  A security mechanism\
    \ MAY exchange integrity-protected digests of\n      channel bindings.  Such mechanisms\
    \ SHOULD provide for hash/digest\n      agility.\n   o  A security mechanism MAY\
    \ use channel bindings in key exchange,\n      authentication, or key derivation,\
    \ prior to the exchange of\n      \"authenticator\" messages.\n"
- title: 2.2.  EAP Channel Binding
  contents:
  - "2.2.  EAP Channel Binding\n   This section is informative.  This document does\
    \ not update EAP\n   [RFC3748], it neither normatively describes, nor does it\
    \ impose\n   requirements on any aspect of EAP or EAP methods.\n   EAP [RFC3748]\
    \ includes a concept of channel binding described as\n   follows:\n      The communication\
    \ within an EAP method of integrity-protected\n      channel properties such as\
    \ endpoint identifiers which can be\n      compared to values communicated via\
    \ out of band mechanisms (such\n      as via a AAA or lower layer protocol).\n\
    \   Section 7.15 of [RFC3748] describes the problem as one where a\n   Network\
    \ Access Server (NAS) (a.k.a. \"authenticator\") may lie to the\n   peer (client)\
    \ and cause the peer to make incorrect authorization\n   decisions (e.g., as to\
    \ what traffic may transit through the NAS).\n   This is not quite like the purpose\
    \ of generic channel binding (MITM\n   detection).\n   Section 7.15 of [RFC3748]\
    \ calls for \"a protected exchange of channel\n   properties such as endpoint\
    \ identifiers\" such that \"it is possible to\n   match the channel properties\
    \ provided by the authenticator via out-\n   of-band mechanisms against those\
    \ exchanged within the EAP method\".\n   This has sometimes been taken to be very\
    \ similar to the generic\n   notion of channel binding provided here.  However,\
    \ there is a very\n   subtle difference between the two concepts of channel binding\
    \ that\n   makes it much too difficult to put forth requirements and\n   recommendations\
    \ that apply to both.  The difference is about the\n   lower-layer channel:\n\
    \   o  In the generic channel binding case, the identities of either end\n   \
    \   of this channel are irrelevant to anything other than the\n      construction\
    \ of a name for that channel, in which case the\n      identities of the channel's\
    \ end-points must be established a\n      priori.\n   o  Whereas in the EAP case,\
    \ the identity of the NAS end of the\n      channel, and even security properties\
    \ of the channel itself, may\n      be established during or after authentication\
    \ of the EAP peer to\n      the EAP server.\n   In other words: there is a fundamental\
    \ difference in mechanics\n   (timing of lower-layer channel establishment) and\
    \ in purpose\n   (authentication of lower-layer channel properties for authorization\n\
    \   purposes vs. MITM detection).\n   After some discussion we have concluded\
    \ that there is no simple way\n   to obtain requirements and recommendations that\
    \ apply to both generic\n   and EAP channel binding.  Therefore, EAP is out of\
    \ the scope of this\n   document.\n"
- title: 3.  Authentication and Channel Binding Semantics
  contents:
  - "3.  Authentication and Channel Binding Semantics\n   Some authentication frameworks\
    \ and/or mechanisms provide for channel\n   binding, such as the GSS-API and some\
    \ GSS-API mechanisms, whereas\n   others may not, such as SASL (however, ongoing\
    \ work is adding channel\n   binding support to SASL).  Semantics may vary with\
    \ respect to\n   negotiation, how the binding occurs, and handling of channel\
    \ binding\n   failure (see below).\n   Where suitable channel binding facilities\
    \ are not provided,\n   application protocols MAY include a separate, protected\
    \ exchange of\n   channel bindings.  In order to do this, the application-layer\n\
    \   authentication service must provide message protection services (at\n   least\
    \ integrity protection).\n"
- title: 3.1.  The GSS-API and Channel Binding
  contents:
  - "3.1.  The GSS-API and Channel Binding\n   The GSS-API [RFC2743] provides for\
    \ the use of channel binding during\n   initialization of GSS-API security contexts,\
    \ though GSS-API\n   mechanisms are not required to support this facility.\n \
    \  This channel binding facility is described in [RFC2743] and\n   [RFC2744].\n\
    \   GSS-API mechanisms must fail security context establishment when\n   channel\
    \ binding fails, and the GSS-API provides no mechanism for the\n   negotiation\
    \ of channel binding.  As a result GSS-API applications\n   must agree a priori,\
    \ through negotiation or otherwise, on the use of\n   channel binding.\n   Fortunately,\
    \ it is possible to design GSS-API pseudo-mechanisms that\n   simply wrap around\
    \ existing mechanisms for the purpose of allowing\n   applications to negotiate\
    \ the use of channel binding within their\n   existing methods for negotiating\
    \ GSS-API mechanisms.  For example,\n   NFSv4 [RFC3530] provides its own GSS-API\
    \ mechanism negotiation, as\n   does the SSHv2 protocol [RFC4462].  Such pseudo-mechanisms\
    \ are being\n   proposed separately, see [STACKABLE].\n"
- title: 3.2.  SASL and Channel Binding
  contents:
  - "3.2.  SASL and Channel Binding\n   SASL [RFC4422] does not yet provide for the\
    \ use of channel binding\n   during initialization of SASL contexts.\n   Work\
    \ is ongoing [SASL-GS2] to specify how SASL, particularly its new\n   bridge to\
    \ the GSS-API, performs channel binding.  SASL will likely\n   differ from the\
    \ GSS-API in its handling of channel binding failure\n   (i.e., when there may\
    \ be an MITM) in that channel binding\n   success/failure will only affect the\
    \ negotiation of SASL security\n   layers.  That is, when channel binding succeeds,\
    \ SASL should select\n   no security layers, leaving session cryptographic protection\
    \ to the\n   secure channel that SASL authentication has been bound to.\n"
- title: 4.  Channel Bindings Specifications
  contents:
  - "4.  Channel Bindings Specifications\n   Channel bindings for various types of\
    \ secure channels are not\n   described herein.  Some channel bindings specifications\
    \ can be found\n   in:\n   +--------------------+----------------------------------------------+\n\
    \   | Secure Channel     | Reference                                    |\n  \
    \ | Type               |                                              |\n   +--------------------+----------------------------------------------+\n\
    \   | SSHv2              | [SSH-CB]                                     |\n  \
    \ |                    |                                              |\n   |\
    \ TLS                | [TLS-CB]                                     |\n   |  \
    \                  |                                              |\n   | IPsec\
    \              | There is no specification for IPsec channel  |\n   |        \
    \            | bindings yet, but the IETF Better Than       |\n   |          \
    \          | Nothing Security (BTNS) WG is working to     |\n   |            \
    \        | specify IPsec channels, and possibly IPsec   |\n   |              \
    \      | channel bindings.                            |\n   +--------------------+----------------------------------------------+\n"
- title: 4.1.  Examples of Unique Channel Bindings
  contents:
  - "4.1.  Examples of Unique Channel Bindings\n   The following text is not normative,\
    \ but is here to show how one\n   might construct channel bindings for various\
    \ types of secure\n   channels.\n   For SSHv2 [RFC4251] the SSHv2 session ID should\
    \ suffice as it is a\n   cryptographic binding of all relevant SSHv2 connection\
    \ parameters:\n   key exchange and negotiation.\n   The TLS [RFC4346] session\
    \ ID is simply assigned by the server.  As\n   such, the TLS session ID does not\
    \ have the required properties to be\n   useful as a channel binding because any\
    \ MITM, posing as the server,\n   can simply assign the same session ID to the\
    \ victim client as the\n   server assigned to the MITM.  Instead, the initial,\
    \ unencrypted TLS\n   finished messages (the client's, the server's, or both)\
    \ are\n   sufficient as they are the output of the TLS pseudo-random function,\n\
    \   keyed with the session key, applied to all handshake material.\n"
- title: 4.2.  Examples of End-Point Channel Bindings
  contents:
  - "4.2.  Examples of End-Point Channel Bindings\n   The following text is not normative,\
    \ but is here to show how one\n   might construct channel bindings for various\
    \ types of secure\n   channels.\n   For SSHv2 [RFC4251] the SSHv2 host public\
    \ key, when present, should\n   suffice as it is used to sign the algorithm suite\
    \ negotiation and\n   Diffie-Hellman key exchange; as long the client observes\
    \ the host\n   public key that corresponds to the private host key that the server\n\
    \   used, then there cannot be an MITM in the SSHv2 connection.  Note\n   that\
    \ not all SSHv2 key exchanges use host public keys; therefore,\n   this channel\
    \ bindings construction is not as useful as the one given\n   in Section 4.1.\n\
    \   For TLS [RFC4346]the server certificate should suffice for the same\n   reasons\
    \ as above.  Again, not all TLS cipher suites involve server\n   certificates;\
    \ therefore, the utility of this construction of channel\n   bindings is limited\
    \ to scenarios where server certificates are\n   commonly used.\n"
- title: 5.  Uses of Channel Binding
  contents:
  - "5.  Uses of Channel Binding\n   Uses for channel binding identified so far:\n\
    \   o  Delegating session cryptographic protection to layers where\n      hardware\
    \ can reasonably be expected to support relevant\n      cryptographic protocols:\n\
    \      *  NFSv4 [RFC3530] with Remote Direct Data Placement (RDDP)\n         [NFS-DDP]\
    \ for zero-copy reception where network interface\n         controllers (NICs)\
    \ support RDDP.  Cryptographic session\n         protection would be delegated\
    \ to Encapsulating Security Payload\n         (ESP) [RFC4303] / Authentication\
    \ Headers (AHs) [RFC4302].\n      *  iSCSI [RFC3720] with Remote Direct Memory\
    \ Access (RDMA)\n         [RFC5046].  Cryptographic session protection would be\
    \ delegated\n         to ESP/AH.\n      *  HTTP with TLS [RFC2817] [RFC2818].\
    \  In situations involving\n         proxies, users may want to bind authentication\
    \ to a TLS channel\n         between the last client-side proxy and the first\
    \ server-side\n         proxy (\"concentrator\").  There is ongoing work to expand\
    \ the\n         set of choices for end-to-end authentication at the HTTP layer,\n\
    \         that, coupled with channel binding to TLS, would allow for\n       \
    \  proxies while not forgoing protection over public internets.\n   o  Reducing\
    \ the number of live cryptographic contexts that an\n      application must maintain:\n\
    \      *  NFSv4 [RFC3530] multiplexes multiple users onto individual\n       \
    \  connections.  Each user is authenticated separately, and users'\n         remote\
    \ procedure calls (RPCs) are protected with per-user GSS-\n         API security\
    \ contexts.  This means that large timesharing\n         clients must often maintain\
    \ many cryptographic contexts per-\n         NFSv4 connection.  With channel binding\
    \ to IPsec, they could\n         maintain a much smaller number of cryptographic\
    \ contexts per-\n         NFSv4 connection, thus reducing memory pressure and\n\
    \         interactions with cryptographic hardware.\n   For example, applications\
    \ that wish to use RDDP to achieve zero-copy\n   semantics on reception may use\
    \ a network layer understood by NICs to\n   offload delivery of application data\
    \ into pre-arranged memory\n   buffers.  Note that in order to obtain zero-copy\
    \ reception semantics\n   either application data has to be in cleartext relative\
    \ to this RDDP\n   layer, or the RDDP implementation must know how to implement\n\
    \   cryptographic session protection protocols used at the application\n   layer.\n\
    \   There are a multitude of application-layer cryptographic session\n   protection\
    \ protocols available.  It is not reasonable to expect that\n   NICs should support\
    \ many such protocols.  Further, some application\n   protocols may maintain many\
    \ cryptographic session contexts per-\n   connection (for example, NFSv4 does).\
    \  It is thought to be simpler to\n   push the cryptographic session protection\
    \ down the network stack (to\n   IPsec), and yet be able to produce NICs that\
    \ offload other operations\n   (i.e., TCP/IP, ESP/AH, and DDP), than it would\
    \ be to add support in\n   the NIC for the many session cryptographic protection\
    \ protocols in\n   use in common applications at the application layer.\n   The\
    \ following figure shows how the various network layers are\n   related:\n   \
    \   +---------------------+\n      | Application layer   |<---+\n      |     \
    \                |<-+ |  In cleartext, relative\n      +---------------------+\
    \  | |  to each other.\n      | RDDP                |<---+\n      +---------------------+\
    \  |\n      | TCP/SCTP            |<-+\n      +---------------------+  | Channel\
    \ binding of app-layer\n      | ESP/AH              |<-+ authentication to IPsec\n\
    \      +---------------------+\n      | IP                  |\n      +---------------------+\n\
    \      | ...                 |\n      +---------------------+\n"
- title: 6.  Benefits of Channel Binding to Secure Channels
  contents:
  - "6.  Benefits of Channel Binding to Secure Channels\n   The use of channel binding\
    \ to delegate session cryptographic\n   protection include:\n   o  Performance\
    \ improvements by avoiding double protection of\n      application data in cases\
    \ where IPsec is in use and applications\n      provide their own secure channels.\n\
    \   o  Performance improvements by leveraging hardware-accelerated IPsec.\n  \
    \ o  Performance improvements by allowing RDDP hardware offloading to\n      be\
    \ integrated with IPsec hardware acceleration.\n         Where protocols layered\
    \ above RDDP use privacy protection, RDDP\n         offload cannot be done.  Thus,\
    \ by using channel binding to\n         IPsec, the privacy protection is moved\
    \ to IPsec, which is\n         layered below RDDP.  So, RDDP can address application\
    \ protocol\n         data that's in cleartext relative to the RDDP headers.\n\
    \   o  Latency improvements for applications that multiplex multiple\n      users\
    \ onto a single channel, such as NFS with RPCSEC_GSS\n      [RFC2203].\n   Delegation\
    \ of session cryptographic protection to IPsec requires\n   features not yet specified.\
    \  There is ongoing work to specify:\n   o  IPsec channels [CONN-LATCH];\n   o\
    \  Application programming interfaces (APIs) related to IPsec\n      channels\
    \ [BTNS-IPSEC];\n   o  Channel bindings for IPsec channels;\n   o  Low infrastructure\
    \ IPsec authentication [BTNS-CORE].\n"
- title: 7.  IANA Considerations
  contents:
  - "7.  IANA Considerations\n   IANA has created a new registry for channel bindings\
    \ specifications\n   for various types of channels.\n   The purpose of this registry\
    \ is not only to ensure uniqueness of\n   values used to name channel bindings,\
    \ but also to provide a\n   definitive reference to technical specifications detailing\
    \ each\n   channel binding available for use on the Internet.\n   There is no\
    \ naming convention for channel bindings: any string\n   composed of US-ASCII\
    \ alphanumeric characters, period ('.'), and dash\n   ('-') will suffice.\n  \
    \ The procedure detailed in Section 7.1 is to be used for registration\n   of\
    \ a value naming a specific individual mechanism.\n"
- title: 7.1.  Registration Procedure
  contents:
  - "7.1.  Registration Procedure\n   Registration of a new channel binding requires\
    \ expert review as\n   defined in BCP 26 [RFC2434].\n   Registration of a channel\
    \ binding is requested by filling in the\n   following template:\n   o  Subject:\
    \ Registration of channel binding X\n   o  Channel binding unique prefix (name):\n\
    \   o  Channel binding type: (One of \"unique\" or \"end-point\")\n   o  Channel\
    \ type: (e.g., TLS, IPsec, SSH, etc.)\n   o  Published specification (recommended,\
    \ optional):\n   o  Channel binding is secret (requires confidentiality protection):\n\
    \      yes/no\n   o  Description (optional if a specification is given; required\
    \ if no\n      published specification is specified):\n   o  Intended usage: (one\
    \ of COMMON, LIMITED USE, or OBSOLETE)\n   o  Person and email address to contact\
    \ for further information:\n   o  Owner/Change controller name and email address:\n\
    \   o  Expert reviewer name and contact information: (leave blank)\n   o  Note:\
    \ (Any other information that the author deems relevant may be\n      added here.)\n\
    \   and sending it via electronic mail to <channel-binding@ietf.org> (a\n   public\
    \ mailing list) and carbon copying IANA at <iana@iana.org>.\n   After allowing\
    \ two weeks for community input on the mailing list to\n   be determined, an expert\
    \ will determine the appropriateness of the\n   registration request and either\
    \ approve or disapprove the request\n   with notice to the requestor, the mailing\
    \ list, and IANA.\n   If the expert approves registration, it adds her/his name\
    \ to the\n   submitted registration.\n   The expert has the primary responsibility\
    \ of making sure that channel\n   bindings for IETF specifications go through\
    \ the IETF consensus\n   process and that prefixes are unique.\n   The review\
    \ should focus on the appropriateness of the requested\n   channel binding for\
    \ the proposed use, the appropriateness of the\n   proposed prefix, and correctness\
    \ of the channel binding type in the\n   registration.  The scope of this request\
    \ review may entail\n   consideration of relevant aspects of any provided technical\n\
    \   specification, such as their IANA Considerations section.  However,\n   this\
    \ review is narrowly focused on the appropriateness of the\n   requested registration\
    \ and not on the overall soundness of any\n   provided technical specification.\n\
    \   Authors are encouraged to pursue community review by posting the\n   technical\
    \ specification as an Internet-Draft and soliciting comment\n   by posting to\
    \ appropriate IETF mailing lists.\n"
- title: 7.2.  Comments on Channel Bindings Registrations
  contents:
  - "7.2.  Comments on Channel Bindings Registrations\n   Comments on registered channel\
    \ bindings should first be sent to the\n   \"owner\" of the channel bindings and\
    \ to the channel binding mailing\n   list.\n   Submitters of comments may, after\
    \ a reasonable attempt to contact the\n   owner, request IANA to attach their\
    \ comment to the channel binding\n   type registration itself by sending mail\
    \ to <iana@iana.org>.  At\n   IANA's sole discretion, IANA may attach the comment\
    \ to the channel\n   bindings registration.\n"
- title: 7.3.  Change Control
  contents:
  - "7.3.  Change Control\n   Once a channel bindings registration has been published\
    \ by IANA, the\n   author may request a change to its definition.  The change\
    \ request\n   follows the same procedure as the registration request.\n   The\
    \ owner of a channel bindings may pass responsibility for the\n   channel bindings\
    \ to another person or agency by informing IANA; this\n   can be done without\
    \ discussion or review.\n   The IESG may reassign responsibility for a channel\
    \ bindings\n   registration.  The most common case of this will be to enable changes\n\
    \   to be made to mechanisms where the author of the registration has\n   died,\
    \ has moved out of contact, or is otherwise unable to make\n   changes that are\
    \ important to the community.\n   Channel bindings registrations may not be deleted;\
    \ mechanisms that\n   are no longer believed appropriate for use can be declared\
    \ OBSOLETE\n   by a change to their \"intended usage\" field.  Such channel bindings\n\
    \   will be clearly marked in the lists published by IANA.\n   The IESG is considered\
    \ to be the owner of all channel bindings that\n   are on the IETF standards track.\n"
- title: 8.  Security Considerations
  contents:
  - "8.  Security Considerations\n   Security considerations appear throughout this\
    \ document.  In\n   particular see Section 2.1.\n   When delegating session protection\
    \ from one layer to another, one\n   will almost certainly be making some session\
    \ security trade-offs,\n   such as using weaker cipher modes in one layer than\
    \ might be used in\n   the other.  Evaluation and comparison of the relative cryptographic\n\
    \   strengths of these is difficult, may not be easily automated, and is\n   far\
    \ out of scope for this document.  Implementors and administrators\n   should\
    \ understand these trade-offs.  Interfaces to secure channels\n   and application-layer\
    \ authentication frameworks and mechanisms could\n   provide some notion of security\
    \ profile so that applications may\n   avoid delegation of session protection\
    \ to channels that are too weak\n   to match a required security profile.\n  \
    \ Channel binding makes \"anonymous\" channels (where neither end-point\n   is\
    \ strongly authenticated to the other) useful.  Implementors should\n   avoid\
    \ making it easy to use such channels without channel binding.\n   The security\
    \ of channel binding depends on the security of the\n   channels, the construction\
    \ of their channel bindings, and the\n   security of the authentication mechanism\
    \ used by the application and\n   its channel binding method.\n   Channel bindings\
    \ should be constructed in such a way that revealing\n   the channel bindings\
    \ of a channel to third parties does not weaken\n   the security of the channel.\
    \  However, for end-point channel bindings\n   disclosure of the channel bindings\
    \ may disclose the identities of the\n   peers.\n"
- title: 8.1.  Non-Unique Channel Bindings and Channel Binding Re-Establishment
  contents:
  - "8.1.  Non-Unique Channel Bindings and Channel Binding Re-Establishment\n   Application\
    \ developers may be tempted to use non-unique channel\n   bindings for fast re-authentication\
    \ following channel re-\n   establishment.  Care must be taken to avoid the possibility\
    \ of\n   attacks on multi-user systems.\n   Consider a user multiplexing protocol\
    \ like NFSv4 using channel\n   binding to IPsec on a multi-user client.  If another\
    \ user can connect\n   directly to port 2049 (NFS) on some server using IPsec\
    \ and merely\n   assert RPCSEC_GSS credential handles, then this user will be\
    \ able to\n   impersonate any user authenticated by the client to the server.\
    \  This\n   is because the new connection will have the same channel bindings\
    \ as\n   the NFS client's!  To prevent this, the server must require that at\n\
    \   least a host-based client principal, and perhaps all the client's\n   user\
    \ principals, re-authenticate and perform channel binding before\n   the server\
    \ will allow the clients to assert RPCSEC_GSS context\n   handles.  Alternatively,\
    \ the protocol could require a) that secure\n   channels provide confidentiality\
    \ protection and b) that fast re-\n   authentication cookies be difficult to guess\
    \ (e.g., large numbers\n   selected randomly).\n   In other contexts there may\
    \ not be such problems, for example, in the\n   case of application protocols\
    \ that don't multiplex users over a\n   single channel and where confidentiality\
    \ protection is always used in\n   the secure channel.\n"
- title: 9.  References
  contents:
  - '9.  References

    '
- title: 9.1.  Normative References
  contents:
  - "9.1.  Normative References\n   [RFC2119]    Bradner, S., \"Key words for use\
    \ in RFCs to Indicate\n                Requirement Levels\", BCP 14, RFC 2119,\
    \ March 1997.\n"
- title: 9.2.  Informative References
  contents:
  - "9.2.  Informative References\n   [BTNS-AS]    Touch, J., Black, D., and Y. Wang,\
    \ \"Problem and\n                Applicability Statement for Better Than Nothing\
    \ Security\n                (BTNS)\", Work in Progress, October 2007.\n   [BTNS-CORE]\
    \  Richardson, M. and N. Williams, \"Better-Than-Nothing-\n                Security:\
    \ An Unauthenticated Mode of IPsec\", Work in\n                Progress, September\
    \ 2007.\n   [BTNS-IPSEC] Richardson, M. and B. Sommerfeld, \"Requirements for\
    \ an\n                IPsec API\", Work in Progress, April 2006.\n   [CONN-LATCH]\
    \ Williams, N., \"IPsec Channels: Connection Latching\",\n                Work\
    \ in Progress, September 2007.\n   [Lampson91]  Lampson, B., Abadi, M., Burrows,\
    \ M., and E. Wobber,\n                \"Authentication in Distributed Systems:\
    \ Theory and\n                Practive\", October 1991.\n   [NFS-DDP]    Callaghan,\
    \ B. and T. Talpey, \"NFS Direct Data\n                Placement\", Work in Progress,\
    \ July 2007.\n   [RFC1964]    Linn, J., \"The Kerberos Version 5 GSS-API Mechanism\"\
    ,\n                RFC 1964, June 1996.\n   [RFC2203]    Eisler, M., Chiu, A.,\
    \ and L. Ling, \"RPCSEC_GSS Protocol\n                Specification\", RFC 2203,\
    \ September 1997.\n   [RFC2401]    Kent, S. and R. Atkinson, \"Security Architecture\
    \ for the\n                Internet Protocol\", RFC 2401, November 1998.\n   [RFC2434]\
    \    Narten, T. and H. Alvestrand, \"Guidelines for Writing an\n             \
    \   IANA Considerations Section in RFCs\", BCP 26, RFC 2434,\n               \
    \ October 1998.\n   [RFC2743]    Linn, J., \"Generic Security Service Application\
    \ Program\n                Interface Version 2, Update 1\", RFC 2743, January\
    \ 2000.\n   [RFC2744]    Wray, J., \"Generic Security Service API Version 2 :\n\
    \                C-bindings\", RFC 2744, January 2000.\n   [RFC2817]    Khare,\
    \ R. and S. Lawrence, \"Upgrading to TLS Within\n                HTTP/1.1\", RFC\
    \ 2817, May 2000.\n   [RFC2818]    Rescorla, E., \"HTTP Over TLS\", RFC 2818,\
    \ May 2000.\n   [RFC3530]    Shepler, S., Callaghan, B., Robinson, D., Thurlow,\
    \ R.,\n                Beame, C., Eisler, M., and D. Noveck, \"Network File\n\
    \                System (NFS) version 4 Protocol\", RFC 3530, April 2003.\n  \
    \ [RFC3720]    Satran, J., Meth, K., Sapuntzakis, C., Chadalapaka, M.,\n     \
    \           and E. Zeidner, \"Internet Small Computer Systems\n              \
    \  Interface (iSCSI)\", RFC 3720, April 2004.\n   [RFC3748]    Aboba, B., Blunk,\
    \ L., Vollbrecht, J., Carlson, J., and\n                H.  Levkowetz, \"Extensible\
    \ Authentication Protocol\n                (EAP)\", RFC 3748, June 2004.\n   [RFC4120]\
    \    Neuman, C., Yu, T., Hartman, S., and K. Raeburn, \"The\n                Kerberos\
    \ Network Authentication Service (V5)\", RFC 4120,\n                July 2005.\n\
    \   [RFC4251]    Ylonen, T. and C. Lonvick, \"The Secure Shell (SSH)\n       \
    \         Protocol Architecture\", RFC 4251, January 2006.\n   [RFC4301]    Kent,\
    \ S. and K. Seo, \"Security Architecture for the\n                Internet Protocol\"\
    , RFC 4301, December 2005.\n   [RFC4302]    Kent, S., \"IP Authentication Header\"\
    , RFC 4302, December\n                2005.\n   [RFC4303]    Kent, S., \"IP Encapsulating\
    \ Security Payload (ESP)\", RFC\n                4303, December 2005.\n   [RFC4346]\
    \    Dierks, T. and E. Rescorla, \"The Transport Layer\n                Security\
    \ (TLS) Protocol Version 1.1\", RFC 4346, April\n                2006.\n   [RFC4422]\
    \    Melnikov, A. and K. Zeilenga, \"Simple Authentication and\n             \
    \   Security Layer (SASL)\", RFC 4422, June 2006.\n   [RFC4462]    Hutzelman,\
    \ J., Salowey, J., Galbraith, J., and V. Welch,\n                \"Generic Security\
    \ Service Application Program Interface\n                (GSS-API) Authentication\
    \ and Key Exchange for the Secure\n                Shell (SSH) Protocol\", RFC\
    \ 4462, May 2006.\n   [RFC5046]    Ko, M., Chadalapaka, M., Hufferd, J., Elzur,\
    \ U., Shah,\n                H., and P. Thaler, \"Internet Small Computer System\n\
    \                Interface (iSCSI) Extensions for Remote Direct Memory\n     \
    \           Access (RDMA)\", RFC 5046, October 2007.\n   [SASL-GS2]   Josefsson,\
    \ S., \"Using GSS-API Mechanisms in SASL: The\n                GS2 Mechanism Family\"\
    , Work in Progress, October 2007.\n   [SSH-CB]     Williams, N., \"Channel Binding\
    \ Identifiers for Secure\n                Shell Channels\", Work in Progress,\
    \ November 2007.\n   [STACKABLE]  Williams, N., \"Stackable Generic Security Service\n\
    \                Pseudo-Mechanisms\", Work in Progress, June 2006.\n   [TLS-CB]\
    \     Altman, J. and N. Williams, \"Unique Channel Bindings for\n            \
    \    TLS\", Work in Progress, November 2007.\n"
- title: Appendix A.  Acknowledgments
  contents:
  - "Appendix A.  Acknowledgments\n   Thanks to Mike Eisler for his work on the Channel\
    \ Conjunction\n   Mechanism document and for bringing the problem to a head, Sam\n\
    \   Hartman for pointing out that channel binding provides a general\n   solution\
    \ to the channel binding problem, and Jeff Altman for his\n   suggestion of using\
    \ the TLS finished messages as the TLS channel\n   bindings.  Also, thanks to\
    \ Bill Sommerfeld, Radia Perlman, Simon\n   Josefsson, Joe Salowey, Eric Rescorla,\
    \ Michael Richardson, Bernard\n   Aboba, Tom Petch, Mark Brown, and many others.\n"
- title: Author's Address
  contents:
  - "Author's Address\n   Nicolas Williams\n   Sun Microsystems\n   5300 Riata Trace\
    \ Ct.\n   Austin, TX  78727\n   US\n   EMail: Nicolas.Williams@sun.com\n"
- title: Full Copyright Statement
  contents:
  - "Full Copyright Statement\n   Copyright (C) The IETF Trust (2007).\n   This document\
    \ is subject to the rights, licenses and restrictions\n   contained in BCP 78,\
    \ and except as set forth therein, the authors\n   retain all their rights.\n\
    \   This document and the information contained herein are provided on an\n  \
    \ \"AS IS\" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS\n  \
    \ OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY, THE IETF TRUST AND\n   THE\
    \ INTERNET ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS\n   OR IMPLIED,\
    \ INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF\n   THE INFORMATION\
    \ HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED\n   WARRANTIES OF MERCHANTABILITY\
    \ OR FITNESS FOR A PARTICULAR PURPOSE.\n"
- title: Intellectual Property
  contents:
  - "Intellectual Property\n   The IETF takes no position regarding the validity or\
    \ scope of any\n   Intellectual Property Rights or other rights that might be\
    \ claimed to\n   pertain to the implementation or use of the technology described\
    \ in\n   this document or the extent to which any license under such rights\n\
    \   might or might not be available; nor does it represent that it has\n   made\
    \ any independent effort to identify any such rights.  Information\n   on the\
    \ procedures with respect to rights in RFC documents can be\n   found in BCP 78\
    \ and BCP 79.\n   Copies of IPR disclosures made to the IETF Secretariat and any\n\
    \   assurances of licenses to be made available, or the result of an\n   attempt\
    \ made to obtain a general license or permission for the use of\n   such proprietary\
    \ rights by implementers or users of this\n   specification can be obtained from\
    \ the IETF on-line IPR repository at\n   http://www.ietf.org/ipr.\n   The IETF\
    \ invites any interested party to bring to its attention any\n   copyrights, patents\
    \ or patent applications, or other proprietary\n   rights that may cover technology\
    \ that may be required to implement\n   this standard.  Please address the information\
    \ to the IETF at\n   ietf-ipr@ietf.org.\n"
