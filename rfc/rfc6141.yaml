- title: __initial_text__
  contents:
  - "             Re-INVITE and Target-Refresh Request Handling\n                in\
    \ the Session Initiation Protocol (SIP)\n"
- title: Abstract
  contents:
  - "Abstract\n   The procedures for handling SIP re-INVITEs are described in RFC\
    \ 3261.\n   Implementation and deployment experience has uncovered a number of\n\
    \   issues with the original documentation, and this document provides\n   additional\
    \ procedures that update the original specification to\n   address those issues.\
    \  In particular, this document defines in which\n   situations a UAS (User Agent\
    \ Server) should generate a success\n   response and in which situations a UAS\
    \ should generate an error\n   response to a re-INVITE.  Additionally, this document\
    \ defines further\n   details of procedures related to target-refresh requests.\n"
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This is an Internet Standards Track document.\n   This\
    \ document is a product of the Internet Engineering Task Force\n   (IETF).  It\
    \ represents the consensus of the IETF community.  It has\n   received public\
    \ review and has been approved for publication by the\n   Internet Engineering\
    \ Steering Group (IESG).  Further information on\n   Internet Standards is available\
    \ in Section 2 of RFC 5741.\n   Information about the current status of this document,\
    \ any errata,\n   and how to provide feedback on it may be obtained at\n   http://www.rfc-editor.org/info/rfc6141.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (c) 2011 IETF Trust and the persons identified\
    \ as the\n   document authors.  All rights reserved.\n   This document is subject\
    \ to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n\
    \   (http://trustee.ietf.org/license-info) in effect on the date of\n   publication\
    \ of this document.  Please review these documents\n   carefully, as they describe\
    \ your rights and restrictions with respect\n   to this document.  Code Components\
    \ extracted from this document must\n   include Simplified BSD License text as\
    \ described in Section 4.e of\n   the Trust Legal Provisions and are provided\
    \ without warranty as\n   described in the Simplified BSD License.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1. Introduction ....................................................3\n\
    \   2. Terminology .....................................................4\n  \
    \ 3. Changing the Session State during a Re-INVITE ...................5\n    \
    \  3.1. Background on Re-INVITE Handling by UASs ...................5\n      3.2.\
    \ Problems with Error Responses and Already Executed Changes .9\n      3.3. UAS\
    \ Behavior ..............................................10\n      3.4. UAC Behavior\
    \ ..............................................11\n      3.5. Glare Situations\
    \ ..........................................11\n      3.6. Example of UAS Behavior\
    \ ...................................12\n      3.7. Example of UAC Behavior ...................................14\n\
    \      3.8. Clarifications on Canceling Re-INVITEs ....................17\n  \
    \ 4. Refreshing a Dialog's Targets ..................................17\n    \
    \  4.1. Background and Terminology on a Dialog's Targets ..........17\n      4.2.\
    \ Background on Target-Refresh Requests .....................17\n      4.3. Clarification\
    \ on the Atomicity of Target-Refresh Requests .18\n      4.4. UA Updating the\
    \ Dialog's Local Target in a Request ........19\n      4.5. UA Updating the Dialog's\
    \ Local Target in a Response .......19\n      4.6. A Request Updating the Dialog's\
    \ Remote Target .............19\n      4.7. A Response Updating the Dialog's Remote\
    \ Target ............20\n      4.8. Race Conditions and Target Refreshes ......................20\n\
    \      4.9. Early Dialogs .............................................21\n  \
    \ 5. A UA Losing Its Contact ........................................21\n    \
    \  5.1. Background on Re-INVITE Transaction Routing ...............22\n      5.2.\
    \ Problems with UAs Losing Their Contact ....................22\n      5.3. UAS\
    \ Losing Its Contact: UAC Behavior ......................22\n      5.4. UAC Losing\
    \ Its Contact: UAS Behavior ......................23\n      5.5. UAC Losing Its\
    \ Contact: UAC Behavior ......................24\n   6. Security Considerations\
    \ ........................................24\n   7. Acknowledgements ...............................................24\n\
    \   8. References .....................................................25\n  \
    \    8.1. Normative References ......................................25\n    \
    \  8.2. Informative References ....................................25\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   As discussed in Section 14 of RFC 3261 [RFC3261], an INVITE\
    \ request\n   sent within an existing dialog is known as a re-INVITE.  A re-INVITE\n\
    \   is used to modify session parameters, dialog parameters, or both.\n   That\
    \ is, a single re-INVITE can change both the parameters of its\n   associated\
    \ session (e.g., changing the IP address where a media\n   stream is received)\
    \ and the parameters of its associated dialog\n   (e.g., changing the remote target\
    \ of the dialog).  A re-INVITE can\n   change the remote target of a dialog because\
    \ it is a target refresh\n   request, as defined in Section 6 of RFC 3261 [RFC3261].\n\
    \   A re-INVITE transaction has an offer/answer [RFC3264] exchange\n   associated\
    \ with it.  The UAC (User Agent Client) generating a given\n   re-INVITE can act\
    \ as the offerer or as the answerer.  A UAC willing\n   to act as the offerer\
    \ includes an offer in the re-INVITE.  The UAS\n   (User Agent Server) then provides\
    \ an answer in a response to the\n   re-INVITE.  A UAC willing to act as answerer\
    \ does not include an\n   offer in the re-INVITE.  The UAS then provides an offer\
    \ in a response\n   to the re-INVITE becoming, thus, the offerer.\n   Certain\
    \ transactions within a re-INVITE (e.g., UPDATE [RFC3311]\n   transactions) can\
    \ also have offer/answer exchanges associated to\n   them.  A UA (User Agent)\
    \ can act as the offerer or the answerer in\n   any of these transactions regardless\
    \ of whether the UA was the\n   offerer or the answerer in the umbrella re-INVITE\
    \ transaction.\n   There has been some confusion among implementors regarding\
    \ how a UAS\n   should handle re-INVITEs.  In particular, implementors requested\n\
    \   clarification on which type of response a UAS should generate in\n   different\
    \ situations.  In this document, we clarify these issues.\n   Additionally, there\
    \ has also been some confusion among implementors\n   regarding target refresh\
    \ requests, which include but are not limited\n   to re-INVITEs.  In this document,\
    \ we also clarify the process by\n   which remote targets are refreshed.\n   \
    \   Indented passages such as this one are used in this document to\n      provide\
    \ additional information and clarifying text.  They do not\n      contain normative\
    \ protocol behavior.\n"
- title: 2.  Terminology
  contents:
  - "2.  Terminology\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\"\
    , \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and\
    \ \"OPTIONAL\" in this\n   document are to be interpreted as described in RFC\
    \ 2119 [RFC2119].\n   UA: User Agent.\n   UAC: User Agent Client.\n   UAS: User\
    \ Agent Server.\n      Note that the terms UAC and UAS are used with respect to\
    \ an INVITE\n      or re-INVITE transaction and do not necessarily reflect the\
    \ role\n      of the UA concerned with respect to any other transaction, such\
    \ as\n      an UPDATE transaction occurring within the INVITE transaction.\n"
- title: 3.  Changing the Session State during a Re-INVITE
  contents:
  - "3.  Changing the Session State during a Re-INVITE\n   The following sub-sections\
    \ discuss how to change the state of the\n   session during a re-INVITE transaction.\n"
- title: 3.1.  Background on Re-INVITE Handling by UASs
  contents:
  - "3.1.  Background on Re-INVITE Handling by UASs\n   Eventually, a UAS receiving\
    \ a re-INVITE will need to generate a\n   response to it.  Some re-INVITEs can\
    \ be responded to immediately\n   because their handling does not require user\
    \ interaction (e.g.,\n   changing the IP address where a media stream is received).\
    \  The\n   handling of other re-INVITEs requires user interaction (e.g., adding\n\
    \   a video stream to an audio-only session).  Therefore, these\n   re-INVITEs\
    \ cannot be responded to immediately.\n   An error response to a re-INVITE has\
    \ the following semantics.  As\n   specified in Section 12.2.2 of RFC 3261 [RFC3261],\
    \ if a re-INVITE is\n   rejected, no state changes are performed.  These state\
    \ changes\n   include state changes associated to the re-INVITE transaction and\
    \ all\n   other transactions within the re-INVITE (this section deals with\n \
    \  changes to the session state; target refreshes are discussed in\n   Section\
    \ 4.2).  That is, the session state is the same as before the\n   re-INVITE was\
    \ received.  The example in Figure 1 illustrates this\n   point.\n           \
    \      UAC                                          UAS\n                  | \
    \                                           |\n                  |-------------(1)\
    \ INVITE SDP1--------------->|\n                  |                          \
    \                  |\n                  |<------------(2) 200 OK SDP2----------------|\n\
    \                  |                                            |\n          \
    \        |------------------(3) ACK------------------>|\n                  | \
    \                                           |\n                  |           \
    \                                 |\n                  |-------------(4) INVITE\
    \ SDP3--------------->|\n                  |                                 \
    \           |\n                  |<-----------------(5) 4xx-------------------|\n\
    \                  |                                            |\n          \
    \        |------------------(6) ACK------------------>|\n                  | \
    \                                           |\n                    Figure 1: Rejection\
    \ of a re-INVITE\n   The UAs perform an offer/answer exchange to establish an\
    \ audio-only\n   session:\n         SDP1:\n            m=audio 30000 RTP/AVP 0\n\
    \         SDP2:\n            m=audio 31000 RTP/AVP 0\n   At a later point, the\
    \ UAC sends a re-INVITE (4) in order to add a\n   video stream to the session.\n\
    \         SDP3:\n            m=audio 30000 RTP/AVP 0\n            m=video 30002\
    \ RTP/AVP 31\n   The UAS is configured to automatically reject video streams.\n\
    \   Consequently, the UAS returns an error response (5).  At that point,\n   the\
    \ session parameters in use are still those resulting from the\n   initial offer/answer\
    \ exchange, which are described by SDP1 and SDP2.\n   That is, the session state\
    \ is the same as before the re-INVITE was\n   received.\n   In the previous example,\
    \ the UAS rejected all the changes requested\n   in the re-INVITE by returning\
    \ an error response.  However, there are\n   situations where a UAS wants to accept\
    \ some but not all the changes\n   requested in a re-INVITE.  In these cases,\
    \ the UAS generates a 200\n   (OK) response with a Session Description Protocol\
    \ (SDP) indicating\n   which changes were accepted and which were not.  The example\
    \ in\n   Figure 2 illustrates this point.\n                 UAC              \
    \                            UAS\n                  |                        \
    \                    |\n                  |-------------(1) INVITE SDP1--------------->|\n\
    \                  |                                            |\n          \
    \        |<------------(2) 200 OK SDP2----------------|\n                  | \
    \                                           |\n                  |------------------(3)\
    \ ACK------------------>|\n                  |                               \
    \             |\n                  |                                         \
    \   |\n                  |-------------(4) INVITE SDP3--------------->|\n    \
    \              |                                            |\n              \
    \    |<------------(5) 200 OK SDP4----------------|\n                  |     \
    \                                       |\n                  |------------------(6)\
    \ ACK------------------>|\n                  |                               \
    \             |\n              Figure 2: Automatic rejection of a video stream\n\
    \   The UAs perform an offer/answer exchange to establish an audio-only\n   session:\n\
    \         SDP1:\n            m=audio 30000 RTP/AVP 0\n            c=IN IP4 192.0.2.1\n\
    \         SDP2:\n            m=audio 31000 RTP/AVP 0\n            c=IN IP4 192.0.2.5\n\
    \   At a later point, the UAC moves to an access that provides a higher\n   bandwidth.\
    \  Therefore, the UAC sends a re-INVITE (4) in order to\n   change the IP address\
    \ where it receives the audio stream to its new\n   IP address and add a video\
    \ stream to the session.\n         SDP3:\n            m=audio 30000 RTP/AVP 0\n\
    \            c=IN IP4 192.0.2.2\n            m=video 30002 RTP/AVP 31\n      \
    \      c=IN IP4 192.0.2.2\n   The UAS is automatically configured to reject video\
    \ streams.\n   However, the UAS needs to accept the change of the audio stream's\n\
    \   remote IP address.  Consequently, the UAS returns a 200 (OK) response\n  \
    \ and sets the port of the video stream to zero in its SDP.\n         SDP4:\n\
    \            m=audio 31000 RTP/AVP 0\n            c=IN IP4 192.0.2.5\n       \
    \     m=video 0 RTP/AVP 31\n   In the previous example, the UAS was configured\
    \ to automatically\n   reject the addition of video streams.  The example in Figure\
    \ 3\n   assumes that the UAS requires its user's input in order to accept or\n\
    \   reject the addition of a video stream and uses reliable provisional\n   responses\
    \ [RFC3262] (PRACK transactions are not shown for clarity).\n                \
    \ UAC                                          UAS\n                  |      \
    \                                      |\n                  |-------------(1)\
    \ INVITE SDP1--------------->|\n                  |                          \
    \                  |\n                  |<------------(2) 200 OK SDP2----------------|\n\
    \                  |                                            |\n          \
    \        |------------------(3) ACK------------------>|\n                  | \
    \                                           |\n                  |           \
    \                                 |\n                  |-------------(4) INVITE\
    \ SDP3--------------->|\n                  |                                 \
    \           |\n                  |<----(5) 183 Session Progress SDP4----------|\n\
    \                  |                                            |\n          \
    \        |                                            |\n                  |<------------(6)\
    \ UPDATE SDP5----------------|\n                  |                          \
    \                  |\n                  |-------------(7) 200 OK SDP6--------------->|\n\
    \                  |                                            |\n          \
    \        |<---------------(8) 200 OK------------------|\n                  | \
    \                                           |\n                  |------------------(9)\
    \ ACK------------------>|\n                  |                               \
    \             |\n         Figure 3: Manual rejection of a video stream by the\
    \ user\n   Everything up to (4) is identical to the previous example.  In (5),\n\
    \   the UAS accepts the change of the audio stream's remote IP address\n   but\
    \ does not accept the video stream yet (it provides a null IP\n   address instead\
    \ of setting the stream to 'inactive' because inactive\n   streams still need\
    \ to exchange RTP Control Protocol (RTCP) traffic).\n         SDP4:\n        \
    \    m=audio 31000 RTP/AVP 0\n            c=IN IP4 192.0.2.5\n            m=video\
    \ 31002 RTP/AVP 31\n            c=IN IP4 0.0.0.0\n   At a later point, the UAS's\
    \ user rejects the addition of the video\n   stream.  Consequently, the UAS sends\
    \ an UPDATE request (6) setting\n   the port of the video stream to zero in its\
    \ offer.\n         SDP5:\n            m=audio 31000 RTP/AVP 0\n            c=IN\
    \ IP4 192.0.2.5\n            m=video 0 RTP/AVP 31\n            c=IN IP4 0.0.0.0\n\
    \   The UAC returns a 200 (OK) response (7) to the UPDATE with the\n   following\
    \ answer:\n         SDP6:\n            m=audio 30000 RTP/AVP 0\n            c=IN\
    \ IP4 192.0.2.2\n            m=video 0 RTP/AVP 31\n   The UAS now returns a 200\
    \ (OK) response (8) to the re-INVITE.\n   In all the previous examples, the UAC\
    \ of the re-INVITE transaction\n   was the offerer.  Examples with UACs acting\
    \ as the answerers would be\n   similar.\n"
- title: 3.2.  Problems with Error Responses and Already Executed Changes
  contents:
  - "3.2.  Problems with Error Responses and Already Executed Changes\n   Section\
    \ 3.1 contains examples on how a UAS rejects all the changes\n   requested in\
    \ a re-INVITE without executing any of them by returning\n   an error response\
    \ (Figure 1), and how a UAS executes some of the\n   changes requested in a re-INVITE\
    \ and rejects some of them by\n   returning a 2xx response (Figures 2 and 3).\
    \  A UAS can accept and\n   reject different sets of changes simultaneously (Figure\
    \ 2) or at\n   different times (Figure 3).\n   The scenario that created confusion\
    \ among implementors consists of a\n   UAS that receives a re-INVITE, executes\
    \ some of the changes requested\n   in it, and then wants to reject all those\
    \ already executed changes\n   and revert to the pre-re-INVITE state.  Such a\
    \ UAS may consider\n   returning an error response to the re-INVITE (the message\
    \ flow would\n   be similar to the one in Figure 1), or using an UPDATE request\
    \ to\n   revert to the pre-re-INVITE state and then returning a 2xx response\n\
    \   to the re-INVITE (the message flow would be similar to the one in\n   Figure\
    \ 3).  This section explains the problems associated with\n   returning an error\
    \ response in these circumstances.  In order to\n   avoid these problems, the\
    \ UAS should use the latter option (UPDATE\n   request plus a 2xx response). \
    \ Sections 3.3 and 3.4 contain the\n   normative statements needed to avoid these\
    \ problems.\n   The reason for not using an error response to undo already executed\n\
    \   changes is that an error response to a re-INVITE for which changes\n   have\
    \ already been executed (e.g., as a result of UPDATE transactions\n   or reliable\
    \ provisional responses) is effectively requesting a change\n   in the session\
    \ state.  However, the UAC has no means to reject that\n   change if it is unable\
    \ to execute them.  That is, if the UAC is\n   unable to revert to the pre-re-INVITE\
    \ state, it will not be able to\n   communicate this fact to the UAS.\n"
- title: 3.3.  UAS Behavior
  contents:
  - "3.3.  UAS Behavior\n   UASs should only return an error response to a re-INVITE\
    \ if no\n   changes to the session state have been executed since the re-INVITE\n\
    \   was received.  Such an error response indicates that no changes have\n   been\
    \ executed as a result of the re-INVITE or any other transaction\n   within it.\n\
    \   If any of the changes requested in a re-INVITE or in any transaction\n   within\
    \ it have already been executed, the UAS SHOULD return a 2xx\n   response.\n \
    \  A change to the session state is considered to have been executed if\n   an\
    \ offer/answer without preconditions [RFC4032] for the stream has\n   completed\
    \ successfully or the UA has sent or received media using the\n   new parameters.\
    \  Connection establishment messages (e.g., TCP SYN),\n   connectivity checks\
    \ (e.g., when using Interactive Connectivity\n   Establishment (ICE) [RFC5245]),\
    \ and any other messages used in the\n   process of meeting the preconditions\
    \ for a stream are not considered\n   media.\n      Normally, a UA receiving media\
    \ can easily detect when the new\n      parameters for the media stream are used\
    \ (e.g., media is received\n      on a new port).  However, in some scenarios,\
    \ the UA will have to\n      process incoming media packets in order to detect\
    \ whether they use\n      the old or new parameters.\n   The successful completion\
    \ of an offer/answer exchange without\n   preconditions indicates that the new\
    \ parameters for the media stream\n   are already considered to be in use.  The\
    \ successful completion of an\n   offer/answer exchange with preconditions means\
    \ something different.\n   The fact that all mandatory preconditions for the stream\
    \ are met\n   indicates that the new parameters for the media stream are ready\
    \ to\n   be used.  However, they will not actually be used until the UAS\n   decides\
    \ to use them.  During a session establishment, the UAS can\n   wait before using\
    \ the media parameters until the callee starts being\n   alerted or until the\
    \ callee accepts the session.  During a session\n   modification, the UAS can\
    \ wait until its user accepts the changes to\n   the session.  When dealing with\
    \ streams where the UAS sends media\n   more or less continuously, the UAC notices\
    \ that the new parameters\n   are in use because the UAC receives media that uses\
    \ the new\n   parameters.  However, this mechanism does not work with other types\n\
    \   of streams.  Therefore, it is RECOMMENDED that when a UAS decides to\n   start\
    \ using the new parameters for a stream for which all mandatory\n   preconditions\
    \ have been met, the UAS either sends media using the new\n   parameters or sends\
    \ a new offer where the precondition-related\n   attributes for the stream have\
    \ been removed.  As indicated above, the\n   successful completion of an offer/answer\
    \ exchange without\n   preconditions indicates that the new parameters for the\
    \ media stream\n   are already considered to be in use.\n"
- title: 3.4.  UAC Behavior
  contents:
  - "3.4.  UAC Behavior\n   A UAC that receives an error response to a re-INVITE that\
    \ undoes\n   already executed changes within the re-INVITE may be facing a legacy\n\
    \   UAS that does not support this specification (i.e., a UAS that does\n   not\
    \ follow the guidelines in Section 3.3).  There are also certain\n   race condition\
    \ situations that get both user agents out of\n   synchronization.  In order to\
    \ cope with these race condition\n   situations, a UAC that receives an error\
    \ response to a re-INVITE for\n   which changes have been already executed SHOULD\
    \ generate a new\n   re-INVITE or UPDATE request in order to make sure that both\
    \ UAs have\n   a common view of the state of the session (the UAC uses the criteria\n\
    \   in Section 3.3 in order to decide whether or not changes have been\n   executed\
    \ for a particular stream).  The purpose of this new offer/\n   answer exchange\
    \ is to synchronize both UAs, not to request changes\n   that the UAS may choose\
    \ to reject.  Therefore, session parameters in\n   the offer/answer exchange SHOULD\
    \ be as close to those in the\n   pre-re-INVITE state as possible.\n"
- title: 3.5.  Glare Situations
  contents:
  - "3.5.  Glare Situations\n   Section 4 of RFC 3264 [RFC3264] defines glare conditions\
    \ as a user\n   agent receiving an offer after having sent one but before having\n\
    \   received an answer to it.  That section specifies rules to avoid\n   glare\
    \ situations in most cases.  When, despite following those rules,\n   a glare\
    \ condition occurs (as a result of a race condition), it is\n   handled as specified\
    \ in Sections 14.1 and 14.2 of RFC 3261 [RFC3261].\n   The UAS returns a 491 (Request\
    \ Pending) response and the UAC retries\n   the offer after a randomly selected\
    \ time, which depends on which user\n   agent is the owner of the Call-ID of the\
    \ dialog.  The rules in RFC\n   3261 [RFC3261] not only cover collisions between\
    \ re-INVITEs that\n   contain offers, they cover collisions between two re-INVITEs\
    \ in\n   general, even if they do not contain offers.  Sections 5.2 and 5.3 of\n\
    \   RFC 3311 [RFC3311] extend those rules to also cover collisions\n   between\
    \ an UPDATE request carrying an offer and another message\n   (UPDATE, PRACK,\
    \ or INVITE) also carrying an offer.\n   The rules in RFC 3261 [RFC3261] do not\
    \ cover collisions between an\n   UPDATE request and a non-2xx final response\
    \ to a re-INVITE.  Since\n   both the UPDATE request and the reliable response\
    \ could be requesting\n   changes to the session state, it would not be clear\
    \ which changes\n   would need to be executed first.  However, the procedures\
    \ discussed\n   in Section 3.4 already cover this type of situation.  Therefore,\n\
    \   there is no need to specify further rules here.\n"
- title: 3.6.  Example of UAS Behavior
  contents:
  - "3.6.  Example of UAS Behavior\n   This section contains an example of a UAS that\
    \ implements this\n   specification using an UPDATE request and a 2xx response\
    \ to a\n   re-INVITE in order to revert to the pre-re-INVITE state.  The example\n\
    \   shown in Figure 4 assumes that the UAS requires its user's input in\n   order\
    \ to accept or reject the addition of a video stream and uses\n   reliable provisional\
    \ responses [RFC3262] (PRACK transactions are not\n   shown for clarity).\n  \
    \               UAC                                          UAS\n           \
    \       |                                            |\n                  |-------------(1)\
    \ INVITE SDP1--------------->|\n                  |                          \
    \                  |\n                  |<------------(2) 200 OK SDP2----------------|\n\
    \                  |                                            |\n          \
    \        |------------------(3) ACK------------------>|\n                  | \
    \                                           |\n                  |           \
    \                                 |\n                  |-------------(4) INVITE\
    \ SDP3--------------->|\n                  |                                 \
    \           |\n                  |<----(5) 183 Session Progress SDP4----------|\n\
    \                  |                                            |\n          \
    \        |-------------(6) UPDATE SDP5--------------->|\n                  | \
    \                                           |\n                  |<------------(7)\
    \ 200 OK SDP6----------------|\n                  |                          \
    \                  |\n                  |                                    \
    \        |\n                  |<------------(8) UPDATE SDP7----------------|\n\
    \                  |                                            |\n          \
    \        |-------------(9) 200 OK SDP8--------------->|\n                  | \
    \                                           |\n                  |<--------------(10)\
    \ 200 OK------------------|\n                  |                             \
    \               |\n                  |-----------------(11) ACK------------------>|\n\
    \                  |                                            |\n          \
    \   Figure 4: Rejection of a video stream by the user\n   The UAs perform an offer/answer\
    \ exchange to establish an audio-only\n   session:\n         SDP1:\n         \
    \   m=audio 30000 RTP/AVP 0\n            c=IN IP4 192.0.2.1\n         SDP2:\n\
    \            m=audio 31000 RTP/AVP 0\n            c=IN IP4 192.0.2.5\n   At a\
    \ later point, the UAC sends a re-INVITE (4) in order to add a new\n   codec to\
    \ the audio stream and to add a video stream to the session.\n         SDP3:\n\
    \            m=audio 30000 RTP/AVP 0 3\n            c=IN IP4 192.0.2.1\n     \
    \       m=video 30002 RTP/AVP 31\n            c=IN IP4 192.0.2.1\n   In (5), the\
    \ UAS accepts the addition of the audio codec but does not\n   accept the video\
    \ stream yet (it provides a null IP address instead of\n   setting the stream\
    \ to 'inactive' because inactive streams still need\n   to exchange RTCP traffic).\n\
    \         SDP4:\n            m=audio 31000 RTP/AVP 0 3\n            c=IN IP4 192.0.2.5\n\
    \            m=video 31002 RTP/AVP 31\n            c=IN IP4 0.0.0.0\n   At a later\
    \ point, the UAC sends an UPDATE request (6) to remove the\n   original audio\
    \ codec from the audio stream (the UAC could have also\n   used the PRACK to (5)\
    \ to request this change).\n         SDP5:\n            m=audio 30000 RTP/AVP\
    \ 3\n            c=IN IP4 192.0.2.1\n            m=video 30002 RTP/AVP 31\n  \
    \          c=IN IP4 192.0.2.1\n         SDP6:\n            m=audio 31000 RTP/AVP\
    \ 3\n            c=IN IP4 192.0.2.5\n            m=video 31002 RTP/AVP 31\n  \
    \          c=IN IP4 0.0.0.0\n   Yet, at a later point, the UAS's user rejects\
    \ the addition of the\n   video stream.  Additionally, the UAS decides to revert\
    \ to the\n   original audio codec.  Consequently, the UAS sends an UPDATE request\n\
    \   (8) setting the port of the video stream to zero and offering the\n   original\
    \ audio codec in its SDP.\n         SDP7:\n            m=audio 31000 RTP/AVP 0\n\
    \            c=IN IP4 192.0.2.5\n            m=video 0 RTP/AVP 31\n          \
    \  c=IN IP4 0.0.0.0\n   The UAC accepts the change in the audio codec in its 200\
    \ (OK)\n   response (9) to the UPDATE request.\n         SDP8:\n            m=audio\
    \ 30000 RTP/AVP 0\n            c=IN IP4 192.0.2.1\n            m=video 0 RTP/AVP\
    \ 31\n            c=IN IP4 192.0.2.1\n   The UAS now returns a 200 (OK) response\
    \ (10) to the re-INVITE.  Note\n   that the media state after this 200 (OK) response\
    \ is the same as the\n   pre-re-INVITE media state.\n"
- title: 3.7.  Example of UAC Behavior
  contents:
  - "3.7.  Example of UAC Behavior\n   Figure 5 shows an example of a race condition\
    \ situation in which the\n   UAs end up with different views of the state of the\
    \ session.\n  a:sendrecv                                                  a:sendrecv\n\
    \  v:inactive                                                  v:inactive\n  \
    \           UA1                   Proxy                   UA2\n              |\
    \                      |                      |\n              |----(1) INVITE\
    \ SDP1-->|                      |\n              |                      |----(2)\
    \ INVITE SDP1-->|\n              |                      |                    \
    \  |\n              |                      |<----(3) 183 SDP2-----| a:sendrecv\n\
    \  a:sendrecv  |<----(4) 183 SDP2-----|                      | v:recvonly\n  v:sendonly\
    \  |                      |                      |\n              |          \
    \            |<------(5) 4xx -------|\n              |                      |-------(6)\
    \ ACK ------>| a:sendrecv\n              |           +-(7) 4xx -|            \
    \          | v:inactive\n              |           |          |<---(8) UPDATE\
    \ SDP3---|\n              |<---(9) UPDATE SDP3---|                      |\n  \
    \            |           |          |                      |\n  a:sendonly  |---(10)\
    \ 200 OK SDP4-->|                      |\n  v:inactive  |           |        \
    \  |---(11) 200 OK SDP4-->| a:recvonly\n              |<-(7) 4xx -+          |\
    \                      | v:inactive\n  a:sendrecv  |------(12) ACK ------>|  \
    \                    |\n  v:inactive  |                      |               \
    \       |\n                       a: status of the audio stream\n            \
    \           v: status of the video stream\n                Figure 5: Message flow\
    \ with race condition\n   The UAs in Figure 5 are involved in a session that,\
    \ just before the\n   message flows in the figures starts, includes a sendrecv\
    \ audio stream\n   and an inactive video stream.  UA1 sends a re-INVITE (1) requesting\n\
    \   to make the video stream sendrecv.\n         SDP1:\n            m=audio 20000\
    \ RTP/AVP 0\n            a=sendrecv\n            m=video 20002 RTP/AVP 31\n  \
    \          a=sendrecv\n   UA2 is configured to automatically accept incoming video\
    \ streams but\n   to ask for user input before generating an outgoing video stream.\n\
    \   Therefore, UAS2 makes the video stream recvonly by returning a 183\n   (Session\
    \ Progress) response (2).\n         SDP2:\n            m=audio 30000 RTP/AVP 0\n\
    \            a=sendrecv\n            m=video 30002 RTP/AVP 31\n            a=recvonly\n\
    \   When asked for input, UA2's user chooses not to have either incoming\n   or\
    \ outgoing video.  In order to make the video stream inactive, UA2\n   returns\
    \ a 4xx error response (5) to the re-INVITE.  The ACK request\n   (6) for this\
    \ error response is generated by the proxy between both\n   user agents.  Note\
    \ that this error response undoes already executed\n   changes.  So, UA2 is a\
    \ legacy UA that does not support this\n   specification.\n   The proxy relays\
    \ the 4xx response (7) towards UA1.  However, the 4xx\n   response (7) takes time\
    \ to arrive to UA1 (e.g., the response may have\n   been sent over UDP and the\
    \ first few retransmissions were lost).  In\n   the meantime, UA2's user decides\
    \ to put the audio stream on hold.\n   UA2 sends an UPDATE request (8) making\
    \ the audio stream recvonly.\n   The video stream, which is inactive, is not modified\
    \ and, thus,\n   continues being inactive.\n         SDP3:\n            m=audio\
    \ 30000 RTP/AVP 0\n            a=recvonly\n            m=video 30002 RTP/AVP 31\n\
    \            a=inactive\n   The proxy relays the UPDATE request (9) to UA1.  The\
    \ UPDATE request\n   (9) arrives at UA1 before the 4xx response (7) that had been\n\
    \   previously sent.  UA1 accepts the changes in the UPDATE request and\n   returns\
    \ a 200 (OK) response (10) to it.\n         SDP4:\n            m=audio 20000 RTP/AVP\
    \ 0\n            a=sendonly\n            m=video 30002 RTP/AVP 31\n          \
    \  a=inactive\n   At a later point, the 4xx response (7) finally arrives at UA1.\
    \  This\n   response makes the session return to its pre-re-INVITE state.\n  \
    \ Therefore, for UA1, the audio stream is sendrecv and the video stream\n   is\
    \ inactive.  However, for UA2, the audio stream is recvonly (the\n   video stream\
    \ is also inactive).\n   After the message flow in Figure 5, following the recommendations\
    \ in\n   this section, when UA1 received an error response (7) that undid\n  \
    \ already executed changes, UA1 would generate an UPDATE request with\n   an SDP\
    \ reflecting the pre-re-INVITE state (i.e., sendrecv audio and\n   inactive video).\
    \  UA2 could then return a 200 (OK) response to the\n   UPDATE request making\
    \ the audio stream recvonly, which is the state\n   UA2's user had requested.\
    \  Such an UPDATE transaction would get the\n   UAs back into synchronization.\n"
- title: 3.8.  Clarifications on Canceling Re-INVITEs
  contents:
  - "3.8.  Clarifications on Canceling Re-INVITEs\n   Section 9.2 of RFC 3261 [RFC3261]\
    \ specifies the behavior of a UAS\n   responding to a CANCEL request.  Such a\
    \ UAS responds to the INVITE\n   request with a 487 (Request Terminated) at the\
    \ SHOULD level.  Per the\n   rules specified in Section 3.3, if the INVITE request\
    \ was a re-INVITE\n   and some of its requested changes had already been executed,\
    \ the UAS\n   would return a 2xx response instead.\n"
- title: 4.  Refreshing a Dialog's Targets
  contents:
  - "4.  Refreshing a Dialog's Targets\n   The following sections discuss how to refresh\
    \ the targets of a\n   dialog.\n"
- title: 4.1.  Background and Terminology on a Dialog's Targets
  contents:
  - "4.1.  Background and Terminology on a Dialog's Targets\n   As described in Section\
    \ 12 of RFC 3261 [RFC3261], a UA involved in a\n   dialog keeps a record of the\
    \ SIP or Session Initiation Protocol\n   Secure (SIPS) URI at which it can communicate\
    \ with a specific\n   instance of its peer (this is called the \"dialog's remote\
    \ target URI\"\n   and is equal to the URI contained in the Contact header of\
    \ requests\n   and responses it receives from the peer).  This document introduces\n\
    \   the complementary concept of the \"dialog's local target URI\", defined\n\
    \   as a UA's record of the SIP or SIPS URI at which the peer can\n   communicate\
    \ with it (equal to the URI contained in the Contact header\n   of requests and\
    \ responses it sends to the peer).  These terms are\n   complementary because\
    \ the \"dialog's remote target URI\" according to\n   one UA is the \"dialog's\
    \ local target URI\" according to the other UA,\n   and vice versa.\n"
- title: 4.2.  Background on Target-Refresh Requests
  contents:
  - "4.2.  Background on Target-Refresh Requests\n   A target-refresh request is defined\
    \ as follows in Section 6 of RFC\n   3261 [RFC3261]:\n      A target-refresh request\
    \ sent within a dialog is defined as a\n      request that can modify the remote\
    \ target of the dialog.\n   Additionally, 2xx responses to target-refresh requests\
    \ can also\n   update the remote target of the dialog.  As discussed in Section\
    \ 12.2\n   of RFC 3261 [RFC3261], re-INVITEs are target-refresh requests.\n  \
    \ RFC 3261 [RFC3261] specifies the behavior of UASs receiving target-\n   refresh\
    \ requests and of UACs receiving a 2xx response for a target-\n   refresh request.\n\
    \   Section 12.2.2 of RFC 3261 [RFC3261] says:\n      When a UAS receives a target\
    \ refresh request, it MUST replace the\n      dialog's remote target URI with\
    \ the URI from the Contact header\n      field in that request, if present.\n\
    \   Section 12.2.1.2 of RFC 3261 [RFC3261] says:\n      When a UAC receives a\
    \ 2xx response to a target refresh request, it\n      MUST replace the dialog's\
    \ remote target URI with the URI from the\n      Contact header field in that\
    \ response, if present.\n   The fact that re-INVITEs can be long-lived transactions\
    \ and can have\n   other transactions within them makes it necessary to revise\
    \ these\n   rules.  Section 4.3 specifies new rules for the handling of target-\n\
    \   refresh requests.  Note that the new rules apply to any target-\n   refresh\
    \ request, not only to re-INVITEs.\n"
- title: 4.3.  Clarification on the Atomicity of Target-Refresh Requests
  contents:
  - "4.3.  Clarification on the Atomicity of Target-Refresh Requests\n   The local\
    \ and remote targets of a dialog are special types of state\n   information because\
    \ of their essential role in the exchange of SIP\n   messages between UAs in a\
    \ dialog.  A UA involved in a dialog receives\n   the remote target of the dialog\
    \ from the remote UA.  The UA uses the\n   received remote target to send SIP\
    \ requests to the remote UA.\n   The dialog's local target is a piece of state\
    \ information that is not\n   meant to be negotiated.  When a UA changes its local\
    \ target (i.e.,\n   the UA changes its IP address), the UA simply communicates\
    \ its new\n   local target to the remote UA (e.g., the UA communicates its new\
    \ IP\n   address to the remote UA in order to remain reachable by the remote\n\
    \   UA).  UAs need to follow the behavior specified in Sections 4.4, 4.5,\n  \
    \ 4.6, and 4.7 of this specification instead of that specified in RFC\n   3261\
    \ [RFC3261], which was discussed in Section 4.2.  The new behavior\n   regarding\
    \ target-refresh requests implies that a target-refresh\n   request can, in some\
    \ cases, update the remote target even if the\n   request is responded to with\
    \ a final error response.  This means that\n   target-refresh requests are not\
    \ atomic.\n"
- title: 4.4.  UA Updating the Dialog's Local Target in a Request
  contents:
  - "4.4.  UA Updating the Dialog's Local Target in a Request\n   In order to update\
    \ its local target, a UA can send a target-refresh\n   request.  If the UA receives\
    \ an error response to the target-refresh\n   request, the remote UA has not updated\
    \ its remote target.\n      This allows UASs to authenticate target-refresh requests\
    \ (see\n      Section 26.2 of RFC 3261 [RFC3261]).\n   If the UA receives a reliable\
    \ provisional response or a 2xx response\n   to the target-refresh request, or\
    \ the UA receives an in-dialog\n   request on the new local target, the remote\
    \ UA has updated its remote\n   target.  The UA can consider the target refresh\
    \ operation completed.\n      Even if the target request was a re-INVITE and the\
    \ final response\n      to the re-INVITE was an error response, the UAS would\
    \ not revert\n      to the pre-re-INVITE remote target.\n   A UA SHOULD NOT use\
    \ the same target refresh request to refresh the\n   target and to make session\
    \ changes unless the session changes can be\n   trivially accepted by the remote\
    \ UA (e.g., an IP address change).\n   Piggybacking a target refresh with more\
    \ complicated session changes\n   would make it unnecessarily complicated for\
    \ the remote UA to accept\n   the target refresh while rejecting the session changes.\
    \  Only in case\n   the target refresh request is a re-INVITE and the UAS supports\n\
    \   reliable provisional response or UPDATE requests, the UAC MAY\n   piggyback\
    \ session changes and a target refresh in the same re-INVITE.\n"
- title: 4.5.  UA Updating the Dialog's Local Target in a Response
  contents:
  - "4.5.  UA Updating the Dialog's Local Target in a Response\n   A UA processing\
    \ an incoming target refresh request can update its\n   local target by returning\
    \ a reliable provisional response or a 2xx\n   response to the target-refresh\
    \ request.  The response needs to\n   contain the updated local target URI in\
    \ its Contact header field.  On\n   sending the response, the UA can consider\
    \ the target refresh\n   operation completed.\n"
- title: 4.6.  A Request Updating the Dialog's Remote Target
  contents:
  - "4.6.  A Request Updating the Dialog's Remote Target\n   Behavior of a UA after\
    \ having received a target-refresh request\n   updating the remote target:\n \
    \  If the UA receives a target-refresh request that has been properly\n   authenticated\
    \ (see Section 26.2 of RFC 3261 [RFC3261]), the UA SHOULD\n   generate a reliable\
    \ provisional response or a 2xx response to the\n   target-refresh request.  If\
    \ generating such responses is not possible\n   (e.g., the UA does not support\
    \ reliable provisional responses and\n   needs user input before generating a\
    \ final response), the UA SHOULD\n   send an in-dialog request to the remote UA\
    \ using the new remote\n   target (if the UA does not need to send a request for\
    \ other reasons,\n   the UAS can send an UPDATE request).  On sending a reliable\n\
    \   provisional response or a 2xx response to the target-refresh request,\n  \
    \ or a request to the new remote target, the UA MUST replace the\n   dialog's\
    \ remote target URI with the URI from the Contact header field\n   in the target-refresh\
    \ request.\n      Reliable provisional responses in SIP are specified in RFC 3262\n\
    \      [RFC3262].  In this document, reliable provisional responses are\n    \
    \  those that use the mechanism defined in RFC 3262 [RFC3262].  Other\n      specifications\
    \ may define ways to send provisional responses\n      reliably using non-SIP\
    \ mechanisms (e.g., using media-level\n      messages to acknowledge the reception\
    \ of the SIP response).  For\n      the purposes of this document, provisional\
    \ responses using those\n      non-SIP mechanisms are considered unreliable responses.\
    \  Note that\n      non-100 provisional responses are only applicable to INVITE\n\
    \      transactions [RFC4320].\n   If instead of sending a reliable provisional\
    \ response or a 2xx\n   response to the target-refresh request, or a request to\
    \ the new\n   target, the UA generates an error response to the target-refresh\n\
    \   request, the UA MUST NOT update its dialog's remote target.\n"
- title: 4.7.  A Response Updating the Dialog's Remote Target
  contents:
  - "4.7.  A Response Updating the Dialog's Remote Target\n   If a UA receives a reliable\
    \ provisional response or a 2xx response to\n   a target-refresh request, the\
    \ UA MUST replace the dialog's remote\n   target URI with the URI from the Contact\
    \ header field in that\n   response, if present.\n   If a UA receives an unreliable\
    \ provisional response to a target-\n   refresh request, the UA MUST NOT refresh\
    \ the dialog's remote target.\n"
- title: 4.8.  Race Conditions and Target Refreshes
  contents:
  - "4.8.  Race Conditions and Target Refreshes\n   SIP provides request ordering\
    \ by using the Cseq header field.  That\n   is, a UA that receives two requests\
    \ at roughly the same time can know\n   which one is newer.  However, SIP does\
    \ not provide ordering between\n   responses and requests.  For example, if a\
    \ UA receives a 200 (OK)\n   response to an UPDATE request and an UPDATE request\
    \ at roughly the\n   same time, the UA cannot know which one was sent last.  Since\
    \ both\n   messages can refresh the remote target, the UA needs to know which\n\
    \   message was sent last in order to know which remote target needs to\n   be\
    \ used.\n   This document specifies the following rule to avoid the situation\n\
    \   just described.  If the protocol allows a UA to use a target-refresh\n   request\
    \ at the point in time that the UA wishes to refresh its local\n   target, the\
    \ UA MUST use a target-refresh request instead of a\n   response to refresh its\
    \ local target.  This rule implies that a UA\n   only uses a response (i.e., a\
    \ reliable provisional response or a 2xx\n   response to a target-refresh request)\
    \ to refresh its local target if\n   the UA is unable to use a target-refresh\
    \ request at that point in\n   time (e.g., the UAS of an ongoing re-INVITE without\
    \ support for\n   UPDATE).\n"
- title: 4.9.  Early Dialogs
  contents:
  - "4.9.  Early Dialogs\n   The rules given in this section about which messages\
    \ can refresh the\n   target of a dialog also apply to early dialogs created by\
    \ an initial\n   INVITE transaction.  Additionally, as specified in Section 13.2.2.4\n\
    \   of RFC 3261 [RFC3261], on receiving a 2xx response to the initial\n   INVITE,\
    \ the UAC recomputes the whole route set of the dialog, which\n   transitions\
    \ from the \"early\" state to the \"confirmed\" state.\n   Section 12.1 of RFC\
    \ 3261 allows unreliable provisional responses to\n   create early dialogs.  However,\
    \ per the rules given in this section,\n   unreliable provisional responses cannot\
    \ refresh the target of a\n   dialog.  Therefore, the UAC of an initial INVITE\
    \ transaction will not\n   perform any target refresh as a result of the reception\
    \ of an\n   unreliable provisional response with an updated Contact value on an\n\
    \   (already established) early dialog.  Note also that a given UAS can\n   establish\
    \ additional early dialogs, which can have different targets,\n   by returning\
    \ additional unreliable provisional responses with\n   different To tags.\n"
- title: 5.  A UA Losing Its Contact
  contents:
  - "5.  A UA Losing Its Contact\n   The following sections discuss the case where\
    \ a UA loses its\n   transport address during an ongoing re-INVITE transaction.\
    \  Such a UA\n   will refresh the dialog's local target so that it reflects its\
    \ new\n   transport address.  Note that target refreshes that do not involve\n\
    \   changes in the UA's transport address are outside of the scope of\n   this\
    \ section.  Also, UAs losing their transport address during a\n   non-re-INVITE\
    \ transaction (e.g., a UA losing its transport address\n   right after having\
    \ sent an UPDATE request before having received a\n   response to it) are out\
    \ of scope as well.\n   The rules given in this section are also applicable to\
    \ initial INVITE\n   requests that have established early dialogs.\n"
- title: 5.1.  Background on Re-INVITE Transaction Routing
  contents:
  - "5.1.  Background on Re-INVITE Transaction Routing\n   Re-INVITEs are routed using\
    \ the dialog's route set, which contains\n   all the proxy servers that need to\
    \ be traversed by requests sent\n   within the dialog.  Responses to the re-INVITE\
    \ are routed using the\n   Via entries in the re-INVITE.\n   ACK requests for\
    \ 2xx responses and for non-2xx final responses are\n   generated in different\
    \ ways.  As specified in Sections 14.1 and\n   13.2.1 of RFC 3261 [RFC3261], ACK\
    \ requests for 2xx responses are\n   generated by the UAC core and are routed\
    \ using the dialog's route\n   set.  As specified in Section 17.1.1.2 of RFC 3261\
    \ [RFC3261], ACK\n   requests for non-2xx final responses are generated by the\
    \ INVITE\n   client transaction (i.e., they are generated in a hop-by-hop fashion\n\
    \   by the proxy servers in the path) and are sent to the same transport\n   address\
    \ as the re-INVITE.\n"
- title: 5.2.  Problems with UAs Losing Their Contact
  contents:
  - "5.2.  Problems with UAs Losing Their Contact\n   Refreshing the dialog's remote\
    \ target during a re-INVITE transaction\n   (see Section 4.3) presents some issues\
    \ because of the fact that\n   re-INVITE transactions can be long lived.  As described\
    \ in\n   Section 5.1, the way responses to the re-INVITE and ACKs for non-2xx\n\
    \   final responses are routed is fixed once the re-INVITE is sent.  The\n   routing\
    \ of this messages does not depend on the dialog's route set\n   and, thus, target\
    \ refreshes within an ongoing re-INVITE do not affect\n   their routing.  A UA\
    \ that changes its location (i.e., performs a\n   target refresh) but is still\
    \ reachable at its old location will be\n   able to receive those messages (which\
    \ will be sent to the old\n   location).  However, a UA that cannot be reachable\
    \ at its old\n   location any longer will not be able to receive them.\n   The\
    \ following sections describe the errors UAs face when they lose\n   their transport\
    \ address during a re-INVITE.  On detecting some of\n   these errors, UAs following\
    \ the rules specified in RFC 3261 [RFC3261]\n   will terminate the dialog.  When\
    \ the dialog is terminated, the only\n   option for the UAs is to establish a\
    \ new dialog.  The following\n   sections change the requirements RFC 3261 [RFC3261]\
    \ places on UAs\n   when certain errors occur so that the UAs can recover from\
    \ those\n   errors.  In short, the UAs generate a new re-INVITE transaction to\n\
    \   synchronize both UAs.  Note that there are existing UA\n   implementations\
    \ deployed that already implement this behavior.\n"
- title: '5.3.  UAS Losing Its Contact: UAC Behavior'
  contents:
  - "5.3.  UAS Losing Its Contact: UAC Behavior\n   When a UAS that moves to a new\
    \ contact and loses its old contact\n   generates a non-2xx final response to\
    \ the re-INVITE, it will not be\n   able to receive the ACK request.  The entity\
    \ receiving the response\n   and, thus, generating the ACK request will either\
    \ get a transport\n   error or a timeout error, which, as described in Section\
    \ 8.1.3.1 of\n   RFC 3261 [RFC3261], will be treated as a 503 (Service Unavailable)\n\
    \   response and as a 408 (Request Timeout) response, respectively.  If\n   the\
    \ sender of the ACK request is a proxy server, it will typically\n   ignore this\
    \ error.  If the sender of the ACK request is the UAC,\n   according to Section\
    \ 12.2.1.2 of RFC 3261 [RFC3261], it is supposed\n   to (at the SHOULD level)\
    \ terminate the dialog by sending a BYE\n   request.  However, because of the\
    \ special properties of ACK requests\n   for non-2xx final responses, most existing\
    \ UACs do not terminate the\n   dialog when ACK request fails, which is fortunate.\n\
    \   A UAC that accepts a target refresh within a re-INVITE MUST ignore\n   transport\
    \ and timeout errors when generating an ACK request for a\n   non-2xx final response.\
    \  Additionally, UAC SHOULD generate a new\n   re-INVITE in order to make sure\
    \ that both UAs have a common view of\n   the state of the session.\n      It\
    \ is possible that the errors ignored by the UAC were not related\n      to the\
    \ target refresh operation.  If that was the case, the second\n      re-INVITE\
    \ would fail and the UAC would terminate the dialog\n      because, per the rules\
    \ above, UACs only ignore errors when they\n      accept a target refresh within\
    \ the re-INVITE.\n"
- title: '5.4.  UAC Losing Its Contact: UAS Behavior'
  contents:
  - "5.4.  UAC Losing Its Contact: UAS Behavior\n   When a UAC moves to a new contact\
    \ and loses its old contact, it will\n   not be able to receive responses to the\
    \ re-INVITE.  Consequently, it\n   will never generate an ACK request.\n   As\
    \ described in Section 16.9 of RFC 3261 [RFC3261], a proxy server\n   that gets\
    \ an error when forwarding a response does not take any\n   measures.  Consequently,\
    \ proxy servers relaying responses will\n   effectively ignore the error.\n  \
    \ If there are no proxy servers in the dialog's route set, the UAS will\n   get\
    \ an error when sending a non-2xx final response.  The UAS core\n   will be notified\
    \ of the transaction failure, as described in Section\n   17.2.1 of RFC 3261 [RFC3261].\
    \  Most existing UASs do not terminate\n   the dialog on encountering this failure,\
    \ which is fortunate.\n   Regardless of the presence or absence of proxy servers\
    \ in the\n   dialog's route set, a UAS generating a 2xx response to the re-INVITE\n\
    \   will never receive an ACK request for it.  According to Section 14.2\n   of\
    \ RFC 3261 [RFC3261], such a UAS is supposed to (at the \"should\"\n   level)\
    \ terminate the dialog by sending a BYE request.\n   A UAS that accepts a target\
    \ refresh within a re-INVITE and never\n   receives an ACK request after having\
    \ sent a final response to the\n   re-INVITE SHOULD NOT terminate the dialog if\
    \ the UA has received a\n   new re-INVITE with a higher CSeq sequence number than\
    \ the original\n   one.\n"
- title: '5.5.  UAC Losing Its Contact: UAC Behavior'
  contents:
  - "5.5.  UAC Losing Its Contact: UAC Behavior\n   When a UAC moves to a new contact\
    \ and loses its old contact, it will\n   not be able to receive responses to the\
    \ re-INVITE.  Consequently, it\n   will never generate an ACK request.\n   Such\
    \ a UAC SHOULD generate a CANCEL request to cancel the re-INVITE\n   and cause\
    \ the INVITE client transaction corresponding to the\n   re-INVITE to enter the\
    \ \"Terminated\" state.  The UAC SHOULD also send\n   a new re-INVITE in order\
    \ to make sure that both UAs have a common\n   view of the state of the session.\n\
    \      Per Section 14.2 of RFC 3261 [RFC3261], the UAS will accept new\n     \
    \ incoming re-INVITEs as soon as it has generated a final response\n      to the\
    \ previous INVITE request, which had a lower CSeq sequence\n      number.\n"
- title: 6.  Security Considerations
  contents:
  - "6.  Security Considerations\n   This document does not introduce any new security\
    \ issue.  It just\n   clarifies how certain transactions should be handled in\
    \ SIP.\n   Security issues related to re-INVITEs and UPDATE requests are\n   discussed\
    \ in RFC 3261 [RFC3261] and RFC 3311 [RFC3311].\n   In particular, in order not\
    \ to reduce the security level for a given\n   session, re-INVITEs and UPDATE\
    \ requests SHOULD be secured using a\n   mechanism equivalent to or stronger than\
    \ the initial INVITE request\n   that created the session.  For example, if the\
    \ initial INVITE request\n   was end-to-end integrity protected or encrypted,\
    \ subsequent\n   re-INVITEs and UPDATE requests should also be so.\n"
- title: 7.  Acknowledgements
  contents:
  - "7.  Acknowledgements\n   Paul Kyzivat provided useful ideas on the topics discussed\
    \ in this\n   document.\n"
- title: 8.  References
  contents:
  - '8.  References

    '
- title: 8.1.  Normative References
  contents:
  - "8.1.  Normative References\n   [RFC2119]  Bradner, S., \"Key words for use in\
    \ RFCs to Indicate\n              Requirement Levels\", BCP 14, RFC 2119, March\
    \ 1997.\n   [RFC3261]  Rosenberg, J., Schulzrinne, H., Camarillo, G., Johnston,\n\
    \              A., Peterson, J., Sparks, R., Handley, M., and E.\n           \
    \   Schooler, \"SIP: Session Initiation Protocol\", RFC 3261,\n              June\
    \ 2002.\n   [RFC3262]  Rosenberg, J. and H. Schulzrinne, \"Reliability of\n  \
    \            Provisional Responses in Session Initiation Protocol\n          \
    \    (SIP)\", RFC 3262, June 2002.\n   [RFC3264]  Rosenberg, J. and H. Schulzrinne,\
    \ \"An Offer/Answer Model\n              with Session Description Protocol (SDP)\"\
    , RFC 3264,\n              June 2002.\n   [RFC3311]  Rosenberg, J., \"The Session\
    \ Initiation Protocol (SIP)\n              UPDATE Method\", RFC 3311, October\
    \ 2002.\n   [RFC4032]  Camarillo, G. and P. Kyzivat, \"Update to the Session\n\
    \              Initiation Protocol (SIP) Preconditions Framework\",\n        \
    \      RFC 4032, March 2005.\n"
- title: 8.2.  Informative References
  contents:
  - "8.2.  Informative References\n   [RFC4320]  Sparks, R., \"Actions Addressing\
    \ Identified Issues with the\n              Session Initiation Protocol's (SIP)\
    \ Non-INVITE\n              Transaction\", RFC 4320, January 2006.\n   [RFC5245]\
    \  Rosenberg, J., \"Interactive Connectivity Establishment\n              (ICE):\
    \ A Protocol for Network Address Translator (NAT)\n              Traversal for\
    \ Offer/Answer Protocols\", RFC 5245,\n              April 2010.\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Gonzalo Camarillo (editor)\n   Ericsson\n   Hirsalantie\
    \ 11\n   Jorvas  02420\n   Finland\n   EMail: Gonzalo.Camarillo@ericsson.com\n\
    \   Christer Holmberg\n   Ericsson\n   Hirsalantie 11\n   Jorvas  02420\n   Finland\n\
    \   EMail: Christer.Holmberg@ericsson.com\n   Yang Gao\n   ZTE\n   China\n   EMail:\
    \ gao.yang2@zte.com.cn\n"
