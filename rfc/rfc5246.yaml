- title: __initial_text__
  contents:
  - "              The Transport Layer Security (TLS) Protocol\n                 \
    \             Version 1.2\n"
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This document specifies an Internet standards track protocol\
    \ for the\n   Internet community, and requests discussion and suggestions for\n\
    \   improvements.  Please refer to the current edition of the \"Internet\n   Official\
    \ Protocol Standards\" (STD 1) for the standardization state\n   and status of\
    \ this protocol.  Distribution of this memo is unlimited.\n"
- title: Abstract
  contents:
  - "Abstract\n   This document specifies Version 1.2 of the Transport Layer Security\n\
    \   (TLS) protocol.  The TLS protocol provides communications security\n   over\
    \ the Internet.  The protocol allows client/server applications to\n   communicate\
    \ in a way that is designed to prevent eavesdropping,\n   tampering, or message\
    \ forgery.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n           6.2.2. Record Compression and Decompression ...............20\n\
    \           6.2.3. Record Payload Protection ..........................21\n  \
    \                6.2.3.1. Null or Standard Stream Cipher ............22\n    \
    \              6.2.3.2. CBC Block Cipher ..........................22\n      \
    \            6.2.3.3. AEAD Ciphers ..............................24\n      6.3.\
    \ Key Calculation ...........................................25\n   7. The TLS\
    \ Handshaking Protocols ..................................26\n      7.1. Change\
    \ Cipher Spec Protocol ...............................27\n      7.2. Alert Protocol\
    \ ............................................28\n           7.2.1. Closure Alerts\
    \ .....................................29\n           7.2.2. Error Alerts .......................................30\n\
    \      7.3. Handshake Protocol Overview ...............................33\n  \
    \    7.4. Handshake Protocol ........................................37\n    \
    \       7.4.1. Hello Messages .....................................38\n      \
    \            7.4.1.1. Hello Request .............................38\n        \
    \          7.4.1.2. Client Hello ..............................39\n          \
    \        7.4.1.3. Server Hello ..............................42\n            \
    \      7.4.1.4. Hello Extensions ..........................44\n              \
    \             7.4.1.4.1. Signature Algorithms ...........45\n           7.4.2.\
    \ Server Certificate .................................47\n           7.4.3. Server\
    \ Key Exchange Message ........................50\n           7.4.4. Certificate\
    \ Request ................................53\n           7.4.5. Server Hello Done\
    \ ..................................55\n           7.4.6. Client Certificate .................................55\n\
    \           7.4.7. Client Key Exchange Message ........................57\n  \
    \                7.4.7.1. RSA-Encrypted Premaster Secret Message ....58\n    \
    \              7.4.7.2. Client Diffie-Hellman Public Value ........61\n      \
    \     7.4.8. Certificate Verify .................................62\n        \
    \   7.4.9. Finished ...........................................63\n   8. Cryptographic\
    \ Computations .....................................64\n      8.1. Computing the\
    \ Master Secret ...............................64\n           8.1.1. RSA ................................................65\n\
    \           8.1.2. Diffie-Hellman .....................................65\n  \
    \ 9. Mandatory Cipher Suites ........................................65\n   10.\
    \ Application Data Protocol .....................................65\n   11. Security\
    \ Considerations .......................................65\n   12. IANA Considerations\
    \ ...........................................65\n   Appendix A. Protocol Data\
    \ Structures and Constant Values ..........68\n      A.1. Record Layer ..............................................68\n\
    \      A.2. Change Cipher Specs Message ...............................69\n  \
    \    A.3. Alert Messages ............................................69\n    \
    \  A.4. Handshake Protocol ........................................70\n      \
    \     A.4.1. Hello Messages .....................................71\n        \
    \   A.4.2. Server Authentication and Key Exchange Messages ....72\n          \
    \ A.4.3. Client Authentication and Key Exchange Messages ....74\n           A.4.4.\
    \ Handshake Finalization Message .....................74\n      A.5. The Cipher\
    \ Suite ..........................................75\n      A.6. The Security\
    \ Parameters ...................................77\n      A.7. Changes to RFC\
    \ 4492 .......................................78\n   Appendix B. Glossary ..............................................78\n\
    \   Appendix C. Cipher Suite Definitions ..............................83\n  \
    \ Appendix D. Implementation Notes ..................................85\n    \
    \  D.1. Random Number Generation and Seeding ......................85\n      D.2.\
    \ Certificates and Authentication ...........................85\n      D.3. Cipher\
    \ Suites .............................................85\n      D.4. Implementation\
    \ Pitfalls ...................................85\n   Appendix E. Backward Compatibility\
    \ ................................87\n      E.1. Compatibility with TLS 1.0/1.1\
    \ and SSL 3.0 ................87\n      E.2. Compatibility with SSL 2.0 ................................88\n\
    \      E.3. Avoiding Man-in-the-Middle Version Rollback ...............90\n  \
    \ Appendix F. Security Analysis .....................................91\n    \
    \  F.1. Handshake Protocol ........................................91\n      \
    \     F.1.1. Authentication and Key Exchange ....................91\n        \
    \          F.1.1.1. Anonymous Key Exchange ....................91\n          \
    \        F.1.1.2. RSA Key Exchange and Authentication .......92\n            \
    \      F.1.1.3. Diffie-Hellman Key Exchange with\n                           Authentication\
    \ ............................92\n           F.1.2. Version Rollback Attacks ...........................93\n\
    \           F.1.3. Detecting Attacks Against the Handshake Protocol ...94\n  \
    \         F.1.4. Resuming Sessions ..................................94\n    \
    \  F.2. Protecting Application Data ...............................94\n      F.3.\
    \ Explicit IVs ..............................................95\n      F.4. Security\
    \ of Composite Cipher Modes ........................95\n      F.5. Denial of Service\
    \ .........................................96\n      F.6. Final Notes ...............................................96\n\
    \   Normative References ..............................................97\n  \
    \ Informative References ............................................98\n   Working\
    \ Group Information ........................................101\n   Contributors\
    \ .....................................................101\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   The primary goal of the TLS protocol is to provide privacy\
    \ and data\n   integrity between two communicating applications.  The protocol\
    \ is\n   composed of two layers: the TLS Record Protocol and the TLS Handshake\n\
    \   Protocol.  At the lowest level, layered on top of some reliable\n   transport\
    \ protocol (e.g., TCP [TCP]), is the TLS Record Protocol.\n   The TLS Record Protocol\
    \ provides connection security that has two\n   basic properties:\n   -  The connection\
    \ is private.  Symmetric cryptography is used for\n      data encryption (e.g.,\
    \ AES [AES], RC4 [SCH], etc.).  The keys for\n      this symmetric encryption\
    \ are generated uniquely for each\n      connection and are based on a secret\
    \ negotiated by another\n      protocol (such as the TLS Handshake Protocol).\
    \  The Record\n      Protocol can also be used without encryption.\n   -  The\
    \ connection is reliable.  Message transport includes a message\n      integrity\
    \ check using a keyed MAC.  Secure hash functions (e.g.,\n      SHA-1, etc.) are\
    \ used for MAC computations.  The Record Protocol\n      can operate without a\
    \ MAC, but is generally only used in this mode\n      while another protocol is\
    \ using the Record Protocol as a transport\n      for negotiating security parameters.\n\
    \   The TLS Record Protocol is used for encapsulation of various higher-\n   level\
    \ protocols.  One such encapsulated protocol, the TLS Handshake\n   Protocol,\
    \ allows the server and client to authenticate each other and\n   to negotiate\
    \ an encryption algorithm and cryptographic keys before\n   the application protocol\
    \ transmits or receives its first byte of\n   data.  The TLS Handshake Protocol\
    \ provides connection security that\n   has three basic properties:\n   -  The\
    \ peer's identity can be authenticated using asymmetric, or\n      public key,\
    \ cryptography (e.g., RSA [RSA], DSA [DSS], etc.).  This\n      authentication\
    \ can be made optional, but is generally required for\n      at least one of the\
    \ peers.\n   -  The negotiation of a shared secret is secure: the negotiated\n\
    \      secret is unavailable to eavesdroppers, and for any authenticated\n   \
    \   connection the secret cannot be obtained, even by an attacker who\n      can\
    \ place himself in the middle of the connection.\n   -  The negotiation is reliable:\
    \ no attacker can modify the\n      negotiation communication without being detected\
    \ by the parties to\n      the communication.\n   One advantage of TLS is that\
    \ it is application protocol independent.\n   Higher-level protocols can layer\
    \ on top of the TLS protocol\n   transparently.  The TLS standard, however, does\
    \ not specify how\n   protocols add security with TLS; the decisions on how to\
    \ initiate TLS\n   handshaking and how to interpret the authentication certificates\n\
    \   exchanged are left to the judgment of the designers and implementors\n   of\
    \ protocols that run on top of TLS.\n"
- title: 1.1.  Requirements Terminology
  contents:
  - "1.1.  Requirements Terminology\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\"\
    , \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"\
    MAY\", and \"OPTIONAL\" in this\n   document are to be interpreted as described\
    \ in RFC 2119 [REQ].\n"
- title: 1.2.  Major Differences from TLS 1.1
  contents:
  - "1.2.  Major Differences from TLS 1.1\n   This document is a revision of the TLS\
    \ 1.1 [TLS1.1] protocol which\n   contains improved flexibility, particularly\
    \ for negotiation of\n   cryptographic algorithms.  The major changes are:\n \
    \  -  The MD5/SHA-1 combination in the pseudorandom function (PRF) has\n     \
    \ been replaced with cipher-suite-specified PRFs.  All cipher suites\n      in\
    \ this document use P_SHA256.\n   -  The MD5/SHA-1 combination in the digitally-signed\
    \ element has been\n      replaced with a single hash.  Signed elements now include\
    \ a field\n      that explicitly specifies the hash algorithm used.\n   -  Substantial\
    \ cleanup to the client's and server's ability to\n      specify which hash and\
    \ signature algorithms they will accept.\n      Note that this also relaxes some\
    \ of the constraints on signature\n      and hash algorithms from previous versions\
    \ of TLS.\n   -  Addition of support for authenticated encryption with additional\n\
    \      data modes.\n   -  TLS Extensions definition and AES Cipher Suites were\
    \ merged in\n      from external [TLSEXT] and [TLSAES].\n   -  Tighter checking\
    \ of EncryptedPreMasterSecret version numbers.\n   -  Tightened up a number of\
    \ requirements.\n   -  Verify_data length now depends on the cipher suite (default\
    \ is\n      still 12).\n   -  Cleaned up description of Bleichenbacher/Klima attack\
    \ defenses.\n   -  Alerts MUST now be sent in many cases.\n   -  After a certificate_request,\
    \ if no certificates are available,\n      clients now MUST send an empty certificate\
    \ list.\n   -  TLS_RSA_WITH_AES_128_CBC_SHA is now the mandatory to implement\n\
    \      cipher suite.\n   -  Added HMAC-SHA256 cipher suites.\n   -  Removed IDEA\
    \ and DES cipher suites.  They are now deprecated and\n      will be documented\
    \ in a separate document.\n   -  Support for the SSLv2 backward-compatible hello\
    \ is now a MAY, not\n      a SHOULD, with sending it a SHOULD NOT.  Support will\
    \ probably\n      become a SHOULD NOT in the future.\n   -  Added limited \"fall-through\"\
    \ to the presentation language to allow\n      multiple case arms to have the\
    \ same encoding.\n   -  Added an Implementation Pitfalls sections\n   -  The usual\
    \ clarifications and editorial work.\n"
- title: 2.  Goals
  contents:
  - "2.  Goals\n   The goals of the TLS protocol, in order of priority, are as follows:\n\
    \   1. Cryptographic security: TLS should be used to establish a secure\n    \
    \  connection between two parties.\n   2. Interoperability: Independent programmers\
    \ should be able to\n      develop applications utilizing TLS that can successfully\
    \ exchange\n      cryptographic parameters without knowledge of one another's\
    \ code.\n   3. Extensibility: TLS seeks to provide a framework into which new\n\
    \      public key and bulk encryption methods can be incorporated as\n      necessary.\
    \  This will also accomplish two sub-goals: preventing\n      the need to create\
    \ a new protocol (and risking the introduction of\n      possible new weaknesses)\
    \ and avoiding the need to implement an\n      entire new security library.\n\
    \   4. Relative efficiency: Cryptographic operations tend to be highly\n     \
    \ CPU intensive, particularly public key operations.  For this\n      reason,\
    \ the TLS protocol has incorporated an optional session\n      caching scheme\
    \ to reduce the number of connections that need to be\n      established from\
    \ scratch.  Additionally, care has been taken to\n      reduce network activity.\n"
- title: 3.  Goals of This Document
  contents:
  - "3.  Goals of This Document\n   This document and the TLS protocol itself are\
    \ based on the SSL 3.0\n   Protocol Specification as published by Netscape.  The\
    \ differences\n   between this protocol and SSL 3.0 are not dramatic, but they\
    \ are\n   significant enough that the various versions of TLS and SSL 3.0 do\n\
    \   not interoperate (although each protocol incorporates a mechanism by\n   which\
    \ an implementation can back down to prior versions).  This\n   document is intended\
    \ primarily for readers who will be implementing\n   the protocol and for those\
    \ doing cryptographic analysis of it.  The\n   specification has been written\
    \ with this in mind, and it is intended\n   to reflect the needs of those two\
    \ groups.  For that reason, many of\n   the algorithm-dependent data structures\
    \ and rules are included in the\n   body of the text (as opposed to in an appendix),\
    \ providing easier\n   access to them.\n   This document is not intended to supply\
    \ any details of service\n   definition or of interface definition, although it\
    \ does cover select\n   areas of policy as they are required for the maintenance\
    \ of solid\n   security.\n"
- title: 4.  Presentation Language
  contents:
  - "4.  Presentation Language\n   This document deals with the formatting of data\
    \ in an external\n   representation.  The following very basic and somewhat casually\n\
    \   defined presentation syntax will be used.  The syntax draws from\n   several\
    \ sources in its structure.  Although it resembles the\n   programming language\
    \ \"C\" in its syntax and XDR [XDR] in both its\n   syntax and intent, it would\
    \ be risky to draw too many parallels.  The\n   purpose of this presentation language\
    \ is to document TLS only; it has\n   no general application beyond that particular\
    \ goal.\n"
- title: 4.1.  Basic Block Size
  contents:
  - "4.1.  Basic Block Size\n   The representation of all data items is explicitly\
    \ specified.  The\n   basic data block size is one byte (i.e., 8 bits).  Multiple\
    \ byte data\n   items are concatenations of bytes, from left to right, from top\
    \ to\n   bottom.  From the byte stream, a multi-byte item (a numeric in the\n\
    \   example) is formed (using C notation) by:\n      value = (byte[0] << 8*(n-1))\
    \ | (byte[1] << 8*(n-2)) |\n              ... | byte[n-1];\n   This byte ordering\
    \ for multi-byte values is the commonplace network\n   byte order or big-endian\
    \ format.\n"
- title: 4.2.  Miscellaneous
  contents:
  - "4.2.  Miscellaneous\n   Comments begin with \"/*\" and end with \"*/\".\n   Optional\
    \ components are denoted by enclosing them in \"[[ ]]\" double\n   brackets.\n\
    \   Single-byte entities containing uninterpreted data are of type\n   opaque.\n"
- title: 4.3.  Vectors
  contents:
  - "4.3.  Vectors\n   A vector (single-dimensioned array) is a stream of homogeneous\
    \ data\n   elements.  The size of the vector may be specified at documentation\n\
    \   time or left unspecified until runtime.  In either case, the length\n   declares\
    \ the number of bytes, not the number of elements, in the\n   vector.  The syntax\
    \ for specifying a new type, T', that is a fixed-\n   length vector of type T\
    \ is\n      T T'[n];\n   Here, T' occupies n bytes in the data stream, where n\
    \ is a multiple\n   of the size of T.  The length of the vector is not included\
    \ in the\n   encoded stream.\n   In the following example, Datum is defined to\
    \ be three consecutive\n   bytes that the protocol does not interpret, while Data\
    \ is three\n   consecutive Datum, consuming a total of nine bytes.\n      opaque\
    \ Datum[3];      /* three uninterpreted bytes */\n      Datum Data[9];       \
    \ /* 3 consecutive 3 byte vectors */\n   Variable-length vectors are defined by\
    \ specifying a subrange of legal\n   lengths, inclusively, using the notation\
    \ <floor..ceiling>.  When\n   these are encoded, the actual length precedes the\
    \ vector's contents\n   in the byte stream.  The length will be in the form of\
    \ a number\n   consuming as many bytes as required to hold the vector's specified\n\
    \   maximum (ceiling) length.  A variable-length vector with an actual\n   length\
    \ field of zero is referred to as an empty vector.\n      T T'<floor..ceiling>;\n\
    \   In the following example, mandatory is a vector that must contain\n   between\
    \ 300 and 400 bytes of type opaque.  It can never be empty.\n   The actual length\
    \ field consumes two bytes, a uint16, which is\n   sufficient to represent the\
    \ value 400 (see Section 4.4).  On the\n   other hand, longer can represent up\
    \ to 800 bytes of data, or 400\n   uint16 elements, and it may be empty.  Its\
    \ encoding will include a\n   two-byte actual length field prepended to the vector.\
    \  The length of\n   an encoded vector must be an even multiple of the length\
    \ of a single\n   element (for example, a 17-byte vector of uint16 would be illegal).\n\
    \      opaque mandatory<300..400>;\n            /* length field is 2 bytes, cannot\
    \ be empty */\n      uint16 longer<0..800>;\n            /* zero to 400 16-bit\
    \ unsigned integers */\n"
- title: 4.4.  Numbers
  contents:
  - "4.4.  Numbers\n   The basic numeric data type is an unsigned byte (uint8).  All\
    \ larger\n   numeric data types are formed from fixed-length series of bytes\n\
    \   concatenated as described in Section 4.1 and are also unsigned.  The\n   following\
    \ numeric types are predefined.\n      uint8 uint16[2];\n      uint8 uint24[3];\n\
    \      uint8 uint32[4];\n      uint8 uint64[8];\n   All values, here and elsewhere\
    \ in the specification, are stored in\n   network byte (big-endian) order; the\
    \ uint32 represented by the hex\n   bytes 01 02 03 04 is equivalent to the decimal\
    \ value 16909060.\n   Note that in some cases (e.g., DH parameters) it is necessary\
    \ to\n   represent integers as opaque vectors.  In such cases, they are\n   represented\
    \ as unsigned integers (i.e., leading zero octets are not\n   required even if\
    \ the most significant bit is set).\n"
- title: 4.5.  Enumerateds
  contents:
  - "4.5.  Enumerateds\n   An additional sparse data type is available called enum.\
    \  A field of\n   type enum can only assume the values declared in the definition.\n\
    \   Each definition is a different type.  Only enumerateds of the same\n   type\
    \ may be assigned or compared.  Every element of an enumerated\n   must be assigned\
    \ a value, as demonstrated in the following example.\n   Since the elements of\
    \ the enumerated are not ordered, they can be\n   assigned any unique value, in\
    \ any order.\n      enum { e1(v1), e2(v2), ... , en(vn) [[, (n)]] } Te;\n   An\
    \ enumerated occupies as much space in the byte stream as would its\n   maximal\
    \ defined ordinal value.  The following definition would cause\n   one byte to\
    \ be used to carry fields of type Color.\n      enum { red(3), blue(5), white(7)\
    \ } Color;\n   One may optionally specify a value without its associated tag to\n\
    \   force the width definition without defining a superfluous element.\n   In\
    \ the following example, Taste will consume two bytes in the data\n   stream but\
    \ can only assume the values 1, 2, or 4.\n      enum { sweet(1), sour(2), bitter(4),\
    \ (32000) } Taste;\n   The names of the elements of an enumeration are scoped\
    \ within the\n   defined type.  In the first example, a fully qualified reference\
    \ to\n   the second element of the enumeration would be Color.blue.  Such\n  \
    \ qualification is not required if the target of the assignment is well\n   specified.\n\
    \      Color color = Color.blue;     /* overspecified, legal */\n      Color color\
    \ = blue;           /* correct, type implicit */\n   For enumerateds that are\
    \ never converted to external representation,\n   the numerical information may\
    \ be omitted.\n      enum { low, medium, high } Amount;\n"
- title: 4.6.  Constructed Types
  contents:
  - "4.6.  Constructed Types\n   Structure types may be constructed from primitive\
    \ types for\n   convenience.  Each specification declares a new, unique type.\
    \  The\n   syntax for definition is much like that of C.\n      struct {\n   \
    \       T1 f1;\n          T2 f2;\n          ...\n          Tn fn;\n      } [[T]];\n\
    \   The fields within a structure may be qualified using the type's name,\n  \
    \ with a syntax much like that available for enumerateds.  For example,\n   T.f2\
    \ refers to the second field of the previous declaration.\n   Structure definitions\
    \ may be embedded.\n"
- title: 4.6.1.  Variants
  contents:
  - "4.6.1.  Variants\n   Defined structures may have variants based on some knowledge\
    \ that is\n   available within the environment.  The selector must be an enumerated\n\
    \   type that defines the possible variants the structure defines.  There\n  \
    \ must be a case arm for every element of the enumeration declared in\n   the\
    \ select.  Case arms have limited fall-through: if two case arms\n   follow in\
    \ immediate succession with no fields in between, then they\n   both contain the\
    \ same fields.  Thus, in the example below, \"orange\"\n   and \"banana\" both\
    \ contain V2.  Note that this is a new piece of\n   syntax in TLS 1.2.\n   The\
    \ body of the variant structure may be given a label for reference.\n   The mechanism\
    \ by which the variant is selected at runtime is not\n   prescribed by the presentation\
    \ language.\n      struct {\n          T1 f1;\n          T2 f2;\n          ....\n\
    \          Tn fn;\n           select (E) {\n               case e1: Te1;\n   \
    \            case e2: Te2;\n               case e3: case e4: Te3;\n          \
    \     ....\n               case en: Ten;\n           } [[fv]];\n      } [[Tv]];\n\
    \   For example:\n      enum { apple, orange, banana } VariantTag;\n      struct\
    \ {\n          uint16 number;\n          opaque string<0..10>; /* variable length\
    \ */\n      } V1;\n      struct {\n          uint32 number;\n          opaque\
    \ string[10];    /* fixed length */\n      } V2;\n      struct {\n          select\
    \ (VariantTag) { /* value of selector is implicit */\n              case apple:\n\
    \                V1;   /* VariantBody, tag = apple */\n              case orange:\n\
    \              case banana:\n                V2;   /* VariantBody, tag = orange\
    \ or banana */\n          } variant_body;       /* optional label on variant */\n\
    \      } VariantRecord;\n"
- title: 4.7.  Cryptographic Attributes
  contents:
  - "4.7.  Cryptographic Attributes\n   The five cryptographic operations -- digital\
    \ signing, stream cipher\n   encryption, block cipher encryption, authenticated\
    \ encryption with\n   additional data (AEAD) encryption, and public key encryption\
    \ -- are\n   designated digitally-signed, stream-ciphered, block-ciphered, aead-\n\
    \   ciphered, and public-key-encrypted, respectively.  A field's\n   cryptographic\
    \ processing is specified by prepending an appropriate\n   key word designation\
    \ before the field's type specification.\n   Cryptographic keys are implied by\
    \ the current session state (see\n   Section 6.1).\n   A digitally-signed element\
    \ is encoded as a struct DigitallySigned:\n      struct {\n         SignatureAndHashAlgorithm\
    \ algorithm;\n         opaque signature<0..2^16-1>;\n      } DigitallySigned;\n\
    \   The algorithm field specifies the algorithm used (see Section\n   7.4.1.4.1\
    \ for the definition of this field).  Note that the\n   introduction of the algorithm\
    \ field is a change from previous\n   versions.  The signature is a digital signature\
    \ using those\n   algorithms over the contents of the element.  The contents themselves\n\
    \   do not appear on the wire but are simply calculated.  The length of\n   the\
    \ signature is specified by the signing algorithm and key.\n   In RSA signing,\
    \ the opaque vector contains the signature generated\n   using the RSASSA-PKCS1-v1_5\
    \ signature scheme defined in [PKCS1].  As\n   discussed in [PKCS1], the DigestInfo\
    \ MUST be DER-encoded [X680]\n   [X690].  For hash algorithms without parameters\
    \ (which includes\n   SHA-1), the DigestInfo.AlgorithmIdentifier.parameters field\
    \ MUST be\n   NULL, but implementations MUST accept both without parameters and\n\
    \   with NULL parameters.  Note that earlier versions of TLS used a\n   different\
    \ RSA signature scheme that did not include a DigestInfo\n   encoding.\n   In\
    \ DSA, the 20 bytes of the SHA-1 hash are run directly through the\n   Digital\
    \ Signing Algorithm with no additional hashing.  This produces\n   two values,\
    \ r and s.  The DSA signature is an opaque vector, as\n   above, the contents\
    \ of which are the DER encoding of:\n      Dss-Sig-Value ::= SEQUENCE {\n    \
    \      r INTEGER,\n          s INTEGER\n      }\n   Note: In current terminology,\
    \ DSA refers to the Digital Signature\n   Algorithm and DSS refers to the NIST\
    \ standard.  In the original SSL\n   and TLS specs, \"DSS\" was used universally.\
    \  This document uses \"DSA\"\n   to refer to the algorithm, \"DSS\" to refer\
    \ to the standard, and it\n   uses \"DSS\" in the code point definitions for historical\
    \ continuity.\n   In stream cipher encryption, the plaintext is exclusive-ORed\
    \ with an\n   identical amount of output generated from a cryptographically secure\n\
    \   keyed pseudorandom number generator.\n   In block cipher encryption, every\
    \ block of plaintext encrypts to a\n   block of ciphertext.  All block cipher\
    \ encryption is done in CBC\n   (Cipher Block Chaining) mode, and all items that\
    \ are block-ciphered\n   will be an exact multiple of the cipher block length.\n\
    \   In AEAD encryption, the plaintext is simultaneously encrypted and\n   integrity\
    \ protected.  The input may be of any length, and aead-\n   ciphered output is\
    \ generally larger than the input in order to\n   accommodate the integrity check\
    \ value.\n   In public key encryption, a public key algorithm is used to encrypt\n\
    \   data in such a way that it can be decrypted only with the matching\n   private\
    \ key.  A public-key-encrypted element is encoded as an opaque\n   vector <0..2^16-1>,\
    \ where the length is specified by the encryption\n   algorithm and key.\n   RSA\
    \ encryption is done using the RSAES-PKCS1-v1_5 encryption scheme\n   defined\
    \ in [PKCS1].\n   In the following example\n      stream-ciphered struct {\n \
    \         uint8 field1;\n          uint8 field2;\n          digitally-signed opaque\
    \ {\n            uint8 field3<0..255>;\n            uint8 field4;\n          };\n\
    \      } UserType;\n   The contents of the inner struct (field3 and field4) are\
    \ used as\n   input for the signature/hash algorithm, and then the entire structure\n\
    \   is encrypted with a stream cipher.  The length of this structure, in\n   bytes,\
    \ would be equal to two bytes for field1 and field2, plus two\n   bytes for the\
    \ signature and hash algorithm, plus two bytes for the\n   length of the signature,\
    \ plus the length of the output of the signing\n   algorithm.  The length of the\
    \ signature is known because the\n   algorithm and key used for the signing are\
    \ known prior to encoding or\n   decoding this structure.\n"
- title: 4.8.  Constants
  contents:
  - "4.8.  Constants\n   Typed constants can be defined for purposes of specification\
    \ by\n   declaring a symbol of the desired type and assigning values to it.\n\
    \   Under-specified types (opaque, variable-length vectors, and\n   structures\
    \ that contain opaque) cannot be assigned values.  No fields\n   of a multi-element\
    \ structure or vector may be elided.\n   For example:\n      struct {\n      \
    \    uint8 f1;\n          uint8 f2;\n      } Example1;\n      Example1 ex1 = {1,\
    \ 4};  /* assigns f1 = 1, f2 = 4 */\n"
- title: 5.  HMAC and the Pseudorandom Function
  contents:
  - "5.  HMAC and the Pseudorandom Function\n   The TLS record layer uses a keyed\
    \ Message Authentication Code (MAC)\n   to protect message integrity.  The cipher\
    \ suites defined in this\n   document use a construction known as HMAC, described\
    \ in [HMAC], which\n   is based on a hash function.  Other cipher suites MAY define\
    \ their\n   own MAC constructions, if needed.\n   In addition, a construction\
    \ is required to do expansion of secrets\n   into blocks of data for the purposes\
    \ of key generation or validation.\n   This pseudorandom function (PRF) takes\
    \ as input a secret, a seed, and\n   an identifying label and produces an output\
    \ of arbitrary length.\n   In this section, we define one PRF, based on HMAC.\
    \  This PRF with the\n   SHA-256 hash function is used for all cipher suites defined\
    \ in this\n   document and in TLS documents published prior to this document when\n\
    \   TLS 1.2 is negotiated.  New cipher suites MUST explicitly specify a\n   PRF\
    \ and, in general, SHOULD use the TLS PRF with SHA-256 or a\n   stronger standard\
    \ hash function.\n   First, we define a data expansion function, P_hash(secret,\
    \ data),\n   that uses a single hash function to expand a secret and seed into\
    \ an\n   arbitrary quantity of output:\n      P_hash(secret, seed) = HMAC_hash(secret,\
    \ A(1) + seed) +\n                             HMAC_hash(secret, A(2) + seed)\
    \ +\n                             HMAC_hash(secret, A(3) + seed) + ...\n   where\
    \ + indicates concatenation.\n   A() is defined as:\n      A(0) = seed\n     \
    \ A(i) = HMAC_hash(secret, A(i-1))\n   P_hash can be iterated as many times as\
    \ necessary to produce the\n   required quantity of data.  For example, if P_SHA256\
    \ is being used to\n   create 80 bytes of data, it will have to be iterated three\
    \ times\n   (through A(3)), creating 96 bytes of output data; the last 16 bytes\n\
    \   of the final iteration will then be discarded, leaving 80 bytes of\n   output\
    \ data.\n   TLS's PRF is created by applying P_hash to the secret as:\n      PRF(secret,\
    \ label, seed) = P_<hash>(secret, label + seed)\n   The label is an ASCII string.\
    \  It should be included in the exact\n   form it is given without a length byte\
    \ or trailing null character.\n   For example, the label \"slithy toves\" would\
    \ be processed by hashing\n   the following bytes:\n      73 6C 69 74 68 79 20\
    \ 74 6F 76 65 73\n"
- title: 6.  The TLS Record Protocol
  contents:
  - "6.  The TLS Record Protocol\n   The TLS Record Protocol is a layered protocol.\
    \  At each layer,\n   messages may include fields for length, description, and\
    \ content.\n   The Record Protocol takes messages to be transmitted, fragments\
    \ the\n   data into manageable blocks, optionally compresses the data, applies\n\
    \   a MAC, encrypts, and transmits the result.  Received data is\n   decrypted,\
    \ verified, decompressed, reassembled, and then delivered to\n   higher-level\
    \ clients.\n   Four protocols that use the record protocol are described in this\n\
    \   document: the handshake protocol, the alert protocol, the change\n   cipher\
    \ spec protocol, and the application data protocol.  In order to\n   allow extension\
    \ of the TLS protocol, additional record content types\n   can be supported by\
    \ the record protocol.  New record content type\n   values are assigned by IANA\
    \ in the TLS Content Type Registry as\n   described in Section 12.\n   Implementations\
    \ MUST NOT send record types not defined in this\n   document unless negotiated\
    \ by some extension.  If a TLS\n   implementation receives an unexpected record\
    \ type, it MUST send an\n   unexpected_message alert.\n   Any protocol designed\
    \ for use over TLS must be carefully designed to\n   deal with all possible attacks\
    \ against it.  As a practical matter,\n   this means that the protocol designer\
    \ must be aware of what security\n   properties TLS does and does not provide\
    \ and cannot safely rely on\n   the latter.\n   Note in particular that type and\
    \ length of a record are not protected\n   by encryption.  If this information\
    \ is itself sensitive, application\n   designers may wish to take steps (padding,\
    \ cover traffic) to minimize\n   information leakage.\n"
- title: 6.1.  Connection States
  contents:
  - "6.1.  Connection States\n   A TLS connection state is the operating environment\
    \ of the TLS Record\n   Protocol.  It specifies a compression algorithm, an encryption\n\
    \   algorithm, and a MAC algorithm.  In addition, the parameters for\n   these\
    \ algorithms are known: the MAC key and the bulk encryption keys\n   for the connection\
    \ in both the read and the write directions.\n   Logically, there are always four\
    \ connection states outstanding: the\n   current read and write states, and the\
    \ pending read and write states.\n   All records are processed under the current\
    \ read and write states.\n   The security parameters for the pending states can\
    \ be set by the TLS\n   Handshake Protocol, and the ChangeCipherSpec can selectively\
    \ make\n   either of the pending states current, in which case the appropriate\n\
    \   current state is disposed of and replaced with the pending state; the\n  \
    \ pending state is then reinitialized to an empty state.  It is illegal\n   to\
    \ make a state that has not been initialized with security\n   parameters a current\
    \ state.  The initial current state always\n   specifies that no encryption, compression,\
    \ or MAC will be used.\n   The security parameters for a TLS Connection read and\
    \ write state are\n   set by providing the following values:\n   connection end\n\
    \      Whether this entity is considered the \"client\" or the \"server\" in\n\
    \      this connection.\n   PRF algorithm\n      An algorithm used to generate\
    \ keys from the master secret (see\n      Sections 5 and 6.3).\n   bulk encryption\
    \ algorithm\n      An algorithm to be used for bulk encryption.  This specification\n\
    \      includes the key size of this algorithm, whether it is a block,\n     \
    \ stream, or AEAD cipher, the block size of the cipher (if\n      appropriate),\
    \ and the lengths of explicit and implicit\n      initialization vectors (or nonces).\n\
    \   MAC algorithm\n      An algorithm to be used for message authentication. \
    \ This\n      specification includes the size of the value returned by the MAC\n\
    \      algorithm.\n   compression algorithm\n      An algorithm to be used for\
    \ data compression.  This specification\n      must include all information the\
    \ algorithm requires to do\n      compression.\n   master secret\n      A 48-byte\
    \ secret shared between the two peers in the connection.\n   client random\n \
    \     A 32-byte value provided by the client.\n   server random\n      A 32-byte\
    \ value provided by the server.\n      These parameters are defined in the presentation\
    \ language as:\n      enum { server, client } ConnectionEnd;\n      enum { tls_prf_sha256\
    \ } PRFAlgorithm;\n      enum { null, rc4, 3des, aes }\n        BulkCipherAlgorithm;\n\
    \      enum { stream, block, aead } CipherType;\n      enum { null, hmac_md5,\
    \ hmac_sha1, hmac_sha256,\n           hmac_sha384, hmac_sha512} MACAlgorithm;\n\
    \      enum { null(0), (255) } CompressionMethod;\n      /* The algorithms specified\
    \ in CompressionMethod, PRFAlgorithm,\n         BulkCipherAlgorithm, and MACAlgorithm\
    \ may be added to. */\n      struct {\n          ConnectionEnd          entity;\n\
    \          PRFAlgorithm           prf_algorithm;\n          BulkCipherAlgorithm\
    \    bulk_cipher_algorithm;\n          CipherType             cipher_type;\n \
    \         uint8                  enc_key_length;\n          uint8            \
    \      block_length;\n          uint8                  fixed_iv_length;\n    \
    \      uint8                  record_iv_length;\n          MACAlgorithm      \
    \     mac_algorithm;\n          uint8                  mac_length;\n         \
    \ uint8                  mac_key_length;\n          CompressionMethod      compression_algorithm;\n\
    \          opaque                 master_secret[48];\n          opaque       \
    \          client_random[32];\n          opaque                 server_random[32];\n\
    \      } SecurityParameters;\n   The record layer will use the security parameters\
    \ to generate the\n   following six items (some of which are not required by all\
    \ ciphers,\n   and are thus empty):\n      client write MAC key\n      server\
    \ write MAC key\n      client write encryption key\n      server write encryption\
    \ key\n      client write IV\n      server write IV\n   The client write parameters\
    \ are used by the server when receiving and\n   processing records and vice versa.\
    \  The algorithm used for generating\n   these items from the security parameters\
    \ is described in Section 6.3.\n   Once the security parameters have been set\
    \ and the keys have been\n   generated, the connection states can be instantiated\
    \ by making them\n   the current states.  These current states MUST be updated\
    \ for each\n   record processed.  Each connection state includes the following\n\
    \   elements:\n   compression state\n      The current state of the compression\
    \ algorithm.\n   cipher state\n      The current state of the encryption algorithm.\
    \  This will consist\n      of the scheduled key for that connection.  For stream\
    \ ciphers,\n      this will also contain whatever state information is necessary\
    \ to\n      allow the stream to continue to encrypt or decrypt data.\n   MAC key\n\
    \      The MAC key for this connection, as generated above.\n   sequence number\n\
    \      Each connection state contains a sequence number, which is\n      maintained\
    \ separately for read and write states.  The sequence\n      number MUST be set\
    \ to zero whenever a connection state is made the\n      active state.  Sequence\
    \ numbers are of type uint64 and may not\n      exceed 2^64-1.  Sequence numbers\
    \ do not wrap.  If a TLS\n      implementation would need to wrap a sequence number,\
    \ it must\n      renegotiate instead.  A sequence number is incremented after\
    \ each\n      record: specifically, the first record transmitted under a\n   \
    \   particular connection state MUST use sequence number 0.\n"
- title: 6.2.  Record Layer
  contents:
  - "6.2.  Record Layer\n   The TLS record layer receives uninterpreted data from\
    \ higher layers\n   in non-empty blocks of arbitrary size.\n"
- title: 6.2.1.  Fragmentation
  contents:
  - "6.2.1.  Fragmentation\n   The record layer fragments information blocks into\
    \ TLSPlaintext\n   records carrying data in chunks of 2^14 bytes or less.  Client\n\
    \   message boundaries are not preserved in the record layer (i.e.,\n   multiple\
    \ client messages of the same ContentType MAY be coalesced\n   into a single TLSPlaintext\
    \ record, or a single message MAY be\n   fragmented across several records).\n\
    \      struct {\n          uint8 major;\n          uint8 minor;\n      } ProtocolVersion;\n\
    \      enum {\n          change_cipher_spec(20), alert(21), handshake(22),\n \
    \         application_data(23), (255)\n      } ContentType;\n      struct {\n\
    \          ContentType type;\n          ProtocolVersion version;\n          uint16\
    \ length;\n          opaque fragment[TLSPlaintext.length];\n      } TLSPlaintext;\n\
    \   type\n      The higher-level protocol used to process the enclosed fragment.\n\
    \   version\n      The version of the protocol being employed.  This document\n\
    \      describes TLS Version 1.2, which uses the version { 3, 3 }.  The\n    \
    \  version value 3.3 is historical, deriving from the use of {3, 1}\n      for\
    \ TLS 1.0.  (See Appendix A.1.)  Note that a client that\n      supports multiple\
    \ versions of TLS may not know what version will\n      be employed before it\
    \ receives the ServerHello.  See Appendix E\n      for discussion about what record\
    \ layer version number should be\n      employed for ClientHello.\n   length\n\
    \      The length (in bytes) of the following TLSPlaintext.fragment.  The\n  \
    \    length MUST NOT exceed 2^14.\n   fragment\n      The application data.  This\
    \ data is transparent and treated as an\n      independent block to be dealt with\
    \ by the higher-level protocol\n      specified by the type field.\n   Implementations\
    \ MUST NOT send zero-length fragments of Handshake,\n   Alert, or ChangeCipherSpec\
    \ content types.  Zero-length fragments of\n   Application data MAY be sent as\
    \ they are potentially useful as a\n   traffic analysis countermeasure.\n   Note:\
    \ Data of different TLS record layer content types MAY be\n   interleaved.  Application\
    \ data is generally of lower precedence for\n   transmission than other content\
    \ types.  However, records MUST be\n   delivered to the network in the same order\
    \ as they are protected by\n   the record layer.  Recipients MUST receive and\
    \ process interleaved\n   application layer traffic during handshakes subsequent\
    \ to the first\n   one on a connection.\n"
- title: 6.2.2.  Record Compression and Decompression
  contents:
  - "6.2.2.  Record Compression and Decompression\n   All records are compressed using\
    \ the compression algorithm defined in\n   the current session state.  There is\
    \ always an active compression\n   algorithm; however, initially it is defined\
    \ as\n   CompressionMethod.null.  The compression algorithm translates a\n   TLSPlaintext\
    \ structure into a TLSCompressed structure.  Compression\n   functions are initialized\
    \ with default state information whenever a\n   connection state is made active.\
    \  [RFC3749] describes compression\n   algorithms for TLS.\n   Compression must\
    \ be lossless and may not increase the content length\n   by more than 1024 bytes.\
    \  If the decompression function encounters a\n   TLSCompressed.fragment that\
    \ would decompress to a length in excess of\n   2^14 bytes, it MUST report a fatal\
    \ decompression failure error.\n      struct {\n          ContentType type;  \
    \     /* same as TLSPlaintext.type */\n          ProtocolVersion version;/* same\
    \ as TLSPlaintext.version */\n          uint16 length;\n          opaque fragment[TLSCompressed.length];\n\
    \      } TLSCompressed;\n   length\n      The length (in bytes) of the following\
    \ TLSCompressed.fragment.\n      The length MUST NOT exceed 2^14 + 1024.\n   fragment\n\
    \      The compressed form of TLSPlaintext.fragment.\n      Note: A CompressionMethod.null\
    \ operation is an identity operation;\n      no fields are altered.\n      Implementation\
    \ note: Decompression functions are responsible for\n      ensuring that messages\
    \ cannot cause internal buffer overflows.\n"
- title: 6.2.3.  Record Payload Protection
  contents:
  - "6.2.3.  Record Payload Protection\n      The encryption and MAC functions translate\
    \ a TLSCompressed\n      structure into a TLSCiphertext.  The decryption functions\
    \ reverse\n      the process.  The MAC of the record also includes a sequence\n\
    \      number so that missing, extra, or repeated messages are\n      detectable.\n\
    \      struct {\n          ContentType type;\n          ProtocolVersion version;\n\
    \          uint16 length;\n          select (SecurityParameters.cipher_type) {\n\
    \              case stream: GenericStreamCipher;\n              case block:  GenericBlockCipher;\n\
    \              case aead:   GenericAEADCipher;\n          } fragment;\n      }\
    \ TLSCiphertext;\n   type\n      The type field is identical to TLSCompressed.type.\n\
    \   version\n      The version field is identical to TLSCompressed.version.\n\
    \   length\n      The length (in bytes) of the following TLSCiphertext.fragment.\n\
    \      The length MUST NOT exceed 2^14 + 2048.\n   fragment\n      The encrypted\
    \ form of TLSCompressed.fragment, with the MAC.\n"
- title: 6.2.3.1.  Null or Standard Stream Cipher
  contents:
  - "6.2.3.1.  Null or Standard Stream Cipher\n   Stream ciphers (including BulkCipherAlgorithm.null;\
    \ see Appendix A.6)\n   convert TLSCompressed.fragment structures to and from\
    \ stream\n   TLSCiphertext.fragment structures.\n      stream-ciphered struct\
    \ {\n          opaque content[TLSCompressed.length];\n          opaque MAC[SecurityParameters.mac_length];\n\
    \      } GenericStreamCipher;\n   The MAC is generated as:\n      MAC(MAC_write_key,\
    \ seq_num +\n                            TLSCompressed.type +\n              \
    \              TLSCompressed.version +\n                            TLSCompressed.length\
    \ +\n                            TLSCompressed.fragment);\n   where \"+\" denotes\
    \ concatenation.\n   seq_num\n      The sequence number for this record.\n   MAC\n\
    \      The MAC algorithm specified by SecurityParameters.mac_algorithm.\n   Note\
    \ that the MAC is computed before encryption.  The stream cipher\n   encrypts\
    \ the entire block, including the MAC.  For stream ciphers\n   that do not use\
    \ a synchronization vector (such as RC4), the stream\n   cipher state from the\
    \ end of one record is simply used on the\n   subsequent packet.  If the cipher\
    \ suite is TLS_NULL_WITH_NULL_NULL,\n   encryption consists of the identity operation\
    \ (i.e., the data is not\n   encrypted, and the MAC size is zero, implying that\
    \ no MAC is used).\n   For both null and stream ciphers, TLSCiphertext.length\
    \ is\n   TLSCompressed.length plus SecurityParameters.mac_length.\n"
- title: 6.2.3.2.  CBC Block Cipher
  contents:
  - "6.2.3.2.  CBC Block Cipher\n   For block ciphers (such as 3DES or AES), the encryption\
    \ and MAC\n   functions convert TLSCompressed.fragment structures to and from\
    \ block\n   TLSCiphertext.fragment structures.\n      struct {\n          opaque\
    \ IV[SecurityParameters.record_iv_length];\n          block-ciphered struct {\n\
    \              opaque content[TLSCompressed.length];\n              opaque MAC[SecurityParameters.mac_length];\n\
    \              uint8 padding[GenericBlockCipher.padding_length];\n           \
    \   uint8 padding_length;\n          };\n      } GenericBlockCipher;\n   The MAC\
    \ is generated as described in Section 6.2.3.1.\n   IV\n      The Initialization\
    \ Vector (IV) SHOULD be chosen at random, and\n      MUST be unpredictable.  Note\
    \ that in versions of TLS prior to 1.1,\n      there was no IV field, and the\
    \ last ciphertext block of the\n      previous record (the \"CBC residue\") was\
    \ used as the IV.  This was\n      changed to prevent the attacks described in\
    \ [CBCATT].  For block\n      ciphers, the IV length is of length\n      SecurityParameters.record_iv_length,\
    \ which is equal to the\n      SecurityParameters.block_size.\n   padding\n  \
    \    Padding that is added to force the length of the plaintext to be\n      an\
    \ integral multiple of the block cipher's block length.  The\n      padding MAY\
    \ be any length up to 255 bytes, as long as it results\n      in the TLSCiphertext.length\
    \ being an integral multiple of the\n      block length.  Lengths longer than\
    \ necessary might be desirable to\n      frustrate attacks on a protocol that\
    \ are based on analysis of the\n      lengths of exchanged messages.  Each uint8\
    \ in the padding data\n      vector MUST be filled with the padding length value.\
    \  The receiver\n      MUST check this padding and MUST use the bad_record_mac\
    \ alert to\n      indicate padding errors.\n   padding_length\n      The padding\
    \ length MUST be such that the total size of the\n      GenericBlockCipher structure\
    \ is a multiple of the cipher's block\n      length.  Legal values range from\
    \ zero to 255, inclusive.  This\n      length specifies the length of the padding\
    \ field exclusive of the\n      padding_length field itself.\n   The encrypted\
    \ data length (TLSCiphertext.length) is one more than the\n   sum of SecurityParameters.block_length,\
    \ TLSCompressed.length,\n   SecurityParameters.mac_length, and padding_length.\n\
    \   Example: If the block length is 8 bytes, the content length\n   (TLSCompressed.length)\
    \ is 61 bytes, and the MAC length is 20 bytes,\n   then the length before padding\
    \ is 82 bytes (this does not include the\n   IV.  Thus, the padding length modulo\
    \ 8 must be equal to 6 in order to\n   make the total length an even multiple\
    \ of 8 bytes (the block length).\n   The padding length can be 6, 14, 22, and\
    \ so on, through 254.  If the\n   padding length were the minimum necessary, 6,\
    \ the padding would be 6\n   bytes, each containing the value 6.  Thus, the last\
    \ 8 octets of the\n   GenericBlockCipher before block encryption would be xx 06\
    \ 06 06 06 06\n   06 06, where xx is the last octet of the MAC.\n   Note: With\
    \ block ciphers in CBC mode (Cipher Block Chaining), it is\n   critical that the\
    \ entire plaintext of the record be known before any\n   ciphertext is transmitted.\
    \  Otherwise, it is possible for the\n   attacker to mount the attack described\
    \ in [CBCATT].\n   Implementation note: Canvel et al. [CBCTIME] have demonstrated\
    \ a\n   timing attack on CBC padding based on the time required to compute\n \
    \  the MAC.  In order to defend against this attack, implementations\n   MUST\
    \ ensure that record processing time is essentially the same\n   whether or not\
    \ the padding is correct.  In general, the best way to\n   do this is to compute\
    \ the MAC even if the padding is incorrect, and\n   only then reject the packet.\
    \  For instance, if the pad appears to be\n   incorrect, the implementation might\
    \ assume a zero-length pad and then\n   compute the MAC.  This leaves a small\
    \ timing channel, since MAC\n   performance depends to some extent on the size\
    \ of the data fragment,\n   but it is not believed to be large enough to be exploitable,\
    \ due to\n   the large block size of existing MACs and the small size of the\n\
    \   timing signal.\n"
- title: 6.2.3.3.  AEAD Ciphers
  contents:
  - "6.2.3.3.  AEAD Ciphers\n   For AEAD [AEAD] ciphers (such as [CCM] or [GCM]),\
    \ the AEAD function\n   converts TLSCompressed.fragment structures to and from\
    \ AEAD\n   TLSCiphertext.fragment structures.\n      struct {\n         opaque\
    \ nonce_explicit[SecurityParameters.record_iv_length];\n         aead-ciphered\
    \ struct {\n             opaque content[TLSCompressed.length];\n         };\n\
    \      } GenericAEADCipher;\n   AEAD ciphers take as input a single key, a nonce,\
    \ a plaintext, and\n   \"additional data\" to be included in the authentication\
    \ check, as\n   described in Section 2.1 of [AEAD].  The key is either the\n \
    \  client_write_key or the server_write_key.  No MAC key is used.\n   Each AEAD\
    \ cipher suite MUST specify how the nonce supplied to the\n   AEAD operation is\
    \ constructed, and what is the length of the\n   GenericAEADCipher.nonce_explicit\
    \ part.  In many cases, it is\n   appropriate to use the partially implicit nonce\
    \ technique described\n   in Section 3.2.1 of [AEAD]; with record_iv_length being\
    \ the length of\n   the explicit part.  In this case, the implicit part SHOULD\
    \ be derived\n   from key_block as client_write_iv and server_write_iv (as described\n\
    \   in Section 6.3), and the explicit part is included in\n   GenericAEAEDCipher.nonce_explicit.\n\
    \   The plaintext is the TLSCompressed.fragment.\n   The additional authenticated\
    \ data, which we denote as\n   additional_data, is defined as follows:\n     \
    \ additional_data = seq_num + TLSCompressed.type +\n                        TLSCompressed.version\
    \ + TLSCompressed.length;\n   where \"+\" denotes concatenation.\n   The aead_output\
    \ consists of the ciphertext output by the AEAD\n   encryption operation.  The\
    \ length will generally be larger than\n   TLSCompressed.length, but by an amount\
    \ that varies with the AEAD\n   cipher.  Since the ciphers might incorporate padding,\
    \ the amount of\n   overhead could vary with different TLSCompressed.length values.\
    \  Each\n   AEAD cipher MUST NOT produce an expansion of greater than 1024 bytes.\n\
    \   Symbolically,\n      AEADEncrypted = AEAD-Encrypt(write_key, nonce, plaintext,\n\
    \                                   additional_data)\n   In order to decrypt and\
    \ verify, the cipher takes as input the key,\n   nonce, the \"additional_data\"\
    , and the AEADEncrypted value.  The\n   output is either the plaintext or an error\
    \ indicating that the\n   decryption failed.  There is no separate integrity check.\
    \  That is:\n      TLSCompressed.fragment = AEAD-Decrypt(write_key, nonce,\n \
    \                                           AEADEncrypted,\n                 \
    \                           additional_data)\n   If the decryption fails, a fatal\
    \ bad_record_mac alert MUST be\n   generated.\n"
- title: 6.3.  Key Calculation
  contents:
  - "6.3.  Key Calculation\n   The Record Protocol requires an algorithm to generate\
    \ keys required\n   by the current connection state (see Appendix A.6) from the\
    \ security\n   parameters provided by the handshake protocol.\n   The master secret\
    \ is expanded into a sequence of secure bytes, which\n   is then split to a client\
    \ write MAC key, a server write MAC key, a\n   client write encryption key, and\
    \ a server write encryption key.  Each\n   of these is generated from the byte\
    \ sequence in that order.  Unused\n   values are empty.  Some AEAD ciphers may\
    \ additionally require a\n   client write IV and a server write IV (see Section\
    \ 6.2.3.3).\n   When keys and MAC keys are generated, the master secret is used\
    \ as an\n   entropy source.\n   To generate the key material, compute\n      key_block\
    \ = PRF(SecurityParameters.master_secret,\n                      \"key expansion\"\
    ,\n                      SecurityParameters.server_random +\n                \
    \      SecurityParameters.client_random);\n   until enough output has been generated.\
    \  Then, the key_block is\n   partitioned as follows:\n      client_write_MAC_key[SecurityParameters.mac_key_length]\n\
    \      server_write_MAC_key[SecurityParameters.mac_key_length]\n      client_write_key[SecurityParameters.enc_key_length]\n\
    \      server_write_key[SecurityParameters.enc_key_length]\n      client_write_IV[SecurityParameters.fixed_iv_length]\n\
    \      server_write_IV[SecurityParameters.fixed_iv_length]\n   Currently, the\
    \ client_write_IV and server_write_IV are only generated\n   for implicit nonce\
    \ techniques as described in Section 3.2.1 of\n   [AEAD].\n   Implementation note:\
    \ The currently defined cipher suite which\n   requires the most material is AES_256_CBC_SHA256.\
    \  It requires 2 x 32\n   byte keys and 2 x 32 byte MAC keys, for a total 128\
    \ bytes of key\n   material.\n"
- title: 7.  The TLS Handshaking Protocols
  contents:
  - "7.  The TLS Handshaking Protocols\n   TLS has three subprotocols that are used\
    \ to allow peers to agree upon\n   security parameters for the record layer, to\
    \ authenticate themselves,\n   to instantiate negotiated security parameters,\
    \ and to report error\n   conditions to each other.\n   The Handshake Protocol\
    \ is responsible for negotiating a session,\n   which consists of the following\
    \ items:\n   session identifier\n      An arbitrary byte sequence chosen by the\
    \ server to identify an\n      active or resumable session state.\n   peer certificate\n\
    \      X509v3 [PKIX] certificate of the peer.  This element of the state\n   \
    \   may be null.\n   compression method\n      The algorithm used to compress\
    \ data prior to encryption.\n   cipher spec\n      Specifies the pseudorandom\
    \ function (PRF) used to generate keying\n      material, the bulk data encryption\
    \ algorithm (such as null, AES,\n      etc.) and the MAC algorithm (such as HMAC-SHA1).\
    \  It also defines\n      cryptographic attributes such as the mac_length.  (See\
    \ Appendix\n      A.6 for formal definition.)\n   master secret\n      48-byte\
    \ secret shared between the client and server.\n   is resumable\n      A flag\
    \ indicating whether the session can be used to initiate new\n      connections.\n\
    \   These items are then used to create security parameters for use by\n   the\
    \ record layer when protecting application data.  Many connections\n   can be\
    \ instantiated using the same session through the resumption\n   feature of the\
    \ TLS Handshake Protocol.\n"
- title: 7.1.  Change Cipher Spec Protocol
  contents:
  - "7.1.  Change Cipher Spec Protocol\n   The change cipher spec protocol exists\
    \ to signal transitions in\n   ciphering strategies.  The protocol consists of\
    \ a single message,\n   which is encrypted and compressed under the current (not\
    \ the pending)\n   connection state.  The message consists of a single byte of\
    \ value 1.\n      struct {\n          enum { change_cipher_spec(1), (255) } type;\n\
    \      } ChangeCipherSpec;\n   The ChangeCipherSpec message is sent by both the\
    \ client and the\n   server to notify the receiving party that subsequent records\
    \ will be\n   protected under the newly negotiated CipherSpec and keys.  Reception\n\
    \   of this message causes the receiver to instruct the record layer to\n   immediately\
    \ copy the read pending state into the read current state.\n   Immediately after\
    \ sending this message, the sender MUST instruct the\n   record layer to make\
    \ the write pending state the write active state.\n   (See Section 6.1.)  The\
    \ ChangeCipherSpec message is sent during the\n   handshake after the security\
    \ parameters have been agreed upon, but\n   before the verifying Finished message\
    \ is sent.\n   Note: If a rehandshake occurs while data is flowing on a connection,\n\
    \   the communicating parties may continue to send data using the old\n   CipherSpec.\
    \  However, once the ChangeCipherSpec has been sent, the\n   new CipherSpec MUST\
    \ be used.  The first side to send the\n   ChangeCipherSpec does not know that\
    \ the other side has finished\n   computing the new keying material (e.g., if\
    \ it has to perform a\n   time-consuming public key operation).  Thus, a small\
    \ window of time,\n   during which the recipient must buffer the data, MAY exist.\
    \  In\n   practice, with modern machines this interval is likely to be fairly\n\
    \   short.\n"
- title: 7.2.  Alert Protocol
  contents:
  - "7.2.  Alert Protocol\n   One of the content types supported by the TLS record\
    \ layer is the\n   alert type.  Alert messages convey the severity of the message\n\
    \   (warning or fatal) and a description of the alert.  Alert messages\n   with\
    \ a level of fatal result in the immediate termination of the\n   connection.\
    \  In this case, other connections corresponding to the\n   session may continue,\
    \ but the session identifier MUST be invalidated,\n   preventing the failed session\
    \ from being used to establish new\n   connections.  Like other messages, alert\
    \ messages are encrypted and\n   compressed, as specified by the current connection\
    \ state.\n      enum { warning(1), fatal(2), (255) } AlertLevel;\n      enum {\n\
    \          close_notify(0),\n          unexpected_message(10),\n          bad_record_mac(20),\n\
    \          decryption_failed_RESERVED(21),\n          record_overflow(22),\n \
    \         decompression_failure(30),\n          handshake_failure(40),\n     \
    \     no_certificate_RESERVED(41),\n          bad_certificate(42),\n         \
    \ unsupported_certificate(43),\n          certificate_revoked(44),\n         \
    \ certificate_expired(45),\n          certificate_unknown(46),\n          illegal_parameter(47),\n\
    \          unknown_ca(48),\n          access_denied(49),\n          decode_error(50),\n\
    \          decrypt_error(51),\n          export_restriction_RESERVED(60),\n  \
    \        protocol_version(70),\n          insufficient_security(71),\n       \
    \   internal_error(80),\n          user_canceled(90),\n          no_renegotiation(100),\n\
    \          unsupported_extension(110),\n          (255)\n      } AlertDescription;\n\
    \      struct {\n          AlertLevel level;\n          AlertDescription description;\n\
    \      } Alert;\n"
- title: 7.2.1.  Closure Alerts
  contents:
  - "7.2.1.  Closure Alerts\n   The client and the server must share knowledge that\
    \ the connection is\n   ending in order to avoid a truncation attack.  Either\
    \ party may\n   initiate the exchange of closing messages.\n   close_notify\n\
    \      This message notifies the recipient that the sender will not send\n   \
    \   any more messages on this connection.  Note that as of TLS 1.1,\n      failure\
    \ to properly close a connection no longer requires that a\n      session not\
    \ be resumed.  This is a change from TLS 1.0 to conform\n      with widespread\
    \ implementation practice.\n   Either party may initiate a close by sending a\
    \ close_notify alert.\n   Any data received after a closure alert is ignored.\n\
    \   Unless some other fatal alert has been transmitted, each party is\n   required\
    \ to send a close_notify alert before closing the write side\n   of the connection.\
    \  The other party MUST respond with a close_notify\n   alert of its own and close\
    \ down the connection immediately,\n   discarding any pending writes.  It is not\
    \ required for the initiator\n   of the close to wait for the responding close_notify\
    \ alert before\n   closing the read side of the connection.\n   If the application\
    \ protocol using TLS provides that any data may be\n   carried over the underlying\
    \ transport after the TLS connection is\n   closed, the TLS implementation must\
    \ receive the responding\n   close_notify alert before indicating to the application\
    \ layer that\n   the TLS connection has ended.  If the application protocol will\
    \ not\n   transfer any additional data, but will only close the underlying\n \
    \  transport connection, then the implementation MAY choose to close the\n   transport\
    \ without waiting for the responding close_notify.  No part\n   of this standard\
    \ should be taken to dictate the manner in which a\n   usage profile for TLS manages\
    \ its data transport, including when\n   connections are opened or closed.\n \
    \  Note: It is assumed that closing a connection reliably delivers\n   pending\
    \ data before destroying the transport.\n"
- title: 7.2.2.  Error Alerts
  contents:
  - "7.2.2.  Error Alerts\n   Error handling in the TLS Handshake protocol is very\
    \ simple.  When an\n   error is detected, the detecting party sends a message\
    \ to the other\n   party.  Upon transmission or receipt of a fatal alert message,\
    \ both\n   parties immediately close the connection.  Servers and clients MUST\n\
    \   forget any session-identifiers, keys, and secrets associated with a\n   failed\
    \ connection.  Thus, any connection terminated with a fatal\n   alert MUST NOT\
    \ be resumed.\n   Whenever an implementation encounters a condition which is defined\
    \ as\n   a fatal alert, it MUST send the appropriate alert prior to closing\n\
    \   the connection.  For all errors where an alert level is not\n   explicitly\
    \ specified, the sending party MAY determine at its\n   discretion whether to\
    \ treat this as a fatal error or not.  If the\n   implementation chooses to send\
    \ an alert but intends to close the\n   connection immediately afterwards, it\
    \ MUST send that alert at the\n   fatal alert level.\n   If an alert with a level\
    \ of warning is sent and received, generally\n   the connection can continue normally.\
    \  If the receiving party decides\n   not to proceed with the connection (e.g.,\
    \ after having received a\n   no_renegotiation alert that it is not willing to\
    \ accept), it SHOULD\n   send a fatal alert to terminate the connection.  Given\
    \ this, the\n   sending party cannot, in general, know how the receiving party\
    \ will\n   behave.  Therefore, warning alerts are not very useful when the\n \
    \  sending party wants to continue the connection, and thus are\n   sometimes\
    \ omitted.  For example, if a peer decides to accept an\n   expired certificate\
    \ (perhaps after confirming this with the user) and\n   wants to continue the\
    \ connection, it would not generally send a\n   certificate_expired alert.\n \
    \  The following error alerts are defined:\n   unexpected_message\n      An inappropriate\
    \ message was received.  This alert is always fatal\n      and should never be\
    \ observed in communication between proper\n      implementations.\n   bad_record_mac\n\
    \      This alert is returned if a record is received with an incorrect\n    \
    \  MAC.  This alert also MUST be returned if an alert is sent because\n      a\
    \ TLSCiphertext decrypted in an invalid way: either it wasn't an\n      even multiple\
    \ of the block length, or its padding values, when\n      checked, weren't correct.\
    \  This message is always fatal and should\n      never be observed in communication\
    \ between proper implementations\n      (except when messages were corrupted in\
    \ the network).\n   decryption_failed_RESERVED\n      This alert was used in some\
    \ earlier versions of TLS, and may have\n      permitted certain attacks against\
    \ the CBC mode [CBCATT].  It MUST\n      NOT be sent by compliant implementations.\n\
    \   record_overflow\n      A TLSCiphertext record was received that had a length\
    \ more than\n      2^14+2048 bytes, or a record decrypted to a TLSCompressed record\n\
    \      with more than 2^14+1024 bytes.  This message is always fatal and\n   \
    \   should never be observed in communication between proper\n      implementations\
    \ (except when messages were corrupted in the\n      network).\n   decompression_failure\n\
    \      The decompression function received improper input (e.g., data\n      that\
    \ would expand to excessive length).  This message is always\n      fatal and\
    \ should never be observed in communication between proper\n      implementations.\n\
    \   handshake_failure\n      Reception of a handshake_failure alert message indicates\
    \ that the\n      sender was unable to negotiate an acceptable set of security\n\
    \      parameters given the options available.  This is a fatal error.\n   no_certificate_RESERVED\n\
    \      This alert was used in SSLv3 but not any version of TLS.  It MUST\n   \
    \   NOT be sent by compliant implementations.\n   bad_certificate\n      A certificate\
    \ was corrupt, contained signatures that did not\n      verify correctly, etc.\n\
    \   unsupported_certificate\n      A certificate was of an unsupported type.\n\
    \   certificate_revoked\n      A certificate was revoked by its signer.\n   certificate_expired\n\
    \      A certificate has expired or is not currently valid.\n   certificate_unknown\n\
    \      Some other (unspecified) issue arose in processing the\n      certificate,\
    \ rendering it unacceptable.\n   illegal_parameter\n      A field in the handshake\
    \ was out of range or inconsistent with\n      other fields.  This message is\
    \ always fatal.\n   unknown_ca\n      A valid certificate chain or partial chain\
    \ was received, but the\n      certificate was not accepted because the CA certificate\
    \ could not\n      be located or couldn't be matched with a known, trusted CA.\
    \  This\n      message is always fatal.\n   access_denied\n      A valid certificate\
    \ was received, but when access control was\n      applied, the sender decided\
    \ not to proceed with negotiation.  This\n      message is always fatal.\n   decode_error\n\
    \      A message could not be decoded because some field was out of the\n    \
    \  specified range or the length of the message was incorrect.  This\n      message\
    \ is always fatal and should never be observed in\n      communication between\
    \ proper implementations (except when messages\n      were corrupted in the network).\n\
    \   decrypt_error\n      A handshake cryptographic operation failed, including\
    \ being unable\n      to correctly verify a signature or validate a Finished message.\n\
    \      This message is always fatal.\n   export_restriction_RESERVED\n      This\
    \ alert was used in some earlier versions of TLS.  It MUST NOT\n      be sent\
    \ by compliant implementations.\n   protocol_version\n      The protocol version\
    \ the client has attempted to negotiate is\n      recognized but not supported.\
    \  (For example, old protocol versions\n      might be avoided for security reasons.)\
    \  This message is always\n      fatal.\n   insufficient_security\n      Returned\
    \ instead of handshake_failure when a negotiation has\n      failed specifically\
    \ because the server requires ciphers more\n      secure than those supported\
    \ by the client.  This message is always\n      fatal.\n   internal_error\n  \
    \    An internal error unrelated to the peer or the correctness of the\n     \
    \ protocol (such as a memory allocation failure) makes it impossible\n      to\
    \ continue.  This message is always fatal.\n   user_canceled\n      This handshake\
    \ is being canceled for some reason unrelated to a\n      protocol failure.  If\
    \ the user cancels an operation after the\n      handshake is complete, just closing\
    \ the connection by sending a\n      close_notify is more appropriate.  This alert\
    \ should be followed\n      by a close_notify.  This message is generally a warning.\n\
    \   no_renegotiation\n      Sent by the client in response to a hello request\
    \ or by the server\n      in response to a client hello after initial handshaking.\
    \  Either\n      of these would normally lead to renegotiation; when that is not\n\
    \      appropriate, the recipient should respond with this alert.  At\n      that\
    \ point, the original requester can decide whether to proceed\n      with the\
    \ connection.  One case where this would be appropriate is\n      where a server\
    \ has spawned a process to satisfy a request; the\n      process might receive\
    \ security parameters (key length,\n      authentication, etc.) at startup, and\
    \ it might be difficult to\n      communicate changes to these parameters after\
    \ that point.  This\n      message is always a warning.\n   unsupported_extension\n\
    \      sent by clients that receive an extended server hello containing\n    \
    \  an extension that they did not put in the corresponding client\n      hello.\
    \  This message is always fatal.\n   New Alert values are assigned by IANA as\
    \ described in Section 12.\n"
- title: 7.3.  Handshake Protocol Overview
  contents:
  - "7.3.  Handshake Protocol Overview\n   The cryptographic parameters of the session\
    \ state are produced by the\n   TLS Handshake Protocol, which operates on top\
    \ of the TLS record\n   layer.  When a TLS client and server first start communicating,\
    \ they\n   agree on a protocol version, select cryptographic algorithms,\n   optionally\
    \ authenticate each other, and use public-key encryption\n   techniques to generate\
    \ shared secrets.\n   The TLS Handshake Protocol involves the following steps:\n\
    \   -  Exchange hello messages to agree on algorithms, exchange random\n     \
    \ values, and check for session resumption.\n   -  Exchange the necessary cryptographic\
    \ parameters to allow the\n      client and server to agree on a premaster secret.\n\
    \   -  Exchange certificates and cryptographic information to allow the\n    \
    \  client and server to authenticate themselves.\n   -  Generate a master secret\
    \ from the premaster secret and exchanged\n      random values.\n   -  Provide\
    \ security parameters to the record layer.\n   -  Allow the client and server\
    \ to verify that their peer has\n      calculated the same security parameters\
    \ and that the handshake\n      occurred without tampering by an attacker.\n \
    \  Note that higher layers should not be overly reliant on whether TLS\n   always\
    \ negotiates the strongest possible connection between two\n   peers.  There are\
    \ a number of ways in which a man-in-the-middle\n   attacker can attempt to make\
    \ two entities drop down to the least\n   secure method they support.  The protocol\
    \ has been designed to\n   minimize this risk, but there are still attacks available:\
    \ for\n   example, an attacker could block access to the port a secure service\n\
    \   runs on, or attempt to get the peers to negotiate an unauthenticated\n   connection.\
    \  The fundamental rule is that higher levels must be\n   cognizant of what their\
    \ security requirements are and never transmit\n   information over a channel\
    \ less secure than what they require.  The\n   TLS protocol is secure in that\
    \ any cipher suite offers its promised\n   level of security: if you negotiate\
    \ 3DES with a 1024-bit RSA key\n   exchange with a host whose certificate you\
    \ have verified, you can\n   expect to be that secure.\n   These goals are achieved\
    \ by the handshake protocol, which can be\n   summarized as follows: The client\
    \ sends a ClientHello message to\n   which the server must respond with a ServerHello\
    \ message, or else a\n   fatal error will occur and the connection will fail.\
    \  The ClientHello\n   and ServerHello are used to establish security enhancement\n\
    \   capabilities between client and server.  The ClientHello and\n   ServerHello\
    \ establish the following attributes: Protocol Version,\n   Session ID, Cipher\
    \ Suite, and Compression Method.  Additionally, two\n   random values are generated\
    \ and exchanged: ClientHello.random and\n   ServerHello.random.\n   The actual\
    \ key exchange uses up to four messages: the server\n   Certificate, the ServerKeyExchange,\
    \ the client Certificate, and the\n   ClientKeyExchange.  New key exchange methods\
    \ can be created by\n   specifying a format for these messages and by defining\
    \ the use of the\n   messages to allow the client and server to agree upon a shared\n\
    \   secret.  This secret MUST be quite long; currently defined key\n   exchange\
    \ methods exchange secrets that range from 46 bytes upwards.\n   Following the\
    \ hello messages, the server will send its certificate in\n   a Certificate message\
    \ if it is to be authenticated.  Additionally, a\n   ServerKeyExchange message\
    \ may be sent, if it is required (e.g., if\n   the server has no certificate,\
    \ or if its certificate is for signing\n   only).  If the server is authenticated,\
    \ it may request a certificate\n   from the client, if that is appropriate to\
    \ the cipher suite selected.\n   Next, the server will send the ServerHelloDone\
    \ message, indicating\n   that the hello-message phase of the handshake is complete.\
    \  The\n   server will then wait for a client response.  If the server has sent\n\
    \   a CertificateRequest message, the client MUST send the Certificate\n   message.\
    \  The ClientKeyExchange message is now sent, and the content\n   of that message\
    \ will depend on the public key algorithm selected\n   between the ClientHello\
    \ and the ServerHello.  If the client has sent\n   a certificate with signing\
    \ ability, a digitally-signed\n   CertificateVerify message is sent to explicitly\
    \ verify possession of\n   the private key in the certificate.\n   At this point,\
    \ a ChangeCipherSpec message is sent by the client, and\n   the client copies\
    \ the pending Cipher Spec into the current Cipher\n   Spec.  The client then immediately\
    \ sends the Finished message under\n   the new algorithms, keys, and secrets.\
    \  In response, the server will\n   send its own ChangeCipherSpec message, transfer\
    \ the pending to the\n   current Cipher Spec, and send its Finished message under\
    \ the new\n   Cipher Spec.  At this point, the handshake is complete, and the\n\
    \   client and server may begin to exchange application layer data.  (See\n  \
    \ flow chart below.)  Application data MUST NOT be sent prior to the\n   completion\
    \ of the first handshake (before a cipher suite other than\n   TLS_NULL_WITH_NULL_NULL\
    \ is established).\n      Client                                             \
    \  Server\n      ClientHello                  -------->\n                    \
    \                                  ServerHello\n                             \
    \                        Certificate*\n                                      \
    \         ServerKeyExchange*\n                                              CertificateRequest*\n\
    \                                   <--------      ServerHelloDone\n      Certificate*\n\
    \      ClientKeyExchange\n      CertificateVerify*\n      [ChangeCipherSpec]\n\
    \      Finished                     -------->\n                              \
    \                 [ChangeCipherSpec]\n                                   <--------\
    \             Finished\n      Application Data             <------->     Application\
    \ Data\n             Figure 1.  Message flow for a full handshake\n   * Indicates\
    \ optional or situation-dependent messages that are not\n   always sent.\n   Note:\
    \ To help avoid pipeline stalls, ChangeCipherSpec is an\n   independent TLS protocol\
    \ content type, and is not actually a TLS\n   handshake message.\n   When the\
    \ client and server decide to resume a previous session or\n   duplicate an existing\
    \ session (instead of negotiating new security\n   parameters), the message flow\
    \ is as follows:\n   The client sends a ClientHello using the Session ID of the\
    \ session to\n   be resumed.  The server then checks its session cache for a match.\n\
    \   If a match is found, and the server is willing to re-establish the\n   connection\
    \ under the specified session state, it will send a\n   ServerHello with the same\
    \ Session ID value.  At this point, both\n   client and server MUST send ChangeCipherSpec\
    \ messages and proceed\n   directly to Finished messages.  Once the re-establishment\
    \ is\n   complete, the client and server MAY begin to exchange application\n \
    \  layer data.  (See flow chart below.)  If a Session ID match is not\n   found,\
    \ the server generates a new session ID, and the TLS client and\n   server perform\
    \ a full handshake.\n      Client                                            \
    \    Server\n      ClientHello                   -------->\n                 \
    \                                      ServerHello\n                         \
    \                       [ChangeCipherSpec]\n                                 \
    \   <--------             Finished\n      [ChangeCipherSpec]\n      Finished \
    \                     -------->\n      Application Data              <------->\
    \     Application Data\n          Figure 2.  Message flow for an abbreviated handshake\n\
    \   The contents and significance of each message will be presented in\n   detail\
    \ in the following sections.\n"
- title: 7.4.  Handshake Protocol
  contents:
  - "7.4.  Handshake Protocol\n   The TLS Handshake Protocol is one of the defined\
    \ higher-level clients\n   of the TLS Record Protocol.  This protocol is used\
    \ to negotiate the\n   secure attributes of a session.  Handshake messages are\
    \ supplied to\n   the TLS record layer, where they are encapsulated within one\
    \ or more\n   TLSPlaintext structures, which are processed and transmitted as\n\
    \   specified by the current active session state.\n      enum {\n          hello_request(0),\
    \ client_hello(1), server_hello(2),\n          certificate(11), server_key_exchange\
    \ (12),\n          certificate_request(13), server_hello_done(14),\n         \
    \ certificate_verify(15), client_key_exchange(16),\n          finished(20), (255)\n\
    \      } HandshakeType;\n      struct {\n          HandshakeType msg_type;   \
    \ /* handshake type */\n          uint24 length;             /* bytes in message\
    \ */\n          select (HandshakeType) {\n              case hello_request:  \
    \     HelloRequest;\n              case client_hello:        ClientHello;\n  \
    \            case server_hello:        ServerHello;\n              case certificate:\
    \         Certificate;\n              case server_key_exchange: ServerKeyExchange;\n\
    \              case certificate_request: CertificateRequest;\n              case\
    \ server_hello_done:   ServerHelloDone;\n              case certificate_verify:\
    \  CertificateVerify;\n              case client_key_exchange: ClientKeyExchange;\n\
    \              case finished:            Finished;\n          } body;\n      }\
    \ Handshake;\n   The handshake protocol messages are presented below in the order\
    \ they\n   MUST be sent; sending handshake messages in an unexpected order\n \
    \  results in a fatal error.  Unneeded handshake messages can be\n   omitted,\
    \ however.  Note one exception to the ordering: the\n   Certificate message is\
    \ used twice in the handshake (from server to\n   client, then from client to\
    \ server), but described only in its first\n   position.  The one message that\
    \ is not bound by these ordering rules\n   is the HelloRequest message, which\
    \ can be sent at any time, but which\n   SHOULD be ignored by the client if it\
    \ arrives in the middle of a\n   handshake.\n   New handshake message types are\
    \ assigned by IANA as described in\n   Section 12.\n"
- title: 7.4.1.  Hello Messages
  contents:
  - "7.4.1.  Hello Messages\n   The hello phase messages are used to exchange security\
    \ enhancement\n   capabilities between the client and server.  When a new session\n\
    \   begins, the record layer's connection state encryption, hash, and\n   compression\
    \ algorithms are initialized to null.  The current\n   connection state is used\
    \ for renegotiation messages.\n"
- title: 7.4.1.1.  Hello Request
  contents:
  - "7.4.1.1.  Hello Request\n   When this message will be sent:\n      The HelloRequest\
    \ message MAY be sent by the server at any time.\n   Meaning of this message:\n\
    \      HelloRequest is a simple notification that the client should begin\n  \
    \    the negotiation process anew.  In response, the client should send\n    \
    \  a ClientHello message when convenient.  This message is not\n      intended\
    \ to establish which side is the client or server but\n      merely to initiate\
    \ a new negotiation.  Servers SHOULD NOT send a\n      HelloRequest immediately\
    \ upon the client's initial connection.  It\n      is the client's job to send\
    \ a ClientHello at that time.\n      This message will be ignored by the client\
    \ if the client is\n      currently negotiating a session.  This message MAY be\
    \ ignored by\n      the client if it does not wish to renegotiate a session, or\
    \ the\n      client may, if it wishes, respond with a no_renegotiation alert.\n\
    \      Since handshake messages are intended to have transmission\n      precedence\
    \ over application data, it is expected that the\n      negotiation will begin\
    \ before no more than a few records are\n      received from the client.  If the\
    \ server sends a HelloRequest but\n      does not receive a ClientHello in response,\
    \ it may close the\n      connection with a fatal alert.\n      After sending\
    \ a HelloRequest, servers SHOULD NOT repeat the\n      request until the subsequent\
    \ handshake negotiation is complete.\n   Structure of this message:\n      struct\
    \ { } HelloRequest;\n   This message MUST NOT be included in the message hashes\
    \ that are\n   maintained throughout the handshake and used in the Finished messages\n\
    \   and the certificate verify message.\n"
- title: 7.4.1.2.  Client Hello
  contents:
  - "7.4.1.2.  Client Hello\n   When this message will be sent:\n      When a client\
    \ first connects to a server, it is required to send\n      the ClientHello as\
    \ its first message.  The client can also send a\n      ClientHello in response\
    \ to a HelloRequest or on its own initiative\n      in order to renegotiate the\
    \ security parameters in an existing\n      connection.\n   Structure of this\
    \ message:\n      The ClientHello message includes a random structure, which is\
    \ used\n      later in the protocol.\n         struct {\n             uint32 gmt_unix_time;\n\
    \             opaque random_bytes[28];\n         } Random;\n      gmt_unix_time\n\
    \         The current time and date in standard UNIX 32-bit format\n         (seconds\
    \ since the midnight starting Jan 1, 1970, UTC, ignoring\n         leap seconds)\
    \ according to the sender's internal clock.  Clocks\n         are not required\
    \ to be set correctly by the basic TLS protocol;\n         higher-level or application\
    \ protocols may define additional\n         requirements.  Note that, for historical\
    \ reasons, the data\n         element is named using GMT, the predecessor of the\
    \ current\n         worldwide time base, UTC.\n      random_bytes\n         28\
    \ bytes generated by a secure random number generator.\n   The ClientHello message\
    \ includes a variable-length session\n   identifier.  If not empty, the value\
    \ identifies a session between the\n   same client and server whose security parameters\
    \ the client wishes to\n   reuse.  The session identifier MAY be from an earlier\
    \ connection,\n   this connection, or from another currently active connection.\
    \  The\n   second option is useful if the client only wishes to update the\n \
    \  random structures and derived values of a connection, and the third\n   option\
    \ makes it possible to establish several independent secure\n   connections without\
    \ repeating the full handshake protocol.  These\n   independent connections may\
    \ occur sequentially or simultaneously; a\n   SessionID becomes valid when the\
    \ handshake negotiating it completes\n   with the exchange of Finished messages\
    \ and persists until it is\n   removed due to aging or because a fatal error was\
    \ encountered on a\n   connection associated with the session.  The actual contents\
    \ of the\n   SessionID are defined by the server.\n      opaque SessionID<0..32>;\n\
    \   Warning: Because the SessionID is transmitted without encryption or\n   immediate\
    \ MAC protection, servers MUST NOT place confidential\n   information in session\
    \ identifiers or let the contents of fake\n   session identifiers cause any breach\
    \ of security.  (Note that the\n   content of the handshake as a whole, including\
    \ the SessionID, is\n   protected by the Finished messages exchanged at the end\
    \ of the\n   handshake.)\n   The cipher suite list, passed from the client to\
    \ the server in the\n   ClientHello message, contains the combinations of cryptographic\n\
    \   algorithms supported by the client in order of the client's\n   preference\
    \ (favorite choice first).  Each cipher suite defines a key\n   exchange algorithm,\
    \ a bulk encryption algorithm (including secret key\n   length), a MAC algorithm,\
    \ and a PRF.  The server will select a cipher\n   suite or, if no acceptable choices\
    \ are presented, return a handshake\n   failure alert and close the connection.\
    \  If the list contains cipher\n   suites the server does not recognize, support,\
    \ or wish to use, the\n   server MUST ignore those cipher suites, and process\
    \ the remaining\n   ones as usual.\n      uint8 CipherSuite[2];    /* Cryptographic\
    \ suite selector */\n   The ClientHello includes a list of compression algorithms\
    \ supported\n   by the client, ordered according to the client's preference.\n\
    \      enum { null(0), (255) } CompressionMethod;\n      struct {\n          ProtocolVersion\
    \ client_version;\n          Random random;\n          SessionID session_id;\n\
    \          CipherSuite cipher_suites<2..2^16-2>;\n          CompressionMethod\
    \ compression_methods<1..2^8-1>;\n          select (extensions_present) {\n  \
    \            case false:\n                  struct {};\n              case true:\n\
    \                  Extension extensions<0..2^16-1>;\n          };\n      } ClientHello;\n\
    \   TLS allows extensions to follow the compression_methods field in an\n   extensions\
    \ block.  The presence of extensions can be detected by\n   determining whether\
    \ there are bytes following the compression_methods\n   at the end of the ClientHello.\
    \  Note that this method of detecting\n   optional data differs from the normal\
    \ TLS method of having a\n   variable-length field, but it is used for compatibility\
    \ with TLS\n   before extensions were defined.\n   client_version\n      The version\
    \ of the TLS protocol by which the client wishes to\n      communicate during\
    \ this session.  This SHOULD be the latest\n      (highest valued) version supported\
    \ by the client.  For this\n      version of the specification, the version will\
    \ be 3.3 (see\n      Appendix E for details about backward compatibility).\n \
    \  random\n      A client-generated random structure.\n   session_id\n      The\
    \ ID of a session the client wishes to use for this connection.\n      This field\
    \ is empty if no session_id is available, or if the\n      client wishes to generate\
    \ new security parameters.\n   cipher_suites\n      This is a list of the cryptographic\
    \ options supported by the\n      client, with the client's first preference first.\
    \  If the\n      session_id field is not empty (implying a session resumption\n\
    \      request), this vector MUST include at least the cipher_suite from\n   \
    \   that session.  Values are defined in Appendix A.5.\n   compression_methods\n\
    \      This is a list of the compression methods supported by the client,\n  \
    \    sorted by client preference.  If the session_id field is not empty\n    \
    \  (implying a session resumption request), it MUST include the\n      compression_method\
    \ from that session.  This vector MUST contain,\n      and all implementations\
    \ MUST support, CompressionMethod.null.\n      Thus, a client and server will\
    \ always be able to agree on a\n      compression method.\n   extensions\n   \
    \   Clients MAY request extended functionality from servers by sending\n     \
    \ data in the extensions field.  The actual \"Extension\" format is\n      defined\
    \ in Section 7.4.1.4.\n   In the event that a client requests additional functionality\
    \ using\n   extensions, and this functionality is not supplied by the server,\
    \ the\n   client MAY abort the handshake.  A server MUST accept ClientHello\n\
    \   messages both with and without the extensions field, and (as for all\n   other\
    \ messages) it MUST check that the amount of data in the message\n   precisely\
    \ matches one of these formats; if not, then it MUST send a\n   fatal \"decode_error\"\
    \ alert.\n   After sending the ClientHello message, the client waits for a\n \
    \  ServerHello message.  Any handshake message returned by the server,\n   except\
    \ for a HelloRequest, is treated as a fatal error.\n"
- title: 7.4.1.3.  Server Hello
  contents:
  - "7.4.1.3.  Server Hello\n   When this message will be sent:\n      The server\
    \ will send this message in response to a ClientHello\n      message when it was\
    \ able to find an acceptable set of algorithms.\n      If it cannot find such\
    \ a match, it will respond with a handshake\n      failure alert.\n   Structure\
    \ of this message:\n      struct {\n          ProtocolVersion server_version;\n\
    \          Random random;\n          SessionID session_id;\n          CipherSuite\
    \ cipher_suite;\n          CompressionMethod compression_method;\n          select\
    \ (extensions_present) {\n              case false:\n                  struct\
    \ {};\n              case true:\n                  Extension extensions<0..2^16-1>;\n\
    \          };\n      } ServerHello;\n   The presence of extensions can be detected\
    \ by determining whether\n   there are bytes following the compression_method\
    \ field at the end of\n   the ServerHello.\n   server_version\n      This field\
    \ will contain the lower of that suggested by the client\n      in the client\
    \ hello and the highest supported by the server.  For\n      this version of the\
    \ specification, the version is 3.3.  (See\n      Appendix E for details about\
    \ backward compatibility.)\n   random\n      This structure is generated by the\
    \ server and MUST be\n      independently generated from the ClientHello.random.\n\
    \   session_id\n      This is the identity of the session corresponding to this\n\
    \      connection.  If the ClientHello.session_id was non-empty, the\n      server\
    \ will look in its session cache for a match.  If a match is\n      found and\
    \ the server is willing to establish the new connection\n      using the specified\
    \ session state, the server will respond with\n      the same value as was supplied\
    \ by the client.  This indicates a\n      resumed session and dictates that the\
    \ parties must proceed\n      directly to the Finished messages.  Otherwise, this\
    \ field will\n      contain a different value identifying the new session.  The\
    \ server\n      may return an empty session_id to indicate that the session will\n\
    \      not be cached and therefore cannot be resumed.  If a session is\n     \
    \ resumed, it must be resumed using the same cipher suite it was\n      originally\
    \ negotiated with.  Note that there is no requirement\n      that the server resume\
    \ any session even if it had formerly\n      provided a session_id.  Clients MUST\
    \ be prepared to do a full\n      negotiation -- including negotiating new cipher\
    \ suites -- during\n      any handshake.\n   cipher_suite\n      The single cipher\
    \ suite selected by the server from the list in\n      ClientHello.cipher_suites.\
    \  For resumed sessions, this field is\n      the value from the state of the\
    \ session being resumed.\n   compression_method\n      The single compression\
    \ algorithm selected by the server from the\n      list in ClientHello.compression_methods.\
    \  For resumed sessions,\n      this field is the value from the resumed session\
    \ state.\n   extensions\n      A list of extensions.  Note that only extensions\
    \ offered by the\n      client can appear in the server's list.\n"
- title: 7.4.1.4.  Hello Extensions
  contents:
  - "7.4.1.4.  Hello Extensions\n   The extension format is:\n      struct {\n   \
    \       ExtensionType extension_type;\n          opaque extension_data<0..2^16-1>;\n\
    \      } Extension;\n      enum {\n          signature_algorithms(13), (65535)\n\
    \      } ExtensionType;\n   Here:\n   -  \"extension_type\" identifies the particular\
    \ extension type.\n   -  \"extension_data\" contains information specific to the\
    \ particular\n      extension type.\n   The initial set of extensions is defined\
    \ in a companion document\n   [TLSEXT].  The list of extension types is maintained\
    \ by IANA as\n   described in Section 12.\n   An extension type MUST NOT appear\
    \ in the ServerHello unless the same\n   extension type appeared in the corresponding\
    \ ClientHello.  If a\n   client receives an extension type in ServerHello that\
    \ it did not\n   request in the associated ClientHello, it MUST abort the handshake\n\
    \   with an unsupported_extension fatal alert.\n   Nonetheless, \"server-oriented\"\
    \ extensions may be provided in the\n   future within this framework.  Such an\
    \ extension (say, of type x)\n   would require the client to first send an extension\
    \ of type x in a\n   ClientHello with empty extension_data to indicate that it\
    \ supports\n   the extension type.  In this case, the client is offering the\n\
    \   capability to understand the extension type, and the server is taking\n  \
    \ the client up on its offer.\n   When multiple extensions of different types\
    \ are present in the\n   ClientHello or ServerHello messages, the extensions MAY\
    \ appear in any\n   order.  There MUST NOT be more than one extension of the same\
    \ type.\n   Finally, note that extensions can be sent both when starting a new\n\
    \   session and when requesting session resumption.  Indeed, a client\n   that\
    \ requests session resumption does not in general know whether the\n   server\
    \ will accept this request, and therefore it SHOULD send the\n   same extensions\
    \ as it would send if it were not attempting\n   resumption.\n   In general, the\
    \ specification of each extension type needs to\n   describe the effect of the\
    \ extension both during full handshake and\n   session resumption.  Most current\
    \ TLS extensions are relevant only\n   when a session is initiated: when an older\
    \ session is resumed, the\n   server does not process these extensions in Client\
    \ Hello, and does\n   not include them in Server Hello.  However, some extensions\
    \ may\n   specify different behavior during session resumption.\n   There are\
    \ subtle (and not so subtle) interactions that may occur in\n   this protocol\
    \ between new features and existing features which may\n   result in a significant\
    \ reduction in overall security.  The following\n   considerations should be taken\
    \ into account when designing new\n   extensions:\n   -  Some cases where a server\
    \ does not agree to an extension are error\n      conditions, and some are simply\
    \ refusals to support particular\n      features.  In general, error alerts should\
    \ be used for the former,\n      and a field in the server extension response\
    \ for the latter.\n   -  Extensions should, as far as possible, be designed to\
    \ prevent any\n      attack that forces use (or non-use) of a particular feature\
    \ by\n      manipulation of handshake messages.  This principle should be\n  \
    \    followed regardless of whether the feature is believed to cause a\n     \
    \ security problem.\n      Often the fact that the extension fields are included\
    \ in the\n      inputs to the Finished message hashes will be sufficient, but\n\
    \      extreme care is needed when the extension changes the meaning of\n    \
    \  messages sent in the handshake phase.  Designers and implementors\n      should\
    \ be aware of the fact that until the handshake has been\n      authenticated,\
    \ active attackers can modify messages and insert,\n      remove, or replace extensions.\n\
    \   -  It would be technically possible to use extensions to change major\n  \
    \    aspects of the design of TLS; for example the design of cipher\n      suite\
    \ negotiation.  This is not recommended; it would be more\n      appropriate to\
    \ define a new version of TLS -- particularly since\n      the TLS handshake algorithms\
    \ have specific protection against\n      version rollback attacks based on the\
    \ version number, and the\n      possibility of version rollback should be a significant\n\
    \      consideration in any major design change.\n"
- title: 7.4.1.4.1.  Signature Algorithms
  contents:
  - "7.4.1.4.1.  Signature Algorithms\n   The client uses the \"signature_algorithms\"\
    \ extension to indicate to\n   the server which signature/hash algorithm pairs\
    \ may be used in\n   digital signatures.  The \"extension_data\" field of this\
    \ extension\n   contains a \"supported_signature_algorithms\" value.\n      enum\
    \ {\n          none(0), md5(1), sha1(2), sha224(3), sha256(4), sha384(5),\n  \
    \        sha512(6), (255)\n      } HashAlgorithm;\n      enum { anonymous(0),\
    \ rsa(1), dsa(2), ecdsa(3), (255) }\n        SignatureAlgorithm;\n      struct\
    \ {\n            HashAlgorithm hash;\n            SignatureAlgorithm signature;\n\
    \      } SignatureAndHashAlgorithm;\n      SignatureAndHashAlgorithm\n       \
    \ supported_signature_algorithms<2..2^16-2>;\n   Each SignatureAndHashAlgorithm\
    \ value lists a single hash/signature\n   pair that the client is willing to verify.\
    \  The values are indicated\n   in descending order of preference.\n   Note: Because\
    \ not all signature algorithms and hash algorithms may be\n   accepted by an implementation\
    \ (e.g., DSA with SHA-1, but not\n   SHA-256), algorithms here are listed in pairs.\n\
    \   hash\n      This field indicates the hash algorithm which may be used.  The\n\
    \      values indicate support for unhashed data, MD5 [MD5], SHA-1,\n      SHA-224,\
    \ SHA-256, SHA-384, and SHA-512 [SHS], respectively.  The\n      \"none\" value\
    \ is provided for future extensibility, in case of a\n      signature algorithm\
    \ which does not require hashing before signing.\n   signature\n      This field\
    \ indicates the signature algorithm that may be used.\n      The values indicate\
    \ anonymous signatures, RSASSA-PKCS1-v1_5\n      [PKCS1] and DSA [DSS], and ECDSA\
    \ [ECDSA], respectively.  The\n      \"anonymous\" value is meaningless in this\
    \ context but used in\n      Section 7.4.3.  It MUST NOT appear in this extension.\n\
    \   The semantics of this extension are somewhat complicated because the\n   cipher\
    \ suite indicates permissible signature algorithms but not hash\n   algorithms.\
    \  Sections 7.4.2 and 7.4.3 describe the appropriate rules.\n   If the client\
    \ supports only the default hash and signature algorithms\n   (listed in this\
    \ section), it MAY omit the signature_algorithms\n   extension.  If the client\
    \ does not support the default algorithms, or\n   supports other hash and signature\
    \ algorithms (and it is willing to\n   use them for verifying messages sent by\
    \ the server, i.e., server\n   certificates and server key exchange), it MUST\
    \ send the\n   signature_algorithms extension, listing the algorithms it is willing\n\
    \   to accept.\n   If the client does not send the signature_algorithms extension,\
    \ the\n   server MUST do the following:\n   -  If the negotiated key exchange\
    \ algorithm is one of (RSA, DHE_RSA,\n      DH_RSA, RSA_PSK, ECDH_RSA, ECDHE_RSA),\
    \ behave as if client had\n      sent the value {sha1,rsa}.\n   -  If the negotiated\
    \ key exchange algorithm is one of (DHE_DSS,\n      DH_DSS), behave as if the\
    \ client had sent the value {sha1,dsa}.\n   -  If the negotiated key exchange\
    \ algorithm is one of (ECDH_ECDSA,\n      ECDHE_ECDSA), behave as if the client\
    \ had sent value {sha1,ecdsa}.\n   Note: this is a change from TLS 1.1 where there\
    \ are no explicit\n   rules, but as a practical matter one can assume that the\
    \ peer\n   supports MD5 and SHA-1.\n   Note: this extension is not meaningful\
    \ for TLS versions prior to 1.2.\n   Clients MUST NOT offer it if they are offering\
    \ prior versions.\n   However, even if clients do offer it, the rules specified\
    \ in [TLSEXT]\n   require servers to ignore extensions they do not understand.\n\
    \   Servers MUST NOT send this extension.  TLS servers MUST support\n   receiving\
    \ this extension.\n   When performing session resumption, this extension is not\
    \ included in\n   Server Hello, and the server ignores the extension in Client\
    \ Hello\n   (if present).\n"
- title: 7.4.2.  Server Certificate
  contents:
  - "7.4.2.  Server Certificate\n   When this message will be sent:\n      The server\
    \ MUST send a Certificate message whenever the agreed-\n      upon key exchange\
    \ method uses certificates for authentication\n      (this includes all key exchange\
    \ methods defined in this document\n      except DH_anon).  This message will\
    \ always immediately follow the\n      ServerHello message.\n   Meaning of this\
    \ message:\n      This message conveys the server's certificate chain to the client.\n\
    \      The certificate MUST be appropriate for the negotiated cipher\n      suite's\
    \ key exchange algorithm and any negotiated extensions.\n   Structure of this\
    \ message:\n      opaque ASN.1Cert<1..2^24-1>;\n      struct {\n          ASN.1Cert\
    \ certificate_list<0..2^24-1>;\n      } Certificate;\n   certificate_list\n  \
    \    This is a sequence (chain) of certificates.  The sender's\n      certificate\
    \ MUST come first in the list.  Each following\n      certificate MUST directly\
    \ certify the one preceding it.  Because\n      certificate validation requires\
    \ that root keys be distributed\n      independently, the self-signed certificate\
    \ that specifies the root\n      certificate authority MAY be omitted from the\
    \ chain, under the\n      assumption that the remote end must already possess\
    \ it in order to\n      validate it in any case.\n   The same message type and\
    \ structure will be used for the client's\n   response to a certificate request\
    \ message.  Note that a client MAY\n   send no certificates if it does not have\
    \ an appropriate certificate\n   to send in response to the server's authentication\
    \ request.\n   Note: PKCS #7 [PKCS7] is not used as the format for the certificate\n\
    \   vector because PKCS #6 [PKCS6] extended certificates are not used.\n   Also,\
    \ PKCS #7 defines a SET rather than a SEQUENCE, making the task\n   of parsing\
    \ the list more difficult.\n   The following rules apply to the certificates sent\
    \ by the server:\n   -  The certificate type MUST be X.509v3, unless explicitly\
    \ negotiated\n      otherwise (e.g., [TLSPGP]).\n   -  The end entity certificate's\
    \ public key (and associated\n      restrictions) MUST be compatible with the\
    \ selected key exchange\n      algorithm.\n      Key Exchange Alg.  Certificate\
    \ Key Type\n      RSA                RSA public key; the certificate MUST allow\
    \ the\n      RSA_PSK            key to be used for encryption (the\n         \
    \                keyEncipherment bit MUST be set if the key\n                \
    \         usage extension is present).\n                         Note: RSA_PSK\
    \ is defined in [TLSPSK].\n      DHE_RSA            RSA public key; the certificate\
    \ MUST allow the\n      ECDHE_RSA          key to be used for signing (the\n \
    \                        digitalSignature bit MUST be set if the key\n       \
    \                  usage extension is present) with the signature\n          \
    \               scheme and hash algorithm that will be employed\n            \
    \             in the server key exchange message.\n                         Note:\
    \ ECDHE_RSA is defined in [TLSECC].\n      DHE_DSS            DSA public key;\
    \ the certificate MUST allow the\n                         key to be used for\
    \ signing with the hash\n                         algorithm that will be employed\
    \ in the server\n                         key exchange message.\n      DH_DSS\
    \             Diffie-Hellman public key; the keyAgreement bit\n      DH_RSA  \
    \           MUST be set if the key usage extension is\n                      \
    \   present.\n      ECDH_ECDSA         ECDH-capable public key; the public key\
    \ MUST\n      ECDH_RSA           use a curve and point format supported by the\n\
    \                         client, as described in [TLSECC].\n      ECDHE_ECDSA\
    \        ECDSA-capable public key; the certificate MUST\n                    \
    \     allow the key to be used for signing with the\n                        \
    \ hash algorithm that will be employed in the\n                         server\
    \ key exchange message.  The public key\n                         MUST use a curve\
    \ and point format supported by\n                         the client, as described\
    \ in  [TLSECC].\n   -  The \"server_name\" and \"trusted_ca_keys\" extensions\
    \ [TLSEXT] are\n      used to guide certificate selection.\n   If the client provided\
    \ a \"signature_algorithms\" extension, then all\n   certificates provided by\
    \ the server MUST be signed by a\n   hash/signature algorithm pair that appears\
    \ in that extension.  Note\n   that this implies that a certificate containing\
    \ a key for one\n   signature algorithm MAY be signed using a different signature\n\
    \   algorithm (for instance, an RSA key signed with a DSA key).  This is\n   a\
    \ departure from TLS 1.1, which required that the algorithms be the\n   same.\
    \  Note that this also implies that the DH_DSS, DH_RSA,\n   ECDH_ECDSA, and ECDH_RSA\
    \ key exchange algorithms do not restrict the\n   algorithm used to sign the certificate.\
    \  Fixed DH certificates MAY be\n   signed with any hash/signature algorithm pair\
    \ appearing in the\n   extension.  The names DH_DSS, DH_RSA, ECDH_ECDSA, and ECDH_RSA\
    \ are\n   historical.\n   If the server has multiple certificates, it chooses\
    \ one of them based\n   on the above-mentioned criteria (in addition to other\
    \ criteria, such\n   as transport layer endpoint, local configuration and preferences,\n\
    \   etc.).  If the server has a single certificate, it SHOULD attempt to\n   validate\
    \ that it meets these criteria.\n   Note that there are certificates that use\
    \ algorithms and/or algorithm\n   combinations that cannot be currently used with\
    \ TLS.  For example, a\n   certificate with RSASSA-PSS signature key (id-RSASSA-PSS\
    \ OID in\n   SubjectPublicKeyInfo) cannot be used because TLS defines no\n   corresponding\
    \ signature algorithm.\n   As cipher suites that specify new key exchange methods\
    \ are specified\n   for the TLS protocol, they will imply the certificate format\
    \ and the\n   required encoded keying information.\n"
- title: 7.4.3.  Server Key Exchange Message
  contents:
  - "7.4.3.  Server Key Exchange Message\n   When this message will be sent:\n   \
    \   This message will be sent immediately after the server Certificate\n     \
    \ message (or the ServerHello message, if this is an anonymous\n      negotiation).\n\
    \      The ServerKeyExchange message is sent by the server only when the\n   \
    \   server Certificate message (if sent) does not contain enough data\n      to\
    \ allow the client to exchange a premaster secret.  This is true\n      for the\
    \ following key exchange methods:\n         DHE_DSS\n         DHE_RSA\n      \
    \   DH_anon\n      It is not legal to send the ServerKeyExchange message for the\n\
    \      following key exchange methods:\n         RSA\n         DH_DSS\n      \
    \   DH_RSA\n      Other key exchange algorithms, such as those defined in [TLSECC],\n\
    \      MUST specify whether the ServerKeyExchange message is sent or not;\n  \
    \    and if the message is sent, its contents.\n   Meaning of this message:\n\
    \      This message conveys cryptographic information to allow the client\n  \
    \    to communicate the premaster secret: a Diffie-Hellman public key\n      with\
    \ which the client can complete a key exchange (with the result\n      being the\
    \ premaster secret) or a public key for some other\n      algorithm.\n   Structure\
    \ of this message:\n      enum { dhe_dss, dhe_rsa, dh_anon, rsa, dh_dss, dh_rsa\n\
    \            /* may be extended, e.g., for ECDH -- see [TLSECC] */\n         \
    \  } KeyExchangeAlgorithm;\n      struct {\n          opaque dh_p<1..2^16-1>;\n\
    \          opaque dh_g<1..2^16-1>;\n          opaque dh_Ys<1..2^16-1>;\n     \
    \ } ServerDHParams;     /* Ephemeral DH parameters */\n      dh_p\n         The\
    \ prime modulus used for the Diffie-Hellman operation.\n      dh_g\n         The\
    \ generator used for the Diffie-Hellman operation.\n      dh_Ys\n         The\
    \ server's Diffie-Hellman public value (g^X mod p).\n      struct {\n        \
    \  select (KeyExchangeAlgorithm) {\n              case dh_anon:\n            \
    \      ServerDHParams params;\n              case dhe_dss:\n              case\
    \ dhe_rsa:\n                  ServerDHParams params;\n                  digitally-signed\
    \ struct {\n                      opaque client_random[32];\n                \
    \      opaque server_random[32];\n                      ServerDHParams params;\n\
    \                  } signed_params;\n              case rsa:\n              case\
    \ dh_dss:\n              case dh_rsa:\n                  struct {} ;\n       \
    \          /* message is omitted for rsa, dh_dss, and dh_rsa */\n            \
    \  /* may be extended, e.g., for ECDH -- see [TLSECC] */\n          };\n     \
    \ } ServerKeyExchange;\n      params\n         The server's key exchange parameters.\n\
    \      signed_params\n         For non-anonymous key exchanges, a signature over\
    \ the server's\n         key exchange parameters.\n   If the client has offered\
    \ the \"signature_algorithms\" extension, the\n   signature algorithm and hash\
    \ algorithm MUST be a pair listed in that\n   extension.  Note that there is a\
    \ possibility for inconsistencies\n   here.  For instance, the client might offer\
    \ DHE_DSS key exchange but\n   omit any DSA pairs from its \"signature_algorithms\"\
    \ extension.  In\n   order to negotiate correctly, the server MUST check any candidate\n\
    \   cipher suites against the \"signature_algorithms\" extension before\n   selecting\
    \ them.  This is somewhat inelegant but is a compromise\n   designed to minimize\
    \ changes to the original cipher suite design.\n   In addition, the hash and signature\
    \ algorithms MUST be compatible\n   with the key in the server's end-entity certificate.\
    \  RSA keys MAY be\n   used with any permitted hash algorithm, subject to restrictions\
    \ in\n   the certificate, if any.\n   Because DSA signatures do not contain any\
    \ secure indication of hash\n   algorithm, there is a risk of hash substitution\
    \ if multiple hashes\n   may be used with any key.  Currently, DSA [DSS] may only\
    \ be used with\n   SHA-1.  Future revisions of DSS [DSS-3] are expected to allow\
    \ the use\n   of other digest algorithms with DSA, as well as guidance as to which\n\
    \   digest algorithms should be used with each key size.  In addition,\n   future\
    \ revisions of [PKIX] may specify mechanisms for certificates to\n   indicate\
    \ which digest algorithms are to be used with DSA.\n   As additional cipher suites\
    \ are defined for TLS that include new key\n   exchange algorithms, the server\
    \ key exchange message will be sent if\n   and only if the certificate type associated\
    \ with the key exchange\n   algorithm does not provide enough information for\
    \ the client to\n   exchange a premaster secret.\n"
- title: 7.4.4.  Certificate Request
  contents:
  - "7.4.4.  Certificate Request\n   When this message will be sent:\n       A non-anonymous\
    \ server can optionally request a certificate from\n       the client, if appropriate\
    \ for the selected cipher suite.  This\n       message, if sent, will immediately\
    \ follow the ServerKeyExchange\n       message (if it is sent; otherwise, this\
    \ message follows the\n       server's Certificate message).\n   Structure of\
    \ this message:\n      enum {\n          rsa_sign(1), dss_sign(2), rsa_fixed_dh(3),\
    \ dss_fixed_dh(4),\n          rsa_ephemeral_dh_RESERVED(5), dss_ephemeral_dh_RESERVED(6),\n\
    \          fortezza_dms_RESERVED(20), (255)\n      } ClientCertificateType;\n\
    \      opaque DistinguishedName<1..2^16-1>;\n      struct {\n          ClientCertificateType\
    \ certificate_types<1..2^8-1>;\n          SignatureAndHashAlgorithm\n        \
    \    supported_signature_algorithms<2^16-1>;\n          DistinguishedName certificate_authorities<0..2^16-1>;\n\
    \      } CertificateRequest;\n   certificate_types\n      A list of the types\
    \ of certificate types that the client may\n      offer.\n         rsa_sign  \
    \      a certificate containing an RSA key\n         dss_sign        a certificate\
    \ containing a DSA key\n         rsa_fixed_dh    a certificate containing a static\
    \ DH key.\n         dss_fixed_dh    a certificate containing a static DH key\n\
    \   supported_signature_algorithms\n      A list of the hash/signature algorithm\
    \ pairs that the server is\n      able to verify, listed in descending order of\
    \ preference.\n   certificate_authorities\n      A list of the distinguished names\
    \ [X501] of acceptable\n      certificate_authorities, represented in DER-encoded\
    \ format.  These\n      distinguished names may specify a desired distinguished\
    \ name for a\n      root CA or for a subordinate CA; thus, this message can be\
    \ used to\n      describe known roots as well as a desired authorization space.\
    \  If\n      the certificate_authorities list is empty, then the client MAY\n\
    \      send any certificate of the appropriate ClientCertificateType,\n      unless\
    \ there is some external arrangement to the contrary.\n   The interaction of the\
    \ certificate_types and\n   supported_signature_algorithms fields is somewhat\
    \ complicated.\n   certificate_types has been present in TLS since SSLv3, but\
    \ was\n   somewhat underspecified.  Much of its functionality is superseded by\n\
    \   supported_signature_algorithms.  The following rules apply:\n   -  Any certificates\
    \ provided by the client MUST be signed using a\n      hash/signature algorithm\
    \ pair found in\n      supported_signature_algorithms.\n   -  The end-entity certificate\
    \ provided by the client MUST contain a\n      key that is compatible with certificate_types.\
    \  If the key is a\n      signature key, it MUST be usable with some hash/signature\n\
    \      algorithm pair in supported_signature_algorithms.\n   -  For historical\
    \ reasons, the names of some client certificate types\n      include the algorithm\
    \ used to sign the certificate.  For example,\n      in earlier versions of TLS,\
    \ rsa_fixed_dh meant a certificate\n      signed with RSA and containing a static\
    \ DH key.  In TLS 1.2, this\n      functionality has been obsoleted by the\n \
    \     supported_signature_algorithms, and the certificate type no longer\n   \
    \   restricts the algorithm used to sign the certificate.  For\n      example,\
    \ if the server sends dss_fixed_dh certificate type and\n      {{sha1, dsa}, {sha1,\
    \ rsa}} signature types, the client MAY reply\n      with a certificate containing\
    \ a static DH key, signed with RSA-\n      SHA1.\n   New ClientCertificateType\
    \ values are assigned by IANA as described in\n   Section 12.\n   Note: Values\
    \ listed as RESERVED may not be used.  They were used in\n   SSLv3.\n   Note:\
    \ It is a fatal handshake_failure alert for an anonymous server\n   to request\
    \ client authentication.\n"
- title: 7.4.5.  Server Hello Done
  contents:
  - "7.4.5.  Server Hello Done\n   When this message will be sent:\n      The ServerHelloDone\
    \ message is sent by the server to indicate the\n      end of the ServerHello\
    \ and associated messages.  After sending\n      this message, the server will\
    \ wait for a client response.\n   Meaning of this message:\n      This message\
    \ means that the server is done sending messages to\n      support the key exchange,\
    \ and the client can proceed with its\n      phase of the key exchange.\n    \
    \  Upon receipt of the ServerHelloDone message, the client SHOULD\n      verify\
    \ that the server provided a valid certificate, if required,\n      and check\
    \ that the server hello parameters are acceptable.\n   Structure of this message:\n\
    \      struct { } ServerHelloDone;\n"
- title: 7.4.6.  Client Certificate
  contents:
  - "7.4.6.  Client Certificate\n   When this message will be sent:\n      This is\
    \ the first message the client can send after receiving a\n      ServerHelloDone\
    \ message.  This message is only sent if the server\n      requests a certificate.\
    \  If no suitable certificate is available,\n      the client MUST send a certificate\
    \ message containing no\n      certificates.  That is, the certificate_list structure\
    \ has a\n      length of zero.  If the client does not send any certificates,\
    \ the\n      server MAY at its discretion either continue the handshake without\n\
    \      client authentication, or respond with a fatal handshake_failure\n    \
    \  alert.  Also, if some aspect of the certificate chain was\n      unacceptable\
    \ (e.g., it was not signed by a known, trusted CA), the\n      server MAY at its\
    \ discretion either continue the handshake\n      (considering the client unauthenticated)\
    \ or send a fatal alert.\n      Client certificates are sent using the Certificate\
    \ structure\n      defined in Section 7.4.2.\n   Meaning of this message:\n  \
    \    This message conveys the client's certificate chain to the server;\n    \
    \  the server will use it when verifying the CertificateVerify\n      message\
    \ (when the client authentication is based on signing) or\n      calculating the\
    \ premaster secret (for non-ephemeral Diffie-\n      Hellman).  The certificate\
    \ MUST be appropriate for the negotiated\n      cipher suite's key exchange algorithm,\
    \ and any negotiated\n      extensions.\n   In particular:\n   -  The certificate\
    \ type MUST be X.509v3, unless explicitly negotiated\n      otherwise (e.g., [TLSPGP]).\n\
    \   -  The end-entity certificate's public key (and associated\n      restrictions)\
    \ has to be compatible with the certificate types\n      listed in CertificateRequest:\n\
    \      Client Cert. Type   Certificate Key Type\n      rsa_sign            RSA\
    \ public key; the certificate MUST allow the\n                          key to\
    \ be used for signing with the signature\n                          scheme and\
    \ hash algorithm that will be\n                          employed in the certificate\
    \ verify message.\n      dss_sign            DSA public key; the certificate MUST\
    \ allow the\n                          key to be used for signing with the hash\n\
    \                          algorithm that will be employed in the\n          \
    \                certificate verify message.\n      ecdsa_sign          ECDSA-capable\
    \ public key; the certificate MUST\n                          allow the key to\
    \ be used for signing with the\n                          hash algorithm that\
    \ will be employed in the\n                          certificate verify message;\
    \ the public key\n                          MUST use a curve and point format\
    \ supported by\n                          the server.\n      rsa_fixed_dh    \
    \    Diffie-Hellman public key; MUST use the same\n      dss_fixed_dh        parameters\
    \ as server's key.\n      rsa_fixed_ecdh      ECDH-capable public key; MUST use\
    \ the\n      ecdsa_fixed_ecdh    same curve as the server's key, and MUST use\
    \ a\n                          point format supported by the server.\n   -  If\
    \ the certificate_authorities list in the certificate request\n      message was\
    \ non-empty, one of the certificates in the certificate\n      chain SHOULD be\
    \ issued by one of the listed CAs.\n   -  The certificates MUST be signed using\
    \ an acceptable hash/\n      signature algorithm pair, as described in Section\
    \ 7.4.4.  Note\n      that this relaxes the constraints on certificate-signing\n\
    \      algorithms found in prior versions of TLS.\n   Note that, as with the server\
    \ certificate, there are certificates\n   that use algorithms/algorithm combinations\
    \ that cannot be currently\n   used with TLS.\n"
- title: 7.4.7.  Client Key Exchange Message
  contents:
  - "7.4.7.  Client Key Exchange Message\n   When this message will be sent:\n   \
    \   This message is always sent by the client.  It MUST immediately\n      follow\
    \ the client certificate message, if it is sent.  Otherwise,\n      it MUST be\
    \ the first message sent by the client after it receives\n      the ServerHelloDone\
    \ message.\n   Meaning of this message:\n      With this message, the premaster\
    \ secret is set, either by direct\n      transmission of the RSA-encrypted secret\
    \ or by the transmission of\n      Diffie-Hellman parameters that will allow each\
    \ side to agree upon\n      the same premaster secret.\n      When the client\
    \ is using an ephemeral Diffie-Hellman exponent,\n      then this message contains\
    \ the client's Diffie-Hellman public\n      value.  If the client is sending a\
    \ certificate containing a static\n      DH exponent (i.e., it is doing fixed_dh\
    \ client authentication),\n      then this message MUST be sent but MUST be empty.\n\
    \   Structure of this message:\n      The choice of messages depends on which\
    \ key exchange method has\n      been selected.  See Section 7.4.3 for the KeyExchangeAlgorithm\n\
    \      definition.\n      struct {\n          select (KeyExchangeAlgorithm) {\n\
    \              case rsa:\n                  EncryptedPreMasterSecret;\n      \
    \        case dhe_dss:\n              case dhe_rsa:\n              case dh_dss:\n\
    \              case dh_rsa:\n              case dh_anon:\n                  ClientDiffieHellmanPublic;\n\
    \          } exchange_keys;\n      } ClientKeyExchange;\n"
- title: 7.4.7.1.  RSA-Encrypted Premaster Secret Message
  contents:
  - "7.4.7.1.  RSA-Encrypted Premaster Secret Message\n   Meaning of this message:\n\
    \      If RSA is being used for key agreement and authentication, the\n      client\
    \ generates a 48-byte premaster secret, encrypts it using the\n      public key\
    \ from the server's certificate, and sends the result in\n      an encrypted premaster\
    \ secret message.  This structure is a\n      variant of the ClientKeyExchange\
    \ message and is not a message in\n      itself.\n   Structure of this message:\n\
    \      struct {\n          ProtocolVersion client_version;\n          opaque random[46];\n\
    \      } PreMasterSecret;\n      client_version\n         The latest (newest)\
    \ version supported by the client.  This is\n         used to detect version rollback\
    \ attacks.\n      random\n         46 securely-generated random bytes.\n     \
    \ struct {\n          public-key-encrypted PreMasterSecret pre_master_secret;\n\
    \      } EncryptedPreMasterSecret;\n      pre_master_secret\n         This random\
    \ value is generated by the client and is used to\n         generate the master\
    \ secret, as specified in Section 8.1.\n   Note: The version number in the PreMasterSecret\
    \ is the version\n   offered by the client in the ClientHello.client_version,\
    \ not the\n   version negotiated for the connection.  This feature is designed\
    \ to\n   prevent rollback attacks.  Unfortunately, some old implementations\n\
    \   use the negotiated version instead, and therefore checking the\n   version\
    \ number may lead to failure to interoperate with such\n   incorrect client implementations.\n\
    \   Client implementations MUST always send the correct version number in\n  \
    \ PreMasterSecret.  If ClientHello.client_version is TLS 1.1 or higher,\n   server\
    \ implementations MUST check the version number as described in\n   the note below.\
    \  If the version number is TLS 1.0 or earlier, server\n   implementations SHOULD\
    \ check the version number, but MAY have a\n   configuration option to disable\
    \ the check.  Note that if the check\n   fails, the PreMasterSecret SHOULD be\
    \ randomized as described below.\n   Note: Attacks discovered by Bleichenbacher\
    \ [BLEI] and Klima et al.\n   [KPR03] can be used to attack a TLS server that\
    \ reveals whether a\n   particular message, when decrypted, is properly PKCS#1\
    \ formatted,\n   contains a valid PreMasterSecret structure, or has the correct\n\
    \   version number.\n   As described by Klima [KPR03], these vulnerabilities can\
    \ be avoided\n   by treating incorrectly formatted message blocks and/or mismatched\n\
    \   version numbers in a manner indistinguishable from correctly\n   formatted\
    \ RSA blocks.  In other words:\n      1. Generate a string R of 46 random bytes\n\
    \      2. Decrypt the message to recover the plaintext M\n      3. If the PKCS#1\
    \ padding is not correct, or the length of message\n         M is not exactly\
    \ 48 bytes:\n            pre_master_secret = ClientHello.client_version || R\n\
    \         else If ClientHello.client_version <= TLS 1.0, and version\n       \
    \  number check is explicitly disabled:\n            pre_master_secret = M\n \
    \        else:\n            pre_master_secret = ClientHello.client_version ||\
    \ M[2..47]\n   Note that explicitly constructing the pre_master_secret with the\n\
    \   ClientHello.client_version produces an invalid master_secret if the\n   client\
    \ has sent the wrong version in the original pre_master_secret.\n   An alternative\
    \ approach is to treat a version number mismatch as a\n   PKCS-1 formatting error\
    \ and randomize the premaster secret\n   completely:\n      1. Generate a string\
    \ R of 48 random bytes\n      2. Decrypt the message to recover the plaintext\
    \ M\n      3. If the PKCS#1 padding is not correct, or the length of message\n\
    \         M is not exactly 48 bytes:\n            pre_master_secret = R\n    \
    \     else If ClientHello.client_version <= TLS 1.0, and version\n         number\
    \ check is explicitly disabled:\n            premaster secret = M\n         else\
    \ If M[0..1] != ClientHello.client_version:\n            premaster secret = R\n\
    \         else:\n            premaster secret = M\n   Although no practical attacks\
    \ against this construction are known,\n   Klima et al. [KPR03] describe some\
    \ theoretical attacks, and therefore\n   the first construction described is RECOMMENDED.\n\
    \   In any case, a TLS server MUST NOT generate an alert if processing an\n  \
    \ RSA-encrypted premaster secret message fails, or the version number\n   is not\
    \ as expected.  Instead, it MUST continue the handshake with a\n   randomly generated\
    \ premaster secret.  It may be useful to log the\n   real cause of failure for\
    \ troubleshooting purposes; however, care\n   must be taken to avoid leaking the\
    \ information to an attacker\n   (through, e.g., timing, log files, or other channels.)\n\
    \   The RSAES-OAEP encryption scheme defined in [PKCS1] is more secure\n   against\
    \ the Bleichenbacher attack.  However, for maximal\n   compatibility with earlier\
    \ versions of TLS, this specification uses\n   the RSAES-PKCS1-v1_5 scheme.  No\
    \ variants of the Bleichenbacher\n   attack are known to exist provided that the\
    \ above recommendations are\n   followed.\n   Implementation note: Public-key-encrypted\
    \ data is represented as an\n   opaque vector <0..2^16-1> (see Section 4.7). \
    \ Thus, the RSA-encrypted\n   PreMasterSecret in a ClientKeyExchange is preceded\
    \ by two length\n   bytes.  These bytes are redundant in the case of RSA because\
    \ the\n   EncryptedPreMasterSecret is the only data in the ClientKeyExchange\n\
    \   and its length can therefore be unambiguously determined.  The SSLv3\n   specification\
    \ was not clear about the encoding of public-key-\n   encrypted data, and therefore\
    \ many SSLv3 implementations do not\n   include the length bytes -- they encode\
    \ the RSA-encrypted data\n   directly in the ClientKeyExchange message.\n   This\
    \ specification requires correct encoding of the\n   EncryptedPreMasterSecret\
    \ complete with length bytes.  The resulting\n   PDU is incompatible with many\
    \ SSLv3 implementations.  Implementors\n   upgrading from SSLv3 MUST modify their\
    \ implementations to generate\n   and accept the correct encoding.  Implementors\
    \ who wish to be\n   compatible with both SSLv3 and TLS should make their implementation's\n\
    \   behavior dependent on the protocol version.\n   Implementation note: It is\
    \ now known that remote timing-based attacks\n   on TLS are possible, at least\
    \ when the client and server are on the\n   same LAN.  Accordingly, implementations\
    \ that use static RSA keys MUST\n   use RSA blinding or some other anti-timing\
    \ technique, as described in\n   [TIMING].\n"
- title: 7.4.7.2.  Client Diffie-Hellman Public Value
  contents:
  - "7.4.7.2.  Client Diffie-Hellman Public Value\n   Meaning of this message:\n \
    \     This structure conveys the client's Diffie-Hellman public value\n      (Yc)\
    \ if it was not already included in the client's certificate.\n      The encoding\
    \ used for Yc is determined by the enumerated\n      PublicValueEncoding.  This\
    \ structure is a variant of the client\n      key exchange message, and not a\
    \ message in itself.\n   Structure of this message:\n      enum { implicit, explicit\
    \ } PublicValueEncoding;\n      implicit\n         If the client has sent a certificate\
    \ which contains a suitable\n         Diffie-Hellman key (for fixed_dh client\
    \ authentication), then\n         Yc is implicit and does not need to be sent\
    \ again.  In this\n         case, the client key exchange message will be sent,\
    \ but it MUST\n         be empty.\n      explicit\n         Yc needs to be sent.\n\
    \      struct {\n          select (PublicValueEncoding) {\n              case\
    \ implicit: struct { };\n              case explicit: opaque dh_Yc<1..2^16-1>;\n\
    \          } dh_public;\n      } ClientDiffieHellmanPublic;\n      dh_Yc\n   \
    \      The client's Diffie-Hellman public value (Yc).\n"
- title: 7.4.8.  Certificate Verify
  contents:
  - "7.4.8.  Certificate Verify\n   When this message will be sent:\n      This message\
    \ is used to provide explicit verification of a client\n      certificate.  This\
    \ message is only sent following a client\n      certificate that has signing\
    \ capability (i.e., all certificates\n      except those containing fixed Diffie-Hellman\
    \ parameters).  When\n      sent, it MUST immediately follow the client key exchange\
    \ message.\n   Structure of this message:\n      struct {\n           digitally-signed\
    \ struct {\n               opaque handshake_messages[handshake_messages_length];\n\
    \           }\n      } CertificateVerify;\n      Here handshake_messages refers\
    \ to all handshake messages sent or\n      received, starting at client hello\
    \ and up to, but not including,\n      this message, including the type and length\
    \ fields of the\n      handshake messages.  This is the concatenation of all the\n\
    \      Handshake structures (as defined in Section 7.4) exchanged thus\n     \
    \ far.  Note that this requires both sides to either buffer the\n      messages\
    \ or compute running hashes for all potential hash\n      algorithms up to the\
    \ time of the CertificateVerify computation.\n      Servers can minimize this\
    \ computation cost by offering a\n      restricted set of digest algorithms in\
    \ the CertificateRequest\n      message.\n      The hash and signature algorithms\
    \ used in the signature MUST be\n      one of those present in the supported_signature_algorithms\
    \ field\n      of the CertificateRequest message.  In addition, the hash and\n\
    \      signature algorithms MUST be compatible with the key in the\n      client's\
    \ end-entity certificate.  RSA keys MAY be used with any\n      permitted hash\
    \ algorithm, subject to restrictions in the\n      certificate, if any.\n    \
    \  Because DSA signatures do not contain any secure indication of\n      hash\
    \ algorithm, there is a risk of hash substitution if multiple\n      hashes may\
    \ be used with any key.  Currently, DSA [DSS] may only be\n      used with SHA-1.\
    \  Future revisions of DSS [DSS-3] are expected to\n      allow the use of other\
    \ digest algorithms with DSA, as well as\n      guidance as to which digest algorithms\
    \ should be used with each\n      key size.  In addition, future revisions of\
    \ [PKIX] may specify\n      mechanisms for certificates to indicate which digest\
    \ algorithms\n      are to be used with DSA.\n"
- title: 7.4.9.  Finished
  contents:
  - "7.4.9.  Finished\n   When this message will be sent:\n      A Finished message\
    \ is always sent immediately after a change\n      cipher spec message to verify\
    \ that the key exchange and\n      authentication processes were successful. \
    \ It is essential that a\n      change cipher spec message be received between\
    \ the other handshake\n      messages and the Finished message.\n   Meaning of\
    \ this message:\n      The Finished message is the first one protected with the\
    \ just\n      negotiated algorithms, keys, and secrets.  Recipients of Finished\n\
    \      messages MUST verify that the contents are correct.  Once a side\n    \
    \  has sent its Finished message and received and validated the\n      Finished\
    \ message from its peer, it may begin to send and receive\n      application data\
    \ over the connection.\n   Structure of this message:\n      struct {\n      \
    \    opaque verify_data[verify_data_length];\n      } Finished;\n      verify_data\n\
    \         PRF(master_secret, finished_label, Hash(handshake_messages))\n     \
    \       [0..verify_data_length-1];\n      finished_label\n         For Finished\
    \ messages sent by the client, the string\n         \"client finished\".  For\
    \ Finished messages sent by the server,\n         the string \"server finished\"\
    .\n      Hash denotes a Hash of the handshake messages.  For the PRF\n      defined\
    \ in Section 5, the Hash MUST be the Hash used as the basis\n      for the PRF.\
    \  Any cipher suite which defines a different PRF MUST\n      also define the\
    \ Hash to use in the Finished computation.\n      In previous versions of TLS,\
    \ the verify_data was always 12 octets\n      long.  In the current version of\
    \ TLS, it depends on the cipher\n      suite.  Any cipher suite which does not\
    \ explicitly specify\n      verify_data_length has a verify_data_length equal\
    \ to 12.  This\n      includes all existing cipher suites.  Note that this\n \
    \     representation has the same encoding as with previous versions.\n      Future\
    \ cipher suites MAY specify other lengths but such length\n      MUST be at least\
    \ 12 bytes.\n      handshake_messages\n         All of the data from all messages\
    \ in this handshake (not\n         including any HelloRequest messages) up to,\
    \ but not including,\n         this message.  This is only data visible at the\
    \ handshake layer\n         and does not include record layer headers.  This is\
    \ the\n         concatenation of all the Handshake structures as defined in\n\
    \         Section 7.4, exchanged thus far.\n   It is a fatal error if a Finished\
    \ message is not preceded by a\n   ChangeCipherSpec message at the appropriate\
    \ point in the handshake.\n   The value handshake_messages includes all handshake\
    \ messages starting\n   at ClientHello up to, but not including, this Finished\
    \ message.  This\n   may be different from handshake_messages in Section 7.4.8\
    \ because it\n   would include the CertificateVerify message (if sent).  Also,\
    \ the\n   handshake_messages for the Finished message sent by the client will\n\
    \   be different from that for the Finished message sent by the server,\n   because\
    \ the one that is sent second will include the prior one.\n   Note: ChangeCipherSpec\
    \ messages, alerts, and any other record types\n   are not handshake messages\
    \ and are not included in the hash\n   computations.  Also, HelloRequest messages\
    \ are omitted from handshake\n   hashes.\n"
- title: 8.  Cryptographic Computations
  contents:
  - "8.  Cryptographic Computations\n   In order to begin connection protection, the\
    \ TLS Record Protocol\n   requires specification of a suite of algorithms, a master\
    \ secret, and\n   the client and server random values.  The authentication, encryption,\n\
    \   and MAC algorithms are determined by the cipher_suite selected by the\n  \
    \ server and revealed in the ServerHello message.  The compression\n   algorithm\
    \ is negotiated in the hello messages, and the random values\n   are exchanged\
    \ in the hello messages.  All that remains is to\n   calculate the master secret.\n"
- title: 8.1.  Computing the Master Secret
  contents:
  - "8.1.  Computing the Master Secret\n   For all key exchange methods, the same\
    \ algorithm is used to convert\n   the pre_master_secret into the master_secret.\
    \  The pre_master_secret\n   should be deleted from memory once the master_secret\
    \ has been\n   computed.\n      master_secret = PRF(pre_master_secret, \"master\
    \ secret\",\n                          ClientHello.random + ServerHello.random)\n\
    \                          [0..47];\n   The master secret is always exactly 48\
    \ bytes in length.  The length\n   of the premaster secret will vary depending\
    \ on key exchange method.\n"
- title: 8.1.1.  RSA
  contents:
  - "8.1.1.  RSA\n   When RSA is used for server authentication and key exchange,\
    \ a 48-\n   byte pre_master_secret is generated by the client, encrypted under\n\
    \   the server's public key, and sent to the server.  The server uses its\n  \
    \ private key to decrypt the pre_master_secret.  Both parties then\n   convert\
    \ the pre_master_secret into the master_secret, as specified\n   above.\n"
- title: 8.1.2.  Diffie-Hellman
  contents:
  - "8.1.2.  Diffie-Hellman\n   A conventional Diffie-Hellman computation is performed.\
    \  The\n   negotiated key (Z) is used as the pre_master_secret, and is converted\n\
    \   into the master_secret, as specified above.  Leading bytes of Z that\n   contain\
    \ all zero bits are stripped before it is used as the\n   pre_master_secret.\n\
    \   Note: Diffie-Hellman parameters are specified by the server and may\n   be\
    \ either ephemeral or contained within the server's certificate.\n"
- title: 9.  Mandatory Cipher Suites
  contents:
  - "9.  Mandatory Cipher Suites\n   In the absence of an application profile standard\
    \ specifying\n   otherwise, a TLS-compliant application MUST implement the cipher\n\
    \   suite TLS_RSA_WITH_AES_128_CBC_SHA (see Appendix A.5 for the\n   definition).\n"
- title: 10.  Application Data Protocol
  contents:
  - "10.  Application Data Protocol\n   Application data messages are carried by the\
    \ record layer and are\n   fragmented, compressed, and encrypted based on the\
    \ current connection\n   state.  The messages are treated as transparent data\
    \ to the record\n   layer.\n"
- title: 11.  Security Considerations
  contents:
  - "11.  Security Considerations\n   Security issues are discussed throughout this\
    \ memo, especially in\n   Appendices D, E, and F.\n"
- title: 12.  IANA Considerations
  contents:
  - "12.  IANA Considerations\n   This document uses several registries that were\
    \ originally created in\n   [TLS1.1].  IANA has updated these to reference this\
    \ document.  The\n   registries and their allocation policies (unchanged from\
    \ [TLS1.1])\n   are listed below.\n   -  TLS ClientCertificateType Identifiers\
    \ Registry: Future values in\n      the range 0-63 (decimal) inclusive are assigned\
    \ via Standards\n      Action [RFC2434].  Values in the range 64-223 (decimal)\
    \ inclusive\n      are assigned via Specification Required [RFC2434].  Values\
    \ from\n      224-255 (decimal) inclusive are reserved for Private Use\n     \
    \ [RFC2434].\n   -  TLS Cipher Suite Registry: Future values with the first byte\
    \ in\n      the range 0-191 (decimal) inclusive are assigned via Standards\n \
    \     Action [RFC2434].  Values with the first byte in the range 192-254\n   \
    \   (decimal) are assigned via Specification Required [RFC2434].\n      Values\
    \ with the first byte 255 (decimal) are reserved for Private\n      Use [RFC2434].\n\
    \   -  This document defines several new HMAC-SHA256-based cipher suites,\n  \
    \    whose values (in Appendix A.5) have been allocated from the TLS\n      Cipher\
    \ Suite registry.\n   -  TLS ContentType Registry: Future values are allocated\
    \ via\n      Standards Action [RFC2434].\n   -  TLS Alert Registry: Future values\
    \ are allocated via Standards\n      Action [RFC2434].\n   -  TLS HandshakeType\
    \ Registry: Future values are allocated via\n      Standards Action [RFC2434].\n\
    \   This document also uses a registry originally created in [RFC4366].\n   IANA\
    \ has updated it to reference this document.  The registry and its\n   allocation\
    \ policy (unchanged from [RFC4366]) is listed below:\n   -  TLS ExtensionType\
    \ Registry: Future values are allocated via IETF\n      Consensus [RFC2434]. \
    \ IANA has updated this registry to include\n      the signature_algorithms extension\
    \ and its corresponding value\n      (see Section 7.4.1.4).\n   In addition, this\
    \ document defines two new registries to be\n   maintained by IANA:\n   -  TLS\
    \ SignatureAlgorithm Registry: The registry has been initially\n      populated\
    \ with the values described in Section 7.4.1.4.1.  Future\n      values in the\
    \ range 0-63 (decimal) inclusive are assigned via\n      Standards Action [RFC2434].\
    \  Values in the range 64-223 (decimal)\n      inclusive are assigned via Specification\
    \ Required [RFC2434].\n      Values from 224-255 (decimal) inclusive are reserved\
    \ for Private\n      Use [RFC2434].\n   -  TLS HashAlgorithm Registry: The registry\
    \ has been initially\n      populated with the values described in Section 7.4.1.4.1.\
    \  Future\n      values in the range 0-63 (decimal) inclusive are assigned via\n\
    \      Standards Action [RFC2434].  Values in the range 64-223 (decimal)\n   \
    \   inclusive are assigned via Specification Required [RFC2434].\n      Values\
    \ from 224-255 (decimal) inclusive are reserved for Private\n      Use [RFC2434].\n\
    \      This document also uses the TLS Compression Method Identifiers\n      Registry,\
    \ defined in [RFC3749].  IANA has allocated value 0 for\n      the \"null\" compression\
    \ method.\n"
- title: Appendix A.  Protocol Data Structures and Constant Values
  contents:
  - "Appendix A.  Protocol Data Structures and Constant Values\n   This section describes\
    \ protocol types and constants.\n"
- title: A.1.  Record Layer
  contents:
  - "A.1.  Record Layer\n   struct {\n       uint8 major;\n       uint8 minor;\n \
    \  } ProtocolVersion;\n   ProtocolVersion version = { 3, 3 };     /* TLS v1.2*/\n\
    \   enum {\n       change_cipher_spec(20), alert(21), handshake(22),\n       application_data(23),\
    \ (255)\n   } ContentType;\n   struct {\n       ContentType type;\n       ProtocolVersion\
    \ version;\n       uint16 length;\n       opaque fragment[TLSPlaintext.length];\n\
    \   } TLSPlaintext;\n   struct {\n       ContentType type;\n       ProtocolVersion\
    \ version;\n       uint16 length;\n       opaque fragment[TLSCompressed.length];\n\
    \   } TLSCompressed;\n   struct {\n       ContentType type;\n       ProtocolVersion\
    \ version;\n       uint16 length;\n       select (SecurityParameters.cipher_type)\
    \ {\n           case stream: GenericStreamCipher;\n           case block:  GenericBlockCipher;\n\
    \           case aead:   GenericAEADCipher;\n       } fragment;\n   } TLSCiphertext;\n\
    \   stream-ciphered struct {\n       opaque content[TLSCompressed.length];\n \
    \      opaque MAC[SecurityParameters.mac_length];\n   } GenericStreamCipher;\n\
    \   struct {\n       opaque IV[SecurityParameters.record_iv_length];\n       block-ciphered\
    \ struct {\n           opaque content[TLSCompressed.length];\n           opaque\
    \ MAC[SecurityParameters.mac_length];\n           uint8 padding[GenericBlockCipher.padding_length];\n\
    \           uint8 padding_length;\n       };\n   } GenericBlockCipher;\n   struct\
    \ {\n      opaque nonce_explicit[SecurityParameters.record_iv_length];\n     \
    \ aead-ciphered struct {\n          opaque content[TLSCompressed.length];\n  \
    \    };\n   } GenericAEADCipher;\n"
- title: A.2.  Change Cipher Specs Message
  contents:
  - "A.2.  Change Cipher Specs Message\n   struct {\n       enum { change_cipher_spec(1),\
    \ (255) } type;\n   } ChangeCipherSpec;\n"
- title: A.3.  Alert Messages
  contents:
  - "A.3.  Alert Messages\n   enum { warning(1), fatal(2), (255) } AlertLevel;\n \
    \  enum {\n       close_notify(0),\n       unexpected_message(10),\n       bad_record_mac(20),\n\
    \       decryption_failed_RESERVED(21),\n       record_overflow(22),\n       decompression_failure(30),\n\
    \       handshake_failure(40),\n       no_certificate_RESERVED(41),\n       bad_certificate(42),\n\
    \       unsupported_certificate(43),\n       certificate_revoked(44),\n      \
    \ certificate_expired(45),\n       certificate_unknown(46),\n       illegal_parameter(47),\n\
    \       unknown_ca(48),\n       access_denied(49),\n       decode_error(50),\n\
    \       decrypt_error(51),\n       export_restriction_RESERVED(60),\n       protocol_version(70),\n\
    \       insufficient_security(71),\n       internal_error(80),\n       user_canceled(90),\n\
    \       no_renegotiation(100),\n       unsupported_extension(110),           /*\
    \ new */\n       (255)\n   } AlertDescription;\n   struct {\n       AlertLevel\
    \ level;\n       AlertDescription description;\n   } Alert;\n"
- title: A.4.  Handshake Protocol
  contents:
  - "A.4.  Handshake Protocol\n   enum {\n       hello_request(0), client_hello(1),\
    \ server_hello(2),\n       certificate(11), server_key_exchange (12),\n      \
    \ certificate_request(13), server_hello_done(14),\n       certificate_verify(15),\
    \ client_key_exchange(16),\n       finished(20)\n       (255)\n   } HandshakeType;\n\
    \   struct {\n       HandshakeType msg_type;\n       uint24 length;\n       select\
    \ (HandshakeType) {\n           case hello_request:       HelloRequest;\n    \
    \       case client_hello:        ClientHello;\n           case server_hello:\
    \        ServerHello;\n           case certificate:         Certificate;\n   \
    \        case server_key_exchange: ServerKeyExchange;\n           case certificate_request:\
    \ CertificateRequest;\n           case server_hello_done:   ServerHelloDone;\n\
    \           case certificate_verify:  CertificateVerify;\n           case client_key_exchange:\
    \ ClientKeyExchange;\n           case finished:            Finished;\n       }\
    \ body;\n   } Handshake;\n"
- title: A.4.1.  Hello Messages
  contents:
  - "A.4.1.  Hello Messages\n   struct { } HelloRequest;\n   struct {\n       uint32\
    \ gmt_unix_time;\n       opaque random_bytes[28];\n   } Random;\n   opaque SessionID<0..32>;\n\
    \   uint8 CipherSuite[2];\n   enum { null(0), (255) } CompressionMethod;\n   struct\
    \ {\n       ProtocolVersion client_version;\n       Random random;\n       SessionID\
    \ session_id;\n       CipherSuite cipher_suites<2..2^16-2>;\n       CompressionMethod\
    \ compression_methods<1..2^8-1>;\n       select (extensions_present) {\n     \
    \      case false:\n               struct {};\n           case true:\n       \
    \        Extension extensions<0..2^16-1>;\n       };\n   } ClientHello;\n   struct\
    \ {\n       ProtocolVersion server_version;\n       Random random;\n       SessionID\
    \ session_id;\n       CipherSuite cipher_suite;\n       CompressionMethod compression_method;\n\
    \       select (extensions_present) {\n           case false:\n              \
    \ struct {};\n           case true:\n               Extension extensions<0..2^16-1>;\n\
    \       };\n   } ServerHello;\n   struct {\n       ExtensionType extension_type;\n\
    \       opaque extension_data<0..2^16-1>;\n   } Extension;\n   enum {\n      \
    \ signature_algorithms(13), (65535)\n   } ExtensionType;\n   enum{\n       none(0),\
    \ md5(1), sha1(2), sha224(3), sha256(4), sha384(5),\n       sha512(6), (255)\n\
    \   } HashAlgorithm;\n   enum {\n      anonymous(0), rsa(1), dsa(2), ecdsa(3),\
    \ (255)\n   } SignatureAlgorithm;\n   struct {\n         HashAlgorithm hash;\n\
    \         SignatureAlgorithm signature;\n   } SignatureAndHashAlgorithm;\n   SignatureAndHashAlgorithm\n\
    \    supported_signature_algorithms<2..2^16-1>;\n"
- title: A.4.2.  Server Authentication and Key Exchange Messages
  contents:
  - "A.4.2.  Server Authentication and Key Exchange Messages\n   opaque ASN.1Cert<2^24-1>;\n\
    \   struct {\n       ASN.1Cert certificate_list<0..2^24-1>;\n   } Certificate;\n\
    \   enum { dhe_dss, dhe_rsa, dh_anon, rsa,dh_dss, dh_rsa\n          /* may be\
    \ extended, e.g., for ECDH -- see [TLSECC] */\n        } KeyExchangeAlgorithm;\n\
    \   struct {\n       opaque dh_p<1..2^16-1>;\n       opaque dh_g<1..2^16-1>;\n\
    \       opaque dh_Ys<1..2^16-1>;\n   } ServerDHParams;     /* Ephemeral DH parameters\
    \ */\n   struct {\n       select (KeyExchangeAlgorithm) {\n           case dh_anon:\n\
    \               ServerDHParams params;\n           case dhe_dss:\n           case\
    \ dhe_rsa:\n               ServerDHParams params;\n               digitally-signed\
    \ struct {\n                   opaque client_random[32];\n                   opaque\
    \ server_random[32];\n                   ServerDHParams params;\n            \
    \   } signed_params;\n           case rsa:\n           case dh_dss:\n        \
    \   case dh_rsa:\n               struct {} ;\n              /* message is omitted\
    \ for rsa, dh_dss, and dh_rsa */\n           /* may be extended, e.g., for ECDH\
    \ -- see [TLSECC] */\n   } ServerKeyExchange;\n   enum {\n       rsa_sign(1),\
    \ dss_sign(2), rsa_fixed_dh(3), dss_fixed_dh(4),\n       rsa_ephemeral_dh_RESERVED(5),\
    \ dss_ephemeral_dh_RESERVED(6),\n       fortezza_dms_RESERVED(20),\n       (255)\n\
    \   } ClientCertificateType;\n   opaque DistinguishedName<1..2^16-1>;\n   struct\
    \ {\n       ClientCertificateType certificate_types<1..2^8-1>;\n       DistinguishedName\
    \ certificate_authorities<0..2^16-1>;\n   } CertificateRequest;\n   struct { }\
    \ ServerHelloDone;\n"
- title: A.4.3.  Client Authentication and Key Exchange Messages
  contents:
  - "A.4.3.  Client Authentication and Key Exchange Messages\n   struct {\n      \
    \ select (KeyExchangeAlgorithm) {\n           case rsa:\n               EncryptedPreMasterSecret;\n\
    \           case dhe_dss:\n           case dhe_rsa:\n           case dh_dss:\n\
    \           case dh_rsa:\n           case dh_anon:\n               ClientDiffieHellmanPublic;\n\
    \       } exchange_keys;\n   } ClientKeyExchange;\n   struct {\n       ProtocolVersion\
    \ client_version;\n       opaque random[46];\n   } PreMasterSecret;\n   struct\
    \ {\n       public-key-encrypted PreMasterSecret pre_master_secret;\n   } EncryptedPreMasterSecret;\n\
    \   enum { implicit, explicit } PublicValueEncoding;\n   struct {\n       select\
    \ (PublicValueEncoding) {\n           case implicit: struct {};\n           case\
    \ explicit: opaque DH_Yc<1..2^16-1>;\n       } dh_public;\n   } ClientDiffieHellmanPublic;\n\
    \   struct {\n        digitally-signed struct {\n            opaque handshake_messages[handshake_messages_length];\n\
    \        }\n   } CertificateVerify;\n"
- title: A.4.4.  Handshake Finalization Message
  contents:
  - "A.4.4.  Handshake Finalization Message\n   struct {\n       opaque verify_data[verify_data_length];\n\
    \   } Finished;\n"
- title: A.5.  The Cipher Suite
  contents:
  - "A.5.  The Cipher Suite\n   The following values define the cipher suite codes\
    \ used in the\n   ClientHello and ServerHello messages.\n   A cipher suite defines\
    \ a cipher specification supported in TLS\n   Version 1.2.\n   TLS_NULL_WITH_NULL_NULL\
    \ is specified and is the initial state of a\n   TLS connection during the first\
    \ handshake on that channel, but MUST\n   NOT be negotiated, as it provides no\
    \ more protection than an\n   unsecured connection.\n      CipherSuite TLS_NULL_WITH_NULL_NULL\
    \               = { 0x00,0x00 };\n   The following CipherSuite definitions require\
    \ that the server provide\n   an RSA certificate that can be used for key exchange.\
    \  The server may\n   request any signature-capable certificate in the certificate\
    \ request\n   message.\n      CipherSuite TLS_RSA_WITH_NULL_MD5              \
    \   = { 0x00,0x01 };\n      CipherSuite TLS_RSA_WITH_NULL_SHA                \
    \ = { 0x00,0x02 };\n      CipherSuite TLS_RSA_WITH_NULL_SHA256              =\
    \ { 0x00,0x3B };\n      CipherSuite TLS_RSA_WITH_RC4_128_MD5              = {\
    \ 0x00,0x04 };\n      CipherSuite TLS_RSA_WITH_RC4_128_SHA              = { 0x00,0x05\
    \ };\n      CipherSuite TLS_RSA_WITH_3DES_EDE_CBC_SHA         = { 0x00,0x0A };\n\
    \      CipherSuite TLS_RSA_WITH_AES_128_CBC_SHA          = { 0x00,0x2F };\n  \
    \    CipherSuite TLS_RSA_WITH_AES_256_CBC_SHA          = { 0x00,0x35 };\n    \
    \  CipherSuite TLS_RSA_WITH_AES_128_CBC_SHA256       = { 0x00,0x3C };\n      CipherSuite\
    \ TLS_RSA_WITH_AES_256_CBC_SHA256       = { 0x00,0x3D };\n   The following cipher\
    \ suite definitions are used for server-\n   authenticated (and optionally client-authenticated)\
    \ Diffie-Hellman.\n   DH denotes cipher suites in which the server's certificate\
    \ contains\n   the Diffie-Hellman parameters signed by the certificate authority\n\
    \   (CA).  DHE denotes ephemeral Diffie-Hellman, where the Diffie-Hellman\n  \
    \ parameters are signed by a signature-capable certificate, which has\n   been\
    \ signed by the CA.  The signing algorithm used by the server is\n   specified\
    \ after the DHE component of the CipherSuite name.  The\n   server can request\
    \ any signature-capable certificate from the client\n   for client authentication,\
    \ or it may request a Diffie-Hellman\n   certificate.  Any Diffie-Hellman certificate\
    \ provided by the client\n   must use the parameters (group and generator) described\
    \ by the\n   server.\n      CipherSuite TLS_DH_DSS_WITH_3DES_EDE_CBC_SHA     \
    \ = { 0x00,0x0D };\n      CipherSuite TLS_DH_RSA_WITH_3DES_EDE_CBC_SHA      =\
    \ { 0x00,0x10 };\n      CipherSuite TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA     = {\
    \ 0x00,0x13 };\n      CipherSuite TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA     = { 0x00,0x16\
    \ };\n      CipherSuite TLS_DH_DSS_WITH_AES_128_CBC_SHA       = { 0x00,0x30 };\n\
    \      CipherSuite TLS_DH_RSA_WITH_AES_128_CBC_SHA       = { 0x00,0x31 };\n  \
    \    CipherSuite TLS_DHE_DSS_WITH_AES_128_CBC_SHA      = { 0x00,0x32 };\n    \
    \  CipherSuite TLS_DHE_RSA_WITH_AES_128_CBC_SHA      = { 0x00,0x33 };\n      CipherSuite\
    \ TLS_DH_DSS_WITH_AES_256_CBC_SHA       = { 0x00,0x36 };\n      CipherSuite TLS_DH_RSA_WITH_AES_256_CBC_SHA\
    \       = { 0x00,0x37 };\n      CipherSuite TLS_DHE_DSS_WITH_AES_256_CBC_SHA \
    \     = { 0x00,0x38 };\n      CipherSuite TLS_DHE_RSA_WITH_AES_256_CBC_SHA   \
    \   = { 0x00,0x39 };\n      CipherSuite TLS_DH_DSS_WITH_AES_128_CBC_SHA256   \
    \ = { 0x00,0x3E };\n      CipherSuite TLS_DH_RSA_WITH_AES_128_CBC_SHA256    =\
    \ { 0x00,0x3F };\n      CipherSuite TLS_DHE_DSS_WITH_AES_128_CBC_SHA256   = {\
    \ 0x00,0x40 };\n      CipherSuite TLS_DHE_RSA_WITH_AES_128_CBC_SHA256   = { 0x00,0x67\
    \ };\n      CipherSuite TLS_DH_DSS_WITH_AES_256_CBC_SHA256    = { 0x00,0x68 };\n\
    \      CipherSuite TLS_DH_RSA_WITH_AES_256_CBC_SHA256    = { 0x00,0x69 };\n  \
    \    CipherSuite TLS_DHE_DSS_WITH_AES_256_CBC_SHA256   = { 0x00,0x6A };\n    \
    \  CipherSuite TLS_DHE_RSA_WITH_AES_256_CBC_SHA256   = { 0x00,0x6B };\n   The\
    \ following cipher suites are used for completely anonymous\n   Diffie-Hellman\
    \ communications in which neither party is\n   authenticated.  Note that this\
    \ mode is vulnerable to man-in-the-\n   middle attacks.  Using this mode therefore\
    \ is of limited use: These\n   cipher suites MUST NOT be used by TLS 1.2 implementations\
    \ unless the\n   application layer has specifically requested to allow anonymous\
    \ key\n   exchange.  (Anonymous key exchange may sometimes be acceptable, for\n\
    \   example, to support opportunistic encryption when no set-up for\n   authentication\
    \ is in place, or when TLS is used as part of more\n   complex security protocols\
    \ that have other means to ensure\n   authentication.)\n      CipherSuite TLS_DH_anon_WITH_RC4_128_MD5\
    \          = { 0x00,0x18 };\n      CipherSuite TLS_DH_anon_WITH_3DES_EDE_CBC_SHA\
    \     = { 0x00,0x1B };\n      CipherSuite TLS_DH_anon_WITH_AES_128_CBC_SHA   \
    \   = { 0x00,0x34 };\n      CipherSuite TLS_DH_anon_WITH_AES_256_CBC_SHA     \
    \ = { 0x00,0x3A };\n      CipherSuite TLS_DH_anon_WITH_AES_128_CBC_SHA256   =\
    \ { 0x00,0x6C };\n      CipherSuite TLS_DH_anon_WITH_AES_256_CBC_SHA256   = {\
    \ 0x00,0x6D };\n   Note that using non-anonymous key exchange without actually\
    \ verifying\n   the key exchange is essentially equivalent to anonymous key exchange,\n\
    \   and the same precautions apply.  While non-anonymous key exchange\n   will\
    \ generally involve a higher computational and communicational\n   cost than anonymous\
    \ key exchange, it may be in the interest of\n   interoperability not to disable\
    \ non-anonymous key exchange when the\n   application layer is allowing anonymous\
    \ key exchange.\n   New cipher suite values have been assigned by IANA as described\
    \ in\n   Section 12.\n   Note: The cipher suite values { 0x00, 0x1C } and { 0x00,\
    \ 0x1D } are\n   reserved to avoid collision with Fortezza-based cipher suites\
    \ in\n   SSL 3.\n"
- title: A.6.  The Security Parameters
  contents:
  - "A.6.  The Security Parameters\n   These security parameters are determined by\
    \ the TLS Handshake\n   Protocol and provided as parameters to the TLS record\
    \ layer in order\n   to initialize a connection state.  SecurityParameters includes:\n\
    \   enum { null(0), (255) } CompressionMethod;\n   enum { server, client } ConnectionEnd;\n\
    \   enum { tls_prf_sha256 } PRFAlgorithm;\n   enum { null, rc4, 3des, aes } BulkCipherAlgorithm;\n\
    \   enum { stream, block, aead } CipherType;\n   enum { null, hmac_md5, hmac_sha1,\
    \ hmac_sha256, hmac_sha384,\n     hmac_sha512} MACAlgorithm;\n   /* Other values\
    \ may be added to the algorithms specified in\n   CompressionMethod, PRFAlgorithm,\
    \ BulkCipherAlgorithm, and\n   MACAlgorithm. */\n   struct {\n       ConnectionEnd\
    \          entity;\n       PRFAlgorithm           prf_algorithm;\n       BulkCipherAlgorithm\
    \    bulk_cipher_algorithm;\n       CipherType             cipher_type;\n    \
    \   uint8                  enc_key_length;\n       uint8                  block_length;\n\
    \       uint8                  fixed_iv_length;\n       uint8                \
    \  record_iv_length;\n       MACAlgorithm           mac_algorithm;\n       uint8\
    \                  mac_length;\n       uint8                  mac_key_length;\n\
    \       CompressionMethod      compression_algorithm;\n       opaque         \
    \        master_secret[48];\n       opaque                 client_random[32];\n\
    \       opaque                 server_random[32];\n   } SecurityParameters;\n"
- title: A.7.  Changes to RFC 4492
  contents:
  - "A.7.  Changes to RFC 4492\n   RFC 4492 [TLSECC] adds Elliptic Curve cipher suites\
    \ to TLS.  This\n   document changes some of the structures used in that document.\
    \  This\n   section details the required changes for implementors of both RFC\n\
    \   4492 and TLS 1.2.  Implementors of TLS 1.2 who are not implementing\n   RFC\
    \ 4492 do not need to read this section.\n   This document adds a \"signature_algorithm\"\
    \ field to the digitally-\n   signed element in order to identify the signature\
    \ and digest\n   algorithms used to create a signature.  This change applies to\n\
    \   digital signatures formed using ECDSA as well, thus allowing ECDSA\n   signatures\
    \ to be used with digest algorithms other than SHA-1,\n   provided such use is\
    \ compatible with the certificate and any\n   restrictions imposed by future revisions\
    \ of [PKIX].\n   As described in Sections 7.4.2 and 7.4.6, the restrictions on\
    \ the\n   signature algorithms used to sign certificates are no longer tied to\n\
    \   the cipher suite (when used by the server) or the\n   ClientCertificateType\
    \ (when used by the client).  Thus, the\n   restrictions on the algorithm used\
    \ to sign certificates specified in\n   Sections 2 and 3 of RFC 4492 are also\
    \ relaxed.  As in this document,\n   the restrictions on the keys in the end-entity\
    \ certificate remain.\n"
- title: Appendix B.  Glossary
  contents:
  - "Appendix B.  Glossary\n   Advanced Encryption Standard (AES)\n      AES [AES]\
    \ is a widely used symmetric encryption algorithm.  AES is\n      a block cipher\
    \ with a 128-, 192-, or 256-bit keys and a 16-byte\n      block size.  TLS currently\
    \ only supports the 128- and 256-bit key\n      sizes.\n   application protocol\n\
    \      An application protocol is a protocol that normally layers\n      directly\
    \ on top of the transport layer (e.g., TCP/IP).  Examples\n      include HTTP,\
    \ TELNET, FTP, and SMTP.\n   asymmetric cipher\n      See public key cryptography.\n\
    \   authenticated encryption with additional data (AEAD)\n      A symmetric encryption\
    \ algorithm that simultaneously provides\n      confidentiality and message integrity.\n\
    \   authentication\n      Authentication is the ability of one entity to determine\
    \ the\n      identity of another entity.\n   block cipher\n      A block cipher\
    \ is an algorithm that operates on plaintext in\n      groups of bits, called\
    \ blocks.  64 bits was, and 128 bits is, a\n      common block size.\n   bulk\
    \ cipher\n      A symmetric encryption algorithm used to encrypt large quantities\n\
    \      of data.\n   cipher block chaining (CBC)\n      CBC is a mode in which\
    \ every plaintext block encrypted with a\n      block cipher is first exclusive-ORed\
    \ with the previous ciphertext\n      block (or, in the case of the first block,\
    \ with the initialization\n      vector).  For decryption, every block is first\
    \ decrypted, then\n      exclusive-ORed with the previous ciphertext block (or\
    \ IV).\n   certificate\n      As part of the X.509 protocol (a.k.a. ISO Authentication\n\
    \      framework), certificates are assigned by a trusted Certificate\n      Authority\
    \ and provide a strong binding between a party's identity\n      or some other\
    \ attributes and its public key.\n   client\n      The application entity that\
    \ initiates a TLS connection to a\n      server.  This may or may not imply that\
    \ the client initiated the\n      underlying transport connection.  The primary\
    \ operational\n      difference between the server and client is that the server\
    \ is\n      generally authenticated, while the client is only optionally\n   \
    \   authenticated.\n   client write key\n      The key used to encrypt data written\
    \ by the client.\n   client write MAC key\n      The secret data used to authenticate\
    \ data written by the client.\n   connection\n      A connection is a transport\
    \ (in the OSI layering model definition)\n      that provides a suitable type\
    \ of service.  For TLS, such\n      connections are peer-to-peer relationships.\
    \  The connections are\n      transient.  Every connection is associated with\
    \ one session.\n   Data Encryption Standard\n      DES [DES] still is a very widely\
    \ used symmetric encryption\n      algorithm although it is considered as rather\
    \ weak now.  DES is a\n      block cipher with a 56-bit key and an 8-byte block\
    \ size.  Note\n      that in TLS, for key generation purposes, DES is treated\
    \ as having\n      an 8-byte key length (64 bits), but it still only provides\
    \ 56 bits\n      of protection.  (The low bit of each key byte is presumed to\
    \ be\n      set to produce odd parity in that key byte.)  DES can also be\n  \
    \    operated in a mode [3DES] where three independent keys and three\n      encryptions\
    \ are used for each block of data; this uses 168 bits of\n      key (24 bytes\
    \ in the TLS key generation method) and provides the\n      equivalent of 112\
    \ bits of security.\n   Digital Signature Standard (DSS)\n      A standard for\
    \ digital signing, including the Digital Signing\n      Algorithm, approved by\
    \ the National Institute of Standards and\n      Technology, defined in NIST FIPS\
    \ PUB 186-2, \"Digital Signature\n      Standard\", published January 2000 by\
    \ the U.S. Department of\n      Commerce [DSS].  A significant update [DSS-3]\
    \ has been drafted and\n      was published in March 2006.\n   digital signatures\n\
    \      Digital signatures utilize public key cryptography and one-way\n      hash\
    \ functions to produce a signature of the data that can be\n      authenticated,\
    \ and is difficult to forge or repudiate.\n   handshake An initial negotiation\
    \ between client and server that\n      establishes the parameters of their transactions.\n\
    \   Initialization Vector (IV)\n      When a block cipher is used in CBC mode,\
    \ the initialization vector\n      is exclusive-ORed with the first plaintext\
    \ block prior to\n      encryption.\n   Message Authentication Code (MAC)\n  \
    \    A Message Authentication Code is a one-way hash computed from a\n      message\
    \ and some secret data.  It is difficult to forge without\n      knowing the secret\
    \ data.  Its purpose is to detect if the message\n      has been altered.\n  \
    \ master secret\n      Secure secret data used for generating encryption keys,\
    \ MAC\n      secrets, and IVs.\n   MD5\n      MD5 [MD5] is a hashing function\
    \ that converts an arbitrarily long\n      data stream into a hash of fixed size\
    \ (16 bytes).  Due to\n      significant progress in cryptanalysis, at the time\
    \ of publication\n      of this document, MD5 no longer can be considered a 'secure'\n\
    \      hashing function.\n   public key cryptography\n      A class of cryptographic\
    \ techniques employing two-key ciphers.\n      Messages encrypted with the public\
    \ key can only be decrypted with\n      the associated private key.  Conversely,\
    \ messages signed with the\n      private key can be verified with the public\
    \ key.\n   one-way hash function\n      A one-way transformation that converts\
    \ an arbitrary amount of data\n      into a fixed-length hash.  It is computationally\
    \ hard to reverse\n      the transformation or to find collisions.  MD5 and SHA\
    \ are\n      examples of one-way hash functions.\n   RC4\n      A stream cipher\
    \ invented by Ron Rivest.  A compatible cipher is\n      described in [SCH].\n\
    \   RSA\n      A very widely used public key algorithm that can be used for\n\
    \      either encryption or digital signing.  [RSA]\n   server\n      The server\
    \ is the application entity that responds to requests for\n      connections from\
    \ clients.  See also \"client\".\n   session\n      A TLS session is an association\
    \ between a client and a server.\n      Sessions are created by the handshake\
    \ protocol.  Sessions define a\n      set of cryptographic security parameters\
    \ that can be shared among\n      multiple connections.  Sessions are used to\
    \ avoid the expensive\n      negotiation of new security parameters for each connection.\n\
    \   session identifier\n      A session identifier is a value generated by a server\
    \ that\n      identifies a particular session.\n   server write key\n      The\
    \ key used to encrypt data written by the server.\n   server write MAC key\n \
    \     The secret data used to authenticate data written by the server.\n   SHA\n\
    \      The Secure Hash Algorithm [SHS] is defined in FIPS PUB 180-2.  It\n   \
    \   produces a 20-byte output.  Note that all references to SHA\n      (without\
    \ a numerical suffix) actually use the modified SHA-1\n      algorithm.\n   SHA-256\n\
    \      The 256-bit Secure Hash Algorithm is defined in FIPS PUB 180-2.\n     \
    \ It produces a 32-byte output.\n   SSL\n      Netscape's Secure Socket Layer\
    \ protocol [SSL3].  TLS is based on\n      SSL Version 3.0.\n   stream cipher\n\
    \      An encryption algorithm that converts a key into a\n      cryptographically\
    \ strong keystream, which is then exclusive-ORed\n      with the plaintext.\n\
    \   symmetric cipher\n      See bulk cipher.\n   Transport Layer Security (TLS)\n\
    \      This protocol; also, the Transport Layer Security working group of\n  \
    \    the Internet Engineering Task Force (IETF).  See \"Working Group\n      Information\"\
    \ at the end of this document (see page 99).\n"
- title: Appendix C.  Cipher Suite Definitions
  contents:
  - 'Appendix C.  Cipher Suite Definitions

    '
- title: Cipher Suite                            Key        Cipher         Mac
  contents:
  - "Cipher Suite                            Key        Cipher         Mac\n     \
    \                                   Exchange\n"
- title: TLS_NULL_WITH_NULL_NULL                 NULL         NULL         NULL
  contents:
  - 'TLS_NULL_WITH_NULL_NULL                 NULL         NULL         NULL

    '
- title: TLS_RSA_WITH_NULL_MD5                   RSA          NULL         MD5
  contents:
  - 'TLS_RSA_WITH_NULL_MD5                   RSA          NULL         MD5

    '
- title: TLS_RSA_WITH_NULL_SHA                   RSA          NULL         SHA
  contents:
  - 'TLS_RSA_WITH_NULL_SHA                   RSA          NULL         SHA

    '
- title: TLS_RSA_WITH_NULL_SHA256                RSA          NULL         SHA256
  contents:
  - 'TLS_RSA_WITH_NULL_SHA256                RSA          NULL         SHA256

    '
- title: TLS_RSA_WITH_RC4_128_MD5                RSA          RC4_128      MD5
  contents:
  - 'TLS_RSA_WITH_RC4_128_MD5                RSA          RC4_128      MD5

    '
- title: TLS_RSA_WITH_RC4_128_SHA                RSA          RC4_128      SHA
  contents:
  - 'TLS_RSA_WITH_RC4_128_SHA                RSA          RC4_128      SHA

    '
- title: TLS_RSA_WITH_3DES_EDE_CBC_SHA           RSA          3DES_EDE_CBC SHA
  contents:
  - 'TLS_RSA_WITH_3DES_EDE_CBC_SHA           RSA          3DES_EDE_CBC SHA

    '
- title: TLS_RSA_WITH_AES_128_CBC_SHA            RSA          AES_128_CBC  SHA
  contents:
  - 'TLS_RSA_WITH_AES_128_CBC_SHA            RSA          AES_128_CBC  SHA

    '
- title: TLS_RSA_WITH_AES_256_CBC_SHA            RSA          AES_256_CBC  SHA
  contents:
  - 'TLS_RSA_WITH_AES_256_CBC_SHA            RSA          AES_256_CBC  SHA

    '
- title: TLS_RSA_WITH_AES_128_CBC_SHA256         RSA          AES_128_CBC  SHA256
  contents:
  - 'TLS_RSA_WITH_AES_128_CBC_SHA256         RSA          AES_128_CBC  SHA256

    '
- title: TLS_RSA_WITH_AES_256_CBC_SHA256         RSA          AES_256_CBC  SHA256
  contents:
  - 'TLS_RSA_WITH_AES_256_CBC_SHA256         RSA          AES_256_CBC  SHA256

    '
- title: TLS_DH_DSS_WITH_3DES_EDE_CBC_SHA        DH_DSS       3DES_EDE_CBC SHA
  contents:
  - 'TLS_DH_DSS_WITH_3DES_EDE_CBC_SHA        DH_DSS       3DES_EDE_CBC SHA

    '
- title: TLS_DH_RSA_WITH_3DES_EDE_CBC_SHA        DH_RSA       3DES_EDE_CBC SHA
  contents:
  - 'TLS_DH_RSA_WITH_3DES_EDE_CBC_SHA        DH_RSA       3DES_EDE_CBC SHA

    '
- title: TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA       DHE_DSS      3DES_EDE_CBC SHA
  contents:
  - 'TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA       DHE_DSS      3DES_EDE_CBC SHA

    '
- title: TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA       DHE_RSA      3DES_EDE_CBC SHA
  contents:
  - 'TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA       DHE_RSA      3DES_EDE_CBC SHA

    '
- title: TLS_DH_anon_WITH_RC4_128_MD5            DH_anon      RC4_128      MD5
  contents:
  - 'TLS_DH_anon_WITH_RC4_128_MD5            DH_anon      RC4_128      MD5

    '
- title: TLS_DH_anon_WITH_3DES_EDE_CBC_SHA       DH_anon      3DES_EDE_CBC SHA
  contents:
  - 'TLS_DH_anon_WITH_3DES_EDE_CBC_SHA       DH_anon      3DES_EDE_CBC SHA

    '
- title: TLS_DH_DSS_WITH_AES_128_CBC_SHA         DH_DSS       AES_128_CBC  SHA
  contents:
  - 'TLS_DH_DSS_WITH_AES_128_CBC_SHA         DH_DSS       AES_128_CBC  SHA

    '
- title: TLS_DH_RSA_WITH_AES_128_CBC_SHA         DH_RSA       AES_128_CBC  SHA
  contents:
  - 'TLS_DH_RSA_WITH_AES_128_CBC_SHA         DH_RSA       AES_128_CBC  SHA

    '
- title: TLS_DHE_DSS_WITH_AES_128_CBC_SHA        DHE_DSS      AES_128_CBC  SHA
  contents:
  - 'TLS_DHE_DSS_WITH_AES_128_CBC_SHA        DHE_DSS      AES_128_CBC  SHA

    '
- title: TLS_DHE_RSA_WITH_AES_128_CBC_SHA        DHE_RSA      AES_128_CBC  SHA
  contents:
  - 'TLS_DHE_RSA_WITH_AES_128_CBC_SHA        DHE_RSA      AES_128_CBC  SHA

    '
- title: TLS_DH_anon_WITH_AES_128_CBC_SHA        DH_anon      AES_128_CBC  SHA
  contents:
  - 'TLS_DH_anon_WITH_AES_128_CBC_SHA        DH_anon      AES_128_CBC  SHA

    '
- title: TLS_DH_DSS_WITH_AES_256_CBC_SHA         DH_DSS       AES_256_CBC  SHA
  contents:
  - 'TLS_DH_DSS_WITH_AES_256_CBC_SHA         DH_DSS       AES_256_CBC  SHA

    '
- title: TLS_DH_RSA_WITH_AES_256_CBC_SHA         DH_RSA       AES_256_CBC  SHA
  contents:
  - 'TLS_DH_RSA_WITH_AES_256_CBC_SHA         DH_RSA       AES_256_CBC  SHA

    '
- title: TLS_DHE_DSS_WITH_AES_256_CBC_SHA        DHE_DSS      AES_256_CBC  SHA
  contents:
  - 'TLS_DHE_DSS_WITH_AES_256_CBC_SHA        DHE_DSS      AES_256_CBC  SHA

    '
- title: TLS_DHE_RSA_WITH_AES_256_CBC_SHA        DHE_RSA      AES_256_CBC  SHA
  contents:
  - 'TLS_DHE_RSA_WITH_AES_256_CBC_SHA        DHE_RSA      AES_256_CBC  SHA

    '
- title: TLS_DH_anon_WITH_AES_256_CBC_SHA        DH_anon      AES_256_CBC  SHA
  contents:
  - 'TLS_DH_anon_WITH_AES_256_CBC_SHA        DH_anon      AES_256_CBC  SHA

    '
- title: TLS_DH_DSS_WITH_AES_128_CBC_SHA256      DH_DSS       AES_128_CBC  SHA256
  contents:
  - 'TLS_DH_DSS_WITH_AES_128_CBC_SHA256      DH_DSS       AES_128_CBC  SHA256

    '
- title: TLS_DH_RSA_WITH_AES_128_CBC_SHA256      DH_RSA       AES_128_CBC  SHA256
  contents:
  - 'TLS_DH_RSA_WITH_AES_128_CBC_SHA256      DH_RSA       AES_128_CBC  SHA256

    '
- title: TLS_DHE_DSS_WITH_AES_128_CBC_SHA256     DHE_DSS      AES_128_CBC  SHA256
  contents:
  - 'TLS_DHE_DSS_WITH_AES_128_CBC_SHA256     DHE_DSS      AES_128_CBC  SHA256

    '
- title: TLS_DHE_RSA_WITH_AES_128_CBC_SHA256     DHE_RSA      AES_128_CBC  SHA256
  contents:
  - 'TLS_DHE_RSA_WITH_AES_128_CBC_SHA256     DHE_RSA      AES_128_CBC  SHA256

    '
- title: TLS_DH_anon_WITH_AES_128_CBC_SHA256     DH_anon      AES_128_CBC  SHA256
  contents:
  - 'TLS_DH_anon_WITH_AES_128_CBC_SHA256     DH_anon      AES_128_CBC  SHA256

    '
- title: TLS_DH_DSS_WITH_AES_256_CBC_SHA256      DH_DSS       AES_256_CBC  SHA256
  contents:
  - 'TLS_DH_DSS_WITH_AES_256_CBC_SHA256      DH_DSS       AES_256_CBC  SHA256

    '
- title: TLS_DH_RSA_WITH_AES_256_CBC_SHA256      DH_RSA       AES_256_CBC  SHA256
  contents:
  - 'TLS_DH_RSA_WITH_AES_256_CBC_SHA256      DH_RSA       AES_256_CBC  SHA256

    '
- title: TLS_DHE_DSS_WITH_AES_256_CBC_SHA256     DHE_DSS      AES_256_CBC  SHA256
  contents:
  - 'TLS_DHE_DSS_WITH_AES_256_CBC_SHA256     DHE_DSS      AES_256_CBC  SHA256

    '
- title: TLS_DHE_RSA_WITH_AES_256_CBC_SHA256     DHE_RSA      AES_256_CBC  SHA256
  contents:
  - 'TLS_DHE_RSA_WITH_AES_256_CBC_SHA256     DHE_RSA      AES_256_CBC  SHA256

    '
- title: TLS_DH_anon_WITH_AES_256_CBC_SHA256     DH_anon      AES_256_CBC  SHA256
  contents:
  - "TLS_DH_anon_WITH_AES_256_CBC_SHA256     DH_anon      AES_256_CBC  SHA256\n  \
    \                      Key      IV   Block\n"
- title: Cipher        Type    Material  Size  Size
  contents:
  - 'Cipher        Type    Material  Size  Size

    '
- title: '------------  ------  --------  ----  -----'
  contents:
  - '------------  ------  --------  ----  -----

    '
- title: NULL          Stream      0       0    N/A
  contents:
  - 'NULL          Stream      0       0    N/A

    '
- title: RC4_128       Stream     16       0    N/A
  contents:
  - 'RC4_128       Stream     16       0    N/A

    '
- title: 3DES_EDE_CBC  Block      24       8      8
  contents:
  - '3DES_EDE_CBC  Block      24       8      8

    '
- title: AES_128_CBC   Block      16      16     16
  contents:
  - 'AES_128_CBC   Block      16      16     16

    '
- title: AES_256_CBC   Block      32      16     16
  contents:
  - 'AES_256_CBC   Block      32      16     16

    '
- title: MAC       Algorithm    mac_length  mac_key_length
  contents:
  - 'MAC       Algorithm    mac_length  mac_key_length

    '
- title: '--------  -----------  ----------  --------------'
  contents:
  - '--------  -----------  ----------  --------------

    '
- title: NULL      N/A              0             0
  contents:
  - 'NULL      N/A              0             0

    '
- title: MD5       HMAC-MD5        16            16
  contents:
  - 'MD5       HMAC-MD5        16            16

    '
- title: SHA       HMAC-SHA1       20            20
  contents:
  - 'SHA       HMAC-SHA1       20            20

    '
- title: SHA256    HMAC-SHA256     32            32
  contents:
  - "SHA256    HMAC-SHA256     32            32\n   Type\n      Indicates whether\
    \ this is a stream cipher or a block cipher\n      running in CBC mode.\n   Key\
    \ Material\n      The number of bytes from the key_block that are used for\n \
    \     generating the write keys.\n   IV Size\n      The amount of data needed\
    \ to be generated for the initialization\n      vector.  Zero for stream ciphers;\
    \ equal to the block size for\n      block ciphers (this is equal to\n      SecurityParameters.record_iv_length).\n\
    \   Block Size\n      The amount of data a block cipher enciphers in one chunk;\
    \ a block\n      cipher running in CBC mode can only encrypt an even multiple\
    \ of\n      its block size.\n"
- title: Appendix D.  Implementation Notes
  contents:
  - "Appendix D.  Implementation Notes\n   The TLS protocol cannot prevent many common\
    \ security mistakes.  This\n   section provides several recommendations to assist\
    \ implementors.\n"
- title: D.1.  Random Number Generation and Seeding
  contents:
  - "D.1.  Random Number Generation and Seeding\n   TLS requires a cryptographically\
    \ secure pseudorandom number generator\n   (PRNG).  Care must be taken in designing\
    \ and seeding PRNGs.  PRNGs\n   based on secure hash operations, most notably\
    \ SHA-1, are acceptable,\n   but cannot provide more security than the size of\
    \ the random number\n   generator state.\n   To estimate the amount of seed material\
    \ being produced, add the\n   number of bits of unpredictable information in each\
    \ seed byte.  For\n   example, keystroke timing values taken from a PC compatible's\
    \ 18.2 Hz\n   timer provide 1 or 2 secure bits each, even though the total size\
    \ of\n   the counter value is 16 bits or more.  Seeding a 128-bit PRNG would\n\
    \   thus require approximately 100 such timer values.\n   [RANDOM] provides guidance\
    \ on the generation of random values.\n"
- title: D.2.  Certificates and Authentication
  contents:
  - "D.2.  Certificates and Authentication\n   Implementations are responsible for\
    \ verifying the integrity of\n   certificates and should generally support certificate\
    \ revocation\n   messages.  Certificates should always be verified to ensure proper\n\
    \   signing by a trusted Certificate Authority (CA).  The selection and\n   addition\
    \ of trusted CAs should be done very carefully.  Users should\n   be able to view\
    \ information about the certificate and root CA.\n"
- title: D.3.  Cipher Suites
  contents:
  - "D.3.  Cipher Suites\n   TLS supports a range of key sizes and security levels,\
    \ including some\n   that provide no or minimal security.  A proper implementation\
    \ will\n   probably not support many cipher suites.  For instance, anonymous\n\
    \   Diffie-Hellman is strongly discouraged because it cannot prevent man-\n  \
    \ in-the-middle attacks.  Applications should also enforce minimum and\n   maximum\
    \ key sizes.  For example, certificate chains containing 512-\n   bit RSA keys\
    \ or signatures are not appropriate for high-security\n   applications.\n"
- title: D.4.  Implementation Pitfalls
  contents:
  - "D.4.  Implementation Pitfalls\n   Implementation experience has shown that certain\
    \ parts of earlier TLS\n   specifications are not easy to understand, and have\
    \ been a source of\n   interoperability and security problems.  Many of these\
    \ areas have\n   been clarified in this document, but this appendix contains a\
    \ short\n   list of the most important things that require special attention from\n\
    \   implementors.\n   TLS protocol issues:\n   -  Do you correctly handle handshake\
    \ messages that are fragmented to\n      multiple TLS records (see Section 6.2.1)?\
    \ Including corner cases\n      like a ClientHello that is split to several small\
    \ fragments? Do\n      you fragment handshake messages that exceed the maximum\
    \ fragment\n      size? In particular, the certificate and certificate request\n\
    \      handshake messages can be large enough to require fragmentation.\n   -\
    \  Do you ignore the TLS record layer version number in all TLS\n      records\
    \ before ServerHello (see Appendix E.1)?\n   -  Do you handle TLS extensions in\
    \ ClientHello correctly, including\n      omitting the extensions field completely?\n\
    \   -  Do you support renegotiation, both client and server initiated?\n     \
    \ While renegotiation is an optional feature, supporting it is\n      highly recommended.\n\
    \   -  When the server has requested a client certificate, but no\n      suitable\
    \ certificate is available, do you correctly send an empty\n      Certificate\
    \ message, instead of omitting the whole message (see\n      Section 7.4.6)?\n\
    \   Cryptographic details:\n   -  In the RSA-encrypted Premaster Secret, do you\
    \ correctly send and\n      verify the version number? When an error is encountered,\
    \ do you\n      continue the handshake to avoid the Bleichenbacher attack (see\n\
    \      Section 7.4.7.1)?\n   -  What countermeasures do you use to prevent timing\
    \ attacks against\n      RSA decryption and signing operations (see Section 7.4.7.1)?\n\
    \   -  When verifying RSA signatures, do you accept both NULL and missing\n  \
    \    parameters (see Section 4.7)? Do you verify that the RSA padding\n      doesn't\
    \ have additional data after the hash value?  [FI06]\n   -  When using Diffie-Hellman\
    \ key exchange, do you correctly strip\n      leading zero bytes from the negotiated\
    \ key (see Section 8.1.2)?\n   -  Does your TLS client check that the Diffie-Hellman\
    \ parameters sent\n      by the server are acceptable (see Section F.1.1.3)?\n\
    \   -  How do you generate unpredictable IVs for CBC mode ciphers (see\n     \
    \ Section 6.2.3.2)?\n   -  Do you accept long CBC mode padding (up to 255 bytes;\
    \ see Section\n      6.2.3.2)?\n   -  How do you address CBC mode timing attacks\
    \ (Section 6.2.3.2)?\n   -  Do you use a strong and, most importantly, properly\
    \ seeded random\n      number generator (see Appendix D.1) for generating the\
    \ premaster\n      secret (for RSA key exchange), Diffie-Hellman private values,\
    \ the\n      DSA \"k\" parameter, and other security-critical values?\n"
- title: Appendix E.  Backward Compatibility
  contents:
  - 'Appendix E.  Backward Compatibility

    '
- title: E.1.  Compatibility with TLS 1.0/1.1 and SSL 3.0
  contents:
  - "E.1.  Compatibility with TLS 1.0/1.1 and SSL 3.0\n   Since there are various\
    \ versions of TLS (1.0, 1.1, 1.2, and any\n   future versions) and SSL (2.0 and\
    \ 3.0), means are needed to negotiate\n   the specific protocol version to use.\
    \  The TLS protocol provides a\n   built-in mechanism for version negotiation\
    \ so as not to bother other\n   protocol components with the complexities of version\
    \ selection.\n   TLS versions 1.0, 1.1, and 1.2, and SSL 3.0 are very similar,\
    \ and use\n   compatible ClientHello messages; thus, supporting all of them is\n\
    \   relatively easy.  Similarly, servers can easily handle clients trying\n  \
    \ to use future versions of TLS as long as the ClientHello format\n   remains\
    \ compatible, and the client supports the highest protocol\n   version available\
    \ in the server.\n   A TLS 1.2 client who wishes to negotiate with such older\
    \ servers will\n   send a normal TLS 1.2 ClientHello, containing { 3, 3 } (TLS\
    \ 1.2) in\n   ClientHello.client_version.  If the server does not support this\n\
    \   version, it will respond with a ServerHello containing an older\n   version\
    \ number.  If the client agrees to use this version, the\n   negotiation will\
    \ proceed as appropriate for the negotiated protocol.\n   If the version chosen\
    \ by the server is not supported by the client\n   (or not acceptable), the client\
    \ MUST send a \"protocol_version\" alert\n   message and close the connection.\n\
    \   If a TLS server receives a ClientHello containing a version number\n   greater\
    \ than the highest version supported by the server, it MUST\n   reply according\
    \ to the highest version supported by the server.\n   A TLS server can also receive\
    \ a ClientHello containing a version\n   number smaller than the highest supported\
    \ version.  If the server\n   wishes to negotiate with old clients, it will proceed\
    \ as appropriate\n   for the highest version supported by the server that is not\
    \ greater\n   than ClientHello.client_version.  For example, if the server supports\n\
    \   TLS 1.0, 1.1, and 1.2, and client_version is TLS 1.0, the server will\n  \
    \ proceed with a TLS 1.0 ServerHello.  If server supports (or is\n   willing to\
    \ use) only versions greater than client_version, it MUST\n   send a \"protocol_version\"\
    \ alert message and close the connection.\n   Whenever a client already knows\
    \ the highest protocol version known to\n   a server (for example, when resuming\
    \ a session), it SHOULD initiate\n   the connection in that native protocol.\n\
    \   Note: some server implementations are known to implement version\n   negotiation\
    \ incorrectly.  For example, there are buggy TLS 1.0\n   servers that simply close\
    \ the connection when the client offers a\n   version newer than TLS 1.0.  Also,\
    \ it is known that some servers will\n   refuse the connection if any TLS extensions\
    \ are included in\n   ClientHello.  Interoperability with such buggy servers is\
    \ a complex\n   topic beyond the scope of this document, and may require multiple\n\
    \   connection attempts by the client.\n   Earlier versions of the TLS specification\
    \ were not fully clear on\n   what the record layer version number (TLSPlaintext.version)\
    \ should\n   contain when sending ClientHello (i.e., before it is known which\n\
    \   version of the protocol will be employed).  Thus, TLS servers\n   compliant\
    \ with this specification MUST accept any value {03,XX} as\n   the record layer\
    \ version number for ClientHello.\n   TLS clients that wish to negotiate with\
    \ older servers MAY send any\n   value {03,XX} as the record layer version number.\
    \  Typical values\n   would be {03,00}, the lowest version number supported by\
    \ the client,\n   and the value of ClientHello.client_version.  No single value\
    \ will\n   guarantee interoperability with all old servers, but this is a\n  \
    \ complex topic beyond the scope of this document.\n"
- title: E.2.  Compatibility with SSL 2.0
  contents:
  - "E.2.  Compatibility with SSL 2.0\n   TLS 1.2 clients that wish to support SSL\
    \ 2.0 servers MUST send\n   version 2.0 CLIENT-HELLO messages defined in [SSL2].\
    \  The message\n   MUST contain the same version number as would be used for ordinary\n\
    \   ClientHello, and MUST encode the supported TLS cipher suites in the\n   CIPHER-SPECS-DATA\
    \ field as described below.\n   Warning: The ability to send version 2.0 CLIENT-HELLO\
    \ messages will\n   be phased out with all due haste, since the newer ClientHello\
    \ format\n   provides better mechanisms for moving to newer versions and\n   negotiating\
    \ extensions.  TLS 1.2 clients SHOULD NOT support SSL 2.0.\n   However, even TLS\
    \ servers that do not support SSL 2.0 MAY accept\n   version 2.0 CLIENT-HELLO\
    \ messages.  The message is presented below in\n   sufficient detail for TLS server\
    \ implementors; the true definition is\n   still assumed to be [SSL2].\n   For\
    \ negotiation purposes, 2.0 CLIENT-HELLO is interpreted the same\n   way as a\
    \ ClientHello with a \"null\" compression method and no\n   extensions.  Note\
    \ that this message MUST be sent directly on the\n   wire, not wrapped as a TLS\
    \ record.  For the purposes of calculating\n   Finished and CertificateVerify,\
    \ the msg_length field is not\n   considered to be a part of the handshake message.\n\
    \      uint8 V2CipherSpec[3];\n      struct {\n          uint16 msg_length;\n\
    \          uint8 msg_type;\n          Version version;\n          uint16 cipher_spec_length;\n\
    \          uint16 session_id_length;\n          uint16 challenge_length;\n   \
    \       V2CipherSpec cipher_specs[V2ClientHello.cipher_spec_length];\n       \
    \   opaque session_id[V2ClientHello.session_id_length];\n          opaque challenge[V2ClientHello.challenge_length;\n\
    \      } V2ClientHello;\n   msg_length\n      The highest bit MUST be 1; the remaining\
    \ bits contain the length\n      of the following data in bytes.\n   msg_type\n\
    \      This field, in conjunction with the version field, identifies a\n     \
    \ version 2 ClientHello message.  The value MUST be 1.\n   version\n      Equal\
    \ to ClientHello.client_version.\n   cipher_spec_length\n      This field is the\
    \ total length of the field cipher_specs.  It\n      cannot be zero and MUST be\
    \ a multiple of the V2CipherSpec length\n      (3).\n   session_id_length\n  \
    \    This field MUST have a value of zero for a client that claims to\n      support\
    \ TLS 1.2.\n   challenge_length\n      The length in bytes of the client's challenge\
    \ to the server to\n      authenticate itself.  Historically, permissible values\
    \ are between\n      16 and 32 bytes inclusive.  When using the SSLv2 backward-\n\
    \      compatible handshake the client SHOULD use a 32-byte challenge.\n   cipher_specs\n\
    \      This is a list of all CipherSpecs the client is willing and able\n    \
    \  to use.  In addition to the 2.0 cipher specs defined in [SSL2],\n      this\
    \ includes the TLS cipher suites normally sent in\n      ClientHello.cipher_suites,\
    \ with each cipher suite prefixed by a\n      zero byte.  For example, the TLS\
    \ cipher suite {0x00,0x0A} would be\n      sent as {0x00,0x00,0x0A}.\n   session_id\n\
    \      This field MUST be empty.\n   challenge\n      Corresponds to ClientHello.random.\
    \  If the challenge length is\n      less than 32, the TLS server will pad the\
    \ data with leading (note:\n      not trailing) zero bytes to make it 32 bytes\
    \ long.\n   Note: Requests to resume a TLS session MUST use a TLS client hello.\n"
- title: E.3.  Avoiding Man-in-the-Middle Version Rollback
  contents:
  - "E.3.  Avoiding Man-in-the-Middle Version Rollback\n   When TLS clients fall back\
    \ to Version 2.0 compatibility mode, they\n   MUST use special PKCS#1 block formatting.\
    \  This is done so that TLS\n   servers will reject Version 2.0 sessions with\
    \ TLS-capable clients.\n   When a client negotiates SSL 2.0 but also supports\
    \ TLS, it MUST set\n   the right-hand (least-significant) 8 random bytes of the\
    \ PKCS padding\n   (not including the terminal null of the padding) for the RSA\n\
    \   encryption of the ENCRYPTED-KEY-DATA field of the CLIENT-MASTER-KEY\n   to\
    \ 0x03 (the other padding bytes are random).\n   When a TLS-capable server negotiates\
    \ SSL 2.0 it SHOULD, after\n   decrypting the ENCRYPTED-KEY-DATA field, check\
    \ that these 8 padding\n   bytes are 0x03.  If they are not, the server SHOULD\
    \ generate a random\n   value for SECRET-KEY-DATA, and continue the handshake\
    \ (which will\n   eventually fail since the keys will not match).  Note that reporting\n\
    \   the error situation to the client could make the server vulnerable to\n  \
    \ attacks described in [BLEI].\n"
- title: Appendix F.  Security Analysis
  contents:
  - "Appendix F.  Security Analysis\n   The TLS protocol is designed to establish\
    \ a secure connection between\n   a client and a server communicating over an\
    \ insecure channel.  This\n   document makes several traditional assumptions,\
    \ including that\n   attackers have substantial computational resources and cannot\
    \ obtain\n   secret information from sources outside the protocol.  Attackers\
    \ are\n   assumed to have the ability to capture, modify, delete, replay, and\n\
    \   otherwise tamper with messages sent over the communication channel.\n   This\
    \ appendix outlines how TLS has been designed to resist a variety\n   of attacks.\n"
- title: F.1.  Handshake Protocol
  contents:
  - "F.1.  Handshake Protocol\n   The handshake protocol is responsible for selecting\
    \ a cipher spec and\n   generating a master secret, which together comprise the\
    \ primary\n   cryptographic parameters associated with a secure session.  The\n\
    \   handshake protocol can also optionally authenticate parties who have\n   certificates\
    \ signed by a trusted certificate authority.\n"
- title: F.1.1.  Authentication and Key Exchange
  contents:
  - "F.1.1.  Authentication and Key Exchange\n   TLS supports three authentication\
    \ modes: authentication of both\n   parties, server authentication with an unauthenticated\
    \ client, and\n   total anonymity.  Whenever the server is authenticated, the\
    \ channel\n   is secure against man-in-the-middle attacks, but completely anonymous\n\
    \   sessions are inherently vulnerable to such attacks.  Anonymous\n   servers\
    \ cannot authenticate clients.  If the server is authenticated,\n   its certificate\
    \ message must provide a valid certificate chain\n   leading to an acceptable\
    \ certificate authority.  Similarly,\n   authenticated clients must supply an\
    \ acceptable certificate to the\n   server.  Each party is responsible for verifying\
    \ that the other's\n   certificate is valid and has not expired or been revoked.\n\
    \   The general goal of the key exchange process is to create a\n   pre_master_secret\
    \ known to the communicating parties and not to\n   attackers.  The pre_master_secret\
    \ will be used to generate the\n   master_secret (see Section 8.1).  The master_secret\
    \ is required to\n   generate the Finished messages, encryption keys, and MAC\
    \ keys (see\n   Sections 7.4.9 and 6.3).  By sending a correct Finished message,\n\
    \   parties thus prove that they know the correct pre_master_secret.\n"
- title: F.1.1.1.  Anonymous Key Exchange
  contents:
  - "F.1.1.1.  Anonymous Key Exchange\n   Completely anonymous sessions can be established\
    \ using Diffie-Hellman\n   for key exchange.  The server's public parameters are\
    \ contained in\n   the server key exchange message, and the client's are sent\
    \ in the\n   client key exchange message.  Eavesdroppers who do not know the\n\
    \   private values should not be able to find the Diffie-Hellman result\n   (i.e.,\
    \ the pre_master_secret).\n   Warning: Completely anonymous connections only provide\
    \ protection\n   against passive eavesdropping.  Unless an independent tamper-proof\n\
    \   channel is used to verify that the Finished messages were not\n   replaced\
    \ by an attacker, server authentication is required in\n   environments where\
    \ active man-in-the-middle attacks are a concern.\n"
- title: F.1.1.2.  RSA Key Exchange and Authentication
  contents:
  - "F.1.1.2.  RSA Key Exchange and Authentication\n   With RSA, key exchange and\
    \ server authentication are combined.  The\n   public key is contained in the\
    \ server's certificate.  Note that\n   compromise of the server's static RSA key\
    \ results in a loss of\n   confidentiality for all sessions protected under that\
    \ static key.\n   TLS users desiring Perfect Forward Secrecy should use DHE cipher\n\
    \   suites.  The damage done by exposure of a private key can be limited\n   by\
    \ changing one's private key (and certificate) frequently.\n   After verifying\
    \ the server's certificate, the client encrypts a\n   pre_master_secret with the\
    \ server's public key.  By successfully\n   decoding the pre_master_secret and\
    \ producing a correct Finished\n   message, the server demonstrates that it knows\
    \ the private key\n   corresponding to the server certificate.\n   When RSA is\
    \ used for key exchange, clients are authenticated using\n   the certificate verify\
    \ message (see Section 7.4.8).  The client signs\n   a value derived from all\
    \ preceding handshake messages.  These\n   handshake messages include the server\
    \ certificate, which binds the\n   signature to the server, and ServerHello.random,\
    \ which binds the\n   signature to the current handshake process.\n"
- title: F.1.1.3.  Diffie-Hellman Key Exchange with Authentication
  contents:
  - "F.1.1.3.  Diffie-Hellman Key Exchange with Authentication\n   When Diffie-Hellman\
    \ key exchange is used, the server can either\n   supply a certificate containing\
    \ fixed Diffie-Hellman parameters or\n   use the server key exchange message to\
    \ send a set of temporary\n   Diffie-Hellman parameters signed with a DSA or RSA\
    \ certificate.\n   Temporary parameters are hashed with the hello.random values\
    \ before\n   signing to ensure that attackers do not replay old parameters.  In\n\
    \   either case, the client can verify the certificate or signature to\n   ensure\
    \ that the parameters belong to the server.\n   If the client has a certificate\
    \ containing fixed Diffie-Hellman\n   parameters, its certificate contains the\
    \ information required to\n   complete the key exchange.  Note that in this case\
    \ the client and\n   server will generate the same Diffie-Hellman result (i.e.,\n\
    \   pre_master_secret) every time they communicate.  To prevent the\n   pre_master_secret\
    \ from staying in memory any longer than necessary,\n   it should be converted\
    \ into the master_secret as soon as possible.\n   Client Diffie-Hellman parameters\
    \ must be compatible with those\n   supplied by the server for the key exchange\
    \ to work.\n   If the client has a standard DSA or RSA certificate or is\n   unauthenticated,\
    \ it sends a set of temporary parameters to the server\n   in the client key exchange\
    \ message, then optionally uses a\n   certificate verify message to authenticate\
    \ itself.\n   If the same DH keypair is to be used for multiple handshakes, either\n\
    \   because the client or server has a certificate containing a fixed DH\n   keypair\
    \ or because the server is reusing DH keys, care must be taken\n   to prevent\
    \ small subgroup attacks.  Implementations SHOULD follow the\n   guidelines found\
    \ in [SUBGROUP].\n   Small subgroup attacks are most easily avoided by using one\
    \ of the\n   DHE cipher suites and generating a fresh DH private key (X) for each\n\
    \   handshake.  If a suitable base (such as 2) is chosen, g^X mod p can\n   be\
    \ computed very quickly; therefore, the performance cost is\n   minimized.  Additionally,\
    \ using a fresh key for each handshake\n   provides Perfect Forward Secrecy. \
    \ Implementations SHOULD generate a\n   new X for each handshake when using DHE\
    \ cipher suites.\n   Because TLS allows the server to provide arbitrary DH groups,\
    \ the\n   client should verify that the DH group is of suitable size as defined\n\
    \   by local policy.  The client SHOULD also verify that the DH public\n   exponent\
    \ appears to be of adequate size.  [KEYSIZ] provides a useful\n   guide to the\
    \ strength of various group sizes.  The server MAY choose\n   to assist the client\
    \ by providing a known group, such as those\n   defined in [IKEALG] or [MODP].\
    \  These can be verified by simple\n   comparison.\n"
- title: F.1.2.  Version Rollback Attacks
  contents:
  - "F.1.2.  Version Rollback Attacks\n   Because TLS includes substantial improvements\
    \ over SSL Version 2.0,\n   attackers may try to make TLS-capable clients and\
    \ servers fall back\n   to Version 2.0.  This attack can occur if (and only if)\
    \ two TLS-\n   capable parties use an SSL 2.0 handshake.\n   Although the solution\
    \ using non-random PKCS #1 block type 2 message\n   padding is inelegant, it provides\
    \ a reasonably secure way for Version\n   3.0 servers to detect the attack.  This\
    \ solution is not secure\n   against attackers who can brute-force the key and\
    \ substitute a new\n   ENCRYPTED-KEY-DATA message containing the same key (but\
    \ with normal\n   padding) before the application-specified wait threshold has\
    \ expired.\n   Altering the padding of the least-significant 8 bytes of the PKCS\n\
    \   padding does not impact security for the size of the signed hashes\n   and\
    \ RSA key lengths used in the protocol, since this is essentially\n   equivalent\
    \ to increasing the input block size by 8 bytes.\n"
- title: F.1.3.  Detecting Attacks Against the Handshake Protocol
  contents:
  - "F.1.3.  Detecting Attacks Against the Handshake Protocol\n   An attacker might\
    \ try to influence the handshake exchange to make the\n   parties select different\
    \ encryption algorithms than they would\n   normally choose.\n   For this attack,\
    \ an attacker must actively change one or more\n   handshake messages.  If this\
    \ occurs, the client and server will\n   compute different values for the handshake\
    \ message hashes.  As a\n   result, the parties will not accept each others' Finished\
    \ messages.\n   Without the master_secret, the attacker cannot repair the Finished\n\
    \   messages, so the attack will be discovered.\n"
- title: F.1.4.  Resuming Sessions
  contents:
  - "F.1.4.  Resuming Sessions\n   When a connection is established by resuming a\
    \ session, new\n   ClientHello.random and ServerHello.random values are hashed\
    \ with the\n   session's master_secret.  Provided that the master_secret has not\n\
    \   been compromised and that the secure hash operations used to produce\n   the\
    \ encryption keys and MAC keys are secure, the connection should be\n   secure\
    \ and effectively independent from previous connections.\n   Attackers cannot\
    \ use known encryption keys or MAC secrets to\n   compromise the master_secret\
    \ without breaking the secure hash\n   operations.\n   Sessions cannot be resumed\
    \ unless both the client and server agree.\n   If either party suspects that the\
    \ session may have been compromised,\n   or that certificates may have expired\
    \ or been revoked, it should\n   force a full handshake.  An upper limit of 24\
    \ hours is suggested for\n   session ID lifetimes, since an attacker who obtains\
    \ a master_secret\n   may be able to impersonate the compromised party until the\n\
    \   corresponding session ID is retired.  Applications that may be run in\n  \
    \ relatively insecure environments should not write session IDs to\n   stable\
    \ storage.\n"
- title: F.2.  Protecting Application Data
  contents:
  - "F.2.  Protecting Application Data\n   The master_secret is hashed with the ClientHello.random\
    \ and\n   ServerHello.random to produce unique data encryption keys and MAC\n\
    \   secrets for each connection.\n   Outgoing data is protected with a MAC before\
    \ transmission.  To\n   prevent message replay or modification attacks, the MAC\
    \ is computed\n   from the MAC key, the sequence number, the message length, the\n\
    \   message contents, and two fixed character strings.  The message type\n   field\
    \ is necessary to ensure that messages intended for one TLS\n   record layer client\
    \ are not redirected to another.  The sequence\n   number ensures that attempts\
    \ to delete or reorder messages will be\n   detected.  Since sequence numbers\
    \ are 64 bits long, they should never\n   overflow.  Messages from one party cannot\
    \ be inserted into the\n   other's output, since they use independent MAC keys.\
    \  Similarly, the\n   server write and client write keys are independent, so stream\
    \ cipher\n   keys are used only once.\n   If an attacker does break an encryption\
    \ key, all messages encrypted\n   with it can be read.  Similarly, compromise\
    \ of a MAC key can make\n   message-modification attacks possible.  Because MACs\
    \ are also\n   encrypted, message-alteration attacks generally require breaking\
    \ the\n   encryption algorithm as well as the MAC.\n   Note: MAC keys may be larger\
    \ than encryption keys, so messages can\n   remain tamper resistant even if encryption\
    \ keys are broken.\n"
- title: F.3.  Explicit IVs
  contents:
  - "F.3.  Explicit IVs\n   [CBCATT] describes a chosen plaintext attack on TLS that\
    \ depends on\n   knowing the IV for a record.  Previous versions of TLS [TLS1.0]\
    \ used\n   the CBC residue of the previous record as the IV and therefore\n  \
    \ enabled this attack.  This version uses an explicit IV in order to\n   protect\
    \ against this attack.\n"
- title: F.4.  Security of Composite Cipher Modes
  contents:
  - "F.4.  Security of Composite Cipher Modes\n   TLS secures transmitted application\
    \ data via the use of symmetric\n   encryption and authentication functions defined\
    \ in the negotiated\n   cipher suite.  The objective is to protect both the integrity\
    \ and\n   confidentiality of the transmitted data from malicious actions by\n\
    \   active attackers in the network.  It turns out that the order in\n   which\
    \ encryption and authentication functions are applied to the data\n   plays an\
    \ important role for achieving this goal [ENCAUTH].\n   The most robust method,\
    \ called encrypt-then-authenticate, first\n   applies encryption to the data and\
    \ then applies a MAC to the\n   ciphertext.  This method ensures that the integrity\
    \ and\n   confidentiality goals are obtained with ANY pair of encryption and\n\
    \   MAC functions, provided that the former is secure against chosen\n   plaintext\
    \ attacks and that the MAC is secure against chosen-message\n   attacks.  TLS\
    \ uses another method, called authenticate-then-encrypt,\n   in which first a\
    \ MAC is computed on the plaintext and then the\n   concatenation of plaintext\
    \ and MAC is encrypted.  This method has\n   been proven secure for CERTAIN combinations\
    \ of encryption functions\n   and MAC functions, but it is not guaranteed to be\
    \ secure in general.\n   In particular, it has been shown that there exist perfectly\
    \ secure\n   encryption functions (secure even in the information-theoretic sense)\n\
    \   that combined with any secure MAC function, fail to provide the\n   confidentiality\
    \ goal against an active attack.  Therefore, new cipher\n   suites and operation\
    \ modes adopted into TLS need to be analyzed under\n   the authenticate-then-encrypt\
    \ method to verify that they achieve the\n   stated integrity and confidentiality\
    \ goals.\n   Currently, the security of the authenticate-then-encrypt method has\n\
    \   been proven for some important cases.  One is the case of stream\n   ciphers\
    \ in which a computationally unpredictable pad of the length of\n   the message,\
    \ plus the length of the MAC tag, is produced using a\n   pseudorandom generator\
    \ and this pad is exclusive-ORed with the\n   concatenation of plaintext and MAC\
    \ tag.  The other is the case of CBC\n   mode using a secure block cipher.  In\
    \ this case, security can be\n   shown if one applies one CBC encryption pass\
    \ to the concatenation of\n   plaintext and MAC and uses a new, independent, and\
    \ unpredictable IV\n   for each new pair of plaintext and MAC.  In versions of\
    \ TLS prior to\n   1.1, CBC mode was used properly EXCEPT that it used a predictable\
    \ IV\n   in the form of the last block of the previous ciphertext.  This made\n\
    \   TLS open to chosen plaintext attacks.  This version of the protocol\n   is\
    \ immune to those attacks.  For exact details in the encryption\n   modes proven\
    \ secure, see [ENCAUTH].\n"
- title: F.5.  Denial of Service
  contents:
  - "F.5.  Denial of Service\n   TLS is susceptible to a number of denial-of-service\
    \ (DoS) attacks.\n   In particular, an attacker who initiates a large number of\
    \ TCP\n   connections can cause a server to consume large amounts of CPU for\n\
    \   doing RSA decryption.  However, because TLS is generally used over\n   TCP,\
    \ it is difficult for the attacker to hide his point of origin if\n   proper TCP\
    \ SYN randomization is used [SEQNUM] by the TCP stack.\n   Because TLS runs over\
    \ TCP, it is also susceptible to a number of DoS\n   attacks on individual connections.\
    \  In particular, attackers can\n   forge RSTs, thereby terminating connections,\
    \ or forge partial TLS\n   records, thereby causing the connection to stall. \
    \ These attacks\n   cannot in general be defended against by a TCP-using protocol.\n\
    \   Implementors or users who are concerned with this class of attack\n   should\
    \ use IPsec AH [AH] or ESP [ESP].\n"
- title: F.6.  Final Notes
  contents:
  - "F.6.  Final Notes\n   For TLS to be able to provide a secure connection, both\
    \ the client\n   and server systems, keys, and applications must be secure.  In\n\
    \   addition, the implementation must be free of security errors.\n   The system\
    \ is only as strong as the weakest key exchange and\n   authentication algorithm\
    \ supported, and only trustworthy\n   cryptographic functions should be used.\
    \  Short public keys and\n   anonymous servers should be used with great caution.\
    \  Implementations\n   and users must be careful when deciding which certificates\
    \ and\n   certificate authorities are acceptable; a dishonest certificate\n  \
    \ authority can do tremendous damage.\n"
- title: Normative References
  contents:
  - "Normative References\n   [AES]      National Institute of Standards and Technology,\n\
    \              \"Specification for the Advanced Encryption Standard (AES)\"\n\
    \              FIPS 197.  November 26, 2001.\n   [3DES]     National Institute\
    \ of Standards and Technology,\n              \"Recommendation for the Triple\
    \ Data Encryption Algorithm\n              (TDEA) Block Cipher\", NIST Special\
    \ Publication 800-67, May\n              2004.\n   [DSS]      NIST FIPS PUB 186-2,\
    \ \"Digital Signature Standard\",\n              National Institute of Standards\
    \ and Technology, U.S.\n              Department of Commerce, 2000.\n   [HMAC]\
    \     Krawczyk, H., Bellare, M., and R. Canetti, \"HMAC: Keyed-\n            \
    \  Hashing for Message Authentication\", RFC 2104, February\n              1997.\n\
    \   [MD5]      Rivest, R., \"The MD5 Message-Digest Algorithm\", RFC 1321,\n \
    \             April 1992.\n   [PKCS1]    Jonsson, J. and B. Kaliski, \"Public-Key\
    \ Cryptography\n              Standards (PKCS) #1: RSA Cryptography Specifications\n\
    \              Version 2.1\", RFC 3447, February 2003.\n   [PKIX]     Housley,\
    \ R., Polk, W., Ford, W., and D. Solo, \"Internet\n              X.509 Public\
    \ Key Infrastructure Certificate and\n              Certificate Revocation List\
    \ (CRL) Profile\", RFC 3280,\n              April 2002.\n   [SCH]      B. Schneier.\
    \ \"Applied Cryptography: Protocols, Algorithms,\n              and Source Code\
    \ in C, 2nd ed.\", Published by John Wiley &\n              Sons, Inc. 1996.\n\
    \   [SHS]      NIST FIPS PUB 180-2, \"Secure Hash Standard\", National\n     \
    \         Institute of Standards and Technology, U.S. Department of\n        \
    \      Commerce, August 2002.\n   [REQ]      Bradner, S., \"Key words for use\
    \ in RFCs to Indicate\n              Requirement Levels\", BCP 14, RFC 2119, March\
    \ 1997.\n   [RFC2434]  Narten, T. and H. Alvestrand, \"Guidelines for Writing\
    \ an\n              IANA Considerations Section in RFCs\", BCP 26, RFC 2434,\n\
    \              October 1998.\n   [X680]     ITU-T Recommendation X.680 (2002)\
    \ | ISO/IEC 8824-1:2002,\n              Information technology - Abstract Syntax\
    \ Notation One\n              (ASN.1): Specification of basic notation.\n   [X690]\
    \     ITU-T Recommendation X.690 (2002) | ISO/IEC 8825-1:2002,\n             \
    \ Information technology - ASN.1 encoding Rules:\n              Specification\
    \ of Basic Encoding Rules (BER), Canonical\n              Encoding Rules (CER)\
    \ and Distinguished Encoding Rules\n              (DER).\n"
- title: Informative References
  contents:
  - "Informative References\n   [AEAD]     McGrew, D., \"An Interface and Algorithms\
    \ for Authenticated\n              Encryption\", RFC 5116, January 2008.\n   [AH]\
    \       Kent, S., \"IP Authentication Header\", RFC 4302, December\n         \
    \     2005.\n   [BLEI]     Bleichenbacher D., \"Chosen Ciphertext Attacks against\n\
    \              Protocols Based on RSA Encryption Standard PKCS #1\" in\n     \
    \         Advances in Cryptology -- CRYPTO'98, LNCS vol. 1462,\n             \
    \ pages:  1-12, 1998.\n   [CBCATT]   Moeller, B., \"Security of CBC Ciphersuites\
    \ in SSL/TLS:\n              Problems and Countermeasures\",\n              http://www.openssl.org/~bodo/tls-cbc.txt.\n\
    \   [CBCTIME]  Canvel, B., Hiltgen, A., Vaudenay, S., and M. Vuagnoux,\n     \
    \         \"Password Interception in a SSL/TLS Channel\", Advances in\n      \
    \        Cryptology -- CRYPTO 2003, LNCS vol. 2729, 2003.\n   [CCM]      \"NIST\
    \ Special Publication 800-38C: The CCM Mode for\n              Authentication\
    \ and Confidentiality\",\n              http://csrc.nist.gov/publications/nistpubs/800-38C/\n\
    \              SP800-38C.pdf\n   [DES]      National Institute of Standards and\
    \ Technology, \"Data\n              Encryption Standard (DES)\", FIPS PUB 46-3,\
    \ October 1999.\n   [DSS-3]    NIST FIPS PUB 186-3 Draft, \"Digital Signature\
    \ Standard\",\n              National Institute of Standards and Technology, U.S.\n\
    \              Department of Commerce, 2006.\n   [ECDSA]    American National\
    \ Standards Institute, \"Public Key\n              Cryptography for the Financial\
    \ Services Industry: The\n              Elliptic Curve Digital Signature Algorithm\
    \ (ECDSA)\", ANS\n              X9.62-2005, November 2005.\n   [ENCAUTH]  Krawczyk,\
    \ H., \"The Order of Encryption and Authentication\n              for Protecting\
    \ Communications (Or: How Secure is SSL?)\",\n              Crypto 2001.\n   [ESP]\
    \      Kent, S., \"IP Encapsulating Security Payload (ESP)\", RFC\n          \
    \    4303, December 2005.\n   [FI06]     Hal Finney, \"Bleichenbacher's RSA signature\
    \ forgery based\n              on implementation error\", ietf-openpgp@imc.org\
    \ mailing\n              list, 27 August 2006, http://www.imc.org/ietf-openpgp/\n\
    \              mail-archive/msg14307.html.\n   [GCM]      Dworkin, M., NIST Special\
    \ Publication 800-38D,\n              \"Recommendation for Block Cipher Modes\
    \ of Operation:\n              Galois/Counter Mode (GCM) and GMAC\", November\
    \ 2007.\n   [IKEALG]   Schiller, J., \"Cryptographic Algorithms for Use in the\n\
    \              Internet Key Exchange Version 2 (IKEv2)\", RFC 4307,\n        \
    \      December 2005.\n   [KEYSIZ]   Orman, H. and P. Hoffman, \"Determining Strengths\
    \ For\n              Public Keys Used For Exchanging Symmetric Keys\", BCP 86,\n\
    \              RFC 3766, April 2004.\n   [KPR03]    Klima, V., Pokorny, O., Rosa,\
    \ T., \"Attacking RSA-based\n              Sessions in SSL/TLS\", http://eprint.iacr.org/2003/052/,\n\
    \              March 2003.\n   [MODP]     Kivinen, T. and M. Kojo, \"More Modular\
    \ Exponential (MODP)\n              Diffie-Hellman groups for Internet Key Exchange\
    \ (IKE)\",\n              RFC 3526, May 2003.\n   [PKCS6]    RSA Laboratories,\
    \ \"PKCS #6: RSA Extended Certificate\n              Syntax Standard\", version\
    \ 1.5, November 1993.\n   [PKCS7]    RSA Laboratories, \"PKCS #7: RSA Cryptographic\
    \ Message\n              Syntax Standard\", version 1.5, November 1993.\n   [RANDOM]\
    \   Eastlake, D., 3rd, Schiller, J., and S. Crocker,\n              \"Randomness\
    \ Requirements for Security\", BCP 106, RFC 4086,\n              June 2005.\n\
    \   [RFC3749]  Hollenbeck, S., \"Transport Layer Security Protocol\n         \
    \     Compression Methods\", RFC 3749, May 2004.\n   [RFC4366]  Blake-Wilson,\
    \ S., Nystrom, M., Hopwood, D., Mikkelsen, J.,\n              and T. Wright, \"\
    Transport Layer Security (TLS)\n              Extensions\", RFC 4366, April 2006.\n\
    \   [RSA]      R. Rivest, A. Shamir, and L. M. Adleman, \"A Method for\n     \
    \         Obtaining Digital Signatures and Public-Key\n              Cryptosystems\"\
    , Communications of the ACM, v. 21, n. 2,\n              Feb 1978, pp. 120-126.\n\
    \   [SEQNUM]   Bellovin, S., \"Defending Against Sequence Number Attacks\",\n\
    \              RFC 1948, May 1996.\n   [SSL2]     Hickman, Kipp, \"The SSL Protocol\"\
    , Netscape Communications\n              Corp., Feb 9, 1995.\n   [SSL3]     A.\
    \ Freier, P. Karlton, and P. Kocher, \"The SSL 3.0\n              Protocol\",\
    \ Netscape Communications Corp., Nov 18, 1996.\n   [SUBGROUP] Zuccherato, R.,\
    \ \"Methods for Avoiding the \"Small-Subgroup\"\n              Attacks on the\
    \ Diffie-Hellman Key Agreement Method for\n              S/MIME\", RFC 2785, March\
    \ 2000.\n   [TCP]      Postel, J., \"Transmission Control Protocol\", STD 7, RFC\n\
    \              793, September 1981.\n   [TIMING]   Boneh, D., Brumley, D., \"\
    Remote timing attacks are\n              practical\", USENIX Security Symposium\
    \ 2003.\n   [TLSAES]   Chown, P., \"Advanced Encryption Standard (AES)\n     \
    \         Ciphersuites for Transport Layer Security (TLS)\", RFC\n           \
    \   3268, June 2002.\n   [TLSECC]   Blake-Wilson, S., Bolyard, N., Gupta, V.,\
    \ Hawk, C., and B.\n              Moeller, \"Elliptic Curve Cryptography (ECC)\
    \ Cipher Suites\n              for Transport Layer Security (TLS)\", RFC 4492,\
    \ May 2006.\n   [TLSEXT]   Eastlake, D., 3rd, \"Transport Layer Security (TLS)\n\
    \              Extensions:  Extension Definitions\", Work in Progress,\n     \
    \         February 2008.\n   [TLSPGP]   Mavrogiannopoulos, N., \"Using OpenPGP\
    \ Keys for Transport\n              Layer Security (TLS) Authentication\", RFC\
    \ 5081, November\n              2007.\n   [TLSPSK]   Eronen, P., Ed., and H. Tschofenig,\
    \ Ed., \"Pre-Shared Key\n              Ciphersuites for Transport Layer Security\
    \ (TLS)\", RFC\n              4279, December 2005.\n   [TLS1.0]   Dierks, T. and\
    \ C. Allen, \"The TLS Protocol Version 1.0\",\n              RFC 2246, January\
    \ 1999.\n   [TLS1.1]   Dierks, T. and E. Rescorla, \"The Transport Layer Security\n\
    \              (TLS) Protocol Version 1.1\", RFC 4346, April 2006.\n   [X501]\
    \     ITU-T Recommendation X.501: Information Technology - Open\n            \
    \  Systems Interconnection - The Directory: Models, 1993.\n   [XDR]      Eisler,\
    \ M., Ed., \"XDR: External Data Representation\n              Standard\", STD\
    \ 67, RFC 4506, May 2006.\n"
- title: Working Group Information
  contents:
  - "Working Group Information\n   The discussion list for the IETF TLS working group\
    \ is located at the\n   e-mail address <tls@ietf.org>. Information on the group\
    \ and\n   information on how to subscribe to the list is at\n   <https://www1.ietf.org/mailman/listinfo/tls>\n\
    \   Archives of the list can be found at:\n   <http://www.ietf.org/mail-archive/web/tls/current/index.html>\n"
- title: Contributors
  contents:
  - "Contributors\n   Christopher Allen (co-editor of TLS 1.0)\n   Alacrity Ventures\n\
    \   ChristopherA@AlacrityManagement.com\n   Martin Abadi\n   University of California,\
    \ Santa Cruz\n   abadi@cs.ucsc.edu\n   Steven M. Bellovin\n   Columbia University\n\
    \   smb@cs.columbia.edu\n   Simon Blake-Wilson\n   BCI\n   sblakewilson@bcisse.com\n\
    \   Ran Canetti\n   IBM\n   canetti@watson.ibm.com\n   Pete Chown\n   Skygate\
    \ Technology Ltd\n   pc@skygate.co.uk\n   Taher Elgamal\n   taher@securify.com\n\
    \   Securify\n   Pasi Eronen\n   pasi.eronen@nokia.com\n   Nokia\n   Anil Gangolli\n\
    \   anil@busybuddha.org\n   Kipp Hickman\n   Alfred Hoenes\n   David Hopwood\n\
    \   Independent Consultant\n   david.hopwood@blueyonder.co.uk\n   Phil Karlton\
    \ (co-author of SSLv3)\n   Paul Kocher (co-author of SSLv3)\n   Cryptography Research\n\
    \   paul@cryptography.com\n   Hugo Krawczyk\n   IBM\n   hugo@ee.technion.ac.il\n\
    \   Jan Mikkelsen\n   Transactionware\n   janm@transactionware.com\n   Magnus\
    \ Nystrom\n   RSA Security\n   magnus@rsasecurity.com\n   Robert Relyea\n   Netscape\
    \ Communications\n   relyea@netscape.com\n   Jim Roskind\n   Netscape Communications\n\
    \   jar@netscape.com\n   Michael Sabin\n   Dan Simon\n   Microsoft, Inc.\n   dansimon@microsoft.com\n\
    \   Tom Weinstein\n   Tim Wright\n   Vodafone\n   timothy.wright@vodafone.com\n"
- title: Editors' Addresses
  contents:
  - "Editors' Addresses\n   Tim Dierks\n   Independent\n   EMail: tim@dierks.org\n\
    \   Eric Rescorla\n   RTFM, Inc.\n   EMail: ekr@rtfm.com\n"
- title: Full Copyright Statement
  contents:
  - "Full Copyright Statement\n   Copyright (C) The IETF Trust (2008).\n   This document\
    \ is subject to the rights, licenses and restrictions\n   contained in BCP 78,\
    \ and except as set forth therein, the authors\n   retain all their rights.\n\
    \   This document and the information contained herein are provided on an\n  \
    \ \"AS IS\" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS\n  \
    \ OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY, THE IETF TRUST AND\n   THE\
    \ INTERNET ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS\n   OR IMPLIED,\
    \ INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF\n   THE INFORMATION\
    \ HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED\n   WARRANTIES OF MERCHANTABILITY\
    \ OR FITNESS FOR A PARTICULAR PURPOSE.\n"
- title: Intellectual Property
  contents:
  - "Intellectual Property\n   The IETF takes no position regarding the validity or\
    \ scope of any\n   Intellectual Property Rights or other rights that might be\
    \ claimed to\n   pertain to the implementation or use of the technology described\
    \ in\n   this document or the extent to which any license under such rights\n\
    \   might or might not be available; nor does it represent that it has\n   made\
    \ any independent effort to identify any such rights.  Information\n   on the\
    \ procedures with respect to rights in RFC documents can be\n   found in BCP 78\
    \ and BCP 79.\n   Copies of IPR disclosures made to the IETF Secretariat and any\n\
    \   assurances of licenses to be made available, or the result of an\n   attempt\
    \ made to obtain a general license or permission for the use of\n   such proprietary\
    \ rights by implementers or users of this\n   specification can be obtained from\
    \ the IETF on-line IPR repository at\n   http://www.ietf.org/ipr.\n   The IETF\
    \ invites any interested party to bring to its attention any\n   copyrights, patents\
    \ or patent applications, or other proprietary\n   rights that may cover technology\
    \ that may be required to implement\n   this standard.  Please address the information\
    \ to the IETF at\n   ietf-ipr@ietf.org.\n"
