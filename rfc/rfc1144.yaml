- title: __initial_text__
  contents:
  - "   Network Working Group                                     V. Jacobson/1/\n\
    \   Request for Comments: 1144                                           LBL\n\
    \                          Compressing TCP/IP Headers\n                      \
    \    for Low-Speed Serial Links\n   Status of this Memo\n   This RFC is a proposed\
    \ elective protocol for the Internet community and\n   requests discussion and\
    \ suggestions for improvement.  It describes a\n   method for compressing the\
    \ headers of TCP/IP datagrams to improve\n   performance over low speed serial\
    \ links.  The motivation, implementation\n   and performance of the method are\
    \ described.  C code for a sample\n   implementation is given for reference. \
    \ Distribution of this memo is\n   unlimited.\n   NOTE: Both ASCII and Postscript\
    \ versions of this document are available.\n         The ASCII version, obviously,\
    \ lacks all the figures and all the\n"
- title: information encoded in typographic variation (italics, boldface,
  contents:
  - "\t information encoded in typographic variation (italics, boldface,\n"
- title: etc.).  Since this information was, in the author's opinion, an
  contents:
  - "\t etc.).  Since this information was, in the author's opinion, an\n"
- title: essential part of the document, the ASCII version is at best
  contents:
  - "\t essential part of the document, the ASCII version is at best\n"
- title: incomplete and at worst misleading.  Anyone who plans to work
  contents:
  - "\t incomplete and at worst misleading.  Anyone who plans to work\n"
- title: with this protocol is strongly encouraged obtain the Postscript
  contents:
  - "\t with this protocol is strongly encouraged obtain the Postscript\n"
- title: version of this RFC.
  contents:
  - "\t version of this RFC.\n   Contents\n   1  Introduction                    \
    \                                    1\n   2  The problem                    \
    \                                     1\n   3  The compression algorithm     \
    \                                      4\n      3.1 The basic idea . . . . . .\
    \ . . . . . . . . . . . . . . . . . .  4\n      3.2 The ugly details . . . . .\
    \ . . . . . . . . . . . . . . . . . .  5\n         3.2.1 Overview. . . . . . .\
    \ . . . . . . . . . . . . . . . . . .  5\n         3.2.2 Compressed packet format.\
    \ . . . . . . . . . . . . . . . .  7\n         3.2.3 Compressor processing . .\
    \ . . . . . . . . . . . . . . . .  8\n         3.2.4 Decompressor processing .\
    \ . . . . . . . . . . . . . . . . 12\n   4  Error handling                   \
    \                                  14\n      4.1 Error detection  . . . . . .\
    \ . . . . . . . . . . . . . . . . . 14\n      4.2 Error recovery . . . . . . .\
    \ . . . . . . . . . . . . . . . . . 17\n   5  Configurable parameters and tuning\
    \                                 18\n      5.1 Compression configuration  . .\
    \ . . . . . . . . . . . . . . . . 18\n      5.2 Choosing a maximum transmission\
    \ unit . . . . . . . . . . . . . 20\n      5.3 Interaction with data compression\
    \  . . . . . . . . . . . . . . 21\n   6  Performance measurements            \
    \                               23\n   7  Acknowlegements                    \
    \                                25\n   A  Sample Implementation             \
    \                                 27\n      A.1 Definitions and State Data . .\
    \ . . . . . . . . . . . . . . . . 28\n      A.2 Compression  . . . . . . . . .\
    \ . . . . . . . . . . . . . . . . 31\n      A.3 Decompression  . . . . . . . .\
    \ . . . . . . . . . . . . . . . . 37\n      A.4 Initialization . . . . . . . .\
    \ . . . . . . . . . . . . . . . . 41\n      A.5 Berkeley Unix dependencies . .\
    \ . . . . . . . . . . . . . . . . 41\n   B  Compatibility with past mistakes \
    \                                  43\n      B.1 Living without a framing `type'\
    \ byte . . . . . . . . . . . . . 43\n      B.2 Backwards compatible SLIP servers\
    \  . . . . . . . . . . . . . . 43\n   C  More aggressive compression         \
    \                               45\n   D  Security Considerations            \
    \                                46\n   E  Author's address                  \
    \                                 46\n   1  Introduction\n   As increasingly powerful\
    \ computers find their way into people's homes,\n   there is growing interest\
    \ in extending Internet connectivity to those\n   computers.  Unfortunately, this\
    \ extension exposes some complex problems\n   in link-level framing, address assignment,\
    \ routing, authentication and\n   performance.  As of this writing there is active\
    \ work in all these\n   areas.  This memo describes a method that has been used\
    \ to improve\n   TCP/IP performance over low speed (300 to 19,200 bps) serial\
    \ links.\n   The compression proposed here is similar in spirit to the Thinwire-II\n\
    \   protocol described in [5].  However, this protocol compresses more\n   effectively\
    \ (the average compressed header is 3 bytes compared to 13 in\n   Thinwire-II)\
    \ and is both efficient and simple to implement (the Unix\n   implementation is\
    \ 250 lines of C and requires, on the average, 90us (170\n   instructions) for\
    \ a 20MHz MC68020 to compress or decompress a packet).\n   This compression is\
    \ specific to TCP/IP datagrams./2/  The author\n   investigated compressing UDP/IP\
    \ datagrams but found that they were too\n   infrequent to be worth the bother\
    \ and either there was insufficient\n   datagram-to-datagram coherence for good\
    \ compression (e.g., name server\n   queries) or the higher level protocol headers\
    \ overwhelmed the cost of\n   the UDP/IP header (e.g., Sun's RPC/NFS). Separately\
    \ compressing the IP\n   and the TCP portions of the datagram was also investigated\
    \ but rejected\n   since it increased the average compressed header size by 50%\
    \ and doubled\n   the compression and decompression code size.\n   2  The problem\n\
    \   Internet services one might wish to access over a serial IP link from\n  \
    \ home range from interactive `terminal' type connections (e.g., telnet,\n   rlogin,\
    \ xterm) to bulk data transfer (e.g., ftp, smtp, nntp).  Header\n   compression\
    \ is motivated by the need for good interactive response.\n   I.e., the line efficiency\
    \ of a protocol is the ratio of the data to\n   header+data in a datagram.  If\
    \ efficient bulk data transfer is the only\n   objective, it is always possible\
    \ to make the datagram large enough to\n   approach an efficiency of 100%.\n \
    \  Human-factors studies[15] have found that interactive response is\n   perceived\
    \ as `bad' when low-level feedback (character echo) takes longer\n   ----------------------------\n\
    \     2. The tie to TCP is deeper than might be obvious.  In addition to the\n\
    \   compression `knowing' the format of TCP and IP headers, certain features\n\
    \   of TCP have been used to simplify the compression protocol.  In\n   particular,\
    \ TCP's reliable delivery and the byte-stream conversation\n   model have been\
    \ used to eliminate the need for any kind of error\n   correction dialog in the\
    \ protocol (see sec. 4).\n   than 100 to 200 ms.  Protocol headers interact with\
    \ this threshold three\n   ways:\n   (1) If the line is too slow, it may be impossible\
    \ to fit both the\n       headers and data into a 200 ms window:  One typed character\
    \ results\n       in a 41 byte TCP/IP packet being sent and a 41 byte echo being\n\
    \       received.  The line speed must be at least 4000 bps to handle these\n\
    \       82 bytes in 200 ms.\n   (2) Even with a line fast enough to handle packetized\
    \ typing echo (4800\n       bps or above), there may be an undesirable interaction\
    \ between bulk\n       data and interactive traffic:  For reasonable line efficiency\
    \ the\n       bulk data packet size needs to be 10 to 20 times the header size.\n\
    \       I.e., the line maximum transmission unit or MTU should be 500 to\n   \
    \    1000 bytes for 40 byte TCP/IP headers.  Even with type-of-service\n     \
    \  queuing to give priority to interactive traffic, a telnet packet has\n    \
    \   to wait for any in-progress bulk data packet to finish.  Assuming\n      \
    \ data transfer in only one direction, that wait averages half the MTU\n     \
    \  or 500 ms for a 1024 byte MTU at 9600 bps.\n   (3) Any communication medium\
    \ has a maximum signalling rate, the Shannon\n       limit.  Based on an AT&T\
    \ study[2], the Shannon limit for a typical\n       dialup phone line is around\
    \ 22,000 bps.  Since a full duplex, 9600\n       bps modem already runs at 80%\
    \ of the limit, modem manufacturers are\n       starting to offer asymmetric allocation\
    \ schemes to increase\n       effective bandwidth:  Since a line rarely has equivalent\
    \ amounts of\n       data flowing both directions simultaneously, it is possible\
    \ to give\n       one end of the line more than 11,000 bps by either time-division\n\
    \       multiplexing a half-duplex line (e.g., the Telebit Trailblazer) or\n \
    \      offering a low-speed `reverse channel' (e.g., the USR Courier\n       HST)./3/\
    \ In either case, the modem dynamically tries to guess which\n       end of the\
    \ conversation needs high bandwidth by assuming one end of\n       the conversation\
    \ is a human (i.e., demand is limited to <300 bps by\n       typing speed).  The\
    \ factor-of-forty bandwidth multiplication due to\n       protocol headers will\
    \ fool this allocation heuristic and cause these\n       modems to `thrash'.\n\
    \   From the above, it's clear that one design goal of the compression\n   should\
    \ be to limit the bandwidth demand of typing and ack traffic to at\n   most 300\
    \ bps.  A typical maximum typing speed is around five characters\n   ----------------------------\n\
    \     3. See the excellent discussion of two-wire dialup line capacity in\n  \
    \ [1], chap. 11.  In particular, there is widespread misunderstanding of\n   the\
    \ capabilities of `echo-cancelling' modems (such as those conforming\n   to CCITT\
    \ V.32):  Echo-cancellation can offer each side of a two-wire\n   line the full\
    \ line bandwidth but, since the far talker's signal adds to\n   the local `noise',\
    \ not the full line capacity.  The 22Kbps Shannon limit\n   is a hard-limit on\
    \ data rate through a two-wire telephone connection.\n   per second/4/ which leaves\
    \ a budget 30 - 5 = 25 characters for headers\n   or five bytes of header per\
    \ character typed./5/  Five byte headers solve\n   problems (1) and (3) directly\
    \ and, indirectly, problem (2):  A packet\n   size of 100--200 bytes will easily\
    \ amortize the cost of a five byte\n   header and offer a user 95--98% of the\
    \ line bandwidth for data.  These\n   short packets mean little interference between\
    \ interactive and bulk data\n   traffic (see sec. 5.2).\n   Another design goal\
    \ is that the compression protocol be based solely on\n   information guaranteed\
    \ to be known to both ends of a single serial link.\n   Consider the topology\
    \ shown in fig. 1 where communicating hosts A and B\n   are on separate local\
    \ area nets (the heavy black lines) and the nets are\n   connected by two serial\
    \ links (the open lines between gateways C--D and\n   E--F)./6/ One compression\
    \ possibility would be to convert each TCP/IP\n   conversation into a semantically\
    \ equivalent conversation in a protocol\n   with smaller headers, e.g., to an\
    \ X.25 call.  But, because of routing\n   transients or multipathing, it's entirely\
    \ possible that some of the A--B\n   traffic will follow the A-C-D-B path and\
    \ some will follow the A-E-F-B\n   path.  Similarly, it's possible that A->B traffic\
    \ will flow A-C-D-B and\n   B->A traffic will flow B-F-E-A. None of the gateways\
    \ can count on seeing\n   all the packets in a particular TCP conversation and\
    \ a compression\n   algorithm that works for such a topology cannot be tied to\
    \ the TCP\n   connection syntax.\n   A physical link treated as two, independent,\
    \ simplex links (one each\n   direction) imposes the minimum requirements on topology,\
    \ routing and\n   pipelining.  The ends of each simplex link only have to agree\
    \ on the\n   most recent packet(s) sent on that link.  Thus, although any compression\n\
    \   scheme involves shared state, this state is spatially and temporally\n   ----------------------------\n\
    \     4. See [13].  Typing bursts or multiple character keystrokes such as\n \
    \  cursor keys can exceed this average rate by factors of two to four.\n   However\
    \ the bandwidth demand stays approximately constant since the TCP\n   Nagle algorithm[8]\
    \ aggregates traffic with a <200ms interarrival time\n   and the improved header-to-data\
    \ ratio compensates for the increased\n   data.\n     5. A similar analysis leads\
    \ to essentially the same header size limit\n   for bulk data transfer ack packets.\
    \  Assuming that the MTU has been\n   selected for `unobtrusive' background file\
    \ transfers (i.e., chosen so\n   the packet time is 200--400 ms --- see sec. 5),\
    \ there can be at most 5\n   data packets per second in the `high bandwidth' direction.\
    \  A reasonable\n   TCP implementation will ack at most every other data packet\
    \ so at 5\n   bytes per ack the reverse channel bandwidth is 2.5 * 5 = 12.5 bytes/sec.\n\
    \     6. Note that although the TCP endpoints are A and B, in this example\n \
    \  compression/decompression must be done at the gateway serial links,\n   i.e.,\
    \ between C and D and between E and F. Since A and B are using IP,\n   they cannot\
    \ know that their communication path includes a low speed\n   serial link.  It\
    \ is clearly a requirement that compression not break the\n   IP model, i.e.,\
    \ that compression function between intermediate systems\n   and not just between\
    \ end systems.\n   local and adheres to Dave Clark's principle of fate sharing[4]:\
    \  The two\n   ends can only disagree on the state if the link connecting them\
    \ is\n   inoperable, in which case the disagreement doesn't matter.\n   3  The\
    \ compression algorithm\n   3.1  The basic idea\n   Figure 2 shows a typical (and\
    \ minimum length) TCP/IP datagram header./7/\n   The header size is 40 bytes:\
    \  20 bytes of IP and 20 of TCP.\n   Unfortunately, since the TCP and IP protocols\
    \ were not designed by a\n   committee, all these header fields serve some useful\
    \ purpose and it's\n   not possible to simply omit some in the name of efficiency.\n\
    \   However, TCP establishes connections and, typically, tens or hundreds of\n\
    \   packets are exchanged on each connection.  How much of the per-packet\n  \
    \ information is likely to stay constant over the life of a connection?\n   Half---the\
    \ shaded fields in fig. 3.  So, if the sender and receiver keep\n   track of active\
    \ connections/8/ and the receiver keeps a copy of the\n   header from the last\
    \ packet it saw from each connection, the sender gets\n   a factor-of-two compression\
    \ by sending only a small (<= 8 bit)\n   connection identifier together with the\
    \ 20 bytes that change and letting\n   the receiver fill in the 20 fixed bytes\
    \ from the saved header.\n   One can scavenge a few more bytes by noting that\
    \ any reasonable\n   link-level framing protocol will tell the receiver the length\
    \ of a\n   received message so total length (bytes 2 and 3) is redundant.  But\
    \ then\n   the header checksum (bytes 10 and 11), which protects individual hops\n\
    \   from processing a corrupted IP header, is essentially the only part of\n \
    \  the IP header being sent.  It seems rather silly to protect the\n   transmission\
    \ of information that isn't being transmitted.  So, the\n   receiver can check\
    \ the header checksum when the header is actually sent\n   (i.e., in an uncompressed\
    \ datagram) but, for compressed datagrams,\n   regenerate it locally at the same\
    \ time the rest of the IP header is\n   being regenerated./9/\n   ----------------------------\n\
    \     7. The TCP and IP protocols and protocol headers are described in [10]\n\
    \   and [11].\n     8. The 96-bit tuple <src address, dst address, src port, dst\
    \ port>\n   uniquely identifies a TCP connection.\n     9. The IP header checksum\
    \ is not an end-to-end checksum in the sense\n   of [14]:  The time-to-live update\
    \ forces the IP checksum to be\n   recomputed at each hop.  The author has had\
    \ unpleasant personal\n   experience with the consequences of violating the end-to-end\
    \ argument in\n   [14] and this protocol is careful to pass the end-to-end TCP\
    \ checksum\n   through unmodified.  See sec. 4.\n   This leaves 16 bytes of header\
    \ information to send.  All of these bytes\n   are likely to change over the life\
    \ of the conversation but they do not\n   all change at the same time.  For example,\
    \ during an FTP data transfer\n   only the packet ID, sequence number and checksum\
    \ change in the\n   sender->receiver direction and only the packet ID, ack, checksum\
    \ and,\n   possibly, window, change in the receiver->sender direction.  With a\
    \ copy\n   of the last packet sent for each connection, the sender can figure\
    \ out\n   what fields change in the current packet then send a bitmask indicating\n\
    \   what changed followed by the changing fields./10/\n   If the sender only sends\
    \ fields that differ, the above scheme gets the\n   average header size down to\
    \ around ten bytes.  However, it's worthwhile\n   looking at how the fields change:\
    \  The packet ID typically comes from a\n   counter that is incremented by one\
    \ for each packet sent.  I.e., the\n   difference between the current and previous\
    \ packet IDs should be a\n   small, positive integer, usually <256 (one byte)\
    \ and frequently = 1.\n   For packets from the sender side of a data transfer,\
    \ the sequence number\n   in the current packet will be the sequence number in\
    \ the previous packet\n   plus the amount of data in the previous packet (assuming\
    \ the packets are\n   arriving in order).  Since IP packets can be at most 64K,\
    \ the sequence\n   number change must be < 2^16 (two bytes).  So, if the differences\
    \ in the\n   changing fields are sent rather than the fields themselves, another\n\
    \   three or four bytes per packet can be saved.\n   That gets us to the five-byte\
    \ header target.  Recognizing a couple of\n   special cases will get us three\
    \ byte headers for the two most common\n   cases---interactive typing traffic\
    \ and bulk data transfer---but the\n   basic compression scheme is the differential\
    \ coding developed above.\n   Given that this intellectual exercise suggests it\
    \ is possible to get\n   five byte headers, it seems reasonable to flesh out the\
    \ missing details\n   and actually implement something.\n   3.2  The ugly details\n\
    \   3.2.1  Overview\n   Figure 4 shows a block diagram of the compression software.\
    \  The\n   networking system calls a SLIP output driver with an IP packet to be\n\
    \   ----------------------------\n    10. This is approximately Thinwire-I from\
    \ [5].  A slight modification\n   is to do a `delta encoding' where the sender\
    \ subtracts the previous\n   packet from the current packet (treating each packet\
    \ as an array of 16\n   bit integers), then sends a 20-bit mask indicating the\
    \ non-zero\n   differences followed by those differences.  If distinct conversations\n\
    \   are separated, this is a fairly effective compression scheme (e.g.,\n   typically\
    \ 12-16 byte headers) that doesn't involve the compressor\n   knowing any details\
    \ of the packet structure.  Variations on this theme\n   have been used, successfully,\
    \ for a number of years (e.g., the Proteon\n   router's serial link protocol[3]).\n\
    \   sent over the serial line.  The packet goes through a compressor which\n \
    \  checks if the protocol is TCP. Non-TCP packets and `uncompressible' TCP\n \
    \  packets (described below) are just marked as TYPE_IP and passed to a\n   framer.\
    \  Compressible TCP packets are looked up in an array of packet\n   headers. \
    \ If a matching connection is found, the incoming packet is\n   compressed, the\
    \ (uncompressed) packet header is copied into the array,\n   and a packet of type\
    \ COMPRESSED_TCP is sent to the framer.  If no match\n   is found, the oldest\
    \ entry in the array is discarded, the packet header\n   is copied into that slot,\
    \ and a packet of type UNCOMPRESSED_TCP is sent\n   to the framer.  (An UNCOMPRESSED_TCP\
    \ packet is identical to the original\n   IP packet except the IP protocol field\
    \ is replaced with a connection\n   number---an index into the array of saved,\
    \ per-connection packet\n   headers.  This is how the sender (re-)synchronizes\
    \ the receiver and\n   `seeds' it with the first, uncompressed packet of a compressed\
    \ packet\n   sequence.)\n   The framer is responsible for communicating the packet\
    \ data, type and\n   boundary (so the decompressor can learn how many bytes came\
    \ out of the\n   compressor).  Since the compression is a differential coding,\
    \ the framer\n   must not re-order packets (this is rarely a concern over a single\
    \ serial\n   link).  It must also provide good error detection and, if connection\n\
    \   numbers are compressed, must provide an error indication to the\n   decompressor\
    \ (see sec. 4)./11/\n   The decompressor does a `switch' on the type of incoming\
    \ packets:  For\n   TYPE_IP, the packet is simply passed through.  For UNCOMPRESSED_TCP,\
    \ the\n   connection number is extracted from the IP protocol field and\n   IPPROTO_TCP\
    \ is restored, then the connection number is used as an index\n   into the receiver's\
    \ array of saved TCP/IP headers and the header of the\n   incoming packet is copied\
    \ into the indexed slot.  For COMPRESSED_TCP,\n   the connection number is used\
    \ as an array index to get the TCP/IP header\n   of the last packet from that\
    \ connection, the info in the compressed\n   packet is used to update that header,\
    \ then a new packet is constructed\n   containing the now-current header from\
    \ the array concatenated with the\n   data from the compressed packet.\n   Note\
    \ that the communication is simplex---no information flows in the\n   decompressor-to-compressor\
    \ direction.  In particular, this implies that\n   the decompressor is relying\
    \ on TCP retransmissions to correct the saved\n   state in the event of line errors\
    \ (see sec. 4).\n   ----------------------------\n    11. Link level framing is\
    \ outside the scope of this document.  Any\n   framing that provides the facilities\
    \ listed in this paragraph should be\n   adequate for the compression protocol.\
    \  However, the author encourages\n   potential implementors to see [9] for a\
    \ proposed, standard, SLIP\n   framing.\n   3.2.2  Compressed packet format\n\
    \   Figure 5 shows the format of a compressed TCP/IP packet.  There is a\n   change\
    \ mask that identifies which of the fields expected to change\n   per-packet actually\
    \ changed, a connection number so the receiver can\n   locate the saved copy of\
    \ the last packet for this TCP connection, the\n   unmodified TCP checksum so\
    \ the end-to-end data integrity check will\n   still be valid, then for each bit\
    \ set in the change mask, the amount the\n   associated field changed.  (Optional\
    \ fields, controlled by the mask, are\n   enclosed in dashed lines in the figure.)\
    \  In all cases, the bit is set\n   if the associated field is present and clear\
    \ if the field is absent./12/\n   Since the delta's in the sequence number, etc.,\
    \ are usually small,\n   particularly if the tuning guidelines in section 5 are\
    \ followed, all the\n   numbers are encoded in a variable length scheme that,\
    \ in practice,\n   handles most traffic with eight bits:  A change of one through\
    \ 255 is\n   represented in one byte.  Zero is improbable (a change of zero is\
    \ never\n   sent) so a byte of zero signals an extension:  The next two bytes\
    \ are\n   the MSB and LSB, respectively, of a 16 bit value.  Numbers larger than\n\
    \   16 bits force an uncompressed packet to be sent.  For example, decimal\n \
    \  15 is encoded as hex 0f, 255 as ff, 65534 as 00 ff fe, and zero as 00 00\n\
    \   00.  This scheme packs and decodes fairly efficiently:  The usual case\n \
    \  for both encode and decode executes three instructions on a MC680x0.\n   The\
    \ numbers sent for TCP sequence number and ack are the difference/13/\n   between\
    \ the current value and the value in the previous packet (an\n   uncompressed\
    \ packet is sent if the difference is negative or more than\n   64K). The number\
    \ sent for the window is also the difference between the\n   current and previous\
    \ values.  However, either positive or negative\n   changes are allowed since\
    \ the window is a 16 bit field.  The packet's\n   urgent pointer is sent if URG\
    \ is set (an uncompressed packet is sent if\n   the urgent pointer changes but\
    \ URG is not set).  For packet ID, the\n   number sent is the difference between\
    \ the current and previous values.\n   However, unlike the rest of the compressed\
    \ fields, the assumed change\n   when I is clear is one, not zero.\n   There are\
    \ two important special cases:\n   (1) The sequence number and ack both change\
    \ by the amount of data in the\n       last packet; no window change or URG.\n\
    \   (2) The sequence number changes by the amount of data in the last\n      \
    \ packet, no ack or window change or URG.\n   ----------------------------\n \
    \   12. The bit `P' in the figure is different from the others:  It is a\n   copy\
    \ of the `PUSH' bit from the TCP header.  `PUSH' is a curious\n   anachronism\
    \ considered indispensable by certain members of the Internet\n   community. \
    \ Since PUSH can (and does) change in any datagram, an\n   information preserving\
    \ compression scheme must pass it explicitly.\n    13. All differences are computed\
    \ using two's complement arithmetic.\n   (1) is the case for echoed terminal traffic.\
    \  (2) is the sender side of\n   non-echoed terminal traffic or a unidirectional\
    \ data transfer.  Certain\n   combinations of the S, A, W and U bits of the change\
    \ mask are used to\n   signal these special cases.  `U' (urgent data) is rare\
    \ so two unlikely\n   combinations are S W U (used for case 1) and S A W U (used\
    \ for case 2).\n   To avoid ambiguity, an uncompressed packet is sent if the actual\
    \ changes\n   in a packet are S * W U.\n   Since the `active' connection changes\
    \ rarely (e.g., a user will type for\n   several minutes in a telnet window before\
    \ changing to a different\n   window), the C bit allows the connection number\
    \ to be elided.  If C is\n   clear, the connection is assumed to be the same as\
    \ for the last\n   compressed or uncompressed packet.  If C is set, the connection\
    \ number\n   is in the byte immediately following the change mask./14/\n   From\
    \ the above, it's probably obvious that compressed terminal traffic\n   usually\
    \ looks like (in hex):  0B c c d, where the 0B indicates case (1),\n   c c is\
    \ the two byte TCP checksum and d is the character typed.  Commands\n   to vi\
    \ or emacs, or packets in the data transfer direction of an FTP\n   `put' or `get'\
    \ look like 0F c c d ... , and acks for that FTP look like\n   04 c c a where\
    \ a is the amount of data being acked./15/\n   3.2.3  Compressor processing\n\
    \   The compressor is called with the IP packet to be processed and the\n   compression\
    \ state structure for the outgoing serial line.  It returns a\n   packet ready\
    \ for final framing and the link level `type' of that packet.\n   As the last\
    \ section noted, the compressor converts every input packet\n   into either a\
    \ TYPE_IP, UNCOMPRESSED_TCP or COMPRESSED_TCP packet.  A\n   ----------------------------\n\
    \    14. The connection number is limited to one byte, i.e., 256\n   simultaneously\
    \ active TCP connections.  In almost two years of\n   operation, the author has\
    \ never seen a case where more than sixteen\n   connection states would be useful\
    \ (even in one case where the SLIP link\n   was used as a gateway behind a very\
    \ busy, 64-port terminal multiplexor).\n   Thus this does not seem to be a significant\
    \ restriction and allows the\n   protocol field in UNCOMPRESSED_TCP packets to\
    \ be used for the connection\n   number, simplifying the processing of those packets.\n\
    \    15. It's also obvious that the change mask changes infrequently and\n   could\
    \ often be elided.  In fact, one can do slightly better by saving\n   the last\
    \ compressed packet (it can be at most 16 bytes so this isn't\n   much additional\
    \ state) and checking to see if any of it (except the TCP\n   checksum) has changed.\
    \  If not, send a packet type that means\n   `compressed TCP, same as last time'\
    \ and a packet containing only the\n   checksum and data.  But, since the improvement\
    \ is at most 25%, the added\n   complexity and state doesn't seem justified. \
    \ See appendix C.\n   TYPE_IP packet is an unmodified copy/16/ of the input packet\
    \ and\n   processing it doesn't change the compressor's state in any way.\n  \
    \ An UNCOMPRESSED_TCP packet is identical to the input packet except the\n   IP\
    \ protocol field (byte 9) is changed from `6' (protocol TCP) to a\n   connection\
    \ number.  In addition, the state slot associated with the\n   connection number\
    \ is updated with a copy of the input packet's IP and\n   TCP headers and the\
    \ connection number is recorded as the last connection\n   sent on this serial\
    \ line (for the C compression described below).\n   A COMPRESSED_TCP packet contains\
    \ the data, if any, from the original\n   packet but the IP and TCP headers are\
    \ completely replaced with a new,\n   compressed header.  The connection state\
    \ slot and last connection sent\n   are updated by the input packet exactly as\
    \ for an UNCOMPRESSED_TCP\n   packet.\n   The compressor's decision procedure\
    \ is:\n     - If the packet is not protocol TCP, send it as TYPE_IP.\n     - If\
    \ the packet is an IP fragment (i.e., either the fragment offset\n       field\
    \ is non-zero or the more fragments bit is set), send it as\n       TYPE_IP./17/\n\
    \     - If any of the TCP control bits SYN, FIN or RST are set or if the ACK\n\
    \       bit is clear, consider the packet uncompressible and send it as\n    \
    \   TYPE_IP./18/\n   ----------------------------\n    16. It is not necessary\
    \ (or desirable) to actually duplicate the input\n   packet for any of the three\
    \ output types.  Note that the compressor\n   cannot increase the size of a datagram.\
    \  As the code in appendix A\n   shows, the protocol can be implemented so all\
    \ header modifications are\n   made `in place'.\n    17. Only the first fragment\
    \ contains the TCP header so the fragment\n   offset check is necessary.  The\
    \ first fragment might contain a complete\n   TCP header and, thus, could be compressed.\
    \  However the check for a\n   complete TCP header adds quite a lot of code and,\
    \ given the arguments in\n   [6], it seems reasonable to send all IP fragments\
    \ uncompressed.\n    18. The ACK test is redundant since a standard conforming\n\
    \   implementation must set ACK in all packets except for the initial SYN\n  \
    \ packet.  However, the test costs nothing and avoids turning a bogus\n   packet\
    \ into a valid one.\n   SYN packets are not compressed because only half of them\
    \ contain a valid\n   ACK field and they usually contain a TCP option (the max.\
    \ segment size)\n   which the following packets don't.  Thus the next packet would\
    \ be sent\n   uncompressed because the TCP header length changed and sending the\
    \ SYN\n   as UNCOMPRESSED_TCP instead of TYPE_IP would buy nothing.\n   The decision\
    \ to not compress FIN packets is questionable.  Discounting\n   the trick in appendix\
    \ B.1, there is a free bit in the header that could\n   be used to communicate\
    \ the FIN flag.  However, since connections tend to\n   If a packet makes it through\
    \ the above checks, it will be sent as either\n   UNCOMPRESSED_TCP or COMPRESSED_TCP:\n\
    \     - If no connection state can be found that matches the packet's source\n\
    \       and destination IP addresses and TCP ports, some state is reclaimed\n\
    \       (which should probably be the least recently used) and an\n       UNCOMPRESSED_TCP\
    \ packet is sent.\n     - If a connection state is found, the packet header it\
    \ contains is\n       checked against the current packet to make sure there were\
    \ no\n       unexpected changes.  (E.g., that all the shaded fields in fig. 3\
    \ are\n       the same).  The IP protocol, fragment offset, more fragments, SYN,\n\
    \       FIN and RST fields were checked above and the source and destination\n\
    \       address and ports were checked as part of locating the state.  So\n  \
    \     the remaining fields to check are protocol version, header length,\n   \
    \    type of service, don't fragment, time-to-live, data offset, IP\n       options\
    \ (if any) and TCP options (if any).  If any of these fields\n       differ between\
    \ the two headers, an UNCOMPRESSED_TCP packet is sent.\n   If all the `unchanging'\
    \ fields match, an attempt is made to compress the\n   current packet:\n     -\
    \ If the URG flag is set, the urgent data field is encoded (note that\n      \
    \ it may be zero) and the U bit is set in the change mask.\n       Unfortunately,\
    \ if URG is clear, the urgent data field must be\n       checked against the previous\
    \ packet and, if it changes, an\n       UNCOMPRESSED_TCP packet is sent.  (`Urgent\
    \ data' shouldn't change\n       when URG is clear but [11] doesn't require this.)\n\
    \     - The difference between the current and previous packet's window\n    \
    \   field is computed and, if non-zero, is encoded and the W bit is set\n    \
    \   in the change mask.\n     - The difference between ack fields is computed.\
    \  If the result is\n       less than zero or greater than 2^16 - 1, an UNCOMPRESSED_TCP\
    \ packet\n       is sent./19/  Otherwise, if the result is non-zero, it is encoded\n\
    \       and the A bit is set in the change mask.\n     - The difference between\
    \ sequence number fields is computed.  If the\n       result is less than zero\
    \ or greater than 2^16 - 1, an\n   ----------------------------\n   last for many\
    \ packets, it seemed unreasonable to dedicate an entire bit\n   to a flag that\
    \ would only appear once in the lifetime of the connection.\n    19. The two tests\
    \ can be combined into a single test of the most\n   significant 16 bits of the\
    \ difference being non-zero.\n       UNCOMPRESSED_TCP packet is sent./20/  Otherwise,\
    \ if the result is\n       non-zero, it is encoded and the S bit is set in the\
    \ change mask.\n   Once the U, W, A and S changes have been determined, the special-case\n\
    \   encodings can be checked:\n     - If U, S and W are set, the changes match\
    \ one of the special-case\n       encodings.  Send an UNCOMPRESSED_TCP packet.\n\
    \     - If only S is set, check if the change equals the amount of user data\n\
    \       in the last packet.  I.e., subtract the TCP and IP header lengths\n  \
    \     from the last packet's total length field and compare the result to\n  \
    \     the S change.  If they're the same, set the change mask to SAWU (the\n \
    \      special case for `unidirectional data transfer') and discard the\n    \
    \   encoded sequence number change (the decompressor can reconstruct it\n    \
    \   since it knows the last packet's total length and header length).\n     -\
    \ If only S and A are set, check if they both changed by the same\n       amount\
    \ and that amount is the amount of user data in the last\n       packet.  If so,\
    \ set the change mask to SWU (the special case for\n       `echoed interactive'\
    \ traffic) and discard the encoded changes.\n     - If nothing changed, check\
    \ if this packet has no user data (in which\n       case it is probably a duplicate\
    \ ack or window probe) or if the\n       previous packet contained user data (which\
    \ means this packet is a\n       retransmission on a connection with no pipelining).\
    \  In either of\n       these cases, send an UNCOMPRESSED_TCP packet.\n   Finally,\
    \ the TCP/IP header on the outgoing packet is replaced with a\n   compressed header:\n\
    \     - The change in the packet ID is computed and, if not one,/21/ the\n   \
    \    difference is encoded (note that it may be zero or negative) and the\n  \
    \     I bit is set in the change mask.\n     - If the PUSH bit is set in the original\
    \ datagram, the P bit is set in\n       the change mask.\n     - The TCP and IP\
    \ headers of the packet are copied to the connection\n       state slot.\n   ----------------------------\n\
    \    20. A negative sequence number change probably indicates a\n   retransmission.\
    \  Since this may be due to the decompressor having\n   dropped a packet, an uncompressed\
    \ packet is sent to re-sync the\n   decompressor (see sec. 4).\n    21. Note that\
    \ the test here is against one, not zero.  The packet ID is\n   typically incremented\
    \ by one for each packet sent so a change of zero is\n   very unlikely.  A change\
    \ of one is likely:  It occurs during any period\n   when the originating system\
    \ has activity on only one connection.\n     - The TCP and IP headers of the packet\
    \ are discarded and a new header\n       is prepended consisting of (in reverse\
    \ order):\n         - the accumulated, encoded changes.\n         - the TCP checksum\
    \ (if the new header is being constructed `in\n           place', the checksum\
    \ may have been overwritten and will have to\n           be taken from the header\
    \ copy in the connection state or saved\n           in a temporary before the\
    \ original header is discarded).\n         - the connection number (if different\
    \ than the last one sent on\n           this serial line).  This also means that\
    \ the the line's last\n           connection sent must be set to the connection\
    \ number and the C\n           bit set in the change mask.\n         - the change\
    \ mask.\n   At this point, the compressed TCP packet is passed to the framer for\n\
    \   transmission.\n   3.2.4  Decompressor processing\n   Because of the simplex\
    \ communication model, processing at the\n   decompressor is much simpler than\
    \ at the compressor --- all the\n   decisions have been made and the decompressor\
    \ simply does what the\n   compressor has told it to do.\n   The decompressor\
    \ is called with the incoming packet,/22/ the length and\n   type of the packet\
    \ and the compression state structure for the incoming\n   serial line.  A (possibly\
    \ re-constructed) IP packet will be returned.\n   The decompressor can receive\
    \ four types of packet:  the three generated\n   by the compressor and a TYPE_ERROR\
    \ pseudo-packet generated when the\n   receive framer detects an error./23/  The\
    \ first step is a `switch' on\n   the packet type:\n     - If the packet is TYPE_ERROR\
    \ or an unrecognized type, a `toss' flag\n       is set in the state to force\
    \ COMPRESSED_TCP packets to be discarded\n       until one with the C bit set\
    \ or an UNCOMPRESSED_TCP packet arrives.\n       Nothing (a null packet) is returned.\n\
    \   ----------------------------\n    22. It's assumed that link-level framing\
    \ has been removed by this point\n   and the packet and length do not include\
    \ type or framing bytes.\n    23. No data need be associated with a TYPE_ERROR\
    \ packet.  It exists so\n   the receive framer can tell the decompressor that\
    \ there may be a gap in\n   the data stream.  The decompressor uses this as a\
    \ signal that packets\n   should be tossed until one arrives with an explicit\
    \ connection number (C\n   bit set).  See the last part of sec. 4.1 for a discussion\
    \ of why this is\n   necessary.\n     - If the packet is TYPE_IP, an unmodified\
    \ copy of it is returned and\n       the state is not modified.\n     - If the\
    \ packet is UNCOMPRESSED_TCP, the state index from the IP\n       protocol field\
    \ is checked./24/  If it's illegal, the toss flag is\n       set and nothing is\
    \ returned.  Otherwise, the toss flag is cleared,\n       the index is copied\
    \ to the state's last connection received field, a\n       copy of the input packet\
    \ is made,/25/ the TCP protocol number is\n       restored to the IP protocol\
    \ field, the packet header is copied to\n       the indicated state slot, then\
    \ the packet copy is returned.\n   If the packet was not handled above, it is\
    \ COMPRESSED_TCP and a new\n   TCP/IP header has to be synthesized from information\
    \ in the packet plus\n   the last packet's header in the state slot.  First, the\
    \ explicit or\n   implicit connection number is used to locate the state slot:\n\
    \     - If the C bit is set in the change mask, the state index is checked.\n\
    \       If it's illegal, the toss flag is set and nothing is returned.\n     \
    \  Otherwise, last connection received is set to the packet's state\n       index\
    \ and the toss flag is cleared.\n     - If the C bit is clear and the toss flag\
    \ is set, the packet is\n       ignored and nothing is returned.\n   At this point,\
    \ last connection received is the index of the appropriate\n   state slot and\
    \ the first byte(s) of the compressed packet (the change\n   mask and, possibly,\
    \ connection index) have been consumed.  Since the\n   TCP/IP header in the state\
    \ slot must end up reflecting the newly arrived\n   packet, it's simplest to apply\
    \ the changes from the packet to that\n   header then construct the output packet\
    \ from that header concatenated\n   with the data from the input packet.  (In\
    \ the following description,\n   `saved header' is used as an abbreviation for\
    \ `the TCP/IP header saved\n   in the state slot'.)\n     - The next two bytes\
    \ in the incoming packet are the TCP checksum.\n       They are copied to the\
    \ saved header.\n     - If the P bit is set in the change mask, the TCP PUSH bit\
    \ is set in\n       the saved header.  Otherwise the PUSH bit is cleared.\n  \
    \ ----------------------------\n    24. State indices follow the C language convention\
    \ and run from 0 to N\n   - 1, where 0 < N <= 256 is the number of available state\
    \ slots.\n    25. As with the compressor, the code can be structured so no copies\
    \ are\n   done and all modifications are done in-place.  However, since the output\n\
    \   packet can be larger than the input packet, 128 bytes of free space must\n\
    \   be left at the front of the input packet buffer to allow room to prepend\n\
    \   the TCP/IP header.\n     - If the low order four bits (S, A, W and U) of the\
    \ change mask are\n       all set (the `unidirectional data' special case), the\
    \ amount of user\n       data in the last packet is calculated by subtracting\
    \ the TCP and IP\n       header lengths from the IP total length in the saved\
    \ header.  That\n       amount is then added to the TCP sequence number in the\
    \ saved header.\n     - If S, W and U are set and A is clear (the `terminal traffic'\
    \ special\n       case), the amount of user data in the last packet is calculated\
    \ and\n       added to both the TCP sequence number and ack fields in the saved\n\
    \       header.\n     - Otherwise, the change mask bits are interpreted individually\
    \ in the\n       order that the compressor set them:\n         - If the U bit\
    \ is set, the TCP URG bit is set in the saved header\n           and the next\
    \ byte(s) of the incoming packet are decoded and\n           stuffed into the\
    \ TCP Urgent Pointer.  If the U bit is clear, the\n           TCP URG bit is cleared.\n\
    \         - If the W bit is set, the next byte(s) of the incoming packet are\n\
    \           decoded and added to the TCP window field of the saved header.\n \
    \        - If the A bit is set, the next byte(s) of the incoming packet are\n\
    \           decoded and added to the TCP ack field of the saved header.\n    \
    \     - If the S bit is set, the next byte(s) of the incoming packet are\n   \
    \        decoded and added to the TCP sequence number field of the saved\n   \
    \        header.\n     - If the I bit is set in the change mask, the next byte(s)\
    \ of the\n       incoming packet are decoded and added to the IP ID field of the\n\
    \       saved packet.  Otherwise, one is added to the IP ID.\n   At this point,\
    \ all the header information from the incoming packet has\n   been consumed and\
    \ only data remains.  The length of the remaining data\n   is added to the length\
    \ of the saved IP and TCP headers and the result is\n   put into the saved IP\
    \ total length field.  The saved IP header is now up\n   to date so its checksum\
    \ is recalculated and stored in the IP checksum\n   field.  Finally, an output\
    \ datagram consisting of the saved header\n   concatenated with the remaining\
    \ incoming data is constructed and\n   returned.\n   4  Error handling\n   4.1\
    \  Error detection\n   In the author's experience, dialup connections are particularly\
    \ prone to\n   data errors.  These errors interact with compression in two different\n\
    \   ways:\n   First is the local effect of an error in a compressed packet.  All\
    \ error\n   detection is based on redundancy yet compression has squeezed out\
    \ almost\n   all the redundancy in the TCP and IP headers.  In other words, the\n\
    \   decompressor will happily turn random line noise into a perfectly valid\n\
    \   TCP/IP packet./26/  One could rely on the TCP checksum to detect\n   corrupted\
    \ compressed packets but, unfortunately, some rather likely\n   errors will not\
    \ be detected.  For example, the TCP checksum will often\n   not detect two single\
    \ bit errors separated by 16 bits.  For a V.32 modem\n   signalling at 2400 baud\
    \ with 4 bits/baud, any line hit lasting longer\n   than 400us. would corrupt\
    \ 16 bits.  According to [2], residential phone\n   line hits of up to 2ms. are\
    \ likely.\n   The correct way to deal with this problem is to provide for error\n\
    \   detection at the framing level.  Since the framing (at least in theory)\n\
    \   can be tailored to the characteristics of a particular link, the\n   detection\
    \ can be as light or heavy-weight as appropriate for that\n   link./27/  Since\
    \ packet error detection is done at the framing level,\n   the decompressor simply\
    \ assumes that it will get an indication that the\n   current packet was received\
    \ with errors.  (The decompressor always\n   ignores (discards) a packet with\
    \ errors.  However, the indication is\n   needed to prevent the error being propagated\
    \ --- see below.)\n   The `discard erroneous packets' policy gives rise to the\
    \ second\n   interaction of errors and compression.  Consider the following\n\
    \   conversation:\n                 +-------------------------------------------+\n\
    \                 |original | sent   |received |reconstructed |\n            \
    \     +---------+--------+---------+--------------+\n                 | 1:  A\
    \   | 1:  A  | 1:  A   | 1:  A        |\n                 | 2:  BC  | 1,  BC |\
    \ 1,  BC  | 2:  BC       |\n                 | 4:  DE  | 2,  DE |  ---    |  ---\
    \         |\n                 | 6:  F   | 2,  F  | 2,  F   | 4:  F        |\n\
    \                 | 7:  GH  | 1,  GH | 1,  GH  | 5:  GH       |\n            \
    \     +-------------------------------------------+\n   (Each entry above has\
    \ the form `starting sequence number:data sent' or\n   `?sequence number change,data\
    \ sent'.)  The first thing sent is an\n   uncompressed packet, followed by four\
    \ compressed packets.  The third\n   packet picks up an error and is discarded.\
    \  To reconstruct the fourth\n   packet, the receiver applies the sequence number\
    \ change from incoming\n   compressed packet to the sequence number of the last\
    \ correctly received\n   ----------------------------\n    26. modulo the TCP\
    \ checksum.\n    27. While appropriate error detection is link dependent, the\
    \ CCITT CRC\n   used in [9] strikes an excellent balance between ease of computation\
    \ and\n   robust error detection for a large variety of links, particularly at\
    \ the\n   relatively small packet sizes needed for good interactive response.\n\
    \   Thus, for the sake of interoperability, the framing in [9] should be\n   used\
    \ unless there is a truly compelling reason to do otherwise.\n   packet, packet\
    \ two, and generates an incorrect sequence number for\n   packet four.  After\
    \ the error, all reconstructed packets' sequence\n   numbers will be in error,\
    \ shifted down by the amount of data in the\n   missing packet./28/\n   Without\
    \ some sort of check, the preceding error would result in the\n   receiver invisibly\
    \ losing two bytes from the middle of the transfer\n   (since the decompressor\
    \ regenerates sequence numbers, the packets\n   containing F and GH arrive at\
    \ the receiver's TCP with exactly the\n   sequence numbers they would have had\
    \ if the DE packet had never\n   existed).  Although some TCP conversations can\
    \ survive missing data/29/\n   it is not a practice to be encouraged.  Fortunately\
    \ the TCP checksum,\n   since it is a simple sum of the packet contents including\
    \ the sequence\n   numbers, detects 100% of these errors.  E.g., the receiver's\
    \ computed\n   checksum for the last two packets above always differs from the\
    \ packet\n   checksum by two.\n   Unfortunately, there is a way for the TCP checksum\
    \ protection described\n   above to fail if the changes in an incoming compressed\
    \ packet are\n   applied to the wrong conversation:  Consider two active conversations\
    \ C1\n   and C2 and a packet from C1 followed by two packets from C2.  Since the\n\
    \   connection number doesn't change, it's omitted from the second C2\n   packet.\
    \  But, if the first C2 packet is received with a CRC error, the\n   second C2\
    \ packet will mistakenly be considered the next packet in C1.\n   Since the C2\
    \ checksum is a random number with respect to the C1 sequence\n   numbers, there\
    \ is at least a 2^-16 probability that this packet will be\n   accepted by the\
    \ C1 TCP receiver./30/  To prevent this, after a CRC error\n   indication from\
    \ the framer the receiver discards packets until it\n   receives either a COMPRESSED_TCP\
    \ packet with the C bit set or an\n   UNCOMPRESSED_TCP packet.  I.e., packets\
    \ are discarded until the receiver\n   gets an explicit connection number.\n \
    \  To summarize this section, there are two different types of errors:\n   per-packet\
    \ corruption and per-conversation loss-of-sync.  The first type\n   is detected\
    \ at the decompressor from a link-level CRC error, the second\n   at the TCP receiver\
    \ from a (guaranteed) invalid TCP checksum.  The\n   combination of these two\
    \ independent mechanisms ensures that erroneous\n   packets are discarded.\n \
    \  ----------------------------\n    28. This is an example of a generic problem\
    \ with differential or delta\n   encodings known as `losing DC'.\n    29. Many\
    \ system managers claim that holes in an NNTP stream are more\n   valuable than\
    \ the data.\n    30. With worst-case traffic, this probability translates to one\n\
    \   undetected error every three hours over a 9600 baud line with a 30%\n   error\
    \ rate).\n   4.2  Error recovery\n   The previous section noted that after a CRC\
    \ error the decompressor will\n   introduce TCP checksum errors in every uncompressed\
    \ packet.  Although\n   the checksum errors prevent data stream corruption, the\
    \ TCP conversation\n   won't be terribly useful until the decompressor again generates\
    \ valid\n   packets.  How can this be forced to happen?\n   The decompressor generates\
    \ invalid packets because its state (the saved\n   `last packet header') disagrees\
    \ with the compressor's state.  An\n   UNCOMPRESSED_TCP packet will correct the\
    \ decompressor's state.  Thus\n   error recovery amounts to forcing an uncompressed\
    \ packet out of the\n   compressor whenever the decompressor is (or might be)\
    \ confused.\n   The first thought is to take advantage of the full duplex communication\n\
    \   link and have the decompressor send something to the compressor\n   requesting\
    \ an uncompressed packet.  This is clearly undesirable since it\n   constrains\
    \ the topology more than the minimum suggested in sec. 2 and\n   requires that\
    \ a great deal of protocol be added to both the decompressor\n   and compressor.\
    \  A little thought convinces one that this alternative is\n   not only undesirable,\
    \ it simply won't work:  Compressed packets are\n   small and it's likely that\
    \ a line hit will so completely obliterate one\n   that the decompressor will\
    \ get nothing at all.  Thus packets are\n   reconstructed incorrectly (because\
    \ of the missing compressed packet) but\n   only the TCP end points, not the decompressor,\
    \ know that the packets are\n   incorrect.\n   But the TCP end points know about\
    \ the error and TCP is a reliable\n   protocol designed to run over unreliable\
    \ media.  This means the end\n   points must eventually take some sort of error\
    \ recovery action and\n   there's an obvious trigger for the compressor to resync\
    \ the\n   decompressor:  send uncompressed packets whenever TCP is doing error\n\
    \   recovery.\n   But how does the compressor recognize TCP error recovery?  Consider\
    \ the\n   schematic TCP data transfer of fig. 6.    The confused decompressor\
    \ is\n   in the forward (data transfer) half of the TCP conversation.  The\n \
    \  receiving TCP discards packets rather than acking them (because of the\n  \
    \ checksum errors), the sending TCP eventually times out and retransmits a\n \
    \  packet, and the forward path compressor finds that the difference\n   between\
    \ the sequence number in the retransmitted packet and the sequence\n   number\
    \ in the last packet seen is either negative (if there were\n   multiple packets\
    \ in transit) or zero (one packet in transit).  The first\n   case is detected\
    \ in the compression step that computes sequence number\n   differences.  The\
    \ second case is detected in the step that checks the\n   `special case' encodings\
    \ but needs an additional test:  It's fairly\n   common for an interactive conversation\
    \ to send a dataless ack packet\n   followed by a data packet.  The ack and data\
    \ packet will have the same\n   sequence numbers yet the data packet is not a\
    \ retransmission.  To\n   prevent sending an unnecessary uncompressed packet,\
    \ the length of the\n   previous packet should be checked and, if it contained\
    \ data, a zero\n   sequence number change must indicate a retransmission.\n  \
    \ A confused decompressor in the reverse (ack) half of the conversation is\n \
    \  as easy to detect (fig. 7):    The sending TCP discards acks (because\n   they\
    \ contain checksum errors), eventually times out, then retransmits\n   some packet.\
    \  The receiving TCP thus gets a duplicate packet and must\n   generate an ack\
    \ for the next expected sequence number[11, p. 69].  This\n   ack will be a duplicate\
    \ of the last ack the receiver generated so the\n   reverse-path compressor will\
    \ find no ack, seq number, window or urg\n   change.  If this happens for a packet\
    \ that contains no data, the\n   compressor assumes it is a duplicate ack sent\
    \ in response to a\n   retransmit and sends an UNCOMPRESSED_TCP packet./31/\n\
    \   5  Configurable parameters and tuning\n   5.1  Compression configuration\n\
    \   There are two configuration parameters associated with header\n   compression:\
    \  Whether or not compressed packets should be sent on a\n   particular line and,\
    \ if so, how many state slots (saved packet headers)\n   to reserve.  There is\
    \ also one link-level configuration parameter, the\n   maximum packet size or\
    \ MTU, and one front-end configuration parameter,\n   data compression, that interact\
    \ with header compression.  Compression\n   configuration is discussed in this\
    \ section.  MTU and data compression\n   are discussed in the next two sections.\n\
    \   There are some hosts (e.g., low end PCs) which may not have enough\n   processor\
    \ or memory resources to implement this compression.  There are\n   also rare\
    \ link or application characteristics that make header\n   compression unnecessary\
    \ or undesirable.  And there are many existing\n   SLIP links that do not currently\
    \ use this style of header compression.\n   For the sake of interoperability,\
    \ serial line IP drivers that allow\n   header compression should include some\
    \ sort of user configurable flag to\n   disable compression (see appendix B.2)./32/\n\
    \   If compression is enabled, the compressor must be sure to never send a\n \
    \  connection id (state index) that will be dropped by the decompressor.\n   E.g.,\
    \ a black hole is created if the decompressor has sixteen slots and\n   ----------------------------\n\
    \    31. The packet could be a zero-window probe rather than a retransmitted\n\
    \   ack but window probes should be infrequent and it does no harm to send\n \
    \  them uncompressed.\n    32. The PPP protocol in [9] allows the end points to\
    \ negotiate\n   compression so there is no interoperability problem.  However,\
    \ there\n   should still be a provision for the system manager at each end to\n\
    \   control whether compression is negotiated on or off.  And, obviously,\n  \
    \ compression should default to `off' until it has been negotiated `on'.\n   the\
    \ compressor uses twenty./33/  Also, if the compressor is allowed too\n   few\
    \ slots, the LRU allocator will thrash and most packets will be sent\n   as UNCOMPRESSED_TCP.\
    \ Too many slots and memory is wasted.\n   Experimenting with different sizes\
    \ over the past year, the author has\n   found that eight slots will thrash (i.e.,\
    \ the performance degradation is\n   noticeable) when many windows on a multi-window\
    \ workstation are\n   simultaneously in use or the workstation is being used as\
    \ a gateway for\n   three or more other machines.  Sixteen slots were never observed\
    \ to\n   thrash.  (This may simply be because a 9600 bps line split more than\
    \ 16\n   ways is already so overloaded that the additional degradation from\n\
    \   round-robbining slots is negligible.)\n   Each slot must be large enough to\
    \ hold a maximum length TCP/IP header of\n   128 bytes/34/ so 16 slots occupy\
    \ 2KB of memory.  In these days of 4 Mbit\n   RAM chips, 2KB seems so little memory\
    \ that the author recommends the\n   following configuration rules:\n   (1) If\
    \ the framing protocol does not allow negotiation, the compressor\n       and\
    \ decompressor should provide sixteen slots, zero through fifteen.\n   (2) If\
    \ the framing protocol allows negotiation, any mutually agreeable\n       number\
    \ of slots from 1 to 256 should be negotiable./35/  If number\n       of slots\
    \ is not negotiated, or until it is negotiated, both sides\n       should assume\
    \ sixteen.\n   (3) If you have complete control of all the machines at both ends\
    \ of\n       every link and none of them will ever be used to talk to machines\n\
    \       outside of your control, you are free to configure them however you\n\
    \       please, ignoring the above.  However, when your little eastern-block\n\
    \       dictatorship collapses (as they all eventually seem to), be aware\n  \
    \     that a large, vocal, and not particularly forgiving Internet\n       community\
    \ will take great delight in pointing out to anyone willing\n   ----------------------------\n\
    \    33. Strictly speaking, there's no reason why the connection id should\n \
    \  be treated as an array index.  If the decompressor's states were kept in\n\
    \   a hash table or other associative structure, the connection id would be\n\
    \   a key, not an index, and performance with too few decompressor slots\n   would\
    \ only degrade enormously rather than failing altogether.  However,\n   an associative\
    \ structure is substantially more costly in code and cpu\n   time and, given the\
    \ small per-slot cost (128 bytes of memory), it seems\n   reasonable to design\
    \ for slot arrays at the decompressor and some\n   (possibly implicit) communication\
    \ of the array size.\n    34. The maximum header length, fixed by the protocol\
    \ design, is 64\n   bytes of IP and 64 bytes of TCP.\n    35. Allowing only one\
    \ slot may make the compressor code more complex.\n   Implementations should avoid\
    \ offering one slot if possible and\n   compressor implementations may disable\
    \ compression if only one slot is\n   negotiated.\n       to listen that you have\
    \ misconfigured your systems and are not\n       interoperable.\n   5.2  Choosing\
    \ a maximum transmission unit\n   From the discussion in sec. 2, it seems desirable\
    \ to limit the maximum\n   packet size (MTU) on any line where there might be\
    \ interactive traffic\n   and multiple active connections (to maintain good interactive\
    \ response\n   between the different connections competing for the line).  The\
    \ obvious\n   question is `how much does this hurt throughput?'  It doesn't.\n\
    \   Figure 8 shows how user data throughput/36/ scales with MTU with (solid\n\
    \   line) and without (dashed line) header compression.  The dotted lines\n  \
    \ show what MTU corresponds to a 200 ms packet time at 2400, 9600 and\n   19,200\
    \ bps.  Note that with header compression even a 2400 bps line can\n   be responsive\
    \ yet have reasonable throughput (83%)./37/\n   Figure 9 shows how line efficiency\
    \ scales with increasing line speed,\n   assuming that a 200ms. MTU is always\
    \ chosen./38/  The knee in the\n   performance curve is around 2400 bps.  Below\
    \ this, efficiency is\n   sensitive to small changes in speed (or MTU since the\
    \ two are linearly\n   related) and good efficiency comes at the expense of good\
    \ response.\n   Above 2400bps the curve is flat and efficiency is relatively independent\n\
    \   of speed or MTU. In other words, it is possible to have both good\n   response\
    \ and high line efficiency.\n   To illustrate, note that for a 9600 bps line with\
    \ header compression\n   there is essentially no benefit in increasing the MTU\
    \ beyond 200 bytes:\n   If the MTU is increased to 576, the average delay increases\
    \ by 188%\n   while throughput only improves by 3% (from 96 to 99%).\n   ----------------------------\n\
    \    36. The vertical axis is in percent of line speed.  E.g., `95' means\n  \
    \ that 95% of the line bandwidth is going to user data or, in other words,\n \
    \  the user would see a data transfer rate of 9120 bps on a 9600 bps line.\n \
    \  Four bytes of link-level (framer) encapsulation in addition to the\n   TCP/IP\
    \ or compressed header were included when calculating the relative\n   throughput.\
    \  The 200 ms packet times were computed assuming an\n   asynchronous line using\
    \ 10 bits per character (8 data bits, 1 start, 1\n   stop, no parity).\n    37.\
    \ However, the 40 byte TCP MSS required for a 2400 bps line might\n   stress-test\
    \ your TCP implementation.\n    38. For a typical async line, a 200ms. MTU is\
    \ simply .02 times the line\n   speed in bits per second.\n   5.3  Interaction\
    \ with data compression\n   Since the early 1980's, fast, effective, data compression\
    \ algorithms\n   such as Lempel-Ziv[7] and programs that embody them, such as\
    \ the\n   compress program shipped with Berkeley Unix, have become widely\n  \
    \ available.  When using low speed or long haul lines, it has become\n   common\
    \ practice to compress data before sending it.  For dialup\n   connections, this\
    \ compression is often done in the modems, independent\n   of the communicating\
    \ hosts.  Some interesting issues would seem to be:\n   (1) Given a good data\
    \ compressor, is there any need for header\n   compression?  (2) Does header compression\
    \ interact with data\n   compression?  (3) Should data be compressed before or\
    \ after header\n   compression?/39/\n   To investigate (1), Lempel-Ziv compression\
    \ was done on a trace of 446\n   TCP/IP packets taken from the user's side of\
    \ a typical telnet\n   conversation.  Since the packets resulted from typing,\
    \ almost all\n   contained only one data byte plus 40 bytes of header.  I.e.,\
    \ the test\n   essentially measured L-Z compression of TCP/IP headers.  The compression\n\
    \   ratio (the ratio of uncompressed to compressed data) was 2.6.  In other\n\
    \   words, the average header was reduced from 40 to 16 bytes.  While this\n \
    \  is good compression, it is far from the 5 bytes of header needed for\n   good\
    \ interactive response and far from the 3 bytes of header (a\n   compression ratio\
    \ of 13.3) that header compression yielded on the same\n   packet trace.\n   The\
    \ second and third questions are more complex.  To investigate them,\n   several\
    \ packet traces from FTP file transfers were analyzed/40/ with and\n   without\
    \ header compression and with and without L-Z compression.  The\n   L-Z compression\
    \ was tried at two places in the outgoing data stream\n   (fig. 10):    (1) just\
    \ before the data was handed to TCP for\n   encapsulation (simulating compression\
    \ done at the `application' level)\n   and (2) after the data was encapsulated\
    \ (simulating compression done in\n   the modem).  Table 1 summarizes the results\
    \ for a 78,776 byte ASCII text\n   file (the Unix csh.1 manual entry)/41/ transferred\
    \ using the guidelines\n   of the previous section (256 byte MTU or 216 byte MSS;\
    \ 368 packets\n   total).  Compression ratios for the following ten tests are\
    \ shown\n   (reading left to right and top to bottom):\n   ----------------------------\n\
    \    39. The answers, for those who wish to skip the remainder of this\n   section,\
    \ are `yes', `no' and `either', respectively.\n    40. The data volume from user\
    \ side of a telnet is too small to benefit\n   from data compression and can be\
    \ adversely affected by the delay most\n   compression algorithms (necessarily)\
    \ add.  The statistics and volume of\n   the computer side of a telnet are similar\
    \ to an (ASCII) FTP so these\n   results should apply to either.\n    41. The\
    \ ten experiments described were each done on ten ASCII files\n   (four long e-mail\
    \ messages, three Unix C source files and three Unix\n   manual entries).  The\
    \ results were remarkably similar for different\n   files and the general conclusions\
    \ reached below apply to all ten files.\n     - data file (no compression or encapsulation)\n\
    \     - data -> L--Z compressor\n     - data -> TCP/IP encapsulation\n     - data\
    \ -> L--Z -> TCP/IP\n     - data -> TCP/IP -> L--Z\n     - data -> L--Z -> TCP/IP\
    \ -> L--Z\n     - data -> TCP/IP -> Hdr. Compress.\n     - data -> L--Z -> TCP/IP\
    \ -> Hdr. Compress.\n     - data -> TCP/IP -> Hdr. Compress. -> L--Z\n     - data\
    \ -> L--Z -> TCP/IP -> Hdr. Compress. -> L--Z\n            +-----------------------------------------------------+\n\
    \            |              | No data  | L--Z   |  L--Z  |  L--Z   |\n       \
    \     |              |compress. |on data |on wire | on both |\n            +--------------+----------+--------+--------+---------+\n\
    \            | Raw Data     |     1.00 |   2.44 |   ---- |    ---- |\n       \
    \     | + TCP Encap. |     0.83 |   2.03 |   1.97 |    1.58 |\n            | w/Hdr\
    \ Comp.  |     0.98 |   2.39 |   2.26 |    1.66 |\n            +-----------------------------------------------------+\n\
    \                 Table 1:  ASCII Text File Compression Ratios\n   The first column\
    \ of table 1 says the data expands by 19% (`compresses'\n   by .83) when encapsulated\
    \ in TCP/IP and by 2% when encapsulated in\n   header compressed TCP/IP./42/ The\
    \ first row says L--Z compression is\n   quite effective on this data, shrinking\
    \ it to less than half its\n   original size.  Column four illustrates the well-known\
    \ fact that it is a\n   mistake to L--Z compress already compressed data.  The\
    \ interesting\n   information is in rows two and three of columns two and three.\
    \  These\n   columns say that the benefit of data compression overwhelms the cost\
    \ of\n   encapsulation, even for straight TCP/IP. They also say that it is\n \
    \  slightly better to compress the data before encapsulating it rather than\n\
    \   compressing at the framing/modem level.  The differences however are\n   ----------------------------\n\
    \    42. This is what would be expected from the relative header sizes:\n   256/216\
    \ for TCP/IP and 219/216 for header compression.\n   small --- 3% and 6%, respectively,\
    \ for the TCP/IP and header compressed\n   encapsulations./43/\n   Table 2 shows\
    \ the same experiment for a 122,880 byte binary file (the\n   Sun-3 ps executable).\
    \  Although the raw data doesn't compress nearly as\n   well, the results are\
    \ qualitatively the same as for the ASCII data.  The\n   one significant change\
    \ is in row two:  It is about 3% better to compress\n   the data in the modem\
    \ rather than at the source if doing TCP/IP\n   encapsulation (apparently, Sun\
    \ binaries and TCP/IP headers have similar\n   statistics).  However, with header\
    \ compression (row three) the results\n   were similar to the ASCII data --- it's\
    \ about 3% worse to compress at\n   the modem rather than the source./44/\n  \
    \          +-----------------------------------------------------+\n         \
    \   |              | No data  | L--Z   |  L--Z  |  L--Z   |\n            |   \
    \           |compress. |on data |on wire | on both |\n            +--------------+----------+--------+--------+---------+\n\
    \            | Raw Data     |     1.00 |   1.72 |   ---- |    ---- |\n       \
    \     | + TCP Encap. |     0.83 |   1.43 |   1.48 |    1.21 |\n            | w/Hdr\
    \ Comp.  |     0.98 |   1.69 |   1.64 |    1.28 |\n            +-----------------------------------------------------+\n\
    \                   Table 2:  Binary File Compression Ratios\n   6  Performance\
    \ measurements\n   An implementation goal of compression code was to arrive at\
    \ something\n   simple enough to run at ISDN speeds (64Kbps) on a typical 1989\n\
    \   ----------------------------\n    43. The differences are due to the wildly\
    \ different byte patterns of\n   TCP/IP datagrams and ASCII text.  Any compression\
    \ scheme with an\n   underlying, Markov source model, such as Lempel-Ziv, will\
    \ do worse when\n   radically different sources are interleaved.  If the relative\n\
    \   proportions of the two sources are changed, i.e., the MTU is increased,\n\
    \   the performance difference between the two compressor locations\n   decreases.\
    \  However, the rate of decrease is very slow --- increasing\n   the MTU by 400%\
    \ (256 to 1024) only changed the difference between the\n   data and modem L--Z\
    \ choices from 2.5% to 1.3%.\n    44. There are other good reasons to compress\
    \ at the source:  Far fewer\n   packets have to be encapsulated and far fewer\
    \ characters have to be sent\n   to the modem.  The author suspects that the `compress\
    \ data in the modem'\n   alternative should be avoided except when faced with\
    \ an intractable,\n   vendor proprietary operating system.\n                 \
    \  +---------------------------------------+\n                   |           \
    \    |  Average per-packet   |\n                   |    Machine    | processing\
    \ time (us.) |\n                   |               |                       |\n\
    \                   |               | Compress | Decompress |\n              \
    \     +---------------+----------+------------+\n                   |Sparcstation-1\
    \ |       24 |         18 |\n                   |   Sun 4/260   |       46 | \
    \        20 |\n                   |   Sun 3/60    |       90 |         90 |\n\
    \                   |   Sun 3/50    |      130 |        150 |\n              \
    \     |  HP9000/370   |       42 |         33 |\n                   |  HP9000/360\
    \   |       68 |         70 |\n                   |   DEC 3100    |       27 |\
    \         25 |\n                   |    Vax 780    |      430 |        300 |\n\
    \                   |    Vax 750    |      800 |        500 |\n              \
    \     |   CCI Tahoe   |      110 |        140 |\n                   +---------------------------------------+\n\
    \                      Table 3:  Compression code timings\n   workstation.  64Kbps\
    \ is a byte every 122us so 120us was (arbitrarily)\n   picked as the target compression/decompression\
    \ time./45/\n   As part of the compression code development, a trace-driven exerciser\n\
    \   was developed.  This was initially used to compare different compression\n\
    \   protocol choices then later to test the code on different computer\n   architectures\
    \ and do regression tests after performance `improvements'.\n   A small modification\
    \ of this test program resulted in a useful\n   measurement tool./46/  Table 3\
    \ shows the result of timing the\n   compression code on all the machines available\
    \ to the author (times were\n   measured using a mixed telnet/ftp traffic trace).\
    \  With the exception of\n   the Vax architectures, which suffer from (a) having\
    \ bytes in the wrong\n   order and (b) a lousy compiler (Unix pcc), all machines\
    \ essentially met\n   the 120us goal.\n   ----------------------------\n    45.\
    \ The time choice wasn't completely arbitrary:  Decompression is\n   often done\
    \ during the inter-frame `flag' character time so, on systems\n   where the decompression\
    \ is done at the same priority level as the serial\n   line input interrupt, times\
    \ much longer than a character time would\n   result in receiver overruns.  And,\
    \ with the current average of five byte\n   frames (on the wire, including both\
    \ compressed header and framing), a\n   compression/decompression that takes one\
    \ byte time can use at most 20%\n   of the available time.  This seems like a\
    \ comfortable budget.\n    46. Both the test program and timer program are included\
    \ in the\n   ftp-able package described in appendix A as files tester.c and timer.c.\n\
    \   7  Acknowlegements\n   The author is grateful to the members of the Internet\
    \ Engineering Task\n   Force, chaired by Phill Gross, who provided encouragement\
    \ and thoughtful\n   review of this work.  Several patient beta-testers, particularly\
    \ Sam\n   Leffler and Craig Leres, tracked down and fixed problems in the initial\n\
    \   implementation.  Cynthia Livingston and Craig Partridge carefully read\n \
    \  and greatly improved an unending sequence of partial drafts of this\n   document.\
    \  And last but not least, Telebit modem corporation,\n   particularly Mike Ballard,\
    \ encouraged this work from its inception and\n   has been an ongoing champion\
    \ of serial line and dial-up IP.\n   References\n    [1] Bingham, J. A. C. Theory\
    \ and Practice of Modem Design. John Wiley\n        & Sons, 1988.\n    [2] Carey,\
    \ M. B., Chan, H.-T., Descloux, A., Ingle, J. F., and Park,\n        K. I. 1982/83\
    \ end office connection study:  Analog voice and\n        voiceband data transmission\
    \ performance characterization of the\n        public switched network. Bell System\
    \ Technical Journal 63, 9 (Nov.\n        1984).\n    [3] Chiappa, N., 1988. Private\
    \ communication.\n    [4] Clark, D. D. The design philosophy of the DARPA Internet\n\
    \        protocols. In Proceedings of SIGCOMM '88 (Stanford, CA, Aug.\n      \
    \  1988), ACM.\n    [5] Farber, D. J., Delp, G. S., and Conte, T. M. A Thinwire\
    \ Protocol\n        for connecting personal computers to the Internet. Arpanet\
    \ Working\n        Group Requests for Comment, DDN Network Information Center,\
    \ SRI\n        International, Menlo Park, CA, Sept. 1984. RFC-914.\n    [6] Kent,\
    \ C. A., and Mogul, J. Fragmentation considered harmful. In\n        Proceedings\
    \ of SIGCOMM '87 (Aug. 1987), ACM.\n    [7] Lempel, A., and Ziv, J. Compression\
    \ of individual sequences via\n        variable-rate encoding. IEEE Transactions\
    \ on Information Theory\n        IT-24, 5 (June 1978).\n    [8] Nagle, J. Congestion\
    \ Control in IP/TCP Internetworks. Arpanet\n        Working Group Requests for\
    \ Comment, DDN Network Information Center,\n        SRI International, Menlo Park,\
    \ CA, Jan. 1984. RFC-896.\n    [9] Perkins, D. Point-to-Point Protocol:  A proposal\
    \ for\n        multi-protocol transmission of datagrams over point-to-point links.\n\
    \        Arpanet Working Group Requests for Comment, DDN Network Information\n\
    \        Center, SRI International, Menlo Park, CA, Nov. 1989. RFC-1134.\n   [10]\
    \ Postel, J., Ed. Internet Protocol Specification. SRI\n        International,\
    \ Menlo Park, CA, Sept. 1981. RFC-791.\n   [11] Postel, J., Ed. Transmission Control\
    \ Protocol Specification. SRI\n        International, Menlo Park, CA, Sept. 1981.\
    \ RFC-793.\n   [12] Romkey, J. A Nonstandard for Transmission of IP Datagrams\
    \ Over\n        Serial Lines:  Slip. Arpanet Working Group Requests for Comment,\n\
    \        DDN Network Information Center, SRI International, Menlo Park, CA,\n\
    \        June 1988. RFC-1055.\n   [13] Salthouse, T. A. The skill of typing. Scientific\
    \ American 250, 2\n        (Feb. 1984), 128--135.\n   [14] Saltzer, J. H., Reed,\
    \ D. P., and Clark, D. D. End-to-end arguments\n        in system design. ACM\
    \ Transactions on Computer Systems 2, 4 (Nov.\n        1984).\n   [15] Shneiderman,\
    \ B. Designing the User Interface. Addison-Wesley,\n        1987.\n   A  Sample\
    \ Implementation\n   The following is a sample implementation of the protocol\
    \ described in\n   this document.\n   Since many people who might have the deal\
    \ with this code are familiar\n   with the Berkeley Unix kernel and its coding\
    \ style (affectionately known\n   as kernel normal form), this code was done in\
    \ that style.  It uses the\n   Berkeley `subroutines' (actually, macros and/or\
    \ inline assembler\n   expansions) for converting to/from network byte order and\n\
    \   copying/comparing strings of bytes.  These routines are briefly\n   described\
    \ in sec. A.5 for anyone not familiar with them.\n   This code has been run on\
    \ all the machines listed in the table on page\n   24.  Thus, the author hopes\
    \ there are no byte order or alignment\n   problems (although there are embedded\
    \ assumptions about alignment that\n   are valid for Berkeley Unix but may not\
    \ be true for other IP\n   implementations --- see the comments mentioning alignment\
    \ in\n   sl_compress_tcp and sl_decompress_tcp).\n   There was some attempt to\
    \ make this code efficient.  Unfortunately, that\n   may have made portions of\
    \ it incomprehensible.  The author apologizes\n   for any frustration this engenders.\
    \  (In honesty, my C style is known to\n   be obscure and claims of `efficiency'\
    \ are simply a convenient excuse.)\n   This sample code and a complete Berkeley\
    \ Unix implementation is\n   available in machine readable form via anonymous\
    \ ftp from Internet host\n   ftp.ee.lbl.gov (128.3.254.68), file cslip.tar.Z.\
    \ This is a compressed\n   Unix tar file.  It must be ftped in binary mode.\n\
    \   All of the code in this appendix is covered by the following copyright:\n\
    \   /*\n    * Copyright (c) 1989 Regents of the University of California.\n  \
    \  * All rights reserved.\n    *\n    * Redistribution and use in source and binary\
    \ forms are\n    * permitted provided that the above copyright notice and this\n\
    \    * paragraph are duplicated in all such forms and that any\n    * documentation,\
    \ advertising materials, and other materials\n    * related to such distribution\
    \ and use acknowledge that the\n    * software was developed by the University\
    \ of California,\n    * Berkeley.  The name of the University may not be used\
    \ to\n    * endorse or promote products derived from this software\n    * without\
    \ specific prior written permission.\n    * THIS SOFTWARE IS PROVIDED ``AS IS''\
    \ AND WITHOUT ANY EXPRESS\n    * OR IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION,\
    \ THE\n    * IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A\n    * PARTICULAR\
    \ PURPOSE.\n    */\n   A.1  Definitions and State Data\n   #define MAX_STATES\
    \ 16   /* must be >2 and <255 */\n   #define MAX_HDR 128     /* max TCP+IP hdr\
    \ length (by protocol def) */\n   /* packet types */\n   #define TYPE_IP 0x40\n\
    \   #define TYPE_UNCOMPRESSED_TCP 0x70\n   #define TYPE_COMPRESSED_TCP 0x80\n\
    \   #define TYPE_ERROR 0x00 /* this is not a type that ever appears on\n     \
    \                       * the wire.  The receive framer uses it to\n         \
    \                   * tell the decompressor there was a packet\n             \
    \               * transmission error. */\n   /*\n    * Bits in first octet of\
    \ compressed packet\n    */\n   /* flag bits for what changed in a packet */\n\
    \   #define NEW_C  0x40\n   #define NEW_I  0x20\n   #define TCP_PUSH_BIT 0x10\n\
    \   #define NEW_S  0x08\n   #define NEW_A  0x04\n   #define NEW_W  0x02\n   #define\
    \ NEW_U  0x01\n   /* reserved, special-case values of above */\n   #define SPECIAL_I\
    \ (NEW_S|NEW_W|NEW_U)        /* echoed interactive traffic */\n   #define SPECIAL_D\
    \ (NEW_S|NEW_A|NEW_W|NEW_U)  /* unidirectional data */\n   #define SPECIALS_MASK\
    \ (NEW_S|NEW_A|NEW_W|NEW_U)\n   /*\n    * \"state\" data for each active tcp conversation\
    \ on the wire.  This is\n    * basically a copy of the entire IP/TCP header from\
    \ the last packet together\n    * with a small identifier the transmit & receive\
    \ ends of the line use to\n    * locate saved header.\n    */\n   struct cstate\
    \ {\n        struct cstate *cs_next;  /* next most recently used cstate (xmit\
    \ only) */\n        u_short cs_hlen;         /* size of hdr (receive only) */\n\
    \        u_char cs_id;            /* connection # associated with this state */\n\
    \        u_char cs_filler;\n        union {\n             char hdr[MAX_HDR];\n\
    \             struct ip csu_ip;   /* ip/tcp hdr from most recent packet */\n \
    \       } slcs_u;\n   };\n   #define cs_ip slcs_u.csu_ip\n   #define cs_hdr slcs_u.csu_hdr\n\
    \   /*\n    * all the state data for one serial line (we need one of these per\
    \ line).\n    */\n   struct slcompress {\n        struct cstate *last_cs;    \
    \        /* most recently used tstate */\n        u_char last_recv;          \
    \        /* last rcvd conn. id */\n        u_char last_xmit;                 \
    \ /* last sent conn. id */\n        u_short flags;\n        struct cstate tstate[MAX_STATES];\
    \  /* xmit connection states */\n        struct cstate rstate[MAX_STATES];  /*\
    \ receive connection states */\n   };\n   /* flag values */\n   #define SLF_TOSS\
    \ 1       /* tossing rcvd frames because of input err */\n   /*\n    * The following\
    \ macros are used to encode and decode numbers.  They all\n    * assume that `cp'\
    \ points to a buffer where the next byte encoded (decoded)\n    * is to be stored\
    \ (retrieved).  Since the decode routines do arithmetic,\n    * they have to convert\
    \ from and to network byte order.\n    */\n   /*\n    * ENCODE encodes a number\
    \ that is known to be non-zero.  ENCODEZ checks for\n    * zero (zero has to be\
    \ encoded in the long, 3 byte form).\n    */\n   #define ENCODE(n) { \\\n    \
    \    if ((u_short)(n) >= 256) { \\\n             *cp++ = 0; \\\n             cp[1]\
    \ = (n); \\\n             cp[0] = (n) >> 8; \\\n             cp += 2; \\\n   \
    \     } else { \\\n             *cp++ = (n); \\\n        } \\\n   }\n   #define\
    \ ENCODEZ(n) { \\\n        if ((u_short)(n) >= 256 || (u_short)(n) == 0) { \\\n\
    \             *cp++ = 0; \\\n             cp[1] = (n); \\\n             cp[0]\
    \ = (n) >> 8; \\\n             cp += 2; \\\n        } else { \\\n            \
    \ *cp++ = (n); \\\n        } \\\n   }\n   /*\n    * DECODEL takes the (compressed)\
    \ change at byte cp and adds it to the\n    * current value of packet field 'f'\
    \ (which must be a 4-byte (long) integer\n    * in network byte order).  DECODES\
    \ does the same for a 2-byte (short) field.\n    * DECODEU takes the change at\
    \ cp and stuffs it into the (short) field f.\n    * 'cp' is updated to point to\
    \ the next field in the compressed header.\n    */\n   #define DECODEL(f) { \\\
    \n        if (*cp == 0) {\\\n             (f) = htonl(ntohl(f) + ((cp[1] << 8)\
    \ | cp[2])); \\\n             cp += 3; \\\n        } else { \\\n             (f)\
    \ = htonl(ntohl(f) + (u_long)*cp++); \\\n        } \\\n   }\n   #define DECODES(f)\
    \ { \\\n        if (*cp == 0) {\\\n             (f) = htons(ntohs(f) + ((cp[1]\
    \ << 8) | cp[2])); \\\n             cp += 3; \\\n        } else { \\\n       \
    \      (f) = htons(ntohs(f) + (u_long)*cp++); \\\n        } \\\n   }\n   #define\
    \ DECODEU(f) { \\\n        if (*cp == 0) {\\\n             (f) = htons((cp[1]\
    \ << 8) | cp[2]); \\\n             cp += 3; \\\n        } else { \\\n        \
    \     (f) = htons((u_long)*cp++); \\\n        } \\\n   }\n   A.2  Compression\n\
    \   This routine looks daunting but isn't really.  The code splits into four\n\
    \   approximately equal sized sections:  The first quarter manages a\n   circularly\
    \ linked, least-recently-used list of `active' TCP\n   connections./47/  The second\
    \ figures out the sequence/ack/window/urg\n   changes and builds the bulk of the\
    \ compressed packet.  The third handles\n   the special-case encodings.  The last\
    \ quarter does packet ID and\n   connection ID encoding and replaces the original\
    \ packet header with the\n   compressed header.\n   The arguments to this routine\
    \ are a pointer to a packet to be\n   compressed, a pointer to the compression\
    \ state data for the serial line,\n   and a flag which enables or disables connection\
    \ id (C bit) compression.\n   Compression is done `in-place' so, if a compressed\
    \ packet is created,\n   both the start address and length of the incoming packet\
    \ (the off and\n   len fields of m) will be updated to reflect the removal of\
    \ the original\n   header and its replacement by the compressed header.  If either\
    \ a\n   compressed or uncompressed packet is created, the compression state is\n\
    \   updated.  This routines returns the packet type for the transmit framer\n\
    \   (TYPE_IP, TYPE_UNCOMPRESSED_TCP or TYPE_COMPRESSED_TCP).\n   Because 16 and\
    \ 32 bit arithmetic is done on various header fields, the\n   incoming IP packet\
    \ must be aligned appropriately (e.g., on a SPARC, the\n   IP header is aligned\
    \ on a 32-bit boundary).  Substantial changes would\n   have to be made to the\
    \ code below if this were not true (and it would\n   probably be cheaper to byte\
    \ copy the incoming header to somewhere\n   correctly aligned than to make those\
    \ changes).\n   Note that the outgoing packet will be aligned arbitrarily (e.g.,\
    \ it\n   could easily start on an odd-byte boundary).\n   u_char\n   sl_compress_tcp(m,\
    \ comp, compress_cid)\n        struct mbuf *m;\n        struct slcompress *comp;\n\
    \        int compress_cid;\n   {\n        register struct cstate *cs = comp->last_cs->cs_next;\n\
    \        register struct ip *ip = mtod(m, struct ip *);\n        register u_int\
    \ hlen = ip->ip_hl;\n        register struct tcphdr *oth;       /* last TCP header\
    \ */\n        register struct tcphdr *th;        /* current TCP header */\n  \
    \ ----------------------------\n    47. The two most common operations on the\
    \ connection list are a `find'\n   that terminates at the first entry (a new packet\
    \ for the most recently\n   used connection) and moving the last entry on the\
    \ list to the head of\n   the list (the first packet from a new connection). \
    \ A circular list\n   efficiently handles these two operations.\n        register\
    \ u_int deltaS, deltaA;     /* general purpose temporaries */\n        register\
    \ u_int changes = 0;        /* change mask */\n        u_char new_seq[16];   \
    \             /* changes from last to current */\n        register u_char *cp\
    \ = new_seq;\n        /*\n         * Bail if this is an IP fragment or if the\
    \ TCP packet isn't\n         * `compressible' (i.e., ACK isn't set or some other\
    \ control bit is\n         * set).  (We assume that the caller has already made\
    \ sure the packet\n         * is IP proto TCP).\n         */\n        if ((ip->ip_off\
    \ & htons(0x3fff)) || m->m_len < 40)\n             return (TYPE_IP);\n       \
    \ th = (struct tcphdr *) & ((int *) ip)[hlen];\n        if ((th->th_flags & (TH_SYN\
    \ | TH_FIN | TH_RST | TH_ACK)) != TH_ACK)\n             return (TYPE_IP);\n  \
    \      /*\n         * Packet is compressible -- we're going to send either a\n\
    \         * COMPRESSED_TCP or UNCOMPRESSED_TCP packet.  Either way we need to\n\
    \         * locate (or create) the connection state.  Special case the most\n\
    \         * recently used connection since it's most likely to be used again &\n\
    \         * we don't have to do any reordering if it's used.\n         */\n  \
    \      if (ip->ip_src.s_addr != cs->cs_ip.ip_src.s_addr ||\n            ip->ip_dst.s_addr\
    \ != cs->cs_ip.ip_dst.s_addr ||\n            *(int *) th != ((int *) &cs->cs_ip)[cs->cs_ip.ip_hl])\
    \ {\n             /*\n              * Wasn't the first -- search for it.\n   \
    \           *\n              * States are kept in a circularly linked list with\
    \ last_cs\n              * pointing to the end of the list.  The list is kept\
    \ in lru\n              * order by moving a state to the head of the list whenever\n\
    \              * it is referenced.  Since the list is short and,\n           \
    \   * empirically, the connection we want is almost always near\n            \
    \  * the front, we locate states via linear search.  If we\n              * don't\
    \ find a state for the datagram, the oldest state is\n              * (re-)used.\n\
    \              */\n             register struct cstate *lcs;\n             register\
    \ struct cstate *lastcs = comp->last_cs;\n             do {\n                \
    \  lcs = cs;\n                  cs = cs->cs_next;\n                  if (ip->ip_src.s_addr\
    \ == cs->cs_ip.ip_src.s_addr\n                      && ip->ip_dst.s_addr == cs->cs_ip.ip_dst.s_addr\n\
    \                      && *(int *) th == ((int *) &cs->cs_ip)[cs->cs_ip.ip_hl])\n\
    \                       goto found;\n             } while (cs != lastcs);\n  \
    \           /*\n              * Didn't find it -- re-use oldest cstate.  Send\
    \ an\n              * uncompressed packet that tells the other side what\n   \
    \           * connection number we're using for this conversation. Note\n    \
    \          * that since the state list is circular, the oldest state\n       \
    \       * points to the newest and we only need to set last_cs to\n          \
    \    * update the lru linkage.\n              */\n             comp->last_cs =\
    \ lcs;\n             hlen += th->th_off;\n             hlen <<= 2;\n         \
    \    goto uncompressed;\n   found:\n             /* Found it -- move to the front\
    \ on the connection list. */\n             if (lastcs == cs)\n               \
    \   comp->last_cs = lcs;\n             else {\n                  lcs->cs_next\
    \ = cs->cs_next;\n                  cs->cs_next = lastcs->cs_next;\n         \
    \         lastcs->cs_next = cs;\n             }\n        }\n        /*\n     \
    \    * Make sure that only what we expect to change changed. The first\n     \
    \    * line of the `if' checks the IP protocol version, header length &\n    \
    \     * type of service.  The 2nd line checks the \"Don't fragment\" bit.\n  \
    \       * The 3rd line checks the time-to-live and protocol (the protocol\n  \
    \       * check is unnecessary but costless).  The 4th line checks the TCP\n \
    \        * header length.  The 5th line checks IP options, if any.  The 6th\n\
    \         * line checks TCP options, if any.  If any of these things are\n   \
    \      * different between the previous & current datagram, we send the\n    \
    \     * current datagram `uncompressed'.\n         */\n        oth = (struct tcphdr\
    \ *) & ((int *) &cs->cs_ip)[hlen];\n        deltaS = hlen;\n        hlen += th->th_off;\n\
    \        hlen <<= 2;\n        if (((u_short *) ip)[0] != ((u_short *) &cs->cs_ip)[0]\
    \ ||\n            ((u_short *) ip)[3] != ((u_short *) &cs->cs_ip)[3] ||\n    \
    \        ((u_short *) ip)[4] != ((u_short *) &cs->cs_ip)[4] ||\n            th->th_off\
    \ != oth->th_off ||\n            (deltaS > 5 && BCMP(ip + 1, &cs->cs_ip + 1, (deltaS\
    \ - 5) << 2)) ||\n            (th->th_off > 5 && BCMP(th + 1, oth + 1, (th->th_off\
    \ - 5) << 2)))\n             goto uncompressed;\n        /*\n         * Figure\
    \ out which of the changing fields changed.  The receiver\n         * expects\
    \ changes in the order: urgent, window, ack, seq.\n         */\n        if (th->th_flags\
    \ & TH_URG) {\n             deltaS = ntohs(th->th_urp);\n             ENCODEZ(deltaS);\n\
    \             changes |= NEW_U;\n        } else if (th->th_urp != oth->th_urp)\n\
    \             /*\n              * argh! URG not set but urp changed -- a sensible\n\
    \              * implementation should never do this but RFC793 doesn't\n    \
    \          * prohibit the change so we have to deal with it.\n              */\n\
    \             goto uncompressed;\n        if (deltaS = (u_short) (ntohs(th->th_win)\
    \ - ntohs(oth->th_win))) {\n             ENCODE(deltaS);\n             changes\
    \ |= NEW_W;\n        }\n        if (deltaA = ntohl(th->th_ack) - ntohl(oth->th_ack))\
    \ {\n             if (deltaA > 0xffff)\n                  goto uncompressed;\n\
    \             ENCODE(deltaA);\n             changes |= NEW_A;\n        }\n   \
    \     if (deltaS = ntohl(th->th_seq) - ntohl(oth->th_seq)) {\n             if\
    \ (deltaS > 0xffff)\n                  goto uncompressed;\n             ENCODE(deltaS);\n\
    \             changes |= NEW_S;\n        }\n        /*\n         * Look for the\
    \ special-case encodings.\n         */\n        switch (changes) {\n        case\
    \ 0:\n             /*\n              * Nothing changed. If this packet contains\
    \ data and the last\n              * one didn't, this is probably a data packet\
    \ following an\n              * ack (normal on an interactive connection) and\
    \ we send it\n              * compressed.  Otherwise it's probably a retransmit,\n\
    \              * retransmitted ack or window probe.  Send it uncompressed\n  \
    \            * in case the other side missed the compressed version.\n       \
    \       */\n             if (ip->ip_len != cs->cs_ip.ip_len &&\n             \
    \    ntohs(cs->cs_ip.ip_len) == hlen)\n                  break;\n            \
    \ /* (fall through) */\n        case SPECIAL_I:\n        case SPECIAL_D:\n   \
    \          /*\n              * Actual changes match one of our special case encodings\
    \ --\n              * send packet uncompressed.\n              */\n          \
    \   goto uncompressed;\n        case NEW_S | NEW_A:\n             if (deltaS ==\
    \ deltaA &&\n                 deltaS == ntohs(cs->cs_ip.ip_len) - hlen) {\n  \
    \                /* special case for echoed terminal traffic */\n            \
    \      changes = SPECIAL_I;\n                  cp = new_seq;\n             }\n\
    \             break;\n        case NEW_S:\n             if (deltaS == ntohs(cs->cs_ip.ip_len)\
    \ - hlen) {\n                  /* special case for data xfer */\n            \
    \      changes = SPECIAL_D;\n                  cp = new_seq;\n             }\n\
    \             break;\n        }\n        deltaS = ntohs(ip->ip_id) - ntohs(cs->cs_ip.ip_id);\n\
    \        if (deltaS != 1) {\n             ENCODEZ(deltaS);\n             changes\
    \ |= NEW_I;\n        }\n        if (th->th_flags & TH_PUSH)\n             changes\
    \ |= TCP_PUSH_BIT;\n        /*\n         * Grab the cksum before we overwrite\
    \ it below.  Then update our\n         * state with this packet's header.\n  \
    \       */\n        deltaA = ntohs(th->th_sum);\n        BCOPY(ip, &cs->cs_ip,\
    \ hlen);\n        /*\n         * We want to use the original packet as our compressed\
    \ packet. (cp -\n         * new_seq) is the number of bytes we need for compressed\
    \ sequence\n         * numbers.  In addition we need one byte for the change mask,\
    \ one\n         * for the connection id and two for the tcp checksum. So, (cp\
    \ -\n         * new_seq) + 4 bytes of header are needed.  hlen is how many bytes\n\
    \         * of the original packet to toss so subtract the two to get the new\n\
    \         * packet size.\n         */\n        deltaS = cp - new_seq;\n      \
    \  cp = (u_char *) ip;\n        if (compress_cid == 0 || comp->last_xmit != cs->cs_id)\
    \ {\n             comp->last_xmit = cs->cs_id;\n             hlen -= deltaS +\
    \ 4;\n             cp += hlen;\n             *cp++ = changes | NEW_C;\n      \
    \       *cp++ = cs->cs_id;\n        } else {\n             hlen -= deltaS + 3;\n\
    \             cp += hlen;\n             *cp++ = changes;\n        }\n        m->m_len\
    \ -= hlen;\n        m->m_off += hlen;\n        *cp++ = deltaA >> 8;\n        *cp++\
    \ = deltaA;\n        BCOPY(new_seq, cp, deltaS);\n        return (TYPE_COMPRESSED_TCP);\n\
    \   uncompressed:\n        /*\n         * Update connection state cs & send uncompressed\
    \ packet\n         * ('uncompressed' means a regular ip/tcp packet but with the\n\
    \         * 'conversation id' we hope to use on future compressed packets in\n\
    \         * the protocol field).\n         */\n        BCOPY(ip, &cs->cs_ip, hlen);\n\
    \        ip->ip_p = cs->cs_id;\n        comp->last_xmit = cs->cs_id;\n       \
    \ return (TYPE_UNCOMPRESSED_TCP);\n   }\n   A.3  Decompression\n   This routine\
    \ decompresses a received packet.  It is called with a\n   pointer to the packet,\
    \ the packet length and type, and a pointer to the\n   compression state structure\
    \ for the incoming serial line.  It returns a\n   pointer to the resulting packet\
    \ or zero if there were errors in the\n   incoming packet.  If the packet is COMPRESSED_TCP\
    \ or UNCOMPRESSED_TCP,\n   the compression state will be updated.\n   The new\
    \ packet will be constructed in-place.  That means that there must\n   be 128\
    \ bytes of free space in front of bufp to allow room for the\n   reconstructed\
    \ IP and TCP headers.  The reconstructed packet will be\n   aligned on a 32-bit\
    \ boundary.\n   u_char *\n   sl_uncompress_tcp(bufp, len, type, comp)\n      \
    \  u_char *bufp;\n        int len;\n        u_int type;\n        struct slcompress\
    \ *comp;\n   {\n        register u_char *cp;\n        register u_int hlen, changes;\n\
    \        register struct tcphdr *th;\n        register struct cstate *cs;\n  \
    \      register struct ip *ip;\n        switch (type) {\n        case TYPE_ERROR:\n\
    \        default:\n             goto bad;\n        case TYPE_IP:\n           \
    \  return (bufp);\n        case TYPE_UNCOMPRESSED_TCP:\n             /*\n    \
    \          * Locate the saved state for this connection.  If the state\n     \
    \         * index is legal, clear the 'discard' flag.\n              */\n    \
    \         ip = (struct ip *) bufp;\n             if (ip->ip_p >= MAX_STATES)\n\
    \                  goto bad;\n             cs = &comp->rstate[comp->last_recv\
    \ = ip->ip_p];\n             comp->flags &= ~SLF_TOSS;\n             /*\n    \
    \          * Restore the IP protocol field then save a copy of this\n        \
    \      * packet header.  (The checksum is zeroed in the copy so we\n         \
    \     * don't have to zero it each time we process a compressed\n            \
    \  * packet.\n              */\n             ip->ip_p = IPPROTO_TCP;\n       \
    \      hlen = ip->ip_hl;\n             hlen += ((struct tcphdr *) & ((int *) ip)[hlen])->th_off;\n\
    \             hlen <<= 2;\n             BCOPY(ip, &cs->cs_ip, hlen);\n       \
    \      cs->cs_ip.ip_sum = 0;\n             cs->cs_hlen = hlen;\n             return\
    \ (bufp);\n        case TYPE_COMPRESSED_TCP:\n             break;\n        }\n\
    \        /* We've got a compressed packet. */\n        cp = bufp;\n        changes\
    \ = *cp++;\n        if (changes & NEW_C) {\n             /*\n              * Make\
    \ sure the state index is in range, then grab the\n              * state. If we\
    \ have a good state index, clear the 'discard'\n              * flag.\n      \
    \        */\n             if (*cp >= MAX_STATES)\n                  goto bad;\n\
    \             comp->flags &= ~SLF_TOSS;\n             comp->last_recv = *cp++;\n\
    \        } else {\n             /*\n              * This packet has an implicit\
    \ state index.  If we've had a\n              * line error since the last time\
    \ we got an explicit state\n              * index, we have to toss the packet.\n\
    \              */\n             if (comp->flags & SLF_TOSS)\n                \
    \  return ((u_char *) 0);\n        }\n        /*\n         * Find the state then\
    \ fill in the TCP checksum and PUSH bit.\n         */\n        cs = &comp->rstate[comp->last_recv];\n\
    \        hlen = cs->cs_ip.ip_hl << 2;\n        th = (struct tcphdr *) & ((u_char\
    \ *) &cs->cs_ip)[hlen];\n        th->th_sum = htons((*cp << 8) | cp[1]);\n   \
    \     cp += 2;\n        if (changes & TCP_PUSH_BIT)\n             th->th_flags\
    \ |= TH_PUSH;\n        else\n             th->th_flags &= ~TH_PUSH;\n        /*\n\
    \         * Fix up the state's ack, seq, urg and win fields based on the\n   \
    \      * changemask.\n         */\n        switch (changes & SPECIALS_MASK) {\n\
    \        case SPECIAL_I:\n             {\n             register u_int i = ntohs(cs->cs_ip.ip_len)\
    \ - cs->cs_hlen;\n             th->th_ack = htonl(ntohl(th->th_ack) + i);\n  \
    \           th->th_seq = htonl(ntohl(th->th_seq) + i);\n             }\n     \
    \        break;\n        case SPECIAL_D:\n             th->th_seq = htonl(ntohl(th->th_seq)\
    \ + ntohs(cs->cs_ip.ip_len)\n                          - cs->cs_hlen);\n     \
    \        break;\n        default:\n             if (changes & NEW_U) {\n     \
    \             th->th_flags |= TH_URG;\n                  DECODEU(th->th_urp)\n\
    \             } else\n                  th->th_flags &= ~TH_URG;\n           \
    \  if (changes & NEW_W)\n                  DECODES(th->th_win)\n             if\
    \ (changes & NEW_A)\n                  DECODEL(th->th_ack)\n             if (changes\
    \ & NEW_S)\n                  DECODEL(th->th_seq)\n             break;\n     \
    \   }\n        /* Update the IP ID */\n        if (changes & NEW_I)\n        \
    \     DECODES(cs->cs_ip.ip_id)\n        else\n             cs->cs_ip.ip_id = htons(ntohs(cs->cs_ip.ip_id)\
    \ + 1);\n        /*\n         * At this point, cp points to the first byte of\
    \ data in the packet.\n         * If we're not aligned on a 4-byte boundary, copy\
    \ the data down so\n         * the IP & TCP headers will be aligned.  Then back\
    \ up cp by the\n         * TCP/IP header length to make room for the reconstructed\
    \ header (we\n         * assume the packet we were handed has enough space to\
    \ prepend 128\n         * bytes of header).  Adjust the lenth to account for the\
    \ new header\n         * & fill in the IP total length.\n         */\n       \
    \ len -= (cp - bufp);\n        if (len < 0)\n             /*\n              *\
    \ we must have dropped some characters (crc should detect\n              * this\
    \ but the old slip framing won't)\n              */\n             goto bad;\n\
    \        if ((int) cp & 3) {\n             if (len > 0)\n                  OVBCOPY(cp,\
    \ (int) cp & ~3, len);\n             cp = (u_char *) ((int) cp & ~3);\n      \
    \  }\n        cp -= cs->cs_hlen;\n        len += cs->cs_hlen;\n        cs->cs_ip.ip_len\
    \ = htons(len);\n        BCOPY(&cs->cs_ip, cp, cs->cs_hlen);\n        /* recompute\
    \ the ip header checksum */\n        {\n             register u_short *bp = (u_short\
    \ *) cp;\n             for (changes = 0; hlen > 0; hlen -= 2)\n              \
    \    changes += *bp++;\n             changes = (changes & 0xffff) + (changes >>\
    \ 16);\n             changes = (changes & 0xffff) + (changes >> 16);\n       \
    \      ((struct ip *) cp)->ip_sum = ~changes;\n        }\n        return (cp);\n\
    \   bad:\n        comp->flags |= SLF_TOSS;\n        return ((u_char *) 0);\n \
    \  }\n   A.4  Initialization\n   This routine initializes the state structure\
    \ for both the transmit and\n   receive halves of some serial line.  It must be\
    \ called each time the\n   line is brought up.\n   void\n   sl_compress_init(comp)\n\
    \        struct slcompress *comp;\n   {\n        register u_int i;\n        register\
    \ struct cstate *tstate = comp->tstate;\n        /*\n         * Clean out any\
    \ junk left from the last time line was used.\n         */\n        bzero((char\
    \ *) comp, sizeof(*comp));\n        /*\n         * Link the transmit states into\
    \ a circular list.\n         */\n        for (i = MAX_STATES - 1; i > 0; --i)\
    \ {\n             tstate[i].cs_id = i;\n             tstate[i].cs_next = &tstate[i\
    \ - 1];\n        }\n        tstate[0].cs_next = &tstate[MAX_STATES - 1];\n   \
    \     tstate[0].cs_id = 0;\n        comp->last_cs = &tstate[0];\n        /*\n\
    \         * Make sure we don't accidentally do CID compression\n         * (assumes\
    \ MAX_STATES < 255).\n         */\n        comp->last_recv = 255;\n        comp->last_xmit\
    \ = 255;\n   }\n   A.5  Berkeley Unix dependencies\n   Note:  The following is\
    \ of interest only if you are trying to bring the\n   sample code up on a system\
    \ that is not derived from 4BSD (Berkeley\n   Unix).\n   The code uses the normal\
    \ Berkeley Unix header files (from\n   /usr/include/netinet) for definitions of\
    \ the structure of IP and TCP\n   headers.  The structure tags tend to follow\
    \ the protocol RFCs closely\n   and should be obvious even if you do not have\
    \ access to a 4BSD\n   system./48/\n   ----------------------------\n    48. In\
    \ the event they are not obvious, the header files (and all the\n   Berkeley networking\
    \ code) can be anonymous ftp'd from host\n   The macro BCOPY(src, dst, amt) is\
    \ invoked to copy amt bytes from src to\n   dst.  In BSD, it translates into a\
    \ call to bcopy.  If you have the\n   misfortune to be running System-V Unix,\
    \ it can be translated into a call\n   to memcpy.  The macro OVBCOPY(src, dst,\
    \ amt) is used to copy when src\n   and dst overlap (i.e., when doing the 4-byte\
    \ alignment copy).  In the\n   BSD kernel, it translates into a call to ovbcopy.\
    \  Since AT&T botched\n   the definition of memcpy, this should probably translate\
    \ into a copy\n   loop under System-V.\n   The macro BCMP(src, dst, amt) is invoked\
    \ to compare amt bytes of src and\n   dst for equality.  In BSD, it translates\
    \ into a call to bcmp.  In\n   System-V, it can be translated into a call to memcmp\
    \ or you can write a\n   routine to do the compare.  The routine should return\
    \ zero if all bytes\n   of src and dst are equal and non-zero otherwise.\n   The\
    \ routine ntohl(dat) converts (4 byte) long dat from network byte\n   order to\
    \ host byte order.  On a reasonable cpu this can be the no-op\n   macro:\n   \
    \                        #define ntohl(dat) (dat)\n   On a Vax or IBM PC (or anything\
    \ with Intel byte order), you will have to\n   define a macro or routine to rearrange\
    \ bytes.\n   The routine ntohs(dat) is like ntohl but converts (2 byte) shorts\n\
    \   instead of longs.  The routines htonl(dat) and htons(dat) do the inverse\n\
    \   transform (host to network byte order) for longs and shorts.\n   A struct\
    \ mbuf is used in the call to sl_compress_tcp because that\n   routine needs to\
    \ modify both the start address and length if the\n   incoming packet is compressed.\
    \  In BSD, an mbuf is the kernel's buffer\n   management structure.  If other\
    \ systems, the following definition should\n   be sufficient:\n            struct\
    \ mbuf {\n                    u_char  *m_off; /* pointer to start of data */\n\
    \                    int     m_len;  /* length of data */\n            };\n  \
    \          #define mtod(m, t) ((t)(m->m_off))\n   ----------------------------\n\
    \   ucbarpa.berkeley.edu, files pub/4.3/tcp.tar and pub/4.3/inet.tar.\n   B  Compatibility\
    \ with past mistakes\n   When combined with the modern PPP serial line protocol[9],\
    \ the use of\n   header compression is automatic and invisible to the user.\n\
    \   Unfortunately, many sites have existing users of the SLIP described in\n \
    \  [12] which doesn't allow for different protocol types to distinguish\n   header\
    \ compressed packets from IP packets or for version numbers or an\n   option exchange\
    \ that could be used to automatically negotiate header\n   compression.\n   The\
    \ author has used the following tricks to allow header compressed SLIP\n   to\
    \ interoperate with the existing servers and clients.  Note that these\n   are\
    \ hacks for compatibility with past mistakes and should be offensive\n   to any\
    \ right thinking person.  They are offered solely to ease the pain\n   of running\
    \ SLIP while users wait patiently for vendors to release PPP.\n   B.1  Living\
    \ without a framing `type' byte\n   The bizarre packet type numbers in sec. A.1\
    \ were chosen to allow a\n   `packet type' to be sent on lines where it is undesirable\
    \ or impossible\n   to add an explicit type byte.  Note that the first byte of\
    \ an IP packet\n   always contains `4' (the IP protocol version) in the top four\
    \ bits.  And\n   that the most significant bit of the first byte of the compressed\
    \ header\n   is ignored.  Using the packet types in sec. A.1, the type can be\
    \ encoded\n   in the most significant bits of the outgoing packet using the code\n\
    \                    p->dat[0] |= sl_compress_tcp(p, comp);\n    and decoded on\
    \ the receive side by\n                  if (p->dat[0] & 0x80)\n             \
    \             type = TYPE_COMPRESSED_TCP;\n                  else if (p->dat[0]\
    \ >= 0x70) {\n                          type = TYPE_UNCOMPRESSED_TCP;\n      \
    \                    p->dat[0] &=~ 0x30;\n                  } else\n         \
    \                 type = TYPE_IP;\n                  status = sl_uncompress_tcp(p,\
    \ type, comp);\n   B.2  Backwards compatible SLIP servers\n   The SLIP described\
    \ in [12] doesn't include any mechanism that could be\n   used to automatically\
    \ negotiate header compression.  It would be nice to\n   allow users of this SLIP\
    \ to use header compression but, when users of\n   the two SLIP varients share\
    \ a common server, it would be annoying and\n   difficult to manually configure\
    \ both ends of each connection to enable\n   compression.  The following procedure\
    \ can be used to avoid manual\n   configuration.\n   Since there are two types\
    \ of dial-in clients (those that implement\n   compression and those that don't)\
    \ but one server for both types, it's\n   clear that the server will be reconfiguring\
    \ for each new client session\n   but clients change configuration seldom if ever.\
    \  If manual\n   configuration has to be done, it should be done on the side that\
    \ changes\n   infrequently --- the client.  This suggests that the server should\n\
    \   somehow learn from the client whether to use header compression.\n   Assuming\
    \ symmetry (i.e., if compression is used at all it should be used\n   both directions)\
    \ the server can use the receipt of a compressed packet\n   from some client to\
    \ indicate that it can send compressed packets to that\n   client.  This leads\
    \ to the following algorithm:\n   There are two bits per line to control header\
    \ compression:  allowed and\n   on.  If on is set, compressed packets are sent,\
    \ otherwise not.  If\n   allowed is set, compressed packets can be received and,\
    \ if an\n   UNCOMPRESSED_TCP packet arrives when on is clear, on will be set./49/\n\
    \   If a compressed packet arrives when allowed is clear, it will be\n   ignored.\n\
    \   Clients are configured with both bits set (allowed is always set if on\n \
    \  is set) and the server starts each session with allowed set and on\n   clear.\
    \  The first compressed packet from the client (which must be a\n   UNCOMPRESSED_TCP\
    \ packet) turns on compression for the server.\n   ----------------------------\n\
    \    49. Since [12] framing doesn't include error detection, one should be\n \
    \  careful not to `false trigger' compression on the server.  The\n   UNCOMPRESSED_TCP\
    \ packet should checked for consistency (e.g., IP\n   checksum correctness) before\
    \ compression is enabled.  Arrival of\n   COMPRESSED_TCP packets should not be\
    \ used to enable compression.\n   C  More aggressive compression\n   As noted\
    \ in sec. 3.2.2, easily detected patterns exist in the stream of\n   compressed\
    \ headers, indicating that more compression could be done.\n   Would this be worthwhile?\n\
    \   The average compressed datagram has only seven bits of header./50/  The\n\
    \   framing must be at least one bit (to encode the `type') and will\n   probably\
    \ be more like two to three bytes.  In most interesting cases\n   there will be\
    \ at least one byte of data.  Finally, the end-to-end\n   check---the TCP checksum---must\
    \ be passed through unmodified./51/\n   The framing, data and checksum will remain\
    \ even if the header is\n   completely compressed out so the change in average\
    \ packet size is, at\n   best, four bytes down to three bytes and one bit ---\
    \ roughly a 25%\n   improvement in delay./52/  While this may seem significant,\
    \ on a 2400\n   bps line it means that typing echo response takes 25 rather than\
    \ 29 ms.\n   At the present stage of human evolution, this difference is not\n\
    \   detectable.\n   However, the author sheepishly admits to perverting this compression\n\
    \   scheme for a very special case data-acquisition problem:  We had an\n   instrument\
    \ and control package floating at 200KV, communicating with\n   ground level via\
    \ a telemetry system.  For many reasons (multiplexed\n   communication, pipelining,\
    \ error recovery, availability of well tested\n   implementations, etc.), it was\
    \ convenient to talk to the package using\n   TCP/IP. However, since the primary\
    \ use of the telemetry link was data\n   acquisition, it was designed with an\
    \ uplink channel capacity <0.5% the\n   downlink's.  To meet application delay\
    \ budgets, data packets were 100\n   bytes and, since TCP acks every other packet,\
    \ the relative uplink\n   bandwidth for acks is a/200 where `a' is the total size\
    \ of ack packets.\n   Using the scheme in this paper, the smallest ack is four\
    \ bytes which\n   would imply an uplink bandwidth 2% of the downlink.  This wasn't\n\
    \   ----------------------------\n    50. Tests run with several million packets\
    \ from a mixed traffic load\n   (i.e., statistics kept on a year's traffic from\
    \ my home to work) show\n   that 80% of packets use one of the two special encodings\
    \ and, thus, the\n   only header is the change mask.\n    51. If someone tries\
    \ to sell you a scheme that compresses the TCP\n   checksum `Just say no'.  Some\
    \ poor fool has yet to have the sad\n   experience that reveals the end-to-end\
    \ argument is gospel truth.  Worse,\n   since the fool is subverting your end-to-end\
    \ error check, you may pay\n   the price for this education and they will be none\
    \ the wiser.  What does\n   it profit a man to gain two byte times of delay and\
    \ lose peace of mind?\n    52. Note again that we must be concerned about interactive\
    \ delay to be\n   making this argument:  Bulk data transfer performance will be\
    \ dominated\n   by the time to send the data and the difference between three\
    \ and four\n   byte headers on a datagram containing tens or hundreds of data\
    \ bytes is,\n   practically, no difference.\n   possible so we used the scheme\
    \ described in footnote 15:  If the first\n   bit of the frame was one, it meant\
    \ `same compressed header as last\n   time'.  Otherwise the next two bits gave\
    \ one of the types described in\n   sec. 3.2.  Since the link had excellent forward\
    \ error correction and\n   traffic made only a single hop, the TCP checksum was\
    \ compressed out\n   (blush!) of the `same header' packet types/53/ so the total\
    \ header size\n   for these packets was one bit.  Over several months of operation,\
    \ more\n   than 99% of the 40 byte TCP/IP headers were compressed down to one\n\
    \   bit./54/\n   D  Security Considerations\n   Security considerations are not\
    \ addressed in this memo.\n   E  Author's address\n       Address:  Van Jacobson\n\
    \                 Real Time Systems Group\n                 Mail Stop 46A\n  \
    \               Lawrence Berkeley Laboratory\n                 Berkeley, CA 94720\n\
    \       Phone:    Use email (author ignores his phone)\n       EMail:    van@helios.ee.lbl.gov\n\
    \   ----------------------------\n    53. The checksum was re-generated in the\
    \ decompressor and, of course,\n   the `toss' logic was made considerably more\
    \ aggressive to prevent error\n   propagation.\n    54. We have heard the suggestion\
    \ that `real-time' needs require\n   abandoning TCP/IP in favor of a `light-weight'\
    \ protocol with smaller\n   headers.  It is difficult to envision a protocol that\
    \ averages less than\n   one header bit per packet.\n"
