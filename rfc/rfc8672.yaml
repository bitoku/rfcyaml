- title: __initial_text__
  contents:
  - ''
- title: Independent Submission                                        Y. Sheffer
  contents:
  - "Independent Submission                                        Y. Sheffer\n  \
    \              TLS Server Identity Pinning with Tickets\n"
- title: Abstract
  contents:
  - "Abstract\n   Misissued public-key certificates can prevent TLS clients from\n\
    \   appropriately authenticating the TLS server.  Several alternatives\n   have\
    \ been proposed to detect this situation and prevent a client from\n   establishing\
    \ a TLS session with a TLS end point authenticated with an\n   illegitimate public-key\
    \ certificate.  These mechanisms are either not\n   widely deployed or limited\
    \ to public web browsing.\n   This document proposes experimental extensions to\
    \ TLS with opaque\n   pinning tickets as a way to pin the server's identity. \
    \ During an\n   initial TLS session, the server provides an original encrypted\n\
    \   pinning ticket.  In subsequent TLS session establishment, upon\n   receipt\
    \ of the pinning ticket, the server proves its ability to\n   decrypt the pinning\
    \ ticket and thus the ownership of the pinning\n   protection key.  The client\
    \ can now safely conclude that the TLS\n   session is established with the same\
    \ TLS server as the original TLS\n   session.  One of the important properties\
    \ of this proposal is that no\n   manual management actions are required.\n"
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This document is not an Internet Standards Track specification;\
    \ it is\n   published for examination, experimental implementation, and\n   evaluation.\n\
    \   This document defines an Experimental Protocol for the Internet\n   community.\
    \  This is a contribution to the RFC Series, independently\n   of any other RFC\
    \ stream.  The RFC Editor has chosen to publish this\n   document at its discretion\
    \ and makes no statement about its value for\n   implementation or deployment.\
    \  Documents approved for publication by\n   the RFC Editor are not candidates\
    \ for any level of Internet Standard;\n   see Section 2 of RFC 7841.\n   Information\
    \ about the current status of this document, any errata,\n   and how to provide\
    \ feedback on it may be obtained at\n   https://www.rfc-editor.org/info/rfc8672.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (c) 2019 IETF Trust and the persons identified\
    \ as the\n   document authors.  All rights reserved.\n   This document is subject\
    \ to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n\
    \   (https://trustee.ietf.org/license-info) in effect on the date of\n   publication\
    \ of this document.  Please review these documents\n   carefully, as they describe\
    \ your rights and restrictions with respect\n   to this document.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1.  Introduction\n     1.1.  Conventions Used in This Document\n\
    \     1.2.  Scope of Experimentation\n   2.  Protocol Overview\n     2.1.  Initial\
    \ Connection\n     2.2.  Subsequent Connections\n     2.3.  Indexing the Pins\n\
    \   3.  Message Definitions\n   4.  Cryptographic Operations\n     4.1.  Pinning\
    \ Secret\n     4.2.  Pinning Ticket\n     4.3.  Pinning Protection Key\n     4.4.\
    \  Pinning Proof\n   5.  Operational Considerations\n     5.1.  Protection Key\
    \ Synchronization\n     5.2.  Ticket Lifetime\n     5.3.  Certificate Renewal\n\
    \     5.4.  Certificate Revocation\n     5.5.  Disabling Pinning\n     5.6.  Server\
    \ Compromise\n     5.7.  Disaster Recovery\n   6.  Security Considerations\n \
    \    6.1.  Trust-on-First-Use (TOFU) and MITM Attacks\n     6.2.  Pervasive Monitoring\n\
    \     6.3.  Server-Side Error Detection\n     6.4.  Client Policy and SSL Proxies\n\
    \     6.5.  Client-Side Error Behavior\n     6.6.  Stolen and Forged Tickets\n\
    \     6.7.  Client Privacy\n     6.8.  Ticket Protection Key Management\n   7.\
    \  IANA Considerations\n   8.  References\n     8.1.  Normative References\n \
    \    8.2.  Informative References\n   Appendix A.  Previous Work\n     A.1.  Comparison:\
    \ HPKP\n     A.2.  Comparison: TACK\n   Acknowledgments\n   Authors' Addresses\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   Misissued public-key certificates can prevent TLS [RFC8446]\
    \ clients\n   from appropriately authenticating the TLS server.  This is a\n \
    \  significant risk in the context of the global public key\n   infrastructure\
    \ (PKI), and similarly for large-scale deployments of\n   certificates within\
    \ enterprises.\n   This document proposes experimental extensions to TLS with\
    \ opaque\n   pinning tickets as a way to pin the server's identity.  The approach\n\
    \   is intended to be easy to implement and deploy, and reuses some of\n   the\
    \ ideas behind TLS session resumption [RFC5077].\n   Ticket pinning is a second-factor\
    \ server authentication method and is\n   not proposed as a substitute for the\
    \ authentication method provided\n   in the TLS key exchange.  More specifically,\
    \ the client only uses the\n   pinning identity method after the TLS key exchange\
    \ is successfully\n   completed.  In other words, the pinning identity method\
    \ is only\n   performed over an authenticated TLS session.  Note that ticket\n\
    \   pinning does not pin certificate information and therefore is truly\n   an\
    \ independent second-factor authentication.\n   Ticket pinning is a trust-on-first-use\
    \ (TOFU) mechanism, in that the\n   first server authentication is only based\
    \ on PKI certificate\n   validation, but for any follow-on sessions, the client\
    \ is further\n   ensuring the server's identity based on the server's ability\
    \ to\n   decrypt the ticket, in addition to normal PKI certificate\n   authentication.\n\
    \   During initial TLS session establishment, the client requests a\n   pinning\
    \ ticket from the server.  Upon receiving the request the\n   server generates\
    \ a pinning secret that is expected to be\n   unpredictable for peers other than\
    \ the client or the server.  In our\n   case, the pinning secret is generated\
    \ from parameters exchanged\n   during the TLS key exchange, so client and server\
    \ can generate it\n   locally and independently.  The server constructs the pinning\
    \ ticket\n   with the necessary information to retrieve the pinning secret.  The\n\
    \   server then encrypts the ticket and returns the pinning ticket to the\n  \
    \ client with an associated pinning lifetime.\n   The pinning lifetime value indicates\
    \ for how long the server promises\n   to retain the server-side ticket-encryption\
    \ key, which allows it to\n   complete the protocol exchange correctly and prove\
    \ its identity.  The\n   server commitment (and ticket lifetime) is typically\
    \ on the order of\n   weeks.\n   Once the key exchange is completed, and the server\
    \ is deemed\n   authenticated, the client generates locally the pinning secret\
    \ and\n   caches the server's identifiers to index the pinning secret as well\n\
    \   as the pinning ticket and its associated lifetime.\n   When the client reestablishes\
    \ a new TLS session with the server, it\n   sends the pinning ticket to the server.\
    \  Upon receiving it, the\n   server returns a proof of knowledge of the pinning\
    \ secret.  Once the\n   key exchange is completed, and the server has been authenticated,\
    \ the\n   client checks the pinning proof returned by the server using the\n \
    \  client's stored pinning secret.  If the proof matches, the client can\n   conclude\
    \ that the server to which it is currently connecting is, in\n   fact, the correct\
    \ server.\n   This document only applies to TLS 1.3.  We believe that the idea\
    \ can\n   also be retrofitted into earlier versions of the protocol, but this\n\
    \   would require significant changes.  One example is that TLS 1.2\n   [RFC5246]\
    \ and earlier versions do not provide a generic facility of\n   encrypted handshake\
    \ extensions, such as is used here to transport the\n   ticket.\n   The main advantages\
    \ of this protocol over earlier pinning solutions\n   are the following:\n   *\
    \  The protocol is at the TLS level, and as a result is not\n      restricted\
    \ to HTTP at the application level.\n   *  The protocol is robust to changes in\
    \ server IP address,\n      certification authority (CA), and public key.  The\
    \ server is\n      characterized by the ownership of the pinning protection key,\n\
    \      which is never provided to the client.  Server configuration\n      parameters\
    \ such as the CA and the public key may change without\n      affecting the pinning\
    \ ticket protocol.\n   *  Once a single parameter is configured (the ticket's\
    \ lifetime),\n      operation is fully automated.  The server administrator need\
    \ not\n      bother with the management of backup certificates or explicit\n \
    \     pins.\n   *  For server clusters, we reuse the existing infrastructure\n\
    \      [RFC5077] where it exists.\n   *  Pinning errors, presumably resulting\
    \ from man-in-the-middle (MITM)\n      attacks, can be detected both by the client\
    \ and the server.  This\n      allows for server-side detection of MITM attacks\
    \ using large-scale\n      analytics, and with no need to rely on clients to explicitly\n\
    \      report the error.\n   A note on terminology: unlike other solutions in\
    \ this space, we do\n   not do \"certificate pinning\" (or \"public key pinning\"\
    ), since the\n   protocol is oblivious to the server's certificate.  We prefer\
    \ the\n   term \"server identity pinning\" for this new solution.  In our\n  \
    \ solution, the server proves its identity by generating a proof that\n   it can\
    \ read and decrypt an encrypted ticket.  As a result, the\n   identity proof relies\
    \ on proof of ownership of the pinning protection\n   key.  However, this key\
    \ is never exchanged with the client or known\n   by it, and so cannot itself\
    \ be pinned.\n"
- title: 1.1.  Conventions Used in This Document
  contents:
  - "1.1.  Conventions Used in This Document\n   The key words \"MUST\", \"MUST NOT\"\
    , \"REQUIRED\", \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\"\
    , \"NOT RECOMMENDED\", \"MAY\", and\n   \"OPTIONAL\" in this document are to be\
    \ interpreted as described in\n   BCP 14 [RFC2119] [RFC8174] when, and only when,\
    \ they appear in all\n   capitals, as shown here.\n"
- title: 1.2.  Scope of Experimentation
  contents:
  - "1.2.  Scope of Experimentation\n   This document describes an experimental extension\
    \ to the TLS\n   protocol.  This section defines constraints on this experiment\
    \ and\n   how it can yield useful information, potentially resulting in a\n  \
    \ standard.\n   The protocol is designed so that if the server does not support\
    \ it,\n   the client and server fall back to a normal TLS exchange, with the\n\
    \   exception of a single PinningTicket extension being initially sent by\n  \
    \ the client.  In addition, the protocol is designed only to strengthen\n   the\
    \ validation of the server's identity (\"second factor\").  As a\n   result, implementation\
    \ or even protocol errors should not result in\n   weakened security compared\
    \ to the normal TLS exchange.  Given these\n   two points, experimentation can\
    \ be run on the open Internet between\n   consenting client and server implementations.\n\
    \   The goal of the experiment is to prove that:\n   *  Non-supporting clients\
    \ and servers are unaffected.\n   *  Connectivity between supporting clients and\
    \ servers is retained\n      under normal circumstances, whether the client connects\
    \ to the\n      server frequently (relative to the ticket's lifetime) or very\n\
    \      rarely.\n   *  Enterprise middleboxes do not interrupt such connectivity.\n\
    \   *  Misissued certificates and rogue TLS-aware middleboxes do result\n    \
    \  in broken connectivity, and these cases are detected on the client\n      and/or\
    \ server side.  Clients and servers can be recovered even\n      after such events\
    \ and the normal connectivity restored.\n   Following two years of successful\
    \ deployment, the authors will\n   publish a document that summarizes the experiment's\
    \ findings and will\n   resubmit the protocol for consideration as a Proposed\
    \ Standard.\n"
- title: 2.  Protocol Overview
  contents:
  - "2.  Protocol Overview\n   The protocol consists of two phases: the first time\
    \ a particular\n   client connects to a server, and subsequent connections.\n\
    \   This protocol supports full TLS handshakes, as well as 0-RTT\n   handshakes.\
    \  Below we present it in the context of a full handshake,\n   but behavior in\
    \ 0-RTT handshakes should be identical.\n   The document presents some similarities\
    \ with the ticket resumption\n   mechanism described in [RFC5077].  However the\
    \ scope of this document\n   differs from session resumption mechanisms implemented\
    \ with [RFC5077]\n   or with other mechanisms.  Specifically, the pinning ticket\
    \ does not\n   carry any state associated with a TLS session and thus cannot be\
    \ used\n   for session resumption or client authentication.  Instead, the\n  \
    \ pinning ticket only contains the encrypted pinning secret.  The\n   pinning\
    \ ticket is used by the server to prove its ability to decrypt\n   it, which implies\
    \ ownership of the pinning protection key.\n   [RFC5077] has been obsoleted by\
    \ [RFC8446], and ticket resumption is\n   now defined by Section 2.2 of [RFC8446].\
    \  This document references\n   [RFC5077] as an informational document since it\
    \ contains a more\n   thorough discussion of stateless ticket resumption, and\
    \ because\n   ticket resumption benefits from significant operational experience\n\
    \   with TLS 1.2 that is still widely deployed at the time of writing.\n   This\
    \ experience, as well as deployment experience, can easily be re-\n   used for\
    \ identity pinning.\n   With TLS 1.3, session resumption is based on a Pre-Shared\
    \ Key (PSK).\n   This is orthogonal to this protocol.  With TLS 1.3, a TLS session\
    \ can\n   be established using PKI and a pinning ticket, and later resumed with\n\
    \   PSK.\n   However, the protocol described in this document addresses the\n\
    \   problem of misissued certificates.  Thus, it is not expected to be\n   used\
    \ outside a certificate-based TLS key exchange, such as in PSK.\n   As a result,\
    \ PSK handshakes MUST NOT include the extension defined\n   here.\n"
- title: 2.1.  Initial Connection
  contents:
  - "2.1.  Initial Connection\n   When a client first connects to a server, it requests\
    \ a pinning\n   ticket by sending an empty PinningTicket extension, and receives\
    \ it\n   as part of the server's first response, in the returned PinningTicket\n\
    \   extension.\n    Client                                               Server\n\
    \    ClientHello\n      + key_share\n      + signature_algorithms\n      + PinningTicket\
    \         -------->\n    {Certificate*}\n    {CertificateVerify*}\n    {Finished}\
    \                -------->\n    [Application Data]        <------->      [Application\
    \ Data]\n           *  Indicates optional or situation-dependent\n           \
    \   messages that are not always sent.\n           {} Indicates messages protected\
    \ using keys\n              derived from the ephemeral secret.\n           []\
    \ Indicates messages protected using keys\n              derived from the master\
    \ secret.\n   If a client supports the PinningTicket extension and does not have\n\
    \   any pinning ticket associated with the server, the exchange is\n   considered\
    \ as an initial connection.  Other reasons the client may\n   not have a pinning\
    \ ticket include the client having flushed its\n   pinning ticket store, or the\
    \ committed lifetime of the pinning ticket\n   having expired.\n   Upon receipt\
    \ of the PinningTicket extension, the server computes a\n   pinning secret (Section\
    \ 4.1) and sends the pinning ticket\n   (Section 4.2) encrypted with the pinning\
    \ protection key\n   (Section 4.3).  The pinning ticket is associated with a lifetime\n\
    \   value by which the server assumes the responsibility of retaining the\n  \
    \ pinning protection key and being able to decrypt incoming pinning\n   tickets\
    \ during the period indicated by the committed lifetime.\n   Once the pinning\
    \ ticket has been generated, the server returns the\n   pinning ticket and the\
    \ committed lifetime in a PinningTicket\n   extension embedded in the EncryptedExtensions\
    \ message.  We note that\n   a PinningTicket extension MUST NOT be sent as part\
    \ of a\n   HelloRetryRequest.\n   Upon receiving the pinning ticket, the client\
    \ MUST NOT accept it\n   until the key exchange is completed and the server authenticated.\
    \  If\n   the key exchange is not completed successfully, the client MUST\n  \
    \ ignore the received pinning ticket.  Otherwise, the client computes\n   the\
    \ pinning secret and SHOULD cache the pinning secret and the\n   pinning ticket\
    \ for the duration indicated by the pinning ticket\n   lifetime.  The client SHOULD\
    \ clean up the cached values at the end of\n   the indicated lifetime.\n"
- title: 2.2.  Subsequent Connections
  contents:
  - "2.2.  Subsequent Connections\n   When the client initiates a connection to a\
    \ server it has previously\n   seen (see Section 2.3 on identifying servers),\
    \ it SHOULD send the\n   pinning ticket for that server.  The pinning ticket,\
    \ pinning secret,\n   and pinning ticket lifetime computed during the establishment\
    \ of the\n   previous TLS session are designated in this document as the\n   \"\
    original\" ones, to distinguish them from a new ticket that may be\n   generated\
    \ during the current session.\n   The server MUST extract the original pinning_secret\
    \ value from the\n   ticket and MUST respond with a PinningTicket extension, which\n\
    \   includes:\n   *  A proof that the server can understand the ticket that was\
    \ sent by\n      the client; this proof also binds the pinning ticket to the\n\
    \      server's (current) public key, as well as the ongoing TLS session.\n  \
    \    The proof is mandatory and MUST be included if a pinning ticket\n      was\
    \ sent by the client.\n   *  A fresh pinning ticket.  The main reason for refreshing\
    \ the ticket\n      on each connection is privacy: to avoid the ticket serving\
    \ as a\n      fixed client identifier.  While a fresh pinning ticket might be\
    \ of\n      zero length, it is RECOMMENDED to include a fresh ticket with a\n\
    \      nonzero length with each response.\n   If the server cannot validate the\
    \ received ticket, that might\n   indicate an earlier MITM attack on this client.\
    \  The server MUST then\n   abort the connection with a handshake_failure alert\
    \ and SHOULD log\n   this failure.\n   The client MUST verify the proof, and if\
    \ it fails to do so, the\n   client MUST issue a handshake_failure alert and abort\
    \ the connection\n   (see also Section 6.5).  It is important that the client\
    \ does not\n   attempt to \"fall back\" by omitting the PinningTicket extension.\n\
    \   When the connection is successfully set up, i.e., after the Finished\n   message\
    \ is verified, the client SHOULD store the new ticket along\n   with the corresponding\
    \ pinning_secret, replacing the original ticket.\n   Although this is an extension,\
    \ if the client already has a ticket for\n   a server, the client MUST interpret\
    \ a missing PinningTicket extension\n   in the server's response as an attack,\
    \ because of the server's prior\n   commitment to respect the ticket.  The client\
    \ MUST abort the\n   connection in this case.  See also Section 5.5 on ramping\
    \ down\n   support for this extension.\n"
- title: 2.3.  Indexing the Pins
  contents:
  - "2.3.  Indexing the Pins\n   Each pin is associated with a set of identifiers\
    \ that include, among\n   others, hostname, protocol (TLS or DTLS), and port number.\
    \  In other\n   words, the pin for port TCP/443 may be different from that for\
    \ DTLS,\n   or from the pin for port TCP/8443.  These identifiers are expected\
    \ to\n   be relevant to characterize the identity of the server as well as the\n\
    \   establishing TLS session.  When a hostname is used, it MUST be the\n   value\
    \ sent inside the Server Name Indication (SNI) extension.  This\n   definition\
    \ is similar to the concept of a Web Origin [RFC6454], but\n   does not assume\
    \ the existence of a URL.\n   The purpose of ticket pinning is to pin the server\
    \ identity.  As a\n   result, any information orthogonal to the server's identity\
    \ MUST NOT\n   be considered in indexing.  More particularly, IP addresses are\n\
    \   ephemeral and forbidden in SNI, and therefore pins MUST NOT be\n   associated\
    \ with IP addresses.  Similarly, CA names or public keys\n   associated with server\
    \ MUST NOT be used for indexing as they may\n   change over time.\n"
- title: 3.  Message Definitions
  contents:
  - "3.  Message Definitions\n   This section defines the format of the PinningTicket\
    \ extension.  We\n   follow the message notation of [RFC8446].\n    opaque pinning_ticket<0..2^16-1>;\n\
    \    opaque pinning_proof<0..2^8-1>;\n    struct {\n      select (Role) {\n  \
    \      case client:\n          pinning_ticket ticket<0..2^16-1>; //omitted on\
    \ 1st connection\n        case server:\n          pinning_proof proof<0..2^8-1>;\
    \ //no proof on 1st connection\n          pinning_ticket ticket<0..2^16-1>; //omitted\
    \ on ramp down\n          uint32 lifetime;\n      }\n   } PinningTicketExtension;\n\
    \   ticket    a pinning ticket sent by the client or returned by the\n       \
    \      server.  The ticket is opaque to the client.  The extension\n         \
    \    MUST contain exactly 0 or 1 tickets.\n   proof     a demonstration by the\
    \ server that it understands the\n             received ticket and therefore that\
    \ it is in possession of\n             the secret that was used to generate it\
    \ originally.  The\n             extension MUST contain exactly 0 or 1 proofs.\n\
    \   lifetime  the duration (in seconds) that the server commits to accept\n  \
    \           offered tickets in the future.\n"
- title: 4.  Cryptographic Operations
  contents:
  - "4.  Cryptographic Operations\n   This section provides details on the cryptographic\
    \ operations\n   performed by the protocol peers.\n"
- title: 4.1.  Pinning Secret
  contents:
  - "4.1.  Pinning Secret\n   The pinning secret is generated locally by the client\
    \ and the server,\n   which means they must use the same inputs to generate it.\
    \  This value\n   must be generated before the ServerHello message is sent, as\
    \ the\n   server includes the corresponding pinning ticket in the same flight\n\
    \   as the ServerHello message.  In addition, the pinning secret must be\n   unpredictable\
    \ to any party other than the client and the server.\n   The pinning secret is\
    \ derived using the Derive-Secret function\n   provided by TLS 1.3, described\
    \ in Section 7.1 of [RFC8446].\n   pinning secret = Derive-Secret(Handshake Secret,\
    \ \"pinning secret\",\n            ClientHello...ServerHello)\n"
- title: 4.2.  Pinning Ticket
  contents:
  - "4.2.  Pinning Ticket\n   The pinning ticket contains the pinning secret.  The\
    \ pinning ticket\n   is provided by the client to the server, which decrypts it\
    \ in order\n   to extract the pinning secret and responds with a pinning proof.\
    \  As\n   a result, the characteristics of the pinning ticket are:\n   *  Pinning\
    \ tickets MUST be encrypted and integrity-protected using\n      strong cryptographic\
    \ algorithms.\n   *  Pinning tickets MUST be protected with a long-term pinning\n\
    \      protection key.\n   *  Pinning tickets MUST include a pinning protection\
    \ key ID or serial\n      number as to enable the pinning protection key to be\
    \ refreshed.\n   *  The pinning ticket MAY include other information, in addition\
    \ to\n      the pinning secret.  When additional information is included, a\n\
    \      careful review needs to be performed to evaluate its impact on\n      privacy.\n\
    \   The pinning ticket's format is not specified by this document, but a\n   format\
    \ similar to the one proposed by [RFC5077] is RECOMMENDED.\n"
- title: 4.3.  Pinning Protection Key
  contents:
  - "4.3.  Pinning Protection Key\n   The pinning protection key is used only by the\
    \ server and so remains\n   server implementation specific.  [RFC5077] recommends\
    \ the use of two\n   keys, but when using Authenticated Encryption with Associated\
    \ Data\n   (AEAD) algorithms, only a single key is required.\n   When a single\
    \ server terminates TLS for multiple virtual servers\n   using the SNI mechanism,\
    \ it is strongly RECOMMENDED that the server\n   use a separate protection key\
    \ for each one of them, in order to allow\n   migrating virtual servers between\
    \ different servers while keeping\n   pinning active.\n   As noted in Section\
    \ 5.1, if the server is actually a cluster of\n   machines, the protection key\
    \ MUST be synchronized between all the\n   nodes that accept TLS connections to\
    \ the same server name.  When\n   [RFC5077] is deployed, an easy way to do it\
    \ is to derive the\n   protection key from the session-ticket protection key,\
    \ which is\n   already synchronized.  For example:\n   pinning_protection_key\
    \ = HKDF-Expand(resumption_protection_key,\n   Where resumption_protection_key\
    \ is the ticket protection key defined\n   in [RFC5077].  Both resumption_protection_key\
    \ and\n   pinning_protection_key are only used by the server.\n   The above solution\
    \ attempts to minimize code changes related to\n   management of the resumption_protection_key.\
    \  The drawback is that\n   this key would be used both to directly encrypt session\
    \ tickets and\n   to derive the pinning_protection_key, and such mixed usage of\
    \ a\n   single key is not in line with cryptographic best practices.  Where\n\
    \   possible, it is RECOMMENDED that the resumption_protection_key be\n   unrelated\
    \ to the pinning_protection_key and that they are separately\n   shared among\
    \ the relevant servers.\n"
- title: 4.4.  Pinning Proof
  contents:
  - "4.4.  Pinning Proof\n   The pinning proof is sent by the server to demonstrate\
    \ that it has\n   been able to decrypt the pinning ticket and to retrieve the\
    \ pinning\n   secret.  The proof must be unpredictable and must not be replayed.\n\
    \   Similarly to the pinning ticket, the pinning proof is sent by the\n   server\
    \ in the ServerHello message.  In addition, it must not be\n   possible for a\
    \ MITM server with a fake certificate to obtain a\n   pinning proof from the original\
    \ server.\n   In order to address these requirements, the pinning proof is bound\
    \ to\n   the TLS session as well as the public key of the server:\n   pinning_proof_secret=Derive-Secret(Handshake\
    \ Secret,\n                \"pinning proof 1\", ClientHello...ServerHello)\n \
    \  proof = HMAC(original_pinning_secret, \"pinning proof 2\" +\n             \
    \   pinning_proof_secret + Hash(server_public_key))\n   where HMAC [RFC2104] uses\
    \ the Hash algorithm that was negotiated in\n   the handshake, and the same hash\
    \ is also used over the server's\n   public key.  The original_pinning_secret\
    \ value refers to the secret\n   value extracted from the ticket sent by the client,\
    \ to distinguish it\n   from a new pinning secret value that is possibly computed\
    \ in the\n   current exchange.  The server_public_key value is the DER\n   representation\
    \ of the public key, specifically the\n   SubjectPublicKeyInfo structure as-is.\n"
- title: 5.  Operational Considerations
  contents:
  - "5.  Operational Considerations\n   The main motivation behind the current protocol\
    \ is to enable identity\n   pinning without the need for manual operations.  Manual\
    \ operations\n   are susceptible to human error, and in the case of public key\n\
    \   pinning, can easily result in \"server bricking\": the server becoming\n \
    \  inaccessible to some or all of its users.  To achieve this goal,\n   operations\
    \ described in identity pinning are only performed within\n   the current TLS\
    \ session, and there is no dependence on any TLS\n   configuration parameters\
    \ such as CA identity or public keys.  As a\n   result, configuration changes\
    \ are unlikely to lead to desynchronized\n   state between the client and the\
    \ server.\n"
- title: 5.1.  Protection Key Synchronization
  contents:
  - "5.1.  Protection Key Synchronization\n   The only operational requirement when\
    \ deploying this protocol is\n   that, if the server is part of a cluster, protection\
    \ keys (the keys\n   used to encrypt tickets) MUST be synchronized between all\
    \ cluster\n   members.  The protocol is designed so that if resumption ticket\n\
    \   protection keys [RFC5077] are already synchronized between cluster\n   members,\
    \ nothing more needs to be done.\n   Moreover, synchronization does not need to\
    \ be instantaneous, e.g.,\n   protection keys can be distributed a few minutes\
    \ or hours in advance\n   of their rollover.  In such scenarios, each cluster\
    \ member MUST be\n   able to accept tickets protected with a new version of the\
    \ protection\n   key, even while it is still using an old version to generate\
    \ keys.\n   This ensures that, when a client receives a \"new\" ticket, it does\
    \ not\n   next hit a cluster member that still rejects this ticket.\n   Misconfiguration\
    \ can lead to the server's clock being off by a large\n   amount of time.  Consider\
    \ a case where a server's clock is\n   misconfigured, for example, to be 1 year\
    \ in the future, and the\n   system is allowed to delete expired keys automatically.\
    \  The server\n   will then delete many outstanding keys because they are now\
    \ long\n   expired and will end up rejecting valid tickets that are stored by\n\
    \   clients.  Such a scenario could make the server inaccessible to a\n   large\
    \ number of clients.\n   The decision to delete a key should at least consider\
    \ the largest\n   value of the ticket lifetime as well as the expected time\n\
    \   desynchronization between the servers of the cluster and the time\n   difference\
    \ for distributing the new key among the different servers\n   in the cluster.\n"
- title: 5.2.  Ticket Lifetime
  contents:
  - "5.2.  Ticket Lifetime\n   The lifetime of the ticket is a commitment by the server\
    \ to retain\n   the ticket's corresponding protection key for this duration, so\
    \ that\n   the server can prove to the client that it knows the secret embedded\n\
    \   in the ticket.  For production systems, the lifetime SHOULD be\n   between\
    \ 7 and 31 days.\n"
- title: 5.3.  Certificate Renewal
  contents:
  - "5.3.  Certificate Renewal\n   The protocol ensures that the client will continue\
    \ speaking to the\n   correct server even when the server's certificate is renewed.\
    \  In\n   this sense, pinning is not associated with certificates, which is the\n\
    \   reason we designate the protocol described in this document as\n   \"server\
    \ identity pinning\".\n   Note that this property is not impacted by the use of\
    \ the server's\n   public key in the pinning proof because the scope of the public\
    \ key\n   used is only the current TLS session.\n"
- title: 5.4.  Certificate Revocation
  contents:
  - "5.4.  Certificate Revocation\n   The protocol is orthogonal to certificate validation\
    \ in the sense\n   that, if the server's certificate has been revoked or is invalid\
    \ for\n   some other reason, the client MUST refuse to connect to it regardless\n\
    \   of any ticket-related behavior.\n"
- title: 5.5.  Disabling Pinning
  contents:
  - "5.5.  Disabling Pinning\n   A server implementing this protocol MUST have a \"\
    ramp down\" mode of\n   operation where:\n   *  The server continues to accept\
    \ valid pinning tickets and responds\n      correctly with a proof.\n   *  The\
    \ server does not send back a new pinning ticket.\n   After a while, no clients\
    \ will hold valid tickets, and the feature\n   may be disabled.  Note that clients\
    \ that do not receive a new pinning\n   ticket do not necessarily need to remove\
    \ the original ticket.\n   Instead, the client may keep using the ticket until\
    \ its lifetime\n   expires.  However, as detailed in Section 6.7, re-use of a\
    \ ticket by\n   the client may result in privacy concerns as the ticket value\
    \ may be\n   used to correlate TLS sessions.\n   Issuing a new pinning ticket\
    \ with a shorter lifetime would only delay\n   the ramp down process, as the shorter\
    \ lifetime can only affect\n   clients that actually initiated a new connection.\
    \  Other clients\n   would still see the original lifetime for their pinning tickets.\n"
- title: 5.6.  Server Compromise
  contents:
  - "5.6.  Server Compromise\n   If a server compromise is detected, the pinning protection\
    \ key MUST\n   be rotated immediately, but the server MUST still accept valid\n\
    \   tickets that use the old, compromised key.  Clients that still hold\n   old\
    \ pinning tickets will remain vulnerable to MITM attacks, but those\n   that connect\
    \ to the correct server will immediately receive new\n   tickets protected with\
    \ the newly generated pinning protection key.\n   The same procedure applies if\
    \ the pinning protection key is\n   compromised directly, e.g., if a backup copy\
    \ is inadvertently made\n   public.\n"
- title: 5.7.  Disaster Recovery
  contents:
  - "5.7.  Disaster Recovery\n   All web servers in production need to be backed up,\
    \ so that they can\n   be recovered if a disaster (including a malicious activity)\
    \ ever\n   wipes them out.  Backup often includes the certificate and its\n  \
    \ private key, which must be backed up securely.  The pinning secret,\n   including\
    \ earlier versions that are still being accepted, must be\n   backed up regularly.\
    \  However since it is only used as an\n   authentication second factor, it does\
    \ not require the same level of\n   confidentiality as the server's private key.\n\
    \   Readers should note that [RFC5077] session resumption keys are more\n   security\
    \ sensitive and should normally not be backed up, but rather\n   treated as ephemeral\
    \ keys.  Even when servers derive pinning secrets\n   from resumption keys (Section\
    \ 4.1), they MUST NOT back up resumption\n   keys.\n"
- title: 6.  Security Considerations
  contents:
  - "6.  Security Considerations\n   This section reviews several security aspects\
    \ related to the proposed\n   extension.\n"
- title: 6.1.  Trust-on-First-Use (TOFU) and MITM Attacks
  contents:
  - "6.1.  Trust-on-First-Use (TOFU) and MITM Attacks\n   This protocol is a trust-on-first-use\
    \ protocol.  If a client\n   initially connects to the \"right\" server, it will\
    \ be protected\n   against MITM attackers for the lifetime of each received ticket.\
    \  If\n   it connects regularly (depending, of course, on the server-selected\n\
    \   lifetime), it will stay constantly protected against fake\n   certificates.\n\
    \   However if it initially connects to an attacker, subsequent\n   connections\
    \ to the \"right\" server will fail.  Server operators might\n   want to advise\
    \ clients on how to remove corrupted pins, once such\n   large-scale attacks are\
    \ detected and remediated.\n   The protocol is designed so that it is not vulnerable\
    \ to an active\n   MITM attacker who has real-time access to the original server.\
    \  The\n   pinning proof includes a hash of the server's public key to ensure\n\
    \   the client that the proof was in fact generated by the server with\n   which\
    \ it is initiating the connection.\n"
- title: 6.2.  Pervasive Monitoring
  contents:
  - "6.2.  Pervasive Monitoring\n   Some organizations, and even some countries, perform\
    \ pervasive\n   monitoring on their constituents [RFC7258].  This often takes\
    \ the\n   form of always-active SSL proxies.  Because of the TOFU property,\n\
    \   this protocol does not provide any security in such cases.\n   Pervasive monitoring\
    \ may also result in privacy concerns detailed in\n   Section 6.7.\n"
- title: 6.3.  Server-Side Error Detection
  contents:
  - "6.3.  Server-Side Error Detection\n   Uniquely, this protocol allows the server\
    \ to detect clients that\n   present incorrect tickets and therefore can be assumed\
    \ to be victims\n   of a MITM attack.  Server operators can use such cases as\
    \ indications\n   of ongoing attacks, similarly to fake certificate attacks that\
    \ took\n   place in a few countries in the past.\n"
- title: 6.4.  Client Policy and SSL Proxies
  contents:
  - "6.4.  Client Policy and SSL Proxies\n   Like it or not, some clients are normally\
    \ deployed behind an SSL\n   proxy.  Similar to [RFC7469], it is acceptable to\
    \ allow pinning to be\n   disabled for some hosts according to local policy. \
    \ For example, a\n   User Agent (UA) MAY disable pinning for hosts whose validated\n\
    \   certificate chain terminates at a user-defined trust anchor, rather\n   than\
    \ a trust anchor built into the UA (or underlying platform).\n   Moreover, a client\
    \ MAY accept an empty PinningTicket extension from\n   such hosts as a valid response.\n"
- title: 6.5.  Client-Side Error Behavior
  contents:
  - "6.5.  Client-Side Error Behavior\n   When a client receives a malformed or empty\
    \ PinningTicket extension\n   from a pinned server, it MUST abort the handshake.\
    \  If the client\n   retries the request, it MUST NOT omit the PinningTicket in\
    \ the retry\n   message.  Doing otherwise would expose the client to trivial fallback\n\
    \   attacks, similar to those described in [RFC7507].\n   However, this rule can\
    \ negatively impact clients that move from\n   behind SSL proxies into the open\
    \ Internet, and vice versa, if the\n   advice in Section 6.4 is not followed.\
    \  Therefore, it is RECOMMENDED\n   that browser and library vendors provide a\
    \ documented way to remove\n   stored pins.\n"
- title: 6.6.  Stolen and Forged Tickets
  contents:
  - "6.6.  Stolen and Forged Tickets\n   An attacker gains no benefit from stealing\
    \ pinning tickets, even in\n   conjunction with other pinning parameters such\
    \ as the associated\n   pinning secret, since pinning tickets are used to secure\
    \ the client\n   rather than the server.  Similarly, it is useless to forge a\
    \ ticket\n   for a particular server.\n"
- title: 6.7.  Client Privacy
  contents:
  - "6.7.  Client Privacy\n   This protocol is designed so that an external attacker\
    \ cannot link\n   different requests to a single client, provided the client requests\n\
    \   and receives a fresh ticket upon each connection.  This may be of\n   concern\
    \ particularly during ramp down, if the server does not provide\n   a new ticket,\
    \ and the client reuses the same ticket.  To reduce or\n   avoid such privacy\
    \ concerns, it is RECOMMENDED for the server to\n   issue a fresh ticket with\
    \ a reduced lifetime.  This would at least\n   reduce the time period in which\
    \ the TLS sessions of the client can be\n   linked.  The server MAY also issue\
    \ tickets with a zero-second\n   lifetime until it is confident all tickets are\
    \ expired.\n   On the other hand, the server to which the client is connecting\
    \ can\n   easily track the client.  This may be an issue when the client\n   expects\
    \ to connect to the server (e.g., a mail server) with multiple\n   identities.\
    \  Implementations SHOULD allow the user to opt out of\n   pinning, either in\
    \ general or for particular servers.\n   This document does not define the exact\
    \ content of tickets.\n   Including client-specific information in tickets would\
    \ raise privacy\n   concerns and is NOT RECOMMENDED.\n"
- title: 6.8.  Ticket Protection Key Management
  contents:
  - "6.8.  Ticket Protection Key Management\n   While the ticket format is not mandated\
    \ by this document, protecting\n   the ticket using authenticated encryption is\
    \ RECOMMENDED.  Some of\n   the algorithms commonly used for authenticated encryption,\
    \ e.g.,\n   Galois/Counter Mode (GCM), are highly vulnerable to nonce reuse, and\n\
    \   this problem is magnified in a cluster setting.  Therefore,\n   implementations\
    \ that choose AES-GCM or any AEAD equivalent MUST adopt\n   one of these three\
    \ alternatives:\n   *  Partition the nonce namespace between cluster members and\
    \ use\n      monotonic counters on each member, e.g., by setting the nonce to\n\
    \      the concatenation of the cluster member ID and an incremental\n      counter.\n\
    \   *  Generate random nonces but avoid the so-called birthday bound,\n      i.e.,\
    \ never generate more than the maximum allowed number of\n      encrypted tickets\
    \ (2**64 for AES-128-GCM) for the same ticket\n      pinning protection key.\n\
    \   *  An alternative design that has been attributed to Karthik\n      Bhargavan\
    \ is as follows.  Start with a 128-bit master key K_master\n      and then for\
    \ each encryption, generate a 256-bit random nonce and\n      compute: K = HKDF(K_master,\
    \ Nonce || \"key\"), then N =\n      HKDF(K_master, Nonce || \"nonce\").  Use\
    \ these values to encrypt the\n      ticket, AES-GCM(K, N, data).  This nonce\
    \ should then be stored and\n      transmitted with the ticket.\n"
- title: 7.  IANA Considerations
  contents:
  - "7.  IANA Considerations\n   The IANA has allocated a TicketPinning extension\
    \ value in the \"TLS\n   ExtensionType Values\" registry.\n   [RFC8447] defines\
    \ the procedure, requirements, and the necessary\n   information for the IANA\
    \ to update the \"TLS ExtensionType Values\"\n   registry [TLS-EXT].  The registration\
    \ procedure is \"Specification\n   Required\" [RFC8126].\n   The TicketPinning\
    \ extension is registered as follows.  (The extension\n   is not limited to Private\
    \ Use, and as such has its first byte in the\n   range 0-254.)\n   Value:  32\n\
    \   Name:  ticket_pinning\n   Recommended:  No\n   TLS 1.3:  CH, EE (to indicate\
    \ that the extension is present in\n      ClientHello and EncryptedExtensions\
    \ messages)\n"
- title: 8.  References
  contents:
  - '8.  References

    '
- title: 8.1.  Normative References
  contents:
  - "8.1.  Normative References\n   [RFC2119]  Bradner, S., \"Key words for use in\
    \ RFCs to Indicate\n              Requirement Levels\", BCP 14, RFC 2119,\n  \
    \            DOI 10.17487/RFC2119, March 1997,\n              <https://www.rfc-editor.org/info/rfc2119>.\n\
    \   [RFC8126]  Cotton, M., Leiba, B., and T. Narten, \"Guidelines for\n      \
    \        Writing an IANA Considerations Section in RFCs\", BCP 26,\n         \
    \     RFC 8126, DOI 10.17487/RFC8126, June 2017,\n              <https://www.rfc-editor.org/info/rfc8126>.\n\
    \   [RFC8174]  Leiba, B., \"Ambiguity of Uppercase vs Lowercase in RFC\n     \
    \         2119 Key Words\", BCP 14, RFC 8174, DOI 10.17487/RFC8174,\n        \
    \      May 2017, <https://www.rfc-editor.org/info/rfc8174>.\n   [RFC8446]  Rescorla,\
    \ E., \"The Transport Layer Security (TLS) Protocol\n              Version 1.3\"\
    , RFC 8446, DOI 10.17487/RFC8446, August 2018,\n              <https://www.rfc-editor.org/info/rfc8446>.\n\
    \   [RFC8447]  Salowey, J. and S. Turner, \"IANA Registry Updates for TLS\n  \
    \            and DTLS\", RFC 8447, DOI 10.17487/RFC8447, August 2018,\n      \
    \        <https://www.rfc-editor.org/info/rfc8447>.\n"
- title: 8.2.  Informative References
  contents:
  - "8.2.  Informative References\n   [Netcraft] Mutton, P., \"HTTP Public Key Pinning:\
    \ You're doing it\n              wrong!\", March 2016,\n              <https://news.netcraft.com/archives/2016/03/30/http-\n\
    \              public-key-pinning-youre-doing-it-wrong.html>.\n   [Oreo]     Berkman,\
    \ O., Pinkas, B., and M. Yung, \"Firm Grip\n              Handshakes: A Tool for\
    \ Bidirectional Vouching\", Cryptology\n              and Network Security pp.\
    \ 142-157, 2012.\n   [RFC2104]  Krawczyk, H., Bellare, M., and R. Canetti, \"\
    HMAC: Keyed-\n              Hashing for Message Authentication\", RFC 2104,\n\
    \              DOI 10.17487/RFC2104, February 1997,\n              <https://www.rfc-editor.org/info/rfc2104>.\n\
    \   [RFC5077]  Salowey, J., Zhou, H., Eronen, P., and H. Tschofenig,\n       \
    \       \"Transport Layer Security (TLS) Session Resumption without\n        \
    \      Server-Side State\", RFC 5077, DOI 10.17487/RFC5077,\n              January\
    \ 2008, <https://www.rfc-editor.org/info/rfc5077>.\n   [RFC5246]  Dierks, T. and\
    \ E. Rescorla, \"The Transport Layer Security\n              (TLS) Protocol Version\
    \ 1.2\", RFC 5246,\n              DOI 10.17487/RFC5246, August 2008,\n       \
    \       <https://www.rfc-editor.org/info/rfc5246>.\n   [RFC6454]  Barth, A., \"\
    The Web Origin Concept\", RFC 6454,\n              DOI 10.17487/RFC6454, December\
    \ 2011,\n              <https://www.rfc-editor.org/info/rfc6454>.\n   [RFC6962]\
    \  Laurie, B., Langley, A., and E. Kasper, \"Certificate\n              Transparency\"\
    , RFC 6962, DOI 10.17487/RFC6962, June 2013,\n              <https://www.rfc-editor.org/info/rfc6962>.\n\
    \   [RFC7258]  Farrell, S. and H. Tschofenig, \"Pervasive Monitoring Is an\n \
    \             Attack\", BCP 188, RFC 7258, DOI 10.17487/RFC7258, May\n       \
    \       2014, <https://www.rfc-editor.org/info/rfc7258>.\n   [RFC7469]  Evans,\
    \ C., Palmer, C., and R. Sleevi, \"Public Key Pinning\n              Extension\
    \ for HTTP\", RFC 7469, DOI 10.17487/RFC7469, April\n              2015, <https://www.rfc-editor.org/info/rfc7469>.\n\
    \   [RFC7507]  Moeller, B. and A. Langley, \"TLS Fallback Signaling Cipher\n \
    \             Suite Value (SCSV) for Preventing Protocol Downgrade\n         \
    \     Attacks\", RFC 7507, DOI 10.17487/RFC7507, April 2015,\n              <https://www.rfc-editor.org/info/rfc7507>.\n\
    \   [RFC8555]  Barnes, R., Hoffman-Andrews, J., McCarney, D., and J.\n       \
    \       Kasten, \"Automatic Certificate Management Environment\n             \
    \ (ACME)\", RFC 8555, DOI 10.17487/RFC8555, March 2019,\n              <https://www.rfc-editor.org/info/rfc8555>.\n\
    \   [TLS-EXT]  IANA, \"TLS Extension Type Value\",\n              <https://www.iana.org/assignments/tls-extensiontype-\n\
    \              values/>.\n   [TLS-TACK] Marlinspike, M., \"Trust Assertions for\
    \ Certificate Keys\",\n              Work in Progress, Internet-Draft, draft-perrin-tls-tack-\n\
    \              02, 7 January 2013,\n              <https://tools.ietf.org/html/draft-perrin-tls-tack-02>.\n"
- title: Appendix A.  Previous Work
  contents:
  - "Appendix A.  Previous Work\n   The global PKI system relies on the trust of a\
    \ CA issuing\n   certificates.  As a result, a corrupted trusted CA may issue\
    \ a\n   certificate for any organization without the organization's approval\n\
    \   (a misissued or \"fake\" certificate), and use the certificate to\n   impersonate\
    \ the organization.  There are many attempts to resolve\n   these weaknesses,\
    \ including the Certificate Transparency (CT)\n   protocol [RFC6962], HTTP Public\
    \ Key Pinning (HPKP) [RFC7469], and\n   Trust Assertions for Certificate Keys\
    \ (TACK) [TLS-TACK].\n   CT requires cooperation of a large portion of the hundreds\
    \ of extant\n   certificate authorities (CAs) before it can be used \"for real\"\
    , in\n   enforcing mode.  It is noted that the relevant industry forum (CA/\n\
    \   Browser Forum) is indeed pushing for such extensive adoption.\n   However\
    \ the public nature of CT often makes it inappropriate for\n   enterprise use\
    \ because many organizations are not willing to expose\n   their internal infrastructure\
    \ publicly.\n   TACK has some similarities to the current proposal, but work on\
    \ it\n   seems to have stalled.  Appendix A.2 compares our proposal to TACK.\n\
    \   HPKP is an IETF standard, but so far has proven hard to deploy.  HPKP\n  \
    \ pins (fixes) a public key, one of the public keys listed in the\n   certificate\
    \ chain.  As a result, HPKP needs to be coordinated with\n   the certificate management\
    \ process.  Certificate management impacts\n   HPKP and thus increases the probability\
    \ of HPKP failures.  This risk\n   is made even higher given the fact that, even\
    \ though work has been\n   done in the Automated Certificate Management Environment\
    \ (ACME)\n   working group to automate certificate management, in many or even\n\
    \   most cases, certificates are still managed manually.  As a result,\n   HPKP\
    \ cannot be completely automated, resulting in error-prone manual\n   configuration.\
    \  Such errors could prevent the web server from being\n   accessed by some clients.\
    \  In addition, HPKP uses an HTTP header,\n   which makes this solution HTTPS\
    \ specific and not generic to TLS.  On\n   the other hand, the current document\
    \ provides a solution that is\n   independent of the server's certificate management,\
    \ and that can be\n   entirely and easily automated.  Appendix A.1 compares HPKP\
    \ to the\n   current document in more detail.\n   The ticket pinning proposal\
    \ augments these mechanisms with a much\n   easier to implement and deploy solution\
    \ for server identity pinning,\n   by reusing some of the ideas behind TLS session\
    \ resumption.\n   This section compares ticket pinning to two earlier proposals,\
    \ HPKP\n   and TACK.\n"
- title: 'A.1.  Comparison: HPKP'
  contents:
  - "A.1.  Comparison: HPKP\n   The current IETF standard for pinning the identity\
    \ of web servers is\n   HPKP [RFC7469].\n   The main differences between HPKP\
    \ and the current document are the\n   following:\n   *  HPKP limits its scope\
    \ to HTTPS, while the current document\n      considers all application above\
    \ TLS.\n   *  HPKP pins the public key of the server (or another public key\n\
    \      along the certificate chain), and as such, is highly dependent on\n   \
    \   the management of certificates.  Such dependency increases the\n      potential\
    \ error surface, especially as certificate management is\n      not yet largely\
    \ automated.  The current proposal, on the other\n      hand, is independent of\
    \ certificate management.\n   *  HPKP pins public keys that are public and used\
    \ for the standard\n      TLS authentication.  Identity pinning relies on the\
    \ ownership of\n      the pinning key, which is not disclosed to the public and\
    \ not\n      involved in the standard TLS authentication.  As a result,\n    \
    \  identity pinning is a completely independent, second-factor\n      authentication\
    \ mechanism.\n   *  HPKP relies on a backup key to recover the misissuance of\
    \ a key.\n      We believe such backup mechanisms add excessive complexity and\n\
    \      cost.  Reliability of the current mechanism is primarily based on\n   \
    \   its being highly automated.\n   *  HPKP relies on the client to report errors\
    \ to the report-uri.  The\n      current document does not need any out-of-band\
    \ mechanism, and the\n      server is informed automatically.  This provides an\
    \ easier and\n      more reliable health monitoring.\n   On the other hand, HPKP\
    \ shares the following aspects with identity\n   pinning:\n   *  Both mechanisms\
    \ provide hard failure.  With HPKP, only the client\n      is aware of the failure,\
    \ while with the current proposal both\n      client and server are informed of\
    \ the failure.  This provides room\n      for further mechanisms to automatically\
    \ recover from such\n      failures.\n   *  Both mechanisms are subject to a server\
    \ compromise in which users\n      are provided with an invalid ticket (e.g.,\
    \ a random one) or HTTP\n      header with a very long lifetime.  For identity\
    \ pinning, this\n      lifetime SHOULD NOT be longer than 31 days.  In both cases,\n\
    \      clients will not be able to reconnect the server during this\n      lifetime.\
    \  With the current proposal, an attacker needs to\n      compromise the TLS layer,\
    \ while with HPKP, the attacker needs to\n      compromise the HTTP server.  Arguably,\
    \ the TLS-level compromise is\n      typically more difficult for the attacker.\n\
    \   Unfortunately HPKP has not seen wide deployment yet.  As of March\n   2016,\
    \ the number of servers using HPKP was less than 3000 [Netcraft].\n   This may\
    \ simply be due to inertia, but we believe the main reason is\n   the interactions\
    \ between HPKP and manual certificate management that\n   is needed to implement\
    \ HPKP for enterprise servers.  The penalty for\n   making mistakes (e.g., being\
    \ too early or too late to deploy new\n   pins) is that the server becomes unusable\
    \ for some of the clients.\n   To demonstrate this point, we present a list of\
    \ the steps involved in\n   deploying HPKP on a security-sensitive web server.\n\
    \   1.   Generate two public/private key pairs on a computer that is not\n   \
    \     the live server.  The second one is the \"backup1\" key pair.\n        openssl\
    \ genrsa -out \"example.com.key\" 2048;\n        openssl genrsa -out \"example.com.backup1.key\"\
    \ 2048;\n   2.   Generate hashes for both of the public keys.  These will be used\n\
    \        in the HPKP header:\n        openssl rsa -in \"example.com.key\" -outform\
    \ der -pubout | \\\n        openssl dgst -sha256 -binary | openssl enc -base64\n\
    \        openssl rsa -in \"example.com.backup1.key\" -outform der \\\n       \
    \ -pubout | openssl dgst -sha256 -binary | openssl enc -base64\n   3.   Generate\
    \ a single CSR (Certificate Signing Request) for the\n        first key pair,\
    \ where you include the domain name in the CN\n        (Common Name) field:\n\
    \        openssl req -new -subj \"/C=GB/ST=Area/L=Town/O=Org/ \\\n        CN=example.com\"\
    \ -key \"example.com.key\" -out \"example.com.csr\";\n   4.   Send this CSR to\
    \ the CA and go though the dance to prove you own\n        the domain.  The CA\
    \ will give you a single certificate that will\n        typically expire within\
    \ a year or two.\n   5.   On the live server, upload and set up the first key\
    \ pair and its\n        certificate.  At this point, you can add the \"Public-Key-Pins\"\
    \n        header, using the two hashes you created in step 2.\n        Note that\
    \ only the first key pair has been uploaded to the\n        server so far.\n \
    \  6.   Store the second (backup1) key pair somewhere safe, probably\n       \
    \ somewhere encrypted like a password manager.  It won't expire,\n        as it's\
    \ just a key pair; it just needs to be ready for when you\n        need to get\
    \ your next certificate.\n   7.   Time passes -- probably just under a year (if\
    \ waiting for a\n        certificate to expire), or maybe sooner if you find that\
    \ your\n        server has been compromised, and you need to replace the key\n\
    \        pair and certificate.\n   8.   Create a new CSR using the \"backup1\"\
    \ key pair, and get a new\n        certificate from your CA.\n   9.   Generate\
    \ a new backup key pair (backup2), get its hash, and\n        store it in a safe\
    \ place (again, not on the live server).\n   10.  Replace your old certificate\
    \ and old key pair, update the\n        \"Public-Key-Pins\" header to remove the\
    \ old hash, and add the new\n        \"backup2\" key pair.\n   Note that in the\
    \ above steps, both the certificate issuance as well\n   as the storage of the\
    \ backup key pair involve manual steps.  Even\n   with an automated CA that runs\
    \ the ACME protocol [RFC8555], key\n   backup would be a challenge to automate.\n"
- title: 'A.2.  Comparison: TACK'
  contents:
  - "A.2.  Comparison: TACK\n   Compared with HPKP, TACK [TLS-TACK] is more similar\
    \ to the current\n   document.  It can even be argued that this document is a\
    \ symmetric-\n   cryptography variant of TACK.  That said, there are still a few\n\
    \   significant differences:\n   *  Probably the most important difference is\
    \ that with TACK,\n      validation of the server certificate is no longer required,\
    \ and in\n      fact TACK specifies it as a \"MAY\" requirement ([TLS-TACK],\n\
    \      Section 5.3).  With ticket pinning, certificate validation by the\n   \
    \   client remains a MUST requirement, and the ticket acts only as a\n      second\
    \ factor.  If the pinning secret is compromised, the server's\n      security\
    \ is not immediately at risk.\n   *  Both TACK and the current document are mostly\
    \ orthogonal to the\n      server certificate as far as their life cycle, and\
    \ so both can be\n      deployed with no manual steps.\n   *  TACK uses Elliptic\
    \ Curve Digital Signature Algorithm (ECDSA) to\n      sign the server's public\
    \ key.  This allows cooperating clients to\n      share server assertions between\
    \ themselves.  This is an optional\n      TACK feature, and one that cannot be\
    \ done with pinning tickets.\n   *  TACK allows multiple servers to share its\
    \ public keys.  Such\n      sharing is disallowed by the current document.\n \
    \  *  TACK does not allow the server to track a particular client, and\n     \
    \ so has better privacy properties than the current document.\n   *  TACK has\
    \ an interesting way to determine the pin's lifetime,\n      setting it to the\
    \ time period since the pin was first observed,\n      with a hard upper bound\
    \ of 30 days.  The current document makes\n      the lifetime explicit, which\
    \ may be more flexible to deploy.  For\n      example, web sites that are only\
    \ visited rarely by users may opt\n      for a longer period than other sites\
    \ that expect users to visit on\n      a daily basis.\n"
- title: Acknowledgments
  contents:
  - "Acknowledgments\n   The original idea behind this proposal was published in [Oreo]\
    \ by\n   Moti Yung, Benny Pinkas, and Omer Berkman.  The current protocol is\n\
    \   but a distant relative of the original Oreo protocol, and any errors\n   are\
    \ the responsibility of the authors of this document alone.\n   We would like\
    \ to thank Adrian Farrel, Dave Garrett, Daniel Kahn\n   Gillmor, Alexey Melnikov,\
    \ Yoav Nir, Eric Rescorla, Benjamin Kaduk,\n   and Rich Salz for their comments\
    \ on this document.  Special thanks to\n   Craig Francis for contributing the\
    \ HPKP deployment script, and to\n   Ralph Holz for several fruitful discussions.\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Yaron Sheffer\n   Intuit\n   Email: yaronf.ietf@gmail.com\n\
    \   Daniel Migault\n"
