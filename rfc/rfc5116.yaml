- title: __initial_text__
  contents:
  - '        An Interface and Algorithms for Authenticated Encryption

    '
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This document specifies an Internet standards track protocol\
    \ for the\n   Internet community, and requests discussion and suggestions for\n\
    \   improvements.  Please refer to the current edition of the \"Internet\n   Official\
    \ Protocol Standards\" (STD 1) for the standardization state\n   and status of\
    \ this protocol.  Distribution of this memo is unlimited.\n"
- title: Abstract
  contents:
  - "Abstract\n   This document defines algorithms for Authenticated Encryption with\n\
    \   Associated Data (AEAD), and defines a uniform interface and a\n   registry\
    \ for such algorithms.  The interface and registry can be used\n   as an application-independent\
    \ set of cryptoalgorithm suites.  This\n   approach provides advantages in efficiency\
    \ and security, and promotes\n   the reuse of crypto implementations.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1.  Introduction . . . . . . . . . . . . . . . . . . .\
    \ . . . . . .  3\n     1.1.  Background . . . . . . . . . . . . . . . . . . .\
    \ . . . . .  3\n     1.2.  Scope  . . . . . . . . . . . . . . . . . . . . . .\
    \ . . . .  3\n     1.3.  Benefits . . . . . . . . . . . . . . . . . . . . . .\
    \ . . .  4\n     1.4.  Conventions Used in This Document  . . . . . . . . . .\
    \ . .  4\n   2.  AEAD Interface . . . . . . . . . . . . . . . . . . . . . . .\
    \ .  5\n     2.1.  Authenticated Encryption . . . . . . . . . . . . . . . . .\
    \  5\n     2.2.  Authenticated Decryption . . . . . . . . . . . . . . . . .  7\n\
    \     2.3.  Data Formatting  . . . . . . . . . . . . . . . . . . . . .  7\n  \
    \ 3.  Guidance on the Use of AEAD Algorithms . . . . . . . . . . . .  8\n    \
    \ 3.1.  Requirements on Nonce Generation . . . . . . . . . . . . .  8\n     3.2.\
    \  Recommended Nonce Formation  . . . . . . . . . . . . . . .  9\n       3.2.1.\
    \  Partially Implicit Nonces  . . . . . . . . . . . . . . 10\n     3.3.  Construction\
    \ of AEAD Inputs  . . . . . . . . . . . . . . . 11\n     3.4.  Example Usage \
    \ . . . . . . . . . . . . . . . . . . . . . . 11\n   4.  Requirements on AEAD\
    \ Algorithm Specifications  . . . . . . . . 12\n   5.  AEAD Algorithms  . . .\
    \ . . . . . . . . . . . . . . . . . . . . 14\n     5.1.  AEAD_AES_128_GCM . .\
    \ . . . . . . . . . . . . . . . . . . . 14\n       5.1.1.  Nonce Reuse  . . .\
    \ . . . . . . . . . . . . . . . . . . 14\n     5.2.  AEAD_AES_256_GCM . . . .\
    \ . . . . . . . . . . . . . . . . . 15\n     5.3.  AEAD_AES_128_CCM . . . . .\
    \ . . . . . . . . . . . . . . . . 15\n       5.3.1.  Nonce Reuse  . . . . . .\
    \ . . . . . . . . . . . . . . . 16\n     5.4.  AEAD_AES_256_CCM . . . . . . .\
    \ . . . . . . . . . . . . . . 16\n   6.  IANA Considerations  . . . . . . . .\
    \ . . . . . . . . . . . . . 16\n   7.  Other Considerations . . . . . . . . .\
    \ . . . . . . . . . . . . 17\n   8.  Security Considerations  . . . . . . . .\
    \ . . . . . . . . . . . 18\n   9.  Acknowledgments  . . . . . . . . . . . . .\
    \ . . . . . . . . . . 18\n   10. References . . . . . . . . . . . . . . . . .\
    \ . . . . . . . . . 19\n     10.1. Normative References . . . . . . . . . . .\
    \ . . . . . . . . 19\n     10.2. Informative References . . . . . . . . . . .\
    \ . . . . . . . 19\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   Authenticated encryption [BN00] is a form of encryption\
    \ that, in\n   addition to providing confidentiality for the plaintext that is\n\
    \   encrypted, provides a way to check its integrity and authenticity.\n   Authenticated\
    \ Encryption with Associated Data, or AEAD [R02], adds\n   the ability to check\
    \ the integrity and authenticity of some\n   Associated Data (AD), also called\
    \ \"additional authenticated data\",\n   that is not encrypted.\n"
- title: 1.1.  Background
  contents:
  - "1.1.  Background\n   Many cryptographic applications require both confidentiality\
    \ and\n   message authentication.  Confidentiality is a security service that\n\
    \   ensures that data is available only to those authorized to obtain it;\n  \
    \ usually it is realized through encryption.  Message authentication is\n   the\
    \ service that ensures that data has not been altered or forged by\n   unauthorized\
    \ entities; it can be achieved by using a Message\n   Authentication Code (MAC).\
    \  This service is also called data\n   integrity.  Many applications use an encryption\
    \ method and a MAC\n   together to provide both of those security services, with\
    \ each\n   algorithm using an independent key.  More recently, the idea of\n \
    \  providing both security services using a single cryptoalgorithm has\n   become\
    \ accepted.  In this concept, the cipher and MAC are replaced by\n   an Authenticated\
    \ Encryption with Associated Data (AEAD) algorithm.\n   Several crypto algorithms\
    \ that implement AEAD algorithms have been\n   defined, including block cipher\
    \ modes of operation and dedicated\n   algorithms.  Some of these algorithms have\
    \ been adopted and proven\n   useful in practice.  Additionally, AEAD is close\
    \ to an 'idealized'\n   view of encryption, such as those used in the automated\
    \ analysis of\n   cryptographic protocols (see, for example, Section 2.5 of [BOYD]).\n\
    \   The benefits of AEAD algorithms, and this interface, are outlined in\n   Section\
    \ 1.3.\n"
- title: 1.2.  Scope
  contents:
  - "1.2.  Scope\n   In this document, we define an AEAD algorithm as an abstraction,\
    \ by\n   specifying an interface to an AEAD and defining an IANA registry for\n\
    \   AEAD algorithms.  We populate this registry with four AEAD algorithms\n  \
    \ based on the Advanced Encryption Standard (AES) in Galois/Counter\n   Mode [GCM]\
    \ with 128- and 256-bit keys, and AES in Counter and CBC MAC\n   Mode [CCM] with\
    \ 128- and 256-bit keys.\n   In the following, we define the AEAD interface (Section\
    \ 2), and then\n   provide guidance on the use of AEAD algorithms (Section 3),\
    \ and\n   outline the requirements that each AEAD algorithm must meet\n   (Section\
    \ 4).  Then we define several AEAD algorithms (Section 5), and\n   establish an\
    \ IANA registry for AEAD algorithms (Section 6).  Lastly,\n   we discuss some\
    \ other considerations (Section 7).\n   The AEAD interface specification does\
    \ not address security protocol\n   issues such as anti-replay services or access\
    \ control decisions that\n   are made on authenticated data.  Instead, the specification\
    \ aims to\n   abstract the cryptography away from those issues.  The interface,\
    \ and\n   the guidance about how to use it, are consistent with the\n   recommendations\
    \ from [EEM04].\n"
- title: 1.3.  Benefits
  contents:
  - "1.3.  Benefits\n   The AEAD approach enables applications that need cryptographic\n\
    \   security services to more easily adopt those services.  It benefits\n   the\
    \ application designer by allowing them to focus on important\n   issues such\
    \ as security services, canonicalization, and data\n   marshaling, and relieving\
    \ them of the need to design crypto\n   mechanisms that meet their security goals.\
    \  Importantly, the security\n   of an AEAD algorithm can be analyzed independent\
    \ from its use in a\n   particular application.  This property frees the user\
    \ of the AEAD of\n   the need to consider security aspects such as the relative\
    \ order of\n   authentication and encryption and the security of the particular\n\
    \   combination of cipher and MAC, such as the potential loss of\n   confidentiality\
    \ through the MAC.  The application designer that uses\n   the AEAD interface\
    \ need not select a particular AEAD algorithm during\n   the design stage.  Additionally,\
    \ the interface to the AEAD is\n   relatively simple, since it requires only a\
    \ single key as input and\n   requires only a single identifier to indicate the\
    \ algorithm in use in\n   a particular case.\n   The AEAD approach benefits the\
    \ implementer of the crypto algorithms\n   by making available optimizations that\
    \ are otherwise not possible to\n   reduce the amount of computation, the implementation\
    \ cost, and/or the\n   storage requirements.  The simpler interface makes testing\
    \ easier;\n   this is a considerable benefit for a crypto algorithm implementation.\n\
    \   By providing a uniform interface to access cryptographic services,\n   the\
    \ AEAD approach allows a single crypto implementation to more\n   easily support\
    \ multiple applications.  For example, a hardware module\n   that supports the\
    \ AEAD interface can easily provide crypto\n   acceleration to any application\
    \ using that interface, even to\n   applications that had not been designed when\
    \ the module was built.\n"
- title: 1.4.  Conventions Used in This Document
  contents:
  - "1.4.  Conventions Used in This Document\n   The key words \"MUST\", \"MUST NOT\"\
    , \"REQUIRED\", \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\"\
    , \"MAY\", and \"OPTIONAL\" in this\n   document are to be interpreted as described\
    \ in [RFC2119].\n"
- title: 2.  AEAD Interface
  contents:
  - "2.  AEAD Interface\n   An AEAD algorithm has two operations, authenticated encryption\
    \ and\n   authenticated decryption.  The inputs and outputs of these algorithms\n\
    \   are defined below in terms of octet strings.\n   An implementation MAY accept\
    \ additional inputs.  For example, an\n   input could be provided to allow the\
    \ user to select between different\n   implementation strategies.  However, such\
    \ extensions MUST NOT affect\n   interoperability with other implementations.\n"
- title: 2.1.  Authenticated Encryption
  contents:
  - "2.1.  Authenticated Encryption\n   The authenticated encryption operation has\
    \ four inputs, each of which\n   is an octet string:\n      A secret key K, which\
    \ MUST be generated in a way that is uniformly\n      random or pseudorandom.\n\
    \      A nonce N.  Each nonce provided to distinct invocations of the\n      Authenticated\
    \ Encryption operation MUST be distinct, for any\n      particular value of the\
    \ key, unless each and every nonce is zero-\n      length.  Applications that\
    \ can generate distinct nonces SHOULD use\n      the nonce formation method defined\
    \ in Section 3.2, and MAY use any\n      other method that meets the uniqueness\
    \ requirement.  Other\n      applications SHOULD use zero-length nonces.\n   \
    \   A plaintext P, which contains the data to be encrypted and\n      authenticated.\n\
    \      The associated data A, which contains the data to be\n      authenticated,\
    \ but not encrypted.\n   There is a single output:\n      A ciphertext C, which\
    \ is at least as long as the plaintext, or\n      an indication that the requested\
    \ encryption operation could not be\n      performed.\n   All of the inputs and\
    \ outputs are variable-length octet strings,\n   whose lengths obey the following\
    \ restrictions:\n      The number of octets in the key K is between 1 and 255.\
    \  For each\n      AEAD algorithm, the length of K MUST be fixed.\n      For any\
    \ particular value of the key, either 1) each nonce provided\n      to distinct\
    \ invocations of the Authenticated Encryption operation\n      MUST be distinct,\
    \ or 2) each and every nonce MUST be zero-length.\n      If zero-length nonces\
    \ are used with a particular key, then each\n      and every nonce used with that\
    \ key MUST have a length of zero.\n      Otherwise, the number of octets in the\
    \ nonce SHOULD be twelve\n      (12).  Nonces with different lengths MAY be used\
    \ with a particular\n      key.  Some algorithms cannot be used with zero-length\
    \ nonces, but\n      others can; see Section 4.  Applications that conform to\
    \ the\n      recommended nonce length will avoid having to construct nonces\n\
    \      with different lengths, depending on the algorithm that is in use.\n  \
    \    This guidance helps to keep algorithm-specific logic out of\n      applications.\n\
    \      The number of octets in the plaintext P MAY be zero.\n      The number\
    \ of octets in the associated data A MAY be zero.\n      The number of octets\
    \ in the ciphertext C MAY be zero.\n   This specification does not put a maximum\
    \ length on the nonce, the\n   plaintext, the ciphertext, or the additional authenticated\
    \ data.\n   However, a particular AEAD algorithm MAY further restrict the lengths\n\
    \   of those inputs and outputs.  A particular AEAD implementation MAY\n   further\
    \ restrict the lengths of its inputs and outputs.  If a\n   particular implementation\
    \ of an AEAD algorithm is requested to\n   process an input that is outside the\
    \ range of admissible lengths, or\n   an input that is outside the range of lengths\
    \ supported by that\n   implementation, it MUST return an error code and it MUST\
    \ NOT output\n   any other information.  In particular, partially encrypted or\n\
    \   partially decrypted data MUST NOT be returned.\n   Both confidentiality and\
    \ message authentication are provided on the\n   plaintext P.  When the length\
    \ of P is zero, the AEAD algorithm acts\n   as a Message Authentication Code on\
    \ the input A.\n   The associated data A is used to protect information that needs\
    \ to be\n   authenticated, but does not need to be kept confidential.  When using\n\
    \   an AEAD to secure a network protocol, for example, this input could\n   include\
    \ addresses, ports, sequence numbers, protocol version numbers,\n   and other\
    \ fields that indicate how the plaintext or ciphertext should\n   be handled,\
    \ forwarded, or processed.  In many situations, it is\n   desirable to authenticate\
    \ these fields, though they must be left in\n   the clear to allow the network\
    \ or system to function properly.  When\n   this data is included in the input\
    \ A, authentication is provided\n   without copying the data into the plaintext.\n\
    \   The secret key K MUST NOT be included in any of the other inputs (N,\n   P,\
    \ and A).  (This restriction does not mean that the values of those\n   inputs\
    \ must be checked to ensure that they do not include substrings\n   that match\
    \ the key; instead, it means that the key must not be\n   explicitly copied into\
    \ those inputs.)\n   The nonce is authenticated internally to the algorithm, and\
    \ it is not\n   necessary to include it in the AD input.  The nonce MAY be included\n\
    \   in P or A if it is convenient to the application.\n   The nonce MAY be stored\
    \ or transported with the ciphertext, or it MAY\n   be reconstructed immediately\
    \ prior to the authenticated decryption\n   operation.  It is sufficient to provide\
    \ the decryption module with\n   enough information to allow it to construct the\
    \ nonce.  (For example,\n   a system could use a nonce consisting of a sequence\
    \ number in a\n   particular format, in which case it could be inferred from the\
    \ order\n   of the ciphertexts.)  Because the authenticated decryption process\n\
    \   detects incorrect nonce values, no security failure will result if a\n   nonce\
    \ is incorrectly reconstructed and fed into an authenticated\n   decryption operation.\
    \  Any nonce reconstruction method will need to\n   take into account the possibility\
    \ of loss or reorder of ciphertexts\n   between the encryption and decryption\
    \ processes.\n   Applications MUST NOT assume any particular structure or formatting\n\
    \   of the ciphertext.\n"
- title: 2.2.  Authenticated Decryption
  contents:
  - "2.2.  Authenticated Decryption\n   The authenticated decryption operation has\
    \ four inputs: K, N, A, and\n   C, as defined above.  It has only a single output,\
    \ either a plaintext\n   value P or a special symbol FAIL that indicates that\
    \ the inputs are\n   not authentic.  A ciphertext C, a nonce N, and associated\
    \ data A are\n   authentic for key K when C is generated by the encrypt operation\
    \ with\n   inputs K, N, P, and A, for some values of N, P, and A.  The\n   authenticated\
    \ decrypt operation will, with high probability, return\n   FAIL whenever the\
    \ inputs N, P, and A were crafted by a nonce-\n   respecting adversary that does\
    \ not know the secret key (assuming that\n   the AEAD algorithm is secure).\n"
- title: 2.3.  Data Formatting
  contents:
  - "2.3.  Data Formatting\n   This document does not specify any particular encoding\
    \ for the AEAD\n   inputs and outputs, since the encoding does not affect the\
    \ security\n   services provided by an AEAD algorithm.\n   When choosing the format\
    \ of application data, an application SHOULD\n   position the ciphertext C so\
    \ that it appears after any other data\n   that is needed to construct the other\
    \ inputs to the authenticated\n   decryption operation.  For instance, if the\
    \ nonce and ciphertext both\n   appear in a packet, the former value should precede\
    \ the latter.  This\n   rule facilitates efficient and simple hardware implementations\
    \ of\n   AEAD algorithms.\n"
- title: 3.  Guidance on the Use of AEAD Algorithms
  contents:
  - "3.  Guidance on the Use of AEAD Algorithms\n   This section provides advice that\
    \ must be followed in order to use an\n   AEAD algorithm securely.\n   If an application\
    \ is unable to meet the uniqueness requirement on\n   nonce generation, then it\
    \ MUST use a zero-length nonce.  Randomized\n   or stateful algorithms, which\
    \ are defined below, are suitable for use\n   with such applications.  Otherwise,\
    \ an application SHOULD use nonces\n   with a length of twelve octets.  Since\
    \ algorithms are encouraged to\n   support that length, applications should use\
    \ that length to aid\n   interoperability.\n"
- title: 3.1.  Requirements on Nonce Generation
  contents:
  - "3.1.  Requirements on Nonce Generation\n   It is essential for security that\
    \ the nonces be constructed in a\n   manner that respects the requirement that\
    \ each nonce value be\n   distinct for each invocation of the authenticated encryption\n\
    \   operation, for any fixed value of the key.  In this section, we call\n   attention\
    \ to some consequences of this requirement in different\n   scenarios.\n   When\
    \ there are multiple devices performing encryption using a single\n   key, those\
    \ devices must coordinate to ensure that the nonces are\n   unique.  A simple\
    \ way to do this is to use a nonce format that\n   contains a field that is distinct\
    \ for each one of the devices, as\n   described in Section 3.2.  Note that there\
    \ is no need to coordinate\n   the details of the nonce format between the encrypter\
    \ and the\n   decrypter, as long the entire nonce is sent or stored with the\n\
    \   ciphertext and is thus available to the decrypter.  If the complete\n   nonce\
    \ is not available to the decrypter, then the decrypter will need\n   to know\
    \ how the nonce is structured so that it can reconstruct it.\n   Applications\
    \ SHOULD provide encryption engines with some freedom in\n   choosing their nonces;\
    \ for example, a nonce could contain both a\n   counter and a field that is set\
    \ by the encrypter but is not processed\n   by the receiver.  This freedom allows\
    \ a set of encryption devices to\n   more readily coordinate to ensure the distinctness\
    \ of their nonces.\n   If a secret key will be used for a long period of time,\
    \ e.g., across\n   multiple reboots, then the nonce will need to be stored in\
    \ non-\n   volatile memory.  In such cases, it is essential to use checkpointing\n\
    \   of the nonce; that is, the current nonce value should be stored to\n   provide\
    \ the state information needed to resume encryption in case of\n   unexpected\
    \ failure.  One simple way to provide a high assurance that\n   a nonce value\
    \ will not be used repeatedly is to wait until the\n   encryption process receives\
    \ confirmation from the storage process\n   indicating that the succeeding nonce\
    \ value has already been stored.\n   Because this method may add significant latency,\
    \ it may be desirable\n   to store a nonce value that is several values ahead\
    \ in the sequence.\n   As an example, the nonce 100 could be stored, after which\
    \ the nonces\n   1 through 99 could be used for encryption.  The nonce value 200\
    \ could\n   be stored at the same time that nonces 1 through 99 are being used,\n\
    \   and so on.\n   Many problems with nonce reuse can be avoided by changing a\
    \ key in a\n   situation in which nonce coordination is difficult.\n   Each AEAD\
    \ algorithm SHOULD describe what security degradation would\n   result from an\
    \ inadvertent reuse of a nonce value.\n"
- title: 3.2.  Recommended Nonce Formation
  contents:
  - "3.2.  Recommended Nonce Formation\n   The following method to construct nonces\
    \ is RECOMMENDED.  The nonce\n   is formatted as illustrated in Figure 1, with\
    \ the initial octets\n   consisting of a Fixed field, and the final octets consisting\
    \ of a\n   Counter field.  For each fixed key, the length of each of these\n \
    \  fields, and thus the length of the nonce, is fixed.  Implementations\n   SHOULD\
    \ support 12-octet nonces in which the Counter field is four\n   octets long.\n\
    \       <----- variable ----> <----------- variable ----------->\n      +---------------------+----------------------------------+\n\
    \      |        Fixed        |              Counter             |\n      +---------------------+----------------------------------+\n\
    \                    Figure 1: Recommended nonce format\n   The Counter fields\
    \ of successive nonces form a monotonically\n   increasing sequence, when those\
    \ fields are regarded as unsigned\n   integers in network byte order.  The length\
    \ of the Counter field MUST\n   remain constant for all nonces that are generated\
    \ for a given\n   encryption device.  The Counter part SHOULD be equal to zero\
    \ for the\n   first nonce, and increment by one for each successive nonce that\
    \ is\n   generated.  However, any particular Counter value MAY be skipped\n  \
    \ over, and left out of the sequence of values that are used, if it is\n   convenient.\
    \  For example, an application could choose to skip the\n   initial Counter=0\
    \ value, and set the Counter field of the initial\n   nonce to 1.  Thus, at most\
    \ 2^(8*C) nonces can be generated when the\n   Counter field is C octets in length.\n\
    \   The Fixed field MUST remain constant for all nonces that are\n   generated\
    \ for a given encryption device.  If different devices are\n   performing encryption\
    \ with a single key, then each distinct device\n   MUST use a distinct Fixed field,\
    \ to ensure the uniqueness of the\n   nonces.  Thus, at most 2^(8*F) distinct\
    \ encrypters can share a key\n   when the Fixed field is F octets in length.\n"
- title: 3.2.1.  Partially Implicit Nonces
  contents:
  - "3.2.1.  Partially Implicit Nonces\n   In some cases, it is desirable to not transmit\
    \ or store an entire\n   nonce, but instead to reconstruct that value from contextual\n\
    \   information immediately prior to decryption.  As an example,\n   ciphertexts\
    \ could be stored in sequence on a disk, and the nonce for\n   a particular ciphertext\
    \ could be inferred from its location, as long\n   as the rule for generating\
    \ the nonces is known by the decrypter.  We\n   call the portion of the nonce\
    \ that is stored or sent with the\n   ciphertext the explicit part.  We call the\
    \ portion of the nonce that\n   is inferred the implicit part.  When part of the\
    \ nonce is implicit,\n   the following specialization of the above format is RECOMMENDED.\
    \  The\n   Fixed field is divided into two sub-fields: a Fixed-Common field and\n\
    \   a Fixed-Distinct field.  This format is shown in Figure 2.  If\n   different\
    \ devices are performing encryption with a single key, then\n   each distinct\
    \ device MUST use a distinct Fixed-Distinct field.  The\n   Fixed-Common field\
    \ is common to all nonces.  The Fixed-Distinct field\n   and the Counter field\
    \ MUST be in the explicit part of the nonce.  The\n   Fixed-Common field MAY be\
    \ in the implicit part of the nonce.  These\n   conventions ensure that the nonce\
    \ is easy to reconstruct from the\n   explicit data.\n      +-------------------+--------------------+---------------+\n\
    \      |    Fixed-Common   |   Fixed-Distinct   |    Counter    |\n      +-------------------+--------------------+---------------+\n\
    \       <---- implicit ---> <------------ explicit ------------>\n           \
    \      Figure 2: Partially implicit nonce format\n      The rationale for the\
    \ partially implicit nonce format is as\n      follows.  This method of nonce\
    \ construction incorporates the best\n      known practice; it is used by both\
    \ GCM Encapuslating Security\n      Payload (ESP) [RFC4106] and CCM ESP [RFC4309],\
    \ in which the Fixed\n      field contains the Salt value and the lowest eight\
    \ octets of the\n      nonce are explicitly carried in the ESP packet.  In GCM\
    \ ESP, the\n      Fixed field must be at least four octets long, so that it can\n\
    \      contain the Salt value.  In CCM ESP, the Fixed field must be at\n     \
    \ least three octets long for the same reason.  This nonce\n      generation method\
    \ is also used by several counter mode variants\n      including CTR ESP.\n"
- title: 3.3.  Construction of AEAD Inputs
  contents:
  - "3.3.  Construction of AEAD Inputs\n   If the AD input is constructed out of multiple\
    \ data elements, then it\n   is essential that it be unambiguously parseable into\
    \ its constituent\n   elements, without the use of any unauthenticated data in\
    \ the parsing\n   process.  (In mathematical terms, the AD input must be an injective\n\
    \   function of the data elements.)  If an application constructs its AD\n   input\
    \ in such a way that there are two distinct sets of data elements\n   that result\
    \ in the same AD value, then an attacker could cause a\n   receiver to accept\
    \ a bogus set by substituting one set for the other.\n   The requirement that\
    \ the AD be uniquely parseable ensures that this\n   attack is not possible. \
    \ This requirement is trivially met if the AD\n   is composed of fixed-width elements.\
    \  If the AD contains a variable-\n   length string, for example, this requirement\
    \ can be met by also\n   including the length of the string in the AD.\n   Similarly,\
    \ if the plaintext is constructed out of multiple data\n   elements, then it is\
    \ essential that it be unambiguously parseable\n   into its constituent elements,\
    \ without using any unauthenticated data\n   in the parsing process.  Note that\
    \ data included in the AD may be\n   used when parsing the plaintext, though of\
    \ course since the AD is not\n   encrypted there is a potential loss of confidentiality\
    \ when\n   information about the plaintext is included in the AD.\n"
- title: 3.4.  Example Usage
  contents:
  - "3.4.  Example Usage\n   To make use of an AEAD algorithm, an application must\
    \ define how the\n   encryption algorithm's inputs are defined in terms of application\n\
    \   data, and how the ciphertext and nonce are conveyed.  The clearest\n   way\
    \ to do this is to express each input in terms of the data that\n   form it, then\
    \ to express the application data in terms of the outputs\n   of the AEAD encryption\
    \ operation.\n   For example, AES-GCM ESP [RFC4106] can be expressed as follows.\
    \  The\n   AEAD inputs are\n      P = RestOfPayloadData || TFCpadding || Padding\
    \ || PadLength ||\n      NextHeader\n      N = Salt || IV\n      A = SPI || SequenceNumber\n\
    \   where the symbol \"||\" denotes the concatenation operation, and the\n   fields\
    \ RestOfPayloadData, TFCpadding, Padding, PadLength, NextHeader,\n   SPI, and\
    \ SequenceNumber are as defined in [RFC4303], and the fields\n   Salt and IV are\
    \ as defined in [RFC4106].  The field RestOfPayloadData\n   contains the plaintext\
    \ data that is described by the NextHeader\n   field, and no other data.  (Recall\
    \ that the PayloadData field\n   contains both the IV and the RestOfPayloadData;\
    \ see Figure 2 of\n   [RFC4303] for an illustration.)\n   The format of the ESP\
    \ packet can be expressed as\n      ESP = SPI || SequenceNumber || IV || C\n \
    \  where C is the AEAD ciphertext (which in this case incorporates the\n   authentication\
    \ tag).  Please note that here we have not described the\n   use of the ESP Extended\
    \ Sequence Number.\n"
- title: 4.  Requirements on AEAD Algorithm Specifications
  contents:
  - "4.  Requirements on AEAD Algorithm Specifications\n   Each AEAD algorithm MUST\
    \ only accept keys with a fixed key length\n   K_LEN, and MUST NOT require any\
    \ particular data format for the keys\n   provided as input.  An algorithm that\
    \ requires such structure (e.g.,\n   one with subkeys in a particular parity-check\
    \ format) will need to\n   provide it internally.\n   Each AEAD algorithm MUST\
    \ accept any plaintext with a length between\n   zero and P_MAX octets, inclusive,\
    \ where the value P_MAX is specific\n   to that algorithm.  The value of P_MAX\
    \ MUST be larger than zero, and\n   SHOULD be at least 65,536 (2^16) octets. \
    \ This size is a typical\n   upper limit for network data packets.  Other applications\
    \ may use\n   even larger values of P_MAX, so it is desirable for general-purpose\n\
    \   algorithms to support higher values.\n   Each AEAD algorithm MUST accept any\
    \ associated data with a length\n   between zero and A_MAX octets, inclusive,\
    \ where the value A_MAX is\n   specific to that algorithm.  The value of A_MAX\
    \ MUST be larger than\n   zero, and SHOULD be at least 65,536 (2^16) octets. \
    \ Other\n   applications may use even larger values of A_MAX, so it is desirable\n\
    \   for general-purpose algorithms to support higher values.\n   Each AEAD algorithm\
    \ MUST accept any nonce with a length between N_MIN\n   and N_MAX octets, inclusive,\
    \ where the values of N_MIN and N_MAX are\n   specific to that algorithm.  The\
    \ values of N_MAX and N_MIN MAY be\n   equal.  Each algorithm SHOULD accept a\
    \ nonce with a length of twelve\n   (12) octets.  Randomized or stateful algorithms,\
    \ which are described\n   below, MAY have an N_MAX value of zero.\n   An AEAD\
    \ algorithm MAY structure its ciphertext output in any way; for\n   example, the\
    \ ciphertext can incorporate an authentication tag.  Each\n   algorithm SHOULD\
    \ choose a structure that is amenable to efficient\n   processing.\n   An Authenticated\
    \ Encryption algorithm MAY incorporate or make use of\n   a random source, e.g.,\
    \ for the generation of an internal\n   initialization vector that is incorporated\
    \ into the ciphertext\n   output.  An AEAD algorithm of this sort is called randomized;\
    \ though\n   note that only encryption is random, and decryption is always\n \
    \  deterministic.  A randomized algorithm MAY have a value of N_MAX that\n   is\
    \ equal to zero.\n   An Authenticated Encryption algorithm MAY incorporate internal\
    \ state\n   information that is maintained between invocations of the encrypt\n\
    \   operation, e.g., to allow for the construction of distinct values\n   that\
    \ are used as internal nonces by the algorithm.  An AEAD algorithm\n   of this\
    \ sort is called stateful.  This method could be used by an\n   algorithm to provide\
    \ good security even when the application inputs\n   zero-length nonces.  A stateful\
    \ algorithm MAY have a value of N_MAX\n   that is equal to zero.\n   The specification\
    \ of an AEAD algorithm MUST include the values of\n   K_LEN, P_MAX, A_MAX, N_MIN,\
    \ and N_MAX defined above.  Additionally,\n   it MUST specify the number of octets\
    \ in the largest possible\n   ciphertext, which we denote C_MAX.\n   Each AEAD\
    \ algorithm MUST provide a description relating the length of\n   the plaintext\
    \ to that of the ciphertext.  This relation MUST NOT\n   depend on external parameters,\
    \ such as an authentication strength\n   parameter (e.g., authentication tag length).\
    \  That sort of dependence\n   would complicate the use of the algorithm by creating\
    \ a situation in\n   which the information from the AEAD registry was not sufficient\
    \ to\n   ensure interoperability.\n   EACH AEAD algorithm specification SHOULD\
    \ describe what security\n   degradation would result from an inadvertent reuse\
    \ of a nonce value.\n   Each AEAD algorithm specification SHOULD provide a reference\
    \ to a\n   detailed security analysis.  This document does not specify a\n   particular\
    \ security model, because several different models have been\n   used in the literature.\
    \  The security analysis SHOULD define or\n   reference a security model.\n  \
    \ An algorithm that is randomized or stateful, as defined above, SHOULD\n   describe\
    \ itself using those terms.\n"
- title: 5.  AEAD Algorithms
  contents:
  - "5.  AEAD Algorithms\n   This section defines four AEAD algorithms; two are based\
    \ on AES GCM,\n   two are based on AES CCM.  Each pair includes an algorithm with\
    \ a key\n   size of 128 bits and one with a key size of 256 bits.\n"
- title: 5.1.  AEAD_AES_128_GCM
  contents:
  - "5.1.  AEAD_AES_128_GCM\n   The AEAD_AES_128_GCM authenticated encryption algorithm\
    \ works as\n   specified in [GCM], using AES-128 as the block cipher, by providing\n\
    \   the key, nonce, and plaintext, and associated data to that mode of\n   operation.\
    \  An authentication tag with a length of 16 octets (128\n   bits) is used.  The\
    \ AEAD_AES_128_GCM ciphertext is formed by\n   appending the authentication tag\
    \ provided as an output to the GCM\n   encryption operation to the ciphertext\
    \ that is output by that\n   operation.  Test cases are provided in the appendix\
    \ of [GCM].  The\n   input and output lengths are as follows:\n      K_LEN is\
    \ 16 octets,\n      P_MAX is 2^36 - 31 octets,\n      A_MAX is 2^61 - 1 octets,\n\
    \      N_MIN and N_MAX are both 12 octets, and\n      C_MAX is 2^36 - 15 octets.\n\
    \   An AEAD_AES_128_GCM ciphertext is exactly 16 octets longer than its\n   corresponding\
    \ plaintext.\n   A security analysis of GCM is available in [MV04].\n"
- title: 5.1.1.  Nonce Reuse
  contents:
  - "5.1.1.  Nonce Reuse\n   The inadvertent reuse of the same nonce by two invocations\
    \ of the GCM\n   encryption operation, with the same key, but with distinct plaintext\n\
    \   values, undermines the confidentiality of the plaintexts protected in\n  \
    \ those two invocations, and undermines all of the authenticity and\n   integrity\
    \ protection provided by that key.  For this reason, GCM\n   should only be used\
    \ whenever nonce uniqueness can be provided with\n   assurance.  The design feature\
    \ that GCM uses to achieve minimal\n   latency causes the vulnerabilities on the\
    \ subsequent uses of the key.\n   Note that it is acceptable to input the same\
    \ nonce value multiple\n   times to the decryption operation.\n   The security\
    \ consequences are quite serious if an attacker observes\n   two ciphertexts that\
    \ were created using the same nonce and key\n   values, unless the plaintext and\
    \ AD values in both invocations of the\n   encrypt operation were identical. \
    \ First, a loss of confidentiality\n   ensues because he will be able to reconstruct\
    \ the bitwise\n   exclusive-or of the two plaintext values.  Second, a loss of\n\
    \   integrity ensues because the attacker will be able to recover the\n   internal\
    \ hash key used to provide data integrity.  Knowledge of this\n   key makes subsequent\
    \ forgeries trivial.\n"
- title: 5.2.  AEAD_AES_256_GCM
  contents:
  - "5.2.  AEAD_AES_256_GCM\n   This algorithm is identical to AEAD_AES_128_GCM, but\
    \ with the\n   following differences:\n      K_LEN is 32 octets, instead of 16\
    \ octets, and\n      AES-256 GCM is used instead of AES-128 GCM.\n"
- title: 5.3.  AEAD_AES_128_CCM
  contents:
  - "5.3.  AEAD_AES_128_CCM\n   The AEAD_AES_128_CCM authenticated encryption algorithm\
    \ works as\n   specified in [CCM], using AES-128 as the block cipher, by providing\n\
    \   the key, nonce, associated data, and plaintext to that mode of\n   operation.\
    \  The formatting and counter generation function are as\n   specified in Appendix\
    \ A of that reference, and the values of the\n   parameters identified in that\
    \ appendix are as follows:\n      the nonce length n is 12,\n      the tag length\
    \ t is 16, and\n      the value of q is 3.\n   An authentication tag with a length\
    \ of 16 octets (128 bits) is used.\n   The AEAD_AES_128_CCM ciphertext is formed\
    \ by appending the\n   authentication tag provided as an output to the CCM encryption\n\
    \   operation to the ciphertext that is output by that operation.  Test\n   cases\
    \ are provided in [CCM].  The input and output lengths are as\n   follows:\n \
    \     K_LEN is 16 octets,\n      P_MAX is 2^24 - 1 octets,\n      A_MAX is 2^64\
    \ - 1 octets,\n      N_MIN and N_MAX are both 12 octets, and\n      C_MAX is 2^24\
    \ + 15 octets.\n   An AEAD_AES_128_CCM ciphertext is exactly 16 octets longer\
    \ than its\n   corresponding plaintext.\n   A security analysis of AES CCM is\
    \ available in [J02].\n"
- title: 5.3.1.  Nonce Reuse
  contents:
  - "5.3.1.  Nonce Reuse\n   Inadvertent reuse of the same nonce by two invocations\
    \ of the CCM\n   encryption operation, with the same key, undermines the security\
    \ for\n   the messages processed with those invocations.  A loss of\n   confidentiality\
    \ ensues because an adversary will be able to\n   reconstruct the bitwise exclusive-or\
    \ of the two plaintext values.\n"
- title: 5.4.  AEAD_AES_256_CCM
  contents:
  - "5.4.  AEAD_AES_256_CCM\n   This algorithm is identical to AEAD_AES_128_CCM, but\
    \ with the\n   following differences:\n      K_LEN is 32 octets, instead of 16,\
    \ and\n      AES-256 CCM is used instead of AES-128 CCM.\n"
- title: 6.  IANA Considerations
  contents:
  - "6.  IANA Considerations\n   The Internet Assigned Numbers Authority (IANA) has\
    \ defined the \"AEAD\n   Registry\" described below.  An algorithm designer MAY\
    \ register an\n   algorithm in order to facilitate its use.  Additions to the\
    \ AEAD\n   Registry require that a specification be documented in an RFC or\n\
    \   another permanent and readily available reference, in sufficient\n   detail\
    \ that interoperability between independent implementations is\n   possible. \
    \ Each entry in the registry contains the following\n   elements:\n      a short\
    \ name, such as \"AEAD_AES_128_GCM\", that starts with the\n      string \"AEAD\"\
    ,\n      a positive number, and\n      a reference to a specification that completely\
    \ defines an AEAD\n      algorithm and provides test cases that can be used to\
    \ verify the\n      correctness of an implementation.\n   Requests to add an entry\
    \ to the registry MUST include the name and\n   the reference.  The number is\
    \ assigned by IANA.  These number\n   assignments SHOULD use the smallest available\
    \ positive number.\n   Submitters SHOULD have their requests reviewed by the IRTF\
    \ Crypto\n   Forum Research Group (CFRG) at cfrg@ietf.org.  Interested applicants\n\
    \   that are unfamiliar with IANA processes should visit\n   http://www.iana.org.\n\
    \   The numbers between 32,768 (binary 1000000000000000) and 65,535\n   (binary\
    \ 1111111111111111) inclusive, will not be assigned by IANA,\n   and are reserved\
    \ for private use; no attempt will be made to prevent\n   multiple sites from\
    \ using the same value in different (and\n   incompatible) ways [RFC2434].\n \
    \  IANA has added the following entries to the AEAD Registry:\n          +------------------+-------------+--------------------+\n\
    \          | Name             |  Reference  | Numeric Identifier |\n         \
    \ +------------------+-------------+--------------------+\n          | AEAD_AES_128_GCM\
    \ | Section 5.1 |          1         |\n          | AEAD_AES_256_GCM | Section\
    \ 5.2 |          2         |\n          | AEAD_AES_128_CCM | Section 5.3 |   \
    \       3         |\n          | AEAD_AES_256_CCM | Section 5.4 |          4 \
    \        |\n          +------------------+-------------+--------------------+\n\
    \   An IANA registration of an AEAD does not constitute an endorsement of\n  \
    \ that algorithm or its security.\n"
- title: 7.  Other Considerations
  contents:
  - "7.  Other Considerations\n   Directly testing a randomized AEAD encryption algorithm\
    \ using test\n   cases with fixed inputs and outputs is not possible, since the\n\
    \   encryption process is non-deterministic.  However, it is possible to\n   test\
    \ a randomized AEAD algorithm using the following technique.  The\n   authenticated\
    \ decryption algorithm is deterministic, and it can be\n   directly tested.  The\
    \ authenticated encryption algorithm can be\n   tested by encrypting a plaintext,\
    \ decrypting the resulting\n   ciphertext, and comparing the original plaintext\
    \ to the post-\n   decryption plaintext.  Combining both of these tests covers\
    \ both the\n   encryption and decryption algorithms.\n   The AEAD algorithms selected\
    \ reflect those that have been already\n   adopted by standards.  It is an open\
    \ question as to what other AEAD\n   algorithms should be added.  Many variations\
    \ on basic algorithms are\n   possible, each with its own advantages.  While it\
    \ is desirable to\n   admit any algorithms that are found to be useful in practice,\
    \ it is\n   also desirable to limit the total number of registered algorithms.\n\
    \   The current specification requires that a registered algorithm\n   provide\
    \ a complete specification and a set of validation data; it is\n   hoped that\
    \ these prerequisites set the admission criteria\n   appropriately.\n   It may\
    \ be desirable to define an AEAD algorithm that uses the generic\n   composition\
    \ with the encrypt-then-MAC method [BN00], combining a\n   common encryption algorithm,\
    \ such as CBC [MODES], with a common\n   message authentication code, such as\
    \ HMAC-SHA1 [RFC2104] or AES CMAC\n   [CMAC].  An AEAD algorithm of this sort\
    \ would reflect the best\n   current practice, and might be more easily supported\
    \ by crypto\n   modules that lack support for other AEAD algorithms.\n"
- title: 8.  Security Considerations
  contents:
  - "8.  Security Considerations\n   This document describes authenticated encryption\
    \ algorithms, and\n   provides guidance on their use.  While these algorithms\
    \ make it\n   easier, in some ways, to design a cryptographic application, it\n\
    \   should be borne in mind that strong cryptographic security is\n   difficult\
    \ to achieve.  While AEAD algorithms are quite useful, they\n   do nothing to\
    \ address the issues of key generation [RFC4086] and key\n   management [RFC4107].\n\
    \   AEAD algorithms that rely on distinct nonces may be inappropriate for\n  \
    \ some applications or for some scenarios.  Application designers\n   should understand\
    \ the requirements outlined in Section 3.1.\n   A software implementation of the\
    \ AEAD encryption operation in a\n   Virtual Machine (VM) environment could inadvertently\
    \ reuse a nonce\n   due to a \"rollback\" of the VM to an earlier state [GR05].\n\
    \   Applications are encouraged to document potential issues to help the\n   user\
    \ of the application and the VM avoid unintentional mistakes of\n   this sort.\
    \  The possibility exists that an attacker can cause a VM\n   rollback; threats\
    \ and mitigations in that scenario are an area of\n   active research.  For perspective,\
    \ we note that an attacker who can\n   trigger such a rollback may have already\
    \ succeeded in subverting the\n   security of the system, e.g., by causing an\
    \ accounting error.\n   An IANA registration of an AEAD algorithm MUST NOT be\
    \ regarded as an\n   endorsement of its security.  Furthermore, the perceived\
    \ security\n   level of an algorithm can degrade over time, due to cryptanalytic\n\
    \   advances or to \"Moore's Law\", that is, the diminishing cost of\n   computational\
    \ resources over time.\n"
- title: 9.  Acknowledgments
  contents:
  - "9.  Acknowledgments\n   Many reviewers provided valuable comments on earlier\
    \ drafts of this\n   document.  Some fruitful discussions took place on the email\
    \ list of\n   the Crypto Forum Research Group in 2006.\n"
- title: 10.  References
  contents:
  - '10.  References

    '
- title: 10.1.  Normative References
  contents:
  - "10.1.  Normative References\n   [CCM]      Dworkin, M., \"NIST Special Publication\
    \ 800-38C: The CCM\n              Mode for Authentication and Confidentiality\"\
    , U.S.\n              National Institute of Standards and Technology,\n      \
    \        <http://csrc.nist.gov/publications/nistpubs/800-38C/\n              SP800-38C.pdf>.\n\
    \   [GCM]      Dworkin, M., \"NIST Special Publication 800-38D:\n            \
    \  Recommendation for Block Cipher Modes of Operation:\n              Galois/Counter\
    \ Mode (GCM) and GMAC.\", U.S. National\n              Institute of Standards\
    \ and Technology, November 2007,\n              <http://csrc.nist.gov/publications/nistpubs/800-38D/\n\
    \              SP-800-38D.pdf>.\n   [RFC2119]  Bradner, S., \"Key words for use\
    \ in RFCs to Indicate\n              Requirement Levels\", BCP 14, RFC 2119, March\
    \ 1997.\n"
- title: 10.2.  Informative References
  contents:
  - "10.2.  Informative References\n   [BN00]     Bellare, M. and C. Namprempre, \"\
    Authenticated encryption:\n              Relations among notions and analysis\
    \ of the generic\n              composition paradigm\", Proceedings of ASIACRYPT\
    \ 2000,\n              Springer-Verlag, LNCS 1976, pp. 531-545, 2002.\n   [BOYD]\
    \     Boyd, C. and A. Mathuria, \"Protocols for Authentication\n             \
    \ and Key Establishment\", Springer 2003.\n   [CMAC]     \"NIST Special Publication\
    \ 800-38B\", <http://csrc.nist.gov/\n              publications/nistpubs/800-38B/SP_800-38B.pdf>.\n\
    \   [EEM04]    Bellare, M., Namprempre, C., and T. Kohno, \"Breaking and\n   \
    \           provably repairing the SSH authenticated encryption\n            \
    \  scheme: A case study of the Encode-then-Encrypt-and-MAC\n              paradigm\"\
    , ACM Transactions on Information and\n              System Security,\n      \
    \        <http://www-cse.ucsd.edu/users/tkohno/papers/TISSEC04/>.\n   [GR05] \
    \    Garfinkel, T. and M. Rosenblum, \"When Virtual is Harder\n              than\
    \ Real: Security Challenges in Virtual Machine Based\n              Computing\
    \ Environments\", Proceedings of the 10th Workshop\n              on Hot Topics\
    \ in Operating Systems,\n              <http://www.stanford.edu/~talg/papers/HOTOS05/\n\
    \              virtual-harder-hotos05.pdf>.\n   [J02]      Jonsson, J., \"On the\
    \ Security of CTR + CBC-MAC\",\n              Proceedings of the 9th Annual Workshop\
    \ on Selected Areas\n              on Cryptography, 2002, <http://csrc.nist.gov/groups/ST/\n\
    \              toolkit/BCM/documents/proposedmodes/ccm/ccm-ad1.pdf>.\n   [MODES]\
    \    Dworkin, M., \"NIST Special Publication 800-38:\n              Recommendation\
    \ for Block Cipher Modes of Operation\", U.S.\n              National Institute\
    \ of Standards and Technology,\n              <http://csrc.nist.gov/publications/nistpubs/800-38a/\n\
    \              sp800-38a.pdf>.\n   [MV04]     McGrew, D. and J. Viega, \"The Security\
    \ and Performance of\n              the Galois/Counter Mode (GCM)\", Proceedings\
    \ of\n              INDOCRYPT '04, December 2004,\n              <http://eprint.iacr.org/2004/193>.\n\
    \   [R02]      Rogaway, P., \"Authenticated encryption with Associated-\n    \
    \          Data\", ACM Conference on Computer and Communication\n            \
    \  Security (CCS'02), pp. 98-107, ACM Press, 2002,\n              <http://www.cs.ucdavis.edu/~rogaway/papers/ad.html>.\n\
    \   [RFC2104]  Krawczyk, H., Bellare, M., and R. Canetti, \"HMAC: Keyed-\n   \
    \           Hashing for Message Authentication\", RFC 2104,\n              February\
    \ 1997.\n   [RFC2434]  Narten, T. and H. Alvestrand, \"Guidelines for Writing\
    \ an\n              IANA Considerations Section in RFCs\", BCP 26, RFC 2434,\n\
    \              October 1998.\n   [RFC4086]  Eastlake, D., Schiller, J., and S.\
    \ Crocker, \"Randomness\n              Requirements for Security\", BCP 106, RFC\
    \ 4086, June 2005.\n   [RFC4106]  Viega, J. and D. McGrew, \"The Use of Galois/Counter\
    \ Mode\n              (GCM) in IPsec Encapsulating Security Payload (ESP)\",\n\
    \              RFC 4106, June 2005.\n   [RFC4107]  Bellovin, S. and R. Housley,\
    \ \"Guidelines for Cryptographic\n              Key Management\", BCP 107, RFC\
    \ 4107, June 2005.\n   [RFC4303]  Kent, S., \"IP Encapsulating Security Payload\
    \ (ESP)\",\n              RFC 4303, December 2005.\n   [RFC4309]  Housley, R.,\
    \ \"Using Advanced Encryption Standard (AES) CCM\n              Mode with IPsec\
    \ Encapsulating Security Payload (ESP)\",\n              RFC 4309, December 2005.\n"
- title: Author's Address
  contents:
  - "Author's Address\n   David A. McGrew\n   Cisco Systems, Inc.\n   510 McCarthy\
    \ Blvd.\n   Milpitas, CA  95035\n   US\n   Phone: (408) 525 8651\n   EMail: mcgrew@cisco.com\n\
    \   URI:   http://www.mindspring.com/~dmcgrew/dam.htm\n"
- title: Full Copyright Statement
  contents:
  - "Full Copyright Statement\n   Copyright (C) The IETF Trust (2008).\n   This document\
    \ is subject to the rights, licenses and restrictions\n   contained in BCP 78,\
    \ and except as set forth therein, the authors\n   retain all their rights.\n\
    \   This document and the information contained herein are provided on an\n  \
    \ \"AS IS\" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS\n  \
    \ OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY, THE IETF TRUST AND\n   THE\
    \ INTERNET ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS\n   OR IMPLIED,\
    \ INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF\n   THE INFORMATION\
    \ HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED\n   WARRANTIES OF MERCHANTABILITY\
    \ OR FITNESS FOR A PARTICULAR PURPOSE.\n"
- title: Intellectual Property
  contents:
  - "Intellectual Property\n   The IETF takes no position regarding the validity or\
    \ scope of any\n   Intellectual Property Rights or other rights that might be\
    \ claimed to\n   pertain to the implementation or use of the technology described\
    \ in\n   this document or the extent to which any license under such rights\n\
    \   might or might not be available; nor does it represent that it has\n   made\
    \ any independent effort to identify any such rights.  Information\n   on the\
    \ procedures with respect to rights in RFC documents can be\n   found in BCP 78\
    \ and BCP 79.\n   Copies of IPR disclosures made to the IETF Secretariat and any\n\
    \   assurances of licenses to be made available, or the result of an\n   attempt\
    \ made to obtain a general license or permission for the use of\n   such proprietary\
    \ rights by implementers or users of this\n   specification can be obtained from\
    \ the IETF on-line IPR repository at\n   http://www.ietf.org/ipr.\n   The IETF\
    \ invites any interested party to bring to its attention any\n   copyrights, patents\
    \ or patent applications, or other proprietary\n   rights that may cover technology\
    \ that may be required to implement\n   this standard.  Please address the information\
    \ to the IETF at\n   ietf-ipr@ietf.org.\n"
