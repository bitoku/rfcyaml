- title: __initial_text__
  contents:
  - ''
- title: Independent Submission                                   F. Templin, Ed.
  contents:
  - "Independent Submission                                   F. Templin, Ed.\n  \
    \      The Subnetwork Encapsulation and Adaptation Layer (SEAL)\n"
- title: Abstract
  contents:
  - "Abstract\n   For the purpose of this document, subnetworks are defined as virtual\n\
    \   topologies that span connected network regions bounded by\n   encapsulating\
    \ border nodes.  These virtual topologies may span\n   multiple IP and/or sub-IP\
    \ layer forwarding hops, and can introduce\n   failure modes due to packet duplication\
    \ and/or links with diverse\n   Maximum Transmission Units (MTUs).  This document\
    \ specifies a\n   Subnetwork Encapsulation and Adaptation Layer (SEAL) that\n\
    \   accommodates such virtual topologies over diverse underlying link\n   technologies.\n"
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This document is not an Internet Standards Track specification;\
    \ it is\n   published for examination, experimental implementation, and\n   evaluation.\n\
    \   This document defines an Experimental Protocol for the Internet\n   community.\
    \  This is a contribution to the RFC Series, independently\n   of any other RFC\
    \ stream.  The RFC Editor has chosen to publish this\n   document at its discretion\
    \ and makes no statement about its value for\n   implementation or deployment.\
    \  Documents approved for publication by\n   the RFC Editor are not a candidate\
    \ for any level of Internet\n   Standard; see Section 2 of RFC 5741.\n   Information\
    \ about the current status of this document, any errata,\n   and how to provide\
    \ feedback on it may be obtained at\n   http://www.rfc-editor.org/info/rfc5320.\n"
- title: IESG Note
  contents:
  - "IESG Note\n   This RFC is not a candidate for any level of Internet Standard.\
    \  The\n   IETF disclaims any knowledge of the fitness of this RFC for any\n \
    \  purpose and in particular notes that the decision to publish is not\n   based\
    \ on IETF review for such things as security, congestion control,\n   or inappropriate\
    \ interaction with deployed protocols.  The RFC Editor\n   has chosen to publish\
    \ this document at its discretion.  Readers of\n   this document should exercise\
    \ caution in evaluating its value for\n   implementation and deployment.  See\
    \ RFC 3932 for more information.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (c) 2010 IETF Trust and the persons identified\
    \ as the\n   document authors.  All rights reserved.\n   This document is subject\
    \ to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n\
    \   (http://trustee.ietf.org/license-info) in effect on the date of\n   publication\
    \ of this document.  Please review these documents\n   carefully, as they describe\
    \ your rights and restrictions with respect\n   to this document.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1. Introduction ....................................................4\n\
    \      1.1. Motivation .................................................4\n  \
    \    1.2. Approach ...................................................6\n   2.\
    \ Terminology and Requirements ....................................6\n   3. Applicability\
    \ Statement .........................................7\n   4. SEAL Protocol Specification\
    \ - Tunnel Mode .......................8\n      4.1. Model of Operation .........................................8\n\
    \      4.2. ITE Specification .........................................10\n  \
    \         4.2.1. Tunnel Interface MTU ...............................10\n    \
    \       4.2.2. Accounting for Headers .............................11\n      \
    \     4.2.3. Segmentation and Encapsulation .....................12\n        \
    \   4.2.4. Sending Probes .....................................14\n          \
    \ 4.2.5. Packet Identification ..............................15\n           4.2.6.\
    \ Sending SEAL Protocol Packets ......................15\n           4.2.7. Processing\
    \ Raw ICMPv4 Messages .....................15\n           4.2.8. Processing SEAL-Encapsulated\
    \ ICMPv4 Messages .......16\n      4.3. ETE Specification .........................................17\n\
    \           4.3.1. Reassembly Buffer Requirements .....................17\n  \
    \         4.3.2. IPv4-Layer Reassembly ..............................17\n    \
    \       4.3.3. Generating SEAL-Encapsulated ICMPv4\n                  Fragmentation\
    \ Needed Messages ......................18\n           4.3.4. SEAL-Layer Reassembly\
    \ ..............................19\n           4.3.5. Delivering Packets to Upper\
    \ Layers .................20\n   5. SEAL Protocol Specification - Transport Mode\
    \ ...................20\n   6. Link Requirements ..............................................21\n\
    \   7. End System Requirements ........................................21\n  \
    \ 8. Router Requirements ............................................21\n   9.\
    \ IANA Considerations ............................................21\n   10. Security\
    \ Considerations .......................................21\n   11. Related Work\
    \ ..................................................22\n   12. SEAL Advantages\
    \ over Classical Methods ........................22\n   13. Acknowledgments ...............................................24\n\
    \   14. References ....................................................24\n  \
    \    14.1. Normative References .....................................24\n    \
    \  14.2. Informative References ...................................24\n   Appendix\
    \ A. Historic Evolution of PMTUD ...........................27\n   Appendix B.\
    \ Reliability Extensions ................................29\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   As Internet technology and communication has grown and matured,\
    \ many\n   techniques have developed that use virtual topologies (including\n\
    \   tunnels of one form or another) over an actual network that supports\n   the\
    \ Internet Protocol (IP) [RFC0791][RFC2460].  Those virtual\n   topologies have\
    \ elements that appear as one hop in the virtual\n   topology, but are actually\
    \ multiple IP or sub-IP layer hops.  These\n   multiple hops often have quite\
    \ diverse properties that are often not\n   even visible to the endpoints of the\
    \ virtual hop.  This introduces\n   failure modes that are not dealt with well\
    \ in current approaches.\n   The use of IP encapsulation has long been considered\
    \ as the means for\n   creating such virtual topologies.  However, the insertion\
    \ of an outer\n   IP header reduces the effective path MTU as-seen by the IP layer.\n\
    \   When IPv4 is used, this reduced MTU can be accommodated through the\n   use\
    \ of IPv4 fragmentation, but unmitigated in-the-network\n   fragmentation has\
    \ been found to be harmful through operational\n   experience and studies conducted\
    \ over the course of many years\n   [FRAG][FOLK][RFC4963].  Additionally, classical\
    \ path MTU discovery\n   [RFC1191] has known operational issues that are exacerbated\
    \ by in-\n   the-network tunnels [RFC2923][RFC4459].  In the following\n   subsections,\
    \ we present further details on the motivation and\n   approach for addressing\
    \ these issues.\n"
- title: 1.1.  Motivation
  contents:
  - "1.1.  Motivation\n   Before discussing the approach, it is necessary to first\
    \ understand\n   the problems.  In both the Internet and private-use networks\
    \ today,\n   IPv4 is ubiquitously deployed as the Layer 3 protocol.  The two\n\
    \   primary functions of IPv4 are to provide for 1) addressing, and 2) a\n   fragmentation\
    \ and reassembly capability used to accommodate links\n   with diverse MTUs. \
    \ While it is well known that the addressing\n   properties of IPv4 are limited\
    \ (hence, the larger address space\n   provided by IPv6), there is a lesser-known\
    \ but growing consensus that\n   other limitations may be unable to sustain continued\
    \ growth.\n   First, the IPv4 header Identification field is only 16 bits in\n\
    \   length, meaning that at most 2^16 packets pertaining to the same\n   (source,\
    \ destination, protocol, Identification)-tuple may be active\n   in the Internet\
    \ at a given time.  Due to the escalating deployment of\n   high-speed links (e.g.,\
    \ 1Gbps Ethernet), however, this number may\n   soon become too small by several\
    \ orders of magnitude.  Furthermore,\n   there are many well-known limitations\
    \ pertaining to IPv4\n   fragmentation and reassembly -- even to the point that\
    \ it has been\n   deemed \"harmful\" in both classic and modern-day studies (cited\n\
    \   above).  In particular, IPv4 fragmentation raises issues ranging from\n  \
    \ minor annoyances (e.g., slow-path processing in routers) to the\n   potential\
    \ for major integrity issues (e.g., mis-association of the\n   fragments of multiple\
    \ IP packets during reassembly).\n   As a result of these perceived limitations,\
    \ a fragmentation-avoiding\n   technique for discovering the MTU of the forward\
    \ path from a source\n   to a destination node was devised through the deliberations\
    \ of the\n   Path MTU Discovery Working Group (PMTUDWG) during the late 1980's\n\
    \   through early 1990's (see Appendix A).  In this method, the source\n   node\
    \ provides explicit instructions to routers in the path to discard\n   the packet\
    \ and return an ICMP error message if an MTU restriction is\n   encountered. \
    \ However, this approach has several serious shortcomings\n   that lead to an\
    \ overall \"brittleness\".\n   In particular, site border routers in the Internet\
    \ are being\n   configured more and more to discard ICMP error messages coming\
    \ from\n   the outside world.  This is due in large part to the fact that\n  \
    \ malicious spoofing of error messages in the Internet is made simple\n   since\
    \ there is no way to authenticate the source of the messages.\n   Furthermore,\
    \ when a source node that requires ICMP error message\n   feedback when a packet\
    \ is dropped due to an MTU restriction does not\n   receive the messages, a path\
    \ MTU-related black hole occurs.  This\n   means that the source will continue\
    \ to send packets that are too\n   large and never receive an indication from\
    \ the network that they are\n   being discarded.\n   The issues with both IPv4\
    \ fragmentation and this \"classical\" method\n   of path MTU discovery are exacerbated\
    \ further when IP-in-IP tunneling\n   is used.  For example, site border routers\
    \ that are configured as\n   ingress tunnel endpoints may be required to forward\
    \ packets into the\n   subnetwork on behalf of hundreds, thousands, or even more\
    \ original\n   sources located within the site.  If IPv4 fragmentation were used,\n\
    \   this would quickly wrap the 16-bit Identification field and could\n   lead\
    \ to undetected data corruption.  If classical IPv4 path MTU\n   discovery were\
    \ used instead, the site border router may be bombarded\n   by ICMP error messages\
    \ coming from the subnetwork that may be either\n   untrustworthy or insufficiently\
    \ provisioned to allow translation into\n   error message to be returned to the\
    \ original sources.\n   The situation is exacerbated further still by IPsec tunnels,\
    \ since\n   only the first IPv4 fragment of a fragmented packet contains the\n\
    \   transport protocol selectors (e.g., the source and destination ports)\n  \
    \ required for identifying the correct security association rendering\n   fragmentation\
    \ useless under certain circumstances.  Even worse, there\n   may be no way for\
    \ a site border router that configures an IPsec\n   tunnel to transcribe the encrypted\
    \ packet fragment contained in an\n   ICMP error message into a suitable ICMP\
    \ error message to return to\n   the original source.  Due to these many limitations,\
    \ a new approach\n   to accommodate links with diverse MTUs is necessary.\n"
- title: 1.2.  Approach
  contents:
  - "1.2.  Approach\n   For the purpose of this document, subnetworks are defined\
    \ as virtual\n   topologies that span connected network regions bounded by\n \
    \  encapsulating border nodes.  Examples include the global Internet\n   interdomain\
    \ routing core, Mobile Ad hoc Networks (MANETs) and\n   enterprise networks. \
    \ Subnetwork border nodes forward unicast and\n   multicast IP packets over the\
    \ virtual topology across multiple IP\n   and/or sub-IP layer forwarding hops\
    \ that may introduce packet\n   duplication and/or traverse links with diverse\
    \ Maximum Transmission\n   Units (MTUs).\n   This document introduces a Subnetwork\
    \ Encapsulation and Adaptation\n   Layer (SEAL) for tunnel-mode operation of IP\
    \ over subnetworks that\n   connect Ingress and Egress Tunnel Endpoints (ITEs/ETEs)\
    \ of border\n   nodes.  Operation in transport mode is also supported when subnetwork\n\
    \   border node upper-layer protocols negotiate the use of SEAL during\n   connection\
    \ establishment.  SEAL accommodates links with diverse MTUs\n   and supports efficient\
    \ duplicate packet detection by introducing a\n   minimal mid-layer encapsulation.\n\
    \   The SEAL encapsulation introduces an extended Identification field\n   for\
    \ packet identification and a mid-layer segmentation and reassembly\n   capability\
    \ that allows simplified cutting and pasting of packets.\n   Moreover, SEAL senses\
    \ in-the-network IPv4 fragmentation as a \"noise\"\n   indication that packet\
    \ sizing parameters are \"out of tune\" with\n   respect to the network path.\
    \  As a result, SEAL can naturally tune\n   its packet sizing parameters to eliminate\
    \ the in-the-network\n   fragmentation.\n   The SEAL encapsulation layer and protocol\
    \ are specified in the\n   following sections.\n"
- title: 2.  Terminology and Requirements
  contents:
  - "2.  Terminology and Requirements\n   The terms \"inner\", \"mid-layer\", and\
    \ \"outer\", respectively, refer to\n   the innermost IP (layer, protocol, header,\
    \ packet, etc.) before any\n   encapsulation, the mid-layer IP (protocol, header,\
    \ packet, etc.)\n   after any mid-layer '*' encapsulation, and the outermost IP\
    \ (layer,\n   protocol, header, packet etc.) after SEAL/*/IPv4 encapsulation.\n\
    \   The term \"IP\" used throughout the document refers to either Internet\n \
    \  Protocol version (IPv4 or IPv6).  Additionally, the notation\n   IPvX/*/SEAL/*/IPvY\
    \ refers to an inner IPvX packet encapsulated in any\n   mid-layer '*' encapsulations,\
    \ followed by the SEAL header, followed\n   by any outer '*' encapsulations, followed\
    \ by an outer IPvY header,\n   where the notation \"IPvX\" means either IP protocol\
    \ version (IPv4 or\n   IPv6).\n   The following abbreviations correspond to terms\
    \ used within this\n   document and elsewhere in common Internetworking nomenclature:\n\
    \      ITE - Ingress Tunnel Endpoint\n      ETE - Egress Tunnel Endpoint\n   \
    \   PTB - an ICMPv6 \"Packet Too Big\" or an ICMPv4 \"Fragmentation\n        \
    \    Needed\" message\n      DF - the IPv4 header \"Don't Fragment\" flag\n  \
    \    MHLEN - the length of any mid-layer '*' headers and trailers\n      OHLEN\
    \ - the length of the outer encapsulating SEAL/*/IPv4 headers\n      HLEN - the\
    \ sum of MHLEN and OHLEN\n      S_MRU - the per-ETE SEAL Maximum Reassembly Unit\n\
    \      S_MSS - the SEAL Maximum Segment Size\n      SEAL_ID - a 32-bit Identification\
    \ value, randomly initialized and\n                monotonically incremented for\
    \ each SEAL protocol packet\n      SEAL_PROTO - an IPv4 protocol number used for\
    \ SEAL\n      SEAL_PORT - a TCP/UDP service port number used for SEAL\n      SEAL_OPTION\
    \ - a TCP option number used for (transport-mode) SEAL\n   The key words MUST,\
    \ MUST NOT, REQUIRED, SHALL, SHALL NOT, SHOULD,\n   SHOULD NOT, RECOMMENDED, MAY,\
    \ and OPTIONAL, when they appear in this\n   document, are to be interpreted as\
    \ described in [RFC2119].\n"
- title: 3.  Applicability Statement
  contents:
  - "3.  Applicability Statement\n   SEAL was motivated by the specific case of subnetwork\
    \ abstraction for\n   Mobile Ad hoc Networks (MANETs); however, the domain of\
    \ applicability\n   also extends to subnetwork abstractions of enterprise networks,\
    \ the\n   interdomain routing core, etc.  The domain of application therefore\n\
    \   also includes the map-and-encaps architecture proposals in the IRTF\n   Routing\
    \ Research Group (RRG) (see http://www3.tools.ietf.org/group/\n   irtf/trac/wiki/RoutingResearchGroup).\n\
    \   SEAL introduces a minimal new sublayer for IPvX in IPvY encapsulation\n  \
    \ (e.g., as IPv6/SEAL/IPv4), and appears as a subnetwork encapsulation\n   as\
    \ seen by the inner IP layer.  SEAL can also be used as a sublayer\n   for encapsulating\
    \ inner IP packets within outer UDP/IPv4 headers\n   (e.g., as IPv6/SEAL/UDP/IPv4)\
    \ such as for the Teredo domain of\n   applicability [RFC4380].  When it appears\
    \ immediately after the outer\n   IPv4 header, the SEAL header is processed exactly\
    \ as for IPv6\n   extension headers.\n   SEAL can also be used in \"transport-mode\"\
    , e.g., when the inner layer\n   includes upper-layer protocol data rather than\
    \ an encapsulated IP\n   packet.  For instance, TCP peers can negotiate the use\
    \ of SEAL for\n   the carriage of protocol data encapsulated as TCP/SEAL/IPv4.\
    \  In this\n   sense, the \"subnetwork\" becomes the entire end-to-end path between\n\
    \   the TCP peers and may potentially span the entire Internet.\n   The current\
    \ document version is specific to the use of IPv4 as the\n   outer encapsulation\
    \ layer; however, the same principles apply when\n   IPv6 is used as the outer\
    \ layer.\n"
- title: 4.  SEAL Protocol Specification - Tunnel Mode
  contents:
  - '4.  SEAL Protocol Specification - Tunnel Mode

    '
- title: 4.1.  Model of Operation
  contents:
  - "4.1.  Model of Operation\n   SEAL supports the encapsulation of inner IP packets\
    \ in mid-layer and\n   outer encapsulating headers/trailers.  For example, an\
    \ inner IPv6\n   packet would appear as IPv6/*/SEAL/*/IPv4 after mid-layer and\
    \ outer\n   encapsulations, where '*' denotes zero or more additional\n   encapsulation\
    \ sublayers.  Ingres Tunnel Endpoints (ITEs) add mid-\n   layer inject into a\
    \ subnetwork, where the outermost IPv4 header\n   contains the source and destination\
    \ addresses of the subnetwork\n   entry/exit points (i.e., the ITE/ETE), respectively.\
    \  SEAL uses a new\n   Internet Protocol type and a new encapsulation sublayer\
    \ for both\n   unicast and multicast.  The ITE encapsulates an inner IP packet\
    \ in\n   mid-layer and outer encapsulations as shown in Figure 1:\n          \
    \                                  +-------------------------+\n             \
    \                               |                         |\n                \
    \                            ~   Outer */IPv4 headers  ~\n                   \
    \                         |                         |\n   I                  \
    \                      +-------------------------+\n   n                     \
    \                   |       SEAL Header       |\n   n      +-------------------------+\
    \       +-------------------------+\n   e      ~ Any mid-layer * headers ~   \
    \    ~ Any mid-layer * headers ~\n   r      +-------------------------+      \
    \ +-------------------------+\n          |                         |       | \
    \                        |\n   I -->  ~         Inner IP        ~  -->  ~    \
    \     Inner IP        ~\n   P -->  ~         Packet          ~  -->  ~       \
    \  Packet          ~\n          |                         |       |          \
    \               |\n   P      +-------------------------+       +-------------------------+\n\
    \   a      ~  Any mid-layer trailers ~       ~  Any mid-layer trailers ~\n   c\
    \      +-------------------------+       +-------------------------+\n   k   \
    \                                     ~    Any outer trailers   ~\n   e      \
    \                                  +-------------------------+\n   t\n       \
    \    (After mid-layer encaps.)        (After SEAL/*/IPv4 encaps.)\n          \
    \             Figure 1: SEAL Encapsulation\n   where the SEAL header is inserted\
    \ as follows:\n   o  For simple IPvX/IPv4 encapsulations (e.g.,\n      [RFC2003][RFC2004][RFC4213]),\
    \ the SEAL header is inserted between\n      the inner IP and outer IPv4 headers\
    \ as: IPvX/SEAL/IPv4.\n   o  For tunnel-mode IPsec encapsulations over IPv4, [RFC4301],\
    \ the\n      SEAL header is inserted between the {AH,ESP} header and outer IPv4\n\
    \      headers as: IPvX/*/{AH,ESP}/SEAL/IPv4.\n   o  For IP encapsulations over\
    \ transports such as UDP, the SEAL header\n      is inserted immediately after\
    \ the outer transport layer header,\n      e.g., as IPvX/*/SEAL/UDP/IPv4.\n  \
    \ SEAL-encapsulated packets include a 32-bit SEAL_ID formed from the\n   concatenation\
    \ of the 16-bit ID Extension field in the SEAL header as\n   the most-significant\
    \ bits, and with the 16-bit Identification value\n   in the outer IPv4 header\
    \ as the least-significant bits.  (For tunnels\n   that traverse IPv4 Network\
    \ Address Translators, the SEAL_ID is\n   instead maintained only within the 16-bit\
    \ ID Extension field in the\n   SEAL header.)  Routers within the subnetwork use\
    \ the SEAL_ID for\n   duplicate packet detection, and ITEs/ETEs use the SEAL_ID\
    \ for SEAL\n   segmentation and reassembly.\n   SEAL enables a multi-level segmentation\
    \ and reassembly capability.\n   First, the ITE can use IPv4 fragmentation to\
    \ fragment inner IPv4\n   packets with DF=0 before SEAL encapsulation to avoid\
    \ lower-layer\n   segmentation and reassembly.  Secondly, the SEAL layer itself\n\
    \   provides a simple cutting-and-pasting capability for mid-layer\n   packets\
    \ to avoid IPv4 fragmentation on the outer packet.  Finally,\n   ordinary IPv4\
    \ fragmentation is permitted on the outer packet after\n   SEAL encapsulation\
    \ and used to detect and dampen any in-the-network\n   fragmentation as quickly\
    \ as possible.\n   The following sections specify the SEAL-related operations\
    \ of the ITE\n   and ETE, respectively:\n"
- title: 4.2.  ITE Specification
  contents:
  - '4.2.  ITE Specification

    '
- title: 4.2.1.  Tunnel Interface MTU
  contents:
  - "4.2.1.  Tunnel Interface MTU\n   The ITE configures a tunnel virtual interface\
    \ over one or more\n   underlying links that connect the border node to the subnetwork.\
    \  The\n   tunnel interface must present a fixed MTU to the inner IP layer\n \
    \  (i.e., Layer 3) as the size for admission of inner IP packets into\n   the\
    \ tunnel.  Since the tunnel interface may support a potentially\n   large set\
    \ of ETEs, however, care must be taken in setting a greatest-\n   common-denominator\
    \ MTU for all ETEs while still upholding end system\n   expectations.\n   Due\
    \ to the ubiquitous deployment of standard Ethernet and similar\n   networking\
    \ gear, the nominal Internet cell size has become 1500\n   bytes; this is the\
    \ de facto size that end systems have come to expect\n   will either be delivered\
    \ by the network without loss due to an MTU\n   restriction on the path or a suitable\
    \ PTB message returned.  However,\n   the network may not always deliver the necessary\
    \ PTBs, leading to\n   MTU-related black holes [RFC2923].  The ITE therefore requires\
    \ a\n   means for conveying 1500 byte (or smaller) packets to the ETE without\n\
    \   loss due to MTU restrictions and without dependence on PTB messages\n   from\
    \ within the subnetwork.\n   In common deployments, there may be many forwarding\
    \ hops between the\n   original source and the ITE.  Within those hops, there\
    \ may be\n   additional encapsulations (IPSec, L2TP, etc.) such that a 1500 byte\n\
    \   packet sent by the original source might grow to a larger size by the\n  \
    \ time it reaches the ITE for encapsulation as an inner IP packet.\n   Similarly,\
    \ additional encapsulations on the path from the ITE to the\n   ETE could cause\
    \ the encapsulated packet to become larger still and\n   trigger in-the-network\
    \ fragmentation.  In order to preserve the end\n   system expectations, the ITE\
    \ therefore requires a means for conveying\n   these larger packets to the ETE\
    \ even though there may be links within\n   the subnetwork that configure a smaller\
    \ MTU.\n   The ITE should therefore set a tunnel virtual interface MTU of 1500\n\
    \   bytes plus extra room to accommodate any additional encapsulations\n   that\
    \ may occur on the path from the original source (i.e., even if\n   the path to\
    \ the ETE does not support an MTU of this size).  The ITE\n   can set larger MTU\
    \ values still, but should select a value that is\n   not so large as to cause\
    \ excessive PTBs coming from within the tunnel\n   interface (see Sections 4.2.2\
    \ and 4.2.6).  The ITE can also set\n   smaller MTU values; however, care must\
    \ be taken not to set so small a\n   value that original sources would experience\
    \ an MTU underflow.  In\n   particular, IPv6 sources must see a minimum path MTU\
    \ of 1280 bytes,\n   and IPv4 sources should see a minimum path MTU of 576 bytes.\n\
    \   The inner IP layer consults the tunnel interface MTU when admitting a\n  \
    \ packet into the interface.  For inner IPv4 packets larger than the\n   tunnel\
    \ interface MTU and with the IPv4 Don't Fragment (DF) bit set to\n   0, the inner\
    \ IPv4 layer uses IPv4 fragmentation to break the packet\n   into fragments no\
    \ larger than the tunnel interface MTU (but, see also\n   Section 4.2.3), then\
    \ admits each fragment into the tunnel as an\n   independent packet.  For all\
    \ other inner packets (IPv4 or IPv6), the\n   ITE admits the packet if it is no\
    \ larger than the tunnel interface\n   MTU; otherwise, it drops the packet and\
    \ sends an ICMP PTB message\n   with an MTU value of the tunnel interface MTU\
    \ to the source.\n"
- title: 4.2.2.  Accounting for Headers
  contents:
  - "4.2.2.  Accounting for Headers\n   As for any transport layer protocol, ITEs\
    \ use the MTU of the\n   underlying IPv4 interface, the length of any mid-layer\
    \ '*' headers\n   and trailers, and the length of the outer SEAL/*/IPv4 headers\
    \ to\n   determine the maximum size for a SEAL segment (see Section 4.2.3).\n\
    \   For example, when the underlying IPv4 interface advertises an MTU of\n   1500\
    \ bytes and the ITE inserts a minimum-length (i.e., 20-byte) IPv4\n   header,\
    \ the ITE sees a maximum segment size of 1480 bytes.  When the\n   ITE inserts\
    \ IPv4 header options, the size is further reduced by as\n   many as 40 additional\
    \ bytes (the maximum length for IPv4 options)\n   such that as few as 1440 bytes\
    \ may be available for the upper-layer\n   payload.  When the ITE inserts additional\
    \ '*' encapsulations, the\n   maximum segment size is reduced further still.\n\
    \   The ITE must additionally account for the length of the SEAL header\n   itself\
    \ as an extra encapsulation that further reduces the maximum\n   segment size.\
    \  The length of the SEAL header is not incorporated in\n   the IPv4 header length;\
    \ therefore, the network does not observe the\n   SEAL header as an IPv4 option.\
    \  In this way, the SEAL header is\n   inserted after the IPv4 options but before\
    \ the upper-layer payload in\n   exactly the same manner as for IPv6 extension\
    \ headers.\n"
- title: 4.2.3.  Segmentation and Encapsulation
  contents:
  - "4.2.3.  Segmentation and Encapsulation\n   For each ETE, the ITE maintains the\
    \ length of any mid-layer '*'\n   encapsulation headers and trailers (e.g., for\
    \ '*' = AH, ESP, NULL,\n   etc.) in a variable 'MHLEN' and maintains the length\
    \ of the outer\n   SEAL/*/IPv4 encapsulation headers in a variable 'OHLEN'.  The\
    \ ITE\n   further maintains a variable 'HLEN' set to MHLEN plus OHLEN.  The ITE\n\
    \   maintains a SEAL Maximum Reassembly Unit (S_MRU) value for each ETE\n   as\
    \ soft state within the tunnel interface (e.g., in the IPv4\n   destination cache).\
    \  The ITE initializes S_MRU to a value no larger\n   than 2KB and uses this value\
    \ to determine the maximum-sized packet it\n   will require the ETE to reassemble.\
    \  The ITE additionally maintains a\n   SEAL Maximum Segment Size (S_MSS) value\
    \ for each ETE.  The ITE\n   initializes S_MSS to the maximum of (the underlying\
    \ IPv4 interface\n   MTU minus OHLEN) and S_MRU/8 bytes, and decreases or increases\
    \ S_MSS\n   based on any ICMPv4 Fragmentation Needed messages received (see\n\
    \   Section 4.2.6).\n   The ITE performs segmentation and encapsulation on inner\
    \ packets that\n   have been admitted into the tunnel interface.  For inner IPv4\
    \ packets\n   with the DF bit set to 0, if the length of the inner packet is larger\n\
    \   than (S_MRU - HLEN), the ITE uses IPv4 fragmentation to break the\n   packet\
    \ into IPv4 fragments no larger than (S_MRU - HLEN).  For\n   unfragmentable inner\
    \ packets (e.g., IPv6 packets, IPv4 packets with\n   DF=1, etc.), if the length\
    \ of the inner packet is larger than\n   (MAX(S_MRU, S_MSS) - HLEN), the ITE drops\
    \ the packet and sends an\n   ICMP PTB message with an MTU value of (MAX(S_MRU,\
    \ S_MSS) - HLEN) back\n   to the original source.\n   The ITE then encapsulates\
    \ each inner packet/fragment in the MHLEN\n   bytes of mid-layer '*' headers and\
    \ trailers.  For each such resulting\n   mid-layer packet of length 'M', if (S_MRU\
    \ >= (M + OHLEN) > S_MSS),\n   the ITE must perform SEAL segmentation.  To do\
    \ so, it breaks the mid-\n   layer packet into N segments (N <= 8) that are no\
    \ larger than\n   (MIN(1KB, S_MSS) - OHLEN) bytes each.  Each segment, except\
    \ the final\n   one, MUST be of equal length, while the final segment MUST be\
    \ no\n   larger than the initial segment.  The first byte of each segment MUST\n\
    \   begin immediately after the final byte of the previous segment, i.e.,\n  \
    \ the segments MUST NOT overlap.  The ITE should generate the smallest\n   number\
    \ of segments possible, e.g., it should not generate 6 smaller\n   segments when\
    \ the packet could be accommodated with 4 larger\n   segments.\n   Note that this\
    \ SEAL segmentation ignores the fact that the mid-layer\n   packet may be unfragmentable.\
    \  This segmentation process is a mid-\n   layer (not an IP layer) operation employed\
    \ by the ITE to adapt the\n   mid-layer packet to the subnetwork path characteristics,\
    \ and the ETE\n   will restore the packet to its original form during reassembly.\n\
    \   Therefore, the fact that the packet may have been segmented within\n   the\
    \ subnetwork is not observable outside of the subnetwork.\n   The ITE next encapsulates\
    \ each segment in a SEAL header formatted as\n   follows:\n    0             \
    \      1                   2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1\
    \ 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |          ID Extension         |A|R|M|RSV| SEG |  Next Header  |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                       Figure 2: SEAL Header Format\n   where the header fields\
    \ are defined as follows:\n   ID Extension (16)\n      a 16-bit extension of the\
    \ Identification field in the outer IPv4\n      header; encodes the most-significant\
    \ 16 bits of a 32 bit SEAL_ID\n      value.\n   A (1)\n      the \"Acknowledgement\
    \ Requested\" bit.  Set to 1 if the ITE wishes\n      to receive an explicit acknowledgement\
    \ from the ETE.\n   R (1)\n      the \"Report Fragmentation\" bit.  Set to 1 if\
    \ the ITE wishes to\n      receive a report from the ETE if any IPv4 fragmentation\
    \ occurs.\n   M (1)\n      the \"More Segments\" bit.  Set to 1 if this SEAL protocol\
    \ packet\n      contains a non-final segment of a multi-segment mid-layer packet.\n\
    \   RSV (2)\n      a 2-bit field reserved for future use.  Must be set to 0 for\
    \ the\n      purpose of this specification.\n   SEG (3)\n      a 3-bit segment\
    \ number.  Encodes a segment number between 0 - 7.\n   Next Header (8)\n     \
    \ an 8-bit field that encodes an Internet Protocol number the same\n      as for\
    \ the IPv4 protocol and IPv6 next header fields.\n   For single-segment mid-layer\
    \ packets, the ITE encapsulates the\n   segment in a SEAL header with (M=0; SEG=0).\
    \  For N-segment mid-layer\n   packets (N <= 8), the ITE encapsulates each segment\
    \ in a SEAL header\n   with (M=1; SEG=0) for the first segment, (M=1; SEG=1) for\
    \ the second\n   segment, etc., with the final segment setting (M=0; SEG=N-1).\n\
    \   The ITE next sets RSV='00' and sets the A and R bits in the SEAL\n   header\
    \ of the first segment according to whether the packet is to be\n   used as an\
    \ explicit/implicit probe as specified in Section 4.2.4.\n   The ITE then writes\
    \ the Internet Protocol number corresponding to the\n   mid-layer packet in the\
    \ SEAL 'Next Header' field and encapsulates\n   each segment in the requisite\
    \ */IPv4 outer headers according to the\n   specific encapsulation format (e.g.,\
    \ [RFC2003], [RFC4213], [RFC4380],\n   etc.), except that it writes 'SEAL_PROTO'\
    \ in the protocol field of\n   the outer IPv4 header (when simple IPv4 encapsulation\
    \ is used) or\n   writes 'SEAL_PORT' in the outer destination service port field\
    \ (e.g.,\n   when UDP/IPv4 encapsulation is used).  The ITE finally sets packet\n\
    \   identification values as specified in Section 4.2.5 and sends the\n   packets\
    \ as specified in Section 4.2.6.\n"
- title: 4.2.4.  Sending Probes
  contents:
  - "4.2.4.  Sending Probes\n   When S_MSS is larger than S_MRU/8 bytes, the ITE sends\
    \ ordinary\n   encapsulated data packets as implicit probes to detect in-the-network\n\
    \   IPv4 fragmentation and to determine new values for S_MSS.  The ITE\n   sets\
    \ R=1 in the SEAL header of a packet with SEG=0 to be used as an\n   implicit\
    \ probe, and will receive ICMPv4 Fragmentation Needed messages\n   from the ETE\
    \ if any IPv4 fragmentation occurs.  When the ITE has\n   already reduced S_MSS\
    \ to the minimum value, it instead sets R=0 in\n   the SEAL header to avoid generating\
    \ fragmentation reports for\n   unavoidable in-the-network fragmentation.\n  \
    \ The ITE should send explicit probes periodically to manage a window\n   of SEAL_IDs\
    \ of outstanding probes as a means to validate any ICMPv4\n   messages it receives.\
    \  The ITE sets A=1 in the SEAL header of a\n   packet with SEG=0 to be used as\
    \ an explicit probe, where the probe\n   can be either an ordinary data packet\
    \ or a NULL packet created by\n   setting the 'Next Header' field in the SEAL\
    \ header to a value of \"No\n   Next Header\" (see Section 4.7 of [RFC2460]).\n\
    \   The ITE should further send explicit probes, periodically, to detect\n   increases\
    \ in S_MSS by resetting S_MSS to the maximum of (the\n   underlying IPv4 interface\
    \ MTU minus OHLEN) and S_MRU/8 bytes, and/or\n   by sending explicit probes that\
    \ are larger than the current S_MSS.\n   Finally, the ITE MAY send \"expendable\"\
    \ probe packets with DF=1 (see\n   Section 4.2.6) in order to generate ICMPv4\
    \ Fragmentation Needed\n   messages from routers on the path to the ETE.\n"
- title: 4.2.5.  Packet Identification
  contents:
  - "4.2.5.  Packet Identification\n   For the purpose of packet identification, the\
    \ ITE maintains a 32-bit\n   SEAL_ID value as per-ETE soft state, e.g., in the\
    \ IPv4 destination\n   cache.  The ITE randomly initializes SEAL_ID when the soft\
    \ state is\n   created and monotonically increments it (modulo 2^32) for each\n\
    \   successive SEAL protocol packet it sends to the ETE.  For each\n   packet,\
    \ the ITE writes the least-significant 16 bits of the SEAL_ID\n   value in the\
    \ Identification field in the outer IPv4 header, and\n   writes the most-significant\
    \ 16 bits in the ID Extension field in the\n   SEAL header.\n   For SEAL encapsulations\
    \ specifically designed for the traversal of\n   IPv4 Network Address Translators\
    \ (NATs), e.g., for encapsulations\n   that insert a UDP header between the SEAL\
    \ header and outer IPv4\n   header such as IPv6/SEAL/UDP/IPv4, the ITE instead\
    \ maintains SEAL_ID\n   as a 16-bit value that it randomly initializes when the\
    \ soft state is\n   created and monotonically increments (modulo 2^16) for each\n\
    \   successive packet.  For each packet, the ITE writes SEAL_ID in the ID\n  \
    \ extension field of the SEAL header and writes a random 16-bit value\n   in the\
    \ Identification field in the outer IPv4 header.  This is due to\n   the fact\
    \ that the ITE has no way to control IPv4 NATs in the path\n   that could rewrite\
    \ the Identification value in the outer IPv4 header.\n"
- title: 4.2.6.  Sending SEAL Protocol Packets
  contents:
  - "4.2.6.  Sending SEAL Protocol Packets\n   Following SEAL segmentation and encapsulation,\
    \ the ITE sets DF=0 in\n   the outer IPv4 header of every outer packet it sends.\
    \  For\n   \"expendable\" packets (e.g., for NULL packets used as probes -- see\n\
    \   Section 4.2.4), the ITE may instead set DF=1.\n   The ITE then sends each\
    \ outer packet that encapsulates a segment of\n   the same mid-layer packet into\
    \ the tunnel in canonical order, i.e.,\n   segment 0 first, followed by segment\
    \ 1, etc. and finally segment N-1.\n"
- title: 4.2.7.  Processing Raw ICMPv4 Messages
  contents:
  - "4.2.7.  Processing Raw ICMPv4 Messages\n   The ITE may receive \"raw\" ICMPv4\
    \ error messages from either the ETE\n   or routers within the subnetwork that\
    \ comprise an outer IPv4 header,\n   followed by an ICMPv4 header, followed by\
    \ a portion of the SEAL\n   packet that generated the error (also known as the\
    \ \"packet-in-\n   error\").  For such messages, the ITE can use the 32-bit SEAL\
    \ ID\n   encoded in the packet-in-error as a nonce to confirm that the ICMP\n\
    \   message came from either the ETE or an on-path router.  The ITE MAY\n   process\
    \ raw ICMPv4 messages as soft errors indicating that the path\n   to the ETE may\
    \ be failing.\n   The ITE should specifically process raw ICMPv4 Protocol Unreachable\n\
    \   messages as a hint that the ETE does not implement the SEAL protocol.\n"
- title: 4.2.8.  Processing SEAL-Encapsulated ICMPv4 Messages
  contents:
  - "4.2.8.  Processing SEAL-Encapsulated ICMPv4 Messages\n   In addition to any raw\
    \ ICMPv4 messages, the ITE may receive SEAL-\n   encapsulated ICMPv4 messages\
    \ from the ETE that comprise outer ICMPv4/\n   */SEAL/*/IPv4 headers followed\
    \ by a portion of the SEAL-encapsulated\n   packet-in-error.  The ITE can use\
    \ the 32-bit SEAL ID encoded in the\n   packet-in-error as well as information\
    \ in the outer IPv4 and SEAL\n   headers as nonces to confirm that the ICMP message\
    \ came from a\n   legitimate ETE.  The ITE then verifies that the SEAL_ID encoded\
    \ in\n   the packet-in-error is within the current window of transmitted\n   SEAL_IDs\
    \ for this ETE.  If the SEAL_ID is outside of the window, the\n   ITE discards\
    \ the message; otherwise, it advances the window and\n   processes the message.\n\
    \   The ITE processes SEAL-encapsulated ICMPv4 messages other than ICMPv4\n  \
    \ Fragmentation Needed exactly as specified in [RFC0792].\n   For SEAL-encapsulated\
    \ ICMPv4 Fragmentation Needed messages, the ITE\n   sets a variable 'L' to the\
    \ IPv4 length of the packet-in-error minus\n   OHLEN.  If (L > S_MSS), or if the\
    \ packet-in-error is an IPv4 first\n   fragment (i.e., with MF=1; Offset=0) and\
    \ (L >= (576 - OHLEN)), the\n   ITE sets (S_MSS = L).\n   Note that 576 in the\
    \ above corresponds to the nominal minimum MTU for\n   IPv4 links.  When an ITE\
    \ instead receives an IPv4 first fragment\n   packet-in-error with (L < (576 -\
    \ OHLEN)), it discovers that IPv4\n   fragmentation is occurring in the network\
    \ but it cannot determine the\n   true MTU of the restricting link due to a router\
    \ on the path\n   generating runt first fragments.  The ITE should therefore search\
    \ for\n   a reduced S_MSS value (to a minimum of S_MRU/8) through an iterative\n\
    \   searching strategy that parallels (Section 5 of [RFC1191]).\n   This searching\
    \ strategy may require multiple iterations of sending\n   SEAL packets with DF=0\
    \ using a reduced S_MSS and receiving additional\n   Fragmentation Needed messages,\
    \ but it will soon converge to a stable\n   value.  During this process, it is\
    \ essential that the ITE reduce\n   S_MSS based on the first Fragmentation Needed\
    \ message received, and\n   refrain from further reducing S_MSS until ICMPv4 Fragmentation\
    \ Needed\n   messages pertaining to packets sent under the new S_MSS are received.\n\
    \   As an optimization only, the ITE MAY transcribe SEAL-encapsulated\n   Fragmentation\
    \ Needed messages that contain sufficient information\n   into corresponding PTB\
    \ messages to return to the original source.\n"
- title: 4.3.  ETE Specification
  contents:
  - '4.3.  ETE Specification

    '
- title: 4.3.1.  Reassembly Buffer Requirements
  contents:
  - "4.3.1.  Reassembly Buffer Requirements\n   ETEs MUST be capable of using IPv4-layer\
    \ reassembly to reassemble\n   SEAL protocol outer IPv4 packets up to 2KB in length,\
    \ and MUST also\n   be capable of using SEAL-layer reassembly to reassemble mid-layer\n\
    \   packets up to (2KB - OHLEN).  Note that the ITE must retain the\n   SEAL/*/IPv4\
    \ header during both IPv4-layer and SEAL-layer reassembly\n   for the purpose\
    \ of associating the fragments/segments of the same\n   packet.\n"
- title: 4.3.2.  IPv4-Layer Reassembly
  contents:
  - "4.3.2.  IPv4-Layer Reassembly\n   The ETE performs IPv4 reassembly as normal,\
    \ and should maintain a\n   conservative high- and low-water mark for the number\
    \ of outstanding\n   reassemblies pending for each ITE.  When the size of the\
    \ reassembly\n   buffer exceeds this high-water mark, the ETE actively discards\n\
    \   incomplete reassemblies (e.g., using an Active Queue Management (AQM)\n  \
    \ strategy) until the size falls below the low-water mark.  The ETE\n   should\
    \ also use a reduced IPv4 maximum segment lifetime value (e.g.,\n   15 seconds),\
    \ i.e., the time after which it will discard an incomplete\n   IPv4 reassembly\
    \ for a SEAL protocol packet.  Finally, the ETE should\n   also actively discard\
    \ any pending reassemblies that clearly have no\n   opportunity for completion,\
    \ e.g., when a considerable number of new\n   IPv4 fragments have been received\
    \ before a fragment that completes a\n   pending reassembly has arrived.\n   After\
    \ reassembly, the ETE either accepts or discards the reassembled\n   packet based\
    \ on the current status of the IPv4 reassembly cache\n   (congested versus uncongested).\
    \  The SEAL_ID included in the IPv4\n   first fragment provides an additional\
    \ level of reassembly assurance,\n   since it can record a distinct arrival timestamp\
    \ useful for\n   associating the first fragment with its corresponding non-initial\n\
    \   fragments.  The choice of accepting/discarding a reassembly may also\n   depend\
    \ on the strength of the upper-layer integrity check if known\n   (e.g., IPSec/ESP\
    \ provides a strong upper-layer integrity check)\n   and/or the corruption tolerance\
    \ of the data (e.g., multicast\n   streaming audio/video may be more corruption-tolerant\
    \ than file\n   transfer, etc.).  In the limiting case, the ETE may choose to\
    \ discard\n   all IPv4 reassemblies and process only the IPv4 first fragment for\n\
    \   SEAL-encapsulated error generation purposes (see the following\n   sections).\n"
- title: 4.3.3.  Generating SEAL-Encapsulated ICMPv4 Fragmentation Needed
  contents:
  - "4.3.3.  Generating SEAL-Encapsulated ICMPv4 Fragmentation Needed\n        Messages\n\
    \   During IPv4-layer reassembly, the ETE determines whether the packet\n   belongs\
    \ to the SEAL protocol by checking for SEAL_PROTO in the outer\n   IPv4 header\
    \ (i.e., for simple IPv4 encapsulation) or for SEAL_PORT in\n   the outer */IPv4\
    \ header (e.g., for '*'=UDP).  When the ETE processes\n   the IPv4 first fragment\
    \ (i.e, one with DF=1 and Offset=0 in the IPv4\n   header) of a SEAL protocol\
    \ IPv4 packet with (R=1; SEG=0) in the SEAL\n   header, it sends a SEAL-encapsulated\
    \ ICMPv4 Fragmentation Needed\n   message back to the ITE with the MTU field set\
    \ to 0.  (Note that\n   setting a non-zero value in the MTU field of the ICMPv4\
    \ Fragmentation\n   Needed message would be redundant with the length value in\
    \ the IPv4\n   header of the first fragment, since this value is set to the correct\n\
    \   path MTU through in-the-network fragmentation.  Setting the MTU field\n  \
    \ to 0 therefore avoids the ambiguous case in which the MTU field and\n   the\
    \ IPv4 length field of the first fragment would record different\n   non-zero\
    \ values.)\n   When the ETE processes a SEAL protocol IPv4 packet with (A=1; SEG=0)\n\
    \   for which no IPv4 reassembly was required, or for which IPv4\n   reassembly\
    \ was successful and the R bit was not set, it sends a SEAL-\n   encapsulated\
    \ ICMPv4 Fragmentation Needed message back to the ITE with\n   the MTU value set\
    \ to 0.  Note therefore that when both the A and R\n   bits are set and fragmentation\
    \ occurs, the ETE only sends a single\n   ICMPv4 Fragmentation Needed message,\
    \ i.e., it does not send two\n   separate messages (one for the first fragment\
    \ and a second for the\n   reassembled whole SEAL packet).\n   The ETE prepares\
    \ the ICMPv4 Fragmentation Needed message by\n   encapsulating as much of the\
    \ first fragment (or the non-fragmented\n   packet) as possible in outer */SEAL/*/IPv4\
    \ headers without the length\n   of the message exceeding 576 bytes, as shown\
    \ in Figure 3:\n      +-------------------------+ -\n      |                 \
    \        |   ~ Outer */SEAL/*/IPv4 hdrs~   |\n      |                        \
    \ |   |\n      +-------------------------+   |\n      |      ICMPv4 Header   \
    \   |   |\n      |(Dest Unreach; Frag Need)|   |\n      +-------------------------+\
    \   |\n      |                         |    > Up to 576 bytes\n      ~    IP/*/SEAL/*/IPv4\
    \     ~   |\n      ~ hdrs of packet/fragment ~   |\n      |                  \
    \       |   |\n      +-------------------------+   |\n      |                \
    \         |   |\n      ~ Data of packet/fragment ~   |\n      |              \
    \           |   /\n      +-------------------------+ -\n       Figure 3: SEAL-Encapsulated\
    \ ICMPv4 Fragmentation Needed Message\n   The ETE next sets A=0, R=0, and SEG=0\
    \ in the outer SEAL header, sets\n   the SEAL_ID the same as for any SEAL packet,\
    \ then sets the SEAL Next\n   Header field and the fields of the outer */IPv4\
    \ headers the same as\n   for ordinary SEAL encapsulation.  The ETE then sets\
    \ the outer IPv4\n   destination and source addresses to the source and destination\n\
    \   addresses (respectively) of the packet/fragment.  If the destination\n   address\
    \ in the packet/fragment was multicast, the ETE instead sets\n   the outer IPv4\
    \ source address to an address assigned to the\n   underlying IPv4 interface.\
    \  The ETE finally sends the SEAL-\n   encapsulated ICMPv4 message to the ITE\
    \ the same as specified in\n   Section 4.2.5, except that when the A bit in the\
    \ packet/fragment is\n   not set, the ETE sends the messages subject to rate limiting\
    \ since it\n   is not entirely critical that all fragmentation be reported to\
    \ the\n   ITE.\n"
- title: 4.3.4.  SEAL-Layer Reassembly
  contents:
  - "4.3.4.  SEAL-Layer Reassembly\n   Following IPv4 reassembly of a SEAL packet\
    \ with (RSV!=0; SEG=0), if\n   the packet is not a SEAL-encapsulated ICMPv4 message,\
    \ the ETE\n   generates a SEAL-encapsulated ICMPv4 Parameter Problem message with\n\
    \   pointer set to the flags field in the SEAL header, sends the message\n   back\
    \ to the ITE in the same manner specified in Section 4.3.3, then\n   drops the\
    \ packet.  For all other SEAL packets, the ETE adds the\n   packet to a SEAL-Layer\
    \ pending-reassembly queue if either the M bit\n   or the SEG field in the SEAL\
    \ header is non-zero.\n   The ETE performs SEAL-layer reassembly through simple\
    \ in-order\n   concatenation of the encapsulated segments from N consecutive SEAL\n\
    \   protocol packets from the same mid-layer packet.  SEAL-layer\n   reassembly\
    \ requires the ETE to maintain a cache of recently received\n   segments for a\
    \ hold time that would allow for reasonable inter-\n   segment delays.  The ETE\
    \ uses a SEAL maximum segment lifetime of 15\n   seconds for this purpose, i.e.,\
    \ the time after which it will discard\n   an incomplete reassembly.  However,\
    \ the ETE should also actively\n   discard any pending reassemblies that clearly\
    \ have no opportunity for\n   completion, e.g., when a considerable number of\
    \ new SEAL packets have\n   been received before a packet that completes a pending\
    \ reassembly has\n   arrived.\n   The ETE reassembles the mid-layer packet segments\
    \ in SEAL protocol\n   packets that contain segment numbers 0 through N-1, with\
    \ M=1/0 in\n   non-final/final segments, respectively, and with consecutive SEAL_ID\n\
    \   values.  That is, for an N-segment mid-layer packet, reassembly\n   entails\
    \ the concatenation of the SEAL-encapsulated segments with\n   (segment 0, SEAL_ID\
    \ i), followed by (segment 1, SEAL_ID ((i + 1) mod\n   2^32)), etc. up to (segment\
    \ N-1, SEAL_ID ((i + N-1) mod 2^32)).  (For\n   SEAL encapsulations specifically\
    \ designed for traversal of IPv4 NATs,\n   the ETE instead uses only a 16-bit\
    \ SEAL_ID value, and uses mod 2^16\n   arithmetic to associate the segments of\
    \ the same packet.)\n"
- title: 4.3.5.  Delivering Packets to Upper Layers
  contents:
  - "4.3.5.  Delivering Packets to Upper Layers\n   Following SEAL-layer reassembly,\
    \ the ETE silently discards the\n   reassembled packet if it was a NULL packet\
    \ (see Section 4.2.4).  In\n   the same manner, the ETE silently discards any\
    \ reassembled mid-layer\n   packet larger than (2KB - OHLEN) that either experienced\
    \ IPv4\n   fragmentation or did not arrive as a single SEAL segment.\n   Next,\
    \ if the ETE determines that the inner packet would cause an\n   ICMPv4 error\
    \ message to be generated, it generates a SEAL-\n   encapsulated ICMPv4 error\
    \ message, sends the message back to the ITE\n   in the same manner specified\
    \ in Section 4.3.3, then either accepts or\n   drops the packet according to the\
    \ type of error.  Otherwise, the ETE\n   delivers the inner packet to the upper-layer\
    \ protocol indicated in\n   the Next Header field.\n"
- title: 5.  SEAL Protocol Specification - Transport Mode
  contents:
  - "5.  SEAL Protocol Specification - Transport Mode\n   Section 4 specifies the\
    \ operation of SEAL in \"tunnel mode\", i.e.,\n   when there are both an inner\
    \ and outer IP layer with a SEAL\n   encapsulation layer between.  However, the\
    \ SEAL protocol can also be\n   used in a \"transport mode\" of operation within\
    \ a subnetwork region in\n   which the inner-layer corresponds to a transport\
    \ layer protocol\n   (e.g., UDP, TCP, etc.) instead of an inner IP layer.\n  \
    \ For example, two TCP endpoints connected to the same subnetwork\n   region can\
    \ negotiate the use of transport-mode SEAL for a connection\n   by inserting a\
    \ 'SEAL_OPTION' TCP option during the connection\n   establishment phase.  If\
    \ both TCPs agree on the use of SEAL, their\n   protocol messages will be carried\
    \ as TCP/SEAL/IPv4 and the connection\n   will be serviced by the SEAL protocol\
    \ using TCP (instead of an\n   encapsulating tunnel endpoint) as the transport\
    \ layer protocol.  The\n   SEAL protocol for transport mode otherwise observes\
    \ the same\n   specifications as for Section 4.\n"
- title: 6.  Link Requirements
  contents:
  - "6.  Link Requirements\n   Subnetwork designers are expected to follow the recommendations\
    \ in\n   Section 2 of [RFC3819] when configuring link MTUs.\n"
- title: 7.  End System Requirements
  contents:
  - "7.  End System Requirements\n   SEAL provides robust mechanisms for returning\
    \ PTB messages; however,\n   end systems that send unfragmentable IP packets larger\
    \ than 1500\n   bytes are strongly encouraged to use Packetization Layer Path\
    \ MTU\n   Discovery per [RFC4821].\n"
- title: 8.  Router Requirements
  contents:
  - "8.  Router Requirements\n   IPv4 routers within the subnetwork are strongly encouraged\
    \ to\n   implement IPv4 fragmentation such that the first fragment is the\n  \
    \ largest and approximately the size of the underlying link MTU, i.e.,\n   they\
    \ should avoid generating runt first fragments.\n"
- title: 9.  IANA Considerations
  contents:
  - "9.  IANA Considerations\n   SEAL_PROTO, SEAL_PORT, and SEAL_OPTION are taken\
    \ from their\n   respective range of experimental values documented in [RFC3692]\
    \ and\n   [RFC4727].  These values are for experimentation purposes only, and\n\
    \   not to be used for any kind of deployments (i.e., they are not to be\n   shipped\
    \ in any products).\n"
- title: 10.  Security Considerations
  contents:
  - "10.  Security Considerations\n   Unlike IPv4 fragmentation, overlapping fragment\
    \ attacks are not\n   possible due to the requirement that SEAL segments be non-\n\
    \   overlapping.\n   An amplification/reflection attack is possible when an attacker\
    \ sends\n   IPv4 first fragments with spoofed source addresses to an ETE,\n  \
    \ resulting in a stream of ICMPv4 Fragmentation Needed messages\n   returned to\
    \ a victim ITE.  The encapsulated segment of the spoofed\n   IPv4 first fragment\
    \ provides mitigation for the ITE to detect and\n   discard spurious ICMPv4 Fragmentation\
    \ Needed messages.\n   The SEAL header is sent in-the-clear (outside of any IPsec/ESP\n\
    \   encapsulations) the same as for the outer */IPv4 headers.  As for\n   IPv6\
    \ extension headers, the SEAL header is protected only by L2\n   integrity checks\
    \ and is not covered under any L3 integrity checks.\n"
- title: 11.  Related Work
  contents:
  - "11.  Related Work\n   Section 3.1.7 of [RFC2764] provides a high-level sketch\
    \ for\n   supporting large tunnel MTUs via a tunnel-level segmentation and\n \
    \  reassembly capability to avoid IP level fragmentation, which is in\n   part\
    \ the same approach used by tunnel-mode SEAL.  SEAL could\n   therefore be considered\
    \ as a fully functioned manifestation of the\n   method postulated by that informational\
    \ reference; however, SEAL also\n   supports other modes of operation including\
    \ transport-mode and\n   duplicate packet detection.\n   Section 3 of [RFC4459]\
    \ describes inner and outer fragmentation at the\n   tunnel endpoints as alternatives\
    \ for accommodating the tunnel MTU;\n   however, the SEAL protocol specifies a\
    \ mid-layer segmentation and\n   reassembly capability that is distinct from both\
    \ inner and outer\n   fragmentation.\n   Section 4 of [RFC2460] specifies a method\
    \ for inserting and\n   processing extension headers between the base IPv6 header\
    \ and\n   transport layer protocol data.  The SEAL header is inserted and\n  \
    \ processed in exactly the same manner.\n   The concepts of path MTU determination\
    \ through the report of\n   fragmentation and extending the IP Identification\
    \ field were first\n   proposed in deliberations of the TCP-IP mailing list and\
    \ the Path MTU\n   Discovery Working Group (MTUDWG) during the late 1980's and\
    \ early\n   1990's.  SEAL supports a report fragmentation capability using bits\n\
    \   in an extension header (the original proposal used a spare bit in the\n  \
    \ IP header) and supports ID extension through a 16-bit field in an\n   extension\
    \ header (the original proposal used a new IP option).  A\n   historical analysis\
    \ of the evolution of these concepts, as well as\n   the development of the eventual\
    \ path MTU discovery mechanism for IP,\n   appears in Appendix A of this document.\n"
- title: 12.  SEAL Advantages over Classical Methods
  contents:
  - "12.  SEAL Advantages over Classical Methods\n   The SEAL approach offers a number\
    \ of distinct advantages over the\n   classical path MTU discovery methods [RFC1191]\
    \ [RFC1981]:\n   1.  Classical path MTU discovery *always* results in packet loss\
    \ when\n       an MTU restriction is encountered.  Using SEAL, IPv4\n       fragmentation\
    \ provides a short-term interim mechanism for\n       ensuring that packets are\
    \ delivered while SEAL adjusts its packet\n       sizing parameters.\n   2.  Classical\
    \ path MTU discovery requires that routers generate an\n       ICMP PTB message\
    \ for *all* packets lost due to an MTU\n       restriction; this situation is\
    \ exacerbated at high data rates and\n       becomes severe for in-the-network\
    \ tunnels that service many\n       communicating end systems.  Since SEAL ensures\
    \ that packets no\n       larger than S_MRU are delivered, however, it is sufficient\
    \ for\n       the ETE to return ICMPv4 Fragmentation Needed messages subject to\n\
    \       rate limiting and not for every packet-in-error.\n   3.  Classical path\
    \ MTU may require several iterations of dropping\n       packets and returning\
    \ ICMP PTB messages until an acceptable path\n       MTU value is determined.\
    \  Under normal circumstances, SEAL\n       determines the correct packet sizing\
    \ parameters in a single\n       iteration.\n   4.  Using SEAL, ordinary packets\
    \ serve as implicit probes without\n       exposing data to unnecessary loss.\
    \  SEAL also provides an\n       explicit probing mode not available in the classic\
    \ methods.\n   5.  Using SEAL, ETEs encapsulate ICMP error messages in an outer\
    \ SEAL\n       header such that packet-filtering network middleboxes can\n   \
    \    distinguish them from \"raw\" ICMP messages that may be generated\n     \
    \  by an attacker.\n   6.  Most importantly, all SEAL packets have a 32-bit Identification\n\
    \       value that can be used for duplicate packet detection purposes\n     \
    \  and to match ICMP error messages with actual packets sent without\n       requiring\
    \ per-packet state.  Moreover, the SEAL ITE can be\n       configured to accept\
    \ ICMP feedback only from the legitimate ETE;\n       hence, the packet spoofing-related\
    \ denial-of-service attack\n       vectors open to the classical methods are eliminated.\n\
    \   In summary, the SEAL approach represents an architecturally superior\n   method\
    \ for ensuring that packets of various sizes are either\n   delivered or deterministically\
    \ dropped.  When end systems use their\n   own end-to-end MTU determination mechanisms\
    \ [RFC4821], the SEAL\n   advantages are further enhanced.\n"
- title: 13.  Acknowledgments
  contents:
  - "13.  Acknowledgments\n   The following individuals are acknowledged for helpful\
    \ comments and\n   suggestions: Jari Arkko, Fred Baker, Iljitsch van Beijnum,\
    \ Teco Boot,\n   Bob Braden, Brian Carpenter, Steve Casner, Ian Chakeres, Remi\
    \ Denis-\n   Courmont, Aurnaud Ebalard, Gorry Fairhurst, Joel Halpern, John\n\
    \   Heffner, Thomas Henderson, Bob Hinden, Christian Huitema, Joe Macker,\n  \
    \ Matt Mathis, Erik Nordmark, Dan Romascanu, Dave Thaler, Joe Touch,\n   Magnus\
    \ Westerlund, Robin Whittle, James Woodyatt, and members of the\n   Boeing PhantomWorks\
    \ DC&NT group.\n   Path MTU determination through the report of fragmentation\
    \ was first\n   proposed by Charles Lynn on the TCP-IP mailing list in 1987.\n\
    \   Extending the IP identification field was first proposed by Steve\n   Deering\
    \ on the MTUDWG mailing list in 1989.\n"
- title: 14.  References
  contents:
  - '14.  References

    '
- title: 14.1.  Normative References
  contents:
  - "14.1.  Normative References\n   [RFC0791]  Postel, J., \"Internet Protocol\"\
    , STD 5, RFC 791, September\n              1981.\n   [RFC0792]  Postel, J., \"\
    Internet Control Message Protocol\", STD 5,\n              RFC 792, September\
    \ 1981.\n   [RFC2119]  Bradner, S., \"Key words for use in RFCs to Indicate\n\
    \              Requirement Levels\", BCP 14, RFC 2119, March 1997.\n   [RFC2460]\
    \  Deering, S. and R. Hinden, \"Internet Protocol, Version 6\n              (IPv6)\
    \ Specification\", RFC 2460, December 1998.\n"
- title: 14.2.  Informative References
  contents:
  - "14.2.  Informative References\n   [FOLK]     C, C., D, D., and k. k, \"Beyond\
    \ Folklore: Observations on\n              Fragmented Traffic\", December 2002.\n\
    \   [FRAG]     Kent, C. and J. Mogul, \"Fragmentation Considered Harmful\",\n\
    \              October 1987.\n   [MTUDWG]   \"IETF MTU Discovery Working Group\
    \ mailing list,\n               gatekeeper.dec.com/pub/DEC/WRL/mogul/mtudwg-log,\n\
    \              November 1989 - February 1995.\".\n   [RFC1063]  Mogul, J., Kent,\
    \ C., Partridge, C., and K. McCloghrie, \"IP\n              MTU discovery options\"\
    , RFC 1063, July 1988.\n   [RFC1191]  Mogul, J. and S. Deering, \"Path MTU discovery\"\
    , RFC 1191,\n              November 1990.\n   [RFC1981]  McCann, J., Deering,\
    \ S., and J. Mogul, \"Path MTU Discovery\n              for IP version 6\", RFC\
    \ 1981, August 1996.\n   [RFC2003]  Perkins, C., \"IP Encapsulation within IP\"\
    , RFC 2003,\n              October 1996.\n   [RFC2004]  Perkins, C., \"Minimal\
    \ Encapsulation within IP\", RFC 2004,\n              October 1996.\n   [RFC2764]\
    \  Gleeson, B., Lin, A., Heinanen, J., Armitage, G., and A.\n              Malis,\
    \ \"A Framework for IP Based Virtual Private\n              Networks\", RFC 2764,\
    \ February 2000.\n   [RFC2923]  Lahey, K., \"TCP Problems with Path MTU Discovery\"\
    , RFC\n              2923, September 2000.\n   [RFC3692]  Narten, T., \"Assigning\
    \ Experimental and Testing Numbers\n              Considered Useful\", BCP 82,\
    \ RFC 3692, January 2004.\n   [RFC3819]  Karn, P., Ed., Bormann, C., Fairhurst,\
    \ G., Grossman, D.,\n              Ludwig, R., Mahdavi, J., Montenegro, G., Touch,\
    \ J., and L.\n              Wood, \"Advice for Internet Subnetwork Designers\"\
    , BCP 89,\n              RFC 3819, July 2004.\n   [RFC4213]  Nordmark, E. and\
    \ R. Gilligan, \"Basic Transition Mechanisms\n              for IPv6 Hosts and\
    \ Routers\", RFC 4213, October 2005.\n   [RFC4301]  Kent, S. and K. Seo, \"Security\
    \ Architecture for the\n              Internet Protocol\", RFC 4301, December\
    \ 2005.\n   [RFC4380]  Huitema, C., \"Teredo: Tunneling IPv6 over UDP through\n\
    \              Network Address Translations (NATs)\", RFC 4380, February\n   \
    \           2006.\n   [RFC4459]  Savola, P., \"MTU and Fragmentation Issues with\
    \ In-the-\n              Network Tunneling\", RFC 4459, April 2006.\n   [RFC4727]\
    \  Fenner, B., \"Experimental Values In IPv4, IPv6, ICMPv4,\n              ICMPv6,\
    \ UDP, and TCP Headers\", RFC 4727, November 2006.\n   [RFC4821]  Mathis, M. and\
    \ J. Heffner, \"Packetization Layer Path MTU\n              Discovery\", RFC 4821,\
    \ March 2007.\n   [RFC4963]  Heffner, J., Mathis, M., and B. Chandler, \"IPv4\
    \ Reassembly\n              Errors at High Data Rates\", RFC 4963, July 2007.\n\
    \   [TCP-IP]   \"Archive/Hypermail of Early TCp-IP Mail List\",\n            \
    \  http://www-mice.cs.ucl.ac.uk/multimedia/misc/tcp_ip/,\n              May 1987\
    \ - May 1990.\n"
- title: Appendix A.  Historic Evolution of PMTUD
  contents:
  - "Appendix A.  Historic Evolution of PMTUD\n   (Taken from \"Neighbor Affiliation\
    \ Protocol for IPv6-over-(foo)-over-\n   IPv4\"; written 10/30/2002):\n   The\
    \ topic of Path MTU discovery (PMTUD) saw a flurry of discussion\n   and numerous\
    \ proposals in the late 1980's through early 1990.  The\n   initial problem was\
    \ posed by Art Berggreen on May 22, 1987 in a\n   message to the TCP-IP discussion\
    \ group [TCP-IP].  The discussion that\n   followed provided significant reference\
    \ material for [FRAG].  An IETF\n   Path MTU Discovery Working Group [MTUDWG]\
    \ was formed in late 1989\n   with charter to produce an RFC.  Several variations\
    \ on a very few\n   basic proposals were entertained, including:\n   1.  Routers\
    \ record the PMTUD estimate in ICMP-like path probe\n       messages (proposed\
    \ in [FRAG] and later [RFC1063])\n   2.  The destination reports any fragmentation\
    \ that occurs for packets\n       received with the \"RF\" (Report Fragmentation)\
    \ bit set (Steve\n       Deering's 1989 adaptation of Charles Lynn's Nov. 1987\
    \ proposal)\n   3.  A hybrid combination of 1) and Charles Lynn's Nov. 1987 (straw\n\
    \       RFC draft by McCloughrie, Fox and Mogul on Jan 12, 1990)\n   4.  Combination\
    \ of the Lynn proposal with TCP (Fred Bohle, Jan 30,\n       1990)\n   5.  Fragmentation\
    \ avoidance by setting \"IP_DF\" flag on all packets\n       and retransmitting\
    \ if ICMPv4 \"fragmentation needed\" messages\n       occur (Geof Cooper's 1987\
    \ proposal; later adapted into [RFC1191]\n       by Mogul and Deering).\n   Option\
    \ 1) seemed attractive to the group at the time, since it was\n   believed that\
    \ routers would migrate more quickly than hosts.  Option\n   2) was a strong contender,\
    \ but repeated attempts to secure an \"RF\"\n   bit in the IPv4 header from the\
    \ IESG failed and the proponents became\n   discouraged. 3) was abandoned because\
    \ it was perceived as too\n   complicated, and 4) never received any apparent\
    \ serious\n   consideration.  Proposal 5) was a late entry into the discussion\
    \ from\n   Steve Deering on Feb. 24th, 1990.  The discussion group soon\n   thereafter\
    \ seemingly lost track of all other proposals and adopted\n   5), which eventually\
    \ evolved into [RFC1191] and later [RFC1981].\n   In retrospect, the \"RF\" bit\
    \ postulated in 2) is not needed if a\n   \"contract\" is first established between\
    \ the peers, as in proposal 4)\n   and a message to the MTUDWG mailing list from\
    \ jrd@PTT.LCS.MIT.EDU on\n   Feb 19. 1990.  These proposals saw little discussion\
    \ or rebuttal, and\n   were dismissed based on the following the assertions:\n\
    \      o  routers upgrade their software faster than hosts\n      o  PCs could\
    \ not reassemble fragmented packets\n      o  Proteon and Wellfleet routers did\
    \ not reproduce the \"RF\" bit\n         properly in fragmented packets\n    \
    \  o  Ethernet-FDDI bridges would need to perform fragmentation\n         (i.e.,\
    \ \"translucent\" not \"transparent\" bridging)\n      o  the 16-bit IP_ID field\
    \ could wrap around and disrupt reassembly\n         at high packet arrival rates\n\
    \   The first four assertions, although perhaps valid at the time, have\n   been\
    \ overcome by historical events leaving only the final to\n   consider.  But,\
    \ [FOLK] has shown that IP_ID wraparound simply does\n   not occur within several\
    \ orders of magnitude the reassembly timeout\n   window on high-bandwidth networks.\n\
    \   (Author's 2/11/08 note: this final point was based on a loose\n   interpretation\
    \ of [FOLK], and is more accurately addressed in\n   [RFC4963].)\n"
- title: Appendix B.  Reliability Extensions
  contents:
  - "Appendix B.  Reliability Extensions\n   The SEAL header includes a Reserved (RSV)\
    \ field that is set to zero\n   for the purpose of this specification.  This field\
    \ may be used by\n   future updates to this specification for the purpose of improved\n\
    \   reliability in the face of loss due to congestion, signal\n   intermittence,\
    \ etc.  Automatic Repeat-ReQuest (ARQ) mechanisms are\n   used to ensure reliable\
    \ delivery between the endpoints of physical\n   links (e.g., on-link neighbors\
    \ in an IEEE 802.11 network) as well as\n   between the endpoints of an end-to-end\
    \ transport (e.g., the endpoints\n   of a TCP connection).  However, ARQ mechanisms\
    \ may be poorly suited\n   to in-the-network elements such as the SEAL ITE and\
    \ ETE, since\n   retransmission of lost segments would require unacceptable state\n\
    \   maintenance at the ITE and would result in packet reordering within\n   the\
    \ subnetwork.\n   Instead, alternate reliability mechanisms such as Forward Error\n\
    \   Correction (FEC) may be specified in future updates to this\n   specification\
    \ for the purpose of improved reliability.  Such\n   mechanisms may entail the\
    \ ITE performing proactive transmissions of\n   redundant data, e.g., by sending\
    \ multiple copies of the same data.\n   Signaling from the ETE (e.g., by sending\
    \ SEAL-encapsulated ICMPv4\n   Source Quench messages) may be specified in a future\
    \ document as a\n   means for the ETE to dynamically inform the ITE of changing\
    \ FEC\n   conditions.\n"
- title: Author's Address
  contents:
  - "Author's Address\n   Fred L. Templin, Editor\n   Boeing Research & Technology\n\
    \   P.O. Box 3707\n   Seattle, WA  98124\n   USA\n   EMail: fltemplin@acm.org\n"
