- title: __initial_text__
  contents:
  - "                    Six Virtual Inches to the Left:\n                       \
    \  The Problem with IPng\n"
- title: Status of this Memo
  contents:
  - "Status of this Memo\n   This memo provides information for the Internet community.\
    \  This memo\n   does not specify an Internet standard of any kind.  Distribution\
    \ of\n   this memo is unlimited.\n"
- title: Abstract
  contents:
  - "Abstract\n   This document was submitted to the IETF IPng area in response to\
    \ RFC\n   1550.  Publication of this document does not imply acceptance by the\n\
    \   IPng area of any ideas expressed within.  Comments should be\n   submitted\
    \ to the big-internet@munnari.oz.au mailing list.\n"
- title: Overview
  contents:
  - "Overview\n   This RFC suggests that a new version of TCP (TCPng), and UDP, be\n\
    \   developed and deployed.  It proposes that a globally unique address\n   (TA)\
    \ be assigned to Transport layer protocol (TCP/UDP).  The purpose\n   of this\
    \ TA is to uniquely identify an Internet node without\n   specifying any routing\
    \ information.  A new version of TCP, and UDP,\n   will need to be developed describing\
    \ the new header fields and\n   formats.  This new version of TCP would contain\
    \ support for high\n   bandwidth-delay networks.  Support for multiple network\
    \ layer\n   (Internet Protocol) protocols is also possible with this new TCP.\n\
    \   Assigning an address to TCP/UDP would allow for the support of\n   multiple\
    \ network layer protocols (IPng's).  The TA would identify the\n   location of\
    \ an Internet node.  The IPng layer would provide routing\n   information to the\
    \ Internet.  Separating the location and routing\n   functions will greatly increase\
    \ the versatility of the Internet.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1.  Introduction . . . . . . . . . . . . . . . . . . .\
    \ . . . . . .  2\n   2.  Historical perspective . . . . . . . . . . . . . . .\
    \ . . . . .  3\n        2.1  OSI and the 7 layer model  . . . . . . . . . . .\
    \ . . . .  3\n        2.2  Internet Evolution . . . . . . . . . . . . . . . .\
    \ . . .  4\n        2.3  The Reasons for Change . . . . . . . . . . . . . . .\
    \ . .  4\n              2.3.1  Class-B Address Exhaustion . . . . . . . . . .\
    \ .  4\n              2.3.2  Routing Table Growth . . . . . . . . . . . . . .\
    \  5\n   3.  The Problems with Change . . . . . . . . . . . . . . . . . . .  5\n\
    \        3.1  TCP/UDP Implementations  . . . . . . . . . . . . . . . .  6\n  \
    \      3.2  User Applications  . . . . . . . . . . . . . . . . . . .  6\n    \
    \    3.3  The Entrenched Masses  . . . . . . . . . . . . . . . . .  6\n   4. \
    \ Making TCP & UDP Protocol Independent  . . . . . . . . . . . .  7\n        4.1\
    \  Transport Addressing . . . . . . . . . . . . . . . . . .  7\n        4.2  TCPng\
    \  . . . . . . . . . . . . . . . . . . . . . . . . . 12\n        4.3  Mandatory\
    \ Options  . . . . . . . . . . . . . . . . . . . 15\n        4.4  Optional Options\
    \ . . . . . . . . . . . . . . . . . . . . 16\n        4.5  Compatibility Issues\
    \ . . . . . . . . . . . . . . . . . . 16\n              4.5.1  Backward Compatibility\
    \ . . . . . . . . . . . . . 17\n        4.6  Level 4 Gateways . . . . . . . .\
    \ . . . . . . . . . . . . 17\n        4.7  Error Conditions . . . . . . . . .\
    \ . . . . . . . . . . . 18\n   5.  Advantages and Disadvantages of this approach\
    \  . . . . . . . . 18\n   6.  Conclusions  . . . . . . . . . . . . . . . . . .\
    \ . . . . . . . 19\n   References . . . . . . . . . . . . . . . . . . . . . .\
    \ . . . . . . 19\n   Bibliography . . . . . . . . . . . . . . . . . . . . . .\
    \ . . . . . 20\n   Appendix A . . . . . . . . . . . . . . . . . . . . . . . .\
    \ . . . . 21\n   Appendix B . . . . . . . . . . . . . . . . . . . . . . . . .\
    \ . . . 21\n   Appendix C . . . . . . . . . . . . . . . . . . . . . . . . . .\
    \ . . 22\n   Appendix D . . . . . . . . . . . . . . . . . . . . . . . . . . .\
    \ . 24\n   Security Considerations  . . . . . . . . . . . . . . . . . . . . .\
    \ 27\n   Authors' Addresses . . . . . . . . . . . . . . . . . . . . . . . . 27\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   For more than a decade, network engineers have understood\
    \ the\n   benefits of a multi-layer protocol stack. However, during its\n   development,\
    \ the Transmission Control Protocol (TCP) was strongly\n   linked to the Internet\
    \ Protocol (IP) [Postel, 1981a]. When the TCP/IP\n   protocol suite was developed,\
    \ two important ideas were implemented.\n   The first was that each host would\
    \ be uniquely identified by a\n   network layer number (i.e., IP number = 192.0.2.1).\
    \ The second was to\n   identify an application with a transport layer port number\
    \ (i.e., TCP\n   DNS number = 53). For host-to-host communications, the IP and\
    \ port\n   numbers would be concatenated to form a socket (i.e., 192.0.2.1.53).\n\
    \   While this has lead to a very efficient and streamlined TCP layer, it\n  \
    \ has tightly coupled the TCP and IP layers. So much so, in fact, that\n   it\
    \ is nearly impossible to run TCP over any network layer except for\n   IP.\n\
    \   The motivation for writing this paper resulted from research into the\n  \
    \ various Internet Protocol Next Generation (IPng) proposals put forth\n   by\
    \ various IETF working groups. Each of the IPng proposals strives to\n   solve\
    \ the impending IP address exhaustion problem by increasing the\n   size of the\
    \ address field. They all allude to modifications to TCP\n   and User Datagram\
    \ Protocol (UDP) to make them capable of supporting a\n   new network layer IPng\
    \ protocol. The authors of this paper feel that\n   this points to an inherent\
    \ TCP/IP design flaw. The flaw is namely\n   that the transport (TCP) and network\
    \ (IP) layers are not protocol\n   independent. In this paper, we will propose\
    \ a new TCP and UDP\n   implementation that will make the transport and protocol\
    \ layers\n   independent and thus allow for any of the IPng protocols to operate\n\
    \   on the same internet without any further modification to the higher\n   layer\
    \ protocols.  TCP, and UDP would become extremely powerful\n   Application Programming\
    \ Interfaces (APIs) that operate effectively\n   over multiple network layer technologies.\n"
- title: 2.  Historical perspective
  contents:
  - '2.  Historical perspective

    '
- title: 2.1  OSI and the 7 layer model
  contents:
  - "2.1  OSI and the 7 layer model\n   Present day computer and communication systems\
    \ have become\n   increasingly heterogeneous in both their software and hardware\n\
    \   complexity, as well as their intended functionality. Prior to the\n   establishment\
    \ of computer communications industry standards,\n   proprietary standards followed\
    \ by particular software and hardware\n   manufacturers prevented communication\
    \ and information exchange\n   between different manufacturers  products and therefore\
    \ lead to many\n   \"closed systems\" [Halsal, 1992] incapable of readily sharing\n\
    \   information. With the proliferation of these types of systems in the\n   mid\
    \ 1970s, the potential advantages of \"open systems\" where\n   recognized by\
    \ the computer industry and a range of standards started\n   to be introduced\
    \ [Halsal, 1992].\n   The first and perhaps most important of these standards\
    \ was the\n   International Standards Organization (ISO) reference model for Open\n\
    \   Systems Interconnection standard (OSI), describing the complete\n   communication\
    \ subsystem within each computer. The goal of this\n   standard model was to \"\
    allow an application process in any computer\n   that supports a particular set\
    \ of standards to communicate freely\n   with an application process in any other\
    \ computer that supports the\n   same standards, irrespective of its origin of\
    \ manufacture\" [Halsal,\n   1992].  The last statement above describes the OSI\
    \ 7-layer model\n   which has now, in concept, become the fundamental building\
    \ block of\n   computer networks.  Though there are arguably no present day\n\
    \   computers and networks completely compliant to all 7 layers of the\n   OSI\
    \ protocol stack, most protocol stacks do embrace the fundamental\n   concept\
    \ of independent layers, thus allowing the flexibility for\n   computers operating\
    \ with dissimilar protocol stacks to communicate\n   with one another.\n   Take\
    \ for example, the datalink layers as supported by TCP/IP.  TCP/IP\n   will run\
    \ equally well in either the local area network (LAN) or wide\n   area network\
    \ (WAN) environments. Even though the LAN may use Ethernet\n   802.3 and the WAN\
    \ may use T1 serial links. This function was designed\n   to present a \"standardized\
    \ set of network functions (i.e., a logical\n   network)\", to the upper network\
    \ layer, \"regardless of the exact\n   details of the lower level implementations\"\
    \ [Meyer, Zobrist, 1990].\n"
- title: 2.2  Internet Evolution
  contents:
  - "2.2  Internet Evolution\n   \"The internet architecture, the grand plan behind\
    \ the TCP/IP protocol\n   suite\" was developed and tested in the late 1970s,\
    \ [Braden, et al,\n   1991] and but for the addition of subnetting, autonomous\
    \ systems, and\n   the domain name system in the early 1980s and the more recent\
    \ IP\n   multicasting implementation, stands today essentially unchanged. Even\n\
    \   with the understood benefits of a multi-layer protocol stack, all\n   steps\
    \ taken to enhance the internet and its services have been very\n   incremental\
    \ and narrowly focused.\n"
- title: 2.3  The Reasons for Change
  contents:
  - "2.3  The Reasons for Change\n   The reasons for change from IP to IPng can be\
    \ described in terms of\n   problems for which the current IP will simply become\
    \ inadequate and\n   unusable in the near future (~2-4 years). These problems\
    \ are the\n   exhaustion of IP class B address space, the exhaustion of IP address\n\
    \   space in general, and the non-hierarchical nature of address\n   allocation\
    \ leading to a flat routing space [Dixon, 1993].\n"
- title: 2.3.1  Class-B Address Exhaustion
  contents:
  - "2.3.1  Class-B Address Exhaustion\n   One of the fundamental causes of this problem\
    \ is the lack of a class\n   of network address appropriate for a mid-sized organization.\
    \ The\n   class-C address, with a maximum of 254 unique host addresses is to\n\
    \   small, while class-B, with a maximum of in excess of 65 thousand\n   unique\
    \ host addresses is to large [Fuller, et al, 1992].  As a\n   result, class-B\
    \ addresses get assigned even though nowhere near the\n   number of available\
    \ addresses will ever get used. This fact, combined\n   with a doubling of class-B\
    \ address allocation on a yearly basis lead\n   the Internet Engineering Steering\
    \ Group (IESG) to conclude in\n   November, 1992 that the class-B address space\
    \ would be completely\n   exhausted within 2 years time.  At that point, class-C\
    \ addresses\n   would have to be assigned, sometimes in multiples, to organizations\n\
    \   needing more than the 254 possible host addresses from a single\n   class-C\
    \ address [Almquist, Gross, 1992].\n"
- title: 2.3.2  Routing Table Growth
  contents:
  - "2.3.2  Routing Table Growth\n   Based on research conducted by the IESG in November\
    \ 1992, definite\n   routing table size explosion problems were identified. Namely,\
    \ it was\n   determined that current router technology at that point could support\n\
    \   a maximum of 16,000 routes, which in turn could support the internet\n   for\
    \ an additional 12 to 18 months (~May, 1994) at the then twofold\n   annual network\
    \ growth rate. However, vendor router maximum\n   capabilities were in the process\
    \ of being increased to 64,000 routes,\n   which at the two-fold annual network\
    \ growth rate, could bring us an\n   additional 2 years of lead time, (at best\
    \ bringing us to May, 1996,\n   and at worst to November, 1995) assuming the class-B\
    \ address\n   exhaustion problem mentioned above could be solved in the interim\n\
    \   [Almquist, Gross, 1992].\n   As a short term, incremental solution to this\
    \ routing table growth\n   problem, and to aid in the class-B address exhaustion\
    \ problem the\n   IESG endorsed the CIDR supernetting strategy proposal (see RFC-1338\n\
    \   for full details of this proposal). However, this strategy was\n   estimated\
    \ to have a viability of approximately 3 years, at which\n   point the internet\
    \ would run out of all classes of IP addresses in\n   general. Hence, it is clear\
    \ that even CIDR only offers temporary\n   relief. However, if implemented immediately,\
    \ CIDR can afford the\n   Internet community time to develop and deploy an approach\
    \ to\n   addressing and routing which allows scaling to orders of magnitude\n\
    \   larger than the current architecture (IPng).\n"
- title: 3.  The Problems with Change
  contents:
  - "3.  The Problems with Change\n   There are many problems, both philosophical\
    \ and technical, which\n   greatly contribute to the difficulties associated with\
    \ a large scale\n   change such as the one proposed in the conversion from IP\
    \ to IPng.\n   These problems range from having to rewrite highly utilized and\n\
    \   entrenched user applications, such as NFS, RPC, etc, to potentially\n   having\
    \ to invest additional capital to purchase hardware that\n   supports the new\
    \ protocol(s). This proposal solves the urgent\n   internet problems listed above,\
    \ while simultaneously limiting the\n   amounts of retraining and re- investing\
    \ that the user community would\n   have to undertake. The TCP layer will once\
    \ and for all be changed to\n   support a multiprotocol internet.  The net affect\
    \ is that while\n   administrators will necessarily be trained in the operations\
    \ and\n   details of this new TCP, the much larger operator and end user\n   community\
    \ will experience no perceptible change in service and\n   network usage.\n"
- title: 3.1  TCP/UDP Implementations
  contents:
  - "3.1  TCP/UDP Implementations\n   Both TCP and UDP are highly dependent on the\
    \ IPv4 network layer for 2\n   very low level reasons.  1) a TCP/UDP socket is\
    \ formed by\n   concatenating a network layer address (IP address) and the transport\n\
    \   layer TCP/UDP port number.  2) included in the TCP/UDP checksum\n   calculation\
    \ are the IP layer source and destination addresses\n   mentioned above which\
    \ are transferred across the TCP/IP [Postel,\n   1981b] or UDP/IP [Postel, 1980]\
    \ interfaces as procedure call\n   arguments. It should be noted at this point\
    \ that the reason for such\n   strong dependence between the transport and network\
    \ layers in TCP/IP\n   or UDP/IP is to insure a globally unique TCP/UDP layer\
    \ address, such\n   that a unique connection could be identified by a pair of\
    \ sockets.\n   The authors of this paper propose that the IP address requirement\n\
    \   with TCP and UDP be replaced with a globally unique transport address\n  \
    \ (TA) concatenated with a transport layer port address. This solution\n   offers\
    \ the capability to still maintain a globally unique address and\n   host unique\
    \ port number with the added benefit of eliminating the\n   transport and network\
    \ layer dependence on one another.\n"
- title: 3.2  User Applications
  contents:
  - "3.2  User Applications\n   In addition to TCP and UDP, there are a large number\
    \ of firmly\n   entrenched higher level applications that use the IP network layer\n\
    \   address embedded internally, and would therefore require modification\n  \
    \ for use with the proposed IPng network layer schemes. These\n   applications\
    \ include, but are not limited to Network File System\n   (NFS), Remote Procedure\
    \ Call (RPC), and File Transfer Protocol (FTP).\n   All of these applications\
    \ should be modified to use the Internet\n   Domain name to identify the remote\
    \ node, and not an embedded,\n   protocol dependent IP address.\n"
- title: 3.3  The Entrenched Masses
  contents:
  - "3.3  The Entrenched Masses\n   Will users voluntarily give up their IPv4 systems\
    \ to move to IPng?\n   It seems likely that many users will resist the change.\
    \  They will\n   perceive no benefit and will not install the new software.  Making\n\
    \   the local Internet contact responsible may not be feasible or\n   practical\
    \ in all cases. Another issue is backward compatibility\n   issues.  If a host\
    \ needs to run IPng and IPv4 to support old hosts,\n   then 1) where is the address\
    \ savings IPng promised.  2) Why change if\n   the host you are talking to has\
    \ IPv4 anyway?\n   On the other hand, replacing the existing TCP (TCPv6) with\
    \ this new\n   version (TCPng) will benefit users in several ways.  1) Users will\
    \ be\n   able to connect to unmodified TCPv6 hosts.  2) As nodes upgrade to\n\
    \   TCPng, new features will be enabled allowing TCP to communicate\n   effectively\
    \ over high bandwidth*delay network links.  3) System\n   administrators will\
    \ be able to incrementally upgrade nodes as needed\n   or as local conditions\
    \ demand.  4) Upgraded nodes may return their\n   IPv4 address and use an IPng\
    \ address and TCP transporter function,\n   described later, to communicate with\
    \ IPv4 hosts.\n"
- title: 4.  Making TCP & UDP Protocol Independent
  contents:
  - "4.  Making TCP & UDP Protocol Independent\n   The OSI 7 layer model specifies\
    \ that each layer be independent of the\n   adjacent layers. What is specified\
    \ is the interface between layers.\n   This allows layers to be replaced and/or\
    \ modified without making\n   changes to the other layers.  As was pointed out\
    \ previously, the TCP\n   and UDP transport layers violate this precept.  In the\
    \ following\n   discussion, when we refer to TCP we mean both the TCP and UDP\n\
    \   protocols.  The generic term transport layer and TCP will be used\n   interchangeably.\n\
    \   Overcoming TCP's dependence on IP will require changes to the\n   structure\
    \ of the TCP header.  The developers and implementors will\n   also have to change\
    \ the way they think about TCP and IP.  End users\n   will also have to change\
    \ the way they view the Internet.  Gone will\n   be the days when Internet node\
    \ names and IP addresses can be used\n   interchangeably.  The goal of this change\
    \ is to allow end users to\n   migrate from the current IPv4 network layer to\
    \ an IPng layer.  What\n   this IPng protocol is will be left to the Internet\
    \ Architecture\n   Board/Internet Engineering Steering Group/Internet Engineering\
    \ Task\n   Force (IAB/IESG/IETF) to decide.  By adopting this proposal, the\n\
    \   migration will be greatly enhanced.\n   One of the stated goals of the IAB\
    \ is to promote a single Internet\n   protocol suite [Leiner, Rekhter, 1993].\
    \  While this is a laudable\n   goal, we should not be blinded by it. The addition\
    \ of a Transport\n   layer address (TA) does not invalidate the IAB's stated goals.\
    \  It\n   merely brings the implementation into compliance with standard\n   networking\
    \ practices.  The historical reasons for concatenating TCP\n   port numbers to\
    \ IP numbers has long since passed. The increasing\n   throughput of transmission\
    \ lines and the negligible effect of packet\n   overhead (see appendix A) prove\
    \ this.  The details of assigning and\n   using TA's are discussed in the next\
    \ few sections.\n"
- title: 4.1  Transport Addressing
  contents:
  - "4.1  Transport Addressing\n   A Transport Address (TA) will be assigned to the\
    \ TCP transport layer\n   on each Internet node.  The purpose of this address\
    \ is to allow a TCP\n   on one node to communicate with a TCP on a remote node.\
    \  Some of the\n   goals defined in developing this address are:\n        1. \
    \ Fixed size -- A fixed size will make parsing easier for\n            decoding\
    \ stations.\n        2.  Minimum impact on TCP packet size -- This information\n\
    \            will need to be carried each TCP packet.\n        3.  Global Uniqueness\
    \ -- It is desirable (required) to have a\n            globally unique Transport\
    \ Address.\n        4.  Automatic Registration -- To reduce implementation\n \
    \           problems, an automatic registration of the TA is\n            desirable.\n\
    \   The TA will be used when an Internet node attempts to communicate\n   with\
    \ another Internet node.  Conceptually you can view the TA as\n   replacing the\
    \ IP number in every instance it now appears in the\n   transport layer (i.e.,\
    \ a socket would change from IP#.Port# to\n   TA#.Port#).  A connection setup\
    \ would thus be:\n        1.  A user starts an application on Node-A and requests\n\
    \            service from Node-B.  The user identifies Node-B by\n           \
    \ referencing it's Internet Domain Name.\n        2.  The TCP on Node-A makes\
    \ a Domain Name Service (DNS) call\n            to determine the TA of Node-B.\n\
    \        3.  Node-A constructs a TCP packet using the header Src = TA-\n     \
    \       A.port and Dest = TA-B.port and passes this packet down to\n         \
    \   the network layer.\n        4.  The IP on Node-A makes a DNS call to determine\
    \ the IP\n            address of Node-B.  The IP will cache this TA/IP pair for\n\
    \            later use.\n        5.  Node-A constructs an IP packet using the\
    \ header Src = IP-A\n            and Dest = IP-B and passes this packet down to\
    \ the Media\n            Access layer.\n        6.  Delivery of the packet is\
    \ identical to the delivery of an\n            existing Internet IP packet.\n\
    \        7.  The IP on Node-B examines the IP Dest address and if it\n       \
    \     matches it's own, strips off the header and passes the\n            data\
    \ portion up to the TCP.  (Note: the packet may have\n            passed through\
    \ several IP routers between the source and\n            destination hosts.)\n\
    \        8.  The TCP on Node-B examines the header to determine if the\n     \
    \       Dest TA is it's own, if so it passes the data to the\n            application\
    \ specified by the port address.  If not it\n            determines if it should\
    \ perform the transporter function.\n            The packet will be forwarded\
    \ toward the destination or an\n            error message will be returned.\n\
    \   The above steps represent a quick synopsis of how user applications\n   may\
    \ pass data between different Internet nodes.  The exact structure\n   of the\
    \ network is hidden from the application, allowing the network\n   to be modified\
    \ and improved as needed.  Using the transporter\n   function, several different\
    \ network layers may be traversed when\n   moving from source to destination (several\
    \ examples are provided in\n   appendix D).\n   One of the underlying assumptions\
    \ is that the user application must\n   refrain from making assumptions about\
    \ the network structure.  As\n   pointed out in section 3, this is not the case\
    \ for the current\n   Internet network.  User applications that are deployed with\
    \ this new\n   TCP must be capable of making this assumption.  This means that\
    \ the\n   user application should store the Internet Domain Name in it's\n   internal\
    \ structure instead of the IPng network number.  The domain\n   name is globally\
    \ unique and provides enough information to the system\n   to find the transport\
    \ and network layer addresses.  The user\n   application must pass the following\
    \ parameters down to TCP:\n      1.  Destination domain name  (Text string)\n\
    \      2.  Pointer to data buffer\n      3.  Quality of service indicators\n \
    \     4.  Options\n   When the user application writes data to the network, TCP\
    \ will return\n   a nonzero integer to indicate an error condition, or a zero\
    \ integer\n   to indicate success. When the user application reads data from the\n\
    \   network, TCP will deliver a pointer to a data buffer back to the\n   application.\n\
    \   TCP will receive the users request and it will make a DNS call to\n   determine\
    \ the destination nodes TA.  If DNS returns a TA, TCP will\n   build a Transmission\
    \ Control Block (TCB) (see the paragraph below)\n   and call the network layer.\
    \   Otherwise, TCP will make a DNS call\n   looking for the destination nodes\
    \ IPv4 address.  If an address is\n   returned, TCP will takes the steps listed\
    \ below in building a TCB,\n   and call the proper network layer.  If DNS returns\
    \ a host unknown\n   indication, exit back to the user with a \"host unknown\"\
    \ error.  TCP\n   should maintain a cache of domain names and addresses in lieu\
    \ of\n   making repeated DNS calls.  This feature is highly recommended, but\n\
    \   not required.\n   The state information needed to keep track of a TCP connection\
    \ is\n   kept in the Transmission Control Block (TCB).  Currently this\n   structure\
    \ has fields for the TCP parameters, source port, destination\n   port, window\
    \ size, sequence number, acknowledgment number, and any\n   TCP options.  The\
    \ network layer source and destination IP numbers are\n   also stored here.  Finally,\
    \ the status of the connection (LISTEN,\n   ESTABLISHED, CLOSING, of the TCP parameters\
    \ and include the new\n   source and destination Transport addresses.  The existing\
    \ space for\n   the IPv4 addresses will be left in place to allow for backward\n\
    \   compatibility.  The IPv4 fields will be used if the source is\n   communicating\
    \ directly with an unmodified TCP/IP host.\n   The existing status indicators\
    \ will remain with their meaning\n   unchanged.  Connection setup will retain\
    \ the current 3-way handshake.\n   When performing transporter functions, TCP\
    \ will NOT build a TCB,\n   unless the destination is an unmodified IPv4 host\
    \ (see appendix D).\n   The TCP connection remains an end-to-end reliable transport\
    \ service,\n   regardless of the number of intermediate transporter nodes.\n \
    \  TCP will build an old or new header (defined below) placing the user\n   application\
    \ data in the data field.  If TCP is communicating directly\n   with an unmodified\
    \ IPv4 host, the existing TCP header (STD 7, RFC\n   793) will be used for comparability\
    \ reasons.  If the destination host\n   is an unmodified host, and an intermediate\
    \ transporter node is being\n   used, this new TCP header must be used with the\
    \ 'C' bit set to 1.\n   The destination TA will be set to the IPv4 address, and\
    \ the packet\n   will be delivered to the transporter node.  If the destination\
    \ host\n   is modified with this new TCP, the destination address will be set\
    \ to\n   the TA and the packet will be delivered, possibly through a\n   transporter,\
    \ to the remote host.\n   TCP will communicate with it's underlying network layer(s)\
    \ to deliver\n   packets to remote hosts.  The Internet Assigned Number Authority\n\
    \   (IANA) will assign unique identifiers to each network layer TCP will\n   support.\
    \  TCP will maintain a cache of TA's and IANA network layers\n   numbers, to allow\
    \ support of multiple network layers.  When TCP\n   wishes to send data, it will\
    \ consult this cache to determine which\n   network to send the packet to.  If\
    \ the destination TA is not in this\n   cache, TCP will send a request to each\
    \ of it's network layer(s)\n   asking if they know how to deliver data to this\
    \ TA.  All of the\n   network layers supported by the sending host will be probed,\
    \ in an\n   order defined by the system administrator, until one responds 'yes'\n\
    \   or they all have said 'no'.  The first layer to say 'yes' will be\n   used.\
    \  If no path exists, an error message will be returned to the\n   user application.\
    \  Once a network layer is identified, TCP will\n   communicate with it by passing\
    \ the following parameters:\n          1)  Destination address (TA or IPv4).\n\
    \          2)  A pointer to the data buffer.\n          3)  Options.\n   The network\
    \ layer will use the destination address as an index into a\n   cache to determine\
    \ the network address to send to.  In the entry is\n   not in the cache, it will\
    \ make a DNS call to determine the network\n   address and a cache entry will\
    \ be build (see appendix D).  It is\n   mandatory that a cache be maintained.\
    \  If a host is attached to\n   several different networks (i.e., a transporter)\
    \ each layer will\n   maintain it's own cache.\n   When IP receives a data packet\
    \ from a remote node, it will strip off\n   the IP header and pass a pointer to\
    \ the data buffer up to TCP.  IP\n   will also supply TCP with it's IANA network\
    \ layer number.  TCP may\n   use the source TA and the IANA number to update it's\
    \ cache.\n   The structure of a TA is to concatenate a unique manufacture code\n\
    \   with a manufacturer defined variable to form a unique 64 bit number.\n   The\
    \ unique manufacture code will be a 24 bit number, possibly the\n   same code\
    \ as the IEEE 802.3 MAC address code.  The remaining 40 bits\n   will be supplied\
    \ by the manufacture to uniquely identify the TCP.  It\n   is recommended that\
    \ this field be built by encoding the\n   manufacturer's serial number.  An integer\
    \ serial number will be\n   viewed as an integer number and converted into it's\
    \ hexadecimal\n   equivalent, left padded with 00 octets if necessary.  If a serial\n\
    \   number contains Alpha characters, these alpha characters will be\n   converted\
    \ into octets using the international standard ASCII code.\n   The integer values\
    \ will then be converted to their hexadecimal\n   equivalent and the 2 values\
    \ will be concatenated to form the unique\n   identifier.  These structure will\
    \ allow 2^24 (16,777,216)\n   manufactures to build 2^40 (1,099,511,627,776) transport\
    \ addressable\n   entities. Each of these entities may have 1 or more network\n\
    \   interfaces using IPv4, IPng, or any other network layer protocol.\n   The\
    \ current growth of the Internet may indicate that this amount of\n   address\
    \ space is inadequate.  A larger fixed space (i.e., 96 or 128\n   bits) or a variable\
    \ length field may be required.  The disadvantage\n   is that this address must\
    \ be transmitted in every packet.\n"
- title: 4.2  TCPng
  contents:
  - "4.2  TCPng\n                      The new TCP header is as shown.\n         \
    \               1                   2                   3\n    0 1 2 3 4 5 6 7\
    \ 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                                                               |\n   +  \
    \                  Destination TA                             +\n   |        \
    \                                                       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                                                               |\n   +  \
    \                  Source TA                                  +\n   |        \
    \                                                       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                    Destination Port Number            |  ver  |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                    Source Port Number                 |  QoS  |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                    Window Size                                |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                                                               |\n   +  \
    \                  Sequence Number                            +\n   |        \
    \                                                       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                                                               |\n   +  \
    \                  Acknowledgment Number                      +\n   |        \
    \                                                       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |  data offset  |X|X|C|A|P|R|S|F|     Checksum                  |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   /                    Variable length option 1                   /\n   \\ \
    \                            :                                 \\\n   /      \
    \                       :                                 /\n   \\           \
    \        Variable length Option n                    \\\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                                 Figure 1\n   Destination TA:  64 bits.\n   \
    \        The Destination Transport Address.  The concatenation of\n          \
    \ the 24 bit IEEE assigned Ethernet address and the 40 bit\n           representation\
    \ of the machines serial number for the\n           remote node.\n   Source TA:\
    \  64 Bits.\n           The Source Transport Address.  The concatenation of the\n\
    \           24 bit IEEE assigned Ethernet address and the 40 bit\n           representation\
    \ of the machines serial number for the\n           local node.\n   Destination\
    \ Port Number:  28 Bits.\n           Identifies the specific application on the\
    \ remote node.\n   Ver:  4 bits.\n           Version number.  This is TCPng. \
    \ RFC 793\n           references 9 earlier editions of ARPA TCP.  The current\n\
    \           TCP is version 10.\n   Source Port Number:  28 Bits.\n           Identifies\
    \ the specific application on the local node.\n   QoS:  4 bits.\n           The\
    \ Quality of Service parameter may be set by the user\n           application\
    \ and passed down to a network layer that\n           supports different levels\
    \ of service.\n   Window:  32 Bits.\n           The number of data octets beginning\
    \ with the one\n           indicated in the acknowledgment field which the sender\n\
    \           of this segment is willing to accept.\n   Sequence Number:  64 Bits.\n\
    \         The sequence number of the first data octet in this segment\n      \
    \   (accept when the S bit is present). If S bit is on, the\n         sequence\
    \ number is the initial sequence number (ISN) and\n         the first data octet\
    \ is ISN+1.  (The ISN is computed using\n         the existing algorithm).\n \
    \  Acknowledgment Number:  64 Bits.\n           If the A bit is set, this field\
    \ contains the value of\n           the next sequence number the sender of this\
    \ segment is\n           expecting to receive.  Once a connection is established,\n\
    \           this is always sent.\n   Data Offset:  8 Bits.\n         This is the\
    \ number of 32 bit words in the TCP header.  This\n         indicates where the\
    \ data begins. The TCP header is an\n         integral number of 32 bit words\
    \ long.  The minimum value is\n         12 and the maximum is 256.  If options\
    \ are used, they must\n         pad out to a 32 bit boundary.\n   Flags:  8 Bits.\n\
    \           The A, P, R, S, and F flags carry the same meaning as in\n       \
    \    the current version of TCP.  They are:\n         1.  A = Ack, and acknowledgment\
    \ field significant\n         2.  P = Push, the push function\n         3.  R\
    \ = Reset, reset the connection\n         4.  S = Sync, synchronize sequence numbers\n\
    \         5.  F = Fin, No more data from sender\n         The C bit, C = Compatibility,\
    \  is used to indicate that one\n         end of the connection is an unmodified\
    \ TCP/IP host.  When\n         the C bit is set, all header values must conform\
    \ to the\n         TCPv6 specifications.  The source port, destination port,\n\
    \         and window size must be 16 bits and the Sequence and\n         Acknowledgment\
    \ numbers must be 32 bits.  These values are\n         stored in the lower half\
    \ of the proper area with null octet\n         pads filling out the rest of the\
    \ field.\n         The 2 X bits, X = Reserved,  are not defined and must be\n\
    \         ignored by a receiving TCP.\n   Checksum:  16 Bits.\n         The checksum\
    \ field has the same meaning as in the current\n         version of TCP.  The\
    \ current 96 bit pseudo header is NOT\n         used in calculating the checksum.\
    \  The checksum covers only\n         the information present in this header.\
    \  The checksum field\n         itself is set to zero for the calculation.\n \
    \  Variable Length Options:\n         There are two types of options, mandatory\
    \ and optional.  A\n         TCP must implement all known mandatory options. \
    \ It must\n         also be capable of ignoring all optional options it does\n\
    \         not know about.  This will allow new options to be\n         introduced\
    \ without the fear of damage caused by unknown\n         options.  An option field\
    \ must end on a 32 bit boundary.\n         If not, null octet pad characters will\
    \ be appended to the\n         right of the option.  The structure of an option\
    \ is shown\n         in figure 2 below:\n                        1           \
    \        2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0\
    \ 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |          Type                 |               Length          |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |        Option data                            |      pad      |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                                 Figure 2\n"
- title: 4.3  Mandatory Options
  contents:
  - "4.3  Mandatory Options\n   There are three mandatory options defined by this\
    \ implementation of\n   TCP. Each of these options is implemented using the structure\n\
    \   pictured in figure 2 above.\n   A description of each field follows:\n   Type:\
    \ 16 bits\n               The type field identifies the particular option.\n \
    \  Length: 16 bits\n               The length field represents the size of the\
    \ option\n               data to follow, in octets.\n   Option Data: Variable\
    \ Length\n               The option data is of variable length specified by\n\
    \               the length field, plus 0-3 bytes of zeros to pad to a\n      \
    \         32-bit boundary.\n   The following are the 3 mandatory options that\
    \ must be implemented:\n   Null: 8 bits\n         The null option, (type=0) is\
    \ represented by the bit\n         sequence [00000000], preceded by an additional\
    \ 8, zero\n         padding bits to fill out the full 16-bit type field. The\n\
    \         data may be of any size, including 0 bytes. The option may\n       \
    \  be used to force an option to be ignored.\n   Maximum Segment Size: 8 bits\n\
    \         The maximum segment size option, (type=1) is represented by\n      \
    \   the bit sequence [00000001] preceded by an additional 8,\n         zero padding\
    \ bits to fill out the full 16-bit type field.\n         If this option is present,\
    \ then it communicates the maximum\n         receive segment size at the TCP which\
    \ sends this segment.\n         This potion is mandatory if sent in the initial\
    \ connection\n         request (SYN). If it is sent on any other segment it is\n\
    \         advisory. The data is a 32-bit word specifying the segment\n       \
    \  size in octets [Ullmann, 1993].\n   Urgent Pointer: 8 bits\n         The urgent\
    \ pointer, (type=2) is represented by the bit\n         sequence [00000010] preceded\
    \ by an additional 8, zero\n         padding bits to fill out the full 16-bit\
    \ type field. This\n         option emulates the urgent field in TCPv6. The data\
    \ is a\n         64-bit sequence number identifying the last octet of urgent\n\
    \         data within the segment.\n"
- title: 4.4  Optional Options
  contents:
  - "4.4  Optional Options\n   This version of TCP must be capable of accepting any\
    \ unknown options.\n   This is to guarantee that when presented with an unrecognized\
    \ option,\n   TCP will not crash, however it must not reject or ignore any option.\n"
- title: 4.5  Compatibility Issues
  contents:
  - "4.5  Compatibility Issues\n   The Internet community has a large installed base\
    \ of IP users.  The\n   resources required to operate this network,  both people\
    \ and machine,\n   is enormous.  These resources will need to be preserved.  The\
    \ last\n   time a change like this took place, moving from NCP to TCP, there\n\
    \   were a few 100 nodes to deal with [Postel, 1981c].  A small close\n   knit\
    \ group of engineers managed the network and mandated a one year\n   migration\
    \ strategy.  Today there are millions of nodes and thousands\n   of administrators.\
    \  It will be impossible to convert any portion of\n   the Internet to a new protocol\
    \ without effecting the rest of the\n   community.\n   In the worst case, users\
    \ will lose communications with their peers as\n   some systems upgrade and others\
    \ do not.  In the current global\n   environment, this will not be tolerated.\
    \  Any attempt to simply\n   replace the current IPv4 protocol with a new IPng\
    \ protocol that does\n   not address compatibility issues is doomed to failure.\
    \  This\n   reasoning has recently been realized by Ullmann (CATNIP) and he\n\
    \   attempts to use translators to convert from one protocol to another\n   (i.e.,\
    \ CATNIP to IPv4).  The problem is what to do when incompatible\n   parameters\
    \ are encountered.  Also CATNIP would need to be replaced\n   every time a new\
    \ network layer protocol was developed.\n   This proposal attempts to solve these\
    \ problems by decoupling the\n   transport and network protocols.  By allowing\
    \ TCP to operate over\n   different network layer protocols, we will create a\
    \ more stable\n   environment.  New network layer protocols could be developed\
    \ and\n   implemented without requiring changes that are visible to the user\n\
    \   community.  As TCP packets flow from host-to-host they may use\n   several\
    \ different network layers, allowing users to communicate\n   without having to\
    \ worry about how the data is moved across the\n   underlying network.\n"
- title: 4.5.1  Backward Compatibility
  contents:
  - "4.5.1  Backward Compatibility\n   It may be said that the maturity of a software\
    \ package can be\n   determined by how much code is required to maintain compatibility\n\
    \   with previous versions.  With the current growth of the Internet,\n   backward\
    \ compatibility issues can not be dismissed or added in as an\n   after thought.\
    \  This version of TCP was designed with backward\n   compatibility in mind. When\
    \ the TCP communicates with an unmodified\n   IPv4 TCP/IP, it takes steps to insure\
    \ compatibility.  First off it\n   sets a bit in the header indicating that the\
    \ TCP parameters (ack,\n   seq, port numbers, and window size) use the TCPv6 values.\
    \  When\n   communicating directly with an unmodified host the existing TCP/IP\n\
    \   header is used.  Only existing TCP options may be sent as well.\n   The advantage\
    \ of this approach is that TCP transporter nodes will not\n   have to make decisions\
    \ about how to modify packets just passing\n   through.  It is up to the source\
    \ node to build a header that is\n   compatible before sending it.  This approach\
    \ will allow any new TCP\n   to contact and communicate with any unmodified IPv4\
    \ host.  The source\n   host may have an IPv4 address, or it may send data to\
    \ a transporter\n   for delivery.  The decision will be made based on the source\
    \ and\n   destination addresses.  During connection setup, the location of the\n\
    \   destination node is determined and the proper network layer is used\n   to\
    \ send data.\n   An existing IPv4 host will be capable of opening a connection\
    \ to any\n   new TCPng host that is directly connected to the network with an\
    \ IPv4\n   protocol stack.  If the TCPng host only has an IPng stack, the\n  \
    \ connection attempt will fail.  Some existing batch style services\n   (i.e.,\
    \ Simple Mail Transfer Protocol - SMTP) will continue to work\n   with the help\
    \ of transporters.  Interactive sessions (i.e., Telnet)\n   will fail.  Thus,\
    \ our new TCP is backward compatible, but the\n   existing IPv4 hosts are not\
    \ forward compatible.\n"
- title: 4.6  Level 4 Gateways
  contents:
  - "4.6  Level 4 Gateways\n   The ability to allow hosts with differing network layer\
    \ protocols to\n   communicate will be accomplished by using a transport layer\
    \ gateway\n   (called transporter in this paper).  The transporter works just\
    \ like\n   an IP router, receiving TCP packets from one network layer and\n  \
    \ transporting them over to another.  This switching is done by\n   examining\
    \ the packets source and destination TA's.  If a TCP packet\n   arrives with a\
    \ destination TA that differs from this hosts TA, and\n   the transporter functionality\
    \ is enabled, the packet should be\n   transported to another network layer. \
    \ In some cases, the receiving\n   node is a host and not a transporter (i.e.,\
    \ transporter functionality\n   disabled).  In this case the host will discard\
    \ the packet and return\n   a TCMP (see below) error message.\n   A transporter\
    \ is not responsible for reading or formatting the TCP\n   header of packets it\
    \ receives.  The header is simply examined to\n   determine where to deliver the\
    \ packet.  When forwarding, the packet\n   is sent to any of the network layers\
    \ the transporter supports.  The\n   exception is that the packet may not be presented\
    \ back to the network\n   it was received from. It is the responsibility of the\
    \ network layer\n   to destroy undeliverable packets.  If a transporter is unable\
    \ to\n   determine which network the packet should be forwarded to, the packet\n\
    \   is discarded and a TCMP message is generated and returned to the\n   original\
    \ source host.  Several examples of how transporting works are\n   presented in\
    \ appendix D.\n"
- title: 4.7  Error Conditions
  contents:
  - "4.7  Error Conditions\n   It is recognized that from time to time certain error\
    \ conditions will\n   occur at some intermediate transporter that will need to\
    \ be\n   communicated back to the source host.  To accomplish this a Transport\n\
    \   Control Message Protocol (TCMP) service facility will need to be\n   developed.\
    \  This protocol will model itself after the Internet\n   Control Message Protocol\
    \ (ICMP).  The operational details are\n   discussed in a separate TCMP document.\n"
- title: 5.  Advantages and Disadvantages of this approach
  contents:
  - "5.  Advantages and Disadvantages of this approach\n   This proposal offers the\
    \ Internet community several advantages.\n   First, TCPng will operate over multiple\
    \ network layer protocol\n   stacks.  Users will be able to select the stack(s)\
    \ that meets their\n   needs.  The problem of IPv4 address exhaustion will be\
    \ postponed as\n   sites move from IPv4 to IPng protocol stacks. Future IP3g protocol\n\
    \   stacks may be designed and deployed without major service\n   disruptions.\
    \  The increased size of the sequence, acknowledge, and\n   window fields will\
    \ allow applications to run effectively over high\n   bandwidth-delay network\
    \ links.  Lastly, TCPng will allow applications\n   to specify certain Quality\
    \ of Service (QoS) parameters which may be\n   used by some network layer protocols\
    \ (i.e., Asynchronous Transfer\n   Mode - ATM).\n   This protocol is not without\
    \ it's share of design compromises.  Among\n   these are a large packet header\
    \ increased in size from 5 to 12 long\n   words.  The addition of a TA means that\
    \ network administrators must\n   deal with yet another network number that must\
    \ be globally\n   maintained.  Multiple network protocols may add to the complexity\
    \ of\n   a site's network.  Lastly, is the TA address space large enough so we\n\
    \   will not have to rebuild TCP.\n"
- title: 6.  Conclusions
  contents:
  - "6.  Conclusions\n   In this paper, we have reviewed the current status of the\
    \ Internet\n   society s IPng initiative.  We were struck by the enormity of the\n\
    \   changes required by those proposals.  We felt that a different\n   approach\
    \ was needed to allow change to occur in a controlled manner.\n   This approach\
    \ calls for replacing the current TCP protocol with one\n   that does not require\
    \ a specific IP layer protocol.  Once this is in\n   place, various IPng protocols\
    \ may be developed and deployed as sites\n   require them.  Communications between\
    \ IPv4 and IPng hosts will be\n   maintained throughout the transition period.\
    \  Modified hosts will be\n   able to remove their IPv4 protocol stacks, while\
    \ maintaining\n   communications with unmodified hosts by using a TCP transporter.\n\
    \   The title of this paper \"Six Virtual Inches to the Left\" comes from a\n\
    \   talk the author once heard.  In this talk an engineer from Control\n   Data\
    \ Corporation (CDC) told a story of CDC's attempt to build a\n   cryogenically\
    \ cooled super computer.  The idea being that the power\n   consumption of such\
    \ a computer would be far lower then that of a\n   conventional super computer.\
    \  As the story goes, everyone thought\n   this was a great idea until someone\
    \ pointed out what the power\n   requirements of the cryo system were.  The result\
    \ was that all the\n   assumed power savings were consumed by the cryo system.\
    \  The\n   implication being that all the power requirements were not saved but\n\
    \   simply moved 6 feet from the CPU to the support equipment.  The moral\n  \
    \ being that the entire system should be analyzed instead of just one\n   small\
    \ piece.\n"
- title: References
  contents:
  - "References\n   [Postel, 1981a] Postel, J., \"Transmission Control Protocol -\
    \ DARPA\n   Internet Program Protocol Specification\", STD 7, RFC 793, DARPA,\n\
    \   September 1981.\n   [Halsal, 1992] Data Communications, Computer Networks,\
    \ and Open\n   Systems.\n   [Meyer, Zobrist, 1990] TCP/IP versus OSI, The Battle\
    \ of the\n   Network Standards, IEEE Potentials.\n   [Braden, et al, 1991] Clark,\
    \ D., Chapin, L., Cer, V., Braden, R., and\n   R. Hobby, \"Towards the Future\
    \ Internet Architecture\", RFC 1287,\n   MIT, BBN, CNRI, ISI, UCDavis, December\
    \ 1991.\n   [Dixon, 1993] Dixon, T., \"Comparison of Proposals for Next Version\
    \ of\n   IP\", RFC 1454, RARE, May 1993.\n   [Fuller, et al, 1992] Fuller, V.,\
    \ Li, T., Yu, J., and K. Varadhan,\n   \"Supernetting: an Address Assignment and\
    \ Aggregation Strategy\",\n   RFC 1338, BARRNet, cicso, Merit, OARnet, June 1992.\n\
    \   [Almquist, Gross, 1992] Gross, P., and P. Almquist, \"IESG\n   Deliberations\
    \ on Routing and Addressing\", RFC 1380, IESG Chair,\n   IESG Internet AD, November\
    \ 1992.\n   [Postel, 1981b] Postel, J., \"Transmission Control Protocol - DARPA\n\
    \   Internet Program Protocol Specification\", STD 7, RFC 793, DARPA,\n   September\
    \ 1981.\n   [Postel, 1980] Postel, J., \"User Datagram Protocol\", STD 6, RFC\
    \ 768,\n   USC/Information Sciences Institute, August 1980.\n   [Postel, 1981c]\
    \ Postel, J., \"NCP/TCP Transition Plan\", RFC 801,\n   USC/Information Sciences\
    \ Institute, November 1981.\n   [Leiner, Rekhter, 1993] Leiner, B., and Y. Rekhter,\
    \ \"The\n   Multi-Protocol Internet\" RFC 1560, USRA, IBM, December 1993.\n  \
    \ [Ullmann, 1993] Ullmann, R., \"TP/IX: The Next Internet\", RFC 1475,\n   Process\
    \ Software Corporation, June 1993.\n"
- title: Bibliography
  contents:
  - "Bibliography\n   Gilligan, Nordmark, and Hinden, \"The SIPP Interoperability\
    \ and\n   Transition Mechanism\", IPAE, 1993.\n   Jacobson, V., and R. Braden,\
    \ \"TCP Extensions for Long-Delay Paths\",\n   RFC 1072, LBL, USC/Information\
    \ Sciences Institute, October 1988.\n   Jacobson, V., Braden, R., and D. Borman,\
    \ \"TCP Extensions for High\n   Performance\", RFC 1323, LBL, USC/Information\
    \ Sciences Institute, Cray\n   Research, May 1992.\n   Jacobson, V., Braden, R.,\
    \ and L. Zhang, \"TCP Extension for High-Speed\n   Paths\", RFC 1185, LBL, USC/Information\
    \ Sciences Institute, PARC,\n   October 1990.\n   Leiner, B., and Y. Rekhter,\
    \ \"The Multiprotocol Internet\", RFC 1560,\n   USRA, IBM, December 1993.\n  \
    \ O'Malley, S., and L. Peterson, \"TCP Extensions Considered Harmful\",\n   RFC\
    \ 1263, University of Arizona, October 1991.\n   Westine, A., Smallberg, D., and\
    \ J. Postel, \"Summary of Smallberg\n   Surveys\", RFC 847, USC/Information Sciences\
    \ Institute, February 1983.\n"
- title: Appendix A
  contents:
  - "Appendix A\n   The minimum size of an ethernet frame is 64 bytes.  With the existing\n\
    \   TCP/IP protocol, a minimum size frame is 18 bytes (ethernet header &\n   trailer)\
    \ + 20 bytes (IP header) + 20 bytes (TCP header) for a total\n   of 58 bytes.\
    \  The transmitting station must add 6 null pad characters\n   to this frame to\
    \ make it conform to the 64 byte minimum.  This new\n   TCP will increase the\
    \ size of the TCP header to 48 bytes.\n   Subtracting 26 bytes (the old header\
    \ and pad characters) we are left\n   with 22 bytes or 176 bits.  The time it\
    \ takes to transmit these\n   additional bits is the impact of this new TCP. \
    \ The transmission time\n   for several types of media currently used is shown\
    \ in the table\n   below.  You will note that the increased times are all under\
    \ 20\n   micro-seconds for anything over T1 speeds.  User traffic patterns\n \
    \  vary of course but it is generally agreed that 80% of the traffic\n   stays\
    \ at the local site.  If this is true then the increased header\n   size has a\
    \ negligible impact on communications.\n      Media       Speed (Mbps)      Rate\
    \  (nsec/bit)  time (usec)\n      ------      ------------      ---------------\
    \   ----------\n        T1            1.544            647.7            144.00\n\
    \        T3           44.736             22.4              3.91\n        Enet\
    \         10.00             100.0             17.60\n        FDDI        100.00\
    \              10.0              1.76\n        OC-1         51.84            \
    \  19.3              3.40\n        OC-3        155.52               6.4      \
    \        1.13\n"
- title: Appendix B
  contents:
  - "Appendix B\n   In order to support the TA, new DNS entries will need to be created.\n\
    \   It is hoped that this function will be accomplished automatically.\n   When\
    \ a station is installed, the local DNS server is defined.  On\n   power up, the\
    \ station will contact this server and send it it's TA\n   and domain name.  A\
    \ server process will be listening for this type of\n   information, and it will\
    \ collect the data, run an authorization\n   check, and install the TA into the\
    \ DNS server.  The following entry\n   will be made.\n   node.sub.domain.name\
    \    IN     TA   xx.yy.zz.aa.bb.cc.dd.ee\n   ee.dd.cc.bb.aa.zz.yy.aa.in-addr.tcp\
    \ IN  PTR node.sub.domain.name.\n   Using these entries, along with the existing\
    \ DNS A records, a\n   requesting node can determine where the remote node is\
    \ located.  The\n   format xx.yy.zz is the IEEE assigned portion and aa.bb.cc.dd.ee\
    \ is\n   the encoded machine serial number as described in section 4.1.\n"
- title: Appendix C
  contents:
  - "Appendix C\n                          Proposed UDP Header\n                 \
    \       1                   2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1\
    \ 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                                                               |\n   +  \
    \                  Destination TA                             +\n   |        \
    \                                                       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                                                               |\n   +  \
    \                  Source TA                                  +\n   |        \
    \                                                       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                    Destination Port Number            |  ver  |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                    Source Port Number                 |  QoS  |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |          Length               |        Checksum               |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   /                             Data                              /\n   \\ \
    \                            :                                 \\\n   /      \
    \                       :                                 /\n   \\           \
    \                  :                                 \\\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   Destination TA:  64 bits.\n         The Destination Transport Address.  The\
    \ concatenation of\n         the 24 bit IEEE assigned Ethernet address and the\
    \ 40 bit\n         representation of the machines serial number for the remote\n\
    \         node.\n   Source TA:  64 Bits.\n         The Source Transport Address.\
    \  The concatenation of the 24\n         bit IEEE assigned Ethernet address and\
    \ the 40 bit\n         representation of the machines serial number for the local\n\
    \         node.\n   Destination Port Number:  28 Bits.\n         Identifies the\
    \ specific application on the remote node.\n   Ver:  4 bits.\n         This parameter\
    \ the UDP version number in use within this\n         packet.\n   Source Port\
    \ Number:  28 Bits.\n         Identifies the specific application on the local\
    \ node.\n   QoS:  4 bits.\n         The Quality of Service parameter may be set\
    \ by the user\n         application and passed down to a network layer that\n\
    \         supports different levels of service.\n   Length:  16 bits\n       \
    \  The length parameter represents the length of the data area\n         in octets.\
    \  This value will be set to zero if no data is\n         sent within this packet.\n\
    \   Checksum:  16 bits\n         The checksum parameter has the same meaning as\
    \ in the\n         current version of UDP.  The current 96 bit pseudo header\n\
    \         is NOT used in calculating the checksum.  The checksum\n         covers\
    \ only the information present in this header.  The\n         checksum field itself\
    \ is set to zero for the calculation.\n   Data: Variable\n         This is the\
    \ area in which the data for the datagram will be\n         sent.  The length\
    \ of this data in octets is specified by\n         the length parameter above.\n"
- title: Appendix D
  contents:
  - "Appendix D\n          ______                         ______\n         |     \
    \ |                       |      |\n         |  H1  |                       |\
    \  H2  |\n         |      |                       |      |\n         |______|\
    \                       |______|\n              \\                          /\
    \    \\\n               \\                        /      \\\n            =========================\
    \  /        \\\n           \"                         \"/         |\n        \
    \   \"       (SIPP)            \"          |\n           \"                  \
    \       \"          |\n           \"=========================\"          |\n \
    \                                               |\n                          \
    \         ====================\n                ______            \"         \
    \           \"\n               |      |           \"       CLNP         \"\n \
    \              |  H4  |           \"                    \"\n               | \
    \     |           \"====================\"\n               |______|          \
    \          |\n                     \\                     |\n                \
    \      \\                    |\n             ===================        ___|___\n\
    \            \"                  \"       |       |\n            \"          \
    \        \"-------|  H3   |\n            \"     IPv4         \"       |      \
    \ |\n            \"                  \"       |_______|\n            \"==================\"\
    \n   Example 1: H1 Wishes to Establish Communication with H4 (Refer to the\n \
    \  figure above.)\n      1.  A user on host H1 attempts to communicate with a\
    \ user\n          on host H4 by referencing H4 s fully qualified domain name.\n\
    \      2.  The TCP on H1 makes a DNS call to determine the TA\n          address\
    \ of H4.\n      3.  The DNS call returns only the IPv4 address since H4 is\n \
    \         determined to be an IPv4 only host.\n      4.  The H1 TCP builds a transmission\
    \ control block (TCB)\n          setting the C-Bit (compatibility) \"ON\" since\
    \ H4 is an IPv4\n          host.  Included in the TCB will also be DA = IP-H4,\
    \ SA =\n          TA1, DP = 1234, SP = 5000 and any state parameters\n       \
    \   describing the connection (port numbers are for example\n          purposes\
    \ only).\n      5.  The IP on H1 makes a DNS call to determine the network\n \
    \         IP address of H4 and correspondingly caches both the TA\n          address\
    \ from the TCP as well as the network IP address for\n          later use.\n \
    \     6.  The packet is now routed using standard SIPP procedures\n          to\
    \ H2 this is the only path H1 has to H4.\n      7.  H2 receives the packet from\
    \ H1.  The TCP on H2 checks\n          the destination TA of the packet and compares\
    \ it to its\n          own.  In this case it does not match, therefore the packet\n\
    \          should be forwarded.\n      8.  H2 s TCP will interrogate the supported\
    \ network\n          layer(s) and determines the packet must be forwarded to H3.\n\
    \      9.  The TCP must now pass the packet the CLNP network\n          layer.\
    \  The network layer checks its cache to determine if\n          there is a route\
    \ specified for DA = IP-H4 already in the\n          cache.  If so the cache entry\
    \ is used, if not an entry is\n          created.  H2 then routes the packet to\
    \ H3 via NA3a, which\n          is the network layer address for IP-H4.\n    \
    \  10.  H3 receives the packet from H2. The TCP on H3 checks\n           the destination\
    \ TA of the packet and compares it to its\n           own. Once again, it does\
    \ not match.\n      11.  H3, realizing that the destination address is an IPv4\n\
    \           host, and knowing that it itself is directly connected to\n      \
    \     the IPv4 network constructs an IPv4 compatible header.  H3\n           also\
    \ constructs a TCB to manage the IPv4 connection.\n      12.  The packet is sent\
    \ down to be routed to the IP using\n           standard IP routing procedures.\n\
    \      13.  H4 receives the packet at which point the IP on it\n           determines\
    \ that the destination address is its own and thus\n           proceeds to strip\
    \ off the IP header and pass the packet up\n           to the TCP layer.\n   \
    \   14.  The TCP layer than opens the corresponding IPV4_DP\n           port (2311)\
    \ which forms the first half of the connection to\n           the application.\n\
    \      15.  H4 will now reply with a connection accept message,\n           sending\
    \ the packet back to H3.\n      16.  H3 s TCP receives the packet and based on\
    \ information\n           in the TCB determines the packet should be delivered\
    \ to H1.\n           H3 uses the steps outlined above to route the packet back\n\
    \           through the network structure.\n   Example 2: H2 Wishes to Establish\
    \ Communication with H3 (Refer to the\n   figure above.)\n      1.  A user on\
    \ host H2 attempts to communicate with a user\n          on host H3 by referencing\
    \ H3 s fully qualified domain name.\n      2.  The TCP on H2 makes a DNS call\
    \ to determine the TA\n          address of H3.\n      3.  The DNS call returns\
    \ the TA address for H3.\n      4.  The H2 TCP builds a transmission control block\
    \ (TCB)\n          setting the C-Bit (compatibility) \"OFF\" since H3 is an IPng\n\
    \          host.  Included in the TCB will also be DA = TA3, SA = TA2,\n     \
    \     DP = 1111, SP = 2222 and any state parameters describing\n          the\
    \ connection (port numbers are for example purposes\n          only).\n      5.\
    \  The IPng on H2 makes a DNS call to determine the\n          network IPng address\
    \ of H3 and correspondingly caches both\n          the TA address from the TCP\
    \ as well as the network IPng\n          address for later use.\n      6.  The\
    \ packet is now routed to H3 over the IPng supported\n          on that network.\n\
    \      7.  H3 receives the packet from H2.  The TCP on H3 checks\n          the\
    \ destination TA of the packet and compares it to its\n          own.  In this\
    \ case it matches.\n      8.  H3 s TCP will construct a TCB and respond with an\
    \ open\n          accept message.\n      9.  H3 s TCP will interrogate the supported\
    \ network\n          layer(s) to determine the packet must be delivered to H2\n\
    \          using NA2b which is specified in its cache.\n"
- title: Security Considerations
  contents:
  - "Security Considerations\n   Security issues are not discussed in this memo.\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Richard Carlson\n   Argonne National Laboratory\n   Electronics\
    \ and Computing Technologies\n   Argonne,  IL  60439\n   Phone:  (708) 252-7289\n\
    \   EMail:  RACarlson@anl.gov\n   Domenic Ficarella\n   Motorola\n   Phone:  (708)\
    \ 632-4029\n   EMail:  ficarell@cpdmfg.cig.mot.com\n"
