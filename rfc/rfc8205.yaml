- title: __initial_text__
  contents:
  - '                     BGPsec Protocol Specification

    '
- title: Abstract
  contents:
  - "Abstract\n   This document describes BGPsec, an extension to the Border Gateway\n\
    \   Protocol (BGP) that provides security for the path of Autonomous\n   Systems\
    \ (ASes) through which a BGP UPDATE message passes.  BGPsec is\n   implemented\
    \ via an optional non-transitive BGP path attribute that\n   carries digital signatures\
    \ produced by each AS that propagates the\n   UPDATE message.  The digital signatures\
    \ provide confidence that every\n   AS on the path of ASes listed in the UPDATE\
    \ message has explicitly\n   authorized the advertisement of the route.\n"
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This is an Internet Standards Track document.\n   This\
    \ document is a product of the Internet Engineering Task Force\n   (IETF).  It\
    \ represents the consensus of the IETF community.  It has\n   received public\
    \ review and has been approved for publication by the\n   Internet Engineering\
    \ Steering Group (IESG).  Further information on\n   Internet Standards is available\
    \ in Section 2 of RFC 7841.\n   Information about the current status of this document,\
    \ any errata,\n   and how to provide feedback on it may be obtained at\n   https://www.rfc-editor.org/info/rfc8205.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (c) 2017 IETF Trust and the persons identified\
    \ as the\n   document authors.  All rights reserved.\n   This document is subject\
    \ to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n\
    \   (https://trustee.ietf.org/license-info) in effect on the date of\n   publication\
    \ of this document.  Please review these documents\n   carefully, as they describe\
    \ your rights and restrictions with respect\n   to this document.  Code Components\
    \ extracted from this document must\n   include Simplified BSD License text as\
    \ described in Section 4.e of\n   the Trust Legal Provisions and are provided\
    \ without warranty as\n   described in the Simplified BSD License.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1.  Introduction  . . . . . . . . . . . . . . . . . . .\
    \ . . . . .   3\n     1.1.  Requirements Language . . . . . . . . . . . . . .\
    \ . . . .   3\n   2.  BGPsec Negotiation  . . . . . . . . . . . . . . . . . .\
    \ . . .   3\n     2.1.  The BGPsec Capability . . . . . . . . . . . . . . . .\
    \ . .   4\n     2.2.  Negotiating BGPsec Support  . . . . . . . . . . . . . .\
    \ .   5\n   3.  The BGPsec_PATH Attribute . . . . . . . . . . . . . . . . . .\
    \   6\n     3.1.  Secure_Path . . . . . . . . . . . . . . . . . . . . . . .  \
    \ 8\n     3.2.  Signature_Block . . . . . . . . . . . . . . . . . . . . .  10\n\
    \   4.  BGPsec UPDATE Messages  . . . . . . . . . . . . . . . . . . .  11\n  \
    \   4.1.  General Guidance  . . . . . . . . . . . . . . . . . . . .  11\n    \
    \ 4.2.  Constructing the BGPsec_PATH Attribute  . . . . . . . . .  14\n     4.3.\
    \  Processing Instructions for Confederation Members . . . .  18\n     4.4.  Reconstructing\
    \ the AS_PATH Attribute  . . . . . . . . . .  19\n   5.  Processing a Received\
    \ BGPsec UPDATE Message . . . . . . . . .  21\n     5.1.  Overview of BGPsec Validation\
    \ . . . . . . . . . . . . . .  22\n     5.2.  Validation Algorithm  . . . . .\
    \ . . . . . . . . . . . . .  23\n   6.  Algorithms and Extensibility  . . . .\
    \ . . . . . . . . . . . .  27\n     6.1.  Algorithm Suite Considerations  . .\
    \ . . . . . . . . . . .  27\n     6.2.  Considerations for the SKI Size . . .\
    \ . . . . . . . . . .  28\n     6.3.  Extensibility Considerations  . . . . .\
    \ . . . . . . . . .  28\n   7.  Operations and Management Considerations  . .\
    \ . . . . . . . .  29\n     7.1.  Capability Negotiation Failure  . . . . . .\
    \ . . . . . . .  29\n     7.2.  Preventing Misuse of pCount=0 . . . . . . . .\
    \ . . . . . .  29\n     7.3.  Early Termination of Signature Verification . .\
    \ . . . . .  30\n     7.4.  Non-deterministic Signature Algorithms  . . . . .\
    \ . . . .  30\n     7.5.  Private AS Numbers  . . . . . . . . . . . . . . . .\
    \ . . .  30\n     7.6.  Robustness Considerations for Accessing RPKI Data . .\
    \ . .  32\n     7.7.  Graceful Restart  . . . . . . . . . . . . . . . . . . .\
    \ .  32\n     7.8.  Robustness of Secret Random Number in ECDSA . . . . . . .\
    \  32\n     7.9.  Incremental/Partial Deployment Considerations . . . . . .  33\n\
    \   8.  Security Considerations . . . . . . . . . . . . . . . . . . .  33\n  \
    \   8.1.  Security Guarantees . . . . . . . . . . . . . . . . . . .  33\n    \
    \ 8.2.  On the Removal of BGPsec Signatures . . . . . . . . . . .  34\n     8.3.\
    \  Mitigation of Denial-of-Service Attacks . . . . . . . . .  36\n     8.4.  Additional\
    \ Security Considerations  . . . . . . . . . . .  36\n   9.  IANA Considerations\
    \ . . . . . . . . . . . . . . . . . . . . .  38\n   10. References  . . . . .\
    \ . . . . . . . . . . . . . . . . . . . .  39\n     10.1.  Normative References\
    \ . . . . . . . . . . . . . . . . . .  39\n     10.2.  Informative References\
    \ . . . . . . . . . . . . . . . . .  41\n   Acknowledgements  . . . . . . . .\
    \ . . . . . . . . . . . . . . . .  43\n   Contributors  . . . . . . . . . . .\
    \ . . . . . . . . . . . . . . .  44\n   Authors' Addresses  . . . . . . . . .\
    \ . . . . . . . . . . . . . .  45\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   This document describes BGPsec, a mechanism for providing\
    \ path\n   security for Border Gateway Protocol (BGP) [RFC4271] route\n   advertisements.\
    \  That is, a BGP speaker who receives a valid BGPsec\n   UPDATE message has cryptographic\
    \ assurance that the advertised route\n   has the following property: every Autonomous\
    \ System (AS) on the path\n   of ASes listed in the UPDATE message has explicitly\
    \ authorized the\n   advertisement of the route to the subsequent AS in the path.\n\
    \   This document specifies an optional (non-transitive) BGP path\n   attribute,\
    \ BGPsec_PATH.  It also describes how a BGPsec-compliant BGP\n   speaker (referred\
    \ to hereafter as a BGPsec speaker) can generate,\n   propagate, and validate\
    \ BGP UPDATE messages containing this attribute\n   to obtain the above assurances.\n\
    \   BGPsec is intended to be used to supplement BGP origin validation\n   [RFC6483]\
    \ [RFC6811], and when used in conjunction with origin\n   validation, it is possible\
    \ to prevent a wide variety of route\n   hijacking attacks against BGP.\n   BGPsec\
    \ relies on the Resource Public Key Infrastructure (RPKI)\n   certificates that\
    \ attest to the allocation of AS number and IP\n   address resources.  (For more\
    \ information on the RPKI, see RFC 6480\n   [RFC6480] and the documents referenced\
    \ therein.)  Any BGPsec speaker\n   who wishes to send, to external (eBGP) peers,\
    \ BGP UPDATE messages\n   containing the BGPsec_PATH needs to possess a private\
    \ key associated\n   with an RPKI router certificate [RFC8209] that corresponds\
    \ to the\n   BGPsec speaker's AS number.  Note, however, that a BGPsec speaker\n\
    \   does not need such a certificate in order to validate received UPDATE\n  \
    \ messages containing the BGPsec_PATH attribute (see Section 5.2).\n"
- title: 1.1.  Requirements Language
  contents:
  - "1.1.  Requirements Language\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\"\
    , \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"\
    NOT RECOMMENDED\", \"MAY\", and\n   \"OPTIONAL\" in this document are to be interpreted\
    \ as described in\n   BCP 14 [RFC2119] [RFC8174] when, and only when, they appear\
    \ in all\n   capitals, as shown here.\n"
- title: 2.  BGPsec Negotiation
  contents:
  - "2.  BGPsec Negotiation\n   This document defines a BGP capability [RFC5492] that\
    \ allows a BGP\n   speaker to advertise to a neighbor the ability to send or to\
    \ receive\n   BGPsec UPDATE messages (i.e., UPDATE messages containing the\n \
    \  BGPsec_PATH attribute).\n"
- title: 2.1.  The BGPsec Capability
  contents:
  - "2.1.  The BGPsec Capability\n   This capability has capability code 7.\n   The\
    \ capability length for this capability MUST be set to 3.\n   The 3 octets of\
    \ the capability format are specified in Figure 1.\n                   0   1 \
    \  2   3      4      5   6   7\n                 +---------------------------------------+\n\
    \                 | Version          | Dir |  Unassigned  |\n                \
    \ +---------------------------------------+\n                 |              \
    \                         |\n                 +------           AFI          \
    \    -----+\n                 |                                       |\n    \
    \             +---------------------------------------+\n                    Figure\
    \ 1: BGPsec Capability Format\n   The first 4 bits of the first octet indicate\
    \ the version of BGPsec\n   for which the BGP speaker is advertising support.\
    \  This document\n   defines only BGPsec version 0 (all 4 bits set to 0).  Other\
    \ versions\n   of BGPsec may be defined in future documents.  A BGPsec speaker\
    \ MAY\n   advertise support for multiple versions of BGPsec by including\n   multiple\
    \ versions of the BGPsec capability in its BGP OPEN message.\n   The fifth bit\
    \ of the first octet is a Direction bit, which indicates\n   whether the BGP speaker\
    \ is advertising the capability to send BGPsec\n   UPDATE messages or receive\
    \ BGPsec UPDATE messages.  The BGP speaker\n   sets this bit to 0 to indicate\
    \ the capability to receive BGPsec\n   UPDATE messages.  The BGP speaker sets\
    \ this bit to 1 to indicate the\n   capability to send BGPsec UPDATE messages.\n\
    \   The remaining 3 bits of the first octet are unassigned and for future\n  \
    \ use.  These bits are set to 0 by the sender of the capability and\n   ignored\
    \ by the receiver of the capability.\n   The second and third octets contain the\
    \ 16-bit Address Family\n   Identifier (AFI), which indicates the address family\
    \ for which the\n   BGPsec speaker is advertising support for BGPsec.  This document\
    \ only\n   specifies BGPsec for use with two address families, IPv4 and IPv6,\n\
    \   with AFI values 1 and 2, respectively [IANA-AF].  BGPsec for use with\n  \
    \ other address families may be specified in future documents.\n"
- title: 2.2.  Negotiating BGPsec Support
  contents:
  - "2.2.  Negotiating BGPsec Support\n   In order to indicate that a BGP speaker\
    \ is willing to send BGPsec\n   UPDATE messages (for a particular address family),\
    \ a BGP speaker\n   sends the BGPsec capability (see Section 2.1) with the Direction\
    \ bit\n   (the fifth bit of the first octet) set to 1.  In order to indicate\n\
    \   that the speaker is willing to receive BGP UPDATE messages containing\n  \
    \ the BGPsec_PATH attribute (for a particular address family), a BGP\n   speaker\
    \ sends the BGPsec capability with the Direction bit set to 0.\n   In order to\
    \ advertise the capability to both send and receive BGPsec\n   UPDATE messages,\
    \ the BGP speaker sends two copies of the BGPsec\n   capability (one with the\
    \ Direction bit set to 0 and one with the\n   Direction bit set to 1).\n   Similarly,\
    \ if a BGP speaker wishes to use BGPsec with two different\n   address families\
    \ (i.e., IPv4 and IPv6) over the same BGP session,\n   then the speaker includes\
    \ two instances of this capability (one for\n   each address family) in the BGP\
    \ OPEN message.  A BGP speaker MUST NOT\n   announce BGPsec capability if it does\
    \ not support the BGP\n   multiprotocol extension [RFC4760].  Additionally, a\
    \ BGP speaker\n   MUST NOT advertise the capability of BGPsec support for a particular\n\
    \   AFI unless it has also advertised the multiprotocol extension\n   capability\
    \ for the same AFI [RFC4760].\n   In a BGPsec peering session, a peer is permitted\
    \ to send UPDATE\n   messages containing the BGPsec_PATH attribute if and only\
    \ if:\n   o  The given peer sent the BGPsec capability for a particular version\n\
    \      of BGPsec and a particular address family with the Direction bit\n    \
    \  set to 1, and\n   o  The other (receiving) peer sent the BGPsec capability\
    \ for the same\n      version of BGPsec and the same address family with the Direction\n\
    \      bit set to 0.\n   In such a session, it can be said that the use of the\
    \ particular\n   version of BGPsec has been negotiated for a particular address\n\
    \   family.  Traditional BGP UPDATE messages (i.e., unsigned, containing\n   the\
    \ AS_PATH attribute) MAY be sent within a session regardless of\n   whether or\
    \ not the use of BGPsec is successfully negotiated.\n   However, if BGPsec is\
    \ not successfully negotiated, then BGP UPDATE\n   messages containing the BGPsec_PATH\
    \ attribute MUST NOT be sent.\n   This document defines the behavior of implementations\
    \ in the case\n   where BGPsec version 0 is the only version that has been successfully\n\
    \   negotiated.  Any future document that specifies additional versions\n   of\
    \ BGPsec will need to specify behavior in the case that support for\n   multiple\
    \ versions is negotiated.\n   BGPsec cannot provide meaningful security guarantees\
    \ without support\n   for 4-byte AS numbers.  Therefore, any BGP speaker that\
    \ announces the\n   BGPsec capability, MUST also announce the capability for 4-byte\
    \ AS\n   support [RFC6793].  If a BGP speaker sends the BGPsec capability but\n\
    \   not the 4-byte AS support capability, then BGPsec has not been\n   successfully\
    \ negotiated, and UPDATE messages containing the\n   BGPsec_PATH attribute MUST\
    \ NOT be sent within such a session.\n"
- title: 3.  The BGPsec_PATH Attribute
  contents:
  - "3.  The BGPsec_PATH Attribute\n   The BGPsec_PATH attribute is an optional non-transitive\
    \ BGP path\n   attribute.\n   This document registers an attribute type code for\
    \ this attribute:\n   BGPsec_PATH (see Section 9).\n   The BGPsec_PATH attribute\
    \ carries the secured information regarding\n   the path of ASes through which\
    \ an UPDATE message passes.  This\n   includes the digital signatures used to\
    \ protect the path information.\n   The UPDATE messages that contain the BGPsec_PATH\
    \ attribute are\n   referred to as \"BGPsec UPDATE messages\".  The BGPsec_PATH\
    \ attribute\n   replaces the AS_PATH attribute in a BGPsec UPDATE message.  That\
    \ is,\n   UPDATE messages that contain the BGPsec_PATH attribute MUST NOT\n  \
    \ contain the AS_PATH attribute, and vice versa.\n   The BGPsec_PATH attribute\
    \ is made up of several parts.  The\n   high-level diagram in Figure 2 provides\
    \ an overview of the structure\n   of the BGPsec_PATH attribute.  (\"SKI\" as\
    \ used in Figure 2 means\n   \"Subject Key Identifier\".)\n        +---------------------------------------------------------+\n\
    \        |     +-----------------+                                 |\n       \
    \ |     |   Secure_Path   |                                 |\n        |     +-----------------+\
    \                                 |\n        |     |    pCount X     |       \
    \                          |\n        |     |    Flags X      |              \
    \                   |\n        |     |    AS X         |                     \
    \            |\n        |     |    pCount Y     |                            \
    \     |\n        |     |    Flags Y      |                                 |\n\
    \        |     |    AS Y         |                                 |\n       \
    \ |     |      ...        |                                 |\n        |     +-----------------+\
    \                                 |\n        |                               \
    \                          |\n        |   +---------------------+     +---------------------+\
    \   |\n        |   |  Signature_Block 1  |     |  Signature_Block 2  |   |\n \
    \       |   +---------------------+     +---------------------+   |\n        |\
    \   |  Algorithm Suite 1  |     |  Algorithm Suite 2  |   |\n        |   |  SKI\
    \ X1             |     |  SKI X2             |   |\n        |   |  Signature X1\
    \       |     |  Signature X2       |   |\n        |   |  SKI Y1             |\
    \     |  SKI Y2             |   |\n        |   |  Signature Y1       |     | \
    \ Signature Y2       |   |\n        |   |       ...           |     |       ....\
    \          |   |\n        |   +---------------------+     +---------------------+\
    \   |\n        |                                                         |\n \
    \       +---------------------------------------------------------+\n        \
    \ Figure 2: High-Level Diagram of the BGPsec_PATH Attribute\n   Figure 3 provides\
    \ the specification of the format for the BGPsec_PATH\n   attribute.\n       \
    \  +-------------------------------------------------------+\n         | Secure_Path\
    \                             (variable)    |\n         +-------------------------------------------------------+\n\
    \         | Sequence of one or two Signature_Blocks (variable)    |\n        \
    \ +-------------------------------------------------------+\n                \
    \  Figure 3: BGPsec_PATH Attribute Format\n   The Secure_Path contains AS path\
    \ information for the BGPsec UPDATE\n   message.  This is logically equivalent\
    \ to the information that is\n   contained in a non-BGPsec AS_PATH attribute.\
    \  The information in the\n   Secure_Path is used by BGPsec speakers in the same\
    \ way that\n   information from the AS_PATH is used by non-BGPsec speakers.  The\n\
    \   format of the Secure_Path is described below in Section 3.1.\n   The BGPsec_PATH\
    \ attribute will contain one or two Signature_Blocks,\n   each of which corresponds\
    \ to a different algorithm suite.  Each of\n   the Signature_Blocks will contain\
    \ a Signature Segment for each AS\n   number (i.e., Secure_Path Segment) in the\
    \ Secure_Path.  In the\n   most common case, the BGPsec_PATH attribute will contain\
    \ only a\n   single Signature_Block.  However, in order to enable a transition\n\
    \   from an old algorithm suite to a new algorithm suite (without a\n   flag day),\
    \ it will be necessary to include two Signature_Blocks (one\n   for the old algorithm\
    \ suite and one for the new algorithm suite)\n   during the transition period.\
    \  (See Section 6.1 for more discussion\n   of algorithm transitions.)  The format\
    \ of the Signature_Blocks is\n   described below in Section 3.2.\n"
- title: 3.1.  Secure_Path
  contents:
  - "3.1.  Secure_Path\n   A detailed description of the Secure_Path information in\
    \ the\n   BGPsec_PATH attribute is provided here.  The specification for the\n\
    \   Secure_Path field is provided in Figures 4 and 5.\n             +-----------------------------------------------+\n\
    \             | Secure_Path Length                 (2 octets) |\n            \
    \ +-----------------------------------------------+\n             | One or more\
    \ Secure_Path Segments   (variable) |\n             +-----------------------------------------------+\n\
    \                       Figure 4: Secure_Path Format\n   The Secure_Path Length\
    \ contains the length (in octets) of the entire\n   Secure_Path (including the\
    \ 2 octets used to express this length\n   field).  As explained below, each Secure_Path\
    \ Segment is 6 octets\n   long.  Note that this means the Secure_Path Length is\
    \ two greater\n   than six times the number of Secure_Path Segments (i.e., the\
    \ number\n   of AS numbers in the path).\n   The Secure_Path contains one Secure_Path\
    \ Segment (see Figure 5) for\n   each AS in the path to the originating AS of\
    \ the prefix specified in\n   the UPDATE message.  (Note: Repeated ASes are \"\
    compressed out\" using\n   the pCount field, as discussed below.)\n     +------------------------------------------------------+\n\
    \     | pCount         (1 octet)                             |\n     +------------------------------------------------------+\n\
    \     | Confed_Segment flag (1 bit) |  Unassigned (7 bits)   | (Flags)\n     +------------------------------------------------------+\n\
    \     | AS Number      (4 octets)                            |\n     +------------------------------------------------------+\n\
    \                   Figure 5: Secure_Path Segment Format\n   The AS Number (in\
    \ Figure 5) is the AS number of the BGP speaker that\n   added this Secure_Path\
    \ Segment to the BGPsec_PATH attribute.  (See\n   Section 4 for more information\
    \ on populating this field.)\n   The pCount field contains the number of repetitions\
    \ of the associated\n   AS number that the signature covers.  This field enables\
    \ a BGPsec\n   speaker to mimic the semantics of prepending multiple copies of\
    \ their\n   AS to the AS_PATH without requiring the speaker to generate multiple\n\
    \   signatures.  Note that Section 9.1.2.2 (\"Breaking Ties (Phase 2)\") in\n\
    \   [RFC4271] mentions the \"number of AS numbers\" in the AS_PATH\n   attribute\
    \ that is used in the route selection process.  This metric\n   (number of AS\
    \ numbers) is the same as the AS path length obtained in\n   BGPsec by summing\
    \ the pCount values in the BGPsec_PATH attribute.\n   The pCount field is also\
    \ useful in managing route servers (see\n   Section 4.2), AS confederations (see\
    \ Section 4.3), and AS Number\n   migrations (see [RFC8206] for details).\n  \
    \ The leftmost (i.e., the most significant) bit of the Flags field in\n   Figure\
    \ 5 is the Confed_Segment flag.  The Confed_Segment flag is set\n   to 1 to indicate\
    \ that the BGPsec speaker that constructed this\n   Secure_Path Segment is sending\
    \ the UPDATE message to a peer AS within\n   the same AS confederation [RFC5065].\
    \  (That is, a sequence of\n   consecutive Confed_Segment flags are set in a BGPsec\
    \ UPDATE message\n   whenever, in a non-BGPsec UPDATE message, an AS_PATH segment\
    \ of type\n   AS_CONFED_SEQUENCE occurs.)  In all other cases, the Confed_Segment\n\
    \   flag is set to 0.\n   The remaining 7 bits of the Flags field are unassigned.\
    \  They MUST be\n   set to 0 by the sender and ignored by the receiver.  Note,\
    \ however,\n   that the signature is computed over all 8 bits of the Flags field.\n\
    \   As stated earlier in Section 2.2, BGPsec peering requires that the\n   peering\
    \ ASes MUST each support 4-byte AS numbers.  Currently assigned\n   2-byte AS\
    \ numbers are converted into 4-byte AS numbers by setting the\n   two high-order\
    \ octets of the 4-octet field to 0 [RFC6793].\n"
- title: 3.2.  Signature_Block
  contents:
  - "3.2.  Signature_Block\n   A detailed description of the Signature_Blocks in the\
    \ BGPsec_PATH\n   attribute is provided here using Figures 6 and 7.\n        \
    \      +---------------------------------------------+\n              | Signature_Block\
    \ Length         (2 octets)   |\n              +---------------------------------------------+\n\
    \              | Algorithm Suite Identifier     (1 octet)    |\n             \
    \ +---------------------------------------------+\n              | Sequence of\
    \ Signature Segments (variable)   |\n              +---------------------------------------------+\n\
    \                     Figure 6: Signature_Block Format\n   The Signature_Block\
    \ Length in Figure 6 is the total number of octets\n   in the Signature_Block\
    \ (including the 2 octets used to express this\n   length field).\n   The Algorithm\
    \ Suite Identifier is a 1-octet identifier specifying the\n   digest algorithm\
    \ and digital signature algorithm used to produce the\n   digital signature in\
    \ each Signature Segment.  An IANA registry of\n   algorithm suite identifiers\
    \ for use in BGPsec is specified in the\n   BGPsec algorithms document [RFC8208].\n\
    \   A Signature_Block in Figure 6 has exactly one Signature Segment (see\n   Figure\
    \ 7) for each Secure_Path Segment in the Secure_Path portion of\n   the BGPsec_PATH\
    \ attribute (that is, one Signature Segment for each\n   distinct AS on the path\
    \ for the prefix in the UPDATE message).\n              +---------------------------------------------+\n\
    \              | Subject Key Identifier (SKI)  (20 octets)   |\n             \
    \ +---------------------------------------------+\n              | Signature Length\
    \              (2 octets)    |\n              +---------------------------------------------+\n\
    \              | Signature                     (variable)    |\n             \
    \ +---------------------------------------------+\n                    Figure\
    \ 7: Signature Segment Format\n   The Subject Key Identifier (SKI) field in Figure\
    \ 7 contains the value\n   in the Subject Key Identifier extension of the RPKI\
    \ router\n   certificate [RFC6487] that is used to verify the signature (see\n\
    \   Section 5 for details on the validity of BGPsec UPDATE messages).\n   The\
    \ SKI field has a fixed size of 20 octets.  See Section 6.2 for\n   considerations\
    \ for the SKI size.\n   The Signature Length field contains the size (in octets)\
    \ of the value\n   in the Signature field of the Signature Segment.\n   The Signature\
    \ field in Figure 7 contains a digital signature that\n   protects the prefix\
    \ and the BGPsec_PATH attribute (see Sections 4 and\n   5 for details on signature\
    \ generation and validation, respectively).\n"
- title: 4.  BGPsec UPDATE Messages
  contents:
  - "4.  BGPsec UPDATE Messages\n   Section 4.1 provides general guidance on the creation\
    \ of BGPsec\n   UPDATE messages -- that is, UPDATE messages containing the\n \
    \  BGPsec_PATH attribute.\n   Section 4.2 specifies how a BGPsec speaker generates\
    \ the BGPsec_PATH\n   attribute to include in a BGPsec UPDATE message.\n   Section\
    \ 4.3 contains special processing instructions for members of\n   an AS confederation\
    \ [RFC5065].  A BGPsec speaker that is not a member\n   of such a confederation\
    \ MUST NOT set the Confed_Segment flag in its\n   Secure_Path Segment (i.e., leave\
    \ the Confed_Segment flag at the\n   default value of 0) in all BGPsec UPDATE\
    \ messages it sends.\n   Section 4.4 contains instructions for reconstructing\
    \ the AS_PATH\n   attribute in cases where a BGPsec speaker receives an UPDATE\
    \ message\n   with a BGPsec_PATH attribute and wishes to propagate the UPDATE\n\
    \   message to a peer who does not support BGPsec.\n"
- title: 4.1.  General Guidance
  contents:
  - "4.1.  General Guidance\n   The information protected by the signature on a BGPsec\
    \ UPDATE message\n   includes the AS number of the peer to whom the UPDATE message\
    \ is\n   being sent.  Therefore, if a BGPsec speaker wishes to send a BGPsec\n\
    \   UPDATE message to multiple BGP peers, it MUST generate a separate\n   BGPsec\
    \ UPDATE message for each unique peer AS to whom the UPDATE\n   message is sent.\n\
    \   A BGPsec UPDATE message MUST advertise a route to only a single\n   prefix.\
    \  This is because a BGPsec speaker receiving an UPDATE message\n   with multiple\
    \ prefixes would be unable to construct a valid BGPsec\n   UPDATE message (i.e.,\
    \ valid path signatures) containing a subset of\n   the prefixes in the received\
    \ update.  If a BGPsec speaker wishes to\n   advertise routes to multiple prefixes,\
    \ then it MUST generate a\n   separate BGPsec UPDATE message for each prefix.\
    \  Additionally, a\n   BGPsec UPDATE message MUST use the MP_REACH_NLRI attribute\
    \ [RFC4760]\n   to encode the prefix.\n   The BGPsec_PATH attribute and the AS_PATH\
    \ attribute are mutually\n   exclusive.  That is, any UPDATE message containing\
    \ the BGPsec_PATH\n   attribute MUST NOT contain the AS_PATH attribute.  The information\n\
    \   that would be contained in the AS_PATH attribute is instead conveyed\n   in\
    \ the Secure_Path portion of the BGPsec_PATH attribute.\n   In order to create\
    \ or add a new signature to a BGPsec UPDATE message\n   with a given algorithm\
    \ suite, the BGPsec speaker MUST possess a\n   private key suitable for generating\
    \ signatures for this algorithm\n   suite.  Additionally, this private key must\
    \ correspond to the public\n   key in a valid RPKI end entity certificate whose\
    \ AS number resource\n   extension includes the BGPsec speaker's AS number [RFC8209].\
    \  Note\n   also that new signatures are only added to a BGPsec UPDATE message\n\
    \   when a BGPsec speaker is generating an UPDATE message to send to an\n   external\
    \ peer (i.e., when the AS number of the peer is not equal to\n   the BGPsec speaker's\
    \ own AS number).\n   The RPKI enables the legitimate holder of IP address prefix(es)\
    \ to\n   issue a signed object, called a Route Origin Authorization (ROA),\n \
    \  that authorizes a given AS to originate routes to a given set of\n   prefixes\
    \ (see RFC 6482 [RFC6482]).  It is expected that most Relying\n   Parties (RPs)\
    \ will utilize BGPsec in tandem with origin validation\n   (see RFC 6483 [RFC6483]\
    \ and RFC 6811 [RFC6811]).  Therefore, it is\n   RECOMMENDED that a BGPsec speaker\
    \ only originate a BGPsec UPDATE\n   message advertising a route for a given prefix\
    \ if there exists a\n   valid ROA authorizing the BGPsec speaker's AS to originate\
    \ routes to\n   this prefix.\n   If a BGPsec router has received only a non-BGPsec\
    \ UPDATE message\n   containing the AS_PATH attribute (instead of the BGPsec_PATH\n\
    \   attribute) from a peer for a given prefix, then it MUST NOT attach a\n   BGPsec_PATH\
    \ attribute when it propagates the UPDATE message.  (Note\n   that a BGPsec router\
    \ may also receive a non-BGPsec UPDATE message\n   from an internal peer without\
    \ the AS_PATH attribute, i.e., with just\n   the Network Layer Reachability Information\
    \ (NLRI) in it.  In that\n   case, the prefix is originating from that AS, and\
    \ if it is selected\n   for advertisement, the BGPsec speaker SHOULD attach a\
    \ BGPsec_PATH\n   attribute and send a signed route (for that prefix) to its external\n\
    \   BGPsec-speaking peers.)\n   Conversely, if a BGPsec router has received a\
    \ BGPsec UPDATE message\n   (with the BGPsec_PATH attribute) from a peer for a\
    \ given prefix and\n   it chooses to propagate that peer's route for the prefix,\
    \ then it\n   SHOULD propagate the route as a BGPsec UPDATE message containing\
    \ the\n   BGPsec_PATH attribute.\n   Note that removing BGPsec signatures (i.e.,\
    \ propagating a route\n   advertisement without the BGPsec_PATH attribute) has\
    \ significant\n   security ramifications.  (See Section 8 for a discussion of\
    \ the\n   security ramifications of removing BGPsec signatures.)  Therefore,\n\
    \   when a route advertisement is received via a BGPsec UPDATE message,\n   propagating\
    \ the route advertisement without the BGPsec_PATH attribute\n   is NOT RECOMMENDED,\
    \ unless the message is sent to a peer that did not\n   advertise the capability\
    \ to receive BGPsec UPDATE messages (see\n   Section 4.4).\n   Furthermore, note\
    \ that when a BGPsec speaker propagates a route\n   advertisement with the BGPsec_PATH\
    \ attribute, it is not attesting to\n   the validation state of the UPDATE message\
    \ it received.  (See\n   Section 8 for more discussion of the security semantics\
    \ of BGPsec\n   signatures.)\n   If the BGPsec speaker is producing an UPDATE\
    \ message that would, in\n   the absence of BGPsec, contain an AS_SET (e.g., the\
    \ BGPsec speaker is\n   performing proxy aggregation), then the BGPsec speaker\
    \ MUST NOT\n   include the BGPsec_PATH attribute.  In such a case, the BGPsec\n\
    \   speaker MUST remove any existing BGPsec_PATH in the received\n   advertisement(s)\
    \ for this prefix and produce a traditional\n   (non-BGPsec) UPDATE message. \
    \ It should be noted that BCP 172\n   [RFC6472] recommends against the use of\
    \ AS_SET and AS_CONFED_SET in\n   the AS_PATH of BGP UPDATE messages.\n   The\
    \ case where the BGPsec speaker sends a BGPsec UPDATE message to an\n   iBGP (internal\
    \ BGP) peer is quite simple.  When originating a new\n   route advertisement and\
    \ sending it to a BGPsec-capable iBGP peer, the\n   BGPsec speaker omits the BGPsec_PATH\
    \ attribute.  When originating a\n   new route advertisement and sending it to\
    \ a non-BGPsec iBGP peer, the\n   BGPsec speaker includes an empty AS_PATH attribute\
    \ in the UPDATE\n   message.  (An empty AS_PATH attribute is one whose length\
    \ field\n   contains the value 0 [RFC4271].)  When a BGPsec speaker chooses to\n\
    \   forward a BGPsec UPDATE message to an iBGP peer, the BGPsec_PATH\n   attribute\
    \ SHOULD NOT be removed, unless the peer doesn't support\n   BGPsec.  In the case\
    \ when an iBGP peer doesn't support BGPsec, then a\n   BGP UPDATE message with\
    \ AS_PATH is reconstructed from the BGPsec\n   UPDATE message and then forwarded\
    \ (see Section 4.4).  In particular,\n   when forwarding to a BGPsec-capable iBGP\
    \ (or eBGP) peer, the\n   BGPsec_PATH attribute SHOULD NOT be removed even in\
    \ the case where\n   the BGPsec UPDATE message has not been successfully validated.\
    \  (See\n   Section 5 for more information on validation and Section 8 for the\n\
    \   security ramifications of removing BGPsec signatures.)\n   All BGPsec UPDATE\
    \ messages MUST conform to BGP's maximum message\n   size.  If the resulting message\
    \ exceeds the maximum message size,\n   then the guidelines in Section 9.2 of\
    \ RFC 4271 [RFC4271] MUST be\n   followed.\n"
- title: 4.2.  Constructing the BGPsec_PATH Attribute
  contents:
  - "4.2.  Constructing the BGPsec_PATH Attribute\n   When a BGPsec speaker receives\
    \ a BGPsec UPDATE message containing a\n   BGPsec_PATH attribute (with one or\
    \ more signatures) from an (internal\n   or external) peer, it may choose to propagate\
    \ the route advertisement\n   by sending it to its other (internal or external)\
    \ peers.  When\n   sending the route advertisement to an internal BGPsec-speaking\
    \ peer,\n   the BGPsec_PATH attribute SHALL NOT be modified.  When sending the\n\
    \   route advertisement to an external BGPsec-speaking peer, the\n   following\
    \ procedures are used to form or update the BGPsec_PATH\n   attribute.\n   To\
    \ generate the BGPsec_PATH attribute on the outgoing UPDATE message,\n   the BGPsec\
    \ speaker first generates a new Secure_Path Segment.  Note\n   that if the BGPsec\
    \ speaker is not the origin AS and there is an\n   existing BGPsec_PATH attribute,\
    \ then the BGPsec speaker prepends its\n   new Secure_Path Segment (places in\
    \ first position) onto the existing\n   Secure_Path.\n   The AS number in this\
    \ Secure_Path Segment MUST match the AS number in\n   the Subject field of the\
    \ RPKI router certificate that will be used to\n   verify the digital signature\
    \ constructed by this BGPsec speaker (see\n   Section 3.1.1 in [RFC8209] and RFC\
    \ 6487 [RFC6487]).\n   The pCount field of the Secure_Path Segment is typically\
    \ set to the\n   value 1.  However, a BGPsec speaker may set the pCount field\
    \ to a\n   value greater than 1.  Setting the pCount field to a value greater\n\
    \   than 1 has the same semantics as repeating an AS number multiple\n   times\
    \ in the AS_PATH of a non-BGPsec UPDATE message (e.g., for\n   traffic engineering\
    \ purposes).\n   To prevent unnecessary processing load in the validation of BGPsec\n\
    \   signatures, a BGPsec speaker SHOULD NOT produce multiple consecutive\n   Secure_Path\
    \ Segments with the same AS number.  This means that to\n   achieve the semantics\
    \ of prepending the same AS number k times, a\n   BGPsec speaker SHOULD produce\
    \ a single Secure_Path Segment -- with a\n   pCount of k -- and a single corresponding\
    \ Signature Segment.\n   A route server that participates in the BGP control plane\
    \ but\n   does not act as a transit AS in the data plane may choose to set\n \
    \  pCount to 0.  This option enables the route server to participate in\n   BGPsec\
    \ and obtain the associated security guarantees without\n   increasing the length\
    \ of the AS path.  (Note that BGPsec speakers\n   compute the length of the AS\
    \ path by summing the pCount values in the\n   BGPsec_PATH attribute; see Section\
    \ 5.)  However, when a route server\n   sets the pCount value to 0, it still inserts\
    \ its AS number into the\n   Secure_Path Segment, as this information is needed\
    \ to validate the\n   signature added by the route server.  See [RFC8206] for\
    \ a discussion\n   of setting pCount to 0 to facilitate AS Number migration. \
    \ Also, see\n   Section 4.3 for the use of pCount=0 in the context of an AS\n\
    \   confederation.  See Section 7.2 for operational guidance for\n   configuring\
    \ a BGPsec router for setting pCount=0 and/or accepting\n   pCount=0 from a peer.\n\
    \   Next, the BGPsec speaker generates one or two Signature_Blocks.\n   Typically,\
    \ a BGPsec speaker will use only a single algorithm suite\n   and thus create\
    \ only a single Signature_Block in the BGPsec_PATH\n   attribute.  However, to\
    \ ensure backwards compatibility during a\n   period of transition from a 'current'\
    \ algorithm suite to a 'new'\n   algorithm suite, it will be necessary to originate\
    \ UPDATE messages\n   that contain a Signature_Block for both the 'current' and\
    \ the 'new'\n   algorithm suites (see Section 6.1).\n   If the received BGPsec\
    \ UPDATE message contains two Signature_Blocks\n   and the BGPsec speaker supports\
    \ both of the corresponding algorithm\n   suites, then the new UPDATE message\
    \ generated by the BGPsec speaker\n   MUST include both of the Signature_Blocks.\
    \  If the received BGPsec\n   UPDATE message contains two Signature_Blocks and\
    \ the BGPsec speaker\n   only supports one of the two corresponding algorithm\
    \ suites, then the\n   BGPsec speaker MUST remove the Signature_Block corresponding\
    \ to the\n   algorithm suite that it does not understand.  If the BGPsec speaker\n\
    \   does not support the algorithm suites in any of the Signature_Blocks\n   contained\
    \ in the received UPDATE message, then the BGPsec speaker\n   MUST NOT propagate\
    \ the route advertisement with the BGPsec_PATH\n   attribute.  (That is, if it\
    \ chooses to propagate this route\n   advertisement at all, it MUST do so as an\
    \ unsigned BGP UPDATE\n   message.  See Section 4.4 for more information on converting\
    \ to an\n   unsigned BGP UPDATE message.)\n   Note that in the case where the\
    \ BGPsec_PATH has two Signature_Blocks\n   (corresponding to different algorithm\
    \ suites), the validation\n   algorithm (see Section 5.2) deems a BGPsec UPDATE\
    \ message to be\n   'Valid' if there is at least one supported algorithm suite\
    \ (and\n   corresponding Signature_Block) that is deemed 'Valid'.  This means\n\
    \   that a 'Valid' BGPsec UPDATE message may contain a Signature_Block\n   that\
    \ is not deemed 'Valid' (e.g., contains signatures that BGPsec\n   does not successfully\
    \ verify).  Nonetheless, such Signature_Blocks\n   MUST NOT be removed.  (See\
    \ Section 8 for a discussion of the security\n   ramifications of this design\
    \ choice.)\n   For each Signature_Block corresponding to an algorithm suite that\
    \ the\n   BGPsec speaker does support, the BGPsec speaker MUST add a new\n   Signature\
    \ Segment to the Signature_Block.  This Signature Segment is\n   prepended to\
    \ the list of Signature Segments (placed in the first\n   position) so that the\
    \ list of Signature Segments appears in the same\n   order as the corresponding\
    \ Secure_Path Segments.  The BGPsec speaker\n   populates the fields of this new\
    \ Signature Segment as follows.\n   The Subject Key Identifier field in the new\
    \ segment is populated with\n   the identifier contained in the Subject Key Identifier\
    \ extension of\n   the RPKI router certificate corresponding to the BGPsec speaker\n\
    \   [RFC8209].  This Subject Key Identifier will be used by recipients of\n  \
    \ the route advertisement to identify the proper certificate to use in\n   verifying\
    \ the signature.\n   The Signature field in the new segment contains a digital\
    \ signature\n   that binds the prefix and BGPsec_PATH attribute to the RPKI router\n\
    \   certificate corresponding to the BGPsec speaker.  The digital\n   signature\
    \ is computed as follows:\n   o  For clarity, let us number the Secure_Path and\
    \ corresponding\n      Signature Segments from 1 to N, as follows.  Let Secure_Path\n\
    \      Segment 1 and Signature Segment 1 be the segments produced by the\n   \
    \   origin AS.  Let Secure_Path Segment 2 and Signature Segment 2 be\n      the\
    \ segments added by the next AS after the origin.  Continue this\n      method\
    \ of numbering, and ultimately let Secure_Path Segment N and\n      Signature\
    \ Segment N be those that are being added by the current\n      AS.  The current\
    \ AS (Nth AS) is signing and forwarding the UPDATE\n      message to the next\
    \ AS (i.e., the (N+1)th AS) in the chain of ASes\n      that form the AS path.\n\
    \   o  In order to construct the digital signature for Signature\n      Segment\
    \ N (the Signature Segment being produced by the current\n      AS), first construct\
    \ the sequence of octets to be hashed as shown\n      in Figure 8.  This sequence\
    \ of octets includes all the data that\n      the Nth AS attests to by adding\
    \ its digital signature in the\n      UPDATE message that is being forwarded to\
    \ a BGPsec speaker in the\n      (N+1)th AS.  (For the design rationale for choosing\
    \ the specific\n      structure in Figure 8, please see [Borchert].)\n       \
    \        +------------------------------------+\n               | Target AS Number\
    \                   |\n               +------------------------------------+----\\\
    \n               | Signature Segment   : N-1          |     \\\n             \
    \  +------------------------------------+     |\n               | Secure_Path\
    \ Segment : N            |     |\n               +------------------------------------+\
    \     \\\n                      ...                                  >  Data from\n\
    \               +------------------------------------+     /   N Segments\n  \
    \             | Signature Segment   : 1            |     |\n               +------------------------------------+\
    \     |\n               | Secure_Path Segment : 2            |     |\n       \
    \        +------------------------------------+     /\n               | Secure_Path\
    \ Segment : 1            |    /\n               +------------------------------------+---/\n\
    \               | Algorithm Suite Identifier         |\n               +------------------------------------+\n\
    \               | AFI                                |\n               +------------------------------------+\n\
    \               | SAFI                               |\n               +------------------------------------+\n\
    \               | NLRI                               |\n               +------------------------------------+\n\
    \                 Figure 8: Sequence of Octets to Be Hashed\n      The elements\
    \ in this sequence (Figure 8) MUST be ordered exactly\n      as shown.  The 'Target\
    \ AS Number' is the AS to whom the BGPsec\n      speaker intends to send the UPDATE\
    \ message.  (Note that the\n      'Target AS Number' is the AS number announced\
    \ by the peer in the\n      OPEN message of the BGP session within which the UPDATE\
    \ message is\n      sent.)  The Secure_Path and Signature Segments (1 through\
    \ N-1) are\n      obtained from the BGPsec_PATH attribute.  Finally, the Address\n\
    \      Family Identifier (AFI), Subsequent Address Family Identifier\n      (SAFI),\
    \ and NLRI fields are obtained from the MP_REACH_NLRI\n      attribute [RFC4760].\
    \  Additionally, in the Prefix field within the\n      NLRI field (see Section\
    \ 5 in RFC 4760 [RFC4760]), all of the\n      trailing bits MUST be set to 0 when\
    \ constructing this sequence.\n   o  Apply to this octet sequence (in Figure 8)\
    \ the digest algorithm\n      (for the algorithm suite of this Signature_Block)\
    \ to obtain a\n      digest value.\n   o  Apply to this digest value the signature\
    \ algorithm (for the\n      algorithm suite of this Signature_Block) to obtain\
    \ the digital\n      signature.  Then populate the Signature field (in Figure\
    \ 7) with\n      this digital signature.\n   The Signature Length field (in Figure\
    \ 7) is populated with the length\n   (in octets) of the value in the Signature\
    \ field.\n"
- title: 4.3.  Processing Instructions for Confederation Members
  contents:
  - "4.3.  Processing Instructions for Confederation Members\n   Members of AS confederations\
    \ [RFC5065] MUST additionally follow the\n   instructions in this section for\
    \ processing BGPsec UPDATE messages.\n   When a BGPsec speaker in an AS confederation\
    \ receives a BGPsec UPDATE\n   message from a peer that is external to the confederation\
    \ and chooses\n   to propagate the UPDATE message within the confederation, it\
    \ first\n   adds a signature signed to its own Member-AS (i.e., the 'Target AS\n\
    \   Number' is the BGPsec speaker's Member-AS Number).  In this\n   internally\
    \ modified UPDATE message, the newly added Secure_Path\n   Segment contains the\
    \ public AS number (i.e., Confederation\n   Identifier), the segment's pCount\
    \ value is set to 0, and\n   Confed_Segment flag is set to 1.  Setting pCount=0\
    \ in this case helps\n   ensure that the AS path length is not unnecessarily incremented.\
    \  The\n   newly added signature is generated using a private key corresponding\n\
    \   to the public AS number of the confederation.  The BGPsec speaker\n   propagates\
    \ the modified UPDATE message to its peers within the\n   confederation.\n   Any\
    \ BGPsec_PATH modifications mentioned below in the context of\n   propagation\
    \ of the UPDATE message within the confederation are in\n   addition to the modification\
    \ described above (i.e., with pCount=0).\n   When a BGPsec speaker sends a BGPsec\
    \ UPDATE message to a peer that\n   belongs within its own Member-AS, the confederation\
    \ member SHALL NOT\n   modify the BGPsec_PATH attribute.  When a BGPsec speaker\
    \ sends a\n   BGPsec UPDATE message to a peer that is within the same confederation\n\
    \   but in a different Member-AS, the BGPsec speaker puts its Member-AS\n   Number\
    \ in the AS Number field of the Secure_Path Segment that it adds\n   to the BGPsec\
    \ UPDATE message.  Additionally, in this case, the\n   Member-AS that generates\
    \ the Secure_Path Segment sets the\n   Confed_Segment flag to 1.  Further, the\
    \ signature is generated with a\n   private key corresponding to the BGPsec speaker's\
    \ Member-AS Number.\n   (Note: In this document, intra-Member-AS peering is regarded\
    \ as iBGP,\n   and inter-Member-AS peering is regarded as eBGP.  The latter is\
    \ also\n   known as confederation-eBGP.)\n   Within a confederation, the verification\
    \ of BGPsec signatures added\n   by other members of the confederation is optional.\
    \  Note that if a\n   confederation chooses not to verify digital signatures within\
    \ the\n   confederation, then BGPsec is not able to provide any assurances\n \
    \  about the integrity of the Member-AS Numbers placed in Secure_Path\n   Segments\
    \ where the Confed_Segment flag is set to 1.\n   When a confederation member receives\
    \ a BGPsec UPDATE message from a\n   peer within the confederation and propagates\
    \ it to a peer outside the\n   confederation, it needs to remove all of the Secure_Path\
    \ Segments\n   added by confederation members as well as the corresponding Signature\n\
    \   Segments.  To do this, the confederation member propagating the route\n  \
    \ outside the confederation does the following:\n   o  First, starting with the\
    \ most recently added Secure_Path Segment,\n      remove all of the consecutive\
    \ Secure_Path Segments that have the\n      Confed_Segment flag set to 1.  Stop\
    \ this process once a\n      Secure_Path Segment that has its Confed_Segment flag\
    \ set to 0 is\n      reached.  Keep a count of the number of segments removed\
    \ in this\n      fashion.\n   o  Second, starting with the most recently added\
    \ Signature Segment,\n      remove a number of Signature Segments equal to the\
    \ number of\n      Secure_Path Segments removed in the previous step.  (That is,\n\
    \      remove the K most recently added Signature Segments, where K is\n     \
    \ the number of Secure_Path Segments removed in the previous step.)\n   o  Finally,\
    \ add a Secure_Path Segment containing, in the AS field,\n      the AS Confederation\
    \ Identifier (the public AS number of the\n      confederation) as well as a corresponding\
    \ Signature Segment.  Note\n      that all fields other than the AS field are\
    \ populated as per\n      Section 4.2.\n   Finally, as discussed above, an AS\
    \ confederation MAY optionally\n   decide that its members will not verify digital\
    \ signatures added by\n   members.  In such a confederation, when a BGPsec speaker\
    \ runs the\n   algorithm in Section 5.2, the BGPsec speaker, during the process\
    \ of\n   signature verifications, first checks whether the Confed_Segment flag\n\
    \   in a Secure_Path Segment is set to 1.  If the flag is set to 1, the\n   BGPsec\
    \ speaker skips the verification for the corresponding signature\n   and immediately\
    \ moves on to the next Secure_Path Segment.  Note that\n   as specified in Section\
    \ 5.2, it is an error when a BGPsec speaker\n   receives, from a peer who is not\
    \ in the same AS confederation, a\n   BGPsec UPDATE message containing a Confed_Segment\
    \ flag set to 1.\n"
- title: 4.4.  Reconstructing the AS_PATH Attribute
  contents:
  - "4.4.  Reconstructing the AS_PATH Attribute\n   BGPsec UPDATE messages do not\
    \ contain the AS_PATH attribute.\n   However, the AS_PATH attribute can be reconstructed\
    \ from the\n   BGPsec_PATH attribute.  This is necessary in the case where a route\n\
    \   advertisement is received via a BGPsec UPDATE message and then\n   propagated\
    \ to a peer via a non-BGPsec UPDATE message (e.g., because\n   the latter peer\
    \ does not support BGPsec).  Note that there may be\n   additional cases where\
    \ an implementation finds it useful to perform\n   this reconstruction.  Before\
    \ attempting to reconstruct an AS_PATH for\n   the purpose of forwarding an unsigned\
    \ (non-BGPsec) UPDATE message to\n   a peer, a BGPsec speaker MUST perform the\
    \ basic integrity checks\n   listed in Section 5.2 to ensure that the received\
    \ BGPsec UPDATE\n   message is properly formed.\n   The AS_PATH attribute can\
    \ be constructed from the BGPsec_PATH\n   attribute as follows.  Starting with\
    \ a blank AS_PATH attribute,\n   process the Secure_Path Segments in order from\
    \ least recently added\n   (corresponding to the origin) to most recently added.\
    \  For each\n   Secure_Path Segment, perform the following steps:\n   1.  If the\
    \ Secure_Path Segment has pCount=0, then do nothing (i.e.,\n       move on to\
    \ process the next Secure_Path Segment).\n   2.  If the Secure_Path Segment has\
    \ pCount greater than 0 and the\n       Confed_Segment flag is set to 1, then\
    \ look at the most recently\n       added segment in the AS_PATH.\n       *  In\
    \ the case where the AS_PATH is blank or in the case where\n          the most\
    \ recently added segment is of type AS_SEQUENCE, add\n          (prepend to the\
    \ AS_PATH) a new AS_PATH segment of type\n          AS_CONFED_SEQUENCE.  This\
    \ segment of type AS_CONFED_SEQUENCE\n          shall contain a number of elements\
    \ equal to the pCount field\n          in the current Secure_Path Segment.  Each\
    \ of these elements\n          shall be the AS number contained in the current\
    \ Secure_Path\n          Segment.  (That is, if the pCount field is X, then the\
    \ segment\n          of type AS_CONFED_SEQUENCE contains X copies of the\n   \
    \       Secure_Path Segment's AS Number field.)\n       *  In the case where the\
    \ most recently added segment in the\n          AS_PATH is of type AS_CONFED_SEQUENCE,\
    \ then add (prepend to\n          the segment) a number of elements equal to the\
    \ pCount field in\n          the current Secure_Path Segment.  The value of each\
    \ of these\n          elements shall be the AS number contained in the current\n\
    \          Secure_Path Segment.  (That is, if the pCount field is X, then\n  \
    \        add X copies of the Secure_Path Segment's AS Number field to\n      \
    \    the existing AS_CONFED_SEQUENCE.)\n   3.  If the Secure_Path Segment has\
    \ pCount greater than 0 and the\n       Confed_Segment flag is set to 0, then\
    \ look at the most recently\n       added segment in the AS_PATH.\n       *  In\
    \ the case where the AS_PATH is blank or in the case where\n          the most\
    \ recently added segment is of type AS_CONFED_SEQUENCE,\n          add (prepend\
    \ to the AS_PATH) a new AS_PATH segment of type\n          AS_SEQUENCE.  This\
    \ segment of type AS_SEQUENCE shall contain a\n          number of elements equal\
    \ to the pCount field in the current\n          Secure_Path Segment.  Each of\
    \ these elements shall be the AS\n          number contained in the current Secure_Path\
    \ Segment.  (That\n          is, if the pCount field is X, then the segment of\
    \ type\n          AS_SEQUENCE contains X copies of the Secure_Path Segment's AS\n\
    \          Number field.)\n       *  In the case where the most recently added\
    \ segment in the\n          AS_PATH is of type AS_SEQUENCE, then add (prepend\
    \ to the\n          segment) a number of elements equal to the pCount field in\
    \ the\n          current Secure_Path Segment.  The value of each of these\n  \
    \        elements shall be the AS number contained in the current\n          Secure_Path\
    \ Segment.  (That is, if the pCount field is X, then\n          add X copies of\
    \ the Secure_Path Segment's AS Number field to\n          the existing AS_SEQUENCE.)\n\
    \   As part of the procedure described above, the following additional\n   actions\
    \ are performed in order not to exceed the size limitations of\n   AS_SEQUENCE\
    \ and AS_CONFED_SEQUENCE.  While adding the next\n   Secure_Path Segment (with\
    \ its prepends, if any) to the AS_PATH being\n   assembled, if it would cause\
    \ the AS_SEQUENCE (or AS_CONFED_SEQUENCE)\n   at hand to exceed the limit of 255\
    \ AS numbers per segment [RFC4271]\n   [RFC5065], then the BGPsec speaker would\
    \ follow the recommendations\n   in RFC 4271 [RFC4271] and RFC 5065 [RFC5065]\
    \ of creating another\n   segment of the same type (AS_SEQUENCE or AS_CONFED_SEQUENCE)\
    \ and\n   continue filling that.\n   Finally, one special case of reconstruction\
    \ of AS_PATH is when the\n   BGPsec_PATH attribute is absent.  As explained in\
    \ Section 4.1, when a\n   BGPsec speaker originates a prefix and sends it to a\
    \ BGPsec-capable\n   iBGP peer, the BGPsec_PATH is not attached.  So, when received\
    \ from a\n   BGPsec-capable iBGP peer, no BGPsec_PATH attribute in a BGPsec UPDATE\n\
    \   message is equivalent to an empty AS_PATH [RFC4271].\n"
- title: 5.  Processing a Received BGPsec UPDATE Message
  contents:
  - "5.  Processing a Received BGPsec UPDATE Message\n   Upon receiving a BGPsec UPDATE\
    \ message from an external (eBGP) peer,\n   a BGPsec speaker SHOULD validate the\
    \ message to determine the\n   authenticity of the path information contained\
    \ in the BGPsec_PATH\n   attribute.  Typically, a BGPsec speaker will also wish\
    \ to perform\n   origin validation (see RFC 6483 [RFC6483] and RFC 6811 [RFC6811])\
    \ on\n   an incoming BGPsec UPDATE message, but such validation is independent\n\
    \   of the validation described in this section.\n   Section 5.1 provides an overview\
    \ of BGPsec validation, and\n   Section 5.2 provides a specific algorithm for\
    \ performing such\n   validation.  (Note that an implementation need not follow\
    \ the\n   specific algorithm in Section 5.2 as long as the input/output\n   behavior\
    \ of the validation is identical to that of the algorithm in\n   Section 5.2.)\
    \  During exceptional conditions (e.g., the BGPsec\n   speaker receives an incredibly\
    \ large number of UPDATE messages at\n   once), a BGPsec speaker MAY temporarily\
    \ defer validation of incoming\n   BGPsec UPDATE messages.  The treatment of such\
    \ BGPsec UPDATE\n   messages, whose validation has been deferred, is a matter\
    \ of local\n   policy.  However, an implementation SHOULD ensure that deferment\
    \ of\n   validation and status of deferred messages is visible to the\n   operator.\n\
    \   The validity of BGPsec UPDATE messages is a function of the current\n   RPKI\
    \ state.  When a BGPsec speaker learns that the RPKI state has\n   changed (e.g.,\
    \ from an RPKI validating cache via the RPKI-Router\n   protocol [RFC8210]), the\
    \ BGPsec speaker MUST rerun validation on all\n   affected UPDATE messages stored\
    \ in its Adj-RIB-In [RFC4271].  For\n   example, when a given RPKI router certificate\
    \ ceases to be valid\n   (e.g., it expires or is revoked), all UPDATE messages\
    \ containing a\n   signature whose SKI matches the SKI in the given certificate\
    \ MUST be\n   reassessed to determine if they are still valid.  If this\n   reassessment\
    \ determines that the validity state of an UPDATE message\n   has changed, then,\
    \ depending on local policy, it may be necessary to\n   rerun best path selection.\n\
    \   BGPsec UPDATE messages do not contain an AS_PATH attribute.  The\n   Secure_Path\
    \ contains AS path information for the BGPsec UPDATE\n   message.  Therefore,\
    \ a BGPsec speaker MUST utilize the AS path\n   information in the Secure_Path\
    \ in all cases where it would otherwise\n   use the AS path information in the\
    \ AS_PATH attribute.  The only\n   exception to this rule is when AS path information\
    \ must be updated in\n   order to propagate a route to a peer (in which case the\
    \ BGPsec\n   speaker follows the instructions in Section 4).  Section 4.4 provides\n\
    \   an algorithm for constructing an AS_PATH attribute from a BGPsec_PATH\n  \
    \ attribute.  Whenever the use of AS path information is called for\n   (e.g.,\
    \ loop detection or the use of the AS path length in best path\n   selection),\
    \ the externally visible behavior of the implementation\n   shall be the same\
    \ as if the implementation had run the algorithm in\n   Section 4.4 and used the\
    \ resulting AS_PATH attribute as it would for\n   a non-BGPsec UPDATE message.\n"
- title: 5.1.  Overview of BGPsec Validation
  contents:
  - "5.1.  Overview of BGPsec Validation\n   Validation of a BGPsec UPDATE message\
    \ makes use of data from RPKI\n   router certificates.  In particular, it is necessary\
    \ that the\n   recipient have access to the following data obtained from valid\
    \ RPKI\n   router certificates: the AS Number, Public Key, and Subject Key\n \
    \  Identifier from each valid RPKI router certificate.\n   Note that the BGPsec\
    \ speaker could perform the validation of RPKI\n   router certificates on its\
    \ own and extract the required data, or it\n   could receive the same data from\
    \ a trusted cache that performs RPKI\n   validation on behalf of (some set of)\
    \ BGPsec speakers.  (For example,\n   the trusted cache could deliver the necessary\
    \ validity information to\n   the BGPsec speaker by using the Router Key PDU (Protocol\
    \ Data Unit)\n   for the RPKI-Router protocol [RFC8210].)\n   To validate a BGPsec\
    \ UPDATE message containing the BGPsec_PATH\n   attribute, the recipient performs\
    \ the validation steps specified in\n   Section 5.2.  The validation procedure\
    \ results in one of two states:\n   'Valid' and 'Not Valid'.\n   It is expected\
    \ that the output of the validation procedure will be\n   used as an input to\
    \ BGP route selection.  That said, BGP route\n   selection, and thus the handling\
    \ of the validation states, is a\n   matter of local policy and is handled using\
    \ local policy mechanisms.\n   Implementations SHOULD enable operators to set\
    \ such local policy on a\n   per-session basis.  (That is, it is expected that\
    \ some operators will\n   choose to treat BGPsec validation status differently\
    \ for UPDATE\n   messages received over different BGP sessions.)\n   BGPsec validation\
    \ need only be performed at the eBGP edge.  The\n   validation status of a BGP\
    \ signed/unsigned UPDATE message MAY be\n   conveyed via iBGP from an ingress\
    \ edge router to an egress edge\n   router via some mechanism, according to local\
    \ policy within an AS.\n   As discussed in Section 4, when a BGPsec speaker chooses\
    \ to forward a\n   (syntactically correct) BGPsec UPDATE message, it SHOULD be\
    \ forwarded\n   with its BGPsec_PATH attribute intact (regardless of the validation\n\
    \   state of the UPDATE message).  Based entirely on local policy, an\n   egress\
    \ router receiving a BGPsec UPDATE message from within its own\n   AS MAY choose\
    \ to perform its own validation.\n"
- title: 5.2.  Validation Algorithm
  contents:
  - "5.2.  Validation Algorithm\n   This section specifies an algorithm for validation\
    \ of BGPsec UPDATE\n   messages.  A conformant implementation MUST include a BGPsec\
    \ update\n   validation algorithm that is functionally equivalent to the\n   externally\
    \ visible behavior of this algorithm.\n   First, the recipient of a BGPsec UPDATE\
    \ message performs a check to\n   ensure that the message is properly formed.\
    \  Both syntactical and\n   protocol violation errors are checked.  The BGPsec_PATH\
    \ attribute\n   MUST be present when a BGPsec UPDATE message is received from\
    \ an\n   external (eBGP) BGPsec peer and also when such an UPDATE message is\n\
    \   propagated to an internal (iBGP) BGPsec peer (see Section 4.2).  The\n   error\
    \ checks specified in Section 6.3 of [RFC4271] are performed,\n   except that\
    \ for BGPsec UPDATE messages the checks on the AS_PATH\n   attribute do not apply\
    \ and instead the following checks on the\n   BGPsec_PATH attribute are performed:\n\
    \   1.  Check to ensure that the entire BGPsec_PATH attribute is\n       syntactically\
    \ correct (conforms to the specification in this\n       document).\n   2.  Check\
    \ that the AS number in the most recently added Secure_Path\n       Segment (i.e.,\
    \ the one corresponding to the eBGP peer from which\n       the UPDATE message\
    \ was received) matches the AS number of that\n       peer as specified in the\
    \ BGP OPEN message.  (Note: This check is\n       performed only at an ingress\
    \ BGPsec router where the UPDATE\n       message is first received from a peer\
    \ AS.)\n   3.  Check that each Signature_Block contains one Signature Segment\n\
    \       for each Secure_Path Segment in the Secure_Path portion of the\n     \
    \  BGPsec_PATH attribute.  (Note that the entirety of each\n       Signature_Block\
    \ MUST be checked to ensure that it is well formed,\n       even though the validation\
    \ process may terminate before all\n       signatures are cryptographically verified.)\n\
    \   4.  Check that the UPDATE message does not contain an AS_PATH\n       attribute.\n\
    \   5.  If the UPDATE message was received from a BGPsec peer that is not\n  \
    \     a member of the BGPsec speaker's AS confederation, check to\n       ensure\
    \ that none of the Secure_Path Segments contain a Flags\n       field with the\
    \ Confed_Segment flag set to 1.\n   6.  If the UPDATE message was received from\
    \ a BGPsec peer that is a\n       member of the BGPsec speaker's AS confederation,\
    \ check to ensure\n       that the Secure_Path Segment corresponding to that peer\
    \ contains\n       a Flags field with the Confed_Segment flag set to 1.\n   7.\
    \  If the UPDATE message was received from a peer that is not\n       expected\
    \ to set pCount=0 (see Sections 4.2 and 4.3), then check\n       to ensure that\
    \ the pCount field in the most recently added\n       Secure_Path Segment is not\
    \ equal to 0.  (Note: See Section 7.2\n       for router configuration guidance\
    \ related to this item.)\n   8.  Using the equivalent of AS_PATH corresponding\
    \ to the Secure_Path\n       in the UPDATE message (see Section 4.4), check that\
    \ the local AS\n       number is not present in the AS path (i.e., rule out an\
    \ AS loop).\n   If any of these checks fail, it is an error in the BGPsec_PATH\n\
    \   attribute.  BGPsec speakers MUST handle any syntactical or protocol\n   errors\
    \ in the BGPsec_PATH attribute by using the \"treat-as-withdraw\"\n   approach\
    \ as defined in RFC 7606 [RFC7606].  (Note: Since the AS\n   number of a transparent\
    \ route server does appear in the Secure_Path\n   with pCount=0, the route server\
    \ MAY check to see if its local AS is\n   listed in the Secure_Path, and this\
    \ check MAY be included in the\n   loop-detection check listed above.)\n   Next,\
    \ the BGPsec speaker examines the Signature_Blocks in the\n   BGPsec_PATH attribute.\
    \  A Signature_Block corresponding to an\n   algorithm suite that the BGPsec speaker\
    \ does not support is not\n   considered in the validation process.  If there\
    \ is no Signature_Block\n   corresponding to an algorithm suite that the BGPsec\
    \ speaker supports,\n   then in order to consider the UPDATE message in the route\
    \ selection\n   process, the BGPsec speaker MUST strip the Signature_Block(s),\n\
    \   reconstruct the AS_PATH from the Secure_Path (see Section 4.4), and\n   treat\
    \ the UPDATE message as if it were received as an unsigned BGP\n   UPDATE message.\n\
    \   For each remaining Signature_Block (corresponding to an algorithm\n   suite\
    \ supported by the BGPsec speaker), the BGPsec speaker iterates\n   through the\
    \ Signature Segments in the Signature_Block, starting with\n   the most recently\
    \ added segment (and concluding with the\n   least recently added segment).  Note\
    \ that there is a one-to-one\n   correspondence between Signature Segments and\
    \ Secure_Path Segments\n   within the BGPsec_PATH attribute.  The following steps\
    \ make use of\n   this correspondence:\n   o  Step 1: Let there be K AS hops in\
    \ a received BGPsec_PATH attribute\n      that is to be validated.  Let AS(1),\
    \ AS(2), ..., AS(K+1) denote\n      the sequence of AS numbers from the origin\
    \ AS to the validating\n      AS.  Let Secure_Path Segment N and Signature Segment\
    \ N in the\n      BGPsec_PATH attribute refer to those corresponding to AS(N)\
    \ (where\n      N = 1, 2, ..., K).  The BGPsec speaker that is processing and\n\
    \      validating the BGPsec_PATH attribute resides in AS(K+1).  Let\n      Signature\
    \ Segment N be the Signature Segment that is currently\n      being verified.\n\
    \   o  Step 2: Locate the public key needed to verify the signature (in\n    \
    \  the current Signature Segment).  To do this, consult the valid\n      RPKI\
    \ router certificate data and look up all valid (AS Number,\n      Public Key,\
    \ Subject Key Identifier) triples in which the AS\n      matches the AS number\
    \ in the corresponding Secure_Path Segment.\n      Of these triples that match\
    \ the AS number, check whether there is\n      an SKI that matches the value in\
    \ the Subject Key Identifier field\n      of the Signature Segment.  If this check\
    \ finds no such matching\n      SKI value, then mark the entire Signature_Block\
    \ as 'Not Valid' and\n      proceed to the next Signature_Block.\n   o  Step 3:\
    \ Compute the digest function (for the given algorithm\n      suite) on the appropriate\
    \ data.\n      In order to verify the digital signature in Signature Segment N,\n\
    \      construct the sequence of octets to be hashed as shown in Figure 9\n  \
    \    (using the notations defined in Step 1).  (Note that this sequence\n    \
    \  is the same sequence that was used by AS(N) that created the\n      Signature\
    \ Segment N (see Section 4.2 and Figure 8).)\n         +------------------------------------+\n\
    \         | Target AS Number                   |\n         +------------------------------------+----\\\
    \n         | Signature Segment   : N-1          |     \\\n         +------------------------------------+\
    \     |\n         | Secure_Path Segment : N            |     |\n         +------------------------------------+\
    \     \\\n                ...                                  >  Data from\n\
    \         +------------------------------------+     /   N Segments\n        \
    \ | Signature Segment   : 1            |     |\n         +------------------------------------+\
    \     |\n         | Secure_Path Segment : 2            |     |\n         +------------------------------------+\
    \     /\n         | Secure_Path Segment : 1            |    /\n         +------------------------------------+---/\n\
    \         | Algorithm Suite Identifier         |\n         +------------------------------------+\n\
    \         | AFI                                |\n         +------------------------------------+\n\
    \         | SAFI                               |\n         +------------------------------------+\n\
    \         | NLRI                               |\n         +------------------------------------+\n\
    \   Figure 9: Sequence of Octets to Be Hashed for Signature Verification\n   \
    \  of Signature Segment N; N = 1,2, ..., K, Where K Is the Number of\n       \
    \            AS Hops in the BGPsec_PATH Attribute\n      The elements in this\
    \ sequence (Figure 9) MUST be ordered exactly\n      as shown.  For the first\
    \ segment to be processed (the\n      most recently added segment (i.e., N = K)\
    \ given that there are K\n      hops in the Secure_Path), the 'Target AS Number'\
    \ is AS(K+1), the\n      AS number of the BGPsec speaker validating the UPDATE\
    \ message.\n      Note that if a BGPsec speaker uses multiple AS Numbers (e.g.,\
    \ the\n      BGPsec speaker is a member of a confederation), the AS number used\n\
    \      here MUST be the AS number announced in the OPEN message for the\n    \
    \  BGP session over which the BGPsec UPDATE message was received.\n      For each\
    \ other Signature Segment (N smaller than K), the 'Target\n      AS Number' is\
    \ AS(N+1), the AS number in the Secure_Path Segment\n      that corresponds to\
    \ the Signature Segment added immediately after\n      the one being processed\
    \ (that is, in the Secure_Path Segment that\n      corresponds to the Signature\
    \ Segment that the validator just\n      finished processing).\n      The Secure_Path\
    \ and Signature Segment are obtained from the\n      BGPsec_PATH attribute.  The\
    \ AFI, SAFI, and NLRI fields are\n      obtained from the MP_REACH_NLRI attribute\
    \ [RFC4760].\n      Additionally, in the Prefix field within the NLRI field (see\n\
    \      Section 5 in RFC 4760 [RFC4760]), all of the trailing bits MUST be\n  \
    \    set to 0 when constructing this sequence.\n   o  Step 4: Use the signature\
    \ validation algorithm (for the given\n      algorithm suite) to verify the signature\
    \ in the current segment.\n      That is, invoke the signature validation algorithm\
    \ on the\n      following three inputs: the value of the Signature field in the\n\
    \      current segment, the digest value computed in Step 3 above, and\n     \
    \ the public key obtained from the valid RPKI data in Step 2 above.\n      If\
    \ the signature validation algorithm determines that the\n      signature is invalid,\
    \ then mark the entire Signature_Block as\n      'Not Valid' and proceed to the\
    \ next Signature_Block.  If the\n      signature validation algorithm determines\
    \ that the signature is\n      valid, then continue processing Signature Segments\
    \ (within the\n      current Signature_Block).\n   If all Signature Segments within\
    \ a Signature_Block pass validation\n   (i.e., all segments are processed and\
    \ the Signature_Block has not yet\n   been marked 'Not Valid'), then the Signature_Block\
    \ is marked as\n   'Valid'.\n   If at least one Signature_Block is marked as 'Valid',\
    \ then the\n   validation algorithm terminates and the BGPsec UPDATE message is\n\
    \   deemed 'Valid'.  (That is, if a BGPsec UPDATE message contains two\n   Signature_Blocks,\
    \ then the UPDATE message is deemed 'Valid' if the\n   first Signature_Block is\
    \ marked 'Valid' OR the second Signature_Block\n   is marked 'Valid'.)\n"
- title: 6.  Algorithms and Extensibility
  contents:
  - '6.  Algorithms and Extensibility

    '
- title: 6.1.  Algorithm Suite Considerations
  contents:
  - "6.1.  Algorithm Suite Considerations\n   Note that there is currently no support\
    \ for bilateral negotiation\n   (using BGP capabilities) between BGPsec peers\
    \ to use a particular\n   (digest and signature) algorithm suite.  This is because\
    \ the\n   algorithm suite used by the sender of a BGPsec UPDATE message MUST be\n\
    \   understood not only by the peer to whom it is directly sending the\n   message\
    \ but also by all BGPsec speakers to whom the route\n   advertisement is eventually\
    \ propagated.  Therefore, selection of an\n   algorithm suite cannot be a local\
    \ matter negotiated by BGP peers but\n   instead must be coordinated throughout\
    \ the Internet.\n   To this end, [RFC8208] specifies a mandatory-to-use 'current'\n\
    \   algorithm suite for use by all BGPsec speakers.\n   It is anticipated that,\
    \ in the future, [RFC8208] or its successor\n   will be updated to specify a transition\
    \ from the 'current' algorithm\n   suite to a 'new' algorithm suite.  During the\
    \ period of transition,\n   all BGPsec UPDATE messages SHOULD simultaneously use\
    \ both the\n   'current' algorithm suite and the 'new' algorithm suite.  (Note\
    \ that\n   Sections 3 and 4 specify how the BGPsec_PATH attribute can contain\n\
    \   signatures, in parallel, for two algorithm suites.)  Once the\n   transition\
    \ is complete, the use of the old 'current' algorithm will\n   be deprecated,\
    \ the use of the 'new' algorithm will be mandatory, and\n   a subsequent 'even\
    \ newer' algorithm suite may be specified as\n   \"recommended to implement\"\
    .  Once the transition has successfully\n   been completed in this manner, BGPsec\
    \ speakers SHOULD include only a\n   single Signature_Block (corresponding to\
    \ the 'new' algorithm).\n"
- title: 6.2.  Considerations for the SKI Size
  contents:
  - "6.2.  Considerations for the SKI Size\n   Depending on the method of generating\
    \ key identifiers [RFC7093], the\n   size of the SKI in an RPKI router certificate\
    \ may vary.  The SKI\n   field in the BGPsec_PATH attribute has a fixed size of\
    \ 20 octets (see\n   Figure 7).  If the SKI is longer than 20 octets, then use\
    \ the\n   leftmost 20 octets of the SKI (excluding the tag and length)\n   [RFC7093].\
    \  If the SKI value is shorter than 20 octets, then pad the\n   SKI (excluding\
    \ the tag and length) to the right (least significant\n   octets) with octets\
    \ having \"0\" values.\n"
- title: 6.3.  Extensibility Considerations
  contents:
  - "6.3.  Extensibility Considerations\n   This section discusses potential changes\
    \ to BGPsec that would require\n   substantial changes to the processing of the\
    \ BGPsec_PATH and thus\n   necessitate a new version of BGPsec.  Examples of such\
    \ changes\n   include:\n   o  A new type of signature algorithm that produces\
    \ signatures of\n      variable length\n   o  A new type of signature algorithm\
    \ for which the number of\n      signatures in the Signature_Block is not equal\
    \ to the number of\n      ASes in the Secure_Path (e.g., aggregate signatures)\n\
    \   o  Changes to the data that is protected by the BGPsec signatures\n      (e.g.,\
    \ attributes other than the AS path)\n   In the case that such a change to BGPsec\
    \ were deemed desirable, it is\n   expected that a subsequent version of BGPsec\
    \ would be created and\n   that this version of BGPsec would specify a new BGP\
    \ path attribute --\n   let's call it \"BGPsec_PATH_Two\" -- that is designed\
    \ to accommodate\n   the desired changes to BGPsec.  In such a case, [RFC8208]\
    \ or its\n   successor would be updated to specify algorithm suites appropriate\n\
    \   for the new version of BGPsec.\n   At this point, a transition would begin\
    \ that is analogous to the\n   algorithm transition discussed in Section 6.1.\
    \  During the transition\n   period, all BGPsec speakers SHOULD simultaneously\
    \ include both the\n   BGPsec_PATH attribute and the new BGPsec_PATH_Two attribute.\
    \  Once\n   the transition is complete, the use of BGPsec_PATH could then be\n\
    \   deprecated, at which point BGPsec speakers should include only the\n   new\
    \ BGPsec_PATH_Two attribute.  Such a process could facilitate a\n   transition\
    \ to a new BGPsec semantics in a backwards-compatible\n   fashion.\n"
- title: 7.  Operations and Management Considerations
  contents:
  - "7.  Operations and Management Considerations\n   Some operations and management\
    \ issues that are closely relevant to\n   BGPsec protocol specification and deployment\
    \ are highlighted here.\n   The best practices concerning operations and deployment\
    \ of BGPsec are\n   provided in [RFC8207].\n"
- title: 7.1.  Capability Negotiation Failure
  contents:
  - "7.1.  Capability Negotiation Failure\n   Section 2.2 describes the negotiation\
    \ required to establish a\n   BGPsec-capable peering session.  Not only must the\
    \ BGPsec capability\n   be exchanged (and agreed on), but the BGP multiprotocol\
    \ extension\n   [RFC4760] for the same AFI and the 4-byte AS capability [RFC6793]\n\
    \   MUST also be exchanged.  Failure to properly negotiate a BGPsec\n   session\
    \ -- due to a missing capability, for example -- may still\n   result in the exchange\
    \ of BGP (unsigned) UPDATE messages.  It is\n   RECOMMENDED that an implementation\
    \ log the failure to properly\n   negotiate a BGPsec session.  Also, an implementation\
    \ MUST have the\n   ability to prevent a BGP session from being established if\
    \ configured\n   to only use BGPsec.\n"
- title: 7.2.  Preventing Misuse of pCount=0
  contents:
  - "7.2.  Preventing Misuse of pCount=0\n   A peer that is an Internet Exchange Point\
    \ (IXP) (i.e., route server)\n   with a transparent AS is expected to set pCount=0\
    \ in its Secure_Path\n   Segment while forwarding an UPDATE message to a peer\
    \ (see\n   Section 4.2).  Clearly, such an IXP MUST configure its BGPsec router\n\
    \   to set pCount=0 in its Secure_Path Segment.  This also means that a\n   BGPsec\
    \ speaker MUST be configured so that it permits pCount=0 from an\n   IXP peer.\
    \  Two other cases where pCount is set to 0 are in the\n   contexts of an AS confederation\
    \ (see Section 4.3) and of AS migration\n   [RFC8206].  In these two cases, pCount=0\
    \ is set and accepted within\n   the same AS (albeit the AS has two different\
    \ identities).  Note that\n   if a BGPsec speaker does not expect a peer AS to\
    \ set its pCount=0 and\n   if an UPDATE message received from that peer violates\
    \ this, then the\n   UPDATE message MUST be considered to be in error (see the\
    \ list of\n   checks in Section 5.2).  See Section 8.4 for a discussion of security\n\
    \   considerations concerning pCount=0.\n"
- title: 7.3.  Early Termination of Signature Verification
  contents:
  - "7.3.  Early Termination of Signature Verification\n   During the validation of\
    \ a BGPsec UPDATE message, route processor\n   performance speedup can be achieved\
    \ by incorporating the following\n   observations.  An UPDATE message is deemed\
    \ 'Valid' if at least one of\n   the Signature_Blocks is marked as 'Valid' (see\
    \ Section 5.2).\n   Therefore, if an UPDATE message contains two Signature_Blocks\
    \ and the\n   first one verified is found 'Valid', then the second Signature_Block\n\
    \   does not have to be verified.  And if the UPDATE message is chosen\n   for\
    \ best path, then the BGPsec speaker adds its signature (generated\n   with the\
    \ respective algorithm) to each of the two Signature_Blocks\n   and forwards the\
    \ UPDATE message.  Also, a BGPsec UPDATE message is\n   deemed 'Not Valid' if\
    \ at least one signature in each of the\n   Signature_Blocks is invalid.  This\
    \ principle can also be used for\n   route processor workload savings, i.e., the\
    \ verification for a\n   Signature_Block terminates early when the first invalid\
    \ signature is\n   encountered.\n"
- title: 7.4.  Non-deterministic Signature Algorithms
  contents:
  - "7.4.  Non-deterministic Signature Algorithms\n   Many signature algorithms are\
    \ non-deterministic.  That is, many\n   signature algorithms will produce different\
    \ signatures each time they\n   are run (even when they are signing the same data\
    \ with the same key).\n   Therefore, if a BGPsec router receives a BGPsec UPDATE\
    \ message from a\n   peer and later receives a second BGPsec UPDATE message from\
    \ the same\n   peer for the same prefix with the same Secure_Path and SKIs, the\n\
    \   second UPDATE message MAY differ from the first UPDATE message in the\n  \
    \ signature fields (for a non-deterministic signature algorithm).\n   However,\
    \ the two sets of signature fields will not differ if the\n   sender caches and\
    \ reuses the previous signature.  For a deterministic\n   signature algorithm,\
    \ the signature fields MUST be identical between\n   the two UPDATE messages.\
    \  On the basis of these observations, an\n   implementation MAY incorporate optimizations\
    \ in update validation\n   processing.\n"
- title: 7.5.  Private AS Numbers
  contents:
  - "7.5.  Private AS Numbers\n   It is possible that a stub customer of an ISP employs\
    \ a private AS\n   number.  Such a stub customer cannot publish a ROA in the Global\
    \ RPKI\n   for the private AS number and the prefixes that they use.  Also, the\n\
    \   Global RPKI cannot support private AS numbers (i.e., BGPsec speakers\n   in\
    \ private ASes cannot be issued router certificates in the Global\n   RPKI). \
    \ For interactions between the stub customer (with the private\n   AS number)\
    \ and the ISP, the following two scenarios are possible:\n   1.  The stub customer\
    \ sends an unsigned BGP UPDATE message for a\n       prefix to the ISP's AS. \
    \ An edge BGPsec speaker in the ISP's AS\n       may choose to propagate the prefix\
    \ to its non-BGPsec and BGPsec\n       peers.  If so, the ISP's edge BGPsec speaker\
    \ MUST strip the\n       AS_PATH with the private AS number and then (a) re-originate\
    \ the\n       prefix without any signatures towards its non-BGPsec peer and\n\
    \       (b) re-originate the prefix including its own signature towards\n    \
    \   its BGPsec peer.  In both cases (i.e., (a) and (b)), the prefix\n       MUST\
    \ have a ROA in the Global RPKI authorizing the ISP's AS to\n       originate\
    \ it.\n   2.  The ISP and the stub customer may use a local RPKI repository\n\
    \       (using a mechanism such as one of the mechanisms described in\n      \
    \ [SLURM]).  Then, there can be a ROA for the prefix originated by\n       the\
    \ stub AS, and the eBGP speaker in the stub AS can be a BGPsec\n       speaker\
    \ having a router certificate, albeit the ROA and router\n       certificate are\
    \ valid only locally.  With this arrangement, the\n       stub AS sends a signed\
    \ UPDATE message for the prefix to the ISP's\n       AS.  An edge BGPsec speaker\
    \ in the ISP's AS validates the UPDATE\n       message, using RPKI data based\
    \ on the local RPKI view.  Further,\n       it may choose to propagate the prefix\
    \ to its non-BGPsec and\n       BGPsec peers.  If so, the ISP's edge BGPsec speaker\
    \ MUST strip\n       the Secure_Path and the Signature Segment received from the\
    \ stub\n       AS with the private AS number and then (a) re-originate the\n \
    \      prefix without any signatures towards its non-BGPsec peer and\n       (b)\
    \ re-originate the prefix including its own signature towards\n       its BGPsec\
    \ peer.  In both cases (i.e., (a) and (b)), the prefix\n       MUST have a ROA\
    \ in the Global RPKI authorizing the ISP's AS to\n       originate it.\n   It\
    \ is possible that private AS numbers are used in an AS\n   confederation [RFC5065].\
    \  The BGPsec protocol requires that when a\n   BGPsec UPDATE message propagates\
    \ through a confederation, each\n   Member-AS that forwards it to a peer Member-AS\
    \ MUST sign the UPDATE\n   message (see Section 4.3).  However, the Global RPKI\
    \ cannot support\n   private AS numbers.  In order for the BGPsec speakers in\
    \ Member-ASes\n   with private AS numbers to have digital certificates, there\
    \ MUST be a\n   mechanism in place in the confederation that allows the establishment\n\
    \   of a local, customized view of the RPKI, augmenting the Global RPKI\n   repository\
    \ data as needed.  Since this mechanism (for augmenting and\n   maintaining a\
    \ local image of RPKI data) operates locally within an AS\n   or AS confederation,\
    \ it need not be standard based.  However, a\n   standard-based mechanism can\
    \ be used (see [SLURM]).  Recall that in\n   order to prevent exposure of the\
    \ internals of AS confederations, a\n   BGPsec speaker exporting to a non-member\
    \ removes all\n   intra-confederation Secure_Path Segments and Signatures (see\n\
    \   Section 4.3).\n"
- title: 7.6.  Robustness Considerations for Accessing RPKI Data
  contents:
  - "7.6.  Robustness Considerations for Accessing RPKI Data\n   The deployment structure,\
    \ technologies, and best practices concerning\n   Global RPKI data to reach routers\
    \ (via local RPKI caches) are\n   described in [RFC6810], [RFC8210], [RFC8181],\
    \ [RFC7115], [RFC8207],\n   and [RFC8182].  For example, Serial-Number-based incremental\
    \ update\n   mechanisms are used for efficient transfer of just the data records\n\
    \   that have changed since the last update [RFC6810] [RFC8210].  The\n   update\
    \ notification file is used by Relying Parties (RPs) to discover\n   whether any\
    \ changes exist between the state of the Global RPKI\n   repository and the RP's\
    \ cache [RFC8182].  The notification describes\n   the location of (1) the files\
    \ containing the snapshot and\n   (2) incremental deltas, which can be used by\
    \ the RP to synchronize\n   with the repository.  Making use of these technologies\
    \ and best\n   practices results in enabling robustness, efficiency, and better\n\
    \   security for the BGPsec routers and RPKI caches in terms of the flow\n   of\
    \ RPKI data from repositories to RPKI caches to routers.  With these\n   mechanisms,\
    \ it is believed that an attacker wouldn't be able to\n   meaningfully correlate\
    \ RPKI data flows with BGPsec RP (or router)\n   actions, thus avoiding attacks\
    \ that may attempt to determine the set\n   of ASes interacting with an RP via\
    \ the interactions between the RP\n   and RPKI servers.\n"
- title: 7.7.  Graceful Restart
  contents:
  - "7.7.  Graceful Restart\n   During Graceful Restart (GR), restarting and receiving\
    \ BGPsec\n   speakers MUST follow the procedures specified in [RFC4724] for\n\
    \   restarting and receiving BGP speakers, respectively.  In particular,\n   the\
    \ behavior of retaining the forwarding state for the routes in the\n   Loc-RIB\
    \ [RFC4271] and marking them as stale, as well as not\n   differentiating between\
    \ stale routing information and other\n   information during forwarding, will\
    \ be the same as the behavior\n   specified in [RFC4724].\n"
- title: 7.8.  Robustness of Secret Random Number in ECDSA
  contents:
  - "7.8.  Robustness of Secret Random Number in ECDSA\n   The Elliptic Curve Digital\
    \ Signature Algorithm (ECDSA) with curve\n   P-256 is used for signing UPDATE\
    \ messages in BGPsec [RFC8208].  For\n   ECDSA, it is stated in Section 6.3 of\
    \ [FIPS186-4] that a new secret\n   random number \"k\" shall be generated prior\
    \ to the generation of each\n   digital signature.  A high-entropy random bit\
    \ generator (RBG) must be\n   used for generating \"k\", and any potential bias\
    \ in the \"k\" generation\n   algorithm must be mitigated (see the methods described\
    \ in [FIPS186-4]\n   and [SP800-90A]).\n"
- title: 7.9.  Incremental/Partial Deployment Considerations
  contents:
  - "7.9.  Incremental/Partial Deployment Considerations\n   What will migration from\
    \ BGP to BGPsec look like?  What are the\n   benefits for the first adopters?\
    \  Initially, small groups of\n   contiguous ASes would be doing BGPsec.  There\
    \ would possibly be one\n   or more such groups in different geographic regions\
    \ of the global\n   Internet.  Only the routes originated within each group and\n\
    \   propagated within its borders would get the benefits of cryptographic\n  \
    \ AS path protection.  As BGPsec adoption grows, each group grows in\n   size,\
    \ and eventually they join together to form even larger\n   BGPsec-capable groups\
    \ of contiguous ASes.  The benefit for early\n   adopters starts with AS path\
    \ security within the regions of\n   contiguous ASes spanned by their respective\
    \ groups.  Over time, they\n   would see those regions of contiguous ASes grow\
    \ much larger.\n   During partial deployment, if an AS in the path doesn't support\n\
    \   BGPsec, then BGP goes back to traditional mode, i.e., BGPsec UPDATE\n   messages\
    \ are converted to unsigned UPDATE messages before forwarding\n   to that AS (see\
    \ Section 4.4).  At this point, the assurance that the\n   UPDATE message propagated\
    \ via the sequence of ASes listed is lost.\n   In other words, for the BGPsec\
    \ routers residing in the ASes starting\n   from the origin AS to the AS before\
    \ the one not supporting BGPsec,\n   the assurance can still be provided, but\
    \ not beyond that (for the\n   UPDATE messages in consideration).\n"
- title: 8.  Security Considerations
  contents:
  - "8.  Security Considerations\n   For a discussion of the BGPsec threat model and\
    \ related security\n   considerations, please see RFC 7132 [RFC7132].\n"
- title: 8.1.  Security Guarantees
  contents:
  - "8.1.  Security Guarantees\n   When used in conjunction with origin validation\
    \ (see RFC 6483\n   [RFC6483] and RFC 6811 [RFC6811]), a BGPsec speaker who receives\
    \ a\n   valid BGPsec UPDATE message containing a route advertisement for a\n \
    \  given prefix is provided with the following security guarantees:\n   o  The\
    \ origin AS number corresponds to an AS that has been\n      authorized, in the\
    \ RPKI, by the IP address space holder to\n      originate route advertisements\
    \ for the given prefix.\n   o  For each AS in the path, a BGPsec speaker authorized\
    \ by the holder\n      of the AS number intentionally chose (in accordance with\
    \ local\n      policy) to propagate the route advertisement to the subsequent\
    \ AS\n      in the path.\n   That is, the recipient of a valid BGPsec UPDATE message\
    \ is assured\n   that the UPDATE message propagated via the sequence of ASes listed\
    \ in\n   the Secure_Path portion of the BGPsec_PATH attribute.  (It should be\n\
    \   noted that BGPsec does not offer any guarantee that the data packets\n   would\
    \ flow along the indicated path; it only guarantees that the BGP\n   UPDATE message\
    \ conveying the path indeed propagated along the\n   indicated path.)  Furthermore,\
    \ the recipient is assured that this\n   path terminates in an AS that has been\
    \ authorized by the IP address\n   space holder as a legitimate destination for\
    \ traffic to the given\n   prefix.\n   Note that although BGPsec provides a mechanism\
    \ for an AS to validate\n   that a received UPDATE message has certain security\
    \ properties, the\n   use of such a mechanism to influence route selection is\
    \ completely a\n   matter of local policy.  Therefore, a BGPsec speaker can make\
    \ no\n   assumptions about the validity of a route received from an external\n\
    \   (eBGP) BGPsec peer.  That is, a compliant BGPsec peer may (depending\n   on\
    \ the local policy of the peer) send UPDATE messages that fail the\n   validity\
    \ test in Section 5.  Thus, a BGPsec speaker MUST completely\n   validate all\
    \ BGPsec UPDATE messages received from external peers.\n   (Validation of UPDATE\
    \ messages received from internal peers is also a\n   matter of local policy;\
    \ see Section 5.)\n"
- title: 8.2.  On the Removal of BGPsec Signatures
  contents:
  - "8.2.  On the Removal of BGPsec Signatures\n   There may be cases where a BGPsec\
    \ speaker deems 'Valid' (as per the\n   validation algorithm in Section 5.2) a\
    \ BGPsec UPDATE message that\n   contains both a 'Valid' and a 'Not Valid' Signature_Block.\
    \  That is,\n   the UPDATE message contains two sets of signatures corresponding\
    \ to\n   two algorithm suites, and one set of signatures verifies correctly\n\
    \   and the other set of signatures fails to verify.  In this case, the\n   protocol\
    \ specifies that a BGPsec speaker choosing to propagate the\n   route advertisement\
    \ in such an UPDATE message MUST add its signature\n   to each of the Signature_Blocks\
    \ (see Section 4.2).  Thus, the BGPsec\n   speaker creates a signature using both\
    \ algorithm suites and creates a\n   new UPDATE message that contains both the\
    \ 'Valid' and the 'Not Valid'\n   set of signatures (from its own vantage point).\n\
    \   To understand the reason for such a design decision, consider the\n   case\
    \ where the BGPsec speaker receives an UPDATE message with both a\n   set of algorithm\
    \ A signatures that are 'Valid' and a set of algorithm\n   B signatures that are\
    \ 'Not Valid'.  In such a case, it is possible\n   (perhaps even likely, depending\
    \ on the state of the algorithm\n   transition) that some of the BGPsec speaker's\
    \ peers (or other\n   entities further downstream in the BGP topology) do not\
    \ support\n   algorithm A.  Therefore, if the BGPsec speaker were to remove the\n\
    \   'Not Valid' set of signatures corresponding to algorithm B, such\n   entities\
    \ would treat the message as though it were unsigned.  By\n   including the 'Not\
    \ Valid' set of signatures when propagating a route\n   advertisement, the BGPsec\
    \ speaker ensures that downstream entities\n   have as much information as possible\
    \ to make an informed opinion\n   about the validation status of a BGPsec UPDATE\
    \ message.\n   Note also that during a period of partial BGPsec deployment, a\n\
    \   downstream entity might reasonably treat unsigned messages\n   differently\
    \ from BGPsec UPDATE messages that contain a single set of\n   'Not Valid' signatures.\
    \  That is, by removing the set of 'Not Valid'\n   signatures, the BGPsec speaker\
    \ might actually cause a downstream\n   entity to 'upgrade' the status of a route\
    \ advertisement from\n   'Not Valid' to unsigned.  Finally, note that in the above\
    \ scenario,\n   the BGPsec speaker might have deemed algorithm A signatures 'Valid'\n\
    \   only because of some issue with the RPKI state local to its AS (for\n   example,\
    \ its AS might not yet have obtained a Certificate Revocation\n   List (CRL) indicating\
    \ that a key used to verify an algorithm A\n   signature belongs to a newly revoked\
    \ certificate).  In such a case,\n   it is highly desirable for a downstream entity\
    \ to treat the UPDATE\n   message as 'Not Valid' (due to the revocation) and not\
    \ as 'unsigned'\n   (which would happen if the 'Not Valid' Signature_Blocks were\
    \ removed\n   en route).\n   A similar argument applies to the case where a BGPsec\
    \ speaker (for\n   some reason, such as a lack of viable alternatives) selects\
    \ as its\n   best path (to a given prefix) a route obtained via a 'Not Valid'\n\
    \   BGPsec UPDATE message.  In such a case, the BGPsec speaker should\n   propagate\
    \ a signed BGPsec UPDATE message, adding its signature to the\n   'Not Valid'\
    \ signatures that already exist.  Again, this is to ensure\n   that downstream\
    \ entities are able to make an informed decision and\n   not erroneously treat\
    \ the route as unsigned.  It should also be noted\n   that due to possible differences\
    \ in RPKI data observed at different\n   vantage points in the network, a BGPsec\
    \ UPDATE message deemed 'Not\n   Valid' at an upstream BGPsec speaker may be deemed\
    \ 'Valid' by another\n   BGP speaker downstream.\n   Indeed, when a BGPsec speaker\
    \ signs an outgoing UPDATE message, it is\n   not attesting to a belief that all\
    \ signatures prior to its own\n   signature are valid.  Instead, it is merely\
    \ asserting that:\n   o  The BGPsec speaker received the given route advertisement\
    \ with the\n      indicated prefix, AFI, SAFI, and Secure_Path, and\n   o  The\
    \ BGPsec speaker chose to propagate an advertisement for this\n      route to\
    \ the peer (implicitly) indicated by the 'Target AS\n      Number'.\n"
- title: 8.3.  Mitigation of Denial-of-Service Attacks
  contents:
  - "8.3.  Mitigation of Denial-of-Service Attacks\n   The BGPsec update validation\
    \ procedure is a potential target for\n   denial-of-service attacks against a\
    \ BGPsec speaker.  The mitigation\n   of denial-of-service attacks that are specific\
    \ to the BGPsec protocol\n   is considered here.\n   To mitigate the effectiveness\
    \ of such denial-of-service attacks,\n   BGPsec speakers should implement an update\
    \ validation algorithm that\n   performs expensive checks (e.g., signature verification)\
    \ after\n   performing checks that are less expensive (e.g., syntax checks). \
    \ The\n   validation algorithm specified in Section 5.2 was chosen so as to\n\
    \   perform checks that are likely to be expensive after checks that are\n   likely\
    \ to be inexpensive.  However, the relative cost of performing\n   required validation\
    \ steps may vary between implementations, and thus\n   the algorithm specified\
    \ in Section 5.2 may not provide the best\n   denial-of-service protection for\
    \ all implementations.\n   Additionally, sending UPDATE messages with very long\
    \ AS paths (and\n   hence a large number of signatures) is a potential mechanism\
    \ to\n   conduct denial-of-service attacks.  For this reason, it is important\n\
    \   that an implementation of the validation algorithm stops attempting\n   to\
    \ verify signatures as soon as an invalid signature is found.  (This\n   ensures\
    \ that long sequences of invalid signatures cannot be used for\n   denial-of-service\
    \ attacks.)  Furthermore, implementations can\n   mitigate such attacks by only\
    \ performing validation on UPDATE\n   messages that, if valid, would be selected\
    \ as the best path.  That\n   is, if an UPDATE message contains a route that would\
    \ lose out in best\n   path selection for other reasons (e.g., a very long AS\
    \ path), then it\n   is not necessary to determine the BGPsec-validity status\
    \ of the\n   route.\n"
- title: 8.4.  Additional Security Considerations
  contents:
  - "8.4.  Additional Security Considerations\n   The mechanism of setting the pCount\
    \ field to 0 is included in this\n   specification to enable route servers in\
    \ the control path to\n   participate in BGPsec without increasing the length\
    \ of the AS path.\n   Two other scenarios where pCount=0 is utilized are in the\
    \ contexts of\n   an AS confederation (see Section 4.3) and of AS migration [RFC8206].\n\
    \   In these two scenarios, pCount=0 is set and also accepted within the\n   same\
    \ AS (albeit the AS has two different identities).  However,\n   entities other\
    \ than route servers, confederation ASes, or migrating\n   ASes could conceivably\
    \ use this mechanism (set the pCount to 0) to\n   attract traffic (by reducing\
    \ the length of the AS path)\n   illegitimately.  This risk is largely mitigated\
    \ if every BGPsec\n   speaker follows the operational guidance in Section 7.2\
    \ for\n   configuration for setting pCount=0 and/or accepting pCount=0 from a\n\
    \   peer.  However, note that a recipient of a BGPsec UPDATE message\n   within\
    \ which an upstream entity two or more hops away has set pCount\n   to 0 is unable\
    \ to verify for themselves whether pCount was set to 0\n   legitimately.\n   There\
    \ is a possibility of passing a BGPsec UPDATE message via\n   tunneling between\
    \ colluding ASes.  For example, let's say that AS-X\n   does not peer with AS-Y\
    \ but colludes with AS-Y, and it signs and\n   sends a BGPsec UPDATE message to\
    \ AS-Y by tunneling.  AS-Y can then\n   further sign and propagate the BGPsec\
    \ UPDATE message to its peers.\n   It is beyond the scope of the BGPsec protocol\
    \ to detect this form of\n   malicious behavior.  BGPsec is designed to protect\
    \ messages sent\n   within BGP (i.e., within the control plane) -- not when the\
    \ control\n   plane is bypassed.\n   A variant of the collusion by tunneling mentioned\
    \ above can happen in\n   the context of AS confederations.  When a BGPsec router\
    \ (outside of a\n   confederation) is forwarding an UPDATE message to a Member-AS\
    \ in the\n   confederation, it signs the UPDATE message to the public AS number\
    \ of\n   the confederation and not to the member's AS number (see\n   Section\
    \ 4.3).  The Member-AS can tunnel the signed UPDATE message to\n   another Member-AS\
    \ as received (i.e., without adding a signature).\n   The UPDATE message can then\
    \ be propagated using BGPsec to other\n   confederation members or to BGPsec neighbors\
    \ outside of the\n   confederation.  This kind of operation is possible, but no\
    \ grave\n   security or reachability compromise is feared for the following\n\
    \   reasons:\n   o  The confederation members belong to one organization, and\
    \ strong\n      internal trust is expected.\n   o  Recall that the signatures\
    \ that are internal to the confederation\n      MUST be removed prior to forwarding\
    \ the UPDATE message to an\n      outside BGPsec router (see Section 4.3).\n \
    \  BGPsec does not provide protection against attacks at the transport\n   layer.\
    \  As with any BGP session, an adversary on the path between a\n   BGPsec speaker\
    \ and its peer is able to perform attacks such as\n   modifying valid BGPsec UPDATE\
    \ messages to cause them to fail\n   validation, injecting (unsigned) BGP UPDATE\
    \ messages without\n   BGPsec_PATH attributes, injecting BGPsec UPDATE messages\
    \ with\n   BGPsec_PATH attributes that fail validation, or causing the peer to\n\
    \   tear down the BGP session.  The use of BGPsec does nothing to\n   increase\
    \ the power of an on-path adversary -- in particular, even an\n   on-path adversary\
    \ cannot cause a BGPsec speaker to believe that a\n   BGPsec-invalid route is\
    \ valid.  However, as with any BGP session,\n   BGPsec sessions SHOULD be protected\
    \ by appropriate transport security\n   mechanisms (see the Security Considerations\
    \ section in [RFC4271]).\n   There is a possibility of replay attacks, defined\
    \ as follows.  In the\n   context of BGPsec, a replay attack occurs when a malicious\
    \ BGPsec\n   speaker in the AS path suppresses a prefix withdrawal (implicit or\n\
    \   explicit).  Further, a replay attack is said to occur also when a\n   malicious\
    \ BGPsec speaker replays a previously received BGPsec\n   announcement for a prefix\
    \ that has since been withdrawn.  The\n   mitigation strategy for replay attacks\
    \ involves router certificate\n   rollover; please see [ROLLOVER] for details.\n"
- title: 9.  IANA Considerations
  contents:
  - "9.  IANA Considerations\n   IANA has registered a new BGP capability described\
    \ in Section 2.1 in\n   the \"Capability Codes\" registry's \"IETF Review\" range\
    \ [RFC8126].  The\n   description for the new capability is \"BGPsec Capability\"\
    .  This\n   document is the reference for the new capability.\n   IANA has also\
    \ registered a new path attribute described in Section 3\n   in the \"BGP Path\
    \ Attributes\" registry.  The code for this new\n   attribute is \"BGPsec_PATH\"\
    .  This document is the reference for the\n   new attribute.\n   IANA has defined\
    \ the \"BGPsec Capability\" registry in the \"Resource\n   Public Key Infrastructure\
    \ (RPKI)\" group.  The registry is as shown in\n   Figure 10, with values assigned\
    \ from Section 2.1:\n        +------+------------------------------------+------------+\n\
    \        | Bits | Field                              | Reference  |\n        +------+------------------------------------+------------+\n\
    \        | 0-3  | Version                            | [RFC8205]  |\n        |\
    \      | Value = 0x0                        |            |\n        +------+------------------------------------+------------+\n\
    \        | 4    | Direction                          | [RFC8205]  |\n        |\
    \      |(Both possible values 0 and 1 are   |            |\n        |      | fully\
    \ specified by this RFC)       |            |\n        +------+------------------------------------+------------+\n\
    \        | 5-7  | Unassigned                         | [RFC8205]  |\n        |\
    \      | Value = 000 (in binary)            |            |\n        +------+------------------------------------+------------+\n\
    \              Figure 10: IANA Registry for BGPsec Capability\n   The Direction\
    \ bit (fourth bit) has a value of either 0 or 1, and both\n   values are fully\
    \ specified by this document.  Future Version values\n   and future values of\
    \ the Unassigned bits are assigned using the\n   \"Standards Action\" registration\
    \ procedures defined in RFC 8126\n   [RFC8126].\n   IANA has defined the \"BGPsec_PATH\
    \ Flags\" registry in the \"Resource\n   Public Key Infrastructure (RPKI)\" group.\
    \  The registry is as shown in\n   Figure 11, with one value assigned from Section\
    \ 3.1:\n     +------+-------------------------------------------+------------+\n\
    \     | Flag | Description                               | Reference  |\n    \
    \ +------+-------------------------------------------+------------+\n     | 0\
    \    | Confed_Segment                            | [RFC8205]  |\n     |      |\
    \ Bit value = 1 means Flag set              |            |\n     |      |    \
    \            (indicates Confed_Segment) |            |\n     |      | Bit value\
    \ = 0 is default                  |            |\n     +------+-------------------------------------------+------------+\n\
    \     | 1-7  | Unassigned                                | [RFC8205]  |\n    \
    \ |      | Value: All 7 bits set to zero             |            |\n     +------+-------------------------------------------+------------+\n\
    \           Figure 11: IANA Registry for BGPsec_PATH Flags Field\n   Future values\
    \ of the Unassigned bits are assigned using the\n   \"Standards Action\" registration\
    \ procedures defined in RFC 8126\n   [RFC8126].\n"
- title: 10.  References
  contents:
  - '10.  References

    '
- title: 10.1.  Normative References
  contents:
  - "10.1.  Normative References\n   [IANA-AF]  IANA, \"Address Family Numbers\",\n\
    \              <https://www.iana.org/assignments/address-family-numbers>.\n  \
    \ [RFC2119]  Bradner, S., \"Key words for use in RFCs to Indicate\n          \
    \    Requirement Levels\", BCP 14, RFC 2119,\n              DOI 10.17487/RFC2119,\
    \ March 1997,\n              <https://www.rfc-editor.org/info/rfc2119>.\n   [RFC4271]\
    \  Rekhter, Y., Ed., Li, T., Ed., and S. Hares, Ed., \"A\n              Border\
    \ Gateway Protocol 4 (BGP-4)\", RFC 4271,\n              DOI 10.17487/RFC4271,\
    \ January 2006,\n              <https://www.rfc-editor.org/info/rfc4271>.\n  \
    \ [RFC4724]  Sangli, S., Chen, E., Fernando, R., Scudder, J., and Y.\n       \
    \       Rekhter, \"Graceful Restart Mechanism for BGP\", RFC 4724,\n         \
    \     DOI 10.17487/RFC4724, January 2007,\n              <https://www.rfc-editor.org/info/rfc4724>.\n\
    \   [RFC4760]  Bates, T., Chandra, R., Katz, D., and Y. Rekhter,\n           \
    \   \"Multiprotocol Extensions for BGP-4\", RFC 4760,\n              DOI 10.17487/RFC4760,\
    \ January 2007,\n              <https://www.rfc-editor.org/info/rfc4760>.\n  \
    \ [RFC5065]  Traina, P., McPherson, D., and J. Scudder, \"Autonomous\n       \
    \       System Confederations for BGP\", RFC 5065,\n              DOI 10.17487/RFC5065,\
    \ August 2007,\n              <https://www.rfc-editor.org/info/rfc5065>.\n   [RFC5492]\
    \  Scudder, J. and R. Chandra, \"Capabilities Advertisement\n              with\
    \ BGP-4\", RFC 5492, DOI 10.17487/RFC5492, February\n              2009, <https://www.rfc-editor.org/info/rfc5492>.\n\
    \   [RFC6482]  Lepinski, M., Kent, S., and D. Kong, \"A Profile for Route\n  \
    \            Origin Authorizations (ROAs)\", RFC 6482,\n              DOI 10.17487/RFC6482,\
    \ February 2012,\n              <https://www.rfc-editor.org/info/rfc6482>.\n \
    \  [RFC6487]  Huston, G., Michaelson, G., and R. Loomans, \"A Profile for\n  \
    \            X.509 PKIX Resource Certificates\", RFC 6487,\n              DOI\
    \ 10.17487/RFC6487, February 2012,\n              <https://www.rfc-editor.org/info/rfc6487>.\n\
    \   [RFC6793]  Vohra, Q. and E. Chen, \"BGP Support for Four-Octet\n         \
    \     Autonomous System (AS) Number Space\", RFC 6793,\n              DOI 10.17487/RFC6793,\
    \ December 2012,\n              <https://www.rfc-editor.org/info/rfc6793>.\n \
    \  [RFC7606]  Chen, E., Ed., Scudder, J., Ed., Mohapatra, P., and K.\n       \
    \       Patel, \"Revised Error Handling for BGP UPDATE Messages\",\n         \
    \     RFC 7606, DOI 10.17487/RFC7606, August 2015,\n              <https://www.rfc-editor.org/info/rfc7606>.\n\
    \   [RFC8126]  Cotton, M., Leiba, B., and T. Narten, \"Guidelines for\n      \
    \        Writing an IANA Considerations Section in RFCs\", BCP 26,\n         \
    \     RFC 8126, DOI 10.17487/RFC8126, June 2017,\n              <https://www.rfc-editor.org/info/rfc8126>.\n\
    \   [RFC8174]  Leiba, B., \"Ambiguity of Uppercase vs Lowercase in RFC\n     \
    \         2119 Key Words\", BCP 14, RFC 8174, DOI 10.17487/RFC8174,\n        \
    \      May 2017, <https://www.rfc-editor.org/info/rfc8174>.\n   [RFC8208]  Turner,\
    \ S. and O. Borchert, \"BGPsec Algorithms, Key\n              Formats, and Signature\
    \ Formats\", RFC 8208,\n              DOI 10.17487/RFC8208, September 2017,\n\
    \              <https://www.rfc-editor.org/info/rfc8208>.\n   [RFC8209]  Reynolds,\
    \ M., Turner, S., and S. Kent, \"A Profile for\n              BGPsec Router Certificates,\
    \ Certificate Revocation Lists,\n              and Certification Requests\", RFC\
    \ 8209,\n              DOI 10.17487/RFC8209, September 2017,\n              <https://www.rfc-editor.org/info/rfc8209>.\n"
- title: 10.2.  Informative References
  contents:
  - "10.2.  Informative References\n   [Borchert] Borchert, O. and M. Baer, \"Subject:\
    \ Modification request:\n              draft-ietf-sidr-bgpsec-protocol-14\", message\
    \ to the IETF\n              SIDR WG Mailing List, 10 February 2016,\n       \
    \       <https://mailarchive.ietf.org/arch/msg/\n              sidr/8B_e4CNxQCUKeZ_AUzsdnn2f5Mu>.\n\
    \   [FIPS186-4]\n              National Institute of Standards and Technology,\
    \ \"Digital\n              Signature Standard (DSS)\", NIST FIPS Publication\n\
    \              186-4, DOI 10.6028/NIST.FIPS.186-4, July 2013,\n              <http://nvlpubs.nist.gov/nistpubs/FIPS/\n\
    \              NIST.FIPS.186-4.pdf>.\n   [RFC6472]  Kumari, W. and K. Sriram,\
    \ \"Recommendation for Not Using\n              AS_SET and AS_CONFED_SET in BGP\"\
    , BCP 172, RFC 6472,\n              DOI 10.17487/RFC6472, December 2011,\n   \
    \           <https://www.rfc-editor.org/info/rfc6472>.\n   [RFC6480]  Lepinski,\
    \ M. and S. Kent, \"An Infrastructure to Support\n              Secure Internet\
    \ Routing\", RFC 6480, DOI 10.17487/RFC6480,\n              February 2012, <https://www.rfc-editor.org/info/rfc6480>.\n\
    \   [RFC6483]  Huston, G. and G. Michaelson, \"Validation of Route\n         \
    \     Origination Using the Resource Certificate Public Key\n              Infrastructure\
    \ (PKI) and Route Origin Authorizations\n              (ROAs)\", RFC 6483, DOI\
    \ 10.17487/RFC6483, February 2012,\n              <https://www.rfc-editor.org/info/rfc6483>.\n\
    \   [RFC6810]  Bush, R. and R. Austein, \"The Resource Public Key\n          \
    \    Infrastructure (RPKI) to Router Protocol\", RFC 6810,\n              DOI\
    \ 10.17487/RFC6810, January 2013,\n              <https://www.rfc-editor.org/info/rfc6810>.\n\
    \   [RFC6811]  Mohapatra, P., Scudder, J., Ward, D., Bush, R., and R.\n      \
    \        Austein, \"BGP Prefix Origin Validation\", RFC 6811,\n              DOI\
    \ 10.17487/RFC6811, January 2013,\n              <https://www.rfc-editor.org/info/rfc6811>.\n\
    \   [RFC7093]  Turner, S., Kent, S., and J. Manger, \"Additional Methods\n   \
    \           for Generating Key Identifiers Values\", RFC 7093,\n             \
    \ DOI 10.17487/RFC7093, December 2013,\n              <https://www.rfc-editor.org/info/rfc7093>.\n\
    \   [RFC7115]  Bush, R., \"Origin Validation Operation Based on the\n        \
    \      Resource Public Key Infrastructure (RPKI)\", BCP 185,\n              RFC\
    \ 7115, DOI 10.17487/RFC7115, January 2014,\n              <https://www.rfc-editor.org/info/rfc7115>.\n\
    \   [RFC7132]  Kent, S. and A. Chi, \"Threat Model for BGP Path Security\",\n\
    \              RFC 7132, DOI 10.17487/RFC7132, February 2014,\n              <https://www.rfc-editor.org/info/rfc7132>.\n\
    \   [RFC8181]  Weiler, S., Sonalker, A., and R. Austein, \"A Publication\n   \
    \           Protocol for the Resource Public Key Infrastructure\n            \
    \  (RPKI)\", July 2017,\n              <https://www.rfc-editor.org/info/rfc8181>.\n\
    \   [RFC8182]  Bruijnzeels, T., Muravskiy, O., Weber, B., and R. Austein,\n  \
    \            \"The RPKI Repository Delta Protocol (RRDP)\", RFC 8182,\n      \
    \        DOI 10.17487/RFC8182, July 2017,\n              <https://www.rfc-editor.org/info/rfc8182>.\n\
    \   [RFC8206]  George, W. and S. Murphy, \"BGPsec Considerations for\n       \
    \       Autonomous System (AS) Migration\", RFC 8206,\n              DOI 10.17487/RFC8206,\
    \ September 2017,\n              <https://www.rfc-editor.org/info/rfc8206>.\n\
    \   [RFC8207]  Bush, R., \"BGPsec Operational Considerations\", BCP 211,\n   \
    \           RFC 8207, DOI 10.17487/RFC8207, September 2017,\n              <https://www.rfc-editor.org/info/rfc8207>.\n\
    \   [RFC8210]  Bush, R. and R. Austein, \"The Resource Public Key\n          \
    \    Infrastructure (RPKI) to Router Protocol, Version 1\",\n              RFC\
    \ 8210, DOI 10.17487/RFC8210, September 2017,\n              <https://www.rfc-editor.org/info/rfc8210>.\n\
    \   [ROLLOVER] Weis, B., Gagliano, R., and K. Patel, \"BGPsec Router\n       \
    \       Certificate Rollover\", Work in Progress,\n              draft-ietf-sidrops-bgpsec-rollover-01,\
    \ August 2017.\n   [SLURM]    Mandelberg, D., Ma, D., and T. Bruijnzeels, \"Simplified\n\
    \              Local internet nUmber Resource Management with the RPKI\",\n  \
    \            Work in Progress, draft-ietf-sidr-slurm-04, March 2017.\n   [SP800-90A]\n\
    \              National Institute of Standards and Technology,\n             \
    \ \"Recommendation for Random Number Generation Using\n              Deterministic\
    \ Random Bit Generators\", NIST SP 800-90A\n              Rev 1, DOI 10.6028/NIST.SP.800-90Ar1,\
    \ June 2015,\n              <http://nvlpubs.nist.gov/nistpubs/SpecialPublications/\n\
    \              NIST.SP.800-90Ar1.pdf>.\n"
- title: Acknowledgements
  contents:
  - "Acknowledgements\n   The authors would like to thank Michael Baer, Oliver Borchert,\
    \ David\n   Mandelberg, Mehmet Adalier, Sean Turner, Wes George, Jeff Haas,\n\
    \   Alvaro Retana, Nevil Brownlee, Matthias Waehlisch, Tim Polk, Russ\n   Mundy,\
    \ Wes Hardaker, Sharon Goldberg, Ed Kern, Doug Maughan, Pradosh\n   Mohapatra,\
    \ Mark Reynolds, Heather Schiller, Jason Schiller, Ruediger\n   Volk, and David\
    \ Ward for their review, comments, and suggestions\n   during the course of this\
    \ work.  Thanks are also due to many IESG\n   reviewers whose comments greatly\
    \ helped improve the clarity,\n   accuracy, and presentation in the document.\n\
    \   The authors particularly wish to acknowledge Oliver Borchert and\n   Michael\
    \ Baer for their review and suggestions [Borchert] concerning\n   the sequence\
    \ of octets to be hashed (Figures 8 and 9 in Sections 4.2\n   and 5.2, respectively).\
    \  This was an important contribution based on\n   their implementation experience.\n"
- title: Contributors
  contents:
  - "Contributors\n   The following people have made significant contributions to\
    \ this\n   document and should be considered co-authors:\n   Rob Austein\n   Dragon\
    \ Research Labs\n   Email: sra@hactrn.net\n   Steven Bellovin\n   Columbia University\n\
    \   Email: smb@cs.columbia.edu\n   Russ Housley\n   Vigil Security\n   Email:\
    \ housley@vigilsec.com\n   Stephen Kent\n   BBN Technologies\n   Email: kent@alum.mit.edu\n\
    \   Warren Kumari\n   Google\n   Email: warren@kumari.net\n   Doug Montgomery\n\
    \   USA National Institute of Standards and Technology\n   Email: dougm@nist.gov\n\
    \   Chris Morrow\n   Google, Inc.\n   Email: morrowc@google.com\n   Sandy Murphy\n\
    \   SPARTA, Inc., a Parsons Company\n   Email: sandy@tislabs.com\n   Keyur Patel\n\
    \   Arrcus\n   Email: keyur@arrcus.com\n   John Scudder\n   Juniper Networks\n\
    \   Email: jgs@juniper.net\n   Samuel Weiler\n   W3C/MIT\n   Email: weiler@csail.mit.edu\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Matthew Lepinski (editor)\n   New College of Florida\n\
    \   5800 Bay Shore Road\n   Sarasota, FL  34243\n   United States of America\n\
    \   Email: mlepinski@ncf.edu\n   Kotikalapudi Sriram (editor)\n   USA National\
    \ Institute of Standards and Technology\n   100 Bureau Drive\n   Gaithersburg,\
    \ MD  20899\n   United States of America\n   Email: kotikalapudi.sriram@nist.gov\n"
