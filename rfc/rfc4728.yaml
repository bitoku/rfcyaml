- title: __initial_text__
  contents:
  - "               The Dynamic Source Routing Protocol (DSR)\n                  for\
    \ Mobile Ad Hoc Networks for IPv4\n"
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This memo defines an Experimental Protocol for the Internet\n\
    \   community.  It does not specify an Internet standard of any kind.\n   Discussion\
    \ and suggestions for improvement are requested.\n   Distribution of this memo\
    \ is unlimited.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (C) The IETF Trust (2007).\n"
- title: Abstract
  contents:
  - "Abstract\n   The Dynamic Source Routing protocol (DSR) is a simple and efficient\n\
    \   routing protocol designed specifically for use in multi-hop wireless\n   ad\
    \ hoc networks of mobile nodes.  DSR allows the network to be\n   completely self-organizing\
    \ and self-configuring, without the need for\n   any existing network infrastructure\
    \ or administration.  The protocol\n   is composed of the two main mechanisms\
    \ of \"Route Discovery\" and\n   \"Route Maintenance\", which work together to\
    \ allow nodes to discover\n   and maintain routes to arbitrary destinations in\
    \ the ad hoc network.\n   All aspects of the protocol operate entirely on demand,\
    \ allowing the\n   routing packet overhead of DSR to scale automatically to only\
    \ what is\n   needed to react to changes in the routes currently in use.  The\n\
    \   protocol allows multiple routes to any destination and allows each\n   sender\
    \ to select and control the routes used in routing its packets,\n   for example,\
    \ for use in load balancing or for increased robustness.\n   Other advantages\
    \ of the DSR protocol include easily guaranteed loop-\n   free routing, operation\
    \ in networks containing unidirectional links,\n   use of only \"soft state\"\
    \ in routing, and very rapid recovery when\n   routes in the network change. \
    \ The DSR protocol is designed mainly\n   for mobile ad hoc networks of up to\
    \ about two hundred nodes and is\n   designed to work well even with very high\
    \ rates of mobility.  This\n   document specifies the operation of the DSR protocol\
    \ for routing\n   unicast IPv4 packets.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1. Introduction ....................................................5\n\
    \   2. Assumptions .....................................................7\n  \
    \ 3. DSR Protocol Overview ...........................................9\n    \
    \  3.1. Basic DSR Route Discovery .................................10\n      3.2.\
    \ Basic DSR Route Maintenance ...............................12\n      3.3. Additional\
    \ Route Discovery Features .......................14\n           3.3.1. Caching\
    \ Overheard Routing Information ..............14\n           3.3.2. Replying to\
    \ Route Requests Using Cached Routes .....15\n           3.3.3. Route Request\
    \ Hop Limits ...........................16\n      3.4. Additional Route Maintenance\
    \ Features .....................17\n           3.4.1. Packet Salvaging ...................................17\n\
    \           3.4.2. Queued Packets Destined over a Broken Link .........18\n  \
    \         3.4.3. Automatic Route Shortening .........................19\n    \
    \       3.4.4. Increased Spreading of Route Error Messages ........20\n      3.5.\
    \ Optional DSR Flow State Extension .........................20\n           3.5.1.\
    \ Flow Establishment .................................21\n           3.5.2. Receiving\
    \ and Forwarding Establishment Packets .....22\n           3.5.3. Sending Packets\
    \ along Established Flows ............22\n           3.5.4. Receiving and Forwarding\
    \ Packets Sent along\n                  Established Flows ..................................23\n\
    \           3.5.5. Processing Route Errors ............................24\n  \
    \         3.5.6. Interaction with Automatic Route Shortening ........24\n    \
    \       3.5.7. Loop Detection .....................................25\n      \
    \     3.5.8. Acknowledgement Destination ........................25\n        \
    \   3.5.9. Crash Recovery .....................................25\n          \
    \ 3.5.10. Rate Limiting .....................................25\n           3.5.11.\
    \ Interaction with Packet Salvaging .................26\n   4. Conceptual Data\
    \ Structures .....................................26\n      4.1. Route Cache ...............................................26\n\
    \      4.2. Send Buffer ...............................................30\n  \
    \    4.3. Route Request Table .......................................30\n    \
    \  4.4. Gratuitous Route Reply Table ..............................31\n      4.5.\
    \ Network Interface Queue and Maintenance Buffer ............32\n      4.6. Blacklist\
    \ .................................................33\n   5. Additional Conceptual\
    \ Data Structures for Flow State\n      Extension ......................................................34\n\
    \      5.1. Flow Table ................................................34\n  \
    \    5.2. Automatic Route Shortening Table ..........................35\n    \
    \  5.3. Default Flow ID Table .....................................36\n   6. DSR\
    \ Options Header Format ......................................36\n      6.1. Fixed\
    \ Portion of DSR Options Header .......................37\n      6.2. Route Request\
    \ Option ......................................40\n      6.3. Route Reply Option\
    \ ........................................42\n      6.4. Route Error Option ........................................44\n\
    \           6.4.1. Node Unreachable Type-Specific Information .........46\n  \
    \         6.4.2. Flow State Not Supported Type-Specific\n                  Information\
    \ ........................................46\n           6.4.3. Option Not Supported\
    \ Type-Specific Information .....46\n      6.5. Acknowledgement Request Option\
    \ ............................46\n      6.6. Acknowledgement Option ....................................47\n\
    \      6.7. DSR Source Route Option ...................................48\n  \
    \    6.8. Pad1 Option ...............................................50\n    \
    \  6.9. PadN Option ...............................................50\n   7. Additional\
    \ Header Formats and Options for Flow State\n      Extension ......................................................51\n\
    \      7.1. DSR Flow State Header .....................................52\n  \
    \    7.2. New Options and Extensions in DSR Options Header ..........52\n    \
    \       7.2.1. Timeout Option .....................................52\n      \
    \     7.2.2. Destination and Flow ID Option .....................53\n      7.3.\
    \ New Error Types for Route Error Option ....................54\n           7.3.1.\
    \ Unknown Flow Type-Specific Information .............54\n           7.3.2. Default\
    \ Flow Unknown Type-Specific Information .....55\n      7.4. New Acknowledgement\
    \ Request Option Extension ..............55\n           7.4.1. Previous Hop Address\
    \ Extension .....................55\n   8. Detailed Operation .............................................56\n\
    \      8.1. General Packet Processing .................................56\n  \
    \         8.1.1. Originating a Packet ...............................56\n    \
    \       8.1.2. Adding a DSR Options Header to a Packet ............57\n      \
    \     8.1.3. Adding a DSR Source Route Option to a Packet .......57\n        \
    \   8.1.4. Processing a Received Packet .......................58\n          \
    \ 8.1.5. Processing a Received DSR Source Route Option ......60\n           8.1.6.\
    \ Handling an Unknown DSR Option .....................63\n      8.2. Route Discovery\
    \ Processing ................................64\n           8.2.1. Originating\
    \ a Route Request ........................65\n           8.2.2. Processing a Received\
    \ Route Request Option .........66\n           8.2.3. Generating a Route Reply\
    \ Using the Route Cache .....68\n           8.2.4. Originating a Route Reply ..........................71\n\
    \           8.2.5. Preventing Route Reply Storms ......................72\n  \
    \         8.2.6. Processing a Received Route Reply Option ...........74\n    \
    \  8.3. Route Maintenance Processing ..............................74\n      \
    \     8.3.1. Using Link-Layer Acknowledgements ..................75\n        \
    \   8.3.2. Using Passive Acknowledgements .....................76\n          \
    \ 8.3.3. Using Network-Layer Acknowledgements ...............77\n           8.3.4.\
    \ Originating a Route Error ..........................80\n           8.3.5. Processing\
    \ a Received Route Error Option ...........81\n           8.3.6. Salvaging a Packet\
    \ .................................82\n      8.4. Multiple Network Interface Support\
    \ ........................84\n      8.5. IP Fragmentation and Reassembly ...........................84\n\
    \      8.6. Flow State Processing .....................................85\n  \
    \         8.6.1. Originating a Packet ...............................85\n    \
    \       8.6.2. Inserting a DSR Flow State Header ..................88\n      \
    \     8.6.3. Receiving a Packet .................................88\n        \
    \   8.6.4. Forwarding a Packet Using Flow IDs .................93\n          \
    \ 8.6.5. Promiscuously Receiving a Packet ...................93\n           8.6.6.\
    \ Operation Where the Layer below DSR\n                  Decreases the IP TTL\
    \ ...............................94\n           8.6.7. Salvage Interactions with\
    \ DSR ......................94\n   9. Protocol Constants and Configuration Variables\
    \ .................95\n   10. IANA Considerations ...........................................96\n\
    \   11. Security Considerations .......................................96\n  \
    \ Appendix A. Link-MaxLife Cache Description ........................97\n   Appendix\
    \ B. Location of DSR in the ISO Network Reference Model ....99\n   Appendix C.\
    \ Implementation and Evaluation Status .................100\n   Acknowledgements\
    \ .................................................101\n   Normative References\
    \ .............................................102\n   Informative References\
    \ ...........................................102\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   The Dynamic Source Routing protocol (DSR) [JOHNSON94, JOHNSON96a]\
    \ is\n   a simple and efficient routing protocol designed specifically for use\n\
    \   in multi-hop wireless ad hoc networks of mobile nodes.  Using DSR,\n   the\
    \ network is completely self-organizing and self-configuring,\n   requiring no\
    \ existing network infrastructure or administration.\n   Network nodes cooperate\
    \ to forward packets for each other to allow\n   communication over multiple \"\
    hops\" between nodes not directly within\n   wireless transmission range of one\
    \ another.  As nodes in the network\n   move about or join or leave the network,\
    \ and as wireless transmission\n   conditions such as sources of interference\
    \ change, all routing is\n   automatically determined and maintained by the DSR\
    \ routing protocol.\n   Since the number or sequence of intermediate hops needed\
    \ to reach any\n   destination may change at any time, the resulting network topology\n\
    \   may be quite rich and rapidly changing.\n   In designing DSR, we sought to\
    \ create a routing protocol that had\n   very low overhead yet was able to react\
    \ very quickly to changes in\n   the network.  The DSR protocol provides highly\
    \ reactive service in\n   order to help ensure successful delivery of data packets\
    \ in spite of\n   node movement or other changes in network conditions.\n   The\
    \ DSR protocol is composed of two main mechanisms that work\n   together to allow\
    \ the discovery and maintenance of source routes in\n   the ad hoc network:\n\
    \   -  Route Discovery is the mechanism by which a node S wishing to send\n  \
    \    a packet to a destination node D obtains a source route to D.\n      Route\
    \ Discovery is used only when S attempts to send a packet to D\n      and does\
    \ not already know a route to D.\n   -  Route Maintenance is the mechanism by\
    \ which node S is able to\n      detect, while using a source route to D, if the\
    \ network topology\n      has changed such that it can no longer use its route\
    \ to D because\n      a link along the route no longer works.  When Route Maintenance\n\
    \      indicates a source route is broken, S can attempt to use any other\n  \
    \    route it happens to know to D, or it can invoke Route Discovery\n      again\
    \ to find a new route for subsequent packets to D.  Route\n      Maintenance for\
    \ this route is used only when S is actually sending\n      packets to D.\n  \
    \ In DSR, Route Discovery and Route Maintenance each operate entirely\n   \"on\
    \ demand\".  In particular, unlike other protocols, DSR requires no\n   periodic\
    \ packets of any kind at any layer within the network.  For\n   example, DSR does\
    \ not use any periodic routing advertisement, link\n   status sensing, or neighbor\
    \ detection packets and does not rely on\n   these functions from any underlying\
    \ protocols in the network.  This\n   entirely on-demand behavior and lack of\
    \ periodic activity allows the\n   number of overhead packets caused by DSR to\
    \ scale all the way down to\n   zero, when all nodes are approximately stationary\
    \ with respect to\n   each other and all routes needed for current communication\
    \ have\n   already been discovered.  As nodes begin to move more or as\n   communication\
    \ patterns change, the routing packet overhead of DSR\n   automatically scales\
    \ to only what is needed to track the routes\n   currently in use.  Network topology\
    \ changes not affecting routes\n   currently in use are ignored and do not cause\
    \ reaction from the\n   protocol.\n   All state maintained by DSR is \"soft state\"\
    \ [CLARK88], in that the\n   loss of any state will not interfere with the correct\
    \ operation of\n   the protocol; all state is discovered as needed and can easily\
    \ and\n   quickly be rediscovered if needed after a failure without significant\n\
    \   impact on the protocol.  This use of only soft state allows the\n   routing\
    \ protocol to be very robust to problems such as dropped or\n   delayed routing\
    \ packets or node failures.  In particular, a node in\n   DSR that fails and reboots\
    \ can easily rejoin the network immediately\n   after rebooting; if the failed\
    \ node was involved in forwarding\n   packets for other nodes as an intermediate\
    \ hop along one or more\n   routes, it can also resume this forwarding quickly\
    \ after rebooting,\n   with no or minimal interruption to the routing protocol.\n\
    \   In response to a single Route Discovery (as well as through routing\n   information\
    \ from other packets overheard), a node may learn and cache\n   multiple routes\
    \ to any destination.  This support for multiple routes\n   allows the reaction\
    \ to routing changes to be much more rapid, since a\n   node with multiple routes\
    \ to a destination can try another cached\n   route if the one it has been using\
    \ should fail.  This caching of\n   multiple routes also avoids the overhead of\
    \ needing to perform a new\n   Route Discovery each time a route in use breaks.\
    \  The sender of a\n   packet selects and controls the route used for its own\
    \ packets,\n   which, together with support for multiple routes, also allows\n\
    \   features such as load balancing to be defined.  In addition, all\n   routes\
    \ used are easily guaranteed to be loop-free, since the sender\n   can avoid duplicate\
    \ hops in the routes selected.\n   The operation of both Route Discovery and Route\
    \ Maintenance in DSR\n   are designed to allow unidirectional links and asymmetric\
    \ routes to\n   be supported.  In particular, as noted in Section 2, in wireless\n\
    \   networks, it is possible that a link between two nodes may not work\n   equally\
    \ well in both directions, due to differing transmit power\n   levels or sources\
    \ of interference.\n   It is possible to interface a DSR network with other networks,\n\
    \   external to this DSR network.  Such external networks may, for\n   example,\
    \ be the Internet or may be other ad hoc networks routed with\n   a routing protocol\
    \ other than DSR.  Such external networks may also\n   be other DSR networks that\
    \ are treated as external networks in order\n   to improve scalability.  The complete\
    \ handling of such external\n   networks is beyond the scope of this document.\
    \  However, this\n   document specifies a minimal set of requirements and features\n\
    \   necessary to allow nodes only implementing this specification to\n   interoperate\
    \ correctly with nodes implementing interfaces to such\n   external networks.\n\
    \   This document specifies the operation of the DSR protocol for routing\n  \
    \ unicast IPv4 packets in multi-hop wireless ad hoc networks.\n   Advanced, optional\
    \ features, such as Quality of Service (QoS) support\n   and efficient multicast\
    \ routing, and operation of DSR with IPv6\n   [RFC2460], will be covered in other\
    \ documents.  The specification of\n   DSR in this document provides a compatible\
    \ base on which such\n   features can be added, either independently or by integration\
    \ with\n   the DSR operation specified here.  As described in Appendix C, the\n\
    \   design of DSR has been extensively studied through detailed\n   simulations\
    \ and testbed implementation and demonstration; this\n   document encourages additional\
    \ implementation and experimentation\n   with the protocol.\n   The keywords \"\
    MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\",\
    \ \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this\n   document\
    \ are to be interpreted as described in RFC 2119 [RFC2119].\n"
- title: 2.  Assumptions
  contents:
  - "2.  Assumptions\n   As described here, the DSR protocol is designed mainly for\
    \ mobile ad\n   hoc networks of up to about two hundred nodes and is designed\
    \ to work\n   well even with very high rates of mobility.  Other protocol features\n\
    \   and enhancements that may allow DSR to scale to larger networks are\n   outside\
    \ the scope of this document.\n   We assume in this document that all nodes wishing\
    \ to communicate with\n   other nodes within the ad hoc network are willing to\
    \ participate\n   fully in the protocols of the network.  In particular, each\
    \ node\n   participating in the ad hoc network SHOULD also be willing to forward\n\
    \   packets for other nodes in the network.\n   The diameter of an ad hoc network\
    \ is the minimum number of hops\n   necessary for a packet to reach from any node\
    \ located at one extreme\n   edge of the ad hoc network to another node located\
    \ at the opposite\n   extreme.  We assume that this diameter will often be small\
    \ (e.g.,\n   perhaps 5 or 10 hops), but it may often be greater than 1.\n   Packets\
    \ may be lost or corrupted in transmission on the wireless\n   network.  We assume\
    \ that a node receiving a corrupted packet can\n   detect the error, such as through\
    \ a standard link-layer checksum or\n   Cyclic Redundancy Check (CRC), and discard\
    \ the packet.\n   Nodes within the ad hoc network MAY move at any time without\
    \ notice\n   and MAY even move continuously, but we assume that the speed with\n\
    \   which nodes move is moderate with respect to the packet transmission\n   latency\
    \ and wireless transmission range of the particular underlying\n   network hardware\
    \ in use.  In particular, DSR can support very rapid\n   rates of arbitrary node\
    \ mobility, but we assume that nodes do not\n   continuously move so rapidly as\
    \ to make the flooding of every\n   individual data packet the only possible routing\
    \ protocol.\n   A common feature of many network interfaces, including most current\n\
    \   LAN hardware for broadcast media such as wireless, is the ability to\n   operate\
    \ the network interface in \"promiscuous\" receive mode.  This\n   mode causes\
    \ the hardware to deliver every received packet to the\n   network driver software\
    \ without filtering based on link-layer\n   destination address.  Although we\
    \ do not require this facility, some\n   of our optimizations can take advantage\
    \ of its availability.  Use of\n   promiscuous mode does increase the software\
    \ overhead on the CPU, but\n   we believe that wireless network speeds and capacity\
    \ are more the\n   inherent limiting factors to performance in current and future\n\
    \   systems; we also believe that portions of the protocol are suitable\n   for\
    \ implementation directly within a programmable network interface\n   unit to\
    \ avoid this overhead on the CPU [JOHNSON96a].  Use of\n   promiscuous mode may\
    \ also increase the power consumption of the\n   network interface hardware, depending\
    \ on the design of the receiver\n   hardware, and in such cases, DSR can easily\
    \ be used without the\n   optimizations that depend on promiscuous receive mode\
    \ or can be\n   programmed to only periodically switch the interface into promiscuous\n\
    \   mode.  Use of promiscuous receive mode is entirely optional.\n   Wireless\
    \ communication ability between any pair of nodes may at times\n   not work equally\
    \ well in both directions, due, for example, to\n   transmit power levels or sources\
    \ of interference around the two nodes\n   [BANTZ94, LAUER95].  That is, wireless\
    \ communications between each\n   pair of nodes will in many cases be able to\
    \ operate bidirectionally,\n   but at times the wireless link between two nodes\
    \ may be only\n   unidirectional, allowing one node to successfully send packets\
    \ to the\n   other while no communication is possible in the reverse direction.\n\
    \   Some Medium Access Control (MAC) protocols, however, such as MACA\n   [KARN90],\
    \ MACAW [BHARGHAVAN94], or IEEE 802.11 [IEEE80211], limit\n   unicast data packet\
    \ transmission to bidirectional links, due to the\n   required bidirectional exchange\
    \ of request to send (RTS) and clear to\n   send (CTS) packets in these protocols\
    \ and to the link-layer\n   acknowledgement feature in IEEE 802.11.  When used\
    \ on top of MAC\n   protocols such as these, DSR can take advantage of additional\n\
    \   optimizations, such as the ability to reverse a source route to\n   obtain\
    \ a route back to the origin of the original route.\n   The IP address used by\
    \ a node using the DSR protocol MAY be assigned\n   by any mechanism (e.g., static\
    \ assignment or use of Dynamic Host\n   Configuration Protocol (DHCP) for dynamic\
    \ assignment [RFC2131]),\n   although the method of such assignment is outside\
    \ the scope of this\n   specification.\n   A routing protocol such as DSR chooses\
    \ a next-hop for each packet and\n   provides the IP address of that next-hop.\
    \  When the packet is\n   transmitted, however, the lower-layer protocol often\
    \ has a separate,\n   MAC-layer address for the next-hop node.  DSR uses the Address\n\
    \   Resolution Protocol (ARP) [RFC826] to translate from next-hop IP\n   addresses\
    \ to next-hop MAC addresses.  In addition, a node MAY add an\n   entry to its\
    \ ARP cache based on any received packet, when the IP\n   address and MAC address\
    \ of the transmitting node are available in the\n   packet; for example, the IP\
    \ address of the transmitting node is\n   present in a Route Request option (in\
    \ the Address list being\n   accumulated) and any packets containing a source\
    \ route.  Adding\n   entries to the ARP cache in this way avoids the overhead\
    \ of ARP in\n   most cases.\n"
- title: 3.  DSR Protocol Overview
  contents:
  - "3.  DSR Protocol Overview\n   This section provides an overview of the operation\
    \ of the DSR\n   protocol.  The basic version of DSR uses explicit \"source routing\"\
    ,\n   in which each data packet sent carries in its header the complete,\n   ordered\
    \ list of nodes through which the packet will pass.  This use\n   of explicit\
    \ source routing allows the sender to select and control\n   the routes used for\
    \ its own packets, supports the use of multiple\n   routes to any destination\
    \ (for example, for load balancing), and\n   allows a simple guarantee that the\
    \ routes used are loop-free.  By\n   including this source route in the header\
    \ of each data packet, other\n   nodes forwarding or overhearing any of these\
    \ packets can also easily\n   cache this routing information for future use. \
    \ Section 3.1 describes\n   this basic operation of Route Discovery, Section 3.2\
    \ describes basic\n   Route Maintenance, and Sections 3.3 and 3.4 describe additional\n\
    \   features of these two parts of DSR's operation.  Section 3.5 then\n   describes\
    \ an optional, compatible extension to DSR, known as \"flow\n   state\", that\
    \ allows the routing of most packets without an explicit\n   source route header\
    \ in the packet, while the fundamental properties\n   of DSR's operation are preserved.\n"
- title: 3.1.  Basic DSR Route Discovery
  contents:
  - "3.1.  Basic DSR Route Discovery\n   When some source node originates a new packet\
    \ addressed to some\n   destination node, the source node places in the header\
    \ of the packet\n   a \"source route\" giving the sequence of hops that the packet\
    \ is to\n   follow on its way to the destination.  Normally, the sender will\n\
    \   obtain a suitable source route by searching its \"Route Cache\" of\n   routes\
    \ previously learned; if no route is found in its cache, it will\n   initiate\
    \ the Route Discovery protocol to dynamically find a new route\n   to this destination\
    \ node.  In this case, we call the source node the\n   \"initiator\" and the destination\
    \ node the \"target\" of the Route\n   Discovery.\n   For example, suppose a node\
    \ A is attempting to discover a route to\n   node E.  The Route Discovery initiated\
    \ by node A in this example\n   would proceed as follows:\n            ^    \"\
    A\"    ^   \"A,B\"   ^  \"A,B,C\"  ^ \"A,B,C,D\"\n            |   id=2    |  \
    \ id=2    |   id=2    |   id=2\n         +-----+     +-----+     +-----+     +-----+\
    \     +-----+\n         |  A  |---->|  B  |---->|  C  |---->|  D  |---->|  E \
    \ |\n         +-----+     +-----+     +-----+     +-----+     +-----+\n      \
    \      |           |           |           |\n            v           v      \
    \     v           v\n   To initiate the Route Discovery, node A transmits a \"\
    Route Request\"\n   as a single local broadcast packet, which is received by\n\
    \   (approximately) all nodes currently within wireless transmission\n   range\
    \ of A, including node B in this example.  Each Route Request\n   identifies the\
    \ initiator and target of the Route Discovery, and also\n   contains a unique\
    \ request identification (2, in this example),\n   determined by the initiator\
    \ of the Request.  Each Route Request also\n   contains a record listing the address\
    \ of each intermediate node\n   through which this particular copy of the Route\
    \ Request has been\n   forwarded.  This route record is initialized to an empty\
    \ list by the\n   initiator of the Route Discovery.  In this example, the route\
    \ record\n   initially lists only node A.\n   When another node receives this\
    \ Route Request (such as node B in this\n   example), if it is the target of the\
    \ Route Discovery, it returns a\n   \"Route Reply\" to the initiator of the Route\
    \ Discovery, giving a copy\n   of the accumulated route record from the Route\
    \ Request; when the\n   initiator receives this Route Reply, it caches this route\
    \ in its\n   Route Cache for use in sending subsequent packets to this\n   destination.\n\
    \   Otherwise, if this node receiving the Route Request has recently seen\n  \
    \ another Route Request message from this initiator bearing this same\n   request\
    \ identification and target address, or if this node's own\n   address is already\
    \ listed in the route record in the Route Request,\n   this node discards the\
    \ Request.  (A node considers a Request recently\n   seen if it still has information\
    \ about that Request in its Route\n   Request Table, which is described in Section\
    \ 4.3.)  Otherwise, this\n   node appends its own address to the route record\
    \ in the Route Request\n   and propagates it by transmitting it as a local broadcast\
    \ packet\n   (with the same request identification).  In this example, node B\n\
    \   broadcast the Route Request, which is received by node C; nodes C and\n  \
    \ D each also, in turn, broadcast the Request, resulting in receipt of\n   a copy\
    \ of the Request by node E.\n   In returning the Route Reply to the initiator\
    \ of the Route Discovery,\n   such as in this example, node E replying back to\
    \ node A, node E will\n   typically examine its own Route Cache for a route back\
    \ to A and, if\n   one is found, will use it for the source route for delivery\
    \ of the\n   packet containing the Route Reply.  Otherwise, E SHOULD perform its\n\
    \   own Route Discovery for target node A, but to avoid possible infinite\n  \
    \ recursion of Route Discoveries, it MUST in this case piggyback this\n   Route\
    \ Reply on the packet containing its own Route Request for A.  It\n   is also\
    \ possible to piggyback other small data packets, such as a TCP\n   SYN packet\
    \ [RFC793], on a Route Request using this same mechanism.\n   Node E could instead\
    \ simply reverse the sequence of hops in the route\n   record that it is trying\
    \ to send in the Route Reply and use this as\n   the source route on the packet\
    \ carrying the Route Reply itself.  For\n   MAC protocols, such as IEEE 802.11,\
    \ that require a bidirectional\n   frame exchange for unicast packets as part\
    \ of the MAC protocol\n   [IEEE80211], the discovered source route MUST be reversed\
    \ in this way\n   to return the Route Reply, since this route reversal tests the\n\
    \   discovered route to ensure that it is bidirectional before the Route\n   Discovery\
    \ initiator begins using the route.  This route reversal also\n   avoids the overhead\
    \ of a possible second Route Discovery.\n   When initiating a Route Discovery,\
    \ the sending node saves a copy of\n   the original packet (that triggered the\
    \ discovery) in a local buffer\n   called the \"Send Buffer\".  The Send Buffer\
    \ contains a copy of each\n   packet that cannot be transmitted by this node because\
    \ it does not\n   yet have a source route to the packet's destination.  Each packet\
    \ in\n   the Send Buffer is logically associated with the time that it was\n \
    \  placed into the Send Buffer and is discarded after residing in the\n   Send\
    \ Buffer for some timeout period SendBufferTimeout; if necessary\n   for preventing\
    \ the Send Buffer from overflowing, a FIFO or other\n   replacement strategy MAY\
    \ also be used to evict packets even before\n   they expire.\n   While a packet\
    \ remains in the Send Buffer, the node SHOULD\n   occasionally initiate a new\
    \ Route Discovery for the packet's\n   destination address.  However, the node\
    \ MUST limit the rate at which\n   such new Route Discoveries for the same address\
    \ are initiated (as\n   described in Section 4.3), since it is possible that the\
    \ destination\n   node is not currently reachable.  In particular, due to the\
    \ limited\n   wireless transmission range and the movement of the nodes in the\n\
    \   network, the network may at times become partitioned, meaning that\n   there\
    \ is currently no sequence of nodes through which a packet could\n   be forwarded\
    \ to reach the destination.  Depending on the movement\n   pattern and the density\
    \ of nodes in the network, such network\n   partitions may be rare or common.\n\
    \   If a new Route Discovery was initiated for each packet sent by a node\n  \
    \ in such a partitioned network, a large number of unproductive Route\n   Request\
    \ packets would be propagated throughout the subset of the ad\n   hoc network\
    \ reachable from this node.  In order to reduce the\n   overhead from such Route\
    \ Discoveries, a node SHOULD use an\n   exponential back-off algorithm to limit\
    \ the rate at which it\n   initiates new Route Discoveries for the same target,\
    \ doubling the\n   timeout between each successive discovery initiated for the\
    \ same\n   target.  If the node attempts to send additional data packets to this\n\
    \   same destination node more frequently than this limit, the subsequent\n  \
    \ packets SHOULD be buffered in the Send Buffer until a Route Reply is\n   received\
    \ giving a route to this destination, but the node MUST NOT\n   initiate a new\
    \ Route Discovery until the minimum allowable interval\n   between new Route Discoveries\
    \ for this target has been reached.  This\n   limitation on the maximum rate of\
    \ Route Discoveries for the same\n   target is similar to the mechanism required\
    \ by Internet nodes to\n   limit the rate at which ARP Requests are sent for any\
    \ single target\n   IP address [RFC1122].\n"
- title: 3.2.  Basic DSR Route Maintenance
  contents:
  - "3.2.  Basic DSR Route Maintenance\n   When originating or forwarding a packet\
    \ using a source route, each\n   node transmitting the packet is responsible for\
    \ confirming that data\n   can flow over the link from that node to the next hop.\
    \  For example,\n   in the situation shown below, node A has originated a packet\
    \ for node\n   E using a source route through intermediate nodes B, C, and D:\n\
    \         +-----+     +-----+     +-----+     +-----+     +-----+\n         |\
    \  A  |---->|  B  |---->|  C  |-->? |  D  |     |  E  |\n         +-----+    \
    \ +-----+     +-----+     +-----+     +-----+\n   In this case, node A is responsible\
    \ for the link from A to B, node B\n   is responsible for the link from B to C,\
    \ node C is responsible for\n   the link from C to D, and node D is responsible\
    \ for the link from D\n   to E.\n   An acknowledgement can provide confirmation\
    \ that a link is capable of\n   carrying data, and in wireless networks, acknowledgements\
    \ are often\n   provided at no cost, either as an existing standard part of the\
    \ MAC\n   protocol in use (such as the link-layer acknowledgement frame defined\n\
    \   by IEEE 802.11 [IEEE80211]), or by a \"passive acknowledgement\"\n   [JUBIN87]\
    \ (in which, for example, B confirms receipt at C by\n   overhearing C transmit\
    \ the packet when forwarding it on to D).\n   If a built-in acknowledgement mechanism\
    \ is not available, the node\n   transmitting the packet can explicitly request\
    \ that a DSR-specific\n   software acknowledgement be returned by the next node\
    \ along the\n   route; this software acknowledgement will normally be transmitted\n\
    \   directly to the sending node, but if the link between these two nodes\n  \
    \ is unidirectional (Section 4.6), this software acknowledgement could\n   travel\
    \ over a different, multi-hop path.\n   After an acknowledgement has been received\
    \ from some neighbor, a node\n   MAY choose not to require acknowledgements from\
    \ that neighbor for a\n   brief period of time, unless the network interface connecting\
    \ a node\n   to that neighbor always receives an acknowledgement in response to\n\
    \   unicast traffic.\n   When a software acknowledgement is used, the acknowledgement\
    \ request\n   SHOULD be retransmitted up to a maximum number of times.  A\n  \
    \ retransmission of the acknowledgement request can be sent as a\n   separate\
    \ packet, piggybacked on a retransmission of the original data\n   packet, or\
    \ piggybacked on any packet with the same next-hop\n   destination that does not\
    \ also contain a software acknowledgement.\n   After the acknowledgement request\
    \ has been retransmitted the maximum\n   number of times, if no acknowledgement\
    \ has been received, then the\n   sender treats the link to this next-hop destination\
    \ as currently\n   \"broken\".  It SHOULD remove this link from its Route Cache\
    \ and SHOULD\n   return a \"Route Error\" to each node that has sent a packet\
    \ routed\n   over that link since an acknowledgement was last received.  For\n\
    \   example, in the situation shown above, if C does not receive an\n   acknowledgement\
    \ from D after some number of requests, it would return\n   a Route Error to A,\
    \ as well as any other node that may have used the\n   link from C to D since\
    \ C last received an acknowledgement from D.\n   Node A then removes this broken\
    \ link from its cache; any\n   retransmission of the original packet can be performed\
    \ by upper layer\n   protocols such as TCP, if necessary.  For sending such a\n\
    \   retransmission or other packets to this same destination E, if A has\n   in\
    \ its Route Cache another route to E (for example, from additional\n   Route Replies\
    \ from its earlier Route Discovery, or from having\n   overheard sufficient routing\
    \ information from other packets), it can\n   send the packet using the new route\
    \ immediately.  Otherwise, it\n   SHOULD perform a new Route Discovery for this\
    \ target (subject to the\n   back-off described in Section 3.1).\n"
- title: 3.3.  Additional Route Discovery Features
  contents:
  - '3.3.  Additional Route Discovery Features

    '
- title: 3.3.1.  Caching Overheard Routing Information
  contents:
  - "3.3.1.  Caching Overheard Routing Information\n   A node forwarding or otherwise\
    \ overhearing any packet SHOULD add all\n   usable routing information from that\
    \ packet to its own Route Cache.\n   The usefulness of routing information in\
    \ a packet depends on the\n   directionality characteristics of the physical medium\
    \ (Section 2), as\n   well as on the MAC protocol being used.  Specifically, three\
    \ distinct\n   cases are possible:\n   -  Links in the network frequently are\
    \ capable of operating only\n      unidirectionally (not bidirectionally), and\
    \ the MAC protocol in\n      use in the network is capable of transmitting unicast\
    \ packets over\n      unidirectional links.\n   -  Links in the network occasionally\
    \ are capable of operating only\n      unidirectionally (not bidirectionally),\
    \ but this unidirectional\n      restriction on any link is not persistent; almost\
    \ all links are\n      physically bidirectional, and the MAC protocol in use in\
    \ the\n      network is capable of transmitting unicast packets over\n      unidirectional\
    \ links.\n   -  The MAC protocol in use in the network is not capable of\n   \
    \   transmitting unicast packets over unidirectional links; only\n      bidirectional\
    \ links can be used by the MAC protocol for\n      transmitting unicast packets.\
    \  For example, the IEEE 802.11\n      Distributed Coordination Function (DCF)\
    \ MAC protocol [IEEE80211]\n      is capable of transmitting a unicast packet\
    \ only over a\n      bidirectional link, since the MAC protocol requires the return\
    \ of\n      a link-level acknowledgement packet from the receiver and also\n \
    \     optionally requires the bidirectional exchange of an RTS and CTS\n     \
    \ packet between the transmitter and receiver nodes.\n   In the first case above,\
    \ for example, the source route used in a data\n   packet, the accumulated route\
    \ record in a Route Request, or the route\n   being returned in a Route Reply\
    \ SHOULD all be cached by any node in\n   the \"forward\" direction.  Any node\
    \ SHOULD cache this information from\n   any such packet received, whether the\
    \ packet was addressed to this\n   node, sent to a broadcast (or multicast) MAC\
    \ address, or overheard\n   while the node's network interface is in promiscuous\
    \ mode.  However,\n   the \"reverse\" direction of the links identified in such\
    \ packet\n   headers SHOULD NOT be cached.\n   For example, in the situation shown\
    \ below, node A is using a source\n   route to communicate with node E:\n    \
    \  +-----+     +-----+     +-----+     +-----+     +-----+\n      |  A  |---->|\
    \  B  |---->|  C  |---->|  D  |---->|  E  |\n      +-----+     +-----+     +-----+\
    \     +-----+     +-----+\n   As node C forwards a data packet along the route\
    \ from A to E, it\n   SHOULD add to its cache the presence of the \"forward\"\
    \ direction links\n   that it learns from the headers of these packets, from itself\
    \ to D\n   and from D to E.  Node C SHOULD NOT, in this case, cache the\n   \"\
    reverse\" direction of the links identified in these packet headers,\n   from\
    \ itself back to B and from B to A, since these links might be\n   unidirectional.\n\
    \   In the second case above, in which links may occasionally operate\n   unidirectionally,\
    \ the links described above SHOULD be cached in both\n   directions.  Furthermore,\
    \ in this case, if node X overhears (e.g.,\n   through promiscuous mode) a packet\
    \ transmitted by node C that is\n   using a source route from node A to E, node\
    \ X SHOULD cache all of\n   these links as well, also including the link from\
    \ C to X over which\n   it overheard the packet.\n   In the final case, in which\
    \ the MAC protocol requires physical\n   bidirectionality for unicast operation,\
    \ links from a source route\n   SHOULD be cached in both directions, except when\
    \ the packet also\n   contains a Route Reply, in which case only the links already\n\
    \   traversed in this source route SHOULD be cached.  However, the links\n   not\
    \ yet traversed in this route SHOULD NOT be cached.\n"
- title: 3.3.2.  Replying to Route Requests Using Cached Routes
  contents:
  - "3.3.2.  Replying to Route Requests Using Cached Routes\n   A node receiving a\
    \ Route Request for which it is not the target\n   searches its own Route Cache\
    \ for a route to the target of the\n   Request.  If it is found, the node generally\
    \ returns a Route Reply to\n   the initiator itself rather than forward the Route\
    \ Request.  In the\n   Route Reply, this node sets the route record to list the\
    \ sequence of\n   hops over which this copy of the Route Request was forwarded\
    \ to it,\n   concatenated with the source route to this target obtained from its\n\
    \   own Route Cache.\n   However, before transmitting a Route Reply packet that\
    \ was generated\n   using information from its Route Cache in this way, a node\
    \ MUST\n   verify that the resulting route being returned in the Route Reply,\n\
    \   after this concatenation, contains no duplicate nodes listed in the\n   route\
    \ record.  For example, the figure below illustrates a case in\n   which a Route\
    \ Request for target E has been received by node F, and\n   node F already has\
    \ in its Route Cache a route from itself to E:\n         +-----+     +-----+ \
    \                +-----+     +-----+\n         |  A  |---->|  B  |-          \
    \     >|  D  |---->|  E  |\n         +-----+     +-----+ \\             / +-----+\
    \     +-----+\n                              \\           /\n                \
    \               \\ +-----+ /\n                                >|  C  |-\n    \
    \                             +-----+\n                                   | ^\n\
    \                                   v |\n           Route Request         +-----+\n\
    \           Route: A - B - C - F  |  F  |  Cache: C - D - E\n                \
    \                 +-----+\n   The concatenation of the accumulated route record\
    \ from the Route\n   Request and the cached route from F's Route Cache would include\
    \ a\n   duplicate node in passing from C to F and back to C.\n   Node F in this\
    \ case could attempt to edit the route to eliminate the\n   duplication, resulting\
    \ in a route from A to B to C to D and on to E,\n   but in this case, node F would\
    \ not be on the route that it returned\n   in its own Route Reply.  DSR Route\
    \ Discovery prohibits node F from\n   returning such a Route Reply from its cache;\
    \ this prohibition\n   increases the probability that the resulting route is valid,\
    \ since\n   node F in this case should have received a Route Error if the route\n\
    \   had previously stopped working.  Furthermore, this prohibition means\n   that\
    \ a future Route Error traversing the route is very likely to pass\n   through\
    \ any node that sent the Route Reply for the route (including\n   node F), which\
    \ helps to ensure that stale data is removed from caches\n   (such as at F) in\
    \ a timely manner; otherwise, the next Route\n   Discovery initiated by A might\
    \ also be contaminated by a Route Reply\n   from F containing the same stale route.\
    \  If, due to this restriction\n   on returning a Route Reply based on information\
    \ from its Route Cache,\n   node F does not return such a Route Reply, it propagates\
    \ the Route\n   Request normally.\n"
- title: 3.3.3.  Route Request Hop Limits
  contents:
  - "3.3.3.  Route Request Hop Limits\n   Each Route Request message contains a \"\
    hop limit\" that may be used to\n   limit the number of intermediate nodes allowed\
    \ to forward that copy\n   of the Route Request.  This hop limit is implemented\
    \ using the Time-\n   to-Live (TTL) field in the IP header of the packet carrying\
    \ the Route\n   Request.  As the Request is forwarded, this limit is decremented,\
    \ and\n   the Request packet is discarded if the limit reaches zero before\n \
    \  finding the target.  This Route Request hop limit can be used to\n   implement\
    \ a variety of algorithms for controlling the spread of a\n   Route Request during\
    \ a Route Discovery attempt.\n   For example, a node MAY use this hop limit to\
    \ implement a \"non-\n   propagating\" Route Request as an initial phase of a\
    \ Route Discovery.\n   A node using this technique sends its first Route Request\
    \ attempt for\n   some target node using a hop limit of 1, such that any node\
    \ receiving\n   the initial transmission of the Route Request will not forward\
    \ the\n   Request to other nodes by re-broadcasting it.  This form of Route\n\
    \   Request is called a \"non-propagating\" Route Request; it provides an\n  \
    \ inexpensive method for determining if the target is currently a\n   neighbor\
    \ of the initiator or if a neighbor node has a route to the\n   target cached\
    \ (effectively using the neighbors' Route Caches as an\n   extension of the initiator's\
    \ own Route Cache).  If no Route Reply is\n   received after a short timeout,\
    \ then the node sends a \"propagating\"\n   Route Request for the target node\
    \ (i.e., with hop limit as defined by\n   the value of the DiscoveryHopLimit configuration\
    \ variable).\n   As another example, a node MAY use this hop limit to implement\
    \ an\n   \"expanding ring\" search for the target [JOHNSON96a].  A node using\n\
    \   this technique sends an initial non-propagating Route Request as\n   described\
    \ above; if no Route Reply is received for it, the node\n   originates another\
    \ Route Request with a hop limit of 2.  For each\n   Route Request originated,\
    \ if no Route Reply is received for it, the\n   node doubles the hop limit used\
    \ on the previous attempt, to\n   progressively explore for the target node without\
    \ allowing the Route\n   Request to propagate over the entire network.  However,\
    \ this\n   expanding ring search approach could increase the average latency of\n\
    \   Route Discovery, since multiple Discovery attempts and timeouts may\n   be\
    \ needed before discovering a route to the target node.\n"
- title: 3.4.  Additional Route Maintenance Features
  contents:
  - '3.4.  Additional Route Maintenance Features

    '
- title: 3.4.1.  Packet Salvaging
  contents:
  - "3.4.1.  Packet Salvaging\n   When an intermediate node forwarding a packet detects\
    \ through Route\n   Maintenance that the next hop along the route for that packet\
    \ is\n   broken, if the node has another route to the packet's destination in\n\
    \   its Route Cache, the node SHOULD \"salvage\" the packet rather than\n   discard\
    \ it.  To salvage a packet, the node replaces the original\n   source route on\
    \ the packet with a route from its Route Cache.  The\n   node then forwards the\
    \ packet to the next node indicated along this\n   source route.  For example,\
    \ in the situation shown in the example of\n   Section 3.2, if node C has another\
    \ route cached to node E, it can\n   salvage the packet by replacing the original\
    \ route in the packet with\n   this new route from its own Route Cache rather\
    \ than discarding the\n   packet.\n   When salvaging a packet, a count is maintained\
    \ in the packet of the\n   number of times that it has been salvaged, to prevent\
    \ a single packet\n   from being salvaged endlessly.  Otherwise, since the TTL\
    \ is\n   decremented only once by each node, a single node could salvage a\n \
    \  packet an unbounded number of times.  Even if we chose to require the\n   TTL\
    \ to be decremented on each salvage attempt, packet salvaging is an\n   expensive\
    \ operation, so it is desirable to bound the maximum number\n   of times a packet\
    \ can be salvaged independently of the maximum number\n   of hops a packet can\
    \ traverse.\n   As described in Section 3.2, an intermediate node, such as in\
    \ this\n   case, that detects through Route Maintenance that the next hop along\n\
    \   the route for a packet that it is forwarding is broken, the node also\n  \
    \ SHOULD return a Route Error to the original sender of the packet,\n   identifying\
    \ the link over which the packet could not be forwarded.\n   If the node sends\
    \ this Route Error, it SHOULD originate the Route\n   Error before salvaging the\
    \ packet.\n"
- title: 3.4.2.  Queued Packets Destined over a Broken Link
  contents:
  - "3.4.2.  Queued Packets Destined over a Broken Link\n   When an intermediate node\
    \ forwarding a packet detects through Route\n   Maintenance that the next-hop\
    \ link along the route for that packet is\n   broken, in addition to handling\
    \ that packet as defined for Route\n   Maintenance, the node SHOULD also handle\
    \ in a similar way any pending\n   packets that it has queued that are destined\
    \ over this new broken\n   link.  Specifically, the node SHOULD search its Network\
    \ Interface\n   Queue and Maintenance Buffer (Section 4.5) for packets for which\
    \ the\n   next-hop link is this new broken link.  For each such packet\n   currently\
    \ queued at this node, the node SHOULD process that packet as\n   follows:\n \
    \  -  Remove the packet from the node's Network Interface Queue and\n      Maintenance\
    \ Buffer.\n   -  Originate a Route Error for this packet to the original sender\
    \ of\n      the packet, using the procedure described in Section 8.3.4, as if\n\
    \      the node had already reached the maximum number of retransmission\n   \
    \   attempts for that packet for Route Maintenance.  However, in\n      sending\
    \ such Route Errors for queued packets in response to\n      detection of a single,\
    \ new broken link, the node SHOULD send no\n      more than one Route Error to\
    \ each original sender of any of these\n      packets.\n   -  If the node has\
    \ another route to the packet's IP Destination\n      Address in its Route Cache,\
    \ the node SHOULD salvage the packet as\n      described in Section 8.3.6.  Otherwise,\
    \ the node SHOULD discard\n      the packet.\n"
- title: 3.4.3.  Automatic Route Shortening
  contents:
  - "3.4.3.  Automatic Route Shortening\n   Source routes in use MAY be automatically\
    \ shortened if one or more\n   intermediate nodes in the route become no longer\
    \ necessary.  This\n   mechanism of automatically shortening routes in use is\
    \ somewhat\n   similar to the use of passive acknowledgements [JUBIN87].  In\n\
    \   particular, if a node is able to overhear a packet carrying a source\n   route\
    \ (e.g., by operating its network interface in promiscuous\n   receive mode),\
    \ then this node examines the unexpended portion of that\n   source route.  If\
    \ this node is not the intended next-hop destination\n   for the packet but is\
    \ named in the later unexpended portion of the\n   packet's source route, then\
    \ it can infer that the intermediate nodes\n   before itself in the source route\
    \ are no longer needed in the route.\n   For example, the figure below illustrates\
    \ an example in which node D\n   has overheard a data packet being transmitted\
    \ from B to C, for later\n   forwarding to D and to E:\n         +-----+     +-----+\
    \     +-----+     +-----+     +-----+\n         |  A  |---->|  B  |---->|  C \
    \ |     |  D  |     |  E  |\n         +-----+     +-----+     +-----+     +-----+\
    \     +-----+\n                        \\                       ^\n          \
    \               \\                     /\n                          ---------------------\n\
    \   In this case, this node (node D) SHOULD return a \"gratuitous\" Route\n  \
    \ Reply to the original sender of the packet (node A).  The Route Reply\n   gives\
    \ the shorter route as the concatenation of the portion of the\n   original source\
    \ route up through the node that transmitted the\n   overheard packet (node B),\
    \ plus the suffix of the original source\n   route beginning with the node returning\
    \ the gratuitous Route Reply\n   (node D).  In this example, the route returned\
    \ in the gratuitous\n   Route Reply message sent from D to A gives the new route\
    \ as the\n   sequence of hops from A to B to D to E.\n   When deciding whether\
    \ to return a gratuitous Route Reply in this way,\n   a node MAY factor in additional\
    \ information beyond the fact that it\n   was able to overhear the packet.  For\
    \ example, the node MAY decide to\n   return the gratuitous Route Reply only when\
    \ the overheard packet is\n   received with a signal strength or signal-to-noise\
    \ ratio above some\n   specific threshold.  In addition, each node maintains a\
    \ Gratuitous\n   Route Reply Table, as described in Section 4.4, to limit the\
    \ rate at\n   which it originates gratuitous Route Replies for the same returned\n\
    \   route.\n"
- title: 3.4.4.  Increased Spreading of Route Error Messages
  contents:
  - "3.4.4.  Increased Spreading of Route Error Messages\n   When a source node receives\
    \ a Route Error for a data packet that it\n   originated, this source node propagates\
    \ this Route Error to its\n   neighbors by piggybacking it on its next Route Request.\
    \  In this way,\n   stale information in the caches of nodes around this source\
    \ node will\n   not generate Route Replies that contain the same invalid link\
    \ for\n   which this source node received the Route Error.\n   For example, in\
    \ the situation shown in the example of Section 3.2,\n   node A learns from the\
    \ Route Error message from C that the link from\n   C to D is currently broken.\
    \  It thus removes this link from its own\n   Route Cache and initiates a new\
    \ Route Discovery (if it has no other\n   route to E in its Route Cache).  On\
    \ the Route Request packet\n   initiating this Route Discovery, node A piggybacks\
    \ a copy of this\n   Route Error, ensuring that the Route Error spreads well to\
    \ other\n   nodes, and guaranteeing that any Route Reply that it receives\n  \
    \ (including those from other node's Route Caches) in response to this\n   Route\
    \ Request does not contain a route that assumes the existence of\n   this broken\
    \ link.\n"
- title: 3.5.  Optional DSR Flow State Extension
  contents:
  - "3.5.  Optional DSR Flow State Extension\n   This section describes an optional,\
    \ compatible extension to the DSR\n   protocol, known as \"flow state\", that\
    \ allows the routing of most\n   packets without an explicit source route header\
    \ in the packet.  The\n   DSR flow state extension further reduces the overhead\
    \ of the protocol\n   yet still preserves the fundamental properties of DSR's\
    \ operation.\n   Once a sending node has discovered a source route such as through\n\
    \   DSR's Route Discovery mechanism, the flow state mechanism allows the\n   sending\
    \ node to establish hop-by-hop forwarding state within the\n   network, based\
    \ on this source route, to enable each node along the\n   route to forward the\
    \ packet to the next hop based on the node's own\n   local knowledge of the flow\
    \ along which this packet is being routed.\n   Flow state is dynamically initialized\
    \ by the first packet using a\n   source route and is then able to route subsequent\
    \ packets along the\n   same flow without use of a source route header in the\
    \ packet.  The\n   state established at each hop along a flow is \"soft state\"\
    \ and thus\n   automatically expires when no longer needed and can be quickly\n\
    \   recreated as necessary.  Extending DSR's basic operation based on an\n   explicit\
    \ source route in the header of each packet routed, the flow\n   state extension\
    \ operates as a form of \"implicit source routing\" by\n   preserving DSR's basic\
    \ operation but removing the explicit source\n   route from packets.\n"
- title: 3.5.1.  Flow Establishment
  contents:
  - "3.5.1.  Flow Establishment\n   A source node sending packets to some destination\
    \ node MAY use the\n   DSR flow state extension described here to establish a\
    \ route to that\n   destination as a flow.  A \"flow\" is a route from the source\
    \ to the\n   destination represented by hop-by-hop forwarding state within the\n\
    \   nodes along the route.  Each flow is uniquely identified by a\n   combination\
    \ of the source node address, the destination node address,\n   and a flow identifier\
    \ (flow ID) chosen by the source node.\n   Each flow ID is a 16-bit unsigned integer.\
    \  Comparison between\n   different flow IDs MUST be performed modulo 2**16. \
    \ For example,\n   using an implementation in the C programming language, a flow\
    \ ID\n   value (a) is greater than another flow ID value (b) if\n   ((short)((a)\
    \ - (b)) > 0), if a C language \"short\" data type is\n   implemented as a 16-bit\
    \ signed integer.\n   A DSR Flow State header in a packet identifies the flow\
    \ ID to be\n   followed in forwarding that packet.  From a given source to some\n\
    \   destination, any number of different flows MAY exist and be in use,\n   for\
    \ example, following different sequences of hops to reach the\n   destination.\
    \  One of these flows MAY be considered the \"default\" flow\n   from that source\
    \ to that destination.  If a node receives a packet\n   with neither a DSR Options\
    \ header specifying the route to be taken\n   (with a Source Route option in the\
    \ DSR Options header) nor a DSR Flow\n   State header specifying the flow ID to\
    \ be followed, it is forwarded\n   along the default flow for the source and destination\
    \ addresses\n   specified in the packet's IP header.\n   In establishing a new\
    \ flow, the source node generates a nonzero\n   16-bit flow ID greater than any\
    \ unexpired flow IDs for this (source,\n   destination) pair.  If the source wishes\
    \ for this flow to become the\n   default flow, the low bit of the flow ID MUST\
    \ be set (the flow ID is\n   an odd number); otherwise, the low bit MUST NOT be\
    \ set (the flow ID\n   is an even number).\n   The source node establishing the\
    \ new flow then transmits a packet\n   containing a DSR Options header with a\
    \ Source Route option.  To\n   establish the flow, the source node also MUST include\
    \ in the packet a\n   DSR Flow State header, with the Flow ID field set to the\
    \ chosen flow\n   ID for the new flow, and MUST include a Timeout option in the\
    \ DSR\n   Options header, giving the lifetime after which state information\n\
    \   about this flow is to expire.  This packet will generally be a normal\n  \
    \ data packet being sent from this sender to the destination (for\n   example,\
    \ the first packet sent after discovering the new route) but\n   is also treated\
    \ as a \"flow establishment\" packet.\n   The source node records this flow in\
    \ its Flow Table for future use,\n   setting the TTL in this Flow Table entry\
    \ to the value used in the TTL\n   field in the packet's IP header and setting\
    \ the Lifetime in this\n   entry to the lifetime specified in the Timeout option\
    \ in the DSR\n   Options header.  The TTL field is used for Default Flow Forwarding,\n\
    \   as described in Sections 3.5.3 and 3.5.4.\n   Any further packets sent with\
    \ this flow ID before the timeout that\n   also contain a DSR Options header with\
    \ a Source Route option MUST use\n   this same source route in the Source Route\
    \ option.\n"
- title: 3.5.2.  Receiving and Forwarding Establishment Packets
  contents:
  - "3.5.2.  Receiving and Forwarding Establishment Packets\n   Packets intended to\
    \ establish a flow, as described in Section 3.5.1,\n   contain a DSR Options header\
    \ with a Source Route option and are\n   forwarded along the indicated route.\
    \  A node implementing the DSR\n   flow state extension, when receiving and forwarding\
    \ such a DSR\n   packet, also keeps some state in its own Flow Table to enable\
    \ it to\n   forward future packets that are sent along this flow with only the\n\
    \   flow ID specified.  Specifically, if the packet also contains a DSR\n   Flow\
    \ State header, this packet SHOULD cause an entry to be\n   established for this\
    \ flow in the Flow Table of each node along the\n   packet's route.\n   The Hop\
    \ Count field of the DSR Flow State header is also stored in\n   the Flow Table,\
    \ as is the lifetime specified in the Timeout option\n   specified in the DSR\
    \ Options header.\n   If the Flow ID is odd and there is no flow in the Flow Table\
    \ with\n   Flow ID greater than the received Flow ID, set the default Flow ID\n\
    \   for this (IP Source Address, IP Destination Address) pair to the\n   received\
    \ Flow ID, and the TTL of the packet is recorded.\n   The Flow ID option is removed\
    \ before final delivery of the packet.\n"
- title: 3.5.3.  Sending Packets along Established Flows
  contents:
  - "3.5.3.  Sending Packets along Established Flows\n   When a flow is established\
    \ as described in Section 3.5.1, a packet is\n   sent that establishes state in\
    \ each node along the route.  This state\n   is soft; that is, the protocol contains\
    \ mechanisms for recovering\n   from the loss of this state.  However, the use\
    \ of these mechanisms\n   may result in reduced performance for packets sent along\
    \ flows with\n   forgotten state.  As a result, it is desirable to differentiate\n\
    \   behavior based on whether or not the sender is reasonably certain\n   that\
    \ the flow state exists on each node along the route.  We define a\n   flow's\
    \ state to be \"established end-to-end\" if the Flow Tables of all\n   nodes on\
    \ the route contains forwarding information for that flow.\n   While it is impossible\
    \ to detect whether or not a flow's state has\n   been established end-to-end\
    \ without sending packets, implementations\n   may make reasonable assumptions\
    \ about the retention of flow state and\n   the probability that an establishment\
    \ packet has been seen by all\n   nodes on the route.\n   A source wishing to\
    \ send a packet along an established flow\n   determines if the flow state has\
    \ been established end-to-end.  If it\n   has not, a DSR Options header with Source\
    \ Route option with this\n   flow's route is added to the packet.  The source\
    \ SHOULD set the Flow\n   ID field of the DSR Flow State header either to the\
    \ flow ID\n   previously associated with this flow's route or to zero.  If it\
    \ sets\n   the Flow ID field to any other value, it MUST follow the processing\n\
    \   steps in Section 3.5.1 for establishing a new flow ID.  If it sets\n   the\
    \ Flow ID field to a nonzero value, it MUST include a Timeout\n   option with\
    \ a value not greater than the timeout remaining in the\n   node's Flow Table,\
    \ and if its TTL is not equal to that specified in\n   the Flow Table, the flow\
    \ MUST NOT be used as a default flow in the\n   future.\n   Once flow state has\
    \ been established end-to-end for non-default\n   flows, a source adds a DSR Flow\
    \ State header to each packet it wishes\n   to send along that flow, setting the\
    \ Flow ID field to the flow ID of\n   that flow.  A Source Route option SHOULD\
    \ NOT be added to the packet,\n   though if one is, then the steps for processing\
    \ flows that have not\n   been established end-to-end MUST be followed.\n   Once\
    \ flow state has been established end-to-end for default flows,\n   sources sending\
    \ packets with IP TTL equal to the TTL value in the\n   local Flow Table entry\
    \ for this flow then transmit the packet to the\n   next hop.  In this case, a\
    \ DSR Flow State header SHOULD NOT be added\n   to the packet and a DSR Options\
    \ header likewise SHOULD NOT be added\n   to the packet; though if one is, the\
    \ steps for sending packets along\n   non-default flows MUST be followed.  If\
    \ the IP TTL is not equal to\n   the TTL value in the local Flow Table, then the\
    \ steps for processing\n   a non-default flow MUST be followed.\n"
- title: 3.5.4.  Receiving and Forwarding Packets Sent along Established Flows
  contents:
  - "3.5.4.  Receiving and Forwarding Packets Sent along Established Flows\n   The\
    \ handling of packets containing a DSR Options header with both a\n   nonzero\
    \ Flow ID and a Source Route option is described in Section\n   3.5.2.  The Flow\
    \ ID is ignored when it is equal to zero.  This\n   section only describes handling\
    \ of packets without a Source Route\n   option.\n   If a node receives a packet\
    \ with a Flow ID in the DSR Options header\n   that indicates an unexpired flow\
    \ in the node's Flow Table, it\n   increments the Hop Count in the DSR Options\
    \ header and forwards the\n   packet to the next hop indicated in the Flow Table.\n\
    \   If a node receives a packet with a Flow ID that indicates a flow not\n   currently\
    \ in the node's Flow Table, it returns a Route Error of type\n   UNKNOWN_FLOW\
    \ with Error Destination and IP Destination addresses\n   copied from the IP Source\
    \ of the packet triggering the error.  This\n   error packet SHOULD be MAC-destined\
    \ to the node from which the packet\n   was received; if it cannot confirm reachability\
    \ of the previous node\n   using Route Maintenance, it MUST send the error as\
    \ described in\n   Section 8.1.1.  The node sending the error SHOULD attempt to\
    \ salvage\n   the packet triggering the Route Error.  If it does salvage the\n\
    \   packet, it MUST zero the Flow ID in the packet.\n   If a node receives a packet\
    \ with no DSR Options header and no DSR\n   Flow State header, it checks the Default\
    \ Flow Table.  If there is a\n   matching entry, it forwards to the next hop indicated\
    \ in the Flow\n   Table for the default flow.  Otherwise, it returns a Route Error\
    \ of\n   type DEFAULT_FLOW_UNKNOWN with Error Destination and IP Destination\n\
    \   addresses copied from the IP Source Address of the packet triggering\n   the\
    \ error.  This error packet SHOULD be MAC-destined to the node from\n   which\
    \ it was received; if this node cannot confirm reachability of\n   the previous\
    \ node using Route Maintenance, it MUST send the error as\n   described in Section\
    \ 8.1.1.  The node sending the error SHOULD\n   attempt to salvage the packet\
    \ triggering the Route Error.  If it does\n   salvage the packet, it MUST zero\
    \ the Flow ID in the packet.\n"
- title: 3.5.5.  Processing Route Errors
  contents:
  - "3.5.5.  Processing Route Errors\n   When a node receives a Route Error of type\
    \ UNKNOWN_FLOW, it marks the\n   flow to indicate that it has not been established\
    \ end-to-end.  When a\n   node receives a Route Error of type DEFAULT_FLOW_UNKNOWN,\
    \ it marks\n   the default flow to indicate that it has not been established end-\n\
    \   to-end.\n"
- title: 3.5.6.  Interaction with Automatic Route Shortening
  contents:
  - "3.5.6.  Interaction with Automatic Route Shortening\n   Because a full source\
    \ route is not carried in every packet, an\n   alternative method for performing\
    \ automatic route shortening is\n   necessary for packets using the flow state\
    \ extension.  Instead, nodes\n   promiscuously listen to packets, and if a node\
    \ receives a packet with\n   (IP Source, IP Destination, Flow ID) found in the\
    \ Flow Table but the\n   MAC-layer (next hop) destination address of the packet\
    \ is not this\n   node, the node determines whether the packet was sent by an\
    \ upstream\n   or downstream node by examining the Hop Count field in the DSR\
    \ Flow\n   State header.  If the Hop Count field is less than the expected Hop\n\
    \   Count at this node (that is, the expected Hop Count field in the Flow\n  \
    \ Table described in Section 5.1), the node assumes that the packet was\n   sent\
    \ by an upstream node and adds an entry for the packet to its\n   Automatic Route\
    \ Shortening Table, possibly evicting an earlier entry\n   added to this table.\
    \  When the packet is then sent to that node for\n   forwarding, the node finds\
    \ that it has previously received the packet\n   by checking its Automatic Route\
    \ Shortening Table and returns a\n   gratuitous Route Reply to the source of the\
    \ packet.\n"
- title: 3.5.7.  Loop Detection
  contents:
  - "3.5.7.  Loop Detection\n   If a node receives a packet for forwarding with TTL\
    \ lower than\n   expected and default flow forwarding is being used, it sends\
    \ a Route\n   Error of type DEFAULT_FLOW_UNKNOWN back to the IP source.  It can\n\
    \   attempt delivery of the packet by normal salvaging (subject to\n   constraints\
    \ described in Section 8.6.7).\n"
- title: 3.5.8.  Acknowledgement Destination
  contents:
  - "3.5.8.  Acknowledgement Destination\n   In packets sent using Flow State, the\
    \ previous hop is not necessarily\n   known.  In order to allow nodes that have\
    \ lost flow state to\n   determine the previous hop, the address of the previous\
    \ hop can\n   optionally be stored in the Acknowledgement Request.  This extension\n\
    \   SHOULD NOT be used when a Source Route option is present, MAY be used\n  \
    \ when flow state routing is used without a Source Route option, and\n   SHOULD\
    \ be used before Route Maintenance determines that the next-hop\n   destination\
    \ is unreachable.\n"
- title: 3.5.9.  Crash Recovery
  contents:
  - "3.5.9.  Crash Recovery\n   Each node has a maximum Timeout value that it can\
    \ possibly generate.\n   This can be based on the largest number that can be set\
    \ in a timeout\n   option (2**16 - 1 seconds) or may be less than this, set in\
    \ system\n   software.  When a node crashes, it does not establish new flows for\
    \ a\n   period equal to this maximum Timeout value, in order to avoid\n   colliding\
    \ with its old Flow IDs.\n"
- title: 3.5.10.  Rate Limiting
  contents:
  - "3.5.10.  Rate Limiting\n   Flow IDs can be assigned with a counter.  More specifically,\
    \ the\n   \"Current Flow ID\" is kept.  When a new default Flow ID needs to be\n\
    \   assigned, if the Current Flow ID is odd, the Current Flow ID is\n   assigned\
    \ as the Flow ID and the Current Flow ID is incremented by\n   one; if the Current\
    \ Flow ID is even, one plus the Current Flow ID is\n   assigned as the Flow ID\
    \ and the Current Flow ID is incremented by\n   two.\n   If Flow IDs are assigned\
    \ in this way, one algorithm for avoiding\n   duplicate, unexpired Flow IDs is\
    \ to rate limit new Flow IDs to an\n   average rate of n assignments per second,\
    \ where n is 2**15 divided by\n   the maximum Timeout value.  This can be averaged\
    \ over any period not\n   exceeding the maximum Timeout value.\n"
- title: 3.5.11.  Interaction with Packet Salvaging
  contents:
  - "3.5.11.  Interaction with Packet Salvaging\n   Salvaging is modified to zero\
    \ the Flow ID field in the packet.  Also,\n   anytime this document refers to\
    \ the Salvage field in the Source Route\n   option in a DSR Options header, packets\
    \ without a Source Route option\n   are considered to have the value zero in the\
    \ Salvage field.\n"
- title: 4.  Conceptual Data Structures
  contents:
  - "4.  Conceptual Data Structures\n   This document describes the operation of the\
    \ DSR protocol in terms of\n   a number of conceptual data structures.  This section\
    \ describes each\n   of these data structures and provides an overview of its\
    \ use in the\n   protocol.  In an implementation of the protocol, these data\n\
    \   structures MUST be implemented in a manner consistent with the\n   external\
    \ behavior described in this document, but the choice of\n   implementation used\
    \ is otherwise unconstrained.  Additional\n   conceptual data structures are required\
    \ for the optional flow state\n   extensions to DSR; these data structures are\
    \ described in Section 5.\n"
- title: 4.1.  Route Cache
  contents:
  - "4.1.  Route Cache\n   Each node implementing DSR MUST maintain a Route Cache,\
    \ containing\n   routing information needed by the node.  A node adds information\
    \ to\n   its Route Cache as it learns of new links between nodes in the ad hoc\n\
    \   network; for example, a node may learn of new links when it receives\n   a\
    \ packet carrying a Route Request, Route Reply, or DSR source route.\n   Likewise,\
    \ a node removes information from its Route Cache as it\n   learns that existing\
    \ links in the ad hoc network have broken.  For\n   example, a node may learn\
    \ of a broken link when it receives a packet\n   carrying a Route Error or through\
    \ the link-layer retransmission\n   mechanism reporting a failure in forwarding\
    \ a packet to its next-hop\n   destination.\n   Anytime a node adds new information\
    \ to its Route Cache, the node\n   SHOULD check each packet in its own Send Buffer\
    \ (Section 4.2) to\n   determine whether a route to that packet's IP Destination\
    \ Address now\n   exists in the node's Route Cache (including the information\
    \ just\n   added to the Cache).  If so, the packet SHOULD then be sent using\n\
    \   that route and removed from the Send Buffer.\n   It is possible to interface\
    \ a DSR network with other networks,\n   external to this DSR network.  Such external\
    \ networks may, for\n   example, be the Internet or may be other ad hoc networks\
    \ routed with\n   a routing protocol other than DSR.  Such external networks may\
    \ also\n   be other DSR networks that are treated as external networks in order\n\
    \   to improve scalability.  The complete handling of such external\n   networks\
    \ is beyond the scope of this document.  However, this\n   document specifies\
    \ a minimal set of requirements and features\n   necessary to allow nodes only\
    \ implementing this specification to\n   interoperate correctly with nodes implementing\
    \ interfaces to such\n   external networks.  This minimal set of requirements\
    \ and features\n   involve the First Hop External (F) and Last Hop External (L)\
    \ bits in\n   a DSR Source Route option (Section 6.7) and a Route Reply option\n\
    \   (Section 6.3) in a packet's DSR Options header (Section 6).  These\n   requirements\
    \ also include the addition of an External flag bit\n   tagging each link in the\
    \ Route Cache, copied from the First Hop\n   External (F) and Last Hop External\
    \ (L) bits in the DSR Source Route\n   option or Route Reply option from which\
    \ this link was learned.\n   The Route Cache SHOULD support storing more than\
    \ one route to each\n   destination.  In searching the Route Cache for a route\
    \ to some\n   destination node, the Route Cache is searched by destination node\n\
    \   address.  The following properties describe this searching function\n   on\
    \ a Route Cache:\n   -  Each implementation of DSR at any node MAY choose any\
    \ appropriate\n      strategy and algorithm for searching its Route Cache and\
    \ selecting\n      a \"best\" route to the destination from among those found.\
    \  For\n      example, a node MAY choose to select the shortest route to the\n\
    \      destination (the shortest sequence of hops), or it MAY use an\n      alternate\
    \ metric to select the route from the Cache.\n   -  However, if there are multiple\
    \ cached routes to a destination, the\n      selection of routes when searching\
    \ the Route Cache SHOULD prefer\n      routes that do not have the External flag\
    \ set on any link.  This\n      preference will select routes that lead directly\
    \ to the target\n      node over routes that attempt to reach the target via any\
    \ external\n      networks connected to the DSR ad hoc network.\n   -  In addition,\
    \ any route selected when searching the Route Cache\n      MUST NOT have the External\
    \ bit set for any links other than\n      possibly the first link, the last link,\
    \ or both; the External bit\n      MUST NOT be set for any intermediate hops in\
    \ the route selected.\n   An implementation of a Route Cache MAY provide a fixed\
    \ capacity for\n   the cache, or the cache size MAY be variable.  The following\n\
    \   properties describe the management of available space within a node's\n  \
    \ Route Cache:\n   -  Each implementation of DSR at each node MAY choose any appropriate\n\
    \      policy for managing the entries in its Route Cache, such as when\n    \
    \  limited cache capacity requires a choice of which entries to\n      retain\
    \ in the Cache.  For example, a node MAY chose a \"least\n      recently used\"\
    \ (LRU) cache replacement policy, in which the entry\n      last used longest\
    \ ago is discarded from the cache if a decision\n      needs to be made to allow\
    \ space in the cache for some new entry\n      being added.\n   -  However, the\
    \ Route Cache replacement policy SHOULD allow routes to\n      be categorized\
    \ based upon \"preference\", where routes with a higher\n      preferences are\
    \ less likely to be removed from the cache.  For\n      example, a node could\
    \ prefer routes for which it initiated a Route\n      Discovery over routes that\
    \ it learned as the result of promiscuous\n      snooping on other packets.  In\
    \ particular, a node SHOULD prefer\n      routes that it is presently using over\
    \ those that it is not.\n   Any suitable data structure organization, consistent\
    \ with this\n   specification, MAY be used to implement the Route Cache in any\
    \ node.\n   For example, the following two types of organization are possible:\n\
    \   -  In DSR, the route returned in each Route Reply that is received by\n  \
    \    the initiator of a Route Discovery (or that is learned from the\n      header\
    \ of overhead packets, as described in Section 8.1.4)\n      represents a complete\
    \ path (a sequence of links) leading to the\n      destination node.  By caching\
    \ each of these paths separately, a\n      \"path cache\" organization for the\
    \ Route Cache can be formed.  A\n      path cache is very simple to implement\
    \ and easily guarantees that\n      all routes are loop-free, since each individual\
    \ route from a Route\n      Reply or Route Request or used in a packet is loop-free.\
    \  To\n      search for a route in a path cache data structure, the sending\n\
    \      node can simply search its Route Cache for any path (or prefix of\n   \
    \   a path) that leads to the intended destination node.\n      This type of organization\
    \ for the Route Cache in DSR has been\n      extensively studied through simulation\
    \ [BROCH98, HU00,\n      JOHANSSON99, MALTZ99a] and through implementation of\
    \ DSR in a\n      mobile outdoor testbed under significant workload [MALTZ99b,\n\
    \      MALTZ00, MALTZ01].\n   -  Alternatively, a \"link cache\" organization\
    \ could be used for the\n      Route Cache, in which each individual link (hop)\
    \ in the routes\n      returned in Route Reply packets (or otherwise learned from\
    \ the\n      header of overhead packets) is added to a unified graph data\n  \
    \    structure of this node's current view of the network topology.  To\n    \
    \  search for a route in link cache, the sending node must use a more\n      complex\
    \ graph search algorithm, such as the well-known Dijkstra's\n      shortest-path\
    \ algorithm, to find the current best path through the\n      graph to the destination\
    \ node.  Such an algorithm is more\n      difficult to implement and may require\
    \ significantly more CPU time\n      to execute.\n      However, a link cache\
    \ organization is more powerful than a path\n      cache organization, in its\
    \ ability to effectively utilize all of\n      the potential information that\
    \ a node might learn about the state\n      of the network.  In particular, links\
    \ learned from different Route\n      Discoveries or from the header of any overheard\
    \ packets can be\n      merged together to form new routes in the network, but\
    \ this is not\n      possible in a path cache due to the separation of each individual\n\
    \      path in the cache.\n      This type of organization for the Route Cache\
    \ in DSR, including\n      the effect of a range of implementation choices, has\
    \ been studied\n      through detailed simulation [HU00].\n   The choice of data\
    \ structure organization to use for the Route Cache\n   in any DSR implementation\
    \ is a local matter for each node and affects\n   only performance; any reasonable\
    \ choice of organization for the Route\n   Cache does not affect either correctness\
    \ or interoperability.\n   Each entry in the Route Cache SHOULD have a timeout\
    \ associated with\n   it, to allow that entry to be deleted if not used within\
    \ some time.\n   The particular choice of algorithm and data structure used to\n\
    \   implement the Route Cache SHOULD be considered in choosing the\n   timeout\
    \ for entries in the Route Cache.  The configuration variable\n   RouteCacheTimeout\
    \ defined in Section 9 specifies the timeout to be\n   applied to entries in the\
    \ Route Cache, although it is also possible\n   to instead use an adaptive policy\
    \ in choosing timeout values rather\n   than using a single timeout setting for\
    \ all entries.  For example,\n   the Link-MaxLife cache design (below) uses an\
    \ adaptive timeout\n   algorithm and does not use the RouteCacheTimeout configuration\n\
    \   variable.\n   As guidance to implementers, Appendix A describes a type of\
    \ link\n   cache known as \"Link-MaxLife\" that has been shown to outperform other\n\
    \   types of link caches and path caches studied in detailed simulation\n   [HU00].\
    \  Link-MaxLife is an adaptive link cache in which each link in\n   the cache\
    \ has a timeout that is determined dynamically by the caching\n   node according\
    \ to its observed past behavior of the two nodes at the\n   ends of the link.\
    \  In addition, when selecting a route for a packet\n   being sent to some destination,\
    \ among cached routes of equal length\n   (number of hops) to that destination,\
    \ Link-MaxLife selects the route\n   with the longest expected lifetime (highest\
    \ minimum timeout of any\n   link in the route).  Use of the Link-MaxLife design\
    \ for the Route\n   Cache is recommended in implementations of DSR.\n"
- title: 4.2.  Send Buffer
  contents:
  - "4.2.  Send Buffer\n   The Send Buffer of a node implementing DSR is a queue of\
    \ packets that\n   cannot be sent by that node because it does not yet have a\
    \ source\n   route to each such packet's destination.  Each packet in the Send\n\
    \   Buffer is logically associated with the time that it was placed into\n   the\
    \ buffer and SHOULD be removed from the Send Buffer and silently\n   discarded\
    \ after a period of SendBufferTimeout after initially being\n   placed in the\
    \ buffer.  If necessary, a FIFO strategy SHOULD be used\n   to evict packets before\
    \ they time out to prevent the buffer from\n   overflowing.\n   Subject to the\
    \ rate limiting defined in Section 4.3, a Route\n   Discovery SHOULD be initiated\
    \ as often as allowed for the destination\n   address of any packets residing\
    \ in the Send Buffer.\n"
- title: 4.3.  Route Request Table
  contents:
  - "4.3.  Route Request Table\n   The Route Request Table of a node implementing\
    \ DSR records\n   information about Route Requests that have been recently originated\n\
    \   or forwarded by this node.  The table is indexed by IP address.\n   The Route\
    \ Request Table on a node records the following information\n   about nodes to\
    \ which this node has initiated a Route Request:\n   -  The Time-to-Live (TTL)\
    \ field used in the IP header of the Route\n      Request for the last Route Discovery\
    \ initiated by this node for\n      that target node.  This value allows the node\
    \ to implement a\n      variety of algorithms for controlling the spread of its\
    \ Route\n      Request on each Route Discovery initiated for a target.  As\n \
    \     examples, two possible algorithms for this use of the TTL field\n      are\
    \ described in Section 3.3.3.\n   -  The time that this node last originated a\
    \ Route Request for that\n      target node.\n   -  The number of consecutive\
    \ Route Discoveries initiated for this\n      target since receiving a valid Route\
    \ Reply giving a route to that\n      target node.\n   -  The remaining amount\
    \ of time before which this node MAY next\n      attempt at a Route Discovery\
    \ for that target node.  When the node\n      initiates a new Route Discovery\
    \ for this target node, this field\n      in the Route Request Table entry for\
    \ that target node is\n      initialized to the timeout for that Route Discovery,\
    \ after which\n      the node MAY initiate a new Discovery for that target.  Until\
    \ a\n      valid Route Reply is received for this target node address, a node\n\
    \      MUST implement a back-off algorithm in determining this timeout\n     \
    \ value for each successive Route Discovery initiated for this\n      target using\
    \ the same Time-to-Live (TTL) value in the IP header of\n      the Route Request\
    \ packet.  The timeout between such consecutive\n      Route Discovery initiations\
    \ SHOULD increase by doubling the\n      timeout value on each new initiation.\n\
    \   In addition, the Route Request Table on a node also records the\n   following\
    \ information about initiator nodes from which this node has\n   received a Route\
    \ Request:\n   -  A FIFO cache of size RequestTableIds entries containing the\n\
    \      Identification value and target address from the most recent Route\n  \
    \    Requests received by this node from that initiator node.\n   Nodes SHOULD\
    \ use an LRU policy to manage the entries in their Route\n   Request Table.\n\
    \   The number of Identification values to retain in each Route Request\n   Table\
    \ entry, RequestTableIds, MUST NOT be unlimited, since, in the\n   worst case,\
    \ when a node crashes and reboots, the first\n   RequestTableIds Route Discoveries\
    \ it initiates after rebooting could\n   appear to be duplicates to the other\
    \ nodes in the network.  In\n   addition, a node SHOULD base its initial Identification\
    \ value, used\n   for Route Discoveries after rebooting, on a battery backed-up\
    \ clock\n   or other persistent memory device, if available, in order to help\n\
    \   avoid any possible such delay in successfully discovering new routes\n   after\
    \ rebooting; if no such source of initial Identification value is\n   available,\
    \ a node after rebooting SHOULD base its initial\n   Identification value on a\
    \ random number.\n"
- title: 4.4.  Gratuitous Route Reply Table
  contents:
  - "4.4.  Gratuitous Route Reply Table\n   The Gratuitous Route Reply Table of a\
    \ node implementing DSR records\n   information about \"gratuitous\" Route Replies\
    \ sent by this node as\n   part of automatic route shortening.  As described in\
    \ Section 3.4.3, a\n   node returns a gratuitous Route Reply when it overhears\
    \ a packet\n   transmitted by some node, for which the node overhearing the packet\n\
    \   was not the intended next-hop node but was named later in the\n   unexpended\
    \ hops of the source route in that packet; the node\n   overhearing the packet\
    \ returns a gratuitous Route Reply to the\n   original sender of the packet, listing\
    \ the shorter route (not\n   including the hops of the source route \"skipped\
    \ over\" by this\n   packet).  A node uses its Gratuitous Route Reply Table to\
    \ limit the\n   rate at which it originates gratuitous Route Replies to the same\n\
    \   original sender for the same node from which it overheard a packet to\n  \
    \ trigger the gratuitous Route Reply.\n   Each entry in the Gratuitous Route Reply\
    \ Table of a node contains the\n   following fields:\n   -  The address of the\
    \ node to which this node originated a gratuitous\n      Route Reply.\n   -  The\
    \ address of the node from which this node overheard the packet\n      triggering\
    \ that gratuitous Route Reply.\n   -  The remaining time before which this entry\
    \ in the Gratuitous Route\n      Reply Table expires and SHOULD be deleted by\
    \ the node.  When a\n      node creates a new entry in its Gratuitous Route Reply\
    \ Table, the\n      timeout value for that entry SHOULD be initialized to the\
    \ value\n      GratReplyHoldoff.\n   When a node overhears a packet that would\
    \ trigger a gratuitous Route\n   Reply, if a corresponding entry already exists\
    \ in the node's\n   Gratuitous Route Reply Table, then the node SHOULD NOT send\
    \ a\n   gratuitous Route Reply for that packet.  Otherwise (i.e., if no\n   corresponding\
    \ entry already exists), the node SHOULD create a new\n   entry in its Gratuitous\
    \ Route Reply Table to record that gratuitous\n   Route Reply, with a timeout\
    \ value of GratReplyHoldoff.\n"
- title: 4.5.  Network Interface Queue and Maintenance Buffer
  contents:
  - "4.5.  Network Interface Queue and Maintenance Buffer\n   Depending on factors\
    \ such as the structure and organization of the\n   operating system, protocol\
    \ stack implementation, network interface\n   device driver, and network interface\
    \ hardware, a packet being\n   transmitted could be queued in a variety of ways.\
    \  For example,\n   outgoing packets from the network protocol stack might be\
    \ queued at\n   the operating system or link layer, before transmission by the\n\
    \   network interface.  The network interface might also provide a\n   retransmission\
    \ mechanism for packets, such as occurs in IEEE 802.11\n   [IEEE80211]; the DSR\
    \ protocol, as part of Route Maintenance, requires\n   limited buffering of packets\
    \ already transmitted for which the\n   reachability of the next-hop destination\
    \ has not yet been determined.\n   The operation of DSR is defined here in terms\
    \ of two conceptual data\n   structures that, together, incorporate this queuing\
    \ behavior.\n   The Network Interface Queue of a node implementing DSR is an output\n\
    \   queue of packets from the network protocol stack waiting to be\n   transmitted\
    \ by the network interface; for example, in the 4.4BSD Unix\n   network protocol\
    \ stack implementation, this queue for a network\n   interface is represented\
    \ as a \"struct ifqueue\" [WRIGHT95].  This\n   queue is used to hold packets\
    \ while the network interface is in the\n   process of transmitting another packet.\n\
    \   The Maintenance Buffer of a node implementing DSR is a queue of\n   packets\
    \ sent by this node that are awaiting next-hop reachability\n   confirmation as\
    \ part of Route Maintenance.  For each packet in the\n   Maintenance Buffer, a\
    \ node maintains a count of the number of\n   retransmissions and the time of\
    \ the last retransmission.  Packets are\n   added to the Maintenance buffer after\
    \ the first transmission attempt\n   is made.  The Maintenance Buffer MAY be of\
    \ limited size; when adding\n   a new packet to the Maintenance Buffer, if the\
    \ buffer size is\n   insufficient to hold the new packet, the new packet SHOULD\
    \ be\n   silently discarded.  If, after MaxMaintRexmt attempts to confirm\n  \
    \ next-hop reachability of some node, no confirmation is received, all\n   packets\
    \ in this node's Maintenance Buffer with this next-hop\n   destination SHOULD\
    \ be removed from the Maintenance Buffer.  In this\n   case, the node also SHOULD\
    \ originate a Route Error for this packet to\n   each original source of a packet\
    \ removed in this way (Section 8.3)\n   and SHOULD salvage each packet removed\
    \ in this way (Section 8.3.6) if\n   it has another route to that packet's IP\
    \ Destination Address in its\n   Route Cache.  The definition of MaxMaintRexmt\
    \ conceptually includes\n   any retransmissions that might be attempted for a\
    \ packet at the link\n   layer or within the network interface hardware.  The\
    \ timeout value to\n   use for each transmission attempt for an acknowledgement\
    \ request\n   depends on the type of acknowledgement mechanism used by Route\n\
    \   Maintenance for that attempt, as described in Section 8.3.\n"
- title: 4.6.  Blacklist
  contents:
  - "4.6.  Blacklist\n   When a node using the DSR protocol is connected through a\
    \ network\n   interface that requires physically bidirectional links for unicast\n\
    \   transmission, the node MUST maintain a blacklist.  The blacklist is a\n  \
    \ table, indexed by neighbor node address, that indicates that the link\n   between\
    \ this node and the specified neighbor node may not be\n   bidirectional.  A node\
    \ places another node's address in this list\n   when it believes that broadcast\
    \ packets from that other node reach\n   this node, but that unicast transmission\
    \ between the two nodes is not\n   possible.  For example, if a node forwarding\
    \ a Route Reply discovers\n   that the next hop is unreachable, it places that\
    \ next hop in the\n   node's blacklist.\n   Once a node discovers that it can\
    \ communicate bidirectionally with\n   one of the nodes listed in the blacklist,\
    \ it SHOULD remove that node\n   from the blacklist.  For example, if node A has\
    \ node B listed in its\n   blacklist, but after transmitting a Route Request,\
    \ node A hears B\n   forward the Route Request with a route record indicating\
    \ that the\n   broadcast from A to B was successful, then A SHOULD remove the\
    \ entry\n   for node B from its blacklist.\n   A node MUST associate a state with\
    \ each node listed in its blacklist,\n   specifying whether the unidirectionality\
    \ of the link to that node is\n   \"questionable\" or \"probable\".  Each time\
    \ the unreachability is\n   positively determined, the node SHOULD set the state\
    \ to \"probable\".\n   After the unreachability has not been positively determined\
    \ for some\n   amount of time, the state SHOULD revert to \"questionable\".  A\
    \ node\n   MAY expire entries for nodes from its blacklist after a reasonable\n\
    \   amount of time.\n"
- title: 5.  Additional Conceptual Data Structures for Flow State Extension
  contents:
  - "5.  Additional Conceptual Data Structures for Flow State Extension\n   This section\
    \ defines additional conceptual data structures used by\n   the optional \"flow\
    \ state\" extension to DSR.  In an implementation of\n   the protocol, these data\
    \ structures MUST be implemented in a manner\n   consistent with the external\
    \ behavior described in this document, but\n   the choice of implementation used\
    \ is otherwise unconstrained.\n"
- title: 5.1.  Flow Table
  contents:
  - "5.1.  Flow Table\n   A node implementing the flow state extension MUST implement\
    \ a Flow\n   Table or other data structure consistent with the external behavior\n\
    \   described in this section.  A node not implementing the flow state\n   extension\
    \ SHOULD NOT implement a Flow Table.\n   The Flow Table records information about\
    \ flows from which packets\n   recently have been sent or forwarded by this node.\
    \  The table is\n   indexed by a triple (IP Source Address, IP Destination Address,\
    \ Flow\n   ID), where Flow ID is a 16-bit number assigned by the source as\n \
    \  described in Section 3.5.1.  Each entry in the Flow Table contains\n   the\
    \ following fields:\n   -  The MAC address of the next-hop node along this flow.\n\
    \   -  An indication of the outgoing network interface on this node to be\n  \
    \    used in transmitting packets along this flow.\n   -  The MAC address of the\
    \ previous-hop node along this flow.\n   -  An indication of the network interface\
    \ on this node from which\n      packets from that previous-hop node are received.\n\
    \   -  A timeout after which this entry in the Flow Table MUST be\n      deleted.\n\
    \   -  The expected value of the Hop Count field in the DSR Flow State\n     \
    \ header for packets received for forwarding along this field (for\n      use\
    \ with packets containing a DSR Flow State header).\n   -  An indication of whether\
    \ or not this flow can be used as a default\n      flow for packets originated\
    \ by this node (the Flow ID of a default\n      flow MUST be odd).\n   -  The\
    \ entry SHOULD record the complete source route for the flow.\n      (Nodes not\
    \ recording the complete source route cannot participate\n      in Automatic Route\
    \ Shortening.)\n   -  The entry MAY contain a field recording the time this entry\
    \ was\n      last used.\n   The entry MUST be deleted when its timeout expires.\n"
- title: 5.2.  Automatic Route Shortening Table
  contents:
  - "5.2.  Automatic Route Shortening Table\n   A node implementing the flow state\
    \ extension SHOULD implement an\n   Automatic Route Shortening Table or other\
    \ data structure consistent\n   with the external behavior described in this section.\
    \  A node not\n   implementing the flow state extension SHOULD NOT implement an\n\
    \   Automatic Route Shortening Table.\n   The Automatic Route Shortening Table\
    \ records information about\n   received packets for which Automatic Route Shortening\
    \ may be\n   possible.  The table is indexed by a triple (IP Source Address, IP\n\
    \   Destination Address, Flow ID).  Each entry in the Automatic Route\n   Shortening\
    \ Table contains a list of (packet identifier, Hop Count)\n   pairs for that flow.\
    \  The packet identifier in the list may be any\n   unique identifier for the\
    \ received packet; for example, for IPv4\n   packets, the combination of the following\
    \ fields from the packet's IP\n   header MAY be used as a unique identifier for\
    \ the packet:  Source\n   Address, Destination Address, Identification, Protocol,\
    \ Fragment\n   Offset, and Total Length.  The Hop Count in the list in the entry\
    \ is\n   copied from the Hop Count field in the DSR Flow State header of the\n\
    \   received packet for which this table entry was created.  Any packet\n   identifier\
    \ SHOULD appear at most once in an entry's list, and this\n   list item SHOULD\
    \ record the minimum Hop Count value received for that\n   packet (if the wireless\
    \ signal strength or signal-to-noise ratio at\n   which a packet is received is\
    \ available to the DSR implementation in\n   a node, the node MAY, for example,\
    \ remember instead in this list the\n   minimum Hop Count value for which the\
    \ received packet's signal\n   strength or signal-to-noise ratio exceeded some\
    \ threshold).\n   Space in the Automatic Route Shortening Table of a node MAY\
    \ be\n   dynamically managed by any local algorithm at the node.  For example,\n\
    \   in order to limit the amount of memory used to store the table, any\n   existing\
    \ entry MAY be deleted at any time, and the number of packets\n   listed in each\
    \ entry MAY be limited.  However, when reclaiming space\n   in the table, nodes\
    \ SHOULD favor retaining information about more\n   flows in the table rather\
    \ than about more packets listed in each\n   entry in the table, as long as at\
    \ least the listing of some small\n   number of packets (e.g., 3) can be retained\
    \ in each entry.\n"
- title: 5.3.  Default Flow ID Table
  contents:
  - "5.3.  Default Flow ID Table\n   A node implementing the flow state extension\
    \ MUST implement a Default\n   Flow Table or other data structure consistent with\
    \ the external\n   behavior described in this section.  A node not implementing\
    \ the flow\n   state extension SHOULD NOT implement a Default Flow Table.\n  \
    \ For each (IP Source Address, IP Destination Address) pair for which a\n   node\
    \ forwards packets, the node MUST record:\n   -  The largest odd Flow ID value\
    \ seen.\n   -  The time at which all the corresponding flows that are forwarded\n\
    \      by this node expire.\n   -  The current default Flow ID.\n   -  A flag\
    \ indicating whether or not the current default Flow ID is\n      valid.\n   If\
    \ a node deletes this record for an (IP Source Address, IP\n   Destination Address)\
    \ pair, it MUST also delete all Flow Table entries\n   for that pair.  Nodes MUST\
    \ delete table entries if all of this (IP\n   Source Address, IP Destination Address)\
    \ pair's flows that are\n   forwarded by this node expire.\n"
- title: 6.  DSR Options Header Format
  contents:
  - "6.  DSR Options Header Format\n   The Dynamic Source Routing protocol makes use\
    \ of a special header\n   carrying control information that can be included in\
    \ any existing IP\n   packet.  This DSR Options header in a packet contains a\
    \ small fixed-\n   sized, 4-octet portion, followed by a sequence of zero or more\
    \ DSR\n   options carrying optional information.  The end of the sequence of\n\
    \   DSR options in the DSR Options header is implied by the total length\n   of\
    \ the DSR Options header.\n   For IPv4, the DSR Options header MUST immediately\
    \ follow the IP\n   header in the packet.  (If a Hop-by-Hop Options extension\
    \ header, as\n   defined in IPv6 [RFC2460], becomes defined for IPv4, the DSR\
    \ Options\n   header MUST immediately follow the Hop-by-Hop Options extension\n\
    \   header, if one is present in the packet, and MUST otherwise\n   immediately\
    \ follow the IP header.)\n   To add a DSR Options header to a packet, the DSR\
    \ Options header is\n   inserted following the packet's IP header, before any\
    \ following\n   header such as a traditional (e.g., TCP or UDP) transport layer\n\
    \   header.  Specifically, the Protocol field in the IP header is used to\n  \
    \ indicate that a DSR Options header follows the IP header, and the\n   Next Header\
    \ field in the DSR Options header is used to indicate the\n   type of protocol\
    \ header (such as a transport layer header) following\n   the DSR Options header.\n\
    \   If any headers follow the DSR Options header in a packet, the total\n   length\
    \ of the DSR Options header (and thus the total, combined length\n   of all DSR\
    \ options present) MUST be a multiple of 4 octets.  This\n   requirement preserves\
    \ the alignment of these following headers in the\n   packet.\n"
- title: 6.1.  Fixed Portion of DSR Options Header
  contents:
  - "6.1.  Fixed Portion of DSR Options Header\n   The fixed portion of the DSR Options\
    \ header is used to carry\n   information that must be present in any DSR Options\
    \ header.  This\n   fixed portion of the DSR Options header has the following\
    \ format:\n    0                   1                   2                   3\n\
    \    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |  Next Header  |F|   Reserved  |        Payload Length         |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   .                                                               .\n   .  \
    \                          Options                            .\n   .        \
    \                                                       .\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      Next Header\n         8-bit selector.  Identifies the type of header immediately\n\
    \         following the DSR Options header.  Uses the same values as the\n   \
    \      IPv4 Protocol field [RFC1700].  If no header follows, then Next\n     \
    \    Header MUST have the value 59, \"No Next Header\" [RFC2460].\n      Flow\
    \ State Header (F)\n         Flag bit.  MUST be set to 0.  This bit is set in\
    \ a DSR Flow\n         State header (Section 7.1) and clear in a DSR Options header.\n\
    \      Reserved\n         MUST be sent as 0 and ignored on reception.\n      Payload\
    \ Length\n         The length of the DSR Options header, excluding the 4-octet\n\
    \         fixed portion.  The value of the Payload Length field defines\n    \
    \     the total length of all options carried in the DSR Options\n         header.\n\
    \      Options\n         Variable-length field; the length of the Options field\
    \ is\n         specified by the Payload Length field in this DSR Options\n   \
    \      header.  Contains one or more pieces of optional information\n        \
    \ (DSR options), encoded in type-length-value (TLV) format (with\n         the\
    \ exception of the Pad1 option described in Section 6.8).\n   The placement of\
    \ DSR options following the fixed portion of the DSR\n   Options header MAY be\
    \ padded for alignment.  However, due to the\n   typically limited available wireless\
    \ bandwidth in ad hoc networks,\n   this padding is not required, and receiving\
    \ nodes MUST NOT expect\n   options within a DSR Options header to be aligned.\n\
    \   Each DSR option is assigned a unique Option Type code.  The most\n   significant\
    \ 3 bits (that is, Option Type & 0xE0) allow a node not\n   implementing processing\
    \ for this Option Type value to behave in the\n   manner closest to correct for\
    \ that type:\n   -  The most significant bit in the Option Type value (that is,\
    \ Option\n      Type & 0x80) represents whether or not a node receiving this\n\
    \      Option Type (when the node does not implement processing for this\n   \
    \   Option Type) SHOULD respond to such a DSR option with a Route\n      Error\
    \ of type OPTION_NOT_SUPPORTED, except that such a Route Error\n      SHOULD never\
    \ be sent in response to a packet containing a Route\n      Request option.\n\
    \   -  The two following bits in the Option Type value (that is, Option\n    \
    \  Type & 0x60) are a two-bit field indicating how such a node that\n      does\
    \ not support this Option Type MUST process the packet:\n         00 = Ignore\
    \ Option\n         01 = Remove Option\n         10 = Mark Option\n         11\
    \ = Drop Packet\n      When these 2 bits are 00 (that is, Option Type & 0x60 ==\
    \ 0), a\n      node not implementing processing for that Option Type MUST use\
    \ the\n      Opt Data Len field to skip over the option and continue\n      processing.\
    \  When these 2 bits are 01 (that is, Option Type & 0x60\n      == 0x20), a node\
    \ not implementing processing for that Option Type\n      MUST use the Opt Data\
    \ Len field to remove the option from the\n      packet and continue processing\
    \ as if the option had not been\n      included in the received packet.  When\
    \ these 2 bits are 10 (that\n      is, Option Type & 0x60 == 0x40), a node not\
    \ implementing\n      processing for that Option Type MUST set the most significant\
    \ bit\n      following the Opt Data Len field, MUST ignore the contents of the\n\
    \      option using the Opt Data Len field, and MUST continue processing\n   \
    \   the packet.  Finally, when these 2 bits are 11 (that is, Option\n      Type\
    \ & 0x60 == 0x60), a node not implementing processing for that\n      Option Type\
    \ MUST drop the packet.\n   The following types of DSR options are defined in\
    \ this document for\n   use within a DSR Options header:\n   -  Route Request\
    \ option (Section 6.2)\n   -  Route Reply option (Section 6.3)\n   -  Route Error\
    \ option (Section 6.4)\n   -  Acknowledgement Request option (Section 6.5)\n \
    \  -  Acknowledgement option (Section 6.6)\n   -  DSR Source Route option (Section\
    \ 6.7)\n   -  Pad1 option (Section 6.8)\n   -  PadN option (Section 6.9)\n   In\
    \ addition, Section 7 specifies further DSR options for use with the\n   optional\
    \ DSR flow state extension.\n"
- title: 6.2.  Route Request Option
  contents:
  - "6.2.  Route Request Option\n   The Route Request option in a DSR Options header\
    \ is encoded as\n   follows:\n    0                   1                   2  \
    \                 3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6\
    \ 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |  Option Type  |  Opt Data Len |         Identification        |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                         Target Address                        |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                           Address[1]                          |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                           Address[2]                          |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                              ...                              |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                           Address[n]                          |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   IP fields:\n      Source Address\n         MUST be set to the address of the\
    \ node originating this packet.\n         Intermediate nodes that retransmit the\
    \ packet to propagate the\n         Route Request MUST NOT change this field.\n\
    \      Destination Address\n         MUST be set to the IP limited broadcast address\n\
    \         (255.255.255.255).\n      Hop Limit (TTL)\n         MAY be varied from\
    \ 1 to 255, for example, to implement non-\n         propagating Route Requests\
    \ and Route Request expanding-ring\n         searches (Section 3.3.3).\n   Route\
    \ Request fields:\n      Option Type\n         1.  Nodes not understanding this\
    \ option will ignore this\n         option.\n      Opt Data Len\n         8-bit\
    \ unsigned integer.  Length of the option, in octets,\n         excluding the\
    \ Option Type and Opt Data Len fields.  MUST be set\n         equal to (4 * n)\
    \ + 6, where n is the number of addresses in the\n         Route Request Option.\n\
    \      Identification\n         A unique value generated by the initiator (original\
    \ sender) of\n         the Route Request.  Nodes initiating a Route Request generate\
    \ a\n         new Identification value for each Route Request, for example\n \
    \        based on a sequence number counter of all Route Requests\n         initiated\
    \ by the node.\n         This value allows a receiving node to determine whether\
    \ it has\n         recently seen a copy of this Route Request.  If this\n    \
    \     Identification value (for this IP Source address and Target\n         Address)\
    \ is found by this receiving node in its Route Request\n         Table (in the\
    \ cache of Identification values in the entry there\n         for this initiating\
    \ node), this receiving node MUST discard the\n         Route Request.  When a\
    \ Route Request is propagated, this field\n         MUST be copied from the received\
    \ copy of the Route Request\n         being propagated.\n      Target Address\n\
    \         The address of the node that is the target of the Route\n         Request.\n\
    \      Address[1..n]\n         Address[i] is the IPv4 address of the i-th node\
    \ recorded in the\n         Route Request option.  The address given in the Source\
    \ Address\n         field in the IP header is the address of the initiator of\
    \ the\n         Route Discovery and MUST NOT be listed in the Address[i]\n   \
    \      fields; the address given in Address[1] is thus the IPv4\n         address\
    \ of the first node on the path after the initiator.  The\n         number of\
    \ addresses present in this field is indicated by the\n         Opt Data Len field\
    \ in the option (n = (Opt Data Len - 6) / 4).\n         Each node propagating\
    \ the Route Request adds its own address to\n         this list, increasing the\
    \ Opt Data Len value by 4 octets.\n   The Route Request option MUST NOT appear\
    \ more than once within a DSR\n   Options header.\n"
- title: 6.3.  Route Reply Option
  contents:
  - "6.3.  Route Reply Option\n   The Route Reply option in a DSR Options header is\
    \ encoded as follows:\n    0                   1                   2         \
    \          3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9\
    \ 0 1\n                   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                   |  Option Type  |  Opt Data Len |L|   Reserved  |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                           Address[1]                          |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                           Address[2]                          |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                              ...                              |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                           Address[n]                          |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   IP fields:\n      Source Address\n         Set to the address of the node\
    \ sending the Route Reply.  In the\n         case of a node sending a reply from\
    \ its Route Cache (Section\n         3.3.2) or sending a gratuitous Route Reply\
    \ (Section 3.4.3),\n         this address can differ from the address that was\
    \ the target of\n         the Route Discovery.\n      Destination Address\n  \
    \       MUST be set to the address of the source node of the route\n         being\
    \ returned.  Copied from the Source Address field of the\n         Route Request\
    \ generating the Route Reply or, in the case of a\n         gratuitous Route Reply,\
    \ copied from the Source Address field of\n         the data packet triggering\
    \ the gratuitous Reply.\n   Route Reply fields:\n      Option Type\n         2.\
    \  Nodes not understanding this option will ignore this\n         option.\n  \
    \    Opt Data Len\n         8-bit unsigned integer.  Length of the option, in\
    \ octets,\n         excluding the Option Type and Opt Data Len fields.  MUST be\
    \ set\n         equal to (4 * n) + 1, where n is the number of addresses in the\n\
    \         Route Reply Option.\n      Last Hop External (L)\n         Set to indicate\
    \ that the last hop given by the Route Reply (the\n         link from Address[n-1]\
    \ to Address[n]) is actually an arbitrary\n         path in a network external\
    \ to the DSR network; the exact route\n         outside the DSR network is not\
    \ represented in the Route Reply.\n         Nodes caching this hop in their Route\
    \ Cache MUST flag the\n         cached hop with the External flag.  Such hops\
    \ MUST NOT be\n         returned in a cached Route Reply generated from this Route\n\
    \         Cache entry, and selection of routes from the Route Cache to\n     \
    \    route a packet being sent SHOULD prefer routes that contain no\n        \
    \ hops flagged as External.\n      Reserved\n         MUST be sent as 0 and ignored\
    \ on reception.\n      Address[1..n]\n         The source route being returned\
    \ by the Route Reply.  The route\n         indicates a sequence of hops, originating\
    \ at the source node\n         specified in the Destination Address field of the\
    \ IP header of\n         the packet carrying the Route Reply, through each of\
    \ the\n         Address[i] nodes in the order listed in the Route Reply, ending\n\
    \         at the node indicated by Address[n].  The number of addresses\n    \
    \     present in the Address[1..n] field is indicated by the Opt Data\n      \
    \   Len field in the option (n = (Opt Data Len - 1) / 4).\n   A Route Reply option\
    \ MAY appear one or more times within a DSR\n   Options header.\n"
- title: 6.4.  Route Error Option
  contents:
  - "6.4.  Route Error Option\n   The Route Error option in a DSR Options header is\
    \ encoded as follows:\n    0                   1                   2         \
    \          3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9\
    \ 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |  Option Type  |  Opt Data Len |   Error Type  |Reservd|Salvage|\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                      Error Source Address                     |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                   Error Destination Address                   |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   .                                                               .\n   .  \
    \                 Type-Specific Information                   .\n   .        \
    \                                                       .\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      Option Type\n         3.  Nodes not understanding this option will ignore\
    \ this\n         option.\n      Opt Data Len\n         8-bit unsigned integer.\
    \  Length of the option, in octets,\n         excluding the Option Type and Opt\
    \ Data Len fields.\n         For the current definition of the Route Error option,\n\
    \         this field MUST be set to 10, plus the size of any\n         Type-Specific\
    \ Information present in the Route Error.  Further\n         extensions to the\
    \ Route Error option format may also be\n         included after the Type-Specific\
    \ Information portion of the\n         Route Error option specified above.  The\
    \ presence of such\n         extensions will be indicated by the Opt Data Len\
    \ field.\n         When the Opt Data Len is greater than that required for\n \
    \        the fixed portion of the Route Error plus the necessary\n         Type-Specific\
    \ Information as indicated by the Option Type\n         value in the option, the\
    \ remaining octets are interpreted as\n         extensions.  Currently, no such\
    \ further extensions have been\n         defined.\n      Error Type\n        \
    \ The type of error encountered.  Currently, the following type\n         values\
    \ are defined:\n            1 = NODE_UNREACHABLE\n            2 = FLOW_STATE_NOT_SUPPORTED\n\
    \            3 = OPTION_NOT_SUPPORTED\n         Other values of the Error Type\
    \ field are reserved for future\n         use.\n      Reservd\n         Reserved.\
    \  MUST be sent as 0 and ignored on reception.\n      Salvage\n         A 4-bit\
    \ unsigned integer.  Copied from the Salvage field in the\n         DSR Source\
    \ Route option of the packet triggering the Route\n         Error.\n         The\
    \ \"total salvage count\" of the Route Error option is derived\n         from\
    \ the value in the Salvage field of this Route Error option\n         and all\
    \ preceding Route Error options in the packet as follows:\n         the total\
    \ salvage count is the sum of, for each such Route\n         Error option, one\
    \ plus the value in the Salvage field of that\n         Route Error option.\n\
    \      Error Source Address\n         The address of the node originating the\
    \ Route Error (e.g., the\n         node that attempted to forward a packet and\
    \ discovered the link\n         failure).\n      Error Destination Address\n \
    \        The address of the node to which the Route Error must be\n         delivered.\
    \  For example, when the Error Type field is set to\n         NODE_UNREACHABLE,\
    \ this field will be set to the address of the\n         node that generated the\
    \ routing information claiming that the\n         hop from the Error Source Address\
    \ to Unreachable Node Address\n         (specified in the Type-Specific Information)\
    \ was a valid hop.\n      Type-Specific Information\n         Information specific\
    \ to the Error Type of this Route Error\n         message.\n   A Route Error option\
    \ MAY appear one or more times within a DSR\n   Options header.\n"
- title: 6.4.1.  Node Unreachable Type-Specific Information
  contents:
  - "6.4.1.  Node Unreachable Type-Specific Information\n   When the Route Error is\
    \ of type NODE_UNREACHABLE, the Type-Specific\n   Information field is defined\
    \ as follows:\n    0                   1                   2                 \
    \  3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n  \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   |    \
    \                Unreachable Node Address                   |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      Unreachable Node Address\n         The IP address of the node that was\
    \ found to be unreachable\n         (the next-hop neighbor to which the node with\
    \ address\n         Error Source Address was attempting to transmit the packet).\n"
- title: 6.4.2.  Flow State Not Supported Type-Specific Information
  contents:
  - "6.4.2.  Flow State Not Supported Type-Specific Information\n   When the Route\
    \ Error is of type FLOW_STATE_NOT_SUPPORTED, the\n   Type-Specific Information\
    \ field is empty.\n"
- title: 6.4.3.  Option Not Supported Type-Specific Information
  contents:
  - "6.4.3.  Option Not Supported Type-Specific Information\n   When the Route Error\
    \ is of type OPTION_NOT_SUPPORTED, the\n   Type-Specific Information field is\
    \ defined as follows:\n   0 1 2 3 4 5 6 7\n   +-+-+-+-+-+-+-+-+\n   |Unsupported\
    \ Opt|\n   +-+-+-+-+-+-+-+-+\n      Unsupported Opt\n         The Option Type\
    \ of option triggering the Route Error.\n"
- title: 6.5.  Acknowledgement Request Option
  contents:
  - "6.5.  Acknowledgement Request Option\n   The Acknowledgement Request option in\
    \ a DSR Options header is encoded\n   as follows:\n    0                   1 \
    \                  2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5\
    \ 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |  Option Type  |  Opt Data Len |         Identification        |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      Option Type\n         160.  Nodes not understanding this option will remove\
    \ the\n         option and return a Route Error.\n      Opt Data Len\n       \
    \  8-bit unsigned integer.  Length of the option, in octets,\n         excluding\
    \ the Option Type and Opt Data Len fields.\n      Identification\n         The\
    \ Identification field is set to a unique value and is copied\n         into the\
    \ Identification field of the Acknowledgement option\n         when returned by\
    \ the node receiving the packet over this hop.\n   An Acknowledgement Request\
    \ option MUST NOT appear more than once\n   within a DSR Options header.\n"
- title: 6.6.  Acknowledgement Option
  contents:
  - "6.6.  Acknowledgement Option\n   The Acknowledgement option in a DSR Options\
    \ header is encoded as\n   follows:\n    0                   1               \
    \    2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2\
    \ 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |  Option Type  |  Opt Data Len |         Identification        |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                       ACK Source Address                      |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                     ACK Destination Address                   |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      Option Type\n         32.  Nodes not understanding this option will remove\
    \ the\n         option.\n      Opt Data Len\n         8-bit unsigned integer.\
    \  Length of the option, in octets,\n         excluding the Option Type and Opt\
    \ Data Len fields.\n      Identification\n         Copied from the Identification\
    \ field of the Acknowledgement\n         Request option of the packet being acknowledged.\n\
    \      ACK Source Address\n         The address of the node originating the acknowledgement.\n\
    \      ACK Destination Address\n         The address of the node to which the\
    \ acknowledgement is to be\n         delivered.\n   An Acknowledgement option\
    \ MAY appear one or more times within a DSR\n   Options header.\n"
- title: 6.7.  DSR Source Route Option
  contents:
  - "6.7.  DSR Source Route Option\n   The DSR Source Route option in a DSR Options\
    \ header is encoded as\n   follows:\n    0                   1               \
    \    2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2\
    \ 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |  Option Type  |  Opt Data Len |F|L|Reservd|Salvage| Segs Left |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                           Address[1]                          |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                           Address[2]                          |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                              ...                              |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                           Address[n]                          |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      Option Type\n         96.  Nodes not understanding this option will drop\
    \ the packet.\n      Opt Data Len\n         8-bit unsigned integer.  Length of\
    \ the option, in octets,\n         excluding the Option Type and Opt Data Len\
    \ fields.  For the\n         format of the DSR Source Route option defined here,\
    \ this field\n         MUST be set to the value (n * 4) + 2, where n is the number\
    \ of\n         addresses present in the Address[i] fields.\n      First Hop External\
    \ (F)\n         Set to indicate that the first hop indicated by the DSR Source\n\
    \         Route option is actually an arbitrary path in a network\n         external\
    \ to the DSR network; the exact route outside the DSR\n         network is not\
    \ represented in the DSR Source Route option.\n         Nodes caching this hop\
    \ in their Route Cache MUST flag the\n         cached hop with the External flag.\
    \  Such hops MUST NOT be\n         returned in a Route Reply generated from this\
    \ Route Cache\n         entry, and selection of routes from the Route Cache to\
    \ route a\n         packet being sent SHOULD prefer routes that contain no hops\n\
    \         flagged as External.\n      Last Hop External (L)\n         Set to indicate\
    \ that the last hop indicated by the DSR Source\n         Route option is actually\
    \ an arbitrary path in a network\n         external to the DSR network; the exact\
    \ route outside the DSR\n         network is not represented in the DSR Source\
    \ Route option.\n         Nodes caching this hop in their Route Cache MUST flag\
    \ the\n         cached hop with the External flag.  Such hops MUST NOT be\n  \
    \       returned in a Route Reply generated from this Route Cache\n         entry,\
    \ and selection of routes from the Route Cache to route a\n         packet being\
    \ sent SHOULD prefer routes that contain no hops\n         flagged as External.\n\
    \      Reserved\n         MUST be sent as 0 and ignored on reception.\n      Salvage\n\
    \         A 4-bit unsigned integer.  Count of number of times that this\n    \
    \     packet has been salvaged as a part of DSR routing (Section\n         3.4.1).\n\
    \      Segments Left (Segs Left)\n         Number of route segments remaining,\
    \ i.e., number of explicitly\n         listed intermediate nodes still to be visited\
    \ before reaching\n         the final destination.\n      Address[1..n]\n    \
    \     The sequence of addresses of the source route.  In routing and\n       \
    \  forwarding the packet, the source route is processed as\n         described\
    \ in Sections 8.1.3 and 8.1.5.  The number of addresses\n         present in the\
    \ Address[1..n] field is indicated by the Opt Data\n         Len field in the\
    \ option (n = (Opt Data Len - 2) / 4).\n   When forwarding a packet along a DSR\
    \ source route using a DSR Source\n   Route option in the packet's DSR Options\
    \ header, the Destination\n   Address field in the packet's IP header is always\
    \ set to the address\n   of the packet's ultimate destination.  A node receiving\
    \ a packet\n   containing a DSR Options header with a DSR Source Route option\
    \ MUST\n   examine the indicated source route to determine if it is the intended\n\
    \   next-hop node for the packet and how to forward the packet, as\n   defined\
    \ in Sections 8.1.4 and 8.1.5.\n"
- title: 6.8.  Pad1 Option
  contents:
  - "6.8.  Pad1 Option\n   The Pad1 option in a DSR Options header is encoded as follows:\n\
    \   +-+-+-+-+-+-+-+-+\n   |  Option Type  |\n   +-+-+-+-+-+-+-+-+\n      Option\
    \ Type\n         224.  Nodes not understanding this option will drop the packet\n\
    \         and return a Route Error.\n   A Pad1 option MAY be included in the Options\
    \ field of a DSR Options\n   header in order to align subsequent DSR options,\
    \ but such alignment\n   is not required and MUST NOT be expected by a node receiving\
    \ a packet\n   containing a DSR Options header.\n   If any headers follow the\
    \ DSR Options header in a packet, the total\n   length of a DSR Options header,\
    \ indicated by the Payload Length field\n   in the DSR Options header MUST be\
    \ a multiple of 4 octets.  In this\n   case, when building a DSR Options header\
    \ in a packet, sufficient Pad1\n   or PadN options MUST be included in the Options\
    \ field of the DSR\n   Options header to make the total length a multiple of 4\
    \ octets.\n   If more than one consecutive octet of padding is being inserted\
    \ in\n   the Options field of a DSR Options header, the PadN option described\n\
    \   next, SHOULD be used, rather than multiple Pad1 options.\n   Note that the\
    \ format of the Pad1 option is a special case; it does\n   not have an Opt Data\
    \ Len or Option Data field.\n"
- title: 6.9.  PadN Option
  contents:
  - "6.9.  PadN Option\n   The PadN option in a DSR Options header is encoded as follows:\n\
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- - - - - - - - -\n   |  Option Type  | \
    \ Opt Data Len |   Option Data\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- - - - -\
    \ - - - -\n      Option Type\n         0.  Nodes not understanding this option\
    \ will ignore this\n         option.\n      Opt Data Len\n         8-bit unsigned\
    \ integer.  Length of the option, in octets,\n         excluding the Option Type\
    \ and Opt Data Len fields.  The size of\n         the Option Data field.\n   \
    \   Option Data\n         A number of zero-valued octets equal to the Opt Data\
    \ Len.\n   A PadN option MAY be included in the Options field of a DSR Options\n\
    \   header in order to align subsequent DSR options, but such alignment\n   is\
    \ not required and MUST NOT be expected by a node receiving a packet\n   containing\
    \ a DSR Options header.\n   If any headers follow the DSR Options header in a\
    \ packet, the total\n   length of a DSR Options header, indicated by the Payload\
    \ Length field\n   in the DSR Options header, MUST be a multiple of 4 octets.\
    \  In this\n   case, when building a DSR Options header in a packet, sufficient\
    \ Pad1\n   or PadN options MUST be included in the Options field of the DSR\n\
    \   Options header to make the total length a multiple of 4 octets.\n"
- title: 7.  Additional Header Formats and Options for Flow State Extension
  contents:
  - "7.  Additional Header Formats and Options for Flow State Extension\n   The optional\
    \ DSR flow state extension requires a new header type, the\n   DSR Flow State\
    \ header.\n   In addition, the DSR flow state extension adds the following options\n\
    \   for the DSR Options header defined in Section 6:\n   -  Timeout option (Section\
    \ 7.2.1)\n   -  Destination and Flow ID option (Section 7.2.2)\n   Two new Error\
    \ Type values are also defined for use in the Route Error\n   option in a DSR\
    \ Options header:\n   -  UNKNOWN_FLOW\n   -  DEFAULT_FLOW_UNKNOWN\n   Finally,\
    \ an extension to the Acknowledgement Request option in a DSR\n   Options header\
    \ is also defined:\n   -  Previous Hop Address\n   This section defines each of\
    \ these new header, option, or extension\n   formats.\n"
- title: 7.1.  DSR Flow State Header
  contents:
  - "7.1.  DSR Flow State Header\n   The DSR Flow State header is a small 4-byte header\
    \ optionally used to\n   carry the flow ID and hop count for a packet being sent\
    \ along a DSR\n   flow.  It is distinguished from the fixed DSR Options header\
    \ (Section\n   6.1) in that the Flow State Header (F) bit is set in the DSR Flow\n\
    \   State header and is clear in the fixed DSR Options header.\n    0        \
    \           1                   2                   3\n    0 1 2 3 4 5 6 7 8 9\
    \ 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |  Next Header  |F|  Hop Count  |        Flow Identifier        |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      Next Header\n         8-bit selector.  Identifies the type of header immediately\n\
    \         following the DSR Flow State header.  Uses the same values as\n    \
    \     the IPv4 Protocol field [RFC1700].\n      Flow State Header (F)\n      \
    \   Flag bit.  MUST be set to 1.  This bit is set in a DSR Flow\n         State\
    \ header and clear in a DSR Options header (Section 6.1).\n      Hop Count\n \
    \        7-bit unsigned integer.  The number of hops through which this\n    \
    \     packet has been forwarded.\n      Flow Identification\n         The flow\
    \ ID for this flow, as described in Section 3.5.1.\n"
- title: 7.2.  New Options and Extensions in DSR Options Header
  contents:
  - '7.2.  New Options and Extensions in DSR Options Header

    '
- title: 7.2.1.  Timeout Option
  contents:
  - "7.2.1.  Timeout Option\n   The Timeout option is defined for use in a DSR Options\
    \ header to\n   indicate the amount of time before the expiration of the flow\
    \ ID\n   along which the packet is being sent.\n    0                   1    \
    \               2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7\
    \ 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |  Option Type  | Opt Data Len  |            Timeout            |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      Option Type\n         128.  Nodes not understanding this option will ignore\
    \ the\n         option and return a Route Error.\n      Opt Data Len\n       \
    \  8-bit unsigned integer.  Length of the option, in octets,\n         excluding\
    \ the Option Type and Opt Data Len fields.\n         When no extensions are present,\
    \ the Opt Data Len of a Timeout\n         option is 2.  Further extensions to\
    \ DSR may include additional\n         data in a Timeout option.  The presence\
    \ of such extensions is\n         indicated by an Opt Data Len greater than 2.\
    \  Currently, no\n         such extensions have been defined.\n      Timeout\n\
    \         The number of seconds for which this flow remains valid.\n   The Timeout\
    \ option MUST NOT appear more than once within a DSR\n   Options header.\n"
- title: 7.2.2.  Destination and Flow ID Option
  contents:
  - "7.2.2.  Destination and Flow ID Option\n   The Destination and Flow ID option\
    \ is defined for use in a DSR\n   Options header to send a packet to an intermediate\
    \ host along one\n   flow, for eventual forwarding to the final destination along\
    \ a\n   different flow.  This option enables the aggregation of the state of\n\
    \   multiple flows.\n    0                   1                   2           \
    \        3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0\
    \ 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n  \
    \ |  Option Type  | Opt Data Len  |      New Flow Identifier      |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                   New IP Destination Address                  |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      Option Type\n         129.  Nodes not understanding this option will ignore\
    \ the\n         option and return a Route Error.\n      Opt Data Len\n       \
    \  8-bit unsigned integer.  Length of the option, in octets,\n         excluding\
    \ the Option Type and Opt Data Len fields.\n         When no extensions are present,\
    \ the Opt Data Len of a\n         Destination and Flow ID option is 6.  Further\
    \ extensions to DSR\n         may include additional data in a Destination and\
    \ Flow ID\n         option.  The presence of such extensions is indicated by an\
    \ Opt\n         Data Len greater than 6.  Currently, no such extensions have\n\
    \         been defined.\n      New Flow Identifier\n         Indicates the next\
    \ identifier to store in the Flow ID field of\n         the DSR Options header.\n\
    \      New IP Destination Address\n         Indicates the next address to store\
    \ in the Destination Address\n         field of the IP header.\n   The Destination\
    \ and Flow ID option MAY appear one or more times\n   within a DSR Options header.\n"
- title: 7.3.  New Error Types for Route Error Option
  contents:
  - '7.3.  New Error Types for Route Error Option

    '
- title: 7.3.1.  Unknown Flow Type-Specific Information
  contents:
  - "7.3.1.  Unknown Flow Type-Specific Information\n   A new Error Type value of\
    \ 129 (UNKNOWN_FLOW) is defined for use in a\n   Route Error option in a DSR Options\
    \ header.  The Type-Specific\n   Information for errors of this type is encoded\
    \ as follows:\n    0                   1                   2                 \
    \  3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n  \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   |    \
    \            Original IP Destination Address                |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |            Flow ID            |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      Original IP Destination Address\n         The IP Destination Address of\
    \ the packet that caused the error.\n      Flow ID\n         The Flow ID contained\
    \ in the DSR Flow ID option that caused the\n         error.\n"
- title: 7.3.2.  Default Flow Unknown Type-Specific Information
  contents:
  - "7.3.2.  Default Flow Unknown Type-Specific Information\n   A new Error Type value\
    \ of 130 (DEFAULT_FLOW_UNKNOWN) is defined\n   for use in a Route Error option\
    \ in a DSR Options header.  The\n   Type-Specific Information for errors of this\
    \ type is encoded as\n   follows:\n    0                   1                 \
    \  2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3\
    \ 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |               Original IP Destination Address                 |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      Original IP Destination Address\n         The IP Destination Address of\
    \ the packet that caused the error.\n"
- title: 7.4.  New Acknowledgement Request Option Extension
  contents:
  - '7.4.  New Acknowledgement Request Option Extension

    '
- title: 7.4.1.  Previous Hop Address Extension
  contents:
  - "7.4.1.  Previous Hop Address Extension\n   When the Opt Data Len field of an\
    \ Acknowledgement Request option\n   in a DSR Options header is greater than or\
    \ equal to 6, the\n   ACK Request Source Address field is present.  The option\
    \ is then\n   formatted as follows:\n    0                   1               \
    \    2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2\
    \ 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |  Option Type  | Opt Data Len  |       Packet Identifier       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                   ACK Request Source Address                  |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      Option Type\n         160.  Nodes not understanding this option will remove\
    \ the\n         option and return a Route Error.\n      Opt Data Len\n       \
    \  8-bit unsigned integer.  Length of the option, in octets,\n         excluding\
    \ the Option Type and Opt Data Len fields.\n         When no extensions are presents,\
    \ the Opt Data Len of an\n         Acknowledgement Request option is 2.  Further\
    \ extensions to DSR\n         may include additional data in an Acknowledgement\
    \ Request\n         option.  The presence of such extensions is indicated by an\
    \ Opt\n         Data Len greater than 2.\n         Currently, one such extension\
    \ has been defined.  If the Opt\n         Data Len is at least 6, then an ACK\
    \ Request Source Address is\n         present.\n      Packet Identifier\n    \
    \     The Packet Identifier field is set to a unique number and is\n         copied\
    \ into the Identification field of the DSR Acknowledgement\n         option when\
    \ returned by the node receiving the packet over this\n         hop.\n      ACK\
    \ Request Source Address\n         The address of the node requesting the DSR\
    \ Acknowledgement.\n"
- title: 8.  Detailed Operation
  contents:
  - '8.  Detailed Operation

    '
- title: 8.1.  General Packet Processing
  contents:
  - '8.1.  General Packet Processing

    '
- title: 8.1.1.  Originating a Packet
  contents:
  - "8.1.1.  Originating a Packet\n   When originating any packet, a node using DSR\
    \ routing MUST perform\n   the following sequence of steps:\n   -  Search the\
    \ node's Route Cache for a route to the address given in\n      the IP Destination\
    \ Address field in the packet's header.\n   -  If no such route is found in the\
    \ Route Cache, then perform Route\n      Discovery for the Destination Address,\
    \ as described in Section\n      8.2.  Initiating a Route Discovery for this target\
    \ node address\n      results in the node adding a Route Request option in a DSR\
    \ Options\n      header in this existing packet, or saving this existing packet\
    \ to\n      its Send Buffer and initiating the Route Discovery by sending a\n\
    \      separate packet containing such a Route Request option.  If the\n     \
    \ node chooses to initiate the Route Discovery by adding the Route\n      Request\
    \ option to this existing packet, it will replace the IP\n      Destination Address\
    \ field with the IP \"limited broadcast\" address\n      (255.255.255.255) [RFC1122],\
    \ copying the original IP Destination\n      Address to the Target Address field\
    \ of the new Route Request\n      option added to the packet, as described in\
    \ Section 8.2.1.\n   -  If the packet now does not contain a Route Request option,\
    \ then\n      this node must have a route to the Destination Address of the\n\
    \      packet; if the node has more than one route to this Destination\n     \
    \ Address, the node selects one to use for this packet.  If the\n      length\
    \ of this route is greater than 1 hop, or if the node\n      determines to request\
    \ a DSR network-layer acknowledgement from the\n      first-hop node in that route,\
    \ then insert a DSR Options header\n      into the packet, as described in Section\
    \ 8.1.2, and insert a DSR\n      Source Route option, as described in Section\
    \ 8.1.3.  The source\n      route in the packet is initialized from the selected\
    \ route to the\n      Destination Address of the packet.\n   -  Transmit the packet\
    \ to the first-hop node address given in\n      selected source route, using Route\
    \ Maintenance to determine the\n      reachability of the next hop, as described\
    \ in Section 8.3.\n"
- title: 8.1.2.  Adding a DSR Options Header to a Packet
  contents:
  - "8.1.2.  Adding a DSR Options Header to a Packet\n   A node originating a packet\
    \ adds a DSR Options header to the packet,\n   if necessary, to carry information\
    \ needed by the routing protocol.  A\n   packet MUST NOT contain more than one\
    \ DSR Options header.  A DSR\n   Options header is added to a packet by performing\
    \ the following\n   sequence of steps (these steps assume that the packet contains\
    \ no\n   other headers that MUST be located in the packet before the DSR\n   Options\
    \ header):\n   -  Insert a DSR Options header after the IP header but before any\n\
    \      other header that may be present.\n   -  Set the Next Header field of the\
    \ DSR Options header to the\n      Protocol number field of the packet's IP header.\n\
    \   -  Set the Protocol field of the packet's IP header to the protocol\n    \
    \  number assigned for DSR (48).\n"
- title: 8.1.3.  Adding a DSR Source Route Option to a Packet
  contents:
  - "8.1.3.  Adding a DSR Source Route Option to a Packet\n   A node originating a\
    \ packet adds a DSR Source Route option to the\n   packet, if necessary, in order\
    \ to carry the source route from this\n   originating node to the final destination\
    \ address of the packet.\n   Specifically, the node adding the DSR Source Route\
    \ option constructs\n   the DSR Source Route option and modifies the IP packet\
    \ according to\n   the following sequence of steps:\n   -  The node creates a\
    \ DSR Source Route option, as described in\n      Section 6.7, and appends it\
    \ to the DSR Options header in the\n      packet.  (A DSR Options header is added,\
    \ as described in Section\n      8.1.2, if not already present.)\n   -  The number\
    \ of Address[i] fields to include in the DSR Source Route\n      option (n) is\
    \ the number of intermediate nodes in the source route\n      for the packet (i.e.,\
    \ excluding the address of the originating\n      node and the final destination\
    \ address of the packet).  The\n      Segments Left field in the DSR Source Route\
    \ option is initialized\n      equal to n.\n   -  The addresses within the source\
    \ route for the packet are copied\n      into sequential Address[i] fields in\
    \ the DSR Source Route option,\n      for i = 1, 2, ..., n.\n   -  The First Hop\
    \ External (F) bit in the DSR Source Route option is\n      copied from the External\
    \ bit flagging the first hop in the source\n      route for the packet, as indicated\
    \ in the Route Cache.\n   -  The Last Hop External (L) bit in the DSR Source Route\
    \ option is\n      copied from the External bit flagging the last hop in the source\n\
    \      route for the packet, as indicated in the Route Cache.\n   -  The Salvage\
    \ field in the DSR Source Route option is initialized to\n      0.\n"
- title: 8.1.4.  Processing a Received Packet
  contents:
  - "8.1.4.  Processing a Received Packet\n   When a node receives any packet (whether\
    \ for forwarding, overheard,\n   or the final destination of the packet), if that\
    \ packet contains a\n   DSR Options header, then that node MUST process any options\
    \ contained\n   in that DSR Options header, in the order contained there.\n  \
    \ Specifically:\n   -  If the DSR Options header contains a Route Request option,\
    \ the\n      node SHOULD extract the source route from the Route Request and\n\
    \      add this routing information to its Route Cache, subject to the\n     \
    \ conditions identified in Section 3.3.1.  The routing information\n      from\
    \ the Route Request is the sequence of hop addresses\n         initiator, Address[1],\
    \ Address[2], ..., Address[n]\n      where initiator is the value of the Source\
    \ Address field in the IP\n      header of the packet carrying the Route Request\
    \ (the address of\n      the initiator of the Route Discovery), and each Address[i]\
    \ is a\n      node through which this Route Request has passed, in turn, during\n\
    \      this Route Discovery.  The value n, here, is the number of\n      addresses\
    \ recorded in the Route Request option, or\n      (Opt Data Len - 6) / 4.\n  \
    \    After possibly updating the node's Route Cache in response to the\n     \
    \ routing information in the Route Request option, the node MUST\n      then process\
    \ the Route Request option as described in Section\n      8.2.2.\n   -  If the\
    \ DSR Options header contains a Route Reply option, the node\n      SHOULD extract\
    \ the source route from the Route Reply and add this\n      routing information\
    \ to its Route Cache, subject to the conditions\n      identified in Section 3.3.1.\
    \  The source route from the Route\n      Reply is the sequence of hop addresses\n\
    \         initiator, Address[1], Address[2], ..., Address[n]\n      where initiator\
    \ is the value of the Destination Address field in\n      the IP header of the\
    \ packet carrying the Route Reply (the address\n      of the initiator of the\
    \ Route Discovery), and each Address[i] is a\n      node through which the source\
    \ route passes, in turn, on the route\n      to the target of the Route Discovery.\
    \  Address[n] is the address\n      of the target.  If the Last Hop External (L)\
    \ bit is set in the\n      Route Reply, the node MUST flag the last hop from the\
    \ Route Reply\n      (the link from Address[n-1] to Address[n]) in its Route Cache\
    \ as\n      External.  The value n here is the number of addresses in the\n  \
    \    source route being returned in the Route Reply option, or\n      (Opt Data\
    \ Len - 1) / 4.\n      After possibly updating the node's Route Cache in response\
    \ to the\n      routing information in the Route Reply option, then if the\n \
    \     packet's IP Destination Address matches one of this node's IP\n      addresses,\
    \ the node MUST then process the Route Reply option as\n      described in Section\
    \ 8.2.6.\n   -  If the DSR Options header contains a Route Error option, the node\n\
    \      MUST process the Route Error option as described in Section 8.3.5.\n  \
    \ -  If the DSR Options header contains an Acknowledgement Request\n      option,\
    \ the node MUST process the Acknowledgement Request option\n      as described\
    \ in Section 8.3.3.\n   -  If the DSR Options header contains an Acknowledgement\
    \ option, then\n      subject to the conditions identified in Section 3.3.1, the\
    \ node\n      SHOULD add to its Route Cache the single link from the node\n  \
    \    identified by the ACK Source Address field to the node identified\n     \
    \ by the ACK Destination Address field.\n      After possibly updating the node's\
    \ Route Cache in response to the\n      routing information in the Acknowledgement\
    \ option, the node MUST\n      then process the Acknowledgement option as described\
    \ in Section\n      8.3.3.\n   -  If the DSR Options header contains a DSR Source\
    \ Route option, the\n      node SHOULD extract the source route from the DSR Source\
    \ Route\n      option and add this routing information to its Route Cache,\n \
    \     subject to the conditions identified in Section 3.3.1.  If the\n      value\
    \ of the Salvage field in the DSR Source Route option is zero,\n      then the\
    \ routing information from the DSR Source Route is the\n      sequence of hop\
    \ addresses\n         source, Address[1], Address[2], ..., Address[n], destination\n\
    \      Otherwise (i.e., if Salvage is nonzero), the routing information\n    \
    \  from the DSR Source Route is the sequence of hop addresses\n         Address[1],\
    \ Address[2], ..., Address[n], destination\n      where source is the value of\
    \ the Source Address field in the IP\n      header of the packet carrying the\
    \ DSR Source Route option (the\n      original sender of the packet), each Address[i]\
    \ is the value in\n      the Address[i] field in the DSR Source Route option,\
    \ and\n      destination is the value of the Destination Address field in the\n\
    \      packet's IP header (the last-hop address of the source route).\n      The\
    \ value n here is the number of addresses in source route in the\n      DSR Source\
    \ Route option, or (Opt Data Len - 2) / 4.\n      After possibly updating the\
    \ node's Route Cache in response to the\n      routing information in the DSR\
    \ Source Route option, the node MUST\n      then process the DSR Source Route\
    \ option as described in Section\n      8.1.5.\n   -  Any Pad1 or PadN options\
    \ in the DSR Options header are ignored.\n   -  Finally, if the Destination Address\
    \ in the packet's IP header\n      matches one of this receiving node's own IP\
    \ address(es), remove\n      the DSR Options header and all the included DSR options\
    \ in the\n      header, and pass the rest of the packet to the network layer.\n"
- title: 8.1.5.  Processing a Received DSR Source Route Option
  contents:
  - "8.1.5.  Processing a Received DSR Source Route Option\n   When a node receives\
    \ a packet containing a DSR Source Route option\n   (whether for forwarding, overheard,\
    \ or the final destination of the\n   packet), that node SHOULD examine the packet\
    \ to determine if the\n   receipt of that packet indicates an opportunity for\
    \ automatic route\n   shortening, as described in Section 3.4.3.  Specifically,\
    \ if this\n   node is not the intended next-hop destination for the packet but\
    \ is\n   named in the later unexpended portion of the source route in the\n  \
    \ packet's DSR Source Route option, then this packet indicates an\n   opportunity\
    \ for automatic route shortening:  the intermediate nodes\n   after the node from\
    \ which this node overheard the packet and before\n   this node itself are no\
    \ longer necessary in the source route.  In\n   this case, this node SHOULD perform\
    \ the following sequence of steps\n   as part of automatic route shortening:\n\
    \   -  The node searches its Gratuitous Route Reply Table for an entry\n     \
    \ describing a gratuitous Route Reply earlier sent by this node, for\n      which\
    \ the original sender (of the packet triggering the gratuitous\n      Route Reply)\
    \ and the transmitting node (from which this node\n      overheard that packet\
    \ in order to trigger the gratuitous Route\n      Reply) both match the respective\
    \ node addresses for this new\n      received packet.  If such an entry is found\
    \ in the node's\n      Gratuitous Route Reply Table, the node SHOULD NOT perform\n\
    \      automatic route shortening in response to this receipt of this\n      packet.\n\
    \   -  Otherwise, the node creates an entry for this overheard packet in\n   \
    \   its Gratuitous Route Reply Table.  The timeout value for this new\n      entry\
    \ SHOULD be initialized to the value GratReplyHoldoff.  After\n      this timeout\
    \ has expired, the node SHOULD delete this entry from\n      its Gratuitous Route\
    \ Reply Table.\n   -  After creating the new Gratuitous Route Reply Table entry\
    \ above,\n      the node originates a gratuitous Route Reply to the IP Source\n\
    \      Address of this overheard packet, as described in Section 3.4.3.\n    \
    \  If the MAC protocol in use in the network is not capable of\n      transmitting\
    \ unicast packets over unidirectional links, as\n      discussed in Section 3.3.1,\
    \ then in originating this Route Reply,\n      the node MUST use a source route\
    \ for routing the Route Reply\n      packet that is obtained by reversing the\
    \ sequence of hops over\n      which the packet triggering the gratuitous Route\
    \ Reply was routed\n      in reaching and being overheard by this node.  This\
    \ reversing of\n      the route uses the gratuitous Route Reply to test this sequence\
    \ of\n      hops for bidirectionality, preventing the gratuitous Route Reply\n\
    \      from being received by the initiator of the Route Discovery unless\n  \
    \    each of the hops over which the gratuitous Route Reply is returned\n    \
    \  is bidirectional.\n   -  Discard the overheard packet, since the packet has\
    \ been received\n      before its normal traversal of the packet's source route\
    \ would\n      have caused it to reach this receiving node.  Another copy of the\n\
    \      packet will normally arrive at this node as indicated in the\n      packet's\
    \ source route; discarding this initial copy of the packet,\n      which triggered\
    \ the gratuitous Route Reply, will prevent the\n      duplication of this packet\
    \ that would otherwise occur.\n   If the packet is not discarded as part of automatic\
    \ route shortening\n   above, then the node MUST process the Source Route option\
    \ according\n   to the following sequence of steps:\n   -  If the value of the\
    \ Segments Left field in the DSR Source Route\n      option equals 0, then remove\
    \ the DSR Source Route option from the\n      DSR Options header.\n   -  Else,\
    \ let n equal (Opt Data Len - 2) / 4.  This is the number of\n      addresses\
    \ in the DSR Source Route option.\n   -  If the value of the Segments Left field\
    \ is greater than n, then\n      send an ICMP Parameter Problem, Code 0, message\
    \ [RFC792] to the IP\n      Source Address, pointing to the Segments Left field,\
    \ and discard\n      the packet.  Do not process the DSR Source Route option further.\n\
    \   -  Else, decrement the value of the Segments Left field by 1.  Let i\n   \
    \   equal n minus Segments Left.  This is the index of the next\n      address\
    \ to be visited in the Address vector.\n   -  If Address[i] or the IP Destination\
    \ Address is a multicast\n      address, then discard the packet.  Do not process\
    \ the DSR Source\n      Route option further.\n   -  If this node has more than\
    \ one network interface and if Address[i]\n      is the address of one this node's\
    \ network interfaces, then this\n      indicates a change in the network interface\
    \ to use in forwarding\n      the packet, as described in Section 8.4.  In this\
    \ case, decrement\n      the value of the Segments Left field by 1 to skip over\
    \ this\n      address (that indicated the change of network interface) and go\
    \ to\n      the first step above (checking the value of the Segments Left\n  \
    \    field) to continue processing this Source Route option; in further\n    \
    \  processing of this Source Route option, the indicated new network\n      interface\
    \ MUST be used in forwarding the packet.\n   -  If the MTU of the link over which\
    \ this node would transmit the\n      packet to forward it to the node Address[i]\
    \ is less than the size\n      of the packet, the node MUST either discard the\
    \ packet and send an\n      ICMP Packet Too Big message to the packet's Source\
    \ Address\n      [RFC792] or fragment it as specified in Section 8.5.\n   -  Forward\
    \ the packet to the IP address specified in the Address[i]\n      field of the\
    \ IP header, following normal IP forwarding procedures,\n      including checking\
    \ and decrementing the Time-to-Live (TTL) field\n      in the packet's IP header\
    \ [RFC791, RFC1122].  In this forwarding\n      of the packet, the next-hop node\
    \ (identified by Address[i]) MUST\n      be treated as a direct neighbor node:\
    \  the transmission to that\n      next node MUST be done in a single IP forwarding\
    \ hop, without\n      Route Discovery and without searching the Route Cache.\n\
    \   -  In forwarding the packet, perform Route Maintenance for the next\n    \
    \  hop of the packet, by verifying that the next-hop node is\n      reachable,\
    \ as described in Section 8.3.\n   Multicast addresses MUST NOT appear in a DSR\
    \ Source Route option or\n   in the IP Destination Address field of a packet carrying\
    \ a DSR Source\n   Route option in a DSR Options header.\n"
- title: 8.1.6.  Handling an Unknown DSR Option
  contents:
  - "8.1.6.  Handling an Unknown DSR Option\n   Nodes implementing DSR MUST handle\
    \ all options specified in this\n   document, except those options pertaining\
    \ to the optional flow state\n   extension (Section 7).  However, further extensions\
    \ to DSR may\n   include other option types that may not be understood by\n  \
    \ implementations conforming to this version of the DSR specification.\n   In\
    \ DSR, Option Type codes encode required behavior for nodes not\n   implementing\
    \ that type of option.  These behaviors are included in\n   the most significant\
    \ 3 bits of the Option Type.\n   If the most significant bit of the Option Type\
    \ is set (that is,\n   Option Type & 0x80 is nonzero), and this packet does not\
    \ contain a\n   Route Request option, a node SHOULD return a Route Error to the\
    \ IP\n   Source Address, following the steps described in Section 8.3.4,\n   except\
    \ that the Error Type MUST be set to OPTION_NOT_SUPPORTED and\n   the Unsupported\
    \ Opt field MUST be set to the Option Type triggering\n   the Route Error.\n \
    \  Whether or not a Route Error is sent in response to this DSR option,\n   as\
    \ described above, the node also MUST examine the next 2 most\n   significant\
    \ bits (that is, Option Type & 0x60):\n   -  When these 2 bits are 00 (that is,\
    \ Option Type & 0x60 == 0), a\n      node not implementing processing for that\
    \ Option Type MUST use the\n      Opt Data Len field to skip over the option and\
    \ continue\n      processing.\n   -  When these 2 bits are 01 (that is, Option\
    \ Type & 0x60 == 0x20), a\n      node not implementing processing for that Option\
    \ Type MUST use the\n      Opt Data Len field to remove the option from the packet\
    \ and\n      continue processing as if the option had not been included in the\n\
    \      received packet.\n   -  When these 2 bits are 10 (that is, Option Type\
    \ & 0x60 == 0x40), a\n      node not implementing processing for that Option Type\
    \ MUST set the\n      most significant bit following the Opt Data Len field. \
    \ In\n      addition, the node MUST then ignore and skip over the contents of\n\
    \      the option using the Opt Data Len field and MUST continue\n      processing\
    \ the packet.\n   -  Finally, when these 2 bits are 11 (that is,\n      Option\
    \ Type & 0x60 == 0x60), a node not implementing processing\n      for that Option\
    \ Type MUST drop the packet.\n"
- title: 8.2.  Route Discovery Processing
  contents:
  - "8.2.  Route Discovery Processing\n   Route Discovery is the mechanism by which\
    \ a node S wishing to send a\n   packet to a destination node D obtains a source\
    \ route to D.  Route\n   Discovery SHOULD be used only when S attempts to send\
    \ a packet to D\n   and does not already know a route to D.  The node initiating\
    \ a Route\n   Discovery is known as the \"initiator\" of the Route Discovery,\
    \ and the\n   destination node for which the Route Discovery is initiated is known\n\
    \   as the \"target\" of the Route Discovery.\n   Route Discovery operates entirely\
    \ on demand; a node initiates Route\n   Discovery based on its own origination\
    \ of new packets for some\n   destination address to which it does not currently\
    \ know a route.\n   Route Discovery does not depend on any periodic or background\n\
    \   exchange of routing information or neighbor node detection at any\n   layer\
    \ in the network protocol stack at any node.\n   The Route Discovery procedure\
    \ utilizes two types of messages, a Route\n   Request (Section 6.2) and a Route\
    \ Reply (Section 6.3), to actively\n   search the ad hoc network for a route to\
    \ the desired target\n   destination.  These DSR messages MAY be carried in any\
    \ type of IP\n   packet, through use of the DSR Options header as described in\
    \ Section\n   6.\n   Except as discussed in Section 8.3.5, a Route Discovery for\
    \ a\n   destination address SHOULD NOT be initiated unless the initiating\n  \
    \ node has a packet in its Send Buffer requiring delivery to that\n   destination.\
    \  A Route Discovery for a given target node MUST NOT be\n   initiated unless\
    \ permitted by the rate-limiting information contained\n   in the Route Request\
    \ Table.  After each Route Discovery attempt, the\n   interval between successive\
    \ Route Discoveries for this target SHOULD\n   be doubled, up to a maximum of\
    \ MaxRequestPeriod, until a valid Route\n   Reply is received for this target.\n"
- title: 8.2.1.  Originating a Route Request
  contents:
  - "8.2.1.  Originating a Route Request\n   A node initiating a Route Discovery for\
    \ some target creates and\n   initializes a Route Request option in a DSR Options\
    \ header in some IP\n   packet.  This MAY be a separate IP packet, used only to\
    \ carry this\n   Route Request option, or the node MAY include the Route Request\n\
    \   option in some existing packet that it needs to send to the target\n   node\
    \ (e.g., the IP packet originated by this node that caused the\n   node to attempt\
    \ Route Discovery for the destination address of the\n   packet).  The Route Request\
    \ option MUST be included in a DSR Options\n   header in the packet.  To initialize\
    \ the Route Request option, the\n   node performs the following sequence of steps:\n\
    \   -  The Option Type in the option MUST be set to the value 2.\n   -  The Opt\
    \ Data Len field in the option MUST be set to the value 6.\n      The total size\
    \ of the Route Request option, when initiated, is 8\n      octets; the Opt Data\
    \ Len field excludes the size of the Option\n      Type and Opt Data Len fields\
    \ themselves.\n   -  The Identification field in the option MUST be set to a new\
    \ value,\n      different from that used for other Route Requests recently\n \
    \     initiated by this node for this same target address.  For example,\n   \
    \   each node MAY maintain a single counter value for generating a new\n     \
    \ Identification value for each Route Request it initiates.\n   -  The Target\
    \ Address field in the option MUST be set to the IP\n      address that is the\
    \ target of this Route Discovery.\n   The Source Address in the IP header of this\
    \ packet MUST be the node's\n   own IP address.  The Destination Address in the\
    \ IP header of this\n   packet MUST be the IP \"limited broadcast\" address (255.255.255.255).\n\
    \   A node MUST maintain, in its Route Request Table, information about\n   Route\
    \ Requests that it initiates.  When initiating a new Route\n   Request, the node\
    \ MUST use the information recorded in the Route\n   Request Table entry for the\
    \ target of that Route Request, and it MUST\n   update that information in the\
    \ table entry for use in the next Route\n   Request initiated for this target.\
    \  In particular:\n   -  The Route Request Table entry for a target node records\
    \ the Time-\n      to-Live (TTL) field used in the IP header of the Route Request\
    \ for\n      the last Route Discovery initiated by this node for that target\n\
    \      node.  This value allows the node to implement a variety of\n      algorithms\
    \ for controlling the spread of its Route Request on each\n      Route Discovery\
    \ initiated for a target.  As examples, two possible\n      algorithms for this\
    \ use of the TTL field are described in Section\n      3.3.3.\n   -  The Route\
    \ Request Table entry for a target node records the number\n      of consecutive\
    \ Route Requests initiated for this target since\n      receiving a valid Route\
    \ Reply giving a route to that target node,\n      and the remaining amount of\
    \ time before which this node MAY next\n      attempt at a Route Discovery for\
    \ that target node.\n      A node MUST use these values to implement a back-off\
    \ algorithm to\n      limit the rate at which this node initiates new Route Discoveries\n\
    \      for the same target address.  In particular, until a valid Route\n    \
    \  Reply is received for this target node address, the timeout\n      between\
    \ consecutive Route Discovery initiations for this target\n      node with the\
    \ same hop limit SHOULD increase by doubling the\n      timeout value on each\
    \ new initiation.\n   The behavior of a node processing a packet containing DSR\
    \ Options\n   header with both a DSR Source Route option and a Route Request option\n\
    \   is unspecified.  Packets SHOULD NOT contain both a DSR Source Route\n   option\
    \ and a Route Request option.\n   Packets containing a Route Request option SHOULD\
    \ NOT include an\n   Acknowledgement Request option, SHOULD NOT expect link-layer\n\
    \   acknowledgement or passive acknowledgement, and SHOULD NOT be\n   retransmitted.\
    \  The retransmission of packets containing a Route\n   Request option is controlled\
    \ solely by the logic described in this\n   section.\n"
- title: 8.2.2.  Processing a Received Route Request Option
  contents:
  - "8.2.2.  Processing a Received Route Request Option\n   When a node receives a\
    \ packet containing a Route Request option, that\n   node MUST process the option\
    \ according to the following sequence of\n   steps:\n   -  If the Target Address\
    \ field in the Route Request matches this\n      node's own IP address, then the\
    \ node SHOULD return a Route Reply\n      to the initiator of this Route Request\
    \ (the Source Address in the\n      IP header of the packet), as described in\
    \ Section 8.2.4.  The\n      source route for this Reply is the sequence of hop\
    \ addresses\n         initiator, Address[1], Address[2], ..., Address[n], target\n\
    \      where initiator is the address of the initiator of this Route\n      Request,\
    \ each Address[i] is an address from the Route Request, and\n      target is the\
    \ target of the Route Request (the Target Address\n      field in the Route Request).\
    \  The value n here is the number of\n      addresses recorded in the Route Request,\
    \ or\n      (Opt Data Len - 6) / 4.\n      The node then MUST replace the Destination\
    \ Address field in the\n      Route Request packet's IP header with the value\
    \ in the Target\n      Address field in the Route Request option, and continue\
    \ processing\n      the rest of the Route Request packet normally.  The node MUST\
    \ NOT\n      process the Route Request option further and MUST NOT retransmit\n\
    \      the Route Request to propagate it to other nodes as part of the\n     \
    \ Route Discovery.\n   -  Else, the node MUST examine the route recorded in the\
    \ Route\n      Request option (the IP Source Address field and the sequence of\n\
    \      Address[i] fields) to determine if this node's own IP address\n      already\
    \ appears in this list of addresses.  If so, the node MUST\n      discard the\
    \ entire packet carrying the Route Request option.\n   -  Else, if the Route Request\
    \ was received through a network\n      interface that requires physically bidirectional\
    \ links for unicast\n      transmission, the node MUST check if the Route Request\
    \ was last\n      forwarded by a node on its blacklist (Section 4.6).  If such\
    \ an\n      entry is found in the blacklist, and the state of the\n      unidirectional\
    \ link is \"probable\", then the Request MUST be\n      silently discarded.\n\
    \   -  Else, if the Route Request was received through a network\n      interface\
    \ that requires physically bidirectional links for unicast\n      transmission,\
    \ the node MUST check if the Route Request was last\n      forwarded by a node\
    \ on its blacklist.  If such an entry is found\n      in the blacklist, and the\
    \ state of the unidirectional link is\n      \"questionable\", then the node MUST\
    \ create and unicast a Route\n      Request packet to that previous node, setting\
    \ the IP Time-To-Live\n      (TTL) to 1 to prevent the Request from being propagated.\
    \  If the\n      node receives a Route Reply in response to the new Request, it\n\
    \      MUST remove the blacklist entry for that node, and SHOULD continue\n  \
    \    processing.  If the node does not receive a Route Reply within\n      some\
    \ reasonable amount of time, the node MUST silently discard the\n      Route Request\
    \ packet.\n   -  Else, the node MUST search its Route Request Table for an entry\n\
    \      for the initiator of this Route Request (the IP Source Address\n      field).\
    \  If such an entry is found in the table, the node MUST\n      search the cache\
    \ of Identification values of recently received\n      Route Requests in that\
    \ table entry, to determine if an entry is\n      present in the cache matching\
    \ the Identification value and target\n      node address in this Route Request.\
    \  If such an (Identification,\n      target address) entry is found in this cache\
    \ in this entry in the\n      Route Request Table, then the node MUST discard\
    \ the entire packet\n      carrying the Route Request option.\n   -  Else, this\
    \ node SHOULD further process the Route Request according\n      to the following\
    \ sequence of steps:\n      o  Add an entry for this Route Request in its cache\
    \ of\n         (Identification, target address) values of recently received\n\
    \         Route Requests.\n      o  Conceptually create a copy of this entire\
    \ packet and perform\n         the following steps on the copy of the packet.\n\
    \      o  Append this node's own IP address to the list of Address[i]\n      \
    \   values in the Route Request and increase the value of the Opt\n         Data\
    \ Len field in the Route Request by 4 (the size of an IP\n         address). \
    \ However, if the node has multiple network\n         interfaces, this step MUST\
    \ be modified by the special\n         processing specified in Section 8.4.\n\
    \      o  This node SHOULD search its own Route Cache for a route (from\n    \
    \     itself, as if it were the source of a packet) to the target of\n       \
    \  this Route Request.  If such a route is found in its Route\n         Cache,\
    \ then this node SHOULD follow the procedure outlined in\n         Section 8.2.3\
    \ to return a \"cached Route Reply\" to the initiator\n         of this Route\
    \ Request, if permitted by the restrictions\n         specified there.\n     \
    \ o  If the node does not return a cached Route Reply, then this\n         node\
    \ SHOULD transmit this copy of the packet as a link-layer\n         broadcast,\
    \ with a short jitter delay before the broadcast is\n         sent.  The jitter\
    \ period SHOULD be chosen as a random period,\n         uniformly distributed\
    \ between 0 and BroadcastJitter.\n"
- title: 8.2.3.  Generating a Route Reply Using the Route Cache
  contents:
  - "8.2.3.  Generating a Route Reply Using the Route Cache\n   As described in Section\
    \ 3.3.2, it is possible for a node processing a\n   received Route Request to\
    \ avoid propagating the Route Request further\n   toward the target of the Request,\
    \ if this node has in its Route Cache\n   a route from itself to this target.\
    \  Such a Route Reply generated by\n   a node from its own cached route to the\
    \ target of a Route Request is\n   called a \"cached Route Reply\", and this mechanism\
    \ can greatly reduce\n   the overall overhead of Route Discovery on the network\
    \ by reducing\n   the flood of Route Requests.  The general processing of a received\n\
    \   Route Request is described in Section 8.2.2; this section specifies\n   the\
    \ additional requirements that MUST be met before a cached Route\n   Reply may\
    \ be generated and returned and specifies the procedure for\n   returning such\
    \ a cached Route Reply.\n   While processing a received Route Request, for a node\
    \ to possibly\n   return a cached Route Reply, it MUST have in its Route Cache\
    \ a route\n   from itself to the target of this Route Request.  However, before\n\
    \   generating a cached Route Reply for this Route Request, the node MUST\n  \
    \ verify that there are no duplicate addresses listed in the route\n   accumulated\
    \ in the Route Request together with the route from this\n   node's Route Cache.\
    \  Specifically, there MUST be no duplicates among\n   the following addresses:\n\
    \   -  The IP Source Address of the packet containing the Route Request,\n   -\
    \  The Address[i] fields in the Route Request, and\n   -  The nodes listed in\
    \ the route obtained from this node's Route\n      Cache, excluding the address\
    \ of this node itself (this node itself\n      is the common point between the\
    \ route accumulated in the Route\n      Request and the route obtained from the\
    \ Route Cache).\n   If any duplicates exist among these addresses, then the node\
    \ MUST NOT\n   send a cached Route Reply using this route from the Route Cache\
    \ (it\n   is possible that this node has another route in its Route Cache for\n\
    \   which the above restriction on duplicate addresses is met, allowing\n   the\
    \ node to send a cached Route Reply based on that cached route,\n   instead).\
    \  The node SHOULD continue to process the Route Request as\n   described in Section\
    \ 8.2.2 if it does not send a cached Route Reply.\n   If the Route Request and\
    \ the route from the Route Cache meet the\n   restriction above, then the node\
    \ SHOULD construct and return a cached\n   Route Reply as follows:\n   -  The\
    \ source route for this Route Reply is the sequence of hop\n      addresses\n\
    \         initiator, Address[1], Address[2], ..., Address[n], c-route\n      where\
    \ initiator is the address of the initiator of this Route\n      Request, each\
    \ Address[i] is an address from the Route Request, and\n      c-route is the sequence\
    \ of hop addresses in the source route to\n      this target node, obtained from\
    \ the node's Route Cache.  In\n      appending this cached route to the source\
    \ route for the reply, the\n      address of this node itself MUST be excluded,\
    \ since it is already\n      listed as Address[n].\n   -  Send a Route Reply to\
    \ the initiator of the Route Request, using\n      the procedure defined in Section\
    \ 8.2.4.  The initiator of the\n      Route Request is indicated in the Source\
    \ Address field in the\n      packet's IP header.\n   Before sending the cached\
    \ Route Reply, however, the node MAY delay\n   the Reply in order to help prevent\
    \ a possible Route Reply \"storm\", as\n   described in Section 8.2.5.\n   If\
    \ the node returns a cached Route Reply as described above, then the\n   node\
    \ MUST NOT propagate the Route Request further (i.e., the node\n   MUST NOT rebroadcast\
    \ the Route Request).  In this case, instead, if\n   the packet contains no other\
    \ DSR options and contains no payload\n   after the DSR Options header (e.g.,\
    \ the Route Request is not\n   piggybacked on a TCP or UDP packet), then the node\
    \ SHOULD simply\n   discard the packet.  Otherwise (if the packet contains other\
    \ DSR\n   options or contains any payload after the DSR Options header), the\n\
    \   node SHOULD forward the packet along the cached route to the target\n   of\
    \ the Route Request.  Specifically, if the node does so, it MUST use\n   the following\
    \ steps:\n   -  Copy the Target Address from the Route Request option in the DSR\n\
    \      Options header to the Destination Address field in the packet's IP\n  \
    \    header.\n   -  Remove the Route Request option from the DSR Options header\
    \ in the\n      packet, and add a DSR Source Route option to the packet's DSR\n\
    \      Options header.\n   -  In the DSR Source Route option, set the Address[i]\
    \ fields to\n      represent the source route found in this node's Route Cache\
    \ to the\n      original target of the Route Discovery (the new IP Destination\n\
    \      Address of the packet).  Specifically, the node copies the hop\n      addresses\
    \ of the source route into sequential Address[i] fields in\n      the DSR Source\
    \ Route option, for i = 1, 2, ..., n.  Address[1],\n      here, is the address\
    \ of this node itself (the first address in the\n      source route found from\
    \ this node to the original target of the\n      Route Discovery).  The value\
    \ n, here, is the number of hop\n      addresses in this source route, excluding\
    \ the destination of the\n      packet (which is instead already represented in\
    \ the Destination\n      Address field in the packet's IP header).\n   -  Initialize\
    \ the Segments Left field in the DSR Source Route option\n      to n as defined\
    \ above.\n   -  The First Hop External (F) bit in the DSR Source Route option\
    \ MUST\n      be set to 0.\n   -  The Last Hop External (L) bit in the DSR Source\
    \ Route option is\n      copied from the External bit flagging the last hop in\
    \ the source\n      route for the packet, as indicated in the Route Cache.\n \
    \  -  The Salvage field in the DSR Source Route option MUST be\n      initialized\
    \ to some nonzero value; the particular nonzero value\n      used SHOULD be MAX_SALVAGE_COUNT.\
    \  By initializing this field to a\n      nonzero value, nodes forwarding or overhearing\
    \ this packet will\n      not consider a link to exist between the IP Source Address\
    \ of the\n      packet and the Address[1] address in the DSR Source Route option\n\
    \      (e.g., they will not attempt to add this to their Route Cache as a\n  \
    \    link).  By choosing MAX_SALVAGE_COUNT as the nonzero value to\n      which\
    \ the node initializes this field, nodes furthermore will not\n      attempt to\
    \ salvage this packet.\n   -  Transmit the packet to the next-hop node on the\
    \ new source route\n      in the packet, using the forwarding procedure described\
    \ in Section\n      8.1.5.\n"
- title: 8.2.4.  Originating a Route Reply
  contents:
  - "8.2.4.  Originating a Route Reply\n   A node originates a Route Reply in order\
    \ to reply to a received and\n   processed Route Request, according to the procedures\
    \ described in\n   Sections 8.2.2 and 8.2.3.  The Route Reply is returned in a\
    \ Route\n   Reply option (Section 6.3).  The Route Reply option MAY be returned\n\
    \   to the initiator of the Route Request in a separate IP packet, used\n   only\
    \ to carry this Route Reply option, or it MAY be included in any\n   other IP\
    \ packet being sent to this address.\n   The Route Reply option MUST be included\
    \ in a DSR Options header in\n   the packet returned to the initiator.  To initialize\
    \ the Route Reply\n   option, the node performs the following sequence of steps:\n\
    \   -  The Option Type in the option MUST be set to the value 3.\n   -  The Opt\
    \ Data Len field in the option MUST be set to the value\n      (n * 4) + 3, where\
    \ n is the number of addresses in the source\n      route being returned (excluding\
    \ the Route Discovery initiator\n      node's address).\n   -  If this node is\
    \ the target of the Route Request, the Last Hop\n      External (L) bit in the\
    \ option MUST be initialized to 0.\n   -  The Reserved field in the option MUST\
    \ be initialized to 0.\n   -  The Route Request Identifier MUST be initialized\
    \ to the Identifier\n      field of the Route Request to which this Route Reply\
    \ is sent in\n      response.\n   -  The sequence of hop addresses in the source\
    \ route are copied into\n      the Address[i] fields of the option.  Address[1]\
    \ MUST be set to\n      the first-hop address of the route after the initiator\
    \ of the\n      Route Discovery, Address[n] MUST be set to the last-hop address\
    \ of\n      the source route (the address of the target node), and each other\n\
    \      Address[i] MUST be set to the next address in sequence in the\n      source\
    \ route being returned.\n   The Destination Address field in the IP header of\
    \ the packet carrying\n   the Route Reply option MUST be set to the address of\
    \ the initiator of\n   the Route Discovery (i.e., for a Route Reply being returned\
    \ in\n   response to some Route Request, the IP Source Address of the Route\n\
    \   Request).\n   After creating and initializing the Route Reply option and the\
    \ IP\n   packet containing it, send the Route Reply.  In sending the Route\n \
    \  Reply from this node (but not from nodes forwarding the Route Reply),\n   this\
    \ node SHOULD delay the Reply by a small jitter period chosen\n   randomly between\
    \ 0 and BroadcastJitter.\n   When returning any Route Reply in the case in which\
    \ the MAC protocol\n   in use in the network is not capable of transmitting unicast\
    \ packets\n   over unidirectional links, the source route used for routing the\n\
    \   Route Reply packet MUST be obtained by reversing the sequence of hops\n  \
    \ in the Route Request packet (the source route that is then returned\n   in the\
    \ Route Reply).  This restriction on returning a Route Reply\n   enables the Route\
    \ Reply to test this sequence of hops for\n   bidirectionality, preventing the\
    \ Route Reply from being received by\n   the initiator of the Route Discovery\
    \ unless each of the hops over\n   which the Route Reply is returned (and thus\
    \ each of the hops in the\n   source route being returned in the Reply) is bidirectional.\n\
    \   If sending a Route Reply to the initiator of the Route Request\n   requires\
    \ performing a Route Discovery, the Route Reply option MUST be\n   piggybacked\
    \ on the packet that contains the Route Request.  This\n   piggybacking prevents\
    \ a recursive dependency wherein the target of\n   the new Route Request (which\
    \ was itself the initiator of the original\n   Route Request) must do another\
    \ Route Request in order to return its\n   Route Reply.\n   If sending the Route\
    \ Reply to the initiator of the Route Request does\n   not require performing\
    \ a Route Discovery, a node SHOULD send a\n   unicast Route Reply in response\
    \ to every Route Request it receives\n   for which it is the target node.\n"
- title: 8.2.5.  Preventing Route Reply Storms
  contents:
  - "8.2.5.  Preventing Route Reply Storms\n   The ability for nodes to reply to a\
    \ Route Request based on\n   information in their Route Caches, as described in\
    \ Sections 3.3.2 and\n   8.2.3, could result in a possible Route Reply \"storm\"\
    \ in some cases.\n   In particular, if a node broadcasts a Route Request for a\
    \ target node\n   for which the node's neighbors have a route in their Route Caches,\n\
    \   each neighbor may attempt to send a Route Reply, thereby wasting\n   bandwidth\
    \ and possibly increasing the number of network collisions in\n   the area.\n\
    \   For example, the figure below shows a situation in which nodes B, C,\n   D,\
    \ E, and F all receive A's Route Request for target G, and each has\n   the indicated\
    \ route cached for this target:\n                +-----+                 +-----+\n\
    \                |  D  |<               >|  C  |\n                +-----+ \\ \
    \            / +-----+\n      Cache: C - B - G   \\           /  Cache: B - G\n\
    \                          \\ +-----+ /\n                           -|  A  |-\n\
    \                            +-----+\\     +-----+     +-----+\n             \
    \                |   |  \\--->|  B  |     |  G  |\n                          \
    \  /     \\      +-----+     +-----+\n                           /       \\  \
    \   Cache: G\n                          v         v\n                    +-----+\
    \         +-----+\n                    |  E  |         |  F  |\n             \
    \       +-----+         +-----+\n               Cache: F - B - G     Cache: B\
    \ - G\n   Normally, each of these nodes would attempt to reply from its own\n\
    \   Route Cache, and they would thus all send their Route Replies at\n   about\
    \ the same time, since they all received the broadcast Route\n   Request at about\
    \ the same time.  Such simultaneous Route Replies from\n   different nodes all\
    \ receiving the Route Request may cause local\n   congestion in the wireless network\
    \ and may create packet collisions\n   among some or all of these Replies if the\
    \ MAC protocol in use does\n   not provide sufficient collision avoidance for\
    \ these packets.  In\n   addition, it will often be the case that the different\
    \ replies will\n   indicate routes of different lengths, as shown in this example.\n\
    \   In order to reduce these effects, if a node can put its network\n   interface\
    \ into promiscuous receive mode, it MAY delay sending its own\n   Route Reply\
    \ for a short period, while listening to see if the\n   initiating node begins\
    \ using a shorter route first.  Specifically,\n   this node MAY delay sending\
    \ its own Route Reply for a random period\n      d = H * (h - 1 + r)\n   where\
    \ h is the length in number of network hops for the route to be\n   returned in\
    \ this node's Route Reply, r is a random floating point\n   number between 0 and\
    \ 1, and H is a small constant delay (at least\n   twice the maximum wireless\
    \ link propagation delay) to be introduced\n   per hop.  This delay effectively\
    \ randomizes the time at which each\n   node sends its Route Reply, with all nodes\
    \ sending Route Replies\n   giving routes of length less than h sending their\
    \ Replies before this\n   node, and all nodes sending Route Replies giving routes\
    \ of length\n   greater than h send their Replies after this node.\n   Within\
    \ the delay period, this node promiscuously receives all\n   packets, looking\
    \ for data packets from the initiator of this Route\n   Discovery destined for\
    \ the target of the Route Discovery.  If such a\n   data packet received by this\
    \ node during the delay period uses a\n   source route of length less than or\
    \ equal to h, this node may infer\n   that the initiator of the Route Discovery\
    \ has already received a\n   Route Reply giving an equally good or better route.\
    \  In this case,\n   this node SHOULD cancel its delay timer and SHOULD NOT send\
    \ its Route\n   Reply for this Route Discovery.\n"
- title: 8.2.6.  Processing a Received Route Reply Option
  contents:
  - "8.2.6.  Processing a Received Route Reply Option\n   Section 8.1.4 describes\
    \ the general processing for a received packet,\n   including the addition of\
    \ routing information from options in the\n   packet's DSR Options header to the\
    \ receiving node's Route Cache.\n   If the received packet contains a Route Reply,\
    \ no additional special\n   processing of the Route Reply option is required beyond\
    \ what is\n   described there.  As described in Section 4.1, anytime a node adds\n\
    \   new information to its Route Cache (including the information added\n   from\
    \ this Route Reply option), the node SHOULD check each packet in\n   its own Send\
    \ Buffer (Section 4.2) to determine whether a route to\n   that packet's IP Destination\
    \ Address now exists in the node's Route\n   Cache (including the information\
    \ just added to the Cache).  If so,\n   the packet SHOULD then be sent using that\
    \ route and removed from the\n   Send Buffer.  This general procedure handles\
    \ all processing required\n   for a received Route Reply option.\n   When using\
    \ a MAC protocol that requires bidirectional links for\n   unicast transmission,\
    \ a unidirectional link may be discovered by the\n   propagation of the Route\
    \ Request.  When the Route Reply is sent over\n   the reverse path, a forwarding\
    \ node may discover that the next-hop is\n   unreachable.  In this case, it MUST\
    \ add the next-hop address to its\n   blacklist (Section 4.6).\n"
- title: 8.3.  Route Maintenance Processing
  contents:
  - "8.3.  Route Maintenance Processing\n   Route Maintenance is the mechanism by\
    \ which a source node S is able\n   to detect, while using a source route to some\
    \ destination node D, if\n   the network topology has changed such that it can\
    \ no longer use its\n   route to D because a link along the route no longer works.\
    \  When\n   Route Maintenance indicates that a source route is broken, S can\n\
    \   attempt to use any other route it happens to know to D or can invoke\n   Route\
    \ Discovery again to find a new route for subsequent packets to\n   D.  Route\
    \ Maintenance for this route is used only when S is actually\n   sending packets\
    \ to D.\n   Specifically, when forwarding a packet, a node MUST attempt to\n \
    \  confirm the reachability of the next-hop node, unless such\n   confirmation\
    \ had been received in the last MaintHoldoffTime period.\n   Individual implementations\
    \ MAY choose to bypass such confirmation for\n   some limited number of packets,\
    \ as long as those packets all fall\n   within MaintHoldoffTime since the last\
    \ confirmation.  If no\n   confirmation is received after the retransmission of\
    \ MaxMaintRexmt\n   acknowledgement requests, after the initial transmission of\
    \ the\n   packet, and conceptually including all retransmissions provided by\n\
    \   the MAC layer, the node determines that the link for this next-hop\n   node\
    \ of the source route is \"broken\".  This confirmation from the\n   next-hop\
    \ node for Route Maintenance can be implemented using a link-\n   layer acknowledgement\
    \ (Section 8.3.1), a \"passive acknowledgement\"\n   (Section 8.3.2), or a network-layer\
    \ acknowledgement (Section 8.3.3);\n   the particular strategy for retransmission\
    \ timing depends on the type\n   of acknowledgement mechanism used.  When not\
    \ using link-layer\n   acknowledgements for Route Maintenance, nodes SHOULD use\
    \ passive\n   acknowledgements when possible but SHOULD try requesting a network-\n\
    \   layer acknowledgement one or more times before deciding that the link\n  \
    \ has failed and originating a Route Error to the original sender of\n   the packet,\
    \ as described in Section 8.3.4.\n   In deciding whether or not to send a Route\
    \ Error in response to\n   attempting to forward a packet from some sender over\
    \ a broken link, a\n   node MUST limit the number of consecutive packets from\
    \ a single\n   sender that the node attempts to forward over this same broken\
    \ link\n   for which the node chooses not to return a Route Error.  This\n   requirement\
    \ MAY be satisfied by returning a Route Error for each\n   packet that the node\
    \ attempts to forward over a broken link.\n"
- title: 8.3.1.  Using Link-Layer Acknowledgements
  contents:
  - "8.3.1.  Using Link-Layer Acknowledgements\n   If the MAC protocol in use provides\
    \ feedback as to the successful\n   delivery of a data packet (such as is provided\
    \ for unicast packets by\n   the link-layer acknowledgement frame defined by IEEE\
    \ 802.11\n   [IEEE80211]), then the use of the DSR Acknowledgement Request and\n\
    \   Acknowledgement options is not necessary.  If such link-layer\n   feedback\
    \ is available, it SHOULD be used instead of any other\n   acknowledgement mechanism\
    \ for Route Maintenance, and the node SHOULD\n   NOT use either passive acknowledgements\
    \ or network-layer\n   acknowledgements for Route Maintenance.\n   When using\
    \ link-layer acknowledgements for Route Maintenance, the\n   retransmission timing\
    \ and the timing at which retransmission attempts\n   are scheduled are generally\
    \ controlled by the particular link layer\n   implementation in use in the network.\
    \  For example, in IEEE 802.11,\n   the link-layer acknowledgement is returned\
    \ after a unicast packet as\n   a part of the basic access method of the IEEE\
    \ 802.11 Distributed\n   Coordination Function (DCF) MAC protocol; the time at\
    \ which the\n   acknowledgement is expected to arrive and the time at which the\
    \ next\n   retransmission attempt (if necessary) will occur are controlled by\n\
    \   the MAC protocol implementation.\n   When a node receives a link-layer acknowledgement\
    \ for any packet in\n   its Maintenance Buffer, that node SHOULD remove from its\
    \ Maintenance\n   Buffer that packet, as well as any other packets in its Maintenance\n\
    \   Buffer with the same next-hop destination.\n"
- title: 8.3.2.  Using Passive Acknowledgements
  contents:
  - "8.3.2.  Using Passive Acknowledgements\n   When link-layer acknowledgements are\
    \ not available, but passive\n   acknowledgements [JUBIN87] are available, passive\
    \ acknowledgements\n   SHOULD be used for Route Maintenance when originating or\
    \ forwarding a\n   packet along any hop other than the last hop (the hop leading\
    \ to the\n   IP Destination Address node of the packet).  In particular, passive\n\
    \   acknowledgements SHOULD be used for Route Maintenance in such cases\n   if\
    \ the node can place its network interface into \"promiscuous\"\n   receive mode,\
    \ and if network links used for data packets generally\n   operate bidirectionally.\n\
    \   A node MUST NOT attempt to use passive acknowledgements for Route\n   Maintenance\
    \ for a packet originated or forwarded over its last hop\n   (the hop leading\
    \ to the IP Destination Address node of the packet),\n   since the receiving node\
    \ will not be forwarding the packet and thus\n   no passive acknowledgement will\
    \ be available to be heard by this\n   node.  Beyond this restriction, a node\
    \ MAY utilize a variety of\n   strategies in using passive acknowledgements for\
    \ Route Maintenance of\n   a packet that it originates or forwards.  For example,\
    \ the following\n   two strategies are possible:\n   -  Each time a node receives\
    \ a packet to be forwarded to a node other\n      than the final destination (the\
    \ IP Destination Address of the\n      packet), that node sends the original transmission\
    \ of that packet\n      without requesting a network-layer acknowledgement for\
    \ it.  If no\n      passive acknowledgement is received within PassiveAckTimeout\
    \ after\n      this transmission, the node retransmits the packet, again without\n\
    \      requesting a network-layer acknowledgement for it; the same\n      PassiveAckTimeout\
    \ timeout value is used for each such attempt.  If\n      no acknowledgement has\
    \ been received after a total of\n      TryPassiveAcks retransmissions of the\
    \ packet, network-layer\n      acknowledgements (as described in Section 8.3.3)\
    \ are requested for\n      all remaining attempts for that packet.\n   -  Each\
    \ node maintains a table of possible next-hop destination\n      nodes, noting\
    \ whether or not passive acknowledgements can\n      typically be expected from\
    \ transmission to that node, and the\n      expected latency and jitter of a passive\
    \ acknowledgement from that\n      node.  Each time a node receives a packet to\
    \ be forwarded to a\n      node other than the IP Destination Address, the node\
    \ checks its\n      table of next-hop destination nodes to determine whether to\
    \ use a\n      passive acknowledgement or a network-layer acknowledgement for\n\
    \      that transmission to that node.  The timeout for this packet can\n    \
    \  also be derived from this table.  A node using this method SHOULD\n      prefer\
    \ using passive acknowledgements to network-layer\n      acknowledgements.\n \
    \  In using passive acknowledgements for a packet that it originates or\n   forwards,\
    \ a node considers the later receipt of a new packet (e.g.,\n   with promiscuous\
    \ receive mode enabled on its network interface) an\n   acknowledgement of this\
    \ first packet if both of the following two\n   tests succeed:\n   -  The Source\
    \ Address, Destination Address, Protocol, Identification,\n      and Fragment\
    \ Offset fields in the IP header of the two packets\n      MUST match [RFC791].\n\
    \   -  If either packet contains a DSR Source Route header, both packets\n   \
    \   MUST contain one, and the value in the Segments Left field in the\n      DSR\
    \ Source Route header of the new packet MUST be less than that\n      in the first\
    \ packet.\n   When a node hears such a passive acknowledgement for any packet\
    \ in\n   its Maintenance Buffer, that node SHOULD remove from its Maintenance\n\
    \   Buffer that packet, as well as any other packets in its Maintenance\n   Buffer\
    \ with the same next-hop destination.\n"
- title: 8.3.3.  Using Network-Layer Acknowledgements
  contents:
  - "8.3.3.  Using Network-Layer Acknowledgements\n   When a node originates or forwards\
    \ a packet and has no other\n   mechanism of acknowledgement available to determine\
    \ reachability of\n   the next-hop node in the source route for Route Maintenance,\
    \ that\n   node SHOULD request a network-layer acknowledgement from that next-\n\
    \   hop node.  To do so, the node inserts an Acknowledgement Request\n   option\
    \ in the DSR Options header in the packet.  The Identification\n   field in that\
    \ Acknowledgement Request option MUST be set to a value\n   unique over all packets\
    \ recently transmitted by this node to the same\n   next-hop node.\n   When a\
    \ node receives a packet containing an Acknowledgement Request\n   option, that\
    \ node performs the following tests on the packet:\n   -  If the indicated next-hop\
    \ node address for this packet does not\n      match any of this node's own IP\
    \ addresses, then this node MUST NOT\n      process the Acknowledgement Request\
    \ option.  The indicated next-\n      hop node address is the next Address[i]\
    \ field in the DSR Source\n      Route option in the DSR Options header in the\
    \ packet, or the IP\n      Destination Address in the packet if the packet does\
    \ not contain a\n      DSR Source Route option or the Segments Left there is zero.\n\
    \   -  If the packet contains an Acknowledgement option, then this node\n    \
    \  MUST NOT process the Acknowledgement Request option.\n   If neither of the\
    \ tests above fails, then this node MUST process the\n   Acknowledgement Request\
    \ option by sending an Acknowledgement option\n   to the previous-hop node; to\
    \ do so, the node performs the following\n   sequence of steps:\n   -  Create\
    \ a packet and set the IP Protocol field to the protocol\n      number assigned\
    \ for DSR (48).\n   -  Set the IP Source Address field in this packet to the IP\
    \ address\n      of this node, copied from the source route in the DSR Source\
    \ Route\n      option in that packet (or from the IP Destination Address field\
    \ of\n      the packet, if the packet does not contain a DSR Source Route\n  \
    \    option).\n   -  Set the IP Destination Address field in this packet to the\
    \ IP\n      address of the previous-hop node, copied from the source route in\n\
    \      the DSR Source Route option in that packet (or from the IP Source\n   \
    \   Address field of the packet, if the packet does not contain a DSR\n      Source\
    \ Route option).\n   -  Add a DSR Options header to the packet.  Set the Next\
    \ Header field\n      in the DSR Options header to the value 59, \"No Next Header\"\
    \n      [RFC2460].\n   -  Add an Acknowledgement option to the DSR Options header\
    \ in the\n      packet; set the Acknowledgement option's Option Type field to\
    \ 6\n      and the Opt Data Len field to 10.\n   -  Copy the Identification field\
    \ from the received Acknowledgement\n      Request option into the Identification\
    \ field in the\n      Acknowledgement option.\n   -  Set the ACK Source Address\
    \ field in the Acknowledgement option to\n      be the IP Source Address of this\
    \ new packet (set above to be the\n      IP address of this node).\n   -  Set\
    \ the ACK Destination Address field in the Acknowledgement\n      option to be\
    \ the IP Destination Address of this new packet (set\n      above to be the IP\
    \ address of the previous-hop node).\n   -  Send the packet as described in Section\
    \ 8.1.1.\n   Packets containing an Acknowledgement option SHOULD NOT be placed\
    \ in\n   the Maintenance Buffer.\n   When a node receives a packet with both an\
    \ Acknowledgement option and\n   an Acknowledgement Request option, if that node\
    \ is not the\n   destination of the Acknowledgement option (the IP Destination\
    \ Address\n   of the packet), then the Acknowledgement Request option MUST be\n\
    \   ignored.  Otherwise (that node is the destination of the\n   Acknowledgement\
    \ option), that node MUST process the Acknowledgement\n   Request option by returning\
    \ an Acknowledgement option according to\n   the following sequence of steps:\n\
    \   -  Create a packet and set the IP Protocol field to the protocol\n      number\
    \ assigned for DSR (48).\n   -  Set the IP Source Address field in this packet\
    \ to the IP address\n      of this node, copied from the source route in the DSR\
    \ Source Route\n      option in that packet (or from the IP Destination Address\
    \ field of\n      the packet, if the packet does not contain a DSR Source Route\n\
    \      option).\n   -  Set the IP Destination Address field in this packet to\
    \ the IP\n      address of the node originating the Acknowledgement option.\n\
    \   -  Add a DSR Options header to the packet, and set the DSR Options\n     \
    \ header's Next Header field to the value 59, \"No Next Header\"\n      [RFC2460].\n\
    \   -  Add an Acknowledgement option to the DSR Options header in this\n     \
    \ packet; set the Acknowledgement option's Option Type field to 6\n      and the\
    \ Opt Data Len field to 10.\n   -  Copy the Identification field from the received\
    \ Acknowledgement\n      Request option into the Identification field in the\n\
    \      Acknowledgement option.\n   -  Set the ACK Source Address field in the\
    \ option to the IP Source\n      Address of this new packet (set above to be the\
    \ IP address of this\n      node).\n   -  Set the ACK Destination Address field\
    \ in the option to the IP\n      Destination Address of this new packet (set above\
    \ to be the IP\n      address of the node originating the Acknowledgement option).\n\
    \   -  Send the packet directly to the destination.  The IP Destination\n    \
    \  Address MUST be treated as a direct neighbor node: the\n      transmission\
    \ to that node MUST be done in a single IP forwarding\n      hop, without Route\
    \ Discovery and without searching the Route\n      Cache.  In addition, this packet\
    \ MUST NOT contain a DSR\n      Acknowledgement Request, MUST NOT be retransmitted\
    \ for Route\n      Maintenance, and MUST NOT expect a link-layer acknowledgement\
    \ or\n      passive acknowledgement.\n   When using network-layer acknowledgements\
    \ for Route Maintenance, a\n   node SHOULD use an adaptive algorithm in determining\
    \ the\n   retransmission timeout for each transmission attempt of an\n   acknowledgement\
    \ request.  For example, a node SHOULD maintain a\n   separate round-trip time\
    \ (RTT) estimate for each node to which it has\n   recently attempted to transmit\
    \ packets, and it SHOULD use this RTT\n   estimate in setting the timeout for\
    \ each retransmission attempt for\n   Route Maintenance.  The TCP RTT estimation\
    \ algorithm has been shown\n   to work well for this purpose in implementation\
    \ and testbed\n   experiments with DSR [MALTZ99b, MALTZ01].\n"
- title: 8.3.4.  Originating a Route Error
  contents:
  - "8.3.4.  Originating a Route Error\n   When a node is unable to verify reachability\
    \ of a next-hop node after\n   reaching a maximum number of retransmission attempts,\
    \ it SHOULD send\n   a Route Error to the IP Source Address of the packet.  When\
    \ sending a\n   Route Error for a packet containing either a Route Error option\
    \ or an\n   Acknowledgement option, a node SHOULD add these existing options to\n\
    \   its Route Error, subject to the limit described below.\n   A node transmitting\
    \ a Route Error MUST perform the following steps:\n   -  Create an IP packet and\
    \ set the IP Protocol field to the protocol\n      number assigned for DSR (48).\
    \  Set the Source Address field in\n      this packet's IP header to the address\
    \ of this node.\n   -  If the Salvage field in the DSR Source Route option in\
    \ the packet\n      triggering the Route Error is zero, then copy the Source Address\n\
    \      field of the packet triggering the Route Error into the\n      Destination\
    \ Address field in the new packet's IP header;\n      otherwise, copy the Address[1]\
    \ field from the DSR Source Route\n      option of the packet triggering the Route\
    \ Error into the\n      Destination Address field in the new packet's IP header\n\
    \   -  Insert a DSR Options header into the new packet.\n   -  Add a Route Error\
    \ Option to the new packet, setting the Error Type\n      to NODE_UNREACHABLE,\
    \ the Salvage value to the Salvage value from\n      the DSR Source Route option\
    \ of the packet triggering the Route\n      Error, and the Unreachable Node Address\
    \ field to the address of\n      the next-hop node from the original source route.\
    \  Set the Error\n      Source Address field to this node's IP address, and the\
    \ Error\n      Destination field to the new packet's IP Destination Address.\n\
    \   -  If the packet triggering the Route Error contains any Route Error\n   \
    \   or Acknowledgement options, the node MAY append to its Route Error\n     \
    \ each of these options, with the following constraints:\n      o  The node MUST\
    \ NOT include any Route Error option from the\n         packet triggering the\
    \ new Route Error, for which the total\n         Salvage count (Section 6.4) of\
    \ that included Route Error would\n         be greater than MAX_SALVAGE_COUNT\
    \ in the new packet.\n      o  If any Route Error option from the packet triggering\
    \ the new\n         Route Error is not included in the packet, the node MUST NOT\n\
    \         include any following Route Error or Acknowledgement options\n     \
    \    from the packet triggering the new Route Error.\n      o  Any appended options\
    \ from the packet triggering the Route Error\n         MUST follow the new Route\
    \ Error in the packet.\n      o  In appending these options to the new Route Error,\
    \ the order of\n         these options from the packet triggering the Route Error\
    \ MUST\n         be preserved.\n   -  Send the packet as described in Section\
    \ 8.1.1.\n"
- title: 8.3.5.  Processing a Received Route Error Option
  contents:
  - "8.3.5.  Processing a Received Route Error Option\n   When a node receives a packet\
    \ containing a Route Error option, that\n   node MUST process the Route Error\
    \ option according to the following\n   sequence of steps:\n   -  The node MUST\
    \ remove from its Route Cache the link from the node\n      identified by the\
    \ Error Source Address field to the node\n      identified by the Unreachable\
    \ Node Address field (if this link is\n      present in its Route Cache).  If\
    \ the node implements its Route\n      Cache as a link cache, as described in\
    \ Section 4.1, only this\n      single link is removed; if the node implements\
    \ its Route Cache as\n      a path cache, however, all routes (paths) that use\
    \ this link are\n      either truncated before the link or removed completely.\n\
    \   -  If the option following the Route Error is an Acknowledgement or\n    \
    \  Route Error option sent by this node (that is, with\n      Acknowledgement\
    \ or Error Source Address equal to this node's\n      address), copy the DSR options\
    \ following the current Route Error\n      into a new packet with IP Source Address\
    \ equal to this node's own\n      IP address and IP Destination Address equal\
    \ to the Acknowledgement\n      or Error Destination Address.  Transmit this packet\
    \ as described\n      in Section 8.1.1, with the Salvage count in the DSR Source\
    \ Route\n      option set to the Salvage value of the Route Error.\n   In addition,\
    \ after processing the Route Error as described above, the\n   node MAY initiate\
    \ a new Route Discovery for any destination node for\n   which it then has no\
    \ route in its Route Cache as a result of\n   processing this Route Error, if\
    \ the node has indication that a route\n   to that destination is needed.  For\
    \ example, if the node has an open\n   TCP connection to some destination node,\
    \ then if the processing of\n   this Route Error removed the only route to that\
    \ destination from this\n   node's Route Cache, then this node MAY initiate a\
    \ new Route Discovery\n   for that destination node.  Any node, however, MUST\
    \ limit the rate at\n   which it initiates new Route Discoveries for any single\
    \ destination\n   address, and any new Route Discovery initiated in this way as\
    \ part of\n   processing this Route Error MUST conform as a part of this limit.\n"
- title: 8.3.6.  Salvaging a Packet
  contents:
  - "8.3.6.  Salvaging a Packet\n   When an intermediate node forwarding a packet\
    \ detects through Route\n   Maintenance that the next-hop link along the route\
    \ for that packet is\n   broken (Section 8.3), if the node has another route to\
    \ the packet's\n   IP Destination Address in its Route Cache, the node SHOULD\
    \ \"salvage\"\n   the packet rather than discard it.  To do so using the route\
    \ found in\n   its Route Cache, this node processes the packet as follows:\n \
    \  -  If the MAC protocol in use in the network is not capable of\n      transmitting\
    \ unicast packets over unidirectional links, as\n      discussed in Section 3.3.1,\
    \ then if this packet contains a Route\n      Reply option, remove and discard\
    \ the Route Reply option in the\n      packet; if the DSR Options header in the\
    \ packet then contains no\n      DSR options or only a DSR Source Route Option,\
    \ remove the DSR\n      Options header from the packet.  If the resulting packet\
    \ then\n      contains only an IP header (e.g., no transport layer header or\n\
    \      payload), the node SHOULD NOT salvage the packet and instead\n      SHOULD\
    \ discard the entire packet.\n   -  Modify the existing DSR Source Route option\
    \ in the packet so that\n      the Address[i] fields represent the source route\
    \ found in this\n      node's Route Cache to this packet's IP Destination Address.\n\
    \      Specifically, the node copies the hop addresses of the source\n      route\
    \ into sequential Address[i] fields in the DSR Source Route\n      option, for\
    \ i = 1, 2, ..., n.  Address[1], here, is the address of\n      the salvaging\
    \ node itself (the first address in the source route\n      found from this node\
    \ to the IP Destination Address of the packet).\n      The value n, here, is the\
    \ number of hop addresses in this source\n      route, excluding the destination\
    \ of the packet (which is instead\n      already represented in the Destination\
    \ Address field in the\n      packet's IP header).\n   -  Initialize the Segments\
    \ Left field in the DSR Source Route option\n      to n as defined above.\n  \
    \ -  The First Hop External (F) bit in the DSR Source Route option MUST\n    \
    \  be set to 0.\n   -  The Last Hop External (L) bit in the DSR Source Route option\
    \ is\n      copied from the External bit flagging the last hop in the source\n\
    \      route for the packet, as indicated in the Route Cache.\n   -  The Salvage\
    \ field in the DSR Source Route option is set to 1 plus\n      the value of the\
    \ Salvage field in the DSR Source Route option of\n      the packet that caused\
    \ the error.\n   -  Transmit the packet to the next-hop node on the new source\
    \ route\n      in the packet, using the forwarding procedure described in Section\n\
    \      8.1.5.\n   As described in Section 8.3.4, the node in this case also SHOULD\n\
    \   return a Route Error to the original sender of the packet.  If the\n   node\
    \ chooses to salvage the packet, it SHOULD do so after originating\n   the Route\
    \ Error.\n   When returning any Route Reply in the case in which the MAC protocol\n\
    \   in use in the network is not capable of transmitting unicast packets\n   over\
    \ unidirectional links, the source route used for routing the\n   Route Reply\
    \ packet MUST be obtained by reversing the sequence of hops\n   in the Route Request\
    \ packet (the source route that is then returned\n   in the Route Reply).  This\
    \ restriction on returning a Route Reply and\n   on salvaging a packet that contains\
    \ a Route Reply option enables the\n   Route Reply to test this sequence of hops\
    \ for bidirectionality,\n   preventing the Route Reply from being received by\
    \ the initiator of\n   the Route Discovery unless each of the hops over which\
    \ the Route\n   Reply is returned (and thus each of the hops in the source route\n\
    \   being returned in the Reply) is bidirectional.\n"
- title: 8.4.  Multiple Network Interface Support
  contents:
  - "8.4.  Multiple Network Interface Support\n   A node using DSR MAY have multiple\
    \ network interfaces that support\n   DSR ad hoc network routing.  This section\
    \ describes special packet\n   processing at such nodes.\n   A node with multiple\
    \ network interfaces that support DSR ad hoc\n   network routing MUST have some\
    \ policy for determining which Route\n   Request packets are forwarded using which\
    \ network interfaces.  For\n   example, a node MAY choose to forward all Route\
    \ Requests over all\n   network interfaces.\n   When a node with multiple network\
    \ interfaces that support DSR\n   propagates a Route Request on a network interface\
    \ other than the one\n   on which it received the Route Request, it MUST in this\
    \ special case\n   modify the Address list in the Route Request as follows:\n\
    \   -  Append the node's IP address for the incoming network interface.\n   -\
    \  Append the node's IP address for the outgoing network interface.\n   When a\
    \ node forwards a packet containing a source route, it MUST\n   assume that the\
    \ next-hop node is reachable on the incoming network\n   interface, unless the\
    \ next hop is the address of one of this node's\n   network interfaces, in which\
    \ case this node MUST skip over this\n   address in the source route and process\
    \ the packet in the same way as\n   if it had just received it from that network\
    \ interface, as described\n   in Section 8.1.5.\n   If a node that previously\
    \ had multiple network interfaces that\n   support DSR receives a packet sent\
    \ with a source route specifying a\n   change to a network interface, as described\
    \ above, that is no longer\n   available, it MAY send a Route Error to the source\
    \ of the packet\n   without attempting to forward the packet on the incoming network\n\
    \   interface, unless the network uses an autoconfiguration mechanism\n   that\
    \ may have allowed another node to acquire the now unused address\n   of the unavailable\
    \ network interface.\n"
- title: 8.5.  IP Fragmentation and Reassembly
  contents:
  - "8.5.  IP Fragmentation and Reassembly\n   When a node using DSR wishes to fragment\
    \ a packet that contains a DSR\n   header not containing a Route Request option,\
    \ it MUST perform the\n   following sequence of steps:\n   -  Remove the DSR Options\
    \ header from the packet.\n   -  Fragment the packet using normal IP fragmentation\
    \ processing\n      [RFC791].  However, when determining the size of each fragment\
    \ to\n      create from the original packet, the fragment size MUST be reduced\n\
    \      by the size of the DSR Options header from the original packet.\n   - \
    \ IP-in-IP encapsulate each fragment [RFC2003].  The IP Destination\n      address\
    \ of the outer (encapsulating) packet MUST be set equal to\n      the IP Destination\
    \ address of the original packet.\n   -  Add the DSR Options header from the original\
    \ packet to each\n      resulting encapsulating packet.  If a Source Route header\
    \ is\n      present in the DSR Options header, increment the Salvage field.\n\
    \   When a node using the DSR protocol receives an IP-in-IP encapsulated\n   packet\
    \ destined to itself, it SHOULD decapsulate the packet [RFC2003]\n   and then\
    \ process the inner packet according to standard IP reassembly\n   processing\
    \ [RFC791].\n"
- title: 8.6.  Flow State Processing
  contents:
  - "8.6.  Flow State Processing\n   A node implementing the optional DSR flow state\
    \ extension MUST follow\n   these additional processing steps.\n"
- title: 8.6.1.  Originating a Packet
  contents:
  - "8.6.1.  Originating a Packet\n   When originating any packet to be routed using\
    \ flow state, a node\n   using DSR flow state MUST do the following:\n   -  If\
    \ the route to be used for this packet has never had a DSR flow\n      state established\
    \ along it (or the existing flow state has\n      expired):\n      o  Generate\
    \ a 16-bit Flow ID larger than any unexpired Flow IDs\n         used by this node\
    \ for this destination.  Odd Flow IDs MUST be\n         chosen for \"default\"\
    \ flows; even Flow IDs MUST be chosen for\n         non-default flows.\n     \
    \ o  Add a DSR Options header, as described in Section 8.1.2.\n      o  Add a\
    \ DSR Flow State header, as described in Section 8.6.2.\n      o  Initialize the\
    \ Hop Count field in the DSR Flow State header to\n         0.\n      o  Set the\
    \ Flow ID field in the DSR Flow State header to the Flow\n         ID generated\
    \ in the first step.\n      o  Add a Timeout option to the DSR Options header.\n\
    \      o  Add a Source Route option after the Timeout option with the\n      \
    \   route to be used, as described in Section 8.1.3.\n      o  The source node\
    \ SHOULD record this flow in its Flow Table.\n      o  If this flow is recorded\
    \ in the Flow Table, the TTL in this\n         Flow Table entry MUST be set to\
    \ be the TTL of this flow\n         establishment packet.\n      o  If this flow\
    \ is recorded in the Flow Table, the timeout in this\n         Flow Table entry\
    \ MUST be set to a value no less than the value\n         specified in the Timeout\
    \ option.\n   -  If the route to be used for this packet has had DSR flow state\n\
    \      established along it, but has not been established end-to-end:\n      o\
    \  Add a DSR Options header, as described in Section 8.1.2.\n      o  Add a DSR\
    \ Flow State header, as described in Section 8.6.2.\n      o  Initialize the Hop\
    \ Count field in the DSR Flow State header to\n         0.\n      o  The Flow\
    \ ID field of the DSR Flow State header SHOULD be the\n         Flow ID previously\
    \ used for this route.  If it is not, the\n         steps for sending packets\
    \ along never-before-established routes\n         above MUST be followed in place\
    \ of these.\n      o  Add a Timeout option to the DSR Options header, setting\
    \ the\n         Timeout to a value not greater than the timeout remaining for\n\
    \         this flow in the Flow Table.\n      o  Add a Source Route option after\
    \ the Timeout option with the\n         route to be used, as described in Section\
    \ 8.1.3.\n      o  If the IP TTL is not equal to the TTL specified in the Flow\n\
    \         Table, the source node MUST set a flag to indicate that this\n     \
    \    flow cannot be used as default.\n   -  If the route the node wishes to use\
    \ for this packet has been\n      established as a flow end-to-end and is not\
    \ the default flow:\n      o  Add a DSR Flow State header, as described in Section\
    \ 8.6.2.\n      o  Initialize the Hop Count field in the DSR Flow State header\
    \ to\n         0.\n      o  The Flow ID field of the DSR Flow State header SHOULD\
    \ be set to\n         the Flow ID previously used for this route.  If it is not,\
    \ the\n         steps for sending packets along never-before-established routes\n\
    \         above MUST be followed in place of these.\n      o  If the next hop\
    \ requires a network-layer acknowledgement for\n         Route Maintenance, add\
    \ a DSR Options header, as described in\n         Section 8.1.2, and an Acknowledgement\
    \ Request option, as\n         described in Section 8.3.3.\n      o  A DSR Options\
    \ header SHOULD NOT be added to a packet, unless it\n         is added to carry\
    \ an Acknowledgement Request option, in which\n         case:\n         +  A Source\
    \ Route option in the DSR Options header SHOULD NOT\n            be added.\n \
    \        +  If a Source Route option in the DSR Options header is added,\n   \
    \         the steps for sending packets along flows not yet\n            established\
    \ end-to-end MUST be followed in place of these.\n         +  A Timeout option\
    \ SHOULD NOT be added.\n         +  If a Timeout option is added, it MUST specify\
    \ a timeout not\n            greater than the timeout remaining for this flow\
    \ in the Flow\n            Table.\n   -  If the route the node wishes to use for\
    \ this packet has been\n      established as a flow end-to-end and is the current\
    \ default flow:\n      o  If the IP TTL is not equal to the TTL specified in the\
    \ Flow\n         Table, the source node MUST follow the steps above for sending\n\
    \         a packet along a non-default flow that has been established\n      \
    \   end-to-end in place of these steps.\n      o  If the next hop requires a network-layer\
    \ acknowledgement for\n         Route Maintenance, the sending node MUST add a\
    \ DSR Options\n         header and an Acknowledgement Request option, as described\
    \ in\n         Section 8.3.3.  The sending node MUST NOT add any additional\n\
    \         options to this header.\n      o  A DSR Options header SHOULD NOT be\
    \ added, except as specified\n         in the previous step.  If one is added\
    \ in a way inconsistent\n         with the previous step, the source node MUST\
    \ follow the steps\n         above for sending a packet along a non-default flow\
    \ that has\n         been established end-to-end in place of these steps.\n"
- title: 8.6.2.  Inserting a DSR Flow State Header
  contents:
  - "8.6.2.  Inserting a DSR Flow State Header\n   A node originating a packet adds\
    \ a DSR Flow State header to the\n   packet, if necessary, to carry information\
    \ needed by the routing\n   protocol.  A packet MUST NOT contain more than one\
    \ DSR Flow State\n   header.  A DSR Flow State header is added to a packet by\
    \ performing\n   the following sequence of steps:\n   -  Insert a DSR Flow State\
    \ header after the IP header and any Hop-\n      by-Hop Options header that may\
    \ already be in the packet, but\n      before any other header that may be present.\n\
    \   -  Set the Next Header field of the DSR Flow State header to the Next\n  \
    \    Header field of the previous header (either an IP header or a\n      Hop-by-Hop\
    \ Options header).\n   -  Set the Flow (F) bit in the DSR Flow State header to\
    \ 1.\n   -  Set the Protocol field of the IP header to the protocol number\n \
    \     assigned for DSR (48).\n"
- title: 8.6.3.  Receiving a Packet
  contents:
  - "8.6.3.  Receiving a Packet\n   This section describes processing only for packets\
    \ that are sent to\n   this processing node as the next-hop node; that is, when\
    \ the MAC-\n   layer destination address is the MAC address of this node.\n  \
    \ Otherwise, the process described in Sections 8.6.5 should be\n   followed.\n\
    \   The flow along which a packet is being sent is considered to be in\n   the\
    \ Flow Table if the triple (IP Source Address, IP Destination\n   Address, Flow\
    \ ID) has an unexpired entry in this node's Flow Table.\n   When a node using\
    \ DSR flow state receives a packet, it MUST follow\n   the following steps for\
    \ processing:\n   -  If a DSR Flow State header is present, increment the Hop\
    \ Count\n      field.\n   -  In addition, if a DSR Flow State header is present,\
    \ then if the\n      triple (IP Source Address, IP Destination Address, Flow ID)\
    \ is in\n      this node's Automatic Route Shortening Table and the packet is\n\
    \      listed in the entry, then the node MAY send a gratuitous Route\n      Reply\
    \ as described in Section 4.4, subject to the rate limiting\n      specified therein.\
    \  This gratuitous Route Reply gives the route by\n      which the packet originally\
    \ reached this node.  Specifically, the\n      node sending the gratuitous Route\
    \ Reply constructs the route to\n      return in the Route Reply as follows:\n\
    \      o  Let k = (packet Hop Count) - (table Hop Count), where packet\n     \
    \    Hop Count is the value of the Hop Count field in this received\n        \
    \ packet, and table Hop Count is the Hop Count value stored for\n         this\
    \ packet in the corresponding entry in this node's Automatic\n         Route Shortening\
    \ Table.\n      o  Copy the complete source route for this flow from the\n   \
    \      corresponding entry in the node's Flow Table.\n      o  Remove from this\
    \ route the k hops immediately preceding this\n         node in the route, since\
    \ these are the hops \"skipped over\" by\n         the packet as recorded in the\
    \ Automatic Route Shortening Table\n         entry.\n   -  Process each of the\
    \ DSR options within the DSR Options header in\n      order:\n      o  On receiving\
    \ a Pad1 or PadN option, skip over the option.\n      o  On receiving a Route\
    \ Request for which this node is the\n         destination, remove the option\
    \ and return a Route Reply as\n         specified in Section 8.2.2.\n      o \
    \ On receiving a broadcast Route Request that this node has not\n         previously\
    \ seen for which this node is not the destination,\n         append this node's\
    \ incoming interface address to the Route\n         Request, continue propagating\
    \ the Route Request as specified in\n         Section 8.2.2, pass the payload,\
    \ if any, to the network layer,\n         and stop processing.\n      o  On receiving\
    \ a Route Request that this node has previously seen\n         for which this\
    \ node is not the destination, discard the packet\n         and stop processing.\n\
    \      o  On receiving any Route Request, add appropriate links to the\n     \
    \    Route Cache, as specified in Section 8.2.2.\n      o  On receiving a Route\
    \ Reply for which this node is the\n         initiator, remove the Route Reply\
    \ from the packet and process\n         it as specified in Section 8.2.6.\n  \
    \    o  On receiving any Route Reply, add appropriate links to the\n         Route\
    \ Cache, as specified in Section 8.2.6.\n      o  On receiving any Route Error\
    \ of type NODE_UNREACHABLE, remove\n         appropriate links to the Route Cache,\
    \ as specified in Section\n         8.3.5.\n      o  On receiving a Route Error\
    \ of type NODE_UNREACHABLE that this\n         node is the Error Destination Address\
    \ of, remove the Route\n         Error from the packet and process it as specified\
    \ in Section\n         8.3.5.  It also MUST stop originating packets along any\
    \ flows\n         using the link from Error Source Address to Unreachable Node,\n\
    \         and it MAY remove from its Flow Table any flows using the link\n   \
    \      from Error Source Address to Unreachable Node.\n      o  On receiving a\
    \ Route Error of type UNKNOWN_FLOW that this node\n         is not the Error Destination\
    \ Address of, the node checks if the\n         Route Error corresponds to a flow\
    \ in its Flow Table.  If it\n         does not, the node silently discards the\
    \ Route Error;\n         otherwise, it forwards the packet to the expected previous\
    \ hop\n         of the corresponding flow.  If Route Maintenance cannot confirm\n\
    \         the reachability of the previous hop, the node checks if the\n     \
    \    network interface requires bidirectional links for operation.\n         If\
    \ it does, the node silently discards the Route Error;\n         otherwise, it\
    \ sends the Error as if it were originating it, as\n         described in Section\
    \ 8.1.1.\n      o  On receiving a Route Error of type UNKNOWN_FLOW that this node\n\
    \         is the Error Destination Address of, remove the Route Error\n      \
    \   from the packet and mark the flow specified by the triple\n         (Error\
    \ Destination Address, Original IP Destination Address,\n         Flow ID) as\
    \ not having been established end-to-end.\n      o  On receiving a Route Error\
    \ of type DEFAULT_FLOW_UNKNOWN that\n         this node is not the Error Destination\
    \ Address of, the node\n         checks if the Route Error corresponds to a flow\
    \ in its Default\n         Flow Table.  If it does not, the node silently discards\
    \ the\n         Route Error; otherwise, it forwards the packet to the expected\n\
    \         previous hop of the corresponding flow.  If Route Maintenance\n    \
    \     cannot confirm the reachability of the previous hop, the node\n        \
    \ checks if the network interface requires bidirectional links\n         for operation.\
    \  If it does, the node silently discards the\n         Route Error; otherwise,\
    \ it sends the Error as if it were\n         originating it, as described in Section\
    \ 8.1.1.\n      o  On receiving a Route Error of type DEFAULT_FLOW_UNKNOWN that\n\
    \         this node is the Error Destination Address of, remove the Route\n  \
    \       Error from the packet and mark the default flow between the\n        \
    \ Error Destination Address and the Original IP Destination\n         Address\
    \ as not having been established end-to-end.\n      o  On receiving an Acknowledgement\
    \ Request option, the receiving\n         node removes the Acknowledgement Request\
    \ option and replies to\n         the previous hop with an Acknowledgement option.\
    \  If the\n         previous hop cannot be determined, the Acknowledgement Request\n\
    \         option is discarded, and processing continues.\n      o  On receiving\
    \ an Acknowledgement option, the receiving node\n         removes the Acknowledgement\
    \ option and processes it.\n      o  On receiving any Acknowledgement option,\
    \ add the appropriate\n         link to the Route Cache, as specified in Section\
    \ 8.1.4.\n      o  On receiving any Source Route option, add appropriate links\
    \ to\n         the Route Cache, as specified in Section 8.1.4.\n      o  On receiving\
    \ a Source Route option, if no DSR Flow State header\n         is present, if\
    \ the flow this packet is being sent along is in\n         the Flow Table, or\
    \ if no Timeout option preceded the Source\n         Route option in this DSR\
    \ Options header, process it as\n         specified in Section 8.1.4.  Stop processing\
    \ this packet unless\n         the last address in the Source Route option is\
    \ an address of\n         this node.\n      o  On receiving a Source Route option\
    \ in a packet with a DSR Flow\n         State header, if the Flow ID specified\
    \ in the DSR Flow State\n         header is not in the Flow Table, add the flow\
    \ to the Flow\n         Table, setting the Timeout value to a value not greater\
    \ than\n         the Timeout field of the Timeout option in this header.  If no\n\
    \         Timeout option preceded the Source Route option in this header,\n  \
    \       the flow MUST NOT be added to the Flow Table.\n         If the Flow ID\
    \ is odd and larger than any unexpired, odd Flow\n         IDs for this (IP Source\
    \ Address, IP Destination Address), it is\n         set to be default in the Default\
    \ Flow ID Table.\n         Then process the Route option as specified in Section\
    \ 8.1.4.\n         Stop processing this packet unless the last address in the\n\
    \         Source Route option is an address of this node.\n      o  On receiving\
    \ a Timeout option, check if this packet contains a\n         DSR Flow State header.\
    \  If this packet does not contain a DSR\n         Flow State header, discard\
    \ the DSR option.  Otherwise, record\n         the Timeout value in the option\
    \ for future reference.  The\n         value recorded SHOULD be discarded when\
    \ the node has finished\n         processing this DSR Options header.  If the\
    \ flow that this\n         packet is being sent along is in the Flow Table, it\
    \ MAY set the\n         flow to time out no more than Timeout seconds in the future.\n\
    \      o  On receiving a Destination and Flow ID option, if the IP\n         Destination\
    \ Address is not an address of this node, forward the\n         packet according\
    \ to the Flow ID, as described in Section 8.6.4,\n         and stop processing\
    \ this packet.\n      o  On receiving a Destination and Flow ID option, if the\
    \ IP\n         Destination Address is an address of this node, set the IP\n  \
    \       Destination Address to the New IP Destination Address specified\n    \
    \     in the option and set the Flow ID to the New Flow Identifier.\n        \
    \ Then remove the Destination and Flow ID option from the packet\n         and\
    \ continue processing.\n   -  If the IP Destination Address is an address of this\
    \ node, remove\n      the DSR Options header, if any, pass the packet up the network\n\
    \      stack, and stop processing.\n   -  If there is still a DSR Options header\
    \ containing no options,\n      remove the DSR Options header.\n   -  If there\
    \ is still a DSR Flow State header, forward the packet\n      according to the\
    \ Flow ID, as described in Section 8.6.4.\n   -  If there is neither a DSR Options\
    \ header nor a DSR Flow State\n      header, but there is an entry in the Default\
    \ Flow Table for the\n      (IP Source Address, IP Destination Address) pair:\n\
    \      o  If the IP TTL is not equal to the TTL expected in the Flow\n       \
    \  Table, insert a DSR Flow State header, setting the Hop Count\n         equal\
    \ to the Hop Count of this node, and the Flow ID equal to\n         the default\
    \ Flow ID found in the Default Flow Table, and\n         forward this packet according\
    \ to the Flow ID, as described in\n         Section 8.6.4.\n      o  Otherwise,\
    \ follow the steps for forwarding the packet using\n         Flow IDs described\
    \ in Section 8.6.4, but taking the Flow ID to\n         be the default Flow ID\
    \ found in the Default Flow Table.\n   -  If there is no DSR Options header and\
    \ no DSR Flow State header and\n      no default flow can be found, the node returns\
    \ a Route Error of\n      type DEFAULT_FLOW_UNKNOWN to the IP Source Address,\
    \ specifying the\n      IP Destination Address as the Original IP Destination\
    \ in the\n      type-specific field.\n"
- title: 8.6.4.  Forwarding a Packet Using Flow IDs
  contents:
  - "8.6.4.  Forwarding a Packet Using Flow IDs\n   To forward a packet using Flow\
    \ IDs, a node MUST follow the following\n   sequence of steps:\n   -  If the triple\
    \ (IP Source Address, IP Destination Address, Flow ID)\n      is not in the Flow\
    \ Table, return a Route Error of type\n      UNKNOWN_FLOW.\n   -  If a network-layer\
    \ acknowledgement is required for Route\n      Maintenance for the next hop, the\
    \ node MUST include an\n      Acknowledgement Request option as specified in Section\
    \ 8.3.3.  If\n      no DSR Options header is in the packet in which the\n    \
    \  Acknowledgement Request option is to be added, it MUST be\n      included,\
    \ as described in Section 8.1.2, except that it MUST be\n      added after the\
    \ DSR Flow State header, if one is present.\n   -  Attempt to transmit this packet\
    \ to the next hop as specified in\n      the Flow Table, performing Route Maintenance\
    \ to detect broken\n      routes.\n"
- title: 8.6.5.  Promiscuously Receiving a Packet
  contents:
  - "8.6.5.  Promiscuously Receiving a Packet\n   This section describes processing\
    \ only for packets that have MAC\n   destinations other than this processing node.\
    \  Otherwise, the process\n   described in Section 8.6.3 should be followed.\n\
    \   When a node using DSR flow state promiscuously overhears a packet, it\n  \
    \ SHOULD follow the following steps for processing:\n   -  If the packet contains\
    \ a DSR Flow State header, and if the triple\n      (IP Source Address, IP Destination\
    \ Address, Flow ID) is in the\n      Flow Table and the Hop Count is less than\
    \ the Hop Count in the\n      flow's entry, the node MAY retain the packet in\
    \ the Automatic\n      Route Shortening Table.  If it can be determined that this\
    \ Flow ID\n      has been recently used, the node SHOULD retain the packet in\
    \ the\n      Automatic Route Shortening Table.\n   -  If the packet contains neither\
    \ a DSR Flow State header nor a\n      Source Route option and a Default Flow\
    \ ID can be found in the\n      Default Flow Table for the (IP Source Address,\
    \ IP Destination\n      Address), and if the IP TTL is greater than the TTL in\
    \ the Flow\n      Table for the default flow, the node MAY retain the packet in\
    \ the\n      Automatic Route Shortening Table.  If it can be determined that\n\
    \      this Flow ID has been used recently, the node SHOULD retain the\n     \
    \ packet in the Automatic Route Shortening Table.\n"
- title: 8.6.6.  Operation Where the Layer below DSR Decreases the IP TTL
  contents:
  - "8.6.6.  Operation Where the Layer below DSR Decreases the IP TTL\n        Non-uniformly\n\
    \   Some nodes may use an IP tunnel as a DSR hop.  If different packets\n   sent\
    \ along this IP tunnel can take different routes, the reduction in\n   IP TTL\
    \ across this link may be different for different packets.  This\n   prevents\
    \ the Automatic Route Shortening and Loop Detection\n   functionality from working\
    \ properly when used in conjunction with\n   default routes.\n   Nodes forwarding\
    \ packets without a Source Route option onto a link\n   with unpredictable TTL\
    \ changes MUST ensure that a DSR Flow State\n   header is present, indicating\
    \ the correct Hop Count and Flow ID.\n"
- title: 8.6.7.  Salvage Interactions with DSR
  contents:
  - "8.6.7.  Salvage Interactions with DSR\n   Nodes salvaging packets MUST remove\
    \ the DSR Flow State header, if\n   present.\n   Anytime this document refers\
    \ to the Salvage field in the Source Route\n   option, packets without a Source\
    \ Route option are considered to have\n   the value zero in the Salvage field.\n"
- title: 9.  Protocol Constants and Configuration Variables
  contents:
  - "9.  Protocol Constants and Configuration Variables\n   Any DSR implementation\
    \ MUST support the following configuration\n   variables and MUST support a mechanism\
    \ enabling the value of these\n   variables to be modified by system management.\
    \  The specific variable\n   names are used for demonstration purposes only, and\
    \ an implementation\n   is not required to use these names for the configuration\
    \ variables,\n   so long as the external behavior of the implementation is consistent\n\
    \   with that described in this document.\n   For each configuration variable\
    \ below, the default value is specified\n   to simplify configuration.  In particular,\
    \ the default values given\n   below are chosen for a DSR network running over\
    \ 2 Mbps IEEE 802.11\n   network interfaces using the Distributed Coordination\
    \ Function (DCF)\n   MAC protocol with RTS and CTS [IEEE80211, BROCH98].\n   \
    \   DiscoveryHopLimit                  255   hops\n      BroadcastJitter     \
    \                10   milliseconds\n      RouteCacheTimeout                  300\
    \   seconds\n      SendBufferTimeout                   30   seconds\n      RequestTableSize\
    \                    64   nodes\n      RequestTableIds                     16\
    \   identifiers\n      MaxRequestRexmt                     16   retransmissions\n\
    \      MaxRequestPeriod                    10   seconds\n      RequestPeriod \
    \                     500   milliseconds\n      NonpropRequestTimeout        \
    \       30   milliseconds\n      RexmtBufferSize                     50   packets\n\
    \      MaintHoldoffTime                   250   milliseconds\n      MaxMaintRexmt\
    \                        2   retransmissions\n      TryPassiveAcks           \
    \            1   attempt\n      PassiveAckTimeout                  100   milliseconds\n\
    \      GratReplyHoldoff                     1   second\n   In addition, the following\
    \ protocol constant MUST be supported by any\n   implementation of the DSR protocol:\n\
    \      MAX_SALVAGE_COUNT                   15   salvages\n"
- title: 10.  IANA Considerations
  contents:
  - "10.  IANA Considerations\n   This document specifies the DSR Options header and\
    \ DSR Flow State\n   header, for which the IP protocol number 48 has been assigned.\
    \  A\n   single IP protocol number can be used for both header types, since\n\
    \   they can be distinguished by the Flow State Header (F) bit in each\n   header.\n\
    \   In addition, this document proposes use of the value \"No Next Header\"\n\
    \   (originally defined for use in IPv6 [RFC2460]) within an IPv4 packet,\n  \
    \ to indicate that no further header follows a DSR Options header.\n   Finally,\
    \ this document introduces a number of DSR options for use in\n   the DSR Options\
    \ header, and additional new DSR options may be defined\n   in the future.  Each\
    \ of these options requires a unique Option Type\n   value, the most significant\
    \ 3 bits (that is, Option Type & 0xE0)\n   encoded as defined in Section 6.1.\
    \  It is necessary only that each\n   Option Type value be unique, not that they\
    \ be unique in the remaining\n   5 bits of the value after these 3 most significant\
    \ bits.\n   Two registries (DSR Protocol Options and DSR Protocol Route Error\n\
    \   Types) have been created and contain the initial registrations.\n   Assignment\
    \ of new values for DSR options will be by Expert Review\n   [RFC2434], with the\
    \ authors of this document serving as the\n   Designated Experts.\n"
- title: 11.  Security Considerations
  contents:
  - "11.  Security Considerations\n   This document does not specifically address\
    \ security concerns.  This\n   document does assume that all nodes participating\
    \ in the DSR protocol\n   do so in good faith and without malicious intent to\
    \ corrupt the\n   routing ability of the network.\n   Depending on the threat\
    \ model, a number of different mechanisms can\n   be used to secure DSR.  For\
    \ example, in an environment where node\n   compromise is unrealistic and where\
    \ all the nodes participating in\n   the DSR protocol share a common goal that\
    \ motivates their\n   participation in the protocol, the communications between\
    \ the nodes\n   can be encrypted at the physical channel or link layer to prevent\n\
    \   attack by outsiders.  Cryptographic approaches, such as that provided\n  \
    \ by Ariadne [HU02] or Secure Routing Protocol (SRP)\n   [PAPADIMITRATOS02], can\
    \ resist stronger attacks.\n"
- title: Appendix A.  Link-MaxLife Cache Description
  contents:
  - "Appendix A.  Link-MaxLife Cache Description\n   As guidance to implementers of\
    \ DSR, the description below outlines\n   the operation of a possible implementation\
    \ of a Route Cache for DSR\n   that has been shown to outperform other caches\
    \ studied in detailed\n   simulations.  Use of this design for the Route Cache\
    \ is recommended\n   in implementations of DSR.\n   This cache, called \"Link-MaxLife\"\
    \ [HU00], is a link cache, in that\n   each individual link (hop) in the routes\
    \ returned in Route Reply\n   packets (or otherwise learned from the header of\
    \ overhead packets) is\n   added to a unified graph data structure of this node's\
    \ current view\n   of the network topology, as described in Section 4.1.  To search\
    \ for\n   a route in this cache to some destination node, the sending node uses\n\
    \   a graph search algorithm, such as the well-known Dijkstra's\n   shortest-path\
    \ algorithm, to find the current best path through the\n   graph to the destination\
    \ node.\n   The Link-MaxLife form of link cache is adaptive in that each link\
    \ in\n   the cache has a timeout that is determined dynamically by the caching\n\
    \   node according to its observed past behavior of the two nodes at the\n   ends\
    \ of the link; in addition, when selecting a route for a packet\n   being sent\
    \ to some destination, among cached routes of equal length\n   (number of hops)\
    \ to that destination, Link-MaxLife selects the route\n   with the longest expected\
    \ lifetime (highest minimum timeout of any\n   link in the route).\n   Specifically,\
    \ in Link-MaxLife, a link's timeout in the Route Cache is\n   chosen according\
    \ to a \"Stability Table\" maintained by the caching\n   node.  Each entry in\
    \ a node's Stability Table records the address of\n   another node and a factor\
    \ representing the perceived \"stability\" of\n   this node.  The stability of\
    \ each other node in a node's Stability\n   Table is initialized to InitStability.\
    \  When a link from the Route\n   Cache is used in routing a packet originated\
    \ or salvaged by that\n   node, the stability metric for each of the two endpoint\
    \ nodes of that\n   link is incremented by the amount of time since that link\
    \ was last\n   used, multiplied by StabilityIncrFactor (StabilityIncrFactor >=\
    \ 1);\n   when a link is observed to break and the link is thus removed from\n\
    \   the Route Cache, the stability metric for each of the two endpoint\n   nodes\
    \ of that link is multiplied by StabilityDecrFactor\n   (StabilityDecrFactor <\
    \ 1).\n   When a node adds a new link to its Route Cache, the node assigns a\n\
    \   lifetime for that link in the Cache equal to the stability of the\n   less\
    \ \"stable\" of the two endpoint nodes for the link, except that a\n   link is\
    \ not allowed to be given a lifetime less than MinLifetime.\n   When a link is\
    \ used in a route chosen for a packet originated or\n   salvaged by this node,\
    \ the link's lifetime is set to be at least\n   UseExtends into the future; if\
    \ the lifetime of that link in the Route\n   Cache is already further into the\
    \ future, the lifetime remains\n   unchanged.\n   When a node using Link-MaxLife\
    \ selects a route from its Route Cache\n   for a packet being originated or salvaged\
    \ by this node, it selects\n   the shortest-length route that has the longest\
    \ expected lifetime\n   (highest minimum timeout of any link in the route), as\
    \ opposed to\n   simply selecting an arbitrary route of shortest length.\n   The\
    \ following configuration variables are used in the description of\n   Link-MaxLife\
    \ above.  The specific variable names are used for\n   demonstration purposes\
    \ only, and an implementation is not required to\n   use these names for these\
    \ configuration variables.  For each\n   configuration variable below, the default\
    \ value is specified to\n   simplify configuration.  In particular, the default\
    \ values given\n   below are chosen for a DSR network where nodes move at relative\n\
    \   velocities between 12 and 25 seconds per wireless transmission\n   radius.\n\
    \      InitStability                       25   seconds\n      StabilityIncrFactor\
    \                  4\n      StabilityDecrFactor                0.5\n      MinLifetime\
    \                          1   second\n      UseExtends                      \
    \   120   seconds\n"
- title: Appendix B.  Location of DSR in the ISO Network Reference Model
  contents:
  - "Appendix B.  Location of DSR in the ISO Network Reference Model\n   When designing\
    \ DSR, we had to determine at what layer within the\n   protocol hierarchy to\
    \ implement ad hoc network routing.  We\n   considered two different options:\
    \ routing at the link layer (ISO\n   layer 2) and routing at the network layer\
    \ (ISO layer 3).  Originally,\n   we opted to route at the link layer for several\
    \ reasons:\n   -  Pragmatically, running the DSR protocol at the link layer\n\
    \      maximizes the number of mobile nodes that can participate in ad\n     \
    \ hoc networks.  For example, the protocol can route equally well\n      between\
    \ IPv4 [RFC791], IPv6 [RFC2460], and IPX [TURNER90] nodes.\n   -  Historically\
    \ [JOHNSON94, JOHNSON96a], DSR grew from our\n      contemplation of a multi-hop\
    \ propagating version of the Internet's\n      Address Resolution Protocol (ARP)\
    \ [RFC826], as well as from the\n      routing mechanism used in IEEE 802 source\
    \ routing bridges\n      [PERLMAN92].  These are layer 2 protocols.\n   -  Technically,\
    \ we designed DSR to be simple enough that it could be\n      implemented directly\
    \ in the firmware inside wireless network\n      interface cards [JOHNSON94, JOHNSON96a],\
    \ well below the layer 3\n      software within a mobile node.  We see great potential\
    \ in this for\n      DSR running inside a cloud of mobile nodes around a fixed\
    \ base\n      station, where DSR would act to transparently extend the coverage\n\
    \      range to these nodes.  Mobile nodes that would otherwise be unable\n  \
    \    to communicate with the base station due to factors such as\n      distance,\
    \ fading, or local interference sources could then reach\n      the base station\
    \ through their peers.\n   Ultimately, however, we decided to specify and to implement\n\
    \   [MALTZ99b] DSR as a layer 3 protocol, since this is the only layer at\n  \
    \ which we could realistically support nodes with multiple network\n   interfaces\
    \ of different types forming an ad hoc network.\n"
- title: Appendix C.  Implementation and Evaluation Status
  contents:
  - "Appendix C.  Implementation and Evaluation Status\n   The initial design of the\
    \ DSR protocol, including DSR's basic Route\n   Discovery and Route Maintenance\
    \ mechanisms, was first published in\n   December 1994 [JOHNSON94]; significant\
    \ additional design details and\n   initial simulation results were published\
    \ in early 1996 [JOHNSON96a].\n   The DSR protocol has been extensively studied\
    \ since then through\n   additional detailed simulations.  In particular, we have\
    \ implemented\n   DSR in the ns-2 network simulator [NS-2, BROCH98] and performed\n\
    \   extensive simulations of DSR using ns-2 (e.g., [BROCH98, MALTZ99a]).\n   We\
    \ have also conducted evaluations of the different caching\n   strategies in this\
    \ document [HU00].\n   We have also implemented the DSR protocol under the FreeBSD\
    \ 2.2.7\n   operating system running on Intel x86 platforms.  FreeBSD [FREEBSD]\n\
    \   is based on a variety of free software, including 4.4 BSD Lite, from\n   the\
    \ University of California, Berkeley.  For the environments in\n   which we used\
    \ it, this implementation is functionally equivalent to\n   the version of the\
    \ DSR protocol specified in this document.\n   During the 7 months from August\
    \ 1998 to February 1999, we designed\n   and implemented a full-scale physical\
    \ testbed to enable the\n   evaluation of ad hoc network performance in the field,\
    \ in an actively\n   mobile ad hoc network under realistic communication workloads.\
    \  The\n   last week of February and the first week of March of 1999 included\n\
    \   demonstrations of this testbed to a number of our sponsors and\n   partners,\
    \ including Lucent Technologies, Bell Atlantic, and the\n   Defense Advanced Research\
    \ Projects Agency (DARPA).  A complete\n   description of the testbed is available\
    \ [MALTZ99b, MALTZ00, MALTZ01].\n   We have since ported this implementation of\
    \ DSR to FreeBSD 3.3, and\n   we have also added a preliminary version of Quality\
    \ of Service (QoS)\n   support for DSR.  A demonstration of this modified version\
    \ of DSR was\n   presented in July 2000.  These QoS features are not included\
    \ in this\n   document and will be added later in a separate document on top of\
    \ the\n   base protocol specified here.\n   DSR has also been implemented under\
    \ Linux by Alex Song at the\n   University of Queensland, Australia [SONG01].\
    \  This implementation\n   supports the Intel x86 PC platform and the Compaq iPAQ.\n\
    \   The Network and Telecommunications Research Group at Trinity College,\n  \
    \ Dublin, have implemented a version of DSR on Windows CE.\n   Microsoft Research\
    \ has implemented a version of DSR on Windows XP and\n   has used it in testbeds\
    \ of over 15 nodes.  Several machines use this\n   implementation as their primary\
    \ means of accessing the Internet.\n   Several other independent groups have also\
    \ used DSR as a platform for\n   their own research, or as a basis of comparison\
    \ between ad hoc\n   network routing protocols.\n   A preliminary version of the\
    \ optional DSR flow state extension was\n   implemented in FreeBSD 3.3.  A demonstration\
    \ of this modified version\n   of DSR was presented in July 2000.  The DSR flow\
    \ state extension has\n   also been extensively evaluated using simulation [HU01].\n"
- title: Acknowledgements
  contents:
  - "Acknowledgements\n   The protocol described in this document has been designed\
    \ and\n   developed within the Monarch Project, a long-term research project at\n\
    \   Rice University (previously at Carnegie Mellon University) that is\n   developing\
    \ adaptive networking protocols and protocol interfaces to\n   allow truly seamless\
    \ wireless and mobile node networking [JOHNSON96b,\n   MONARCH].\n   The authors\
    \ would like to acknowledge the substantial contributions\n   of Josh Broch in\
    \ helping to design, simulate, and implement the DSR\n   protocol.  We thank him\
    \ for his contributions to earlier versions of\n   this document.\n   We would\
    \ also like to acknowledge the assistance of Robert V. Barron\n   at Carnegie\
    \ Mellon University.  Bob ported our DSR implementation\n   from FreeBSD 2.2.7\
    \ into FreeBSD 3.3.\n   Many valuable suggestions came from participants in the\
    \ IETF process.\n   We would particularly like to acknowledge Fred Baker, who\
    \ provided\n   extensive feedback on a previous version of this document, as well\
    \ as\n   the working group chairs, for their suggestions of previous versions\n\
    \   of the document.\n"
- title: Normative References
  contents:
  - "Normative References\n   [RFC791]       Postel, J., \"Internet Protocol\", STD\
    \ 5, RFC 791,\n                  September 1981.\n   [RFC792]       Postel, J.,\
    \ \"Internet Control Message Protocol\", STD\n                  5, RFC 792, September\
    \ 1981.\n   [RFC826]       Plummer, David C., \"Ethernet Address Resolution\n\
    \                  Protocol: Or converting network protocol addresses to\n   \
    \               48.bit Ethernet address for transmission on Ethernet\n       \
    \           hardware\", STD 37, RFC 826, November 1982.\n   [RFC1122]      Braden,\
    \ R., \"Requirements for Internet Hosts -\n                  Communication Layers\"\
    , STD 3, RFC 1122, October 1989.\n   [RFC1700]      Reynolds, J. and J. Postel,\
    \ \"Assigned Numbers\", STD 2,\n                  RFC 1700, October 1994.  See\
    \ also\n                  http://www.iana.org/numbers.html.\n   [RFC2003]    \
    \  Perkins, C., \"IP Encapsulation within IP\", RFC 2003,\n                  October\
    \ 1996.  RFC 2003, October 1996.\n   [RFC2119]      Bradner, S., \"Key words for\
    \ use in RFCs to Indicate\n                  Requirement Levels\", BCP 14, RFC\
    \ 2119, March 1997.\n   [RFC2434]      Narten, T. and H. Alvestrand, \"Guidelines\
    \ for Writing\n                  an IANA Considerations Section in RFCs\", BCP\
    \ 26, RFC\n                  2434, October 1998.\n"
- title: Informative References
  contents:
  - "Informative References\n   [BANTZ94]      David F. Bantz and Frederic J. Bauchot.\
    \  Wireless LAN\n                  Design Alternatives.  IEEE Network, 8(2):43-53,\n\
    \                  March/April 1994.\n   [BHARGHAVAN94] Vaduvur Bharghavan, Alan\
    \ Demers, Scott Shenker, and\n                  Lixia Zhang.  MACAW: A Media Access\
    \ Protocol for\n                  Wireless LAN's.  In Proceedings of the ACM SIGCOMM\
    \ '94\n                  Conference, pages 212-225. ACM, August 1994.\n   [BROCH98]\
    \      Josh Broch, David A. Maltz, David B. Johnson, Yih-Chun\n              \
    \    Hu, and Jorjeta Jetcheva.  A Performance Comparison of\n                \
    \  Multi-Hop Wireless Ad Hoc Network Routing Protocols.\n                  In\
    \ Proceedings of the Fourth Annual ACM/IEEE\n                  International Conference\
    \ on Mobile Computing and\n                  Networking, pages 85-97.  ACM/IEEE,\
    \ October 1998.\n   [CLARK88]      David D. Clark.  The Design Philosophy of the\
    \ DARPA\n                  Internet Protocols.  In Proceedings of the ACM SIGCOMM\n\
    \                  '88 Conference, pages 106-114. ACM, August 1988.\n   [FREEBSD]\
    \      The FreeBSD Project.  Project web page available at\n                 \
    \ http://www.freebsd.org/.\n   [HU00]         Yih-Chun Hu and David B. Johnson.\
    \  Caching Strategies\n                  in On-Demand Routing Protocols for Wireless\
    \ Ad Hoc\n                  Networks.  In Proceedings of the Sixth Annual ACM\n\
    \                  International Conference on Mobile Computing and\n        \
    \          Networking. ACM, August 2000.\n   [HU01]         Yih-Chun Hu and David\
    \ B. Johnson.  Implicit Source\n                  Routing in On-Demand Ad Hoc\
    \ Network Routing.  In\n                  Proceedings of the Second Symposium\
    \ on Mobile Ad Hoc\n                  Networking and Computing (MobiHoc 2001),\
    \ pages 1-10,\n                  October 2001.\n   [HU02]         Yih-Chun Hu,\
    \ Adrian Perrig, and David B. Johnson.\n                  Ariadne:  A Secure On-Demand\
    \ Routing Protocol for Ad\n                  Hoc Networks.  In Proceedings of\
    \ the Eighth Annual\n                  International Conference on Mobile Computing\
    \ and\n                  Networking (MobiCom 2002), pages 12-23, September\n \
    \                 2002.\n   [IEEE80211]    IEEE Computer Society LAN MAN Standards\
    \ Committee.\n                  Wireless LAN Medium Access Control (MAC) and Physical\n\
    \                  Layer (PHY) Specifications, IEEE Std 802.11-1997.  The\n  \
    \                Institute of Electrical and Electronics Engineers, New\n    \
    \              York, New York, 1997.\n   [JOHANSSON99]  Per Johansson, Tony Larsson,\
    \ Nicklas Hedman, Bartosz\n                  Mielczarek, and Mikael Degermark.\
    \  Scenario-based\n                  Performance Analysis of Routing Protocols\
    \ for Mobile\n                  Ad-hoc Networks.  In Proceedings of the Fifth\
    \ Annual\n                  ACM/IEEE International Conference on Mobile Computing\n\
    \                  and Networking, pages 195-206. ACM/IEEE, August 1999.\n   [JOHNSON94]\
    \    David B. Johnson.  Routing in Ad Hoc Networks of\n                  Mobile\
    \ Hosts.  In Proceedings of the IEEE Workshop on\n                  Mobile Computing\
    \ Systems and Applications, pages 158-\n                  163. IEEE Computer Society,\
    \ December 1994.\n   [JOHNSON96a]   David B. Johnson and David A. Maltz.  Dynamic\
    \ Source\n                  Routing in Ad Hoc Wireless Networks.  In Mobile\n\
    \                  Computing, edited by Tomasz Imielinski and Hank Korth,\n  \
    \                chapter 5, pages 153-181. Kluwer Academic Publishers,\n     \
    \             1996.\n   [JOHNSON96b]   David B. Johnson and David A. Maltz.  Protocols\
    \ for\n                  Adaptive Wireless and Mobile Networking.  IEEE\n    \
    \              Personal Communications, 3(1):34-42, February 1996.\n   [JUBIN87]\
    \      John Jubin and Janet D. Tornow.  The DARPA Packet\n                  Radio\
    \ Network Protocols.  Proceedings of the IEEE,\n                  75(1):21-32,\
    \ January 1987.\n   [KARN90]       Phil Karn.  MACA---A New Channel Access Method\
    \ for\n                  Packet Radio.  In ARRL/CRRL Amateur Radio 9th Computer\n\
    \                  Networking Conference, pages 134-140. American Radio\n    \
    \              Relay League, September 1990.\n   [LAUER95]      Gregory S. Lauer.\
    \  Packet-Radio Routing.  In Routing\n                  in Communications Networks,\
    \ edited by Martha E.\n                  Steenstrup, chapter 11, pages 351-396.\
    \ Prentice-Hall,\n                  Englewood Cliffs, New Jersey, 1995.\n   [MALTZ99a]\
    \     David A. Maltz, Josh Broch, Jorjeta Jetcheva, and\n                  David\
    \ B. Johnson.  The Effects of On-Demand Behavior\n                  in Routing\
    \ Protocols for Multi-Hop Wireless Ad Hoc\n                  Networks.  IEEE Journal\
    \ on Selected Areas of\n                  Communications, 17(8):1439-1453, August\
    \ 1999.\n   [MALTZ99b]     David A. Maltz, Josh Broch, and David B. Johnson.\n\
    \                  Experiences Designing and Building a Multi-Hop\n          \
    \        Wireless Ad Hoc Network Testbed.  Technical Report\n                \
    \  CMU-CS-99-116, School of Computer Science, Carnegie\n                  Mellon\
    \ University, Pittsburgh, Pennsylvania, March\n                  1999.\n   [MALTZ00]\
    \      David A. Maltz, Josh Broch, and David B. Johnson.\n                  Quantitative\
    \ Lessons From a Full-Scale Multi-Hop\n                  Wireless Ad Hoc Network\
    \ Testbed.  In Proceedings of\n                  the IEEE Wireless Communications\
    \ and Networking\n                  Conference. IEEE, September 2000.\n   [MALTZ01]\
    \      David A. Maltz, Josh Broch, and David B. Johnson.\n                  Lessons\
    \ From a Full-Scale MultiHop Wireless Ad Hoc\n                  Network Testbed.\
    \  IEEE Personal Communications,\n                  8(1):8-15, February 2001.\n\
    \   [MONARCH]      Rice University Monarch Project.  Monarch Project Home\n  \
    \                Page.  Available at http://www.monarch.cs.rice.edu/.\n   [NS-2]\
    \         The Network Simulator -- ns-2.  Project web page\n                 \
    \ available at http://www.isi.edu/nsnam/ns/.\n   [PAPADIMITRATOS02]\n        \
    \          Panagiotis Papadimitratos and Zygmunt J. Haas.  Secure\n          \
    \        Routing for Mobile Ad Hoc Networks.  In SCS\n                  Communication\
    \ Networks and Distributed Systems\n                  Modeling and Simulation\
    \ Conference (CNDS 2002),\n                  January 2002.\n   [PERLMAN92]   \
    \ Radia Perlman.  Interconnections:  Bridges and\n                  Routers. \
    \ Addison-Wesley, Reading, Massachusetts,\n                  1992.\n   [RFC793]\
    \       Postel, J., \"Transmission Control Protocol\", STD 7,\n              \
    \    RFC 793, September 1981.\n   [RFC2131]      Droms, R., \"Dynamic Host Configuration\
    \ Protocol\", RFC\n                  2131, March 1997.\n   [RFC2460]      Deering,\
    \ S. and R. Hinden, \"Internet Protocol, Version\n                  6 (IPv6) Specification\"\
    , RFC 2460, December 1998.\n   [SONG01]       Alex Song.  picoNet II: A Wireless\
    \ Ad Hoc Network for\n                  Mobile Handheld Devices.  Submitted for\
    \ the degree of\n                  Bachelor of Engineering (Honours) in the division\
    \ of\n                  Electrical Engineering, Department of Information\n  \
    \                Technology and Electrical Engineering, University of\n      \
    \            Queensland, Australia, October 2001.  Available at\n            \
    \      http://piconet.sourceforge.net/thesis/index.html.\n   [TURNER90]     Paul\
    \ Turner.  NetWare Communications Processes.\n                  NetWare Application\
    \ Notes, Novell Research, pages 25-\n                  91, September 1990.\n \
    \  [WRIGHT95]     Gary R. Wright and W. Richard Stevens.  TCP/IP\n           \
    \       Illustrated, Volume 2:  The Implementation.  Addison-\n              \
    \    Wesley, Reading, Massachusetts, 1995.\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   David B. Johnson\n   Rice University\n   Computer Science\
    \ Department, MS 132\n   6100 Main Street\n   Houston, TX 77005-1892\n   USA\n\
    \   Phone: +1 713 348-3063\n   Fax:   +1 713 348-5930\n   EMail: dbj@cs.rice.edu\n\
    \   David A. Maltz\n   Microsoft Research\n   One Microsoft Way\n   Redmond, WA\
    \ 98052\n   USA\n   Phone: +1 425 706-7785\n   Fax:   +1 425 936-7329\n   EMail:\
    \ dmaltz@microsoft.com\n   Yih-Chun Hu\n   University of Illinois at Urbana-Champaign\n\
    \   Coordinated Science Lab\n   1308 West Main St, MC 228\n   Urbana, IL 61801\n\
    \   USA\n   Phone: +1 217 333-4220\n   EMail: yihchun@uiuc.edu\n"
- title: Full Copyright Statement
  contents:
  - "Full Copyright Statement\n   Copyright (C) The IETF Trust (2007).\n   This document\
    \ is subject to the rights, licenses and restrictions\n   contained in BCP 78,\
    \ and except as set forth therein, the authors\n   retain all their rights.\n\
    \   This document and the information contained herein are provided on an\n  \
    \ \"AS IS\" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS\n  \
    \ OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY, THE IETF TRUST AND\n   THE\
    \ INTERNET ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS\n   OR IMPLIED,\
    \ INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF\n   THE INFORMATION\
    \ HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED\n   WARRANTIES OF MERCHANTABILITY\
    \ OR FITNESS FOR A PARTICULAR PURPOSE.\n"
- title: Intellectual Property
  contents:
  - "Intellectual Property\n   The IETF takes no position regarding the validity or\
    \ scope of any\n   Intellectual Property Rights or other rights that might be\
    \ claimed to\n   pertain to the implementation or use of the technology described\
    \ in\n   this document or the extent to which any license under such rights\n\
    \   might or might not be available; nor does it represent that it has\n   made\
    \ any independent effort to identify any such rights.  Information\n   on the\
    \ procedures with respect to rights in RFC documents can be\n   found in BCP 78\
    \ and BCP 79.\n   Copies of IPR disclosures made to the IETF Secretariat and any\n\
    \   assurances of licenses to be made available, or the result of an\n   attempt\
    \ made to obtain a general license or permission for the use of\n   such proprietary\
    \ rights by implementers or users of this\n   specification can be obtained from\
    \ the IETF on-line IPR repository at\n   http://www.ietf.org/ipr.\n   The IETF\
    \ invites any interested party to bring to its attention any\n   copyrights, patents\
    \ or patent applications, or other proprietary\n   rights that may cover technology\
    \ that may be required to implement\n   this standard.  Please address the information\
    \ to the IETF at\n   ietf-ipr@ietf.org.\n"
- title: Acknowledgement
  contents:
  - "Acknowledgement\n   Funding for the RFC Editor function is currently provided\
    \ by the\n   Internet Society.\n"
