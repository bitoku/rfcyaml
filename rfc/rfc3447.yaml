- title: __initial_text__
  contents:
  - "     Public-Key Cryptography Standards (PKCS) #1: RSA Cryptography\n        \
    \              Specifications Version 2.1\n"
- title: Status of this Memo
  contents:
  - "Status of this Memo\n   This memo provides information for the Internet community.\
    \  It does\n   not specify an Internet standard of any kind.  Distribution of\
    \ this\n   memo is unlimited.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (C) The Internet Society (2003).  All Rights Reserved.\n"
- title: Abstract
  contents:
  - "Abstract\n   This memo represents a republication of PKCS #1 v2.1 from RSA\n\
    \   Laboratories' Public-Key Cryptography Standards (PKCS) series, and\n   change\
    \ control is retained within the PKCS process.  The body of this\n   document\
    \ is taken directly from the PKCS #1 v2.1 document, with\n   certain corrections\
    \ made during the publication process.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1.       Introduction...............................................2\n\
    \   2.       Notation...................................................3\n  \
    \ 3.       Key types..................................................6\n    \
    \  3.1      RSA public key..........................................6\n      3.2\
    \      RSA private key.........................................7\n   4.      \
    \ Data conversion primitives.................................8\n      4.1    \
    \  I2OSP...................................................9\n      4.2      OS2IP...................................................9\n\
    \   5.       Cryptographic primitives..................................10\n  \
    \    5.1      Encryption and decryption primitives...................10\n    \
    \  5.2      Signature and verification primitives..................12\n   6. \
    \      Overview of schemes.......................................14\n   7.   \
    \    Encryption schemes........................................15\n      7.1 \
    \     RSAES-OAEP.............................................16\n      7.2   \
    \   RSAES-PKCS1-v1_5.......................................23\n   8.       Signature\
    \ schemes with appendix...........................27\n      8.1      RSASSA-PSS.............................................29\n\
    \      8.2      RSASSA-PKCS1-v1_5......................................32\n  \
    \ 9.       Encoding methods for signatures with appendix.............35\n    \
    \  9.1      EMSA-PSS...............................................36\n      9.2\
    \      EMSA-PKCS1-v1_5........................................41\n   Appendix\
    \ A. ASN.1 syntax...........................................44\n      A.1    \
    \  RSA key representation.................................44\n      A.2      Scheme\
    \ identification..................................46\n   Appendix B. Supporting\
    \ techniques..................................52\n      B.1      Hash functions.........................................52\n\
    \      B.2      Mask generation functions..............................54\n  \
    \ Appendix C. ASN.1 module...........................................56\n   Appendix\
    \ D. Intellectual Property Considerations...................63\n   Appendix E.\
    \ Revision history.......................................64\n   Appendix F. References.............................................65\n\
    \   Appendix G. About PKCS.............................................70\n  \
    \ Appendix H. Corrections Made During RFC Publication Process........70\n   Security\
    \ Considerations............................................70\n   Acknowledgements...................................................71\n\
    \   Authors' Addresses.................................................71\n  \
    \ Full Copyright Statement...........................................72\n"
- title: 1. Introduction
  contents:
  - "1. Introduction\n   This document provides recommendations for the implementation\
    \ of\n   public-key cryptography based on the RSA algorithm [42], covering the\n\
    \   following aspects:\n    * Cryptographic primitives\n    * Encryption schemes\n\
    \    * Signature schemes with appendix\n    * ASN.1 syntax for representing keys\
    \ and for identifying the schemes\n   The recommendations are intended for general\
    \ application within\n   computer and communications systems, and as such include\
    \ a fair\n   amount of flexibility.  It is expected that application standards\n\
    \   based on these specifications may include additional constraints.\n   The\
    \ recommendations are intended to be compatible with the standard\n   IEEE-1363-2000\
    \ [26] and draft standards currently being developed by\n   the ANSI X9F1 [1]\
    \ and IEEE P1363 [27] working groups.\n   This document supersedes PKCS #1 version\
    \ 2.0 [35][44] but includes\n   compatible techniques.\n   The organization of\
    \ this document is as follows:\n    * Section 1 is an introduction.\n    * Section\
    \ 2 defines some notation used in this document.\n    * Section 3 defines the\
    \ RSA public and private key types.\n    * Sections 4 and 5 define several primitives,\
    \ or basic mathematical\n      operations.  Data conversion primitives are in\
    \ Section 4, and\n      cryptographic primitives (encryption-decryption, signature-\n\
    \      verification) are in Section 5.\n    * Sections 6, 7, and 8 deal with the\
    \ encryption and signature\n      schemes in this document.  Section 6 gives an\
    \ overview.  Along\n      with the methods found in PKCS #1 v1.5, Section 7 defines\
    \ an\n      OAEP-based [3] encryption scheme and Section 8 defines a PSS-based\n\
    \      [4][5] signature scheme with appendix.\n    * Section 9 defines the encoding\
    \ methods for the signature schemes\n      in Section 8.\n    * Appendix A defines\
    \ the ASN.1 syntax for the keys defined in\n      Section 3 and the schemes in\
    \ Sections 7 and 8.\n    * Appendix B defines the hash functions and the mask\
    \ generation\n      function used in this document, including ASN.1 syntax for\
    \ the\n      techniques.\n    * Appendix C gives an ASN.1 module.\n    * Appendices\
    \ D, E, F and G cover intellectual property issues,\n      outline the revision\
    \ history of PKCS #1, give references to other\n      publications and standards,\
    \ and provide general information about\n      the Public-Key Cryptography Standards.\n"
- title: 2. Notation
  contents:
  - "2. Notation\n   c              ciphertext representative, an integer between\
    \ 0 and\n                  n-1\n   C              ciphertext, an octet string\n\
    \   d              RSA private exponent\n   d_i            additional factor r_i's\
    \ CRT exponent, a positive\n                  integer such that\n            \
    \        e * d_i == 1 (mod (r_i-1)), i = 3, ..., u\n   dP             p's CRT\
    \ exponent, a positive integer such that\n                    e * dP == 1 (mod\
    \ (p-1))\n   dQ             q's CRT exponent, a positive integer such that\n \
    \                   e * dQ == 1 (mod (q-1))\n   e              RSA public exponent\n\
    \   EM             encoded message, an octet string\n   emBits         (intended)\
    \ length in bits of an encoded message EM\n   emLen          (intended) length\
    \ in octets of an encoded message EM\n   GCD(. , .)     greatest common divisor\
    \ of two nonnegative integers\n   Hash           hash function\n   hLen      \
    \     output length in octets of hash function Hash\n   k              length\
    \ in octets of the RSA modulus n\n   K              RSA private key\n   L    \
    \          optional RSAES-OAEP label, an octet string\n   LCM(., ..., .) least\
    \ common multiple of a list of nonnegative\n                  integers\n   m \
    \             message representative, an integer between 0 and n-1\n   M     \
    \         message, an octet string\n   mask           MGF output, an octet string\n\
    \   maskLen        (intended) length of the octet string mask\n   MGF        \
    \    mask generation function\n   mgfSeed        seed from which mask is generated,\
    \ an octet string\n   mLen           length in octets of a message M\n   n   \
    \           RSA modulus, n = r_1 * r_2 * ... * r_u , u >= 2\n   (n, e)       \
    \  RSA public key\n   p, q           first two prime factors of the RSA modulus\
    \ n\n   qInv           CRT coefficient, a positive integer less than p such\n\
    \                  that\n                    q * qInv == 1 (mod p)\n   r_i   \
    \         prime factors of the RSA modulus n, including r_1 = p,\n           \
    \       r_2 = q, and additional factors if any\n   s              signature representative,\
    \ an integer between 0 and n-1\n   S              signature, an octet string\n\
    \   sLen           length in octets of the EMSA-PSS salt\n   t_i            additional\
    \ prime factor r_i's CRT coefficient, a\n                  positive integer less\
    \ than r_i such that\n                    r_1 * r_2 * ... * r_(i-1) * t_i == 1\
    \ (mod r_i) ,\n                  i = 3, ... , u\n   u              number of prime\
    \ factors of the RSA modulus, u >= 2\n   x              a nonnegative integer\n\
    \   X              an octet string corresponding to x\n   xLen           (intended)\
    \ length of the octet string X\n   0x             indicator of hexadecimal representation\
    \ of an octet or\n                  an octet string; \"0x48\" denotes the octet\
    \ with\n                  hexadecimal value 48; \"(0x)48 09 0e\" denotes the\n\
    \                  string of three consecutive octets with hexadecimal\n     \
    \             value 48, 09, and 0e, respectively\n   \\lambda(n)     LCM(r_1-1,\
    \ r_2-1, ... , r_u-1)\n   \\xor           bit-wise exclusive-or of two octet strings\n\
    \   \\ceil(.)       ceiling function; \\ceil(x) is the smallest integer\n    \
    \              larger than or equal to the real number x\n   ||             concatenation\
    \ operator\n   ==             congruence symbol; a == b (mod n) means that the\n\
    \                  integer n divides the integer a - b\n   Note.  The CRT can\
    \ be applied in a non-recursive as well as a\n   recursive way.  In this document\
    \ a recursive approach following\n   Garner's algorithm [22] is used.  See also\
    \ Note 1 in Section 3.2.\n"
- title: 3. Key types
  contents:
  - "3. Key types\n   Two key types are employed in the primitives and schemes defined\
    \ in\n   this document: RSA public key and RSA private key.  Together, an RSA\n\
    \   public key and an RSA private key form an RSA key pair.\n   This specification\
    \ supports so-called \"multi-prime\" RSA where the\n   modulus may have more than\
    \ two prime factors.  The benefit of multi-\n   prime RSA is lower computational\
    \ cost for the decryption and\n   signature primitives, provided that the CRT\
    \ (Chinese Remainder\n   Theorem) is used.  Better performance can be achieved\
    \ on single\n   processor platforms, but to a greater extent on multiprocessor\n\
    \   platforms, where the modular exponentiations involved can be done in\n   parallel.\n\
    \   For a discussion on how multi-prime affects the security of the RSA\n   cryptosystem,\
    \ the reader is referred to [49].\n"
- title: 3.1 RSA public key
  contents:
  - "3.1 RSA public key\n   For the purposes of this document, an RSA public key consists\
    \ of two\n   components:\n      n        the RSA modulus, a positive integer\n\
    \      e        the RSA public exponent, a positive integer\n   In a valid RSA\
    \ public key, the RSA modulus n is a product of u\n   distinct odd primes r_i,\
    \ i = 1, 2, ..., u, where u >= 2, and the RSA\n   public exponent e is an integer\
    \ between 3 and n - 1 satisfying GCD(e,\n   \\lambda(n)) = 1, where \\lambda(n)\
    \ = LCM(r_1 - 1, ..., r_u - 1).  By\n   convention, the first two primes r_1 and\
    \ r_2 may also be denoted p\n   and q respectively.\n   A recommended syntax for\
    \ interchanging RSA public keys between\n   implementations is given in Appendix\
    \ A.1.1; an implementation's\n   internal representation may differ.\n"
- title: 3.2 RSA private key
  contents:
  - "3.2 RSA private key\n   For the purposes of this document, an RSA private key\
    \ may have either\n   of two representations.\n   1. The first representation\
    \ consists of the pair (n, d), where the\n      components have the following\
    \ meanings:\n         n        the RSA modulus, a positive integer\n         d\
    \        the RSA private exponent, a positive integer\n   2. The second representation\
    \ consists of a quintuple (p, q, dP, dQ,\n      qInv) and a (possibly empty) sequence\
    \ of triplets (r_i, d_i, t_i),\n      i = 3, ..., u, one for each prime not in\
    \ the quintuple, where the\n      components have the following meanings:\n  \
    \       p        the first factor, a positive integer\n         q        the second\
    \ factor, a positive integer\n         dP       the first factor's CRT exponent,\
    \ a positive integer\n         dQ       the second factor's CRT exponent, a positive\
    \ integer\n         qInv     the (first) CRT coefficient, a positive integer\n\
    \         r_i      the i-th factor, a positive integer\n         d_i      the\
    \ i-th factor's CRT exponent, a positive integer\n         t_i      the i-th factor's\
    \ CRT coefficient, a positive integer\n   In a valid RSA private key with the\
    \ first representation, the RSA\n   modulus n is the same as in the corresponding\
    \ RSA public key and is\n   the product of u distinct odd primes r_i, i = 1, 2,\
    \ ..., u, where u\n   >= 2.  The RSA private exponent d is a positive integer\
    \ less than n\n   satisfying\n      e * d == 1 (mod \\lambda(n)),\n   where e\
    \ is the corresponding RSA public exponent and \\lambda(n) is\n   defined as in\
    \ Section 3.1.\n   In a valid RSA private key with the second representation,\
    \ the two\n   factors p and q are the first two prime factors of the RSA modulus\
    \ n\n   (i.e., r_1 and r_2), the CRT exponents dP and dQ are positive\n   integers\
    \ less than p and q respectively satisfying\n      e * dP == 1 (mod (p-1))\n \
    \     e * dQ == 1 (mod (q-1)) ,\n   and the CRT coefficient qInv is a positive\
    \ integer less than p\n   satisfying\n      q * qInv == 1 (mod p).\n   If u >\
    \ 2, the representation will include one or more triplets (r_i,\n   d_i, t_i),\
    \ i = 3, ..., u.  The factors r_i are the additional prime\n   factors of the\
    \ RSA modulus n.  Each CRT exponent d_i (i = 3, ..., u)\n   satisfies\n      e\
    \ * d_i == 1 (mod (r_i - 1)).\n   Each CRT coefficient t_i (i = 3, ..., u) is\
    \ a positive integer less\n   than r_i satisfying\n      R_i * t_i == 1 (mod r_i)\
    \ ,\n   where R_i = r_1 * r_2 * ... * r_(i-1).\n   A recommended syntax for interchanging\
    \ RSA private keys between\n   implementations, which includes components from\
    \ both representations,\n   is given in Appendix A.1.2; an implementation's internal\n\
    \   representation may differ.\n   Notes.\n   1. The definition of the CRT coefficients\
    \ here and the formulas that\n      use them in the primitives in Section 5 generally\
    \ follow Garner's\n      algorithm [22] (see also Algorithm 14.71 in [37]). However,\
    \ for\n      compatibility with the representations of RSA private keys in PKCS\n\
    \      #1 v2.0 and previous versions, the roles of p and q are reversed\n    \
    \  compared to the rest of the primes.  Thus, the first CRT\n      coefficient,\
    \ qInv, is defined as the inverse of q mod p, rather\n      than as the inverse\
    \ of R_1 mod r_2, i.e., of p mod q.\n   2. Quisquater and Couvreur [40] observed\
    \ the benefit of applying the\n      Chinese Remainder Theorem to RSA operations.\n"
- title: 4. Data conversion primitives
  contents:
  - "4. Data conversion primitives\n   Two data conversion primitives are employed\
    \ in the schemes defined in\n   this document:\n      * I2OSP - Integer-to-Octet-String\
    \ primitive\n      * OS2IP - Octet-String-to-Integer primitive\n   For the purposes\
    \ of this document, and consistent with ASN.1 syntax,\n   an octet string is an\
    \ ordered sequence of octets (eight-bit bytes).\n   The sequence is indexed from\
    \ first (conventionally, leftmost) to last\n   (rightmost).  For purposes of conversion\
    \ to and from integers, the\n   first octet is considered the most significant\
    \ in the following\n   conversion primitives.\n"
- title: 4.1 I2OSP
  contents:
  - "4.1 I2OSP\n   I2OSP converts a nonnegative integer to an octet string of a\n\
    \   specified length.\n   I2OSP (x, xLen)\n   Input:\n   x        nonnegative\
    \ integer to be converted\n   xLen     intended length of the resulting octet\
    \ string\n   Output:\n   X        corresponding octet string of length xLen\n\
    \   Error: \"integer too large\"\n   Steps:\n   1. If x >= 256^xLen, output \"\
    integer too large\" and stop.\n   2. Write the integer x in its unique xLen-digit\
    \ representation in\n      base 256:\n         x = x_(xLen-1) 256^(xLen-1) + x_(xLen-2)\
    \ 256^(xLen-2) + ...\n         + x_1 256 + x_0,\n      where 0 <= x_i < 256 (note\
    \ that one or more leading digits will be\n      zero if x is less than 256^(xLen-1)).\n\
    \   3. Let the octet X_i have the integer value x_(xLen-i) for 1 <= i <=\n   \
    \   xLen.  Output the octet string\n         X = X_1 X_2 ... X_xLen.\n"
- title: 4.2 OS2IP
  contents:
  - "4.2 OS2IP\n   OS2IP converts an octet string to a nonnegative integer.\n   OS2IP\
    \ (X)\n   Input:\n   X        octet string to be converted\n   Output:\n   x \
    \       corresponding nonnegative integer\n   Steps:\n   1. Let X_1 X_2 ... X_xLen\
    \ be the octets of X from first to last,\n      and let x_(xLen-i) be the integer\
    \ value of the octet X_i for\n      1 <= i <= xLen.\n   2. Let x = x_(xLen-1)\
    \ 256^(xLen-1) + x_(xLen-2) 256^(xLen-2) + ...\n      + x_1 256 + x_0.\n   3.\
    \ Output x.\n"
- title: 5. Cryptographic primitives
  contents:
  - "5. Cryptographic primitives\n   Cryptographic primitives are basic mathematical\
    \ operations on which\n   cryptographic schemes can be built.  They are intended\
    \ for\n   implementation in hardware or as software modules, and are not\n   intended\
    \ to provide security apart from a scheme.\n   Four types of primitive are specified\
    \ in this document, organized in\n   pairs: encryption and decryption; and signature\
    \ and verification.\n   The specifications of the primitives assume that certain\
    \ conditions\n   are met by the inputs, in particular that RSA public and private\
    \ keys\n   are valid.\n"
- title: 5.1 Encryption and decryption primitives
  contents:
  - "5.1 Encryption and decryption primitives\n   An encryption primitive produces\
    \ a ciphertext representative from a\n   message representative under the control\
    \ of a public key, and a\n   decryption primitive recovers the message representative\
    \ from the\n   ciphertext representative under the control of the corresponding\n\
    \   private key.\n   One pair of encryption and decryption primitives is employed\
    \ in the\n   encryption schemes defined in this document and is specified here:\n\
    \   RSAEP/RSADP.  RSAEP and RSADP involve the same mathematical\n   operation,\
    \ with different keys as input.\n   The primitives defined here are the same as\
    \ IFEP-RSA/IFDP-RSA in IEEE\n   Std 1363-2000 [26] (except that support for multi-prime\
    \ RSA has been\n   added) and are compatible with PKCS #1 v1.5.\n   The main mathematical\
    \ operation in each primitive is exponentiation.\n"
- title: 5.1.1 RSAEP
  contents:
  - "5.1.1 RSAEP\n   RSAEP ((n, e), m)\n   Input:\n   (n, e)   RSA public key\n  \
    \ m        message representative, an integer between 0 and n - 1\n   Output:\n\
    \   c        ciphertext representative, an integer between 0 and n - 1\n   Error:\
    \ \"message representative out of range\"\n   Assumption: RSA public key (n, e)\
    \ is valid\n   Steps:\n   1. If the message representative m is not between 0\
    \ and n - 1, output\n      \"message representative out of range\" and stop.\n\
    \   2. Let c = m^e mod n.\n   3. Output c.\n"
- title: 5.1.2   RSADP
  contents:
  - "5.1.2   RSADP\n   RSADP (K, c)\n   Input:\n   K        RSA private key, where\
    \ K has one of the following forms:\n            - a pair (n, d)\n           \
    \ - a quintuple (p, q, dP, dQ, qInv) and a possibly empty\n              sequence\
    \ of triplets (r_i, d_i, t_i), i = 3, ..., u\n   c        ciphertext representative,\
    \ an integer between 0 and n - 1\n   Output:\n   m        message representative,\
    \ an integer between 0 and n - 1\n   Error: \"ciphertext representative out of\
    \ range\"\n   Assumption: RSA private key K is valid\n   Steps:\n   1. If the\
    \ ciphertext representative c is not between 0 and n - 1,\n      output \"ciphertext\
    \ representative out of range\" and stop.\n   2. The message representative m\
    \ is computed as follows.\n      a. If the first form (n, d) of K is used, let\
    \ m = c^d mod n.\n      b. If the second form (p, q, dP, dQ, qInv) and (r_i, d_i,\
    \ t_i)\n         of K is used, proceed as follows:\n         i.    Let m_1 = c^dP\
    \ mod p and m_2 = c^dQ mod q.\n         ii.   If u > 2, let m_i = c^(d_i) mod\
    \ r_i, i = 3, ..., u.\n         iii.  Let h = (m_1 - m_2) * qInv mod p.\n    \
    \     iv.   Let m = m_2 + q * h.\n         v.    If u > 2, let R = r_1 and for\
    \ i = 3 to u do\n                  1. Let R = R * r_(i-1).\n                 \
    \ 2. Let h = (m_i - m) * t_i mod r_i.\n                  3. Let m = m + R * h.\n\
    \   3.   Output m.\n   Note.  Step 2.b can be rewritten as a single loop, provided\
    \ that one\n   reverses the order of p and q.  For consistency with PKCS #1 v2.0,\n\
    \   however, the first two primes p and q are treated separately from\n   the\
    \ additional primes.\n"
- title: 5.2 Signature and verification primitives
  contents:
  - "5.2 Signature and verification primitives\n   A signature primitive produces\
    \ a signature representative from a\n   message representative under the control\
    \ of a private key, and a\n   verification primitive recovers the message representative\
    \ from the\n   signature representative under the control of the corresponding\n\
    \   public key.  One pair of signature and verification primitives is\n   employed\
    \ in the signature schemes defined in this document and is\n   specified here:\
    \ RSASP1/RSAVP1.\n   The primitives defined here are the same as IFSP-RSA1/IFVP-RSA1\
    \ in\n   IEEE 1363-2000 [26] (except that support for multi-prime RSA has\n  \
    \ been added) and are compatible with PKCS #1 v1.5.\n   The main mathematical\
    \ operation in each primitive is\n   exponentiation, as in the encryption and\
    \ decryption primitives of\n   Section 5.1.  RSASP1 and RSAVP1 are the same as\
    \ RSADP and RSAEP\n   except for the names of their input and output arguments;\
    \ they are\n   distinguished as they are intended for different purposes.\n"
- title: 5.2.1 RSASP1
  contents:
  - "5.2.1 RSASP1\n   RSASP1 (K, m)\n   Input:\n   K        RSA private key, where\
    \ K has one of the following forms:\n            - a pair (n, d)\n           \
    \ - a quintuple (p, q, dP, dQ, qInv) and a (possibly empty)\n              sequence\
    \ of triplets (r_i, d_i, t_i), i = 3, ..., u\n   m        message representative,\
    \ an integer between 0 and n - 1\n   Output:\n   s        signature representative,\
    \ an integer between 0 and n - 1\n   Error: \"message representative out of range\"\
    \n   Assumption: RSA private key K is valid\n   Steps:\n   1. If the message representative\
    \ m is not between 0 and n - 1,\n      output \"message representative out of\
    \ range\" and stop.\n   2. The signature representative s is computed as follows.\n\
    \      a. If the first form (n, d) of K is used, let s = m^d mod n.\n        \
    \ b. If the second form (p, q, dP, dQ, qInv) and (r_i, d_i, t_i)\n         of\
    \ K is used, proceed as follows:\n         i.    Let s_1 = m^dP mod p and s_2\
    \ = m^dQ mod q.\n         ii.   If u > 2, let s_i = m^(d_i) mod r_i, i = 3, ...,\
    \ u.\n         iii.  Let h = (s_1 - s_2) * qInv mod p.\n         iv.   Let s =\
    \ s_2 + q * h.\n         v.    If u > 2, let R = r_1 and for i = 3 to u do\n \
    \                 1. Let R = R * r_(i-1).\n                  2. Let h = (s_i -\
    \ s) * t_i mod r_i.\n                  3. Let s = s + R * h.\n   3. Output s.\n\
    \   Note.  Step 2.b can be rewritten as a single loop, provided that one\n   reverses\
    \ the order of p and q.  For consistency with PKCS #1 v2.0,\n   however, the first\
    \ two primes p and q are treated separately from the\n   additional primes.\n"
- title: 5.2.2 RSAVP1
  contents:
  - "5.2.2 RSAVP1\n   RSAVP1 ((n, e), s)\n   Input:\n   (n, e)   RSA public key\n\
    \   s        signature representative, an integer between 0 and n - 1\n   Output:\n\
    \   m        message representative, an integer between 0 and n - 1\n   Error:\
    \ \"signature representative out of range\"\n   Assumption: RSA public key (n,\
    \ e) is valid\n   Steps:\n   1. If the signature representative s is not between\
    \ 0 and n - 1,\n      output \"signature representative out of range\" and stop.\n\
    \   2. Let m = s^e mod n.\n   3. Output m.\n"
- title: 6. Overview of schemes
  contents:
  - "6. Overview of schemes\n   A scheme combines cryptographic primitives and other\
    \ techniques to\n   achieve a particular security goal.  Two types of scheme are\n\
    \   specified in this document: encryption schemes and signature schemes\n   with\
    \ appendix.\n   The schemes specified in this document are limited in scope in\
    \ that\n   their operations consist only of steps to process data with an RSA\n\
    \   public or private key, and do not include steps for obtaining or\n   validating\
    \ the key.  Thus, in addition to the scheme operations, an\n   application will\
    \ typically include key management operations by which\n   parties may select\
    \ RSA public and private keys for a scheme\n   operation.  The specific additional\
    \ operations and other details are\n   outside the scope of this document.\n \
    \  As was the case for the cryptographic primitives (Section 5), the\n   specifications\
    \ of scheme operations assume that certain conditions\n   are met by the inputs,\
    \ in particular that RSA public and private keys\n   are valid.  The behavior\
    \ of an implementation is thus unspecified\n   when a key is invalid.  The impact\
    \ of such unspecified behavior\n   depends on the application.  Possible means\
    \ of addressing key\n   validation include explicit key validation by the application;\
    \ key\n   validation within the public-key infrastructure; and assignment of\n\
    \   liability for operations performed with an invalid key to the party\n   who\
    \ generated the key.\n   A generally good cryptographic practice is to employ\
    \ a given RSA key\n   pair in only one scheme.  This avoids the risk that vulnerability\
    \ in\n   one scheme may compromise the security of the other, and may be\n   essential\
    \ to maintain provable security.  While RSAES-PKCS1-v1_5\n   (Section 7.2) and\
    \ RSASSA-PKCS1-v1_5 (Section 8.2) have traditionally\n   been employed together\
    \ without any known bad interactions (indeed,\n   this is the model introduced\
    \ by PKCS #1 v1.5), such a combined use of\n   an RSA key pair is not recommended\
    \ for new applications.\n   To illustrate the risks related to the employment\
    \ of an RSA key pair\n   in more than one scheme, suppose an RSA key pair is employed\
    \ in both\n   RSAES-OAEP (Section 7.1) and RSAES-PKCS1-v1_5.  Although RSAES-OAEP\n\
    \   by itself would resist attack, an opponent might be able to exploit a\n  \
    \ weakness in the implementation of RSAES-PKCS1-v1_5 to recover\n   messages encrypted\
    \ with either scheme.  As another example, suppose\n   an RSA key pair is employed\
    \ in both RSASSA-PSS (Section 8.1) and\n   RSASSA-PKCS1-v1_5.  Then the security\
    \ proof for RSASSA-PSS would no\n   longer be sufficient since the proof does\
    \ not account for the\n   possibility that signatures might be generated with\
    \ a second scheme.\n   Similar considerations may apply if an RSA key pair is\
    \ employed in\n   one of the schemes defined here and in a variant defined elsewhere.\n"
- title: 7. Encryption schemes
  contents:
  - "7. Encryption schemes\n   For the purposes of this document, an encryption scheme\
    \ consists of\n   an encryption operation and a decryption operation, where the\n\
    \   encryption operation produces a ciphertext from a message with a\n   recipient's\
    \ RSA public key, and the decryption operation recovers the\n   message from the\
    \ ciphertext with the recipient's corresponding RSA\n   private key.\n   An encryption\
    \ scheme can be employed in a variety of applications.  A\n   typical application\
    \ is a key establishment protocol, where the\n   message contains key material\
    \ to be delivered confidentially from one\n   party to another.  For instance,\
    \ PKCS #7 [45] employs such a protocol\n   to deliver a content-encryption key\
    \ from a sender to a recipient; the\n   encryption schemes defined here would\
    \ be suitable key-encryption\n   algorithms in that context.\n   Two encryption\
    \ schemes are specified in this document: RSAES-OAEP and\n   RSAES-PKCS1-v1_5.\
    \  RSAES-OAEP is recommended for new applications;\n   RSAES-PKCS1-v1_5 is included\
    \ only for compatibility with existing\n   applications, and is not recommended\
    \ for new applications.\n   The encryption schemes given here follow a general\
    \ model similar to\n   that employed in IEEE Std 1363-2000 [26], combining encryption\
    \ and\n   decryption primitives with an encoding method for encryption.  The\n\
    \   encryption operations apply a message encoding operation to a message\n  \
    \ to produce an encoded message, which is then converted to an integer\n   message\
    \ representative.  An encryption primitive is applied to the\n   message representative\
    \ to produce the ciphertext.  Reversing this,\n   the decryption operations apply\
    \ a decryption primitive to the\n   ciphertext to recover a message representative,\
    \ which is then\n   converted to an octet string encoded message.  A message decoding\n\
    \   operation is applied to the encoded message to recover the message\n   and\
    \ verify the correctness of the decryption.\n   To avoid implementation weaknesses\
    \ related to the way errors are\n   handled within the decoding operation (see\
    \ [6] and [36]), the\n   encoding and decoding operations for RSAES-OAEP and RSAES-PKCS1-v1_5\n\
    \   are embedded in the specifications of the respective encryption\n   schemes\
    \ rather than defined in separate specifications.  Both\n   encryption schemes\
    \ are compatible with the corresponding schemes in\n   PKCS #1 v2.0.\n"
- title: 7.1 RSAES-OAEP
  contents:
  - "7.1 RSAES-OAEP\n   RSAES-OAEP combines the RSAEP and RSADP primitives (Sections\
    \ 5.1.1\n   and 5.1.2) with the EME-OAEP encoding method (step 1.b in Section\n\
    \   7.1.1 and step 3 in Section 7.1.2).  EME-OAEP is based on Bellare and\n  \
    \ Rogaway's Optimal Asymmetric Encryption scheme [3].  (OAEP stands for\n   \"\
    Optimal Asymmetric Encryption Padding.\").  It is compatible with the\n   IFES\
    \ scheme defined in IEEE Std 1363-2000 [26], where the encryption\n   and decryption\
    \ primitives are IFEP-RSA and IFDP-RSA and the message\n   encoding method is\
    \ EME-OAEP.  RSAES-OAEP can operate on messages of\n   length up to k - 2hLen\
    \ - 2 octets, where hLen is the length of the\n   output from the underlying hash\
    \ function and k is the length in\n   octets of the recipient's RSA modulus.\n\
    \   Assuming that computing e-th roots modulo n is infeasible and the\n   mask\
    \ generation function in RSAES-OAEP has appropriate properties,\n   RSAES-OAEP\
    \ is semantically secure against adaptive chosen-ciphertext\n   attacks.  This\
    \ assurance is provable in the sense that the difficulty\n   of breaking RSAES-OAEP\
    \ can be directly related to the difficulty of\n   inverting the RSA function,\
    \ provided that the mask generation\n   function is viewed as a black box or random\
    \ oracle; see [21] and the\n   note below for further discussion.\n   Both the\
    \ encryption and the decryption operations of RSAES-OAEP take\n   the value of\
    \ a label L as input.  In this version of PKCS #1, L is\n   the empty string;\
    \ other uses of the label are outside the scope of\n   this document.  See Appendix\
    \ A.2.1 for the relevant ASN.1 syntax.\n   RSAES-OAEP is parameterized by the\
    \ choice of hash function and mask\n   generation function.  This choice should\
    \ be fixed for a given RSA\n   key.  Suggested hash and mask generation functions\
    \ are given in\n   Appendix B.\n   Note.  Recent results have helpfully clarified\
    \ the security\n   properties of the OAEP encoding method [3] (roughly the procedure\n\
    \   described in step 1.b in Section 7.1.1).  The background is as\n   follows.\
    \  In 1994, Bellare and Rogaway [3] introduced a security\n   concept that they\
    \ denoted plaintext awareness (PA94).  They proved\n   that if a deterministic\
    \ public-key encryption primitive (e.g., RSAEP)\n   is hard to invert without\
    \ the private key, then the corresponding\n   OAEP-based encryption scheme is\
    \ plaintext-aware (in the random oracle\n   model), meaning roughly that an adversary\
    \ cannot produce a valid\n   ciphertext without actually \"knowing\" the underlying\
    \ plaintext.\n   Plaintext awareness of an encryption scheme is closely related\
    \ to the\n   resistance of the scheme against chosen-ciphertext attacks.  In such\n\
    \   attacks, an adversary is given the opportunity to send queries to an\n   oracle\
    \ simulating the decryption primitive.  Using the results of\n   these queries,\
    \ the adversary attempts to decrypt a challenge\n   ciphertext.\n   However, there\
    \ are two flavors of chosen-ciphertext attacks, and PA94\n   implies security\
    \ against only one of them.  The difference relies on\n   what the adversary is\
    \ allowed to do after she is given the challenge\n   ciphertext.  The indifferent\
    \ attack scenario (denoted CCA1) does not\n   admit any queries to the decryption\
    \ oracle after the adversary is\n   given the challenge ciphertext, whereas the\
    \ adaptive scenario\n   (denoted CCA2) does (except that the decryption oracle\
    \ refuses to\n   decrypt the challenge ciphertext once it is published).  In 1998,\n\
    \   Bellare and Rogaway, together with Desai and Pointcheval [2], came up\n  \
    \ with a new, stronger notion of plaintext awareness (PA98) that does\n   imply\
    \ security against CCA2.\n   To summarize, there have been two potential sources\
    \ for\n   misconception: that PA94 and PA98 are equivalent concepts; or that\n\
    \   CCA1 and CCA2 are equivalent concepts.  Either assumption leads to\n   the\
    \ conclusion that the Bellare-Rogaway paper implies security of\n   OAEP against\
    \ CCA2, which it does not.\n   (Footnote: It might be fair to mention that PKCS\
    \ #1 v2.0 cites [3]\n   and claims that \"a chosen ciphertext attack is ineffective\
    \ against a\n   plaintext-aware encryption scheme such as RSAES-OAEP\" without\n\
    \   specifying the kind of plaintext awareness or chosen ciphertext\n   attack\
    \ considered.)\n   OAEP has never been proven secure against CCA2; in fact, Victor\
    \ Shoup\n   [48] has demonstrated that such a proof does not exist in the general\n\
    \   case.  Put briefly, Shoup showed that an adversary in the CCA2\n   scenario\
    \ who knows how to partially invert the encryption primitive\n   but does not\
    \ know how to invert it completely may well be able to\n   break the scheme. \
    \ For example, one may imagine an attacker who is\n   able to break RSAES-OAEP\
    \ if she knows how to recover all but the\n   first 20 bytes of a random integer\
    \ encrypted with RSAEP.  Such an\n   attacker does not need to be able to fully\
    \ invert RSAEP, because she\n   does not use the first 20 octets in her attack.\n\
    \   Still, RSAES-OAEP is secure against CCA2, which was proved by\n   Fujisaki,\
    \ Okamoto, Pointcheval, and Stern [21] shortly after the\n   announcement of Shoup's\
    \ result.  Using clever lattice reduction\n   techniques, they managed to show\
    \ how to invert RSAEP completely given\n   a sufficiently large part of the pre-image.\
    \  This observation,\n   combined with a proof that OAEP is secure against CCA2\
    \ if the\n   underlying encryption primitive is hard to partially invert, fills\n\
    \   the gap between what Bellare and Rogaway proved about RSAES-OAEP and\n   what\
    \ some may have believed that they proved.  Somewhat\n   paradoxically, we are\
    \ hence saved by an ostensible weakness in RSAEP\n   (i.e., the whole inverse\
    \ can be deduced from parts of it).\n   Unfortunately however, the security reduction\
    \ is not efficient for\n   concrete parameters.  While the proof successfully\
    \ relates an\n   adversary Adv against the CCA2 security of RSAES-OAEP to an algorithm\n\
    \   Inv inverting RSA, the probability of success for Inv is only\n   approximately\
    \ \\epsilon^2 / 2^18, where \\epsilon is the probability of\n   success for Adv.\n\
    \   (Footnote: In [21] the probability of success for the inverter was\n   \\\
    epsilon^2 / 4.  The additional factor 1 / 2^16 is due to the eight\n   fixed zero\
    \ bits at the beginning of the encoded message EM, which are\n   not present in\
    \ the variant of OAEP considered in [21] (Inv must apply\n   Adv twice to invert\
    \ RSA, and each application corresponds to a factor\n   1 / 2^8).)\n   In addition,\
    \ the running time for Inv is approximately t^2, where t\n   is the running time\
    \ of the adversary.  The consequence is that we\n   cannot exclude the possibility\
    \ that attacking RSAES-OAEP is\n   considerably easier than inverting RSA for\
    \ concrete parameters.\n   Still, the existence of a security proof provides some\
    \ assurance that\n   the RSAES-OAEP construction is sounder than ad hoc constructions\
    \ such\n   as RSAES-PKCS1-v1_5.\n   Hybrid encryption schemes based on the RSA-KEM\
    \ key encapsulation\n   paradigm offer tight proofs of security directly applicable\
    \ to\n   concrete parameters; see [30] for discussion.  Future versions of\n \
    \  PKCS #1 may specify schemes based on this paradigm.\n"
- title: 7.1.1 Encryption operation
  contents:
  - "7.1.1 Encryption operation\n   RSAES-OAEP-ENCRYPT ((n, e), M, L)\n   Options:\n\
    \   Hash     hash function (hLen denotes the length in octets of the hash\n  \
    \          function output)\n   MGF      mask generation function\n   Input:\n\
    \   (n, e)   recipient's RSA public key (k denotes the length in octets\n    \
    \        of the RSA modulus n)\n   M        message to be encrypted, an octet\
    \ string of length mLen,\n            where mLen <= k - 2hLen - 2\n   L      \
    \  optional label to be associated with the message; the\n            default\
    \ value for L, if L is not provided, is the empty\n            string\n   Output:\n\
    \   C        ciphertext, an octet string of length k\n   Errors:  \"message too\
    \ long\"; \"label too long\"\n   Assumption: RSA public key (n, e) is valid\n\
    \   Steps:\n   1. Length checking:\n      a. If the length of L is greater than\
    \ the input limitation for the\n         hash function (2^61 - 1 octets for SHA-1),\
    \ output \"label too\n         long\" and stop.\n      b. If mLen > k - 2hLen\
    \ - 2, output \"message too long\" and stop.\n   2. EME-OAEP encoding (see Figure\
    \ 1 below):\n      a. If the label L is not provided, let L be the empty string.\
    \ Let\n         lHash = Hash(L), an octet string of length hLen (see the note\n\
    \         below).\n      b. Generate an octet string PS consisting of k - mLen\
    \ - 2hLen - 2\n         zero octets.  The length of PS may be zero.\n      c.\
    \ Concatenate lHash, PS, a single octet with hexadecimal value\n         0x01,\
    \ and the message M to form a data block DB of length k -\n         hLen - 1 octets\
    \ as\n            DB = lHash || PS || 0x01 || M.\n      d. Generate a random octet\
    \ string seed of length hLen.\n      e. Let dbMask = MGF(seed, k - hLen - 1).\n\
    \      f. Let maskedDB = DB \\xor dbMask.\n      g. Let seedMask = MGF(maskedDB,\
    \ hLen).\n      h. Let maskedSeed = seed \\xor seedMask.\n      i. Concatenate\
    \ a single octet with hexadecimal value 0x00,\n         maskedSeed, and maskedDB\
    \ to form an encoded message EM of\n         length k octets as\n            EM\
    \ = 0x00 || maskedSeed || maskedDB.\n   3. RSA encryption:\n      a. Convert the\
    \ encoded message EM to an integer message\n         representative m (see Section\
    \ 4.2):\n            m = OS2IP (EM).\n      b. Apply the RSAEP encryption primitive\
    \ (Section 5.1.1) to the RSA\n         public key (n, e) and the message representative\
    \ m to produce\n         an integer ciphertext representative c:\n           \
    \ c = RSAEP ((n, e), m).\n      c. Convert the ciphertext representative c to\
    \ a ciphertext C of\n         length k octets (see Section 4.1):\n           \
    \ C = I2OSP (c, k).\n   4. Output the ciphertext C.\n   Note.  If L is the empty\
    \ string, the corresponding hash value lHash\n   has the following hexadecimal\
    \ representation for different choices of\n   Hash:\n   SHA-1:   (0x)da39a3ee\
    \ 5e6b4b0d 3255bfef 95601890 afd80709\n   SHA-256: (0x)e3b0c442 98fc1c14 9afbf4c8\
    \ 996fb924 27ae41e4 649b934c\n                a495991b 7852b855\n   SHA-384: (0x)38b060a7\
    \ 51ac9638 4cd9327e b1b1e36a 21fdb711 14be0743\n                4c0cc7bf 63f6e1da\
    \ 274edebf e76f65fb d51ad2f1 4898b95b\n   SHA-512: (0x)cf83e135 7eefb8bd f1542850\
    \ d66d8007 d620e405 0b5715dc\n                83f4a921 d36ce9ce 47d0d13c 5d85f2b0\
    \ ff8318d2 877eec2f\n                63b931bd 47417a81 a538327a f927da3e\n   __________________________________________________________________\n\
    \                             +----------+---------+-------+\n               \
    \         DB = |  lHash   |    PS   |   M   |\n                             +----------+---------+-------+\n\
    \                                            |\n                  +----------+\
    \              V\n                  |   seed   |--> MGF ---> xor\n           \
    \       +----------+              |\n                        |               \
    \    |\n               +--+     V                   |\n               |00|   \
    \ xor <----- MGF <-----|\n               +--+     |                   |\n    \
    \             |      |                   |\n                 V      V        \
    \           V\n               +--+----------+----------------------------+\n \
    \        EM =  |00|maskedSeed|          maskedDB          |\n               +--+----------+----------------------------+\n\
    \   __________________________________________________________________\n   Figure\
    \ 1: EME-OAEP encoding operation.  lHash is the hash of the\n   optional label\
    \ L.  Decoding operation follows reverse steps to\n   recover M and verify lHash\
    \ and PS.\n"
- title: 7.1.2 Decryption operation
  contents:
  - "7.1.2 Decryption operation\n   RSAES-OAEP-DECRYPT (K, C, L)\n   Options:\n  \
    \ Hash     hash function (hLen denotes the length in octets of the hash\n    \
    \        function output)\n   MGF      mask generation function\n   Input:\n \
    \  K        recipient's RSA private key (k denotes the length in octets\n    \
    \        of the RSA modulus n)\n   C        ciphertext to be decrypted, an octet\
    \ string of length k,\n            where k = 2hLen + 2\n   L        optional label\
    \ whose association with the message is to be\n            verified; the default\
    \ value for L, if L is not provided, is\n            the empty string\n   Output:\n\
    \   M        message, an octet string of length mLen, where mLen <= k -\n    \
    \        2hLen - 2\n   Error: \"decryption error\"\n   Steps:\n   1. Length checking:\n\
    \      a. If the length of L is greater than the input limitation for the\n  \
    \       hash function (2^61 - 1 octets for SHA-1), output \"decryption\n     \
    \    error\" and stop.\n      b. If the length of the ciphertext C is not k octets,\
    \ output\n         \"decryption error\" and stop.\n      c. If k < 2hLen + 2,\
    \ output \"decryption error\" and stop.\n   2.    RSA decryption:\n      a. Convert\
    \ the ciphertext C to an integer ciphertext\n         representative c (see Section\
    \ 4.2):\n            c = OS2IP (C).\n         b. Apply the RSADP decryption primitive\
    \ (Section 5.1.2) to the\n         RSA private key K and the ciphertext representative\
    \ c to\n         produce an integer message representative m:\n            m =\
    \ RSADP (K, c).\n         If RSADP outputs \"ciphertext representative out of\
    \ range\"\n         (meaning that c >= n), output \"decryption error\" and stop.\n\
    \      c. Convert the message representative m to an encoded message EM\n    \
    \     of length k octets (see Section 4.1):\n            EM = I2OSP (m, k).\n\
    \   3. EME-OAEP decoding:\n      a. If the label L is not provided, let L be the\
    \ empty string. Let\n         lHash = Hash(L), an octet string of length hLen\
    \ (see the note\n         in Section 7.1.1).\n      b. Separate the encoded message\
    \ EM into a single octet Y, an octet\n         string maskedSeed of length hLen,\
    \ and an octet string maskedDB\n         of length k - hLen - 1 as\n         \
    \   EM = Y || maskedSeed || maskedDB.\n      c. Let seedMask = MGF(maskedDB, hLen).\n\
    \      d. Let seed = maskedSeed \\xor seedMask.\n      e. Let dbMask = MGF(seed,\
    \ k - hLen - 1).\n      f. Let DB = maskedDB \\xor dbMask.\n      g. Separate\
    \ DB into an octet string lHash' of length hLen, a\n         (possibly empty)\
    \ padding string PS consisting of octets with\n         hexadecimal value 0x00,\
    \ and a message M as\n            DB = lHash' || PS || 0x01 || M.\n         If\
    \ there is no octet with hexadecimal value 0x01 to separate PS\n         from\
    \ M, if lHash does not equal lHash', or if Y is nonzero,\n         output \"decryption\
    \ error\" and stop.  (See the note below.)\n   4. Output the message M.\n   Note.\
    \  Care must be taken to ensure that an opponent cannot\n   distinguish the different\
    \ error conditions in Step 3.g, whether by\n   error message or timing, or, more\
    \ generally, learn partial\n   information about the encoded message EM.  Otherwise\
    \ an opponent may\n   be able to obtain useful information about the decryption\
    \ of the\n   ciphertext C, leading to a chosen-ciphertext attack such as the one\n\
    \   observed by Manger [36].\n"
- title: 7.2 RSAES-PKCS1-v1_5
  contents:
  - "7.2 RSAES-PKCS1-v1_5\n   RSAES-PKCS1-v1_5 combines the RSAEP and RSADP primitives\
    \ (Sections\n   5.1.1 and 5.1.2) with the EME-PKCS1-v1_5 encoding method (step\
    \ 1 in\n   Section 7.2.1 and step 3 in Section 7.2.2).  It is mathematically\n\
    \   equivalent to the encryption scheme in PKCS #1 v1.5.  RSAES-PKCS1-\n   v1_5\
    \ can operate on messages of length up to k - 11 octets (k is the\n   octet length\
    \ of the RSA modulus), although care should be taken to\n   avoid certain attacks\
    \ on low-exponent RSA due to Coppersmith,\n   Franklin, Patarin, and Reiter when\
    \ long messages are encrypted (see\n   the third bullet in the notes below and\
    \ [10]; [14] contains an\n   improved attack).  As a general rule, the use of\
    \ this scheme for\n   encrypting an arbitrary message, as opposed to a randomly\
    \ generated\n   key, is not recommended.\n   It is possible to generate valid\
    \ RSAES-PKCS1-v1_5 ciphertexts without\n   knowing the corresponding plaintexts,\
    \ with a reasonable probability\n   of success.  This ability can be exploited\
    \ in a chosen- ciphertext\n   attack as shown in [6].  Therefore, if RSAES-PKCS1-v1_5\
    \ is to be\n   used, certain easily implemented countermeasures should be taken\
    \ to\n   thwart the attack found in [6].  Typical examples include the\n   addition\
    \ of structure to the data to be encoded, rigorous checking of\n   PKCS #1 v1.5\
    \ conformance (and other redundancy) in decrypted\n   messages, and the consolidation\
    \ of error messages in a client-server\n   protocol based on PKCS #1 v1.5.  These\
    \ can all be effective\n   countermeasures and do not involve changes to a PKCS\
    \ #1 v1.5-based\n   protocol.  See [7] for a further discussion of these and other\n\
    \   countermeasures.  It has recently been shown that the security of the\n  \
    \ SSL/TLS handshake protocol [17], which uses RSAES-PKCS1-v1_5 and\n   certain\
    \ countermeasures, can be related to a variant of the RSA\n   problem; see [32]\
    \ for discussion.\n   Note.  The following passages describe some security recommendations\n\
    \   pertaining to the use of RSAES-PKCS1-v1_5.  Recommendations from\n   version\
    \ 1.5 of this document are included as well as new\n   recommendations motivated\
    \ by cryptanalytic advances made in the\n   intervening years.\n    * It is recommended\
    \ that the pseudorandom octets in step 2 in\n      Section 7.2.1 be generated\
    \ independently for each encryption\n      process, especially if the same data\
    \ is input to more than one\n      encryption process.  Haastad's results [24]\
    \ are one motivation for\n      this recommendation.\n    * The padding string\
    \ PS in step 2 in Section 7.2.1 is at least eight\n      octets long, which is\
    \ a security condition for public-key\n      operations that makes it difficult\
    \ for an attacker to recover data\n      by trying all possible encryption blocks.\n\
    \    * The pseudorandom octets can also help thwart an attack due to\n      Coppersmith\
    \ et al. [10] (see [14] for an improvement of the\n      attack) when the size\
    \ of the message to be encrypted is kept\n      small.  The attack works on low-exponent\
    \ RSA when similar messages\n      are encrypted with the same RSA public key.\
    \  More specifically, in\n      one flavor of the attack, when two inputs to RSAEP\
    \ agree on a\n      large fraction of bits (8/9) and low-exponent RSA (e = 3)\
    \ is used\n      to encrypt both of them, it may be possible to recover both inputs\n\
    \      with the attack.  Another flavor of the attack is successful in\n     \
    \ decrypting a single ciphertext when a large fraction (2/3) of the\n      input\
    \ to RSAEP is already known.  For typical applications, the\n      message to\
    \ be encrypted is short (e.g., a 128-bit symmetric key)\n      so not enough information\
    \ will be known or common between two\n      messages to enable the attack.  However,\
    \ if a long message is\n      encrypted, or if part of a message is known, then\
    \ the attack may\n      be a concern.  In any case, the RSAES-OAEP scheme overcomes\
    \ the\n      attack.\n"
- title: 7.2.1 Encryption operation
  contents:
  - "7.2.1 Encryption operation\n   RSAES-PKCS1-V1_5-ENCRYPT ((n, e), M)\n   Input:\n\
    \   (n, e)   recipient's RSA public key (k denotes the length in octets\n    \
    \        of the modulus n)\n   M        message to be encrypted, an octet string\
    \ of length mLen,\n            where mLen <= k - 11\n   Output:\n   C        ciphertext,\
    \ an octet string of length k\n   Error: \"message too long\"\n   Steps:\n   1.\
    \ Length checking: If mLen > k - 11, output \"message too long\" and\n      stop.\n\
    \   2. EME-PKCS1-v1_5 encoding:\n      a. Generate an octet string PS of length\
    \ k - mLen - 3 consisting\n         of pseudo-randomly generated nonzero octets.\
    \  The length of PS\n         will be at least eight octets.\n      b. Concatenate\
    \ PS, the message M, and other padding to form an\n         encoded message EM\
    \ of length k octets as\n            EM = 0x00 || 0x02 || PS || 0x00 || M.\n \
    \  3. RSA encryption:\n      a. Convert the encoded message EM to an integer message\n\
    \         representative m (see Section 4.2):\n            m = OS2IP (EM).\n \
    \     b. Apply the RSAEP encryption primitive (Section 5.1.1) to the RSA\n   \
    \      public key (n, e) and the message representative m to produce\n       \
    \  an integer ciphertext representative c:\n            c = RSAEP ((n, e), m).\n\
    \      c. Convert the ciphertext representative c to a ciphertext C of\n     \
    \    length k octets (see Section 4.1):\n               C = I2OSP (c, k).\n  \
    \ 4. Output the ciphertext C.\n"
- title: 7.2.2 Decryption operation
  contents:
  - "7.2.2 Decryption operation\n   RSAES-PKCS1-V1_5-DECRYPT (K, C)\n   Input:\n \
    \  K        recipient's RSA private key\n   C        ciphertext to be decrypted,\
    \ an octet string of length k,\n            where k is the length in octets of\
    \ the RSA modulus n\n   Output:\n   M        message, an octet string of length\
    \ at most k - 11\n   Error: \"decryption error\"\n   Steps:\n   1. Length checking:\
    \ If the length of the ciphertext C is not k octets\n      (or if k < 11), output\
    \ \"decryption error\" and stop.\n   2. RSA decryption:\n      a. Convert the\
    \ ciphertext C to an integer ciphertext\n         representative c (see Section\
    \ 4.2):\n            c = OS2IP (C).\n      b. Apply the RSADP decryption primitive\
    \ (Section 5.1.2) to the RSA\n         private key (n, d) and the ciphertext representative\
    \ c to\n         produce an integer message representative m:\n            m =\
    \ RSADP ((n, d), c).\n         If RSADP outputs \"ciphertext representative out\
    \ of range\"\n         (meaning that c >= n), output \"decryption error\" and\
    \ stop.\n      c. Convert the message representative m to an encoded message EM\n\
    \         of length k octets (see Section 4.1):\n            EM = I2OSP (m, k).\n\
    \   3. EME-PKCS1-v1_5 decoding: Separate the encoded message EM into an\n    \
    \  octet string PS consisting of nonzero octets and a message M as\n         EM\
    \ = 0x00 || 0x02 || PS || 0x00 || M.\n      If the first octet of EM does not\
    \ have hexadecimal value 0x00, if\n      the second octet of EM does not have\
    \ hexadecimal value 0x02, if\n      there is no octet with hexadecimal value 0x00\
    \ to separate PS from\n      M, or if the length of PS is less than 8 octets,\
    \ output\n      \"decryption error\" and stop.  (See the note below.)\n   4. Output\
    \ M.\n   Note.  Care shall be taken to ensure that an opponent cannot\n   distinguish\
    \ the different error conditions in Step 3, whether by\n   error message or timing.\
    \  Otherwise an opponent may be able to obtain\n   useful information about the\
    \ decryption of the ciphertext C, leading\n   to a strengthened version of Bleichenbacher's\
    \ attack [6]; compare to\n   Manger's attack [36].\n"
- title: 8. Signature schemes with appendix
  contents:
  - "8. Signature schemes with appendix\n   For the purposes of this document, a signature\
    \ scheme with appendix\n   consists of a signature generation operation and a\
    \ signature\n   verification operation, where the signature generation operation\n\
    \   produces a signature from a message with a signer's RSA private key,\n   and\
    \ the signature verification operation verifies the signature on\n   the message\
    \ with the signer's corresponding RSA public key.  To\n   verify a signature constructed\
    \ with this type of scheme it is\n   necessary to have the message itself.  In\
    \ this way, signature schemes\n   with appendix are distinguished from signature\
    \ schemes with message\n   recovery, which are not supported in this document.\n\
    \   A signature scheme with appendix can be employed in a variety of\n   applications.\
    \  For instance, the signature schemes with appendix\n   defined here would be\
    \ suitable signature algorithms for X.509\n   certificates [28].  Related signature\
    \ schemes could be employed in\n   PKCS #7 [45], although for technical reasons\
    \ the current version of\n   PKCS #7 separates a hash function from a signature\
    \ scheme, which is\n   different than what is done here; see the note in Appendix\
    \ A.2.3 for\n   more discussion.\n   Two signature schemes with appendix are specified\
    \ in this document:\n   RSASSA-PSS and RSASSA-PKCS1-v1_5.  Although no attacks\
    \ are known\n   against RSASSA-PKCS1-v1_5, in the interest of increased robustness,\n\
    \   RSASSA-PSS is recommended for eventual adoption in new applications.\n   RSASSA-PKCS1-v1_5\
    \ is included for compatibility with existing\n   applications, and while still\
    \ appropriate for new applications, a\n   gradual transition to RSASSA-PSS is\
    \ encouraged.\n   The signature schemes with appendix given here follow a general\
    \ model\n   similar to that employed in IEEE Std 1363-2000 [26], combining\n \
    \  signature and verification primitives with an encoding method for\n   signatures.\
    \  The signature generation operations apply a message\n   encoding operation\
    \ to a message to produce an encoded message, which\n   is then converted to an\
    \ integer message representative.  A signature\n   primitive is applied to the\
    \ message representative to produce the\n   signature.  Reversing this, the signature\
    \ verification operations\n   apply a signature verification primitive to the\
    \ signature to recover\n   a message representative, which is then converted to\
    \ an octet string\n   encoded message.  A verification operation is applied to\
    \ the message\n   and the encoded message to determine whether they are consistent.\n\
    \   If the encoding method is deterministic (e.g., EMSA-PKCS1-v1_5), the\n   verification\
    \ operation may apply the message encoding operation to\n   the message and compare\
    \ the resulting encoded message to the\n   previously derived encoded message.\
    \  If there is a match, the\n   signature is considered valid.  If the method\
    \ is randomized (e.g.,\n   EMSA-PSS), the verification operation is typically\
    \ more complicated.\n   For example, the verification operation in EMSA-PSS extracts\
    \ the\n   random salt and a hash output from the encoded message and checks\n\
    \   whether the hash output, the salt, and the message are consistent;\n   the\
    \ hash output is a deterministic function in terms of the message\n   and the\
    \ salt.\n   For both signature schemes with appendix defined in this document,\n\
    \   the signature generation and signature verification operations are\n   readily\
    \ implemented as \"single-pass\" operations if the signature is\n   placed after\
    \ the message.  See PKCS #7 [45] for an example format in\n   the case of RSASSA-PKCS1-v1_5.\n"
- title: 8.1 RSASSA-PSS
  contents:
  - "8.1 RSASSA-PSS\n   RSASSA-PSS combines the RSASP1 and RSAVP1 primitives with\
    \ the EMSA-\n   PSS encoding method.  It is compatible with the IFSSA scheme as\n\
    \   amended in the IEEE P1363a draft [27], where the signature and\n   verification\
    \ primitives are IFSP-RSA1 and IFVP-RSA1 as defined in\n   IEEE Std 1363-2000\
    \ [26] and the message encoding method is EMSA4.\n   EMSA4 is slightly more general\
    \ than EMSA-PSS as it acts on bit\n   strings rather than on octet strings.  EMSA-PSS\
    \ is equivalent to\n   EMSA4 restricted to the case that the operands as well\
    \ as the hash\n   and salt values are octet strings.\n   The length of messages\
    \ on which RSASSA-PSS can operate is either\n   unrestricted or constrained by\
    \ a very large number, depending on the\n   hash function underlying the EMSA-PSS\
    \ encoding method.\n   Assuming that computing e-th roots modulo n is infeasible\
    \ and the\n   hash and mask generation functions in EMSA-PSS have appropriate\n\
    \   properties, RSASSA-PSS provides secure signatures.  This assurance is\n  \
    \ provable in the sense that the difficulty of forging signatures can\n   be directly\
    \ related to the difficulty of inverting the RSA function,\n   provided that the\
    \ hash and mask generation functions are viewed as\n   black boxes or random oracles.\
    \  The bounds in the security proof are\n   essentially \"tight\", meaning that\
    \ the success probability and running\n   time for the best forger against RSASSA-PSS\
    \ are very close to the\n   corresponding parameters for the best RSA inversion\
    \ algorithm; see\n   [4][13][31] for further discussion.\n   In contrast to the\
    \ RSASSA-PKCS1-v1_5 signature scheme, a hash\n   function identifier is not embedded\
    \ in the EMSA-PSS encoded message,\n   so in theory it is possible for an adversary\
    \ to substitute a\n   different (and potentially weaker) hash function than the\
    \ one\n   selected by the signer.  Therefore, it is recommended that the EMSA-\n\
    \   PSS mask generation function be based on the same hash function.  In\n   this\
    \ manner the entire encoded message will be dependent on the hash\n   function\
    \ and it will be difficult for an opponent to substitute a\n   different hash\
    \ function than the one intended by the signer.  This\n   matching of hash functions\
    \ is only for the purpose of preventing hash\n   function substitution, and is\
    \ not necessary if hash function\n   substitution is addressed by other means\
    \ (e.g., the verifier accepts\n   only a designated hash function).  See [34]\
    \ for further discussion of\n   these points.  The provable security of RSASSA-PSS\
    \ does not rely on\n   the hash function in the mask generation function being\
    \ the same as\n   the hash function applied to the message.\n   RSASSA-PSS is\
    \ different from other RSA-based signature schemes in\n   that it is probabilistic\
    \ rather than deterministic, incorporating a\n   randomly generated salt value.\
    \  The salt value enhances the security\n   of the scheme by affording a \"tighter\"\
    \ security proof than\n   deterministic alternatives such as Full Domain Hashing\
    \ (FDH); see [4]\n   for discussion.  However, the randomness is not critical\
    \ to security.\n   In situations where random generation is not possible, a fixed\
    \ value\n   or a sequence number could be employed instead, with the resulting\n\
    \   provable security similar to that of FDH [12].\n"
- title: 8.1.1 Signature generation operation
  contents:
  - "8.1.1 Signature generation operation\n   RSASSA-PSS-SIGN (K, M)\n   Input:\n\
    \   K        signer's RSA private key\n   M        message to be signed, an octet\
    \ string\n   Output:\n   S        signature, an octet string of length k, where\
    \ k is the\n            length in octets of the RSA modulus n\n   Errors: \"message\
    \ too long;\" \"encoding error\"\n   Steps:\n   1. EMSA-PSS encoding: Apply the\
    \ EMSA-PSS encoding operation (Section\n      9.1.1) to the message M to produce\
    \ an encoded message EM of length\n      \\ceil ((modBits - 1)/8) octets such\
    \ that the bit length of the\n      integer OS2IP (EM) (see Section 4.2) is at\
    \ most modBits - 1, where\n      modBits is the length in bits of the RSA modulus\
    \ n:\n         EM = EMSA-PSS-ENCODE (M, modBits - 1).\n      Note that the octet\
    \ length of EM will be one less than k if\n      modBits - 1 is divisible by 8\
    \ and equal to k otherwise.  If the\n      encoding operation outputs \"message\
    \ too long,\" output \"message too\n      long\" and stop.  If the encoding operation\
    \ outputs \"encoding\n      error,\" output \"encoding error\" and stop.\n   2.\
    \ RSA signature:\n      a. Convert the encoded message EM to an integer message\n\
    \         representative m (see Section 4.2):\n            m = OS2IP (EM).\n \
    \     b. Apply the RSASP1 signature primitive (Section 5.2.1) to the RSA\n   \
    \      private key K and the message representative m to produce an\n        \
    \ integer signature representative s:\n            s = RSASP1 (K, m).\n      c.\
    \ Convert the signature representative s to a signature S of\n         length\
    \ k octets (see Section 4.1):\n            S = I2OSP (s, k).\n   3. Output the\
    \ signature S.\n"
- title: 8.1.2 Signature verification operation
  contents:
  - "8.1.2 Signature verification operation\n   RSASSA-PSS-VERIFY ((n, e), M, S)\n\
    \   Input:\n   (n, e)   signer's RSA public key\n   M        message whose signature\
    \ is to be verified, an octet string\n   S        signature to be verified, an\
    \ octet string of length k, where\n            k is the length in octets of the\
    \ RSA modulus n\n   Output:\n   \"valid signature\" or \"invalid signature\"\n\
    \   Steps:\n   1. Length checking: If the length of the signature S is not k octets,\n\
    \      output \"invalid signature\" and stop.\n   2. RSA verification:\n     \
    \ a. Convert the signature S to an integer signature representative\n        \
    \ s (see Section 4.2):\n            s = OS2IP (S).\n      b. Apply the RSAVP1\
    \ verification primitive (Section 5.2.2) to the\n         RSA public key (n, e)\
    \ and the signature representative s to\n         produce an integer message representative\
    \ m:\n            m = RSAVP1 ((n, e), s).\n         If RSAVP1 output \"signature\
    \ representative out of range,\"\n         output \"invalid signature\" and stop.\n\
    \      c. Convert the message representative m to an encoded message EM\n    \
    \     of length emLen = \\ceil ((modBits - 1)/8) octets, where modBits\n     \
    \    is the length in bits of the RSA modulus n (see Section 4.1):\n         \
    \   EM = I2OSP (m, emLen).\n         Note that emLen will be one less than k if\
    \ modBits - 1 is\n         divisible by 8 and equal to k otherwise.  If I2OSP\
    \ outputs\n         \"integer too large,\" output \"invalid signature\" and stop.\n\
    \   3. EMSA-PSS verification: Apply the EMSA-PSS verification operation\n    \
    \  (Section 9.1.2) to the message M and the encoded message EM to\n      determine\
    \ whether they are consistent:\n         Result = EMSA-PSS-VERIFY (M, EM, modBits\
    \ - 1).\n   4. If Result = \"consistent,\" output \"valid signature.\" Otherwise,\n\
    \      output \"invalid signature.\"\n"
- title: 8.2. RSASSA-PKCS1-v1_5
  contents:
  - "8.2. RSASSA-PKCS1-v1_5\n   RSASSA-PKCS1-v1_5 combines the RSASP1 and RSAVP1 primitives\
    \ with the\n   EMSA-PKCS1-v1_5 encoding method.  It is compatible with the IFSSA\n\
    \   scheme defined in IEEE Std 1363-2000 [26], where the signature and\n   verification\
    \ primitives are IFSP-RSA1 and IFVP-RSA1 and the message\n   encoding method is\
    \ EMSA-PKCS1-v1_5 (which is not defined in IEEE Std\n   1363-2000, but is in the\
    \ IEEE P1363a draft [27]).\n   The length of messages on which RSASSA-PKCS1-v1_5\
    \ can operate is\n   either unrestricted or constrained by a very large number,\
    \ depending\n   on the hash function underlying the EMSA-PKCS1-v1_5 method.\n\
    \   Assuming that computing e-th roots modulo n is infeasible and the\n   hash\
    \ function in EMSA-PKCS1-v1_5 has appropriate properties, RSASSA-\n   PKCS1-v1_5\
    \ is conjectured to provide secure signatures.  More\n   precisely, forging signatures\
    \ without knowing the RSA private key is\n   conjectured to be computationally\
    \ infeasible.  Also, in the encoding\n   method EMSA-PKCS1-v1_5, a hash function\
    \ identifier is embedded in the\n   encoding.  Because of this feature, an adversary\
    \ trying to find a\n   message with the same signature as a previously signed\
    \ message must\n   find collisions of the particular hash function being used;\
    \ attacking\n   a different hash function than the one selected by the signer\
    \ is not\n   useful to the adversary.  See [34] for further discussion.\n   Note.\
    \  As noted in PKCS #1 v1.5, the EMSA-PKCS1-v1_5 encoding method\n   has the property\
    \ that the encoded message, converted to an integer\n   message representative,\
    \ is guaranteed to be large and at least\n   somewhat \"random\".  This prevents\
    \ attacks of the kind proposed by\n   Desmedt and Odlyzko [16] where multiplicative\
    \ relationships between\n   message representatives are developed by factoring\
    \ the message\n   representatives into a set of small values (e.g., a set of small\n\
    \   primes).  Coron, Naccache, and Stern [15] showed that a stronger form\n  \
    \ of this type of attack could be quite effective against some\n   instances of\
    \ the ISO/IEC 9796-2 signature scheme.  They also analyzed\n   the complexity\
    \ of this type of attack against the EMSA-PKCS1-v1_5\n   encoding method and concluded\
    \ that an attack would be impractical,\n   requiring more operations than a collision\
    \ search on the underlying\n   hash function (i.e., more than 2^80 operations).\
    \  Coppersmith,\n   Halevi, and Jutla [11] subsequently extended Coron et al.'s\
    \ attack to\n   break the ISO/IEC 9796-1 signature scheme with message recovery.\
    \  The\n   various attacks illustrate the importance of carefully constructing\n\
    \   the input to the RSA signature primitive, particularly in a signature\n  \
    \ scheme with message recovery.  Accordingly, the EMSA-PKCS-v1_5\n   encoding\
    \ method explicitly includes a hash operation and is not\n   intended for signature\
    \ schemes with message recovery.  Moreover,\n   while no attack is known against\
    \ the EMSA-PKCS-v1_5 encoding method,\n   a gradual transition to EMSA-PSS is\
    \ recommended as a precaution\n   against future developments.\n"
- title: 8.2.1 Signature generation operation
  contents:
  - "8.2.1 Signature generation operation\n   RSASSA-PKCS1-V1_5-SIGN (K, M)\n   Input:\n\
    \   K        signer's RSA private key\n   M        message to be signed, an octet\
    \ string\n   Output:\n   S        signature, an octet string of length k, where\
    \ k is the\n            length in octets of the RSA modulus n\n   Errors: \"message\
    \ too long\"; \"RSA modulus too short\"\n   Steps:\n   1. EMSA-PKCS1-v1_5 encoding:\
    \ Apply the EMSA-PKCS1-v1_5 encoding\n      operation (Section 9.2) to the message\
    \ M to produce an encoded\n      message EM of length k octets:\n         EM =\
    \ EMSA-PKCS1-V1_5-ENCODE (M, k).\n      If the encoding operation outputs \"message\
    \ too long,\" output\n      \"message too long\" and stop.  If the encoding operation\
    \ outputs\n      \"intended encoded message length too short,\" output \"RSA modulus\n\
    \      too short\" and stop.\n   2. RSA signature:\n      a. Convert the encoded\
    \ message EM to an integer message\n         representative m (see Section 4.2):\n\
    \            m = OS2IP (EM).\n      b. Apply the RSASP1 signature primitive (Section\
    \ 5.2.1) to the RSA\n         private key K and the message representative m to\
    \ produce an\n         integer signature representative s:\n            s = RSASP1\
    \ (K, m).\n      c. Convert the signature representative s to a signature S of\n\
    \         length k octets (see Section 4.1):\n            S = I2OSP (s, k).\n\
    \   3. Output the signature S.\n"
- title: 8.2.2 Signature verification operation
  contents:
  - "8.2.2 Signature verification operation\n   RSASSA-PKCS1-V1_5-VERIFY ((n, e),\
    \ M, S)\n   Input:\n   (n, e)   signer's RSA public key\n   M        message whose\
    \ signature is to be verified, an octet string\n   S        signature to be verified,\
    \ an octet string of length k, where\n            k is the length in octets of\
    \ the RSA modulus n\n   Output:\n   \"valid signature\" or \"invalid signature\"\
    \n   Errors: \"message too long\"; \"RSA modulus too short\"\n   Steps:\n   1.\
    \ Length checking: If the length of the signature S is not k octets,\n      output\
    \ \"invalid signature\" and stop.\n   2. RSA verification:\n      a. Convert the\
    \ signature S to an integer signature representative\n         s (see Section\
    \ 4.2):\n            s = OS2IP (S).\n      b. Apply the RSAVP1 verification primitive\
    \ (Section 5.2.2) to the\n         RSA public key (n, e) and the signature representative\
    \ s to\n         produce an integer message representative m:\n            m =\
    \ RSAVP1 ((n, e), s).\n         If RSAVP1 outputs \"signature representative out\
    \ of range,\"\n         output \"invalid signature\" and stop.\n      c. Convert\
    \ the message representative m to an encoded message EM\n         of length k\
    \ octets (see Section 4.1):\n            EM' = I2OSP (m, k).\n         If I2OSP\
    \ outputs \"integer too large,\" output \"invalid\n         signature\" and stop.\n\
    \   3. EMSA-PKCS1-v1_5 encoding: Apply the EMSA-PKCS1-v1_5 encoding\n      operation\
    \ (Section 9.2) to the message M to produce a second\n      encoded message EM'\
    \ of length k octets:\n            EM' = EMSA-PKCS1-V1_5-ENCODE (M, k).\n    \
    \  If the encoding operation outputs \"message too long,\" output\n      \"message\
    \ too long\" and stop.  If the encoding operation outputs\n      \"intended encoded\
    \ message length too short,\" output \"RSA modulus\n      too short\" and stop.\n\
    \   4. Compare the encoded message EM and the second encoded message EM'.\n  \
    \    If they are the same, output \"valid signature\"; otherwise, output\n   \
    \   \"invalid signature.\"\n   Note.  Another way to implement the signature verification\
    \ operation\n   is to apply a \"decoding\" operation (not specified in this document)\n\
    \   to the encoded message to recover the underlying hash value, and then\n  \
    \ to compare it to a newly computed hash value.  This has the advantage\n   that\
    \ it requires less intermediate storage (two hash values rather\n   than two encoded\
    \ messages), but the disadvantage that it requires\n   additional code.\n"
- title: 9. Encoding methods for signatures with appendix
  contents:
  - "9. Encoding methods for signatures with appendix\n   Encoding methods consist\
    \ of operations that map between octet string\n   messages and octet string encoded\
    \ messages, which are converted to\n   and from integer message representatives\
    \ in the schemes.  The integer\n   message representatives are processed via the\
    \ primitives.  The\n   encoding methods thus provide the connection between the\
    \ schemes,\n   which process messages, and the primitives.\n   An encoding method\
    \ for signatures with appendix, for the purposes of\n   this document, consists\
    \ of an encoding operation and optionally a\n   verification operation.  An encoding\
    \ operation maps a message M to an\n   encoded message EM of a specified length.\
    \  A verification operation\n   determines whether a message M and an encoded\
    \ message EM are\n   consistent, i.e., whether the encoded message EM is a valid\
    \ encoding\n   of the message M.\n   The encoding operation may introduce some\
    \ randomness, so that\n   different applications of the encoding operation to\
    \ the same message\n   will produce different encoded messages, which has benefits\
    \ for\n   provable security.  For such an encoding method, both an encoding and\n\
    \   a verification operation are needed unless the verifier can reproduce\n  \
    \ the randomness (e.g., by obtaining the salt value from the signer).\n   For\
    \ a deterministic encoding method only an encoding operation is\n   needed.\n\
    \   Two encoding methods for signatures with appendix are employed in the\n  \
    \ signature schemes and are specified here: EMSA-PSS and EMSA-PKCS1-\n   v1_5.\n"
- title: 9.1 EMSA-PSS
  contents:
  - "9.1 EMSA-PSS\n   This encoding method is parameterized by the choice of hash\
    \ function,\n   mask generation function, and salt length.  These options should\
    \ be\n   fixed for a given RSA key, except that the salt length can be\n   variable\
    \ (see [31] for discussion).  Suggested hash and mask\n   generation functions\
    \ are given in Appendix B.  The encoding method is\n   based on Bellare and Rogaway's\
    \ Probabilistic Signature Scheme (PSS)\n   [4][5].  It is randomized and has an\
    \ encoding operation and a\n   verification operation.\n   Figure 2 illustrates\
    \ the encoding operation.\n   __________________________________________________________________\n\
    \                                  +-----------+\n                           \
    \       |     M     |\n                                  +-----------+\n     \
    \                                   |\n                                      \
    \  V\n                                      Hash\n                           \
    \             |\n                                        V\n                 \
    \         +--------+----------+----------+\n                     M' = |Padding1|\
    \  mHash   |   salt   |\n                          +--------+----------+----------+\n\
    \                                         |\n               +--------+----------+\
    \     V\n         DB =  |Padding2|maskedseed|   Hash\n               +--------+----------+\
    \     |\n                         |               |\n                        \
    \ V               |    +--+\n                        xor <--- MGF <---|    |bc|\n\
    \                         |               |    +--+\n                        \
    \ |               |      |\n                         V               V      V\n\
    \               +-------------------+----------+--+\n         EM =  |    maskedDB\
    \       |maskedseed|bc|\n               +-------------------+----------+--+\n\
    \   __________________________________________________________________\n   Figure\
    \ 2: EMSA-PSS encoding operation.  Verification operation\n   follows reverse\
    \ steps to recover salt, then forward steps to\n   recompute and compare H.\n\
    \   Notes.\n   1. The encoding method defined here differs from the one in Bellare\n\
    \      and Rogaway's submission to IEEE P1363a [5] in three respects:\n      *\
    \  It applies a hash function rather than a mask generation\n         function\
    \ to the message.  Even though the mask generation\n         function is based\
    \ on a hash function, it seems more natural to\n         apply a hash function\
    \ directly.\n      *  The value that is hashed together with the salt value is\
    \ the\n         string (0x)00 00 00 00 00 00 00 00 || mHash rather than the\n\
    \         message M itself.  Here, mHash is the hash of M.  Note that the\n  \
    \       hash function is the same in both steps.  See Note 3 below for\n     \
    \    further discussion.  (Also, the name \"salt\" is used instead of\n      \
    \   \"seed\", as it is more reflective of the value's role.)\n      *  The encoded\
    \ message in EMSA-PSS has nine fixed bits; the first\n         bit is 0 and the\
    \ last eight bits form a \"trailer field\", the\n         octet 0xbc.  In the\
    \ original scheme, only the first bit is\n         fixed.  The rationale for the\
    \ trailer field is for\n         compatibility with the Rabin-Williams IFSP-RW\
    \ signature\n         primitive in IEEE Std 1363-2000 [26] and the corresponding\n\
    \         primitive in the draft ISO/IEC 9796-2 [29].\n   2. Assuming that the\
    \ mask generation function is based on a hash\n      function, it is recommended\
    \ that the hash function be the same as\n      the one that is applied to the\
    \ message; see Section 8.1 for\n      further discussion.\n   3. Without compromising\
    \ the security proof for RSASSA-PSS, one may\n      perform steps 1 and 2 of EMSA-PSS-ENCODE\
    \ and EMSA-PSS-VERIFY (the\n      application of the hash function to the message)\
    \ outside the\n      module that computes the rest of the signature operation,\
    \ so that\n      mHash rather than the message M itself is input to the module.\
    \  In\n      other words, the security proof for RSASSA-PSS still holds even if\n\
    \      an opponent can control the value of mHash.  This is convenient if\n  \
    \    the module has limited I/O bandwidth, e.g., a smart card.  Note\n      that\
    \ previous versions of PSS [4][5] did not have this property.\n      Of course,\
    \ it may be desirable for other security reasons to have\n      the module process\
    \ the full message.  For instance, the module may\n      need to \"see\" what\
    \ it is signing if it does not trust the\n      component that computes the hash\
    \ value.\n   4. Typical salt lengths in octets are hLen (the length of the output\n\
    \      of the hash function Hash) and 0.  In both cases the security of\n    \
    \  RSASSA-PSS can be closely related to the hardness of inverting\n      RSAVP1.\
    \  Bellare and Rogaway [4] give a tight lower bound for the\n      security of\
    \ the original RSA-PSS scheme, which corresponds roughly\n      to the former\
    \ case, while Coron [12] gives a lower bound for the\n      related Full Domain\
    \ Hashing scheme, which corresponds roughly to\n      the latter case.  In [13]\
    \ Coron provides a general treatment with\n      various salt lengths ranging\
    \ from 0 to hLen; see [27] for\n      discussion.  See also [31], which adapts\
    \ the security proofs in\n      [4][13] to address the differences between the\
    \ original and the\n      present version of RSA-PSS as listed in Note 1 above.\n\
    \   5. As noted in IEEE P1363a [27], the use of randomization in\n      signature\
    \ schemes - such as the salt value in EMSA-PSS - may\n      provide a \"covert\
    \ channel\" for transmitting information other than\n      the message being signed.\
    \  For more on covert channels, see [50].\n"
- title: 9.1.1 Encoding operation
  contents:
  - "9.1.1 Encoding operation\n   EMSA-PSS-ENCODE (M, emBits)\n   Options:\n   Hash\
    \     hash function (hLen denotes the length in octets of the hash\n         \
    \   function output)\n   MGF      mask generation function\n   sLen     intended\
    \ length in octets of the salt\n   Input:\n   M        message to be encoded,\
    \ an octet string\n   emBits   maximal bit length of the integer OS2IP (EM) (see\
    \ Section\n            4.2), at least 8hLen + 8sLen + 9\n   Output:\n   EM   \
    \    encoded message, an octet string of length emLen = \\ceil\n            (emBits/8)\n\
    \   Errors:  \"encoding error\"; \"message too long\"\n   Steps:\n   1.  If the\
    \ length of M is greater than the input limitation for the\n       hash function\
    \ (2^61 - 1 octets for SHA-1), output \"message too\n       long\" and stop.\n\
    \   2.  Let mHash = Hash(M), an octet string of length hLen.\n   3.  If emLen\
    \ < hLen + sLen + 2, output \"encoding error\" and stop.\n   4.  Generate a random\
    \ octet string salt of length sLen; if sLen = 0,\n       then salt is the empty\
    \ string.\n   5.  Let\n         M' = (0x)00 00 00 00 00 00 00 00 || mHash || salt;\n\
    \       M' is an octet string of length 8 + hLen + sLen with eight\n       initial\
    \ zero octets.\n   6.  Let H = Hash(M'), an octet string of length hLen.\n   7.\
    \  Generate an octet string PS consisting of emLen - sLen - hLen - 2\n       zero\
    \ octets.  The length of PS may be 0.\n   8.  Let DB = PS || 0x01 || salt; DB\
    \ is an octet string of length\n       emLen - hLen - 1.\n   9.  Let dbMask =\
    \ MGF(H, emLen - hLen - 1).\n   10. Let maskedDB = DB \\xor dbMask.\n   11. Set\
    \ the leftmost 8emLen - emBits bits of the leftmost octet in\n       maskedDB\
    \ to zero.\n   12. Let EM = maskedDB || H || 0xbc.\n   13. Output EM.\n"
- title: 9.1.2 Verification operation
  contents:
  - "9.1.2 Verification operation\n   EMSA-PSS-VERIFY (M, EM, emBits)\n   Options:\n\
    \   Hash     hash function (hLen denotes the length in octets of the hash\n  \
    \          function output)\n   MGF      mask generation function\n   sLen   \
    \  intended length in octets of the salt\n   Input:\n   M        message to be\
    \ verified, an octet string\n   EM       encoded message, an octet string of length\
    \ emLen = \\ceil\n            (emBits/8)\n   emBits   maximal bit length of the\
    \ integer OS2IP (EM) (see Section\n            4.2), at least 8hLen + 8sLen +\
    \ 9\n   Output:\n   \"consistent\" or \"inconsistent\"\n   Steps:\n   1.  If the\
    \ length of M is greater than the input limitation for the\n       hash function\
    \ (2^61 - 1 octets for SHA-1), output \"inconsistent\"\n       and stop.\n   2.\
    \  Let mHash = Hash(M), an octet string of length hLen.\n   3.  If emLen < hLen\
    \ + sLen + 2, output \"inconsistent\" and stop.\n   4.  If the rightmost octet\
    \ of EM does not have hexadecimal value\n       0xbc, output \"inconsistent\"\
    \ and stop.\n   5.  Let maskedDB be the leftmost emLen - hLen - 1 octets of EM,\
    \ and\n       let H be the next hLen octets.\n   6.  If the leftmost 8emLen -\
    \ emBits bits of the leftmost octet in\n       maskedDB are not all equal to zero,\
    \ output \"inconsistent\" and\n       stop.\n   7.  Let dbMask = MGF(H, emLen\
    \ - hLen - 1).\n   8.  Let DB = maskedDB \\xor dbMask.\n   9.  Set the leftmost\
    \ 8emLen - emBits bits of the leftmost octet in DB\n       to zero.\n   10. If\
    \ the emLen - hLen - sLen - 2 leftmost octets of DB are not zero\n       or if\
    \ the octet at position emLen - hLen - sLen - 1 (the leftmost\n       position\
    \ is \"position 1\") does not have hexadecimal value 0x01,\n       output \"inconsistent\"\
    \ and stop.\n   11.  Let salt be the last sLen octets of DB.\n   12.  Let\n  \
    \          M' = (0x)00 00 00 00 00 00 00 00 || mHash || salt ;\n       M' is an\
    \ octet string of length 8 + hLen + sLen with eight\n       initial zero octets.\n\
    \   13. Let H' = Hash(M'), an octet string of length hLen.\n   14. If H = H',\
    \ output \"consistent.\" Otherwise, output \"inconsistent.\"\n"
- title: 9.2 EMSA-PKCS1-v1_5
  contents:
  - "9.2 EMSA-PKCS1-v1_5\n   This encoding method is deterministic and only has an\
    \ encoding\n   operation.\n   EMSA-PKCS1-v1_5-ENCODE (M, emLen)\n   Option:\n\
    \   Hash     hash function (hLen denotes the length in octets of the hash\n  \
    \          function output)\n   Input:\n   M        message to be encoded\n  \
    \ emLen    intended length in octets of the encoded message, at least\n      \
    \      tLen + 11, where tLen is the octet length of the DER\n            encoding\
    \ T of a certain value computed during the encoding\n            operation\n \
    \  Output:\n   EM       encoded message, an octet string of length emLen\n   Errors:\n\
    \   \"message too long\"; \"intended encoded message length too short\"\n   Steps:\n\
    \   1. Apply the hash function to the message M to produce a hash value\n    \
    \  H:\n         H = Hash(M).\n      If the hash function outputs \"message too\
    \ long,\" output \"message\n      too long\" and stop.\n   2. Encode the algorithm\
    \ ID for the hash function and the hash value\n      into an ASN.1 value of type\
    \ DigestInfo (see Appendix A.2.4) with\n      the Distinguished Encoding Rules\
    \ (DER), where the type DigestInfo\n      has the syntax\n      DigestInfo ::=\
    \ SEQUENCE {\n          digestAlgorithm AlgorithmIdentifier,\n          digest\
    \ OCTET STRING\n      }\n      The first field identifies the hash function and\
    \ the second\n      contains the hash value.  Let T be the DER encoding of the\n\
    \      DigestInfo value (see the notes below) and let tLen be the length\n   \
    \   in octets of T.\n   3. If emLen < tLen + 11, output \"intended encoded message\
    \ length too\n      short\" and stop.\n   4. Generate an octet string PS consisting\
    \ of emLen - tLen - 3 octets\n      with hexadecimal value 0xff.  The length of\
    \ PS will be at least 8\n      octets.\n   5. Concatenate PS, the DER encoding\
    \ T, and other padding to form the\n      encoded message EM as\n         EM =\
    \ 0x00 || 0x01 || PS || 0x00 || T.\n   6. Output EM.\n   Notes.\n   1. For the\
    \ six hash functions mentioned in Appendix B.1, the DER\n      encoding T of the\
    \ DigestInfo value is equal to the following:\n      MD2:     (0x)30 20 30 0c\
    \ 06 08 2a 86 48 86 f7 0d 02 02 05 00 04\n                   10 || H.\n      MD5:\
    \     (0x)30 20 30 0c 06 08 2a 86 48 86 f7 0d 02 05 05 00 04\n               \
    \    10 || H.\n      SHA-1:   (0x)30 21 30 09 06 05 2b 0e 03 02 1a 05 00 04 14\
    \ || H.\n      SHA-256: (0x)30 31 30 0d 06 09 60 86 48 01 65 03 04 02 01 05 00\n\
    \                   04 20 || H.\n      SHA-384: (0x)30 41 30 0d 06 09 60 86 48\
    \ 01 65 03 04 02 02 05 00\n                   04 30 || H.\n      SHA-512: (0x)30\
    \ 51 30 0d 06 09 60 86 48 01 65 03 04 02 03 05 00\n                      04 40\
    \ || H.\n   2. In version 1.5 of this document, T was defined as the BER\n   \
    \   encoding, rather than the DER encoding, of the DigestInfo value.\n      In\
    \ particular, it is possible - at least in theory - that the\n      verification\
    \ operation defined in this document (as well as in\n      version 2.0) rejects\
    \ a signature that is valid with respect to the\n      specification given in\
    \ PKCS #1 v1.5.  This occurs if other rules\n      than DER are applied to DigestInfo\
    \ (e.g., an indefinite length\n      encoding of the underlying SEQUENCE type).\
    \  While this is unlikely\n      to be a concern in practice, a cautious implementer\
    \ may choose to\n      employ a verification operation based on a BER decoding\
    \ operation\n      as specified in PKCS #1 v1.5.  In this manner, compatibility\
    \ with\n      any valid implementation based on PKCS #1 v1.5 is obtained.  Such\n\
    \      a verification operation should indicate whether the underlying\n     \
    \ BER encoding is a DER encoding and hence whether the signature is\n      valid\
    \ with respect to the specification given in this document.\n"
- title: Appendix A. ASN.1 syntax
  contents:
  - 'Appendix A. ASN.1 syntax

    '
- title: A.1 RSA key representation
  contents:
  - "A.1 RSA key representation\n   This section defines ASN.1 object identifiers\
    \ for RSA public and\n   private keys, and defines the types RSAPublicKey and\
    \ RSAPrivateKey.\n   The intended application of these definitions includes X.509\n\
    \   certificates, PKCS #8 [46], and PKCS #12 [47].\n   The object identifier rsaEncryption\
    \ identifies RSA public and private\n   keys as defined in Appendices A.1.1 and\
    \ A.1.2.  The parameters field\n   associated with this OID in a value of type\
    \ AlgorithmIdentifier shall\n   have a value of type NULL.\n   rsaEncryption \
    \   OBJECT IDENTIFIER ::= { pkcs-1 1 }\n   The definitions in this section have\
    \ been extended to support multi-\n   prime RSA, but are backward compatible with\
    \ previous versions.\n"
- title: A.1.1 RSA public key syntax
  contents:
  - "A.1.1 RSA public key syntax\n   An RSA public key should be represented with\
    \ the ASN.1 type\n   RSAPublicKey:\n      RSAPublicKey ::= SEQUENCE {\n      \
    \    modulus           INTEGER,  -- n\n          publicExponent    INTEGER   --\
    \ e\n      }\n   The fields of type RSAPublicKey have the following meanings:\n\
    \    * modulus is the RSA modulus n.\n    * publicExponent is the RSA public exponent\
    \ e.\n"
- title: A.1.2 RSA private key syntax
  contents:
  - "A.1.2 RSA private key syntax\n   An RSA private key should be represented with\
    \ the ASN.1 type\n   RSAPrivateKey:\n      RSAPrivateKey ::= SEQUENCE {\n    \
    \      version           Version,\n          modulus           INTEGER,  -- n\n\
    \          publicExponent    INTEGER,  -- e\n          privateExponent   INTEGER,\
    \  -- d\n          prime1            INTEGER,  -- p\n          prime2        \
    \    INTEGER,  -- q\n          exponent1         INTEGER,  -- d mod (p-1)\n  \
    \        exponent2         INTEGER,  -- d mod (q-1)\n          coefficient   \
    \    INTEGER,  -- (inverse of q) mod p\n          otherPrimeInfos   OtherPrimeInfos\
    \ OPTIONAL\n      }\n   The fields of type RSAPrivateKey have the following meanings:\n\
    \    * version is the version number, for compatibility with future\n      revisions\
    \ of this document.  It shall be 0 for this version of the\n      document, unless\
    \ multi-prime is used, in which case it shall be 1.\n            Version ::= INTEGER\
    \ { two-prime(0), multi(1) }\n               (CONSTRAINED BY\n               {--\
    \ version must be multi if otherPrimeInfos present --})\n    * modulus is the\
    \ RSA modulus n.\n    * publicExponent is the RSA public exponent e.\n    * privateExponent\
    \ is the RSA private exponent d.\n    * prime1 is the prime factor p of n.\n \
    \   * prime2 is the prime factor q of n.\n    * exponent1 is d mod (p - 1).\n\
    \    * exponent2 is d mod (q - 1).\n    * coefficient is the CRT coefficient q^(-1)\
    \ mod p.\n    * otherPrimeInfos contains the information for the additional primes\n\
    \      r_3, ..., r_u, in order.  It shall be omitted if version is 0 and\n   \
    \   shall contain at least one instance of OtherPrimeInfo if version\n      is\
    \ 1.\n         OtherPrimeInfos ::= SEQUENCE SIZE(1..MAX) OF OtherPrimeInfo\n \
    \        OtherPrimeInfo ::= SEQUENCE {\n             prime             INTEGER,\
    \  -- ri\n             exponent          INTEGER,  -- di\n             coefficient\
    \       INTEGER   -- ti\n         }\n   The fields of type OtherPrimeInfo have\
    \ the following meanings:\n    * prime is a prime factor r_i of n, where i >=\
    \ 3.\n    * exponent is d_i = d mod (r_i - 1).\n    * coefficient is the CRT coefficient\
    \ t_i = (r_1 * r_2 * ... * r_(i-\n      1))^(-1) mod r_i.\n   Note.  It is important\
    \ to protect the RSA private key against both\n   disclosure and modification.\
    \  Techniques for such protection are\n   outside the scope of this document.\
    \  Methods for storing and\n   distributing private keys and other cryptographic\
    \ data are described\n   in PKCS #12 and #15.\n"
- title: A.2 Scheme identification
  contents:
  - "A.2 Scheme identification\n   This section defines object identifiers for the\
    \ encryption and\n   signature schemes.  The schemes compatible with PKCS #1 v1.5\
    \ have the\n   same definitions as in PKCS #1 v1.5.  The intended application\
    \ of\n   these definitions includes X.509 certificates and PKCS #7.\n   Here are\
    \ type identifier definitions for the PKCS #1 OIDs:\n      PKCS1Algorithms   \
    \ ALGORITHM-IDENTIFIER ::= {\n          { OID rsaEncryption              PARAMETERS\
    \ NULL } |\n          { OID md2WithRSAEncryption       PARAMETERS NULL } |\n \
    \         { OID md5WithRSAEncryption       PARAMETERS NULL } |\n          { OID\
    \ sha1WithRSAEncryption      PARAMETERS NULL } |\n          { OID sha256WithRSAEncryption\
    \    PARAMETERS NULL } |\n          { OID sha384WithRSAEncryption    PARAMETERS\
    \ NULL } |\n          { OID sha512WithRSAEncryption    PARAMETERS NULL } |\n \
    \         { OID id-RSAES-OAEP PARAMETERS RSAES-OAEP-params } |\n          PKCS1PSourceAlgorithms\
    \                             |\n          { OID id-RSASSA-PSS PARAMETERS RSASSA-PSS-params\
    \ } ,\n          ...  -- Allows for future expansion --\n      }\n"
- title: A.2.1 RSAES-OAEP
  contents:
  - "A.2.1 RSAES-OAEP\n   The object identifier id-RSAES-OAEP identifies the RSAES-OAEP\n\
    \   encryption scheme.\n      id-RSAES-OAEP    OBJECT IDENTIFIER ::= { pkcs-1\
    \ 7 }\n   The parameters field associated with this OID in a value of type\n \
    \  AlgorithmIdentifier shall have a value of type RSAES-OAEP-params:\n      RSAES-OAEP-params\
    \ ::= SEQUENCE {\n          hashAlgorithm     [0] HashAlgorithm    DEFAULT sha1,\n\
    \          maskGenAlgorithm  [1] MaskGenAlgorithm DEFAULT mgf1SHA1,\n        \
    \  pSourceAlgorithm  [2] PSourceAlgorithm DEFAULT pSpecifiedEmpty\n      }\n \
    \  The fields of type RSAES-OAEP-params have the following meanings:\n    * hashAlgorithm\
    \ identifies the hash function.  It shall be an\n      algorithm ID with an OID\
    \ in the set OAEP-PSSDigestAlgorithms.\n      For a discussion of supported hash\
    \ functions, see Appendix B.1.\n         HashAlgorithm ::= AlgorithmIdentifier\
    \ {\n            {OAEP-PSSDigestAlgorithms}\n         }\n         OAEP-PSSDigestAlgorithms\
    \    ALGORITHM-IDENTIFIER ::= {\n             { OID id-sha1 PARAMETERS NULL  \
    \ }|\n             { OID id-sha256 PARAMETERS NULL }|\n             { OID id-sha384\
    \ PARAMETERS NULL }|\n             { OID id-sha512 PARAMETERS NULL },\n      \
    \       ...  -- Allows for future expansion --\n         }\n      The default\
    \ hash function is SHA-1:\n         sha1    HashAlgorithm ::= {\n            \
    \ algorithm   id-sha1,\n             parameters  SHA1Parameters : NULL\n     \
    \    }\n         SHA1Parameters ::= NULL\n    * maskGenAlgorithm identifies the\
    \ mask generation function.  It\n      shall be an algorithm ID with an OID in\
    \ the set\n      PKCS1MGFAlgorithms, which for this version shall consist of\n\
    \      id-mgf1, identifying the MGF1 mask generation function (see\n      Appendix\
    \ B.2.1).  The parameters field associated with id-mgf1\n      shall be an algorithm\
    \ ID with an OID in the set\n      OAEP-PSSDigestAlgorithms, identifying the hash\
    \ function on which\n      MGF1 is based.\n         MaskGenAlgorithm ::= AlgorithmIdentifier\
    \ {\n            {PKCS1MGFAlgorithms}\n         }\n         PKCS1MGFAlgorithms\
    \    ALGORITHM-IDENTIFIER ::= {\n             { OID id-mgf1 PARAMETERS HashAlgorithm\
    \ },\n             ...  -- Allows for future expansion --\n         }\n      The\
    \ default mask generation function is MGF1 with SHA-1:\n         mgf1SHA1    MaskGenAlgorithm\
    \ ::= {\n             algorithm   id-mgf1,\n             parameters  HashAlgorithm\
    \ : sha1\n         }\n    * pSourceAlgorithm identifies the source (and possibly\
    \ the value)\n      of the label L.  It shall be an algorithm ID with an OID in\
    \ the\n      set PKCS1PSourceAlgorithms, which for this version shall consist\n\
    \      of id-pSpecified, indicating that the label is specified\n      explicitly.\
    \  The parameters field associated with id-pSpecified\n      shall have a value\
    \ of type OCTET STRING, containing the\n      label.  In previous versions of\
    \ this specification, the term\n      \"encoding parameters\" was used rather\
    \ than \"label\", hence the\n      name of the type below.\n         PSourceAlgorithm\
    \ ::= AlgorithmIdentifier {\n            {PKCS1PSourceAlgorithms}\n         }\n\
    \         PKCS1PSourceAlgorithms    ALGORITHM-IDENTIFIER ::= {\n             {\
    \ OID id-pSpecified PARAMETERS EncodingParameters },\n             ...  -- Allows\
    \ for future expansion --\n         }\n         id-pSpecified    OBJECT IDENTIFIER\
    \ ::= { pkcs-1 9 }\n         EncodingParameters ::= OCTET STRING(SIZE(0..MAX))\n\
    \      The default label is an empty string (so that lHash will contain\n    \
    \  the hash of the empty string):\n         pSpecifiedEmpty    PSourceAlgorithm\
    \ ::= {\n             algorithm   id-pSpecified,\n             parameters  EncodingParameters\
    \ : emptyString\n         }\n         emptyString    EncodingParameters ::= ''H\n\
    \      If all of the default values of the fields in RSAES-OAEP-params\n     \
    \ are used, then the algorithm identifier will have the following\n      value:\n\
    \         rSAES-OAEP-Default-Identifier  RSAES-AlgorithmIdentifier ::= {\n   \
    \          algorithm   id-RSAES-OAEP,\n             parameters  RSAES-OAEP-params\
    \ : {\n                 hashAlgorithm       sha1,\n                 maskGenAlgorithm\
    \    mgf1SHA1,\n                 pSourceAlgorithm    pSpecifiedEmpty\n       \
    \      }\n         }\n         RSAES-AlgorithmIdentifier ::= AlgorithmIdentifier\
    \ {\n            {PKCS1Algorithms}\n         }\n"
- title: A.2.2 RSAES-PKCS1-v1_5
  contents:
  - "A.2.2 RSAES-PKCS1-v1_5\n   The object identifier rsaEncryption (see Appendix\
    \ A.1) identifies the\n   RSAES-PKCS1-v1_5 encryption scheme.  The parameters\
    \ field associated\n   with this OID in a value of type AlgorithmIdentifier shall\
    \ have a\n   value of type NULL.  This is the same as in PKCS #1 v1.5.\n     \
    \ rsaEncryption    OBJECT IDENTIFIER ::= { pkcs-1 1 }\n"
- title: A.2.3 RSASSA-PSS
  contents:
  - "A.2.3 RSASSA-PSS\n   The object identifier id-RSASSA-PSS identifies the RSASSA-PSS\n\
    \   encryption scheme.\n      id-RSASSA-PSS    OBJECT IDENTIFIER ::= { pkcs-1\
    \ 10 }\n   The parameters field associated with this OID in a value of type\n\
    \   AlgorithmIdentifier shall have a value of type RSASSA-PSS-params:\n      RSASSA-PSS-params\
    \ ::= SEQUENCE {\n          hashAlgorithm      [0] HashAlgorithm    DEFAULT sha1,\n\
    \          maskGenAlgorithm   [1] MaskGenAlgorithm DEFAULT mgf1SHA1,\n       \
    \   saltLength         [2] INTEGER          DEFAULT 20,\n          trailerField\
    \       [3] TrailerField     DEFAULT trailerFieldBC\n      }\n   The fields of\
    \ type RSASSA-PSS-params have the following meanings:\n    * hashAlgorithm identifies\
    \ the hash function.  It shall be an\n      algorithm ID with an OID in the set\
    \ OAEP-PSSDigestAlgorithms (see\n      Appendix A.2.1).  The default hash function\
    \ is SHA-1.\n    * maskGenAlgorithm identifies the mask generation function. \
    \ It\n      shall be an algorithm ID with an OID in the set\n      PKCS1MGFAlgorithms\
    \ (see Appendix A.2.1).  The default mask\n      generation function is MGF1 with\
    \ SHA-1.  For MGF1 (and more\n      generally, for other mask generation functions\
    \ based on a hash\n      function), it is recommended that the underlying hash\
    \ function be\n      the same as the one identified by hashAlgorithm; see Note\
    \ 2 in\n      Section 9.1 for further comments.\n    * saltLength is the octet\
    \ length of the salt.  It shall be an\n      integer.  For a given hashAlgorithm,\
    \ the default value of\n      saltLength is the octet length of the hash value.\
    \  Unlike the\n      other fields of type RSASSA-PSS-params, saltLength does not\
    \ need\n      to be fixed for a given RSA key pair.\n    * trailerField is the\
    \ trailer field number, for compatibility with\n      the draft IEEE P1363a [27].\
    \  It shall be 1 for this version of the\n      document, which represents the\
    \ trailer field with hexadecimal\n      value 0xbc.  Other trailer fields (including\
    \ the trailer field\n      HashID || 0xcc in IEEE P1363a) are not supported in\
    \ this document.\n         TrailerField ::= INTEGER { trailerFieldBC(1) }\n  \
    \    If the default values of the hashAlgorithm, maskGenAlgorithm, and\n     \
    \ trailerField fields of RSASSA-PSS-params are used, then the\n      algorithm\
    \ identifier will have the following value:\n         rSASSA-PSS-Default-Identifier\
    \  RSASSA-AlgorithmIdentifier ::= {\n             algorithm   id-RSASSA-PSS,\n\
    \             parameters  RSASSA-PSS-params : {\n                 hashAlgorithm\
    \       sha1,\n                 maskGenAlgorithm    mgf1SHA1,\n              \
    \   saltLength          20,\n                 trailerField        trailerFieldBC\n\
    \             }\n         }\n         RSASSA-AlgorithmIdentifier ::=\n       \
    \      AlgorithmIdentifier { {PKCS1Algorithms} }\n   Note.  In some applications,\
    \ the hash function underlying a signature\n   scheme is identified separately\
    \ from the rest of the operations in\n   the signature scheme.  For instance,\
    \ in PKCS #7 [45], a hash function\n   identifier is placed before the message\
    \ and a \"digest encryption\"\n   algorithm identifier (indicating the rest of\
    \ the operations) is\n   carried with the signature.  In order for PKCS #7 to\
    \ support the\n   RSASSA-PSS signature scheme, an object identifier would need\
    \ to be\n   defined for the operations in RSASSA-PSS after the hash function\n\
    \   (analogous to the RSAEncryption OID for the RSASSA-PKCS1-v1_5\n   scheme).\
    \  S/MIME CMS [25] takes a different approach.  Although a\n   hash function identifier\
    \ is placed before the message, an algorithm\n   identifier for the full signature\
    \ scheme may be carried with a CMS\n   signature (this is done for DSA signatures).\
    \  Following this\n   convention, the id-RSASSA-PSS OID can be used to identify\
    \ RSASSA-PSS\n   signatures in CMS.  Since CMS is considered the successor to\
    \ PKCS #7\n   and new developments such as the addition of support for RSASSA-PSS\n\
    \   will be pursued with respect to CMS rather than PKCS #7, an OID for\n   the\
    \ \"rest of\" RSASSA-PSS is not defined in this version of PKCS #1.\n"
- title: A.2.4 RSASSA-PKCS1-v1_5
  contents:
  - "A.2.4 RSASSA-PKCS1-v1_5\n   The object identifier for RSASSA-PKCS1-v1_5 shall\
    \ be one of the\n   following.  The choice of OID depends on the choice of hash\n\
    \   algorithm: MD2, MD5, SHA-1, SHA-256, SHA-384, or SHA-512.  Note that\n   if\
    \ either MD2 or MD5 is used, then the OID is just as in PKCS #1\n   v1.5.  For\
    \ each OID, the parameters field associated with this OID in\n   a value of type\
    \ AlgorithmIdentifier shall have a value of type NULL.\n   The OID should be chosen\
    \ in accordance with the following table:\n      Hash algorithm   OID\n      --------------------------------------------------------\n\
    \      MD2              md2WithRSAEncryption    ::= {pkcs-1 2}\n      MD5    \
    \          md5WithRSAEncryption    ::= {pkcs-1 4}\n      SHA-1            sha1WithRSAEncryption\
    \   ::= {pkcs-1 5}\n      SHA-256          sha256WithRSAEncryption ::= {pkcs-1\
    \ 11}\n      SHA-384          sha384WithRSAEncryption ::= {pkcs-1 12}\n      SHA-512\
    \          sha512WithRSAEncryption ::= {pkcs-1 13}\n   The EMSA-PKCS1-v1_5 encoding\
    \ method includes an ASN.1 value of type\n   DigestInfo, where the type DigestInfo\
    \ has the syntax\n      DigestInfo ::= SEQUENCE {\n          digestAlgorithm DigestAlgorithm,\n\
    \          digest OCTET STRING\n      }\n   digestAlgorithm identifies the hash\
    \ function and shall be an\n   algorithm ID with an OID in the set PKCS1-v1-5DigestAlgorithms.\
    \  For\n   a discussion of supported hash functions, see Appendix B.1.\n     \
    \ DigestAlgorithm ::=\n          AlgorithmIdentifier { {PKCS1-v1-5DigestAlgorithms}\
    \ }\n      PKCS1-v1-5DigestAlgorithms    ALGORITHM-IDENTIFIER ::= {\n        \
    \  { OID id-md2 PARAMETERS NULL    }|\n          { OID id-md5 PARAMETERS NULL\
    \    }|\n          { OID id-sha1 PARAMETERS NULL   }|\n          { OID id-sha256\
    \ PARAMETERS NULL }|\n          { OID id-sha384 PARAMETERS NULL }|\n         \
    \ { OID id-sha512 PARAMETERS NULL }\n      }\n"
- title: Appendix B. Supporting techniques
  contents:
  - "Appendix B. Supporting techniques\n   This section gives several examples of\
    \ underlying functions\n   supporting the encryption schemes in Section 7 and\
    \ the encoding\n   methods in Section 9.  A range of techniques is given here\
    \ to allow\n   compatibility with existing applications as well as migration to\
    \ new\n   techniques.  While these supporting techniques are appropriate for\n\
    \   applications to implement, none of them is required to be\n   implemented.\
    \  It is expected that profiles for PKCS #1 v2.1 will be\n   developed that specify\
    \ particular supporting techniques.\n   This section also gives object identifiers\
    \ for the supporting\n   techniques.\n"
- title: B.1 Hash functions
  contents:
  - "B.1 Hash functions\n   Hash functions are used in the operations contained in\
    \ Sections 7 and\n   9.  Hash functions are deterministic, meaning that the output\
    \ is\n   completely determined by the input.  Hash functions take octet\n   strings\
    \ of variable length, and generate fixed length octet strings.\n   The hash functions\
    \ used in the operations contained in Sections 7 and\n   9 should generally be\
    \ collision-resistant.  This means that it is\n   infeasible to find two distinct\
    \ inputs to the hash function that\n   produce the same output.  A collision-resistant\
    \ hash function also\n   has the desirable property of being one-way; this means\
    \ that given an\n   output, it is infeasible to find an input whose hash is the\
    \ specified\n   output.  In addition to the requirements, the hash function should\n\
    \   yield a mask generation function (Appendix B.2) with pseudorandom\n   output.\n\
    \   Six hash functions are given as examples for the encoding methods in\n   this\
    \ document: MD2 [33], MD5 [41], SHA-1 [38], and the proposed\n   algorithms SHA-256,\
    \ SHA-384, and SHA-512 [39].  For the RSAES-OAEP\n   encryption scheme and EMSA-PSS\
    \ encoding method, only SHA-1 and SHA-\n   256/384/512 are recommended.  For the\
    \ EMSA-PKCS1-v1_5 encoding\n   method, SHA-1 or SHA-256/384/512 are recommended\
    \ for new\n   applications.  MD2 and MD5 are recommended only for compatibility\n\
    \   with existing applications based on PKCS #1 v1.5.\n   The object identifiers\
    \ id-md2, id-md5, id-sha1, id-sha256, id-sha384,\n   and id-sha512, identify the\
    \ respective hash functions:\n      id-md2      OBJECT IDENTIFIER ::= {\n    \
    \      iso(1) member-body(2) us(840) rsadsi(113549)\n          digestAlgorithm(2)\
    \ 2\n      }\n      id-md5      OBJECT IDENTIFIER ::= {\n          iso(1) member-body(2)\
    \ us(840) rsadsi(113549)\n          digestAlgorithm(2) 5\n      }\n      id-sha1\
    \    OBJECT IDENTIFIER ::= {\n          iso(1) identified-organization(3) oiw(14)\
    \ secsig(3)\n          algorithms(2) 26\n      }\n      id-sha256    OBJECT IDENTIFIER\
    \ ::= {\n          joint-iso-itu-t(2) country(16) us(840) organization(1)\n  \
    \        gov(101) csor(3) nistalgorithm(4) hashalgs(2) 1\n      }\n      id-sha384\
    \    OBJECT IDENTIFIER ::= {\n          joint-iso-itu-t(2) country(16) us(840)\
    \ organization(1)\n          gov(101) csor(3) nistalgorithm(4) hashalgs(2) 2\n\
    \      }\n      id-sha512    OBJECT IDENTIFIER ::= {\n          joint-iso-itu-t(2)\
    \ country(16) us(840) organization(1)\n          gov(101) csor(3) nistalgorithm(4)\
    \ hashalgs(2) 3\n      }\n   The parameters field associated with id-md2 and id-md5\
    \ in a value of\n   type AlgorithmIdentifier shall have a value of type NULL.\n\
    \   The parameters field associated with id-sha1, id-sha256, id-sha384,\n   and\
    \ id-sha512 should be omitted, but if present, shall have a value\n   of type\
    \ NULL.\n   Note.  Version 1.5 of PKCS #1 also allowed for the use of MD4 in\n\
    \   signature schemes.  The cryptanalysis of MD4 has progressed\n   significantly\
    \ in the intervening years.  For example, Dobbertin [18]\n   demonstrated how\
    \ to find collisions for MD4 and that the first two\n   rounds of MD4 are not\
    \ one-way [20].  Because of these results and\n   others (e.g., [8]), MD4 is no\
    \ longer recommended.  There have also\n   been advances in the cryptanalysis\
    \ of MD2 and MD5, although not\n   enough to warrant removal from existing applications.\
    \  Rogier and\n   Chauvaud [43] demonstrated how to find collisions in a modified\n\
    \   version of MD2.  No one has demonstrated how to find collisions for\n   the\
    \ full MD5 algorithm, although partial results have been found\n   (e.g., [9][19]).\n\
    \   To address these concerns, SHA-1, SHA-256, SHA-384, or SHA-512 are\n   recommended\
    \ for new applications.  As of today, the best (known)\n   collision attacks against\
    \ these hash functions are generic attacks\n   with complexity 2^(L/2), where\
    \ L is the bit length of the hash\n   output.  For the signature schemes in this\
    \ document, a collision\n   attack is easily translated into a signature forgery.\
    \  Therefore, the\n   value L / 2 should be at least equal to the desired security\
    \ level in\n   bits of the signature scheme (a security level of B bits means\
    \ that\n   the best attack has complexity 2^B).  The same rule of thumb can be\n\
    \   applied to RSAES-OAEP; it is recommended that the bit length of the\n   seed\
    \ (which is equal to the bit length of the hash output) be twice\n   the desired\
    \ security level in bits.\n"
- title: B.2 Mask generation functions
  contents:
  - "B.2 Mask generation functions\n   A mask generation function takes an octet string\
    \ of variable length\n   and a desired output length as input, and outputs an\
    \ octet string of\n   the desired length.  There may be restrictions on the length\
    \ of the\n   input and output octet strings, but such bounds are generally very\n\
    \   large.  Mask generation functions are deterministic; the octet string\n  \
    \ output is completely determined by the input octet string.  The\n   output of\
    \ a mask generation function should be pseudorandom: Given\n   one part of the\
    \ output but not the input, it should be infeasible to\n   predict another part\
    \ of the output.  The provable security of RSAES-\n   OAEP and RSASSA-PSS relies\
    \ on the random nature of the output of the\n   mask generation function, which\
    \ in turn relies on the random nature\n   of the underlying hash.\n   One mask\
    \ generation function is given here: MGF1, which is based on a\n   hash function.\
    \  MGF1 coincides with the mask generation functions\n   defined in IEEE Std 1363-2000\
    \ [26] and the draft ANSI X9.44 [1].\n   Future versions of this document may\
    \ define other mask generation\n   functions.\n"
- title: B.2.1 MGF1
  contents:
  - "B.2.1 MGF1\n   MGF1 is a Mask Generation Function based on a hash function.\n\
    \   MGF1 (mgfSeed, maskLen)\n   Options:\n   Hash     hash function (hLen denotes\
    \ the length in octets of the hash\n            function output)\n   Input:\n\
    \   mgfSeed  seed from which mask is generated, an octet string\n   maskLen  intended\
    \ length in octets of the mask, at most 2^32 hLen\n   Output:\n   mask     mask,\
    \ an octet string of length maskLen\n   Error:   \"mask too long\"\n   Steps:\n\
    \   1. If maskLen > 2^32 hLen, output \"mask too long\" and stop.\n   2. Let T\
    \ be the empty octet string.\n   3. For counter from 0 to \\ceil (maskLen / hLen)\
    \ - 1, do the\n      following:\n      a. Convert counter to an octet string C\
    \ of length 4 octets (see\n         Section 4.1):\n            C = I2OSP (counter,\
    \ 4) .\n      b. Concatenate the hash of the seed mgfSeed and C to the octet\n\
    \         string T:\n            T = T || Hash(mgfSeed || C) .\n   4. Output the\
    \ leading maskLen octets of T as the octet string mask.\n   The object identifier\
    \ id-mgf1 identifies the MGF1 mask generation\n   function:\n   id-mgf1    OBJECT\
    \ IDENTIFIER ::= { pkcs-1 8 }\n   The parameters field associated with this OID\
    \ in a value of type\n   AlgorithmIdentifier shall have a value of type hashAlgorithm,\n\
    \   identifying the hash function on which MGF1 is based.\n"
- title: Appendix C. ASN.1 module
  contents:
  - 'Appendix C. ASN.1 module

    '
- title: PKCS-1 {
  contents:
  - "PKCS-1 {\n    iso(1) member-body(2) us(840) rsadsi(113549) pkcs(1) pkcs-1(1)\n\
    \    modules(0) pkcs-1(1)\n"
- title: '}'
  contents:
  - '}

    '
- title: '-- $ Revision: 2.1r1 $'
  contents:
  - '-- $ Revision: 2.1r1 $

    '
- title: -- This module has been checked for conformance with the ASN.1
  contents:
  - '-- This module has been checked for conformance with the ASN.1

    '
- title: -- standard by the OSS ASN.1 Tools
  contents:
  - '-- standard by the OSS ASN.1 Tools

    '
- title: DEFINITIONS EXPLICIT TAGS ::=
  contents:
  - 'DEFINITIONS EXPLICIT TAGS ::=

    '
- title: BEGIN
  contents:
  - 'BEGIN

    '
- title: -- EXPORTS ALL
  contents:
  - '-- EXPORTS ALL

    '
- title: -- All types and values defined in this module are exported for use
  contents:
  - '-- All types and values defined in this module are exported for use

    '
- title: -- in other ASN.1 modules.
  contents:
  - '-- in other ASN.1 modules.

    '
- title: IMPORTS
  contents:
  - 'IMPORTS

    '
- title: id-sha256, id-sha384, id-sha512
  contents:
  - "id-sha256, id-sha384, id-sha512\n    FROM NIST-SHA2 {\n        joint-iso-itu-t(2)\
    \ country(16) us(840) organization(1)\n        gov(101) csor(3) nistalgorithm(4)\
    \ modules(0) sha2(1)\n    };\n"
- title: -- ============================
  contents:
  - '-- ============================

    '
- title: --   Basic object identifiers
  contents:
  - '--   Basic object identifiers

    '
- title: -- ============================
  contents:
  - '-- ============================

    '
- title: '-- The DER encoding of this in hexadecimal is:'
  contents:
  - '-- The DER encoding of this in hexadecimal is:

    '
- title: -- (0x)06 08
  contents:
  - '-- (0x)06 08

    '
- title: --        2A 86 48 86 F7 0D 01 01
  contents:
  - '--        2A 86 48 86 F7 0D 01 01

    '
- title: --
  contents:
  - '--

    '
- title: pkcs-1    OBJECT IDENTIFIER ::= {
  contents:
  - "pkcs-1    OBJECT IDENTIFIER ::= {\n    iso(1) member-body(2) us(840) rsadsi(113549)\
    \ pkcs(1) 1\n"
- title: '}'
  contents:
  - '}

    '
- title: --
  contents:
  - '--

    '
- title: -- When rsaEncryption is used in an AlgorithmIdentifier the
  contents:
  - '-- When rsaEncryption is used in an AlgorithmIdentifier the

    '
- title: -- parameters MUST be present and MUST be NULL.
  contents:
  - '-- parameters MUST be present and MUST be NULL.

    '
- title: --
  contents:
  - '--

    '
- title: rsaEncryption    OBJECT IDENTIFIER ::= { pkcs-1 1 }
  contents:
  - 'rsaEncryption    OBJECT IDENTIFIER ::= { pkcs-1 1 }

    '
- title: --
  contents:
  - '--

    '
- title: -- When id-RSAES-OAEP is used in an AlgorithmIdentifier the
  contents:
  - '-- When id-RSAES-OAEP is used in an AlgorithmIdentifier the

    '
- title: -- parameters MUST be present and MUST be RSAES-OAEP-params.
  contents:
  - '-- parameters MUST be present and MUST be RSAES-OAEP-params.

    '
- title: --
  contents:
  - '--

    '
- title: id-RSAES-OAEP    OBJECT IDENTIFIER ::= { pkcs-1 7 }
  contents:
  - 'id-RSAES-OAEP    OBJECT IDENTIFIER ::= { pkcs-1 7 }

    '
- title: --
  contents:
  - '--

    '
- title: -- When id-pSpecified is used in an AlgorithmIdentifier the
  contents:
  - '-- When id-pSpecified is used in an AlgorithmIdentifier the

    '
- title: -- parameters MUST be an OCTET STRING.
  contents:
  - '-- parameters MUST be an OCTET STRING.

    '
- title: --
  contents:
  - '--

    '
- title: id-pSpecified    OBJECT IDENTIFIER ::= { pkcs-1 9 }
  contents:
  - 'id-pSpecified    OBJECT IDENTIFIER ::= { pkcs-1 9 }

    '
- title: -- When id-RSASSA-PSS is used in an AlgorithmIdentifier the
  contents:
  - '-- When id-RSASSA-PSS is used in an AlgorithmIdentifier the

    '
- title: -- parameters MUST be present and MUST be RSASSA-PSS-params.
  contents:
  - '-- parameters MUST be present and MUST be RSASSA-PSS-params.

    '
- title: --
  contents:
  - '--

    '
- title: id-RSASSA-PSS    OBJECT IDENTIFIER ::= { pkcs-1 10 }
  contents:
  - 'id-RSASSA-PSS    OBJECT IDENTIFIER ::= { pkcs-1 10 }

    '
- title: --
  contents:
  - '--

    '
- title: -- When the following OIDs are used in an AlgorithmIdentifier the
  contents:
  - '-- When the following OIDs are used in an AlgorithmIdentifier the

    '
- title: -- parameters MUST be present and MUST be NULL.
  contents:
  - '-- parameters MUST be present and MUST be NULL.

    '
- title: --
  contents:
  - '--

    '
- title: md2WithRSAEncryption       OBJECT IDENTIFIER ::= { pkcs-1 2 }
  contents:
  - 'md2WithRSAEncryption       OBJECT IDENTIFIER ::= { pkcs-1 2 }

    '
- title: md5WithRSAEncryption       OBJECT IDENTIFIER ::= { pkcs-1 4 }
  contents:
  - 'md5WithRSAEncryption       OBJECT IDENTIFIER ::= { pkcs-1 4 }

    '
- title: sha1WithRSAEncryption      OBJECT IDENTIFIER ::= { pkcs-1 5 }
  contents:
  - 'sha1WithRSAEncryption      OBJECT IDENTIFIER ::= { pkcs-1 5 }

    '
- title: sha256WithRSAEncryption    OBJECT IDENTIFIER ::= { pkcs-1 11 }
  contents:
  - 'sha256WithRSAEncryption    OBJECT IDENTIFIER ::= { pkcs-1 11 }

    '
- title: sha384WithRSAEncryption    OBJECT IDENTIFIER ::= { pkcs-1 12 }
  contents:
  - 'sha384WithRSAEncryption    OBJECT IDENTIFIER ::= { pkcs-1 12 }

    '
- title: sha512WithRSAEncryption    OBJECT IDENTIFIER ::= { pkcs-1 13 }
  contents:
  - 'sha512WithRSAEncryption    OBJECT IDENTIFIER ::= { pkcs-1 13 }

    '
- title: --
  contents:
  - '--

    '
- title: -- This OID really belongs in a module with the secsig OIDs.
  contents:
  - '-- This OID really belongs in a module with the secsig OIDs.

    '
- title: --
  contents:
  - '--

    '
- title: id-sha1    OBJECT IDENTIFIER ::= {
  contents:
  - "id-sha1    OBJECT IDENTIFIER ::= {\n    iso(1) identified-organization(3) oiw(14)\
    \ secsig(3)\n    algorithms(2) 26\n"
- title: '}'
  contents:
  - '}

    '
- title: --
  contents:
  - '--

    '
- title: -- OIDs for MD2 and MD5, allowed only in EMSA-PKCS1-v1_5.
  contents:
  - '-- OIDs for MD2 and MD5, allowed only in EMSA-PKCS1-v1_5.

    '
- title: --
  contents:
  - '--

    '
- title: id-md2 OBJECT IDENTIFIER ::= {
  contents:
  - "id-md2 OBJECT IDENTIFIER ::= {\n    iso(1) member-body(2) us(840) rsadsi(113549)\
    \ digestAlgorithm(2) 2\n"
- title: '}'
  contents:
  - '}

    '
- title: id-md5 OBJECT IDENTIFIER ::= {
  contents:
  - "id-md5 OBJECT IDENTIFIER ::= {\n    iso(1) member-body(2) us(840) rsadsi(113549)\
    \ digestAlgorithm(2) 5\n"
- title: '}'
  contents:
  - '}

    '
- title: --
  contents:
  - '--

    '
- title: -- When id-mgf1 is used in an AlgorithmIdentifier the parameters MUST
  contents:
  - '-- When id-mgf1 is used in an AlgorithmIdentifier the parameters MUST

    '
- title: -- be present and MUST be a HashAlgorithm, for example sha1.
  contents:
  - '-- be present and MUST be a HashAlgorithm, for example sha1.

    '
- title: --
  contents:
  - '--

    '
- title: id-mgf1    OBJECT IDENTIFIER ::= { pkcs-1 8 }
  contents:
  - 'id-mgf1    OBJECT IDENTIFIER ::= { pkcs-1 8 }

    '
- title: -- ================
  contents:
  - '-- ================

    '
- title: --   Useful types
  contents:
  - '--   Useful types

    '
- title: -- ================
  contents:
  - '-- ================

    '
- title: ALGORITHM-IDENTIFIER ::= CLASS {
  contents:
  - "ALGORITHM-IDENTIFIER ::= CLASS {\n    &id    OBJECT IDENTIFIER  UNIQUE,\n   \
    \ &Type  OPTIONAL\n"
- title: '}'
  contents:
  - "}\n    WITH SYNTAX { OID &id [PARAMETERS &Type] }\n"
- title: --
  contents:
  - '--

    '
- title: '-- Note: the parameter InfoObjectSet in the following definitions'
  contents:
  - '-- Note: the parameter InfoObjectSet in the following definitions

    '
- title: -- allows a distinct information object set to be specified for sets
  contents:
  - '-- allows a distinct information object set to be specified for sets

    '
- title: '-- of algorithms such as:'
  contents:
  - '-- of algorithms such as:

    '
- title: -- DigestAlgorithms    ALGORITHM-IDENTIFIER ::= {
  contents:
  - '-- DigestAlgorithms    ALGORITHM-IDENTIFIER ::= {

    '
- title: --     { OID id-md2  PARAMETERS NULL }|
  contents:
  - '--     { OID id-md2  PARAMETERS NULL }|

    '
- title: --     { OID id-md5  PARAMETERS NULL }|
  contents:
  - '--     { OID id-md5  PARAMETERS NULL }|

    '
- title: --     { OID id-sha1 PARAMETERS NULL }
  contents:
  - '--     { OID id-sha1 PARAMETERS NULL }

    '
- title: -- }
  contents:
  - '-- }

    '
- title: --
  contents:
  - '--

    '
- title: AlgorithmIdentifier { ALGORITHM-IDENTIFIER:InfoObjectSet } ::=
  contents:
  - 'AlgorithmIdentifier { ALGORITHM-IDENTIFIER:InfoObjectSet } ::=

    '
- title: SEQUENCE {
  contents:
  - "SEQUENCE {\n    algorithm  ALGORITHM-IDENTIFIER.&id({InfoObjectSet}),\n    parameters\n\
    \        ALGORITHM-IDENTIFIER.&Type({InfoObjectSet}{@.algorithm})\n          \
    \  OPTIONAL\n"
- title: '}'
  contents:
  - '}

    '
- title: -- ==============
  contents:
  - '-- ==============

    '
- title: --   Algorithms
  contents:
  - '--   Algorithms

    '
- title: -- ==============
  contents:
  - '-- ==============

    '
- title: --
  contents:
  - '--

    '
- title: -- Allowed EME-OAEP and EMSA-PSS digest algorithms.
  contents:
  - '-- Allowed EME-OAEP and EMSA-PSS digest algorithms.

    '
- title: --
  contents:
  - '--

    '
- title: OAEP-PSSDigestAlgorithms    ALGORITHM-IDENTIFIER ::= {
  contents:
  - "OAEP-PSSDigestAlgorithms    ALGORITHM-IDENTIFIER ::= {\n    { OID id-sha1 PARAMETERS\
    \ NULL   }|\n    { OID id-sha256 PARAMETERS NULL }|\n    { OID id-sha384 PARAMETERS\
    \ NULL }|\n    { OID id-sha512 PARAMETERS NULL },\n    ...  -- Allows for future\
    \ expansion --\n"
- title: '}'
  contents:
  - '}

    '
- title: --
  contents:
  - '--

    '
- title: -- Allowed EMSA-PKCS1-v1_5 digest algorithms.
  contents:
  - '-- Allowed EMSA-PKCS1-v1_5 digest algorithms.

    '
- title: --
  contents:
  - '--

    '
- title: PKCS1-v1-5DigestAlgorithms    ALGORITHM-IDENTIFIER ::= {
  contents:
  - "PKCS1-v1-5DigestAlgorithms    ALGORITHM-IDENTIFIER ::= {\n    { OID id-md2 PARAMETERS\
    \ NULL    }|\n    { OID id-md5 PARAMETERS NULL    }|\n    { OID id-sha1 PARAMETERS\
    \ NULL   }|\n    { OID id-sha256 PARAMETERS NULL }|\n    { OID id-sha384 PARAMETERS\
    \ NULL }|\n    { OID id-sha512 PARAMETERS NULL }\n"
- title: '}'
  contents:
  - '}

    '
- title: -- When id-md2 and id-md5 are used in an AlgorithmIdentifier the
  contents:
  - '-- When id-md2 and id-md5 are used in an AlgorithmIdentifier the

    '
- title: -- parameters MUST be present and MUST be NULL.
  contents:
  - '-- parameters MUST be present and MUST be NULL.

    '
- title: -- When id-sha1, id-sha256, id-sha384 and id-sha512 are used in an
  contents:
  - '-- When id-sha1, id-sha256, id-sha384 and id-sha512 are used in an

    '
- title: -- AlgorithmIdentifier the parameters (which are optional) SHOULD
  contents:
  - '-- AlgorithmIdentifier the parameters (which are optional) SHOULD

    '
- title: -- be omitted. However, an implementation MUST also accept
  contents:
  - '-- be omitted. However, an implementation MUST also accept

    '
- title: -- AlgorithmIdentifier values where the parameters are NULL.
  contents:
  - '-- AlgorithmIdentifier values where the parameters are NULL.

    '
- title: sha1    HashAlgorithm ::= {
  contents:
  - "sha1    HashAlgorithm ::= {\n    algorithm   id-sha1,\n    parameters  SHA1Parameters\
    \ : NULL  -- included for compatibility\n                                    \
    \   -- with existing implementations\n"
- title: '}'
  contents:
  - '}

    '
- title: HashAlgorithm ::= AlgorithmIdentifier { {OAEP-PSSDigestAlgorithms} }
  contents:
  - 'HashAlgorithm ::= AlgorithmIdentifier { {OAEP-PSSDigestAlgorithms} }

    '
- title: SHA1Parameters ::= NULL
  contents:
  - 'SHA1Parameters ::= NULL

    '
- title: --
  contents:
  - '--

    '
- title: -- Allowed mask generation function algorithms.
  contents:
  - '-- Allowed mask generation function algorithms.

    '
- title: -- If the identifier is id-mgf1, the parameters are a HashAlgorithm.
  contents:
  - '-- If the identifier is id-mgf1, the parameters are a HashAlgorithm.

    '
- title: --
  contents:
  - '--

    '
- title: PKCS1MGFAlgorithms    ALGORITHM-IDENTIFIER ::= {
  contents:
  - "PKCS1MGFAlgorithms    ALGORITHM-IDENTIFIER ::= {\n    { OID id-mgf1 PARAMETERS\
    \ HashAlgorithm },\n    ...  -- Allows for future expansion --\n"
- title: '}'
  contents:
  - '}

    '
- title: --
  contents:
  - '--

    '
- title: -- Default AlgorithmIdentifier for id-RSAES-OAEP.maskGenAlgorithm and
  contents:
  - '-- Default AlgorithmIdentifier for id-RSAES-OAEP.maskGenAlgorithm and

    '
- title: -- id-RSASSA-PSS.maskGenAlgorithm.
  contents:
  - '-- id-RSASSA-PSS.maskGenAlgorithm.

    '
- title: --
  contents:
  - '--

    '
- title: mgf1SHA1    MaskGenAlgorithm ::= {
  contents:
  - "mgf1SHA1    MaskGenAlgorithm ::= {\n    algorithm   id-mgf1,\n    parameters\
    \  HashAlgorithm : sha1\n"
- title: '}'
  contents:
  - '}

    '
- title: MaskGenAlgorithm ::= AlgorithmIdentifier { {PKCS1MGFAlgorithms} }
  contents:
  - 'MaskGenAlgorithm ::= AlgorithmIdentifier { {PKCS1MGFAlgorithms} }

    '
- title: --
  contents:
  - '--

    '
- title: -- Allowed algorithms for pSourceAlgorithm.
  contents:
  - '-- Allowed algorithms for pSourceAlgorithm.

    '
- title: --
  contents:
  - '--

    '
- title: PKCS1PSourceAlgorithms    ALGORITHM-IDENTIFIER ::= {
  contents:
  - "PKCS1PSourceAlgorithms    ALGORITHM-IDENTIFIER ::= {\n    { OID id-pSpecified\
    \ PARAMETERS EncodingParameters },\n    ...  -- Allows for future expansion --\n"
- title: '}'
  contents:
  - '}

    '
- title: EncodingParameters ::= OCTET STRING(SIZE(0..MAX))
  contents:
  - 'EncodingParameters ::= OCTET STRING(SIZE(0..MAX))

    '
- title: --
  contents:
  - '--

    '
- title: -- This identifier means that the label L is an empty string, so the
  contents:
  - '-- This identifier means that the label L is an empty string, so the

    '
- title: -- digest of the empty string appears in the RSA block before
  contents:
  - '-- digest of the empty string appears in the RSA block before

    '
- title: -- masking.
  contents:
  - '-- masking.

    '
- title: --
  contents:
  - '--

    '
- title: pSpecifiedEmpty    PSourceAlgorithm ::= {
  contents:
  - "pSpecifiedEmpty    PSourceAlgorithm ::= {\n    algorithm   id-pSpecified,\n \
    \   parameters  EncodingParameters : emptyString\n"
- title: '}'
  contents:
  - '}

    '
- title: PSourceAlgorithm ::= AlgorithmIdentifier { {PKCS1PSourceAlgorithms} }
  contents:
  - 'PSourceAlgorithm ::= AlgorithmIdentifier { {PKCS1PSourceAlgorithms} }

    '
- title: emptyString    EncodingParameters ::= ''H
  contents:
  - 'emptyString    EncodingParameters ::= ''''H

    '
- title: --
  contents:
  - '--

    '
- title: '-- Type identifier definitions for the PKCS #1 OIDs.'
  contents:
  - '-- Type identifier definitions for the PKCS #1 OIDs.

    '
- title: --
  contents:
  - '--

    '
- title: PKCS1Algorithms    ALGORITHM-IDENTIFIER ::= {
  contents:
  - "PKCS1Algorithms    ALGORITHM-IDENTIFIER ::= {\n    { OID rsaEncryption      \
    \        PARAMETERS NULL } |\n    { OID md2WithRSAEncryption       PARAMETERS\
    \ NULL } |\n    { OID md5WithRSAEncryption       PARAMETERS NULL } |\n    { OID\
    \ sha1WithRSAEncryption      PARAMETERS NULL } |\n    { OID sha256WithRSAEncryption\
    \    PARAMETERS NULL } |\n    { OID sha384WithRSAEncryption    PARAMETERS NULL\
    \ } |\n    { OID sha512WithRSAEncryption    PARAMETERS NULL } |\n    { OID id-RSAES-OAEP\
    \ PARAMETERS RSAES-OAEP-params } |\n    PKCS1PSourceAlgorithms               \
    \              |\n    { OID id-RSASSA-PSS PARAMETERS RSASSA-PSS-params } ,\n \
    \   ...  -- Allows for future expansion --\n"
- title: '}'
  contents:
  - '}

    '
- title: -- ===================
  contents:
  - '-- ===================

    '
- title: --   Main structures
  contents:
  - '--   Main structures

    '
- title: -- ===================
  contents:
  - '-- ===================

    '
- title: RSAPublicKey ::= SEQUENCE {
  contents:
  - "RSAPublicKey ::= SEQUENCE {\n    modulus           INTEGER,  -- n\n    publicExponent\
    \    INTEGER   -- e\n"
- title: '}'
  contents:
  - '}

    '
- title: --
  contents:
  - '--

    '
- title: -- Representation of RSA private key with information for the CRT
  contents:
  - '-- Representation of RSA private key with information for the CRT

    '
- title: -- algorithm.
  contents:
  - '-- algorithm.

    '
- title: --
  contents:
  - '--

    '
- title: RSAPrivateKey ::= SEQUENCE {
  contents:
  - "RSAPrivateKey ::= SEQUENCE {\n    version           Version,\n    modulus   \
    \        INTEGER,  -- n\n    publicExponent    INTEGER,  -- e\n    privateExponent\
    \   INTEGER,  -- d\n    prime1            INTEGER,  -- p\n    prime2         \
    \   INTEGER,  -- q\n    exponent1         INTEGER,  -- d mod (p-1)\n    exponent2\
    \         INTEGER,  -- d mod (q-1)\n    coefficient       INTEGER,  -- (inverse\
    \ of q) mod p\n    otherPrimeInfos   OtherPrimeInfos OPTIONAL\n"
- title: '}'
  contents:
  - '}

    '
- title: Version ::= INTEGER { two-prime(0), multi(1) }
  contents:
  - "Version ::= INTEGER { two-prime(0), multi(1) }\n    (CONSTRAINED BY {\n     \
    \   -- version must be multi if otherPrimeInfos present --\n    })\n"
- title: OtherPrimeInfos ::= SEQUENCE SIZE(1..MAX) OF OtherPrimeInfo
  contents:
  - 'OtherPrimeInfos ::= SEQUENCE SIZE(1..MAX) OF OtherPrimeInfo

    '
- title: OtherPrimeInfo ::= SEQUENCE {
  contents:
  - "OtherPrimeInfo ::= SEQUENCE {\n    prime             INTEGER,  -- ri\n    exponent\
    \          INTEGER,  -- di\n    coefficient       INTEGER   -- ti\n"
- title: '}'
  contents:
  - '}

    '
- title: --
  contents:
  - '--

    '
- title: -- AlgorithmIdentifier.parameters for id-RSAES-OAEP.
  contents:
  - '-- AlgorithmIdentifier.parameters for id-RSAES-OAEP.

    '
- title: -- Note that the tags in this Sequence are explicit.
  contents:
  - '-- Note that the tags in this Sequence are explicit.

    '
- title: --
  contents:
  - '--

    '
- title: RSAES-OAEP-params ::= SEQUENCE {
  contents:
  - "RSAES-OAEP-params ::= SEQUENCE {\n    hashAlgorithm      [0] HashAlgorithm  \
    \   DEFAULT sha1,\n    maskGenAlgorithm   [1] MaskGenAlgorithm  DEFAULT mgf1SHA1,\n\
    \    pSourceAlgorithm   [2] PSourceAlgorithm  DEFAULT pSpecifiedEmpty\n"
- title: '}'
  contents:
  - '}

    '
- title: --
  contents:
  - '--

    '
- title: -- Identifier for default RSAES-OAEP algorithm identifier.
  contents:
  - '-- Identifier for default RSAES-OAEP algorithm identifier.

    '
- title: '-- The DER Encoding of this is in hexadecimal:'
  contents:
  - '-- The DER Encoding of this is in hexadecimal:

    '
- title: -- (0x)30 0D
  contents:
  - '-- (0x)30 0D

    '
- title: --        06 09
  contents:
  - '--        06 09

    '
- title: --           2A 86 48 86 F7 0D 01 01 07
  contents:
  - '--           2A 86 48 86 F7 0D 01 01 07

    '
- title: --        30 00
  contents:
  - '--        30 00

    '
- title: -- Notice that the DER encoding of default values is "empty".
  contents:
  - '-- Notice that the DER encoding of default values is "empty".

    '
- title: --
  contents:
  - '--

    '
- title: rSAES-OAEP-Default-Identifier    RSAES-AlgorithmIdentifier ::= {
  contents:
  - "rSAES-OAEP-Default-Identifier    RSAES-AlgorithmIdentifier ::= {\n    algorithm\
    \   id-RSAES-OAEP,\n    parameters  RSAES-OAEP-params : {\n        hashAlgorithm\
    \       sha1,\n        maskGenAlgorithm    mgf1SHA1,\n        pSourceAlgorithm\
    \    pSpecifiedEmpty\n    }\n"
- title: '}'
  contents:
  - '}

    '
- title: RSAES-AlgorithmIdentifier ::=
  contents:
  - "RSAES-AlgorithmIdentifier ::=\n    AlgorithmIdentifier { {PKCS1Algorithms} }\n"
- title: --
  contents:
  - '--

    '
- title: -- AlgorithmIdentifier.parameters for id-RSASSA-PSS.
  contents:
  - '-- AlgorithmIdentifier.parameters for id-RSASSA-PSS.

    '
- title: -- Note that the tags in this Sequence are explicit.
  contents:
  - '-- Note that the tags in this Sequence are explicit.

    '
- title: --
  contents:
  - '--

    '
- title: RSASSA-PSS-params ::= SEQUENCE {
  contents:
  - "RSASSA-PSS-params ::= SEQUENCE {\n    hashAlgorithm      [0] HashAlgorithm  \
    \    DEFAULT sha1,\n    maskGenAlgorithm   [1] MaskGenAlgorithm   DEFAULT mgf1SHA1,\n\
    \    saltLength         [2] INTEGER            DEFAULT 20,\n    trailerField \
    \      [3] TrailerField       DEFAULT trailerFieldBC\n"
- title: '}'
  contents:
  - '}

    '
- title: TrailerField ::= INTEGER { trailerFieldBC(1) }
  contents:
  - 'TrailerField ::= INTEGER { trailerFieldBC(1) }

    '
- title: --
  contents:
  - '--

    '
- title: -- Identifier for default RSASSA-PSS algorithm identifier
  contents:
  - '-- Identifier for default RSASSA-PSS algorithm identifier

    '
- title: '-- The DER Encoding of this is in hexadecimal:'
  contents:
  - '-- The DER Encoding of this is in hexadecimal:

    '
- title: -- (0x)30 0D
  contents:
  - '-- (0x)30 0D

    '
- title: --        06 09
  contents:
  - '--        06 09

    '
- title: --           2A 86 48 86 F7 0D 01 01 0A
  contents:
  - '--           2A 86 48 86 F7 0D 01 01 0A

    '
- title: --        30 00
  contents:
  - '--        30 00

    '
- title: -- Notice that the DER encoding of default values is "empty".
  contents:
  - '-- Notice that the DER encoding of default values is "empty".

    '
- title: --
  contents:
  - '--

    '
- title: rSASSA-PSS-Default-Identifier    RSASSA-AlgorithmIdentifier ::= {
  contents:
  - "rSASSA-PSS-Default-Identifier    RSASSA-AlgorithmIdentifier ::= {\n    algorithm\
    \   id-RSASSA-PSS,\n    parameters  RSASSA-PSS-params : {\n        hashAlgorithm\
    \       sha1,\n        maskGenAlgorithm    mgf1SHA1,\n        saltLength     \
    \     20,\n        trailerField        trailerFieldBC\n    }\n"
- title: '}'
  contents:
  - '}

    '
- title: RSASSA-AlgorithmIdentifier ::=
  contents:
  - "RSASSA-AlgorithmIdentifier ::=\n    AlgorithmIdentifier { {PKCS1Algorithms} }\n"
- title: --
  contents:
  - '--

    '
- title: -- Syntax for the EMSA-PKCS1-v1_5 hash identifier.
  contents:
  - '-- Syntax for the EMSA-PKCS1-v1_5 hash identifier.

    '
- title: --
  contents:
  - '--

    '
- title: DigestInfo ::= SEQUENCE {
  contents:
  - "DigestInfo ::= SEQUENCE {\n    digestAlgorithm DigestAlgorithm,\n    digest OCTET\
    \ STRING\n"
- title: '}'
  contents:
  - '}

    '
- title: DigestAlgorithm ::=
  contents:
  - "DigestAlgorithm ::=\n    AlgorithmIdentifier { {PKCS1-v1-5DigestAlgorithms} }\n"
- title: END  -- PKCS1Definitions
  contents:
  - 'END  -- PKCS1Definitions

    '
- title: Appendix D. Intellectual Property Considerations
  contents:
  - "Appendix D. Intellectual Property Considerations\n   The RSA public-key cryptosystem\
    \ is described in U.S. Patent\n   4,405,829, which expired on September 20, 2000.\
    \  RSA Security Inc.\n   makes no other patent claims on the constructions described\
    \ in this\n   document, although specific underlying techniques may be covered.\n\
    \   Multi-prime RSA is described in U.S. Patent 5,848,159.\n   The University\
    \ of California has indicated that it has a patent\n   pending on the PSS signature\
    \ scheme [5].  It has also provided a\n   letter to the IEEE P1363 working group\
    \ stating that if the PSS\n   signature scheme is included in an IEEE standard,\
    \ \"the University of\n   California will, when that standard is adopted, FREELY\
    \ license any\n   conforming implementation of PSS as a technique for achieving\
    \ a\n   digital signature with appendix\" [23].  The PSS signature scheme is\n\
    \   specified in the IEEE P1363a draft [27], which was in ballot\n   resolution\
    \ when this document was published.\n   License to copy this document is granted\
    \ provided that it is\n   identified as \"RSA Security Inc.  Public-Key Cryptography\
    \ Standards\n   (PKCS)\" in all material mentioning or referencing this document.\n\
    \   RSA Security Inc. makes no other representations regarding\n   intellectual\
    \ property claims by other parties.  Such determination is\n   the responsibility\
    \ of the user.\n"
- title: Appendix E. Revision history
  contents:
  - "Appendix E. Revision history\n   Versions 1.0 - 1.3\n      Versions 1.0 - 1.3\
    \ were distributed to participants in RSA Data\n      Security, Inc.'s Public-Key\
    \ Cryptography Standards meetings in\n      February and March 1991.\n   Version\
    \ 1.4\n      Version 1.4 was part of the June 3, 1991 initial public release of\n\
    \      PKCS.  Version 1.4 was published as NIST/OSI Implementors'\n      Workshop\
    \ document SEC-SIG-91-18.\n   Version 1.5\n      Version 1.5 incorporated several\
    \ editorial changes, including\n      updates to the references and the addition\
    \ of a revision history.\n      The following substantive changes were made:\n\
    \      -  Section 10: \"MD4 with RSA\" signature and verification processes\n\
    \         were added.\n      -  Section 11: md4WithRSAEncryption object identifier\
    \ was added.\n      Version 1.5 was republished as IETF RFC 2313.\n   Version\
    \ 2.0\n      Version 2.0 incorporated major editorial changes in terms of the\n\
    \      document structure and introduced the RSAES-OAEP encryption\n      scheme.\
    \  This version continued to support the encryption and\n      signature processes\
    \ in version 1.5, although the hash algorithm\n      MD4 was no longer allowed\
    \ due to cryptanalytic advances in the\n      intervening years.  Version 2.0\
    \ was republished as IETF RFC 2437\n      [35].\n   Version 2.1\n      Version\
    \ 2.1 introduces multi-prime RSA and the RSASSA-PSS\n      signature scheme with\
    \ appendix along with several editorial\n      improvements.  This version continues\
    \ to support the schemes in\n      version 2.0.\n"
- title: 'Appendix F: References'
  contents:
  - "Appendix F: References\n   [1]   ANSI X9F1 Working Group.  ANSI X9.44 Draft D2:\
    \ Key\n         Establishment Using Integer Factorization Cryptography.\n    \
    \     Working Draft, March 2002.\n   [2]   M. Bellare, A. Desai, D. Pointcheval\
    \ and P. Rogaway.  Relations\n         Among Notions of Security for Public-Key\
    \ Encryption Schemes.\n         In H. Krawczyk, editor, Advances in Cryptology\
    \ - Crypto '98,\n         volume 1462 of Lecture Notes in Computer Science, pp.\
    \ 26 - 45.\n         Springer Verlag, 1998.\n   [3]   M. Bellare and P. Rogaway.\
    \  Optimal Asymmetric Encryption - How\n         to Encrypt with RSA.  In A. De\
    \ Santis, editor, Advances in\n         Cryptology - Eurocrypt '94, volume 950\
    \ of Lecture Notes in\n         Computer Science, pp. 92 - 111.  Springer Verlag,\
    \ 1995.\n   [4]   M. Bellare and P. Rogaway.  The Exact Security of Digital\n\
    \         Signatures - How to Sign with RSA and Rabin.  In U. Maurer,\n      \
    \   editor, Advances in Cryptology - Eurocrypt '96, volume 1070 of\n         Lecture\
    \ Notes in Computer Science, pp. 399 - 416.  Springer\n         Verlag, 1996.\n\
    \   [5]   M. Bellare and P. Rogaway.  PSS: Provably Secure Encoding\n        \
    \ Method for Digital Signatures.  Submission to IEEE P1363\n         working group,\
    \ August 1998.  Available from\n         http://grouper.ieee.org/groups/1363/.\n\
    \   [6]   D. Bleichenbacher.  Chosen Ciphertext Attacks Against Protocols\n  \
    \       Based on the RSA Encryption Standard PKCS #1.  In H. Krawczyk,\n     \
    \    editor, Advances in Cryptology - Crypto '98, volume 1462 of\n         Lecture\
    \ Notes in Computer Science, pp. 1 - 12.  Springer\n         Verlag, 1998.\n \
    \  [7]   D. Bleichenbacher, B. Kaliski and J. Staddon.  Recent Results\n     \
    \    on PKCS #1: RSA Encryption Standard.  RSA Laboratories'\n         Bulletin\
    \ No. 7, June 1998.\n   [8]   B. den Boer and A. Bosselaers.  An Attack on the\
    \ Last Two\n         Rounds of MD4.  In J.  Feigenbaum, editor, Advances in\n\
    \         Cryptology - Crypto '91, volume 576 of Lecture Notes in\n         Computer\
    \ Science, pp. 194 - 203.  Springer Verlag, 1992.\n   [9]   B. den Boer and A.\
    \ Bosselaers.  Collisions for the Compression\n         Function of MD5.  In T.\
    \ Helleseth, editor, Advances in\n         Cryptology - Eurocrypt '93, volume\
    \ 765 of Lecture Notes in\n         Computer Science, pp. 293 - 304.  Springer\
    \ Verlag, 1994.\n   [10]  D. Coppersmith, M. Franklin, J. Patarin and M. Reiter.\
    \  Low-\n         Exponent RSA with Related Messages.  In U. Maurer, editor,\n\
    \         Advances in Cryptology - Eurocrypt '96, volume 1070 of Lecture\n   \
    \      Notes in Computer Science, pp. 1 - 9.  Springer Verlag, 1996.\n   [11]\
    \  D. Coppersmith, S. Halevi and C. Jutla.  ISO 9796-1 and the New\n         Forgery\
    \ Strategy.  Presented at the rump session of Crypto '99,\n         August 1999.\n\
    \   [12]  J.-S. Coron.  On the Exact Security of Full Domain Hashing.  In\n  \
    \       M. Bellare, editor, Advances in Cryptology - Crypto 2000,\n         volume\
    \ 1880 of Lecture Notes in Computer Science, pp. 229 -\n         235.  Springer\
    \ Verlag, 2000.\n   [13]  J.-S. Coron.  Optimal Security Proofs for PSS and Other\n\
    \         Signature Schemes.   In L. Knudsen, editor, Advances in\n         Cryptology\
    \ - Eurocrypt 2002, volume 2332 of Lecture Notes in\n         Computer Science,\
    \ pp. 272 - 287.  Springer Verlag, 2002.\n   [14]  J.-S. Coron, M. Joye, D. Naccache\
    \ and P. Paillier.  New Attacks\n         on PKCS #1 v1.5 Encryption.  In B. Preneel,\
    \ editor, Advances in\n         Cryptology - Eurocrypt 2000, volume 1807 of Lecture\
    \ Notes in\n         Computer Science, pp. 369 - 379.  Springer Verlag, 2000.\n\
    \   [15]  J.-S. Coron, D. Naccache and J. P. Stern.  On the Security of\n    \
    \     RSA Padding.  In M. Wiener, editor, Advances in Cryptology -\n         Crypto\
    \ '99, volume 1666 of Lecture Notes in Computer Science,\n         pp. 1 - 18.\
    \  Springer Verlag, 1999.\n   [16]  Y. Desmedt and A.M. Odlyzko.  A Chosen Text\
    \ Attack on the RSA\n         Cryptosystem and Some Discrete Logarithm Schemes.\
    \  In H.C.\n         Williams, editor, Advances in Cryptology - Crypto '85, volume\n\
    \         218 of Lecture Notes in Computer Science, pp. 516 - 522.\n         Springer\
    \ Verlag, 1986.\n   [17]  Dierks, T. and C. Allen, \"The TLS Protocol, Version\
    \ 1.0\", RFC\n         2246, January 1999.\n   [18]  H. Dobbertin.  Cryptanalysis\
    \ of MD4.  In D. Gollmann, editor,\n         Fast Software Encryption '96, volume\
    \ 1039 of Lecture Notes in\n         Computer Science, pp. 55 - 72.  Springer\
    \ Verlag, 1996.\n   [19]  H. Dobbertin.  Cryptanalysis of MD5 Compress.  Presented\
    \ at the\n         rump session of Eurocrypt '96, May 1996.\n   [20]  H. Dobbertin.\
    \  The First Two Rounds of MD4 are Not One-Way.  In\n         S. Vaudenay, editor,\
    \ Fast Software Encryption '98, volume 1372\n         in Lecture Notes in Computer\
    \ Science, pp. 284 - 292.  Springer\n         Verlag, 1998.\n   [21]  E. Fujisaki,\
    \ T. Okamoto, D. Pointcheval and J. Stern.  RSA-OAEP\n         is Secure under\
    \ the RSA Assumption.  In J. Kilian, editor,\n         Advances in Cryptology\
    \ - Crypto 2001, volume 2139 of Lecture\n         Notes in Computer Science, pp.\
    \ 260 - 274.  Springer Verlag,\n         2001.\n   [22]  H. Garner.  The Residue\
    \ Number System.  IRE Transactions on\n         Electronic Computers, EC-8 (6),\
    \ pp. 140 - 147, June 1959.\n   [23]  M.L. Grell.  Re: Encoding Methods PSS/PSS-R.\
    \  Letter to IEEE\n         P1363 working group, University of California, June\
    \ 15, 1999.\n         Available from\n         http://grouper.ieee.org/groups/1363/P1363/patents.html.\n\
    \   [24]  J. Haastad.  Solving Simultaneous Modular Equations of Low\n       \
    \  Degree.  SIAM Journal of Computing, volume 17, pp. 336 - 341,\n         1988.\n\
    \   [25]  Housley, R., \"Cryptographic Message Syntax (CMS)\", RFC 3369,\n   \
    \      August 2002.  Housley, R., \"Cryptographic Message Syntax (CMS)\n     \
    \    Algorithms\", RFC 3370, August 2002.\n   [26]  IEEE Std 1363-2000: Standard\
    \ Specifications for Public Key\n         Cryptography.  IEEE, August 2000.\n\
    \   [27]  IEEE P1363 working group.  IEEE P1363a D11: Draft Standard\n       \
    \  Specifications for Public Key Cryptography -- Amendment 1:\n         Additional\
    \ Techniques. December 16, 2002.  Available from\n         http://grouper.ieee.org/groups/1363/.\n\
    \   [28]  ISO/IEC 9594-8:1997: Information technology - Open Systems\n       \
    \  Interconnection - The Directory: Authentication Framework.\n         1997.\n\
    \   [29]  ISO/IEC FDIS 9796-2: Information Technology - Security\n         Techniques\
    \ - Digital Signature Schemes Giving Message Recovery\n         - Part 2: Integer\
    \ Factorization Based Mechanisms.  Final Draft\n         International Standard,\
    \ December 2001.\n   [30]  ISO/IEC 18033-2: Information Technology - Security\
    \ Techniques -\n         Encryption Algorithms - Part 2: Asymmetric Ciphers. \
    \ V. Shoup,\n         editor, Text for 2nd Working Draft, January 2002.\n   [31]\
    \  J. Jonsson.  Security Proof for the RSA-PSS Signature Scheme\n         (extended\
    \ abstract).  Second Open NESSIE Workshop.  September\n         2001.  Full version\
    \ available from\n         http://eprint.iacr.org/2001/053/.\n   [32]  J. Jonsson\
    \ and B. Kaliski.  On the Security of RSA Encryption\n         in TLS.  In M.\
    \ Yung, editor, Advances in Cryptology - CRYPTO\n         2002, vol. 2442 of Lecture\
    \ Notes in Computer Science, pp. 127 -\n         142.  Springer Verlag, 2002.\n\
    \   [33]  Kaliski, B., \"The MD2 Message-Digest Algorithm\", RFC 1319,\n     \
    \    April 1992.\n   [34]  B. Kaliski.  On Hash Function Identification in Signature\n\
    \         Schemes.  In B. Preneel, editor, RSA Conference 2002,\n         Cryptographers'\
    \ Track, volume 2271 of Lecture Notes in Computer\n         Science, pp. 1 - 16.\
    \  Springer Verlag, 2002.\n   [35]  Kaliski, B. and J. Staddon, \"PKCS #1: RSA\
    \ Cryptography\n         Specifications Version 2.0\", RFC 2437, October 1998.\n\
    \   [36]  J. Manger.  A Chosen Ciphertext Attack on RSA Optimal\n         Asymmetric\
    \ Encryption Padding (OAEP) as Standardized in PKCS #1\n         v2.0. In J. Kilian,\
    \ editor, Advances in Cryptology - Crypto\n         2001, volume 2139 of Lecture\
    \ Notes in Computer Science, pp. 260\n         - 274.  Springer Verlag, 2001.\n\
    \   [37]  A. Menezes, P. van Oorschot and S. Vanstone.  Handbook of\n        \
    \ Applied Cryptography.  CRC Press, 1996.\n   [38]  National Institute of Standards\
    \ and Technology (NIST).  FIPS\n         Publication 180-1: Secure Hash Standard.\
    \  April 1994.\n   [39]  National Institute of Standards and Technology (NIST).\
    \  Draft\n         FIPS 180-2: Secure Hash Standard.  Draft, May 2001.  Available\n\
    \         from http://www.nist.gov/sha/.\n   [40]  J.-J. Quisquater and C. Couvreur.\
    \  Fast Decipherment Algorithm\n         for RSA Public-Key Cryptosystem.  Electronics\
    \ Letters, 18 (21),\n         pp. 905 - 907, October 1982.\n   [41]  Rivest, R.,\
    \ \"The MD5 Message-Digest Algorithm\", RFC 1321, April\n         1992.\n   [42]\
    \  R. Rivest, A. Shamir and L. Adleman.  A Method for Obtaining\n         Digital\
    \ Signatures and Public-Key Cryptosystems.\n         Communications of the ACM,\
    \ 21 (2), pp. 120-126, February 1978.\n   [43]  N. Rogier and P. Chauvaud.  The\
    \ Compression Function of MD2 is\n         not Collision Free.  Presented at Selected\
    \ Areas of\n         Cryptography '95.  Carleton University, Ottawa, Canada. \
    \ May\n         1995.\n   [44]  RSA Laboratories.  PKCS #1 v2.0: RSA Encryption\
    \ Standard.\n         October 1998.\n   [45]  RSA Laboratories.  PKCS #7 v1.5:\
    \ Cryptographic Message Syntax\n         Standard.  November 1993.  (Republished\
    \ as IETF RFC 2315.)\n   [46]  RSA Laboratories.  PKCS #8 v1.2: Private-Key Information\
    \ Syntax\n         Standard.  November 1993.\n   [47]  RSA Laboratories.  PKCS\
    \ #12 v1.0: Personal Information Exchange\n         Syntax Standard.  June 1999.\n\
    \   [48]  V. Shoup.  OAEP Reconsidered.  In J. Kilian, editor, Advances\n    \
    \     in Cryptology - Crypto 2001, volume 2139 of Lecture Notes in\n         Computer\
    \ Science, pp. 239 - 259.  Springer Verlag, 2001.\n   [49]  R. D. Silverman. \
    \ A Cost-Based Security Analysis of Symmetric\n         and Asymmetric Key Lengths.\
    \  RSA Laboratories Bulletin No. 13,\n         April 2000.  Available from\n \
    \        http://www.rsasecurity.com.rsalabs/bulletins/.\n   [50]  G. J. Simmons.\
    \  Subliminal communication is easy using the DSA.\n         In T. Helleseth,\
    \ editor, Advances in Cryptology - Eurocrypt\n         '93, volume 765 of Lecture\
    \ Notes in Computer Science, pp. 218-\n         232.  Springer-Verlag, 1993.\n"
- title: 'Appendix G: About PKCS'
  contents:
  - "Appendix G: About PKCS\n   The Public-Key Cryptography Standards are specifications\
    \ produced by\n   RSA Laboratories in cooperation with secure systems developers\n\
    \   worldwide for the purpose of accelerating the deployment of\n   public-key\
    \ cryptography.  First published in 1991 as a result of\n   meetings with a small\
    \ group of early adopters of public-key\n   technology, the PKCS documents have\
    \ become widely referenced and\n   implemented.  Contributions from the PKCS series\
    \ have become part of\n   many formal and de facto standards, including ANSI X9\
    \ and IEEE P1363\n   documents, PKIX, SET, S/MIME, SSL/TLS, and WAP/WTLS.\n  \
    \ Further development of PKCS occurs through mailing list discussions\n   and\
    \ occasional workshops, and suggestions for improvement are\n   welcome.  For\
    \ more information, contact:\n      PKCS Editor\n      RSA Laboratories\n    \
    \  174 Middlesex Turnpike\n      Bedford, MA  01730 USA\n      pkcs-editor@rsasecurity.com\n\
    \      http://www.rsasecurity.com/rsalabs/pkcs\n"
- title: 'Appendix H: Corrections Made During RFC Publication Process'
  contents:
  - "Appendix H: Corrections Made During RFC Publication Process\n   The following\
    \ corrections were made in converting the PKCS #1 v2.1\n   document to this RFC:\n\
    \   *  The requirement that the parameters in an AlgorithmIdentifier\n      value\
    \ for id-sha1, id-sha256, id-sha384, and id-sha512 be NULL was\n      changed\
    \ to a recommendation that the parameters be omitted (while\n      still allowing\
    \ the parameters to be NULL). This is to align with\n      the definitions originally\
    \ promulgated by NIST. Implementations\n      MUST accept AlgorithmIdentifier\
    \ values both without parameters and\n      with NULL parameters.\n   *  The notes\
    \ after RSADP and RSASP1 (Secs. 5.1.2 and 5.2.1) were\n      corrected to refer\
    \ to step 2.b rather than 2.a.\n   *  References [25], [27] and [32] were updated\
    \ to reflect new\n      publication data.\n   These corrections will be reflected\
    \ in future editions of PKCS #1\n   v2.1.\n"
- title: Security Considerations
  contents:
  - "Security Considerations\n   Security issues are discussed throughout this memo.\n"
- title: Acknowledgements
  contents:
  - "Acknowledgements\n   This document is based on a contribution of RSA Laboratories,\
    \ the\n   research center of RSA Security Inc.  Any substantial use of the text\n\
    \   from this document must acknowledge RSA Security Inc.  RSA Security\n   Inc.\
    \ requests that all material mentioning or referencing this\n   document identify\
    \ this as \"RSA Security Inc. PKCS #1 v2.1\".\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Jakob Jonsson\n   Philipps-Universitaet Marburg\n   Fachbereich\
    \ Mathematik und Informatik\n   Hans Meerwein Strasse, Lahnberge\n   DE-35032\
    \ Marburg\n   Germany\n   Phone: +49 6421 28 25672\n   EMail: jonsson@mathematik.uni-marburg.de\n\
    \   Burt Kaliski\n   RSA Laboratories\n   174 Middlesex Turnpike\n   Bedford,\
    \ MA 01730 USA\n   Phone: +1 781 515 7073\n   EMail: bkaliski@rsasecurity.com\n"
- title: Full Copyright Statement
  contents:
  - "Full Copyright Statement\n   Copyright (C) The Internet Society 2003.  All Rights\
    \ Reserved.\n   This document and translations of it may be copied and furnished\
    \ to\n   others provided that the above copyright notice and this paragraph\n\
    \   are included on all such copies.  However, this document itself may\n   not\
    \ be modified in any way, such as by removing the copyright notice\n   or references\
    \ to the Internet Society or other Internet\n   organizations, except as required\
    \ to translate it into languages\n   other than English.\n   The limited permissions\
    \ granted above are perpetual and will not be\n   revoked by the Internet Society\
    \ or its successors or assigns.\n   This document and the information contained\
    \ herein is provided on an\n   \"AS IS\" basis and THE INTERNET SOCIETY AND THE\
    \ INTERNET ENGINEERING\n   TASK FORCE DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED,\
    \ INCLUDING\n   BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION\n\
    \   HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF\n   MERCHANTABILITY\
    \ OR FITNESS FOR A PARTICULAR PURPOSE.\n"
- title: Acknowledgement
  contents:
  - "Acknowledgement\n   Funding for the RFC Editor function is currently provided\
    \ by the\n   Internet Society.\n"
