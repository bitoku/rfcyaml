- contents:
  - "                 A Reverse Address Resolution Protocol\n      Ross Finlayson,
    Timothy Mann, Jeffrey Mogul, Marvin Theimer\n                      Computer Science
    Department\n                          Stanford University\n                               June
    1984\n"
  title: __initial_text__
- contents:
  - "Status of this Memo\n   This RFC suggests a method for workstations to dynamically
    find their\n   protocol address (e.g., their Internet Address), when they know
    only\n   their hardware address (e.g., their attached physical network\n   address).\n
    \  This RFC specifies a proposed protocol for the ARPA Internet\n   community,
    and requests discussion and suggestions for improvements.\n"
  title: Status of this Memo
- contents:
  - "I. Introduction\n   Network hosts such as diskless workstations frequently do
    not know\n   their protocol addresses when booted; they often know only their\n
    \  hardware interface addresses.  To communicate using higher-level\n   protocols
    like IP, they must discover their protocol address from\n   some external source.
    \ Our problem is that there is no standard\n   mechanism for doing so.\n   Plummer's
    \"Address Resolution Protocol\" (ARP) [1] is designed to\n   solve a complementary
    problem, resolving a host's hardware address\n   given its protocol address.  This
    RFC proposes a \"Reverse Address\n   Resolution Protocol\" (RARP).  As with ARP,
    we assume a broadcast\n   medium, such as Ethernet.\n"
  title: I. Introduction
- contents:
  - "II. Design Considerations\n   The following considerations guided our design
    of the RARP protocol.\n   A. ARP and RARP are different operations.  ARP assumes
    that every\n   host knows the mapping between its own hardware address and protocol\n
    \  address(es).  Information gathered about other hosts is accumulated\n   in
    a small cache.  All hosts are equal in status; there is no\n   distinction between
    clients and servers.\n   On the other hand, RARP requires one or more server hosts
    to maintain\n   a database of mappings from hardware address to protocol address
    and\n   respond to requests from client hosts.\n"
  title: II. Design Considerations
- contents:
  - "III.  The Proposed Protocol\n   We propose that RARP be specified as a separate
    protocol at the\n   data-link level.  For example, if the medium used is Ethernet,
    then\n   RARP packets will have an Ethertype (still to be assigned) different\n
    \  from that of ARP.  This recognizes that ARP and RARP are two\n   fundamentally
    different operations, not supported equally by all\n   hosts.  The impact on existing
    systems is minimized; existing ARP\n   servers will not be confused by RARP packets.
    It makes RARP a general\n   facility that can be used for mapping hardware addresses
    to any\n   higher level protocol address.\n   This approach provides the simplest
    implementation for RARP client\n   hosts, but also provides the most difficulties
    for RARP server hosts.\n   However, these difficulties should not be insurmountable,
    as is shown\n   in Appendix A, where we sketch two possible implementations for\n
    \  4.2BSD Unix.\n   RARP uses the same packet format that is used by ARP, namely:\n
    \     ar$hrd (hardware address space) -  16 bits\n      ar$pro (protocol address
    space) -  16 bits\n      ar$hln (hardware address length) - 8 bits\n      ar$pln
    (protocol address length) - 8 bits\n      ar$op  (opcode) - 16 bits\n      ar$sha
    (source hardware address) - n bytes,\n                                       where
    n is from the ar$hln field.\n      ar$spa (source protocol address) - m bytes,\n
    \                                      where m is from the ar$pln field.\n      ar$tha
    (target hardware address) - n bytes\n      ar$tpa (target protocol address) -
    m bytes\n   ar$hrd, ar$pro, ar$hln and ar$pln are the same as in regular ARP\n
    \  (see [1]).\n"
  title: III.  The Proposed Protocol
- contents:
  - "IV. References\n   [1] Plummer, D., \"An Ethernet Address Resolution Protocol\",
    \ RFC 826,\n   MIT-LCS, November 1982.\n"
  title: IV. References
- contents:
  - "Appendix A.  Two Example Implementations for 4.2BSD Unix\n   The following implementation
    sketches outline two different\n   approaches to implementing a RARP server under
    4.2BSD.\n   A. Provide access to data-link level packets outside the kernel.  The\n
    \  RARP server is implemented completely outside the kernel and\n   interacts
    with the kernel only to receive and send RARP packets.  The\n   kernel has to
    be modified to provide the appropriate access for these\n   packets; currently
    the 4.2 kernel allows access only to IP packets.\n   One existing mechanism that
    provides this capability is the CMU\n   \"packet-filter\" pseudo driver.  This
    has been used successfully at\n   CMU and Stanford to implement similar sorts
    of \"user-level\" network\n   servers.\n   B. Maintain a cache of database entries
    inside the kernel.  The full\n   RARP server database is maintained outside the
    kernel by a user\n   process.  The RARP server itself is implemented directly
    in the\n   kernel and employs a small cache of database entries for its\n   responses.
    \ This cache could be the same as is used for forward ARP.\n   The cache gets
    filled from the actual RARP database by means of two\n   new ioctls.  (These are
    like SIOCIFADDR, in that they are not really\n   associated with a specific socket.)
    \ One means: \"sleep until there is\n   a translation to be done, then pass the
    request out to the user\n   process\"; the other means: \"enter this translation
    into the kernel\n   table\".  Thus, when the kernel can't find an entry in the
    cache, it\n   puts the request on a (global) queue and then does a wakeup().  The\n
    \  implementation of the first ioctl is to sleep() and then pull the\n   first
    item off of this queue and return it to the user process.\n   Since the kernel
    can't wait around at interrupt level until the user\n   process replies, it can
    either give up (and assume that the\n   requesting host will retransmit the request
    packet after a second) or\n   if the second ioctl passes a copy of the request
    back into the\n   kernel, formulate and send a response at that time.\n"
  title: Appendix A.  Two Example Implementations for 4.2BSD Unix
