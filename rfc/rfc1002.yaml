- title: __initial_text__
  contents:
  - "             PROTOCOL STANDARD FOR A NetBIOS SERVICE\n                     ON\
    \ A TCP/UDP TRANSPORT:\n                     DETAILED SPECIFICATIONS\n       \
    \                     ABSTRACT\n"
- title: This RFC defines a proposed standard protocol to support NetBIOS
  contents:
  - 'This RFC defines a proposed standard protocol to support NetBIOS

    '
- title: services in a TCP/IP environment.  Both local network and internet
  contents:
  - 'services in a TCP/IP environment.  Both local network and internet

    '
- title: operation are supported.  Various node types are defined to accommodate
  contents:
  - 'operation are supported.  Various node types are defined to accommodate

    '
- title: local and internet topologies and to allow operation with or without the
  contents:
  - 'local and internet topologies and to allow operation with or without the

    '
- title: use of IP broadcast.
  contents:
  - 'use of IP broadcast.

    '
- title: This RFC gives the detailed specifications of the NetBIOS-over-TCP
  contents:
  - 'This RFC gives the detailed specifications of the NetBIOS-over-TCP

    '
- title: packets, protocols, and defined constants and variables.  A more general
  contents:
  - 'packets, protocols, and defined constants and variables.  A more general

    '
- title: overview is found in a companion RFC, "Protocol Standard For a NetBIOS
  contents:
  - 'overview is found in a companion RFC, "Protocol Standard For a NetBIOS

    '
- title: 'Service on a TCP/UDP Transport: Concepts and Methods".'
  contents:
  - "Service on a TCP/UDP Transport: Concepts and Methods\".\n                   \
    \     TABLE OF CONTENTS\n"
- title: 1.  STATUS OF THIS MEMO                                              4
  contents:
  - '1.  STATUS OF THIS MEMO                                              4

    '
- title: 2.  ACKNOWLEDGEMENTS                                                 4
  contents:
  - '2.  ACKNOWLEDGEMENTS                                                 4

    '
- title: 3.  INTRODUCTION                                                     5
  contents:
  - '3.  INTRODUCTION                                                     5

    '
- title: 4.  PACKET DESCRIPTIONS                                              5
  contents:
  - "4.  PACKET DESCRIPTIONS                                              5\n  4.1\
    \  NAME FORMAT                                                   5\n  4.2  NAME\
    \ SERVICE PACKETS                                          7\n     4.2.1  GENERAL\
    \ FORMAT OF NAME SERVICE PACKETS                   7\n       4.2.1.1  HEADER \
    \                                              8\n       4.2.1.2  QUESTION SECTION\
    \                                    10\n       4.2.1.3  RESOURCE RECORD     \
    \                                11\n     4.2.2  NAME REGISTRATION REQUEST   \
    \                            13\n     4.2.3  NAME OVERWRITE REQUEST & DEMAND \
    \                        14\n     4.2.4  NAME REFRESH REQUEST                \
    \                    15\n     4.2.5  POSITIVE NAME REGISTRATION RESPONSE     \
    \                16\n     4.2.6  NEGATIVE NAME REGISTRATION RESPONSE         \
    \            16\n     4.2.7  END-NODE CHALLENGE REGISTRATION RESPONSE        \
    \        17\n     4.2.8  NAME CONFLICT DEMAND                                \
    \    18\n     4.2.9  NAME RELEASE REQUEST & DEMAND                           19\n\
    \     4.2.10  POSITIVE NAME RELEASE RESPONSE                         20\n    \
    \ 4.2.11  NEGATIVE NAME RELEASE RESPONSE                         20\n     4.2.12\
    \  NAME QUERY REQUEST                                     21\n     4.2.13  POSITIVE\
    \ NAME QUERY RESPONSE                           22\n     4.2.14  NEGATIVE NAME\
    \ QUERY RESPONSE                           23\n     4.2.15  REDIRECT NAME QUERY\
    \ RESPONSE                           24\n     4.2.16  WAIT FOR ACKNOWLEDGEMENT\
    \ (WACK) RESPONSE               25\n     4.2.17  NODE STATUS REQUEST         \
    \                           26\n     4.2.18  NODE STATUS RESPONSE            \
    \                       27\n  4.3  SESSION SERVICE PACKETS                   \
    \                   29\n     4.3.1  GENERAL FORMAT OF SESSION PACKETS        \
    \               29\n     4.3.2  SESSION REQUEST PACKET                       \
    \           30\n     4.3.3  POSITIVE SESSION RESPONSE PACKET                 \
    \       31\n     4.3.4  NEGATIVE SESSION RESPONSE PACKET                     \
    \   31\n     4.3.5  SESSION RETARGET RESPONSE PACKET                        31\n\
    \     4.3.6  SESSION MESSAGE PACKET                                  32\n    \
    \ 4.3.7  SESSION KEEP ALIVE PACKET                               32\n  4.4  DATAGRAM\
    \ SERVICE PACKETS                                     32\n     4.4.1  NetBIOS\
    \ DATAGRAM HEADER                                 32\n     4.4.2  DIRECT_UNIQUE,\
    \ DIRECT_GROUP, & BROADCAST DATAGRAM       33\n     4.4.3  DATAGRAM ERROR PACKET\
    \                                   34\n     4.4.4  DATAGRAM QUERY REQUEST   \
    \                               34\n     4.4.5  DATAGRAM POSITIVE AND NEGATIVE\
    \ QUERY RESPONSE           34\n"
- title: 5.  PROTOCOL DESCRIPTIONS                                           35
  contents:
  - "5.  PROTOCOL DESCRIPTIONS                                           35\n  5.1\
    \  NAME SERVICE PROTOCOLS                                       35\n     5.1.1\
    \  B-NODE ACTIVITY                                         35\n       5.1.1.1\
    \  B-NODE ADD NAME                                     35\n       5.1.1.2  B-NODE\
    \ ADD_GROUP NAME                               37\n       5.1.1.3  B-NODE FIND_NAME\
    \                                    37\n       5.1.1.4  B NODE NAME RELEASE \
    \                                38\n       5.1.1.5  B-NODE INCOMING PACKET PROCESSING\
    \                   39\n     5.1.2  P-NODE ACTIVITY                          \
    \               42\n       5.1.2.1  P-NODE ADD_NAME                          \
    \           42\n       5.1.2.2  P-NODE ADD GROUP NAME                        \
    \       45\n       5.1.2.3  P-NODE FIND NAME                                 \
    \   45\n       5.1.2.4  P-NODE DELETE_NAME                                  46\n\
    \       5.1.2.5  P-NODE INCOMING PACKET PROCESSING                   47\n    \
    \   5.1.2.6  P-NODE TIMER INITIATED PROCESSING                   49\n     5.1.3\
    \  M-NODE ACTIVITY                                         50\n       5.1.3.1\
    \  M-NODE ADD NAME                                     50\n       5.1.3.2  M-NODE\
    \ ADD GROUP NAME                               54\n       5.1.3.3  M-NODE FIND\
    \ NAME                                    55\n       5.1.3.4  M-NODE DELETE NAME\
    \                                  56\n       5.1.3.5  M-NODE INCOMING PACKET\
    \ PROCESSING                   58\n       5.1.3.6  M-NODE TIMER INITIATED PROCESSING\
    \                   60\n     5.1.4  NBNS ACTIVITY                            \
    \               60\n       5.1.4.1  NBNS INCOMING PACKET PROCESSING          \
    \           61\n       5.1.4.2  NBNS TIMER INITIATED PROCESSING              \
    \       66\n  5.2  SESSION SERVICE PROTOCOLS                                 \
    \   67\n     5.2.1  SESSION ESTABLISHMENT PROTOCOLS                         67\n\
    \       5.2.1.1  USER REQUEST PROCESSING                             67\n    \
    \   5.2.1.2  RECEIVED PACKET PROCESSING                          71\n     5.2.2\
    \  SESSION DATA TRANSFER PROTOCOLS                         72\n       5.2.2.1\
    \  USER REQUEST PROCESSING                             72\n       5.2.2.2  RECEIVED\
    \ PACKET PROCESSING                          72\n       5.2.2.3  PROCESSING INITIATED\
    \ BY TIMER                       73\n     5.2.3  SESSION TERMINATION PROTOCOLS\
    \                           73\n       5.2.3.1  USER REQUEST PROCESSING      \
    \                       73\n       5.2.3.2  RECEPTION INDICATION PROCESSING  \
    \                   73\n  5.3  NetBIOS DATAGRAM SERVICE PROTOCOLS            \
    \               74\n     5.3.1  B NODE TRANSMISSION OF NetBIOS DATAGRAMS     \
    \           74\n     5.3.2  P AND M NODE TRANSMISSION OF NetBIOS DATAGRAMS   \
    \       76\n     5.3.3  RECEPTION OF NetBIOS DATAGRAMS BY ALL NODES          \
    \   78\n     5.3.4  PROTOCOLS FOR THE NBDD                                  80\n"
- title: 6.  DEFINED CONSTANTS AND VARIABLES                                 83
  contents:
  - '6.  DEFINED CONSTANTS AND VARIABLES                                 83

    '
- title: REFERENCES                                                          85
  contents:
  - "REFERENCES                                                          85\n    \
    \         PROTOCOL STANDARD FOR A NetBIOS SERVICE\n                     ON A TCP/UDP\
    \ TRANSPORT:\n                     DETAILED SPECIFICATIONS\n"
- title: 1.  STATUS OF THIS MEMO
  contents:
  - "1.  STATUS OF THIS MEMO\n   This RFC specifies a proposed standard for the DARPA\
    \ Internet\n   community.  Since this topic is new to the Internet community,\n\
    \   discussions and suggestions are specifically requested.\n   Please send written\
    \ comments to:\n           Karl Auerbach\n           Epilogue Technology Corporation\n\
    \           P.O. Box 5432\n           Redwood City, CA   94063\n   Please send\
    \ online comments to:\n           Avnish Aggarwal\n                   Internet:\
    \ mtxinu!excelan!avnish@ucbvax.berkeley.edu\n                   Usenet:   ucbvax!mtxinu!excelan!avnish\n\
    \   Distribution of this memorandum is unlimited.\n"
- title: 2.  ACKNOWLEDGEMENTS
  contents:
  - "2.  ACKNOWLEDGEMENTS\n   This RFC has been developed under the auspices of the\
    \ Internet\n   Activities Board.\n   The following individuals have contributed\
    \ to the development of\n   this RFC:\n   Avnish Aggarwal       Arvind Agrawal\
    \        Lorenzo Aguilar\n   Geoffrey Arnold       Karl Auerbach         K. Ramesh\
    \ Babu\n   Keith Ball            Amatzia Ben-Artzi     Vint Cerf\n   Richard Cherry\
    \        David Crocker         Steve Deering\n   Greg Ennis            Steve Holmgren\
    \        Jay Israel\n   David Kaufman         Lee LaBarre           James Lau\n\
    \   Dan Lynch             Gaylord Miyata        David Stevens\n   Steve Thomas\
    \          Ishan Wu\n   The system proposed by this RFC does not reflect any existing\n\
    \   Netbios-over-TCP implementation.  However, the design\n   incorporates considerable\
    \ knowledge obtained from prior\n   implementations.  Special thanks goes to the\
    \ following\n   organizations which have provided this invaluable information:\n\
    \   CMC/Syros      Excelan        Sytek          Ungermann-Bass\n"
- title: 3.  INTRODUCTION
  contents:
  - "3.  INTRODUCTION\n   This RFC contains the detailed packet formats and protocol\n\
    \   specifications for NetBIOS-over-TCP.  This RFC is a companion to\n   RFC 1001,\
    \ \"Protocol Standard For a NetBIOS Service on a TCP/UDP\n   Transport: Concepts\
    \ and Methods\" [1].\n"
- title: 4.  PACKET DESCRIPTIONS
  contents:
  - "4.  PACKET DESCRIPTIONS\n   Bit and byte ordering are defined by the most recent\
    \ version of\n   \"Assigned Numbers\" [2].\n"
- title: 4.1.  NAME FORMAT
  contents:
  - "4.1.  NAME FORMAT\n   The NetBIOS name representation in all NetBIOS packets\
    \ (for NAME,\n   SESSION, and DATAGRAM services) is defined in the Domain Name\n\
    \   Service RFC 883[3] as \"compressed\" name messages.  This format is\n   called\
    \ \"second-level encoding\" in the section entitled\n   \"Representation of NetBIOS\
    \ Names\" in the Concepts and Methods\n   document.\n   For ease of description,\
    \ the first two paragraphs from page 31,\n   the section titled \"Domain name\
    \ representation and compression\",\n   of RFC 883 are replicated here:\n    \
    \    Domain names messages are expressed in terms of a sequence\n        of labels.\
    \  Each label is represented as a one octet length\n        field followed by\
    \ that number of octets.  Since every domain\n        name ends with the null\
    \ label of the root, a compressed\n        domain name is terminated by a length\
    \ byte of zero.  The\n        high order two bits of the length field must be\
    \ zero, and\n        the remaining six bits of the length field limit the label\n\
    \        to 63 octets or less.\n        To simplify implementations, the total\
    \ length of label\n        octets and label length octets that make up a domain\
    \ name is\n        restricted to 255 octets or less.\n   The following is the\
    \ uncompressed representation of the NetBIOS name\n   \"FRED \", which is the\
    \ 4 ASCII characters, F, R, E, D, followed by 12\n   space characters (0x20).\
    \  This name has the SCOPE_ID: \"NETBIOS.COM\"\n           EGFCEFEECACACACACACACACACACACACA.NETBIOS.COM\n\
    \   This uncompressed representation of names is called \"first-level\n   encoding\"\
    \ in the section entitled \"Representation of NetBIOS Names\"\n   in the Concepts\
    \ and Methods document.\n   The following is a pictographic representation of\
    \ the compressed\n   representation of the previous uncompressed Domain Name\n\
    \   representation.\n                        1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2\
    \ 2 2 2 3 3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0\
    \ 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n  \
    \ |      0x20     |    E (0x45)   |    G (0x47)   |    F (0x46)   |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |    C (0x43)   |    E (0x45)   |    F (0x46)   |    E (0x45)   |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |    E (0x45)   |    C (0x43)   |    A (0x41)   |    C (0x43)   |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |    A (0x41)   |    C (0x43)   |    A (0x41)   |    C (0x43)   |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |    A (0x41)   |    C (0x43)   |    A (0x41)   |    C (0x43)   |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |    A (0x41)   |    C (0x43)   |    A (0x41)   |    C (0x43)   |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |    A (0x41)   |    C (0x43)   |    A (0x41)   |    C (0x43)   |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |    A (0x41)   |    C (0x43)   |    A (0x41)   |    C (0x43)   |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |    A (0X41)   |      0x07     |    N (0x4E)   |    E (0x45)   |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |    T (0x54)   |    B (0x42)   |    I (0x49)   |    O (0x4F)   |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |    S (0x53)   |      0x03     |    C (0x43)   |    O (0x4F)   |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |    M (0x4D)   |      0x00     |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   Each section of a domain name is called a label [7 (page 31)].  A\n   label\
    \ can be a maximum of 63 bytes.  The first byte of a label in\n   compressed representation\
    \ is the number of bytes in the label.  For\n   the above example, the first 0x20\
    \ is the number of bytes in the\n   left-most label, EGFCEFEECACACACACACACACACACACACA,\
    \ of the domain\n   name.  The bytes following the label length count are the\
    \ characters\n   of the label.  The following labels are in sequence after the\
    \ first\n   label, which is the encoded NetBIOS name, until a zero (0x00) length\n\
    \   count.  The zero length count represents the root label, which is\n   always\
    \ null.\n   A label length count is actually a 6-bit field in the label length\n\
    \   field.  The most significant 2 bits of the field, bits 7 and 6, are\n   flags\
    \ allowing an escape from the above compressed representation.\n   If bits 7 and\
    \ 6 are both set (11), the following 14 bits are an\n   offset pointer into the\
    \ full message to the actual label string from\n   another domain name that belongs\
    \ in this name.  This label pointer\n   allows for a further compression of a\
    \ domain name in a packet.\n   NetBIOS implementations can only use label string\
    \ pointers in Name\n   Service packets.  They cannot be used in Session or Datagram\
    \ Service\n   packets.\n   The other two possible values for bits 7 and 6 (01\
    \ and 10) of a label\n   length field are reserved for future use by RFC 883[2\
    \ (page 32)].\n   Note that the first octet of a compressed name must contain\
    \ one of\n   the following bit patterns.  (An \"x\" indicates a bit whose value\
    \ may\n   be either 0 or 1.):\n           00100000 -  Netbios name, length must\
    \ be 32 (decimal)\n           11xxxxxx -  Label string pointer\n           10xxxxxx\
    \ -  Reserved\n           01xxxxxx -  Reserved\n"
- title: 4.2.  NAME SERVICE PACKETS
  contents:
  - '4.2.  NAME SERVICE PACKETS

    '
- title: 4.2.1.  GENERAL FORMAT OF NAME SERVICE PACKETS
  contents:
  - "4.2.1.  GENERAL FORMAT OF NAME SERVICE PACKETS\n   The NetBIOS Name Service packets\
    \ follow the packet structure defined\n   in the Domain Name Service (DNS) RFC\
    \ 883 [7 (pg 26-31)].  The\n   structures are compatible with the existing DNS\
    \ packet formats,\n   however, additional types and codes have been added to work\
    \ with\n   NetBIOS.\n   If Name Service packets are sent over a TCP connection\
    \ they are\n   preceded by a 16 bit unsigned integer representing the length of\
    \ the\n   Name Service packet.\n                        1 1 1 1 1 1 1 1 1 1 2\
    \ 2 2 2 2 2 2 2 2 2 3 3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4\
    \ 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                                                               |\n   + ------\
    \                                                ------- +\n   |             \
    \               HEADER                             |\n   + ------            \
    \                                    ------- +\n   |                         \
    \                                      |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                                                               |\n   /  \
    \                     QUESTION ENTRIES                        /\n   |        \
    \                                                       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                                                               |\n   /  \
    \                  ANSWER RESOURCE RECORDS                    /\n   |        \
    \                                                       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                                                               |\n   /  \
    \                AUTHORITY RESOURCE RECORDS                   /\n   |        \
    \                                                       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                                                               |\n   /  \
    \                ADDITIONAL RESOURCE RECORDS                  /\n   |        \
    \                                                       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n"
- title: 4.2.1.1.  HEADER
  contents:
  - "4.2.1.1.  HEADER\n                        1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2\
    \ 2 2 3 3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n\
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   |  \
    \       NAME_TRN_ID           | OPCODE  |   NM_FLAGS  | RCODE |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |          QDCOUNT              |           ANCOUNT             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |          NSCOUNT              |           ARCOUNT             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   Field     Description\n   NAME_TRN_ID      Transaction ID for Name Service\
    \ Transaction.\n                    Requestor places a unique value for each active\n\
    \                    transaction.  Responder puts NAME_TRN_ID value\n        \
    \            from request packet in response packet.\n   OPCODE           Packet\
    \ type code, see table below.\n   NM_FLAGS         Flags for operation, see table\
    \ below.\n   RCODE            Result codes of request.  Table of RCODE values\n\
    \                    for each response packet below.\n   QDCOUNT          Unsigned\
    \ 16 bit integer specifying the number of\n                    entries in the\
    \ question section of a Name\n                    Service packet.  Always zero\
    \ (0) for responses.\n                    Must be non-zero for all NetBIOS Name\
    \ requests.\n   ANCOUNT          Unsigned 16 bit integer specifying the number\
    \ of\n                    resource records in the answer section of a Name\n \
    \                   Service packet.\n   NSCOUNT          Unsigned 16 bit integer\
    \ specifying the number of\n                    resource records in the authority\
    \ section of a\n                    Name Service packet.\n   ARCOUNT         \
    \ Unsigned 16 bit integer specifying the number of\n                    resource\
    \ records in the additional records\n                    section of a Name Service\
    \ packet.\n   The OPCODE field is defined as:\n     0   1   2   3   4\n   +---+---+---+---+---+\n\
    \   | R |    OPCODE     |\n   +---+---+---+---+---+\n   Symbol     Bit(s)   Description\n\
    \   OPCODE        1-4   Operation specifier:\n                         0 = query\n\
    \                         5 = registration\n                         6 = release\n\
    \                         7 = WACK\n                         8 = refresh\n   R\
    \               0   RESPONSE flag:\n                         if bit == 0 then\
    \ request packet\n                         if bit == 1 then response packet.\n\
    \   The NM_FLAGS field is defined as:\n     0   1   2   3   4   5   6\n   +---+---+---+---+---+---+---+\n\
    \   |AA |TC |RD |RA | 0 | 0 | B |\n   +---+---+---+---+---+---+---+\n   Symbol\
    \     Bit(s)   Description\n   B               6   Broadcast Flag.\n         \
    \                = 1: packet was broadcast or multicast\n                    \
    \     = 0: unicast\n   RA              3   Recursion Available Flag.\n       \
    \                Only valid in responses from a NetBIOS Name\n               \
    \        Server -- must be zero in all other\n                       responses.\n\
    \                       If one (1) then the NBNS supports recursive\n        \
    \               query, registration, and release.\n                       If zero\
    \ (0) then the end-node must iterate\n                       for query and challenge\
    \ for registration.\n   RD              2   Recursion Desired Flag.\n        \
    \               May only be set on a request to a NetBIOS\n                  \
    \     Name Server.\n                       The NBNS will copy its state into the\n\
    \                       response packet.\n                       If one (1) the\
    \ NBNS will iterate on the\n                       query, registration, or release.\n\
    \   TC              1   Truncation Flag.\n                       Set if this message\
    \ was truncated because the\n                       datagram carrying it would\
    \ be greater than\n                       576 bytes in length.  Use TCP to get\
    \ the\n                       information from the NetBIOS Name Server.\n   AA\
    \              0   Authoritative Answer flag.\n                       Must be\
    \ zero (0) if R flag of OPCODE is zero\n                       (0).\n        \
    \               If R flag is one (1) then if AA is one (1)\n                 \
    \      then the node responding is an authority for\n                       the\
    \ domain name.\n                       End nodes responding to queries always\
    \ set\n                       this bit in responses.\n"
- title: 4.2.1.2.  QUESTION SECTION
  contents:
  - "4.2.1.2.  QUESTION SECTION\n                        1 1 1 1 1 1 1 1 1 1 2 2 2\
    \ 2 2 2 2 2 2 2 3 3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6\
    \ 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                                                               |\n   /  \
    \                       QUESTION_NAME                         /\n   /        \
    \                                                       /\n   |              \
    \                                                 |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |         QUESTION_TYPE         |        QUESTION_CLASS         |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   Field            Description\n   QUESTION_NAME    The compressed name representation\
    \ of the\n                    NetBIOS name for the request.\n   QUESTION_TYPE\
    \    The type of request.  The values for this field\n                    are\
    \ specified for each request.\n   QUESTION_CLASS   The class of the request. \
    \ The values for this\n                    field are specified for each request.\n\
    \   QUESTION_TYPE is defined as:\n   Symbol      Value   Description:\n   NB \
    \        0x0020   NetBIOS general Name Service Resource Record\n   NBSTAT    \
    \ 0x0021   NetBIOS NODE STATUS Resource Record (See NODE\n                   \
    \    STATUS REQUEST)\n   QUESTION_CLASS is defined as:\n   Symbol      Value \
    \  Description:\n   IN         0x0001   Internet class\n"
- title: 4.2.1.3.  RESOURCE RECORD
  contents:
  - "4.2.1.3.  RESOURCE RECORD\n                        1 1 1 1 1 1 1 1 1 1 2 2 2\
    \ 2 2 2 2 2 2 2 3 3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6\
    \ 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                                                               |\n   /  \
    \                          RR_NAME                            /\n   /        \
    \                                                       /\n   |              \
    \                                                 |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |           RR_TYPE             |          RR_CLASS             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                              TTL                              |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |           RDLENGTH            |                               |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\
    \                               |\n   /                                      \
    \                         /\n   /                             RDATA          \
    \                   /\n   |                                                  \
    \             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   Field            Description\n   RR_NAME          The compressed name representation\
    \ of the\n                    NetBIOS name corresponding to this resource\n  \
    \                  record.\n   RR_TYPE          Resource record type code\n  \
    \ RR_CLASS         Resource record class code\n   TTL              The Time To\
    \ Live of a the resource record's\n                    name.\n   RDLENGTH    \
    \     Unsigned 16 bit integer that specifies the\n                    number of\
    \ bytes in the RDATA field.\n   RDATA            RR_CLASS and RR_TYPE dependent\
    \ field.  Contains\n                    the resource information for the NetBIOS\
    \ name.\n   RESOURCE RECORD RR_TYPE field definitions:\n   Symbol      Value \
    \  Description:\n   A          0x0001   IP address Resource Record (See REDIRECT\
    \ NAME\n                       QUERY RESPONSE)\n   NS         0x0002   Name Server\
    \ Resource Record (See REDIRECT\n                       NAME QUERY RESPONSE)\n\
    \   NULL       0x000A   NULL Resource Record (See WAIT FOR\n                 \
    \      ACKNOWLEDGEMENT RESPONSE)\n   NB         0x0020   NetBIOS general Name\
    \ Service Resource Record\n                       (See NB_FLAGS and NB_ADDRESS,\
    \ below)\n   NBSTAT     0x0021   NetBIOS NODE STATUS Resource Record (See NODE\n\
    \                       STATUS RESPONSE)\n   RESOURCE RECORD RR_CLASS field definitions:\n\
    \   Symbol      Value   Description:\n   IN         0x0001   Internet class\n\
    \   NB_FLAGS field of the RESOURCE RECORD RDATA field for RR_TYPE of\n   \"NB\"\
    :\n                                             1   1   1   1   1   1\n     0\
    \   1   2   3   4   5   6   7   8   9   0   1   2   3   4   5\n   +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\n\
    \   | G |  ONT  |                RESERVED                           |\n   +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\n\
    \   Symbol     Bit(s)   Description:\n   RESERVED     3-15   Reserved for future\
    \ use.  Must be zero (0).\n   ONT           1,2   Owner Node Type:\n         \
    \                 00 = B node\n                          01 = P node\n       \
    \                   10 = M node\n                          11 = Reserved for future\
    \ use\n                       For registration requests this is the\n        \
    \               claimant's type.\n                       For responses this is\
    \ the actual owner's\n                       type.\n   G               0   Group\
    \ Name Flag.\n                       If one (1) then the RR_NAME is a GROUP\n\
    \                       NetBIOS name.\n                       If zero (0) then\
    \ the RR_NAME is a UNIQUE\n                       NetBIOS name.\n   The NB_ADDRESS\
    \ field of the RESOURCE RECORD RDATA field for\n   RR_TYPE of \"NB\" is the IP\
    \ address of the name's owner.\n"
- title: 4.2.2.  NAME REGISTRATION REQUEST
  contents:
  - "4.2.2.  NAME REGISTRATION REQUEST\n                        1 1 1 1 1 1 1 1 1\
    \ 1 2 2 2 2 2 2 2 2 2 2 3 3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2\
    \ 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |         NAME_TRN_ID           |0|  0x5  |0|0|1|0|0 0|B|  0x0  |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |          0x0001               |           0x0000              |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |          0x0000               |           0x0001              |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                                                               |\n   /  \
    \                       QUESTION_NAME                         /\n   /        \
    \                                                       /\n   |              \
    \                                                 |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |           NB (0x0020)         |        IN (0x0001)            |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                                                               |\n   /  \
    \                          RR_NAME                            /\n   /        \
    \                                                       /\n   |              \
    \                                                 |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |           NB (0x0020)         |         IN (0x0001)           |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                              TTL                              |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |           0x0006              |          NB_FLAGS             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                          NB_ADDRESS                           |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   Since the RR_NAME is the same name as the QUESTION_NAME, the\n   RR_NAME representation\
    \ must use pointers to the QUESTION_NAME\n   name's labels to guarantee the length\
    \ of the datagram is less\n   than the maximum 576 bytes.  See section above on\
    \ name formats\n   and also page 31 and 32 of RFC 883, Domain Names - Implementation\n\
    \   and Specification, for a complete description of compressed name\n   label\
    \ pointers.\n"
- title: 4.2.3.  NAME OVERWRITE REQUEST & DEMAND
  contents:
  - "4.2.3.  NAME OVERWRITE REQUEST & DEMAND\n                        1 1 1 1 1 1\
    \ 1 1 1 1 2 2 2 2 2 2 2 2 2 2 3 3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9\
    \ 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |         NAME_TRN_ID           |0|  0x5  |0|0|0|0|0 0|B|  0x0  |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |          0x0001               |           0x0000              |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |          0x0000               |           0x0001              |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                                                               |\n   /  \
    \                       QUESTION_NAME                         /\n   /        \
    \                                                       /\n   |              \
    \                                                 |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |           NB (0x0020)         |        IN (0x0001)            |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                                                               |\n   /  \
    \                          RR_NAME                            /\n   /        \
    \                                                       /\n   |              \
    \                                                 |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |           NB (0x0020)         |         IN (0x0001)           |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                              TTL                              |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |           0x0006              |          NB_FLAGS             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                          NB_ADDRESS                           |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n"
- title: 4.2.4.  NAME REFRESH REQUEST
  contents:
  - "4.2.4.  NAME REFRESH REQUEST\n                        1 1 1 1 1 1 1 1 1 1 2 2\
    \ 2 2 2 2 2 2 2 2 3 3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5\
    \ 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |         NAME_TRN_ID           |0|  0x9  |0|0|0|0|0 0|B|  0x0  |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |          0x0001               |           0x0000              |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |          0x0000               |           0x0001              |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                                                               |\n   /  \
    \                       QUESTION_NAME                         /\n   /        \
    \                                                       /\n   |              \
    \                                                 |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |           NB (0x0020)         |        IN (0x0001)            |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                                                               |\n   /  \
    \                          RR_NAME                            /\n   /        \
    \                                                       /\n   |              \
    \                                                 |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |           NB (0x0020)         |         IN (0x0001)           |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                              TTL                              |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |           0x0006              |          NB_FLAGS             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                          NB_ADDRESS                           |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n"
- title: 4.2.5.  POSITIVE NAME REGISTRATION RESPONSE
  contents:
  - "4.2.5.  POSITIVE NAME REGISTRATION RESPONSE\n                        1 1 1 1\
    \ 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 3 3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7\
    \ 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |         NAME_TRN_ID           |1|  0x5  |1|0|1|1|0 0|0|  0x0  |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |          0x0000               |           0x0001              |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |          0x0000               |           0x0000              |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                                                               |\n   /  \
    \                          RR_NAME                            /\n   /        \
    \                                                       /\n   |              \
    \                                                 |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |           NB (0x0020)         |         IN (0x0001)           |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                              TTL                              |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |           0x0006              |          NB_FLAGS             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                          NB_ADDRESS                           |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n"
- title: 4.2.6.  NEGATIVE NAME REGISTRATION RESPONSE
  contents:
  - "4.2.6.  NEGATIVE NAME REGISTRATION RESPONSE\n                        1 1 1 1\
    \ 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 3 3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7\
    \ 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |         NAME_TRN_ID           |1|  0x5  |1|0|1|1|0 0|0| RCODE |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |          0x0000               |           0x0001              |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |          0x0000               |           0x0000              |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                                                               |\n   /  \
    \                          RR_NAME                            /\n   /        \
    \                                                       /\n   |              \
    \                                                 |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |           NB (0x0020)         |         IN (0x0001)           |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                              TTL                              |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |           0x0006              |          NB_FLAGS             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                          NB_ADDRESS                           |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   RCODE field values:\n   Symbol      Value   Description:\n   FMT_ERR     \
    \  0x1   Format Error.  Request was invalidly\n                       formatted.\n\
    \   SRV_ERR       0x2   Server failure.  Problem with NBNS, cannot\n         \
    \              process name.\n   IMP_ERR       0x4   Unsupported request error.\
    \  Allowable only\n                       for challenging NBNS when gets an Update\
    \ type\n                       registration request.\n   RFS_ERR       0x5   Refused\
    \ error.  For policy reasons server\n                       will not register\
    \ this name from this host.\n   ACT_ERR       0x6   Active error.  Name is owned\
    \ by another node.\n   CFT_ERR       0x7   Name in conflict error.  A UNIQUE name\
    \ is\n                       owned by more than one node.\n"
- title: 4.2.7.  END-NODE CHALLENGE REGISTRATION RESPONSE
  contents:
  - "4.2.7.  END-NODE CHALLENGE REGISTRATION RESPONSE\n                        1 1\
    \ 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 3 3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5\
    \ 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |         NAME_TRN_ID           |1|  0x5  |1|0|1|0|0 0|0|  0x0  |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |          0x0000               |           0x0001              |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |          0x0000               |           0x0000              |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                                                               |\n   /  \
    \                          RR_NAME                            /\n   /        \
    \                                                       /\n   |              \
    \                                                 |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |           NB (0x0020)         |         IN (0x0001)           |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                              TTL                              |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |           0x0006              |          NB_FLAGS             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                          NB_ADDRESS                           |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n"
- title: 4.2.8.  NAME CONFLICT DEMAND
  contents:
  - "4.2.8.  NAME CONFLICT DEMAND\n                        1 1 1 1 1 1 1 1 1 1 2 2\
    \ 2 2 2 2 2 2 2 2 3 3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5\
    \ 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |         NAME_TRN_ID           |1|  0x5  |1|0|1|1|0 0|0|  0x7  |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |          0x0000               |           0x0001              |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |          0x0000               |           0x0000              |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                                                               |\n   /  \
    \                          RR_NAME                            /\n   /        \
    \                                                       /\n   |              \
    \                                                 |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |           NB (0x0020)         |         IN (0x0001)           |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                          0x00000000                           |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |           0x0006              |0|ONT|0|     0x000             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                          0x00000000                           |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   This packet is identical to a NEGATIVE NAME REGISTRATION RESPONSE\n   with\
    \ RCODE = CFT_ERR.\n"
- title: 4.2.9.  NAME RELEASE REQUEST & DEMAND
  contents:
  - "4.2.9.  NAME RELEASE REQUEST & DEMAND\n                        1 1 1 1 1 1 1\
    \ 1 1 1 2 2 2 2 2 2 2 2 2 2 3 3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0\
    \ 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |         NAME_TRN_ID           |0|  0x6  |0|0|0|0|0 0|B|  0x0  |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |          0x0001               |           0x0000              |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |          0x0000               |           0x0001              |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                                                               |\n   /  \
    \                       QUESTION_NAME                         /\n   /        \
    \                                                       /\n   |              \
    \                                                 |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |           NB (0x0020)         |        IN (0x0001)            |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                                                               |\n   /  \
    \                          RR_NAME                            /\n   /        \
    \                                                       /\n   |              \
    \                                                 |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |           NB (0x0020)         |         IN (0x0001)           |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                          0x00000000                           |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |           0x0006              |          NB_FLAGS             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                          NB_ADDRESS                           |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   Since the RR_NAME is the same name as the QUESTION_NAME, the\n   RR_NAME representation\
    \ must use label string pointers to the\n   QUESTION_NAME labels to guarantee\
    \ the length of the datagram is\n   less than the maximum 576 bytes.  This is\
    \ the same condition as\n   with the NAME REGISTRATION REQUEST.\n"
- title: 4.2.10.  POSITIVE NAME RELEASE RESPONSE
  contents:
  - "4.2.10.  POSITIVE NAME RELEASE RESPONSE\n                        1 1 1 1 1 1\
    \ 1 1 1 1 2 2 2 2 2 2 2 2 2 2 3 3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9\
    \ 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |         NAME_TRN_ID           |1|  0x6  |1|0|0|0|0 0|0|  0x0  |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |          0x0000               |           0x0001              |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |          0x0000               |           0x0000              |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                                                               |\n   /  \
    \                          RR_NAME                            /\n   /        \
    \                                                       /\n   |              \
    \                                                 |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |           NB (0x0020)         |         IN (0x0001)           |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                              TTL                              |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |           0x0006              |          NB_FLAGS             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                          NB_ADDRESS                           |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n"
- title: 4.2.11.  NEGATIVE NAME RELEASE RESPONSE
  contents:
  - "4.2.11.  NEGATIVE NAME RELEASE RESPONSE\n                        1 1 1 1 1 1\
    \ 1 1 1 1 2 2 2 2 2 2 2 2 2 2 3 3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9\
    \ 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |         NAME_TRN_ID           |1|  0x6  |1|0|0|0|0 0|0| RCODE |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |          0x0000               |           0x0001              |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |          0x0000               |           0x0000              |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                                                               |\n   /  \
    \                          RR_NAME                            /\n   /        \
    \                                                       /\n   |              \
    \                                                 |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |           NB (0x0020)         |         IN (0x0001)           |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                              TTL                              |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |           0x0006              |          NB_FLAGS             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                          NB_ADDRESS                           |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   RCODE field values:\n   Symbol      Value   Description:\n   FMT_ERR     \
    \  0x1   Format Error.  Request was invalidly\n                       formatted.\n\
    \   SRV_ERR       0x2   Server failure.  Problem with NBNS, cannot\n         \
    \              process name.\n   RFS_ERR       0x5   Refused error.  For policy\
    \ reasons server\n                       will not release this name from this\
    \ host.\n   ACT_ERR       0x6   Active error.  Name is owned by another node.\n\
    \                       Only that node may release it.  A NetBIOS\n          \
    \             Name Server can optionally allow a node to\n                   \
    \    release a name it does not own.  This would\n                       facilitate\
    \ detection of inactive names for\n                       nodes that went down\
    \ silently.\n"
- title: 4.2.12.  NAME QUERY REQUEST
  contents:
  - "4.2.12.  NAME QUERY REQUEST\n                        1 1 1 1 1 1 1 1 1 1 2 2\
    \ 2 2 2 2 2 2 2 2 3 3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5\
    \ 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |         NAME_TRN_ID           |0|  0x0  |0|0|1|0|0 0|B|  0x0  |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |          0x0001               |           0x0000              |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |          0x0000               |           0x0000              |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                                                               |\n   /  \
    \                       QUESTION_NAME                         /\n   /        \
    \                                                       /\n   |              \
    \                                                 |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |           NB (0x0020)         |        IN (0x0001)            |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n"
- title: 4.2.13.  POSITIVE NAME QUERY RESPONSE
  contents:
  - "4.2.13.  POSITIVE NAME QUERY RESPONSE\n                        1 1 1 1 1 1 1\
    \ 1 1 1 2 2 2 2 2 2 2 2 2 2 3 3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0\
    \ 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |         NAME_TRN_ID           |1|  0x0  |1|T|1|?|0 0|0|  0x0  |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |          0x0000               |           0x0001              |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |          0x0000               |           0x0000              |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                                                               |\n   /  \
    \                          RR_NAME                            /\n   /        \
    \                                                       /\n   |              \
    \                                                 |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |           NB (0x0020)         |         IN (0x0001)           |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                              TTL                              |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |           RDLENGTH            |                               |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\
    \                               |\n   |                                      \
    \                         |\n   /                       ADDR_ENTRY ARRAY     \
    \                   /\n   /                                                  \
    \             /\n   |                                                        \
    \       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   The ADDR_ENTRY ARRAY a sequence of zero or more ADDR_ENTRY\n   records.  Each\
    \ ADDR_ENTRY record represents an owner of a name.\n   For group names there may\
    \ be multiple entries.  However, the list\n   may be incomplete due to packet\
    \ size limitations.  Bit 22, \"T\",\n   will be set to indicate truncated data.\n\
    \   Each ADDR_ENTRY has the following format:\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |          NB_FLAGS             |          NB_ADDRESS           |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |   NB_ADDRESS (continued)      |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n"
- title: 4.2.14.  NEGATIVE NAME QUERY RESPONSE
  contents:
  - "4.2.14.  NEGATIVE NAME QUERY RESPONSE\n                        1 1 1 1 1 1 1\
    \ 1 1 1 2 2 2 2 2 2 2 2 2 2 3 3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0\
    \ 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |         NAME_TRN_ID           |1|  0x0  |1|0|1|?|0 0|0| RCODE |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |          0x0000               |           0x0000              |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |          0x0000               |           0x0000              |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                                                               |\n   /  \
    \                          RR_NAME                            /\n   /        \
    \                                                       /\n   |              \
    \                                                 |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |           NULL (0x000A)       |         IN (0x0001)           |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                          0x00000000                           |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |           0x0000              |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   RCODE field values:\n   Symbol      Value   Description\n   FMT_ERR      \
    \ 0x1   Format Error.  Request was invalidly\n                       formatted.\n\
    \   SRV_ERR       0x2   Server failure.  Problem with NBNS, cannot\n         \
    \              process name.\n   NAM_ERR       0x3   Name Error.  The name requested\
    \ does not\n                       exist.\n   IMP_ERR       0x4   Unsupported\
    \ request error.  Allowable only\n                       for challenging NBNS\
    \ when gets an Update type\n                       registration request.\n   RFS_ERR\
    \       0x5   Refused error.  For policy reasons server\n                    \
    \   will not register this name from this host.\n"
- title: 4.2.15.  REDIRECT NAME QUERY RESPONSE
  contents:
  - "4.2.15.  REDIRECT NAME QUERY RESPONSE\n                        1 1 1 1 1 1 1\
    \ 1 1 1 2 2 2 2 2 2 2 2 2 2 3 3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0\
    \ 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |         NAME_TRN_ID           |1|  0x0  |0|0|1|0|0 0|0|  0x0  |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |          0x0000               |           0x0000              |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |          0x0001               |           0x0001              |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                                                               |\n   /  \
    \                          RR_NAME                            /\n   /        \
    \                                                       /\n   |              \
    \                                                 |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |           NS (0x0002)         |         IN (0x0001)           |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                              TTL                              |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |           RDLENGTH            |                               |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\
    \                               +\n   |                                      \
    \                         |\n   /                            NSD_NAME        \
    \                   /\n   /                                                  \
    \             /\n   |                                                        \
    \       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                                                               |\n   /  \
    \                          RR_NAME                            /\n   /        \
    \                                                       /\n   |              \
    \                                                 |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |           A (0x0001)          |         IN (0x0001)           |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                              TTL                              |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |             0x0004            |           NSD_IP_ADDR         |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |     NSD_IP_ADDR, continued    |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   An end node responding to a NAME QUERY REQUEST always responds\n   with the\
    \ AA and RA bits set for both the NEGATIVE and POSITIVE\n   NAME QUERY RESPONSE\
    \ packets.  An end node never sends a REDIRECT\n   NAME QUERY RESPONSE packet.\n\
    \   When the requestor receives the REDIRECT NAME QUERY RESPONSE it\n   must reiterate\
    \ the NAME QUERY REQUEST to the NBNS specified by\n   the NSD_IP_ADDR field of\
    \ the A type RESOURCE RECORD in the\n   ADDITIONAL section of the response packet.\
    \  This is an optional\n   packet for the NBNS.\n   The NSD_NAME and the RR_NAME\
    \ in the ADDITIONAL section of the\n   response packet are the same name.  Space\
    \ can be optimized if\n   label string pointers are used in the RR_NAME which\
    \ point to the\n   labels in the NSD_NAME.\n   The RR_NAME in the AUTHORITY section\
    \ is the name of the domain\n   the NBNS called by NSD_NAME has authority over.\n"
- title: 4.2.16.  WAIT FOR ACKNOWLEDGEMENT (WACK) RESPONSE
  contents:
  - "4.2.16.  WAIT FOR ACKNOWLEDGEMENT (WACK) RESPONSE\n                        1\
    \ 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 3 3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4\
    \ 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |         NAME_TRN_ID           |1|  0x7  |1|0|0|0|0 0|0|  0x0  |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |          0x0000               |           0x0001              |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |          0x0000               |           0x0000              |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                                                               |\n   /  \
    \                          RR_NAME                            /\n   /        \
    \                                                       /\n   |              \
    \                                                 |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |          NULL (0x0020)        |         IN (0x0001)           |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                              TTL                              |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |           0x0002              | OPCODE  |   NM_FLAGS  |  0x0  |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   The NAME_TRN_ID of the WACK RESPONSE packet is the same\n   NAME_TRN_ID of\
    \ the request that the NBNS is telling the requestor\n   to wait longer to complete.\
    \  The RR_NAME is the name from the\n   request, if any.  If no name is available\
    \ from the request then\n   it is a null name, single byte of zero.\n   The TTL\
    \ field of the ResourceRecord is the new time to wait, in\n   seconds, for the\
    \ request to complete.  The RDATA field contains\n   the OPCODE and NM_FLAGS of\
    \ the request.\n   A TTL value of 0 means that the NBNS can not estimate the time\
    \ it\n   may take to complete a response.\n"
- title: 4.2.17.  NODE STATUS REQUEST
  contents:
  - "4.2.17.  NODE STATUS REQUEST\n                        1 1 1 1 1 1 1 1 1 1 2 2\
    \ 2 2 2 2 2 2 2 2 3 3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5\
    \ 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |         NAME_TRN_ID           |0|  0x0  |0|0|0|0|0 0|B|  0x0  |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |          0x0001               |           0x0000              |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |          0x0000               |           0x0000              |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                                                               |\n   /  \
    \                       QUESTION_NAME                         /\n   |        \
    \                                                       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |         NBSTAT (0x0021)       |        IN (0x0001)            |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n"
- title: 4.2.18.  NODE STATUS RESPONSE
  contents:
  - "4.2.18.  NODE STATUS RESPONSE\n                        1 1 1 1 1 1 1 1 1 1 2\
    \ 2 2 2 2 2 2 2 2 2 3 3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4\
    \ 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |         NAME_TRN_ID           |1|  0x0  |1|0|0|0|0 0|0|  0x0  |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |          0x0000               |           0x0001              |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |          0x0000               |           0x0000              |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                                                               |\n   /  \
    \                          RR_NAME                            /\n   |        \
    \                                                       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |        NBSTAT (0x0021)        |         IN (0x0001)           |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                          0x00000000                           |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |          RDLENGTH             |   NUM_NAMES   |               |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\
    \               +\n   |                                                      \
    \         |\n   +                                                            \
    \   +\n   /                         NODE_NAME ARRAY                       /\n\
    \   +                                                               +\n   |  \
    \                                                             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                                                               |\n   +  \
    \                                                             +\n   /        \
    \                   STATISTICS                          /\n   +              \
    \                                                 +\n   |                    \
    \                                           |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   The NODE_NAME ARRAY is an array of zero or more NUM_NAMES entries\n   of NODE_NAME\
    \ records.  Each NODE_NAME entry represents an active\n   name in the same NetBIOS\
    \ scope as the requesting name in the\n   local name table of the responder. \
    \ RR_NAME is the requesting\n   name.\n   NODE_NAME Entry:\n                 \
    \       1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 3 3\n    0 1 2 3 4 5 6 7 8 9 0\
    \ 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                                                               |\n   +---\
    \                                                         ---+\n   |         \
    \                                                      |\n   +---            \
    \        NETBIOS FORMAT NAME                  ---+\n   |                     \
    \                                          |\n   +---                        \
    \                                 ---+\n   |                                 \
    \                              |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |         NAME_FLAGS            |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   The NAME_FLAGS field:\n                                             1   1\
    \   1   1   1   1\n     0   1   2   3   4   5   6   7   8   9   0   1   2   3\
    \   4   5\n   +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\n\
    \   | G |  ONT  |DRG|CNF|ACT|PRM|          RESERVED                 |\n   +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\n\
    \   The NAME_FLAGS field is defined as:\n   Symbol     Bit(s)   Description:\n\
    \   RESERVED     7-15   Reserved for future use.  Must be zero (0).\n   PRM  \
    \           6   Permanent Name Flag.  If one (1) then entry\n                \
    \       is for the permanent node name.  Flag is zero\n                      \
    \ (0) for all other names.\n   ACT             5   Active Name Flag.  All entries\
    \ have this flag\n                       set to one (1).\n   CNF             4\
    \   Conflict Flag.  If one (1) then name on this\n                       node\
    \ is in conflict.\n   DRG             3   Deregister Flag.  If one (1) then this\
    \ name\n                       is in the process of being deleted.\n   ONT   \
    \        1,2   Owner Node Type:\n                          00 = B node\n     \
    \                     01 = P node\n                          10 = M node\n   \
    \                       11 = Reserved for future use\n   G               0   Group\
    \ Name Flag.\n                       If one (1) then the name is a GROUP NetBIOS\n\
    \                       name.\n                       If zero (0) then it is a\
    \ UNIQUE NetBIOS name.\n   STATISTICS Field of the NODE STATUS RESPONSE:\n   \
    \                     1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 3 3\n    0 1 2 3\
    \ 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |               UNIT_ID (Unique unit ID)                        |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |       UNIT_ID,continued       |    JUMPERS    |  TEST_RESULT  |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |       VERSION_NUMBER          |      PERIOD_OF_STATISTICS     |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |       NUMBER_OF_CRCs          |     NUMBER_ALIGNMENT_ERRORS   |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |       NUMBER_OF_COLLISIONS    |        NUMBER_SEND_ABORTS     |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                       NUMBER_GOOD_SENDS                       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                      NUMBER_GOOD_RECEIVES                     |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |       NUMBER_RETRANSMITS      | NUMBER_NO_RESOURCE_CONDITIONS |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |  NUMBER_FREE_COMMAND_BLOCKS   |  TOTAL_NUMBER_COMMAND_BLOCKS  |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |MAX_TOTAL_NUMBER_COMMAND_BLOCKS|    NUMBER_PENDING_SESSIONS    |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |  MAX_NUMBER_PENDING_SESSIONS  |  MAX_TOTAL_SESSIONS_POSSIBLE  |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |   SESSION_DATA_PACKET_SIZE    |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n"
- title: 4.3.  SESSION SERVICE PACKETS
  contents:
  - '4.3.  SESSION SERVICE PACKETS

    '
- title: 4.3.1.  GENERAL FORMAT OF SESSION PACKETS
  contents:
  - "4.3.1.  GENERAL FORMAT OF SESSION PACKETS\n   All session service messages are\
    \ sent over a TCP connection.\n   All session packets are of the following general\
    \ structure:\n                        1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2\
    \ 3 3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n \
    \  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   |   \
    \   TYPE     |     FLAGS     |            LENGTH             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                                                               |\n   /  \
    \             TRAILER (Packet Type Dependent)                 /\n   |        \
    \                                                       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   The TYPE, FLAGS, and LENGTH fields are present in every session\n   packet.\n\
    \   The LENGTH field is the number of bytes following the LENGTH\n   field.  In\
    \ other words, LENGTH is the combined size of the\n   TRAILER field(s).  For example,\
    \ the POSITIVE SESSION RESPONSE\n   packet always has a LENGTH field value of\
    \ zero (0000) while the\n   RETARGET SESSION RESPONSE always has a LENGTH field\
    \ value of six\n   (0006).\n   One of the bits of the FLAGS field acts as an additional,\
    \ high-\n   order bit for the LENGTH field.  Thus the cumulative size of the\n\
    \   trailer field(s) may range from 0 to 128K bytes.\n   Session Packet Types\
    \ (in hexidecimal):\n           00 -  SESSION MESSAGE\n           81 -  SESSION\
    \ REQUEST\n           82 -  POSITIVE SESSION RESPONSE\n           83 -  NEGATIVE\
    \ SESSION RESPONSE\n           84 -  RETARGET SESSION RESPONSE\n           85\
    \ -  SESSION KEEP ALIVE\n   Bit definitions of the FLAGS field:\n     0   1  \
    \ 2   3   4   5   6   7\n   +---+---+---+---+---+---+---+---+\n   | 0 | 0 | 0\
    \ | 0 | 0 | 0 | 0 | E |\n   +---+---+---+---+---+---+---+---+\n   Symbol     Bit(s)\
    \   Description\n   E               7   Length extension, used as an additional,\n\
    \                       high-order bit on the LENGTH field.\n   RESERVED     \
    \ 0-6   Reserved, must be zero (0)\n"
- title: 4.3.2.  SESSION REQUEST PACKET
  contents:
  - "4.3.2.  SESSION REQUEST PACKET\n                        1 1 1 1 1 1 1 1 1 1 2\
    \ 2 2 2 2 2 2 2 2 2 3 3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4\
    \ 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |      TYPE     |     FLAGS     |            LENGTH             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                                                               |\n   /  \
    \                        CALLED NAME                          /\n   |        \
    \                                                       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                                                               |\n   /  \
    \                        CALLING NAME                         /\n   |        \
    \                                                       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n"
- title: 4.3.3.  POSITIVE SESSION RESPONSE PACKET
  contents:
  - "4.3.3.  POSITIVE SESSION RESPONSE PACKET\n                        1 1 1 1 1 1\
    \ 1 1 1 1 2 2 2 2 2 2 2 2 2 2 3 3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9\
    \ 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |      TYPE     |     FLAGS     |            LENGTH             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n"
- title: 4.3.4.  NEGATIVE SESSION RESPONSE PACKET
  contents:
  - "4.3.4.  NEGATIVE SESSION RESPONSE PACKET\n                        1 1 1 1 1 1\
    \ 1 1 1 1 2 2 2 2 2 2 2 2 2 2 3 3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9\
    \ 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |      TYPE     |     FLAGS     |            LENGTH             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |   ERROR_CODE  |\n   +-+-+-+-+-+-+-+-+\n   NEGATIVE SESSION RESPONSE packet\
    \ error code values (in\n   hexidecimal):\n           80 -  Not listening on called\
    \ name\n           81 -  Not listening for calling name\n           82 -  Called\
    \ name not present\n           83 -  Called name present, but insufficient resources\n\
    \           8F -  Unspecified error\n"
- title: 4.3.5.  SESSION RETARGET RESPONSE PACKET
  contents:
  - "4.3.5.  SESSION RETARGET RESPONSE PACKET\n                        1 1 1 1 1 1\
    \ 1 1 1 1 2 2 2 2 2 2 2 2 2 2 3 3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9\
    \ 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |      TYPE     |     FLAGS     |            LENGTH             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                      RETARGET_IP_ADDRESS                      |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |           PORT                |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n"
- title: 4.3.6.  SESSION MESSAGE PACKET
  contents:
  - "4.3.6.  SESSION MESSAGE PACKET\n                        1 1 1 1 1 1 1 1 1 1 2\
    \ 2 2 2 2 2 2 2 2 2 3 3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4\
    \ 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |      TYPE     |     FLAGS     |            LENGTH             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                                                               |\n   /  \
    \                                                             /\n   /        \
    \                   USER_DATA                           /\n   /              \
    \                                                 /\n   |                    \
    \                                           |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n"
- title: 4.3.7.  SESSION KEEP ALIVE PACKET
  contents:
  - "4.3.7.  SESSION KEEP ALIVE PACKET\n                        1 1 1 1 1 1 1 1 1\
    \ 1 2 2 2 2 2 2 2 2 2 2 3 3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2\
    \ 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |      TYPE     |     FLAGS     |            LENGTH             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n"
- title: 4.4.  DATAGRAM SERVICE PACKETS
  contents:
  - '4.4.  DATAGRAM SERVICE PACKETS

    '
- title: 4.4.1.  NetBIOS DATAGRAM HEADER
  contents:
  - "4.4.1.  NetBIOS DATAGRAM HEADER\n                        1 1 1 1 1 1 1 1 1 1\
    \ 2 2 2 2 2 2 2 2 2 2 3 3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3\
    \ 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |   MSG_TYPE    |     FLAGS     |           DGM_ID              |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                           SOURCE_IP                           |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |          SOURCE_PORT          |          DGM_LENGTH           |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |         PACKET_OFFSET         |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   MSG_TYPE values (in hexidecimal):\n           10 -  DIRECT_UNIQUE DATAGRAM\n\
    \           11 -  DIRECT_GROUP DATAGRAM\n           12 -  BROADCAST DATAGRAM\n\
    \           13 -  DATAGRAM ERROR\n           14 -  DATAGRAM QUERY REQUEST\n  \
    \         15 -  DATAGRAM POSITIVE QUERY RESPONSE\n           16 -  DATAGRAM NEGATIVE\
    \ QUERY RESPONSE\n   Bit definitions of the FLAGS field:\n     0   1   2   3 \
    \  4   5   6   7\n   +---+---+---+---+---+---+---+---+\n   | 0 | 0 | 0 | 0 | \
    \ SNT  | F | M |\n   +---+---+---+---+---+---+---+---+\n   Symbol     Bit(s) \
    \  Description\n   M               7   MORE flag, If set then more NetBIOS datagram\n\
    \                       fragments follow.\n   F               6   FIRST packet\
    \ flag,  If set then this is first\n                       (and possibly only)\
    \ fragment of NetBIOS\n                       datagram\n   SNT           4,5 \
    \  Source End-Node type:\n                          00 = B node\n            \
    \              01 = P node\n                          10 = M node\n          \
    \                11 = NBDD\n   RESERVED      0-3   Reserved, must be zero (0)\n"
- title: 4.4.2.  DIRECT_UNIQUE, DIRECT_GROUP, & BROADCAST DATAGRAM
  contents:
  - "4.4.2.  DIRECT_UNIQUE, DIRECT_GROUP, & BROADCAST DATAGRAM\n                 \
    \       1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 3 3\n    0 1 2 3 4 5 6 7 8 9 0\
    \ 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |   MSG_TYPE    |     FLAGS     |           DGM_ID              |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                           SOURCE_IP                           |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |          SOURCE_PORT          |          DGM_LENGTH           |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |         PACKET_OFFSET         |                               |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\
    \                               |\n   |                                      \
    \                         |\n   /                          SOURCE_NAME       \
    \                   /\n   /                                                  \
    \             /\n   |                                                        \
    \       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                                                               |\n   /  \
    \                     DESTINATION_NAME                        /\n   /        \
    \                                                       /\n   |              \
    \                                                 |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                                                               |\n   /  \
    \                         USER_DATA                           /\n   /        \
    \                                                       /\n   |              \
    \                                                 |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   4.4.3.  DATAGRAM ERROR PACKET\n                        1 1 1 1 1 1 1 1 1 1\
    \ 2 2 2 2 2 2 2 2 2 2 3 3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3\
    \ 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |   MSG_TYPE    |     FLAGS     |           DGM_ID              |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                           SOURCE_IP                           |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |          SOURCE_PORT          |  ERROR_CODE   |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   ERROR_CODE values (in hexidecimal):\n           82 -  DESTINATION NAME NOT\
    \ PRESENT\n           83 -  INVALID SOURCE NAME FORMAT\n           84 -  INVALID\
    \ DESTINATION NAME FORMAT\n"
- title: 4.4.4.  DATAGRAM QUERY REQUEST
  contents:
  - "4.4.4.  DATAGRAM QUERY REQUEST\n                        1 1 1 1 1 1 1 1 1 1 2\
    \ 2 2 2 2 2 2 2 2 2 3 3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4\
    \ 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |   MSG_TYPE    |     FLAGS     |           DGM_ID              |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                           SOURCE_IP                           |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |          SOURCE_PORT          |                               |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\
    \                               +\n   |                                      \
    \                         |\n   /                       DESTINATION_NAME     \
    \                   /\n   /                                                  \
    \             /\n   |                                                        \
    \       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n"
- title: 4.4.5.  DATAGRAM POSITIVE AND NEGATIVE QUERY RESPONSE
  contents:
  - "4.4.5.  DATAGRAM POSITIVE AND NEGATIVE QUERY RESPONSE\n                     \
    \   1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 3 3\n    0 1 2 3 4 5 6 7 8 9 0 1 2\
    \ 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |   MSG_TYPE    |     FLAGS     |           DGM_ID              |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                           SOURCE_IP                           |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |          SOURCE_PORT          |                               |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\
    \                               +\n   |                                      \
    \                         |\n   /                       DESTINATION_NAME     \
    \                   /\n   /                                                  \
    \             /\n   |                                                        \
    \       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n"
- title: 5.  PROTOCOL DESCRIPTIONS
  contents:
  - '5.  PROTOCOL DESCRIPTIONS

    '
- title: 5.1.  NAME SERVICE PROTOCOLS
  contents:
  - "5.1.  NAME SERVICE PROTOCOLS\n   A REQUEST packet is always sent to the well\
    \ known UDP port -\n   NAME_SERVICE_UDP_PORT.  The destination address is normally\n\
    \   either the IP broadcast address or the address of the NBNS - the\n   address\
    \ of the NBNS server it set up at initialization time.  In\n   rare cases, a request\
    \ packet will be sent to an end node, e.g.  a\n   NAME QUERY REQUEST sent to \"\
    challenge\" a node.\n   A RESPONSE packet is always sent to the source UDP port\
    \ and\n   source IP address of the request packet.\n   A DEMAND packet must always\
    \ be sent to the well known UDP port -\n   NAME_SERVICE_UDP_PORT.  There is no\
    \ restriction on the target IP\n   address.\n   Terms used in this section:\n\
    \   tid -            Transaction ID.  This is a value composed from\n        \
    \            the requestor's IP address and a unique 16 bit\n                \
    \    value generated by the originator of the\n                    transaction.\n"
- title: 5.1.1.  B-NODE ACTIVITY
  contents:
  - '5.1.1.  B-NODE ACTIVITY

    '
- title: 5.1.1.1.  B-NODE ADD NAME
  contents:
  - "5.1.1.1.  B-NODE ADD NAME\n   PROCEDURE add_name(newname)\n   /*\n    * Host\
    \ initiated processing for a B node\n    */\n   BEGIN\n        REPEAT\n      \
    \       /* build name service packet */\n             ONT = B_NODE; /* broadcast\
    \ node */\n             G = UNIQUE;   /* unique name */\n             TTL = 0;\n\
    \             broadcast NAME REGISTRATION REQUEST packet;\n             /*\n \
    \             * remote node(s) will send response packet\n              * if applicable\n\
    \              */\n             pause(BCAST_REQ_RETRY_TIMEOUT);\n        UNTIL\
    \ response packet is received or\n             retransmit count has been exceeded\n\
    \        IF no response packet was received THEN\n        BEGIN /* no response\
    \ */\n             /*\n              * build packet\n              */\n      \
    \       ONT = B_NODE; /* broadcast node */\n             G = UNIQUE;   /* unique\
    \ name */\n             TTL = 0;\n             /*\n              * Let other nodes\
    \ known you have the name\n              */\n             broadcast NAME UPDATE\
    \ REQUEST packet;\n             /* name can be added to local name table */\n\
    \             return success;\n        END /* no response */\n        ELSE\n \
    \       BEGIN /* got response */\n             /*\n              * Match return\
    \ transaction id\n              * against tid sent in request\n              */\n\
    \            IF NOT response tid = request tid THEN\n            BEGIN\n     \
    \        ignore response packet;\n            END\n            ELSE\n        \
    \    CASE packet type OF\n            NEGATIVE NAME REGISTRATION RESPONSE:\n \
    \                return failure; /* name cannot be added */\n            POSITIVE\
    \ NAME REGISTRATION RESPONSE:\n            END-NODE CHALLENGE NAME REGISTRATION\
    \ RESPONSE:\n                 /*\n                  * B nodes should normally\
    \ not get this\n                  * response.\n                  */\n        \
    \          ignore packet;\n            END /* case */;\n        END /* got response\
    \ */\n   END /* procedure */\n"
- title: 5.1.1.2.  B-NODE ADD_GROUP NAME
  contents:
  - "5.1.1.2.  B-NODE ADD_GROUP NAME\n   PROCEDURE add_group_name(newname)\n   /*\n\
    \    * Host initiated processing for a B node\n    */\n   BEGIN\n        /*\n\
    \         * same as for a unique name with the\n         * exception that the\
    \ group bit (G) must\n         * be set in the request packets.\n         */\n\
    \        ...\n        G = GROUP;\n        ...\n        ...\n        /*\n     \
    \    * broadcast request ...\n         */\n   END\n"
- title: 5.1.1.3.  B-NODE FIND_NAME
  contents:
  - "5.1.1.3.  B-NODE FIND_NAME\n   PROCEDURE find_name(name)\n   /*\n    * Host initiated\
    \ processing for a B node\n    */\n   BEGIN\n        REPEAT\n             /*\n\
    \              * build packet\n              */\n             ONT = B;\n     \
    \        TTL = 0;\n             G = DONT CARE;\n             broadcast NAME QUERY\
    \ REQUEST packet;\n             /*\n              * a node might send response\
    \ packet\n              */\n             pause(BCAST_REQ_RETRY_TIMEOUT);\n   \
    \     UNTIL response packet received OR\n             max transmit threshold exceeded\n\
    \        IF no response packet received THEN\n             return failure;\n \
    \       ELSE\n        IF NOT response tid = request tid THEN\n             ignore\
    \ packet;\n        ELSE\n        CASE packet type OF\n        POSITIVE NAME QUERY\
    \ RESPONSE:\n             /*\n              * Start a timer to detect conflict.\n\
    \              *\n              * Be prepared to detect conflict if\n        \
    \      * any more response packets are received.\n              *\n          \
    \    */\n             save response as authoritative response;\n             start_timer(CONFLICT_TIMER);\n\
    \             return success;\n        NEGATIVE NAME QUERY RESPONSE:\n       \
    \ REDIRECT NAME QUERY RESPONSE:\n             /*\n              * B Node should\
    \ normally not get either\n              * response.\n              */\n     \
    \         ignore response packet;\n        END /* case */\n   END /* procedure\
    \ */\n"
- title: 5.1.1.4.  B NODE NAME RELEASE
  contents:
  - "5.1.1.4.  B NODE NAME RELEASE\n   PROCEDURE delete_name (name)\n   BEGIN\n  \
    \      REPEAT\n             /*\n              * build packet\n              */\n\
    \             ...\n             /*\n              * send request\n           \
    \   */\n             broadcast NAME RELEASE REQUEST packet;\n             /*\n\
    \              * no response packet expected\n              */\n             pause(BCAST_REQ_RETRY_TIMEOUT);\n\
    \        UNTIL retransmit count has been exceeded\n   END /* procedure */\n"
- title: 5.1.1.5.  B-NODE INCOMING PACKET PROCESSING
  contents:
  - "5.1.1.5.  B-NODE INCOMING PACKET PROCESSING\n   Following processing is done\
    \ when broadcast or unicast packets\n   are received at the NAME_SERVICE_UDP_PORT.\n\
    \   PROCEDURE process_incoming_packet(packet)\n   /*\n    * Processing initiated\
    \ by incoming packets for a B node\n    */\n   BEGIN\n        /*\n         * Note:\
    \ response packets are always sent\n         * to:\n         * source IP address\
    \ of request packet\n         * source UDP port of request packet\n         */\n\
    \        CASE packet type OF\n        NAME REGISTRATION REQUEST (UNIQUE):\n  \
    \           IF name exists in local name table THEN\n                  send NEGATIVE\
    \ NAME REGISTRATION RESPONSE ;\n        NAME REGISTRATION REQUEST (GROUP):\n \
    \            IF name exists in local name table THEN\n             BEGIN\n   \
    \               IF local entry is a unique name THEN\n                      send\
    \ NEGATIVE NAME REGISTRATION RESPONSE ;\n             END\n        NAME QUERY\
    \ REQUEST:\n             IF name exists in local name table THEN\n           \
    \  BEGIN\n                  build response packet;\n                  send POSITIVE\
    \ NAME QUERY RESPONSE;\n        POSITIVE NAME QUERY RESPONSE:\n             IF\
    \ name conflict timer is not active THEN\n             BEGIN\n               \
    \   /*\n                   * timer has expired already...  ignore this\n     \
    \              * packet\n                   */\n                  return;\n  \
    \           END\n             ELSE /* timer is active */\n             IF a response\
    \ for this name has previously been\n                  received THEN\n       \
    \      BEGIN /* existing entry */\n                  /*\n                   *\
    \ we sent out a request packet, and\n                   * have already received\
    \ (at least)\n                   * one response\n                   *\n      \
    \             * Check if conflict exists.\n                   * If so, send out\
    \ a conflict packet.\n                   *\n                   * Note: detecting\
    \ conflict does NOT\n                   * affect any existing sessions.\n    \
    \               *\n                   */\n                  /*\n             \
    \      * Check for name conflict.\n                   * See \"Name Conflict\"\
    \ in Concepts and Methods\n                   */\n                  check saved\
    \ authoritative response against\n                       information in this response\
    \ packet;\n                  IF conflict detected THEN\n                  BEGIN\n\
    \                       unicast NAME CONFLICT DEMAND packet;\n               \
    \        IF entry exists in cache THEN\n                       BEGIN\n       \
    \                     remove entry from cache;\n                       END\n \
    \                 END\n             END /* existing entry */\n             ELSE\n\
    \             BEGIN\n                  /*\n                   * Note: If this\
    \ was the first response\n                   * to a name query, it would have\
    \ been\n                   * handled in the\n                   * find_name()\
    \ procedure.\n                   */\n                  ignore packet;\n      \
    \       END\n        NAME CONFLICT DEMAND:\n             IF name exists in local\
    \ name table THEN\n             BEGIN\n                  mark name as conflict\
    \ detected;\n                  /*\n                   * a name in the state \"\
    conflict detected\"\n                   * does not \"logically\" exist on that\
    \ node.\n                   * No further session will be accepted on\n       \
    \            * that name.\n                   * No datagrams can be sent against\
    \ that name.\n                   * Such an entry will not be used for\n      \
    \             * purposes of processing incoming request\n                   *\
    \ packets.\n                   * The only valid user NetBIOS operation\n     \
    \              * against such a name is DELETE NAME.\n                   */\n\
    \             END\n        NAME RELEASE REQUEST:\n             IF caching is being\
    \ done THEN\n             BEGIN\n                  remove entry from cache;\n\
    \             END\n        NAME UPDATE REQUEST:\n             IF caching is being\
    \ done THEN\n             BEGIN\n                  IF entry exists in cache already,\n\
    \                       update cache;\n                  ELSE IF name is \"interesting\"\
    \ THEN\n                  BEGIN\n                       add entry to cache;\n\
    \                  END\n             END\n        NODE STATUS REQUEST:\n     \
    \        IF name exists in local name table THEN\n             BEGIN\n       \
    \           /*\n                   * send only those names that are\n        \
    \           * in the same scope as the scope\n                   * field in the\
    \ request packet\n                   */\n                  send NODE STATUS RESPONSE;\n\
    \             END\n   END\n"
- title: 5.1.2.  P-NODE ACTIVITY
  contents:
  - "5.1.2.  P-NODE ACTIVITY\n   All packets sent or received by P nodes are unicast\
    \ UDP packets.\n   A P node sends name service requests to the NBNS node that\
    \ is\n   specified in the P-node configuration.\n"
- title: 5.1.2.1.  P-NODE ADD_NAME
  contents:
  - "5.1.2.1.  P-NODE ADD_NAME\n   PROCEDURE add_name(newname)\n   /*\n    * Host\
    \ initiated processing for a P node\n    */\n   BEGIN\n        REPEAT\n      \
    \       /*\n              * build packet\n              */\n             ONT =\
    \ P;\n             G = UNIQUE;\n             ...\n             /*\n          \
    \    * send request\n              */\n             unicast NAME REGISTRATION\
    \ REQUEST packet;\n             /*\n              * NBNS will send response packet\n\
    \              */\n             IF receive a WACK RESPONSE THEN\n            \
    \      pause(time from TTL field of response);\n             ELSE\n          \
    \        pause(UCAST_REQ_RETRY_TIMEOUT);\n        UNTIL response packet is received\
    \ OR\n             retransmit count has been exceeded\n        IF no response\
    \ packet was received THEN\n        BEGIN /* no response */\n             /*\n\
    \              * NBNS is down.  Cannot claim name.\n              */\n       \
    \      return failure; /* name cannot be claimed */\n        END /* no response\
    \ */\n        ELSE\n        BEGIN /* response */\n            IF NOT response\
    \ tid = request tid THEN\n            BEGIN\n             /*  Packet may belong\
    \ to another transaction  */\n             ignore response packet;\n         \
    \   END\n            ELSE\n            CASE packet type OF\n            POSITIVE\
    \ NAME REGISTRATION RESPONSE:\n                 /*\n                  * name can\
    \ be added\n                  */\n                 adjust refresh timeout value,\
    \ TTL, for this name;\n                 return success;      /* name can be added\
    \ */\n            NEGATIVE NAME REGISTRATION RESPONSE:\n                 return\
    \ failure; /* name cannot be added */\n            END-NODE CHALLENGE REGISTRATION\
    \ REQUEST:\n            BEGIN /* end node challenge */\n                 /*\n\
    \                  * The response packet has in it the\n                  * address\
    \ of the presumed owner of the\n                  * name.  Challenge that owner.\n\
    \                  * If owner either does not\n                  * respond or\
    \ indicates that he no longer\n                  * owns the name, claim the name.\n\
    \                  * Otherwise, the name cannot be claimed.\n                \
    \  *\n                  */\n                 REPEAT\n                  /*\n  \
    \                 * build packet\n                   */\n                  ...\n\
    \                  unicast NAME QUERY REQUEST packet to the\n                \
    \       address contained in the END NODE\n                       CHALLENGE RESPONSE\
    \ packet;\n                  /*\n                   * remote node may send response\
    \ packet\n                   */\n                  pause(UCAST_REQ_RETRY_TIMEOUT);\n\
    \                 UNTIL response packet is received or\n                     retransmit\
    \ count has been exceeded\n                 IF no response packet is received\
    \ OR\n                       NEGATIVE NAME QUERY RESPONSE packet\n           \
    \            received THEN\n                 BEGIN /* update */\n            \
    \      /*\n                   * name can be claimed\n                   */\n \
    \                 REPEAT\n                      /*\n                       * build\
    \ packet\n                       */\n                       ...\n            \
    \          unicast NAME UPDATE REQUEST to NBNS;\n                      /*\n  \
    \                     * NBNS node will send response packet\n                \
    \       */\n                      IF receive a WACK RESPONSE THEN\n          \
    \                  pause(time from TTL field of response);\n                 \
    \     ELSE\n                            pause(UCAST_REQ_RETRY_TIMEOUT);\n    \
    \              UNTIL response packet is received or\n                      retransmit\
    \ count has been exceeded\n                  IF no response packet received THEN\n\
    \                  BEGIN /* no response */\n                       /*\n      \
    \                  * name could not be claimed\n                        */\n \
    \                      return failure;\n                  END /* no response */\n\
    \                  ELSE\n                  CASE packet type OF\n             \
    \          POSITIVE NAME REGISTRATION RESPONSE:\n                            /*\n\
    \                             * add name\n                             */\n  \
    \                          return success;\n                       NEGATIVE NAME\
    \ REGISTRATION RESPONSE:\n                            /*\n                   \
    \          * you lose  ...\n                             */\n                \
    \            return failure;\n                       END /* case */\n        \
    \         END /* update */\n                 ELSE\n                 /*\n     \
    \             * received a positive response to the \"challenge\"\n          \
    \        * Remote node still has name\n                  */\n                \
    \  return failure;\n            END /* end node challenge */\n        END /* response\
    \ */\n   END /* procedure */\n"
- title: 5.1.2.2.  P-NODE ADD GROUP NAME
  contents:
  - "5.1.2.2.  P-NODE ADD GROUP NAME\n   PROCEDURE add_group_name(newname)\n   /*\n\
    \    * Host initiated processing for a P node\n    */\n   BEGIN\n        /*\n\
    \         * same as for a unique name, except that the\n         * request packet\
    \ must indicate that a\n         * group name claim is being made.\n         */\n\
    \        ...\n        G = GROUP;\n        ...\n        /*\n         * send packet\n\
    \         */\n         ...\n   END\n   5.1.2.3.  P-NODE FIND NAME\n   PROCEDURE\
    \ find_name(name)\n   /*\n    * Host initiated processing for a P node\n    */\n\
    \   BEGIN\n        REPEAT\n             /*\n              * build packet\n   \
    \           */\n             ONT = P;\n             G = DONT CARE;\n         \
    \    unicast NAME QUERY REQUEST packet;\n             /*\n              * a NBNS\
    \ node might send response packet\n              */\n             IF receive a\
    \ WACK RESPONSE THEN\n                  pause(time from TTL field of response);\n\
    \             ELSE\n                  pause(UCAST_REQ_RETRY_TIMEOUT);\n      \
    \  UNTIL response packet received OR\n             max transmit threshold exceeded\n\
    \        IF no response packet received THEN\n             return failure;\n \
    \       ELSE\n        IF NOT response tid = request tid THEN\n             ignore\
    \ packet;\n        ELSE\n        CASE packet type OF\n        POSITIVE NAME QUERY\
    \ RESPONSE:\n             return success;\n        REDIRECT NAME QUERY RESPONSE:\n\
    \             /*\n              * NBNS node wants this end node\n            \
    \  * to use some other NBNS node\n              * to resolve the query.\n    \
    \          */\n              repeat query with NBNS address\n                \
    \  in the response packet;\n        NEGATIVE NAME QUERY RESPONSE:\n          \
    \   return failure;\n        END /* case */\n   END /* procedure */\n"
- title: 5.1.2.4.  P-NODE DELETE_NAME
  contents:
  - "5.1.2.4.  P-NODE DELETE_NAME\n   PROCEDURE delete_name (name)\n   /*\n    * Host\
    \ initiated processing for a P node\n    */\n   BEGIN\n        REPEAT\n      \
    \       /*\n              * build packet\n              */\n             ...\n\
    \             /*\n              * send request\n              */\n           \
    \  unicast NAME RELEASE REQUEST packet;\n             IF receive a WACK RESPONSE\
    \ THEN\n                  pause(time from TTL field of response);\n          \
    \   ELSE\n                  pause(UCAST_REQ_RETRY_TIMEOUT);\n        UNTIL retransmit\
    \ count has been exceeded\n             or response been received\n        IF\
    \ response has been received THEN\n        CASE packet type OF\n        POSITIVE\
    \ NAME RELEASE RESPONSE:\n             return success;\n        NEGATIVE NAME\
    \ RELEASE RESPONSE:\n             /*\n              * NBNS does want node to delete\
    \ this\n              * name !!!\n              */\n             return failure;\n\
    \        END /* case */\n   END /* procedure */\n"
- title: 5.1.2.5.  P-NODE INCOMING PACKET PROCESSING
  contents:
  - "5.1.2.5.  P-NODE INCOMING PACKET PROCESSING\n   Processing initiated by reception\
    \ of packets at a P node\n   PROCEDURE process_incoming_packet(packet)\n   /*\n\
    \    * Processing initiated by incoming packets at a P node\n    */\n   BEGIN\n\
    \        /*\n         * always ignore UDP broadcast packets\n         */\n   \
    \     IF packet was sent as a broadcast THEN\n        BEGIN\n             ignore\
    \ packet;\n             return;\n        END\n        CASE packet type of\n  \
    \      NAME CONFLICT DEMAND:\n             IF name exists in local name table\
    \ THEN\n                  mark name as in conflict;\n             return;\n  \
    \      NAME QUERY REQUEST:\n             IF name exists in local name table THEN\n\
    \             BEGIN /* name exists */\n                  /*\n                \
    \   * build packet\n                   */\n                  ...\n           \
    \       /*\n                   * send response to the IP address and port\n  \
    \                 * number from which the request was received.\n            \
    \       */\n                  send POSITIVE NAME QUERY RESPONSE ;\n          \
    \        return;\n             END /* exists */\n             ELSE\n         \
    \    BEGIN /* does not exist */\n                  /*\n                   * send\
    \ response to the requestor\n                   */\n                  send NEGATIVE\
    \ NAME QUERY RESPONSE ;\n                  return;\n             END /* does not\
    \ exist */\n        NODE STATUS REQUEST:\n             /*\n              * Name\
    \ of \"*\" may be used for force node to\n              * divulge status for administrative\
    \ purposes\n              */\n             IF name in local name table OR name\
    \ = \"*\" THEN\n             BEGIN\n                  /*\n                   *\
    \ Build response packet and\n                   * send to requestor node\n   \
    \                * Send only those names that are\n                   * in the\
    \ same scope as the scope\n                   * in the request packet.\n     \
    \              */\n                  send NODE STATUS RESPONSE;\n            \
    \ END\n        NAME RELEASE REQUEST:\n             /*\n              * This will\
    \ be received if the NBNS wants to flush the\n              * name from the local\
    \ name table, or from the local\n              * cache.\n              */\n  \
    \           IF name exists in the local name table THEN\n             BEGIN\n\
    \                  delete name from local name table;\n                  inform\
    \ user that name has been deleted;\n             END\n             ELSE\n    \
    \              IF name has been cached locally THEN\n                  BEGIN\n\
    \                       remove entry from cache:\n                  END\n    \
    \    END /* case */\n   END /* procedure */\n"
- title: 5.1.2.6.  P-NODE TIMER INITIATED PROCESSING
  contents:
  - "5.1.2.6.  P-NODE TIMER INITIATED PROCESSING\n   Processing initiated by timer\
    \ expiration.\n   PROCEDURE timer_expired()\n   /*\n    * Processing initiated\
    \ by the expiration of a timer on a P node\n    */\n   BEGIN\n        /*\n   \
    \      * Send a NAME REFRESH REQUEST for each name which the\n         * TTL which\
    \ has expired.\n         */\n        REPEAT\n             build NAME REFRESH REQUEST\
    \ packet;\n             REPEAT\n                  send packet to NBNS;\n     \
    \             IF receive a WACK RESPONSE THEN\n                       pause(time\
    \ from TTL field of response);\n                  ELSE\n                     \
    \  pause(UCAST_REQ_RETRY_TIMEOUT);\n             UNTIL response packet is received\
    \ or\n                  retransmit count has been exceeded\n             CASE\
    \ packet type OF\n               POSITIVE NAME REGISTRATION RESPONSE:\n      \
    \            /* successfully refreshed */\n                  reset TTL timer for\
    \ this name;\n               NEGATIVE NAME REGISTRATION RESPONSE:\n          \
    \        /*\n                   * refused, can't keep name\n                 \
    \  * assume in conflict\n                   */\n                  mark name as\
    \ in conflict;\n             END /* case */\n        UNTIL request sent for all\
    \ names for which TTL\n             has expired\n   END /* procedure */\n"
- title: 5.1.3.  M-NODE ACTIVITY
  contents:
  - "5.1.3.  M-NODE ACTIVITY\n   M nodes behavior is similar to that of P nodes with\
    \ the addition\n   of some B node-like broadcast actions.  M node name service\n\
    \   proceeds in two steps:\n   1.Use broadcast UDP based name service.  Depending\
    \ on the\n     operation, goto step 2.\n   2.Use directed UDP name service.\n\
    \   The following code for M nodes is exactly the same as for a P\n   node, with\
    \ the exception that broadcast operations are done\n   before P type operation\
    \ is attempted.\n   5.1.3.1.  M-NODE ADD NAME\n   PROCEDURE add_name(newname)\n\
    \   /*\n    * Host initiated processing for a M node\n    */\n   BEGIN\n     \
    \   /*\n         * check if name exists on the\n         * broadcast area\n  \
    \       */\n        REPEAT\n            /* build packet */\n            ....\n\
    \            broadcast NAME REGISTRATION REQUEST packet;\n            pause(BCAST_REQ_RETRY_TIMEOUT);\n\
    \        UNTIL response packet is received or\n             retransmit count has\
    \ been  exceeded\n        IF valid response received THEN\n        BEGIN\n   \
    \          /* cannot claim name */\n             return failure;\n        END\n\
    \        /*\n         * No objections received within the\n         * broadcast\
    \ area.\n         * Send request to name server.\n         */\n        REPEAT\n\
    \             /*\n              * build packet\n              */\n           \
    \  ONT = M;\n             ...\n             unicast NAME REGISTRATION REQUEST\
    \ packet;\n             /*\n              * remote NBNS will send response packet\n\
    \              */\n             IF receive a WACK RESPONSE THEN\n            \
    \      pause(time from TTL field of response);\n             ELSE\n          \
    \        pause(UCAST_REQ_RETRY_TIMEOUT);\n        UNTIL response packet is received\
    \ or\n             retransmit count has been exceeded\n        IF no response\
    \ packet was received THEN\n        BEGIN /* no response */\n             /*\n\
    \              * NBNS is down.  Cannot claim name.\n              */\n       \
    \      return failure; /* name cannot be claimed */\n        END /* no response\
    \ */\n        ELSE\n        BEGIN /* response */\n            IF NOT response\
    \ tid = request tid THEN\n            BEGIN\n             ignore response packet;\n\
    \            END\n            ELSE\n            CASE packet type OF\n        \
    \    POSITIVE NAME REGISTRATION RESPONSE:\n                 /*\n             \
    \     * name can be added\n                  */\n                 adjust refresh\
    \ timeout value, TTL;\n                 return success;      /* name can be added\
    \ */\n            NEGATIVE NAME REGISTRATION RESPONSE:\n                 return\
    \ failure; /* name cannot be added */\n            END-NODE CHALLENGE REGISTRATION\
    \ REQUEST:\n            BEGIN /* end node challenge */\n                 /*\n\
    \                  * The response packet has in it the\n                  * address\
    \ of the presumed owner of the\n                  * name.  Challenge that owner.\n\
    \                  * If owner either does not\n                  * respond or\
    \ indicates that he no longer\n                  * owns the name, claim the name.\n\
    \                  * Otherwise, the name cannot be claimed.\n                \
    \  *\n                  */\n                 REPEAT\n                  /*\n  \
    \                 * build packet\n                   */\n                  ...\n\
    \                  /*\n                   * send packet to address contained in\
    \ the\n                   * response packet\n                   */\n         \
    \         unicast NAME QUERY REQUEST packet;\n                  /*\n         \
    \          * remote node may send response packet\n                   */\n   \
    \               pause(UCAST_REQ_RETRY_TIMEOUT);\n                 UNTIL response\
    \ packet is received or\n                     retransmit count has been exceeded\n\
    \                 IF no response packet is received THEN\n                 BEGIN\
    \ /* no response */\n                  /*\n                   * name can be claimed\n\
    \                   */\n                  REPEAT\n                      /*\n \
    \                      * build packet\n                       */\n           \
    \            ...\n                      unicast NAME UPDATE REQUEST to NBNS;\n\
    \                      /*\n                       * NBNS node will send response\
    \ packet\n                       */\n                      IF receive a WACK RESPONSE\
    \ THEN\n                            pause(time from TTL field of response);\n\
    \                  ELSE\n                       pause(UCAST_REQ_RETRY_TIMEOUT);\n\
    \                  UNTIL response packet is received or\n                    \
    \  retransmit count has been exceeded\n                  IF no response packet\
    \ received THEN\n                  BEGIN /* no response */\n                 \
    \      /*\n                        * name could not be claimed\n             \
    \           */\n                       return failure;\n                  END\
    \ /* no response */\n                  ELSE\n                  CASE packet type\
    \ OF\n                  POSITIVE NAME REGISTRATION RESPONSE:\n               \
    \        /*\n                        * add name\n                        */\n\
    \                       return success;\n                  NEGATIVE NAME REGISTRATION\
    \ RESPONSE:\n                       /*\n                        * you lose  ...\n\
    \                        */\n                       return failure;\n        \
    \          END /* case */\n                 END /* no response */\n          \
    \       ELSE\n                 IF NOT response tid = request tid THEN\n      \
    \           BEGIN\n                  ignore response packet;\n               \
    \  END\n                 /*\n                  * received a response to the \"\
    challenge\"\n                  * packet\n                  */\n              \
    \   CASE packet type OF\n                 POSITIVE NAME QUERY:\n             \
    \     /*\n                   * remote node still has name.\n                 \
    \  */\n                  return failure;\n                 NEGATIVE NAME QUERY:\n\
    \                  /*\n                   * remote node no longer has name\n \
    \                  */\n                  return success;\n                 END\
    \ /* case */\n            END /* end node challenge */\n            END /* case\
    \ */\n        END /* response */\n   END /* procedure */\n"
- title: 5.1.3.2.  M-NODE ADD GROUP NAME
  contents:
  - "5.1.3.2.  M-NODE ADD GROUP NAME\n   PROCEDURE add_group_name(newname)\n   /*\n\
    \    * Host initiated processing for a P node\n    */\n   BEGIN\n        /*\n\
    \         * same as for a unique name, except that the\n         * request packet\
    \ must indicate that a\n         * group name claim is being made.\n         */\n\
    \        ...\n        G = GROUP;\n        ...\n        /*\n         * send packet\n\
    \         */\n         ...\n   END\n"
- title: 5.1.3.3.  M-NODE FIND NAME
  contents:
  - "5.1.3.3.  M-NODE FIND NAME\n   PROCEDURE find_name(name)\n   /*\n    * Host initiated\
    \ processing for a M node\n    */\n   BEGIN\n        /*\n         * check if any\
    \ node on the broadcast\n         * area has the name\n         */\n        REPEAT\n\
    \             /* build packet */\n             ...\n             broadcast NAME\
    \ QUERY REQUEST packet;\n             pause(BCAST_REQ_RETRY_TIMEOUT);\n      \
    \  UNTIL response packet received OR\n             max transmit threshold exceeded\n\
    \        IF valid response received THEN\n        BEGIN\n             save response\
    \ as authoritative response;\n             start_timer(CONFLICT_TIMER);\n    \
    \         return success;\n        END\n        /*\n         * no valid response\
    \ on the b'cast segment.\n         * Try the name server.\n         */\n     \
    \   REPEAT\n             /*\n              * build packet\n              */\n\
    \             ONT = M;\n             G = DONT CARE;\n             unicast NAME\
    \ QUERY REQUEST packet to NBNS;\n             /*\n              * a NBNS node\
    \ might send response packet\n              */\n             IF receive a WACK\
    \ RESPONSE THEN\n                  pause(time from TTL field of response);\n \
    \            ELSE\n                  pause(UCAST_REQ_RETRY_TIMEOUT);\n       \
    \ UNTIL response packet received OR\n             max transmit threshold exceeded\n\
    \        IF no response packet received THEN\n             return failure;\n \
    \       ELSE\n        IF NOT response tid = request tid THEN\n             ignore\
    \ packet;\n        ELSE\n        CASE packet type OF\n        POSITIVE NAME QUERY\
    \ RESPONSE:\n             return success;\n        REDIRECT NAME QUERY RESPONSE:\n\
    \             /*\n              * NBNS node wants this end node\n            \
    \  * to use some other NBNS node\n              * to resolve the query.\n    \
    \          */\n              repeat query with NBNS address\n                \
    \  in the response packet;\n        NEGATIVE NAME QUERY RESPONSE:\n          \
    \   return failure;\n        END /* case */\n   END /* procedure */\n"
- title: 5.1.3.4.  M-NODE DELETE NAME
  contents:
  - "5.1.3.4.  M-NODE DELETE NAME\n   PROCEDURE delete_name (name)\n   /*\n    * Host\
    \ initiated processing for a P node\n    */\n   BEGIN\n        /*\n         *\
    \ First, delete name on NBNS\n         */\n        REPEAT\n             /*\n \
    \             * build packet\n              */\n             ...\n           \
    \  /*\n              * send request\n              */\n             unicast NAME\
    \ RELEASE REQUEST packet to NBNS;\n             IF receive a WACK RESPONSE THEN\n\
    \                  pause(time from TTL field of response);\n             ELSE\n\
    \                  pause(UCAST_REQ_RETRY_TIMEOUT);\n        UNTIL retransmit count\
    \ has been exceeded\n             or response been received\n        IF response\
    \ has been received THEN\n        CASE packet type OF\n        POSITIVE NAME RELEASE\
    \ RESPONSE:\n             /*\n              * Deletion of name on b'cast segment\
    \ is deferred\n              * until after NBNS has deleted the name\n       \
    \       */\n             REPEAT\n                  /* build packet */\n      \
    \            ...\n                  broadcast NAME RELEASE REQUEST;\n        \
    \          pause(BCAST_REQ_RETRY_TIMEOUT);\n             UNTIL rexmt threshold\
    \ exceeded\n             return success;\n        NEGATIVE NAME RELEASE RESPONSE:\n\
    \             /*\n              * NBNS does want node to delete this\n       \
    \       * name\n              */\n             return failure;\n        END /*\
    \ case */\n   END /* procedure */\n"
- title: 5.1.3.5.  M-NODE INCOMING PACKET PROCESSING
  contents:
  - "5.1.3.5.  M-NODE INCOMING PACKET PROCESSING\n   Processing initiated by reception\
    \ of packets at a M node\n   PROCEDURE process_incoming_packet(packet)\n   /*\n\
    \    * Processing initiated by incoming packets at a M node\n    */\n   BEGIN\n\
    \        CASE packet type of\n        NAME CONFLICT DEMAND:\n             IF name\
    \ exists in local name table THEN\n                  mark name as in conflict;\n\
    \             return;\n        NAME QUERY REQUEST:\n             IF name exists\
    \ in local name table THEN\n             BEGIN /* name exists */\n           \
    \       /*\n                   * build packet\n                   */\n       \
    \           ...\n                  /*\n                   * send response to the\
    \ IP address and port\n                   * number from which the request was\
    \ received.\n                   */\n                  send POSITIVE NAME QUERY\
    \ RESPONSE ;\n                  return;\n             END /* exists */\n     \
    \        ELSE\n             BEGIN /* does not exist */\n                  /*\n\
    \                   * send response to the requestor\n                   */\n\
    \                  IF request NOT broadcast THEN\n                       /*\n\
    \                        * Don't send negative responses to\n                \
    \        * queries sent by B nodes\n                        */\n             \
    \          send NEGATIVE NAME QUERY RESPONSE ;\n                  return;\n  \
    \           END /* does not exist */\n        NODE STATUS REQUEST:\n         \
    \    BEGIN\n             /*\n              * Name of \"*\" may be used for force\
    \ node to\n              * divulge status for administrative purposes\n      \
    \        */\n             IF name in local name table OR name = \"*\" THEN\n \
    \                 /*\n                   * Build response packet and\n       \
    \            * send to requestor node\n                   * Send only those names\
    \ that are\n                   * in the same scope as the scope\n            \
    \       * in the request packet.\n                   */\n                  send\
    \ NODE STATUS RESPONSE;\n             END\n        NAME RELEASE REQUEST:\n   \
    \          /*\n              * This will be received if the NBNS wants to flush\
    \ the\n              * name from the local name table, or from the local\n   \
    \           * cache.\n              */\n             IF name exists in the local\
    \ name table THEN\n             BEGIN\n                  delete name from local\
    \ name table;\n                  inform user that name has been deleted;\n   \
    \          END\n             ELSE\n                  IF name has been cached locally\
    \ THEN\n                  BEGIN\n                       remove entry from cache:\n\
    \                  END\n        NAME REGISTRATION REQUEST (UNIQUE):\n        \
    \     IF name exists in local name table THEN\n                  send NEGATIVE\
    \ NAME REGISTRATION RESPONSE ;\n        NAME REGISTRATION REQUEST (GROUP):\n \
    \            IF name exists in local name table THEN\n             BEGIN\n   \
    \               IF local entry is a unique name THEN\n                      send\
    \ NEGATIVE NAME REGISTRATION RESPONSE ;\n             END\n        END /* case\
    \ */\n   END /* procedure */\n"
- title: 5.1.3.6.  M-NODE TIMER INITIATED PROCESSING
  contents:
  - "5.1.3.6.  M-NODE TIMER INITIATED PROCESSING\n   Processing initiated by timer\
    \ expiration:\n   PROCEDURE timer_expired()\n   /*\n    * Processing initiated\
    \ by the expiration of a timer on a M node\n    */\n   BEGIN\n        /*\n   \
    \      * Send a NAME REFRESH REQUEST for each name which the\n         * TTL which\
    \ has expired.\n         */\n        REPEAT\n             build NAME REFRESH REQUEST\
    \ packet;\n             REPEAT\n                  send packet to NBNS;\n     \
    \             IF receive a WACK RESPONSE THEN\n                       pause(time\
    \ from TTL field of response);\n                  ELSE\n                     \
    \  pause(UCAST_REQ_RETRY_TIMEOUT);\n             UNTIL response packet is received\
    \ or\n                  retransmit count has been exceeded\n             CASE\
    \ packet type OF\n               POSITIVE NAME REGISTRATION RESPONSE:\n      \
    \            /* successfully refreshed */\n                  reset TTL timer for\
    \ this name;\n               NEGATIVE NAME REGISTRATION RESPONSE:\n          \
    \        /*\n                   * refused, can't keep name\n                 \
    \  * assume in conflict\n                   */\n                  mark name as\
    \ in conflict;\n             END /* case */\n        UNTIL request sent for all\
    \ names for which TTL\n             has expired\n   END /* procedure */\n"
- title: 5.1.4.  NBNS ACTIVITY
  contents:
  - "5.1.4.  NBNS ACTIVITY\n   A NBNS node will receive directed packets from P and\
    \ M nodes.\n   Reply packets are always sent as directed packets to the source\n\
    \   IP address and UDP port number.  Received broadcast packets must\n   be ignored.\n"
- title: 5.1.4.1.  NBNS INCOMING PACKET PROCESSING
  contents:
  - "5.1.4.1.  NBNS INCOMING PACKET PROCESSING\n   PROCEDURE process_incoming_packet(packet)\n\
    \   /*\n    * Incoming packet processing on a NS node\n    */\n   BEGIN\n    \
    \    IF packet was sent as a broadcast THEN\n        BEGIN\n             discard\
    \ packet;\n             return;\n        END\n        CASE packet type of\n  \
    \      NAME REGISTRATION REQUEST (UNIQUE):\n             IF unique name exists\
    \ in data base THEN\n             BEGIN /* unique name exists */\n           \
    \       /*\n                   * NBNS node may be a \"passive\"\n            \
    \       * server in that it expects the\n                   * end node to do the\
    \ challenge\n                   * server.  Such a NBNS node is\n             \
    \      * called a \"non-secure\" server.\n                   * A \"secure\" server\
    \ will do the\n                   * challenging before it sends\n            \
    \       * back a response packet.\n                   */\n                  IF\
    \ non-secure THEN\n                  BEGIN\n                       /*\n      \
    \                  * build response packet\n                        */\n     \
    \                  ...\n                       /*\n                        * let\
    \ end node do the challenge\n                        */\n                    \
    \   send END-NODE CHALLENGE NAME REGISTRATION\n                            RESPONSE;\n\
    \                       return;\n                  END\n                  ELSE\n\
    \                  /*\n                   * secure server - do the name\n    \
    \               * challenge operation\n                   */\n               \
    \   REPEAT\n                      send NAME QUERY REQUEST;\n                 \
    \     pause(UCAST_REQ_RETRY_TIMEOUT);\n                  UNTIL response has been\
    \ received or\n                       retransmit count has been exceeded\n   \
    \               IF no response was received THEN\n                  BEGIN\n  \
    \                     /* node down */\n                       update data base\
    \ - remove entry;\n                       update data base - add new entry;\n\
    \                       send POSITIVE NAME REGISTRATION RESPONSE;\n          \
    \             return;\n                  END\n                  ELSE\n       \
    \           BEGIN /* challenged node replied */\n                      /*\n  \
    \                     * challenged node replied with\n                       *\
    \ a response packet\n                       */\n                      CASE packet\
    \ type\n                      POSITIVE NAME QUERY RESPONSE:\n                \
    \       /*\n                        * name still owned by the\n              \
    \          * challenged node\n                        *\n                    \
    \    * build packet and send response\n                        */\n          \
    \              ...\n                       /*\n                        * Note:\
    \ The NBNS will need to\n                        * keep track (based on transaction\
    \ id) of\n                        * the IP address and port number\n         \
    \               * of the original requestor.\n                        */\n   \
    \                    send NEGATIVE NAME REGISTRATION RESPONSE;\n             \
    \          return;\n                      NEGATIVE NAME QUERY RESPONSE:\n    \
    \                   update data base - remove entry;\n                       update\
    \ data base - add new  entry;\n                       /*\n                   \
    \     * build response packet and send\n                        * response\n \
    \                       */\n                       send POSITIVE NAME REGISTRATION\
    \ RESPONSE;\n                       return;\n                      END /* case\
    \ */\n                  END /* challenged node replied */\n             END /*\
    \ unique name exists in data base */\n             ELSE\n             IF group\
    \ name exists in data base THEN\n             BEGIN /* group names exists */\n\
    \                  /*\n                   * Members of a group name are NOT\n\
    \                   * challenged.\n                   * Make the assumption that\n\
    \                   * at least some of the group members\n                   *\
    \ are still alive.\n                   * Refresh mechanism will\n            \
    \       * allow the NBNS to detect when all\n                   * members of a\
    \ group no longer use that\n                   * name\n                   */\n\
    \                   send NEGATIVE NAME REGISTRATION RESPONSE;\n             END\
    \ /* group name exists */\n             ELSE\n             BEGIN /* name does\
    \ not exist */\n                  /*\n                   * Name does not exist\
    \ in data base\n                   *\n                   * This code applies to\
    \ both non-secure\n                   * and secure server.\n                 \
    \  */\n                  update data base - add new entry;\n                 \
    \ send POSITIVE NAME REGISTRATION RESPONSE;\n                  return;\n     \
    \        END\n        NAME QUERY REQUEST:\n             IF name exists in data\
    \ base THEN\n             BEGIN\n                  /*\n                   * build\
    \ response packet and send to\n                   * requestor\n              \
    \     */\n                   ...\n                  send POSITIVE NAME QUERY RESPONSE;\n\
    \                  return;\n             ELSE\n             BEGIN\n          \
    \        /*\n                   * build response packet and send to\n        \
    \           * requestor\n                   */\n                   ...\n     \
    \             send NEGATIVE NAME QUERY RESPONSE;\n                  return;\n\
    \             END\n        NAME REGISTRATION REQUEST (GROUP):\n             IF\
    \ name exists in data base THEN\n             BEGIN\n                  IF local\
    \ entry is a unique name THEN\n                  BEGIN /* local is unique */\n\
    \                      IF non-secure THEN\n                      BEGIN\n     \
    \                  send  END-NODE CHALLENGE NAME\n                           \
    \ REGISTRATION RESPONSE;\n                       return;\n                   \
    \   END\n                      REPEAT\n                       send NAME QUERY\
    \ REQUEST;\n                       pause(UCAST_REQ_RETRY_TIMEOUT);\n         \
    \             UNTIL response received or\n                           retransmit\
    \ count exceeded\n                      IF no response received or\n         \
    \                  NEGATIVE NAME QUERY RESPONSE\n                            received\
    \ THEN\n                      BEGIN\n                       update data base -\
    \ remove entry;\n                       update data base - add new entry;\n  \
    \                     send POSITIVE NAME REGISTRATION RESPONSE;\n            \
    \           return;\n                      END\n                      ELSE\n \
    \                     BEGIN\n                       /*\n                     \
    \   * name still being held\n                        * by challenged node\n  \
    \                      */\n                        send NEGATIVE NAME REGISTRATION\
    \ RESPONSE;\n                      END\n                  END /* local is unique\
    \ */\n                  ELSE\n                  BEGIN /* local is group  */\n\
    \                       /*\n                        * existing entry is a group\
    \ name\n                        */\n                       update data base -\
    \ remove entry;\n                       update data base - add new entry;\n  \
    \                     send POSITIVE NAME REGISTRATION RESPONSE;\n            \
    \           return;\n                  END /* local is group */\n            \
    \ END /* names exists */\n             ELSE\n             BEGIN /* does not exist\
    \ */\n                  /* name does not exist in data base */\n             \
    \     update data base - add new entry;\n                  send POSITIVE NAME\
    \ REGISTRATION RESPONSE;\n                  return;\n             END /* does\
    \ not exist */\n        NAME RELEASE REQUEST:\n             /*\n             \
    \ * secure server may choose to disallow\n              * a node from deleting\
    \ a name\n              */\n             update data base - remove entry;\n  \
    \           send POSITIVE NAME RELEASE RESPONSE;\n             return;\n     \
    \   NAME UPDATE REQUEST:\n             /*\n              * End-node completed\
    \ a successful challenge,\n              * no update database\n              */\n\
    \             IF secure server THEN\n                  send NEGATIVE NAME REGISTRATION\
    \ RESPONSE;\n             ELSE\n             BEGIN /* new entry */\n         \
    \         IF entry already exists THEN\n                       update data base\
    \ - remove entry;\n                  update data base - add new entry;\n     \
    \             send POSITIVE NAME REGISTRATION RESPONSE;\n                  start_timer(TTL);\n\
    \             END\n        NAME REFRESH REQUEST:\n             check for consistency;\n\
    \             IF node not allowed to have name THEN\n             BEGIN\n    \
    \              /*\n                   * tell end node that it can't have name\n\
    \                   */\n                  send NEGATIVE NAME REGISTRATION RESPONSE;\n\
    \             END\n             ELSE\n             BEGIN\n                  /*\n\
    \                   * send confirmation response to the\n                   *\
    \ end node.\n                   */\n                  send POSITIVE NAME REGISTRATION;\n\
    \                  start_timer(TTL);\n             END\n             return;\n\
    \        END /* case */\n   END /* procedure */\n"
- title: 5.1.4.2.  NBNS TIMER INITIATED PROCESSING
  contents:
  - "5.1.4.2.  NBNS TIMER INITIATED PROCESSING\n   A NS node uses timers to flush\
    \ out entries from the data base.\n   Each entry in the data base is removed when\
    \ its timer expires.\n   This time value is a multiple of the refresh TTL established\
    \ when\n   the name was registered.\n   PROCEDURE timer_expired()\n   /*\n   \
    \ * processing initiated by expiration of TTL for a given name\n    */\n   BEGIN\n\
    \        /*\n         * NBNS can (optionally) ensure\n         * that the node\
    \ is actually down\n         * by sending a NODE STATUS REQUEST.\n         * If\
    \ such a request is sent, and\n         * no response is received, it can\n  \
    \       * be assumed that the node is down.\n         */\n        remove entry\
    \ from data base;\n   END\n"
- title: 5.2.  SESSION SERVICE PROTOCOLS
  contents:
  - "5.2.  SESSION SERVICE PROTOCOLS\n   The following are variables and should be\
    \ configurable by the\n   NetBIOS user.  The default values of these variables\
    \ is found in\n   \"Defined Constants and Variables\" in the Detailed\n   Specification.):\n\
    \   - SSN_RETRY_COUNT - The maximum number TCP connection attempts\n     allowable\
    \ per a single NetBIOS call request.\n   - SSN_CLOSE_TIMEOUT is the time period\
    \ to wait when closing the\n     NetBIOS session before killing the TCP connection\
    \ if session\n     sends are outstanding.\n   The following are Defined Constants\
    \ for the NetBIOS Session\n   Service.  (See \"Defined Constants and Variables\"\
    \ in the Detailed\n   Specification for the value of these constants):\n   - SSN_SRVC_TCP_PORT\
    \ - is the globally well-known TCP port\n     allocated for the NetBIOS Session\
    \ Service.  The service accepts\n     TCP connections on this port to establish\
    \ NetBIOS Sessions.\n     The TCP connection established to this port by the caller\
    \ is\n     initially used for the exchange of NetBIOS control information.\n \
    \    The actual NetBIOS data connection may also pass through this\n     port\
    \ or, through the retargetting facility, through another\n     port.\n"
- title: 5.2.1.  SESSION ESTABLISHMENT PROTOCOLS
  contents:
  - '5.2.1.  SESSION ESTABLISHMENT PROTOCOLS

    '
- title: 5.2.1.1.  USER REQUEST PROCESSING
  contents:
  - "5.2.1.1.  USER REQUEST PROCESSING\n   PROCEDURE listen(listening name, caller\
    \ name)\n   /*\n    * User initiated processing for B, P and M nodes\n    *\n\
    \    * This procedure assumes that an incoming session will be\n    * retargetted\
    \ here by a session server.\n    */\n   BEGIN\n        Do TCP listen; /* Returns\
    \ TCP port used */\n        Register listen with Session Service, give names and\n\
    \             TCP port;\n        Wait for TCP connection to open;   /* Incoming\
    \ call */\n        Read SESSION REQUEST packet from connection\n        Process\
    \ session request (see section on\n             processing initiated by the reception\
    \ of session\n             service packets);\n        Inform Session Service that\
    \ NetBIOS listen is complete;\n        IF session established THEN\n         \
    \    return success and session information to user;\n        ELSE\n         \
    \    return failure;\n   END /* procedure */\n   PROCEDURE call(calling name,\
    \ called name)\n   /*\n    * user initiated processing for B, P and M nodes\n\
    \    */\n   /*\n    * This algorithm assumes that the called name is a unique\
    \ name.\n    * If the called name is a group name, the call() procedure\n    *\
    \ needs to cycle through the members of the group\n    * until either (retry_count\
    \ == SSN_RETRY_COUNT) or\n    * the list has been exhausted.\n    */\n   BEGIN\n\
    \        retry_count = 0;\n        retarget = FALSE;   /* TRUE: caller is being\
    \ retargetted */\n        name_query = TRUE;  /* TRUE: caller must begin again\
    \ with */\n                            /*       name query. */\n        REPEAT\n\
    \             IF name_query THEN\n             BEGIN\n                  do name\
    \ discovery, returns IP address;\n                  TCP port = SSN_SRVC_TCP_PORT;\n\
    \                  IF name discovery fails THEN\n                       return\
    \ failure;\n                  ELSE\n                       name_query = FALSE;\n\
    \             END\n             /*\n              * now have IP address and TCP\
    \ port of\n              * remote party.\n              */\n             establish\
    \ TCP connection with remote party, use an\n                  ephemeral port as\
    \ source TCP port;\n             IF connection refused THEN\n             BEGIN\n\
    \                  IF retarget THEN\n                  BEGIN\n               \
    \        /* retry */\n                       retarget = FALSE;\n             \
    \          use original IP address and TCP port;\n                       goto\
    \ LOOP;\n                  END\n                  /* retry for just missed TCP\
    \ listen */\n                  pause(SESSION_RETRY_TIMER);\n                 \
    \ establish TCP connection, again use ephemeral\n                       port as\
    \ source TCP port;\n                  IF connection refused OR\n             \
    \        connection timed out THEN\n                       return failure;\n \
    \            END\n             ELSE\n             IF connection timed out THEN\n\
    \             BEGIN\n                  IF retarget THEN\n                  BEGIN\n\
    \                       /* retry */\n                       retarget = FALSE;\n\
    \                       use original IP address and TCP port;\n              \
    \         goto LOOP;\n                  END\n                  ELSE\n        \
    \          BEGIN\n                       /*\n                        * incorrect\
    \ name discovery was done,\n                        * try again\n            \
    \            */\n                       inform name discovery process of\n   \
    \                         possible error;\n                       name_query =\
    \ TRUE;\n                       goto LOOP;\n                  END\n          \
    \   END\n             /*\n              * TCP connection has been established\n\
    \              */\n             wait for session response packet;\n          \
    \   CASE packet type OF\n                POSITIVE SESSION RESPONSE:\n        \
    \          return success and session established\n                       information;\n\
    \                NEGATIVE SESSION RESPONSE:\n                BEGIN\n         \
    \         CASE error OF\n                     NOT LISTENING ON CALLED NAME:\n\
    \                     NOT LISTENING FOR CALLING NAME:\n                     BEGIN\n\
    \                       kill TCP connection;\n                       return failure;\n\
    \                     END\n                     CALLED NAME NOT PRESENT:\n   \
    \                  BEGIN\n                       /*\n                        *\
    \ called name does not exist on\n                        * remote node\n     \
    \                   */\n                       inform name discovery procedure\n\
    \                            of possible error;\n                       IF this\
    \ is a P or M node THEN\n                       BEGIN\n                      \
    \      /*\n                             * Inform NetBIOS Name Server\n       \
    \                      * it has returned incorrect\n                         \
    \    * information.\n                             */\n                       \
    \     send NAME RELEASE REQUEST for called\n                              name\
    \ and IP address to\n                              NetBIOS Name Server;\n    \
    \                   END\n                       /* retry from beginning */\n \
    \                      retarget = FALSE;\n                       name_query =\
    \ TRUE;\n                       goto LOOP;\n                     END /* called\
    \ name not present */\n                  END /* case */\n                END /*\
    \ negative response */\n                RETARGET SESSION RESPONSE:\n         \
    \       BEGIN\n                  close TCP connection;\n                  extract\
    \ IP address and TCP port from\n                       response;\n           \
    \       retarget = TRUE;\n                END /* retarget response */\n      \
    \       END /* case */\n   LOOP:          retry_count = retry_count + 1;\n   \
    \     UNTIL (retry_count > SSN_RETRY_COUNT);\n        return failure;\n   END\
    \ /* procedure */\n"
- title: 5.2.1.2.  RECEIVED PACKET PROCESSING
  contents:
  - "5.2.1.2.  RECEIVED PACKET PROCESSING\n   These are packets received on a TCP\
    \ connection before a session\n   has been established.  The listen routines attached\
    \ to a NetBIOS\n   user process need not implement the RETARGET response section.\n\
    \   The user process version, separate from a shared Session Service,\n   need\
    \ only accept (POSITIVE SESSION RESPONSE) or reject (NEGATIVE\n   SESSION RESPONSE)\
    \ a session request.\n   PROCEDURE session_packet(packet)\n   /*\n    * processing\
    \ initiated by receipt of a session service\n    * packet for a session in the\
    \ session establishment phase.\n    * Assumes the TCP connection has been accepted.\n\
    \    */\n   BEGIN\n        CASE packet type\n           SESSION REQUEST:\n   \
    \        BEGIN\n             IF called name does not exist on node THEN\n    \
    \         BEGIN\n                  send NEGATIVE SESSION RESPONSE with CALLED\n\
    \                       NAME NOT PRESENT error code;\n                  close\
    \ TCP connection;\n             END\n             Search for a listen with CALLING\
    \ NAME for CALLED\n                  NAME;\n             IF matching listen is\
    \ found THEN\n             BEGIN\n                  IF port of listener process\
    \ is port TCP\n                     connection is on THEN\n                  BEGIN\n\
    \                       send POSITIVE SESSION RESPONSE;\n                    \
    \   Hand off connection to client process\n                            and/or\
    \ inform user session is\n                            established;\n         \
    \         END\n                  ELSE\n                  BEGIN\n             \
    \          send RETARGET SESSION RESPONSE with\n                            listener's\
    \ IP address and\n                            TCP port;\n                    \
    \   close TCP connection;\n                  END\n             END\n         \
    \    ELSE\n             BEGIN\n                  /* no matching listen pending\
    \ */\n                  send NEGATIVE SESSION RESPONSE with either\n         \
    \              NOT LISTENING ON CALLED NAME or NOT\n                       LISTENING\
    \ FOR CALLING NAME error\n                       code;\n                  close\
    \ TCP connection;\n             END\n           END /* session request */\n  \
    \      END /* case */\n   END /* procedure */\n"
- title: 5.2.2.  SESSION DATA TRANSFER PROTOCOLS
  contents:
  - '5.2.2.  SESSION DATA TRANSFER PROTOCOLS

    '
- title: 5.2.2.1.  USER REQUEST PROCESSING
  contents:
  - "5.2.2.1.  USER REQUEST PROCESSING\n   PROCEDURE send_message(user_message)\n\
    \   BEGIN\n        build SESSION MESSAGE header;\n        send SESSION MESSAGE\
    \ header;\n        send user_message;\n        reset and restart keep-alive timer;\n\
    \        IF send fails THEN\n        BEGIN\n             /*\n              * TCP\
    \ connection has failed */\n              */\n             close NetBIOS session;\n\
    \             inform user that session is lost;\n             return failure;\n\
    \        END\n        ELSE\n             return success;\n   END\n   5.2.2.2.\
    \  RECEIVED PACKET PROCESSING\n   These are packets received after a session has\
    \ been established.\n   PROCEDURE session_packet(packet)\n   /*\n    * processing\
    \ initiated by receipt of a session service\n    * packet for a session in the\
    \ data transfer phase.\n    */\n   BEGIN\n        CASE packet type OF\n      \
    \     SESSION  MESSAGE:\n           BEGIN\n             process message header;\n\
    \             read in user data;\n             reset and restart keep-alive timer;\n\
    \             deliver data to user;\n           END /* session message */\n  \
    \         SESSION KEEP ALIVE:\n             discard packet;\n        END /* case\
    \ */\n   END /* procedure */\n"
- title: 5.2.2.3.  PROCESSING INITIATED BY TIMER
  contents:
  - "5.2.2.3.  PROCESSING INITIATED BY TIMER\n   PROCEDURE session_ka_timer()\n  \
    \ /*\n    * processing initiated when session keep alive timer expires\n    */\n\
    \   BEGIN\n            send SESSION KEEP ALIVE, if configured;\n            IF\
    \ send fails THEN\n            BEGIN\n             /* remote node, or path to\
    \ it, is down */\n             abort TCP connection;\n             close NetBIOS\
    \ session;\n             inform user that session is lost;\n             return;\n\
    \            END\n   END /* procedure */\n"
- title: 5.2.3.  SESSION TERMINATION PROTOCOLS
  contents:
  - '5.2.3.  SESSION TERMINATION PROTOCOLS

    '
- title: 5.2.3.1.  USER REQUEST PROCESSING
  contents:
  - "5.2.3.1.  USER REQUEST PROCESSING\n   PROCEDURE close_session()\n   /* initiated\
    \ by a user request to close a session */\n   BEGIN\n        close gracefully\
    \ the TCP connection;\n        WAIT for the connection to close or SSN_CLOSE_TIMEOUT\n\
    \             to expire;\n        IF time out expired THEN\n             abort\
    \ TCP connection;\n   END /* procedure */\n"
- title: 5.2.3.2.  RECEPTION INDICATION PROCESSING
  contents:
  - "5.2.3.2.  RECEPTION INDICATION PROCESSING\n   PROCEDURE close_indication()\n\
    \   /*\n    * initiated by a TCP indication of a close request from\n    * the\
    \ remote connection partner.\n    */\n   BEGIN\n        close gracefully TCP connection;\n\
    \        close NetBIOS session;\n        inform user session closed by remote\
    \ partner;\n   END /* procedure */\n"
- title: 5.3.  NetBIOS DATAGRAM SERVICE PROTOCOLS
  contents:
  - "5.3.  NetBIOS DATAGRAM SERVICE PROTOCOLS\n   The following are GLOBAL variables\
    \ and should be NetBIOS user\n   configurable:\n   - SCOPE_ID: the non-leaf section\
    \ of the domain name preceded by a\n     '.'  which represents the domain of the\
    \ NetBIOS scope for the\n     NetBIOS name.  The following protocol description\
    \ only supports\n     single scope operation.\n   - MAX_DATAGRAM_LENGTH: the maximum\
    \ length of an IP datagram.  The\n     minimal maximum length defined in for IP\
    \ is 576 bytes.  This\n     value is used when determining whether to fragment\
    \ a NetBIOS\n     datagram.  Implementations are expected to be capable of\n \
    \    receiving unfragmented NetBIOS datagrams up to their maximum\n     size.\n\
    \   - BROADCAST_ADDRESS: the IP address B-nodes use to send datagrams\n     with\
    \ group name destinations and broadcast datagrams.  The\n     default is the IP\
    \ broadcast address for a single IP network.\n   The following are Defined Constants\
    \ for the NetBIOS Datagram\n   Service:\n   - DGM_SRVC_UDP_PORT: the globally\
    \ well-known UDP port allocated\n     where the NetBIOS Datagram Service receives\
    \ UDP packets.  See\n     section 6, \"Defined Constants\", for its value.\n"
- title: 5.3.1.  B NODE TRANSMISSION OF NetBIOS DATAGRAMS
  contents:
  - "5.3.1.  B NODE TRANSMISSION OF NetBIOS DATAGRAMS\n   PROCEDURE send_datagram(data,\
    \ source, destination, broadcast)\n   /*\n    * user initiated processing on B\
    \ node\n    */\n   BEGIN\n        group = FALSE;\n        do name discovery on\
    \ destination name, returns name type and\n             IP address;\n        IF\
    \ name type is group name THEN\n        BEGIN\n             group = TRUE;\n  \
    \      END\n        /*\n         * build datagram service UDP packet;\n      \
    \   */\n        convert source and destination NetBIOS names into\n          \
    \   half-ASCII, biased encoded name;\n        SOURCE_NAME = cat(source, SCOPE_ID);\n\
    \        SOURCE_IP = this nodes IP address;\n        SOURCE_PORT =  DGM_SRVC_UDP_PORT;\n\
    \        IF NetBIOS broadcast THEN\n        BEGIN\n             DESTINATION_NAME\
    \ = cat(\"*\", SCOPE_ID)\n        END\n        ELSE\n        BEGIN\n         \
    \    DESTINATION_NAME = cat(destination, SCOPE_ID)\n        END\n        MSG_TYPE\
    \ = select_one_from_set\n             {BROADCAST, DIRECT_UNIQUE, DIRECT_GROUP}\n\
    \        DGM_ID = next transaction id for Datagrams;\n        DGM_LENGTH = length\
    \ of data + length of second level encoded\n             source and destination\
    \ names;\n        IF (length of the NetBIOS Datagram, including UDP and\n    \
    \        IP headers, > MAX_DATAGRAM_LENGTH) THEN\n        BEGIN\n            \
    \ /*\n              * fragment NetBIOS datagram into 2 UDP packets\n         \
    \     */\n             Put names into 1st UDP packet and any data that fits\n\
    \                  after names;\n             Set MORE and FIRST bits in 1st UDP\
    \ packet's FLAGS;\n             OFFSET in 1st UDP = 0;\n             Replicate\
    \ NetBIOS Datagram header from 1st UDP packet\n                  into 2nd UDP\
    \ packet;\n             Put rest of data in 2nd UDP packet;\n             Clear\
    \ MORE and FIRST bits in 2nd UDP packet's FLAGS;\n             OFFSET in 2nd UDP\
    \ = DGM_LENGTH - number of name and\n                  data bytes in 1st UDP;\n\
    \        END\n        BEGIN\n             /*\n              * Only need one UDP\
    \ packet\n              */\n             USER_DATA = data;\n             Clear\
    \ MORE bit and set FIRST bit in FLAGS;\n             OFFSET = 0;\n        END\n\
    \        IF (group == TRUE) OR (NetBIOS broadcast) THEN\n        BEGIN\n     \
    \        send UDP packet(s) to BROADCAST_ADDRESS;\n        END\n        ELSE\n\
    \        BEGIN\n             send UDP packet(s) to IP address returned by name\n\
    \                discovery;\n        END\n   END /* procedure */\n"
- title: 5.3.2.  P AND M NODE TRANSMISSION OF NetBIOS DATAGRAMS
  contents:
  - "5.3.2.  P AND M NODE TRANSMISSION OF NetBIOS DATAGRAMS\n   PROCEDURE send_datagram(data,\
    \ source, destination, broadcast)\n   /*\n    * User initiated processing on P\
    \ and M node.\n    *\n    * This processing is the same as for B nodes except\
    \ for\n    * sending broadcast and multicast NetBIOS datagrams.\n    */\n   BEGIN\n\
    \        group = FALSE;\n        do name discovery on destination name, returns\
    \ name type\n             and IP address;\n        IF name type is group name\
    \ THEN\n        BEGIN\n             group = TRUE;\n        END\n        /*\n \
    \        * build datagram service UDP packet;\n         */\n        convert source\
    \ and destination NetBIOS names into\n             half-ASCII, biased encoded\
    \ name;\n        SOURCE_NAME = cat(source, SCOPE_ID);\n        SOURCE_IP = this\
    \ nodes IP address;\n        SOURCE_PORT =  DGM_SRVC_UDP_PORT;\n        IF NetBIOS\
    \ broadcast THEN\n        BEGIN\n             DESTINATION_NAME = cat(\"*\", SCOPE_ID)\n\
    \        END\n        ELSE\n        BEGIN\n             DESTINATION_NAME = cat(destination,\
    \ SCOPE_ID)\n        END\n        MSG_TYPE = select_one_from_set\n           \
    \  {BROADCAST, DIRECT_UNIQUE, DIRECT_GROUP}\n        DGM_ID = next transaction\
    \ id for Datagrams;\n        DGM_LENGTH = length of data + length of second level\
    \ encoded\n             source and destination names;\n        IF (length of the\
    \ NetBIOS Datagram, including UDP and\n            IP headers, > MAX_DATAGRAM_LENGTH)\
    \ THEN\n        BEGIN\n             /*\n              * fragment NetBIOS datagram\
    \ into 2 UDP packets\n              */\n             Put names into 1st UDP packet\
    \ and any data that fits\n                  after names;\n             Set MORE\
    \ and FIRST bits in 1st UDP packet's FLAGS;\n             OFFSET in 1st UDP =\
    \ 0;\n             Replicate NetBIOS Datagram header from 1st UDP packet\n   \
    \               into 2nd UDP packet;\n             Put rest of data in 2nd UDP\
    \ packet;\n             Clear MORE and FIRST bits in 2nd UDP packet's FLAGS;\n\
    \             OFFSET in 2nd UDP = DGM_LENGTH - number of name and\n          \
    \        data bytes in 1st UDP;\n        END\n        BEGIN\n             /*\n\
    \              * Only need one UDP packet\n              */\n             USER_DATA\
    \ = data;\n             Clear MORE bit and set FIRST bit in FLAGS;\n         \
    \    OFFSET = 0;\n        END\n        IF (group == TRUE) OR (NetBIOS broadcast)\
    \ THEN\n        BEGIN\n             /*\n              * Sending of following query\
    \ is optional.\n              * Node may send datagram to NBDD immediately\n \
    \             * but NBDD may discard the datagram.\n              */\n       \
    \      send DATAGRAM QUERY REQUEST to NBDD;\n             IF response is POSITIVE\
    \ QUERY RESPONSE THEN\n                  send UDP packet(s) to NBDD Server IP\
    \ address;\n             ELSE\n             BEGIN\n                  get list\
    \ of destination nodes from NBNS;\n                  FOR EACH node in list\n \
    \                 BEGIN\n                       send UDP packet(s) to this node's\n\
    \                            IP address;\n                  END\n            \
    \ END\n        END\n        ELSE\n        BEGIN\n             send UDP packet(s)\
    \ to IP address returned by name\n                discovery;\n   END /* procedure\
    \ */\n"
- title: 5.3.3.  RECEPTION OF NetBIOS DATAGRAMS BY ALL NODES
  contents:
  - "5.3.3.  RECEPTION OF NetBIOS DATAGRAMS BY ALL NODES\n   The following algorithm\
    \ discards out of order NetBIOS Datagram\n   fragments.  An implementation which\
    \ reassembles out of order\n   NetBIOS Datagram fragments conforms to this specification.\
    \  The\n   fragment discard timer is initialized to the value FRAGMENT_TO.\n \
    \  This value should be user configurable.  The default value is\n   given in\
    \ Section 6, \"Defined Constants and Variables\".\n   PROCEDURE datagram_packet(packet)\n\
    \   /*\n    * processing initiated by datagram packet reception\n    * on B, P\
    \ and M nodes\n    */\n   BEGIN\n        /*\n         * if this node is a P node,\
    \ ignore\n         * broadcast packets.\n         */\n        IF this is a P node\
    \ AND incoming packet is\n             a broadcast packet THEN\n        BEGIN\n\
    \             discard packet;\n        END\n        CASE packet type OF\n    \
    \       DATAGRAM SERVICE:\n           BEGIN\n             IF FIRST bit in FLAGS\
    \ is set THEN\n             BEGIN\n                  IF MORE bit in FLAGS is set\
    \ THEN\n                  BEGIN\n                       Save 1st UDP packet of\
    \ the Datagram;\n                       Set this Datagram's fragment discard\n\
    \                         timer to FRAGMENT_TO;\n                       return;\n\
    \                  END\n                  ELSE\n                       Datagram\
    \ is composed of a single\n                         UDP packet;\n            \
    \ END\n             ELSE\n             BEGIN\n                  /* Have the second\
    \ fragment of a Datagram */\n                  Search for 1st fragment by source\
    \ IP address\n                     and DGM_ID;\n                  IF found 1st\
    \ fragment THEN\n                       Process both UDP packets;\n          \
    \        ELSE\n                  BEGIN\n                       discard 2nd fragment\
    \ UDP packet;\n                       return;\n                  END\n       \
    \      END\n             IF DESTINATION_NAME is '*' THEN\n             BEGIN\n\
    \                  /* NetBIOS broadcast */\n                  deliver USER_DATA\
    \ from UDP packet(s) to all\n                       outstanding receive broadcast\n\
    \                       datagram requests;\n                  return;\n      \
    \       END\n             ELSE\n             BEGIN /* non-broadcast */\n     \
    \             /* Datagram for Unique or Group Name */\n                  IF DESTINATION_NAME\
    \ is not present in the\n                     local name table THEN\n        \
    \          BEGIN\n                       /* destination not present */\n     \
    \                  build DATAGRAM ERROR packet, clear\n                      \
    \      FIRST and MORE bit, put in\n                            this nodes IP and\
    \ PORT, set\n                            ERROR_CODE;\n                       send\
    \ DATAGRAM ERROR packet to\n                            source IP address and\
    \ port\n                            of UDP;\n                       discard UDP\
    \ packet(s);\n                       return;\n                  END\n        \
    \          ELSE\n                  BEGIN /* good */\n                       /*\n\
    \                        * Replicate received NetBIOS datagram for\n         \
    \               * each recipient\n                        */\n               \
    \        FOR EACH pending NetBIOS user's receive\n                           \
    \ datagram operation\n                       BEGIN\n                         \
    \   IF source name of operation\n                               matches destination\
    \ name\n                               of packet THEN\n                      \
    \      BEGIN\n                               deliver USER_DATA from UDP\n    \
    \                             packet(s);\n                            END\n  \
    \                     END /* for each */\n                       return;\n   \
    \               END /* good */\n             END /* non-broadcast */\n       \
    \     END /* datagram service */\n           DATAGRAM ERROR:\n           BEGIN\n\
    \                /*\n                 * name service returned incorrect information\n\
    \                 */\n                inform local name service that incorrect\n\
    \                  information was provided;\n                IF this is a P or\
    \ M node THEN\n                BEGIN\n                     /*\n              \
    \        * tell NetBIOS Name Server that it may\n                      * have\
    \ given incorrect information\n                      */\n                    \
    \ send NAME RELEASE REQUEST with name\n                       and incorrect IP\
    \ address to NetBIOS\n                       Name Server;\n                END\n\
    \           END /* datagram error */\n        END /* case */\n   END\n"
- title: 5.3.4.  PROTOCOLS FOR THE NBDD
  contents:
  - "5.3.4.  PROTOCOLS FOR THE NBDD\n   The key to NetBIOS Datagram forwarding service\
    \ is the packet\n   delivered to the destination end node must have the same NetBIOS\n\
    \   header as if the source end node sent the packet directly to the\n   destination\
    \ end node.  Consequently, the NBDD does not reassemble\n   NetBIOS Datagrams.\
    \  It forwards the UDP packet as is.\n   PROCEDURE  datagram_packet(packet)\n\
    \   /*\n    * processing initiated by a incoming datagram service\n    * packet\
    \ on a NBDD node.\n    */\n   BEGIN\n        CASE packet type OF\n           DATAGRAM\
    \ SERVICE:\n           BEGIN\n                IF packet was sent as a directed\n\
    \                   NetBIOS datagram THEN\n                BEGIN\n           \
    \       /*\n                   * provide group forwarding service\n          \
    \         *\n                   * Forward datagram to each member of the\n   \
    \                * group.  Can forward via:\n                   *   1) get list\
    \ of group members and send\n                   *   the DATAGRAM SERVICE packet\
    \ unicast\n                   *   to each\n                   *   2) use Group\
    \ Multicast, if available\n                   *   3) combination of 1) and 2)\n\
    \                   */\n                  ...\n                END\n         \
    \       ELSE\n                BEGIN\n                  /*\n                  \
    \ * provide broadcast forwarding service\n                   *\n             \
    \      * Forward datagram to every node in the\n                   * NetBIOS scope.\
    \  Can forward via:\n                   *   1) get list of group members and send\n\
    \                   *   the DATAGRAM SERVICE packet unicast\n                \
    \   *   to each\n                   *   2) use Group Multicast, if available\n\
    \                   *   3) combination of 1) and 2)\n                   */\n \
    \                 ...\n                END\n           END /* datagram service\
    \ */\n           DATAGRAM ERROR:\n           BEGIN\n             /*\n        \
    \      * Should never receive these because Datagrams\n              * forwarded\
    \ have source end node IP address and\n              * port in NetBIOS header.\n\
    \              */\n             send DELETE NAME REQUEST with incorrect name and\n\
    \                  IP address to NetBIOS Name Server;\n           END /* datagram\
    \ error */\n           DATAGRAM QUERY REQUEST:\n           BEGIN\n           \
    \  IF can send packet to DESTINATION_NAME THEN\n             BEGIN\n         \
    \         /*\n                   * NBDD is able to relay Datagrams for\n     \
    \              * this name\n                   */\n                  send POSITIVE\
    \ DATAGRAM QUERY RESPONSE to\n                    REQUEST source IP address and\
    \ UDP port\n                    with request's DGM_ID;\n             END\n   \
    \          ELSE\n             BEGIN\n                  /*\n                  \
    \ * NBDD is NOT able to relay Datagrams for\n                   * this name\n\
    \                   */\n                  send NEGATIVE DATAGRAM QUERY RESPONSE\
    \ to\n                    REQUEST source IP address and UDP port\n           \
    \         with request's DGM_ID;\n             END\n           END /* datagram\
    \ query request */\n        END /* case */\n   END /* procedure */\n"
- title: 6.  DEFINED CONSTANTS AND VARIABLES
  contents:
  - "6.  DEFINED CONSTANTS AND VARIABLES\n   GENERAL:\n      SCOPE_ID            \
    \       The name of the NetBIOS scope.\n                                 This\
    \ is expressed as a character\n                                 string meeting\
    \ the requirements of\n                                 the domain name system\
    \ and without\n                                 a leading or trailing \"dot\"\
    .\n                                 An implementation may elect to make\n    \
    \                             this a single global value for the\n           \
    \                      node or allow it to be specified\n                    \
    \             with each separate NetBIOS name\n                              \
    \   (thus permitting cross-scope\n                                 references.)\n\
    \      BROADCAST_ADDRESS          An IP address composed of the\n            \
    \                     nodes's network and subnetwork\n                       \
    \          numbers with all remaining bits set\n                             \
    \    to one.\n                                 I.e. \"Specific subnet\" broadcast\n\
    \                                 addressing according to section 2.3\n      \
    \                           of RFC 950.\n      BCAST_REQ_RETRY_TIMEOUT    250\
    \ milliseconds.\n                                 An adaptive timer may be used.\n\
    \      BCAST_REQ_RETRY_COUNT      3\n      UCAST_REQ_RETRY_TIMEOUT    5 seconds\n\
    \                                 An adaptive timer may be used.\n      UCAST_REQ_RETRY_COUNT\
    \      3\n      MAX_DATAGRAM_LENGTH        576 bytes (default)\n   NAME SERVICE:\n\
    \      REFRESH_TIMER              Negotiated with NBNS for each name.\n      CONFLICT_TIMER\
    \             1 second\n                                 Implementations may chose\
    \ a longer\n                                 value.\n      NAME_SERVICE_TCP_PORT\
    \      137 (decimal)\n      NAME_SERVICE_UDP_PORT      137 (decimal)\n      INFINITE_TTL\
    \               0\n   SESSION SERVICE:\n      SSN_SRVC_TCP_PORT          139 (decimal)\n\
    \      SSN_RETRY_COUNT            4 (default)\n                              \
    \   Re-configurable by user.\n      SSN_CLOSE_TIMEOUT          30 seconds (default)\n\
    \                                 Re-configurable by user.\n      SSN_KEEP_ALIVE_TIMEOUT\
    \     60 seconds, recommended, may be set to\n                               \
    \  a higher value.\n                                 (Session keep-alives are\
    \ used only\n                                 if configured.)\n   DATAGRAM SERVICE:\n\
    \      DGM_SRVC_UDP_PORT          138 (decimal)\n      FRAGMENT_TO           \
    \     2 seconds (default)\n"
- title: REFERENCES
  contents:
  - "REFERENCES\n   [1]  \"Protocol Standard For a NetBIOS Service on a TCP/UDP\n\
    \        Transport: Concepts and Methods\", RFC 1001, March 1987.\n   [2]  J.\
    \ Reynolds, J. Postel, \"Assigned Numbers\", RFC 990, November\n        1986.\n\
    \   [3]  P. Mockapetris, \"Domain Names - Implementation and\n        Specification\"\
    , RFC 883, November 1983.\n"
