- title: __initial_text__
  contents:
  - '                      A Possible Protocol Plateau

    '
- title: I. Introduction
  contents:
  - "I. Introduction\n   We have been engaged in two activities since the network\
    \ meeting of\n   March 17, 1970 and, as promised, are reporting our results.\n\
    \   First, we have considered the various modifications suggested from\n   all\
    \ quarters and have formed preferences about each of these.  In\n   Section II\
    \ we give our preferences on each issue, together with our\n   reasoning.\n  \
    \ Second, we have tried to formalize the protocol and algorithms for\n   the NCP,\
    \ we attempted to do this with very little specification of a\n   particular implementation.\
    \  Our attempts to date have been seriously\n   incomplete but have led to a better\
    \ understanding.  We include here,\n   only a brief sketch of the structure of\
    \ the NCP.  Section III gives\n   our assumptions about the environment of the\
    \ NCP and in Section IV\n   the components of the NCP are described.\n"
- title: II. Issues and Preferences
  contents:
  - "II. Issues and Preferences\n   In this section we try to present each of the\
    \ several questions which\n   have been raised in recent NWG/RFC's and in private\
    \ conversations,\n   and for each issue, we suggest an answer or policy.  In many\
    \ cases,\n   good ideas are rejected because in our estimation they should be\n\
    \   incorporated at a different level.\n      A. Double Padding\n         As BBN\
    \ report #1822 explains, the Imp side of the Host-to-Imp\n         interface concatenates\
    \ a 1 followed by zero or more 0's to fill\n         out a message to an Imp word\
    \ boundary and yet preserve the\n         message length.  Furthermore, the Host\
    \ side of the Imp-to-Host\n         interface extends a message with 0's to fill\
    \ out the message to\n         a Host word boundary.\n         BBN's mechanism\
    \ works fine if the sending Host wants to send an\n         integral number of\
    \ words, or if the sending Host's hardware is\n         capable of sending partial\
    \ words.  However, in the event that\n         the sending Host wants to send\
    \ an irregular length message and\n         its hardware is only capable of sending\
    \ word-multiple messages,\n         some additional convention is needed.\n  \
    \       One of the simplest solutions is to modify the Imp side of the\n     \
    \    Host-to-Imp interface so that it appends only 0's.  This would\n        \
    \ mean that the Host software would have to supply the trailing\n         1. \
    \ BBN rejected the change because of an understandably strong\n         bias against\
    \ hardware changes.  It was also suggested that a\n         five instruction patch\
    \ to the Imp program would remove the\n         interface supplied 1, but this\
    \ was also rejected on the new\n         grounds that it seemed more secure to\
    \ depend only upon the Host\n         hardware to signal message end, and not\
    \ to depend upon the Host\n         software at all.\n         Two other solutions\
    \ are also available.  One is to have \"double\n         padding\", whereby the\
    \ sending Host supplies 10* and the network\n         also supplies 10*.  Upon\
    \ input, a receiving Host then strips\n         the trailing 10* 10*.  The other\
    \ solution is to make use of the\n         marking.  Marking is a string of the\
    \ form 0*1 inserted between\n         the leader and the text of a message.  The\
    \ original intent of\n         marking was to extend the leader so that the sending\
    \ Host could\n         _begin_ its text on a word boundary.  It is also possible\
    \ to\n         use the marking to expand a message so that it _ends_ on a word\n\
    \         boundary.\n         Notice that double padding could replace marking\
    \ altogether by\n         abutting the text beginning against the leader.  For\
    \ 32 bit\n         machines, this is convenient and marking is not, while for\n\
    \         other lengths, particularly 36 bit machines, marking is much\n     \
    \    more convenient than double padding.\n         We have no strong preference,\
    \ partially because we can send\n         word fragments.  Shoshani, et al in\
    \ NWG/RFC #44 claim that\n         adjusting the marking does not cause them any\
    \ problems, and\n         they have a 32 bit machine.  Since the idea of marking\
    \ has been\n         accepted for some time, we suggest that double padding not\
    \ be\n         used and that marking be used to adjust the length of a\n     \
    \    message.  We note that if BBN ever does remove the 1 from the\n         hardware\
    \ padding, only minimal change to Host software is\n         needed on the send\
    \ side.\n         A much prettier (and more expensive) arrangement was suggested\n\
    \         by W. Sutherland.  He suggested that the Host/Imp interfaces be\n  \
    \       smart enough to strip padding or marking and might even parse\n      \
    \   the message upon input.\n      B. Reconnection\n         A very large population\
    \ of networkers has beat upon us for\n         including dynamic reconnection\
    \ in the protocol.  We felt it\n         might be of interest to relate how it\
    \ came to be included.\n         After considering connections and their uses\
    \ for a while, we\n         wondered how the mechanism of connections compared\
    \ to existing\n         forms of intra-Host interprocess communication.  Two aspects\n\
    \         are of interest, what formalisms have been presented in the\n      \
    \   literature, and what mechanisms are in use.  The formalisms are\n        \
    \ interesting because they lead to uniform implementations and\n         parsimonious\
    \ design.  The existing mechanisms are interesting\n         because they point\
    \ out which problems need solving and\n         sometimes indicate what an appropriate\
    \ formalism might be.  In\n         particular, we have noticed that the mechanisms\
    \ for connecting\n         a console to the logger upon dial in, the mechanisms\
    \ for\n         creating a job, and the mechanisms for passing a console around\n\
    \         to various processes within a job tend to be highly\n         idiosyncratic\
    \ and distinct from all other structures and\n         mechanisms within an operating\
    \ system.\n         With respect to the literature, it appears there is only one\n\
    \         idea with several variations, viz processes should share a\n       \
    \  portion of their address spaces and cooperatively wake up each\n         other.\
    \  Semaphores and event channels are handy extensions of\n         wake up signals,\
    \ but the intent is basically the same.  (Event\n         channels could probably\
    \ function as connections, but it seems\n         not to be within their intended\
    \ use.  In small systems, the\n         efficiency and capacity of event channels\
    \ are inversely\n         related.)\n         With respect to existing implementations,\
    \ we note that several\n         systems allow a process to appear to be a file\
    \ to another\n         process.  Some systems, e.g. the SDS-940 at SRI impose\
    \ a\n         master/slave relationship between two processes so connected,\n\
    \         but other systems provide for a coequal relationship e.g. the\n    \
    \     AI group's PDP-6 system at MAC.  The PDP-6 system also has a\n         feature\
    \ whereby a superior process can \"surround\" an inferior\n         process with\
    \ a mapping from device and file names to other\n         device and file names.\
    \  Consoles have nearly the same semantics\n         as files, so it is quite\
    \ reasonable for an inferior process to\n         believe it is communicating\
    \ with the console but in fact be\n         communicating with another process.\n\
    \         The similarity between network connections and existing\n         sequential\
    \ interprocess connections supports our belief that\n         network connections\
    \ are probably the correct structure for\n         using the network.  Moreover,\
    \ the structure is clean enough and\n         compatible with enough machines\
    \ to pass as a formalism or\n         theory, at least to the extent of the other\
    \ forms of\n         interprocess communication presented in the literature.\n\
    \         Any new formalism, we believe, must meet at least the following\n  \
    \       two tests:\n            1. What outstanding problems does it solve?\n\
    \            2. Is it closed under all operations?\n         In the case of network\
    \ connections, the candidates for the\n         first are the ones given above,\
    \ i.e. all operations involving\n         connecting a console to a job or a process.\
    \  Also of interest\n         are the modelling of sequential devices such as\
    \ tape drives,\n         printers and card readers, and the modeling of their\
    \ buffering\n         (spooling, symbiont) systems.\n         The second question\
    \ mentions closure.  In applying the\n         connection formalism to the dial-in\
    \ and login procedures, we\n         felt the need to include some sort of switching\
    \ or\n         reconnection, and an extremely mild form is presented in an\n \
    \        SJCC paper, which is also NWG/RFC #33.  This mild form permits\n    \
    \     only the substitution of AEN's, and even then only at the time\n       \
    \  of connection establishment. However, it is a common experience\n         that\
    \ if an operation has a natural definition on an extended\n         domain, it\
    \ eventually becomes necessary or at least desirable\n         to extend its definition.\
    \  Therefore, we considered the\n         following extensions:\n            1.\
    \ Switching to any other socket, possibly in another Host.\n            2. Switching\
    \ even after data flow has started.\n         There is even some precedent for\
    \ feeling these extensions might\n         be useful.  In one view of an operating\
    \ system, we see all\n         available phone lines as belonging to a live process\
    \ known as\n         the logger.  The logger answers calls, screens users, and\n\
    \         creates jobs and processes.  One of the features of most\n         telephone\
    \ answering equipment is that many phone lines may\n         serve the same phone\
    \ number by using a block of sequential\n         numbers and a rotary answering\
    \ system.  In our quest for\n         accurate models of practical systems, we\
    \ wanted to be able to\n         provide equivalent service to network users,\
    \ i.e. they should\n         be able to call a single advertised number and get\
    \ connected to\n         the logger.  Thus a prima facie case for switching is\n\
    \         established.\n         Next we see that after the logger interrogates\
    \ a prospective\n         user, it must connect the user to a newly created job.\
    \  Data\n         flow between the user and the logger has already commenced,\
    \ so\n         flow control has to be meshed with switching if it is desired\n\
    \         not to lose or garble data in transit.\n         With respect to inter-Host\
    \ switching, we find it easy to\n         imagine a utility service which is distributed\
    \ throughout the\n         network and which passes connections from one socket\
    \ to another\n         without the knowledge of the user.  Also, it is similar\
    \ to the\n         more sophisticated telephone systems, to standard facilities\
    \ of\n         telephone company operators, and to distributed private\n     \
    \    systems.\n         These considerations led us to investigate the possibility\
    \ of\n         finding one type of reconnection which provided a basis for all\n\
    \         known models.  The algorithm did not come easily, probably\n       \
    \  because of inexperience with finite state automata theory, but\n         eventually\
    \ we produced the algorithm presented in NWG/RFC #36.\n         A short time later,\
    \ Bill Crowther produced an equivalent\n         algorithm which takes an alternate\
    \ approach to race conditions.\n         Networkers seem to have one of two reactions.\
    \  Either it was\n         pretty and (perhaps ipso facto) useful, or it was complex\
    \ and\n         (again perhaps ipso facto) unnecessary.  The latter group was\n\
    \         far more evident to us, and we were put into the defensive\n       \
    \  position of admitting that dynamic reconnection was only\n            1. pretty\n\
    \            2. useful for login and console passing\n         In response to\
    \ persistent criticism, we have made the following\n         change in the protocol.\
    \  Instead of calling socket <O,H,O> to\n         login, sockets of the form <U,H,O>\
    \ and <U,H,1> are the input\n         and output sockets respectively of a copy\
    \ of the logger or, if\n         a job has been stared with user id U, these sockets\
    \ are the\n         console sockets.  The protocol for login is thus to initiate\
    \ a\n         connection to <U,H,O> and <U,H,1>.  If user U is not in use, a\n\
    \         copy of the logger will respond and interrogate the caller.  If\n  \
    \       user id U is in use, the call will be refused.  This\n         modification\
    \ was suggested by Barry Wessler recently.  (Others\n         also suggested this\
    \ change much earlier; but we rejected it\n         then.)\n         The logger\
    \ may demand that the caller be from the same virtual\n         net, i.e. the\
    \ caller may have user id U in some other Host, or\n         it may demand that\
    \ the user supply a password matched to user\n         id U, or it may demand\
    \ both.  Some systems may even choose to\n         permit anybody to login to\
    \ any user id.\n         After login, AEN's 0 and 1 remain the console AEN's.\
    \  Each\n         system presumably has mechanisms for passing the console, and\n\
    \         these would be extended to know about AEN's 0 and 1 for network\n  \
    \       users.  Passing the console is thus a matter of reconnecting\n       \
    \  sockets to ports, and happens within the Host and without the\n         network.\n\
    \         In conversations with Meyer and Skinner after NWG/RFC #46 was\n    \
    \     received, they suggested a login scheme different from both\n         Meyer's\
    \ and ours in section above.  Their new scheme seemed a\n         little better\
    \ and we look forward to their next note.\n         It is generally agreed that\
    \ login should be \"third-level\", that\n         is, above the NCP level.  We\
    \ are beginning to be indifferent\n         about particular logins schemes; all\
    \ seem ok and none impress\n         us greatly.  We suggest that several be tried.\
    \  It is some\n         burden, of course, to modify the local login procedure,\
    \ but we\n         believe it imposes no extra hardship to deal with diverse login\n\
    \         procedures.  This is because the text sequences and interrupt\n    \
    \     conventions are so heterogenous that the additional burden of\n        \
    \ following, say, our scheme on our system and Meyer's on Multics\n         is\
    \ minimal.\n         We are agreed that reconnection should not be required in\
    \ the\n         initial protocol, and we will offer it later as an optional and\n\
    \         experimental tool.  In addition, we would like to be on record\n   \
    \      as predicting that general reconnection facilities will become\n      \
    \   useful and will provide a unifying framework for currently ad\n         hoc\
    \ operating system structures.\n      C. Decoupling Connections and Links\n  \
    \       Bill Crowther (BBN) and Steve Wolfe (UCLA) independently have\n      \
    \   suggested that links not be assigned to particular connections.\n        \
    \ Instead, they suggest, include the destination socket as part\n         of the\
    \ text of the message and then send messages over any\n         unblocked link.\n\
    \         We discussed this question a little in NWG/RFC #37, and feel\n     \
    \    there is yet an argument for either case.  With the current\n         emphasis\
    \ on simplicity, speed and small core requirements, it\n         seems more efficient\
    \ to leave links and connections coupled.\n         We, therefore, recommend this.\n\
    \      D. Error Reporting\n         As mentioned by J. Heafner and E. Harslem\
    \ of RAND, it is\n         important to treat errors which might occur.  A good\
    \ philosophy\n         is to guard against any input which destroys the consistency\
    \ of\n         the NCP's data base.\n         The specific formulation of the\
    \ error command given by Heafner\n         and Harslem in NWG/RFC #40 and by Meyer\
    \ in NWG/RFC #46 seems\n         reasonable and we recommend its adoption.  Some\
    \ comments are in\n         order, however.\n         A distinction should be\
    \ made between resource errors and other\n         types of errors.  Resource\
    \ errors are just the detection of\n         overload conditions.  Overload conditions\
    \ are well-defined and\n         valid, although perhaps undesirable.  Other types\
    \ of errors\n         reflect errant software or hardware.  We feel that resource\n\
    \         errors should not be handled with error mechanisms, but with\n     \
    \    mechanisms specific to the problem.  Thus the <CLS> command may\n       \
    \  be issued when there is no more room to save waiting <RFC>'s.\n         Flow\
    \ control protocol is designed solely to handle buffering\n         overload.\n\
    \         With respect to true errors, we are not certain what the value\n   \
    \      of the <ERR> command is to the recipient.  Presumably his NCP\n       \
    \  is broken, and it may only aggravate the problem to bombard it\n         with\
    \ error commands.  We therefore, recommend that error\n         generation be\
    \ optional, that all errors be logged locally in a\n         chronological file\
    \ and that <ERR> commands received likewise be\n         logged in a chronological\
    \ file.  No corrective action is\n         specified at this time.\n         In\
    \ the short time the network has been up at UCLA, we have\n         become convinced\
    \ that the network itself will generate very few\n         errors.  We have watched\
    \ the BBN staff debug and test the IMP\n         program, and it seemed that most\
    \ of the errors affected timing\n         and throughput rather than validity.\
    \  Hence most errors will\n         probably arise from broken Hosts and/or buggy\
    \ NCP's.\n      E. Status Testing and Reporting\n         A valuable debugging\
    \ aid is to be able to get information about\n         what a foreign NCP thinks\
    \ is happening.  A convenient way to do\n         this is to permit NCP's to send\
    \ status whenever they wish, but\n         to always have them do it whenever\
    \ they receive a request.\n         Since we view this feature as primarily a\
    \ debugging tool, we\n         suggest that a distinct link, like 255, be used.\
    \  The intent is\n         that processing of status requests and generating of\
    \ status\n         messages should use as little of the normal machinery as\n\
    \         possible.  Thus we suggest that link 255 be used to send\n         \"\
    request status\" and \"status is\" commands.  The form follows\n         the suggestion\
    \ on page 2 of NWG/RFC #40.\n         Meyer's <ECO> command is easily implemented\
    \ and serves the more\n         basic function of testing whether a foreign NCP\
    \ is alive.  We\n         suggest that the length of the <ECO> command be variable,\
    \ as\n         there seems to be no significance in this context to 48 bits.\n\
    \         Also, the value of a (presumably) 8 bit binary switch is\n         unclear,\
    \ so we recommend a pair of commands:\n                   <ECO>   <length>   <text>\n\
    \         and\n                   <ERP>   <length>   <text>\n         where\n\
    \                   <length> is 8 bits.\n         Upon receipt of an <ECO> command\
    \ the NCP would echo with the\n         <ERP> command.\n      F. Expansion and\
    \ Experimentation\n         As Meyer correctly points out in NWG/RFC #46, network\
    \ protocol\n         is a layered affair.  Three levels are apparent so far.\n\
    \            1. IMP Network Protocol\n            2. Network Control Program Protocol\n\
    \            3. Special user level or Subsystem Level Protocol\n         This\
    \ last level should remain idiosyncratic to each Host (or\n         even each\
    \ user).  The first level is well-specified by BBN, and\n         our focus here\
    \ is on level 2.  We would like to keep level 2 as\n         neutral and simple\
    \ as possible, and in particular we agree that\n         login protocol should\
    \ be as much on level 3 as possible.\n         Simplicity and foresight notwithstanding,\
    \ there will arise\n         occasions when the level 2 protocol should change\
    \ or be\n         experimented with.  In order to provide for experimentation\
    \ and\n         change, we recommend that only link numbers 2 through 31 be\n\
    \         assigned to regular connections, with the remaining link\n         numbers,\
    \ 32 to 255, used experimentally.  We have already\n         suggested that link\
    \ 255 be used for status requests and\n         replies, and this is in consonance\
    \ with our view of the\n         experimental aspects of that feature.\n     \
    \    We also recommend that control command prefixes from 255\n         downward\
    \ be used for experimentation.\n         These two conventions are sufficient,\
    \ we feel to permit\n         convenient experimentation with new protocol among\
    \ any subset\n         of the sites. We thus do not favor inclusion of Ancona's\n\
    \         suggestion in NWG/RFC #42 for a message data type code as the\n    \
    \     first eight bits of the text of a message.\n      G. Multiplexing Ports\
    \ to Sockets\n         Wolfe in NWG/RFC #38 and Shoshani et al in NWG/RFC #44\
    \ suggest\n         that it should be possible to attach more than one port to\
    \ a\n         socket.  While all of our diagrams and prototypical system\n   \
    \      calls have shown a one-to-one correspondence between sockets\n        \
    \ and ports, it is strictly a matter of local implementation.  We\n         note\
    \ that sockets form a network-wide name space whose sole\n         purpose is\
    \ to interface between the idiosyncratic structures\n         peculiar to each\
    \ operating system.  Our references to ports are\n         intended to be suggestive\
    \ only, and should be ignored if no\n         internal structures corresponds\
    \ to them.  Most systems do have\n         such structures, however, so we shall\
    \ continue to use them for\n         illustration.\n      H. Echoing, Interrupts\
    \ and Code Conversion\n         1. Interrupts\n            We had been under the\
    \ impression that all operating systems\n            scanned for a reserved character\
    \ from the keyboard to\n            interpret it as an interrupt signal.  Tom\
    \ Skinner and Ed\n            Meyer of MIT inform us that model 37 TTY's and IBM\
    \ 2741\n            generate a \"long space\" of 200-500 milliseconds which is\n\
    \            detected by the I/O channel hardware and passed to the\n        \
    \    operating system as an interrupt.  The \"long space\" is not a\n        \
    \    character -- it has no ASCII code and cannot be program\n            generated.\n\
    \            Well over a year ago, we considered the problem of\n            simulating\
    \ console interrupts and rejected the <INT> type\n            command because\
    \ it didn't correctly model any system we\n            knew.  We now reverse our\
    \ position and recommend the\n            implementation of an INTERRUPT system\
    \ call and an <INT>\n            control command as suggested by Meyer in NWG/RFC\
    \ #46.\n            Two restrictions of the interrupt facility should be\n   \
    \         observed.  First, when communicating with systems which scan\n     \
    \       for interrupt characters, this feature should not be used.\n         \
    \   Second, non-console-like connections probably should not\n            have\
    \ interrupts. We recommend that systems follow their own\n            conventions,\
    \ and if an <INT> arrives for a connection on\n            which it shouldn't\
    \ the <INT> should be discarded and\n            optionally returned as an error.\n\
    \         2. Echoing and Code Conversion\n            We believe that each site\
    \ should continue its current\n            echoing policy and that code conversion\
    \ should be done by\n            the using process.  Standardization in this area\
    \ should\n            await further development.\n            Ancona's suggestion\
    \ of a table-driven front-end transducer\n            seems like the right thing,\
    \ but we believe that such\n            techniques are part of a larger discussion\
    \ involving\n            higher-level languages for the network.\n      I. Broadcast\
    \ Facilities\n         Heafner and Harslem suggest in NWG/RFC #39 a broadcast\n\
    \         facility, i.e. <TER> and <BDC>.  We do not fully understand the\n  \
    \       value of this facility and are thus disposed against it.  We\n       \
    \  suspect that we would understand its value better if we had\n         more\
    \ experience with OS/360.  It is probably true in general\n         that sites\
    \ running OS/360 or similar systems will find less\n         relevance in our\
    \ suggestions for network protocol than sites\n         running time-sharing systems.\
    \  We would appreciate any cogent\n         statement on the relationship between\
    \ OS/360 and the concepts\n         and assumptions underlying the network protocol.\n\
    \      J. Instance Numbers\n         Meyer in NWG/RFC #46 suggests extending a\
    \ socket to include an\n         _instance_ code which identifies the process\
    \ attached to the\n         socket.  We carefully arranged matters so that processes\
    \ would\n         be indistinguishable.  We did this with the belief that both\
    \ as\n         a formal and as a practical matter it is of concern only within\n\
    \         a Host whether a computation is performed by one or many\n         processes.\
    \  Thus we believe that all processes within a job\n         should cooperate\
    \ in allocating AEN's.  If an operating system\n         has facilities for passing\
    \ a console from process to process\n         within a job, these facilities mesh\
    \ nicely with the current\n         network protocol, even within reconnection\
    \ protocol; but\n         instance numbers interfere with such a procedure.\n\
    \         We suggest this matter be discussed fully because it relates to\n  \
    \       the basic philosophy of sockets and connections.  Presently we\n     \
    \    recommend 40 bit socket numbers without instance codes.\n      K. AEN's\n\
    \         Nobody, including us, is particularly happy with our name AEN\n    \
    \     for the low order 8 bits of the socket.  We rejected _socket_\n        \
    \ number_, and are similarly unhappy with Meyer's _socket_code_.\n         The\
    \ word socket should not be used as part of the field name,\n         and we solicit\
    \ suggestions.\n"
- title: III. Environment
  contents:
  - "III. Environment\n   We assume that the typical host will have a time-sharing\
    \ operating\n   system in which the cpu is shared by processes.\n   Processes\n\
    \   We envision that each process is tagged with a _user_number_. There\n   may\
    \ be more than one process with the same user number, and if so,\n   they should\
    \ all be cooperating with respect to using the network.\n   We envision that each\
    \ process contains a set of _ports_ which are\n   unique to the process.  These\
    \ ports are used for input to or output\n   from the process, from or to files,\
    \ devices or other processes.\n   We also envision that each process has an event\
    \ channel over which it\n   can receive very short messages (several bits).  We\
    \ will use this\n   mechanism to notify a process that some action external to\
    \ the\n   process has occurred.\n   To engage in network activity, a process _attaches_\
    \ a _local_socket_\n   to one of its ports.  Sockets are identified by user number,\
    \ host and\n   AEN, and a socket is local to a process if their user numbers match\n\
    \   and they are in the same host.  A process need only specify an AEN\n   when\
    \ it is referring to a local socket.\n   Each port has a status which is modified\
    \ by system calls and by\n   concurrent events outside the process.  Whenever\
    \ the status of a port\n   is changed, the process is sent an event over its event\
    \ channel which\n   specifies which port's status has changed.  The process may\
    \ then look\n   at a port's status.\n   These assumptions are used descriptive\
    \ material which follows.\n   However, these assumptions are not imposed by the\
    \ network protocol\n   and the implementation suggested by section IV is in no\
    \ way binding.\n   We wish to make very clear that this material is offered only\
    \ to\n   provide clues as to what the implementation difficulties might be and\n\
    \   not to impose any particular discipline.\n   For example, we treat <RFC>'s\
    \ which arrive for unattached local\n   sockets as valid and queue them.  If desired,\
    \ an NCP may reject them,\n   as Meyer suggests, or it might hold them for awhile\
    \ and reject them\n   if they're not soon satisfied.  The offered protocol supports\
    \ all\n   these options.\n   Another local option is the one mentioned before\
    \ of attaching\n   multiple ports to a socket.  We have shown one-one correspondence\
    \ but\n   this may be ignored.  Similarly, the system calls are merely\n   suggestive.\n\
    \   System Calls\n   These are typical system calls which a user process might\
    \ execute.\n   We show these only for completeness; each site will undoubtedly\n\
    \   implement whatever equivalent set is convenient.\n        We use the notation\n\
    \        Syscall ( arg , arg ...; val ... )\n                     1     2    \
    \    1\n   where\n        Syscall is the system call\n        arg  etc. are the\
    \ parameters supplied with the call, and\n           1\n        val etc. are any\
    \ values returned by the system call.\n           1\n   Init (P,AEN,FS,Bsiz;C)\n\
    \        P      Specifies a port of the process.\n        AEN    Specifies a local\
    \ socket.  The user number of this\n               process and host number of\
    \ this host are implicit.\n        FS     Specifies a socket with any user number\
    \ in any host,\n               with any AEN.\n        Bsiz   Specified the amount\
    \ of storage in bits the user wants\n               to devote to buffering messages.\n\
    \        C      The condition code returned.\n   Init attempts to attach the local\
    \ socket specified by AEN to the port\n   P and to initiate a connection with\
    \ socket FS.  Possible returned\n   values of C are\n        C = ok      The Init\
    \ was legal and the socket FS is being\n                    contacted.  When the\
    \ connection is established or\n                    when FS refuses, the process\
    \ will receive an event.\n        C = busy    The local socket was in use by a\
    \ port on this or\n                    some other process with the same user number.\
    \  No\n                    action was taken.\n        C = homosex The AEN and\
    \ FS were either both send or both receive\n                    sockets.\n   \
    \     C = nohost  The host designated within FS isn't known.\n        C = bufbig\
    \  Bsiz is too large.\n   Listen (P,AEN,Bsize;C)\n        P     Specifies a port\
    \ of the process.\n        AEN   Specifies a local socket.\n        Bsiz  Specified\
    \ a buffer size.\n        C     The returned legality code.\n   Codes for C are\n\
    \        C = ok\n        C = busy\n        C = bufbig\n   The local socket specifies\
    \ by AEN is attached to P.  If there is a\n   waiting call, it is processed; otherwise\
    \ no action is taken.  When a\n   call comes in, a connection will be established\
    \ and the process\n   notified via an event.\n   Close (P)\n        P Specifies\
    \ a port of the process.\n   Any activity is stopped, and the port becomes free\
    \ for other use.\n   Transmit (P,M,L1;L2,C)\n        P     Specifies port with\
    \ an open connection.\n        M     The text to be transmitted.\n        L1 \
    \   Specifies the length of the text.\n        L2    The length actually transmitted.\n\
    \        C     The error code.\n   Transmission between the processes on either\
    \ side of the port takes\n   place.\n   Codes for C are\n        C = ok\n   or\n\
    \        C = not open     if no connection is currently open and\n           \
    \              otherwise uninhibited\n   Status (P;C)\n   The status of port P\
    \ is returned as C.\n"
- title: IV. The NCP
  contents:
  - "IV. The NCP\n   We view the NCP as having five component programs, three associative\n\
    \   tables, some queues and buffers, and a link assignment table.  Each\n   site\
    \ will of course, vary this design to meet its needs, so our\n   design is only\
    \ illustrative.\n   The Component Programs\n      1. The Input Handler\n     \
    \    This is an interrupt driven input routine.  It initiates Imp-\n         to-Host\
    \ transmission into a resident buffer and wakes up the\n         Input Interpreter\
    \ when transmission is complete.\n      2. The Output Handler\n         This is\
    \ an interrupt driven output routine.  It initiates\n         Host-to-Imp transmission\
    \ out of a resident buffer and wakes up\n         the Output Scheduler when transmission\
    \ is complete.\n      3. The Input Interpreter\n         This program decides\
    \ whether the input is a regular message\n         intended for a user, a control\
    \ message, an Imp-to-Host message,\n         or an error.  For each class of message,\
    \ this program takes the\n         appropriate action.\n      4. The Output Scheduler\n\
    \         Three classes of message are sent to the Imp\n            (a) Host-to-Imp\
    \ messages\n            (b) Control messages\n            (c) Regular messages\n\
    \         We believe that a priority should be imposed among these\n         classes.\
    \  The priority we suggest is the ordering above. The\n         Output Scheduler\
    \ selects the highest priority message and\n         gives it to the Output Handler.\n\
    \      5. The System Call Interpreter\n         This program interprets requests\
    \ from the user.\n   The two interesting components are the Input Interpreter\
    \ and the\n   System Call Interpreter.  These are similar in that the Input\n\
    \   Interpreter services foreign requests and the System Call Interpreter\n  \
    \ services local requests.\n   Associative Tables\n   We envision that the bulk\
    \ of the NCP's data base is in three\n   associative tables.  By \"associative\"\
    , we mean that there is some\n   lookup routine which is presented with a key\
    \ and either returns\n   successfully with a pointer to the corresponding entry,\
    \ or fails if\n   no entry corresponds to the key.\n      1. The Rendezvous Table\n\
    \         \"Requests-for-connection\" and other attributes of a\n         connection\
    \ are held in this table.  This table is accessed by\n         local socket, but\
    \ other tables have pointers to existing\n         entries.\n            The components\
    \ of an entry are:\n            (a) local socket   (key)\n            (b) foreign\
    \ socket\n            (c) link\n            (d) queue of callers\n           \
    \ (e) text queue\n            (f) connection state\n            (g) flow state\n\
    \            (h) pointer to attached port\n            An entry is created when\
    \ a user executes either an Init or a\n            Listen system call or when\
    \ a <RFC> is received.  Some fields\n            are unused until the connection\
    \ is established, e.g. the\n            foreign socket is not known until a <RFC>\
    \ arrives if the\n            user did a Listen.\n      2. The Input Link Table\n\
    \            The Input Interpreter uses the foreign host and link as a\n     \
    \       key to get a pointer to the entry in the rendezvous table\n          \
    \  for the connection using the incoming link.\n      3. The Output Link Table\n\
    \            In order to interpret RFNM's, the Input Interpreter needs a\n   \
    \         table in the same form as the Input Link Table but using\n         \
    \   outgoing links.\n   Link Assignment Table\n   This is a very simple structure\
    \ which keeps track of which links are\n   in use for each host.  One word per\
    \ host probably suffices.\n   The following diagram is our conception of the Network\
    \ Control\n   Program.  Boxes represent tables and Buffers, boxes with angled\n\
    \   corners and a double bottom represent Queues, and jagged boxes\n   represent\
    \ component programs, the arrows represent data paths.\n   The abbreviated names\
    \ have the following meanings.\n   ILT   - Input Link Table\n   OLT   - Output\
    \ Link Table\n   LAT   - Link Assignment Table\n   RT    - Rendezvous Table\n\
    \   HIQ   - Host to Imp Queue\n   OCCQ  - Output Control Command Queue\n   ORMQ\
    \  - Output Regular Message Queue\n   IHBuf - Buffer filled by the Input Handler\
    \ from the IMP and\n           emptied by the Input Interpreter\n   OHBuf - Buffer\
    \ of outgoing messages filled from the Queues\n           by the Output Scheduler\
    \ and emptied by the Output\n           Handler.\n                           \
    \   +---------+\n                              |  I M P  |\n                 \
    \             +---------+\n                                v     ^\n         \
    \                       |     |\n    +---------------------------|-----|------------------------------+\n\
    \    |                           |     |                              |\n    |\
    \   /\\/\\/\\/\\/\\/\\/\\          |     |     /\\/\\/\\/\\/\\/\\/\\         \
    \  |\n    |   \\            / <--------+     +---< \\            /           |\n\
    \    |   /  Input     \\                      /  Output    \\           |\n  \
    \  |   \\   Handler  /                      \\   Handler  / <----+    |\n    |\
    \   /            \\ >------+             /            \\      |    |\n    |  \
    \ \\/\\/\\/\\/\\/\\/\\/        |             \\/\\/\\/\\/\\/\\/\\/      ^    |\n\
    \    |                         v                              +-----+ |\n    |\
    \                      +-----+                           | OH  | |\n    |    \
    \                  | IM  |                           | Buf | |\n    |        \
    \              | Buf |                           +-----+ |\n    |            \
    \          +-----+          /\\/\\/\\/\\/\\/\\/\\/\\    ^    |\n    | /\\/\\/\\\
    /\\/\\/\\/\\/\\        v      +----> \\              /    |    |\n    | \\   \
    \           /        |      |      /  Output      \\ >--+    |\n    | /      \
    \        \\ <------+      ^      \\              /         |\n    | \\  Input\
    \       /           /-----\\    /   Scheduler  \\         |\n    | /         \
    \     \\ >-------->| HIQ |    \\              /         |\n    | \\  Interpreter\
    \ /           |_____|    /              \\         |\n    | /              \\\
    \ >----+    \\_____/    \\/\\/\\/\\/\\/\\/\\/\\/         |\n    | \\/\\/\\/\\\
    /\\/\\/\\/\\/      |                ^     v    ^            |\n    |   ^   ^ \
    \   ^   \\      |    /-----\\     |     |    |    /-----\\ |\n    |   |    \\\
    \    \\   \\     |    |  O  |     |     |    |    |  O  | |\n    |   |     \\\
    \    \\   \\    +--->|  C  |>----+     |    +---<|  R  | |\n    |   v     v  \
    \   v   \\        |  C  |           |         |  M  | |\n    | +---+ +---+ +---+\
    \  \\       |  Q  |           v         |  Q  | |\n    | |   | |   | |   |   \\\
    \      |_____|      +---------+    |_____| |\n    | |ILT| |LAT| |OLT|    \\  \
    \   \\_____/      |         |    \\_____/ |\n    | |   | |   | |   |     \\  \
    \     ^         |   R T   |       ^    |\n    | +---+ +---+ +---+      +------|-------->|\
    \         |       |    |\n    |         v                     |         +---------+\
    \       |    |\n    |         |                     ^              ^         \
    \   |    |\n    |         |            /\\/\\/\\/\\/\\/\\/\\/\\        |     \
    \       |    |\n    |         |            \\              /        |        \
    \    |    |\n    |         +----------->/    System    \\<-------+           \
    \ |    |\n    |                      \\     Call     /                     | \
    \   |\n    |                      /  Interpreter \\>--------------------+    |\n\
    \    |                      \\              /                          |\n   \
    \ |                  +-->/              \\>--+                      |\n    | \
    \                 |   \\/\\/\\/\\/\\/\\/\\/\\/   |                      |\n  \
    \  +------------------|----------------------|----------------------+\n      \
    \                 |                      |\n                       +---< system\
    \ calls <---+\n       [ This RFC was put into machine readable form for entry\
    \ ]\n   [ into the online RFC archives by Donald and Jill Eastlake 1999 ]\n"
- title: '[Editor''s note: The original hand-drawn diagram represented'
  contents:
  - '[Editor''s note: The original hand-drawn diagram represented

    '
- title: Queues by cylinders and component programs by "squishy ameoba
  contents:
  - 'Queues by cylinders and component programs by "squishy ameoba

    '
- title: like things".]
  contents:
  - 'like things".]

    '
