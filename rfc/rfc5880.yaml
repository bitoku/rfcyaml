- title: __initial_text__
  contents:
  - '                Bidirectional Forwarding Detection (BFD)

    '
- title: Abstract
  contents:
  - "Abstract\n   This document describes a protocol intended to detect faults in\
    \ the\n   bidirectional path between two forwarding engines, including\n   interfaces,\
    \ data link(s), and to the extent possible the forwarding\n   engines themselves,\
    \ with potentially very low latency.  It operates\n   independently of media,\
    \ data protocols, and routing protocols.\n"
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This is an Internet Standards Track document.\n   This\
    \ document is a product of the Internet Engineering Task Force\n   (IETF).  It\
    \ represents the consensus of the IETF community.  It has\n   received public\
    \ review and has been approved for publication by the\n   Internet Engineering\
    \ Steering Group (IESG).  Further information on\n   Internet Standards is available\
    \ in Section 2 of RFC 5741.\n   Information about the current status of this document,\
    \ any errata,\n   and how to provide feedback on it may be obtained at\n   http://www.rfc-editor.org/info/rfc5880.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (c) 2010 IETF Trust and the persons identified\
    \ as the\n   document authors.  All rights reserved.\n   This document is subject\
    \ to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n\
    \   (http://trustee.ietf.org/license-info) in effect on the date of\n   publication\
    \ of this document.  Please review these documents\n   carefully, as they describe\
    \ your rights and restrictions with respect\n   to this document.  Code Components\
    \ extracted from this document must\n   include Simplified BSD License text as\
    \ described in Section 4.e of\n   the Trust Legal Provisions and are provided\
    \ without warranty as\n   described in the Simplified BSD License.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1. Introduction ....................................................3\n\
    \      1.1. Conventions Used in This Document ..........................4\n  \
    \ 2. Design ..........................................................4\n   3.\
    \ Protocol Overview ...............................................5\n      3.1.\
    \ Addressing and Session Establishment .......................5\n      3.2. Operating\
    \ Modes ............................................5\n   4. BFD Control Packet\
    \ Format .......................................7\n      4.1. Generic BFD Control\
    \ Packet Format ..........................7\n      4.2. Simple Password Authentication\
    \ Section Format .............11\n      4.3. Keyed MD5 and Meticulous Keyed MD5\
    \ Authentication\n           Section Format ............................................11\n\
    \      4.4. Keyed SHA1 and Meticulous Keyed SHA1\n           Authentication Section\
    \ Format .............................13\n   5. BFD Echo Packet Format .........................................14\n\
    \   6. Elements of Procedure ..........................................14\n  \
    \    6.1. Overview ..................................................14\n    \
    \  6.2. BFD State Machine .........................................16\n      6.3.\
    \ Demultiplexing and the Discriminator Fields ...............17\n      6.4. The\
    \ Echo Function and Asymmetry ...........................18\n      6.5. The Poll\
    \ Sequence .........................................19\n      6.6. Demand Mode\
    \ ...............................................19\n      6.7. Authentication\
    \ ............................................21\n           6.7.1. Enabling and\
    \ Disabling Authentication ..............21\n           6.7.2. Simple Password\
    \ Authentication .....................22\n           6.7.3. Keyed MD5 and Meticulous\
    \ Keyed MD5 Authentication ..23\n           6.7.4. Keyed SHA1 and Meticulous Keyed\
    \ SHA1\n                  Authentication .....................................25\n\
    \      6.8. Functional Specifics ......................................27\n  \
    \         6.8.1. State Variables ....................................27\n    \
    \       6.8.2. Timer Negotiation ..................................30\n      \
    \     6.8.3. Timer Manipulation .................................31\n        \
    \   6.8.4. Calculating the Detection Time .....................32\n          \
    \ 6.8.5. Detecting Failures with the Echo Function ..........33\n           6.8.6.\
    \ Reception of BFD Control Packets ...................33\n           6.8.7. Transmitting\
    \ BFD Control Packets ...................36\n           6.8.8. Reception of BFD\
    \ Echo Packets ......................39\n           6.8.9. Transmission of BFD\
    \ Echo Packets ...................39\n           6.8.10. Min Rx Interval Change\
    \ ............................40\n           6.8.11. Min Tx Interval Change ............................40\n\
    \           6.8.12. Detect Multiplier Change ..........................40\n  \
    \         6.8.13. Enabling or Disabling The Echo Function ...........40\n    \
    \       6.8.14. Enabling or Disabling Demand Mode .................40\n      \
    \     6.8.15. Forwarding Plane Reset ............................41\n        \
    \   6.8.16. Administrative Control ............................41\n          \
    \ 6.8.17. Concatenated Paths ................................41\n           6.8.18.\
    \ Holding Down Sessions .............................42\n   7. Operational Considerations\
    \ .....................................43\n   8. IANA Considerations ............................................44\n\
    \   9. Security Considerations ........................................45\n  \
    \ 10. References ....................................................46\n    \
    \  10.1. Normative References .....................................46\n      10.2.\
    \ Informative References ...................................47\n   Appendix A.\
    \ Backward Compatibility (Non-Normative) ................48\n   Appendix B. Contributors\
    \ ..........................................48\n   Appendix C. Acknowledgments\
    \ .......................................49\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   An increasingly important feature of networking equipment\
    \ is the\n   rapid detection of communication failures between adjacent systems,\n\
    \   in order to more quickly establish alternative paths.  Detection can\n   come\
    \ fairly quickly in certain circumstances when data link hardware\n   comes into\
    \ play (such as Synchronous Optical Network (SONET) alarms).\n   However, there\
    \ are media that do not provide this kind of signaling\n   (such as Ethernet),\
    \ and some media may not detect certain kinds of\n   failures in the path, for\
    \ example, failing interfaces or forwarding\n   engine components.\n   Networks\
    \ use relatively slow \"Hello\" mechanisms, usually in routing\n   protocols,\
    \ to detect failures when there is no hardware signaling to\n   help out.  The\
    \ time to detect failures (\"Detection Times\") available\n   in the existing\
    \ protocols are no better than a second, which is far\n   too long for some applications\
    \ and represents a great deal of lost\n   data at gigabit rates.  Furthermore,\
    \ routing protocol Hellos are of\n   no help when those routing protocols are\
    \ not in use, and the\n   semantics of detection are subtly different -- they\
    \ detect a failure\n   in the path between the two routing protocol engines.\n\
    \   The goal of Bidirectional Forwarding Detection (BFD) is to provide\n   low-overhead,\
    \ short-duration detection of failures in the path\n   between adjacent forwarding\
    \ engines, including the interfaces, data\n   link(s), and, to the extent possible,\
    \ the forwarding engines\n   themselves.\n   An additional goal is to provide\
    \ a single mechanism that can be used\n   for liveness detection over any media,\
    \ at any protocol layer, with a\n   wide range of Detection Times and overhead,\
    \ to avoid a proliferation\n   of different methods.\n   This document specifies\
    \ the details of the base protocol.  The use of\n   some mechanisms are application\
    \ dependent and are specified in a\n   separate series of application documents.\
    \  These issues are so noted.\n   Note that many of the exact mechanisms are implementation\
    \ dependent\n   and will not affect interoperability, and are thus outside the\
    \ scope\n   of this specification.  Those issues are so noted.\n"
- title: 1.1.  Conventions Used in This Document
  contents:
  - "1.1.  Conventions Used in This Document\n   The key words \"MUST\", \"MUST NOT\"\
    , \"REQUIRED\", \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\"\
    ,  \"MAY\", and \"OPTIONAL\" in this\n   document are to be interpreted as described\
    \ in RFC 2119 [KEYWORDS].\n"
- title: 2.  Design
  contents:
  - "2.  Design\n   BFD is designed to detect failures in communication with a forwarding\n\
    \   plane next hop.  It is intended to be implemented in some component\n   of\
    \ the forwarding engine of a system, in cases where the forwarding\n   and control\
    \ engines are separated.  This not only binds the protocol\n   more to the forwarding\
    \ plane, but decouples the protocol from the\n   fate of the routing protocol\
    \ engine, making it useful in concert with\n   various \"graceful restart\" mechanisms\
    \ for those protocols.  BFD may\n   also be implemented in the control engine,\
    \ though doing so may\n   preclude the detection of some kinds of failures.\n\
    \   BFD operates on top of any data protocol (network layer, link layer,\n   tunnels,\
    \ etc.)  being forwarded between two systems.  It is always\n   run in a unicast,\
    \ point-to-point mode.  BFD packets are carried as\n   the payload of whatever\
    \ encapsulating protocol is appropriate for the\n   medium and network.  BFD may\
    \ be running at multiple layers in a\n   system.  The context of the operation\
    \ of any particular BFD session\n   is bound to its encapsulation.\n   BFD can\
    \ provide failure detection on any kind of path between\n   systems, including\
    \ direct physical links, virtual circuits, tunnels,\n   MPLS Label Switched Paths\
    \ (LSPs), multihop routed paths, and\n   unidirectional links (so long as there\
    \ is some return path, of\n   course).  Multiple BFD sessions can be established\
    \ between the same\n   pair of systems when multiple paths between them are present\
    \ in at\n   least one direction, even if a lesser number of paths are available\n\
    \   in the other direction (multiple parallel unidirectional links or\n   MPLS\
    \ LSPs, for example).\n   The BFD state machine implements a three-way handshake,\
    \ both when\n   establishing a BFD session and when tearing it down for any reason,\n\
    \   to ensure that both systems are aware of the state change.\n   BFD can be\
    \ abstracted as a simple service.  The service primitives\n   provided by BFD\
    \ are to create, destroy, and modify a session, given\n   the destination address\
    \ and other parameters.  BFD in return provides\n   a signal to its clients indicating\
    \ when the BFD session goes up or\n   down.\n"
- title: 3.  Protocol Overview
  contents:
  - "3.  Protocol Overview\n   BFD is a simple Hello protocol that, in many respects,\
    \ is similar to\n   the detection components of well-known routing protocols.\
    \  A pair of\n   systems transmit BFD packets periodically over each path between\
    \ the\n   two systems, and if a system stops receiving BFD packets for long\n\
    \   enough, some component in that particular bidirectional path to the\n   neighboring\
    \ system is assumed to have failed.  Under some conditions,\n   systems may negotiate\
    \ not to send periodic BFD packets in order to\n   reduce overhead.\n   A path\
    \ is only declared to be operational when two-way communication\n   has been established\
    \ between systems, though this does not preclude\n   the use of unidirectional\
    \ links.\n   A separate BFD session is created for each communications path and\n\
    \   data protocol in use between two systems.\n   Each system estimates how quickly\
    \ it can send and receive BFD packets\n   in order to come to an agreement with\
    \ its neighbor about how rapidly\n   detection of failure will take place.  These\
    \ estimates can be\n   modified in real time in order to adapt to unusual situations.\
    \  This\n   design also allows for fast systems on a shared medium with a slow\n\
    \   system to be able to more rapidly detect failures between the fast\n   systems\
    \ while allowing the slow system to participate to the best of\n   its ability.\n"
- title: 3.1.  Addressing and Session Establishment
  contents:
  - "3.1.  Addressing and Session Establishment\n   A BFD session is established based\
    \ on the needs of the application\n   that will be making use of it.  It is up\
    \ to the application to\n   determine the need for BFD, and the addresses to use\
    \ -- there is no\n   discovery mechanism in BFD.  For example, an OSPF [OSPF]\n\
    \   implementation may request a BFD session to be established to a\n   neighbor\
    \ discovered using the OSPF Hello protocol.\n"
- title: 3.2.  Operating Modes
  contents:
  - "3.2.  Operating Modes\n   BFD has two operating modes that may be selected, as\
    \ well as an\n   additional function that can be used in combination with the\
    \ two\n   modes.\n   The primary mode is known as Asynchronous mode.  In this\
    \ mode, the\n   systems periodically send BFD Control packets to one another,\
    \ and if\n   a number of those packets in a row are not received by the other\n\
    \   system, the session is declared to be down.\n   The second mode is known as\
    \ Demand mode.  In this mode, it is assumed\n   that a system has an independent\
    \ way of verifying that it has\n   connectivity to the other system.  Once a BFD\
    \ session is established,\n   such a system may ask the other system to stop sending\
    \ BFD Control\n   packets, except when the system feels the need to verify connectivity\n\
    \   explicitly, in which case a short sequence of BFD Control packets is\n   exchanged,\
    \ and then the far system quiesces.  Demand mode may operate\n   independently\
    \ in each direction, or simultaneously.\n   An adjunct to both modes is the Echo\
    \ function.  When the Echo\n   function is active, a stream of BFD Echo packets\
    \ is transmitted in\n   such a way as to have the other system loop them back\
    \ through its\n   forwarding path.  If a number of packets of the echoed data\
    \ stream\n   are not received, the session is declared to be down.  The Echo\n\
    \   function may be used with either Asynchronous or Demand mode.  Since\n   the\
    \ Echo function is handling the task of detection, the rate of\n   periodic transmission\
    \ of Control packets may be reduced (in the case\n   of Asynchronous mode) or\
    \ eliminated completely (in the case of Demand\n   mode).\n   Pure Asynchronous\
    \ mode is advantageous in that it requires half as\n   many packets to achieve\
    \ a particular Detection Time as does the Echo\n   function.  It is also used\
    \ when the Echo function cannot be supported\n   for some reason.\n   The Echo\
    \ function has the advantage of truly testing only the\n   forwarding path on\
    \ the remote system.  This may reduce round-trip\n   jitter and thus allow more\
    \ aggressive Detection Times, as well as\n   potentially detecting some classes\
    \ of failure that might not\n   otherwise be detected.\n   The Echo function may\
    \ be enabled individually in each direction.  It\n   is enabled in a particular\
    \ direction only when the system that loops\n   the Echo packets back signals\
    \ that it will allow it, and when the\n   system that sends the Echo packets decides\
    \ it wishes to.\n   Demand mode is useful in situations where the overhead of\
    \ a periodic\n   protocol might prove onerous, such as a system with a very large\n\
    \   number of BFD sessions.  It is also useful when the Echo function is\n   being\
    \ used symmetrically.  Demand mode has the disadvantage that\n   Detection Times\
    \ are essentially driven by the heuristics of the\n   system implementation and\
    \ are not known to the BFD protocol.  Demand\n   mode may not be used when the\
    \ path round-trip time is greater than\n   the desired Detection Time, or the\
    \ protocol will fail to work\n   properly.  See section 6.6 for more details.\n"
- title: 4.  BFD Control Packet Format
  contents:
  - '4.  BFD Control Packet Format

    '
- title: 4.1.  Generic BFD Control Packet Format
  contents:
  - "4.1.  Generic BFD Control Packet Format\n   BFD Control packets are sent in an\
    \ encapsulation appropriate to the\n   environment.  The specific encapsulation\
    \ is outside of the scope of\n   this specification.  See the appropriate application\
    \ document for\n   encapsulation details.\n   The BFD Control packet has a Mandatory\
    \ Section and an optional\n   Authentication Section.  The format of the Authentication\
    \ Section, if\n   present, is dependent on the type of authentication in use.\n\
    \   The Mandatory Section of a BFD Control packet has the following\n   format:\n\
    \    0                   1                   2                   3\n    0 1 2\
    \ 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |Vers |  Diag   |Sta|P|F|C|A|D|M|  Detect Mult  |    Length     |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                       My Discriminator                        |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                      Your Discriminator                       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                    Desired Min TX Interval                    |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                   Required Min RX Interval                    |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                 Required Min Echo RX Interval                 |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   An optional Authentication Section MAY be present:\n    0                \
    \   1                   2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3\
    \ 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |   Auth Type   |   Auth Len    |    Authentication Data...     |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   Version (Vers)\n      The version number of the protocol.  This document defines\n\
    \      protocol version 1.\n   Diagnostic (Diag)\n      A diagnostic code specifying\
    \ the local system's reason for the\n      last change in session state.  Values\
    \ are:\n         0 -- No Diagnostic\n         1 -- Control Detection Time Expired\n\
    \         2 -- Echo Function Failed\n         3 -- Neighbor Signaled Session Down\n\
    \         4 -- Forwarding Plane Reset\n         5 -- Path Down\n         6 --\
    \ Concatenated Path Down\n         7 -- Administratively Down\n         8 -- Reverse\
    \ Concatenated Path Down\n      9-31 -- Reserved for future use\n      This field\
    \ allows remote systems to determine the reason that the\n      previous session\
    \ failed, for example.\n   State (Sta)\n      The current BFD session state as\
    \ seen by the transmitting system.\n      Values are:\n         0 -- AdminDown\n\
    \         1 -- Down\n         2 -- Init\n         3 -- Up\n   Poll (P)\n     \
    \ If set, the transmitting system is requesting verification of\n      connectivity,\
    \ or of a parameter change, and is expecting a packet\n      with the Final (F)\
    \ bit in reply.  If clear, the transmitting\n      system is not requesting verification.\n\
    \   Final (F)\n      If set, the transmitting system is responding to a received\
    \ BFD\n      Control packet that had the Poll (P) bit set.  If clear, the\n  \
    \    transmitting system is not responding to a Poll.\n   Control Plane Independent\
    \ (C)\n      If set, the transmitting system's BFD implementation does not\n \
    \     share fate with its control plane (in other words, BFD is\n      implemented\
    \ in the forwarding plane and can continue to function\n      through disruptions\
    \ in the control plane).  If clear, the\n      transmitting system's BFD implementation\
    \ shares fate with its\n      control plane.\n      The use of this bit is application\
    \ dependent and is outside the\n      scope of this specification.  See specific\
    \ application\n      specifications for details.\n   Authentication Present (A)\n\
    \      If set, the Authentication Section is present and the session is\n    \
    \  to be authenticated (see section 6.7 for details).\n   Demand (D)\n      If\
    \ set, Demand mode is active in the transmitting system (the\n      system wishes\
    \ to operate in Demand mode, knows that the session is\n      Up in both directions,\
    \ and is directing the remote system to cease\n      the periodic transmission\
    \ of BFD Control packets).  If clear,\n      Demand mode is not active in the\
    \ transmitting system.\n   Multipoint (M)\n      This bit is reserved for future\
    \ point-to-multipoint extensions to\n      BFD.  It MUST be zero on both transmit\
    \ and receipt.\n   Detect Mult\n      Detection time multiplier.  The negotiated\
    \ transmit interval,\n      multiplied by this value, provides the Detection Time\
    \ for the\n      receiving system in Asynchronous mode.\n   Length\n      Length\
    \ of the BFD Control packet, in bytes.\n   My Discriminator\n      A unique, nonzero\
    \ discriminator value generated by the\n      transmitting system, used to demultiplex\
    \ multiple BFD sessions\n      between the same pair of systems.\n   Your Discriminator\n\
    \      The discriminator received from the corresponding remote system.\n    \
    \  This field reflects back the received value of My Discriminator,\n      or\
    \ is zero if that value is unknown.\n   Desired Min TX Interval\n      This is\
    \ the minimum interval, in microseconds, that the local\n      system would like\
    \ to use when transmitting BFD Control packets,\n      less any jitter applied\
    \ (see section 6.8.2).  The value zero is\n      reserved.\n   Required Min RX\
    \ Interval\n      This is the minimum interval, in microseconds, between received\n\
    \      BFD Control packets that this system is capable of supporting,\n      less\
    \ any jitter applied by the sender (see section 6.8.2).  If\n      this value\
    \ is zero, the transmitting system does not want the\n      remote system to send\
    \ any periodic BFD Control packets.\n   Required Min Echo RX Interval\n      This\
    \ is the minimum interval, in microseconds, between received\n      BFD Echo packets\
    \ that this system is capable of supporting, less\n      any jitter applied by\
    \ the sender (see section 6.8.9).  If this\n      value is zero, the transmitting\
    \ system does not support the\n      receipt of BFD Echo packets.\n   Auth Type\n\
    \      The authentication type in use, if the Authentication Present (A)\n   \
    \   bit is set.\n         0 - Reserved\n         1 - Simple Password\n       \
    \  2 - Keyed MD5\n         3 - Meticulous Keyed MD5\n         4 - Keyed SHA1\n\
    \         5 - Meticulous Keyed SHA1\n     6-255 - Reserved for future use\n  \
    \ Auth Len\n      The length, in bytes, of the authentication section, including\
    \ the\n      Auth Type and Auth Len fields.\n"
- title: 4.2.  Simple Password Authentication Section Format
  contents:
  - "4.2.  Simple Password Authentication Section Format\n   If the Authentication\
    \ Present (A) bit is set in the header, and the\n   Authentication Type field\
    \ contains 1 (Simple Password), the\n   Authentication Section has the following\
    \ format:\n    0                   1                   2                   3\n\
    \    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |   Auth Type   |   Auth Len    |  Auth Key ID  |  Password...  |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                              ...                              |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   Auth Type\n      The Authentication Type, which in this case is 1 (Simple\n\
    \      Password).\n   Auth Len\n      The length of the Authentication Section,\
    \ in bytes.  For Simple\n      Password authentication, the length is equal to\
    \ the password\n      length plus three.\n   Auth Key ID\n      The authentication\
    \ key ID in use for this packet.  This allows\n      multiple keys to be active\
    \ simultaneously.\n   Password\n      The simple password in use on this session.\
    \  The password is a\n      binary string, and MUST be from 1 to 16 bytes in length.\
    \  The\n      password MUST be encoded and configured according to section\n \
    \     6.7.2.\n"
- title: 4.3.  Keyed MD5 and Meticulous Keyed MD5 Authentication Section Format
  contents:
  - "4.3.  Keyed MD5 and Meticulous Keyed MD5 Authentication Section Format\n   The\
    \ use of MD5-based authentication is strongly discouraged.\n   However, it is\
    \ documented here for compatibility with existing\n   implementations.\n   If\
    \ the Authentication Present (A) bit is set in the header, and the\n   Authentication\
    \ Type field contains 2 (Keyed MD5) or 3 (Meticulous\n   Keyed MD5), the Authentication\
    \ Section has the following format:\n    0                   1               \
    \    2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2\
    \ 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |   Auth Type   |   Auth Len    |  Auth Key ID  |   Reserved    |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                        Sequence Number                        |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                      Auth Key/Digest...                       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                              ...                              |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   Auth Type\n      The Authentication Type, which in this case is 2 (Keyed MD5)\
    \ or 3\n      (Meticulous Keyed MD5).\n   Auth Len\n      The length of the Authentication\
    \ Section, in bytes.  For Keyed MD5\n      and Meticulous Keyed MD5 authentication,\
    \ the length is 24.\n   Auth Key ID\n      The authentication key ID in use for\
    \ this packet.  This allows\n      multiple keys to be active simultaneously.\n\
    \   Reserved\n      This byte MUST be set to zero on transmit, and ignored on\
    \ receipt.\n   Sequence Number\n      The sequence number for this packet.  For\
    \ Keyed MD5\n      Authentication, this value is incremented occasionally.  For\n\
    \      Meticulous Keyed MD5 Authentication, this value is incremented for\n  \
    \    each successive packet transmitted for a session.  This provides\n      protection\
    \ against replay attacks.\n   Auth Key/Digest\n      This field carries the 16-byte\
    \ MD5 digest for the packet.  When\n      the digest is calculated, the shared\
    \ MD5 key is stored in this\n      field, padded to 16 bytes with trailing zero\
    \ bytes if needed.  The\n      shared key MUST be encoded and configured to section\
    \ 6.7.3.\n"
- title: 4.4.  Keyed SHA1 and Meticulous Keyed SHA1 Authentication Section Format
  contents:
  - "4.4.  Keyed SHA1 and Meticulous Keyed SHA1 Authentication Section Format\n  \
    \ If the Authentication Present (A) bit is set in the header, and the\n   Authentication\
    \ Type field contains 4 (Keyed SHA1) or 5 (Meticulous\n   Keyed SHA1), the Authentication\
    \ Section has the following format:\n    0                   1               \
    \    2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2\
    \ 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |   Auth Type   |   Auth Len    |  Auth Key ID  |   Reserved    |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                        Sequence Number                        |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                       Auth Key/Hash...                        |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                              ...                              |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   Auth Type\n      The Authentication Type, which in this case is 4 (Keyed SHA1)\
    \ or 5\n      (Meticulous Keyed SHA1).\n   Auth Len\n      The length of the Authentication\
    \ Section, in bytes.  For Keyed\n      SHA1 and Meticulous Keyed SHA1 authentication,\
    \ the length is 28.\n   Auth Key ID\n      The authentication key ID in use for\
    \ this packet.  This allows\n      multiple keys to be active simultaneously.\n\
    \   Reserved\n      This byte MUST be set to zero on transmit and ignored on receipt.\n\
    \   Sequence Number\n      The sequence number for this packet.  For Keyed SHA1\n\
    \      Authentication, this value is incremented occasionally.  For\n      Meticulous\
    \ Keyed SHA1 Authentication, this value is incremented\n      for each successive\
    \ packet transmitted for a session.  This\n      provides protection against replay\
    \ attacks.\n   Auth Key/Hash\n      This field carries the 20-byte SHA1 hash for\
    \ the packet.  When the\n      hash is calculated, the shared SHA1 key is stored\
    \ in this field,\n      padded to a length of 20 bytes with trailing zero bytes\
    \ if needed.\n      The shared key MUST be encoded and configured to section 6.7.4.\n"
- title: 5.  BFD Echo Packet Format
  contents:
  - "5.  BFD Echo Packet Format\n   BFD Echo packets are sent in an encapsulation\
    \ appropriate to the\n   environment.  See the appropriate application documents\
    \ for the\n   specifics of particular environments.\n   The payload of a BFD Echo\
    \ packet is a local matter, since only the\n   sending system ever processes the\
    \ content.  The only requirement is\n   that sufficient information is included\
    \ to demultiplex the received\n   packet to the correct BFD session after it is\
    \ looped back to the\n   sender.  The contents are otherwise outside the scope\
    \ of this\n   specification.\n   Some form of authentication SHOULD be included,\
    \ since Echo packets\n   may be spoofed.\n"
- title: 6.  Elements of Procedure
  contents:
  - "6.  Elements of Procedure\n   This section discusses the normative requirements\
    \ of the protocol in\n   order to achieve interoperability.  It is important for\
    \ implementors\n   to enforce only the requirements specified in this section,\
    \ as\n   misguided pedantry has been proven by experience to affect\n   interoperability\
    \ adversely.\n   Remember that all references of the form \"bfd.Xx\" refer to\
    \ internal\n   state variables (defined in section 6.8.1), whereas all references\
    \ to\n   \"the Xxx field\" refer to fields in the protocol packets themselves\n\
    \   (defined in section 4).\n"
- title: 6.1.  Overview
  contents:
  - "6.1.  Overview\n   A system may take either an Active role or a Passive role\
    \ in session\n   initialization.  A system taking the Active role MUST send BFD\n\
    \   Control packets for a particular session, regardless of whether it\n   has\
    \ received any BFD packets for that session.  A system taking the\n   Passive\
    \ role MUST NOT begin sending BFD packets for a particular\n   session until it\
    \ has received a BFD packet for that session, and thus\n   has learned the remote\
    \ system's discriminator value.  At least one\n   system MUST take the Active\
    \ role (possibly both).  The role that a\n   system takes is specific to the application\
    \ of BFD, and is outside\n   the scope of this specification.\n   A session begins\
    \ with the periodic, slow transmission of BFD Control\n   packets.  When bidirectional\
    \ communication is achieved, the BFD\n   session becomes Up.\n   Once the BFD\
    \ session is Up, a system can choose to start the Echo\n   function if it desires\
    \ and the other system signals that it will\n   allow it.  The rate of transmission\
    \ of Control packets is typically\n   kept low when the Echo function is active.\n\
    \   If the Echo function is not active, the transmission rate of Control\n   packets\
    \ may be increased to a level necessary to achieve the\n   Detection Time requirements\
    \ for the session.\n   Once the session is Up, a system may signal that it has\
    \ entered\n   Demand mode, and the transmission of BFD Control packets by the\n\
    \   remote system ceases.  Other means of implying connectivity are used\n   to\
    \ keep the session alive.  If either system wishes to verify\n   bidirectional\
    \ connectivity, it can initiate a short exchange of BFD\n   Control packets (a\
    \ \"Poll Sequence\"; see section 6.5) to do so.\n   If Demand mode is not active,\
    \ and no Control packets are received in\n   the calculated Detection Time (see\
    \ section 6.8.4), the session is\n   declared Down.  This is signaled to the remote\
    \ end via the State\n   (Sta) field in outgoing packets.\n   If sufficient Echo\
    \ packets are lost, the session is declared Down in\n   the same manner.  See\
    \ section 6.8.5.\n   If Demand mode is active and no appropriate Control packets\
    \ are\n   received in response to a Poll Sequence, the session is declared Down\n\
    \   in the same manner.  See section 6.6.\n   If the session goes Down, the transmission\
    \ of Echo packets (if any)\n   ceases, and the transmission of Control packets\
    \ goes back to the slow\n   rate.\n   Once a session has been declared Down, it\
    \ cannot come back up until\n   the remote end first signals that it is down (by\
    \ leaving the Up\n   state), thus implementing a three-way handshake.\n   A session\
    \ MAY be kept administratively down by entering the AdminDown\n   state and sending\
    \ an explanatory diagnostic code in the Diagnostic\n   field.\n"
- title: 6.2.  BFD State Machine
  contents:
  - "6.2.  BFD State Machine\n   The BFD state machine is quite straightforward. \
    \ There are three\n   states through which a session normally proceeds: two for\n\
    \   establishing a session (Init and Up) and one for tearing down a\n   session\
    \ (Down).  This allows a three-way handshake for both session\n   establishment\
    \ and session teardown (assuring that both systems are\n   aware of all session\
    \ state changes).  A fourth state (AdminDown)\n   exists so that a session can\
    \ be administratively put down\n   indefinitely.\n   Each system communicates\
    \ its session state in the State (Sta) field\n   in the BFD Control packet, and\
    \ that received state, in combination\n   with the local session state, drives\
    \ the state machine.\n   Down state means that the session is down (or has just\
    \ been created).\n   A session remains in Down state until the remote system indicates\n\
    \   that it agrees that the session is down by sending a BFD Control\n   packet\
    \ with the State field set to anything other than Up.  If that\n   packet signals\
    \ Down state, the session advances to Init state; if\n   that packet signals Init\
    \ state, the session advances to Up state.\n   Semantically, Down state indicates\
    \ that the forwarding path is\n   unavailable, and that appropriate actions should\
    \ be taken by the\n   applications monitoring the state of the BFD session.  A\
    \ system MAY\n   hold a session in Down state indefinitely (by simply refusing\
    \ to\n   advance the session state).  This may be done for operational or\n  \
    \ administrative reasons, among others.\n   Init state means that the remote system\
    \ is communicating, and the\n   local system desires to bring the session up,\
    \ but the remote system\n   does not yet realize it.  A session will remain in\
    \ Init state until\n   either a BFD Control Packet is received that is signaling\
    \ Init or Up\n   state (in which case the session advances to Up state) or the\n\
    \   Detection Time expires, meaning that communication with the remote\n   system\
    \ has been lost (in which case the session advances to Down\n   state).\n   Up\
    \ state means that the BFD session has successfully been\n   established, and\
    \ implies that connectivity between the systems is\n   working.  The session will\
    \ remain in the Up state until either\n   connectivity fails or the session is\
    \ taken down administratively.  If\n   either the remote system signals Down state\
    \ or the Detection Time\n   expires, the session advances to Down state.\n   AdminDown\
    \ state means that the session is being held administratively\n   down.  This\
    \ causes the remote system to enter Down state, and remain\n   there until the\
    \ local system exits AdminDown state.  AdminDown state\n   has no semantic implications\
    \ for the availability of the forwarding\n   path.\n   The following diagram provides\
    \ an overview of the state machine.\n   Transitions involving AdminDown state\
    \ are deleted for clarity (but\n   are fully specified in sections 6.8.6 and 6.8.16).\
    \  The notation on\n   each arc represents the state of the remote system (as\
    \ received in\n   the State field in the BFD Control packet) or indicates the\n\
    \   expiration of the Detection Timer.\n                             +--+\n  \
    \                           |  | UP, ADMIN DOWN, TIMER\n                     \
    \        |  V\n                     DOWN  +------+  INIT\n              +------------|\
    \      |------------+\n              |            | DOWN |            |\n    \
    \          |  +-------->|      |<--------+  |\n              |  |         +------+\
    \         |  |\n              |  |                          |  |\n           \
    \   |  |               ADMIN DOWN,|  |\n              |  |ADMIN DOWN,        \
    \  DOWN,|  |\n              |  |TIMER                TIMER|  |\n             \
    \ V  |                          |  V\n            +------+                   \
    \   +------+\n       +----|      |                      |      |----+\n   DOWN|\
    \    | INIT |--------------------->|  UP  |    |INIT, UP\n       +--->|      |\
    \ INIT, UP             |      |<---+\n            +------+                   \
    \   +------+\n"
- title: 6.3.  Demultiplexing and the Discriminator Fields
  contents:
  - "6.3.  Demultiplexing and the Discriminator Fields\n   Since multiple BFD sessions\
    \ may be running between two systems, there\n   needs to be a mechanism for demultiplexing\
    \ received BFD packets to\n   the proper session.\n   Each system MUST choose\
    \ an opaque discriminator value that identifies\n   each session, and which MUST\
    \ be unique among all BFD sessions on the\n   system.  The local discriminator\
    \ is sent in the My Discriminator\n   field in the BFD Control packet, and is\
    \ echoed back in the Your\n   Discriminator field of packets sent from the remote\
    \ end.\n   Once the remote end echoes back the local discriminator, all further\n\
    \   received packets are demultiplexed based on the Your Discriminator\n   field\
    \ only (which means that, among other things, the source address\n   field can\
    \ change or the interface over which the packets are received\n   can change,\
    \ but the packets will still be associated with the proper\n   session).\n   The\
    \ method of demultiplexing the initial packets (in which Your\n   Discriminator\
    \ is zero) is application dependent, and is thus outside\n   the scope of this\
    \ specification.\n   Note that it is permissible for a system to change its discriminator\n\
    \   during a session without affecting the session state, since only that\n  \
    \ system uses its discriminator for demultiplexing purposes (by having\n   the\
    \ other system reflect it back).  The implications on an\n   implementation for\
    \ changing the discriminator value is outside the\n   scope of this specification.\n"
- title: 6.4.  The Echo Function and Asymmetry
  contents:
  - "6.4.  The Echo Function and Asymmetry\n   The Echo function can be run independently\
    \ in each direction between\n   a pair of systems.  For whatever reason, a system\
    \ may advertise that\n   it is willing to receive (and loop back) Echo packets,\
    \ but may not\n   wish to ever send any.  The fact that a system is sending Echo\n\
    \   packets is not directly signaled to the system looping them back.\n   When\
    \ a system is using the Echo function, it is advantageous to\n   choose a sedate\
    \ reception rate for Control packets, since liveness\n   detection is being handled\
    \ by the Echo packets.  This can be\n   controlled by manipulating the Required\
    \ Min RX Interval field (see\n   section 6.8.3).\n   If the Echo function is only\
    \ being run in one direction, the system\n   not running the Echo function will\
    \ more likely wish to receive fairly\n   rapid Control packets in order to achieve\
    \ its desired Detection Time.\n   Since BFD allows independent transmission rates\
    \ in each direction,\n   this is easily accomplished.\n   A system SHOULD otherwise\
    \ advertise the lowest value of Required Min\n   RX Interval and Required Min\
    \ Echo RX Interval that it can under the\n   circumstances, to give the other\
    \ system more freedom in choosing its\n   transmission rate.  Note that a system\
    \ is committing to be able to\n   receive both streams of packets at the rate\
    \ it advertises, so this\n   should be taken into account when choosing the values\
    \ to advertise.\n"
- title: 6.5.  The Poll Sequence
  contents:
  - "6.5.  The Poll Sequence\n   A Poll Sequence is an exchange of BFD Control packets\
    \ that is used in\n   some circumstances to ensure that the remote system is aware\
    \ of\n   parameter changes.  It is also used in Demand mode (see section 6.6)\n\
    \   to validate bidirectional connectivity.\n   A Poll Sequence consists of a\
    \ system sending periodic BFD Control\n   packets with the Poll (P) bit set. \
    \ When the other system receives a\n   Poll, it immediately transmits a BFD Control\
    \ packet with the Final\n   (F) bit set, independent of any periodic BFD Control\
    \ packets it may\n   be sending (see section 6.8.7).  When the system sending\
    \ the Poll\n   sequence receives a packet with Final, the Poll Sequence is\n \
    \  terminated, and any subsequent BFD Control packets are sent with the\n   Poll\
    \ bit cleared.  A BFD Control packet MUST NOT have both the Poll\n   (P) and Final\
    \ (F) bits set.\n   If periodic BFD Control packets are already being sent (the\
    \ remote\n   system is not in Demand mode), the Poll Sequence MUST be performed\
    \ by\n   setting the Poll (P) bit on those scheduled periodic transmissions;\n\
    \   additional packets MUST NOT be sent.\n   After a Poll Sequence is terminated,\
    \ the system requesting the Poll\n   Sequence will cease the periodic transmission\
    \ of BFD Control packets\n   if the remote end is in Demand mode; otherwise, it\
    \ will return to the\n   periodic transmission of BFD Control packets with the\
    \ Poll (P) bit\n   clear.\n   Typically, the entire sequence consists of a single\
    \ packet in each\n   direction, though packet losses or relatively long packet\
    \ latencies\n   may result in multiple Poll packets to be sent before the sequence\n\
    \   terminates.\n"
- title: 6.6.  Demand Mode
  contents:
  - "6.6.  Demand Mode\n   Demand mode is requested independently in each direction\
    \ by virtue of\n   a system setting the Demand (D) bit in its BFD Control packets.\
    \  The\n   system receiving the Demand bit ceases the periodic transmission of\n\
    \   BFD Control packets.  If both systems are operating in Demand mode,\n   no\
    \ periodic BFD Control packets will flow in either direction.\n   Demand mode\
    \ requires that some other mechanism is used to imply\n   continuing connectivity\
    \ between the two systems.  The mechanism used\n   does not have to be the same\
    \ in both directions, and is outside of\n   the scope of this specification. \
    \ One possible mechanism is the\n   receipt of traffic from the remote system;\
    \ another is the use of the\n   Echo function.\n   When a system in Demand mode\
    \ wishes to verify bidirectional\n   connectivity, it initiates a Poll Sequence\
    \ (see section 6.5).  If no\n   response is received to a Poll, the Poll is repeated\
    \ until the\n   Detection Time expires, at which point the session is declared\
    \ to be\n   Down.  Note that if Demand mode is operating only on the local\n \
    \  system, the Poll Sequence is performed by simply setting the Poll (P)\n   bit\
    \ in regular periodic BFD Control packets, as required by section\n   6.5.\n \
    \  The Detection Time in Demand mode is calculated differently than in\n   Asynchronous\
    \ mode; it is based on the transmit rate of the local\n   system, rather than\
    \ the transmit rate of the remote system.  This\n   ensures that the Poll Sequence\
    \ mechanism works properly.  See section\n   6.8.4 for more details.\n   Note\
    \ that the Poll mechanism will always fail unless the negotiated\n   Detection\
    \ Time is greater than the round-trip time between the two\n   systems.  Enforcement\
    \ of this constraint is outside the scope of this\n   specification.\n   Demand\
    \ mode MAY be enabled or disabled at any time, independently in\n   each direction,\
    \ by setting or clearing the Demand (D) bit in the BFD\n   Control packet, without\
    \ affecting the BFD session state.  Note that\n   the Demand bit MUST NOT be set\
    \ unless both systems perceive the\n   session to be Up (the local system thinks\
    \ the session is Up, and the\n   remote system last reported Up state in the State\
    \ (Sta) field of the\n   BFD Control packet).\n   When the transmitted value of\
    \ the Demand (D) bit is to be changed,\n   the transmitting system MUST initiate\
    \ a Poll Sequence in conjunction\n   with changing the bit in order to ensure\
    \ that both systems are aware\n   of the change.\n   If Demand mode is active\
    \ on either or both systems, a Poll Sequence\n   MUST be initiated whenever the\
    \ contents of the next BFD Control\n   packet to be sent would be different than\
    \ the contents of the\n   previous packet, with the exception of the Poll (P)\
    \ and Final (F)\n   bits.  This ensures that parameter changes are transmitted\
    \ to the\n   remote system and that the remote system acknowledges these changes.\n\
    \   Because the underlying detection mechanism is unspecified, and may\n   differ\
    \ between the two systems, the overall Detection Time\n   characteristics of the\
    \ path will not be fully known to either system.\n   The total Detection Time\
    \ for a particular system is the sum of the\n   time prior to the initiation of\
    \ the Poll Sequence, plus the\n   calculated Detection Time.\n   Note that if\
    \ Demand mode is enabled in only one direction, continuous\n   bidirectional connectivity\
    \ verification is lost (only connectivity in\n   the direction from the system\
    \ in Demand mode to the other system will\n   be verified).  Resolving the issue\
    \ of one system requesting Demand\n   mode while the other requires continuous\
    \ bidirectional connectivity\n   verification is outside the scope of this specification.\n"
- title: 6.7.  Authentication
  contents:
  - "6.7.  Authentication\n   An optional Authentication Section MAY be present in\
    \ the BFD Control\n   packet.  In its generic form, the purpose of the Authentication\n\
    \   Section is to carry all necessary information, based on the\n   authentication\
    \ type in use, to allow the receiving system to\n   determine the validity of\
    \ the received packet.  The exact mechanism\n   depends on the authentication\
    \ type in use, but in general the\n   transmitting system will put information\
    \ in the Authentication\n   Section that vouches for the packet's validity, and\
    \ the receiving\n   system will examine the Authentication Section and either\
    \ accept the\n   packet for further processing or discard it.\n   The same authentication\
    \ type, and any keys or other necessary\n   information, obviously must be in\
    \ use by the two systems.  The\n   negotiation of authentication type, key exchange,\
    \ etc., are all\n   outside the scope of this specification and are expected to\
    \ be\n   performed by means outside of the protocol.\n   Note that in the subsections\
    \ below, to \"accept\" a packet means only\n   that the packet has passed authentication;\
    \ it may in fact be\n   discarded for other reasons as described in the general\
    \ packet\n   reception rules described in section 6.8.6.\n   Implementations supporting\
    \ authentication MUST support both types of\n   SHA1 authentication.  Other forms\
    \ of authentication are optional.\n"
- title: 6.7.1.  Enabling and Disabling Authentication
  contents:
  - "6.7.1.  Enabling and Disabling Authentication\n   It may be desirable to enable\
    \ or disable authentication on a session\n   without disturbing the session state.\
    \  The exact mechanism for doing\n   so is outside the scope of this specification.\
    \  However, it is useful\n   to point out some issues in supporting this mechanism.\n\
    \   In a simple implementation, a BFD session will fail when\n   authentication\
    \ is either turned on or turned off, because the packet\n   acceptance rules essentially\
    \ require the local and remote machines to\n   do so in a more or less synchronized\
    \ fashion (within the Detection\n   Time) -- a packet with authentication will\
    \ only be accepted if\n   authentication is \"in use\" (and likewise packets without\n\
    \   authentication).\n   One possible approach is to build an implementation such\
    \ that\n   authentication is configured, but not considered \"in use\" until the\n\
    \   first packet containing a matching authentication section is received\n  \
    \ (providing the necessary synchronization).  Likewise, authentication\n   could\
    \ be configured off, but still considered \"in use\" until the\n   receipt of\
    \ the first packet without the authentication section.\n   In order to avoid security\
    \ risks, implementations using this method\n   SHOULD only allow the authentication\
    \ state to be changed at most once\n   without some form of intervention (so that\
    \ authentication cannot be\n   turned on and off repeatedly simply based on the\
    \ receipt of BFD\n   Control packets from remote systems).  Unless it is desired\
    \ to enable\n   or disable authentication, an implementation SHOULD NOT allow\
    \ the\n   authentication state to change based on the receipt of BFD Control\n\
    \   packets.\n"
- title: 6.7.2.  Simple Password Authentication
  contents:
  - "6.7.2.  Simple Password Authentication\n   The most straightforward (and weakest)\
    \ form of authentication is\n   Simple Password Authentication.  In this method\
    \ of authentication,\n   one or more Passwords (with corresponding Key IDs) are\
    \ configured in\n   each system and one of these Password/ID pairs is carried\
    \ in each BFD\n   Control packet.  The receiving system accepts the packet if\
    \ the\n   Password and Key ID matches one of the Password/ID pairs configured\n\
    \   in that system.\n   Transmission Using Simple Password Authentication\n  \
    \    The currently selected password and Key ID for the session MUST be\n    \
    \  stored in the Authentication Section of each outgoing BFD Control\n      packet.\
    \  The Auth Type field MUST be set to 1 (Simple Password).\n      The Auth Len\
    \ field MUST be set to the proper length (4 to 19\n      bytes).\n      The password\
    \ is a binary string, and MUST be 1 to 16 bytes in\n      length.  For interoperability,\
    \ the management interface by which\n      the password is configured MUST accept\
    \ ASCII strings, and SHOULD\n      also allow for the configuration of any arbitrary\
    \ binary string in\n      hexadecimal form.  Other configuration methods MAY be\
    \ supported.\n   Reception Using Simple Password Authentication\n      If the\
    \ received BFD Control packet does not contain an\n      Authentication Section,\
    \ or the Auth Type is not 1 (Simple\n      Password), then the received packet\
    \ MUST be discarded.\n      If the Auth Key ID field does not match the ID of\
    \ a configured\n      password, the received packet MUST be discarded.\n     \
    \ If the Auth Len field is not equal to the length of the password\n      selected\
    \ by the key ID, plus three, the packet MUST be discarded.\n      If the Password\
    \ field does not match the password selected by the\n      key ID, the packet\
    \ MUST be discarded.\n      Otherwise, the packet MUST be accepted.\n"
- title: 6.7.3.  Keyed MD5 and Meticulous Keyed MD5 Authentication
  contents:
  - "6.7.3.  Keyed MD5 and Meticulous Keyed MD5 Authentication\n   The Keyed MD5 and\
    \ Meticulous Keyed MD5 Authentication mechanisms are\n   very similar to those\
    \ used in other protocols.  In these methods of\n   authentication, one or more\
    \ secret keys (with corresponding key IDs)\n   are configured in each system.\
    \  One of the keys is included in an MD5\n   [MD5] digest calculated over the\
    \ outgoing BFD Control packet, but the\n   Key itself is not carried in the packet.\
    \  To help avoid replay\n   attacks, a sequence number is also carried in each\
    \ packet.  For Keyed\n   MD5, the sequence number is occasionally incremented.\
    \  For Meticulous\n   Keyed MD5, the sequence number is incremented on every packet.\n\
    \   The receiving system accepts the packet if the key ID matches one of\n   the\
    \ configured Keys, an MD5 digest including the selected key matches\n   that carried\
    \ in the packet, and the sequence number is greater than\n   or equal to the last\
    \ sequence number received (for Keyed MD5), or\n   strictly greater than the last\
    \ sequence number received (for\n   Meticulous Keyed MD5).\n   Transmission Using\
    \ Keyed MD5 and Meticulous Keyed MD5 Authentication\n      The Auth Type field\
    \ MUST be set to 2 (Keyed MD5) or 3 (Meticulous\n      Keyed MD5).  The Auth Len\
    \ field MUST be set to 24.  The Auth Key\n      ID field MUST be set to the ID\
    \ of the current authentication key.\n      The Sequence Number field MUST be\
    \ set to bfd.XmitAuthSeq.\n      The authentication key value is a binary string\
    \ of up to 16 bytes,\n      and MUST be placed into the Auth Key/Digest field,\
    \ padded with\n      trailing zero bytes as necessary.  For interoperability,\
    \ the\n      management interface by which the key is configured MUST accept\n\
    \      ASCII strings, and SHOULD also allow for the configuration of any\n   \
    \   arbitrary binary string in hexadecimal form.  Other configuration\n      methods\
    \ MAY be supported.\n      An MD5 digest MUST be calculated over the entire BFD\
    \ Control\n      packet.  The resulting digest MUST be stored in the Auth\n  \
    \    Key/Digest field prior to transmission (replacing the secret key,\n     \
    \ which MUST NOT be carried in the packet).\n      For Keyed MD5, bfd.XmitAuthSeq\
    \ MAY be incremented in a circular\n      fashion (when treated as an unsigned\
    \ 32-bit value).\n      bfd.XmitAuthSeq SHOULD be incremented when the session\
    \ state\n      changes, or when the transmitted BFD Control packet carries\n \
    \     different contents than the previously transmitted packet.  The\n      decision\
    \ as to when to increment bfd.XmitAuthSeq is outside the\n      scope of this\
    \ specification.  See the section titled \"Security\n      Considerations\" below\
    \ for a discussion.\n      For Meticulous Keyed MD5, bfd.XmitAuthSeq MUST be incremented\
    \ in a\n      circular fashion (when treated as an unsigned 32-bit value).\n \
    \  Receipt Using Keyed MD5 and Meticulous Keyed MD5 Authentication\n      If the\
    \ received BFD Control packet does not contain an\n      Authentication Section,\
    \ or the Auth Type is not correct (2 for\n      Keyed MD5 or 3 for Meticulous\
    \ Keyed MD5), then the received packet\n      MUST be discarded.\n      If the\
    \ Auth Key ID field does not match the ID of a configured\n      authentication\
    \ key, the received packet MUST be discarded.\n      If the Auth Len field is\
    \ not equal to 24, the packet MUST be\n      discarded.\n      If bfd.AuthSeqKnown\
    \ is 1, examine the Sequence Number field.  For\n      Keyed MD5, if the sequence\
    \ number lies outside of the range of\n      bfd.RcvAuthSeq to bfd.RcvAuthSeq+(3*Detect\
    \ Mult) inclusive (when\n      treated as an unsigned 32-bit circular number space),\
    \ the received\n      packet MUST be discarded.  For Meticulous Keyed MD5, if\
    \ the\n      sequence number lies outside of the range of bfd.RcvAuthSeq+1 to\n\
    \      bfd.RcvAuthSeq+(3*Detect Mult) inclusive (when treated as an\n      unsigned\
    \ 32-bit circular number space) the received packet MUST be\n      discarded.\n\
    \      Otherwise (bfd.AuthSeqKnown is 0), bfd.AuthSeqKnown MUST be set to\n  \
    \    1, and bfd.RcvAuthSeq MUST be set to the value of the received\n      Sequence\
    \ Number field.\n      Replace the contents of the Auth Key/Digest field with\
    \ the\n      authentication key selected by the received Auth Key ID field.  If\n\
    \      the MD5 digest of the entire BFD Control packet is equal to the\n     \
    \ received value of the Auth Key/Digest field, the received packet\n      MUST\
    \ be accepted.  Otherwise (the digest does not match the Auth\n      Key/Digest\
    \ field), the received packet MUST be discarded.\n"
- title: 6.7.4.  Keyed SHA1 and Meticulous Keyed SHA1 Authentication
  contents:
  - "6.7.4.  Keyed SHA1 and Meticulous Keyed SHA1 Authentication\n   The Keyed SHA1\
    \ and Meticulous Keyed SHA1 Authentication mechanisms\n   are very similar to\
    \ those used in other protocols.  In these methods\n   of authentication, one\
    \ or more secret keys (with corresponding key\n   IDs) are configured in each\
    \ system.  One of the keys is included in a\n   SHA1 [SHA1] hash calculated over\
    \ the outgoing BFD Control packet, but\n   the key itself is not carried in the\
    \ packet.  To help avoid replay\n   attacks, a sequence number is also carried\
    \ in each packet.  For Keyed\n   SHA1, the sequence number is occasionally incremented.\
    \  For\n   Meticulous Keyed SHA1, the sequence number is incremented on every\n\
    \   packet.\n   The receiving system accepts the packet if the key ID matches\
    \ one of\n   the configured keys, a SHA1 hash including the selected key matches\n\
    \   that carried in the packet, and if the sequence number is greater\n   than\
    \ or equal to the last sequence number received (for Keyed SHA1),\n   or strictly\
    \ greater than the last sequence number received (for\n   Meticulous Keyed SHA1).\n\
    \   Transmission Using Keyed SHA1 and Meticulous Keyed SHA1\n      Authentication\n\
    \      The Auth Type field MUST be set to 4 (Keyed SHA1) or 5 (Meticulous\n  \
    \    Keyed SHA1).  The Auth Len field MUST be set to 28.  The Auth Key\n     \
    \ ID field MUST be set to the ID of the current authentication key.\n      The\
    \ Sequence Number field MUST be set to bfd.XmitAuthSeq.\n      The authentication\
    \ key value is a binary string of up to 20 bytes,\n      and MUST be placed into\
    \ the Auth Key/Hash field, padding with\n      trailing zero bytes as necessary.\
    \  For interoperability, the\n      management interface by which the key is configured\
    \ MUST accept\n      ASCII strings, and SHOULD also allow for the configuration\
    \ of any\n      arbitrary binary string in hexadecimal form.  Other configuration\n\
    \      methods MAY be supported.\n      A SHA1 hash MUST be calculated over the\
    \ entire BFD control packet.\n      The resulting hash MUST be stored in the Auth\
    \ Key/Hash field prior\n      to transmission (replacing the secret key, which\
    \ MUST NOT be\n      carried in the packet).\n      For Keyed SHA1, bfd.XmitAuthSeq\
    \ MAY be incremented in a circular\n      fashion (when treated as an unsigned\
    \ 32-bit value).\n      bfd.XmitAuthSeq SHOULD be incremented when the session\
    \ state\n      changes, or when the transmitted BFD Control packet carries\n \
    \     different contents than the previously transmitted packet.  The\n      decision\
    \ as to when to increment bfd.XmitAuthSeq is outside the\n      scope of this\
    \ specification.  See the section titled \"Security\n      Considerations\" below\
    \ for a discussion.\n      For Meticulous Keyed SHA1, bfd.XmitAuthSeq MUST be\
    \ incremented in\n      a circular fashion (when treated as an unsigned 32-bit\
    \ value).\n   Receipt Using Keyed SHA1 and Meticulous Keyed SHA1 Authentication\n\
    \      If the received BFD Control packet does not contain an\n      Authentication\
    \ Section, or the Auth Type is not correct (4 for\n      Keyed SHA1 or 5 for Meticulous\
    \ Keyed SHA1), then the received\n      packet MUST be discarded.\n      If the\
    \ Auth Key ID field does not match the ID of a configured\n      authentication\
    \ key, the received packet MUST be discarded.\n      If the Auth Len field is\
    \ not equal to 28, the packet MUST be\n      discarded.\n      If bfd.AuthSeqKnown\
    \ is 1, examine the Sequence Number field.  For\n      Keyed SHA1, if the sequence\
    \ number lies outside of the range of\n      bfd.RcvAuthSeq to bfd.RcvAuthSeq+(3*Detect\
    \ Mult) inclusive (when\n      treated as an unsigned 32-bit circular number space),\
    \ the received\n      packet MUST be discarded.  For Meticulous Keyed SHA1, if\
    \ the\n      sequence number lies outside of the range of bfd.RcvAuthSeq+1 to\n\
    \      bfd.RcvAuthSeq+(3*Detect Mult) inclusive (when treated as an\n      unsigned\
    \ 32-bit circular number space, the received packet MUST be\n      discarded.\n\
    \      Otherwise (bfd.AuthSeqKnown is 0), bfd.AuthSeqKnown MUST be set to\n  \
    \    1, bfd.RcvAuthSeq MUST be set to the value of the received\n      Sequence\
    \ Number field, and the received packet MUST be accepted.\n      Replace the contents\
    \ of the Auth Key/Hash field with the\n      authentication key selected by the\
    \ received Auth Key ID field.  If\n      the SHA1 hash of the entire BFD Control\
    \ packet is equal to the\n      received value of the Auth Key/Hash field, the\
    \ received packet\n      MUST be accepted.  Otherwise (the hash does not match\
    \ the Auth\n      Key/Hash field), the received packet MUST be discarded.\n"
- title: 6.8.  Functional Specifics
  contents:
  - "6.8.  Functional Specifics\n   The following section of this specification is\
    \ normative.  The means\n   by which this specification is achieved is outside\
    \ the scope of this\n   specification.\n   When a system is said to have \"the\
    \ Echo function active\" it means\n   that the system is sending BFD Echo packets,\
    \ implying that the\n   session is Up and the other system has signaled its willingness\
    \ to\n   loop back Echo packets.\n   When the local system is said to have \"\
    Demand mode active,\" it means\n   that bfd.DemandMode is 1 in the local system\
    \ (see section 6.8.1), the\n   session is Up, and the remote system is signaling\
    \ that the session is\n   in state Up.\n   When the remote system is said to have\
    \ \"Demand mode active,\" it means\n   that bfd.RemoteDemandMode is 1 (the remote\
    \ system set the Demand (D)\n   bit in the last received BFD Control packet),\
    \ the session is Up, and\n   the remote system is signaling that the session is\
    \ in state Up.\n"
- title: 6.8.1.  State Variables
  contents:
  - "6.8.1.  State Variables\n   A minimum amount of information about a session needs\
    \ to be tracked\n   in order to achieve the elements of procedure described here.\
    \  The\n   following is a set of state variables that are helpful in describing\n\
    \   the mechanisms of BFD.  Any means of tracking this state may be used\n   so\
    \ long as the protocol behaves as described.\n   When the text refers to initializing\
    \ a state variable, this takes\n   place only at the time that the session (and\
    \ the corresponding state\n   variables) is created.  The state variables are\
    \ subsequently\n   manipulated by the state machine and are never reinitialized,\
    \ even if\n   the session fails and is reestablished.\n   Once session state is\
    \ created, and at least one BFD Control packet is\n   received from the remote\
    \ end, it MUST be preserved for at least one\n   Detection Time (see section 6.8.4)\
    \ subsequent to the receipt of the\n   last BFD Control packet, regardless of\
    \ the session state.  This\n   preserves timing parameters in case the session\
    \ flaps.  A system MAY\n   preserve session state longer than this.  The preservation\
    \ or\n   destruction of session state when no BFD Control packets for this\n \
    \  session have been received from the remote system is outside the\n   scope\
    \ of this specification.\n   All state variables in this specification are of\
    \ the form \"bfd.Xx\"\n   and should not be confused with fields carried in the\
    \ protocol\n   packets, which are always spelled out to match the names in section\n\
    \   4.\n   bfd.SessionState\n      The perceived state of the session (Init, Up,\
    \ Down, or AdminDown).\n      The exact action taken when the session state changes\
    \ is outside\n      the scope of this specification, though it is expected that\
    \ this\n      state change (particularly, to and from Up state) is reported to\n\
    \      other components of the system.  This variable MUST be initialized\n  \
    \    to Down.\n   bfd.RemoteSessionState\n      The session state last reported\
    \ by the remote system in the State\n      (Sta) field of the BFD Control packet.\
    \  This variable MUST be\n      initialized to Down.\n   bfd.LocalDiscr\n    \
    \  The local discriminator for this BFD session, used to uniquely\n      identify\
    \ it.  It MUST be unique across all BFD sessions on this\n      system, and nonzero.\
    \  It SHOULD be set to a random (but still\n      unique) value to improve security.\
    \  The value is otherwise outside\n      the scope of this specification.\n  \
    \ bfd.RemoteDiscr\n      The remote discriminator for this BFD session.  This\
    \ is the\n      discriminator chosen by the remote system, and is totally opaque\n\
    \      to the local system.  This MUST be initialized to zero.  If a\n      period\
    \ of a Detection Time passes without the receipt of a valid,\n      authenticated\
    \ BFD packet from the remote system, this variable\n      MUST be set to zero.\n\
    \   bfd.LocalDiag\n      The diagnostic code specifying the reason for the most\
    \ recent\n      change in the local session state.  This MUST be initialized to\n\
    \      zero (No Diagnostic).\n   bfd.DesiredMinTxInterval\n      The minimum interval,\
    \ in microseconds, between transmitted BFD\n      Control packets that this system\
    \ would like to use at the current\n      time, less any jitter applied (see section\
    \ 6.8.2).  The actual\n      interval is negotiated between the two systems. \
    \ This MUST be\n      initialized to a value of at least one second (1,000,000\n\
    \      microseconds) according to the rules described in section 6.8.3.\n    \
    \  The setting of this variable is otherwise outside the scope of\n      this\
    \ specification.\n   bfd.RequiredMinRxInterval\n      The minimum interval, in\
    \ microseconds, between received BFD\n      Control packets that this system requires,\
    \ less any jitter applied\n      by the sender (see section 6.8.2).  The setting\
    \ of this variable\n      is outside the scope of this specification.  A value\
    \ of zero means\n      that this system does not want to receive any periodic\
    \ BFD Control\n      packets.  See section 6.8.18 for details.\n   bfd.RemoteMinRxInterval\n\
    \      The last value of Required Min RX Interval received from the\n      remote\
    \ system in a BFD Control packet.  This variable MUST be\n      initialized to\
    \ 1.\n   bfd.DemandMode\n      Set to 1 if the local system wishes to use Demand\
    \ mode, or 0 if\n      not.\n   bfd.RemoteDemandMode\n      Set to 1 if the remote\
    \ system wishes to use Demand mode, or 0 if\n      not.  This is the value of\
    \ the Demand (D) bit in the last received\n      BFD Control packet.  This variable\
    \ MUST be initialized to zero.\n   bfd.DetectMult\n      The desired Detection\
    \ Time multiplier for BFD Control packets on\n      the local system.  The negotiated\
    \ Control packet transmission\n      interval, multiplied by this variable, will\
    \ be the Detection Time\n      for this session (as seen by the remote system).\
    \  This variable\n      MUST be a nonzero integer, and is otherwise outside the\
    \ scope of\n      this specification.  See section 6.8.4 for further information.\n\
    \   bfd.AuthType\n      The authentication type in use for this session, as defined\
    \ in\n      section 4.1, or zero if no authentication is in use.\n   bfd.RcvAuthSeq\n\
    \      A 32-bit unsigned integer containing the last sequence number for\n   \
    \   Keyed MD5 or SHA1 Authentication that was received.  The initial\n      value\
    \ is unimportant.\n   bfd.XmitAuthSeq\n      A 32-bit unsigned integer containing\
    \ the next sequence number for\n      Keyed MD5 or SHA1 Authentication to be transmitted.\
    \  This variable\n      MUST be initialized to a random 32-bit value.\n   bfd.AuthSeqKnown\n\
    \      Set to 1 if the next sequence number for Keyed MD5 or SHA1\n      authentication\
    \ expected to be received is known, or 0 if it is not\n      known.  This variable\
    \ MUST be initialized to zero.\n      This variable MUST be set to zero after\
    \ no packets have been\n      received on this session for at least twice the\
    \ Detection Time.\n      This ensures that the sequence number can be resynchronized\
    \ if the\n      remote system restarts.\n"
- title: 6.8.2.  Timer Negotiation
  contents:
  - "6.8.2.  Timer Negotiation\n   The time values used to determine BFD packet transmission\
    \ intervals\n   and the session Detection Time are continuously negotiated, and\
    \ thus\n   may be changed at any time.  The negotiation and time values are\n\
    \   independent in each direction for each session.\n   Each system reports in\
    \ the BFD Control packet how rapidly it would\n   like to transmit BFD packets,\
    \ as well as how rapidly it is prepared\n   to receive them.  This allows either\
    \ system to unilaterally determine\n   the maximum packet rate (minimum interval)\
    \ in both directions.\n   See section 6.8.7 for the details of packet transmission\
    \ timing and\n   negotiation.\n"
- title: 6.8.3.  Timer Manipulation
  contents:
  - "6.8.3.  Timer Manipulation\n   The time values used to determine BFD packet transmission\
    \ intervals\n   and the session Detection Time may be modified at any time without\n\
    \   affecting the state of the session.  When the timer parameters are\n   changed\
    \ for any reason, the requirements of this section apply.\n   If either bfd.DesiredMinTxInterval\
    \ is changed or\n   bfd.RequiredMinRxInterval is changed, a Poll Sequence MUST\
    \ be\n   initiated (see section 6.5).  If the timing is such that a system\n \
    \  receiving a Poll Sequence wishes to change the parameters described\n   in\
    \ this paragraph, the new parameter values MAY be carried in packets\n   with\
    \ the Final (F) bit set, even if the Poll Sequence has not yet\n   been sent.\n\
    \   If bfd.DesiredMinTxInterval is increased and bfd.SessionState is Up,\n   the\
    \ actual transmission interval used MUST NOT change until the Poll\n   Sequence\
    \ described above has terminated.  This is to ensure that the\n   remote system\
    \ updates its Detection Time before the transmission\n   interval increases.\n\
    \   If bfd.RequiredMinRxInterval is reduced and bfd.SessionState is Up,\n   the\
    \ previous value of bfd.RequiredMinRxInterval MUST be used when\n   calculating\
    \ the Detection Time for the remote system until the Poll\n   Sequence described\
    \ above has terminated.  This is to ensure that the\n   remote system is transmitting\
    \ packets at the higher rate (and those\n   packets are being received) prior\
    \ to the Detection Time being\n   reduced.\n   When bfd.SessionState is not Up,\
    \ the system MUST set\n   bfd.DesiredMinTxInterval to a value of not less than\
    \ one second\n   (1,000,000 microseconds).  This is intended to ensure that the\n\
    \   bandwidth consumed by BFD sessions that are not Up is negligible,\n   particularly\
    \ in the case where a neighbor may not be running BFD.\n   If the local system\
    \ reduces its transmit interval due to\n   bfd.RemoteMinRxInterval being reduced\
    \ (the remote system has\n   advertised a reduced value in Required Min RX Interval),\
    \ and the\n   remote system is not in Demand mode, the local system MUST honor\
    \ the\n   new interval immediately.  In other words, the local system cannot\n\
    \   wait longer than the new interval between the previous packet\n   transmission\
    \ and the next one.  If this interval has already passed\n   since the last transmission\
    \ (because the new interval is\n   significantly shorter), the local system MUST\
    \ send the next periodic\n   BFD Control packet as soon as practicable.\n   When\
    \ the Echo function is active, a system SHOULD set\n   bfd.RequiredMinRxInterval\
    \ to a value of not less than one second\n   (1,000,000 microseconds).  This is\
    \ intended to keep received BFD\n   Control traffic at a negligible level, since\
    \ the actual detection\n   function is being performed using BFD Echo packets.\n\
    \   In any case other than those explicitly called out above, timing\n   parameter\
    \ changes MUST be effected immediately (changing the\n   transmission rate and/or\
    \ the Detection Time).\n   Note that the Poll Sequence mechanism is ambiguous\
    \ if more than one\n   parameter change is made that would require its use, and\
    \ those\n   multiple changes are spread across multiple packets (since the\n \
    \  semantics of the returning Final are unclear).  Therefore, if\n   multiple\
    \ changes are made that require the use of a Poll Sequence,\n   there are three\
    \ choices: 1) they MUST be communicated in a single BFD\n   Control packet (so\
    \ the semantics of the Final reply are clear), or 2)\n   sufficient time must\
    \ have transpired since the Poll Sequence was\n   completed to disambiguate the\
    \ situation (at least a round trip time\n   since the last Poll was transmitted)\
    \ prior to the initiation of\n   another Poll Sequence, or 3) an additional BFD\
    \ Control packet with\n   the Final (F) bit *clear* MUST be received after the\
    \ Poll Sequence\n   has completed prior to the initiation of another Poll Sequence\
    \ (this\n   option is not available when Demand mode is active).\n"
- title: 6.8.4.  Calculating the Detection Time
  contents:
  - "6.8.4.  Calculating the Detection Time\n   The Detection Time (the period of\
    \ time without receiving BFD packets\n   after which the session is determined\
    \ to have failed) is not carried\n   explicitly in the protocol.  Rather, it is\
    \ calculated independently\n   in each direction by the receiving system based\
    \ on the negotiated\n   transmit interval and the detection multiplier.  Note\
    \ that there may\n   be different Detection Times in each direction.\n   The calculation\
    \ of the Detection Time is slightly different when in\n   Demand mode versus Asynchronous\
    \ mode.\n   In Asynchronous mode, the Detection Time calculated in the local\n\
    \   system is equal to the value of Detect Mult received from the remote\n   system,\
    \ multiplied by the agreed transmit interval of the remote\n   system (the greater\
    \ of bfd.RequiredMinRxInterval and the last\n   received Desired Min TX Interval).\
    \  The Detect Mult value is (roughly\n   speaking, due to jitter) the number of\
    \ packets that have to be missed\n   in a row to declare the session to be down.\n\
    \   If Demand mode is not active, and a period of time equal to the\n   Detection\
    \ Time passes without receiving a BFD Control packet from the\n   remote system,\
    \ and bfd.SessionState is Init or Up, the session has\n   gone down -- the local\
    \ system MUST set bfd.SessionState to Down and\n   bfd.LocalDiag to 1 (Control\
    \ Detection Time Expired).\n   In Demand mode, the Detection Time calculated in\
    \ the local system is\n   equal to bfd.DetectMult, multiplied by the agreed transmit\
    \ interval\n   of the local system (the greater of bfd.DesiredMinTxInterval and\n\
    \   bfd.RemoteMinRxInterval).  bfd.DetectMult is (roughly speaking, due\n   to\
    \ jitter) the number of packets that have to be missed in a row to\n   declare\
    \ the session to be down.\n   If Demand mode is active, and a period of time equal\
    \ to the Detection\n   Time passes after the initiation of a Poll Sequence (the\
    \ transmission\n   of the first BFD Control packet with the Poll bit set), the\
    \ session\n   has gone down -- the local system MUST set bfd.SessionState to Down,\n\
    \   and bfd.LocalDiag to 1 (Control Detection Time Expired).\n   (Note that a\
    \ packet is considered to have been received, for the\n   purposes of Detection\
    \ Time expiration, only if it has not been\n   \"discarded\" according to the\
    \ rules of section 6.8.6).\n"
- title: 6.8.5.  Detecting Failures with the Echo Function
  contents:
  - "6.8.5.  Detecting Failures with the Echo Function\n   When the Echo function\
    \ is active and a sufficient number of Echo\n   packets have not arrived as they\
    \ should, the session has gone down --\n   the local system MUST set bfd.SessionState\
    \ to Down and bfd.LocalDiag\n   to 2 (Echo Function Failed).\n   The means by\
    \ which the Echo function failures are detected is outside\n   of the scope of\
    \ this specification.  Any means that will detect a\n   communication failure\
    \ are acceptable.\n"
- title: 6.8.6.  Reception of BFD Control Packets
  contents:
  - "6.8.6.  Reception of BFD Control Packets\n   When a BFD Control packet is received,\
    \ the following procedure MUST\n   be followed, in the order specified.  If the\
    \ packet is discarded\n   according to these rules, processing of the packet MUST\
    \ cease at that\n   point.\n      If the version number is not correct (1), the\
    \ packet MUST be\n      discarded.\n      If the Length field is less than the\
    \ minimum correct value (24 if\n      the A bit is clear, or 26 if the A bit is\
    \ set), the packet MUST be\n      discarded.\n      If the Length field is greater\
    \ than the payload of the\n      encapsulating protocol, the packet MUST be discarded.\n\
    \      If the Detect Mult field is zero, the packet MUST be discarded.\n     \
    \ If the Multipoint (M) bit is nonzero, the packet MUST be\n      discarded.\n\
    \      If the My Discriminator field is zero, the packet MUST be\n      discarded.\n\
    \      If the Your Discriminator field is nonzero, it MUST be used to\n      select\
    \ the session with which this BFD packet is associated.  If\n      no session\
    \ is found, the packet MUST be discarded.\n      If the Your Discriminator field\
    \ is zero and the State field is not\n      Down or AdminDown, the packet MUST\
    \ be discarded.\n      If the Your Discriminator field is zero, the session MUST\
    \ be\n      selected based on some combination of other fields, possibly\n   \
    \   including source addressing information, the My Discriminator\n      field,\
    \ and the interface over which the packet was received.  The\n      exact method\
    \ of selection is application specific and is thus\n      outside the scope of\
    \ this specification.  If a matching session is\n      not found, a new session\
    \ MAY be created, or the packet MAY be\n      discarded.  This choice is outside\
    \ the scope of this\n      specification.\n      If the A bit is set and no authentication\
    \ is in use (bfd.AuthType\n      is zero), the packet MUST be discarded.\n   \
    \   If the A bit is clear and authentication is in use (bfd.AuthType\n      is\
    \ nonzero), the packet MUST be discarded.\n      If the A bit is set, the packet\
    \ MUST be authenticated under the\n      rules of section 6.7, based on the authentication\
    \ type in use\n      (bfd.AuthType).  This may cause the packet to be discarded.\n\
    \      Set bfd.RemoteDiscr to the value of My Discriminator.\n      Set bfd.RemoteState\
    \ to the value of the State (Sta) field.\n      Set bfd.RemoteDemandMode to the\
    \ value of the Demand (D) bit.\n      Set bfd.RemoteMinRxInterval to the value\
    \ of Required Min RX\n      Interval.\n      If the Required Min Echo RX Interval\
    \ field is zero, the\n      transmission of Echo packets, if any, MUST cease.\n\
    \      If a Poll Sequence is being transmitted by the local system and\n     \
    \ the Final (F) bit in the received packet is set, the Poll Sequence\n      MUST\
    \ be terminated.\n      Update the transmit interval as described in section 6.8.2.\n\
    \      Update the Detection Time as described in section 6.8.4.\n      If bfd.SessionState\
    \ is AdminDown\n          Discard the packet\n      If received state is AdminDown\n\
    \          If bfd.SessionState is not Down\n              Set bfd.LocalDiag to\
    \ 3 (Neighbor signaled\n                  session down)\n              Set bfd.SessionState\
    \ to Down\n      Else\n          If bfd.SessionState is Down\n              If\
    \ received State is Down\n                  Set bfd.SessionState to Init\n   \
    \           Else if received State is Init\n                  Set bfd.SessionState\
    \ to Up\n          Else if bfd.SessionState is Init\n              If received\
    \ State is Init or Up\n                  Set bfd.SessionState to Up\n        \
    \  Else (bfd.SessionState is Up)\n              If received State is Down\n  \
    \                Set bfd.LocalDiag to 3 (Neighbor signaled\n                 \
    \     session down)\n                  Set bfd.SessionState to Down\n      Check\
    \ to see if Demand mode should become active or not (see\n      section 6.6).\n\
    \      If bfd.RemoteDemandMode is 1, bfd.SessionState is Up, and\n      bfd.RemoteSessionState\
    \ is Up, Demand mode is active on the remote\n      system and the local system\
    \ MUST cease the periodic transmission\n      of BFD Control packets (see section\
    \ 6.8.7).\n      If bfd.RemoteDemandMode is 0, or bfd.SessionState is not Up,\
    \ or\n      bfd.RemoteSessionState is not Up, Demand mode is not active on the\n\
    \      remote system and the local system MUST send periodic BFD Control\n   \
    \   packets (see section 6.8.7).\n      If the Poll (P) bit is set, send a BFD\
    \ Control packet to the\n      remote system with the Poll (P) bit clear, and\
    \ the Final (F) bit\n      set (see section 6.8.7).\n      If the packet was not\
    \ discarded, it has been received for purposes\n      of the Detection Time expiration\
    \ rules in section 6.8.4.\n"
- title: 6.8.7.  Transmitting BFD Control Packets
  contents:
  - "6.8.7.  Transmitting BFD Control Packets\n   With the exceptions listed in the\
    \ remainder of this section, a system\n   MUST NOT transmit BFD Control packets\
    \ at an interval less than the\n   larger of bfd.DesiredMinTxInterval and bfd.RemoteMinRxInterval,\
    \ less\n   applied jitter (see below).  In other words, the system reporting the\n\
    \   slower rate determines the transmission rate.\n   The periodic transmission\
    \ of BFD Control packets MUST be jittered on\n   a per-packet basis by up to 25%,\
    \ that is, the interval MUST be\n   reduced by a random value of 0 to 25%, in\
    \ order to avoid self-\n   synchronization with other systems on the same subnetwork.\
    \  Thus, the\n   average interval between packets will be roughly 12.5% less than\
    \ that\n   negotiated.\n   If bfd.DetectMult is equal to 1, the interval between\
    \ transmitted BFD\n   Control packets MUST be no more than 90% of the negotiated\n\
    \   transmission interval, and MUST be no less than 75% of the negotiated\n  \
    \ transmission interval.  This is to ensure that, on the remote system,\n   the\
    \ calculated Detection Time does not pass prior to the receipt of\n   the next\
    \ BFD Control packet.\n   The transmit interval MUST be recalculated whenever\n\
    \   bfd.DesiredMinTxInterval changes, or whenever bfd.RemoteMinRxInterval\n  \
    \ changes, and is equal to the greater of those two values.  See\n   sections\
    \ 6.8.2 and 6.8.3 for details on transmit timers.\n   A system MUST NOT transmit\
    \ BFD Control packets if bfd.RemoteDiscr is\n   zero and the system is taking\
    \ the Passive role.\n   A system MUST NOT periodically transmit BFD Control packets\
    \ if\n   bfd.RemoteMinRxInterval is zero.\n   A system MUST NOT periodically transmit\
    \ BFD Control packets if Demand\n   mode is active on the remote system (bfd.RemoteDemandMode\
    \ is 1,\n   bfd.SessionState is Up, and bfd.RemoteSessionState is Up) and a Poll\n\
    \   Sequence is not being transmitted.\n   If a BFD Control packet is received\
    \ with the Poll (P) bit set to 1,\n   the receiving system MUST transmit a BFD\
    \ Control packet with the Poll\n   (P) bit clear and the Final (F) bit set as\
    \ soon as practicable,\n   without respect to the transmission timer or any other\
    \ transmission\n   limitations, without respect to the session state, and without\n\
    \   respect to whether Demand mode is active on either system.  A system\n   MAY\
    \ limit the rate at which such packets are transmitted.  If rate\n   limiting\
    \ is in effect, the advertised value of Desired Min TX\n   Interval MUST be greater\
    \ than or equal to the interval between\n   transmitted packets imposed by the\
    \ rate limiting function.\n   A system MUST NOT set the Demand (D) bit unless\
    \ bfd.DemandMode is 1,\n   bfd.SessionState is Up, and bfd.RemoteSessionState\
    \ is Up.\n   A BFD Control packet SHOULD be transmitted during the interval\n\
    \   between periodic Control packet transmissions when the contents of\n   that\
    \ packet would differ from that in the previously transmitted\n   packet (other\
    \ than the Poll and Final bits) in order to more rapidly\n   communicate a change\
    \ in state.\n   The contents of transmitted BFD Control packets MUST be set as\n\
    \   follows:\n   Version\n      Set to the current version number (1).\n   Diagnostic\
    \ (Diag)\n      Set to bfd.LocalDiag.\n   State (Sta)\n      Set to the value\
    \ indicated by bfd.SessionState.\n   Poll (P)\n      Set to 1 if the local system\
    \ is sending a Poll Sequence, or 0 if\n      not.\n   Final (F)\n      Set to\
    \ 1 if the local system is responding to a Control packet\n      received with\
    \ the Poll (P) bit set, or 0 if not.\n   Control Plane Independent (C)\n     \
    \ Set to 1 if the local system's BFD implementation is independent\n      of the\
    \ control plane (it can continue to function through a\n      disruption of the\
    \ control plane).\n   Authentication Present (A)\n      Set to 1 if authentication\
    \ is in use on this session (bfd.AuthType\n      is nonzero), or 0 if not.\n \
    \  Demand (D)\n      Set to bfd.DemandMode if bfd.SessionState is Up and\n   \
    \   bfd.RemoteSessionState is Up.  Otherwise, it is set to 0.\n   Multipoint (M)\n\
    \      Set to 0.\n   Detect Mult\n      Set to bfd.DetectMult.\n   Length\n  \
    \    Set to the appropriate length, based on the fixed header length\n      (24)\
    \ plus any Authentication Section.\n   My Discriminator\n      Set to bfd.LocalDiscr.\n\
    \   Your Discriminator\n      Set to bfd.RemoteDiscr.\n   Desired Min TX Interval\n\
    \      Set to bfd.DesiredMinTxInterval.\n   Required Min RX Interval\n      Set\
    \ to bfd.RequiredMinRxInterval.\n   Required Min Echo RX Interval\n      Set to\
    \ the minimum required Echo packet receive interval for this\n      session. \
    \ If this field is set to zero, the local system is\n      unwilling or unable\
    \ to loop back BFD Echo packets to the remote\n      system, and the remote system\
    \ will not send Echo packets.\n   Authentication Section\n      Included and set\
    \ according to the rules in section 6.7 if\n      authentication is in use (bfd.AuthType\
    \ is nonzero).  Otherwise,\n      this section is not present.\n"
- title: 6.8.8.  Reception of BFD Echo Packets
  contents:
  - "6.8.8.  Reception of BFD Echo Packets\n   A received BFD Echo packet MUST be\
    \ demultiplexed to the appropriate\n   session for processing.  A means of detecting\
    \ missing Echo packets\n   MUST be implemented, which most likely involves processing\
    \ of the\n   Echo packets that are received.  The processing of received Echo\n\
    \   packets is otherwise outside the scope of this specification.\n"
- title: 6.8.9.  Transmission of BFD Echo Packets
  contents:
  - "6.8.9.  Transmission of BFD Echo Packets\n   BFD Echo packets MUST NOT be transmitted\
    \ when bfd.SessionState is not\n   Up.  BFD Echo packets MUST NOT be transmitted\
    \ unless the last BFD\n   Control packet received from the remote system contains\
    \ a nonzero\n   value in Required Min Echo RX Interval.\n   BFD Echo packets MAY\
    \ be transmitted when bfd.SessionState is Up.  The\n   interval between transmitted\
    \ BFD Echo packets MUST NOT be less than\n   the value advertised by the remote\
    \ system in Required Min Echo RX\n   Interval, except as follows:\n      A 25%\
    \ jitter MAY be applied to the rate of transmission, such that\n      the actual\
    \ interval MAY be between 75% and 100% of the advertised\n      value.  A single\
    \ BFD Echo packet MAY be transmitted between\n      normally scheduled Echo transmission\
    \ intervals.\n   The transmission of BFD Echo packets is otherwise outside the\
    \ scope\n   of this specification.\n"
- title: 6.8.10.  Min Rx Interval Change
  contents:
  - "6.8.10.  Min Rx Interval Change\n   When it is desired to change the rate at\
    \ which BFD Control packets\n   arrive from the remote system, bfd.RequiredMinRxInterval\
    \ can be\n   changed at any time to any value.  The new value will be transmitted\n\
    \   in the next outgoing Control packet, and the remote system will\n   adjust\
    \ accordingly.  See section 6.8.3 for further requirements.\n"
- title: 6.8.11.  Min Tx Interval Change
  contents:
  - "6.8.11.  Min Tx Interval Change\n   When it is desired to change the rate at\
    \ which BFD Control packets\n   are transmitted to the remote system (subject\
    \ to the requirements of\n   the neighboring system), bfd.DesiredMinTxInterval\
    \ can be changed at\n   any time to any value.  The rules in section 6.8.3 apply.\n"
- title: 6.8.12.  Detect Multiplier Change
  contents:
  - "6.8.12.  Detect Multiplier Change\n   When it is desired to change the detect\
    \ multiplier, the value of\n   bfd.DetectMult can be changed to any nonzero value.\
    \  The new value\n   will be transmitted with the next BFD Control packet, and\
    \ the use of\n   a Poll Sequence is not necessary.  See section 6.6 for additional\n\
    \   requirements.\n"
- title: 6.8.13.  Enabling or Disabling The Echo Function
  contents:
  - "6.8.13.  Enabling or Disabling The Echo Function\n   If it is desired to start\
    \ or stop the transmission of BFD Echo\n   packets, this MAY be done at any time\
    \ (subject to the transmission\n   requirements detailed in section 6.8.9).\n\
    \   If it is desired to enable or disable the looping back of received\n   BFD\
    \ Echo packets, this MAY be done at any time by changing the value\n   of Required\
    \ Min Echo RX Interval to zero or nonzero in outgoing BFD\n   Control packets.\n"
- title: 6.8.14.  Enabling or Disabling Demand Mode
  contents:
  - "6.8.14.  Enabling or Disabling Demand Mode\n   If it is desired to start or stop\
    \ Demand mode, this MAY be done at\n   any time by setting bfd.DemandMode to the\
    \ proper value.  Demand mode\n   will subsequently become active under the rules\
    \ described in section\n   6.6.\n   If Demand mode is no longer active on the\
    \ remote system, the local\n   system MUST begin transmitting periodic BFD Control\
    \ packets as\n   described in section 6.8.7.\n"
- title: 6.8.15.  Forwarding Plane Reset
  contents:
  - "6.8.15.  Forwarding Plane Reset\n   When the forwarding plane in the local system\
    \ is reset for some\n   reason, such that the remote system can no longer rely\
    \ on the local\n   forwarding state, the local system MUST set bfd.LocalDiag to\
    \ 4\n   (Forwarding Plane Reset), and set bfd.SessionState to Down.\n"
- title: 6.8.16.  Administrative Control
  contents:
  - "6.8.16.  Administrative Control\n   There may be circumstances where it is desirable\
    \ to administratively\n   enable or disable a BFD session.  When this is desired,\
    \ the following\n   procedure MUST be followed:\n      If enabling session\n \
    \        Set bfd.SessionState to Down\n      Else\n         Set bfd.SessionState\
    \ to AdminDown\n         Set bfd.LocalDiag to an appropriate value\n         Cease\
    \ the transmission of BFD Echo packets\n   If signaling is received from outside\
    \ BFD that the underlying path\n   has failed, an implementation MAY administratively\
    \ disable the\n   session with the diagnostic Path Down.\n   Other scenarios MAY\
    \ use the diagnostic Administratively Down.\n   BFD Control packets SHOULD be\
    \ transmitted for at least a Detection\n   Time after transitioning to AdminDown\
    \ state in order to ensure that\n   the remote system is aware of the state change.\
    \  BFD Control packets\n   MAY be transmitted indefinitely after transitioning\
    \ to AdminDown\n   state in order to maintain session state in each system (see\
    \ section\n   6.8.18 below).\n"
- title: 6.8.17.  Concatenated Paths
  contents:
  - "6.8.17.  Concatenated Paths\n   If the path being monitored by BFD is concatenated\
    \ with other paths\n   (connected end-to-end in series), it may be desirable to\
    \ propagate\n   the indication of a failure of one of those paths across the BFD\n\
    \   session (providing an interworking function for liveness monitoring\n   between\
    \ BFD and other technologies).\n   Two diagnostic codes are defined for this purpose:\
    \ Concatenated Path\n   Down and Reverse Concatenated Path Down.  The first propagates\n\
    \   forward path failures (in which the concatenated path fails in the\n   direction\
    \ toward the interworking system), and the second propagates\n   reverse path\
    \ failures (in which the concatenated path fails in the\n   direction away from\
    \ the interworking system, assuming a bidirectional\n   link).\n   A system MAY\
    \ signal one of these failure states by simply setting\n   bfd.LocalDiag to the\
    \ appropriate diagnostic code.  Note that the BFD\n   session is not taken down.\
    \  If Demand mode is not active on the\n   remote system, no other action is necessary,\
    \ as the diagnostic code\n   will be carried via the periodic transmission of\
    \ BFD Control packets.\n   If Demand mode is active on the remote system (the\
    \ local system is\n   not transmitting periodic BFD Control packets), a Poll Sequence\
    \ MUST\n   be initiated to ensure that the diagnostic code is transmitted.  Note\n\
    \   that if the BFD session subsequently fails, the diagnostic code will\n   be\
    \ overwritten with a code detailing the cause of the failure.  It is\n   up to\
    \ the interworking agent to perform the above procedure again,\n   once the BFD\
    \ session reaches Up state, if the propagation of the\n   concatenated path failure\
    \ is to resume.\n"
- title: 6.8.18.  Holding Down Sessions
  contents:
  - "6.8.18.  Holding Down Sessions\n   A system MAY choose to prevent a BFD session\
    \ from being established.\n   One possible reason might be to manage the rate\
    \ at which sessions are\n   established.  This can be done by holding the session\
    \ in Down or\n   AdminDown state, as appropriate.\n   There are two related mechanisms\
    \ that are available to help with this\n   task.  First, a system is REQUIRED\
    \ to maintain session state\n   (including timing parameters), even when a session\
    \ is down, until a\n   Detection Time has passed without the receipt of any BFD\
    \ Control\n   packets.  This means that a system may take down a session and\n\
    \   transmit an arbitrarily large value in the Required Min RX Interval\n   field\
    \ to control the rate at which it receives packets.\n   Additionally, a system\
    \ MAY transmit a value of zero for Required Min\n   RX Interval to indicate that\
    \ the remote system should send no packets\n   whatsoever.\n   So long as the\
    \ local system continues to transmit BFD Control\n   packets, the remote system\
    \ is obligated to obey the value carried in\n   Required Min RX Interval.  If\
    \ the remote system does not receive any\n   BFD Control packets for a Detection\
    \ Time, it SHOULD reset\n   bfd.RemoteMinRxInterval to its initial value of 1\
    \ (per section 6.8.1,\n   since it is no longer required to maintain previous\
    \ session state)\n   and then can transmit at its own rate.\n"
- title: 7.  Operational Considerations
  contents:
  - "7.  Operational Considerations\n   BFD is likely to be deployed as a critical\
    \ part of network\n   infrastructure.  As such, care should be taken to avoid\
    \ disruption.\n   Obviously, any mechanism that blocks BFD packets, such as firewalls\n\
    \   or other policy processes, will cause BFD to fail.\n   Mechanisms that control\
    \ packet scheduling, such as policers, traffic\n   shapers, priority queueing,\
    \ etc., have the potential of impacting BFD\n   operations if the Detection Time\
    \ is similar in scale to the scheduled\n   packet transmit or receive rate.  The\
    \ delivery of BFD packets is\n   time-critical, relative to the magnitude of the\
    \ Detection Time, so\n   this may need to be taken into account in implementation\
    \ and\n   deployment, particularly when very short Detection Times are to be\n\
    \   used.\n   When BFD is used across multiple hops, a congestion control mechanism\n\
    \   MUST be implemented, and when congestion is detected, the BFD\n   implementation\
    \ MUST reduce the amount of traffic it generates.  The\n   exact mechanism used\
    \ is outside the scope of this specification, and\n   the requirements of this\
    \ mechanism may differ depending on how BFD is\n   deployed, and how it interacts\
    \ with other parts of the system (for\n   example, exponential backoff may not\
    \ be appropriate in cases where\n   routing protocols are interacting closely\
    \ with BFD).\n   Note that \"congestion\" is not only a traffic phenomenon, but\
    \ also a\n   computational one.  It is possible for systems with a large number\
    \ of\n   BFD sessions and/or very short packet intervals to become CPU-bound.\n\
    \   As such, a congestion control algorithm SHOULD be used even across\n   single\
    \ hops in order to avoid the possibility of catastrophic system\n   collapse,\
    \ as such failures have been seen repeatedly in other\n   periodic Hello-based\
    \ protocols.\n   The mechanisms for detecting congestion are outside the scope\
    \ of this\n   specification, but may include the detection of lost BFD Control\n\
    \   packets (by virtue of holes in the authentication sequence number\n   space,\
    \ or by BFD session failure) or other means.\n   The mechanisms for reducing BFD's\
    \ traffic load are the control of the\n   local and remote packet transmission\
    \ rate via the Min RX Interval and\n   Min TX Interval fields.\n   Note that any\
    \ mechanism that increases the transmit or receive\n   intervals will increase\
    \ the Detection Time for the session.\n   It is worth noting that a single BFD\
    \ session does not consume a large\n   amount of bandwidth.  An aggressive session\
    \ that achieves a detection\n   time of 50 milliseconds, by using a transmit interval\
    \ of 16.7\n   milliseconds and a detect multiplier of 3, will generate 60 packets\n\
    \   per second.  The maximum length of each packet on the wire is on the\n   order\
    \ of 100 bytes, for a total of around 48 kilobits per second of\n   bandwidth\
    \ consumption in each direction.\n"
- title: 8.  IANA Considerations
  contents:
  - "8.  IANA Considerations\n   This document defines two registries administered\
    \ by IANA.  The first\n   is titled \"BFD Diagnostic Codes\" (see section 4.1).\
    \  Initial values\n   for the BFD Diagnostic Code registry are given below.  Further\n\
    \   assignments are to be made through Expert Review\n   [IANA-CONSIDERATIONS].\
    \  Assignments consist of a BFD Diagnostic Code\n   name and its associated value.\n\
    \      Value    BFD Diagnostic Code Name\n      -----    ------------------------\n\
    \       0       No Diagnostic\n       1       Control Detection Time Expired\n\
    \       2       Echo Function Failed\n       3       Neighbor Signaled Session\
    \ Down\n       4       Forwarding Plane Reset\n       5       Path Down\n    \
    \   6       Concatenated Path Down\n       7       Administratively Down\n   \
    \    8       Reverse Concatenated Path Down\n       9-31    Unassigned\n   The\
    \ second registry is titled \"BFD Authentication Types\" (see section\n   4.1).\
    \  Initial values for the BFD Authentication Type registry are\n   given below.\
    \  Further assignments are to be made through Expert\n   Review [IANA-CONSIDERATIONS].\
    \  Assignments consist of a BFD\n   Authentication Type Code name and its associated\
    \ value.\n      Value    BFD Authentication Type Name\n      -----    ----------------------------\n\
    \       0       Reserved\n       1       Simple Password\n       2       Keyed\
    \ MD5\n       3       Meticulous Keyed MD5\n       4       Keyed SHA1\n      \
    \ 5       Meticulous Keyed SHA1\n       6-255   Unassigned\n"
- title: 9.  Security Considerations
  contents:
  - "9.  Security Considerations\n   As BFD may be tied into the stability of the\
    \ network infrastructure\n   (such as routing protocols), the effects of an attack\
    \ on a BFD\n   session may be very serious: a link may be falsely declared to\
    \ be\n   down, or falsely declared to be up; in either case, the effect is\n \
    \  denial of service.\n   An attacker who is in complete control of the link between\
    \ the\n   systems can easily drop all BFD packets but forward everything else\n\
    \   (causing the link to be falsely declared down), or forward only the\n   BFD\
    \ packets but nothing else (causing the link to be falsely declared\n   up). \
    \ This attack cannot be prevented by BFD.\n   To mitigate threats from less capable\
    \ attackers, BFD specifies two\n   mechanisms to prevent spoofing of BFD Control\
    \ packets.  The\n   Generalized TTL Security Mechanism [GTSM] uses the time to\
    \ live (TTL)\n   or Hop Count to prevent off-link attackers from spoofing packets.\n\
    \   The Authentication Section authenticates the BFD Control packets.\n   These\
    \ mechanisms are described in more detail below.\n   When a BFD session is directly\
    \ connected across a single link\n   (physical, or a secure tunnel such as IPsec),\
    \ the TTL or Hop Count\n   MUST be set to the maximum on transmit, and checked\
    \ to be equal to\n   the maximum value on reception (and the packet dropped if\
    \ this is not\n   the case).  See [GTSM] for more information on this technique.\
    \  If\n   BFD is run across multiple hops or an insecure tunnel (such as\n   Generic\
    \ Routing Encapsulation (GRE)), the Authentication Section\n   SHOULD be utilized.\n\
    \   The level of security provided by the Authentication Section varies\n   based\
    \ on the authentication type used.  Simple Password\n   authentication is obviously\
    \ only as secure as the secrecy of the\n   passwords used, and should be considered\
    \ only if the BFD session is\n   guaranteed to be run over an infrastructure not\
    \ subject to packet\n   interception.  Its chief advantage is that it minimizes\
    \ the\n   computational effort required for authentication.\n   Keyed MD5 Authentication\
    \ is much stronger than Simple Password\n   Authentication since the keys cannot\
    \ be discerned by intercepting\n   packets.  It is vulnerable to replay attacks\
    \ in between increments of\n   the sequence number.  The sequence number can be\
    \ incremented as\n   seldom (or as often) as desired, trading off resistance to\
    \ replay\n   attacks with the computational effort required for authentication.\n\
    \   Meticulous Keyed MD5 authentication is stronger yet, as it requires\n   the\
    \ sequence number to be incremented for every packet.  Replay\n   attack vulnerability\
    \ is reduced due to the requirement that the\n   sequence number must be incremented\
    \ on every packet, the window size\n   of acceptable packets is small, and the\
    \ initial sequence number is\n   randomized.  There is still a window of attack\
    \ at the beginning of\n   the session while the sequence number is being determined.\
    \  This\n   authentication scheme requires an MD5 calculation on every packet\n\
    \   transmitted and received.\n   Using SHA1 is believed to have stronger security\
    \ properties than MD5.\n   All comments about MD5 in this section also apply to\
    \ SHA1.\n   Both Keyed MD5/SHA1 and Meticulous Keyed MD5/SHA1 use the \"secret\n\
    \   suffix\" construction (also called \"append only\") in which the shared\n\
    \   secret key is appended to the data before calculating the hash,\n   instead\
    \ of the more common Hashed Message Authentication Code (HMAC)\n   construction\
    \ [HMAC].  This construction is believed to be appropriate\n   for BFD, but designers\
    \ of any additional authentication mechanisms\n   for BFD are encouraged to read\
    \ [HMAC] and its references.\n   If both systems randomize their Local Discriminator\
    \ values at the\n   beginning of a session, replay attacks may be further mitigated,\n\
    \   regardless of the authentication type in use.  Since the Local\n   Discriminator\
    \ may be changed at any time during a session, this\n   mechanism may also help\
    \ mitigate attacks.\n   The security implications of the use of BFD Echo packets\
    \ are\n   dependent on how those packets are defined, since their structure is\n\
    \   local to the transmitting system and outside the scope of this\n   specification.\
    \  However, since Echo packets are defined and processed\n   only by the transmitting\
    \ system, the use of cryptographic\n   authentication does not guarantee that\
    \ the other system is actually\n   alive; an attacker could loop the Echo packets\
    \ back (without knowing\n   any secret keys) and cause the link to be falsely\
    \ declared to be up.\n   This can be mitigated by using a suitable interval for\
    \ BFD Control\n   packets.  [GTSM] could be applied to BFD Echo packets, though\
    \ the\n   TTL/Hop Count will be decremented by 1 in the course of echoing the\n\
    \   packet, so spoofing is possible from one hop away.\n"
- title: 10.  References
  contents:
  - '10.  References

    '
- title: 10.1.  Normative References
  contents:
  - "10.1.  Normative References\n   [GTSM]     Gill, V., Heasley, J., Meyer, D.,\
    \ Savola, P., Ed., and C.\n              Pignataro, \"The Generalized TTL Security\
    \ Mechanism\n              (GTSM)\", RFC 5082, October 2007.\n   [KEYWORDS] Bradner,\
    \ S., \"Key words for use in RFCs to Indicate\n              Requirement Levels\"\
    , BCP 14, RFC 2119, March 1997.\n   [MD5]      Rivest, R., \"The MD5 Message-Digest\
    \ Algorithm\", RFC 1321,\n              April 1992.\n   [SHA1]     Eastlake 3rd,\
    \ D. and P. Jones, \"US Secure Hash Algorithm 1\n              (SHA1)\", RFC 3174,\
    \ September 2001.\n"
- title: 10.2.  Informative References
  contents:
  - "10.2.  Informative References\n   [HMAC]     Krawczyk, H., Bellare, M., and R.\
    \ Canetti, \"HMAC: Keyed-\n              Hashing for Message Authentication\"\
    , RFC 2104, February\n              1997.\n   [IANA-CONSIDERATIONS]\n        \
    \      Narten, T. and H. Alvestrand, \"Guidelines for Writing an\n           \
    \   IANA Considerations Section in RFCs\", BCP 26, RFC 5226,\n              May\
    \ 2008.\n   [OSPF]     Moy, J., \"OSPF Version 2\", STD 54, RFC 2328, April 1998.\n"
- title: Appendix A.  Backward Compatibility (Non-Normative)
  contents:
  - "Appendix A.  Backward Compatibility (Non-Normative)\n   Although version 0 of\
    \ this protocol (as defined in early versions of\n   the Internet-Draft that became\
    \ this RFC) is unlikely to have been\n   deployed widely, some implementors may\
    \ wish to have a backward\n   compatibility mechanism.  Note that any mechanism\
    \ may be potentially\n   used that does not alter the protocol definition, so\
    \ interoperability\n   should not be an issue.\n   The suggested mechanism described\
    \ here has the property that it will\n   converge on version 1 if both systems\
    \ implement it, even if one\n   system is upgraded from version 0 within a Detection\
    \ Time.  It will\n   interoperate with a system that implements only one version\
    \ (or is\n   configured to support only one version).  A system should obviously\n\
    \   not perform this function if it is configured to or is only capable\n   of\
    \ using a single version.\n   A BFD session will enter a \"negotiation holddown\"\
    \ if it is configured\n   for automatic versioning and either has just started\
    \ up, or the\n   session has been manually cleared.  The session is set to AdminDown\n\
    \   state and version 1.  During the holddown period, which lasts for one\n  \
    \ Detection Time, the system sends BFD Control packets as usual, but\n   ignores\
    \ received packets.  After the holddown time is complete, the\n   state transitions\
    \ to Down and normal operation resumes.\n   When a system is not in holddown,\
    \ if it doing automatic versioning\n   and is currently using version 1, if any\
    \ version 0 packet is received\n   for the session, it switches immediately to\
    \ version 0.  If it is\n   currently using version 0 and a version 1 packet is\
    \ received that\n   indicates that the neighbor is in state AdminDown, it switches\
    \ to\n   version 1.  If using version 0 and a version 1 packet is received\n \
    \  indicating a state other than AdminDown, the packet is ignored (per\n   spec).\n\
    \   If the version being used is changed, the session goes down as\n   appropriate\
    \ for the new version (Down state for version 1 or Failing\n   state for version\
    \ 0).\n"
- title: Appendix B.  Contributors
  contents:
  - "Appendix B.  Contributors\n   Kireeti Kompella and Yakov Rekhter of Juniper Networks\
    \ were also\n   significant contributors to this document.\n"
- title: Appendix C.  Acknowledgments
  contents:
  - "Appendix C.  Acknowledgments\n   This document was inspired by (and is intended\
    \ to replace) the\n   Protocol Liveness Protocol document, written by Kireeti\
    \ Kompella.\n   Demand mode was inspired by \"A Traffic-Based Method of Detecting\
    \ Dead\n   Internet Key Exchange (IKE) Peers\", by G. Huang, et al.\n   The authors\
    \ would also like to thank Mike Shand, John Scudder,\n   Stewart Bryant, Pekka\
    \ Savola, Richard Spencer, and Pasi Eronen for\n   their substantive input.\n\
    \   The authors would also like to thank Owen Wheeler for hosting\n   teleconferences\
    \ between the authors of this specification and\n   multiple vendors in order\
    \ address implementation and clarity issues.\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Dave Katz\n   Juniper Networks\n   1194 N. Mathilda Ave.\n\
    \   Sunnyvale, CA  94089-1206\n   USA\n   Phone: +1-408-745-2000\n   EMail: dkatz@juniper.net\n\
    \   Dave Ward\n   Juniper Networks\n   1194 N. Mathilda Ave.\n   Sunnyvale, CA\
    \  94089-1206\n   USA\n   Phone: +1-408-745-2000\n   EMail: dward@juniper.net\n"
