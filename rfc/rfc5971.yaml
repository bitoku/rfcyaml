- title: __initial_text__
  contents:
  - '              GIST: General Internet Signalling Transport

    '
- title: Abstract
  contents:
  - "Abstract\n   This document specifies protocol stacks for the routing and transport\n\
    \   of per-flow signalling messages along the path taken by that flow\n   through\
    \ the network.  The design uses existing transport and security\n   protocols\
    \ under a common messaging layer, the General Internet\n   Signalling Transport\
    \ (GIST), which provides a common service for\n   diverse signalling applications.\
    \  GIST does not handle signalling\n   application state itself, but manages its\
    \ own internal state and the\n   configuration of the underlying transport and\
    \ security protocols to\n   enable the transfer of messages in both directions\
    \ along the flow\n   path.  The combination of GIST and the lower layer transport\
    \ and\n   security protocols provides a solution for the base protocol\n   component\
    \ of the \"Next Steps in Signalling\" (NSIS) framework.\n"
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This document is not an Internet Standards Track specification;\
    \ it is\n   published for examination, experimental implementation, and\n   evaluation.\n\
    \   This document defines an Experimental Protocol for the Internet\n   community.\
    \  This document is a product of the Internet Engineering\n   Task Force (IETF).\
    \  It represents the consensus of the IETF\n   community.  It has received public\
    \ review and has been approved for\n   publication by the Internet Engineering\
    \ Steering Group (IESG).  Not\n   all documents approved by the IESG are a candidate\
    \ for any level of\n   Internet Standard; see Section 2 of RFC 5741.\n   Information\
    \ about the current status of this document, any errata,\n   and how to provide\
    \ feedback on it may be obtained at\n   http://www.rfc-editor.org/info/rfc5971.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (c) 2010 IETF Trust and the persons identified\
    \ as the\n   document authors.  All rights reserved.\n   This document is subject\
    \ to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n\
    \   (http://trustee.ietf.org/license-info) in effect on the date of\n   publication\
    \ of this document.  Please review these documents\n   carefully, as they describe\
    \ your rights and restrictions with respect\n   to this document.  Code Components\
    \ extracted from this document must\n   include Simplified BSD License text as\
    \ described in Section 4.e of\n   the Trust Legal Provisions and are provided\
    \ without warranty as\n   described in the Simplified BSD License.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1.  Introduction  . . . . . . . . . . . . . . . . . . .\
    \ . . . . .   4\n   2.  Requirements Notation and Terminology . . . . . . . .\
    \ . . . .   5\n   3.  Design Overview . . . . . . . . . . . . . . . . . . . .\
    \ . . .   8\n     3.1.  Overall Design Approach . . . . . . . . . . . . . . .\
    \ . .   8\n     3.2.  Modes and Messaging Associations  . . . . . . . . . . .\
    \ .  10\n     3.3.  Message Routing Methods . . . . . . . . . . . . . . . . .\
    \  11\n     3.4.  GIST Messages . . . . . . . . . . . . . . . . . . . . . .  13\n\
    \     3.5.  GIST Peering Relationships  . . . . . . . . . . . . . . .  14\n  \
    \   3.6.  Effect on Internet Transparency . . . . . . . . . . . . .  14\n    \
    \ 3.7.  Signalling Sessions . . . . . . . . . . . . . . . . . . .  15\n     3.8.\
    \  Signalling Applications and NSLPIDs . . . . . . . . . . .  16\n     3.9.  GIST\
    \ Security Services  . . . . . . . . . . . . . . . . .  17\n     3.10. Example\
    \ of Operation  . . . . . . . . . . . . . . . . . .  18\n   4.  GIST Processing\
    \ Overview  . . . . . . . . . . . . . . . . . .  20\n     4.1.  GIST Service Interface\
    \  . . . . . . . . . . . . . . . . .  21\n     4.2.  GIST State  . . . . . . .\
    \ . . . . . . . . . . . . . . . .  23\n     4.3.  Basic GIST Message Processing\
    \ . . . . . . . . . . . . . .  25\n     4.4.  Routing State and Messaging Association\
    \ Maintenance . . .  33\n   5.  Message Formats and Transport . . . . . . . .\
    \ . . . . . . . .  45\n     5.1.  GIST Messages . . . . . . . . . . . . . . .\
    \ . . . . . . .  45\n     5.2.  Information Elements  . . . . . . . . . . . .\
    \ . . . . . .  48\n     5.3.  D-mode Transport  . . . . . . . . . . . . . . .\
    \ . . . . .  53\n     5.4.  C-mode Transport  . . . . . . . . . . . . . . . .\
    \ . . . .  58\n     5.5.  Message Type/Encapsulation Relationships  . . . . .\
    \ . . .  59\n     5.6.  Error Message Processing  . . . . . . . . . . . . . .\
    \ . .  60\n     5.7.  Messaging Association Setup . . . . . . . . . . . . . .\
    \ .  61\n     5.8.  Specific Message Routing Methods  . . . . . . . . . . . .\
    \  66\n   6.  Formal Protocol Specification . . . . . . . . . . . . . . . .  71\n\
    \     6.1.  Node Processing . . . . . . . . . . . . . . . . . . . . .  73\n  \
    \   6.2.  Query Node Processing . . . . . . . . . . . . . . . . . .  75\n    \
    \ 6.3.  Responder Node Processing . . . . . . . . . . . . . . . .  79\n     6.4.\
    \  Messaging Association Processing  . . . . . . . . . . . .  83\n   7.  Additional\
    \ Protocol Features  . . . . . . . . . . . . . . . .  86\n     7.1.  Route Changes\
    \ and Local Repair  . . . . . . . . . . . . .  86\n     7.2.  NAT Traversal .\
    \ . . . . . . . . . . . . . . . . . . . . .  93\n     7.3.  Interaction with IP\
    \ Tunnelling  . . . . . . . . . . . . .  99\n     7.4.  IPv4-IPv6 Transition and\
    \ Interworking . . . . . . . . . . 100\n   8.  Security Considerations . . . .\
    \ . . . . . . . . . . . . . . . 101\n     8.1.  Message Confidentiality and Integrity\
    \ . . . . . . . . . . 102\n     8.2.  Peer Node Authentication  . . . . . . .\
    \ . . . . . . . . . 102\n     8.3.  Routing State Integrity . . . . . . . . .\
    \ . . . . . . . . 103\n     8.4.  Denial-of-Service Prevention and Overload Protection\
    \  . . 104\n     8.5.  Requirements on Cookie Mechanisms . . . . . . . . . . .\
    \ . 106\n     8.6.  Security Protocol Selection Policy  . . . . . . . . . . .\
    \ 108\n     8.7.  Residual Threats  . . . . . . . . . . . . . . . . . . . . 109\n\
    \   9.  IANA Considerations . . . . . . . . . . . . . . . . . . . . . 111\n  \
    \ 10. Acknowledgements  . . . . . . . . . . . . . . . . . . . . . . 117\n   11.\
    \ References  . . . . . . . . . . . . . . . . . . . . . . . . . 118\n     11.1.\
    \ Normative References  . . . . . . . . . . . . . . . . . . 118\n     11.2. Informative\
    \ References  . . . . . . . . . . . . . . . . . 119\n   Appendix A.  Bit-Level\
    \ Formats and Error Messages . . . . . . . . 122\n     A.1.  The GIST Common Header\
    \  . . . . . . . . . . . . . . . . . 122\n     A.2.  General Object Format . .\
    \ . . . . . . . . . . . . . . . . 123\n     A.3.  GIST TLV Objects  . . . . .\
    \ . . . . . . . . . . . . . . . 125\n     A.4.  Errors  . . . . . . . . . . .\
    \ . . . . . . . . . . . . . . 134\n   Appendix B.  API between GIST and Signalling\
    \ Applications . . . . 143\n     B.1.  SendMessage . . . . . . . . . . . . . .\
    \ . . . . . . . . . 143\n     B.2.  RecvMessage . . . . . . . . . . . . . . .\
    \ . . . . . . . . 145\n     B.3.  MessageStatus . . . . . . . . . . . . . . .\
    \ . . . . . . . 146\n     B.4.  NetworkNotification . . . . . . . . . . . . .\
    \ . . . . . . 147\n     B.5.  SetStateLifetime  . . . . . . . . . . . . . . .\
    \ . . . . . 148\n     B.6.  InvalidateRoutingState  . . . . . . . . . . . . .\
    \ . . . . 148\n   Appendix C.  Deployment Issues with Router Alert Options  .\
    \ . . . 149\n   Appendix D.  Example Routing State Table and Handshake  . . .\
    \ . . 151\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   Signalling involves the manipulation of state held in network\n\
    \   elements.  'Manipulation' could mean setting up, modifying, and\n   tearing\
    \ down state; or it could simply mean the monitoring of state\n   that is managed\
    \ by other mechanisms.  This specification concentrates\n   mainly on path-coupled\
    \ signalling, controlling resources on network\n   elements that are located on\
    \ the path taken by a particular data\n   flow, possibly including but not limited\
    \ to the flow endpoints.\n   Examples of state management include network resource\
    \ reservation,\n   firewall configuration, and state used in active networking;\
    \ examples\n   of state monitoring are the discovery of instantaneous path\n \
    \  properties, such as available bandwidth or cumulative queuing delay.\n   Each\
    \ of these different uses of signalling is referred to as a\n   signalling application.\n\
    \   GIST assumes other mechanisms are responsible for controlling routing\n  \
    \ within the network, and GIST is not designed to set up or modify\n   paths itself;\
    \ therefore, it is complementary to protocols like\n   Resource Reservation Protocol\
    \ - Traffic Engineering (RSVP-TE) [22] or\n   LDP [23] rather than an alternative.\
    \  There are almost always more\n   than two participants in a path-coupled signalling\
    \ session, although\n   there is no need for every node on the path to participate;\
    \ indeed,\n   support for GIST and any signalling applications imposes a\n   performance\
    \ cost, and deployment for flow-level signalling is much\n   more likely on edge\
    \ devices than core routers.  GIST path-coupled\n   signalling does not directly\
    \ support multicast flows, but the current\n   GIST design could be extended to\
    \ do so, especially in environments\n   where the multicast replication points\
    \ can be made GIST-capable.\n   GIST can also be extended to cover other types\
    \ of signalling pattern,\n   not related to any end-to-end flow in the network,\
    \ in which case the\n   distinction between GIST and end-to-end higher-layer signalling\
    \ will\n   be drawn differently or not at all.\n   Every signalling application\
    \ requires a set of state management\n   rules, as well as protocol support to\
    \ exchange messages along the\n   data path.  Several aspects of this protocol\
    \ support are common to\n   all or a large number of signalling applications,\
    \ and hence can be\n   developed as a common protocol.  The NSIS framework given\
    \ in [29]\n   provides a rationale for a function split between the common and\n\
    \   application-specific protocols, and gives outline requirements for\n   the\
    \ former, the NSIS Transport Layer Protocol (NTLP).  Several\n   concepts in the\
    \ framework are derived from RSVP [14], as are several\n   aspects of the GIST\
    \ protocol design.  The application-specific\n   protocols are referred to as\
    \ NSIS Signalling Layer Protocols (NSLPs),\n   and are defined in separate documents.\
    \  The NSIS framework [29] and\n   the accompanying threats document [30] provide\
    \ important background\n   information to this specification, including information\
    \ on how GIST\n   is expected to be used in various network types and what role\
    \ it is\n   expected to perform.\n   This specification provides a concrete solution\
    \ for the NTLP.  It is\n   based on the use of existing transport and security\
    \ protocols under a\n   common messaging layer, the General Internet Signalling\
    \ Transport\n   (GIST).  GIST does not handle signalling application state itself;\
    \ in\n   that crucial respect, it differs from higher layer signalling\n   protocols\
    \ such as SIP, the Real-time Streaming Protocol (RTSP), and\n   the control component\
    \ of FTP.  Instead, GIST manages its own internal\n   state and the configuration\
    \ of the underlying transport and security\n   protocols to ensure the transfer\
    \ of signalling messages on behalf of\n   signalling applications in both directions\
    \ along the flow path.  The\n   purpose of GIST is thus to provide the common\
    \ functionality of node\n   discovery, message routing, and message transport\
    \ in a way that is\n   simple for multiple signalling applications to re-use.\n\
    \   The structure of this specification is as follows.  Section 2 defines\n  \
    \ terminology, and Section 3 gives an informal overview of the protocol\n   design\
    \ principles and operation.  The normative specification is\n   contained mainly\
    \ in Section 4 to Section 8.  Section 4 describes the\n   message sequences and\
    \ Section 5 their format and contents.  Note that\n   the detailed bit formats\
    \ are given in Appendix A.  The protocol\n   operation is captured in the form\
    \ of state machines in Section 6.\n   Section 7 describes some more advanced protocol\
    \ features, and\n   security considerations are contained in Section 8.  In addition,\n\
    \   Appendix B describes an abstract API for the service that GIST\n   provides\
    \ to signalling applications, and Appendix D provides an\n   example message flow.\
    \  Parts of the GIST design use packets with IP\n   options to probe the network,\
    \ that leads to some migration issues in\n   the case of IPv4, and these are discussed\
    \ in Appendix C.\n   Because of the layered structure of the NSIS protocol suite,\
    \ protocol\n   extensions to cover a new signalling requirement could be carried\
    \ out\n   either within GIST, or within the signalling application layer, or\n\
    \   both.  General guidelines on how to extend different layers of the\n   protocol\
    \ suite, and in particular when and how it is appropriate to\n   extend GIST,\
    \ are contained in a separate document [12].  In this\n   document, Section 9\
    \ gives the formal IANA considerations for the\n   registries defined by the GIST\
    \ specification.\n"
- title: 2.  Requirements Notation and Terminology
  contents:
  - "2.  Requirements Notation and Terminology\n   The key words \"MUST\", \"MUST\
    \ NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\"\
    , \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this\n   document are to be interpreted\
    \ as described in RFC 2119 [3].\n   The terminology used in this specification\
    \ is defined in this\n   section.  The basic entities relevant at the GIST level\
    \ are shown in\n   Figure 1.  In particular, this diagram distinguishes the different\n\
    \   address types as being associated with a flow (end-to-end addresses)\n   or\
    \ signalling (addresses of adjacent signalling peers).\n   Source            \
    \     GIST (adjacent) peer nodes         Destination\n   IP address          \
    \    IP addresses = Signalling         IP address\n   = Flow                Source/Destination\
    \ Addresses        = Flow\n   Source             (depending on signalling direction)\
    \    Destination\n   Address                  |                   |          \
    \  Address\n                            V                   V\n   +--------+ \
    \          +------+  Data Flow  +------+         +--------+\n   |  Flow  |-----------|------|-------------|------|-------->|\
    \  Flow  |\n   | Sender |           |      |             |      |         |Receiver|\n\
    \   +--------+           | GIST |============>| GIST |         +--------+\n  \
    \                      | Node |<============| Node |\n                       \
    \ +------+  Signalling  +------+\n                          GN1       Flow   \
    \    GN2\n                  >>>>>>>>>>>>>>>>>  =  Downstream direction\n     \
    \             <<<<<<<<<<<<<<<<<  =  Upstream direction\n                     \
    \   Figure 1: Basic Terminology\n   [Data] Flow:  A set of packets identified\
    \ by some fixed combination\n      of header fields.  Flows are unidirectional;\
    \ a bidirectional\n      communication is considered a pair of unidirectional\
    \ flows.\n   Session:  A single application layer exchange of information for\n\
    \      which some state information is to be manipulated or monitored.\n     \
    \ See Section 3.7 for further detailed discussion.\n   Session Identifier (SID):\
    \  An identifier for a session; the syntax is\n      a 128-bit value that is opaque\
    \ to GIST.\n   [Flow] Sender:  The node in the network that is the source of the\n\
    \      packets in a flow.  A sender could be a host, or a router if, for\n   \
    \   example, the flow is actually an aggregate.\n   [Flow] Receiver:  The node\
    \ in the network that is the sink for the\n      packets in a flow.\n   Downstream:\
    \  In the same direction as the data flow.\n   Upstream:  In the opposite direction\
    \ to the data flow.\n   GIST Node:  Any node supporting the GIST protocol, regardless\
    \ of what\n      signalling applications it supports.\n   [Adjacent] Peer:  The\
    \ next node along the signalling path, in the\n      upstream or downstream direction,\
    \ with which a GIST node\n      explicitly interacts.\n   Querying Node:  The\
    \ GIST node that initiates the handshake process to\n      discover the adjacent\
    \ peer.\n   Responding Node:  The GIST node that responds to the handshake,\n\
    \      becoming the adjacent peer to the Querying node.\n   Datagram Mode (D-mode):\
    \  A mode of sending GIST messages between\n      nodes without using any transport\
    \ layer state or security\n      protection.  Datagram mode uses UDP encapsulation,\
    \ with source and\n      destination IP addresses derived either from the flow\
    \ definition\n      or previously discovered adjacency information.\n   Connection\
    \ Mode (C-mode):  A mode of sending GIST messages directly\n      between nodes\
    \ using point-to-point messaging associations (see\n      below).  Connection\
    \ mode allows the re-use of existing transport\n      and security protocols where\
    \ such functionality is required.\n   Messaging Association (MA):  A single connection\
    \ between two\n      explicitly identified GIST adjacent peers, i.e., between\
    \ a given\n      signalling source and destination address.  A messaging\n   \
    \   association may use a transport protocol; if security protection\n      is\
    \ required, it may use a network layer security association, or\n      use a transport\
    \ layer security association internally.  A\n      messaging association is bidirectional:\
    \ signalling messages can be\n      sent over it in either direction, referring\
    \ to flows of either\n      direction.\n   [Message] Routing:  Message routing\
    \ describes the process of\n      determining which is the next GIST peer along\
    \ the signalling path.\n      For signalling along a flow path, the message routing\
    \ carried out\n      by GIST is built on top of normal IP routing, that is, forwarding\n\
    \      packets within the network layer based on their destination IP\n      address.\
    \  In this document, the term 'routing' generally refers to\n      GIST message\
    \ routing unless particularly specified.\n   Message Routing Method (MRM):  There\
    \ can be different algorithms for\n      discovering the route that signalling\
    \ messages should take.  These\n      are referred to as message routing methods,\
    \ and GIST supports\n      alternatives within a common protocol framework.  See\
    \ Section 3.3.\n   Message Routing Information (MRI):  The set of data item values\
    \ that\n      is used to route a signalling message according to a particular\n\
    \      MRM; for example, for routing along a flow path, the MRI includes\n   \
    \   flow source and destination addresses, and protocol and port\n      numbers.\
    \  See Section 3.3.\n   Router Alert Option (RAO):  An option that can be included\
    \ in IPv4\n      and v6 headers to assist in the packet interception process;\
    \ see\n      [13] and [17].\n   Transfer Attributes:  A description of the requirements\
    \ that a\n      signalling application has for the delivery of a particular\n\
    \      message; for example, whether the message should be delivered\n      reliably.\
    \  See Section 4.1.2.\n"
- title: 3.  Design Overview
  contents:
  - '3.  Design Overview

    '
- title: 3.1.  Overall Design Approach
  contents:
  - "3.1.  Overall Design Approach\n   The generic requirements identified in the\
    \ NSIS framework [29] for\n   transport of signalling messages are essentially\
    \ two-fold:\n   Routing:  Determine how to reach the adjacent signalling node\
    \ along\n      each direction of the data path (the GIST peer), and if necessary\n\
    \      explicitly establish addressing and identity information about\n      that\
    \ peer;\n   Transport:  Deliver the signalling information to that peer.\n   To\
    \ meet the routing requirement, one possibility is for the node to\n   use local\
    \ routing state information to determine the identity of the\n   GIST peer explicitly.\
    \  GIST defines a three-way handshake that probes\n   the network to set up the\
    \ necessary routing state between adjacent\n   peers, during which signalling\
    \ applications can also exchange data.\n   Once the routing decision has been\
    \ made, the node has to select a\n   mechanism for transport of the message to\
    \ the peer.  GIST divides the\n   transport functionality into two parts, a minimal\
    \ capability provided\n   by GIST itself, with the use of well-understood transport\
    \ protocols\n   for the harder cases.  Here, with details discussed later, the\n\
    \   minimal capability is restricted to messages that are sized well\n   below\
    \ the lowest maximum transmission unit (MTU) along a path, are\n   infrequent\
    \ enough not to cause concerns about congestion and flow\n   control, and do not\
    \ need security protection or guaranteed delivery.\n   In [29], all of these routing\
    \ and transport requirements are assigned\n   to a single notional protocol, the\
    \ NSIS Transport Layer Protocol\n   (NTLP).  The strategy of splitting the transport\
    \ problem leads to a\n   layered structure for the NTLP, with a specialised GIST\
    \ messaging\n   layer running over standard transport and security protocols.\
    \  The\n   basic concept is shown in Figure 2.  Note that not every combination\n\
    \   of transport and security protocols implied by the figure is actually\n  \
    \ possible for use in GIST; the actual combinations allowed by this\n   specification\
    \ are defined in Section 5.7.  The figure also shows GIST\n   offering its services\
    \ to upper layers at an abstract interface, the\n   GIST API, further discussed\
    \ in Section 4.1.\n          ^^                      +-------------+\n       \
    \   ||                      |  Signalling |\n         NSIS        +------------|Application\
    \ 2|\n       Signalling    | Signalling +-------------+\n      Application   \
    \ |Application 1|         |\n         Level       +-------------+         |\n\
    \          ||             |                   |\n          VV             |  \
    \                 |\n                 ========|===================|=====  <--\
    \ GIST API\n                         |                   |\n          ^^     \
    \  +------------------------------------------------+\n          ||       |+-----------------------+\
    \      +--------------+ |\n          ||       ||         GIST          |     \
    \ | GIST State   | |\n          ||       ||     Encapsulation     |<<<>>>| Maintenance\
    \  | |\n          ||       |+-----------------------+      +--------------+ |\n\
    \          ||       | GIST: Messaging Layer                          |\n     \
    \     ||       +------------------------------------------------+\n         NSIS\
    \                 |       |       |       |\n       Transport      ..........................................\n\
    \         Level        . Transport Layer Security (TLS or DTLS) .\n        (NTLP)\
    \        ..........................................\n          ||            \
    \      |       |       |       |\n          ||                +----+  +----+ \
    \ +----+  +----+\n          ||                |UDP |  |TCP |  |SCTP|  |DCCP| ...\
    \ other\n          ||                +----+  +----+  +----+  +----+     protocols\n\
    \          ||                  |       |       |       |\n          ||       \
    \         .............................\n          ||                .     IP\
    \ Layer Security     .\n          ||                .............................\n\
    \          VV                  |       |       |       |\n   ===========================|=======|=======|=======|============\n\
    \                              |       |       |       |\n                   +----------------------------------------------+\n\
    \                   |                      IP                      |\n       \
    \            +----------------------------------------------+\n      Figure 2:\
    \ Protocol Stack Architecture for Signalling Transport\n"
- title: 3.2.  Modes and Messaging Associations
  contents:
  - "3.2.  Modes and Messaging Associations\n   Internally, GIST has two modes of\
    \ operation:\n   Datagram mode (D-mode):  used for small, infrequent messages\
    \ with\n      modest delay constraints and no security requirements.  A special\n\
    \      case of D-mode called Query-mode (Q-mode) is used when no routing\n   \
    \   state exists.\n   Connection mode (C-mode):  used for all other signalling\
    \ traffic.  In\n      particular, it can support large messages and channel security\
    \ and\n      provides congestion control for signalling traffic.\n   C-mode can\
    \ in principle use any stream or message-oriented transport\n   protocol; this\
    \ specification defines TCP as the initial choice.  It\n   can in principle employ\
    \ specific network layer security associations,\n   or an internal transport layer\
    \ security association; this\n   specification defines TLS as the initial choice.\
    \  When GIST messages\n   are carried in C-mode, they are treated just like any\
    \ other traffic\n   by intermediate routers between the GIST peers.  Indeed, it\
    \ would be\n   impossible for intermediate routers to carry out any processing\
    \ on\n   the messages without terminating the transport and security protocols\n\
    \   used.\n   D-mode uses UDP, as a suitable NAT-friendly encapsulation that does\n\
    \   not require per-message shared state to be maintained between the\n   peers.\
    \  Long-term evolution of GIST is assumed to preserve the\n   simplicity of the\
    \ current D-mode design.  Any extension to the\n   security or transport capabilities\
    \ of D-mode can be viewed as the\n   selection of a different protocol stack under\
    \ the GIST messaging\n   layer; this is then equivalent to defining another option\
    \ within the\n   overall C-mode framework.  This includes both the case of using\n\
    \   existing protocols and the specific development of a message exchange\n  \
    \ and payload encapsulation to support GIST requirements.\n   Alternatively, if\
    \ any necessary parameters (e.g., a shared secret for\n   use in integrity or\
    \ confidentiality protection) can be negotiated\n   out-of-band, then the additional\
    \ functions can be added directly to\n   D-mode by adding an optional object to\
    \ the message (see\n   Appendix A.2.1).  Note that in such an approach, downgrade\
    \ attacks as\n   discussed in Section 8.6 would need to be prevented by policy\
    \ at the\n   destination node.\n   It is possible to mix these two modes along\
    \ a path.  This allows, for\n   example, the use of D-mode at the edges of the\
    \ network and C-mode\n   towards the core.  Such combinations may make operation\
    \ more\n   efficient for mobile endpoints, while allowing shared security\n  \
    \ associations and transport connections to be used for messages for\n   multiple\
    \ flows and signalling applications.  The setup for these\n   protocols imposes\
    \ an initialisation cost for the use of C-mode, but\n   in the long term this\
    \ cost can be shared over all signalling sessions\n   between peers; once the\
    \ transport layer state exists, retransmission\n   algorithms can operate much\
    \ more aggressively than would be possible\n   in a pure D-mode design.\n   It\
    \ must be understood that the routing and transport functions within\n   GIST\
    \ are not independent.  If the message transfer has requirements\n   that require\
    \ C-mode, for example, if the message is so large that\n   fragmentation is required,\
    \ this can only be used between explicitly\n   identified nodes.  In such cases,\
    \ GIST carries out the three-way\n   handshake initially in D-mode to identify\
    \ the peer and then sets up\n   the necessary connections if they do not already\
    \ exist.  It must also\n   be understood that the signalling application does\
    \ not make the\n   D-mode/C-mode selection directly; rather, this decision is\
    \ made by\n   GIST on the basis of the message characteristics and the transfer\n\
    \   attributes stated by the application.  The distinction is not visible\n  \
    \ at the GIST service interface.\n   In general, the state associated with C-mode\
    \ messaging to a\n   particular peer (signalling destination address, protocol\
    \ and port\n   numbers, internal protocol configuration, and state information)\
    \ is\n   referred to as a messaging association (MA).  MAs are totally\n   internal\
    \ to GIST (they are not visible to signalling applications).\n   Although GIST\
    \ may be using an MA to deliver messages about a\n   particular flow, there is\
    \ no direct correspondence between them: the\n   GIST message routing algorithms\
    \ consider each message in turn and\n   select an appropriate MA to transport\
    \ it.  There may be any number of\n   MAs between two GIST peers although the\
    \ usual case is zero or one,\n   and they are set up and torn down by management\
    \ actions within GIST\n   itself.\n"
- title: 3.3.  Message Routing Methods
  contents:
  - "3.3.  Message Routing Methods\n   The baseline message routing functionality\
    \ in GIST is that signalling\n   messages follow a route defined by an existing\
    \ flow in the network,\n   visiting a subset of the nodes through which it passes.\
    \  This is the\n   appropriate behaviour for application scenarios where the purpose\
    \ of\n   the signalling is to manipulate resources for that flow.  However,\n\
    \   there are scenarios for which other behaviours are applicable.  Two\n   examples\
    \ are:\n   Predictive Routing:  Here, the intent is to signal along a path that\n\
    \      the data flow may follow in the future.  Possible cases are pre-\n    \
    \  installation of state on the backup path that would be used in the\n      event\
    \ of a link failure, and predictive installation of state on\n      the path that\
    \ will be used after a mobile node handover.\n   NAT Address Reservations:  This\
    \ applies to the case where a node\n      behind a NAT wishes to reserve an address\
    \ at which it can be\n      reached by a sender on the other side.  This requires\
    \ a message to\n      be sent outbound from what will be the flow receiver although\
    \ no\n      reverse routing state for the flow yet exists.\n   Most of the details\
    \ of GIST operation are independent of the routing\n   behaviour being used. \
    \ Therefore, the GIST design encapsulates the\n   routing-dependent details as\
    \ a message routing method (MRM), and\n   allows multiple MRMs to be defined.\
    \  This specification defines the\n   path-coupled MRM, corresponding to the baseline\
    \ functionality\n   described above, and a second (\"Loose-End\") MRM for the\
    \ NAT Address\n   Reservation case.  The detailed specifications are given in\n\
    \   Section 5.8.\n   The content of an MRM definition is as follows, using the\
    \ path-\n   coupled MRM as an example:\n   o  The format of the information that\
    \ describes the path that the\n      signalling should take, the Message Routing\
    \ Information (MRI).\n      For the path-coupled MRM, this is just the flow identifier\
    \ (see\n      Section 5.8.1.1) and some additional control information.\n    \
    \  Specifically, the MRI always includes a flag to distinguish\n      between\
    \ the two directions that signalling messages can take,\n      denoted 'upstream'\
    \ and 'downstream'.\n   o  A specification of the IP-level encapsulation of the\
    \ messages\n      which probe the network to discover the adjacent peers.  A\n\
    \      downstream encapsulation must be defined; an upstream\n      encapsulation\
    \ is optional.  For the path-coupled MRM, this\n      information is given in\
    \ Section 5.8.1.2 and Section 5.8.1.3.\n      Current MRMs rely on the interception\
    \ of probe messages in the\n      data plane, but other mechanisms are also possible\
    \ within the\n      overall GIST design and would be appropriate for other types\
    \ of\n      signalling pattern.\n   o  A specification of what validation checks\
    \ GIST should apply to the\n      probe messages, for example, to protect against\
    \ IP address\n      spoofing attacks.  The checks may be dependent on the direction\n\
    \      (upstream or downstream) of the message.  For the path-coupled\n      MRM,\
    \ the downstream validity check is basically a form of ingress\n      filtering,\
    \ also discussed in Section 5.8.1.2.\n   o  The mechanism(s) available for route\
    \ change detection, i.e., any\n      change in the neighbour relationships that\
    \ the MRM discovers.  The\n      default case for any MRM is soft-state refresh,\
    \ but additional\n      supporting techniques may be possible; see Section 7.1.2.\n\
    \   In addition, it should be noted that NAT traversal may require\n   translation\
    \ of fields in the MRI object carried in GIST messages (see\n   Section 7.2.2).\
    \  The generic MRI format includes a flag that must be\n   given as part of the\
    \ MRM definition, to indicate if some kind of\n   translation is necessary.  Development\
    \ of a new MRM therefore\n   includes updates to the GIST specification, and may\
    \ include updates\n   to specifications of NAT behaviour.  These updates may be\
    \ done in\n   separate documents as is the case for NAT traversal for the MRMs\
    \ of\n   the base GIST specification, as described in Section 7.2.3 and [44].\n\
    \   The MRI is passed explicitly between signalling applications and\n   GIST;\
    \ therefore, signalling application specifications must define\n   which MRMs\
    \ they require.  Signalling applications may use fields in\n   the MRI in their\
    \ packet classifiers; if they use additional\n   information for packet classification,\
    \ this would be carried at the\n   NSLP level and so would be invisible to GIST.\
    \  Any node hosting a\n   particular signalling application needs to use a GIST\
    \ implementation\n   that supports the corresponding MRMs.  The GIST processing\
    \ rules\n   allow nodes not hosting the signalling application to ignore messages\n\
    \   for it at the GIST level, so it does not matter if these nodes\n   support\
    \ the MRM or not.\n"
- title: 3.4.  GIST Messages
  contents:
  - "3.4.  GIST Messages\n   GIST has six message types: Query, Response, Confirm,\
    \ Data, Error,\n   and MA-Hello.  Apart from the invocation of the messaging association\n\
    \   protocols used by C-mode, all GIST communication consists of these\n   messages.\
    \  In addition, all signalling application data is carried as\n   additional payloads\
    \ in these messages, alongside the GIST\n   information.\n   The Query, Response,\
    \ and Confirm messages implement the handshake\n   that GIST uses to set up routing\
    \ state and messaging associations.\n   The handshake is initiated from the Querying\
    \ node towards the\n   Responding node.  The first message is the Query, which\
    \ is\n   encapsulated in a specific way depending on the message routing\n   method,\
    \ in order to probe the network infrastructure so that the\n   correct peer will\
    \ intercept it and become the Responding node.  A\n   Query always triggers a\
    \ Response in the reverse direction as the\n   second message of the handshake.\
    \  The content of the Response\n   controls whether a Confirm message is sent:\
    \ as part of the defence\n   against denial-of-service attacks, the Responding\
    \ node can delay\n   state installation until a return routability check has been\n\
    \   performed, and require the Querying node to complete the handshake\n   with\
    \ the Confirm message.  In addition, if the handshake is being\n   used to set\
    \ up a new MA, the Response is required to request a\n   Confirm.  All of these\
    \ three messages can optionally carry signalling\n   application data.  The handshake\
    \ is fully described in Section 4.4.1.\n   The Data message is used purely to\
    \ encapsulate and deliver signalling\n   application data.  Usually, it is sent\
    \ using pre-established routing\n   state.  However, if there are no security\
    \ or transport requirements\n   and no need for persistent reverse routing state,\
    \ it can also be sent\n   in the same way as the Query.  Finally, Error messages\
    \ are used to\n   indicate error conditions at the GIST level, and the MA-Hello\
    \ message\n   can be used as a diagnostic and keepalive for the messaging\n  \
    \ association protocols.\n"
- title: 3.5.  GIST Peering Relationships
  contents:
  - "3.5.  GIST Peering Relationships\n   Peering is the process whereby two GIST\
    \ nodes create message routing\n   states that point to each other.\n   A peering\
    \ relationship can only be created by a GIST handshake.\n   Nodes become peers\
    \ when one issues a Query and gets a Response from\n   another.  Issuing the initial\
    \ Query is a result of an NSLP request on\n   that node, and the Query itself\
    \ is formatted according to the rules\n   of the message routing method.  For\
    \ current MRMs, the identity of the\n   Responding node is not known explicitly\
    \ at the time the Query is\n   sent; instead, the message is examined by nodes\
    \ along the path until\n   one decides to send a Response, thereby becoming the\
    \ peer.  If the\n   node hosts the NSLP, local GIST and signalling application\
    \ policy\n   determine whether to peer; the details are given in Section 4.3.2.\n\
    \   Nodes not hosting the NSLP forward the Query transparently\n   (Section 4.3.4).\
    \  Note that the design of the Query message (see\n   Section 5.3.2) is such that\
    \ nodes have to opt-in specifically to\n   carry out the message interception\
    \ -- GIST-unaware nodes see the\n   Query as a normal data packet and so forward\
    \ it transparently.\n   An existing peering relationship can only be changed by\
    \ a new GIST\n   handshake; in other words, it can only change when routing state\
    \ is\n   refreshed.  On a refresh, if any of the factors in the original\n   peering\
    \ process have changed, the peering relationship can also\n   change.  As well\
    \ as network-level rerouting, changes could include\n   modifications to NSIS\
    \ signalling functions deployed at a node, or\n   alterations to signalling application\
    \ policy.  A change could cause\n   an existing node to drop out of the signalling\
    \ path, or a new node to\n   become part of it.  All these possibilities are handled\
    \ as rerouting\n   events by GIST; further details of the process are described\
    \ in\n   Section 7.1.\n"
- title: 3.6.  Effect on Internet Transparency
  contents:
  - "3.6.  Effect on Internet Transparency\n   GIST relies on routers inside the network\
    \ to intercept and process\n   packets that would normally be transmitted end-to-end.\
    \  This\n   processing may be non-transparent: messages may be forwarded with\n\
    \   modifications, or not forwarded at all.  This interception applies\n   only\
    \ to the encapsulation used for the Query messages that probe the\n   network,\
    \ for example, along a flow path; all other GIST messages are\n   handled only\
    \ by the nodes to which they are directly addressed, i.e.,\n   as normal Internet\
    \ traffic.\n   Because this interception potentially breaks Internet transparency\n\
    \   for packets that have nothing to do with GIST, the encapsulation used\n  \
    \ by GIST in this case (called Query-mode or Q-mode) has several\n   features\
    \ to avoid accidental collisions with other traffic:\n   o  Q-mode messages are\
    \ always sent as UDP traffic, and to a specific\n      well-known port (270) allocated\
    \ by IANA.\n   o  All GIST messages sent as UDP have a magic number as the first\
    \ 32-\n      bit word of the datagram payload.\n   Even if a node intercepts a\
    \ packet as potentially a GIST message,\n   unless it passes both these checks\
    \ it will be ignored at the GIST\n   level and forwarded transparently.  Further\
    \ discussion of the\n   reception process is in Section 4.3.1 and the encapsulation\
    \ in\n   Section 5.3.\n"
- title: 3.7.  Signalling Sessions
  contents:
  - "3.7.  Signalling Sessions\n   GIST requires signalling applications to associate\
    \ each of their\n   messages with a signalling session.  Informally, given an\
    \ application\n   layer exchange of information for which some network control\
    \ state\n   information is to be manipulated or monitored, the corresponding\n\
    \   signalling messages should be associated with the same session.\n   Signalling\
    \ applications provide the session identifier (SID) whenever\n   they wish to\
    \ send a message, and GIST reports the SID when a message\n   is received; on\
    \ messages forwarded at the GIST level, the SID is\n   preserved unchanged.  Usually,\
    \ NSLPs will preserve the SID value\n   along the entire signalling path, but\
    \ this is not enforced by or even\n   visible to GIST, which only sees the scope\
    \ of the SID as the single\n   hop between adjacent NSLP peers.\n   Most GIST\
    \ processing and state information is related to the flow\n   (defined by the\
    \ MRI; see above) and signalling application (given by\n   the NSLP identifier,\
    \ see below).  There are several possible\n   relationships between flows and\
    \ sessions, for example:\n   o  The simplest case is that all signalling messages\
    \ for the same\n      flow have the same SID.\n   o  Messages for more than one\
    \ flow may use the same SID, for example,\n      because one flow is replacing\
    \ another in a mobility or multihoming\n      scenario.\n   o  A single flow may\
    \ have messages for different SIDs, for example,\n      from independently operating\
    \ signalling applications.\n   Because of this range of options, GIST does not\
    \ perform any\n   validation on how signalling applications map between flows\
    \ and\n   sessions, nor does it perform any direct validation on the properties\n\
    \   of the SID itself, such as any enforcement of uniqueness.  GIST only\n   defines\
    \ the syntax of the SID as an opaque 128-bit identifier.\n   The SID assignment\
    \ has the following impact on GIST processing:\n   o  Messages with the same SID\
    \ that are to be delivered reliably\n      between the same GIST peers are delivered\
    \ in order.\n   o  All other messages are handled independently.\n   o  GIST identifies\
    \ routing state (upstream and downstream peer) by\n      the MRI/SID/NSLPID combination.\n\
    \   Strictly speaking, the routing state should not depend on the SID.\n   However,\
    \ if the routing state is keyed only by (MRI, NSLP), there is\n   a trivial denial-of-service\
    \ attack (see Section 8.3) where a\n   malicious off-path node asserts that it\
    \ is the peer for a particular\n   flow.  Such an attack would not redirect the\
    \ traffic but would\n   reroute the signalling.  Instead, the routing state is\
    \ also\n   segregated between different SIDs, which means that the attacking\n\
    \   node can only disrupt a signalling session if it can guess the\n   corresponding\
    \ SID.  Normative rules on the selection of SIDs are\n   given in Section 4.1.3.\n"
- title: 3.8.  Signalling Applications and NSLPIDs
  contents:
  - "3.8.  Signalling Applications and NSLPIDs\n   The functionality for signalling\
    \ applications is supported by NSIS\n   Signalling Layer Protocols (NSLPs).  Each\
    \ NSLP is identified by a\n   16-bit NSLP identifier (NSLPID), assigned by IANA\
    \ (Section 9).  A\n   single signalling application, such as resource reservation,\
    \ may\n   define a family of NSLPs to implement its functionality, for example,\n\
    \   to carry out signalling operations at different levels in a hierarchy\n  \
    \ (cf. [21]).  However, the interactions between the different NSLPs\n   (for\
    \ example, to relate aggregation levels or aggregation region\n   boundaries in\
    \ the resource management case) are handled at the\n   signalling application\
    \ level; the NSLPID is the only information\n   visible to GIST about the signalling\
    \ application being used.\n"
- title: 3.9.  GIST Security Services
  contents:
  - "3.9.  GIST Security Services\n   GIST has two distinct security goals:\n   o\
    \  to protect GIST state from corruption, and to protect the nodes on\n      which\
    \ it runs from resource exhaustion attacks; and\n   o  to provide secure transport\
    \ for NSLP messages to the signalling\n      applications.\n   The protocol mechanisms\
    \ to achieve the first goal are mainly internal\n   to GIST.  They include a cookie\
    \ exchange and return routability check\n   to protect the handshake that sets\
    \ up routing state, and a random SID\n   is also used to prevent off-path session\
    \ hijacking by SID guessing.\n   Further details are given in Section 4.1.3 and\
    \ Section 4.4.1, and the\n   overall security aspects are discussed in Section\
    \ 8.\n   A second level of protection is provided by the use of a channel\n  \
    \ security protocol in messaging associations (i.e., within C-mode).\n   This\
    \ mechanism serves two purposes: to protect against on-path\n   attacks on GIST\
    \ and to provide a secure channel for NSLP messages.\n   For the mechanism to\
    \ be effective, it must be able to provide the\n   following functions:\n   o\
    \  mutual authentication of the GIST peer nodes;\n   o  ability to verify the\
    \ authenticated identity against a database of\n      nodes authorised to take\
    \ part in GIST signalling;\n   o  confidentiality and integrity protection for\
    \ NSLP data, and\n      provision of the authenticated identities used to the\
    \ signalling\n      application.\n   The authorised peer database is described\
    \ in more detail in\n   Section 4.4.2, including the types of entries that it\
    \ can contain and\n   the authorisation checking algorithm that is used.  The\
    \ only channel\n   security protocol defined by this specification is a basic\
    \ use of\n   TLS, and Section 5.7.3 defines the TLS-specific aspects of how these\n\
    \   functions (for example, authentication and identity comparison) are\n   integrated\
    \ with the rest of GIST operation.  At a high level, there\n   are several alternative\
    \ protocols with similar functionality, and the\n   handshake (Section 4.4.1)\
    \ provides a mechanism within GIST to select\n   between them.  However, they\
    \ differ in their identity schemes and\n   authentication methods and dependencies\
    \ on infrastructure support for\n   the authentication process, and any GIST extension\
    \ to incorporate\n   them would need to define the details of the corresponding\n\
    \   interactions with GIST operation.\n"
- title: 3.10.  Example of Operation
  contents:
  - "3.10.  Example of Operation\n   This section presents an example of GIST usage\
    \ in a relatively simple\n   (in particular, NAT-free) signalling scenario, to\
    \ illustrate its main\n   features.\n               GN1                      \
    \                GN2\n          +------------+                           +------------+\n\
    \  NSLP    |            |                           |            |\n  Level  \
    \ | >>>>>>>>>1 |                           | 5>>>>>>>>5 |\n          | ^     \
    \   V |       Intermediate        | ^        V |\n          |-^--------2-|   \
    \       Routers          |-^--------V-|\n          | ^        V |            \
    \               | ^        V |\n          | ^        V |    +-----+     +-----+\
    \    | ^        V |\n  >>>>>>>>>>^        >3>>>>>>>>4>>>>>>>>>>>4>>>>>>>>>5  \
    \      5>>>>>>>>>\n          |            |    |     |     |     |    |      \
    \      |\n  GIST    |          6<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<6          |\n\
    \  Level   +------------+    +-----+     +-----+    +------------+\n         \
    \      >>>>>, <<<<< = Signalling messages\n               1 - 6        = Stages\
    \ in the example\n                              (stages 7 and 8 are not shown)\n\
    \                      Figure 3: Example of Operation\n   Consider the case of\
    \ an RSVP-like signalling application that makes\n   receiver-based resource reservations\
    \ for a single unicast flow.  In\n   general, signalling can take place along\
    \ the entire end-to-end path\n   (between flow source and destination), but the\
    \ role of GIST is only\n   to transfer signalling messages over a single segment\
    \ of the path,\n   between neighbouring resource-capable nodes.  Basic GIST operation\
    \ is\n   the same, whether it involves the endpoints or only interior nodes:\n\
    \   in either case, GIST is triggered by a request from a local\n   signalling\
    \ application.  The example here describes how GIST\n   transfers messages between\
    \ two adjacent peers some distance along the\n   path, GN1 and GN2 (see Figure\
    \ 3).  We take up the story at the point\n   where a message is being processed\
    \ above the GIST layer by the\n   signalling application in GN1.\n   1.  The signalling\
    \ application in GN1 determines that this message is\n       a simple description\
    \ of resources that would be appropriate for\n       the flow.  It determines\
    \ that it has no special security or\n       transport requirements for the message,\
    \ but simply that it should\n       be transferred to the next downstream signalling\
    \ application peer\n       on the path that the flow will take.\n   2.  The message\
    \ payload is passed to the GIST layer in GN1, along\n       with a definition\
    \ of the flow and description of the message\n       transfer attributes (in this\
    \ case, requesting no reliable\n       transmission or channel security protection).\
    \  GIST determines\n       that this particular message does not require fragmentation\
    \ and\n       that it has no knowledge of the next peer for this flow and\n  \
    \     signalling application; however, it also determines that this\n       application\
    \ is likely to require secured upstream and downstream\n       transport of large\
    \ messages in the future.  This determination is\n       a function of node-internal\
    \ policy interactions between GIST and\n       the signalling application.\n \
    \  3.  GN1 therefore constructs a GIST Query carrying the NSLP payload,\n    \
    \   and additional payloads at the GIST level which will be used to\n       initiate\
    \ a messaging association.  The Query is encapsulated in a\n       UDP datagram\
    \ and injected into the network.  At the IP level, the\n       destination address\
    \ is the flow receiver, and an IP Router Alert\n       Option (RAO) is also included.\n\
    \   4.  The Query passes through the network towards the flow receiver,\n    \
    \   and is seen by each router in turn.  GIST-unaware routers will\n       not\
    \ recognise the RAO value and will forward the message\n       unchanged; GIST-aware\
    \ routers that do not support the NSLP in\n       question will also forward the\
    \ message basically unchanged,\n       although they may need to process more\
    \ of the message to decide\n       this after initial interception.\n   5.  The\
    \ message is intercepted at GN2.  The GIST layer identifies the\n       message\
    \ as relevant to a local signalling application, and passes\n       the NSLP payload\
    \ and flow description upwards to it.  This\n       signalling application in\
    \ GN2 indicates to GIST that it will peer\n       with GN1 and so GIST should\
    \ proceed to set up any routing state.\n       In addition, the signalling application\
    \ continues to process the\n       message as in GN1 (compare step 1), passing\
    \ the message back down\n       to GIST so that it is sent further downstream,\
    \ and this will\n       eventually result in the message reaching the flow receiver.\n\
    \       GIST itself operates hop-by-hop, and the signalling application\n    \
    \   joins these hops together to manage the end-to-end signalling\n       operations.\n\
    \   6.  In parallel, the GIST instance in GN2 now knows that it should\n     \
    \  maintain routing state and a messaging association for future\n       signalling\
    \ with GN1.  This is recognised because the message is a\n       Query, and because\
    \ the local signalling application has indicated\n       that it will peer with\
    \ GN1.  There are two possible cases for\n       sending back the necessary GIST\
    \ Response:\n       6.A - Association Exists:  GN1 and GN2 already have an\n \
    \            appropriate MA.  GN2 simply records the identity of GN1 as\n    \
    \         its upstream peer for that flow and NSLP, and sends a\n            \
    \ Response back to GN1 over the MA identifying itself as the\n             peer\
    \ for this flow.\n       6.B - No Association:  GN2 sends the Response in D-mode\
    \ directly\n             to GN1, identifying itself and agreeing to the messaging\n\
    \             association setup.  The protocol exchanges needed to\n         \
    \    complete this will proceed in parallel with the following\n             stages.\n\
    \       In each case, the result is that GN1 and GN2 are now in a peering\n  \
    \     relationship for the flow.\n   7.  Eventually, another NSLP message works\
    \ its way upstream from the\n       receiver to GN2.  This message contains a\
    \ description of the\n       actual resources requested, along with authorisation\
    \ and other\n       security information.  The signalling application in GN2 passes\n\
    \       this payload to the GIST level, along with the flow definition\n     \
    \  and transfer attributes; in this case, it could request reliable\n       transmission\
    \ and use of a secure channel for integrity\n       protection.  (Other combinations\
    \ of attributes are possible.)\n   8.  The GIST layer in GN2 identifies the upstream\
    \ peer for this flow\n       and NSLP as GN1, and determines that it has an MA\
    \ with the\n       appropriate properties.  The message is queued on the MA for\n\
    \       transmission; this may incur some delay if the procedures begun\n    \
    \   in step 6.B have not yet completed.\n   Further messages can be passed in\
    \ each direction in the same way.\n   The GIST layer in each node can in parallel\
    \ carry out maintenance\n   operations such as route change detection (see Section\
    \ 7.1).\n   It should be understood that several of these details of GIST\n  \
    \ operations can be varied, either by local policy or according to\n   signalling\
    \ application requirements.  The authoritative details are\n   contained in the\
    \ remainder of this document.\n"
- title: 4.  GIST Processing Overview
  contents:
  - "4.  GIST Processing Overview\n   This section defines the basic structure and\
    \ operation of GIST.\n   Section 4.1 describes the way in which GIST interacts\
    \ with local\n   signalling applications in the form of an abstract service interface.\n\
    \   Section 4.2 describes the per-flow and per-peer state that GIST\n   maintains\
    \ for the purpose of transferring messages.  Section 4.3\n   describes how messages\
    \ are processed in the case where any necessary\n   messaging associations and\
    \ routing state already exist; this includes\n   the simple scenario of pure D-mode\
    \ operation, where no messaging\n   associations are necessary.  Finally, Section\
    \ 4.4 describes how\n   routing state and messaging associations are created and\
    \ managed.\n"
- title: 4.1.  GIST Service Interface
  contents:
  - "4.1.  GIST Service Interface\n   This section describes the interaction between\
    \ GIST and signalling\n   applications in terms of an abstract service interface,\
    \ including a\n   definition of the attributes of the message transfer that GIST\
    \ can\n   offer.  The service interface presented here is non-normative and\n\
    \   does not constrain actual implementations of any interface between\n   GIST\
    \ and signalling applications; the interface is provided to aid\n   understanding\
    \ of how GIST can be used.  However, requirements on SID\n   selection and internal\
    \ GIST behaviour to support message transfer\n   semantics (such as in-order delivery)\
    \ are stated normatively here.\n   The same service interface is presented at\
    \ every GIST node; however,\n   applications may invoke it differently at different\
    \ nodes, depending\n   for example on local policy.  In addition, the service\
    \ interface is\n   defined independently of any specific transport protocol, or\
    \ even the\n   distinction between D-mode and C-mode.  The initial version of\
    \ this\n   specification defines how to support the service interface using a\n\
    \   C-mode based on TCP; if additional protocol support is added, this\n   will\
    \ support the same interface and so the change will be invisible\n   to applications,\
    \ except as a possible performance improvement.  A\n   more detailed description\
    \ of this service interface is given in\n   Appendix B.\n"
- title: 4.1.1.  Message Handling
  contents:
  - "4.1.1.  Message Handling\n   Fundamentally, GIST provides a simple message-by-message\
    \ transfer\n   service for use by signalling applications: individual messages\
    \ are\n   sent, and individual messages are received.  At the service\n   interface,\
    \ the NSLP payload, which is opaque to GIST, is accompanied\n   by control information\
    \ expressing the application's requirements\n   about how the message should be\
    \ routed (the MRI), and the application\n   also provides the session identifier\
    \ (SID); see Section 4.1.3.\n   Additional message transfer attributes control\
    \ the specific transport\n   and security properties that the signalling application\
    \ desires.\n   The distinction between GIST D- and C-mode is not visible at the\n\
    \   service interface.  In addition, the functionality to handle\n   fragmentation\
    \ and reassembly, bundling together of small messages for\n   efficiency, and\
    \ congestion control are not visible at the service\n   interface; GIST will take\
    \ whatever action is necessary based on the\n   properties of the messages and\
    \ local node state.\n   A signalling application is free to choose the rate at\
    \ which it\n   processes inbound messages; an implementation MAY allow the\n \
    \  application to block accepting messages from GIST.  In these\n   circumstances,\
    \ GIST MAY discard unreliably delivered messages, but\n   for reliable messages\
    \ MUST propagate flow-control condition back to\n   the sender.  Therefore, applications\
    \ must be aware that they may in\n   turn be blocked from sending outbound messages\
    \ themselves.\n"
- title: 4.1.2.  Message Transfer Attributes
  contents:
  - "4.1.2.  Message Transfer Attributes\n   Message transfer attributes are used\
    \ by NSLPs to define minimum\n   required levels of message processing.  The attributes\
    \ available are\n   as follows:\n   Reliability:  This attribute may be 'true'\
    \ or 'false'.  When 'true',\n      the following rules apply:\n      *  messages\
    \ MUST be delivered to the signalling application in the\n         peer exactly\
    \ once or not at all;\n      *  for messages with the same SID, the delivery MUST\
    \ be in order;\n      *  if there is a chance that the message was not delivered\
    \ (e.g.,\n         in the case of a transport layer error), an error MUST be\n\
    \         indicated to the local signalling application identifying the\n    \
    \     routing information for the message in question.\n      GIST implements\
    \ reliability by using an appropriate transport\n      protocol within a messaging\
    \ association, so mechanisms for the\n      detection of message loss depend on\
    \ the protocol in question; for\n      the current specification, the case of\
    \ TCP is considered in\n      Section 5.7.2.  When 'false', a message may be delivered,\
    \ once,\n      several times, or not at all, with no error indications in any\
    \ of\n      these cases.\n   Security:  This attribute defines the set of security\
    \ properties that\n      the signalling application requires for the message,\
    \ including the\n      type of protection required, and what authenticated identities\n\
    \      should be used for the signalling source and destination.  This\n     \
    \ information maps onto the corresponding properties of the security\n      associations\
    \ established between the peers in C-mode.  Keying\n      material for the security\
    \ associations is established by the\n      authentication mechanisms within the\
    \ messaging association\n      protocols themselves; see Section 8.2.  The attribute\
    \ can be\n      specified explicitly by the signalling application, or reported\
    \ by\n      GIST to the signalling application.  The latter can take place\n \
    \     either on receiving a message, or just before sending a message\n      but\
    \ after configuring or selecting the messaging association to be\n      used for\
    \ it.\n      This attribute can also be used to convey information about any\n\
    \      address validation carried out by GIST, such as whether a return\n    \
    \  routability check has been carried out.  Further details are\n      discussed\
    \ in Appendix B.\n   Local Processing:  An NSLP may provide hints to GIST to enable\
    \ more\n      efficient or appropriate processing.  For example, the NSLP may\n\
    \      select a priority from a range of locally defined values to\n      influence\
    \ the sequence in which messages leave a node.  Any\n      priority mechanism\
    \ MUST respect the ordering requirements for\n      reliable messages within a\
    \ session, and priority values are not\n      carried in the protocol or available\
    \ at the signalling peer or\n      intermediate nodes.  An NSLP may also indicate\
    \ that upstream path\n      routing state will not be needed for this flow, to\
    \ inhibit the\n      node requesting its downstream peer to create it; conversely,\
    \ even\n      if routing state exists, the NSLP may request that it is not used,\n\
    \      which will lead to GIST Data messages being sent Q-mode\n      encapsulated\
    \ instead.\n   A GIST implementation MAY deliver messages with stronger attribute\n\
    \   values than those explicitly requested by the application.\n"
- title: 4.1.3.  SID Selection
  contents:
  - "4.1.3.  SID Selection\n   The fact that SIDs index routing state (see Section\
    \ 4.2.1 below)\n   means that there are requirements for how they are selected.\n\
    \   Specifically, signalling applications MUST choose SIDs so that they\n   are\
    \ cryptographically random, and SHOULD NOT use several SIDs for the\n   same flow,\
    \ to avoid additional load from routing state maintenance.\n   Guidance on secure\
    \ randomness generation can be found in [31].\n"
- title: 4.2.  GIST State
  contents:
  - '4.2.  GIST State

    '
- title: 4.2.1.  Message Routing State
  contents:
  - "4.2.1.  Message Routing State\n   For each flow, the GIST layer can maintain\
    \ message routing state to\n   manage the processing of outgoing messages.  This\
    \ state is\n   conceptually organised into a table with the following structure.\n\
    \   Each row in the table corresponds to a unique combination of the\n   following\
    \ three items:\n   Message Routing Information (MRI):  This defines the method\
    \ to be\n      used to route the message, the direction in which to send the\n\
    \      message, and any associated addressing information; see\n      Section\
    \ 3.3.\n   Session Identifier (SID):  The signalling session with which this\n\
    \      message should be associated; see Section 3.7.\n   NSLP Identifier (NSLPID):\
    \  This is an IANA-assigned identifier\n      associated with the NSLP that is\
    \ generating messages for this\n      flow; see Section 3.8.  The inclusion of\
    \ this identifier allows\n      the routing state to be different for different\
    \ NSLPs.\n   The information associated with a given MRI/SID/NSLPID combination\n\
    \   consists of the routing state to reach the peer in the direction\n   given\
    \ by the MRI.  For any flow, there will usually be two entries in\n   the table,\
    \ one each for the upstream and downstream MRI.  The routing\n   state includes\
    \ information about the peer identity (see\n   Section 4.4.3), and a UDP port\
    \ number for D-mode, or a reference to\n   one or more MAs for C-mode.  Entries\
    \ in the routing state table are\n   created by the GIST handshake, which is described\
    \ in more detail in\n   Section 4.4.\n   It is also possible for the state information\
    \ for either direction to\n   be empty.  There are several possible cases:\n \
    \  o  The signalling application has indicated that no messages will\n      actually\
    \ be sent in that direction.\n   o  The node is the endpoint of the signalling\
    \ path, for example,\n      because it is acting as a proxy, or because it has\
    \ determined that\n      there are no further signalling nodes in that direction.\n\
    \   o  The node is using other techniques to route the message.  For\n      example,\
    \ it can send it in Q-mode and rely on the peer to\n      intercept it.\n   In\
    \ particular, if the node is a flow endpoint, GIST will refuse to\n   create routing\
    \ state for the direction beyond the end of the flow\n   (see Section 4.3.3).\
    \  Each entry in the routing state table has an\n   associated validity timer\
    \ indicating for how long it can be\n   considered accurate.  When this timer\
    \ expires, the entry MUST be\n   purged if it has not been refreshed.  Installation\
    \ and maintenance of\n   routing state are described in more detail in Section\
    \ 4.4.\n"
- title: 4.2.2.  Peer-Peer Messaging Association State
  contents:
  - "4.2.2.  Peer-Peer Messaging Association State\n   The per-flow message routing\
    \ state is not the only state stored by\n   GIST.  There is also the state required\
    \ to manage the MAs.  Since\n   these are not per-flow, they are stored separately\
    \ from the routing\n   state, including the following per-MA information:\n  \
    \ o  a queue of any messages that require the use of an MA, pending\n      transmission\
    \ while the MA is being established;\n   o  the time since the peer re-stated\
    \ its desire to keep the MA open\n      (see Section 4.4.5).\n   In addition,\
    \ per-MA state, such as TCP port numbers or timer\n   information, is held in\
    \ the messaging association protocols\n   themselves.  However, the details of\
    \ this state are not directly\n   visible to GIST, and they do not affect the\
    \ rest of the protocol\n   description.\n"
- title: 4.3.  Basic GIST Message Processing
  contents:
  - "4.3.  Basic GIST Message Processing\n   This section describes how signalling\
    \ application messages are\n   processed in the case where any necessary messaging\
    \ associations and\n   routing state are already in place.  The description is\
    \ divided into\n   several parts.  First, message reception, local processing,\
    \ and\n   message transmission are described for the case where the node hosts\n\
    \   the NSLPID identified in the message.  Second, in Section 4.3.4, the\n   case\
    \ where the message is handled directly in the IP or GIST layer\n   (because there\
    \ is no matching signalling application on the node) is\n   given.  An overview\
    \ is given in Figure 4.  This section concentrates\n   on the GIST-level processing,\
    \ with full details of IP and transport\n   layer encapsulation in Section 5.3\
    \ and Section 5.4.\n       +---------------------------------------------------------+\n\
    \       |        >>  Signalling Application Processing   >>       |\n       |\
    \                                                         |\n       +--------^---------------------------------------V--------+\n\
    \                ^ NSLP                             NSLP V\n                ^\
    \ Payloads                     Payloads V\n       +--------^---------------------------------------V--------+\n\
    \       |                    >>    GIST    >>                     |\n       |\
    \  ^           ^  ^     Processing      V  V           V  |\n       +--x-----------N--Q---------------------Q--N-----------x--+\n\
    \          x           N  Q                     Q  N           x\n          x\
    \           N  Q>>>>>>>>>>>>>>>>>>>>>Q  N           x\n          x           N\
    \  Q      Bypass at      Q  N           x\n       +--x-----+  +--N--Q--+  GIST\
    \ level   +--Q--N--+  +-----x--+\n       | C-mode |  | D-mode |              \
    \ | D-mode |  | C-mode |\n       |Handling|  |Handling|               |Handling|\
    \  |Handling|\n       +--x-----+  +--N--Q--+               +--Q--N--+  +-----x--+\n\
    \          x          N   Q                     Q   N          x\n          x\
    \    NNNNNN    Q>>>>>>>>>>>>>>>>>>>>>Q    NNNNNN    x\n          x   N       \
    \   Q      Bypass at      Q          N   x\n       +--x--N--+  +-----Q--+  IP\
    \ (router   +--Q-----+  +--N--x--+\n       |IP Host |  | Q-mode |  alert) level\
    \ | Q-mode |  |IP Host |\n       |Handling|  |Handling|               |Handling|\
    \  |Handling|\n       +--x--N--+  +-----Q--+               +--Q-----+  +--N--x--+\n\
    \          x  N           Q                     Q           N  x\n       +--x--N-----------Q--+\
    \               +--Q-----------N--x--+\n       |      IP Layer      |        \
    \       |      IP Layer      |\n       |   (Receive Side)   |               |\
    \  (Transmit Side)   |\n       +--x--N-----------Q--+               +--Q-----------N--x--+\n\
    \          x  N           Q                     Q           N  x\n          x\
    \  N           Q                     Q           N  x\n        NNNNNNNNNNNNNN\
    \ = Normal D-mode messages\n        QQQQQQQQQQQQQQ = D-mode messages that are\
    \ Q-mode encapsulated\n        xxxxxxxxxxxxxx = C-mode messages\n            \
    \           RAO = Router Alert Option\n                Figure 4: Message Paths\
    \ through a GIST Node\n"
- title: 4.3.1.  Message Reception
  contents:
  - "4.3.1.  Message Reception\n   Messages can be received in C-mode or D-mode.\n\
    \   Reception in C-mode is simple: incoming packets undergo the security\n   and\
    \ transport treatment associated with the MA, and the MA provides\n   complete\
    \ messages to the GIST layer for further processing.\n   Reception in D-mode depends\
    \ on the message type.\n   Normal encapsulation:  Normal messages arrive UDP-encapsulated\
    \ and\n      addressed directly to the receiving signalling node, at an address\n\
    \      and port learned previously.  Each datagram contains a single\n      message,\
    \ which is passed to the GIST layer for further processing,\n      just as in\
    \ the C-mode case.\n   Q-mode encapsulation:  Where GIST is sending messages to\
    \ be\n      intercepted by the appropriate peer rather than directly addressed\n\
    \      to it (in particular, Query messages), these are UDP encapsulated,\n  \
    \    and MAY include an IP Router Alert Option (RAO) if required by the\n    \
    \  MRM.  Each GIST node can therefore see every such message, but\n      unless\
    \ the message exactly matches the Q-mode encapsulation rules\n      (Section 5.3.2)\
    \ it MUST be forwarded transparently at the IP\n      level.  If it does match,\
    \ GIST MUST check the NSLPID in the common\n      header.  The case where the\
    \ NSLPID does not match a local\n      signalling application at all is considered\
    \ below in\n      Section 4.3.4; otherwise, the message MUST be passed up to the\n\
    \      GIST layer for further processing.\n   Several different RAO values may\
    \ be used by the NSIS protocol suite.\n   GIST itself does not allocate any RAO\
    \ values (for either IPv4 or\n   IPv6); an assignment is made for each NSLP using\
    \ MRMs that use the\n   RAO in the Q-mode encapsulation.  The assignment rationale\
    \ is\n   discussed in a separate document [12].  The RAO value assigned for an\n\
    \   NSLPID may be different for IPv4 and IPv6.  Note the different\n   significance\
    \ between the RAO and the NSLPID values: the meaning of a\n   message (which signalling\
    \ application it refers to, whether it should\n   be processed at a node) is determined\
    \ only from the NSLPID; the role\n   of the RAO value is simply to allow nodes\
    \ to pre-filter which IP\n   datagrams are analysed to see if they might be Q-mode\
    \ GIST messages.\n   For all assignments associated with NSIS, the RAO-specific\
    \ processing\n   is the same and is as defined by this specification, here and\
    \ in\n   Section 4.3.4 and Section 5.3.2.\n   Immediately after reception, the\
    \ GIST hop count is checked.  Any\n   message with a GIST hop count of zero MUST\
    \ be rejected with a \"Hop\n   Limit Exceeded\" error message (Appendix A.4.4.2);\
    \ note that a correct\n   GIST implementation will never send a message with a\
    \ GIST hop count\n   of zero.  Otherwise, the GIST hop count MUST be decremented\
    \ by one\n   before the next stage.\n"
- title: 4.3.2.  Local Processing and Validation
  contents:
  - "4.3.2.  Local Processing and Validation\n   Once a message has been received,\
    \ it is processed locally within the\n   GIST layer.  Further processing depends\
    \ on the message type and\n   payloads carried; most of the GIST payloads are\
    \ associated with\n   internal state maintenance, and details are covered in Section\
    \ 4.4.\n   This section concentrates on the interaction with the signalling\n\
    \   application, in particular, the decision to peer and how data is\n   delivered\
    \ to the NSLP.\n   In the case of a Query, there is an interaction with the signalling\n\
    \   application to determine which of two courses to follow.  The first\n   option\
    \ (peering) MUST be chosen if the node is the final destination\n   of the Query\
    \ message.\n   1.  The receiving signalling application wishes to become a\n \
    \      signalling peer with the Querying node.  GIST MUST continue with\n    \
    \   the handshake process to set up message routing state, as\n       described\
    \ in Section 4.4.1.  The application MAY provide an NSLP\n       payload for the\
    \ same NSLPID, which GIST will transfer in the\n       Response.\n   2.  The signalling\
    \ application does not wish to set up state with the\n       Querying node and\
    \ become its peer.  This includes the case where\n       a node wishes to avoid\
    \ taking part in the signalling for overload\n       protection reasons.  GIST\
    \ MUST propagate the Query, similar to\n       the case described in Section 4.3.4.\
    \  No message is sent back to\n       the Querying node.  The application MAY\
    \ provide an updated NSLP\n       payload for the same NSLPID, which will be used\
    \ in the Query\n       forwarded by GIST.  Note that if the node that finally\
    \ processes\n       the Query returns an Error message, this will be sent directly\n\
    \       back to the originating node, bypassing any forwarders.  For\n       these\
    \ diagnostics to be meaningful, any GIST node forwarding a\n       Query, or relaying\
    \ it with modified NSLP payload, MUST NOT modify\n       it except in the GIST\
    \ hop count; in particular, it MUST NOT\n       modify any other GIST payloads\
    \ or their order.  An implementation\n       MAY choose to achieve this by retaining\
    \ the original message,\n       rather than reconstructing it from some parsed\
    \ internal\n       representation.\n   This interaction with the signalling application,\
    \ including the\n   generation or update of an NSLP payload, SHOULD take place\n\
    \   synchronously as part of the Query processing.  In terms of the GIST\n   service\
    \ interface, this can be implemented by providing appropriate\n   return values\
    \ for the primitive that is triggered when such a message\n   is received; see\
    \ Appendix B.2 for further discussion.\n   For all GIST message types other than\
    \ Queries, if the message\n   includes an NSLP payload, this MUST be delivered\
    \ locally to the\n   signalling application identified by the NSLPID.  The format\
    \ of the\n   payload is not constrained by GIST, and the content is not\n   interpreted.\
    \  Delivery is subject to the following validation checks,\n   which MUST be applied\
    \ in the sequence given:\n   1.  if the message was explicitly routed (see Section\
    \ 7.1.5) or is a\n       Data message delivered without routing state (see Section\
    \ 5.3.2),\n       the payload is delivered but flagged to the receiving NSLP to\n\
    \       indicate that routing state was not validated;\n   2.  else, if the message\
    \ arrived on an association that is not\n       associated with the MRI/NSLPID/SID\
    \ combination given in the\n       message, the message MUST be rejected with\
    \ an \"Incorrectly\n       Delivered Message\" error message (Appendix A.4.4.4);\n\
    \   3.  else, if there is no routing state for this MRI/SID/NSLPID\n       combination,\
    \ the message MUST either be dropped or be rejected\n       with an error message\
    \ (see Section 4.4.6 for further details);\n   4.  else, the payload is delivered\
    \ as normal.\n"
- title: 4.3.3.  Message Transmission
  contents:
  - "4.3.3.  Message Transmission\n   Signalling applications can generate their messages\
    \ for transmission,\n   either asynchronously or in reply to an input message\
    \ delivered by\n   GIST, and GIST can also generate messages autonomously.  GIST\
    \ MUST\n   verify that it is not the direct destination of an outgoing message,\n\
    \   and MUST reject such messages with an error indication to the\n   signalling\
    \ application.  When the message is generated by a\n   signalling application,\
    \ it may be carried in a Query if local policy\n   and the message transfer attributes\
    \ allow it; otherwise, this may\n   trigger setup of an MA over which the NSLP\
    \ payload is sent in a Data\n   message.\n   Signalling applications may specify\
    \ a value to be used for the GIST\n   hop count; otherwise, GIST selects a value\
    \ itself.  GIST MUST reject\n   messages for which the signalling application\
    \ has specified a value\n   of zero.  Although the GIST hop count is only intended\
    \ to control\n   message looping at the GIST level, the GIST API (Appendix B)\
    \ provides\n   the incoming hop count to the NSLPs, which can preserve it on\n\
    \   outgoing messages as they are forwarded further along the path.  This\n  \
    \ provides a lightweight loop-control mechanism for NSLPs that do not\n   define\
    \ anything more sophisticated.  Note that the count will be\n   decremented on\
    \ forwarding through every GIST-aware node.  Initial\n   values for the GIST hop\
    \ count are an implementation matter; one\n   suitable approach is to use the\
    \ same algorithm as for IP TTL setting\n   [1].\n   When a message is available\
    \ for transmission, GIST uses internal\n   policy and the stored routing state\
    \ to determine how to handle it.\n   The following processing applies equally\
    \ to locally generated\n   messages and messages forwarded from within the GIST\
    \ or signalling\n   application levels.  However, see Section 5.6 for special\
    \ rules\n   applying to the transmission of Error messages by GIST.\n   The main\
    \ decision is whether the message must be sent in C-mode or\n   D-mode.  Reasons\
    \ for using C-mode are:\n   o  message transfer attributes: for example, the signalling\n\
    \      application has specified security attributes that require\n      channel-secured\
    \ delivery, or reliable delivery.\n   o  message size: a message whose size (including\
    \ the GIST header,\n      GIST objects and any NSLP payload, and an allowance\
    \ for the IP and\n      transport layer encapsulation required by D-mode) exceeds\
    \ a\n      fragmentation-related threshold MUST be sent over C-mode, using a\n\
    \      messaging association that supports fragmentation and reassembly\n    \
    \  internally.  The allowance for IP and transport layer\n      encapsulation\
    \ is 64 bytes.  The message size MUST NOT exceed the\n      Path MTU to the next\
    \ peer, if this is known.  If this is not\n      known, the message size MUST\
    \ NOT exceed the least of the first-hop\n      MTU, and 576 bytes.  The same limit\
    \ applies to IPv4 and IPv6.\n   o  congestion control: D-mode SHOULD NOT be used\
    \ for signalling where\n      it is possible to set up routing state and use C-mode,\
    \ unless the\n      network can be engineered to guarantee capacity for D-mode\
    \ traffic\n      within the rate control limits imposed by GIST (see\n      Section\
    \ 5.3.3).\n   In principle, as well as determining that some messaging association\n\
    \   must be used, GIST MAY select between a set of alternatives, e.g.,\n   for\
    \ load sharing or because different messaging associations provide\n   different\
    \ transport or security attributes.  For the case of reliable\n   delivery, GIST\
    \ MUST NOT distribute messages for the same session over\n   multiple messaging\
    \ associations in parallel, but MUST use a single\n   association at any given\
    \ time.  The case of moving over to a new\n   association is covered in Section\
    \ 4.4.5.\n   If the use of a messaging association (i.e., C-mode) is selected,\
    \ the\n   message is queued on the association found from the routing state\n\
    \   table, and further output processing is carried out according to the\n   details\
    \ of the protocol stacks used.  If no appropriate association\n   exists, the\
    \ message is queued while one is created (see\n   Section 4.4.1), which will trigger\
    \ the exchange of additional GIST\n   messages.  If no association can be created,\
    \ this is an error\n   condition, and should be indicated back to the local signalling\n\
    \   application.\n   If a messaging association is not appropriate, the message\
    \ is sent in\n   D-mode.  The processing in this case depends on the message type,\n\
    \   local policy, and whether or not routing state exists.\n   o  If the message\
    \ is not a Query, and local policy does not request\n      the use of Q-mode for\
    \ this message, and routing state exists, it\n      is sent with the normal D-mode\
    \ encapsulation directly to the\n      address from the routing state table.\n\
    \   o  If the message is a Query, or the message is Data and local policy\n  \
    \    as given by the message transfer attributes requests the use of\n      Q-mode,\
    \ then it is sent in Q-mode as defined in Section 5.3.2; the\n      details depend\
    \ on the message routing method.\n   o  If no routing state exists, GIST can attempt\
    \ to use Q-mode as in\n      the Query case: either sending a Data message with\
    \ the Q-mode\n      encapsulation or using the event as a trigger for routing\
    \ state\n      setup (see Section 4.4).  If this is not possible, e.g., because\n\
    \      the encapsulation for the MRM is only defined for one message\n      direction,\
    \ then this is an error condition that is reported back\n      to the local signalling\
    \ application.\n"
- title: 4.3.4.  Nodes not Hosting the NSLP
  contents:
  - "4.3.4.  Nodes not Hosting the NSLP\n   A node may receive messages where it has\
    \ no signalling application\n   corresponding to the message NSLPID.  There are\
    \ several possible\n   cases depending mainly on the encapsulation:\n   1.  A\
    \ message contains an RAO value that is relevant to NSIS, but it\n       does\
    \ not exactly match the Q-mode encapsulation rules of\n       Section 5.3.2. \
    \ The message MUST be transparently forwarded at\n       the IP layer.  See Section\
    \ 3.6.\n   2.  A Q-mode encapsulated message contains an RAO value that has been\n\
    \       assigned to some NSIS signalling application but that is not used\n  \
    \     on this specific node, but the IP layer is unable to distinguish\n     \
    \  whether it needs to be passed to GIST for further processing or\n       whether\
    \ the packet should be forwarded just like a normal IP\n       datagram.\n   3.\
    \  A Q-mode encapsulated message contains an RAO value that has been\n       assigned\
    \ to an NSIS signalling application that is used on this\n       node, but the\
    \ signalling application does not process the NSLPID\n       in the message. \
    \ (This covers the case where a signalling\n       application uses a set of NSLPIDs.)\n\
    \   4.  A directly addressed message (in D-mode or C-mode) is delivered\n    \
    \   to a node for which there is no corresponding signalling\n       application.\
    \  With the current specification, this should not\n       happen in normal operation.\
    \  While future versions might find a\n       use for such a feature, currently\
    \ this MUST cause an \"Unknown\n       NSLPID\" error message (Appendix A.4.4.6).\n\
    \   5.  A Q-mode encapsulated message arrives at the end-system that does\n  \
    \     not handle the signalling application.  This is possible in\n       normal\
    \ operation, and MUST be indicated to the sender with an\n       \"Endpoint Found\"\
    \ informational message (Appendix A.4.4.7).  The\n       end-system includes the\
    \ MRI and SID from the original message in\n       the error message without interpreting\
    \ them.\n   6.  The node is a GIST-aware NAT.  See Section 7.2.\n   In case (2)\
    \ and (3), the role of GIST is to forward the message\n   essentially as though\
    \ it were a normal IP datagram, and it will not\n   become a peer to the node\
    \ sending the message.  Forwarding with\n   modified NSLP payloads is covered\
    \ above in Section 4.3.2.  However, a\n   GIST implementation MUST ensure that\
    \ the IP-layer TTL field and GIST\n   hop count are managed correctly to prevent\
    \ message looping, and this\n   should be done consistently independently of where\
    \ in the packet\n   processing path the decision is made.  The rules are that\
    \ in cases\n   (2) and (3), the IP-layer TTL MUST be decremented just as if the\n\
    \   message was a normal IP forwarded packet.  In case (3), the GIST hop\n   count\
    \ MUST be decremented as in the case of normal input processing,\n   which also\
    \ applies to cases (4) and (5).\n   A GIST node processing Q-mode encapsulated\
    \ messages in this way\n   SHOULD make the routing decision based on the full\
    \ contents of the\n   MRI and not only the IP destination address.  It MAY also\
    \ apply a\n   restricted set of sanity checks and under certain conditions return\n\
    \   an error message rather than forward the message.  These conditions\n   are:\n\
    \   1.  The message is so large that it would be fragmented on downstream\n  \
    \     links, for example, because the downstream MTU is abnormally\n       small\
    \ (less than 576 bytes).  The error \"Message Too Large\"\n       (Appendix A.4.4.8)\
    \ SHOULD be returned to the sender, which SHOULD\n       begin messaging association\
    \ setup.\n   2.  The GIST hop count has reached zero.  The error \"Hop Limit\n\
    \       Exceeded\" (Appendix A.4.4.2) SHOULD be returned to the sender,\n    \
    \   which MAY retry with a larger initial hop count.\n   3.  The MRI represents\
    \ a flow definition that is too general to be\n       forwarded along a unique\
    \ path (e.g., the destination address\n       prefix is too short).  The error\
    \ \"MRI Validation Failure\"\n       (Appendix A.4.4.12) with subcode 0 (\"MRI\
    \ Too Wild\") SHOULD be\n       returned to the sender, which MAY retry with restricted\
    \ MRIs,\n       possibly starting additional signalling sessions to do so.  If\n\
    \       the GIST node does not understand the MRM in question, it MUST\n     \
    \  NOT apply this check, instead forwarding the message\n       transparently.\n\
    \   In the first two cases, only the common header of the GIST message is\n  \
    \ examined; in the third case, the MRI is also examined.  The rest of\n   the\
    \ message MUST NOT be inspected in any case.  Similar to the case\n   of Section\
    \ 4.3.2, the GIST payloads MUST NOT be modified or re-\n   ordered; an implementation\
    \ MAY choose to achieve this by retaining\n   the original message, rather than\
    \ reconstructing it from some parsed\n   internal representation.\n"
- title: 4.4.  Routing State and Messaging Association Maintenance
  contents:
  - "4.4.  Routing State and Messaging Association Maintenance\n   The main responsibility\
    \ of GIST is to manage the routing state and\n   messaging associations that are\
    \ used in the message processing\n   described above.  Routing state is installed\
    \ and refreshed by GIST\n   handshake messages.  Messaging associations are set\
    \ up by the normal\n   procedures of the transport and security protocols that\
    \ comprise\n   them, using peer IP addresses from the routing state.  Once a\n\
    \   messaging association has been created, its refresh and expiration\n   can\
    \ be managed independently from the routing state.\n   There are two different\
    \ cases for state installation and refresh:\n   1.  Where routing state is being\
    \ discovered or a new association is\n       to be established; and\n   2.  Where\
    \ a suitable association already exists, including the case\n       where routing\
    \ state for the flow is being refreshed.\n   These cases are now considered in\
    \ turn, followed by the case of\n   background general management procedures.\n"
- title: 4.4.1.  Routing State and Messaging Association Creation
  contents:
  - "4.4.1.  Routing State and Messaging Association Creation\n   The message sequence\
    \ for GIST state setup between peers is shown in\n   Figure 5 and described in\
    \ detail below.  The figure informally\n   summarises the contents of each message,\
    \ including optional elements\n   in square brackets.  An example is given in\
    \ Appendix D.\n   The first message in any routing state maintenance operation\
    \ is a\n   Query, sent from the Querying node and intercepted at the responding\n\
    \   node.  This message has addressing and other identifiers appropriate\n   for\
    \ the flow and signalling application that state maintenance is\n   being done\
    \ for, addressing information about the node that generated\n   the Query itself,\
    \ and MAY contain an NSLP payload.  It also includes\n   a Query-Cookie, and optionally\
    \ capability information about messaging\n   association protocol stacks.  The\
    \ role of the cookies in this and\n   later messages is to protect against certain\
    \ denial-of-service\n   attacks and to correlate the events in the message sequence\
    \ (see\n   Section 8.5 for further details).\n            +----------+       \
    \              +----------+\n            | Querying |                     |Responding|\n\
    \            | Node(Q-N)|                     | Node(R-N)|\n            +----------+\
    \                     +----------+\n                               Query     \
    \             .............\n                       ---------------------->  \
    \      .           .\n                       Router Alert Option            .\
    \  Routing  .\n                       MRI/SID/NSLPID                 .   state\
    \   .\n                       Q-N Network Layer Info         . installed .\n \
    \                      Query-Cookie                   .    at     .\n        \
    \               [Q-N Stack-Proposal            . Responding.\n               \
    \         Q-N Stack-Config-Data]        .    node   .\n                      \
    \ [NSLP Payload]                 .  (case 1) .\n                             \
    \                         .............\n               ......................................\n\
    \               .  The responder can use an existing .\n               . messaging\
    \ association if available .\n               . from here onwards to short-circuit\
    \ .\n               .     messaging association setup    .\n               ......................................\n\
    \                             Response\n   .............       <----------------------\n\
    \   .  Routing  .       MRI/SID/NSLPID\n   .   state   .       R-N Network Layer\
    \ Info\n   . installed .       Query-Cookie\n   .    at     .       [Responder-Cookie\n\
    \   .  Querying .        [R-N Stack-Proposal\n   .   node    .         R-N Stack-Config-Data]]\n\
    \   .............       [NSLP Payload]\n                ....................................\n\
    \                . If a messaging association needs .\n                . to be\
    \ created, it is set up here .\n                .     and the Confirm uses it\
    \      .\n                ....................................\n             \
    \              Confirm                    .............\n                    \
    \ ---------------------->          .  Routing  .\n                     MRI/SID/NSLPID\
    \                   .   state   .\n                     Q-N Network Layer Info\
    \           . installed .\n                     [Responder-Cookie            \
    \    .    at     .\n                      [R-N Stack-Proposal             . Responding.\n\
    \                       [Q-N Stack-Config-Data]]]      .    node   .\n       \
    \              [NSLP Payload]                   .  (case 2) .\n              \
    \                                        .............\n                 Figure\
    \ 5: Message Sequence at State Setup\n   Provided that the signalling application\
    \ has indicated that message\n   routing state should be set up (see Section 4.3.2),\
    \ reception of a\n   Query MUST elicit a Response.  This is a normally encapsulated\
    \ D-mode\n   message with additional GIST payloads.  It contains network layer\n\
    \   information about the Responding node, echoes the Query-Cookie, and\n   MAY\
    \ contain an NSLP payload, possibly a reply to the NSLP payload in\n   the initial\
    \ message.  In case a messaging association was requested,\n   it MUST also contain\
    \ a Responder-Cookie and its own capability\n   information about messaging association\
    \ protocol stacks.  Even if a\n   messaging association is not requested, the\
    \ Response MAY still\n   include a Responder-Cookie if the node's routing state\
    \ setup policy\n   requires it (see below).\n   Setup of a new messaging association\
    \ begins when peer addressing\n   information is available and a new messaging\
    \ association is actually\n   needed.  Any setup MUST take place immediately after\
    \ the specific\n   Query/Response exchange, because the addressing information\
    \ used may\n   have a limited lifetime, either because it depends on limited\n\
    \   lifetime NAT bindings or because it refers to agile destination ports\n  \
    \ for the transport protocols.  The Stack-Proposal and Stack-\n   Configuration-Data\
    \ objects carried in the exchange carry capability\n   information about what\
    \ messaging association protocols can be used,\n   and the processing of these\
    \ objects is described in more detail in\n   Section 5.7.  With the protocol options\
    \ currently defined, setup of\n   the messaging association always starts from\
    \ the Querying node,\n   although more flexible configurations are possible within\
    \ the overall\n   GIST design.  If the messaging association includes a channel\n\
    \   security protocol, each GIST node MUST verify the authenticated\n   identity\
    \ of the peer against its authorised peer database, and if\n   there is no match\
    \ the messaging association MUST be torn down.  The\n   database and authorisation\
    \ check are described in more detail in\n   Section 4.4.2 below.  Note that the\
    \ verification can depend on what\n   the MA is to be used for (e.g., for which\
    \ MRI or session), so this\n   step may not be possible immediately after authentication\
    \ has\n   completed but some time later.\n   Finally, after any necessary messaging\
    \ association setup has\n   completed, a Confirm MUST be sent if the Response\
    \ requested it.  Once\n   the Confirm has been sent, the Querying node assumes\
    \ that routing\n   state has been installed at the responder, and can send normal\
    \ Data\n   messages for the flow in question; recovery from a lost Confirm is\n\
    \   discussed in Section 5.3.3.  If a messaging association is being\n   used,\
    \ the Confirm MUST be sent over it before any other messages for\n   the same\
    \ flow, and it echoes the Responder-Cookie and Stack-Proposal\n   from the Response.\
    \  The former is used to allow the receiver to\n   validate the contents of the\
    \ message (see Section 8.5), and the\n   latter is to prevent certain bidding-down\
    \ attacks on messaging\n   association security (see Section 8.6).  This first\
    \ Confirm on a new\n   association MUST also contain a Stack-Configuration-Data\
    \ object\n   carrying an MA-Hold-Time value, which supersedes the value given\
    \ in\n   the original Query.  The association can be used in the upstream\n  \
    \ direction for the MRI and NSLPID carried in the Confirm, after the\n   Confirm\
    \ has been received.\n   The Querying node MUST install the responder address,\
    \ derived from\n   the R-Node Network Layer info, as routing state information\
    \ after\n   verifying the Query-Cookie in the Response.  The Responding node MAY\n\
    \   install the querying address as peer state information at two points\n   in\
    \ time:\n   Case 1:  after the receipt of the initial Query, or\n   Case 2:  after\
    \ a Confirm containing the Responder-Cookie.\n   The Responding node SHOULD derive\
    \ the peer address from the Q-Node\n   Network Layer Info if this was decoded\
    \ successfully.  Otherwise, it\n   MAY be derived from the IP source address of\
    \ the message if the\n   common header flags this as being the signalling source\
    \ address.  The\n   precise constraints on when state information is installed\
    \ are a\n   matter of security policy considerations on prevention of denial-of-\n\
    \   service attacks and state poisoning attacks, which are discussed\n   further\
    \ in Section 8.  Because the Responding node MAY choose to\n   delay state installation\
    \ as in case (2), the Confirm must contain\n   sufficient information to allow\
    \ it to be processed in the same way as\n   the original Query.  This places some\
    \ special requirements on NAT\n   traversal and cookie functionality, which are\
    \ discussed in\n   Section 7.2 and Section 8 respectively.\n"
- title: 4.4.2.  GIST Peer Authorisation
  contents:
  - "4.4.2.  GIST Peer Authorisation\n   When two GIST nodes authenticate using a\
    \ messaging association, both\n   ends have to decide whether to accept the creation\
    \ of the MA and\n   whether to trust the information sent over it.  This can be\
    \ seen as\n   an authorisation decision:\n   o  Authorised peers are trusted to\
    \ install correct routing state\n      about themselves and not, for example,\
    \ to claim that they are on-\n      path for a flow when they are not.\n   o \
    \ Authorised peers are trusted to obey transport- and application-\n      level\
    \ flow control rules, and not to attempt to create overload\n      situations.\n\
    \   o  Authorised peers are trusted not to send erroneous or malicious\n     \
    \ error messages, for example, asserting that routing state has been\n      lost\
    \ when it has not.\n   This specification models the decision as verification\
    \ by the\n   authorising node of the peer's identity against a local list of\n\
    \   peers, the authorised peer database (APD).  The APD is an abstract\n   construct,\
    \ similar to the security policy database of IPsec [36].\n   Implementations MAY\
    \ provide the associated functionality in any way\n   they choose.  This section\
    \ defines only the requirements for APD\n   administration and the consequences\
    \ of successfully validating a\n   peer's identity against it.\n   The APD consists\
    \ of a list of entries.  Each entry includes an\n   identity, the namespace from\
    \ which the identity comes (e.g., DNS\n   domains), the scope within which the\
    \ entry is applicable, and whether\n   authorisation is allowed or denied.  The\
    \ following are example\n   scopes:\n   Peer Address Ownership:  The scope is\
    \ the IP address at which the\n      peer for this MRI should be; the APD entry\
    \ denotes the identity as\n      the owner of address.  If the authorising node\
    \ can determine this\n      address from local information (such as its own routing\
    \ tables),\n      matching this entry shows that the peer is the correct on-path\n\
    \      node and so should be authorised.  The determination is simple if\n   \
    \   the peer is one IP hop downstream, since the IP address can be\n      derived\
    \ from the router's forwarding tables.  If the peer is more\n      than one hop\
    \ away or is upstream, the determination is harder but\n      may still be possible\
    \ in some circumstances.  The authorising node\n      may be able to determine\
    \ a (small) set of possible peer addresses,\n      and accept that any of these\
    \ could be the correct peer.\n   End-System Subnet:  The scope is an address range\
    \ within which the\n      MRI source or destination lies; the APD entry denotes\
    \ the identity\n      as potentially being on-path between the authorising node\
    \ and that\n      address range.  There may be different source and destination\n\
    \      scopes, to account for asymmetric routing.\n   The same identity may appear\
    \ in multiple entries, and the order of\n   entries in the APD is significant.\
    \  When a messaging association is\n   authenticated and associated with an MRI,\
    \ the authorising node scans\n   the APD to find the first entry where the identity\
    \ matches that\n   presented by the peer, and where the scope information matches\
    \ the\n   circumstances for which the MA is being set up.  The identity\n   matching\
    \ process itself depends on the messaging association protocol\n   that carries\
    \ out the authentication, and details for TLS are given in\n   Section 5.7.3.\
    \  Whenever the full set of possible peers for a\n   specific scope is known,\
    \ deny entries SHOULD be added for the\n   wildcard identity to reject signalling\
    \ associations from unknown\n   nodes.  The ability of the authorising node to\
    \ reject inappropriate\n   MAs depends directly on the granularity of the APD\
    \ and the precision\n   of the scope matching process.\n   If authorisation is\
    \ allowed, the MA can be used as normal; otherwise,\n   it MUST be torn down without\
    \ further GIST exchanges, and any routing\n   state associated with the MA MUST\
    \ also be deleted.  An error\n   condition MAY be logged locally.  When an APD\
    \ entry is modified or\n   deleted, the node MUST re-validate existing MAs and\
    \ the routing state\n   table against the revised contents of the APD.  This may\
    \ result in\n   MAs being torn down or routing state entries being deleted.  These\n\
    \   changes SHOULD be indicated to local signalling applications via the\n   NetworkNotification\
    \ API call (Appendix B.4).\n   This specification does not define how the APD\
    \ is populated.  As a\n   minimum, an implementation MUST provide an administrative\
    \ interface\n   through which entries can be added, modified, or deleted.  More\n\
    \   sophisticated mechanisms are possible in some scenarios.  For\n   example,\
    \ the fact that a node is legitimately associated with a\n   specific IP address\
    \ could be established by direct embedding of the\n   IP address as a particular\
    \ identity type in a certificate, or by a\n   mapping that address to another\
    \ identifier type via an additional\n   database lookup (such as relating IP addresses\
    \ in in-addr.arpa to\n   domain names).  An enterprise network operator could\
    \ generate a list\n   of all the identities of its border nodes as authorised\
    \ to be on the\n   signalling path to external destinations, and this could be\n\
    \   distributed to all hosts inside the network.  Regardless of the\n   technique,\
    \ it MUST be ensured that the source data justify the\n   authorisation decisions\
    \ listed at the start of this section, and that\n   the security of the chain\
    \ of operations on which the APD entry\n   depends cannot be compromised.\n"
- title: 4.4.3.  Messaging Association Multiplexing
  contents:
  - "4.4.3.  Messaging Association Multiplexing\n   It is a design goal of GIST that,\
    \ as far as possible, a single\n   messaging association should be used for multiple\
    \ flows and sessions\n   between two peers, rather than setting up a new MA for\
    \ each.  This\n   re-use of existing MAs is referred to as messaging association\n\
    \   multiplexing.  Multiplexing ensures that the MA cost scales only with\n  \
    \ the number of peers, and avoids the latency of new MA setup where\n   possible.\n\
    \   However, multiplexing requires the identification of an existing MA\n   that\
    \ matches the same routing state and desired properties that would\n   be the\
    \ result of a normal handshake in D-mode, and this\n   identification must be\
    \ done as reliably and securely as continuing\n   with a normal D-mode handshake.\
    \  Note that this requirement is\n   complicated by the fact that NATs may remap\
    \ the node addresses in\n   D-mode messages, and also interacts with the fact\
    \ that some nodes may\n   peer over multiple interfaces (and thus with different\
    \ addresses).\n   MA multiplexing is controlled by the Network Layer Information\
    \ (NLI)\n   object, which is carried in Query, Response, and Confirm messages.\n\
    \   The NLI object includes (among other elements):\n   Peer-Identity:  For a\
    \ given node, this is an interface-independent\n      value with opaque syntax.\
    \  It MUST be chosen so as to have a high\n      probability of uniqueness across\
    \ the set of all potential peers,\n      and SHOULD be stable at least until the\
    \ next node restart.  Note\n      that there is no cryptographic protection of\
    \ this identity;\n      attempting to provide this would essentially duplicate\
    \ the\n      functionality in the messaging association security protocols.\n\
    \      For routers, the Router-ID [2], which is one of the router's IP\n     \
    \ addresses, MAY be used as one possible value for the Peer-\n      Identity.\
    \  In scenarios with nested NATs, the Router-ID alone may\n      not satisfy the\
    \ uniqueness requirements, in which case it MAY be\n      extended with additional\
    \ tokens, either chosen randomly or\n      administratively coordinated.\n   Interface-Address:\
    \  This is an IP address through which the\n      signalling node can be reached.\
    \  There may be several choices\n      available for the Interface-Address, and\
    \ further discussion of\n      this is contained in Section 5.2.2.\n   A messaging\
    \ association is associated with the NLI object that was\n   provided by the peer\
    \ in the Query/Response/Confirm at the time the\n   association was first set\
    \ up.  There may be more than one MA for a\n   given NLI object, for example,\
    \ with different security or transport\n   properties.\n   MA multiplexing is\
    \ achieved by matching these two elements from the\n   NLI provided in a new GIST\
    \ message with one associated with an\n   existing MA.  The message can be either\
    \ a Query or Response, although\n   the former is more likely:\n   o  If there\
    \ is a perfect match to an existing association, that\n      association SHOULD\
    \ be re-used, provided it meets the criteria on\n      security and transport\
    \ properties given at the end of\n      Section 5.7.1.  This is indicated by sending\
    \ the remaining\n      messages in the handshake over that association.  This\
    \ will lead\n      to multiplexing on an association to the wrong node if signalling\n\
    \      nodes have colliding Peer-Identities and one is reachable at the\n    \
    \  same Interface-Address as another.  This could be caused by an on-\n      path\
    \ attacker; on-path attacks are discussed further in\n      Section 8.7.  When\
    \ multiplexing is done, and the original MA\n      authorisation was MRI-dependent,\
    \ the verification steps of\n      Section 4.4.2 MUST be repeated for the new\
    \ flow.\n   o  In all other cases, the handshake MUST be executed in D-mode as\n\
    \      usual.  There are in fact four possibilities:\n      1.  Nothing matches:\
    \ this is clearly a new peer.\n      2.  Only the Peer-Identity matches: this\
    \ may be either a new\n          interface on an existing peer or a changed address\
    \ mapping\n          behind a NAT.  These should be rare events, so the expense\
    \ of\n          a new association setup is acceptable.  Another possibility is\n\
    \          one node using another node's Peer-Identity, for example, as\n    \
    \      some kind of attack.  Because the Peer-Identity is used only\n        \
    \  for this multiplexing process, the only consequence this has\n          is\
    \ to require a new association setup, and this is considered\n          in Section\
    \ 8.4.\n      3.  Only the Interface-Address matches: this is probably a new\n\
    \          peer behind the same NAT as an existing one.  A new\n          association\
    \ setup is required.\n      4.  Both elements of the NLI object match: this is\
    \ a degenerate\n          case, where one node recognises an existing peer, but\
    \ wishes\n          to allow the option to set up a new association in any case,\n\
    \          for example, to create an association with different\n          properties.\n"
- title: 4.4.4.  Routing State Maintenance
  contents:
  - "4.4.4.  Routing State Maintenance\n   Each item of routing state expires after\
    \ a lifetime that is\n   negotiated during the Query/Response/Confirm handshake.\
    \  The Network\n   Layer Information (NLI) object in the Query contains a proposal\
    \ for\n   the lifetime value, and the NLI in the Response contains the value\n\
    \   the Responding node requires.  A default timer value of 30 seconds is\n  \
    \ RECOMMENDED.  Nodes that can exploit alternative, more powerful,\n   route change\
    \ detection methods such as those described in\n   Section 7.1.2 MAY choose to\
    \ use much longer times.  Nodes MAY use\n   shorter times to provide more rapid\
    \ change detection.  If the number\n   of active routing state items corresponds\
    \ to a rate of Queries that\n   will stress the rate limits applied to D-mode\
    \ traffic\n   (Section 5.3.3), nodes MUST increase the timer for new items and\
    \ on\n   the refresh of existing ones.  A suitable value is\n         2 * (number\
    \ of routing states) / (rate limit in packets/second)\n   which leaves a factor\
    \ of two headroom for new routing state creation\n   and Query retransmissions.\n\
    \   The Querying node MUST ensure that a Query is received before this\n   timer\
    \ expires, if it believes that the signalling session is still\n   active; otherwise,\
    \ the Responding node MAY delete the state.  Receipt\n   of the message at the\
    \ Responding node will refresh peer addressing\n   state for one direction, and\
    \ receipt of a Response at the Querying\n   node will refresh it for the other.\
    \  There is no mechanism at the\n   GIST level for explicit teardown of routing\
    \ state.  However, GIST\n   MUST NOT refresh routing state if a signalling session\
    \ is known to be\n   inactive, either because upstream state has expired or because\
    \ the\n   signalling application has indicated via the GIST API (Appendix B.5)\n\
    \   that the state is no longer required, because this would prevent\n   correct\
    \ state repair in the case of network rerouting at the IP\n   layer.\n   This\
    \ specification defines precisely only the time at which routing\n   state expires;\
    \ it does not define when refresh handshakes should be\n   initiated.  Implementations\
    \ MUST select timer settings that take at\n   least the following into account:\n\
    \   o  the transmission latency between source and destination;\n   o  the need\
    \ for retransmissions of Query messages;\n   o  the need to avoid network synchronisation\
    \ of control traffic (cf.\n      [42]).\n   In most cases, a reasonable policy\
    \ is to initiate the routing state\n   refresh when between 1/2 and 3/4 of the\
    \ validity time has elapsed\n   since the last successful refresh.  The actual\
    \ moment MUST be chosen\n   randomly within this interval to avoid synchronisation\
    \ effects.\n"
- title: 4.4.5.  Messaging Association Maintenance
  contents:
  - "4.4.5.  Messaging Association Maintenance\n   Unneeded MAs are torn down by GIST,\
    \ using the teardown mechanisms of\n   the underlying transport or security protocols\
    \ if available, for\n   example, by simply closing a TCP connection.  The teardown\
    \ can be\n   initiated by either end.  Whether an MA is needed is a combination\
    \ of\n   two factors:\n   o  local policy, which could take into account the cost\
    \ of keeping\n      the messaging association open, the level of past activity\
    \ on the\n      association, and the likelihood of future activity, e.g., if there\n\
    \      is routing state still in place that might generate messages to\n     \
    \ use it.\n   o  whether the peer still wants the MA to remain in place.  During\
    \ MA\n      setup, as part of the Stack-Configuration-Data, each node\n      advertises\
    \ its own MA-Hold-Time, i.e., the time for which it will\n      retain an MA that\
    \ is not carrying signalling traffic.  A node MUST\n      NOT tear down an MA\
    \ if it has received traffic from its peer over\n      that period.  A peer that\
    \ has generated no traffic but still wants\n      the MA retained can use a special\
    \ null message (MA-Hello) to\n      indicate the fact.  A default value for MA-Hold-Time\
    \ of 30 seconds\n      is RECOMMENDED.  Nodes MAY use shorter times to achieve\
    \ more rapid\n      peer failure detection, but need to take into account the\
    \ load on\n      the network created by the MA-Hello messages.  Nodes MAY use\n\
    \      longer times, but need to take into account the cost of retaining\n   \
    \   idle MAs for extended periods.  Nodes MAY take signalling\n      application\
    \ behaviour (e.g., NSLP refresh times) into account in\n      choosing an appropriate\
    \ value.\n      Because the Responding node can choose not to create state until\
    \ a\n      Confirm, an abbreviated Stack-Configuration-Data object containing\n\
    \      just this information from the initial Query MUST be repeated by\n    \
    \  the Querying node in the first Confirm sent on a new MA.  If the\n      object\
    \ is missing in the Confirm, an \"Object Type Error\" message\n      (Appendix\
    \ A.4.4.9) with subcode 2 (\"Missing Object\") MUST be\n      returned.\n   Messaging\
    \ associations can always be set up on demand, and messaging\n   association status\
    \ is not made directly visible outside the GIST\n   layer.  Therefore, even if\
    \ GIST tears down and later re-establishes a\n   messaging association, signalling\
    \ applications cannot distinguish\n   this from the case where the MA is kept\
    \ permanently open.  To\n   maintain the transport semantics described in Section\
    \ 4.1, GIST MUST\n   close transport connections carrying reliable messages gracefully\
    \ or\n   report an error condition, and MUST NOT open a new association to be\n\
    \   used for given session and peer while messages on a previous\n   association\
    \ could still be outstanding.  GIST MAY use an MA-Hello\n   request/reply exchange\
    \ on an existing association to verify that\n   messages sent on it have reached\
    \ the peer.  GIST MAY use the same\n   technique to test the liveness of the underlying\
    \ MA protocols\n   themselves at arbitrary times.\n   This specification defines\
    \ precisely only the time at which messaging\n   associations expire; it does\
    \ not define when keepalives should be\n   initiated.  Implementations MUST select\
    \ timer settings that take at\n   least the following into account:\n   o  the\
    \ transmission latency between source and destination;\n   o  the need for retransmissions\
    \ within the messaging association\n      protocols;\n   o  the need to avoid\
    \ network synchronisation of control traffic (cf.\n      [42]).\n   In most cases,\
    \ a reasonable policy is to initiate the MA refresh when\n   between 1/2 and 3/4\
    \ of the validity time has elapsed since the last\n   successful refresh.  The\
    \ actual moment MUST be chosen randomly within\n   this interval to avoid synchronisation\
    \ effects.\n"
- title: 4.4.6.  Routing State Failures
  contents:
  - "4.4.6.  Routing State Failures\n   A GIST node can receive a message from a GIST\
    \ peer that can only be\n   correctly processed in the context of some routing\
    \ state, but where\n   no corresponding routing state exists.  Cases where this\
    \ can arise\n   include:\n   o  Where the message is random traffic from an attacker,\
    \ or\n      backscatter (replies to such traffic).\n   o  Where routing state\
    \ has been correctly installed but the peer has\n      since lost it, for example,\
    \ because of aggressive timeout settings\n      at the peer or because the node\
    \ has crashed and restarted.\n   o  Where the routing state was not correctly\
    \ installed in the first\n      place, but the sending node does not know this.\
    \  This can happen\n      if the Confirm message of the handshake is lost.\n \
    \  It is important for GIST to recover from such situations promptly\n   where\
    \ they represent genuine errors (node restarts, or lost messages\n   that would\
    \ not otherwise be retransmitted).  Note that only Response,\n   Confirm, Data,\
    \ and Error messages ever require routing state to\n   exist, and these are considered\
    \ in turn:\n   Response:  A Response can be received at a node that never sent\
    \ (or\n      has forgotten) the corresponding Query.  If the node wants routing\n\
    \      state to exist, it will initiate it itself; a diagnostic error\n      would\
    \ not allow the sender of the Response to take any corrective\n      action, and\
    \ the diagnostic could itself be a form of backscatter.\n      Therefore, an error\
    \ message MUST NOT be generated, but the\n      condition MAY be logged locally.\n\
    \   Confirm:  For a Responding node that implements delayed state\n      installation,\
    \ this is normal behaviour, and routing state will be\n      created provided\
    \ the Confirm is validated.  Otherwise, this is a\n      case of a non-existent\
    \ or forgotten Response, and the node may not\n      have sufficient information\
    \ in the Confirm to create the correct\n      state.  The requirement is to notify\
    \ the Querying node so that it\n      can recover the routing state.\n   Data:\
    \  This arises when a node receives Data where routing state is\n      required,\
    \ but either it does not exist at all or it has not been\n      finalised (no\
    \ Confirm message).  To avoid Data being black-holed,\n      a notification must\
    \ be sent to the peer.\n   Error:  Some error messages can only be interpreted\
    \ in the context of\n      routing state.  However, the only error messages that\
    \ require a\n      reply within the protocol are routing state error messages\n\
    \      themselves.  Therefore, this case should be treated the same as a\n   \
    \   Response: an error message MUST NOT be generated, but the\n      condition\
    \ MAY be logged locally.\n   For the case of Confirm or Data messages, if the\
    \ state is required\n   but does not exist, the node MUST reject the incoming\
    \ message with a\n   \"No Routing State\" error message (Appendix A.4.4.5).  There\
    \ are then\n   three cases at the receiver of the error message:\n   No routing\
    \ state:  The condition MAY be logged but a reply MUST NOT\n      be sent (see\
    \ above).\n   Querying node:  The node MUST restart the GIST handshake from the\n\
    \      beginning, with a new Query.\n   Responding node:  The node MUST delete\
    \ its own routing state and\n      SHOULD report an error condition to the local\
    \ signalling\n      application.\n   The rules at the Querying or Responding node\
    \ make GIST open to\n   disruption by randomly injected error messages, similar\
    \ to blind\n   reset attacks on TCP (cf. [46]), although because routing state\n\
    \   matching includes the SID this is mainly limited to on-path\n   attackers.\
    \  If a GIST node detects a significant rate of such\n   attacks, it MAY adopt\
    \ a policy of using secured messaging\n   associations to communicate for the\
    \ affected MRIs, and only accepting\n   \"No Routing State\" error messages over\
    \ such associations.\n"
- title: 5.  Message Formats and Transport
  contents:
  - '5.  Message Formats and Transport

    '
- title: 5.1.  GIST Messages
  contents:
  - "5.1.  GIST Messages\n   All GIST messages begin with a common header, followed\
    \ by a sequence\n   of type-length-value (TLV) objects.  This subsection describes\
    \ the\n   various GIST messages and their contents at a high level in ABNF\n \
    \  [11]; a more detailed description of the header and each object is\n   given\
    \ in Section 5.2 and bit formats in Appendix A.  Note that the\n   NAT traversal\
    \ mechanism for GIST involves the insertion of an\n   additional NAT-Traversal-Object\
    \ in Query, Response, and some Data and\n   Error messages; the rules for this\
    \ are given in Section 7.2.\n   GIST-Message: The primary messages are either\
    \ part of the three-way\n   handshake or a simple message carrying NSLP data.\
    \  Additional types\n   are defined for errors and keeping messaging associations\
    \ alive.\n       GIST-Message = Query / Response / Confirm /\n               \
    \       Data / Error / MA-Hello\n   The common header includes a version number,\
    \ message type and size,\n   and NSLPID.  It also carries a hop count to prevent\
    \ infinite message\n   looping and various control flags, including one (the R-flag)\
    \ to\n   indicate if a reply of some sort is requested.  The objects following\n\
    \   the common header MUST be carried in a fixed order, depending on\n   message\
    \ type.  Messages with missing, duplicate, or invalid objects\n   for the message\
    \ type MUST be rejected with an \"Object Type Error\"\n   message with the appropriate\
    \ subcode (Appendix A.4.4.9).  Note that\n   unknown objects indicate explicitly\
    \ how they should be treated and\n   are not covered by the above statement.\n\
    \   Query: A Query MUST be sent in D-mode using the special Q-mode\n   encapsulation.\
    \  In addition to the common header, it contains certain\n   mandatory control\
    \ objects, and MAY contain a signalling application\n   payload.  A stack proposal\
    \ and configuration data MUST be included if\n   the message exchange relates\
    \ to setup of a messaging association, and\n   this is the case even if the Query\
    \ is intended only for refresh\n   (since a routing change might have taken place\
    \ in the meantime).  The\n   R-flag MUST always be set (R=1) in a Query, since\
    \ this message always\n   elicits a Response.\n       Query = Common-Header\n\
    \               [ NAT-Traversal-Object ]\n               Message-Routing-Information\n\
    \               Session-Identifier\n               Network-Layer-Information\n\
    \               Query-Cookie\n               [ Stack-Proposal Stack-Configuration-Data\
    \ ]\n               [ NSLP-Data ]\n   Response: A Response MUST be sent in D-mode\
    \ if no existing messaging\n   association can be re-used.  If one is being re-used,\
    \ the Response\n   MUST be sent in C-mode.  It MUST echo the MRI, SID, and Query-Cookie\n\
    \   of the Query, and carries its own Network-Layer-Information.  If the\n   message\
    \ exchange relates to setup of a new messaging association,\n   which MUST involve\
    \ a D-mode Response, a Responder-Cookie MUST be\n   included, as well as the Responder's\
    \ own stack proposal and\n   configuration data.  The R-flag MUST be set (R=1)\
    \ if a Responder-\n   Cookie is present but otherwise is optional; if the R-flag\
    \ is set, a\n   Confirm MUST be sent as a reply.  Therefore, in particular, a\
    \ Confirm\n   will always be required if a new MA is being set up.  Note that\
    \ the\n   direction of this MRI will be inverted compared to that in the Query,\n\
    \   that is, an upstream MRI becomes downstream and vice versa (see\n   Section\
    \ 3.3).\n       Response = Common-Header\n                  [ NAT-Traversal-Object\
    \ ]\n                  Message-Routing-Information\n                  Session-Identifier\n\
    \                  Network-Layer-Information\n                  Query-Cookie\n\
    \                  [ Responder-Cookie\n                    [ Stack-Proposal Stack-Configuration-Data\
    \ ] ]\n                  [ NSLP-Data ]\n   Confirm: A Confirm MUST be sent in\
    \ C-mode if a messaging association\n   is being used for this routing state,\
    \ and MUST be sent before other\n   messages for this routing state if an association\
    \ is being set up.\n   If no messaging association is being used, the Confirm\
    \ MUST be sent\n   in D-mode.  The Confirm MUST include the MRI (with inverted\n\
    \   direction) and SID, and echo the Responder-Cookie if the Response\n   carried\
    \ one.  In C-mode, the Confirm MUST also echo the Stack-\n   Proposal from the\
    \ Response (if present) so it can be verified that\n   this has not been tampered\
    \ with.  The first Confirm on a new\n   association MUST also repeat the Stack-Configuration-Data\
    \ from the\n   original Query in an abbreviated form, just containing the MA-Hold-\n\
    \   Time.\n       Confirm = Common-Header\n                 Message-Routing-Information\n\
    \                 Session-Identifier\n                 Network-Layer-Information\n\
    \                 [ Responder-Cookie\n                   [ Stack-Proposal\n  \
    \                   [ Stack-Configuration-Data ] ] ]\n                 [ NSLP-Data\
    \ ]\n   Data: The Data message is used to transport NSLP data without\n   modifying\
    \ GIST state.  It contains no control objects, but only the\n   MRI and SID associated\
    \ with the NSLP data being transferred.\n   Network-Layer-Information (NLI) MUST\
    \ be carried in the D-mode case,\n   but MUST NOT be included otherwise.\n   \
    \    Data = Common-Header\n              [ NAT-Traversal-Object ]\n          \
    \    Message-Routing-Information\n              Session-Identifier\n         \
    \     [ Network-Layer-Information ]\n              NSLP-Data\n   Error: An Error\
    \ message reports a problem determined at the GIST\n   level.  (Errors generated\
    \ by signalling applications are reported in\n   NSLP-Data payloads and are not\
    \ treated specially by GIST.)  If the\n   message is being sent in D-mode, the\
    \ originator of the error message\n   MUST include its own Network-Layer-Information\
    \ object.  All other\n   information related to the error is carried in a GIST-Error-Data\n\
    \   object.\n       Error = Common-Header\n               [ NAT-Traversal-Object\
    \ ]\n               [ Network-Layer-Information ]\n               GIST-Error-Data\n\
    \   MA-Hello: This message MUST be sent only in C-mode.  It contains the\n   common\
    \ header, with a NSLPID of zero, and a message identifier, the\n   Hello-ID. \
    \ It always indicates that a node wishes to keep a messaging\n   association open,\
    \ and if sent with R=0 and zero Hello-ID this is its\n   only function.  A node\
    \ MAY also invoke a diagnostic request/reply\n   exchange by setting R=1 and providing\
    \ a non-zero Hello-ID; in this\n   case, the peer MUST send another MA-Hello back\
    \ along the messaging\n   association echoing the same Hello-ID and with R=0.\
    \  Use of this\n   diagnostic is entirely at the discretion of the initiating\
    \ node.\n       MA-Hello = Common-Header\n                  Hello-ID\n"
- title: 5.2.  Information Elements
  contents:
  - "5.2.  Information Elements\n   This section describes the content of the various\
    \ objects that can be\n   present in each GIST message, both the common header\
    \ and the\n   individual TLVs.  The bit formats are provided in Appendix A.\n"
- title: 5.2.1.  The Common Header
  contents:
  - "5.2.1.  The Common Header\n   Each message begins with a fixed format common\
    \ header, which contains\n   the following information:\n   Version:  The version\
    \ number of the GIST protocol.  This\n      specification defines GIST version\
    \ 1.\n   GIST hop count:  A hop count to prevent a message from looping\n    \
    \  indefinitely.\n   Length:  The number of 32-bit words in the message following\
    \ the\n      common header.\n   Upper layer identifier (NSLPID):  This gives the\
    \ specific NSLP for\n      which this message is used.\n   Context-free flag:\
    \  This flag is set (C=1) if the receiver has to be\n      able to process the\
    \ message without supporting routing state.  The\n      C-flag MUST be set for\
    \ Query messages, and also for Data messages\n      sent in Q-mode.  The C-flag\
    \ is important for NAT traversal\n      processing.\n   Message type:  The message\
    \ type (Query, Response, etc.).\n   Source addressing mode:  If set (S=1), this\
    \ indicates that the IP\n      source address of the message is the same as the\
    \ IP address of the\n      signalling peer, so replies to this message can be\
    \ sent safely to\n      this address.  S is always set in C-mode.  It is cleared\
    \ (S=0) if\n      the IP source address was derived from the message routing\n\
    \      information in the payload and this is different from the\n      signalling\
    \ source address.\n   Response requested:  A flag that if set (R=1) indicates\
    \ that a GIST\n      message should be sent in reply to this message.  The appropriate\n\
    \      message type for the reply depends on the type of the initial\n      message.\n\
    \   Explicit routing:  A flag that if set (E=1) indicates that the\n      message\
    \ was explicitly routed (see Section 7.1.5).\n   Note that in D-mode, Section\
    \ 5.3, there is a 32-bit magic number\n   before the header.  However, this is\
    \ regarded as part of the\n   encapsulation rather than part of the message itself.\n"
- title: 5.2.2.  TLV Objects
  contents:
  - "5.2.2.  TLV Objects\n   All data following the common header is encoded as a\
    \ sequence of\n   type-length-value objects.  Currently, each object can occur\
    \ at most\n   once; the set of required and permitted objects is determined by\
    \ the\n   message type and encapsulation (D-mode or C-mode).\n   Message-Routing-Information\
    \ (MRI):  Information sufficient to define\n      how the signalling message should\
    \ be routed through the network.\n       Message-Routing-Information = message-routing-method\n\
    \                                     method-specific-information\n   The format\
    \ of the method-specific-information depends on the\n   message-routing-method\
    \ requested by the signalling application.  Note\n   that it always includes a\
    \ flag defining the direction as either\n   'upstream' or 'downstream' (see Section\
    \ 3.3).  It is provided by the\n   NSLP in the message sender and used by GIST\
    \ to select the message\n   routing.\n   Session-Identifier (SID):  The GIST session\
    \ identifier is a 128-bit,\n      cryptographically random identifier chosen by\
    \ the node that\n      originates the signalling exchange.  See Section 3.7.\n\
    \   Network-Layer-Information (NLI):  This object carries information\n      about\
    \ the network layer attributes of the node sending the\n      message, including\
    \ data related to the management of routing\n      state.  This includes a peer\
    \ identity and IP address for the\n      sending node.  It also includes IP-TTL\
    \ information to allow the IP\n      hop count between GIST peers to be measured\
    \ and reported, and a\n      validity time (RS-validity-time) for the routing\
    \ state.\n       Network-Layer-Information = peer-identity\n                 \
    \                  interface-address\n                                   RS-validity-time\n\
    \                                   IP-TTL\n   The use of the RS-validity-time\
    \ field is described in Section 4.4.4.\n   The peer-identity and interface-address\
    \ are used for matching\n   existing associations, as discussed in Section 4.4.3.\n\
    \   The interface-address must be routable, i.e., it MUST be usable as a\n   destination\
    \ IP address for packets to be sent back to the node\n   generating the signalling\
    \ message, whether in D-mode or C-mode.  If\n   this object is carried in a message\
    \ with the source addressing mode\n   flag S=1, the interface-address MUST match\
    \ the source address used in\n   the IP encapsulation, to assist in legacy NAT\
    \ detection\n   (Section 7.2.1).  If this object is carried in a Query or Confirm,\n\
    \   the interface-address MUST specifically be set to an address bound to\n  \
    \ an interface associated with the MRI, to allow its use in route\n   change handling\
    \ as discussed in Section 7.1.  A suitable choice is\n   the interface that is\
    \ carrying the outbound flow.  A node may have\n   several choices for which of\
    \ its addresses to use as the\n   interface-address.  For example, there may be\
    \ a choice of IP\n   versions, or addresses of limited scope (e.g., link-local),\
    \ or\n   addresses bound to different interfaces in the case of a router or\n\
    \   multihomed host.  However, some of these interface addresses may not\n   be\
    \ usable by the peer.  A node MUST follow a policy of using a global\n   address\
    \ of the same IP version as in the MRI, unless it can establish\n   that an alternative\
    \ address would also be usable.\n   The setting and interpretation of the IP-TTL\
    \ field depends on the\n   message direction (upstream/downstream as determined\
    \ from the MRI as\n   described above) and encapsulation.\n      *  If the message\
    \ is sent downstream, if the TTL that will be set\n         in the IP header for\
    \ the message can be determined, the IP-TTL\n         value MUST be set to this\
    \ value, or else set to 0.\n      *  On receiving a downstream message in D-mode,\
    \ a non-zero IP-TTL\n         is compared to the TTL in the IP header, and the\
    \ difference is\n         stored as the IP-hop-count-to-peer for the upstream\
    \ peer in the\n         routing state table for that flow.  Otherwise, the field\
    \ is\n         ignored.\n      *  If the message is sent upstream, the IP-TTL\
    \ MUST be set to the\n         value of the IP-hop-count-to-peer stored in the\
    \ routing state\n         table, or 0 if there is no value yet stored.\n     \
    \ *  On receiving an upstream message, the IP-TTL is stored as the\n         IP-hop-count-to-peer\
    \ for the downstream peer.\n      In all cases, the IP-TTL value reported to signalling\
    \ applications\n      is the one stored with the routing state for that flow,\
    \ after it\n      has been updated if necessary from processing the message in\n\
    \      question.\n   Stack-Proposal:  This field contains information about which\n\
    \      combinations of transport and security protocols are available for\n  \
    \    use in messaging associations, and is also discussed further in\n      Section\
    \ 5.7.\n       Stack-Proposal = 1*stack-profile\n       stack-profile = protocol-count\
    \ 1*protocol-layer\n                       ;; padded on the right with 0 to 32-bit\
    \ boundary\n       protocol-count = %x01-FF\n                       ;; number\
    \ of the following <protocol-layer>,\n                       ;; represented as\
    \ one byte.  This doesn't include\n                       ;; padding.\n      \
    \ protocol-layer = %x01-FF\n   Each protocol-layer field identifies a protocol\
    \ with a unique tag;\n   any additional data, such as higher-layer addressing\
    \ or other options\n   data associated with the protocol, will be carried in an\n\
    \   MA-protocol-options field in the Stack-Configuration-Data TLV (see\n   below).\n\
    \   Stack-Configuration-Data (SCD):  This object carries information\n      about\
    \ the overall configuration of a messaging association.\n       Stack-Configuration-Data\
    \ = MA-Hold-Time\n                                  0*MA-protocol-options\n  \
    \ The MA-Hold-Time field indicates how long a node will hold open an\n   inactive\
    \ association; see Section 4.4.5 for more discussion.  The\n   MA-protocol-options\
    \ fields give the configuration of the protocols\n   (e.g., TCP, TLS) to be used\
    \ for new messaging associations, and they\n   are described in more detail in\
    \ Section 5.7.\n   Query-Cookie/Responder-Cookie:  A Query-Cookie is contained\
    \ in a\n      Query and MUST be echoed in a Response; a Responder-Cookie MAY be\n\
    \      sent in a Response, and if present MUST be echoed in the following\n  \
    \    Confirm.  Cookies are variable-length bit strings, chosen by the\n      cookie\
    \ generator.  See Section 8.5 for further details on\n      requirements and mechanisms\
    \ for cookie generation.\n   Hello-ID:  The Hello-ID is a 32-bit quantity that\
    \ is used to\n      correlate messages in an MA-Hello request/reply exchange.\
    \  A non-\n      zero value MUST be used in a request (messages sent with R=1)\
    \ and\n      the same value must be returned in the reply (which has R=0).  The\n\
    \      value zero MUST be used for all other messages; if a message is\n     \
    \ received with R=1 and Hello-ID=0, an \"Object Value Error\" message\n      (Appendix\
    \ A.4.4.10) with subcode 1 (\"Value Not Supported\") MUST be\n      returned and\
    \ the message dropped.  Nodes MAY use any algorithm to\n      generate the Hello-ID;\
    \ a suitable approach is a local sequence\n      number with a random starting\
    \ point.\n   NSLP-Data:  The NSLP payload to be delivered to the signalling\n\
    \      application.  GIST does not interpret the payload content.\n   GIST-Error-Data:\
    \  This contains the information to report the cause\n      and context of an\
    \ error.\n       GIST-Error-Data = error-class error-code error-subcode\n    \
    \                     common-error-header\n                         [ Message-Routing-Information-content\
    \ ]\n                         [ Session-Identification-content ]\n           \
    \              0*additional-information\n                         [ comment ]\n\
    \   The error-class indicates the severity level, and the error-code and\n   error-subcode\
    \ identify the specific error itself.  A full list of\n   GIST errors and their\
    \ severity levels is given in Appendix A.4.  The\n   common-error-header carries\
    \ the Common-Header from the original\n   message, and contents of the Message-Routing-Information\
    \ (MRI) and\n   Session-Identifier (SID) objects are also included if they were\n\
    \   successfully decoded.  For some errors, additional information fields\n  \
    \ can be included, and these fields themselves have a simple TLV\n   format. \
    \ Finally, an optional free-text comment may be added.\n"
- title: 5.3.  D-mode Transport
  contents:
  - "5.3.  D-mode Transport\n   This section describes the various encapsulation options\
    \ for D-mode\n   messages.  Although there are several possibilities, depending\
    \ on\n   message type, MRM, and local policy, the general design principle is\n\
    \   that the sole purpose of the encapsulation is to ensure that the\n   message\
    \ is delivered to or intercepted at the correct peer.  Beyond\n   that, minimal\
    \ significance is attached to the type of encapsulation\n   or the values of addresses\
    \ or ports used for it.  This allows new\n   options to be developed in the future\
    \ to handle particular deployment\n   requirements without modifying the overall\
    \ protocol specification.\n"
- title: 5.3.1.  Normal Encapsulation
  contents:
  - "5.3.1.  Normal Encapsulation\n   Normal encapsulation MUST be used for all D-mode\
    \ messages where the\n   signalling peer is already known from previous signalling.\
    \  This\n   includes Response and Confirm messages, and Data messages except if\n\
    \   these are being sent without using local routing state.  Normal\n   encapsulation\
    \ is simple: the message is carried in a single UDP\n   datagram.  UDP checksums\
    \ MUST be enabled.  The UDP payload MUST\n   always begin with a 32-bit magic\
    \ number with value 0x4e04 bda5 in\n   network byte order; this is followed by\
    \ the GIST common header and\n   the complete set of payloads.  If the magic number\
    \ is not present,\n   the message MUST be silently dropped.  The normal encapsulation\
    \ is\n   shown in outline in Figure 6.\n         0                   1       \
    \            2                   3\n        0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6\
    \ 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \       //                          IP Header                          //\n  \
    \     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n    \
    \   //                         UDP Header                          //\n      \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n       |\
    \                GIST Magic Number (0x4e04bda5)                 |\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \       //                     GIST Common Header                      //\n  \
    \     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n    \
    \   //                        GIST Payloads                        //\n      \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n        \
    \       Figure 6: Normal Encapsulation Packet Format\n   The message is IP addressed\
    \ directly to the adjacent peer as given by\n   the routing state table.  Where\
    \ the message is a direct reply to a\n   Query and no routing state exists, the\
    \ destination address is derived\n   from the input message using the same rules\
    \ as in Section 4.4.1.  The\n   UDP port numbering MUST be compatible with that\
    \ used on Query\n   messages (see below), that is, the same for messages in the\
    \ same\n   direction and with source and destination port numbers swapped for\n\
    \   messages in the opposite direction.  Messages with the normal\n   encapsulation\
    \ MUST be sent with source addressing mode flag S=1\n   unless the message is\
    \ a reply to a message that is known to have\n   passed through a NAT, and the\
    \ receiver MUST check the IP source\n   address with the interface-address given\
    \ in the NLI as part of legacy\n   NAT detection.  Both these aspects of message\
    \ processing are\n   discussed further in Section 7.2.1.\n"
- title: 5.3.2.  Q-mode Encapsulation
  contents:
  - "5.3.2.  Q-mode Encapsulation\n   Q-mode encapsulation MUST be used for messages\
    \ where no routing state\n   is available or where the routing state is being\
    \ refreshed, in\n   particular, for Query messages.  Q-mode can also be used when\n\
    \   requested by local policy.  Q-mode encapsulation is similar to normal\n  \
    \ encapsulation, with changes in IP address selection, rules about IP\n   options,\
    \ and a defined method for selecting UDP ports.\n   It is an essential property\
    \ of the Q-mode encapsulation that it is\n   possible for a GIST node to intercept\
    \ these messages efficiently even\n   when they are not directly addressed to\
    \ it and, conversely, that it\n   is possible for a non-GIST node to ignore these\
    \ messages without\n   overloading the slow path packet processing.  This document\
    \ specifies\n   that interception is done based on RAOs.\n"
- title: 5.3.2.1.  Encapsulation and Interception in IPv4
  contents:
  - "5.3.2.1.  Encapsulation and Interception in IPv4\n   In general, the IP addresses\
    \ are derived from information in the MRI;\n   the exact rules depend on the MRM.\
    \  For the case of messages with\n   source addressing mode flag S=1, the receiver\
    \ MUST check the IP\n   source address against the interface-address given in\
    \ the NLI as part\n   of legacy NAT detection; see Section 7.2.1.\n   Current\
    \ MRMs define the use of a Router Alert Option [13] to assist\n   the peer in\
    \ intercepting the message depending on the NSLPID.  If the\n   MRM defines the\
    \ use of RAO, the sender MUST include it unless it has\n   been specifically configured\
    \ not to (see below).  A node MAY make the\n   initial interception decision based\
    \ purely on IP-Protocol number\n   transport header analysis.  Implementations\
    \ MAY provide an option to\n   disable the setting of RAO on Q-mode packets on\
    \ a per-destination\n   prefix basis; however, the option MUST be disabled by\
    \ default and\n   MUST only be enabled when it has been separately verified that\
    \ the\n   next GIST node along the path to the destination is capable of\n   intercepting\
    \ packets without RAO.  The purpose of this option is to\n   allow operation across\
    \ networks that do not properly support RAO;\n   further details are discussed\
    \ in Appendix C.\n   It is likely that fragmented datagrams will not be correctly\n\
    \   intercepted in the network, since the checks that a datagram is a\n   Q-mode\
    \ packet depend on data beyond the IP header.  Therefore, the\n   sender MUST\
    \ set the Don't Fragment (DF) bit in the IPv4 header.  Note\n   that ICMP \"packet\
    \ too large\" messages will be sent to the source\n   address of the original\
    \ IP datagram, and since all MRM definitions\n   recommend S=1 for at least some\
    \ retransmissions, ICMP errors related\n   to fragmentation will be seen at the\
    \ Querying node.\n   The upper layer protocol, identified by the IP-Protocol field\
    \ in the\n   IP header, MUST be UDP.\n"
- title: 5.3.2.2.  Encapsulation and Interception in IPv6
  contents:
  - "5.3.2.2.  Encapsulation and Interception in IPv6\n   As for IPv4, the IP addresses\
    \ are derived from information in the\n   MRI; the exact rules depend on the MRM.\
    \  For the case of messages\n   with source addressing mode flag S=1, the receiver\
    \ MUST check the IP\n   source address with the interface-address given in the\
    \ NLI as part of\n   legacy NAT detection; see Section 7.2.1.\n   For all current\
    \ MRMs, the IP header is given a Router Alert Option\n   [8] to assist the peer\
    \ in intercepting the message depending on the\n   NSLPID.  If the MRM defines\
    \ the use of RAO, the sender MUST include\n   it without exception.  It is RECOMMENDED\
    \ that a node bases its\n   initial interception decision purely on the presence\
    \ of a hop-by-hop\n   option header containing the RAO, which will be at the start\
    \ of the\n   header chain.\n   The upper layer protocol MUST be UDP without intervening\n\
    \   encapsulation layers.  Following any hop-by-hop option header, the IP\n  \
    \ header MUST NOT include any extension headers other than routing or\n   destination\
    \ options [5], and for the last extension header MUST have\n   a next-header field\
    \ of UDP.\n"
- title: 5.3.2.3.  Upper Layer Encapsulation and Overall Interception
  contents:
  - "5.3.2.3.  Upper Layer Encapsulation and Overall Interception\n          Requirements\n\
    \   For both IP versions, the above rules require that the upper layer\n   protocol\
    \ identified by the IP header MUST be UDP.  Other packets MUST\n   NOT be identified\
    \ as GIST Q-mode packets; this includes IP-in-IP\n   tunnelled packets, other\
    \ tunnelled packets (tunnel mode AH/ESP), or\n   packets that have undergone some\
    \ additional transport layer\n   processing (transport mode AH/ESP).  If IP output\
    \ processing at the\n   originating node or an intermediate router causes such\
    \ additional\n   encapsulations to be added to a GIST Q-mode packet, this packet\
    \ will\n   not be identified as GIST until the encapsulation is terminated.  If\n\
    \   the node wishes to signal for data over the network region where the\n   encapsulation\
    \ applies, it MUST generate additional signalling with an\n   MRI matching the\
    \ encapsulated traffic, and the outbound GIST Q-mode\n   messages for it MUST\
    \ bypass the encapsulation processing.\n   Therefore, the final stage of the interception\
    \ process and the final\n   part of encapsulation is at the UDP level.  The source\
    \ UDP port is\n   selected by the message sender as the port at which it is prepared\
    \ to\n   receive UDP messages in reply, and the sender MUST use the\n   destination\
    \ UDP port allocated for GIST by IANA (see Section 9).\n   Note that for some\
    \ MRMs, GIST nodes anywhere along the path can\n   generate GIST packets with\
    \ source addresses that spoof the source\n   address of the data flow.  Therefore,\
    \ destinations cannot distinguish\n   these packets from genuine end-to-end data\
    \ purely on address\n   analysis.  Instead, it must be possible to distinguish\
    \ such GIST\n   packets by port analysis; furthermore, the mechanism to do so\
    \ must\n   remain valid even if the destination is GIST-unaware.  GIST solves\n\
    \   this problem by using a fixed destination UDP port from the \"well\n   known\"\
    \ space for the Q-mode encapsulation.  This port should never be\n   allocated\
    \ on a GIST-unaware host, and therefore Q-mode encapsulated\n   messages should\
    \ always be rejected with an ICMP error.  The usage of\n   this destination port\
    \ by other applications will result in reduced\n   performance due to increased\
    \ delay and packet drop rates due to their\n   interception by GIST nodes.\n \
    \  A GIST node will need to be capable to filter out all IP/UDP packets\n   that\
    \ have a UDP destination port number equal to the one registered\n   for GIST\
    \ Q-mode encapsulation.  These packets SHOULD then be further\n   verified to\
    \ be GIST packets by checking the magic number (see\n   Section 5.3.1).  The packets\
    \ that meet both port and magic number\n   requirements are further processed\
    \ as GIST Q-mode packets.  Any\n   filtered packets that fail this GIST magic\
    \ number check SHOULD be\n   forwarded towards the IP packet's destination as\
    \ a normal IP\n   datagram.  To protect against denial-of-service attacks, a GIST\
    \ node\n   SHOULD have a rate limiter preventing more packets (filtered as\n \
    \  potential Q-mode packets) from being processed than the system can\n   safely\
    \ handle.  Any excess packets SHOULD be discarded.\n"
- title: 5.3.2.4.  IP Option Processing
  contents:
  - "5.3.2.4.  IP Option Processing\n   For both IPv4 and IPv6, for Q-mode packets\
    \ with IP options allowed by\n   the above requirements, IP options processing\
    \ is intended to be\n   carried out independently of GIST processing.  Note that\
    \ for the\n   options allowed by the above rules, the option semantics are\n \
    \  independent of the payload: UDP payload modifications are not\n   prevented\
    \ by the options and do not affect the option content, and\n   conversely the\
    \ presence of the options does not affect the UDP\n   payload.\n   On packets\
    \ originated by GIST, IP options MAY be added according to\n   node-local policies\
    \ on outgoing IP data.  On packets forwarded by\n   GIST without NSLP processing,\
    \ IP options MUST be processed as for a\n   normally forwarded IP packet.  On\
    \ packets locally delivered to the\n   NSLP, the IP options MAY be passed to the\
    \ NSLP and equivalent options\n   used on subsequently generated outgoing Q-mode\
    \ packets.  In this\n   case, routing related options SHOULD be processed identically\
    \ as they\n   would be for a normally forwarded IP packet.\n"
- title: 5.3.3.  Retransmission and Rate Control
  contents:
  - "5.3.3.  Retransmission and Rate Control\n   D-mode uses UDP, and hence has no\
    \ automatic reliability or congestion\n   control capabilities.  Signalling applications\
    \ requiring reliability\n   should be serviced using C-mode, which should also\
    \ carry the bulk of\n   signalling traffic.  However, some form of messaging reliability\
    \ is\n   required for the GIST control messages themselves, as is rate control\n\
    \   to handle retransmissions and also bursts of unreliable signalling or\n  \
    \ state setup requests from the signalling applications.\n   Query messages that\
    \ do not receive Responses MAY be retransmitted;\n   retransmissions MUST use\
    \ a binary exponential backoff.  The initial\n   timer value is T1, which the\
    \ backoff process can increase up to a\n   maximum value of T2 seconds.  The default\
    \ value for T1 is 500 ms.  T1\n   is an estimate of the round-trip time between\
    \ the Querying and\n   Responding nodes.  Nodes MAY use smaller values of T1 if\
    \ it is known\n   that the Query should be answered within the local network.\
    \  T1 MAY\n   be chosen larger, and this is RECOMMENDED if it is known in advance\n\
    \   (such as on high-latency access links) that the round-trip time is\n   larger.\
    \  The default value of T2 is 64*T1.  Note that Queries may go\n   unanswered\
    \ either because of message loss (in either direction) or\n   because there is\
    \ no reachable GIST peer.  Therefore, implementations\n   MAY trade off reliability\
    \ (large T2) against promptness of error\n   feedback to applications (small T2).\
    \  If the NSLP has indicated a\n   timeout on the validity of this payload (see\
    \ Appendix B.1), T2 MUST\n   be chosen so that the process terminates within this\
    \ timeout.\n   Retransmitted Queries MUST use different Query-Cookie values. \
    \ If the\n   Query carries NSLP data, it may be delivered multiple times to the\n\
    \   signalling application.  These rules apply equally to the message\n   that\
    \ first creates routing state, and those that refresh it.  In all\n   cases, Responses\
    \ MUST be sent promptly to avoid spurious\n   retransmissions.  Nodes generating\
    \ any type of retransmission MUST be\n   prepared to receive and match a reply\
    \ to any of them, not just the\n   one most recently sent.  Although a node SHOULD\
    \ terminate its\n   retransmission process when any reply is received, it MUST\
    \ continue\n   to process further replies as normal.\n   This algorithm is sufficient\
    \ to handle lost Queries and Responses.\n   The case of a lost Confirm is more\
    \ subtle.  The Responding node MAY\n   run a retransmission timer to resend the\
    \ Response until a Confirm is\n   received; the timer MUST use the same backoff\
    \ mechanism and\n   parameters as for Responses.  The problem of an amplification\
    \ attack\n   stimulated by a malicious Query is handled by requiring the cookie\n\
    \   mechanism to enable the node receiving the Response to discard it\n   efficiently\
    \ if it does not match a previously sent Query.  This\n   approach is only appropriate\
    \ if the Responding node is prepared to\n   store per-flow state after receiving\
    \ a single (Query) message, which\n   includes the case where the node has queued\
    \ NSLP data.  If the\n   Responding node has delayed state installation, the error\
    \ condition\n   will only be detected when a Data message arrives.  This is handled\n\
    \   as a routing state error (see Section 4.4.6) that causes the Querying\n  \
    \ node to restart the handshake.\n   The basic rate-control requirements for D-mode\
    \ traffic are\n   deliberately minimal.  A single rate limiter applies to all\
    \ traffic,\n   for all interfaces and message types.  It applies to retransmissions\n\
    \   as well as new messages, although an implementation MAY choose to\n   prioritise\
    \ one over the other.  Rate-control applies only to locally\n   generated D-mode\
    \ messages, not to messages that are being forwarded.\n   When the rate limiter\
    \ is in effect, D-mode messages MUST be queued\n   until transmission is re-enabled,\
    \ or they MAY be dropped with an\n   error condition indicated back to local signalling\
    \ applications.  In\n   either case, the effect of this will be to reduce the\
    \ rate at which\n   new transactions can be initiated by signalling applications,\
    \ thereby\n   reducing the load on the network.\n   The rate-limiting mechanism\
    \ is implementation-defined, but it is\n   RECOMMENDED that a token bucket limiter\
    \ as described in [33] be used.\n   The token bucket MUST be sized to ensure that\
    \ a node cannot saturate\n   the network with D-mode traffic, for example, when\
    \ re-probing the\n   network for multiple flows after a route change.  A suitable\
    \ approach\n   is to restrict the token bucket parameters so that the mean output\n\
    \   rate is a small fraction of the node's lowest-speed interface.  It is\n  \
    \ RECOMMENDED that this fraction is no more than 5%.  Note that\n   according\
    \ to the rules of Section 4.3.3, in general, D-mode SHOULD\n   only be used for\
    \ Queries and Responses rather than normal signalling\n   traffic unless capacity\
    \ for normal signalling traffic can be\n   engineered.\n"
- title: 5.4.  C-mode Transport
  contents:
  - "5.4.  C-mode Transport\n   It is a requirement of the NTLP defined in [29] that\
    \ it should be\n   able to support bundling of small messages, fragmentation of\
    \ large\n   messages, and message boundary delineation.  TCP provides both\n \
    \  bundling and fragmentation, but not message boundaries.  However, the\n   length\
    \ information in the GIST common header allows the message\n   boundary to be\
    \ discovered during parsing.  The bundling together of\n   small messages either\
    \ can be done within the transport protocol or\n   can be carried out by GIST\
    \ during message construction.  Either way,\n   two approaches can be distinguished:\n\
    \   1.  As messages arrive for transmission, they are gathered into a\n      \
    \ bundle until a size limit is reached or a timeout expires (cf.\n       the Nagle\
    \ algorithm of TCP).  This provides maximal efficiency at\n       the cost of\
    \ some latency.\n   2.  Messages awaiting transmission are gathered together while\
    \ the\n       node is not allowed to send them, for example, because it is\n \
    \      congestion controlled.\n   The second type of bundling is always appropriate.\
    \  For GIST, the\n   first type MUST NOT be used for trigger messages (i.e., messages\
    \ that\n   update GIST or signalling application state), but may be appropriate\n\
    \   for refresh messages (i.e., messages that just extend timers).  These\n  \
    \ distinctions are known only to the signalling applications, but MAY\n   be indicated\
    \ (as an implementation issue) by setting the priority\n   transfer attribute\
    \ (Section 4.1.2).\n   It can be seen that all of these transport protocol options\
    \ can be\n   supported by the basic GIST message format already presented.  The\n\
    \   GIST message, consisting of common header and TLVs, is carried\n   directly\
    \ in the transport protocol, possibly incorporating transport\n   layer security\
    \ protection.  Further messages can be carried in a\n   continuous stream.  This\
    \ specification defines only the use of TCP,\n   but other possibilities could\
    \ be included without additional work on\n   message formatting.\n"
- title: 5.5.  Message Type/Encapsulation Relationships
  contents:
  - "5.5.  Message Type/Encapsulation Relationships\n   GIST has four primary message\
    \ types (Query, Response, Confirm, and\n   Data) and three possible encapsulation\
    \ methods (normal D-mode,\n   Q-mode, and C-mode).  The combinations of message\
    \ type and\n   encapsulation that are allowed for message transmission are given\
    \ in\n   the table below.  In some cases, there are several possible choices,\n\
    \   depending on the existence of routing state or messaging\n   associations.\
    \  The rules governing GIST policy, including whether or\n   not to create such\
    \ state to handle a message, are described\n   normatively in the other sections\
    \ of this specification.  If a\n   message that can only be sent in Q-mode or\
    \ D-mode arrives in C-mode\n   or vice versa, this MUST be rejected with an \"\
    Incorrect\n   Encapsulation\" error message (Appendix A.4.4.3).  However, it should\n\
    \   be noted that the processing of the message at the receiver is not\n   otherwise\
    \ affected by the encapsulation method used, except that the\n   decapsulation\
    \ process may provide additional information, such as\n   translated addresses\
    \ or IP hop count to be used in the subsequent\n   message processing.\n   +----------+--------------+---------------------------+-------------+\n\
    \   |  Message |    Normal    |   Query D-mode (Q-mode)   |    C-mode   |\n  \
    \ |          |    D-mode    |                           |             |\n   +----------+--------------+---------------------------+-------------+\n\
    \   |   Query  |     Never    |   Always, with C-flag=1   |    Never    |\n  \
    \ |          |              |                           |             |\n   |\
    \ Response |   Unless a   |           Never           |     If a    |\n   |  \
    \        |   messaging  |                           |  messaging  |\n   |    \
    \      |  association |                           | association |\n   |      \
    \    |   is being   |                           |   is being  |\n   |        \
    \  |    re-used   |                           |   re-used   |\n   |          |\
    \              |                           |             |\n   |  Confirm |  Only\
    \ if no  |           Never           |     If a    |\n   |          |   messaging\
    \  |                           |  messaging  |\n   |          |  association |\
    \                           | association |\n   |          | has been set |  \
    \                         |   has been  |\n   |          |   up or is   |    \
    \                       |  set up or  |\n   |          |     being    |      \
    \                     |   is being  |\n   |          |    re-used   |        \
    \                   |   re-used   |\n   |          |              |          \
    \                 |             |\n   |   Data   |  If routing  | If the MRI can\
    \ be used to |     If a    |\n   |          | state exists |     derive the Q-mode\
    \     |  messaging  |\n   |          | for the flow | encapsulation, and either\
    \ | association |\n   |          |    but no    |  no routing state exists  |\
    \    exists   |\n   |          |   messaging  |  or local policy requires |  \
    \           |\n   |          |  association |     Q-mode; MUST have     |    \
    \         |\n   |          |              |          C-flag=1         |      \
    \       |\n   +----------+--------------+---------------------------+-------------+\n"
- title: 5.6.  Error Message Processing
  contents:
  - "5.6.  Error Message Processing\n   Special rules apply to the encapsulation and\
    \ transmission of Error\n   messages.\n   GIST only generates Error messages in\
    \ reaction to incoming messages.\n   Error messages MUST NOT be generated in reaction\
    \ to incoming Error\n   messages.  The routing and encapsulation of the Error\
    \ message are\n   derived from that of the message that caused the error; in\n\
    \   particular, local routing state is not consulted.  Routing state and\n   messaging\
    \ association state MUST NOT be created to handle the error,\n   and Error messages\
    \ MUST NOT be retransmitted explicitly by GIST,\n   although they are subject\
    \ to the same rate control as other messages.\n   o  If the incoming message was\
    \ received in D-mode, the error MUST be\n      sent in D-mode using the normal\
    \ encapsulation, using the\n      addressing information from the NLI object in\
    \ the incoming\n      message.  If the NLI could not be determined, the error\
    \ MUST be\n      sent to the IP source of the incoming message if the S-flag was\n\
    \      set in it.  The NLI object in the Error message reports\n      information\
    \ about the originator of the error.\n   o  If the incoming message was received\
    \ over a messaging association,\n      the error MUST be sent back over the same\
    \ messaging association.\n   The NSLPID in the common header of the Error message\
    \ has the value\n   zero.  If for any reason the message cannot be sent (for example,\n\
    \   because it is too large to send in D-mode, or because the MA over\n   which\
    \ the original message arrived has since been closed), an error\n   SHOULD be\
    \ logged locally.  The receiver of the Error message can\n   infer the NSLPID\
    \ for the message that caused the error from the\n   Common Header that is embedded\
    \ in the Error Object.\n"
- title: 5.7.  Messaging Association Setup
  contents:
  - '5.7.  Messaging Association Setup

    '
- title: 5.7.1.  Overview
  contents:
  - "5.7.1.  Overview\n   A key attribute of GIST is that it is flexible in its ability\
    \ to use\n   existing transport and security protocols.  Different transport\n\
    \   protocols may have performance attributes appropriate to different\n   environments;\
    \ different security protocols may fit appropriately with\n   different authentication\
    \ infrastructures.  Even given an initial\n   default mandatory protocol set for\
    \ GIST, the need to support new\n   protocols in the future cannot be ruled out,\
    \ and secure feature\n   negotiation cannot be added to an existing protocol in\
    \ a backwards-\n   compatible way.  Therefore, some sort of capability discovery\
    \ is\n   required.\n   Capability discovery is carried out in Query and Response\
    \ messages,\n   using Stack-Proposal and Stack-Configuration-Data (SCD) objects.\
    \  If\n   a new messaging association is required, it is then set up, followed\n\
    \   by a Confirm.  Messaging association multiplexing is achieved by\n   short-circuiting\
    \ this exchange by sending the Response or Confirm\n   messages on an existing\
    \ association (Section 4.4.3); whether to do\n   this is a matter of local policy.\
    \  The end result of this process is\n   a messaging association that is a stack\
    \ of protocols.  If multiple\n   associations exist, it is a matter of local policy\
    \ how to distribute\n   messages over them, subject to respecting the transfer\
    \ attributes\n   requested for each message.\n   Every possible protocol for a\
    \ messaging association has the following\n   attributes:\n   o  MA-Protocol-ID,\
    \ a 1-byte IANA-assigned value (see Section 9).\n   o  A specification of the\
    \ (non-negotiable) policies about how the\n      protocol should be used, for\
    \ example, in which direction a\n      connection should be opened.\n   o  (Depending\
    \ on the specific protocol:) Formats for an MA-protocol-\n      options field\
    \ to carry the protocol addressing and other\n      configuration information\
    \ in the SCD object.  The format may\n      differ depending on whether the field\
    \ is present in the Query or\n      Response.  Some protocols do not require the\
    \ definition of such\n      additional data, in which case no corresponding MA-protocol-\n\
    \      options field will occur in the SCD object.\n   A Stack-Proposal object\
    \ is simply a list of profiles; each profile is\n   a sequence of MA-Protocol-IDs.\
    \  A profile lists the protocols in 'top\n   to bottom' order (e.g., TLS over\
    \ TCP).  A Stack-Proposal is generally\n   accompanied by an SCD object that carries\
    \ an MA-protocol-options\n   field for any protocol listed in the Stack-Proposal\
    \ that needs it.\n   An MA-protocol-options field may apply globally, to all instances\
    \ of\n   the protocol in the Stack-Proposal, or it can be tagged as applying\n\
    \   to a specific instance.  The latter approach can for example be used\n   to\
    \ carry different port numbers for TCP depending on whether it is to\n   be used\
    \ with or without TLS.  An message flow that shows several of\n   the features\
    \ of Stack-Proposal and Stack-Configuration-Data formats\n   can be found in Appendix\
    \ D.\n   An MA-protocol-options field may also be flagged as not usable; for\n\
    \   example, a NAT that could not handle SCTP would set this in an MA-\n   protocol-options\
    \ field about SCTP.  A protocol flagged this way MUST\n   NOT be used for a messaging\
    \ association.  If the Stack-Proposal and\n   SCD are both present but not consistent,\
    \ for example, if they refer\n   to different protocols, or an MA-protocol-options\
    \ field refers to a\n   non-existent profile, an \"Object Value Error\" message\n\
    \   (Appendix A.4.4.10) with subcode 5 (\"Stack-Proposal - Stack-\n   Configuration-Data\
    \ Mismatch\") MUST be returned and the message\n   dropped.\n   A node generating\
    \ an SCD object MUST honour the implied protocol\n   configurations for the period\
    \ during which a messaging association\n   might be set up; in particular, it\
    \ MUST be immediately prepared to\n   accept incoming datagrams or connections\
    \ at the protocol/port\n   combinations advertised.  This MAY require the creation\
    \ of listening\n   endpoints for the transport and security protocols in question,\
    \ or a\n   node MAY keep a pool of such endpoints open for extended periods.\n\
    \   However, the received object contents MUST be retained only for the\n   duration\
    \ of the Query/Response exchange and to allow any necessary\n   association setup\
    \ to complete.  They may become invalid because of\n   expired bindings at intermediate\
    \ NATs, or because the advertising\n   node is using agile ports.  Once the setup\
    \ is complete, or if it is\n   not necessary or fails for some reason, the object\
    \ contents MUST be\n   discarded.  A default time of 30 seconds to keep the contents\
    \ is\n   RECOMMENDED.\n   A Query requesting messaging association setup always\
    \ contains a\n   Stack-Proposal and SCD object.  The Stack-Proposal MUST only\
    \ include\n   protocol configurations that are suitable for the transfer attributes\n\
    \   of the messages for which the Querying node wishes to use the\n   messaging\
    \ association.  For example, it should not simply include all\n   configurations\
    \ that the Querying node is capable of supporting.\n   The Response always contains\
    \ a Stack-Proposal and SCD object, unless\n   multiplexing (where the Responder\
    \ decides to use an existing\n   association) occurs.  For such a Response, the\
    \ security protocols\n   listed in the Stack-Proposal MUST NOT depend on the Query.\
    \  A node\n   MAY make different proposals depending on the combination of\n \
    \  interface and NSLPID.  If multiplexing does occur, which is indicated\n   by\
    \ sending the Response over an existing messaging association, the\n   following\
    \ rules apply:\n   o  The re-used messaging association MUST NOT have weaker security\n\
    \      properties than all of the options that would have been offered in\n  \
    \    the full Response that would have been sent without re-use.\n   o  The re-used\
    \ messaging association MUST have equivalent or better\n      transport and security\
    \ characteristics as at least one of the\n      protocol configurations that was\
    \ offered in the Query.\n   Once the messaging association is set up, the Querying\
    \ node repeats\n   the responder's Stack-Proposal over it in the Confirm.  The\n\
    \   Responding node MUST verify that this has not been changed as part of\n  \
    \ bidding-down attack prevention, as well as verifying the Responder-\n   Cookie\
    \ (Section 8.5).  If either check fails, the Responding node\n   MUST NOT create\
    \ the message routing state (or MUST delete it if it\n   already exists) and SHOULD\
    \ log an error condition locally.  If this\n   is the first message on a new MA,\
    \ the MA MUST be torn down.  See\n   Section 8.6 for further discussion.\n"
- title: '5.7.2.  Protocol Definition: Forwards-TCP'
  contents:
  - "5.7.2.  Protocol Definition: Forwards-TCP\n   This MA-Protocol-ID denotes a basic\
    \ use of TCP between peers.\n   Support for this protocol is REQUIRED.  If this\
    \ protocol is offered,\n   MA-protocol-options data MUST also be carried in the\
    \ SCD object.  The\n   MA-protocol-options field formats are:\n   o  in a Query:\
    \ no additional options data (the MA-protocol-options\n      Length field is zero).\n\
    \   o  in a Response: 2-byte port number at which the connection will be\n   \
    \   accepted, followed by 2 pad bytes.\n   The connection is opened in the forwards\
    \ direction, from the Querying\n   node towards the responder.  The Querying node\
    \ MAY use any source\n   address and source port.  The destination information\
    \ MUST be derived\n   from information in the Response: the address from the interface-\n\
    \   address from the Network-Layer-Information object and the port from\n   the\
    \ SCD object as described above.\n   Associations using Forwards-TCP can carry\
    \ messages with the transfer\n   attribute Reliable=True.  If an error occurs\
    \ on the TCP connection\n   such as a reset, as can be detected for example by\
    \ a socket exception\n   condition, GIST MUST report this to NSLPs as discussed\
    \ in\n   Section 4.1.2.\n"
- title: '5.7.3.  Protocol Definition: Transport Layer Security'
  contents:
  - "5.7.3.  Protocol Definition: Transport Layer Security\n   This MA-Protocol-ID\
    \ denotes a basic use of transport layer channel\n   security, initially in conjunction\
    \ with TCP.  Support for this\n   protocol in conjunction with TCP is REQUIRED;\
    \ associations using it\n   can carry messages with transfer attributes requesting\n\
    \   confidentiality or integrity protection.  The specific TLS version\n   will\
    \ be negotiated within the TLS layer itself, but implementations\n   MUST NOT\
    \ negotiate to protocol versions prior to TLS1.0 [15] and MUST\n   use the highest\
    \ protocol version supported by both peers.\n   Implementation of TLS1.2 [10]\
    \ is RECOMMENDED.  GIST nodes supporting\n   TLS1.0 or TLS1.1 MUST be able to\
    \ negotiate the TLS ciphersuite\n   TLS_RSA_WITH_3DES_EDE_CBC_SHA and SHOULD be\
    \ able to negotiate the TLS\n   ciphersuite TLS_RSA_WITH_AES_128_CBC_SHA.  They\
    \ MAY negotiate any\n   mutually acceptable ciphersuite that provides authentication,\n\
    \   integrity, and confidentiality.\n   The default mode of TLS authentication,\
    \ which applies in particular\n   to the above ciphersuites, uses a client/server\
    \ X.509 certificate\n   exchange.  The Querying node acts as a TLS client, and\
    \ the Responding\n   node acts as a TLS server.  Where one of the above ciphersuites\
    \ is\n   negotiated, the GIST node acting as a server MUST provide a\n   certificate,\
    \ and MUST request one from the GIST node acting as a TLS\n   client.  This allows\
    \ either server-only or mutual authentication,\n   depending on the certificates\
    \ available to the client and the policy\n   applied at the server.\n   GIST nodes\
    \ MAY negotiate other TLS ciphersuites.  In some cases, the\n   negotiation of\
    \ alternative ciphersuites is used to trigger\n   alternative authentication procedures,\
    \ such as the use of pre-shared\n   keys [32].  The use of other authentication\
    \ procedures may require\n   additional specification work to define how they\
    \ can be used as part\n   of TLS within the GIST framework, and may or may not\
    \ require the\n   definition of additional MA-Protocol-IDs.\n   No MA-protocol-options\
    \ field is required for this TLS protocol\n   definition.  The configuration information\
    \ for the transport protocol\n   over which TLS is running (e.g., TCP port number)\
    \ is provided by the\n   MA-protocol-options for that protocol.\n"
- title: 5.7.3.1.  Identity Checking in TLS
  contents:
  - "5.7.3.1.  Identity Checking in TLS\n   After TLS authentication, a node MUST\
    \ check the identity presented by\n   the peer in order to avoid man-in-the-middle\
    \ attacks, and verify that\n   the peer is authorised to take part in signalling\
    \ at the GIST layer.\n   The authorisation check is carried out by comparing the\
    \ presented\n   identity with each Authorised Peer Database (APD) entry in turn,\
    \ as\n   discussed in Section 4.4.2.  This section defines the identity\n   comparison\
    \ algorithm for a single APD entry.\n   For TLS authentication with X.509 certificates,\
    \ an identity from the\n   DNS namespace MUST be checked against each subjectAltName\
    \ extension\n   of type dNSName present in the certificate.  If no such extension\
    \ is\n   present, then the identity MUST be compared to the (most specific)\n\
    \   Common Name in the Subject field of the certificate.  When matching\n   DNS\
    \ names against dNSName or Common Name fields, matching is case-\n   insensitive.\
    \  Also, a \"*\" wildcard character MAY be used as the left-\n   most name component\
    \ in the certificate or identity in the APD.  For\n   example, *.example.com in\
    \ the APD would match certificates for\n   a.example.com, foo.example.com, *.example.com,\
    \ etc., but would not\n   match example.com.  Similarly, a certificate for *.example.com\
    \ would\n   be valid for APD identities of a.example.com, foo.example.com,\n \
    \  *.example.com, etc., but not example.com.\n   Additionally, a node MUST verify\
    \ the binding between the identity of\n   the peer to which it connects and the\
    \ public key presented by that\n   peer.  Nodes SHOULD implement the algorithm\
    \ in Section 6 of [8] for\n   general certificate validation, but MAY supplement\
    \ that algorithm\n   with other validation methods that achieve equivalent levels\
    \ of\n   verification (such as comparing the server certificate against a\n  \
    \ local store of already-verified certificates and identity bindings).\n   For\
    \ TLS authentication with pre-shared keys, the identity in the\n   psk_identity_hint\
    \ (for the server identity, i.e., the Responding\n   node) or psk_identity (for\
    \ the client identity, i.e., the Querying\n   node) MUST be compared to the identities\
    \ in the APD.\n"
- title: 5.8.  Specific Message Routing Methods
  contents:
  - "5.8.  Specific Message Routing Methods\n   Each message routing method (see Section\
    \ 3.3) requires the definition\n   of the format of the message routing information\
    \ (MRI) and Q-mode\n   encapsulation rules.  These are given in the following\
    \ subsections\n   for the MRMs currently defined.  A GIST implementation on a\
    \ node MUST\n   support whatever MRMs are required by the NSLPs on that node;\
    \ GIST\n   implementations SHOULD provide support for both the MRMs defined\n\
    \   here, in order to minimise deployment barriers for new signalling\n   applications\
    \ that need them.\n"
- title: 5.8.1.  The Path-Coupled MRM
  contents:
  - '5.8.1.  The Path-Coupled MRM

    '
- title: 5.8.1.1.  Message Routing Information
  contents:
  - "5.8.1.1.  Message Routing Information\n   For the path-coupled MRM, the message\
    \ routing information (MRI) is\n   conceptually the Flow Identifier as in the\
    \ NSIS framework [29].\n   Minimally, this could just be the flow destination\
    \ address; however,\n   to account for policy-based forwarding and other issues\
    \ a more\n   complete set of header fields SHOULD be specified if possible (see\n\
    \   Section 4.3.4 and Section 7.2 for further discussion).\n       MRI = network-layer-version\n\
    \             source-address prefix-length\n             destination-address prefix-length\n\
    \             IP-protocol\n             diffserv-codepoint\n             [ flow-label\
    \ ]\n             [ ipsec-SPI / L4-ports]\n   Additional control information defines\
    \ whether the flow-label, IPsec\n   Security Parameters Index (SPI), and port\
    \ information are present,\n   and whether the IP-protocol and diffserv-codepoint\
    \ fields should be\n   interpreted as significant.  The source and destination\
    \ addresses\n   MUST be real node addresses, but prefix lengths other than 32\
    \ or 128\n   (for IPv4 and IPv6, respectively) MAY be used to implement address\n\
    \   wildcarding, allowing the MRI to refer to traffic to or from a wider\n   address\
    \ range.  An additional flag defines the message direction\n   relative to the\
    \ MRI (upstream vs. downstream).\n   The MRI format allows a potentially very\
    \ large number of different\n   flag and field combinations.  A GIST implementation\
    \ that cannot\n   interpret the MRI in a message MUST return an \"Object Value\
    \ Error\"\n   message (Appendix A.4.4.10) with subcodes 1 (\"Value Not Supported\"\
    )\n   or 2 (\"Invalid Flag-Field Combination\") and drop the message.\n"
- title: 5.8.1.2.  Downstream Q-mode Encapsulation
  contents:
  - "5.8.1.2.  Downstream Q-mode Encapsulation\n   Where the signalling message is\
    \ travelling in the same ('downstream')\n   direction as the flow defined by the\
    \ MRI, the IP addressing for\n   Q-mode encapsulated messages is as follows. \
    \ Support for this\n   encapsulation is REQUIRED.\n   o  The destination IP address\
    \ MUST be the flow destination address as\n      given in the MRI of the message\
    \ payload.\n   o  By default, the source address is the flow source address, again\n\
    \      from the MRI; therefore, the source addressing mode flag in the\n     \
    \ common header S=0.  This provides the best likelihood that the\n      message\
    \ will be correctly routed through any region performing\n      per-packet policy-based\
    \ forwarding or load balancing that takes\n      the source address into account.\
    \  However, there may be\n      circumstances where the use of the signalling\
    \ source address (S=1)\n      is preferable, such as:\n      *  In order to receive\
    \ ICMP error messages about the signalling\n         message, such as unreachable\
    \ port or address.  If these are\n         delivered to the flow source rather\
    \ than the signalling source,\n         it will be very difficult for the querying\
    \ node to detect that\n         it is the last GIST node on the path.  Another\
    \ case is where\n         there is an abnormally low MTU along the path, in which\
    \ case\n         the querying node needs to see the ICMP error (recall that\n\
    \         Q-mode packets are sent with DF set).\n      *  In order to receive\
    \ GIST Error messages where the error message\n         sender could not interpret\
    \ the NLI in the original message.\n      *  In order to attempt to run GIST through\
    \ an unmodified NAT,\n         which will only process and translate IP addresses\
    \ in the IP\n         header (see Section 7.2.1).\n      Because of these considerations,\
    \ use of the signalling source\n      address is allowed as an option, with use\
    \ based on local policy.\n      A node SHOULD use the flow source address for\
    \ initial Query\n      messages, but SHOULD transition to the signalling source\
    \ address\n      for some retransmissions or as a matter of static configuration,\n\
    \      for example, if a NAT is known to be in the path out of a certain\n   \
    \   interface.  The S-flag in the common header tells the message\n      receiver\
    \ which option was used.\n   A Router Alert Option is also included in the IP\
    \ header.  The option\n   value depends on the NSLP being signalled for.  In addition,\
    \ it is\n   essential that the Query mimics the actual data flow as closely as\n\
    \   possible, since this is the basis of how the signalling message is\n   attached\
    \ to the data path.  To this end, GIST SHOULD set the Diffserv\n   codepoint and\
    \ (for IPv6) flow label to match the values in the MRI.\n   A GIST implementation\
    \ SHOULD apply validation checks to the MRI, to\n   reject Query messages that\
    \ are being injected by nodes with no\n   legitimate interest in the flow being\
    \ signalled for.  In general, if\n   the GIST node can detect that no flow could\
    \ arrive over the same\n   interface as the Query, it MUST be rejected with an\
    \ appropriate error\n   message.  Such checks apply only to messages with the\
    \ Q-mode\n   encapsulation, since only those messages are required to track the\n\
    \   flow path.  The main checks are that the IP version used in the\n   encapsulation\
    \ should match that of the MRI and the version(s) used on\n   that interface,\
    \ and that the full range of source addresses (the\n   source-address masked with\
    \ its prefix-length) would pass ingress\n   filtering checks.  For these cases,\
    \ the error message is \"MRI\n   Validation Failure\" (Appendix A.4.4.12) with\
    \ subcodes 1 or 2 (\"IP\n   Version Mismatch\" or \"Ingress Filter Failure\"),\
    \ respectively.\n"
- title: 5.8.1.3.  Upstream Q-mode Encapsulation
  contents:
  - "5.8.1.3.  Upstream Q-mode Encapsulation\n   In some deployment scenarios, it\
    \ is desirable to set up routing state\n   in the upstream direction (i.e., from\
    \ flow receiver towards the\n   sender).  This could be used to support firewall\
    \ signalling to\n   control traffic from an uncooperative sender, or signalling\
    \ in\n   general where the flow sender was not NSIS-capable.  This capability\n\
    \   is incorporated into GIST by defining an encapsulation and processing\n  \
    \ rules for sending Query messages upstream.\n   In general, it is not possible\
    \ to determine the hop-by-hop route\n   upstream because of asymmetric IP routing.\
    \  However, in particular\n   cases, the upstream peer can be discovered with\
    \ a high degree of\n   confidence, for example:\n   o  The upstream GIST peer\
    \ is one IP hop away, and can be reached by\n      tracing back through the interface\
    \ on which the flow arrives.\n   o  The upstream peer is a border router of a\
    \ single-homed (stub)\n      network.\n   This section defines an upstream Q-mode\
    \ encapsulation and validation\n   checks for when it can be used.  The functionality\
    \ to generate\n   upstream Queries is OPTIONAL, but if received they MUST be processed\n\
    \   in the normal way with some additional IP TTL checks.  No special\n   functionality\
    \ is needed for this.\n   It is possible for routing state at a given node, for\
    \ a specific MRI\n   and NSLPID, to be created by both an upstream Query exchange\n\
    \   (initiated by the node itself) and a downstream Query exchange (where\n  \
    \ the node is the responder).  If the SIDs are different, these items\n   of routing\
    \ state MUST be considered as independent; if the SIDs\n   match, the routing\
    \ state installed by the downstream exchange MUST\n   take precedence, provided\
    \ that the downstream Query passed ingress\n   filtering checks.  The rationale\
    \ for this is that the downstream\n   Query is in general a more reliable way\
    \ to install state, since it\n   directly probes the IP routing infrastructure\
    \ along the flow path,\n   whereas use of the upstream Query depends on the correctness\
    \ of the\n   Querying node's understanding of the topology.\n   The details of\
    \ the encapsulation are as follows:\n   o  The destination address SHOULD be the\
    \ flow source address as given\n      in the MRI of the message payload.  An implementation\
    \ with more\n      detailed knowledge of local IP routing MAY use an alternative\n\
    \      destination address (e.g., the address of its default router).\n   o  The\
    \ source address SHOULD be the signalling node address, so in\n      the common\
    \ header S=1.\n   o  A Router Alert Option is included as in the downstream case.\n\
    \   o  The Diffserv codepoint and (for IPv6) flow label MAY be set to\n      match\
    \ the values from the MRI as in the downstream case, and the\n      UDP port selection\
    \ is also the same.\n   o  The IP layer TTL of the message MUST be set to 255.\n\
    \   The sending GIST implementation SHOULD attempt to send the Query via\n   the\
    \ same interface and to the same link layer neighbour from which\n   the data\
    \ packets of the flow are arriving.\n   The receiving GIST node MAY apply validation\
    \ checks to the message\n   and MRI, to reject Query messages that have reached\
    \ a node at which\n   they can no longer be trusted.  In particular, a node SHOULD\
    \ reject a\n   message that has been propagated more than one IP hop, with an\n\
    \   \"Invalid IP layer TTL\" error message (Appendix A.4.4.11).  This can\n  \
    \ be determined by examining the received IP layer TTL, similar to the\n   generalised\
    \ IP TTL security mechanism described in [41].\n   Alternatively, receipt of an\
    \ upstream Query at the flow source MAY be\n   used to trigger setup of GIST state\
    \ in the downstream direction.\n   These restrictions may be relaxed in a future\
    \ version.\n"
- title: 5.8.2.  The Loose-End MRM
  contents:
  - "5.8.2.  The Loose-End MRM\n   The Loose-End MRM is used to discover GIST nodes\
    \ with particular\n   properties in the direction of a given address, for example,\
    \ to\n   discover a NAT along the upstream data path as in [34].\n"
- title: 5.8.2.1.  Message Routing Information
  contents:
  - "5.8.2.1.  Message Routing Information\n   For the loose-end MRM, only a simplified\
    \ version of the Flow\n   Identifier is needed.\n       MRI = network-layer-version\n\
    \             source-address\n             destination-address\n   The source\
    \ address is the address of the node initiating the\n   discovery process, for\
    \ example, the node that will be the data\n   receiver in the NAT discovery case.\
    \  The destination address is the\n   address of a node that is expected to be\
    \ the other side of the node\n   to be discovered.  Additional control information\
    \ defines the\n   direction of the message relative to this flow as in the path-coupled\n\
    \   case.\n"
- title: 5.8.2.2.  Downstream Q-mode Encapsulation
  contents:
  - "5.8.2.2.  Downstream Q-mode Encapsulation\n   Only one encapsulation is defined\
    \ for the loose-end MRM; by\n   convention, this is referred to as the downstream\
    \ encapsulation, and\n   is defined as follows:\n   o  The IP destination address\
    \ MUST be the destination address as\n      given in the MRI of the message payload.\n\
    \   o  By default, the IP source address is the source address from the\n    \
    \  MRI (S=0).  However, the use of the signalling source address\n      (S=1)\
    \ is allowed as in the case of the path-coupled MRM.\n   A Router Alert Option\
    \ is included in the IP header.  The option value\n   depends on the NSLP being\
    \ signalled for.  There are no special\n   requirements on the setting of the\
    \ Diffserv codepoint, IP layer TTL,\n   or (for IPv6) the flow label.  Nor are\
    \ any special validation checks\n   applied.\n"
- title: 6.  Formal Protocol Specification
  contents:
  - "6.  Formal Protocol Specification\n   This section provides a more formal specification\
    \ of the operation of\n   GIST processing, in terms of rules for transitions between\
    \ states of\n   a set of communicating state machines within a node.  The following\n\
    \   description captures only the basic protocol specification;\n   additional\
    \ mechanisms can be used by an implementation to accelerate\n   route change processing,\
    \ and these are captured in Section 7.1.  A\n   more detailed description of the\
    \ GIST protocol operation in state\n   machine syntax can be found in [45].\n\
    \   Conceptually, GIST processing at a node may be seen in terms of four\n   types\
    \ of cooperating state machine:\n   1.  There is a top-level state machine that\
    \ represents the node\n       itself (Node-SM).  It is responsible for the processing\
    \ of events\n       that cannot be directed towards a more specific state machine,\n\
    \       for example, inbound messages for which no routing state\n       currently\
    \ exists.  This machine exists permanently, and is\n       responsible for creating\
    \ per-MRI state machines to manage the\n       GIST handshake and routing state\
    \ maintenance procedures.\n   2.  For each flow and signalling direction where\
    \ the node is\n       responsible for the creation of routing state, there is\
    \ an\n       instance of a Query-Node state machine (Querying-SM).  This\n   \
    \    machine sends Query and Confirm messages and waits for Responses,\n     \
    \  according to the requirements from local API commands or timer\n       processing,\
    \ such as message repetition or routing state refresh.\n   3.  For each flow and\
    \ signalling direction where the node has\n       accepted the creation of routing\
    \ state by a peer, there is an\n       instance of a Responding-Node state machine\
    \ (Responding-SM).\n       This machine is responsible for managing the status\
    \ of the\n       routing state for that flow.  Depending on policy, it MAY be\n\
    \       responsible for transmission or retransmission of Response\n       messages,\
    \ or this MAY be handled by the Node-SM, and a\n       Responding-SM is not even\
    \ created for a flow until a properly\n       formatted Confirm has been accepted.\n\
    \   4.  Messaging associations have their own lifecycle, represented by\n    \
    \   an MA-SM, from when they are first created (in an incomplete\n       state,\
    \ listening for an inbound connection or waiting for\n       outbound connections\
    \ to complete), to when they are active and\n       available for use.\n   Apart\
    \ from the fact that the various machines can be created and\n   destroyed by\
    \ each other, there is almost no interaction between them.\n   The machines for\
    \ different flows do not interact; the Querying-SM and\n   Responding-SM for a\
    \ single flow and signalling direction do not\n   interact.  That is, the Responding-SM\
    \ that accepts the creation of\n   routing state for a flow on one interface has\
    \ no direct interaction\n   with the Querying-SM that sets up routing state on\
    \ the next interface\n   along the path.  This interaction is mediated instead\
    \ through the\n   NSLP.\n   The state machine descriptions use the terminology\
    \ rx_MMMM, tg_TTTT,\n   and er_EEEE for incoming messages, API/lower layer triggers,\
    \ and\n   error conditions, respectively.  The possible events of these types\n\
    \   are given in the table below.  In addition, timeout events denoted\n   to_TTTT\
    \ may also occur; the various timers are listed independently\n   for each type\
    \ of state machine in the following subsections.\n   +---------------------+---------------------------------------------+\n\
    \   | Name                | Meaning                                     |\n  \
    \ +---------------------+---------------------------------------------+\n   |\
    \ rx_Query            | A Query has been received.                  |\n   |  \
    \                   |                                             |\n   | rx_Response\
    \         | A Response has been received.               |\n   |              \
    \       |                                             |\n   | rx_Confirm     \
    \     | A Confirm has been received.                |\n   |                  \
    \   |                                             |\n   | rx_Data            \
    \ | A Data message has been received.           |\n   |                     |\
    \                                             |\n   | rx_Message          | rx_Query||rx_Response||rx_Confirm||rx_Data.\
    \ |\n   |                     |                                             |\n\
    \   | rx_MA-Hello         | An MA-Hello message has been received.      |\n  \
    \ |                     |                                             |\n   |\
    \ tg_NSLPData         | A signalling application has requested data |\n   |  \
    \                   | transfer (via API SendMessage).             |\n   |    \
    \                 |                                             |\n   | tg_Connected\
    \        | The protocol stack for a messaging          |\n   |               \
    \      | association has completed connecting.       |\n   |                 \
    \    |                                             |\n   | tg_RawData        \
    \  | GIST wishes to transfer data over a         |\n   |                     |\
    \ particular messaging association.           |\n   |                     |  \
    \                                           |\n   | tg_MAIdle           | GIST\
    \ decides that it is no longer necessary |\n   |                     | to keep\
    \ an MA open for itself.              |\n   |                     |          \
    \                                   |\n   | er_NoRSM            | A \"No Routing\
    \ State\" error was received.    |\n   |                     |               \
    \                              |\n   | er_MAConnect        | A messaging association\
    \ protocol failed to  |\n   |                     | complete a connection.   \
    \                   |\n   |                     |                            \
    \                 |\n   | er_MAFailure        | A messaging association failed.\
    \             |\n   +---------------------+---------------------------------------------+\n\
    \                              Incoming Events\n"
- title: 6.1.  Node Processing
  contents:
  - "6.1.  Node Processing\n   The Node-level state machine is responsible for processing\
    \ events for\n   which no more appropriate messaging association state or routing\n\
    \   state exists.  Its structure is trivial: there is a single state\n   ('Idle');\
    \ all events cause a transition back to Idle.  Some events\n   cause the creation\
    \ of other state machines.  The only events that are\n   processed by this state\
    \ machine are incoming GIST messages (Query/\n   Response/Confirm/Data) and API\
    \ requests to send data; no other events\n   are possible.  In addition to this\
    \ event processing, the Node-level\n   machine is responsible for managing listening\
    \ endpoints for messaging\n   associations.  Although these relate to Responding\
    \ node operation,\n   they cannot be handled by the Responder state machine since\
    \ they are\n   not created per flow.  The processing rules for each event are\
    \ as\n   follows:\n   Rule 1 (rx_Query):\n   use the GIST service interface to\
    \ determine the signalling\n       application policy relating to this peer\n\
    \       // note that this interaction delivers any NSLP-Data to\n       // the\
    \ NSLP as a side effect\n   if (the signalling application indicates that routing\
    \ state should\n       be created) then\n     if (routing state can be created\
    \ without a 3-way handshake) then\n       create Responding-SM and transfer control\
    \ to it\n     else\n       send Response with R=1\n   else\n     propagate the\
    \ Query with any updated NSLP payload provided\n   Rule 2 (rx_Response):\n   //\
    \ a routing state error\n   discard message\n   Rule 3 (rx_Confirm):\n   if (routing\
    \ state can be created before receiving a Confirm) then\n     // we should already\
    \ have Responding-SM for it,\n     // which would handle this message\n     discard\
    \ message\n     send \"No Routing State\" error message\n   else\n     create\
    \ Responding-SM and pass message to it\n   Rule 4 (rx_Data):\n   if (node policy\
    \ will only process Data messages with matching\n       routing state) then\n\
    \     send \"No Routing State\" error message\n   else\n     pass directly to\
    \ NSLP\n   Rule 4 (er_NoRSM):\n   discard the message\n   Rule 5 (tg_NSLPData):\n\
    \   if Q-mode encapsulation is not possible for this MRI\n     reject message\
    \ with an error\n   else\n     if (local policy & transfer attributes say routing\n\
    \         state is not needed) then\n       send message statelessly\n     else\n\
    \       create Querying-SM and pass message to it\n"
- title: 6.2.  Query Node Processing
  contents:
  - "6.2.  Query Node Processing\n   The Querying-Node state machine (Querying-SM)\
    \ has three states:\n   o  Awaiting Response\n   o  Established\n   o  Awaiting\
    \ Refresh\n   The Querying-SM is created by the Node-SM machine as a result of\
    \ a\n   request to send a message for a flow in a signalling direction where\n\
    \   the appropriate state does not exist.  The Query is generated\n   immediately\
    \ and the No_Response timer is started.  The NSLP data MAY\n   be carried in the\
    \ Query if local policy and the transfer attributes\n   allow it; otherwise, it\
    \ MUST be queued locally pending MA\n   establishment.  Then the machine transitions\
    \ to the Awaiting Response\n   state, in which timeout-based retransmissions are\
    \ handled.  Data\n   messages (rx_Data events) should not occur in this state;\
    \ if they do,\n   this may indicate a lost Response and a node MAY retransmit\
    \ a Query\n   for this reason.\n   Once a Response has been successfully received\
    \ and routing state\n   created, the machine transitions to Established, during\
    \ which NSLP\n   data can be sent and received normally.  Further Responses received\n\
    \   in this state (which may be the result of a lost Confirm) MUST be\n   treated\
    \ the same way.  The Awaiting Refresh state can be considered\n   as a substate\
    \ of Established, where a new Query has been generated to\n   refresh the routing\
    \ state (as in Awaiting Response) but NSLP data can\n   be handled normally.\n\
    \   The timers relevant to this state machine are as follows:\n   Refresh_QNode:\
    \  Indicates when the routing state stored by this state\n      machine must be\
    \ refreshed.  It is reset whenever a Response is\n      received indicating that\
    \ the routing state is still valid.\n      Implementations MUST set the period\
    \ of this timer based on the\n      value in the RS-validity-time field of a Response\
    \ to ensure that a\n      Query is generated before the peer's routing state expires\
    \ (see\n      Section 4.4.4).\n   No_Response:  Indicates that a Response has\
    \ not been received in\n      answer to a Query.  This is started whenever a Query\
    \ is sent and\n      stopped when a Response is received.\n   Inactive_QNode:\
    \  Indicates that no NSLP traffic is currently being\n      handled by this state\
    \ machine.  This is reset whenever the state\n      machine handles NSLP data,\
    \ in either direction.  When it expires,\n      the state machine MAY be deleted.\
    \  The period of the timer can be\n      set at any time via the API (SetStateLifetime),\
    \ and if the period\n      is reset in this way the timer itself MUST be restarted.\n\
    \   The main events (including all those that cause state transitions)\n   are\
    \ shown in the figure below, tagged with the number of the\n   processing rule\
    \ that is used to handle the event.  These rules are\n   listed after the diagram.\
    \  All events not shown or described in the\n   text above are assumed to be impossible\
    \ in a correct implementation\n   and MUST be ignored.\n              [Initialisation]\
    \   +-----+\n        -------------------------|Birth|\n       |              \
    \           +-----+\n       | er_NoRSM[3](from all states)                   rx_Response[4]\n\
    \       |                                               || tg_NSLPData[5]\n  \
    \     |      tg_NSLPData[1]                           || rx_Data[7]\n       |\
    \        --------                                    -------\n       |       |\
    \        V                                  |       V\n       |       |      \
    \  V                                  |       V\n       |      +----------+  \
    \                             +-----------+\n        ---->>| Awaiting |      \
    \                         |Established|\n        ------| Response |---------------------------->>\
    \ |           |\n       |      +----------+       rx_Response[4]          +-----------+\n\
    \       |       ^        |                                     ^   |\n       |\
    \       ^        |                                     ^   |\n       |       \
    \ --------                                      |   |\n       |    to_No_Response[2]\
    \                                 |   |\n       |    [!nResp_reached]     tg_NSLPData[5]\
    \               |   |\n       |                         || rx_Data[7]        \
    \        |   |\n       |                          --------                   \
    \ |   |\n       |                         |        V                   |   |\n\
    \       |    to_No_Response[2]    |        V                   |   |\n       |\
    \     [nResp_reached]    +-----------+  rx_Response[4] |   |\n        ----------\
    \   -----------|  Awaiting |-----------------    |\n                  | |    \
    \       |  Refresh  |<<-------------------\n                  | |           +-----------+\
    \    to_Refresh_QNode[8]\n                  | |            ^        |\n      \
    \            V V            ^        | to_No_Response[2]\n                  V\
    \ V             --------  [!nResp_reached]\n                +-----+\n        \
    \        |Death|<<---------------\n                +-----+   to_Inactive_QNode[6]\n\
    \                          (from all states)\n                    Figure 7: Query\
    \ Node State Machine\n   The processing rules are as follows:\n   Rule 1:\n  \
    \    Store the message for later transmission\n   Rule 2:\n   if number of Queries\
    \ sent has reached the threshold\n     // nQuery_isMax is true\n     indicate\
    \ No Response error to NSLP\n     destroy self\n   else\n     send Query\n   \
    \  start No_Response timer with new value\n   Rule 3:\n   // Assume the Confirm\
    \ was lost in transit or the peer has reset;\n   // restart the handshake\n  \
    \ send Query\n   (re)start No_Response timer\n   Rule 4:\n   if a new MA-SM is\
    \ needed create one\n   if the R-flag was set send a Confirm\n   send any stored\
    \ Data messages\n   stop No_Response timer\n   start Refresh_QNode timer\n   start\
    \ Inactive_QNode timer if it was not running\n   if there was piggybacked NSLP-Data\n\
    \     pass it to the NSLP\n     restart Inactive_QNode timer\n   Rule 5:\n   send\
    \ Data message\n   restart Inactive_QNode timer\n   Rule 6:\n      Terminate\n\
    \   Rule 7:\n   pass any data to the NSLP\n   restart Inactive_QNode timer\n \
    \  Rule 8:\n   send Query\n   start No_Response timer\n   stop Refresh_QNode timer\n"
- title: 6.3.  Responder Node Processing
  contents:
  - "6.3.  Responder Node Processing\n   The Responding-Node state machine (Responding-SM)\
    \ has three states:\n   o  Awaiting Confirm\n   o  Established\n   o  Awaiting\
    \ Refresh\n   The policy governing the handling of Query messages and the creation\n\
    \   of the Responding-SM has three cases:\n   1.  No Confirm is required for a\
    \ Query, and the state machine can be\n       created immediately.\n   2.  A Confirm\
    \ is required for a Query, but the state machine can\n       still be created\
    \ immediately.  A timer is used to retransmit\n       Response messages and the\
    \ Responding-SM is destroyed if no valid\n       Confirm is received.\n   3. \
    \ A Confirm is required for a Query, and the state machine can only\n       be\
    \ created when it is received; the initial Query will have been\n       handled\
    \ by the Node-level machine.\n   In case 2, the Responding-SM is created in the\
    \ Awaiting Confirm\n   state, and remains there until a Confirm is received, at\
    \ which point\n   it transitions to Established.  In cases 1 and 3, the Responding-SM\n\
    \   is created directly in the Established state.  Note that if the\n   machine\
    \ is created on receiving a Query, some of the message\n   processing will already\
    \ have been performed in the node state\n   machine.  In principle, an implementation\
    \ MAY change its policy on\n   handling a Query message at any time; however,\
    \ the state machine\n   descriptions here cover only the case where the policy\
    \ is fixed while\n   waiting for a Confirm message.\n   In the Established state,\
    \ the NSLP can send and receive data\n   normally, and any additional rx_Confirm\
    \ events MUST be silently\n   ignored.  The Awaiting Refresh state can be considered\
    \ a substate of\n   Established, where a Query has been received to begin the\
    \ routing\n   state refresh.  In the Awaiting Refresh state, the Responding-SM\n\
    \   behaves as in the Awaiting Confirm state, except that the NSLP can\n   still\
    \ send and receive data.  In particular, in both states there is\n   timer-based\
    \ retransmission of Response messages until a Confirm is\n   received; additional\
    \ rx_Query events in these states MUST also\n   generate a reply and restart the\
    \ no_Confirm timer.\n   The timers relevant to the operation of this state machine\
    \ are as\n   follows:\n   Expire_RNode:  Indicates when the routing state stored\
    \ by this state\n      machine needs to be expired.  It is reset whenever a Query\
    \ or\n      Confirm (depending on local policy) is received indicating that\n\
    \      the routing state is still valid.  Note that state cannot be\n      refreshed\
    \ from the R-Node.  If this timer fires, the routing state\n      machine is deleted,\
    \ regardless of whether a No_Confirm timer is\n      running.\n   No_Confirm:\
    \  Indicates that a Confirm has not been received in answer\n      to a Response.\
    \  This is started/reset whenever a Response is sent\n      and stopped when a\
    \ Confirm is received.\n   The detailed state transitions and processing rules\
    \ are described\n   below as in the Query node case.\n               rx_Query[1]\
    \                      rx_Query[5]\n            [confirmRequired]    +-----+ \
    \   [!confirmRequired]\n        -------------------------|Birth|----------------------------\n\
    \       |                         +-----+                            |\n     \
    \  |                            |         rx_Confirm[2]         |\n       |  \
    \                           ----------------------------   |\n       |       \
    \                                                  |  |\n       |            \
    \                           rx_Query[5]       |  |\n       |     tg_NSLPData[7]\
    \                   || rx_Confirm[10]  |  |\n       |      || rx_Query[1]    \
    \              || rx_Data[4]      |  |\n       |      || rx_Data[6]          \
    \         || tg_NSLPData[3]  |  |\n       |        --------                  \
    \      --------------   |  |\n       |       |        V                      |\
    \              V  V  V\n       |       |        V                      |     \
    \         V  V  V\n       |      +----------+                     |          \
    \ +-----------+\n        ---->>| Awaiting |     rx_Confirm[8]    -----------|Established|\n\
    \        ------| Confirm  |------------------------------>> |           |\n  \
    \     |      +----------+                                 +-----------+\n    \
    \   |       ^        |                                      ^   |\n       |  \
    \     ^        |         tg_NSLPData[3]               ^   |\n       |        --------\
    \          || rx_Query[1]               |   |\n       |    to_No_Confirm[9]  \
    \    || rx_Data[4]                |   |\n       |    [!nConf_reached]       --------\
    \                    |   |\n       |                          |        V     \
    \              |   |\n       |    to_No_Confirm[9]      |        V           \
    \        |   |\n       |    [nConf_reached]      +-----------+  rx_Confirm[8]\
    \  |   |\n        ----------   ------------|  Awaiting |-----------------    |\n\
    \                  | |            |  Refresh  |<<-------------------\n       \
    \           | |            +-----------+      rx_Query[1]\n                  |\
    \ |             ^        |     [confirmRequired]\n                  | |      \
    \       ^        |\n                  | |              --------\n            \
    \      V V          to_No_Confirm[9]\n                  V V          [!nConf_reached]\n\
    \                +-----+\n                |Death|<<---------------------\n   \
    \             +-----+    er_NoRSM[11]\n                           to_Expire_RNode[11]\n\
    \                               (from Established/Awaiting Refresh)\n        \
    \          Figure 8: Responder Node State Machine\n   The processing rules are\
    \ as follows:\n   Rule 1:\n   // a Confirm is required\n   send Response with\
    \ R=1\n   (re)start No_Confirm timer with the initial timer value\n   Rule 2:\n\
    \   pass any NSLP-Data object to the NSLP\n   start Expire_RNode timer\n   Rule\
    \ 3:  send the Data message\n   Rule 4:  pass data to NSLP\n   Rule 5:\n   //\
    \ no Confirm is required\n   send Response with R=0\n   start Expire_RNode timer\n\
    \   Rule 6:\n   drop incoming data\n   send \"No Routing State\" error message\n\
    \   Rule 7:  store Data message\n   Rule 8:\n   pass any NSLP-Data object to the\
    \ NSLP\n   send any stored Data messages\n   stop No_Confirm timer\n   start Expire_RNode\
    \ timer\n   Rule 9:\n   if number of Responses sent has reached threshold\n  \
    \   // nResp_isMax is true\n     destroy self\n   else\n     send Response\n \
    \    start No_Response timer\n   Rule 10:\n // can happen e.g., a retransmitted\
    \ Response causes a duplicate Confirm\n silently ignore\n   Rule 11:  destroy\
    \ self\n"
- title: 6.4.  Messaging Association Processing
  contents:
  - "6.4.  Messaging Association Processing\n   Messaging associations (MAs) are modelled\
    \ for use within GIST with a\n   simple three-state process.  The Awaiting Connection\
    \ state indicates\n   that the MA is waiting for the connection process(es) for\
    \ every\n   protocol in the messaging association to complete; this might involve\n\
    \   creating listening endpoints or attempting active connects.  Timers\n   may\
    \ also be necessary to detect connection failure (e.g., no incoming\n   connection\
    \ within a certain period), but these are not modelled\n   explicitly.\n   The\
    \ Connected state indicates that the MA is open and ready to use\n   and that\
    \ the node wishes it to remain open.  In this state, the node\n   operates a timer\
    \ (SendHello) to ensure that messages are regularly\n   sent to the peer, to ensure\
    \ that the peer does not tear down the MA.\n   The node transitions from Connected\
    \ to Idle (indicating that it no\n   longer needs the association) as a matter\
    \ of local policy; one way to\n   manage the policy is to use an activity timer\
    \ but this is not\n   specified explicitly by the state machine (see also Section\
    \ 4.4.5).\n   In the Idle state, the node no longer requires the messaging\n \
    \  association but the peer still requires it and is indicating this by\n   sending\
    \ periodic MA-Hello messages.  A different timer (NoHello)\n   operates to purge\
    \ the MA when these messages stop arriving.  If real\n   data is transferred over\
    \ the MA, the state machine transitions back\n   to Connected.\n   At any time\
    \ in the Connected or Idle states, a node MAY test the\n   connectivity to its\
    \ peer and the liveness of the GIST instance at\n   that peer by sending an MA-Hello\
    \ request with R=1.  Failure to\n   receive a reply with a matching Hello-ID within\
    \ a timeout MAY be\n   taken as a reason to trigger er_MAFailure.  Initiation\
    \ of such a test\n   and the timeout setting are left to the discretion of the\n\
    \   implementation.  Note that er_MAFailure may also be signalled by\n   indications\
    \ from the underlying messaging association protocols.  If\n   a messaging association\
    \ fails, this MUST be indicated back to the\n   routing state machines that use\
    \ it, and these MAY generate\n   indications to signalling applications.  In particular,\
    \ if the\n   messaging association was being used to deliver messages reliably,\n\
    \   this MUST be reported as a NetworkNotification error (Appendix B.4).\n   Clearly,\
    \ many internal details of the messaging association protocols\n   are hidden\
    \ in this model, especially where the messaging association\n   uses multiple\
    \ protocol layers.  Note also that although the existence\n   of messaging associations\
    \ is not directly visible to signalling\n   applications, there is some interaction\
    \ between the two because\n   security-related information becomes available during\
    \ the open\n   process, and this may be indicated to signalling applications if\
    \ they\n   have requested it.\n   The timers relevant to the operation of this\
    \ state machine are as\n   follows:\n   SendHello:  Indicates that an MA-Hello\
    \ message should be sent to the\n      remote node.  The period of this timer\
    \ is determined by the MA-\n      Hold-Time sent by the remote node during the\
    \ Query/Response/\n      Confirm exchange.\n   NoHello:  Indicates that no MA-Hello\
    \ has been received from the\n      remote node for a period of time.  The period\
    \ of this timer is\n      sent to the remote node as the MA-Hold-Time during the\
    \ Query/\n      Response exchange.\n   The detailed state transitions and processing\
    \ rules are described\n   below as in the Query node case.\n            [Initialisation]\
    \       +-----+\n       ----------------------------|Birth|\n      |         \
    \                   +-----+       tg_RawData[1]\n      |                     \
    \                     || rx_Message[2]\n      |                              \
    \            || rx_MA-Hello[3]\n      |       tg_RawData[5]                  \
    \    || to_SendHello[4]\n      |        --------                             --------\n\
    \      |       |        V                           |        V\n      |      \
    \ |        V                           |        V\n      |      +----------+ \
    \                        +-----------+\n       ---->>| Awaiting |    tg_Connected[6]\
    \      | Connected |\n       ------|Connection|----------------------->>|    \
    \       |\n      |      +----------+                         +-----------+\n \
    \     |                                              ^    |\n      |         \
    \                     tg_RawData[1]   ^    |\n      |                        \
    \    || rx_Message[2]  |    | tg_MAIdle[7]\n      |                          \
    \                    |    V\n      |                                         \
    \     |    V\n      | er_MAConnect[8]  +-----+   to_NoHello[8]  +-----------+\n\
    \       ---------------->>|Death|<<----------------|   Idle    |\n           \
    \              +-----+                  +-----------+\n                      \
    \     ^                       ^        |\n                           ^       \
    \                ^        |\n                            ---------------     \
    \    --------\n                            er_MAFailure[8]        rx_MA-Hello[9]\n\
    \                         (from Connected/Idle)\n               Figure 9: Messaging\
    \ Association State Machine\n   The processing rules are as follows:\n   Rule\
    \ 1:\n   pass message to transport layer\n   if the NoHello timer was running,\
    \ stop it\n   (re)start SendHello\n   Rule 2:\n   pass message to Node-SM, or\
    \ R-SM (for a Confirm),\n      or Q-SM (for a Response)\n   if the NoHello timer\
    \ was running, stop it\n   Rule 3:\n   if reply requested\n     send MA-Hello\n\
    \     restart SendHello timer\n   Rule 4:\n   send MA-Hello message\n   restart\
    \ SendHello timer\n   Rule 5:\n      queue message for later transmission\n  \
    \ Rule 6:\n   pass outstanding queued messages to transport layer\n   stop any\
    \ timers controlling connection establishment\n   start SendHello timer\n   Rule\
    \ 7:\n   stop SendHello timer\n   start NoHello timer\n   Rule 8:\n   report failure\
    \ to routing state machines and signalling applications\n   destroy self\n   Rule\
    \ 9:\n   if reply requested\n     send MA-Hello\n   restart NoHello timer\n"
- title: 7.  Additional Protocol Features
  contents:
  - '7.  Additional Protocol Features

    '
- title: 7.1.  Route Changes and Local Repair
  contents:
  - '7.1.  Route Changes and Local Repair

    '
- title: 7.1.1.  Introduction
  contents:
  - "7.1.1.  Introduction\n   When IP layer rerouting takes place in the network,\
    \ GIST and\n   signalling application state need to be updated for all flows whose\n\
    \   paths have changed.  The updates to signalling application state\n   depend\
    \ mainly on the signalling application: for example, if the path\n   characteristics\
    \ have changed, simply moving state from the old to the\n   new path is not sufficient.\
    \  Therefore, GIST cannot complete the path\n   update processing by itself. \
    \ Its responsibilities are to detect the\n   route change, update its local routing\
    \ state consistently, and inform\n   interested signalling applications at affected\
    \ nodes.\n                        xxxxxxxxxxxxxxxxxxxxxxxxxxxx\n             \
    \          x  +--+      +--+      +--+  x      Initial\n                     \
    \ x  .|C1|_.....|D1|_.....|E1|   x     Configuration\n                     x \
    \ . +--+.    .+--+.    .+--+\\.  x\n      >>xxxxxxxxxxxxx  .       .  .      .\
    \  .       .  xxxxxx>>\n        +-+       +-+ .         ..        ..         .\
    \ +-+\n     ...|A|_......|B|/          ..        ..          .|F|_....\n     \
    \   +-+       +-+ .        .  .      .  .        . +-+\n                     \
    \  .      .    .    .    .      .\n                        . +--+      +--+  \
    \    +--+ .\n                         .|C2|_.....|D2|_.....|E2|/\n           \
    \               +--+      +--+      +--+\n                          +--+     \
    \ +--+      +--+         Configuration\n                         .|C1|......|D1|......|E1|\
    \         after failure\n                        . +--+     .+--+      +--+  \
    \       of E1-F link\n                       .      \\.  .     \\.  ./\n     \
    \   +-+       +-+ .         ..        ..           +-+\n     ...|A|_......|B|.\
    \          ..        ..          .|F|_....\n        +-+       +-+\\         .\
    \  .      .  .        . +-+\n      >>xxxxxxxxxxxxx .       .    .    .    .  \
    \    .  xxxxxx>>\n                     x  . +--+      +--+      +--+ .  x\n  \
    \                    x  .|C2|_.....|D2|_.....|E2|/  x\n                      \
    \ x  +--+      +--+      +--+  x\n                        xxxxxxxxxxxxxxxxxxxxxxxxxxxx\n\
    \               ........... = physical link topology\n               >>xxxxxxx>>\
    \ = flow direction\n               _.......... = outgoing link for flow xxxxxx\
    \ given\n                             by local forwarding table\n            \
    \           Figure 10: A Rerouting Event\n   Route change management is complicated\
    \ by the distributed nature of\n   the problem.  Consider the rerouting event\
    \ shown in Figure 10.  An\n   external observer can tell that the main responsibility\
    \ for\n   controlling the updates will probably lie with nodes B and F;\n   however,\
    \ E1 is best placed to detect the event quickly at the GIST\n   level, and C1\
    \ and D1 could also attempt to initiate the repair.\n   The NSIS framework [29]\
    \ makes the assumption that signalling\n   applications are soft-state based and\
    \ operate end to end.  In this\n   case, because GIST also periodically updates\
    \ its picture of routing\n   state, route changes will eventually be repaired\
    \ automatically.  The\n   specification as already given includes this functionality.\
    \  However,\n   especially if upper layer refresh times are extended to reduce\n\
    \   signalling load, the duration of inconsistent state may be very long\n   indeed.\
    \  Therefore, GIST includes logic to exchange prompt\n   notifications with signalling\
    \ applications, to allow local repair if\n   possible.  The additional mechanisms\
    \ to achieve this are described in\n   the following subsections.  To a large\
    \ extent, these additions can be\n   seen as implementation issues; the protocol\
    \ messages and their\n   significance are not changed, but there are extra interactions\n\
    \   through the API between GIST and signalling applications, and\n   additional\
    \ triggers for transitions between the various GIST states.\n"
- title: 7.1.2.  Route Change Detection Mechanisms
  contents:
  - "7.1.2.  Route Change Detection Mechanisms\n   There are two aspects to detecting\
    \ a route change at a single node:\n   o  Detecting that the outgoing path, in\
    \ the direction of the Query,\n      has or may have changed.\n   o  Detecting\
    \ that the incoming path, in the direction of the\n      Response, has (or may\
    \ have) changed, in which case the node may no\n      longer be on the path at\
    \ all.\n   At a single node, these processes are largely independent, although\n\
    \   clearly a change in one direction at a node corresponds to a change\n   in\
    \ the opposite direction at its peer.  Note that there are two\n   possible forms\
    \ for a route change: the interface through which a flow\n   leaves or enters\
    \ a node may change, and the adjacent peer may change.\n   In general, a route\
    \ change can include one or the other or both (or\n   indeed neither, although\
    \ such changes are very hard to detect).\n   The route change detection mechanisms\
    \ available to a node depend on\n   the MRM in use and the role the node played\
    \ in setting up the routing\n   state in the first place (i.e., as Querying or\
    \ Responding node).  The\n   following discussion is specific to the case of the\
    \ path-coupled MRM\n   using downstream Queries only; other scenarios may require\
    \ other\n   methods.  However, the repair logic described in the subsequent\n\
    \   subsections is intended to be universal.\n   There are five mechanisms for\
    \ a node to detect that a route change\n   has occurred, which are listed below.\
    \  They apply differently\n   depending on whether the change is in the Query\
    \ or Response\n   direction, and these differences are summarised in the following\n\
    \   table.\n   Local Trigger:  In local trigger mode, GIST finds out from the\
    \ local\n      forwarding table that the next hop has changed.  This only works\n\
    \      if the routing change is local, not if it happens a few IP routing\n  \
    \    hops away, including the case that it happens at a GIST-unaware\n      node.\n\
    \   Extended Trigger:  Here, GIST checks a link-state topology database\n    \
    \  to discover that the path has changed.  This makes certain\n      assumptions\
    \ on consistency of IP route computation and only works\n      within a single\
    \ area for OSPF [16] and similar link-state\n      protocols.  Where available,\
    \ this offers the most accurate and\n      rapid indication of route changes,\
    \ but requires more access to the\n      routing internals than a typical operating\
    \ system may provide.\n   GIST C-mode Monitoring:  GIST may find that C-mode packets\
    \ are\n      arriving (from either peer) with a different IP layer TTL or on a\n\
    \      different interface.  This provides no direct information about\n     \
    \ the new flow path, but indicates that routing has changed and that\n      rediscovery\
    \ may be required.\n   Data Plane Monitoring:  The signalling application on a\
    \ node may\n      detect a change in behaviour of the flow, such as IP layer TTL\n\
    \      change, arrival on a different interface, or loss of the flow\n      altogether.\
    \  The signalling application on the node is allowed to\n      convey this information\
    \ to the local GIST instance (Appendix B.6).\n   GIST Probing:  According to the\
    \ specification, each GIST node MUST\n      periodically repeat the discovery\
    \ (Query/Response) operation.\n      Values for the probe frequency are discussed\
    \ in Section 4.4.4.\n      The period can be negotiated independently for each\
    \ GIST hop, so\n      nodes that have access to the other techniques listed above\
    \ MAY\n      use long periods between probes.  The Querying node will discover\n\
    \      the route change by a modification in the Network-Layer-\n      Information\
    \ in the Response.  The Responding node can detect a\n      change in the upstream\
    \ peer similarly; further, if the Responding\n      node can store the interface\
    \ on which Queries arrive, it can\n      detect if this interface changes even\
    \ when the peer does not.\n   +-------------+--------------------------+--------------------------+\n\
    \   | Method      | Query direction          | Response direction       |\n  \
    \ +-------------+--------------------------+--------------------------+\n   |\
    \ Local       | Discovers new interface  | Not applicable           |\n   | Trigger\
    \     | (and peer if local)      |                          |\n   |          \
    \   |                          |                          |\n   | Extended   \
    \ | Discovers new interface  | May determine that route |\n   | Trigger     |\
    \ and may determine new    | from peer will have      |\n   |             | peer\
    \                     | changed                  |\n   |             |       \
    \                   |                          |\n   | C-mode      | Provides\
    \ hint that       | Provides hint that       |\n   | Monitoring  | change has\
    \ occurred      | change has occurred      |\n   |             |             \
    \             |                          |\n   | Data Plane  | Not applicable\
    \           | NSLP informs GIST that a |\n   | Monitoring  |                 \
    \         | change may have occurred |\n   |             |                   \
    \       |                          |\n   | Probing     | Discovers changed NLI\
    \ in | Discovers changed NLI in |\n   |             | Response               \
    \  | Query                    |\n   +-------------+--------------------------+--------------------------+\n"
- title: 7.1.3.  GIST Behaviour Supporting Rerouting
  contents:
  - "7.1.3.  GIST Behaviour Supporting Rerouting\n   The basic GIST behaviour necessary\
    \ to support rerouting can be\n   modelled using a three-level classification\
    \ of the validity of each\n   item of current routing state.  (In addition to\
    \ current routing\n   state, NSIS can maintain past routing state, described in\n\
    \   Section 7.1.4 below.)  This classification applies separately to the\n   Querying\
    \ and Responding nodes for each pair of GIST peers.  The\n   levels are:\n   Bad:\
    \  The routing state is either missing altogether or not safe to\n      use to\
    \ send data.\n   Tentative:  The routing state may have changed, but it is still\n\
    \      usable for sending NSLP data pending verification.\n   Good:  The routing\
    \ state has been established and no events affecting\n      it have since been\
    \ detected.\n   These classifications are not identical to the states described\
    \ in\n   Section 6, but there are dependencies between them.  Specifically,\n\
    \   routing state is considered Bad until the state machine first enters\n   the\
    \ Established state, at which point it becomes Good.  Thereafter,\n   the status\
    \ may be invalidated for any of the reasons discussed above;\n   it is an implementation\
    \ issue to decide which techniques to implement\n   in any given node, and how\
    \ to reclassify routing state (as Bad or\n   Tentative) for each.  The status\
    \ returns to Good, either when the\n   state machine re-enters the Established\
    \ state or if GIST can\n   determine from direct examination of the IP routing\
    \ or forwarding\n   tables that the peer has not changed.  When the status returns\
    \ to\n   Good, GIST MUST if necessary update its routing state table so that\n\
    \   the relationships between MRI/SID/NSLPID tuples and messaging\n   associations\
    \ are up to date.\n   When classification of the routing state for the downstream\
    \ direction\n   changes to Bad/Tentative because of local IP routing indications,\n\
    \   GIST MAY automatically change the classification in the upstream\n   direction\
    \ to Tentative unless local routing indicates that this is\n   not necessary.\
    \  This SHOULD NOT be done in the case where the initial\n   change was indicated\
    \ by the signalling application.  This mechanism\n   accounts for the fact that\
    \ a routing change may affect several nodes,\n   and so can be an indication that\
    \ upstream routing may also have\n   changed.  In any case, whenever GIST updates\
    \ the routing status, it\n   informs the signalling application with the NetworkNotification\
    \ API\n   (Appendix B.4), unless the change was caused via the API in the first\n\
    \   place.\n   The GIST behaviour for state repair is different for the Querying\
    \ and\n   Responding nodes.  At the Responding node, there is no additional\n\
    \   behaviour, since the Responding node cannot initiate protocol\n   transitions\
    \ autonomously.  (It can only react to the Querying node.)\n   The Querying node\
    \ has three options, depending on how the transition\n   from Good was initially\
    \ caused:\n   1.  To inspect the IP routing/forwarding table and verifying that\
    \ the\n       next peer has not changed.  This technique MUST NOT be used if\n\
    \       the transition was caused by a signalling application, but SHOULD\n  \
    \     be used otherwise if available.\n   2.  To move to the Awaiting Refresh\
    \ state.  This technique MUST NOT\n       be used if the current status is Bad,\
    \ since data is being\n       incorrectly delivered.\n   3.  To move to the Awaiting\
    \ Response state.  This technique may be\n       used at any time, but has the\
    \ effect of freezing NSLP\n       communication while GIST state is being repaired.\n\
    \   The second and third techniques trigger the execution of a GIST\n   handshake\
    \ to carry out the repair.  It may be desirable to delay the\n   start of the\
    \ handshake process, either to wait for the network to\n   stabilise, to avoid\
    \ flooding the network with Query traffic for a\n   large number of affected flows,\
    \ or to wait for confirmation that the\n   node is still on the path from the\
    \ upstream peer.  One approach is to\n   delay the handshake until there is NSLP\
    \ data to be transmitted.\n   Implementation of such delays is a matter of local\
    \ policy; however,\n   GIST MUST begin the handshake immediately if the status\
    \ change was\n   caused by an InvalidateRoutingState API call marked as 'Urgent',\
    \ and\n   SHOULD begin it if the upstream routing state is still known to be\n\
    \   Good.\n"
- title: 7.1.4.  Load Splitting and Route Flapping
  contents:
  - "7.1.4.  Load Splitting and Route Flapping\n   The Q-mode encapsulation rules\
    \ of Section 5.8 try to ensure that the\n   Query messages discovering the path\
    \ mimic the flow as accurately as\n   possible.  However, in environments where\
    \ there is load balancing\n   over multiple routes, and this is based on header\
    \ fields differing\n   between flow and Q-mode packets or done on a round-robin\
    \ basis, the\n   path discovered by the Query may vary from one handshake to the\
    \ next\n   even though the underlying network is stable.  This will appear to\n\
    \   GIST as a route flap; route flapping can also be caused by problems\n   in\
    \ the basic network connectivity or routing protocol operation.  For\n   example,\
    \ a mobile node might be switching back and forth between two\n   links, or might\
    \ appear to have disappeared even though it is still\n   attached to the network\
    \ via a different route.\n   This specification does not define mechanisms for\
    \ GIST to manage\n   multiple parallel routes or an unstable route; instead, GIST\
    \ MAY\n   expose this to the NSLP, which can then manage it according to\n   signalling\
    \ application requirements.  The algorithms already\n   described always maintain\
    \ the concept of the current route, i.e., the\n   latest peer discovered for a\
    \ particular flow.  Instead, GIST allows\n   the use of prior signalling paths\
    \ for some period while the\n   signalling applications still need them.  Since\
    \ NSLP peers are a\n   single GIST hop apart, the necessary information to represent\
    \ a path\n   can be just an entry in the node's routing state table for that flow\n\
    \   (more generally, anything that uniquely identifies the peer, such as\n   the\
    \ NLI, could be used).  Rather than requiring GIST to maintain\n   multiple generations\
    \ of this information, it is provided to the\n   signalling application in the\
    \ same node in an opaque form for each\n   message that is received from the peer.\
    \  The signalling application\n   can store it if necessary and provide it back\
    \ to the GIST layer in\n   case it needs to be used.  Because this is a reference\
    \ to information\n   about the source of a prior signalling message, it is denoted\
    \ 'SII-\n   Handle' (for Source Identification Information) in the abstract API\n\
    \   of Appendix B.\n   Note that GIST if possible SHOULD use the same SII-Handle\
    \ for\n   multiple sessions to the same peer, since this then allows signalling\n\
    \   applications to aggregate some signalling, such as summary refreshes\n   or\
    \ bulk teardowns.  Messages sent using the SII-Handle MUST bypass\n   the routing\
    \ state tables at the sender, and this MUST be indicated by\n   setting the E-flag\
    \ in the common header (Appendix A.1).  Messages\n   other than Data messages\
    \ MUST NOT be sent in this way.  At the\n   receiver, GIST MUST NOT validate the\
    \ MRI/SID/NSLPID against local\n   routing state and instead indicates the mode\
    \ of reception to\n   signalling applications through the API (Appendix B.2).\
    \  Signalling\n   applications should validate the source and effect of the message\n\
    \   themselves, and if appropriate should in particular indicate to GIST\n   (see\
    \ Appendix B.5) that routing state is no longer required for this\n   flow.  This\
    \ is necessary to prevent GIST in nodes on the old path\n   initiating routing\
    \ state refresh and thus causing state conflicts at\n   the crossover router.\n\
    \   GIST notifies signalling applications about route modifications as\n   two\
    \ types of event, additions and deletions.  An addition is notified\n   as a change\
    \ of the current routing state according to the Bad/\n   Tentative/Good classification\
    \ above, while deletion is expressed as a\n   statement that an SII-Handle no\
    \ longer lies on the path.  Both can be\n   reported through the NetworkNotification\
    \ API call (Appendix B.4).  A\n   minimal implementation MAY notify a route change\
    \ as a single (add,\n   delete) operation; however, a more sophisticated implementation\
    \ MAY\n   delay the delete notification, for example, if it knows that the old\n\
    \   route continues to be used in parallel or that the true route is\n   flapping\
    \ between the two.  It is then a matter of signalling\n   application design whether\
    \ to tear down state on the old path, leave\n   it unchanged, or modify it in\
    \ some signalling application specific\n   way to reflect the fact that multiple\
    \ paths are operating in\n   parallel.\n"
- title: 7.1.5.  Signalling Application Operation
  contents:
  - "7.1.5.  Signalling Application Operation\n   Signalling applications can use\
    \ these functions as provided by GIST\n   to carry out rapid local repair following\
    \ rerouting events.  The\n   signalling application instances carry out the multi-hop\
    \ aspects of\n   the procedure, including crossover node detection, and tear-down/\n\
    \   reinstallation of signalling application state; they also trigger\n   GIST\
    \ to carry out the local routing state maintenance operations over\n   each individual\
    \ hop.  The local repair procedures depend heavily on\n   the fact that stateful\
    \ NSLP nodes are a single GIST hop apart; this\n   is enforced by the details\
    \ of the GIST peer discovery process.\n   The following outline description of\
    \ a possible set of NSLP actions\n   takes the scenario of Figure 10 as an example.\n\
    \   1.  The signalling application at node E1 is notified by GIST of\n       route\
    \ changes affecting the downstream and upstream directions.\n       The downstream\
    \ status was updated to Bad because of a trigger\n       from the local forwarding\
    \ tables, and the upstream status changed\n       automatically to Tentative as\
    \ a consequence.  The signalling\n       application at E1 MAY begin local repair\
    \ immediately, or MAY\n       propagate a notification upstream to D1 that rerouting\
    \ has\n       occurred.\n   2.  The signalling application at node D1 is notified\
    \ of the route\n       change, either by signalling application notifications\
    \ or from\n       the GIST level (e.g., by a trigger from a link-state topology\n\
    \       database).  If the information propagates faster within the IP\n     \
    \  routing protocol, GIST will change the upstream/downstream\n       routing\
    \ state to Tentative/Bad automatically, and this will cause\n       the signalling\
    \ application to propagate the notification further\n       upstream.\n   3. \
    \ This process continues until the notification reaches node A.\n       Here,\
    \ there is no downstream routing change, so GIST only learns\n       of the update\
    \ via the signalling application trigger.  Since the\n       upstream status is\
    \ still Good, it therefore begins the repair\n       handshake immediately.\n\
    \   4.  The handshake initiated by node A causes its downstream routing\n    \
    \   state to be confirmed as Good and unchanged there; it also\n       confirms\
    \ the (Tentative) upstream routing state at B as Good.\n       This is enough\
    \ to identify B as the crossover router, and the\n       signalling application\
    \ and GIST can begin the local repair\n       process.\n   An alternative way\
    \ to reach step (4) is that node B is able to\n   determine autonomously that\
    \ there is no likelihood of an upstream\n   route change.  For example, it could\
    \ be an area border router and the\n   route change is only intra-area.  In this\
    \ case, the signalling\n   application and GIST will see that the upstream state\
    \ is Good and can\n   begin the local repair directly.\n   After a route deletion,\
    \ a signalling application may wish to remove\n   state at another node that is\
    \ no longer on the path.  However, since\n   it is no longer on the path, in principle\
    \ GIST can no longer send\n   messages to it.  In general, provided this state\
    \ is soft, it will\n   time out anyway; however, the timeouts involved may have\
    \ been set to\n   be very long to reduce signalling load.  Instead, signalling\n\
    \   applications MAY use the SII-Handle described above to route explicit\n  \
    \ teardown messages.\n"
- title: 7.2.  NAT Traversal
  contents:
  - "7.2.  NAT Traversal\n   GIST messages, for example, for the path-coupled MRM,\
    \ must carry\n   addressing and higher layer information as payload data in order\
    \ to\n   define the flow signalled for.  (This applies to all GIST messages,\n\
    \   regardless of how they are encapsulated or which direction they are\n   travelling\
    \ in.)  At an addressing boundary, the data flow packets\n   will have their headers\
    \ translated; if the signalling payloads are\n   not translated consistently,\
    \ the signalling messages will refer to\n   incorrect (and probably meaningless)\
    \ flows after passing through the\n   boundary.  In addition, GIST handshake messages\
    \ carry additional\n   addressing information about the GIST nodes themselves,\
    \ and this must\n   also be processed appropriately when traversing a NAT.\n \
    \  There is a dual problem of whether the GIST peers on either side of\n   the\
    \ boundary can work out how to address each other, and whether they\n   can work\
    \ out what translation to apply to the signalling packet\n   payloads.  Existing\
    \ generic NAT traversal techniques such as Session\n   Traversal Utilities for\
    \ NAT (STUN) [26] or Traversal Using Relays\n   around NAT (TURN) [27] can operate\
    \ only on the two addresses visible\n   in the IP header.  It is therefore intrinsically\
    \ difficult to use\n   these techniques to discover a consistent translation of\
    \ the three or\n   four interdependent addresses for the flow and signalling source\
    \ and\n   destination.\n   For legacy NATs and MRMs that carry addressing information,\
    \ the base\n   GIST specification is therefore limited to detecting the situation\n\
    \   and triggering the appropriate error conditions to terminate the\n   signalling\
    \ path.  (MRMs that do not contain addressing information\n   could traverse such\
    \ NATs safely, with some modifications to the GIST\n   processing rules.  Such\
    \ modifications could be described in the\n   documents defining such MRMs.) \
    \ Legacy NAT handling is covered in\n   Section 7.2.1 below.  A more general solution\
    \ can be constructed\n   using GIST-awareness in the NATs themselves; this solution\
    \ is\n   outlined in Section 7.2.2 with processing rules in Section 7.2.3.\n \
    \  In all cases, GIST interaction with the NAT is determined by the way\n   the\
    \ NAT handles the Query/Response messages in the initial GIST\n   handshake; these\
    \ messages are UDP datagrams.  Best current practice\n   for NAT treatment of\
    \ UDP traffic is defined in [38], and the legacy\n   NAT handling defined in this\
    \ specification is fully consistent with\n   that document.  The GIST-aware NAT\
    \ traversal technique is equivalent\n   to requiring an Application Layer Gateway\
    \ in the NAT for a specific\n   class of UDP transactions -- namely, those where\
    \ the destination UDP\n   port for the initial message is the GIST port (see Section\
    \ 9).\n"
- title: 7.2.1.  Legacy NAT Handling
  contents:
  - "7.2.1.  Legacy NAT Handling\n   Legacy NAT detection during the GIST handshake\
    \ depends on analysis of\n   the IP header and S-flag in the GIST common header,\
    \ and the NLI\n   object included in the handshake messages.  The message sequence\n\
    \   proceeds differently depending on whether the Querying node is on the\n  \
    \ internal or external side of the NAT.\n   For the case of the Querying node\
    \ on the internal side of the NAT, if\n   the S-flag is not set in the Query (S=0),\
    \ a legacy NAT cannot be\n   detected.  The receiver will generate a normal Response\
    \ to the\n   interface-address given in the NLI in the Query, but the interface-\n\
    \   address will not be routable and the Response will not be delivered.\n   If\
    \ retransmitted Queries keep S=0, this behaviour will persist until\n   the Querying\
    \ node times out.  The signalling path will thus terminate\n   at this point,\
    \ not traversing the NAT.\n   The situation changes once S=1 in a Query; note\
    \ the Q-mode\n   encapsulation rules recommend that S=1 is used at least for some\n\
    \   retransmissions (see Section 5.8).  If S=1, the receiver MUST check\n   the\
    \ source address in the IP header against the interface-address in\n   the NLI.\
    \  A legacy NAT has been found if these addresses do not\n   match.  For MRMs\
    \ that contain addressing information that needs\n   translation, legacy NAT traversal\
    \ is not possible.  The receiver MUST\n   return an \"Object Type Error\" message\
    \ (Appendix A.4.4.9) with subcode\n   4 (\"Untranslated Object\") indicating the\
    \ MRI as the object in\n   question.  The error message MUST be addressed to the\
    \ source address\n   from the IP header of the incoming message.  The Responding\
    \ node\n   SHOULD use the destination IP address of the original datagram as the\n\
    \   source address for IP header of the Response; this makes it more\n   likely\
    \ that the NAT will accept the incoming message, since it looks\n   like a normal\
    \ UDP/IP request/reply exchange.  If this message is able\n   to traverse back\
    \ through the NAT, the Querying node will terminate\n   the handshake immediately;\
    \ otherwise, this reduces to the previous\n   case of a lost Response and the\
    \ Querying node will give up on\n   reaching its retransmission limit.\n   When\
    \ the Querying node is on the external side of the NAT, the Query\n   will only\
    \ traverse the NAT if some static configuration has been\n   carried out on the\
    \ NAT to forward GIST Q-mode traffic to a node on\n   the internal network.  Regardless\
    \ of the S-flag in the Query, the\n   Responding node cannot directly detect the\
    \ presence of the NAT.  It\n   MUST send a normal Response with S=1 to an address\
    \ derived from the\n   Querying node's NLI that will traverse the NAT as normal\
    \ UDP traffic.\n   The Querying node MUST check the source address in the IP header\
    \ with\n   the NLI in the Response, and when it finds a mismatch it MUST\n   terminate\
    \ the handshake.\n   Note that in either of the error cases (internal or external\
    \ Querying\n   node), an alternative to terminating the handshake could be to\
    \ invoke\n   some legacy NAT traversal procedure.  This specification does not\n\
    \   define any such procedure, although one possible approach is\n   described\
    \ in [43].  Any such traversal procedure MUST be incorporated\n   into GIST using\
    \ the existing GIST extensibility capabilities.  Note\n   also that this detection\
    \ process only functions with the handshake\n   exchange; it cannot operate on\
    \ simple Data messages, whether they are\n   Q-mode or normally encapsulated.\
    \  Nodes SHOULD NOT send Data messages\n   outside a messaging association if\
    \ they cannot ensure that they are\n   operating in an environment free of legacy\
    \ NATs.\n"
- title: 7.2.2.  GIST-Aware NAT Traversal
  contents:
  - "7.2.2.  GIST-Aware NAT Traversal\n   The most robust solution to the NAT traversal\
    \ problem is to require\n   that a NAT is GIST-aware, and to allow it to modify\
    \ messages based on\n   the contents of the MRI.  This makes the assumption that\
    \ NATs only\n   rewrite the header fields included in the MRI, and not other higher\n\
    \   layer identifiers.  Provided this is done consistently with the data\n   flow\
    \ header translation, signalling messages can be valid each side\n   of the boundary,\
    \ without requiring the NAT to be signalling\n   application aware.  Note, however,\
    \ that if the NAT does not\n   understand the MRI, and the N-flag in the MRI is\
    \ clear (see\n   Appendix A.3.1), it should reject the message with an \"Object\
    \ Type\n   Error\" message (Appendix A.4.4.9) with subcode 4 (\"Untranslated\n\
    \   Object\").\n   The basic concept is that GIST-aware NATs modify any signalling\n\
    \   messages that have to be able to be interpreted without routing state\n  \
    \ being available; these messages are identified by the context-free\n   flag\
    \ C=1 in the common header, and include the Query in the GIST\n   handshake. \
    \ In addition, NATs have to modify the remaining handshake\n   messages that set\
    \ up routing state.  When routing state is set up,\n   GIST records how subsequent\
    \ messages related to that routing state\n   should be translated; if no routing\
    \ state is being used for a\n   message, GIST directly uses the modifications\
    \ made by the NAT to\n   translate it.\n   This specification defines an additional\
    \ NAT traversal object that a\n   NAT inserts into all Q-mode encapsulated messages\
    \ with the context-\n   free flag C=1, and which GIST echoes back in any replies,\
    \ i.e.,\n   Response or Error messages.  NATs apply GIST-specific processing only\n\
    \   to Q-mode encapsulated messages with C=1, or D-mode messages carrying\n  \
    \ the NAT traversal object.  All other GIST messages, either those in\n   C-mode\
    \ or those in D-mode with no NAT-Traversal object, should be\n   treated as normal\
    \ data traffic by the NAT, i.e., with IP and\n   transport layer header translation\
    \ but no GIST-specific processing.\n   Note that the distinction between Q-mode\
    \ and D-mode encapsulation may\n   not be observable to the NAT, which is why\
    \ the setting of the C-flag\n   or presence of the NAT traversal object is used\
    \ as interception\n   criteria.  The NAT decisions are based purely on the value\
    \ of the\n   C-flag and the presence of the NAT traversal object, not on the\n\
    \   message type.\n   The NAT-Traversal object (Appendix A.3.9), carries the translation\n\
    \   between the MRIs that are appropriate for the internal and external\n   sides\
    \ of the NAT.  It also carries a list of which other objects in\n   the message\
    \ have been translated.  This should always include the\n   NLI, and the Stack-Configuration-Data\
    \ if present; if GIST is extended\n   with further objects that carry addressing\
    \ data, this list allows a\n   message receiver to know if the new objects were\
    \ supported by the\n   NAT.  Finally, the NAT-Traversal object MAY be used to\
    \ carry data to\n   assist the NAT in back-translating D-mode responses; this\
    \ could be\n   the original NLI or SCD, or opaque equivalents in the case of\n\
    \   topology hiding.\n   A consequence of this approach is that the routing state\
    \ tables at\n   the signalling application peers on each side of the NAT are no\n\
    \   longer directly compatible.  In particular, they use different MRI\n   values\
    \ to refer to the same flow.  However, messages after the Query/\n   Response\
    \ (the initial Confirm and subsequent Data messages) need to\n   use a common\
    \ MRI, since the NAT does not rewrite these, and this is\n   chosen to be the\
    \ MRI of the Querying node.  It is the responsibility\n   of the Responding node\
    \ to translate between the two MRIs on inbound\n   and outbound messages, which\
    \ is why the unmodified MRI is propagated\n   in the NAT-Traversal object.\n"
- title: 7.2.3.  Message Processing Rules
  contents:
  - "7.2.3.  Message Processing Rules\n   This specification normatively defines the\
    \ behaviour of a GIST node\n   receiving a message containing a NAT-Traversal\
    \ object.  However, it\n   does not define normative behaviour for a NAT translating\
    \ GIST\n   messages, since much of this will depend on NAT implementation and\n\
    \   policy about allocating bindings.  In addition, it is not necessary\n   for\
    \ a GIST implementation itself.  Therefore, those aspects of the\n   following\
    \ description are informative; full details of NAT behaviour\n   for handling\
    \ GIST messages can be found in [44].\n   A possible set of operations for a NAT\
    \ to process a message with C=1\n   is as follows.  Note that for a Data message,\
    \ only a subset of the\n   operations is applicable.\n   1.  Verify that bindings\
    \ for any data flow are actually in place.\n   2.  Create a new Message-Routing-Information\
    \ object with fields\n       modified according to the data flow bindings.\n \
    \  3.  Create bindings for subsequent C-mode signalling based on the\n       information\
    \ in the Network-Layer-Information and Stack-\n       Configuration-Data objects.\n\
    \   4.  Create new Network-Layer-Information and if necessary Stack-\n       Configuration-Data\
    \ objects with fields to force D-mode response\n       messages through the NAT,\
    \ and to allow C-mode exchanges using the\n       C-mode signalling bindings.\n\
    \   5.  Add a NAT-Traversal object, listing the objects that have been\n     \
    \  modified and including the unmodified MRI and any other data\n       needed\
    \ to interpret the response.  If a NAT-Traversal object is\n       already present,\
    \ in the case of a sequence of NATs, the list of\n       modified objects may\
    \ be updated and further opaque data added,\n       but the MRI contained in it\
    \ is left unchanged.\n   6.  Encapsulate the message according to the normal rules\
    \ of this\n       specification for the Q-mode encapsulation.  If the S-flag was\n\
    \       set in the original message, the same IP source address selection\n  \
    \     policy should be applied to the forwarded message.\n   7.  Forward the message\
    \ with these new payloads.\n   A GIST node receiving such a message MUST verify\
    \ that all mandatory\n   objects containing addressing have been translated correctly,\
    \ or else\n   reject the message with an \"Object Type Error\" message\n   (Appendix\
    \ A.4.4.9) with subcode 4 (\"Untranslated Object\").  The error\n   message MUST\
    \ include the NAT-Traversal object as the first TLV after\n   the common header,\
    \ and this is also true for any other error message\n   generated as a reply.\
    \  Otherwise, the message is processed\n   essentially as normal.  If no state\
    \ needs to be updated for the\n   message, the NAT-Traversal object can be effectively\
    \ ignored.  The\n   other possibility is that a Response must be returned, because\
    \ the\n   message is either the beginning of a handshake for a new flow or a\n\
    \   refresh for existing state.  In both cases, the GIST node MUST create\n  \
    \ the Response in the normal way using the local form of the MRI, and\n   its\
    \ own NLI and (if necessary) SCD.  It MUST also include the NAT-\n   Traversal\
    \ object as the first object in the Response after the common\n   header.\n  \
    \ A NAT will intercept D-mode messages containing such echoed NAT-\n   Traversal\
    \ objects.  The NAT processing is a subset of the processing\n   for the C=1 case:\n\
    \   1.  Verify the existence of bindings for the data flow.\n   2.  Leave the\
    \ Message-Routing-Information object unchanged.\n   3.  Modify the NLI and SCD\
    \ objects for the Responding node if\n       necessary, and create or update any\
    \ bindings for C-mode\n       signalling traffic.\n   4.  Forward the message.\n\
    \   A GIST node receiving such a message (Response or Error) MUST use the\n  \
    \ MRI from the NAT-Traversal object as the key to index its internal\n   routing\
    \ state; it MAY also store the translated MRI for additional\n   (e.g., diagnostic)\
    \ information, but this is not used in the GIST\n   processing.  The remainder\
    \ of GIST processing is unchanged.\n   Note that Confirm messages are not given\
    \ GIST-specific processing by\n   the NAT.  Thus, a Responding node that has delayed\
    \ state installation\n   until receiving the Confirm only has available the untranslated\
    \ MRI\n   describing the flow, and the untranslated NLI as peer routing state.\n\
    \   This would prevent the correct interpretation of the signalling\n   messages;\
    \ also, subsequent Query (refresh) messages would always be\n   seen as route\
    \ changes because of the NLI change.  Therefore, a\n   Responding node that wishes\
    \ to delay state installation until\n   receiving a Confirm must somehow reconstruct\
    \ the translations when\n   the Confirm arrives.  How to do this is an implementation\
    \ issue; one\n   approach is to carry the translated objects as part of the Responder-\n\
    \   Cookie that is echoed in the Confirm.  Indeed, for one of the cookie\n   constructions\
    \ in Section 8.5 this is automatic.\n"
- title: 7.3.  Interaction with IP Tunnelling
  contents:
  - "7.3.  Interaction with IP Tunnelling\n   The interaction between GIST and IP\
    \ tunnelling is very simple.  An IP\n   packet carrying a GIST message is treated\
    \ exactly the same as any\n   other packet with the same source and destination\
    \ addresses: in other\n   words, it is given the tunnel encapsulation and forwarded\
    \ with the\n   other data packets.\n   Tunnelled packets will not be identifiable\
    \ as GIST messages until\n   they leave the tunnel, since any Router Alert Option\
    \ and the standard\n   GIST protocol encapsulation (e.g., port numbers) will be\
    \ hidden\n   within the standard tunnel encapsulation.  If signalling is needed\n\
    \   for the tunnel itself, this has to be initiated as a separate\n   signalling\
    \ session by one of the tunnel endpoints -- that is, the\n   tunnel counts as\
    \ a new flow.  Because the relationship between\n   signalling for the microflow\
    \ and signalling for the tunnel as a whole\n   will depend on the signalling application\
    \ in question, it is a\n   signalling application responsibility to be aware of\
    \ the fact that\n   tunnelling is taking place and to carry out additional signalling\
    \ if\n   necessary; in other words, at least one tunnel endpoint must be\n   signalling\
    \ application aware.\n   In some cases, it is the tunnel exit point (i.e., the\
    \ node where\n   tunnelled data and downstream signalling packets leave the tunnel)\n\
    \   that will wish to carry out the tunnel signalling, but this node will\n  \
    \ not have knowledge or control of how the tunnel entry point is\n   carrying\
    \ out the data flow encapsulation.  The information about how\n   the inner MRI/SID\
    \ relate to the tunnel MRI/SID needs to be carried in\n   the signalling data\
    \ from the tunnel entry point; this functionality\n   is the equivalent to the\
    \ RSVP SESSION_ASSOC object of [18].  In the\n   NSIS protocol suite, these bindings\
    \ are managed by the signalling\n   applications, either implicitly (e.g., by\
    \ SID re-use) or explicitly\n   by carrying objects that bind the inner and outer\
    \ SIDs as part of the\n   NSLP payload.\n"
- title: 7.4.  IPv4-IPv6 Transition and Interworking
  contents:
  - "7.4.  IPv4-IPv6 Transition and Interworking\n   GIST itself is essentially IP\
    \ version neutral: version dependencies\n   are isolated in the formats of the\
    \ Message-Routing-Information,\n   Network-Layer-Information, and Stack-Configuration-Data\
    \ objects, and\n   GIST also depends on the version independence of the protocols\
    \ that\n   support messaging associations.  In mixed environments, GIST\n   operation\
    \ will be influenced by the IP transition mechanisms in use.\n   This section\
    \ provides a high level overview of how GIST is affected,\n   considering only\
    \ the currently predominant mechanisms.\n   Dual Stack:  (As described in [35].)\
    \  In mixed environments, GIST\n      MUST use the same IP version for Q-mode\
    \ encapsulated messages as\n      given by the MRI of the flow for which it is\
    \ signalling, and\n      SHOULD do so for other signalling also (see Section 5.2.2).\n\
    \      Messages with mismatching versions MUST be rejected with an \"MRI\n   \
    \   Validation Failure\" error message (Appendix A.4.4.12) with subcode\n    \
    \  1 (\"IP Version Mismatch\").  The IP version used in D-mode is\n      closely\
    \ tied to the IP version used by the data flow, so it is\n      intrinsically\
    \ impossible for an IPv4-only or IPv6-only GIST node\n      to support signalling\
    \ for flows using the other IP version.  Hosts\n      that are dual stack for\
    \ applications and routers that are dual\n      stack for forwarding need GIST\
    \ implementations that can support\n      both IP versions.  Applications with\
    \ a choice of IP versions might\n      select a version based on which could be\
    \ supported in the network\n      by GIST, which could be established by invoking\
    \ parallel discovery\n      procedures.\n   Packet Translation:  (Applicable to\
    \ SIIT [7].)  Some transition\n      mechanisms allow IPv4 and IPv6 nodes to communicate\
    \ by placing\n      packet translators between them.  From the GIST perspective,\
    \ this\n      should be treated essentially the same way as any other NAT\n  \
    \    operation (e.g., between internal and external addresses) as\n      described\
    \ in Section 7.2.  The translating node needs to be GIST-\n      aware; it will\
    \ have to translate the addressing payloads between\n      IPv4 and IPv6 formats\
    \ for flows that cross between the two.  The\n      translation rules for the\
    \ fields in the MRI payload (including,\n      e.g., diffserv-codepoint and flow-label)\
    \ are as defined in [7].\n      The same analysis applies to NAT-PT, although\
    \ this technique is no\n      longer proposed as a general purpose transition\
    \ mechanism [40].\n   Tunnelling:  (Applicable to 6to4 [19].)  Many transition\
    \ mechanisms\n      handle the problem of how an end-to-end IPv6 (or IPv4) flow\
    \ can be\n      carried over intermediate IPv4 (or IPv6) regions by tunnelling;\n\
    \      the methods tend to focus on minimising the tunnel administration\n   \
    \   overhead.  For GIST, the treatment should be similar to any other\n      IP\
    \ tunnelling mechanism, as described in Section 7.3.  In\n      particular, the\
    \ end-to-end flow signalling will pass transparently\n      through the tunnel,\
    \ and signalling for the tunnel itself will have\n      to be managed by the tunnel\
    \ endpoints.  However, additional\n      considerations may arise because of special\
    \ features of the tunnel\n      management procedures.  In particular, [20] is\
    \ based on using an\n      anycast address as the destination tunnel endpoint.\
    \  GIST MAY use\n      anycast destination addresses in the Q-mode encapsulation\
    \ of\n      D-mode messages if necessary, but MUST NOT use them in the\n     \
    \ Network-Layer-Information addressing field; unicast addresses MUST\n      be\
    \ used instead.  Note that the addresses from the IP header are\n      not used\
    \ by GIST in matching requests and replies, so there is no\n      requirement\
    \ to use anycast source addresses.\n"
- title: 8.  Security Considerations
  contents:
  - "8.  Security Considerations\n   The security requirement for GIST is to protect\
    \ the signalling plane\n   against identified security threats.  For the signalling\
    \ problem as a\n   whole, these threats have been outlined in [30]; the NSIS framework\n\
    \   [29] assigns a subset of the responsibilities to the NTLP.  The main\n   issues\
    \ to be handled can be summarised as:\n   Message Protection:  Signalling message\
    \ content can be protected\n      against eavesdropping, modification, injection,\
    \ and replay while\n      in transit.  This applies to GIST payloads, and GIST\
    \ should also\n      provide such protection as a service to signalling applications\n\
    \      between adjacent peers.\n   Routing State Integrity Protection:  It is\
    \ important that signalling\n      messages are delivered to the correct nodes,\
    \ and nowhere else.\n      Here, 'correct' is defined as 'the appropriate nodes\
    \ for the\n      signalling given the Message-Routing-Information'.  In the case\n\
    \      where the MRI is based on the flow identification for path-coupled\n  \
    \    signalling, 'appropriate' means 'the same nodes that the\n      infrastructure\
    \ will route data flow packets through'.  GIST has no\n      role in deciding\
    \ whether the data flow itself is being routed\n      correctly; all it can do\
    \ is to ensure that signalling and data\n      routing are consistent with each\
    \ other.  GIST uses internal state\n      to decide how to route signalling messages,\
    \ and this state needs\n      to be protected against corruption.\n   Prevention\
    \ of Denial-of-Service Attacks:  GIST nodes and the network\n      have finite\
    \ resources (state storage, processing power,\n      bandwidth).  The protocol\
    \ tries to minimise exhaustion attacks\n      against these resources and not\
    \ allow GIST nodes to be used to\n      launch attacks on other network elements.\n\
    \   The main additional issue is handling authorisation for executing\n   signalling\
    \ operations (e.g., allocating resources).  This is assumed\n   to be done in\
    \ each signalling application.\n   In many cases, GIST relies on the security\
    \ mechanisms available in\n   messaging associations to handle these issues, rather\
    \ than\n   introducing new security measures.  Obviously, this requires the\n\
    \   interaction of these mechanisms with the rest of the GIST protocol to\n  \
    \ be understood and verified, and some aspects of this are discussed in\n   Section\
    \ 5.7.\n"
- title: 8.1.  Message Confidentiality and Integrity
  contents:
  - "8.1.  Message Confidentiality and Integrity\n   GIST can use messaging association\
    \ functionality, specifically in\n   this version TLS (Section 5.7.3), to ensure\
    \ message confidentiality\n   and integrity.  Implementation of this functionality\
    \ is REQUIRED but\n   its use for any given flow or signalling application is\
    \ OPTIONAL.  In\n   some cases, confidentiality of GIST information itself is\
    \ not likely\n   to be a prime concern, in particular, since messages are often\
    \ sent\n   to parties that are unknown ahead of time, although the content\n \
    \  visible even at the GIST level gives significant opportunities for\n   traffic\
    \ analysis.  Signalling applications may have their own\n   mechanism for securing\
    \ content as necessary; however, they may find\n   it convenient to rely on protection\
    \ provided by messaging\n   associations, since it runs unbroken between signalling\
    \ application\n   peers.\n"
- title: 8.2.  Peer Node Authentication
  contents:
  - "8.2.  Peer Node Authentication\n   Cryptographic protection (of confidentiality\
    \ or integrity) requires a\n   security association with session keys.  These\
    \ can be established by\n   an authentication and key exchange protocol based\
    \ on shared secrets,\n   public key techniques, or a combination of both.  Authentication\
    \ and\n   key agreement are possible using the protocols associated with the\n\
    \   messaging association being secured.  TLS incorporates this\n   functionality\
    \ directly.  GIST nodes rely on the messaging association\n   protocol to authenticate\
    \ the identity of the next hop, and GIST has\n   no authentication capability\
    \ of its own.\n   With routing state discovery, there are few effective ways to\
    \ know\n   what is the legitimate next or previous hop as opposed to an\n   impostor.\
    \  In other words, cryptographic authentication here only\n   provides assurance\
    \ that a node is 'who' it is (i.e., the legitimate\n   owner of identity in some\
    \ namespace), not 'what' it is (i.e., a node\n   which is genuinely on the flow\
    \ path and therefore can carry out\n   signalling for a particular flow).  Authentication\
    \ provides only\n   limited protection, in that a known peer is unlikely to lie\
    \ about its\n   role.  Additional methods of protection against this type of attack\n\
    \   are considered in Section 8.3 below.\n   It is an implementation issue whether\
    \ peer node authentication should\n   be made signalling application dependent,\
    \ for example, whether\n   successful authentication could be made dependent on\
    \ presenting\n   credentials related to a particular signalling role (e.g., signalling\n\
    \   for QoS).  The abstract API of Appendix B leaves open such policy and\n  \
    \ authentication interactions between GIST and the NSLP it is serving.\n   However,\
    \ it does allow applications to inspect the authenticated\n   identity of the\
    \ peer to which a message will be sent before\n   transmission.\n"
- title: 8.3.  Routing State Integrity
  contents:
  - "8.3.  Routing State Integrity\n   Internal state in a node (see Section 4.2)\
    \ is used to route messages.\n   If this state is corrupted, signalling messages\
    \ may be misdirected.\n   In the case where the MRM is path-coupled, the messages\
    \ need to be\n   routed identically to the data flow described by the MRI, and\
    \ the\n   routing state table is the GIST view of how these flows are being\n\
    \   routed through the network in the immediate neighbourhood of the\n   node.\
    \  Routes are only weakly secured (e.g., there is no\n   cryptographic binding\
    \ of a flow to a route), and there is no\n   authoritative information about flow\
    \ routes other than the current\n   state of the network itself.  Therefore, consistency\
    \ between GIST and\n   network routing state has to be ensured by directly interacting\
    \ with\n   the IP routing mechanisms to ensure that the signalling peers are the\n\
    \   appropriate ones for any given flow.  An overview of security issues\n   and\
    \ techniques in this context is provided in [37].\n   In one direction, peer identification\
    \ is installed and refreshed only\n   on receiving a Response (compare Figure\
    \ 5).  This MUST echo the\n   cookie from a previous Query, which will have been\
    \ sent along the\n   flow path with the Q-mode encapsulation, i.e., end-to-end\
    \ addressed.\n   Hence, only the true next peer or an on-path attacker will be\
    \ able to\n   generate such a message, provided freshness of the cookie can be\n\
    \   checked at the Querying node.\n   In the other direction, peer identification\
    \ MAY be installed directly\n   on receiving a Query containing addressing information\
    \ for the\n   signalling source.  However, any node in the network could generate\n\
    \   such a message; indeed, many nodes in the network could be the\n   genuine\
    \ upstream peer for a given flow.  To protect against this,\n   four strategies\
    \ are used:\n   Filtering:  The receiving node MAY reject signalling messages\
    \ that\n      claim to be for flows with flow source addresses that could be\n\
    \      ruled out by ingress filtering.  An extension of this technique\n     \
    \ would be for the receiving node to monitor the data plane and to\n      check\
    \ explicitly that the flow packets are arriving over the same\n      interface\
    \ and if possible from the same link layer neighbour as\n      the D-mode signalling\
    \ packets.  If they are not, it is likely that\n      at least one of the signalling\
    \ or flow packets is being spoofed.\n   Return routability checking:  The receiving\
    \ node MAY refuse to\n      install upstream state until it has completed a Confirm\
    \ handshake\n      with the peer.  This echoes the Responder-Cookie of the Response,\n\
    \      and discourages nodes from using forged source addresses.  This\n     \
    \ also plays a role in denial-of-service prevention; see below.\n   Authorisation:\
    \  A stronger approach is to carry out a peer\n      authorisation check (see\
    \ Section 4.4.2) as part of messaging\n      association setup.  The ideal situation\
    \ is that the receiving node\n      can determine the correct upstream node address\
    \ from routing table\n      analysis or knowledge of local topology constraints,\
    \ and then\n      verify from the authorised peer database (APD) that the peer\
    \ has\n      this IP address.  This is only technically feasible in a limited\n\
    \      set of deployment environments.  The APD can also be used to list\n   \
    \   the subsets of nodes that are feasible peers for particular source\n     \
    \ or destination subnets, or to blacklist nodes that have previously\n      originated\
    \ attacks or exist in untrustworthy networks, which\n      provide weaker levels\
    \ of authorisation checking.\n   SID segregation:  The routing state lookup for\
    \ a given MRI and NSLPID\n      MUST also take the SID into account.  A malicious\
    \ node can only\n      overwrite existing GIST routing state if it can guess the\n\
    \      corresponding SID; it can insert state with random SID values, but\n  \
    \    generally this will not be used to route signalling messages for\n      which\
    \ state has already been legitimately established.\n"
- title: 8.4.  Denial-of-Service Prevention and Overload Protection
  contents:
  - "8.4.  Denial-of-Service Prevention and Overload Protection\n   GIST is designed\
    \ so that in general each Query only generates at most\n   one Response that is\
    \ at most only slightly larger than the Query, so\n   that a GIST node cannot\
    \ become the source of a denial-of-service\n   amplification attack.  (There is\
    \ a special case of retransmitted\n   Response messages; see Section 5.3.3.)\n\
    \   However, GIST can still be subjected to denial-of-service attacks\n   where\
    \ an attacker using forged source addresses forces a node to\n   establish state\
    \ without return routability, causing a problem similar\n   to TCP SYN flood attacks.\
    \  Furthermore, an adversary might use\n   modified or replayed unprotected signalling\
    \ messages as part of such\n   an attack.  There are two types of state attacks\
    \ and one\n   computational resource attack.  In the first state attack, an\n\
    \   attacker floods a node with messages that the node has to store until\n  \
    \ it can determine the next hop.  If the destination address is chosen\n   so\
    \ that there is no GIST-capable next hop, the node would accumulate\n   messages\
    \ for several seconds until the discovery retransmission\n   attempt times out.\
    \  The second type of state-based attack causes GIST\n   state to be established\
    \ by bogus messages.  A related computational/\n   network-resource attack uses\
    \ unverified messages to cause a node\n   query an authentication or authorisation\
    \ infrastructure, or attempt\n   to cryptographically verify a digital signature.\n\
    \   We use a combination of two defences against these attacks:\n   1.  The Responding\
    \ node need not establish a session or discover its\n       next hop on receiving\
    \ the Query, but MAY wait for a Confirm,\n       possibly on a secure channel.\
    \  If the channel exists, the\n       additional delay is one one-way delay and\
    \ the total is no more\n       than the minimal theoretically possible delay of\
    \ a three-way\n       handshake, i.e., 1.5 node-to-node round-trip times.  The\
    \ delay\n       gets significantly larger if a new connection needs to be\n  \
    \     established first.\n   2.  The Response to the Query contains a cookie,\
    \ which is repeated in\n       the Confirm.  State is only established for messages\
    \ that contain\n       a valid cookie.  The setup delay is also 1.5 round-trip\
    \ times.\n       This mechanism is similar to that in SCTP [39] and other modern\n\
    \       protocols.\n   There is a potential overload condition if a node is flooded\
    \ with\n   Query or Confirm messages.  One option is for the node to bypass\n\
    \   these messages altogether as described in Section 4.3.2, effectively\n   falling\
    \ back to being a non-NSIS node.  If this is not possible, a\n   node MAY still\
    \ choose to limit the rate at which it processes Query\n   messages and discard\
    \ the excess, although it SHOULD first adapt its\n   policy to one of sending\
    \ Responses statelessly if it is not already\n   doing so.  A conformant GIST\
    \ node will automatically decrease the\n   load by retransmitting Queries with\
    \ an exponential backoff.  A non-\n   conformant node (launching a DoS attack)\
    \ can generate uncorrelated\n   Queries at an arbitrary rate, which makes it hard\
    \ to apply rate-\n   limiting without also affecting genuine handshake attempts.\
    \  However,\n   if Confirm messages are requested, the cookie binds the message\
    \ to a\n   Querying node address that has been validated by a return routability\n\
    \   check and rate-limits can be applied per source.\n   Once a node has decided\
    \ to establish routing state, there may still\n   be transport and security state\
    \ to be established between peers.\n   This state setup is also vulnerable to\
    \ denial-of-service attacks.\n   GIST relies on the implementations of the lower\
    \ layer protocols that\n   make up messaging associations to mitigate such attacks.\
    \  In the\n   current specification, the Querying node is always the one wishing\
    \ to\n   establish a messaging association, so it is the Responding node that\n\
    \   needs to be protected.  It is possible for an attacking node to\n   execute\
    \ these protocols legally to set up large numbers of\n   associations that were\
    \ never used, and Responding node\n   implementations MAY use rate-limiting or\
    \ other techniques to control\n   the load in such cases.\n   Signalling applications\
    \ can use the services provided by GIST to\n   defend against certain (e.g., flooding)\
    \ denial-of-service attacks.\n   In particular, they can elect to process only\
    \ messages from peers\n   that have passed a return routability check or been\
    \ authenticated at\n   the messaging association level (see Appendix B.2).  Signalling\n\
    \   applications that accept messages under other circumstances (in\n   particular,\
    \ before routing state has been fully established at the\n   GIST level) need\
    \ to take this into account when designing their\n   denial-of-service prevention\
    \ mechanisms, for example, by not creating\n   local state as a result of processing\
    \ such messages.  Signalling\n   applications can also manage overload by invoking\
    \ flow control, as\n   described in Section 4.1.1.\n"
- title: 8.5.  Requirements on Cookie Mechanisms
  contents:
  - "8.5.  Requirements on Cookie Mechanisms\n   The requirements on the Query-Cookie\
    \ can be summarised as follows:\n   Liveness:  The cookie must be live; that is,\
    \ it must change from one\n      handshake to the next.  This prevents replay\
    \ attacks.\n   Unpredictability:  The cookie must not be guessable, e.g., from\
    \ a\n      sequence or timestamp.  This prevents direct forgery after\n      capturing\
    \ a set of earlier messages.\n   Easily validated:  It must be efficient for the\
    \ Q-Node to validate\n      that a particular cookie matches an in-progress handshake,\
    \ for a\n      routing state machine that already exists.  This allows to discard\n\
    \      responses that have been randomly generated by an adversary, or to\n  \
    \    discard responses to queries that were generated with forged\n      source\
    \ addresses or an incorrect address in the included NLI\n      object.\n   Uniqueness:\
    \  Each handshake must have a unique cookie since the\n      cookie is used to\
    \ match responses within a handshake, e.g., when\n      multiple messaging associations\
    \ are multiplexed over the same\n      transport connection.\n   Likewise, the\
    \ requirements on the Responder-Cookie can be summarised\n   as follows:\n   Liveness:\
    \  The cookie must be live as above, to prevent replay\n      attacks.\n   Creation\
    \ simplicity:  The cookie must be lightweight to generate in\n      order to avoid\
    \ resource exhaustion at the responding node.\n   Validation simplicity:  It must\
    \ be simple for the R-node to validate\n      that an R-Cookie was generated by\
    \ itself and no one else, without\n      storing state about the handshake for\
    \ which it was generated.\n   Binding:  The cookie must be bound to the routing\
    \ state that will be\n      installed, to prevent use with different routing state,\
    \ e.g., in a\n      modified Confirm.  The routing state here includes the Peer-\n\
    \      Identity and Interface-Address given in the NLI of the Query, and\n   \
    \   the MRI/NSLPID for the messaging.\n      It can also include the interface\
    \ on which the Query was received\n      for use later in route change detection\
    \ (Section 7.1.2).  Since a\n      Q-mode encapsulated message is the one that\
    \ will best follow the\n      data path, subsequent changes in this arrival interface\
    \ indicate\n      route changes between the peers.\n   A suitable implementation\
    \ for the Q-Cookie is a cryptographically\n   strong random number that is unique\
    \ for this routing state machine\n   handshake.  A node MUST implement this or\
    \ an equivalently strong\n   mechanism.  Guidance on random number generation\
    \ can be found in\n   [31].\n   A suitable basic implementation for the R-Cookie\
    \ is as follows:\n        R-Cookie = liveness data + reception interface\n   \
    \                + hash (locally known secret,\n                           Q-Node\
    \ NLI identity and address, MRI, NSLPID,\n                           liveness\
    \ data)\n   A node MUST implement this or an equivalently strong mechanism.\n\
    \   There are several alternatives for the liveness data.  One is to use\n   a\
    \ timestamp like SCTP.  Another is to give the local secret a (rapid)\n   rollover,\
    \ with the liveness data as the generation number of the\n   secret, like IKEv2.\
    \  In both cases, the liveness data has to be\n   carried outside the hash, to\
    \ allow the hash to be verified at the\n   Responder.  Another approach is to\
    \ replace the hash with encryption\n   under a locally known secret, in which\
    \ case the liveness data does\n   not need to be carried in the clear.  Any symmetric\
    \ cipher immune to\n   known plaintext attacks can be used.  In the case of GIST-aware\
    \ NAT\n   traversal with delayed state installation, it is necessary to carry\n\
    \   additional data in the cookie; appropriate constructions are\n   described\
    \ in [44].\n   To support the validation simplicity requirement, the Responder\
    \ can\n   check the liveness data to filter out some blind (flooding) attacks\n\
    \   before beginning any cryptographic cookie verification.  To support\n   this\
    \ usage, the liveness data must be carried in the clear and not be\n   easily\
    \ guessable; this rules out the timestamp approach and suggests\n   the use of\
    \ sequence of secrets with the liveness data identifying the\n   position in the\
    \ sequence.  The secret strength and rollover frequency\n   must be high enough\
    \ that the secret cannot be brute-forced during its\n   lifetime.  Note that any\
    \ node can use a Query to discover the current\n   liveness data, so it remains\
    \ hard to defend against sophisticated\n   attacks that disguise such probes within\
    \ a flood of Queries from\n   forged source addresses.  Therefore, it remains\
    \ important to use an\n   efficient hashing mechanism or equivalent.\n   If a\
    \ node receives a message for which cookie validation fails, it\n   MAY return\
    \ an \"Object Value Error\" message (Appendix A.4.4.10) with\n   subcode 4 (\"\
    Invalid Cookie\") to the sender and SHOULD log an error\n   condition locally,\
    \ as well as dropping the message.  However, sending\n   the error in general\
    \ makes a node a source of backscatter.\n   Therefore, this MUST only be enabled\
    \ selectively, e.g., during\n   initial deployment or debugging.\n"
- title: 8.6.  Security Protocol Selection Policy
  contents:
  - "8.6.  Security Protocol Selection Policy\n   This specification defines a single\
    \ mandatory-to-implement security\n   protocol (TLS; Section 5.7.3).  However,\
    \ it is possible to define\n   additional security protocols in the future, for\
    \ example, to allow\n   re-use with other types of credentials, or migrate towards\
    \ protocols\n   with stronger security properties.  In addition, use of any security\n\
    \   protocol for a messaging association is optional.  Security protocol\n   selection\
    \ is carried out as part of the GIST handshake mechanism\n   (Section 4.4.1).\n\
    \   The selection process may be vulnerable to downgrade attacks, where a\n  \
    \ man in the middle modifies the capabilities offered in the Query or\n   Response\
    \ to mislead the peers into accepting a lower level of\n   protection than is\
    \ achievable.  There is a two-part defence against\n   such attacks (the following\
    \ is based the same concepts as [25]):\n   1.  The Response does not depend on\
    \ the Stack-Proposal in the Query\n       (see Section 5.7.1).  Therefore, tampering\
    \ with the Query has no\n       effect on the resulting messaging association\
    \ configuration.\n   2.  The Responding node's Stack-Proposal is echoed in the\
    \ Confirm.\n       The Responding node checks this to validate that the proposal\
    \ it\n       made in the Response is the same as the one received by the\n   \
    \    Querying node.  Note that as a consequence of the previous point,\n     \
    \  the Responding node does not have to remember the proposal\n       explicitly,\
    \ since it is a static function of local policy.\n   The validity of the second\
    \ part depends on the strength of the\n   security protection provided for the\
    \ Confirm.  If the Querying node\n   is prepared to create messaging associations\
    \ with null security\n   properties (e.g., TCP only), the defence is ineffective,\
    \ since the\n   man in the middle can re-insert the original Responder's Stack-\n\
    \   Proposal, and the Responding node will assume that the minimal\n   protection\
    \ is a consequence of Querying node limitations.  However,\n   if the messaging\
    \ association provides at least integrity protection\n   that cannot be broken\
    \ in real-time, the Confirm cannot be modified in\n   this way.  Therefore, if\
    \ the Querying node does not apply a security\n   policy to the messaging association\
    \ protocols to be created that\n   ensures at least this minimal level of protection\
    \ is met, it remains\n   open to the threat that a downgrade has occurred.  Applying\
    \ such a\n   policy ensures capability discovery process will result in the setup\n\
    \   of a messaging association with the correct security properties for\n   the\
    \ two peers involved.\n"
- title: 8.7.  Residual Threats
  contents:
  - "8.7.  Residual Threats\n   Taking the above security mechanisms into account,\
    \ the main residual\n   threats against NSIS are three types of on-path attack,\n\
    \   vulnerabilities from particular limited modes of TLS usage, and\n   implementation-related\
    \ weaknesses.\n   An on-path attacker who can intercept the initial Query can\
    \ do most\n   things it wants to the subsequent signalling.  It is very hard to\n\
    \   protect against this at the GIST level; the only defence is to use\n   strong\
    \ messaging association security to see whether the Responding\n   node is authorised\
    \ to take part in NSLP signalling exchanges.  To\n   some extent, this behaviour\
    \ is logically indistinguishable from\n   correct operation, so it is easy to\
    \ see why defence is difficult.\n   Note that an on-path attacker of this sort\
    \ can do anything to the\n   traffic as well as the signalling.  Therefore, the\
    \ additional threat\n   induced by the signalling weakness seems tolerable.\n\
    \   At the NSLP level, there is a concern about transitivity of trust of\n   correctness\
    \ of routing along the signalling chain.  The NSLP at the\n   querying node can\
    \ have good assurance that it is communicating with\n   an on-path peer or a node\
    \ delegated by the on-path node by depending\n   on the security protection provided\
    \ by GIST.  However, it has no\n   assurance that the node beyond the responder\
    \ is also on-path, or that\n   the MRI (in particular) is not being modified by\
    \ the responder to\n   refer to a different flow.  Therefore, if it sends signalling\n\
    \   messages with payloads (e.g., authorisation tokens) that are valuable\n  \
    \ to nodes beyond the adjacent hop, it is up to the NSLP to ensure that\n   the\
    \ appropriate chain of trust exists.  This could be achieved using\n   higher\
    \ layer security protection such as Cryptographic Message Syntax\n   (CMS) [28].\n\
    \   There is a further residual attack by a node that is not on the path\n   of\
    \ the Query, but is on the path of the Response, or is able to use a\n   Response\
    \ from one handshake to interfere with another.  The attacker\n   modifies the\
    \ Response to cause the Querying node to form an adjacency\n   with it rather\
    \ than the true peer.  In principle, this attack could\n   be prevented by including\
    \ an additional cryptographic object in the\n   Response that ties the Response\
    \ to the initial Query and the routing\n   state and can be verified by the Querying\
    \ node.\n   GIST depends on TLS for peer node authentication, and subsequent\n\
    \   channel security.  The analysis in [30] indicates the threats that\n   arise\
    \ when the peer node authentication is incomplete --\n   specifically, when unilateral\
    \ authentication is performed (one node\n   authenticates the other, but not vice\
    \ versa).  In this specification,\n   mutual authentication can be supported either\
    \ by certificate exchange\n   or the use of pre-shared keys (see Section 5.7.3);\
    \ if some other TLS\n   authentication mechanism is negotiated, its properties\
    \ would have to\n   be analysed to determine acceptability for use with GIST.\
    \  If mutual\n   authentication is performed, the requirements for NTLP security\
    \ are\n   met.\n   However, in the case of certificate exchange, this specification\n\
    \   allows the possibility that only a server certificate is provided,\n   which\
    \ means that the Querying node authenticates the Responding node\n   but not vice\
    \ versa.  Accepting such unilateral authentication allows\n   for partial security\
    \ in environments where client certificates are\n   not widespread, and is better\
    \ than no security at all; however, it\n   does expose the Responding node to\
    \ certain threats described in\n   Section 3.1 of [30].  For example, the Responding\
    \ node cannot verify\n   whether there is a man-in-the-middle between it and the\
    \ Querying\n   node, which could be manipulating the signalling messages, and\
    \ it\n   cannot verify the identity of the Querying node if it requests\n   authorisation\
    \ of resources.  Note that in the case of host-network\n   signalling, the Responding\
    \ node could be either the host or the first\n   hop router, depending on the\
    \ signalling direction.  Because of these\n   vulnerabilities, modes or deployments\
    \ of TLS which do not provide\n   mutual authentication can be considered as at\
    \ best transitional\n   stages rather than providing a robust security solution.\n\
    \   Certain security aspects of GIST operation depend on signalling\n   application\
    \ behaviour: a poorly implemented or compromised NSLP could\n   degrade GIST security.\
    \  However, the degradation would only affect\n   GIST handling of the NSLP's\
    \ own signalling traffic or overall\n   resource usage at the node where the weakness\
    \ occurred, and\n   implementation weakness or compromise could have just as great\
    \ an\n   effect within the NSLP itself.  GIST depends on NSLPs to choose SIDs\n\
    \   appropriately (Section 4.1.3).  If NSLPs choose non-random SIDs, this\n  \
    \ makes off-path attacks based on SID guessing easier to carry out.\n   NSLPs\
    \ can also leak information in structured SIDs, but they could\n   leak similar\
    \ information in the NSLP payload data anyway.\n"
- title: 9.  IANA Considerations
  contents:
  - "9.  IANA Considerations\n   This section defines the registries and initial codepoint\
    \ assignments\n   for GIST.  It also defines the procedural requirements to be\
    \ followed\n   by IANA in allocating new codepoints.  Note that the guidelines\
    \ on\n   the technical criteria to be followed in evaluating requests for new\n\
    \   codepoint assignments are covered normatively in a separate document\n   that\
    \ considers the NSIS protocol suite in a unified way.  That\n   document discusses\
    \ the general issue of NSIS extensibility, as well\n   as the technical criteria\
    \ for particular registries; see [12] for\n   further details.\n   The registry\
    \ definitions that follow leave large blocks of codes\n   marked \"Reserved\"\
    .  This is to allow a future revision of this\n   specification or another Experimental\
    \ document to modify the relative\n   space given to different allocation policies,\
    \ without having to\n   change the initial rules retrospectively if they turn\
    \ out to have\n   been inappropriate, e.g., if the space for one particular policy\
    \ is\n   exhausted too quickly.\n   The allocation policies used in this section\
    \ follow the guidance\n   given in [4].  In addition, for a number of the GIST\
    \ registries, this\n   specification also defines private/experimental ranges\
    \ as discussed\n   in [9].  Note that the only environment in which these codepoints\
    \ can\n   validly be used is a closed one in which the experimenter knows all\n\
    \   the experiments in progress.\n   This specification allocates the following\
    \ codepoints in existing\n   registries:\n      Well-known UDP port 270 as the\
    \ destination port for Q-mode\n      encapsulated GIST messages (Section 5.3).\n\
    \   This specification creates the following registries with the\n   structures\
    \ as defined below:\n   NSLP Identifiers:  Each signalling application requires\
    \ the\n      assignment of one or more NSLPIDs.  The following NSLPID is\n   \
    \   allocated by this specification:\n   +---------+---------------------------------------------------------+\n\
    \   | NSLPID  | Application                                             |\n  \
    \ +---------+---------------------------------------------------------+\n   |\
    \ 0       | Used for GIST messages not related to any signalling    |\n   |  \
    \       | application.                                            |\n   +---------+---------------------------------------------------------+\n\
    \      Every other NSLPID that uses an MRM that requires RAO usage MUST\n    \
    \  be associated with a specific RAO value; multiple NSLPIDs MAY be\n      associated\
    \ with the same RAO value.  RAO value assignments require\n      a specification\
    \ of the processing associated with messages that\n      carry the value.  NSLP\
    \ specifications MUST normatively depend on\n      this document for the processing,\
    \ specifically Sections 4.3.1,\n      4.3.4 and 5.3.2.  The NSLPID is a 16-bit\
    \ integer, and the\n      registration procedure is IESG Aproval.  Further values\
    \ are as\n      follows:\n      1-32703:  Unassigned\n      32704-32767:  Private/Experimental\
    \ Use\n      32768-65536:  Reserved\n   GIST Message Type:  The GIST common header\
    \ (Appendix A.1) contains a\n      7-bit message type field.  The following values\
    \ are allocated by\n      this specification:\n                          +---------+----------+\n\
    \                          | MType   | Message  |\n                          +---------+----------+\n\
    \                          | 0       | Query    |\n                          |\
    \         |          |\n                          | 1       | Response |\n   \
    \                       |         |          |\n                          | 2\
    \       | Confirm  |\n                          |         |          |\n     \
    \                     | 3       | Data     |\n                          |    \
    \     |          |\n                          | 4       | Error    |\n       \
    \                   |         |          |\n                          | 5    \
    \   | MA-Hello |\n                          +---------+----------+\n      Registration\
    \ procedures are as follows:\n      0-31:  IETF Review\n      32-55:  Expert Review\n\
    \      Further values are as follows:\n      6-55:  Unassigned\n      56-63: \
    \ Private/Experimental Use\n      64-127:  Reserved\n   Object Types:  There is\
    \ a 12-bit field in the object header\n      (Appendix A.2).  The following values\
    \ for object type are defined\n      by this specification:\n                \
    \ +---------+-----------------------------+\n                 | OType   | Object\
    \ Type                 |\n                 +---------+-----------------------------+\n\
    \                 | 0       | Message Routing Information |\n                \
    \ |         |                             |\n                 | 1       | Session\
    \ ID                  |\n                 |         |                        \
    \     |\n                 | 2       | Network Layer Information   |\n        \
    \         |         |                             |\n                 | 3    \
    \   | Stack Proposal              |\n                 |         |            \
    \                 |\n                 | 4       | Stack Configuration Data   \
    \ |\n                 |         |                             |\n            \
    \     | 5       | Query-Cookie                |\n                 |         |\
    \                             |\n                 | 6       | Responder-Cookie\
    \            |\n                 |         |                             |\n \
    \                | 7       | NAT Traversal               |\n                 |\
    \         |                             |\n                 | 8       | NSLP Data\
    \                   |\n                 |         |                          \
    \   |\n                 | 9       | Error                       |\n          \
    \       |         |                             |\n                 | 10     \
    \ | Hello ID                    |\n                 +---------+-----------------------------+\n\
    \      Registration procedures are as follows:\n      0-1023:  IETF Review\n \
    \     1024-1999:  Specification Required\n      Further values are as follows:\n\
    \      11-1999:  Unassigned\n      2000-2047:  Private/Experimental Use\n    \
    \  2048-4095:  Reserved\n      When a new object type is allocated according to\
    \ one of the\n      procedures, the specification MUST provide the object format\
    \ and\n      define the setting of the extensibility bits (A/B; see\n      Appendix\
    \ A.2.1).\n   Message Routing Methods:  GIST allows multiple message routing\n\
    \      methods (see Section 3.3).  The MRM is indicated in the leading\n     \
    \ byte of the MRI object (Appendix A.3.1).  This specification\n      defines\
    \ the following values:\n                  +------------+------------------------+\n\
    \                  | MRM-ID     | Message Routing Method |\n                 \
    \ +------------+------------------------+\n                  | 0          | Path-Coupled\
    \ MRM       |\n                  |            |                        |\n   \
    \               | 1          | Loose-End MRM          |\n                  +------------+------------------------+\n\
    \      Registration procedures are as follows:\n      0-63:  IETF Review\n   \
    \   64-119:  Specification Required\n      Further values are as follows:\n  \
    \    2-119:  Unassigned\n      120-127:  Private/Experimental Use\n      128-255:\
    \  Reserved\n      When a new MRM is allocated according to one of the registration\n\
    \      procedures, the specification MUST provide the information\n      described\
    \ in Section 3.3.\n   MA-Protocol-IDs:  Each protocol that can be used in a messaging\n\
    \      association is identified by a 1-byte MA-Protocol-ID\n      (Section 5.7).\
    \  Note that the MA-Protocol-ID is not an IP protocol\n      number; indeed, some\
    \ of the messaging association protocols --\n      such as TLS -- do not have\
    \ an IP protocol number.  This is used as\n      a tag in the Stack-Proposal and\
    \ Stack-Configuration-Data objects\n      (Appendix A.3.4 and Appendix A.3.5).\
    \  The following values are\n      defined by this specification:\n     +---------------------+-----------------------------------------+\n\
    \     | MA-Protocol-ID      | Protocol                                |\n    \
    \ +---------------------+-----------------------------------------+\n     | 0\
    \                   | Reserved                                |\n     |      \
    \               |                                         |\n     | 1        \
    \           | TCP opened in the forwards direction    |\n     |              \
    \       |                                         |\n     | 2                \
    \   | TLS initiated in the forwards direction |\n     +---------------------+-----------------------------------------+\n\
    \      Registration procedures are as follows:\n      0-63:  IETF Review\n   \
    \   64-119:  Expert Review\n      Further values are as follows:\n      3-119:\
    \  Unassigned\n      120-127:  Private/Experimental Use\n      128-255:  Reserved\n\
    \      When a new MA-Protocol-ID is allocated according to one of the\n      registration\
    \ procedures, a specification document will be\n      required.  This MUST define\
    \ the format for the MA-protocol-options\n      field (if any) in the Stack-Configuration-Data\
    \ object that is\n      needed to define its configuration.  If a protocol is\
    \ to be used\n      for reliable message transfer, it MUST be described how delivery\n\
    \      errors are to be detected by GIST.  Extensions to include new\n      channel\
    \ security protocols MUST include a description of how to\n      integrate the\
    \ functionality described in Section 3.9 with the rest\n      of GIST operation.\
    \  If the new MA-Protocol-ID can be used in\n      conjunction with existing ones\
    \ (for example, a new transport\n      protocol that could be used with Transport\
    \ Layer Security), the\n      specification MUST define the interaction between\
    \ the two.\n   Error Codes/Subcodes:  There is a 2-byte error code and 1-byte\n\
    \      subcode in the Value field of the Error Object (Appendix A.4.1).\n    \
    \  Error codes 1-12 are defined in Appendix A.4.4 together with\n      subcodes\
    \ 0-5 (code 1), 0-5 (code 9), 0-5 (code 10), and 0-2 (code\n      12).  Additional\
    \ codes and subcodes are allocated on a first-come,\n      first-served basis.\
    \  When a new code/subcode combination is\n      allocated, the following information\
    \ MUST be provided:\n      Error case:  textual name of error\n      Error class:\
    \  from the categories given in Appendix A.4.3\n      Error code:  allocated by\
    \ IANA, if a new code is required\n      Error subcode:  subcode point, also allocated\
    \ by IANA\n      Additional information:  what Additional Information fields are\n\
    \         mandatory to include in the error message, from Appendix A.4.2\n   Additional\
    \ Information Types:  An Error Object (Appendix A.4.1) may\n      contain Additional\
    \ Information fields.  Each possible field type\n      is identified by a 16-bit\
    \ AI-Type.  AI-Types 1-4 are defined in\n      Appendix A.4.2; additional AI-Types\
    \ are allocated on a first-come,\n      first-served basis.\n"
- title: 10.  Acknowledgements
  contents:
  - "10.  Acknowledgements\n   This document is based on the discussions within the\
    \ IETF NSIS\n   working group.  It has been informed by prior work and formal\
    \ and\n   informal inputs from: Cedric Aoun, Attila Bader, Vitor Bernado,\n  \
    \ Roland Bless, Bob Braden, Marcus Brunner, Benoit Campedel, Yoshiko\n   Chong,\
    \ Luis Cordeiro, Elwyn Davies, Michel Diaz, Christian Dickmann,\n   Pasi Eronen,\
    \ Alan Ford, Xiaoming Fu, Bo Gao, Ruediger Geib, Eleanor\n   Hepworth, Thomas\
    \ Herzog, Cheng Hong, Teemu Huovila, Jia Jia, Cornelia\n   Kappler, Georgios Karagiannis,\
    \ Ruud Klaver, Max Laier, Chris Lang,\n   Lauri Liuhto, John Loughney, Allison\
    \ Mankin, Jukka Manner, Pete\n   McCann, Andrew McDonald, Mac McTiffin, Glenn\
    \ Morrow, Dave Oran,\n   Andreas Pashalidis, Henning Peters, Tom Phelan, Akbar\
    \ Rahman, Takako\n   Sanda, Charles Shen, Melinda Shore, Martin Stiemerling, Martijn\n\
    \   Swanink, Mike Thomas, Hannes Tschofenig, Sven van den Bosch, Nuutti\n   Varis,\
    \ Michael Welzl, Lars Westberg, and Mayi Zoumaro-djayoon.  Parts\n   of the TLS\
    \ usage description (Section 5.7.3) were derived from the\n   Diameter base protocol\
    \ specification, RFC 3588.  In addition, Hannes\n   Tschofenig provided a detailed\
    \ set of review comments on the security\n   section, and Andrew McDonald provided\
    \ the formal description for the\n   initial packet formats and the name matching\
    \ algorithm for TLS.\n   Chris Lang's implementation work provided objective feedback\
    \ on the\n   clarity and feasibility of the specification, and he also provided\n\
    \   the state machine description and the initial error catalogue and\n   formats.\
    \  Magnus Westerlund carried out a detailed AD review that\n   identified a number\
    \ of issues and led to significant clarifications,\n   which was followed by an\
    \ even more detailed IESG review, with\n   comments from Jari Arkko, Ross Callon,\
    \ Brian Carpenter, Lisa\n   Dusseault, Lars Eggert, Ted Hardie, Sam Hartman, Russ\
    \ Housley, Cullen\n   Jennings, and Tim Polk, and a very detailed analysis by\
    \ Adrian Farrel\n   from the Routing Area directorate; Suresh Krishnan carried\
    \ out a\n   detailed review for the Gen-ART.\n"
- title: 11.  References
  contents:
  - '11.  References

    '
- title: 11.1.  Normative References
  contents:
  - "11.1.  Normative References\n   [1]   Braden, R., \"Requirements for Internet\
    \ Hosts - Communication\n         Layers\", STD 3, RFC 1122, October 1989.\n \
    \  [2]   Baker, F., \"Requirements for IP Version 4 Routers\", RFC 1812,\n   \
    \      June 1995.\n   [3]   Bradner, S., \"Key words for use in RFCs to Indicate\
    \ Requirement\n         Levels\", BCP 14, RFC 2119, March 1997.\n   [4]   Narten,\
    \ T. and H. Alvestrand, \"Guidelines for Writing an IANA\n         Considerations\
    \ Section in RFCs\", BCP 26, RFC 5226, May 2008.\n   [5]   Deering, S. and R.\
    \ Hinden, \"Internet Protocol, Version 6 (IPv6)\n         Specification\", RFC\
    \ 2460, December 1998.\n   [6]   Nichols, K., Blake, S., Baker, F., and D. Black,\
    \ \"Definition of\n         the Differentiated Services Field (DS Field) in the\
    \ IPv4 and\n         IPv6 Headers\", RFC 2474, December 1998.\n   [7]   Nordmark,\
    \ E., \"Stateless IP/ICMP Translation Algorithm (SIIT)\",\n         RFC 2765,\
    \ February 2000.\n   [8]   Cooper, D., Santesson, S., Farrell, S., Boeyen, S.,\
    \ Housley,\n         R., and W. Polk, \"Internet X.509 Public Key Infrastructure\n\
    \         Certificate and Certificate Revocation List (CRL) Profile\",\n     \
    \    RFC 5280, May 2008.\n   [9]   Narten, T., \"Assigning Experimental and Testing\
    \ Numbers\n         Considered Useful\", BCP 82, RFC 3692, January 2004.\n   [10]\
    \  Dierks, T. and E. Rescorla, \"The Transport Layer Security (TLS)\n        \
    \ Protocol Version 1.2\", RFC 5246, August 2008.\n   [11]  Crocker, D. and P.\
    \ Overell, \"Augmented BNF for Syntax\n         Specifications: ABNF\", STD 68,\
    \ RFC 5234, January 2008.\n   [12]  Manner, J., Bless, R., Loughney, J., and E.\
    \ Davies, \"Using and\n         Extending the NSIS Protocol Family\", RFC 5978,\
    \ October 2010.\n"
- title: 11.2.  Informative References
  contents:
  - "11.2.  Informative References\n   [13]  Katz, D., \"IP Router Alert Option\"\
    , RFC 2113, February 1997.\n   [14]  Braden, B., Zhang, L., Berson, S., Herzog,\
    \ S., and S. Jamin,\n         \"Resource ReSerVation Protocol (RSVP) -- Version\
    \ 1 Functional\n         Specification\", RFC 2205, September 1997.\n   [15] \
    \ Dierks, T. and C. Allen, \"The TLS Protocol Version 1.0\",\n         RFC 2246,\
    \ January 1999.\n   [16]  Moy, J., \"OSPF Version 2\", STD 54, RFC 2328, April\
    \ 1998.\n   [17]  Partridge, C. and A. Jackson, \"IPv6 Router Alert Option\",\n\
    \         RFC 2711, October 1999.\n   [18]  Terzis, A., Krawczyk, J., Wroclawski,\
    \ J., and L. Zhang, \"RSVP\n         Operation Over IP Tunnels\", RFC 2746, January\
    \ 2000.\n   [19]  Carpenter, B. and K. Moore, \"Connection of IPv6 Domains via\n\
    \         IPv4 Clouds\", RFC 3056, February 2001.\n   [20]  Huitema, C., \"An\
    \ Anycast Prefix for 6to4 Relay Routers\",\n         RFC 3068, June 2001.\n  \
    \ [21]  Baker, F., Iturralde, C., Le Faucheur, F., and B. Davie,\n         \"\
    Aggregation of RSVP for IPv4 and IPv6 Reservations\", RFC 3175,\n         September\
    \ 2001.\n   [22]  Awduche, D., Berger, L., Gan, D., Li, T., Srinivasan, V., and\n\
    \         G. Swallow, \"RSVP-TE: Extensions to RSVP for LSP Tunnels\",\n     \
    \    RFC 3209, December 2001.\n   [23]  Jamoussi, B., Andersson, L., Callon, R.,\
    \ Dantu, R., Wu, L.,\n         Doolan, P., Worster, T., Feldman, N., Fredette,\
    \ A., Girish, M.,\n         Gray, E., Heinanen, J., Kilty, T., and A. Malis, \"\
    Constraint-\n         Based LSP Setup using LDP\", RFC 3212, January 2002.\n \
    \  [24]  Grossman, D., \"New Terminology and Clarifications for\n         Diffserv\"\
    , RFC 3260, April 2002.\n   [25]  Arkko, J., Torvinen, V., Camarillo, G., Niemi,\
    \ A., and T.\n         Haukka, \"Security Mechanism Agreement for the Session\n\
    \         Initiation Protocol (SIP)\", RFC 3329, January 2003.\n   [26]  Rosenberg,\
    \ J., Mahy, R., Matthews, P., and D. Wing, \"Session\n         Traversal Utilities\
    \ for NAT (STUN)\", RFC 5389, October 2008.\n   [27]  Mahy, R., Matthews, P.,\
    \ and J. Rosenberg, \"Traversal Using\n         Relays around NAT (TURN): Relay\
    \ Extensions to Session Traversal\n         Utilities for NAT (STUN)\", RFC 5766,\
    \ April 2010.\n   [28]  Housley, R., \"Cryptographic Message Syntax (CMS)\", STD\
    \ 70, RFC\n         5652, September 2009.\n   [29]  Hancock, R., Karagiannis,\
    \ G., Loughney, J., and S. Van den\n         Bosch, \"Next Steps in Signaling\
    \ (NSIS): Framework\", RFC 4080,\n         June 2005.\n   [30]  Tschofenig, H.\
    \ and D. Kroeselberg, \"Security Threats for Next\n         Steps in Signaling\
    \ (NSIS)\", RFC 4081, June 2005.\n   [31]  Eastlake, D., Schiller, J., and S.\
    \ Crocker, \"Randomness\n         Requirements for Security\", BCP 106, RFC 4086,\
    \ June 2005.\n   [32]  Eronen, P. and H. Tschofenig, \"Pre-Shared Key Ciphersuites\
    \ for\n         Transport Layer Security (TLS)\", RFC 4279, December 2005.\n \
    \  [33]  Conta, A., Deering, S., and M. Gupta, \"Internet Control Message\n  \
    \       Protocol (ICMPv6) for the Internet Protocol Version 6 (IPv6)\n       \
    \  Specification\", RFC 4443, March 2006.\n   [34]  Stiemerling, M., Tschofenig,\
    \ H., Aoun, C., and E. Davies, \"NAT/\n         Firewall NSIS Signaling Layer\
    \ Protocol (NSLP)\", Work\n         in Progress, April 2010.\n   [35]  Nordmark,\
    \ E. and R. Gilligan, \"Basic Transition Mechanisms for\n         IPv6 Hosts and\
    \ Routers\", RFC 4213, October 2005.\n   [36]  Kent, S. and K. Seo, \"Security\
    \ Architecture for the Internet\n         Protocol\", RFC 4301, December 2005.\n\
    \   [37]  Nikander, P., Arkko, J., Aura, T., Montenegro, G., and E.\n        \
    \ Nordmark, \"Mobile IP Version 6 Route Optimization Security\n         Design\
    \ Background\", RFC 4225, December 2005.\n   [38]  Audet, F. and C. Jennings,\
    \ \"Network Address Translation (NAT)\n         Behavioral Requirements for Unicast\
    \ UDP\", BCP 127, RFC 4787,\n         January 2007.\n   [39]  Stewart, R., \"\
    Stream Control Transmission Protocol\", RFC 4960,\n         September 2007.\n\
    \   [40]  Aoun, C. and E. Davies, \"Reasons to Move the Network Address\n    \
    \     Translator - Protocol Translator (NAT-PT) to Historic Status\",\n      \
    \   RFC 4966, July 2007.\n   [41]  Gill, V., Heasley, J., Meyer, D., Savola, P.,\
    \ and C. Pignataro,\n         \"The Generalized TTL Security Mechanism (GTSM)\"\
    , RFC 5082,\n         October 2007.\n   [42]  Floyd, S. and V. Jacobson, \"The\
    \ Synchronisation of Periodic\n         Routing Messages\", SIGCOMM Symposium\
    \ on Communications\n         Architectures and Protocols pp. 33--44, September\
    \ 1993.\n   [43]  Pashalidis, A. and H. Tschofenig, \"GIST Legacy NAT Traversal\"\
    ,\n         Work in Progress, July 2007.\n   [44]  Pashalidis, A. and H. Tschofenig,\
    \ \"GIST NAT Traversal\", Work\n         in Progress, July 2007.\n   [45]  Tsenov,\
    \ T., Tschofenig, H., Fu, X., Aoun, C., and E. Davies,\n         \"GIST State\
    \ Machine\", Work in Progress, April 2010.\n   [46]  Ramaiah, A., Stewart, R.,\
    \ and M. Dalal, \"Improving TCP's\n         Robustness to Blind In-Window Attacks\"\
    , Work in Progress,\n         May 2010.\n"
- title: Appendix A.  Bit-Level Formats and Error Messages
  contents:
  - "Appendix A.  Bit-Level Formats and Error Messages\n   This appendix provides\
    \ formats for the various component parts of the\n   GIST messages defined abstractly\
    \ in Section 5.2.  The whole of this\n   appendix is normative.\n   Each GIST\
    \ message consists of a header and a sequence of objects.\n   The GIST header\
    \ has a specific format, described in more detail in\n   Appendix A.1 below. \
    \ An NSLP message is one object within a GIST\n   message.  Note that GIST itself\
    \ provides the NSLP message length\n   information and signalling application\
    \ identification.  General\n   object formatting guidelines are provided in Appendix\
    \ A.2 below,\n   followed in Appendix A.3 by the format for each object.  Finally,\n\
    \   Appendix A.4 provides the formats used for error reporting.\n   In the following\
    \ object diagrams, '//' is used to indicate a\n   variable-sized field and ':'\
    \ is used to indicate a field that is\n   optionally present.  Any part of the\
    \ object used for padding or\n   defined as reserved (marked 'Reserved' or 'Rsv'\
    \ or, in the case of\n   individual bits, 'r' in the diagrams below) MUST be set\
    \ to 0 on\n   transmission and MUST be ignored on reception.\n   The objects are\
    \ encoded using big endian (network byte order).\n"
- title: A.1.  The GIST Common Header
  contents:
  - "A.1.  The GIST Common Header\n   This header begins all GIST messages.  It has\
    \ a fixed format, as\n   shown below.\n    0                   1             \
    \      2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\
    \ 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |    Version    |   GIST hops   |        Message Length         |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |           NSLPID              |C|   Type      |S|R|E| Reserved|\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   Version (8 bits):  The GIST protocol version number.  This\n      specification\
    \ defines version number 1.\n   GIST hops (8 bits):  A hop count for the number\
    \ of GIST-aware nodes\n      this message can still be processed by (including\
    \ the\n      destination).\n   Message Length (16 bits):  The total number of\
    \ 32-bit words in the\n      message after the common header itself.\n   NSLPID\
    \ (16 bits):  IANA-assigned identifier of the signalling\n      application to\
    \ which the message refers.\n   C-flag:  C=1 if the message has to be able to\
    \ be interpreted in the\n      absence of routing state (Section 5.2.1).\n   Type\
    \ (7 bits):  The GIST message type (Query, Response, etc.).\n   S-flag:  S=1 if\
    \ the IP source address is the same as the signalling\n      source address, S=0\
    \ if it is different.\n   R-flag:  R=1 if a reply to this message is explicitly\
    \ requested.\n   E-flag:  E=1 if the message was explicitly routed (Section 7.1.5).\n\
    \   The rules governing the use of the R-flag depend on the GIST message\n   type.\
    \  It MUST always be set (R=1) in Query messages, since these\n   always elicit\
    \ a Response, and never in Confirm, Data, or Error\n   messages.  It MAY be set\
    \ in an MA-Hello; if set, another MA-Hello\n   MUST be sent in reply.  It MAY\
    \ be set in a Response, but MUST be set\n   if the Response contains a Responder-Cookie;\
    \ if set, a Confirm MUST\n   be sent in reply.  The E-flag MUST NOT be set unless\
    \ the message type\n   is a Data message.\n   Parsing failures may be caused by\
    \ unknown Version or Type values;\n   inconsistent setting of the C-flag, R-flag,\
    \ or E-flag; or a Message\n   Length inconsistent with the set of objects carried.\
    \  In all cases,\n   the receiver MUST if possible return a \"Common Header Parse\
    \ Error\"\n   message (Appendix A.4.4.1) with the appropriate subcode, and not\n\
    \   process the message further.\n"
- title: A.2.  General Object Format
  contents:
  - "A.2.  General Object Format\n   Each object begins with a fixed header giving\
    \ the object Type and\n   object Length.  This is followed by the object Value,\
    \ which is a\n   whole number of 32-bit words long.\n    0                   1\
    \                   2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5\
    \ 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |A|B|r|r|         Type          |r|r|r|r|        Length         |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   //                             Value                           //\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   A/B flags:  The bits marked 'A' and 'B' are extensibility flags,\n      which\
    \ are defined in Appendix A.2.1 below; the remaining bits\n      marked 'r' are\
    \ reserved.\n   Type (12 bits):  An IANA-assigned identifier for the type of object.\n\
    \   Length (12 bits):  Length has the units of 32-bit words, and measures\n  \
    \    the length of Value.  If there is no Value, Length=0.  If the\n      Length\
    \ is not consistent with the contents of the object, an\n      \"Object Value\
    \ Error\" message (Appendix A.4.4.10) with subcode 0\n      \"Incorrect Length\"\
    \ MUST be returned and the message dropped.\n   Value (variable):  Value is (therefore)\
    \ a whole number of 32-bit\n      words.  If there is any padding required, the\
    \ length and location\n      are be defined by the object-specific format information;\
    \ objects\n      that contain variable-length (e.g., string) types may need to\n\
    \      include additional length subfields to do so.\n"
- title: A.2.1.  Object Extensibility
  contents:
  - "A.2.1.  Object Extensibility\n   The leading 2 bits of the TLV header are used\
    \ to signal the desired\n   treatment for objects whose Type field is unknown\
    \ at the receiver.\n   The following three categories of objects have been identified\
    \ and\n   are described here.\n   AB=00 (\"Mandatory\"):  If the object is not\
    \ understood, the entire\n      message containing it MUST be rejected with an\
    \ \"Object Type Error\"\n      message (Appendix A.4.4.9) with subcode 1 (\"Unrecognised\
    \ Object\").\n   AB=01 (\"Ignore\"):  If the object is not understood, it MUST\
    \ be\n      deleted and the rest of the message processed as usual.\n   AB=10\
    \ (\"Forward\"):  If the object is not understood, it MUST be\n      retained\
    \ unchanged in any message forwarded as a result of message\n      processing,\
    \ but not stored locally.\n   The combination AB=11 is reserved.  If a message\
    \ is received\n   containing an object with AB=11, it MUST be rejected with an\
    \ \"Object\n   Type Error\" message (Appendix A.4.4.9) with subcode 5 (\"Invalid\n\
    \   Extensibility Flags\").\n   These extensibility rules define only the processing\
    \ within the GIST\n   layer.  There is no requirement on GIST implementations\
    \ to support an\n   extensible service interface to signalling applications, so\n\
    \   unrecognised objects with AB=01 or AB=10 do not need to be indicated\n   to\
    \ NSLPs.\n"
- title: A.3.  GIST TLV Objects
  contents:
  - 'A.3.  GIST TLV Objects

    '
- title: A.3.1.  Message-Routing-Information (MRI)
  contents:
  - "A.3.1.  Message-Routing-Information (MRI)\n   Type:  Message-Routing-Information\n\
    \   Length:  Variable (depends on MRM)\n    0                   1            \
    \       2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\
    \ 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |     MRM-ID    |N|  Reserved   |                               |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\
    \                               +\n   //     Method-specific addressing information\
    \ (variable)       //\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   MRM-ID (8 bits):  An IANA-assigned identifier for the message routing\n  \
    \    method.\n   N-flag:  If set (N=1), this means that NATs do not need to translate\n\
    \      this MRM; if clear (N=0), it means that the method-specific\n      information\
    \ contains network or transport layer information that a\n      NAT must process.\n\
    \   The remainder of the object contains method-specific addressing\n   information,\
    \ which is described below.\n"
- title: A.3.1.1.  Path-Coupled MRM
  contents:
  - "A.3.1.1.  Path-Coupled MRM\n   In the case of basic path-coupled routing, the\
    \ addressing information\n   takes the following format.  The N-flag has a value\
    \ of 0 for this\n   MRM.\n    0                   1                   2      \
    \             3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8\
    \ 9 0 1\n                                   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                                   |IP-Ver |P|T|F|S|A|B|D|Reserved |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   //                       Source Address                        //\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   //                      Destination Address                    //\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   | Source Prefix |  Dest Prefix  |   Protocol    | DS-field  |Rsv|\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   :       Reserved        |              Flow Label               :\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   :                              SPI                              :\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   :          Source Port          :       Destination Port        :\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   IP-Ver (4 bits):  The IP version number, 4 or 6.\n   Source/Destination address\
    \ (variable):  The source and destination\n      addresses are always present\
    \ and of the same type; their length\n      depends on the value in the IP-Ver\
    \ field.\n   Source/Dest Prefix (each 8 bits):  The length of the mask to be\n\
    \      applied to the source and destination addresses for address\n      wildcarding.\
    \  In the normal case where the MRI refers only to\n      traffic between specific\
    \ host addresses, the Source/Dest Prefix\n      values would both be 32 or 128\
    \ for IPv4 and IPv6, respectively.\n   P-flag:  P=1 means that the Protocol field\
    \ is significant.\n   Protocol (8 bits):  The IP protocol number.  This MUST be\
    \ ignored if\n      P=0.  In the case of IPv6, the Protocol field refers to the\
    \ true\n      upper layer protocol carried by the packets, i.e., excluding any\n\
    \      IP option headers.  This is therefore not necessarily the same as\n   \
    \   the Next Header value from the base IPv6 header.\n   T-flag:  T=1 means that\
    \ the Diffserv field (DS-field) is significant.\n   DS-field (6 bits):  The Diffserv\
    \ field.  See [6] and [24].\n   F-flag:  F=1 means that flow label is present\
    \ and is significant.  F\n      MUST NOT be set if IP-Ver is not 6.\n   Flow Label\
    \ (20 bits):  The flow label; only present if F=1.  If F=0,\n      the entire\
    \ 32-bit word containing the Flow Label is absent.\n   S-flag:  S=1 means that\
    \ the SPI field is present and is significant.\n      The S-flag MUST be 0 if\
    \ the P-flag is 0.\n   SPI field (32 bits):  The SPI field; see [36].  If S=0,\
    \ the entire\n      32-bit word containing the SPI is absent.\n   A/B flags: \
    \ These can only be set if P=1.  If either is set, the port\n      fields are\
    \ also present.  The A flag indicates the presence of a\n      source port, the\
    \ B flag that of a destination port.  If P=0, the\n      A/B flags MUST both be\
    \ zero and the word containing the port\n      numbers is absent.\n   Source/Destination\
    \ Port (each 16 bits):  If either of A (source), B\n      (destination) is set,\
    \ the word containing the port numbers is\n      included in the object.  However,\
    \ the contents of each field is\n      only significant if the corresponding flag\
    \ is set; otherwise, the\n      contents of the field is regarded as padding,\
    \ and the MRI refers\n      to all ports (i.e., acts as a wildcard).  If the flag\
    \ is set and\n      Port=0x0000, the MRI will apply to a specific port, whose\
    \ value is\n      not yet known.  If neither of A or B is set, the word is absent.\n\
    \   D-flag:  The Direction flag has the following meaning: the value 0\n     \
    \ means 'in the same direction as the flow' (i.e., downstream), and\n      the\
    \ value 1 means 'in the opposite direction to the flow' (i.e.,\n      upstream).\n\
    \   The MRI format defines a number of constraints on the allowed\n   combinations\
    \ of flags and fields in the object.  If these constraints\n   are violated, this\
    \ constitutes a parse error, and an \"Object Value\n   Error\" message (Appendix\
    \ A.4.4.10) with subcode 2 (\"Invalid Flag-\n   Field Combination\") MUST be returned.\n"
- title: A.3.1.2.  Loose-End MRM
  contents:
  - "A.3.1.2.  Loose-End MRM\n   In the case of the loose-end MRM, the addressing\
    \ information takes\n   the following format.  The N-flag has a value of 0 for\
    \ this MRM.\n    0                   1                   2                   3\n\
    \    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n       \
    \                            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n             \
    \                      |IP-Ver |D|      Reserved       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   //                       Source Address                        //\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   //                      Destination Address                    //\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   IP-Ver (4 bits):  The IP version number, 4 or 6.\n   Source/Destination address\
    \ (variable):  The source and destination\n      addresses are always present\
    \ and of the same type; their length\n      depends on the value in the IP-Ver\
    \ field.\n   D-flag:  The Direction flag has the following meaning: the value\
    \ 0\n      means 'towards the edge of the network', and the value 1 means\n  \
    \    'from the edge of the network'.  Note that for Q-mode messages,\n      the\
    \ only valid value is D=0 (see Section 5.8.2).\n"
- title: A.3.2.  Session Identifier
  contents:
  - "A.3.2.  Session Identifier\n   Type:  Session-Identifier\n   Length:  Fixed (4\
    \ 32-bit words)\n    0                   1                   2               \
    \    3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n\
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   |  \
    \                                                             |\n   +        \
    \                                                       +\n   |              \
    \                                                 |\n   +                    \
    \      Session ID                           +\n   |                          \
    \                                     |\n   +                                \
    \                               +\n   |                                      \
    \                         |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n"
- title: A.3.3.  Network-Layer-Information (NLI)
  contents:
  - "A.3.3.  Network-Layer-Information (NLI)\n   Type:  Network-Layer-Information\n\
    \   Length:  Variable (depends on length of Peer-Identity and IP version)\n  \
    \  0                   1                   2                   3\n    0 1 2 3\
    \ 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |   PI-Length   |    IP-TTL     |IP-Ver |        Reserved       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                  Routing State Validity Time                  |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   //                       Peer Identity                         //\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   //                     Interface Address                       //\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   PI-Length (8 bits):  The byte length of the Peer Identity field.\n   Peer\
    \ Identity (variable):  The Peer Identity field.  Note that the\n      Peer-Identity\
    \ field itself is padded to a whole number of words.\n   IP-TTL (8 bits):  Initial\
    \ or reported IP layer TTL.\n   IP-Ver (4 bits):  The IP version for the Interface\
    \ Address field.\n   Interface Address (variable):  The IP address allocated to\
    \ the\n      interface, matching the IP-Ver field.\n   Routing State Validity\
    \ Time (32 bits):  The time for which the\n      routing state for this flow can\
    \ be considered correct without a\n      refresh.  Given in milliseconds.  The\
    \ value 0 (zero) is reserved\n      and MUST NOT be used.\n"
- title: A.3.4.  Stack-Proposal
  contents:
  - "A.3.4.  Stack-Proposal\n   Type:  Stack-Proposal\n   Length:  Variable (depends\
    \ on number of profiles and size of each\n      profile)\n    0              \
    \     1                   2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2\
    \ 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |  Prof-Count   |     Reserved                                  |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   //                    Profile 1                                //\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   :                                                               :\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   //                    Profile N                                //\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   Prof-Count (8 bits): The number of profiles listed.  MUST be > 0.\n   Each\
    \ profile is itself a sequence of protocol layers, and the profile\n   is formatted\
    \ as a list as follows:\n   o  The first byte is a count of the number of layers\
    \ in the profile.\n      MUST be > 0.\n   o  This is followed by a sequence of\
    \ 1-byte MA-Protocol-IDs as\n      described in Section 5.7.\n   o  The profile\
    \ is padded to a word boundary with 0, 1, 2, or 3 zero\n      bytes.  These bytes\
    \ MUST be ignored at the receiver.\n   If there are no profiles (Prof-Count=0),\
    \ then an \"Object Value Error\"\n   message (Appendix A.4.4.10) with subcode\
    \ 1 (\"Value Not Supported\")\n   MUST be returned; if a particular profile is\
    \ empty (the leading byte\n   of the profile is zero), then subcode 3 (\"Empty\
    \ List\") MUST be used.\n   In both cases, the message MUST be dropped.\n"
- title: A.3.5.  Stack-Configuration-Data
  contents:
  - "A.3.5.  Stack-Configuration-Data\n   Type:  Stack-Configuration-Data\n   Length:\
    \  Variable (depends on number of protocols and size of each\n      MA-protocol-options\
    \ field)\n    0                   1                   2                   3\n\
    \    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |   MPO-Count   |     Reserved                                  |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                           MA-Hold-Time                        |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   //                     MA-protocol-options 1                   //\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   :                                                               :\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   //                     MA-protocol-options N                   //\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   MPO-Count (8 bits):  The number of MA-protocol-options fields present\n  \
    \    (these contain their own length information).  The MPO-Count MAY\n      be\
    \ zero, but this will only be the case if none of the MA-\n      protocols referred\
    \ to in the Stack-Proposal require option data.\n   MA-Hold-Time (32 bits):  The\
    \ time for which the messaging association\n      will be held open without traffic\
    \ or a hello message.  Note that\n      this value is given in milliseconds, so\
    \ the default time of 30\n      seconds (Section 4.4.5) corresponds to a value\
    \ of 30000.  The\n      value 0 (zero) is reserved and MUST NOT be used.\n   The\
    \ MA-protocol-options fields are formatted as follows:\n    0                \
    \   1                   2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3\
    \ 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |MA-Protocol-ID |     Profile   |    Length     |D|  Reserved   |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   //                         Options Data                        //\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   MA-Protocol-ID (8 bits):  Protocol identifier as described in\n      Section\
    \ 5.7.\n   Profile (8 bits):  Tag indicating which profile from the accompanying\n\
    \      Stack-Proposal object this applies to.  Profiles are numbered from\n  \
    \    1 upwards; the special value 0 indicates 'applies to all\n      profiles'.\n\
    \   Length (8 bits):  The byte length of MA-protocol-options field that\n    \
    \  follows.  This will be zero-padded up to the next word boundary.\n   D-flag:\
    \  If set (D=1), this protocol MUST NOT be used for a messaging\n      association.\n\
    \   Options Data (variable):  Any options data for this protocol.  Note\n    \
    \  that the format of the options data might differ depending on\n      whether\
    \ the field is in a Query or Response.\n"
- title: A.3.6.  Query-Cookie
  contents:
  - "A.3.6.  Query-Cookie\n   Type:  Query-Cookie\n   Length:  Variable (selected\
    \ by Querying node)\n    0                   1                   2           \
    \        3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0\
    \ 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n  \
    \ //                        Query-Cookie                         //\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   The content is defined by the implementation.  See Section 8.5 for\n   further\
    \ discussion.\n"
- title: A.3.7.  Responder-Cookie
  contents:
  - "A.3.7.  Responder-Cookie\n   Type:  Responder-Cookie\n   Length:  Variable (selected\
    \ by Responding node)\n    0                   1                   2         \
    \          3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9\
    \ 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   //                      Responder-Cookie                       //\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   The content is defined by the implementation.  See Section 8.5 for\n   further\
    \ discussion.\n"
- title: A.3.8.  Hello-ID
  contents:
  - "A.3.8.  Hello-ID\n   Type:  Hello-ID\n   Length:  Fixed (1 32-bit word)\n   \
    \ 0                   1                   2                   3\n    0 1 2 3 4\
    \ 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                          Hello-ID                             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   The content is defined by the implementation.  See Section 5.2.2 for\n   further\
    \ discussion.\n"
- title: A.3.9.  NAT-Traversal
  contents:
  - "A.3.9.  NAT-Traversal\n   Type:  NAT-Traversal\n   Length:  Variable (depends\
    \ on length of contained fields)\n   This object is used to support the NAT traversal\
    \ mechanisms described\n   in Section 7.2.2.\n    0                   1      \
    \             2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8\
    \ 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   | MRI-Length    | Type-Count    |  NAT-Count    |  Reserved     |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   //            Original Message-Routing-Information             //\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   //                 List of translated objects                  //\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   | Length of opaque information  |                               |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\
    \                              //\n   //                Information replaced by\
    \ NAT #1                |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   :                                                               :\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   | Length of opaque information  |                               |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\
    \                              //\n   //                Information replaced by\
    \ NAT #N                |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   MRI-Length (8 bits):  The length of the included MRI payload in\n      32-bit\
    \ words.\n   Original Message-Routing-Information (variable):  The MRI data from\n\
    \      when the message was first sent, not including the object header.\n   Type-Count\
    \ (8 bits):  The number of objects in the 'List of\n      translated objects'\
    \ field.\n   List of translated objects (variable):  This field lists the types\
    \ of\n      objects that were translated by every NAT through which the\n    \
    \  message has passed.  Each element in the list is a 16-bit field\n      containing\
    \ the first 16 bits of the object TLV header, including\n      the AB extensibility\
    \ flags, 2 reserved bits, and 12-bit object\n      type.  The list is initialised\
    \ by the first NAT on the path;\n      subsequent NATs may delete elements in\
    \ the list.  Padded with 2\n      null bytes if necessary.\n   NAT-Count (8 bits):\
    \  The number of NATs traversed by the message, and\n      the number of opaque\
    \ payloads at the end of the object.  The\n      length fields for each opaque\
    \ payload are byte counts, not\n      including the 2 bytes of the length field\
    \ itself.  Note that each\n      opaque information field is zero-padded to the\
    \ next 32-bit word\n      boundary if necessary.\n"
- title: A.3.10.  NSLP-Data
  contents:
  - "A.3.10.  NSLP-Data\n   Type:  NSLP-Data\n   Length:  Variable (depends on NSLP)\n\
    \   This object is used to deliver data between NSLPs.  GIST regards the\n   data\
    \ as a number of complete 32-bit words, as given by the length\n   field in the\
    \ TLV; any padding to a word boundary must be carried out\n   within the NSLP\
    \ itself.\n    0                   1                   2                   3\n\
    \    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   //                          NSLP Data                          //\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n"
- title: A.4.  Errors
  contents:
  - 'A.4.  Errors

    '
- title: A.4.1.  Error Object
  contents:
  - "A.4.1.  Error Object\n   Type:  Error\n   Length:  Variable (depends on error)\n\
    \    0                   1                   2                   3\n    0 1 2\
    \ 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |  Error Class  |           Error Code          | Error Subcode |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |S|M|C|D|Q|       Reserved      |  MRI Length   |  Info Count   |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                                                               |\n   +  \
    \                       Common Header                         +\n   |        \
    \            (of original message)                      |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   :                          Session ID                           :\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   :                    Message Routing Information                :\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   :                 Additional Information Fields                 :\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   :                       Debugging Comment                       :\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   The flags are:\n   S - S=1 means the Session ID object is present.\n   M -\
    \ M=1 means MRI object is present.\n   C - C=1 means a debug Comment is present\
    \ after header.\n   D - D=1 means the original message was received in D-mode.\n\
    \   Q - Q=1 means the original message was received Q-mode encapsulated\n    \
    \   (can't be set if D=0).\n   A GIST Error Object contains an 8-bit error-class\
    \ (see\n   Appendix A.4.3), a 16-bit error-code, an 8-bit error-subcode, and as\n\
    \   much information about the message that triggered the error as is\n   available.\
    \  This information MUST include the common header of the\n   original message\
    \ and MUST also include the Session ID and MRI objects\n   if these could be decoded\
    \ correctly.  These objects are included in\n   their entirety, except for their\
    \ TLV Headers.  The MRI Length field\n   gives the length of the MRI object in\
    \ 32-bit words.\n   The Info Count field contains the number of Additional Information\n\
    \   fields in the object, and the possible formats for these fields are\n   given\
    \ in Appendix A.4.2.  The precise set of fields to include\n   depends on the\
    \ error code/subcode.  For every error description in\n   the error catalogue\
    \ Appendix A.4.4, the line \"Additional Info:\"\n   states what fields MUST be\
    \ included; further fields beyond these MAY\n   be included by the sender, and\
    \ the fields may be included in any\n   order.  The Debugging Comment is a null-terminated\
    \ UTF-8 string,\n   padded if necessary to a whole number of 32-bit words with\
    \ more null\n   characters.\n"
- title: A.4.2.  Additional Information Fields (AI)
  contents:
  - "A.4.2.  Additional Information Fields (AI)\n   The Common Error Header may be\
    \ followed by some Additional\n   Information fields.  Each Additional Information\
    \ field has a simple\n   TLV format as follows:\n    0                   1   \
    \                2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6\
    \ 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |          AI-Type              |         AI-Length             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   //                          AI-Value                           //\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   The AI-Type is a 16-bit IANA-assigned value.  The AI-Length gives the\n  \
    \ number of 32-bit words in AI-Value; if an AI-Value is not present,\n   AI-Length=0.\
    \  The AI-Types and AI-Lengths and AI-Value formats of the\n   currently defined\
    \ Additional Information fields are shown below.\n   Message Length Info:\n  \
    \  0                   1                   2                   3\n    0 1 2 3\
    \ 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |     Calculated Length         |           Reserved            |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   AI-Type: 1\n   AI-Length: 1\n   Calculated Length (16 bits): the length of\
    \ the original message\n   calculated by adding up all the objects in the message.\
    \  Measured in\n   32-bit words.\n   MTU Info:\n    0                   1    \
    \               2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7\
    \ 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |           Link MTU            |           Reserved            |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   AI-Type: 2\n   AI-Length: 1\n   Link MTU (16 bits): the IP MTU for a link\
    \ along which a message\n                       could not be sent.  Measured in\
    \ bytes.\n   Object Type Info:\n    0                   1                   2\
    \                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5\
    \ 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |         Object Type           |           Reserved            |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   AI-Type: 3\n   AI-Length: 1\n   Object type (16 bits): This provides information\
    \ about the type\n                          of object that caused the error.\n\
    \   Object Value Info:\n    0                   1                   2        \
    \           3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9\
    \ 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |  Rsv  |  Real Object Length   |            Offset             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   //                           Object                            //\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   AI-Type: 4\n   AI-Length: variable (depends on object length)\n   This object\
    \ carries information about a TLV object that was found\n   to be invalid in the\
    \ original message.  An error message MAY contain\n   more than one Object Value\
    \ Info object.\n   Real Object Length (12 bits):  Since the length in the original\
    \ TLV\n      header may be inaccurate, this field provides the actual length of\n\
    \      the object (including the TLV header) included in the error\n      message.\
    \  Measured in 32-bit words.\n   Offset (16 bits):  The byte in the object at\
    \ which the GIST node\n      found the error.  The first byte in the object has\
    \ offset=0.\n   Object (variable):  The invalid TLV object (including the TLV\n\
    \      header).\n"
- title: A.4.3.  Error Classes
  contents:
  - "A.4.3.  Error Classes\n   The first byte of the Error Object, \"Error Class\"\
    , indicates the\n   severity level.  The currently defined severity levels are:\n\
    \   0 (Informational):  reply data that should not be thought of as\n      changing\
    \ the condition of the protocol state machine.\n   1 (Success):  reply data that\
    \ indicates that the message being\n      responded to has been processed successfully\
    \ in some sense.\n   2 (Protocol-Error):  the message has been rejected because\
    \ of a\n      protocol error (e.g., an error in message format).\n   3 (Transient-Failure):\
    \  the message has been rejected because of a\n      particular local node status\
    \ that may be transient (i.e., it may\n      be worthwhile to retry after some\
    \ delay).\n   4 (Permanent-Failure):  the message has been rejected because of\n\
    \      local node status that will not change without additional out-of-\n   \
    \   band (e.g., management) operations.\n   Additional error class values are\
    \ reserved.\n   The allocation of error classes to particular errors is not precise;\n\
    \   the above descriptions are deliberately informal.  Actual error\n   processing\
    \ SHOULD take into account the specific error in question;\n   the error class\
    \ may be useful supporting information (e.g., in\n   network debugging).\n"
- title: A.4.4.  Error Catalogue
  contents:
  - "A.4.4.  Error Catalogue\n   This section lists all the possible GIST errors,\
    \ including when they\n   are raised and what Additional Information fields MUST\
    \ be carried in\n   the Error Object.\n"
- title: A.4.4.1.  Common Header Parse Error
  contents:
  - "A.4.4.1.  Common Header Parse Error\n   Class:              Protocol-Error\n\
    \   Code:               1\n   Additional Info:    For subcode 3 only, Message\
    \ Length Info carries\n                       the calculated message length.\n\
    \   This message is sent if a GIST node receives a message where the\n   common\
    \ header cannot be parsed correctly, or where an error in the\n   overall message\
    \ format is detected.  Note that in this case the\n   original MRI and Session\
    \ ID MUST NOT be included in the Error Object.\n   This error code is split into\
    \ subcodes as follows:\n   0: Unknown Version:  The GIST version is unknown. \
    \ The (highest)\n      supported version supported by the node can be inferred\
    \ from the\n      common header of the Error message itself.\n   1: Unknown Type:\
    \  The GIST message type is unknown.\n   2: Invalid R-flag:  The R-flag in the\
    \ header is inconsistent with the\n      message type.\n   3: Incorrect Message\
    \ Length:  The overall message length is not\n      consistent with the set of\
    \ objects carried.\n   4: Invalid E-flag:  The E-flag is set in the header, but\
    \ this is not\n      a Data message.\n   5: Invalid C-flag:  The C-flag was set\
    \ on something other than a\n      Query message or Q-mode Data message, or was\
    \ clear on a Query\n      message.\n"
- title: A.4.4.2.  Hop Limit Exceeded
  contents:
  - "A.4.4.2.  Hop Limit Exceeded\n   Class:              Permanent-Failure\n   Code:\
    \               2\n   Additional Info:    None\n   This message is sent if a GIST\
    \ node receives a message with a GIST\n   hop count of zero, or a GIST node tries\
    \ to forward a message after\n   its GIST hop count has been decremented to zero\
    \ on reception.  This\n   message indicates either a routing loop or too small\
    \ an initial hop\n   count value.\n"
- title: A.4.4.3.  Incorrect Encapsulation
  contents:
  - "A.4.4.3.  Incorrect Encapsulation\n   Class:              Protocol-Error\n  \
    \ Code:               3\n   Additional Info:    None\n   This message is sent\
    \ if a GIST node receives a message that uses an\n   incorrect encapsulation method\
    \ (e.g., a Query arrives over an MA, or\n   the Confirm for a handshake that sets\
    \ up a messaging association\n   arrives in D-mode).\n"
- title: A.4.4.4.  Incorrectly Delivered Message
  contents:
  - "A.4.4.4.  Incorrectly Delivered Message\n   Class:              Protocol-Error\n\
    \   Code:               4\n   Additional Info:    None\n   This message is sent\
    \ if a GIST node receives a message over an MA\n   that is not associated with\
    \ the MRI/NSLPID/SID combination in the\n   message.\n"
- title: A.4.4.5.  No Routing State
  contents:
  - "A.4.4.5.  No Routing State\n   Class:              Protocol-Error\n   Code: \
    \              5\n   Additional Info:    None\n   This message is sent if a node\
    \ receives a message for which routing\n   state should exist, but has not yet\
    \ been created and thus there is no\n   appropriate Querying-SM or Responding-SM.\
    \  This can occur on\n   receiving a Data or Confirm message at a node whose policy\
    \ requires\n   routing state to exist before such messages can be accepted.  See\n\
    \   also Section 6.1 and Section 6.3.\n"
- title: A.4.4.6.  Unknown NSLPID
  contents:
  - "A.4.4.6.  Unknown NSLPID\n   Class:              Permanent-Failure\n   Code:\
    \               6\n   Additional Info:    None\n   This message is sent if a router\
    \ receives a directly addressed\n   message for an NSLP that it does not support.\n"
- title: A.4.4.7.  Endpoint Found
  contents:
  - "A.4.4.7.  Endpoint Found\n   Class:              Permanent-Failure\n   Code:\
    \               7\n   Additional Info:    None\n   This message is sent if a GIST\
    \ node at a flow endpoint receives a\n   Query message for an NSLP that it does\
    \ not support.\n"
- title: A.4.4.8.  Message Too Large
  contents:
  - "A.4.4.8.  Message Too Large\n   Class:              Permanent-Failure\n   Code:\
    \               8\n   Additional Info:    MTU Info\n   This message is sent if\
    \ a router receives a message that it can't\n   forward because it exceeds the\
    \ IP MTU on the next or subsequent hops.\n"
- title: A.4.4.9.  Object Type Error
  contents:
  - "A.4.4.9.  Object Type Error\n   Class:              Protocol-Error\n   Code:\
    \               9\n   Additional Info:    Object Type Info\n   This message is\
    \ sent if a GIST node receives a message containing a\n   TLV object with an invalid\
    \ type.  The message indicates the object\n   type at fault in the additional\
    \ info field.  This error code is split\n   into subcodes as follows:\n   0: Duplicate\
    \ Object:  This subcode is used if a GIST node receives a\n      message containing\
    \ multiple instances of an object that may only\n      appear once in a message.\
    \  In the current specification, this\n      applies to all objects.\n   1: Unrecognised\
    \ Object:  This subcode is used if a GIST node receives\n      a message containing\
    \ an object that it does not support, and the\n      extensibility flags AB=00.\n\
    \   2: Missing Object:  This subcode is used if a GIST node receives a\n     \
    \ message that is missing one or more mandatory objects.  This\n      message\
    \ is also sent if a Stack-Proposal is sent without a\n      matching Stack-Configuration-Data\
    \ object when one was necessary,\n      or vice versa.\n   3: Invalid Object Type:\
    \  This subcode is used if the object type is\n      known, but it is not valid\
    \ for this particular GIST message type.\n   4: Untranslated Object:  This subcode\
    \ is used if the object type is\n      known and is mandatory to interpret, but\
    \ it contains addressing\n      data that has not been translated by an intervening\
    \ NAT.\n   5: Invalid Extensibility Flags:  This subcode is used if an object\
    \ is\n      received with the extensibility flags AB=11.\n"
- title: A.4.4.10.  Object Value Error
  contents:
  - "A.4.4.10.  Object Value Error\n   Class:              Protocol-Error\n   Code:\
    \               10\n   Additional Info:    1 or 2 Object Value Info fields as\
    \ given below\n   This message is sent if a node receives a message containing\
    \ an\n   object that cannot be properly parsed.  The error message contains a\n\
    \   single Object Value Info object, except for subcode 5 as stated\n   below.\
    \  This error code is split into subcodes as follows:\n   0: Incorrect Length:\
    \  The overall length does not match the object\n      length calculated from\
    \ the object contents.\n   1: Value Not Supported:  The value of a field is not\
    \ supported by the\n      GIST node.\n   2: Invalid Flag-Field Combination:  An\
    \ object contains an invalid\n      combination of flags and/or fields.  At the\
    \ moment, this only\n      relates to the Path-Coupled MRI (Appendix A.3.1.1),\
    \ but in future\n      there may be more.\n   3: Empty List:  At the moment, this\
    \ only relates to Stack-Proposals.\n      The error message is sent if a stack\
    \ proposal with a length > 0\n      contains only null bytes (a length of 0 is\
    \ handled as \"Value Not\n      Supported\").\n   4: Invalid Cookie:  The message\
    \ contains a cookie that could not be\n      verified by the node.\n   5: Stack-Proposal\
    \ - Stack-Configuration-Data Mismatch:  This subcode\n      is used if a GIST\
    \ node receives a message in which the data in the\n      Stack-Proposal object\
    \ is inconsistent with the information in the\n      Stack Configuration Data\
    \ object.  In this case, both the Stack-\n      Proposal object and Stack-Configuration-Data\
    \ object MUST be\n      included in separate Object Value Info fields in that\
    \ order.\n"
- title: A.4.4.11.  Invalid IP-Layer TTL
  contents:
  - "A.4.4.11.  Invalid IP-Layer TTL\n   Class:              Permanent-Failure\n \
    \  Code:               11\n   Additional Info:    None\n   This error indicates\
    \ that a message was received with an IP-layer TTL\n   outside an acceptable range,\
    \ for example, that an upstream Query was\n   received with an IP layer TTL of\
    \ less than 254 (i.e., more than one\n   IP hop from the sender).  The actual\
    \ IP distance can be derived from\n   the IP-TTL information in the NLI object\
    \ carried in the same message.\n"
- title: A.4.4.12.  MRI Validation Failure
  contents:
  - "A.4.4.12.  MRI Validation Failure\n   Class:              Permanent-Failure\n\
    \   Code:               12\n   Additional Info:    Object Value Info\n   This\
    \ error indicates that a message was received with an MRI that\n   could not be\
    \ accepted, e.g., because of too much wildcarding or\n   failing some validation\
    \ check (cf. Section 5.8.1.2).  The Object\n   Value Info includes the MRI so\
    \ the error originator can indicate the\n   part of the MRI that caused the problem.\
    \  The error code is divided\n   into subcodes as follows:\n   0: MRI Too Wild:\
    \  The MRI contained too much wildcarding (e.g., too\n      short a destination\
    \ address prefix) to be forwarded correctly down\n      a single path.\n   1:\
    \ IP Version Mismatch:  The MRI in a path-coupled Query message\n      refers\
    \ to an IP version that is not implemented on the interface\n      used, or is\
    \ different from the IP version of the Query\n      encapsulation (see Section\
    \ 7.4).\n   2: Ingress Filter Failure:  The MRI in a path-coupled Query message\n\
    \      describes a flow that would not pass ingress filtering on the\n      interface\
    \ used.\n"
- title: Appendix B.  API between GIST and Signalling Applications
  contents:
  - "Appendix B.  API between GIST and Signalling Applications\n   This appendix provides\
    \ an abstract API between GIST and signalling\n   applications.  It should not\
    \ constrain implementers, but rather help\n   clarify the interface between the\
    \ different layers of the NSIS\n   protocol suite.  In addition, although some\
    \ of the data types carry\n   the information from GIST information elements,\
    \ this does not imply\n   that the format of that data as sent over the API has\
    \ to be the same.\n   Conceptually, the API has similarities to the sockets API,\n\
    \   particularly that for unconnected UDP sockets.  An extension for an\n   API\
    \ like that for UDP connected sockets could be considered.  In this\n   case,\
    \ for example, the only information needed in a SendMessage\n   primitive would\
    \ be NSLP-Data, NSLP-Data-Size, and NSLP-Message-Handle\n   (which can be null).\
    \  Other information that was persistent for a\n   group of messages could be\
    \ configured once for the socket.  Such\n   extensions may make a concrete implementation\
    \ more efficient but do\n   not change the API semantics, and so are not considered\
    \ further here.\n"
- title: B.1.  SendMessage
  contents:
  - "B.1.  SendMessage\n   This primitive is passed from a signalling application\
    \ to GIST.  It\n   is used whenever the signalling application wants to initiate\
    \ sending\n   a message.\n   SendMessage ( NSLP-Data, NSLP-Data-Size, NSLP-Message-Handle,\n\
    \                 NSLPID, Session-ID, MRI, SII-Handle,\n                 Transfer-Attributes,\
    \ Timeout, IP-TTL, GIST-Hop-Count )\n   The following arguments are mandatory:\n\
    \   NSLP-Data:  The NSLP message itself.\n   NSLP-Data-Size:  The length of NSLP-Data.\n\
    \   NSLP-Message-Handle:  A handle for this message that can be used by\n    \
    \  GIST as a reference in subsequent MessageStatus notifications\n      (Appendix\
    \ B.3).  Notifications could be about error conditions or\n      about the security\
    \ attributes that will be used for the message.\n      A NULL handle may be supplied\
    \ if the NSLP is not interested in\n      such notifications.\n   NSLPID:  An\
    \ identifier indicating which NSLP this is.\n   Session-ID:  The NSIS session\
    \ identifier.  Note that it is assumed\n      that the signalling application\
    \ provides this to GIST rather than\n      GIST providing a value itself.\n  \
    \ MRI:  Message routing information for use by GIST in determining the\n     \
    \ correct next GIST hop for this message.  The MRI implies the\n      message\
    \ routing method to be used and the message direction.\n   The following arguments\
    \ are optional:\n   SII-Handle:  A handle, previously supplied by GIST, to a data\n\
    \      structure that should be used to route the message explicitly to a\n  \
    \    particular GIST next hop.\n   Transfer-Attributes:  Attributes defining how\
    \ the message should be\n      handled (see Section 4.1.2).  The following attributes\
    \ can be\n      considered:\n      Reliability:  Values 'unreliable' or 'reliable'.\n\
    \      Security:  This attribute allows the NSLP to specify what level of\n  \
    \       security protection is requested for the message (such as\n         'integrity'\
    \ or 'confidentiality') and can also be used to\n         specify what authenticated\
    \ signalling source and destination\n         identities should be used to send\
    \ the message.  The\n         possibilities can be learned by the signalling application\
    \ from\n         prior MessageStatus or RecvMessage notifications.  If an NSLP-\n\
    \         Message-Handle is provided, GIST will inform the signalling\n      \
    \   application of what values it has actually chosen for this\n         attribute\
    \ via a MessageStatus callback.  This might take place\n         either synchronously\
    \ (where GIST is selecting from available\n         messaging associations) or\
    \ asynchronously (when a new messaging\n         association needs to be created).\n\
    \      Local Processing:  This attribute contains hints from the\n         signalling\
    \ application about what local policy should be\n         applied to the message\
    \ -- in particular, its transmission\n         priority relative to other messages,\
    \ or whether GIST should\n         attempt to set up or maintain forward routing\
    \ state.\n   Timeout:  Length of time GIST should attempt to send this message\n\
    \      before indicating an error.\n   IP-TTL:  The value of the IP layer TTL\
    \ that should be used when\n      sending this message (may be overridden by GIST\
    \ for particular\n      messages).\n   GIST-Hop-Count:  The value for the hop\
    \ count when sending the\n      message.\n"
- title: B.2.  RecvMessage
  contents:
  - "B.2.  RecvMessage\n   This primitive is passed from GIST to a signalling application.\
    \  It\n   is used whenever GIST receives a message from the network, including\n\
    \   the case of null messages (zero-length NSLP payload), typically\n   initial\
    \ Query messages.  For Queries, the results of invoking this\n   primitive are\
    \ used by GIST to check whether message routing state\n   should be created (see\
    \ the discussion of the 'Routing-State-Check'\n   argument below).\n   RecvMessage\
    \ ( NSLP-Data, NSLP-Data-Size, NSLPID, Session-ID, MRI,\n                 Routing-State-Check,\
    \ SII-Handle, Transfer-Attributes,\n                 IP-TTL, IP-Distance, GIST-Hop-Count,\n\
    \                 Inbound-Interface )\n   NSLP-Data:  The NSLP message itself\
    \ (may be empty).\n   NSLP-Data-Size:  The length of NSLP-Data (may be zero).\n\
    \   NSLPID:  An identifier indicating which NSLP this message is for.\n   Session-ID:\
    \  The NSIS session identifier.\n   MRI:  Message routing information that was\
    \ used by GIST in forwarding\n      this message.  Implicitly defines the message\
    \ routing method that\n      was used and the direction of the message relative\
    \ to the MRI.\n   Routing-State-Check:  This boolean is True if GIST is checking\
    \ with\n      the signalling application to see if routing state should be\n \
    \     created with the peer or the message should be forwarded further\n     \
    \ (see Section 4.3.2).  If True, the signalling application should\n      return\
    \ the following values via the RecvMessage call:\n         A boolean indicating\
    \ whether to set up the state.\n         Optionally, an NSLP-Payload to carry\
    \ in the generated Response\n         or forwarded Query respectively.\n     \
    \ This mechanism could be extended to enable the signalling\n      application\
    \ to indicate to GIST whether state installation should\n      be immediate or\
    \ deferred (see Section 5.3.3 and Section 6.3 for\n      further discussion).\n\
    \   SII-Handle:  A handle to a data structure, identifying a peer address\n  \
    \    and interface.  Can be used to identify route changes and for\n      explicit\
    \ routing to a particular GIST next hop.\n   Transfer-Attributes:  The reliability\
    \ and security attributes that\n      were associated with the reception of this\
    \ particular message.  As\n      well as the attributes associated with SendMessage,\
    \ GIST may\n      indicate the level of verification of the addresses in the MRI.\n\
    \      Three attributes can be indicated:\n      *  Whether the signalling source\
    \ address is one of the flow\n         endpoints (i.e., whether this is the first\
    \ or last GIST hop).\n      *  Whether the signalling source address has been\
    \ validated by a\n         return routability check.\n      *  Whether the message\
    \ was explicitly routed (and so has not been\n         validated by GIST as delivered\
    \ consistently with local routing\n         state).\n   IP-TTL:  The value of\
    \ the IP layer TTL this message was received with\n      (if available).\n   IP-Distance:\
    \  The number of IP hops from the peer signalling node\n      that sent this message\
    \ along the path, or 0 if this information is\n      not available.\n   GIST-Hop-Count:\
    \  The value of the hop count the message was received\n      with, after being\
    \ decremented in the GIST receive-side processing.\n   Inbound-Interface:  Attributes\
    \ of the interface on which the message\n      was received, such as whether it\
    \ lies on the internal or external\n      side of a NAT.  These attributes have\
    \ only local significance and\n      are defined by the implementation.\n"
- title: B.3.  MessageStatus
  contents:
  - "B.3.  MessageStatus\n   This primitive is passed from GIST to a signalling application.\
    \  It\n   is used to notify the signalling application that a message that it\n\
    \   requested to be sent could not be dispatched, or to inform the\n   signalling\
    \ application about the transfer attributes that have been\n   selected for the\
    \ message (specifically, security attributes).  The\n   signalling application\
    \ can respond to this message with a return code\n   to abort the sending of the\
    \ message if the attributes are not\n   acceptable.\n  MessageStatus ( NSLP-Message-Handle,\
    \ Transfer-Attributes, Error-Type )\n   NSLP-Message-Handle:  A handle for the\
    \ message provided by the\n      signalling application in SendMessage.\n   Transfer-Attributes:\
    \  The reliability and security attributes that\n      will be used to transmit\
    \ this particular message.\n   Error-Type:  Indicates the type of error that occurred,\
    \ for example,\n      'no next node found'.\n"
- title: B.4.  NetworkNotification
  contents:
  - "B.4.  NetworkNotification\n   This primitive is passed from GIST to a signalling\
    \ application.  It\n   indicates that a network event of possible interest to\
    \ the signalling\n   application occurred.\n   NetworkNotification ( NSLPID, MRI,\
    \ Network-Notification-Type )\n   NSLPID:  An identifier indicating which NSLP\
    \ this is message is for.\n   MRI:  Provides the message routing information to\
    \ which the network\n      notification applies.\n   Network-Notification-Type:\
    \  Indicates the type of event that caused\n      the notification and associated\
    \ additional data.  Five events have\n      been identified:\n      Last Node:\
    \  GIST has detected that this is the last NSLP-aware\n         node in the path.\
    \  See Section 4.3.4.\n      Routing Status Change:  GIST has installed new routing\
    \ state, has\n         detected that existing routing state may no longer be valid,\
    \ or\n         has re-established existing routing state.  See Section 7.1.3.\n\
    \         The new status is reported; if the status is Good, the SII-\n      \
    \   Handle of the peer is also reported, as for RecvMessage.\n      Route Deletion:\
    \  GIST has determined that an old route is now\n         definitely invalid,\
    \ e.g., that flows are definitely not using\n         it (see Section 7.1.4).\
    \  The SII-Handle of the peer is also\n         reported.\n      Node Authorisation\
    \ Change:  The authorisation status of a peer has\n         changed, meaning that\
    \ routing state is no longer valid or that\n         a signalling peer is no longer\
    \ reachable; see Section 4.4.2.\n      Communication Failure:  Communication with\
    \ the peer has failed;\n         messages may have been lost.\n"
- title: B.5.  SetStateLifetime
  contents:
  - "B.5.  SetStateLifetime\n   This primitive is passed from a signalling application\
    \ to GIST.  It\n   indicates the duration for which the signalling application\
    \ would\n   like GIST to retain its routing state.  It can also give a hint that\n\
    \   the signalling application is no longer interested in the state.\n   SetStateLifetime\
    \ ( NSLPID, MRI, SID, State-Lifetime )\n   NSLPID:  Provides the NSLPID to which\
    \ the routing state lifetime\n      applies.\n   MRI:  Provides the message routing\
    \ information to which the routing\n      state lifetime applies; includes the\
    \ direction (in the D-flag).\n   SID:  The session ID that the signalling application\
    \ will be using\n      with this routing state.  Can be wildcarded.\n   State-Lifetime:\
    \  Indicates the lifetime for which the signalling\n      application wishes GIST\
    \ to retain its routing state (may be zero,\n      indicating that the signalling\
    \ application has no further interest\n      in the GIST state).\n"
- title: B.6.  InvalidateRoutingState
  contents:
  - "B.6.  InvalidateRoutingState\n   This primitive is passed from a signalling application\
    \ to GIST.  It\n   indicates that the signalling application has knowledge that\
    \ the next\n   signalling hop known to GIST may no longer be valid, either because\n\
    \   of changes in the network routing or the processing capabilities of\n   signalling\
    \ application nodes.  See Section 7.1.\n   InvalidateRoutingState ( NSLPID, MRI,\
    \ Status, NSLP-Data,\n                            NSLP-Data-Size, Urgent )\n \
    \  NSLPID:  The NSLP originating the message.  May be null (in which\n      case,\
    \ the invalidation applies to all signalling applications).\n   MRI:  The flow\
    \ for which routing state should be invalidated;\n      includes the direction\
    \ of the change (in the D-flag).\n   Status:  The new status that should be assumed\
    \ for the routing state,\n      one of Bad or Tentative (see Section 7.1.3).\n\
    \   NSLP-Data, NSLP-Data-Size:  (optional) A payload provided by the NSLP\n  \
    \    to be used the next GIST handshake.  This can be used as part of a\n    \
    \  conditional peering process (see Section 4.3.2).  The payload will\n      be\
    \ transmitted without security protection.\n   Urgent:  A hint as to whether rediscovery\
    \ should take place\n      immediately or only with the next signalling message.\n"
- title: Appendix C.  Deployment Issues with Router Alert Options
  contents:
  - "Appendix C.  Deployment Issues with Router Alert Options\n   The GIST peer discovery\
    \ handshake (Section 4.4.1) depends on the\n   interception of Q-mode encapsulated\
    \ IP packets (Section 4.3.1 and\n   Section 5.3.2) by routers.  There are two\
    \ fundamental requirements on\n   the process:\n   1.  Packets relevant to GIST\
    \ must be intercepted.\n   2.  Packets not relevant to GIST must be forwarded\
    \ transparently.\n   This specification defines the GIST behaviour to ensure that\
    \ both\n   requirements are met for a GIST-capable node.  However, GIST packets\n\
    \   will also encounter non-GIST nodes, for which requirement (2) still\n   applies.\
    \  If non-GIST nodes block Q-mode packets, GIST will not\n   function.  It is\
    \ always possible for middleboxes to block specific\n   traffic types; by using\
    \ a normal UDP encapsulation for Q-mode\n   traffic, GIST allows NATs at least\
    \ to pass these messages\n   (Section 7.2.1), and firewalls can be configured\
    \ with standard\n   policies.  However, where the Q-mode encapsulation uses a\
    \ Router\n   Alert Option (RAO) at the IP level this can lead to additional\n\
    \   problems.  The situation is different for IPv4 and IPv6.\n   The IPv4 RAO\
    \ is defined by [13], which defines the RAO format with a\n   2-byte value field;\
    \ however, only one value (zero) is defined and\n   there is no IANA registry\
    \ for further allocations.  It states that\n   unknown values should be ignored\
    \ (i.e., the packets forwarded as\n   normal IP traffic); however, it has also\
    \ been reported that some\n   existing implementations simply ignore the RAO value\
    \ completely (i.e.\n   process any packet with an RAO as though the option value\
    \ was zero).\n   Therefore, the use of non-zero RAO values cannot be relied on\
    \ to make\n   GIST traffic transparent to existing implementations.  (Note that\
    \ it\n   may still be valuable to be able to allocate non-zero RAO values for\n\
    \   IPv4: this makes the interception process more efficient for nodes\n   that\
    \ do examine the value field, and makes no difference to nodes\n   that *incorrectly*\
    \ ignore it.  Whether or not non-zero RAO values are\n   used does not change\
    \ the GIST protocol operation, but needs to be\n   decided when new NSLPs are\
    \ registered.)\n   The second stage of the analysis is therefore what happens\
    \ when a\n   non-GIST node that implements RAO handling sees a Q-mode packet.\
    \  The\n   RAO specification simply states \"Routers that recognize this option\n\
    \   shall examine packets carrying it more closely (check the IP Protocol\n  \
    \ field, for example) to determine whether or not further processing is\n   necessary\"\
    .  There are two possible basic behaviours for GIST\n   traffic:\n   1.  The \"\
    closer examination\" of the packet is sufficiently\n       intelligent to realise\
    \ that the node does not need to process it\n       and should forward it.  This\
    \ could either be by virtue of the\n       fact that the node has not been configured\
    \ to match IP-\n       Protocol=UDP for RAO packets at all or that even if UDP\
    \ traffic\n       is intercepted the port numbers do not match anything locally\n\
    \       configured.\n   2.  The \"closer examination\" of the packet identifies\
    \ it as UDP, and\n       delivers it to the UDP stack on the node.  In this case,\
    \ it can\n       no longer be guaranteed to be processed appropriately.  Most\n\
    \       likely, it will simply be dropped or rejected with an ICMP error\n   \
    \    (because there is no GIST process on the destination port to\n       which\
    \ to deliver it).\n   Analysis of open-source operating system source code shows\
    \ the first\n   type of behaviour, and this has also been seen in direct GIST\n\
    \   experiments with commercial routers, including the case when they\n   process\
    \ other uses of the RAO (i.e., RSVP).  However, it has also\n   been reported\
    \ that other RAO implementations will exhibit the second\n   type of behaviour.\
    \  The consequence of this would be that Q-mode\n   packets are blocked in the\
    \ network and GIST could not be used.  Note\n   that although this is caused by\
    \ some subtle details in the RAO\n   processing rules, the end result is the same\
    \ as if the packet was\n   simply blocked for other reasons (for example, many\
    \ IPv4 firewalls\n   drop packets with options by default).\n   The GIST specification\
    \ allows two main options for circumventing\n   nodes that block Q-mode traffic\
    \ in IPv4.  Whether to use these\n   options is a matter of implementation and\
    \ configuration choice.\n   o  A GIST node can be configured to send Q-mode packets\
    \ without the\n      RAO at all.  This should avoid the above problems, but should\
    \ only\n      be done if it is known that nodes on the path to the receiver are\n\
    \      able to intercept such packets.  (See Section 5.3.2.1.)\n   o  If a GIST\
    \ node can identify exactly where the packets are being\n      blocked (e.g.,\
    \ from ICMP messages), or can discover some point on\n      the path beyond the\
    \ blockage (e.g., by use of traceroute or by\n      routing table analysis), it\
    \ can send the Q-mode messages to that\n      point using IP-in-IP tunelling without\
    \ any RAO.  This bypasses the\n      input side processing on the blocking node,\
    \ but picks up normal\n      GIST behaviour beyond it.\n   If in the light of\
    \ deployment experience the problem of blocked\n   Q-mode traffic turns out to\
    \ be widespread and these techniques turn\n   out to be insufficient, a further\
    \ possibility is to define an\n   alternative Q-mode encapsulation that does not\
    \ use UDP.  This would\n   require a specification change.  Such an option would\
    \ be restricted\n   to network-internal use, since operation through NATs and\
    \ firewalls\n   would be much harder with it.\n   The situation with IPv6 is rather\
    \ different, since in that case the\n   use of non-zero RAO values is well established\
    \ in the specification\n   ([17]) and an IANA registry exists.  The main problem\
    \ is that several\n   implementations are still immature: for example, some treat\
    \ any RAO-\n   marked packet as though it was for local processing without further\n\
    \   analysis.  Since this prevents any RAO usage at all (including the\n   existing\
    \ standardised ones) in such a network, it seems reasonable to\n   assume that\
    \ such implementations will be fixed as part of the general\n   deployment of\
    \ IPv6.\n"
- title: Appendix D.  Example Routing State Table and Handshake
  contents:
  - "Appendix D.  Example Routing State Table and Handshake\n   Figure 11 shows a\
    \ signalling scenario for a single flow being managed\n   by two signalling applications\
    \ using the path-coupled message routing\n   method.  The flow sender and receiver\
    \ and one router support both;\n   two other routers support one each.  The figure\
    \ also shows the\n   routing state table at node B.\n       A                \
    \        B          C          D           E\n   +------+                  +-----+\
    \    +-----+    +-----+    +--------+\n   | Flow |    +-+    +-+    |NSLP1|  \
    \  |NSLP1|    |     |    |  Flow  |\n   |Sender|====|R|====|R|====|NSLP2|====|\
    \     |====|NSLP2|====|Receiver|\n   |      |    +-+    +-+    |GIST |    |GIST\
    \ |    |GIST |    |        |\n   +------+                  +-----+    +-----+\
    \    +-----+    +--------+\n             Flow Direction ------------------------------>>\n\
    \   +------------------------------------+---------+--------+-----------+\n  \
    \ |     Message Routing Information    | Session | NSLPID |  Routing  |\n   |\
    \                                    |    ID   |        |   State   |\n   +------------------------------------+---------+--------+-----------+\n\
    \   |    MRM = Path-Coupled; Flow ID =   |  0xABCD |  NSLP1 |    IP-A   |\n  \
    \ |   {IP-A, IP-E, proto/ports}; D=up  |         |        |           |\n   |\
    \                                    |         |        |           |\n   |  \
    \  MRM = Path-Coupled; Flow ID =   |  0xABCD |  NSLP1 |   (null)  |\n   |  {IP-A,\
    \ IP-E, proto/ports}; D=down |         |        |           |\n   |          \
    \                          |         |        |           |\n   |    MRM = Path-Coupled;\
    \ Flow ID =   |  0x1234 |  NSLP2 |    IP-A   |\n   |   {IP-A, IP-E, proto/ports};\
    \ D=up  |         |        |           |\n   |                               \
    \     |         |        |           |\n   |    MRM = Path-Coupled; Flow ID =\
    \   |  0x1234 |  NSLP2 | Points to |\n   |  {IP-A, IP-E, proto/ports}; D=down\
    \ |         |        |   B-D MA  |\n   +------------------------------------+---------+--------+-----------+\n\
    \                     Figure 11: A Signalling Scenario\n   The upstream state\
    \ is just the same address for each application.\n   For the downstream direction,\
    \ NSLP1 only requires D-mode messages and\n   so no explicit routing state towards\
    \ C is needed.  NSLP2 requires a\n   messaging association for its messages towards\
    \ node D, and node C\n   does not process NSLP2 at all, so the peer state for\
    \ NSLP2 is a\n   pointer to a messaging association that runs directly from B\
    \ to D.\n   Note that E is not visible in the state table (except implicitly in\n\
    \   the address in the message routing information); routing state is\n   stored\
    \ only for adjacent peers.  (In addition to the peer\n   identification, IP hop\
    \ counts are stored for each peer where the\n   state itself if not null; this\
    \ is not shown in the table.)\n   Figure 12 shows a GIST handshake setting up\
    \ a messaging association\n   for B-D signalling, with the exchange of Stack Proposals\
    \ and MA-\n   protocol-options in each direction.  The Querying node selects TLS/\n\
    \   TCP as the stack configuration and sets up the messaging association\n   over\
    \ which it sends the Confirm.\n    -------------------------- Query ---------------------------->\n\
    \    IP(Src=IP#A; Dst=IP#E; RAO for NSLP2); UDP(Src=6789; Dst=GIST)\n    D-mode\
    \ magic number (0x4e04 bda5)\n    GIST(Header(Type=Query; NSLPID=NSLP2; C=1; R=1;\
    \ S=0)\n         MRI(MRM=Path-Coupled; Flow=F; Direction=down)\n         SessionID(0x1234)\
    \ NLI(Peer='string1'; IA=IP#B)\n         QueryCookie(0x139471239471923526)\n \
    \        StackProposal(#Proposals=3;1=TLS/TCP; 2=TLS/SCTP; 3=TCP)\n         StackConfigurationData(HoldTime=300;\
    \ #MPO=2;\n           TCP(Applicable: all; Data: null)\n           SCTP(Applicable:\
    \ all; Data: null)))\n    <---------------------- Response ----------------------------\n\
    \    IP(Src=IP#D; Dst=IP#B); UDP(Src=GIST; Dst=6789)\n    D-mode magic number\
    \ (0x4e04 bda5)\n    GIST(Header(Type=Response; NSLPID=NSLP2; C=0; R=1; S=1)\n\
    \         MRI(MRM=Path-Coupled; Flow=F; Direction=up)\n         SessionID(0x1234)\
    \ NLI(Peer='stringr2', IA=IP#D)\n         QueryCookie(0x139471239471923526)\n\
    \         ResponderCookie(0xacdefedcdfaeeeded)\n         StackProposal(#Proposals=3;\
    \ 1=TCP; 2=SCTP; 3=TLS/TCP)\n         StackConfigurationData(HoldTime=200; #MPO=3;\n\
    \           TCP(Applicable: 3; Data: port=6123)\n           TCP(Applicable: 1;\
    \ Data: port=5438)\n           SCTP(Applicable: all; Data: port=3333)))\n    -------------------------TCP\
    \ SYN----------------------->\n    <----------------------TCP SYN/ACK----------------------\n\
    \    -------------------------TCP ACK----------------------->\n    TCP connect(IP\
    \ Src=IP#B; IP Dst=IP#D; Src Port=9166; Dst Port=6123)\n    <-----------------------TLS\
    \ INIT----------------------->\n    ------------------------ Confirm ---------------------------->\n\
    \    [Sent within messaging association]\n    GIST(Header(Type=Confirm; NSLPID=NSLP2;\
    \ C=0; R=0; S=1)\n         MRI(MRM=Path-Coupled; Flow=F; Direction=down)\n   \
    \      SessionID(0x1234) NLI(Peer='string1'; IA=IP#B)\n         ResponderCookie(0xacdefedcdfaeeeded)\n\
    \         StackProposal(#Proposals=3; 1=TCP; 2=SCTP; 3=TLS/TCP)\n         StackConfigurationData(HoldTime=300))\n\
    \                Figure 12: GIST Handshake Message Sequence\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Henning Schulzrinne\n   Columbia University\n   Department\
    \ of Computer Science\n   450 Computer Science Building\n   New York, NY  10027\n\
    \   US\n   Phone: +1 212 939 7042\n   EMail: hgs+nsis@cs.columbia.edu\n   URI:\
    \   http://www.cs.columbia.edu\n   Robert Hancock\n   Roke Manor Research\n  \
    \ Old Salisbury Lane\n   Romsey, Hampshire  SO51 0ZN\n   UK\n   EMail: robert.hancock@roke.co.uk\n\
    \   URI:   http://www.roke.co.uk\n"
