- title: __initial_text__
  contents:
  - '                 Design Choices When Expanding the DNS

    '
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This memo provides information for the Internet community.\
    \  It does\n   not specify an Internet standard of any kind.  Distribution of\
    \ this\n   memo is unlimited.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (c) 2009 IETF Trust and the persons identified\
    \ as the\n   document authors.  All rights reserved.\n   This document is subject\
    \ to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\
    \ in effect on the date of\n   publication of this document (http://trustee.ietf.org/license-info).\n\
    \   Please review these documents carefully, as they describe your rights\n  \
    \ and restrictions with respect to this document.\n"
- title: Abstract
  contents:
  - "Abstract\n   This note discusses how to extend the DNS with new data for a new\n\
    \   application.  DNS extension discussions too often focus on reuse of\n   the\
    \ TXT Resource Record Type.  This document lists different\n   mechanisms to extend\
    \ the DNS, and concludes that the use of a new DNS\n   Resource Record Type is\
    \ the best solution.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1. Introduction ....................................................3\n\
    \   2. Background ......................................................4\n  \
    \ 3. Extension Mechanisms ............................................5\n    \
    \  3.1. Place Selectors inside the RDATA of Existing\n           Resource Record\
    \ Types ......................................5\n      3.2. Add a Prefix to the\
    \ Owner Name .............................6\n      3.3. Add a Suffix to the Owner\
    \ Name .............................7\n      3.4. Add a New Class ............................................8\n\
    \      3.5. Add a New Resource Record Type .............................8\n  \
    \ 4. Zone Boundaries are Invisible to Applications ...................9\n   5.\
    \ Why Adding a New Resource Record Type Is the Preferred\n      Solution .......................................................10\n\
    \   6. Conclusion and Recommendation ..................................14\n  \
    \ 7. Creating a New Resource Record Type ............................14\n   8.\
    \ Security Considerations ........................................15\n   9. Acknowledgements\
    \ ...............................................15\n   10. IAB Members at the\
    \ Time of This Writing .......................16\n   11. References ....................................................16\n\
    \      11.1. Normative References .....................................16\n  \
    \    11.2. Informative References ...................................16\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   The DNS stores multiple categories of data.  The two most\
    \ commonly\n   used categories are infrastructure data for the DNS system itself\
    \ (NS\n   and SOA Resource Records) and data that have to do with mappings\n \
    \  between domain names and IP addresses (A, AAAA, and PTR Resource\n   Records).\
    \  There are other categories as well, some of which are tied\n   to specific\
    \ applications like email (MX Resource Records), while\n   others are generic\
    \ Resource Record Types used to convey information\n   for multiple protocols\
    \ (SRV and NAPTR Resource Records).\n   When storing data in the DNS for a new\
    \ application, the goal must be\n   to store data in such a way that the application\
    \ can query for the\n   data it wants, while minimizing both the impact on existing\n\
    \   applications and the amount of extra data transferred to the client.\n   This\
    \ implies that a number of design choices have to be made, where\n   the most\
    \ important is to ensure that a precise selection of what data\n   to return must\
    \ be made already in the query.  A query consists of a\n   triple: {Owner (or\
    \ name), Resource Record Class, Resource Record\n   Type}.\n   Historically, extending\
    \ the DNS to store application data tied to a\n   domain name has been done in\
    \ different ways at different times.  MX\n   Resource Records were created as\
    \ a new Resource Record Type\n   specifically designed to support electronic mail.\
    \  SRV records are a\n   generic type that use a prefixing scheme in combination\
    \ with a base\n   domain name.  NAPTR records add selection data inside the RDATA.\
    \  It\n   is clear that the methods used to add new data types to the DNS have\n\
    \   been inconsistent, and the purpose of this document is to attempt to\n   clarify\
    \ the implications of each of these methods, both for the\n   applications that\
    \ use them and for the rest of the DNS.\n   This document talks extensively about\
    \ use of DNS wildcards.  Many\n   people might think use of wildcards is not something\
    \ that happens\n   today.  In reality though, wildcards are in use, especially\
    \ for\n   certain application-specific data such as MX Resource Records.\n   Because\
    \ of this, the choice has to be made with the existence of\n   wildcards in mind.\n\
    \   Another overall issue that must be taken into account is what the new\n  \
    \ data in the DNS are to describe.  In some cases, they might be\n   completely\
    \ new data.  In other cases, they might be metadata tied to\n   data that already\
    \ exist in the DNS.  Examples of new data are key\n   information for the Secure\
    \ SHell (SSH) Protocol and data used for\n   authenticating the sender of email\
    \ messages (metadata tied to MX\n   Resource Records).  If the new data are tied\
    \ to data that already\n   exist in the DNS, an analysis should be made as to\
    \ whether having\n   (for example) address records and SSH key information in\
    \ different\n   DNS zones is a problem or if it is a bonus, and if it is a problem,\n\
    \   whether the specification must require all of the related data to be\n   in\
    \ the same zone.  One specific difference between having the records\n   in the\
    \ same zone or not has to do with maintenance of the records.\n   If they are\
    \ in the same zone, the same maintainer (from a DNS\n   perspective) manages the\
    \ two records.  Specifically, they must be\n   signed with the same DNSSEC keys\
    \ if DNSSEC is in use.\n   This document does not talk about what one should store\
    \ in the DNS.\n   It also doesn't discuss whether the DNS should be used for service\n\
    \   discovery, or whether the DNS should be used for storage of data\n   specific\
    \ to the service.  In general, the DNS is a protocol that,\n   apart from holding\
    \ metadata that makes the DNS itself function (NS,\n   SOA, DNSSEC Resource Record\
    \ Types, etc.), only holds references to\n   service locations (SRV, NAPTR, A,\
    \ AAAA Resource Record Types) --\n   though there are exceptions, such as MX Resource\
    \ Records.\n"
- title: 2.  Background
  contents:
  - "2.  Background\n   See RFC 5395 [RFC5395] for a brief summary of the DNS query\n\
    \   structure.  Readers interested in the full story should start with\n   the\
    \ base DNS specification in RFC 1035 [RFC1035] and continue with\n   the various\
    \ documents that update, clarify, and extend the base\n   specification.\n   When\
    \ composing a DNS query, the parameters used by the protocol are a\n   {owner,\
    \ class, type} triple.  Every Resource Record matching such a\n   triple is said\
    \ to belong to the same Resource Record Set (RRSet), and\n   the whole RRSet is\
    \ always returned to the client that queries for it.\n   Splitting an RRSet is\
    \ a protocol violation (sending a partial RRSet,\n   not truncating the DNS response),\
    \ because it can result in coherency\n   problems with the DNS caching mechanism.\
    \  See Section 5 of [RFC2181]\n   for more information.\n   Some discussions around\
    \ extensions to the DNS include arguments\n   around MTU size.  Note that most\
    \ discussions about DNS and MTU size\n   are about the size of the whole DNS packet,\
    \ not about the size of a\n   single RRSet.\n   Almost all DNS query traffic is\
    \ carried over UDP, where a DNS message\n   must fit within a single UDP packet.\
    \  DNS response messages are\n   almost always larger than DNS query messages,\
    \ so message size issues\n   are almost always about responses, not queries. \
    \ The base DNS\n   specification limits DNS messages over UDP to 512 octets; EDNS0\n\
    \   [RFC2671] specifies a mechanism by which a client can signal its\n   willingness\
    \ to receive larger responses, but deployment of EDNS0 is\n   not universal, in\
    \ part because of firewalls that block fragmented UDP\n   packets or EDNS0.  If\
    \ a response message won't fit in a single\n   packet, the name server returns\
    \ a truncated response, at which point\n   the client may retry using TCP.  DNS\
    \ queries over TCP are not subject\n   to this length limitation, but TCP imposes\
    \ significantly higher per-\n   query overhead on name servers than UDP.  It is\
    \ also the case that\n   the policies in deployed firewalls far too often are\
    \ such that they\n   block DNS over TCP, so using TCP might not in reality be\
    \ an option.\n   There are also risks (although possibly small) that a change\
    \ of\n   routing while a TCP flow is open creates problems when the DNS\n   servers\
    \ are deployed in an anycast environment.\n"
- title: 3.  Extension Mechanisms
  contents:
  - "3.  Extension Mechanisms\n   The DNS protocol is intended to be extensible to\
    \ support new kinds of\n   data.  This section examines the various ways in which\
    \ this sort of\n   extension can be accomplished.\n"
- title: 3.1.  Place Selectors inside the RDATA of Existing Resource Record Types
  contents:
  - "3.1.  Place Selectors inside the RDATA of Existing Resource Record Types\n  \
    \ For a given query name, one might choose to have a single RRSet (all\n   Resource\
    \ Records sharing the same {owner, class, type} triple) shared\n   by multiple\
    \ applications, and have the different applications use\n   selectors within the\
    \ Resource Record data (RDATA) to determine which\n   records are intended for\
    \ which applications.  This sort of selector\n   mechanism is usually referred\
    \ to \"subtyping\", because it is in effect\n   creating an additional type subsystem\
    \ within a single DNS Resource\n   Record Type.\n   Examples of subtyping include\
    \ NAPTR Resource Records [RFC3761] and\n   the original DNSSEC KEY Resource Record\
    \ Type [RFC2535] (which was\n   later updated by RFC 3445 [RFC3445], and obsoleted\
    \ by RFC 4033\n   [RFC4033], RFC 4034 [RFC4034] and RFC 4035 [RFC4035]).\n   All\
    \ DNS subtyping schemes share a common weakness: with subtyping\n   schemes, it\
    \ is impossible for a client to query for just the data it\n   wants.  Instead,\
    \ the client must fetch the entire RRSet, then select\n   the Resource Records\
    \ in which it is interested.  Furthermore, since\n   DNSSEC signatures operate\
    \ on complete RRSets, the entire RRSet must\n   be re-signed if any Resource Record\
    \ in it changes.  As a result, each\n   application that uses a subtyped Resource\
    \ Record incurs higher\n   overhead than any of the applications would have incurred\
    \ had they\n   not been using a subtyping scheme.  The fact the RRSet is always\n\
    \   passed around as an indivisible unit increases the risk the RRSet\n   will\
    \ not fit in a UDP packet, which in turn increases the risk that\n   the client\
    \ will have to retry the query with TCP, which substantially\n   increases the\
    \ load on the name server.  More precisely: having one\n   query fail over to\
    \ TCP is not a big deal, but since the typical ratio\n   of clients to servers\
    \ in today's deployed DNS is very high, having a\n   substantial number of DNS\
    \ messages fail over to TCP may cause the\n   queried name servers to be overloaded\
    \ by TCP overhead.\n   Because of the size limitations, using a subtyping scheme\
    \ to list a\n   large number of services for a single domain name risks triggering\n\
    \   truncation and fallback to TCP, which may in turn force the zone\n   administrator\
    \ to announce only a subset of available services.\n"
- title: 3.2.  Add a Prefix to the Owner Name
  contents:
  - "3.2.  Add a Prefix to the Owner Name\n   By adding an application-specific prefix\
    \ to a domain name, we get a\n   different {owner, class, type} triple, and therefore\
    \ a different\n   RRSet.  One problem with adding prefixes has to do with wildcards,\n\
    \   especially if one has records like:\n   *.example.com. IN MX 1 mail.example.com.\n\
    \   and one wants records tied to those names.  Suppose one creates the\n   prefix\
    \ \"_mail\".  One would then have to say something like:\n   _mail.*.example.com.\
    \ IN X-FOO A B C D\n   but DNS wildcards only work with the \"*\" as the leftmost\
    \ token in the\n   domain name (see also RFC 4592 [RFC4592]).\n   There have been\
    \ proposals to deal with the problem that DNS wildcards\n   are always terminal\
    \ records.  These proposals introduce an additional\n   set of trade-offs that\
    \ would need to be taken into account when\n   assessing which extension mechanism\
    \ to choose.  Aspects of extra\n   response time needed to perform the extra queries,\
    \ costs of pre-\n   calculation of possible answers, or the costs induced to the\
    \ system\n   as a whole come to mind.  At the time of writing, none of these\n\
    \   proposals has been published as Standards Track RFCs.\n   Even when a specific\
    \ prefix is chosen, the data will still have to be\n   stored in some Resource\
    \ Record Type.  This Resource Record Type can\n   be either a new Resource Record\
    \ Type or an existing Resource Record\n   Type that has an appropriate format\
    \ to store the data.  One also\n   might need some other selection mechanism,\
    \ such as the ability to\n   distinguish between the records in an RRSet, given\
    \ they have the same\n   Resource Record Type.  Because of this, one needs to\
    \ both register a\n   unique prefix and define what Resource Record Type is to\
    \ be used for\n   this specific service.\n   If the record has some relationship\
    \ with another record in the zone,\n   the fact that the two records can be in\
    \ different zones might have\n   implications on the trust the application has\
    \ in the records.  For\n   example:\n   example.com.      IN MX    10 mail.example.com.\n\
    \   _foo.example.com. IN X-BAR \"metadata for the mail service\"\n   In this example,\
    \ the two records might be in two different zones, and\n   as a result might be\
    \ administered by two different organizations, and\n   signed by two different\
    \ entities when using DNSSEC.  For these two\n   reasons, using a prefix has recently\
    \ become a very interesting\n   solution for many protocol designers.  In some\
    \ cases, e.g.,\n   DomainKeys Identified Mail Signatures [RFC4871], TXT records\
    \ have\n   been used.  In others, such as SRV, entirely new Resource Record\n\
    \   Types have been added.\n"
- title: 3.3.  Add a Suffix to the Owner Name
  contents:
  - "3.3.  Add a Suffix to the Owner Name\n   Adding a suffix to a domain name changes\
    \ the {owner, class, type}\n   triple, and therefore the RRSet.  In this case,\
    \ since the query name\n   can be set to exactly the data one wants, the size\
    \ of the RRSet is\n   minimized.  The problem with adding a suffix is that it\
    \ creates a\n   parallel tree within the IN class.  Further, there is no technical\n\
    \   mechanism to ensure that the delegation for \"example.com\" and\n   \"example.com._bar\"\
    \ are made to the same organization.  Furthermore,\n   data associated with a\
    \ single entity will now be stored in two\n   different zones, such as \"example.com\"\
    \ and \"example.com._bar\", which,\n   depending on who controls \"_bar\", can\
    \ create new synchronization and\n   update authorization issues.\n   One way\
    \ of solving the administrative issues is by using the DNAME\n   Resource Record\
    \ Type specified in RFC 2672 [RFC2672].\n   Even when using a different name,\
    \ the data will still have to be\n   stored in some Resource Record Type that\
    \ has an appropriate format to\n   store the data.  This implies that one might\
    \ have to mix the prefix\n   based selection mechanism with some other mechanism\
    \ so that the right\n   Resource Record can be found out of many in a potential\
    \ larger RRSet.\n   In RFC 2163 [RFC2163] an infix token is inserted directly\
    \ below the\n   Top-Level Domain (TLD), but the result is equivalent to adding\
    \ a\n   suffix to the owner name (instead of creating a TLD, one is creating\n\
    \   a second level domain).\n"
- title: 3.4.  Add a New Class
  contents:
  - "3.4.  Add a New Class\n   DNS zones are class-specific in the sense that all\
    \ the records in\n   that zone share the same class as the zone's SOA record and\
    \ the\n   existence of a zone in one class does not guarantee the existence of\n\
    \   the zone in any other class.  In practice, only the IN class has ever\n  \
    \ seen widespread deployment, and the administrative overhead of\n   deploying\
    \ an additional class would almost certainly be prohibitive.\n   Nevertheless,\
    \ one could, in theory, use the DNS class mechanism to\n   distinguish between\
    \ different kinds of data.  However, since the DNS\n   delegation tree (represented\
    \ by NS Resource Records) is itself tied\n   to a specific class, attempting to\
    \ resolve a query by crossing a\n   class boundary may produce unexpected results\
    \ because there is no\n   guarantee that the name servers for the zone in the\
    \ new class will be\n   the same as the name servers in the IN class.  The MIT\
    \ Hesiod system\n   [Dyer87] used a scheme like this for storing data in the HS\
    \ class,\n   but only on a very small scale (within a single institution), and\n\
    \   with an administrative fiat requiring that the delegation trees for\n   the\
    \ IN and HS trees be identical.  The use of the HS class for such\n   storage\
    \ of non-sensitive data was, over time, replaced by use of the\n   Lightweight\
    \ Directory Access Protocol (LDAP) [RFC4511].\n   Even when using a different\
    \ class, the data will still have to be\n   stored in some Resource Record Type\
    \ that has an appropriate format.\n"
- title: 3.5.  Add a New Resource Record Type
  contents:
  - "3.5.  Add a New Resource Record Type\n   When adding a new Resource Record Type\
    \ to the system, entities in\n   four different roles have to be able to handle\
    \ the new Type:\n   1.  There must be a way to insert the new Resource Records\
    \ into the\n       zone at the Primary Master name server.  For some server\n\
    \       implementations, the user interface only accepts Resource Record\n   \
    \    Types that it understands (perhaps so that the implementation can\n     \
    \  attempt to validate the data).  Other implementations allow the\n       zone\
    \ administrator to enter an integer for the Resource Record\n       Type code\
    \ and the RDATA in Base64 or hexadecimal encoding (or\n       even as raw data).\
    \  RFC 3597 [RFC3597] specifies a standard\n       generic encoding for this purpose.\n\
    \   2.  A slave authoritative name server must be able to do a zone\n       transfer,\
    \ receive the data from some other authoritative name\n       server, and serve\
    \ data from the zone even though the zone\n       includes records of unknown\
    \ Resource Record Types.  Historically,\n       some implementations have had\
    \ problems parsing stored copies of\n       the zone file after restarting, but\
    \ those problems have not been\n       seen for a few years.  Some implementations\
    \ use an alternate\n       mechanism (e.g., LDAP) to transfer Resource Records\
    \ in a zone,\n       and are primarily used within corporate environments; in\
    \ this\n       case, name servers must be able to transfer new Resource Record\n\
    \       Types using whatever mechanism is used.  However, today this\n       alternative\
    \ mechanism may not support unknown Resource Record\n       Types.  Hence, in\
    \ Internet environments, unknown Resource Record\n       Types are supported,\
    \ but in corporate environments they are\n       problematic.\n   3.  A caching\
    \ resolver (most commonly a recursive name server) will\n       cache the records\
    \ that are responses to queries.  As mentioned in\n       RFC 3597 [RFC3597],\
    \ there are various pitfalls where a recursive\n       name server might end up\
    \ having problems.\n   4.  The application must be able to get the RRSet with\
    \ a new Resource\n       Record Type.  The application itself may understand the\
    \ RDATA,\n       but the resolver library might not.  Support for a generic\n\
    \       interface for retrieving arbitrary DNS Resource Record Types has\n   \
    \    been a requirement since 1989 (see Section 6.1.4.2 of [RFC1123]).\n     \
    \  Some stub resolver library implementations neglect to provide\n       this\
    \ functionality and cannot handle unknown Resource Record\n       Types, but implementation\
    \ of a new stub resolver library is not\n       particularly difficult, and open\
    \ source libraries that already\n       provide this functionality are available.\n\
    \   Historically, adding a new Resource Record Type has been very\n   problematic.\
    \  The review process has been cumbersome, DNS servers\n   have not been able\
    \ to handle new Resource Record Types, and firewalls\n   have dropped queries\
    \ or responses with Resource Record Types that are\n   unknown to the firewall.\
    \  This is, for example, one of the reasons\n   the ENUM standard reuses the NAPTR\
    \ Resource Record, a decision that\n   today might have gone to creating a new\
    \ Resource Record Type instead.\n   Today, there is a requirement that DNS software\
    \ handle unknown\n   Resource Record Types, and investigations have shown that\
    \ software\n   that is deployed, in general, does support it, except in some\n\
    \   alternate mechanisms for transferring Resource Records such as LDAP,\n   as\
    \ noted above.  Also, the approval process for new Resource Record\n   Types has\
    \ been updated [RFC5395] so the effort that is needed for\n   various Resource\
    \ Record Types is more predictable.\n"
- title: 4.  Zone Boundaries are Invisible to Applications
  contents:
  - "4.  Zone Boundaries are Invisible to Applications\n   Regardless of the possible\
    \ choices above, we have seen a number of\n   cases where the application made\
    \ assumptions about the structure of\n   the namespace and the location where\
    \ specific information resides.\n   We take a small sidestep to argue against\
    \ such approaches.\n   The DNS namespace is a hierarchy, technically speaking.\
    \  However,\n   this only refers to the way names are built from multiple labels.\n\
    \   DNS hierarchy neither follows nor implies administrative hierarchy.\n   Because\
    \ of that, it cannot be assumed that data attached to a node in\n   the DNS tree\
    \ is valid for the whole subtree.  Technically, there are\n   zone boundaries\
    \ partitioning the namespace, and administrative\n   boundaries (or policy boundaries)\
    \ may even exist elsewhere.\n   The false assumption has lead to an approach called\
    \ \"tree climbing\",\n   where a query that does not receive a positive response\
    \ (either the\n   requested RRSet was missing or the name did not exist) is retried\
    \ by\n   repeatedly stripping off the leftmost label (climbing towards the\n \
    \  root) until the root domain is reached.  Sometimes these proposals\n   try\
    \ to avoid the query for the root or the TLD level, but still this\n   approach\
    \ has severe drawbacks:\n   o  Technically, the DNS was built as a query-response\
    \ tool without\n      any search capability [RFC3467].  Adding the search mechanism\n\
    \      imposes additional burden on the technical infrastructure, in the\n   \
    \   worst case on TLD and root name servers.\n   o  For reasons similar to those\
    \ outlined in RFC 1535 [RFC1535],\n      querying for information in a domain\
    \ outside the control of the\n      intended entity may lead to incorrect results\
    \ and may also put\n      security at risk.  Finding the exact policy boundary\
    \ is impossible\n      without an explicit marker, which does not exist at present.\
    \  At\n      best, software can detect zone boundaries (e.g., by looking for\n\
    \      SOA Resource Records), but some TLD registries register names\n      starting\
    \ at the second level (e.g., CO.UK), and there are various\n      other \"registry\"\
    \ types at second, third, or other level domains\n      that cannot be identified\
    \ as such without policy knowledge\n      external to the DNS.\n   To restate,\
    \ the zone boundary is purely a boundary that exists in the\n   DNS for administrative\
    \ purposes, and applications should be careful\n   not to draw unwarranted conclusions\
    \ from zone boundaries.  A\n   different way of stating this is that the DNS does\
    \ not support\n   inheritance, e.g., an MX RRSet for a TLD will not be valid for\
    \ any\n   subdomain of that particular TLD.\n"
- title: 5.  Why Adding a New Resource Record Type Is the Preferred Solution
  contents:
  - "5.  Why Adding a New Resource Record Type Is the Preferred Solution\n   By now,\
    \ the astute reader might be wondering what conclusions to draw\n   from the issues\
    \ presented so far.  We will now attempt to clear up\n   the reader's confusion\
    \ by following the thought processes of a\n   typical application designer who\
    \ wishes to store data in the DNS.\n   We'll show how such a designer almost inevitably\
    \ hits upon the idea\n   of just using a TXT Resource Record, why this is a bad\
    \ thing, and why\n   a new Resource Record Type should be allocated instead. \
    \ We'll also\n   explain how the reuse of an existing Resource Record, including\
    \ TXT,\n   can be made less harmful.\n   The overall problem with most solutions\
    \ has to do with two main\n   issues:\n   o  No semantics to prevent collision\
    \ with other use\n   o  Space considerations in the DNS message\n   A typical\
    \ application designer is not interested in the DNS for its\n   own sake, but\
    \ rather regards it as a distributed database in which\n   application data can\
    \ be stored.  As a result, the designer of a new\n   application is usually looking\
    \ for the easiest way to add whatever\n   new data the application needs to the\
    \ DNS in a way that naturally\n   associates the data with a DNS name and does\
    \ not require major\n   changes to DNS servers.\n   As explained in Section 3.4,\
    \ using the DNS class system as an\n   extension mechanism is not really an option,\
    \ and in fact, most users\n   of the system don't even realize that the mechanism\
    \ exists.  As a\n   practical matter, therefore any extension is likely to be\
    \ within the\n   IN class.\n   Adding a new Resource Record Type is the technically\
    \ correct answer\n   from the DNS protocol standpoint (more on this below), but\
    \ doing so\n   requires some DNS expertise, due to the issues listed in Section\
    \ 3.5.\n   Consequently, this option is often rejected.  Note that according to\n\
    \   RFC 5395 [RFC5395], some Types require IETF Consensus, while others\n   only\
    \ require a specification.\n   There is a drawback to defining new RR types that\
    \ is worth\n   mentioning.  The Resource Record Type (RRTYPE) is a 16-bit value\
    \ and\n   hence is a limited resource.  In order to prevent hoarding the\n   registry\
    \ has a review-based allocation policy [RFC5395]; however,\n   this may not be\
    \ sufficient if extension of the DNS by addition of new\n   RR types takes up\
    \ significantly and the registry starts nearing\n   completion.  In that case,\
    \ the trade-offs with respect to choosing an\n   extension mechanism may need\
    \ to change.\n   The application designer is thus left with the prospect of reusing\n\
    \   some existing DNS Types within the IN class, but when the designer\n   looks\
    \ at the existing Types, almost all of them have well-defined\n   semantics, none\
    \ of which quite match the needs of the new\n   application.  This has not completely\
    \ prevented proposals from\n   reusing existing Resource Record Types in ways\
    \ incompatible with\n   their defined semantics, but it does tend to steer application\n\
    \   designers away from this approach.\n   For example, Resource Record Type 40\
    \ was registered for the SINK\n   Resource Record Type.  This Resource Record\
    \ Type was discussed in the\n   DNSIND working group of the IETF, and it was decided\
    \ at the 46th IETF\n   to not move the I-D forward to become an RFC because of\
    \ the risk of\n   encouraging application designers to use the SINK Resource Record\n\
    \   Type instead of registering a new Resource Record Type, which would\n   result\
    \ in infeasibly large SINK RRsets.\n   Eliminating all of the above leaves the\
    \ TXT Resource Record Type in\n   the IN class.  The TXT RDATA format is free\
    \ form text, and there are\n   no existing semantics to get in the way.  Some\
    \ attempts have been\n   made, for example, in [DNSEXT-DNS-SD], to specify a structured\
    \ format\n   for TXT Resource Record Types, but no such attempt has reached RFC\n\
    \   status.  Furthermore, the TXT Resource Record can obviously just be\n   used\
    \ as a bucket in which to carry around data to be used by some\n   higher-level\
    \ parser, perhaps in some human-readable programming or\n   markup language. \
    \ Thus, for many applications, TXT Resource Records\n   are the \"obvious\" choice.\
    \  Unfortunately, this conclusion, while\n   understandable, is also problematic,\
    \ for several reasons.\n   The first reason why TXT Resource Records are not well\
    \ suited to such\n   use is precisely what makes them so attractive: the lack\
    \ of pre-\n   defined common syntax or structure.  As a result, each application\n\
    \   that uses them creates its own syntax/structure, and that makes it\n   difficult\
    \ to reliably distinguish one application's record from\n   others, and for its\
    \ parser to avoid problems when it encounters other\n   TXT records.\n   Arguably,\
    \ the TXT Resource Record is misnamed, and should have been\n   called the Local\
    \ Container record, because a TXT Resource Record\n   means only what the data\
    \ producer says it means.  This is fine, so\n   long as TXT Resource Records are\
    \ being used by human beings or by\n   private agreement between data producer\
    \ and data consumer.  However,\n   it becomes a problem once one starts using\
    \ them for standardized\n   protocols in which there is no prior relationship\
    \ between data\n   producer and data consumer.  If TXT records are used without\
    \ one of\n   the naming modifications discussed earlier (and in some cases even\
    \ if\n   one uses such naming mechanisms), there is nothing to prevent\n   collisions\
    \ with some other incompatible use of TXT Resource Records.\n   This is even worse\
    \ than the general subtyping problem described in\n   Section 3.1 because TXT\
    \ Resource Records don't even have a\n   standardized selector field in which\
    \ to store the subtype.  RFC 1464\n   [RFC1464] tried, but it was not a success.\
    \  At best, a definition of\n   a subtype is reduced to hoping that whatever scheme\
    \ one has come up\n   with will not accidently conflict with somebody else's subtyping\n\
    \   scheme, and that it will not be possible to mis-parse one\n   application's\
    \ use of TXT Resource Records as data intended for a\n   different application.\
    \  Any attempt to impose a standardized format\n   within the TXT Resource Record\
    \ format would be at least fifteen years\n   too late, even if it were put into\
    \ effect immediately; at best, one\n   can restrict the syntax that a particular\
    \ application uses within a\n   TXT Resource Record and accept the risk that unrelated\
    \ TXT Resource\n   Record uses will collide with it.\n   Using one of the naming\
    \ modifications discussed in Section 3.2 and\n   Section 3.3 would address the\
    \ subtyping problem, (and have been used\n   in combinations with reuse of TXT\
    \ record, such as for the dns/txt\n   lookup mechanism in Domain Keys Identified\
    \ Mail (DKIM)) but each of\n   these approaches brings in new problems of its\
    \ own.  The prefix\n   approach (that for example SRV Resource Records use) does\
    \ not work\n   well with wildcards, which is a particular problem for mail-related\n\
    \   applications, since MX Resource Records are probably the most common\n   use\
    \ of DNS wildcards.  The suffix approach doesn't have wildcard\n   issues, but,\
    \ as noted previously, it does have synchronization and\n   update authorization\
    \ issues, since it works by creating a second\n   subtree in a different part\
    \ of the global DNS namespace.\n   The next reason why TXT Resource Records are\
    \ not well suited to\n   protocol use has to do with the limited data space available\
    \ in a DNS\n   message.  As alluded to briefly in Section 3.1, typical DNS query\n\
    \   traffic patterns involve a very large number of DNS clients sending\n   queries\
    \ to a relatively small number of DNS servers.  Normal path MTU\n   discovery\
    \ schemes do little good here because, from the server's\n   perspective, there\
    \ isn't enough repeat traffic from any one client\n   for it to be worth retaining\
    \ state.  UDP-based DNS is an idempotent\n   query, whereas TCP-based DNS requires\
    \ the server to keep state (in\n   the form of TCP connection state, usually in\
    \ the server's kernel) and\n   roughly triples the traffic load.  Thus, there's\
    \ a strong incentive\n   to keep DNS messages short enough to fit in a UDP datagram,\n\
    \   preferably a UDP datagram short enough not to require IP\n   fragmentation.\n\
    \   Subtyping schemes are therefore again problematic because they\n   produce\
    \ larger Resource RRSets than necessary, but verbose text\n   encodings of data\
    \ are also wasteful since the data they hold can\n   usually be represented more\
    \ compactly in a Resource Record designed\n   specifically to support the application's\
    \ particular data needs.  If\n   the data that need to be carried are so large\
    \ that there is no way to\n   make them fit comfortably into the DNS regardless\
    \ of encoding, it is\n   probably better to move the data somewhere else, and\
    \ just use the DNS\n   as a pointer to the data, as with NAPTR.\n"
- title: 6.  Conclusion and Recommendation
  contents:
  - "6.  Conclusion and Recommendation\n   Given the problems detailed in Section\
    \ 5, it is worth reexamining the\n   oft-jumped-to conclusion that specifying\
    \ a new Resource Record Type\n   is hard.  Historically, this was indeed the case,\
    \ but recent surveys\n   suggest that support for unknown Resource Record Types\
    \ [RFC3597] is\n   now widespread in the public Internet, and because of that,\
    \ the DNS\n   infrastructure can handle new Resource Record Types.  The lack of\n\
    \   support for unknown Types remains an issue for relatively old\n   provisioning\
    \ software and in corporate environments.\n   Of all the issues detailed in Section\
    \ 3.5, provisioning the data is\n   in some respects the most difficult.  Investigations\
    \ with zone\n   transfers show that the problem is less difficult for the\n  \
    \ authoritative name servers themselves than the front-end systems used\n   to\
    \ enter (and perhaps validate) the data.  Hand editing does not work\n   well\
    \ for maintenance of large zones, so some sort of tool is\n   necessary, and the\
    \ tool may not be tightly coupled to the name server\n   implementation itself.\
    \  Note, however, that this provisioning problem\n   exists to some degree with\
    \ any new form of data to be stored in the\n   DNS, regardless of data format,\
    \ Resource Record type (even if TXT\n   Resource Record Types are in use), or\
    \ naming scheme.  Adapting front-\n   end systems to support a new Resource Record\
    \ Type may be a bit more\n   difficult than reusing an existing type, but this\
    \ appears to be a\n   minor difference in degree rather than a difference in kind.\n\
    \   Given the various issues described in this note, we believe that:\n   o  there\
    \ is no magic solution that allows a completely painless\n      addition of new\
    \ data to the DNS, but\n   o  on the whole, the best solution is still to use\
    \ the DNS Resource\n      Record Type mechanism designed for precisely this purpose,\n\
    \      whenever possible, and\n   o  of all the alternate solutions, the \"obvious\"\
    \ approach of using\n      TXT Resource Records for arbitrary names is almost\
    \ certainly the\n      worst, especially for the two reasons outlined above (lack\
    \ of\n      semantics and its implementations, and size leading to the need to\n\
    \      use TCP).\n"
- title: 7.  Creating a New Resource Record Type
  contents:
  - "7.  Creating a New Resource Record Type\n   The process for creating a new Resource\
    \ Record Type is specified in\n   RFC 5395 [RFC5395].\n"
- title: 8.  Security Considerations
  contents:
  - "8.  Security Considerations\n   DNS RRSets can be signed using DNSSEC.  DNSSEC\
    \ is almost certainly\n   necessary for any application mechanism that stores\
    \ authorization\n   data in the DNS.  DNSSEC signatures significantly increase\
    \ the size\n   of the messages transported, and because of this, the DNS message\n\
    \   size issues discussed in Sections 3.1 and 5 are more serious than\n   they\
    \ might at first appear.\n   Adding new Resource Record Types (as discussed in\
    \ Section 3.5) can\n   create two different kinds of problems: in the DNS software\
    \ and in\n   applications.  In the DNS software, it might conceivably trigger\
    \ bugs\n   and other bad behavior in software that is not compliant with RFC\n\
    \   3597 [RFC3597], but most such DNS software is old enough and insecure\n  \
    \ enough that it should be updated for other reasons in any case.  In\n   applications\
    \ and provisioning software, the changes for the new\n   features that need the\
    \ new data in the DNS can be updated to\n   understand the structure of the new\
    \ data format (regardless of\n   whether a new Resource Record Type is used or\
    \ some other mechanism is\n   chosen).  Basic API support for retrieving arbitrary\
    \ Resource Record\n   Types has been a requirement since 1989 [RFC1123].\n   Any\
    \ new protocol that proposes to use the DNS to store data used to\n   make authorization\
    \ decisions would be well advised not only to use\n   DNSSEC but also to encourage\
    \ upgrades to DNS server software recent\n   enough not to be riddled with well-known\
    \ exploitable bugs.\n"
- title: 9.  Acknowledgements
  contents:
  - "9.  Acknowledgements\n   This document has been created over a number of years,\
    \ with input\n   from many people.  The question on how to expand and use the\
    \ DNS is\n   sensitive, and a document like this can not please everyone.  The\n\
    \   goal is instead to describe the architecture and tradeoffs, and make\n   some\
    \ recommendations about best practices.\n   People that have helped include: Dean\
    \ Anderson, Mark Andrews, John\n   Angelmo, Roy Badami, Dan Bernstein, Alex Bligh,\
    \ Nathaniel Borenstein,\n   Stephane Bortzmeyer, Brian Carpenter, Leslie Daigle,\
    \ Elwyn Davies,\n   Mark Delany, Richard Draves, Martin Duerst, Donald Eastlake,\
    \ Robert\n   Elz, Jim Fenton, Tony Finch, Jim Gilroy, Olafur Gudmundsson, Eric\n\
    \   Hall, Phillip Hallam-Baker, Ted Hardie, Bob Hinden, Paul Hoffman,\n   Geoff\
    \ Houston, Christian Huitema, Johan Ihren, John Klensin, Ben\n   Laurie, William\
    \ Leibzon, John Levine, Edward Lewis, David MacQuigg,\n   Allison Mankin, Bill\
    \ Manning, David Meyer, Pekka Nikander, Mans\n   Nilsson, Masataka Ohta, Douglas\
    \ Otis, Michael Patton, Jonathan\n   Rosenberg, Anders Rundgren, Miriam Sapiro,\
    \ Carsten Strotmann, Pekka\n   Savola, Chip Sharp, James Snell, Michael Thomas,\
    \ Paul Vixie, Sam\n   Weiler, Florian Weimer, Bert Wijnen, and Dan Wing.\n"
- title: 10.  IAB Members at the Time of This Writing
  contents:
  - "10.  IAB Members at the Time of This Writing\n   Loa Andersson\n   Gonzalo Camarillo\n\
    \   Stuart Cheshire\n   Russ Housley\n   Olaf Kolkman\n   Gregory Lebovitz\n \
    \  Barry Leiba\n   Kurtis Lindqvist\n   Andrew Malis\n   Danny McPherson\n   David\
    \ Oran\n   Dave Thaler\n   Lixia Zhang\n"
- title: 11.  References
  contents:
  - '11.  References

    '
- title: 11.1.  Normative References
  contents:
  - "11.1.  Normative References\n   [RFC1035]        Mockapetris, P., \"Domain names\
    \ - implementation and\n                    specification\", STD 13, RFC 1035,\
    \ November 1987.\n   [RFC1464]        Rosenbaum, R., \"Using the Domain Name System\
    \ To\n                    Store Arbitrary String Attributes\", RFC 1464,\n   \
    \                 May 1993.\n   [RFC2535]        Eastlake, D., \"Domain Name System\
    \ Security\n                    Extensions\", RFC 2535, March 1999.\n   [RFC2671]\
    \        Vixie, P., \"Extension Mechanisms for DNS (EDNS0)\",\n              \
    \      RFC 2671, August 1999.\n   [RFC3597]        Gustafsson, A., \"Handling\
    \ of Unknown DNS Resource\n                    Record (RR) Types\", RFC 3597,\
    \ September 2003.\n   [RFC5395]        Eastlake, D., \"Domain Name System (DNS)\
    \ IANA\n                    Considerations\", BCP 42, RFC 5395, November 2008.\n"
- title: 11.2.  Informative References
  contents:
  - "11.2.  Informative References\n   [DNSEXT-DNS-SD]  Cheshire, S. and M. Krochmal,\
    \ \"DNS-Based Service\n                    Discovery\", Work in Progress, September\
    \ 2008.\n   [Dyer87]         Dyer, S. and F. Hsu, \"Hesiod, Project Athena\n \
    \                   Technical Plan - Name Service\", Version 1.9,\n          \
    \          April 1987.\n   [RFC1123]        Braden, R., \"Requirements for Internet\
    \ Hosts -\n                    Application and Support\", STD 3, RFC 1123,\n \
    \                   October 1989.\n   [RFC1535]        Gavron, E., \"A Security\
    \ Problem and Proposed\n                    Correction With Widely Deployed DNS\
    \ Software\",\n                    RFC 1535, October 1993.\n   [RFC2163]     \
    \   Allocchio, C., \"Using the Internet DNS to Distribute\n                  \
    \  MIXER Conformant Global Address Mapping (MCGAM)\",\n                    RFC\
    \ 2163, January 1998.\n   [RFC2181]        Elz, R. and R. Bush, \"Clarifications\
    \ to the DNS\n                    Specification\", RFC 2181, July 1997.\n   [RFC2672]\
    \        Crawford, M., \"Non-Terminal DNS Name Redirection\",\n              \
    \      RFC 2672, August 1999.\n   [RFC3445]        Massey, D. and S. Rose, \"\
    Limiting the Scope of the\n                    KEY Resource Record (RR)\", RFC\
    \ 3445, December 2002.\n   [RFC3467]        Klensin, J., \"Role of the Domain\
    \ Name System (DNS)\",\n                    RFC 3467, February 2003.\n   [RFC3761]\
    \        Faltstrom, P. and M. Mealling, \"The E.164 to Uniform\n             \
    \       Resource Identifiers (URI) Dynamic Delegation\n                    Discovery\
    \ System (DDDS) Application (ENUM)\",\n                    RFC 3761, April 2004.\n\
    \   [RFC4033]        Arends, R., Austein, R., Larson, M., Massey, D., and\n  \
    \                  S. Rose, \"DNS Security Introduction and\n                \
    \    Requirements\", RFC 4033, March 2005.\n   [RFC4034]        Arends, R., Austein,\
    \ R., Larson, M., Massey, D., and\n                    S. Rose, \"Resource Records\
    \ for the DNS Security\n                    Extensions\", RFC 4034, March 2005.\n\
    \   [RFC4035]        Arends, R., Austein, R., Larson, M., Massey, D., and\n  \
    \                  S. Rose, \"Protocol Modifications for the DNS\n           \
    \         Security Extensions\", RFC 4035, March 2005.\n   [RFC4511]        Sermersheim,\
    \ J., \"Lightweight Directory Access\n                    Protocol (LDAP): The\
    \ Protocol\", RFC 4511, June 2006.\n   [RFC4592]        Lewis, E., \"The Role\
    \ of Wildcards in the Domain Name\n                    System\", RFC 4592, July\
    \ 2006.\n   [RFC4871]        Allman, E., Callas, J., Delany, M., Libbey, M.,\n\
    \                    Fenton, J., and M. Thomas, \"DomainKeys Identified\n    \
    \                Mail (DKIM) Signatures\", RFC 4871, May 2007.\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Internet Architecture Board\n   EMail: iab@iab.org\n \
    \  Patrik Faltstrom (editor)\n   EMail: paf@cisco.com\n   Rob Austein (editor)\n\
    \   EMail: sra@isc.org\n   Peter Koch (editor)\n   EMail: pk@denic.de\n"
