- title: __initial_text__
  contents:
  - ''
- title: Independent Submission                                         D. Savage
  contents:
  - "Independent Submission                                         D. Savage\n  \
    \     Cisco's Enhanced Interior Gateway Routing Protocol (EIGRP)\n"
- title: Abstract
  contents:
  - "Abstract\n   This document describes the protocol design and architecture for\n\
    \   Enhanced Interior Gateway Routing Protocol (EIGRP).  EIGRP is a\n   routing\
    \ protocol based on Distance Vector technology.  The specific\n   algorithm used\
    \ is called \"DUAL\", a Diffusing Update Algorithm as\n   referenced in \"Loop-Free\
    \ Routing Using Diffusing Computations\"\n   (Garcia-Luna-Aceves 1993).  The algorithm\
    \ and procedures were\n   researched, developed, and simulated by SRI International.\n"
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This document is not an Internet Standards Track specification;\
    \ it is\n   published for informational purposes.\n   This is a contribution to\
    \ the RFC Series, independently of any other\n   RFC stream.  The RFC Editor has\
    \ chosen to publish this document at\n   its discretion and makes no statement\
    \ about its value for\n   implementation or deployment.  Documents approved for\
    \ publication by\n   the RFC Editor are not a candidate for any level of Internet\n\
    \   Standard; see Section 2 of RFC 5741.\n   Information about the current status\
    \ of this document, any errata,\n   and how to provide feedback on it may be obtained\
    \ at\n   http://www.rfc-editor.org/info/rfc7868.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (c) 2016 IETF Trust and the persons identified\
    \ as the\n   document authors.  All rights reserved.\n   This document is subject\
    \ to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n\
    \   (http://trustee.ietf.org/license-info) in effect on the date of\n   publication\
    \ of this document.  Please review these documents\n   carefully, as they describe\
    \ your rights and restrictions with respect\n   to this document.\n   This document\
    \ may not be modified, and derivative works of it may not\n   be created, except\
    \ to format it for publication as an RFC or to\n   translate it into languages\
    \ other than English.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1. Introduction ....................................................5\n\
    \   2. Conventions .....................................................5\n  \
    \    2.1. Requirements Language ......................................5\n    \
    \  2.2. Terminology ................................................5\n   3. The\
    \ Diffusing Update Algorithm (DUAL) ...........................9\n      3.1. Algorithm\
    \ Description ......................................9\n      3.2. Route States\
    \ ..............................................10\n      3.3. Feasibility Condition\
    \ .....................................11\n      3.4. DUAL Message Types ........................................13\n\
    \      3.5. DUAL Finite State Machine (FSM) ...........................13\n  \
    \    3.6. DUAL Operation -- Example Topology ........................18\n   4.\
    \ EIGRP Packets ..................................................20\n      4.1.\
    \ UPDATE Packets ............................................21\n      4.2. QUERY\
    \ Packets .............................................21\n      4.3. REPLY Packets\
    \ .............................................22\n      4.4. Exception Handling\
    \ ........................................22\n           4.4.1. Active Duration\
    \ (SIA) ..............................22\n                  4.4.1.1. SIA-QUERY\
    \ .................................23\n                  4.4.1.2. SIA-REPLY .................................24\n\
    \   5. EIGRP Operation ................................................25\n  \
    \    5.1. Finite State Machine ......................................25\n    \
    \  5.2. Reliable Transport Protocol ...............................25\n      \
    \     5.2.1. Bandwidth on Low-Speed Links .......................32\n      5.3.\
    \ Neighbor Discovery/Recovery ...............................32\n           5.3.1.\
    \ Neighbor Hold Time .................................32\n           5.3.2. HELLO\
    \ Packets ......................................33\n           5.3.3. UPDATE Packets\
    \ .....................................33\n           5.3.4. Initialization Sequence\
    \ ............................34\n           5.3.5. Neighbor Formation .................................35\n\
    \           5.3.6. QUERY Packets during Neighbor Formation ............35\n  \
    \    5.4. Topology Table ............................................36\n    \
    \       5.4.1. Route Management ...................................36\n      \
    \            5.4.1.1. Internal Routes ...........................37\n        \
    \          5.4.1.2. External Routes ...........................37\n          \
    \ 5.4.2. Split Horizon and Poison Reverse ...................38\n            \
    \      5.4.2.1. Startup Mode ..............................38\n              \
    \    5.4.2.2. Advertising Topology Table Change .........39\n                \
    \  5.4.2.3. Sending a QUERY/UPDATE ....................39\n      5.5. EIGRP Metric\
    \ Coefficients .................................39\n           5.5.1. Coefficients\
    \ K1 and K2 .............................40\n           5.5.2. Coefficient K3\
    \ .....................................40\n           5.5.3. Coefficients K4 and\
    \ K5 .............................40\n           5.5.4. Coefficient K6 .....................................41\n\
    \                  5.5.4.1. Jitter ....................................41\n  \
    \                5.5.4.2. Energy ....................................41\n    \
    \  5.6. EIGRP Metric Calculations .................................41\n      \
    \     5.6.1. Classic Metrics ....................................41\n        \
    \          5.6.1.1. Classic Composite Formulation .............42\n          \
    \        5.6.1.2. Cisco Interface Delay Compatibility .......43\n           5.6.2.\
    \ Wide Metrics .......................................43\n                  5.6.2.1.\
    \ Wide Metric Vectors .......................44\n                  5.6.2.2. Wide\
    \ Metric Conversion Constants ..........45\n                  5.6.2.3. Throughput\
    \ Calculation ....................45\n                  5.6.2.4. Latency Calculation\
    \ .......................46\n                  5.6.2.5. Composite Calculation\
    \ .....................46\n   6. EIGRP Packet Formats ...........................................46\n\
    \      6.1. Protocol Number ...........................................46\n  \
    \    6.2. Protocol Assignment Encoding ..............................47\n    \
    \  6.3. Destination Assignment Encoding ...........................47\n      6.4.\
    \ EIGRP Communities Attribute ...............................48\n      6.5. EIGRP\
    \ Packet Header .......................................49\n      6.6. EIGRP TLV\
    \ Encoding Format .................................51\n           6.6.1. Type\
    \ Field Encoding ................................52\n           6.6.2. Length\
    \ Field Encoding ..............................52\n           6.6.3. Value Field\
    \ Encoding ...............................52\n      6.7. EIGRP Generic TLV Definitions\
    \ .............................52\n           6.7.1. 0x0001 - PARAMETER_TYPE ............................53\n\
    \           6.7.2. 0x0002 - AUTHENTICATION_TYPE .......................53\n  \
    \                6.7.2.1. 0x02 - MD5 Authentication Type ............54\n    \
    \              6.7.2.2. 0x03 - SHA2 Authentication Type ...........54\n      \
    \     6.7.3. 0x0003 - SEQUENCE_TYPE .............................54\n        \
    \   6.7.4. 0x0004 - SOFTWARE_VERSION_TYPE .....................55\n          \
    \ 6.7.5. 0x0005 - MULTICAST_SEQUENCE_TYPE ...................55\n           6.7.6.\
    \ 0x0006 - PEER_INFORMATION_TYPE .....................55\n           6.7.7. 0x0007\
    \ - PEER_ TERMINATION_TYPE ....................56\n           6.7.8. 0x0008 -\
    \ TID_LIST_TYPE .............................56\n      6.8. Classic Route Information\
    \ TLV Types .......................57\n           6.8.1. Classic Flag Field Encoding\
    \ ........................57\n           6.8.2. Classic Metric Encoding ............................57\n\
    \           6.8.3. Classic Exterior Encoding ..........................58\n  \
    \         6.8.4. Classic Destination Encoding .......................59\n    \
    \       6.8.5. IPv4-Specific TLVs .................................59\n      \
    \            6.8.5.1. IPv4 INTERNAL_TYPE ........................60\n        \
    \          6.8.5.2. IPv4 EXTERNAL_TYPE ........................60\n          \
    \        6.8.5.3. IPv4 COMMUNITY_TYPE .......................62\n           6.8.6.\
    \ IPv6-Specific TLVs .................................62\n                  6.8.6.1.\
    \ IPv6 INTERNAL_TYPE ........................63\n                  6.8.6.2. IPv6\
    \ EXTERNAL_TYPE ........................63\n                  6.8.6.3. IPv6 COMMUNITY_TYPE\
    \ .......................65\n      6.9. Multiprotocol Route Information TLV Types\
    \ .................66\n           6.9.1. TLV Header Encoding ................................66\n\
    \           6.9.2. Wide Metric Encoding ...............................67\n  \
    \         6.9.3. Extended Metrics ...................................68\n    \
    \              6.9.3.1. 0x00 - NoOp ...............................69\n      \
    \            6.9.3.2. 0x01 - Scaled Metric ......................70\n        \
    \          6.9.3.3. 0x02 - Administrator Tag ..................70\n          \
    \        6.9.3.4. 0x03 - Community List .....................71\n            \
    \      6.9.3.5. 0x04 - Jitter .............................71\n              \
    \    6.9.3.6. 0x05 - Quiescent Energy ...................71\n                \
    \  6.9.3.7. 0x06 - Energy .............................72\n                  6.9.3.8.\
    \ 0x07 - AddPath ............................72\n                           6.9.3.8.1.\
    \ AddPath with IPv4 Next Hop .....73\n                           6.9.3.8.2. AddPath\
    \ with IPv6 Next Hop .....74\n           6.9.4. Exterior Encoding ..................................75\n\
    \           6.9.5. Destination Encoding ...............................76\n  \
    \         6.9.6. Route Information ..................................76\n    \
    \              6.9.6.1. INTERNAL TYPE .............................76\n      \
    \            6.9.6.2. EXTERNAL TYPE .............................76\n   7. Security\
    \ Considerations ........................................77\n   8. IANA Considerations\
    \ ............................................77\n   9. References .....................................................77\n\
    \      9.1. Normative References ......................................77\n  \
    \    9.2. Informative References ....................................78\n   Acknowledgments\
    \ ...................................................79\n   Authors' Addresses\
    \ ................................................80\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   This document describes the Enhanced Interior Gateway Routing\n\
    \   Protocol (EIGRP), a routing protocol designed and developed by Cisco\n   Systems,\
    \ Inc.  DUAL, the algorithm used to converge the control plane\n   to a single\
    \ set of loop-free paths is based on research conducted at\n   SRI International\
    \ [3].  The Diffusing Update Algorithm (DUAL) is the\n   algorithm used to obtain\
    \ loop freedom at every instant throughout a\n   route computation [2].  This\
    \ allows all routers involved in a\n   topology change to synchronize at the same\
    \ time; the routers not\n   affected by topology changes are not involved in the\
    \ recalculation.\n   This document describes the protocol that implements these\
    \ functions.\n"
- title: 2.  Conventions
  contents:
  - '2.  Conventions

    '
- title: 2.1.  Requirements Language
  contents:
  - "2.1.  Requirements Language\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\"\
    , \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"\
    MAY\", and \"OPTIONAL\" in this\n   document are to be interpreted as described\
    \ in RFC 2119 [1].\n"
- title: 2.2.  Terminology
  contents:
  - "2.2.  Terminology\n   The following is a list of abbreviations and terms used\
    \ throughout\n   this document:\n   ACTIVE State:\n      The local state of a\
    \ route on a router triggered by any event that\n      causes all neighbors providing\
    \ the current least-cost path to fail\n      the Feasibility Condition check.\
    \  A route in Active state is\n      considered unusable.  During Active state,\
    \ the router is actively\n      attempting to compute the least-cost loop-free\
    \ path by explicit\n      coordination with its neighbors using Query and Reply\
    \ messages.\n   Address Family Identifier (AFI):\n      Identity of the network-layer\
    \ protocol reachability information\n      being advertised [12].\n   Autonomous\
    \ System (AS):\n      A collection of routers exchanging routes under the control\
    \ of one\n      or more network administrators on behalf of a single\n      administrative\
    \ entity.\n   Base Topology:\n      A routing domain representing a physical (non-virtual)\
    \ view of the\n      network topology consisting of attached devices and network\n\
    \      segments EIGRP uses to form neighbor relationships.  Destinations\n   \
    \   exchanged within the Base Topology are identified with a Topology\n      Identifier\
    \ value of zero (0).\n   Computed Distance (CD):\n      Total distance (metric)\
    \ along a path from the current router to a\n      destination network through\
    \ a particular neighbor computed using\n      that neighbor's Reported Distance\
    \ (RD) and the cost of the link\n      between the two routers.  Exactly one CD\
    \ is computed and\n      maintained per the [Destination, Advertising Neighbor]\
    \ pair.\n   CR-Mode\n      Conditionally Received Mode\n   Diffusing Computation:\n\
    \      A distributed computation in which a single starting node\n      commences\
    \ the computation by delegating subtasks of the\n      computation to its neighbors\
    \ that may, in turn, recursively\n      delegate sub-subtasks further, including\
    \ a signaling scheme\n      allowing the starting node to detect that the computation\
    \ has\n      finished while avoiding false terminations.  In DUAL, the task of\n\
    \      coordinated updates of routing tables and resulting best path\n      computation\
    \ is performed as a diffusing computation.\n   Diffusing Update Algorithm (DUAL):\n\
    \      A loop-free routing algorithm used with distance vectors or link\n    \
    \  states that provides a diffused computation of a routing table.\n      It works\
    \ very well in the presence of multiple topology changes\n      with low overhead.\
    \  The technology was researched and developed at\n      SRI International [3].\n\
    \   Downstream Router:\n      A router that is one or more hops away from the\
    \ router in question\n      in the direction of the destination.\n   EIGRP:\n\
    \      Enhanced Interior Gateway Routing Protocol.\n   Feasibility Condition:\n\
    \      The Feasibility Condition is a sufficient condition used by a\n      router\
    \ to verify whether a neighboring router provides a loop-free\n      path to a\
    \ destination.  EIGRP uses the Source Node Condition\n      stating that a neighboring\
    \ router meets the Feasibility Condition\n      if the neighbor's RD is less than\
    \ this router's Feasible Distance.\n   Feasible Distance (FD):\n      Defined\
    \ as the least-known total metric to a destination from the\n      current router\
    \ since the last transition from ACTIVE to PASSIVE\n      state.  Being effectively\
    \ a record of the smallest known metric\n      since the last time the network\
    \ entered the PASSIVE state, the FD\n      is not necessarily a metric of the\
    \ current best path.  Exactly one\n      FD is computed per destination network.\n\
    \   Feasible Successor:\n      A neighboring router that meets the Feasibility\
    \ Condition for a\n      particular destination, hence, providing a guaranteed\
    \ loop-free\n      path.\n   Neighbor/Peer:\n      For a particular router, another\
    \ router toward which an EIGRP\n      session, also known as an \"adjacency\"\
    , is established.  The\n      ability of two routers to become neighbors depends\
    \ on their mutual\n      connectivity and compatibility of selected EIGRP configuration\n\
    \      parameters.  Two neighbors with interfaces connected to a common\n    \
    \  subnet are known as adjacent neighbors.  Two neighbors that are\n      multiple\
    \ hops apart are known as remote neighbors.\n   PASSIVE state:\n      The local\
    \ state of a route in which at least one neighbor\n      providing the current\
    \ least-cost path passes the Feasibility\n      Condition check.  A route in PASSIVE\
    \ state is considered usable\n      and not in need of a coordinated re-computation.\n\
    \   Network Layer Reachability Information (NLRI):\n      Information a router\
    \ uses to calculate the global routing table to\n      make routing and forwarding\
    \ decisions.\n   Reported Distance (RD):\n      For a particular destination,\
    \ the value representing the router's\n      distance to the destination as advertised\
    \ in all messages carrying\n      routing information.  RD is not equivalent to\
    \ the current distance\n      of the router to the destination and may be different\
    \ from it\n      during the process of path re-computation.  Exactly one RD is\n\
    \      computed and maintained per destination network.\n   Sub-Topology:\n  \
    \    For a given Base Topology, a sub-topology is characterized by an\n      independent\
    \ set of routers and links in a network for which EIGRP\n      performs an independent\
    \ path calculation.  This allows each sub-\n      topology to implement class-specific\
    \ topologies to carry class-\n      specific traffic.\n   Successor:\n      For\
    \ a particular destination, a neighboring router that meets the\n      Feasibility\
    \ Condition and, at the same time, provides the least-\n      cost path.\n   Stuck\
    \ In Active (SIA):\n      A destination that has remained in the ACTIVE State\
    \ in excess of a\n      predefined time period at the local router (Cisco implements\
    \ this\n      as 3 minutes).\n   Successor-Directed Acyclic Graph (SDAG):\n  \
    \    For a particular destination, a graph defined by routing table\n      contents\
    \ of individual routers in the topology, such that nodes of\n      this graph\
    \ are the routers themselves and a directed edge from\n      router X to router\
    \ Y exists if and only if router Y is router X's\n      successor.  After the\
    \ network has converged, in the absence of\n      topological changes, SDAG is\
    \ a tree.\n   Topology Change / Topology-Change Event:\n      Any event that causes\
    \ the CD for a destination through a neighbor\n      to be added, modified, or\
    \ removed.  As an example, detecting a\n      link-cost change, receiving any\
    \ EIGRP message from a neighbor\n      advertising an updated neighbor's RD.\n\
    \   Topology Identifier (TID):\n      A number that is used to mark prefixes as\
    \ belonging to a specific\n      sub-topology.\n   Topology Table:\n      A data\
    \ structure used by EIGRP to store information about every\n      known destination\
    \ including, but not limited to, network prefix /\n      prefix length, FD, RD\
    \ of each neighbor advertising the\n      destination, CD over the corresponding\
    \ neighbor, and route state.\n   Type, Length, Value (TLV):\n      An encoding\
    \ format for information elements used in EIGRP messages\n      to exchange information.\
    \  Each TLV-formatted information element\n      consists of three generic fields:\
    \ Type identifying the nature of\n      information carried in this element, Length\
    \ describing the length\n      of the entire TLV triplet, and Value carrying the\
    \ actual\n      information.  The Value field may, itself, be internally\n   \
    \   structured; this depends on the actual type of the information\n      element.\
    \  This format allows for extensibility and backward\n      compatibility.\n \
    \  Upstream Router:\n      A router that is one or more hops away from the router\
    \ in\n      question, in the direction of the source of the information.\n   VID:\n\
    \      VLAN Identifier\n   Virtual Routing and Forwarding (VRF):\n      Independent\
    \ Virtual Private Network (VPN) routing/forwarding\n      tables that coexist\
    \ within the same router at the same time.\n"
- title: 3.  The Diffusing Update Algorithm (DUAL)
  contents:
  - "3.  The Diffusing Update Algorithm (DUAL)\n   The Diffusing Update Algorithm\
    \ (DUAL) constructs least-cost paths to\n   all reachable destinations in a network\
    \ consisting of nodes and edges\n   (routers and links).  DUAL guarantees that\
    \ each constructed path is\n   loop free at every instant including periods of\
    \ topology changes and\n   network reconvergence.  This is accomplished by all\
    \ routers, which\n   are affected by a topology change, computing the new best\
    \ path in a\n   coordinated (diffusing) way and using the Feasibility Condition\
    \ to\n   verify prospective paths for loop freedom.  Routers that are not\n  \
    \ affected by topology changes are not involved in the recalculation.\n   The\
    \ convergence time with DUAL rivals that of any other existing\n   routing protocol.\n"
- title: 3.1.  Algorithm Description
  contents:
  - "3.1.  Algorithm Description\n   DUAL is used by EIGRP to achieve fast loop-free\
    \ convergence with\n   little overhead, allowing EIGRP to provide convergence\
    \ rates\n   comparable, and in some cases better than, most common link state\n\
    \   protocols [10].  Only nodes that are affected by a topology change\n   need\
    \ to propagate and act on information about the topology change,\n   allowing\
    \ EIGRP to have good scaling properties, reduced overhead, and\n   lower complexity\
    \ than many other interior gateway protocols.\n   Distributed routing algorithms\
    \ are required to propagate information\n   as well as coordinate information\
    \ among all nodes in the network.\n   Unlike basic Bellman-Ford distance vector\
    \ protocols that rely on\n   uncoordinated updates when a topology change occurs,\
    \ DUAL uses a\n   coordinated procedure to involve the affected part of the network\n\
    \   into computing a new least-cost path, known as a \"diffusing\n   computation\"\
    .  A diffusing computation grows by querying additional\n   routers for their\
    \ current RD to the affected destination, and it\n   shrinks by receiving replies\
    \ from them.  Unaffected routers send\n   replies immediately, terminating the\
    \ growth of the diffusing\n   computation over them.  These intrinsic properties\
    \ cause the\n   diffusing computation to self-adjust in scope and terminate as\
    \ soon\n   as possible.\n   One attribute of DUAL is its ability to control the\
    \ point at which\n   the diffusion of a route calculation terminates by managing\
    \ the\n   distribution of reachability information through the network.\n   Controlling\
    \ the scope of the diffusing process is accomplished by\n   hiding reachability\
    \ information through aggregation (summarization),\n   filtering, or other means.\
    \  This provides the ability to create\n   effective failure domains within a\
    \ single AS, and allows the network\n   administrator to manage the convergence\
    \ and processing\n   characteristics of the network.\n"
- title: 3.2.  Route States
  contents:
  - "3.2.  Route States\n   A route to a destination can be in one of two states:\
    \ PASSIVE or\n   ACTIVE.  These states describe whether the route is guaranteed\
    \ to be\n   both loop free and the shortest available (the PASSIVE state) or\n\
    \   whether such a guarantee cannot be given (the ACTIVE state).\n   Consequently,\
    \ in PASSIVE state, the router does not perform any route\n   recalculation in\
    \ coordination with its neighbors because no such\n   recalculation is needed.\n\
    \   In ACTIVE state, the router is actively involved in re-computing the\n   least-cost\
    \ loop-free path in coordination with its neighbors.  The\n   state is reevaluated\
    \ and possibly changed every time a topology\n   change is detected.  A topology\
    \ change is any event that causes the\n   CD to the destination over any neighbor\
    \ to be added, changed, or\n   removed from EIGRP's topology table.\n   More exactly,\
    \ the two states are defined as follows:\n   o Passive\n      A route is considered\
    \ to be in the Passive state when at least one\n      neighbor that provides the\
    \ current least-total-cost path passes\n      the Feasibility Condition check\
    \ that guarantees loop freedom.  A\n      route in the PASSIVE state is usable\
    \ and its next hop is perceived\n      to be a downstream router.\n   o Active\n\
    \      A route is considered to be in the ACTIVE state if neighbors that\n   \
    \   do not pass the Feasibility Condition check provide lowest-cost\n      path,\
    \ and therefore the path cannot be guaranteed loop free.  A\n      route in the\
    \ ACTIVE state is considered unusable and this router\n      must coordinate with\
    \ its neighbors in the search for the new loop-\n      free least-total-cost path.\n\
    \   In other words, for a route to be in PASSIVE state, at least one\n   neighbor\
    \ that provides the least-total-cost path must be a Feasible\n   Successor.  Feasible\
    \ Successors providing the least-total-cost path\n   are also called \"successors\"\
    .  For a route to be in PASSIVE state, at\n   least one successor must exist.\n\
    \   Conversely, if the path with the least total cost is provided by\n   routers\
    \ that are not Feasible Successors (and thus not successors),\n   the route is\
    \ in the ACTIVE state, requiring re-computation.\n   Notably, for the definition\
    \ of PASSIVE and ACTIVE states, it does not\n   matter if there are Feasible Successors\
    \ providing a worse-than-least-\n   total-cost path.  While these neighbors are\
    \ guaranteed to provide a\n   loop-free path, that path is potentially not the\
    \ shortest available.\n   The fact that the least-total-cost path can be provided\
    \ by a neighbor\n   that fails the Feasibility Condition check may not be intuitive.\n\
    \   However, such a situation can occur during topology changes when the\n   current\
    \ least-total-cost path fails and the next-least-total-cost\n   path traverses\
    \ a neighbor that is not a Feasible Successor.\n   While a router has a route\
    \ in the ACTIVE state, it must not change\n   its successor (i.e., modify the\
    \ current SDAG) nor modify its own\n   Feasible Distance or RD until the route\
    \ enters the PASSIVE state\n   again.  Any updated information about this route\
    \ received during\n   ACTIVE state is reflected only in CDs.  Any updates to the\
    \ successor,\n   FD, and RD are postponed until the route returns to PASSIVE state.\n\
    \   The state transitions from PASSIVE to ACTIVE and from ACTIVE to\n   PASSIVE\
    \ are controlled by the DUAL FSM and are described in detail in\n   Section 3.5.\n"
- title: 3.3.  Feasibility Condition
  contents:
  - "3.3.  Feasibility Condition\n   The Feasibility Condition is a criterion used\
    \ to verify loop freedom\n   of a particular path.  The Feasibility Condition\
    \ is a sufficient but\n   not a necessary condition, meaning that every path meeting\
    \ the\n   Feasibility Condition is guaranteed to be loop free; however, not all\n\
    \   loop-free paths meet the Feasibility Condition.\n   The Feasibility Condition\
    \ is used as an integral part of DUAL\n   operation: every path selection in DUAL\
    \ is subject to the Feasibility\n   Condition check.  Based on the result of the\
    \ Feasibility Condition\n   check after a topology change is detected, the route\
    \ may either\n   remain PASSIVE (if, after the topology change, the neighbor providing\n\
    \   the least cost path meets the Feasibility Condition) or it needs to\n   enter\
    \ the ACTIVE state (if the topology change resulted in none of\n   the neighbors\
    \ providing the least cost path to meet the Feasibility\n   Condition).\n   The\
    \ Feasibility Condition is a part of DUAL that allows the diffused\n   computation\
    \ to terminate as early as possible.  Nodes that are not\n   affected by the topology\
    \ change are not required to perform a DUAL\n   computation and may not be aware\
    \ a topology change occurred.  This\n   can occur in two cases:\n   First, if\
    \ informed about a topology change, a router may keep a route\n   in PASSIVE state\
    \ if it is aware of other paths that are downstream\n   towards the destination\
    \ (routes meeting the Feasibility Condition).\n   A route that meets the Feasibility\
    \ Condition is determined to be loop\n   free and downstream along the path between\
    \ the router and the\n   destination.\n   Second, if informed about a topology\
    \ change for which it does not\n   currently have reachability information, a\
    \ router is not required to\n   enter into the ACTIVE state, nor is it required\
    \ to participate in the\n   DUAL process.\n   In order to facilitate describing\
    \ the Feasibility Condition, a few\n   definitions are in order.\n   o  A successor\
    \ for a given route is the next hop used to forward data\n      traffic for a\
    \ destination.  Typically, the successor is chosen\n      based on the least-cost\
    \ path to reach the destination.\n   o  A Feasible Successor is a neighbor that\
    \ meets the Feasibility\n      Condition.  A Feasible Successor is regarded as\
    \ a downstream\n      neighbor towards the destination, but it may not be the\
    \ least-cost\n      path but could still be used for forwarding data packets in\
    \ the\n      event equal or unequal cost load sharing was active.  A Feasible\n\
    \      Successor can become a successor when the current successor\n      becomes\
    \ unreachable.\n   o  The Feasibility Condition is met when a neighbor's advertised\n\
    \      cost, (RD) to a destination is less than the FD for that\n      destination,\
    \ or in other words, the Feasibility Condition is met\n      when the neighbor\
    \ is closer to the destination than the router\n      itself has ever been since\
    \ the destination has entered the PASSIVE\n      state for the last time.\n  \
    \ o  The FD is the lowest distance to the destination since the last\n      time\
    \ the route went from ACTIVE to PASSIVE state.  It should be\n      noted it is\
    \ not necessarily the current best distance; rather, it\n      is a historical\
    \ record of the best distance known since the last\n      diffusing computation\
    \ for the destination has finished.  Thus, the\n      value of the FD can either\
    \ be the same as the current best\n      distance, or it can be lower.\n   A neighbor\
    \ that advertises a route with a cost that does not meet the\n   Feasibility Condition\
    \ may be upstream and thus cannot be guaranteed\n   to be the next hop for a loop-free\
    \ path.  Routes advertised by\n   upstream neighbors are not recorded in the routing\
    \ table but saved in\n   the topology table.\n"
- title: 3.4.  DUAL Message Types
  contents:
  - "3.4.  DUAL Message Types\n   DUAL operates with three basic message types: QUERY,\
    \ UPDATE, and\n   REPLY.\n   o  UPDATE - sent to indicate a change in metric or\
    \ an addition of a\n      destination.\n   o  QUERY - sent when the Feasibility\
    \ Condition fails, which can\n      happen for reasons like a destination becoming\
    \ unreachable or the\n      metric increasing to a value greater than its current\
    \ FD.\n   o REPLY - sent in response to a QUERY or SIA-QUERY\n   In addition to\
    \ these three basic types, two additional sub-types have\n   been added to EIGRP:\n\
    \   o  SIA-QUERY - sent when a REPLY has not been received within one-\n     \
    \ half of the SIA interval (90 seconds as implemented by Cisco).\n   o  SIA-REPLY\
    \ - sent in response to an SIA-QUERY indicating the route\n      is still in ACTIVE\
    \ state.  This response does not stratify the\n      original QUERY; it is only\
    \ used to indicate that the sending\n      neighbor is still in the ACTIVE state\
    \ for the given destination.\n   When in the PASSIVE state, a received QUERY may\
    \ be propagated if\n   there is no Feasible Successor found.  If a Feasible Successor\
    \ is\n   found, the QUERY is not propagated and a REPLY is sent for the\n   destination\
    \ with a metric equal to the current routing table metric.\n   When a QUERY is\
    \ received from a non-successor in ACTIVE state, a\n   REPLY is sent and the QUERY\
    \ is not propagated.  The REPLY for the\n   destination contains a metric equal\
    \ to the current routing table\n   metric.\n"
- title: 3.5.  DUAL Finite State Machine (FSM)
  contents:
  - "3.5.  DUAL Finite State Machine (FSM)\n   The DUAL FSM embodies the decision\
    \ process for all route\n   computations.  It tracks all routes advertised by\
    \ all neighbors.  The\n   distance information, known as a metric, is used by\
    \ DUAL to select\n   efficient loop-free paths.  DUAL selects routes to be inserted\
    \ into a\n   routing table based on Feasible Successors.  A successor is a\n \
    \  neighboring router used for packet forwarding that has a least-cost\n   path\
    \ to a destination that is guaranteed not to be part of a routing\n   loop.\n\
    \   When there are no Feasible Successors but there are neighbors\n   advertising\
    \ the destination, a recalculation must occur to determine\n   a new successor.\n\
    \   The amount of time it takes to calculate the route impacts the\n   convergence\
    \ time.  Even though the recalculation is not processor\n   intensive, it is advantageous\
    \ to avoid recalculation if it is not\n   necessary.  When a topology change occurs,\
    \ DUAL will test for\n   Feasible Successors.  If there are Feasible Successors,\
    \ it will use\n   any it finds in order to avoid any unnecessary recalculation.\n\
    \   The FSM, which applies per destination in the topology table,\n   operates\
    \ independently for each destination.  It is true that if a\n   single link goes\
    \ down, multiple routes may go into ACTIVE state.\n   However, a separate SDAG\
    \ is computed for each destination, so loop-\n   free topologies can be maintained\
    \ for each reachable destination.\n              +------------+              \
    \  +-----------+\n              |             \\              /            |\n\
    \              |              \\            /             |\n              | \
    \  +=================================+   |\n              |   |              \
    \                   |   |\n              |(1)|             Passive           \
    \  |(2)|\n              +-->|                                 |<--+\n        \
    \          +=================================+\n                      ^     |\
    \    ^    ^    ^    |\n                  (14)|     |(15)|    |(13)|    |\n   \
    \                   |  (4)|    |(16)|    | (3)|\n                      |     |\
    \    |    |    |    +------------+\n                      |     |    |    |  \
    \  |                  \\\n             +-------+      +    +    |    +-------------+\
    \     \\\n            /              /    /     |                   \\     \\\n\
    \           /              /    /      +----+               \\     \\\n      \
    \    |               |   |            |                |     |\n          |  \
    \             v   |            |                |     v\n      +==========+(11)\
    \ +==========+     +==========+(12) +==========+\n      |  Active  |---->|  Active\
    \  |(5)  |  Active  |---->|  Active  |\n      |          |  (9)|          |---->|\
    \          | (10)|          |\n      |  oij=0   |<----|  oij=1   |     |  oij=2\
    \   |<----|  oij=3   |\n   +--|          |  +--|          |  +--|          | \
    \ +--|          |\n   |  +==========+  |  +==========+  |  +==========+  |  +==========+\n\
    \   |      ^   |(5)  |      ^         |    ^    ^      |         ^\n   |     \
    \ |   +-----|------|---------|----+    |      |         |\n   +------+       \
    \  +------+         +---------+      +---------+\n   (6,7,8)          (6,7,8)\
    \            (6,7,8)          (6,7,8)\n                      Figure 1: DUAL Finite\
    \ State Machine\n   Legend:\n    i   Node that is computing route\n    j   Destination\
    \ node or network\n    k   Any neighbor of node i\n    oij QUERY origin flag\n\
    \      0 = metric increase during ACTIVE state\n      1 = node i originated\n\
    \      2 = QUERY from, or link increase to, successor during ACTIVE state\n  \
    \    3 = QUERY originated from successor\n    rijk REPLY status flag for each\
    \ neighbor k for destination j\n      1 = awaiting REPLY\n      0 = received REPLY\n\
    \    lik = the link connecting node i to neighbor k\n   The following describes\
    \ in detail the state/event/action transitions\n   of the DUAL FSM.  For all steps,\
    \ the topology table is updated with\n   the new metric information from either\
    \ QUERY, REPLY, or UPDATE\n   received.\n   (1)  A QUERY is received from a neighbor\
    \ that is not the current\n        successor.  The route is currently in PASSIVE\
    \ state.  As the\n        successor is not affected by the QUERY, and a Feasible\
    \ Successor\n        exists, the route remains in PASSIVE state.  Since a Feasible\n\
    \        Successor exists, a REPLY MUST be sent back to the originator of\n  \
    \      the QUERY.  Any metric received in the QUERY from that neighbor\n     \
    \   is recorded in the topology table and the Feasibility Check (FC)\n       \
    \ is run to check for any change to current successor.\n   (2)  A directly connected\
    \ interface changes state (connects,\n        disconnects, or changes metric),\
    \ or similarly an UPDATE or QUERY\n        has been received with a metric change\
    \ for an existing\n        destination, the route will stay in the PASSIVE state\
    \ if the\n        current successor is not affected by the change, or it is no\n\
    \        longer reachable and there is a Feasible Successor.  In either\n    \
    \    case, an UPDATE is sent with the new metric information if it\n        has\
    \ changed.\n   (3)  A QUERY was received from a neighbor who is the current\n\
    \        successor and no Feasible Successors exist.  The route for the\n    \
    \    destination goes into ACTIVE state.  A QUERY is sent to all\n        neighbors\
    \ on all interfaces that are not split horizon.  Split\n        horizon takes\
    \ effect for a query or update from the successor it\n        is using for the\
    \ destination in the query.  The QUERY origin\n        flag is set to indicate\
    \ the QUERY originated from a neighbor\n        marked as successor for route.\
    \  The REPLY status flag is set for\n        all neighbors to indicate outstanding\
    \ replies.\n   (4)  A directly connected link has gone down or its cost has\n\
    \        increased, or an UPDATE has been received with a metric\n        increase.\
    \  The route to the destination goes to ACTIVE state if\n        there are no\
    \ Feasible Successors found.  A QUERY is sent to all\n        neighbors on all\
    \ interfaces.  The QUERY origin flag is to\n        indicate that the router originated\
    \ the QUERY.  The REPLY status\n        flag is set to 1 for all neighbors to\
    \ indicate outstanding\n        replies.\n   (5)  While a route for a destination\
    \ is in ACTIVE state, and a QUERY\n        is received from the current successor,\
    \ the route remains in\n        ACTIVE state.  The QUERY origin flag is set to\
    \ indicate that\n        there was another topology change while in ACTIVE state.\
    \  This\n        indication is used so new Feasible Successors are compared to\n\
    \        the metric that made the route go to ACTIVE state with the\n        current\
    \ successor.\n   (6)  While a route for a destination is in ACTIVE state and a\
    \ QUERY\n        is received from a neighbor that is not the current successor,\
    \ a\n        REPLY should be sent to the neighbor.  The metric received in\n \
    \       the QUERY should be recorded.\n   (7)  If a link cost changes, or an UPDATE\
    \ with a metric change is\n        received in ACTIVE state from a non-successor,\
    \ the router stays\n        in ACTIVE state for the destination.  The metric information\
    \ in\n        the UPDATE is recorded.  When a route is in the ACTIVE state,\n\
    \        neither a QUERY nor UPDATE are ever sent.\n   (8)  If a REPLY for a destination,\
    \ in ACTIVE state, is received from\n        a neighbor or the link between a\
    \ router and the neighbor fails,\n        the router records that the neighbor\
    \ replied to the QUERY.  The\n        REPLY status flag is set to 0 to indicate\
    \ this.  The route stays\n        in ACTIVE state if there are more replies pending\
    \ because the\n        router has not heard from all neighbors.\n   (9)  If a\
    \ route for a destination is in ACTIVE state, and a link\n        fails or a cost\
    \ increase occurred between a router and its\n        successor, the router treats\
    \ this case like it has received a\n        REPLY from its successor.  When this\
    \ occurs after the router\n        originates a QUERY, it sets the QUERY origin\
    \ flag to indicate\n        that another topology change occurred in ACTIVE state.\n\
    \   (10) If a route for a destination is in ACTIVE state, and a link\n       \
    \ fails or a cost increase occurred between a router and its\n        successor,\
    \ the router treats this case like it has received a\n        REPLY from its successor.\
    \  When this occurs after a successor\n        originated a QUERY, the router\
    \ sets the QUERY origin flag to\n        indicate that another topology change\
    \ occurred in ACTIVE state.\n   (11) If a route for a destination is in ACTIVE\
    \ state, the cost of the\n        link through which the successor increases,\
    \ and the last REPLY\n        was received from all neighbors, but there is no\
    \ Feasible\n        Successor, the route should stay in ACTIVE state.  A QUERY\
    \ is\n        sent to all neighbors.  The QUERY origin flag is set to 1.\n   (12)\
    \ If a route for a destination is in ACTIVE state because of a\n        QUERY\
    \ received from the current successor, and the last REPLY\n        was received\
    \ from all neighbors, but there is no Feasible\n        Successor, the route should\
    \ stay in ACTIVE state.  A QUERY is\n        sent to all neighbors.  The QUERY\
    \ origin flag is set to 3.\n   (13) Received replies from all neighbors.  Since\
    \ the QUERY origin\n        flag indicates the successor originated the QUERY,\
    \ it\n        transitions to PASSIVE state and sends a REPLY to the old\n    \
    \    successor.\n   (14) Received replies from all neighbors.  Since the QUERY\
    \ origin\n        flag indicates a topology change to the successor while in\n\
    \        ACTIVE state, it need not send a REPLY to the old successor.\n      \
    \  When the Feasibility Condition is met, the route state\n        transitions\
    \ to PASSIVE.\n   (15) Received replies from all neighbors.  Since the QUERY origin\n\
    \        flag indicates either the router itself originated the QUERY or\n   \
    \     FC was not satisfied with the replies received in ACTIVE state,\n      \
    \  FD is reset to infinite value and the minimum of all the\n        reported\
    \ metrics is chosen as FD and route transitions back to\n        PASSIVE state.\
    \  A REPLY is sent to the old-successor if oij\n        flags indicate that there\
    \ was a QUERY from successor.\n   (16) If a route for a destination is in ACTIVE\
    \ state because of a\n        QUERY received from the current successor or there\
    \ was an\n        increase in distance while in ACTIVE state, the last REPLY was\n\
    \        received from all neighbors, and a Feasible Successor exists for\n  \
    \      the destination, the route can go into PASSIVE state and a REPLY\n    \
    \    is sent to the successor if oij indicates that QUERY was\n        received\
    \ from the successor.\n"
- title: 3.6.  DUAL Operation -- Example Topology
  contents:
  - "3.6.  DUAL Operation -- Example Topology\n   The following topology (Figure 2)\
    \ will be used to provide an example\n   of how DUAL is used to reroute after\
    \ a link failure.  Each node is\n   labeled with its costs to destination N. \
    \ The arrows indicate the\n   successor (next hop) used to reach destination N.\
    \  The least-cost\n   path is selected.\n                                N\n \
    \                               |\n                             (1)A ---<--- B(2)\n\
    \                                |         |\n                               \
    \ ^         |\n                                |         |\n                 \
    \            (2)D ---<--- C(3)\n                        Figure 2: Stable Topology\n\
    \   In the case where the link between A and D fails (Figure 3);\n          N\
    \                                   N\n          |                           \
    \        |\n          A ---<--- B                         A ---<--- B\n      \
    \    |         |                         |          |\n          X         | \
    \                        ^          |\n          |         |                 \
    \        |          |\n          D ---<--- C                         D ---<---\
    \ C\n            Q->                                      <-R\n              \
    \               N\n                             |\n                          (1)A\
    \ ---<--- B(2)\n                                       |\n                   \
    \                    ^\n                                       |\n           \
    \               (4)D --->--- C(3)\n                  Figure 3: Link between A\
    \ and D Fails\n      Only observing the destination provided by node N, D enters\
    \ the\n   ACTIVE state and sends a QUERY to all its neighbors, in this case\n\
    \   node C.\n      C determines that it has a Feasible Successor and replies\n\
    \   immediately with metric 3.\n      C changes its old successor of D to its\
    \ new single successor B\n   and the route to N stays in PASSIVE state.\n    \
    \  D receives the REPLY and can transition out of ACTIVE state\n   since it received\
    \ replies from all its neighbors.\n      D now has a viable path to N through\
    \ C.\n      D selects C as its successor to reach node N with a cost of 4.\n \
    \  Notice that nodes A and B were not involved in the recalculation\n   since\
    \ they were not affected by the change.\n   Let's consider the situation in Figure\
    \ 4, where Feasible Successors\n   may not exist.  If the link between node A\
    \ and B fails, B goes into\n   ACTIVE state for destination N since it has no\
    \ Feasible Successors.\n   Node B sends a QUERY to node C.  C has no Feasible\
    \ Successors, so it\n   goes active for destination N; and since C has no neighbors,\
    \ it\n   replies to the QUERY, deletes the destination, and returns to the\n \
    \  PASSIVE state for the unreachable route.  As C removes the (now\n   unreachable)\
    \ destination from its table, C sends REPLY to its old\n   successor.  B receives\
    \ this REPLY from C, and determines this is the\n   last REPLY it is waiting on\
    \ before determining what the new state of\n   the route should be; on receiving\
    \ this REPLY, B deletes the route to\n   N from its routing table.\n   Since B\
    \ was the originator of the initial QUERY, it does not have to\n   send a REPLY\
    \ to its old successor (it would not be able to any ways,\n   because the link\
    \ to its old successor is down).  Note that nodes A\n   and D were not involved\
    \ in the recalculation since their successors\n   were not affected.\n       \
    \   N                                N\n          |                          \
    \      |\n       (1)A ---<--- B(2)                   A ------- B   Q\n       \
    \   |         |                      |         |   |^      ^\n          ^    \
    \     ^                      ^         |   v|      |\n          |         |  \
    \                    |         |      |    |\n       (2)D         C(3)       \
    \            D         C     ACK   R\n        Figure 4: No Feasible Successors\
    \ When Link between A and B Fails\n"
- title: 4.  EIGRP Packets
  contents:
  - "4.  EIGRP Packets\n   EIGRP uses five different packet types to handle session\
    \ management\n   and pass DUAL Message types:\n       HELLO Packets (includes\
    \ ACK)\n       QUERY Packets (includes SIA-Query)\n       REPLY Packets (includes\
    \ SIA-Reply)\n       REQUEST Packets\n       UPDATE Packets\n   EIGRP packets\
    \ are directly encapsulated into a network-layer\n   protocol, such as IPv4 or\
    \ IPv6.  While EIGRP is capable of using\n   additional encapsulation (such as\
    \ AppleTalk, IPX, etc.) no further\n   encapsulation is specified in this document.\n\
    \   Support for network-layer protocol fragmentation is not supported,\n   and\
    \ EIGRP will attempt to avoid a maximum size packets that exceed\n   the interface\
    \ MTU by sending multiple packets that are less than or\n   equal to MTU-sized\
    \ packets.\n   Each packet transmitted will use either multicast or unicast network-\n\
    \   layer destination addresses.  When multicast addresses are used, a\n   mapping\
    \ for the data link multicast address (when available) must be\n   provided. \
    \ The source address will be set to the address of the\n   sending interface,\
    \ if applicable.\n   The following network-layer multicast addresses and associated\
    \ data\n   link multicast addresses:\n      224.0.0.10 for IPv4 \"EIGRP Routers\"\
    \ [13]\n      FF02:0:0:0:0:0:0:A for IPv6 \"EIGRP Routers\" [14]\n   They will\
    \ be used on multicast-capable media and will be media\n   independent for unicast\
    \ addresses.  Network-layer addresses will be\n   used and the mapping to media\
    \ addresses will be achieved by the\n   native protocol mechanisms.\n"
- title: 4.1.  UPDATE Packets
  contents:
  - "4.1.  UPDATE Packets\n   UPDATE packets carry the DUAL UPDATE message type and\
    \ are used to\n   convey information about destinations and the reachability of\
    \ those\n   destinations.  When a new neighbor is discovered, unicast UPDATE\n\
    \   packets are used to transmit a full table to the new neighbor, so the\n  \
    \ neighbor can build up its topology table.  In normal operation (other\n   than\
    \ neighbor startup such as a link cost changes), UPDATE packets\n   are multicast.\
    \  UPDATE packets are always transmitted reliably.  Each\n   TLV destination will\
    \ be processed individually through the DUAL FSM.\n"
- title: 4.2.  QUERY Packets
  contents:
  - "4.2.  QUERY Packets\n   A QUERY packet carries the DUAL QUERY message type and\
    \ is sent by a\n   router to advertise that a route is in ACTIVE state and the\n\
    \   originator is requesting alternate path information from its\n   neighbors.\
    \  An infinite metric is encoded by setting the delay part\n   of the metric to\
    \ its maximum value.\n   If there is a topology change that causes multiple destinations\
    \ to be\n   marked ACTIVE, EIGRP will build one or more QUERY packets for all\n\
    \   destinations present.  The state of each route is recorded\n   individually,\
    \ so a responding QUERY or REPLY need not contain all the\n   same destinations\
    \ in a single packet.  Since EIGRP uses a reliable\n   transport mechanism, route\
    \ QUERY packets are also guaranteed be\n   reliably delivered.\n   When a QUERY\
    \ packet is received, each destination will trigger a DUAL\n   event, and the\
    \ state machine will run individually for each route.\n   Once the entire original\
    \ QUERY packet is processed, then a REPLY or\n   SIA-REPLY will be sent with the\
    \ latest information.\n"
- title: 4.3.  REPLY Packets
  contents:
  - "4.3.  REPLY Packets\n   A REPLY packet carries the DUAL REPLY message type and\
    \ will be sent\n   in response to a QUERY or SIA-QUERY packet.  The REPLY packet\
    \ will\n   include a TLV for each destination and the associated vector metric\n\
    \   in its own topology table.\n   The REPLY packet is sent after the entire received\
    \ QUERY packet is\n   processed.  When a REPLY packet is received, there is no\
    \ reason to\n   process the packet before an acknowledgment is sent.  Therefore,\
    \ an\n   acknowledgment is sent immediately and then the packet is processed.\n\
    \   The sending of the acknowledgment is accomplished either by sending\n   an\
    \ ACK packet or by piggybacking the acknowledgment onto another\n   packet already\
    \ being transmitted.\n   Each TLV destination will be processed individually through\
    \ the DUAL\n   FSM.  When a QUERY is received for a route that doesn't exist in\
    \ our\n   topology table, a REPLY with an infinite metric is sent and an entry\n\
    \   in the topology table is added with the metric in the QUERY if the\n   metric\
    \ is not an infinite value.\n   If a REPLY for a designation not in the Active\
    \ state, or not in the\n   topology table, EIGRP will acknowledge the packet and\
    \ discard the\n   REPLY.\n"
- title: 4.4.  Exception Handling
  contents:
  - '4.4.  Exception Handling

    '
- title: 4.4.1.  Active Duration (SIA)
  contents:
  - "4.4.1.  Active Duration (SIA)\n   When an EIGRP router transitions to ACTIVE\
    \ state for a particular\n   destination, a QUERY is sent to a neighbor and the\
    \ ACTIVE timer is\n   started to limit the amount of time a destination may remain\
    \ in an\n   ACTIVE state.\n   A route is regarded as SIA when it does not receive\
    \ a REPLY within a\n   preset time.  This time interval is broken into two equal\
    \ periods\n   following the QUERY, and up to three additional \"busy\" periods\
    \ in\n   which an SIA-QUERY packet is sent for the destination.\n   This process\
    \ is begun when a router sends a QUERY to its neighbor.\n   After one-half the\
    \ SIA time interval (default implementation is 90\n   seconds), the router will\
    \ send an SIA-QUERY; this must be replied to\n   with either a REPLY or SIA-REPLY.\
    \  Any neighbor that fails to send\n   either a REPLY or SIA-REPLY with-in one-half\
    \ the SIA interval will\n   result in the neighbor being deemed to be \"stuck\"\
    \ in the active\n   state.\n   Cisco also limits the number of SIA-REPLY messages\
    \ allowed to three.\n   Once the timeout occurs after the third SIA-REPLY with\
    \ the neighbor\n   remaining in an ACTIVE state (as noted in the SIA-Reply message),\
    \ the\n   neighbor being deemed to be \"stuck\" in the active state.\n   If the\
    \ SIA state is declared, DUAL may take one of two actions;\n      a) Delete the\
    \ route from that neighbor, acting as if the neighbor\n         had responded\
    \ with an unreachable REPLY message from the\n         neighbor.\n      b) Delete\
    \ all routes from that neighbor and reset the adjacency\n         with that neighbor,\
    \ acting as if the neighbor had responded\n         with an unreachable message\
    \ for all routes.\n   Implementation note: Cisco currently implements option (b).\n"
- title: 4.4.1.1.  SIA-QUERY
  contents:
  - "4.4.1.1.  SIA-QUERY\n   When a QUERY is still outstanding and awaiting a REPLY\
    \ from a\n   neighbor, there is insufficient information to determine why a REPLY\n\
    \   has not been received.  A lost packet, congestion on the link, or a\n   slow\
    \ neighbor could cause a lack of REPLY from a downstream neighbor.\n   In order\
    \ to try to ascertain if the neighboring device is still\n   attempting to converge\
    \ on the active route, EIGRP may send an SIA-\n   QUERY packet to the active neighbor(s).\
    \  This enables an EIGRP router\n   to determine if there is a communication issue\
    \ with the neighbor or\n   if it is simply still attempting to converge with downstream\
    \ routers.\n   By sending an SIA-QUERY, the originating router may extend the\n\
    \   effective active time by resetting the ACTIVE timer that has been\n   previously\
    \ set, thus allowing convergence to continue so long as\n   neighbor devices successfully\
    \ communicate that convergence is still\n   underway.\n   The SIA-QUERY packet\
    \ SHOULD be sent on a per-destination basis at\n   one-half of the ACTIVE timeout\
    \ period.  Up to three SIA-QUERY packets\n   for a specific destination may be\
    \ sent, each at a value of one-half\n   the ACTIVE time, so long as each are successfully\
    \ acknowledged and\n   met with an SIA-REPLY.\n   Upon receipt of an SIA-QUERY\
    \ packet, an EIGRP router should first\n   send an ACK and then continue to process\
    \ the SIA-QUERY information.\n   The QUERY is sent on a per-destination basis\
    \ at approximately one-\n   half the active time.\n   If the EIGRP router is still\
    \ active for the destination specified in\n   the SIA-QUERY, the router should\
    \ respond to the originator with the\n   SIA-REPLY indicating that active processing\
    \ for this destination is\n   still underway by setting the ACTIVE flag in the\
    \ packet upon\n   response.\n   If the router receives an SIA-QUERY referencing\
    \ a destination for\n   which it has not received the original QUERY, the router\
    \ should treat\n   the packet as though it was a standard QUERY:\n      1) Acknowledge\
    \ the receipt of the packet\n      2) Send a REPLY if a successor exists\n   \
    \   3) If the SIA-QUERY is from the successor, transition to the\n         ACTIVE\
    \ state if and only if a Feasibility Condition check fails\n         and send\
    \ an SIA-REPLY with the ACTIVE bit set\n"
- title: 4.4.1.2.  SIA-REPLY
  contents:
  - "4.4.1.2.  SIA-REPLY\n   An SIA-REPLY packet is the corresponding response upon\
    \ receipt of an\n   SIA-QUERY from an EIGRP neighbor.  The SIA-REPLY packet will\
    \ include\n   a TLV for each destination and the associated vector metric in the\n\
    \   topology table.  The SIA-REPLY packet is sent after the entire\n   received\
    \ SIA-QUERY packet is processed.\n   If the EIGRP router is still ACTIVE for a\
    \ destination, the SIA-REPLY\n   packet will be sent with the ACTIVE bit set.\
    \  This confirms for the\n   neighbor device that the SIA-QUERY packet has been\
    \ processed by DUAL\n   and that the router is still attempting to resolve a loop-free\
    \ path\n   (likely awaiting responses to its own QUERY to downstream neighbors).\n\
    \   The SIA-REPLY informs the recipient that convergence is complete or\n   still\
    \ ongoing; it is an explicit notification that the router is\n   still actively\
    \ engaged in the convergence process.  This allows the\n   device that sent the\
    \ SIA-QUERY to determine whether it should\n   continue to allow the routes that\
    \ are not converged to be in the\n   ACTIVE state or if it should reset the neighbor\
    \ relationship and\n   flush all routes through this neighbor.\n"
- title: 5. EIGRP Operation
  contents:
  - "5. EIGRP Operation\n   EIGRP has four basic components:\n        o Finite State\
    \ Machine\n        o Reliable Transport Protocol\n        o Neighbor Discovery/Recovery\n\
    \        o Route Management\n"
- title: 5.1.  Finite State Machine
  contents:
  - "5.1.  Finite State Machine\n   The detail of DUAL, the State Machine used by\
    \ EIGRP, is covered in\n   Section 3.5.\n"
- title: 5.2.  Reliable Transport Protocol
  contents:
  - "5.2.  Reliable Transport Protocol\n   The reliable transport is responsible for\
    \ guaranteed, ordered\n   delivery of EIGRP packets to all neighbors.  It supports\
    \ intermixed\n   transmission of multicast and unicast packets.  Some EIGRP packets\n\
    \   must be transmitted reliably and others need not.  For efficiency,\n   reliability\
    \ is provided only when necessary.\n   For example, on a multi-access network\
    \ that has multicast\n   capabilities, such as Ethernet, it is not necessary to\
    \ send HELLOs\n   reliably to all neighbors individually.  EIGRP sends a single\n\
    \   multicast HELLO with an indication in the packet informing the\n   receivers\
    \ that the packet need not be acknowledged.  Other types of\n   packets, such\
    \ as UPDATE packets, require acknowledgment and this is\n   indicated in the packet.\
    \  The reliable transport has a provision to\n   send multicast packets quickly\
    \ when there are unacknowledged packets\n   pending.  This helps ensure that convergence\
    \ time remains low in the\n   presence of varying speed links.\n   DUAL assumes\
    \ there is lossless communication between devices and thus\n   must depend on\
    \ the transport protocol to guarantee that messages are\n   transmitted reliably.\
    \  EIGRP implements the reliable transport\n   protocol to ensure ordered delivery\
    \ and acknowledgment of any\n   messages requiring reliable transmission.  State\
    \ variables such as a\n   received sequence number, acknowledgment number, and\
    \ transmission\n   queues MUST be maintained on a per-neighbor basis.\n   The\
    \ following sequence number rules must be met for the EIGRP\n   reliable transport\
    \ protocol to work correctly:\n      o  A sender of a packet includes its global\
    \ sequence number in the\n         sequence number field of the fixed header.\
    \  The sequence number\n         wraps around to one when the maximum value is\
    \ exceeded\n         (sequence number zero is reserved for unreliable transmission).\n\
    \         The sender includes the receivers sequence number in the\n         acknowledgment\
    \ number field of the fixed header.\n      o  Any packets that do not require\
    \ acknowledgment must be sent\n         with a sequence number of 0.\n      o\
    \  Any packet that has an acknowledgment number of 0 indicates\n         that\
    \ sender is not expecting to explicitly acknowledge\n         delivery.  Otherwise,\
    \ it is acknowledging a single packet.\n      o  Packets that are network-layer\
    \ multicast must contain\n         acknowledgment number of 0.\n   When a router\
    \ transmits a packet, it increments its sequence number\n   and marks the packet\
    \ as requiring acknowledgment by all neighbors on\n   the interface for which\
    \ the packet is sent.  When individual\n   acknowledgments are unicast addressed\
    \ by the receivers to the sender\n   with the acknowledgment number equal to the\
    \ packets sequence number,\n   the sender SHALL clear the pending acknowledgment\
    \ requirement for the\n   packet from the respective neighbor.\n   If the required\
    \ acknowledgment is not received for the packet, it\n   MUST be retransmitted.\
    \  Retransmissions will occur for a maximum of 5\n   seconds.  This retransmission\
    \ for each packet is tried 16 times,\n   after which, if there is no ACK, the\
    \ neighbor relationship is reset\n   with the peer that didn't send the ACK.\n\
    \   The protocol has no explicit windowing support.  A receiver will\n   acknowledge\
    \ each packet individually and will drop packets that are\n   received out of\
    \ order.\n   Implementation note: The exception to this occurs if a duplicate\n\
    \   packet is received, and the acknowledgment for the original packet\n   has\
    \ been scheduled for transmission, but not yet sent.  In this case,\n   EIGRP\
    \ will not send an acknowledgment for the duplicate packet, and\n   the queued\
    \ acknowledgment will acknowledge both the original and\n   duplicate packet.\n\
    \   Duplicate packets are also discarded upon receipt.  Acknowledgments\n   are\
    \ not accumulative.  Therefore, an ACK with a non-zero sequence\n   number acknowledges\
    \ a single packet.\n   There are situations when multicast and unicast packets\
    \ are\n   transmitted close together on multi-access broadcast-capable\n   networks.\
    \  The reliable transport mechanism MUST ensure that all\n   multicasts are transmitted\
    \ in order and not mix the order among\n   unicast and multicast packets.  The\
    \ reliable transport provides a\n   mechanism to deliver multicast packets in\
    \ order to some receivers\n   quickly, while some receivers have not yet received\
    \ all unicast or\n   previously sent multicast packets.  The SEQUENCE_TYPE TLV\
    \ in HELLO\n   packets achieves this.  This will be explained in more detail in\
    \ this\n   section.\n   Figure 5 illustrates the reliable transport protocol on\
    \ point-to-\n   point links.  There are two scenarios that may occur: an UPDATE-\n\
    \   initiated packet exchange or a QUERY-initiated packet exchange.\n   This example\
    \ will assume no packet loss.\n"
- title: Router A                          Router B
  contents:
  - "Router A                          Router B\n                An Example UPDATE\
    \ Exchange\n                                 <----------------\n             \
    \                    UPDATE (multicast)\n"
- title: A receives packet                SEQ=100, ACK=0
  contents:
  - "A receives packet                SEQ=100, ACK=0\n                           \
    \      Add packet to A's retransmit list\n"
- title: '---------------->'
  contents:
  - '---------------->

    '
- title: ACK (unicast)
  contents:
  - 'ACK (unicast)

    '
- title: SEQ=0, ACK=100                   Receive ACK
  contents:
  - 'SEQ=0, ACK=100                   Receive ACK

    '
- title: Process UPDATE                   Delete packet from A's retransmit list
  contents:
  - "Process UPDATE                   Delete packet from A's retransmit list\n   \
    \             An Example QUERY Exchange\n                                 <----------------\n\
    \                                 QUERY (multicast)\n"
- title: A receives packet                SEQ=101, ACK=0
  contents:
  - 'A receives packet                SEQ=101, ACK=0

    '
- title: Process QUERY                    Add packet to A's retransmit list
  contents:
  - 'Process QUERY                    Add packet to A''s retransmit list

    '
- title: '---------------->'
  contents:
  - '---------------->

    '
- title: REPLY (unicast)
  contents:
  - 'REPLY (unicast)

    '
- title: SEQ=201, ACK=101                 Process ACK
  contents:
  - "SEQ=201, ACK=101                 Process ACK\n                              \
    \   Delete packet from A's retransmit\n"
- title: list
  contents:
  - "list\n                                 Process REPLY packet\n               \
    \                  <----------------\n                                 ACK (unicast)\n"
- title: A receives packet                SEQ=0, ACK=201
  contents:
  - "A receives packet                SEQ=0, ACK=201\n       Figure 5: Reliable Transfer\
    \ on Point-to-Point Links\n   The UPDATE exchange sequence requires UPDATE packets\
    \ sent to be\n   delivered reliably.  The UPDATE packet transmitted contains a\n\
    \   sequence number that is acknowledged by a receipt of an ACK packet.\n   If\
    \ the UPDATE or the ACK packet is lost on the network, the UPDATE\n   packet will\
    \ be retransmitted.\n   This example will assume there is heavy packet loss on\
    \ a network.\n"
- title: Router A                           Router B
  contents:
  - "Router A                           Router B\n                               \
    \  <----------------\n                                 UPDATE (multicast)\n"
- title: A receives packet                SEQ=100, ACK=0
  contents:
  - "A receives packet                SEQ=100, ACK=0\n                           \
    \      Add packet to A's retransmit list\n"
- title: '---------------->'
  contents:
  - '---------------->

    '
- title: ACK (unicast)
  contents:
  - 'ACK (unicast)

    '
- title: SEQ=0, ACK=100                   Receive ACK
  contents:
  - 'SEQ=0, ACK=100                   Receive ACK

    '
- title: Process UPDATE                   Delete packet from A's retransmit list
  contents:
  - "Process UPDATE                   Delete packet from A's retransmit list\n   \
    \                              <--/LOST/--------------\n                     \
    \            UPDATE (multicast)\n                                 SEQ=101, ACK=0\n\
    \                                 Add packet to A's retransmit list\n        \
    \                         Retransmit Timer Expires\n                         \
    \        <----------------\n                                 Retransmit UPDATE\
    \ (unicast)\n                                 SEQ=101, ACK=0\n               \
    \                  Keep packet on A's retransmit list\n"
- title: '---------------->'
  contents:
  - '---------------->

    '
- title: ACK (unicast)
  contents:
  - 'ACK (unicast)

    '
- title: SEQ=0, ACK=101                   Receive ACK
  contents:
  - 'SEQ=0, ACK=101                   Receive ACK

    '
- title: Process UPDATE                   Delete packet from A's retransmit list
  contents:
  - "Process UPDATE                   Delete packet from A's retransmit list\n   \
    \       Figure 6: Reliable Transfer on Lossy Point-to-Point Links\n   Reliable\
    \ delivery on multi-access LANs works in a similar fashion to\n   point-to-point\
    \ links.  The initial packet is always multicast and\n   subsequent retransmissions\
    \ are unicast addressed.  The\n   acknowledgments sent are always unicast addressed.\
    \  Figure 7 shows an\n   example with four routers on an Ethernet.\n         \
    \  Router B -----------+\n                               |\n           Router\
    \ C -----------+------------ Router A\n                               |\n    \
    \       Router D -----------+\n                        An Example UPDATE Exchange\n\
    \                                  <----------------\n                       \
    \           A send UPDATE (multicast)\n                                  SEQ=100,\
    \ ACK=0\n                                  Add packet to B's retransmit list\n\
    \                                  Add packet to C's retransmit list\n       \
    \                           Add packet to D's retransmit list\n"
- title: '---------------->'
  contents:
  - '---------------->

    '
- title: B sends ACK (unicast)
  contents:
  - 'B sends ACK (unicast)

    '
- title: SEQ=0, ACK=100                    Receive ACK
  contents:
  - 'SEQ=0, ACK=100                    Receive ACK

    '
- title: Process UPDATE                    Delete packet from B's retransmit list
  contents:
  - 'Process UPDATE                    Delete packet from B''s retransmit list

    '
- title: '---------------->'
  contents:
  - '---------------->

    '
- title: C sends ACK (unicast)
  contents:
  - 'C sends ACK (unicast)

    '
- title: SEQ=0, ACK=100                    Receive ACK
  contents:
  - 'SEQ=0, ACK=100                    Receive ACK

    '
- title: Process UPDATE                    Delete packet from C's retransmit list
  contents:
  - 'Process UPDATE                    Delete packet from C''s retransmit list

    '
- title: '---------------->'
  contents:
  - '---------------->

    '
- title: D sends ACK (unicast)
  contents:
  - 'D sends ACK (unicast)

    '
- title: SEQ=0, ACK=100                    Receive ACK
  contents:
  - 'SEQ=0, ACK=100                    Receive ACK

    '
- title: Process UPDATE                    Delete packet from D's retransmit list
  contents:
  - "Process UPDATE                    Delete packet from D's retransmit list\n  \
    \                       An Example QUERY Exchange\n                          \
    \        <----------------\n                                  A sends UPDATE (multicast)\n\
    \                                  SEQ=101, ACK=0\n                          \
    \        Add packet to B's retransmit list\n                                 \
    \ Add packet to C's retransmit list\n                                  Add packet\
    \ to D's retransmit list\n"
- title: '---------------->'
  contents:
  - '---------------->

    '
- title: B sends REPLY (unicast)           <----------------
  contents:
  - 'B sends REPLY (unicast)           <----------------

    '
- title: SEQ=511, ACK=101                  A sends ACK (unicast to B)
  contents:
  - 'SEQ=511, ACK=101                  A sends ACK (unicast to B)

    '
- title: Process UPDATE                    SEQ=0, ACK=511
  contents:
  - "Process UPDATE                    SEQ=0, ACK=511\n                          \
    \        Delete packet from B's retransmit list\n"
- title: '---------------->'
  contents:
  - '---------------->

    '
- title: C sends REPLY (unicast)           <----------------
  contents:
  - 'C sends REPLY (unicast)           <----------------

    '
- title: SEQ=200, ACK=101                  A sends ACK (unicast to C)
  contents:
  - 'SEQ=200, ACK=101                  A sends ACK (unicast to C)

    '
- title: Process UPDATE                    SEQ=0, ACK=200
  contents:
  - "Process UPDATE                    SEQ=0, ACK=200\n                          \
    \        Delete packet from C's retransmit list\n"
- title: '---------------->'
  contents:
  - '---------------->

    '
- title: D sends REPLY (unicast)           <----------------
  contents:
  - 'D sends REPLY (unicast)           <----------------

    '
- title: SEQ=11, ACK=101                   A sends ACK (unicast to D)
  contents:
  - 'SEQ=11, ACK=101                   A sends ACK (unicast to D)

    '
- title: Process UPDATE                    SEQ=0, ACK=11
  contents:
  - "Process UPDATE                    SEQ=0, ACK=11\n                           \
    \       Delete packet from D's retransmit list\n         Figure 7: Reliable Transfer\
    \ on Multi-Access Links\n   And finally, a situation where numerous multicast\
    \ and unicast packets\n   are sent close together in a multi-access environment\
    \ is illustrated\n   in Figure 8.\n        Router B -----------+\n           \
    \                 |\n        Router C -----------+------------ Router A\n    \
    \                        |\n        Router D -----------+\n                  \
    \              <----------------\n                                A sends UPDATE\
    \ (multicast)\n                                SEQ=100, ACK=0\n"
- title: '---------------/LOST/->         Add packet to B''s retransmit list'
  contents:
  - '---------------/LOST/->         Add packet to B''s retransmit list

    '
- title: B sends ACK (unicast)           Add packet to C's retransmit list
  contents:
  - 'B sends ACK (unicast)           Add packet to C''s retransmit list

    '
- title: SEQ=0, ACK=100                  Add packet to D's retransmit list
  contents:
  - 'SEQ=0, ACK=100                  Add packet to D''s retransmit list

    '
- title: '---------------->'
  contents:
  - '---------------->

    '
- title: C sends ACK (unicast)
  contents:
  - 'C sends ACK (unicast)

    '
- title: SEQ=0, ACK=100                  Delete packet from C's retransmit list
  contents:
  - 'SEQ=0, ACK=100                  Delete packet from C''s retransmit list

    '
- title: '---------------->'
  contents:
  - '---------------->

    '
- title: D sends ACK (unicast)
  contents:
  - 'D sends ACK (unicast)

    '
- title: SEQ=0, ACK=100                  Delete packet from D's retransmit list
  contents:
  - "SEQ=0, ACK=100                  Delete packet from D's retransmit list\n    \
    \                            <----------------\n                             \
    \   A sends HELLO (multicast)\n                                SEQ=0, ACK=0, SEQ_TLV\
    \ listing B\n"
- title: B receives Hello, does not set CR-Mode
  contents:
  - 'B receives Hello, does not set CR-Mode

    '
- title: C receives Hello, sets CR-Mode
  contents:
  - 'C receives Hello, sets CR-Mode

    '
- title: D receives Hello, sets CR-Mode
  contents:
  - "D receives Hello, sets CR-Mode\n                                <----------------\n\
    \                                A sends UPDATE (multicast)\n                \
    \                SEQ=101, ACK=0, CR-Flag=1\n"
- title: '---------------/LOST/->         Add packet to B''s retransmit list'
  contents:
  - '---------------/LOST/->         Add packet to B''s retransmit list

    '
- title: B sends ACK (unicast)           Add packet to C's retransmit list
  contents:
  - 'B sends ACK (unicast)           Add packet to C''s retransmit list

    '
- title: SEQ=0, ACK=100                  Add packet to D's retransmit list
  contents:
  - 'SEQ=0, ACK=100                  Add packet to D''s retransmit list

    '
- title: B ignores UPDATE 101 because the CR-Flag
  contents:
  - 'B ignores UPDATE 101 because the CR-Flag

    '
- title: is set and it is not in CR-Mode
  contents:
  - 'is set and it is not in CR-Mode

    '
- title: '---------------->'
  contents:
  - '---------------->

    '
- title: C sends ACK (unicast)
  contents:
  - 'C sends ACK (unicast)

    '
- title: SEQ=0, ACK=101
  contents:
  - 'SEQ=0, ACK=101

    '
- title: '---------------->'
  contents:
  - '---------------->

    '
- title: D sends ACK (unicast)
  contents:
  - 'D sends ACK (unicast)

    '
- title: SEQ=0, ACK=101
  contents:
  - "SEQ=0, ACK=101\n                                <----------------\n         \
    \                       A resends UPDATE (unicast to B)\n                    \
    \            SEQ=100, ACK=0\n"
- title: B packet duplicate
  contents:
  - 'B packet duplicate

    '
- title: '--------------->'
  contents:
  - '--------------->

    '
- title: B sends ACK (unicast)           A removes packet from retransmit list
  contents:
  - 'B sends ACK (unicast)           A removes packet from retransmit list

    '
- title: SEQ=0, ACK=100
  contents:
  - "SEQ=0, ACK=100\n                                <----------------\n         \
    \                       A resends UPDATE (unicast to B)\n                    \
    \            SEQ=101, ACK=0\n"
- title: '--------------->'
  contents:
  - '--------------->

    '
- title: B sends ACK (unicast)            A removes packet from retransmit list
  contents:
  - 'B sends ACK (unicast)            A removes packet from retransmit list

    '
- title: SEQ=0, ACK=101
  contents:
  - "SEQ=0, ACK=101\n         Figure 8: Reliable Transfer on Multi-Access Links\n\
    \                      with Conditional Receive\n   Initially, Router A sends\
    \ a multicast addressed UPDATE packet on the\n   LAN.  B and C receive it and\
    \ send acknowledgments.  Router B receives\n   the UPDATE, but the acknowledgment\
    \ sent is lost on the network.\n   Before the retransmission timer for Router\
    \ B's packet expires, there\n   is an event that causes a new multicast addressed\
    \ UPDATE to be sent.\n   Router A detects that there is at least one neighbor\
    \ on the interface\n   with a full queue.  Therefore, it MUST signal that neighbor\
    \ not to\n   receive the next packet or it would receive the retransmitted packet\n\
    \   out of order.  If all neighbors on the interface have a full queue,\n   then\
    \ EIGRP should reschedule the transmission of the UPDATE once the\n   queues are\
    \ no longer full.\n   Router A builds a HELLO packet with a SEQUENCE_TYPE TLV\
    \ indicating\n   all the neighbors that have full queues.  In this case, the only\n\
    \   neighbor address in the list is Router B.  The HELLO packet is sent\n   via\
    \ multicast unreliably out the interface.\n   Routers C and D process the SEQUENCE_TYPE\
    \ TLV by looking for their\n   own addresses in the list.  If not found, they\
    \ put themselves in CR-\n   Mode.\n   Router B does not find its address in the\
    \ SEQUENCE TLV peer list, so\n   it enters CR-Mode.  Packets received by Router\
    \ B with the CR-Flag\n   MUST be discarded and not acknowledged.\n   Later, Router\
    \ A will unicast transmit both packets 100 and 101\n   directly to Router B. \
    \ Router B already has 100, so it discards and\n   acknowledges it.\n   Router\
    \ B then accepts and acknowledges packet 101.  Once an\n   acknowledgment is received,\
    \ Router A can remove both packets from\n   Router B's transmission list.\n"
- title: 5.2.1.  Bandwidth on Low-Speed Links
  contents:
  - "5.2.1.  Bandwidth on Low-Speed Links\n   By default, EIGRP limits itself to using\
    \ no more than 50% of the\n   bandwidth reported by an interface when determining\
    \ packet-pacing\n   intervals.  If the bandwidth does not match the physical bandwidth\n\
    \   (the network architect may have put in an artificially low or high\n   bandwidth\
    \ value to influence routing decisions), EIGRP may:\n      1. Generate more traffic\
    \ than the interface can handle, possibly\n         causing drops, thereby impairing\
    \ EIGRP performance.\n      2. Generate a lot of EIGRP traffic that could result\
    \ in little\n         bandwidth remaining for user data.  To control such\n  \
    \       transmissions, an interface-pacing timer is defined for the\n        \
    \ interfaces on which EIGRP is enabled.  When a pacing timer\n         expires,\
    \ a packet is transmitted out on that interface.\n"
- title: 5.3.  Neighbor Discovery/Recovery
  contents:
  - "5.3.  Neighbor Discovery/Recovery\n   Neighbor Discovery/Recovery is the process\
    \ that routers use to\n   dynamically learn of other routers on their directly\
    \ attached\n   networks.  Routers MUST also discover when their neighbors become\n\
    \   unreachable or inoperative.  This process is achieved with low\n   overhead\
    \ by periodically sending small HELLO packets.  As long as any\n   packets are\
    \ received from a neighbor, the router can determine that\n   neighbor is alive\
    \ and functioning.  Only after a neighbor router is\n   considered operational\
    \ can the neighboring routers exchange routing\n   information.\n"
- title: 5.3.1.  Neighbor Hold Time
  contents:
  - "5.3.1.  Neighbor Hold Time\n   Each router keeps state information about adjacent\
    \ neighbors.  When\n   newly discovered neighbors are learned the address, interface,\
    \ and\n   Hold Time of the neighbor is noted.  When a neighbor sends a HELLO,\n\
    \   it advertises its Hold Time.  The Hold Time is the amount of time a\n   router\
    \ treats a neighbor as reachable and operational.  In addition\n   to the HELLO\
    \ packet, if any packet is received within the Hold Time\n   period, then the\
    \ Hold Time period will be reset.  When the Hold Time\n   expires, DUAL is informed\
    \ of the topology change.\n"
- title: 5.3.2.  HELLO Packets
  contents:
  - "5.3.2.  HELLO Packets\n   When an EIGRP router is initialized, it will start\
    \ sending HELLO\n   packets out any interface on which EIGRP is enabled.  HELLO\
    \ packets,\n   when used for neighbor discovery, are normally sent multicast\n\
    \   addressed.  The HELLO packet will include the configured EIGRP metric\n  \
    \ K-values.  Two routers become neighbors only if the K-values are the\n   same.\
    \  This enforces that the metric usage is consistent throughout\n   the Internet.\
    \  Also included in the HELLO packet is a Hold Time\n   value.  This value indicates\
    \ to all receivers the length of time in\n   seconds that the neighbor is valid.\
    \  The default Hold Time will be\n   three times the HELLO interval.  HELLO packets\
    \ will be transmitted\n   every 5 seconds (by default).  There may be a configuration\
    \ command\n   that controls this value and therefore changes the Hold Time.  HELLO\n\
    \   packets are not transmitted reliably, so the sequence number should\n   be\
    \ set to 0.\n"
- title: 5.3.3.  UPDATE Packets
  contents:
  - "5.3.3.  UPDATE Packets\n   A router detects a new neighbor by receiving a HELLO\
    \ packet from a\n   neighbor not presently known.  To ensure unicast and multicast\
    \ packet\n   delivery, the detecting neighbor will send a unicast UPDATE packet\
    \ to\n   the new neighbor with no routing information (the NULL UPDATE\n   packet).\
    \  The initial NULL UPDATE packet sent MUST have the INIT-Flag\n   set and contain\
    \ no topology information.\n   Implementation note: The NULL UPDATE packet is\
    \ used to ensure\n   bidirectional UNICAST packet delivery as the NULL UPDATE\
    \ and the ACK\n   are both sent unicast.  Additional UPDATE packets cannot be\
    \ sent\n   until the initial NULL UPDATE packet is acknowledged.\n   The INIT-Flag\
    \ instructs the neighbor to advertise its routes, and it\n   is also useful when\
    \ a neighbor goes down and comes back up before the\n   router detects it went\
    \ down.  In this case, the neighbor needs new\n   routing information.  The INIT-Flag\
    \ informs the router to send it.\n   Implementation note: When a router sends\
    \ an UPDATE with the INIT-Flag\n   set, and without the Restart (RS) flag set\
    \ in the header, the\n   receiving neighbor must also send an UPDATE with the\
    \ INIT-Flag.\n   Failure to do so will result in a Cisco device posting a \"stuck\
    \ in\n   INIT state\" error and subsequent discards.\n"
- title: 5.3.4.  Initialization Sequence
  contents:
  - "5.3.4.  Initialization Sequence\n            Router A                       \
    \    Router B\n          (just booted)                    (up and running)\n \
    \       (1)---------------->\n             HELLO (multicast)           <----------------\
    \     (2)\n             SEQ=0, ACK=0                 HELLO (multicast)\n     \
    \                                     SEQ=0, ACK=0\n                         \
    \                <----------------     (3)\n                                 \
    \         UPDATE (unicast)\n                                          SEQ=10,\
    \ ACK=0, INIT\n        (4)---------------->              UPDATE 11 is queued\n\
    \             UPDATE (unicast)\n             SEQ=100, ACK=10, INIT       <----------------\
    \     (5)\n                                         UPDATE (unicast)\n       \
    \                                  SEQ=11, ACK=100\n                         \
    \                All UPDATES sent\n        (6)--------------/lost/->\n       \
    \      ACK (unicast)\n             SEQ=0, ACK=11\n                           \
    \              (5 seconds later)\n                                         <----------------\
    \     (7)\n             Duplicate received,         UPDATE (unicast)\n       \
    \      packet discarded            SEQ=11, ACK=100\n        (8)--------------->\n\
    \             ACK (unicast)\n             SEQ=0, ACK=11\n                    Figure\
    \ 9: Initialization Sequence\n   (1) Router A sends a multicast HELLO and Router\
    \ B discovers it.\n   (2) Router B sends an expedited HELLO and starts the process\
    \ of\n       sending its topology table to Router A.  In addition, Router B\n\
    \       sends the NULL UPDATE packet with the INIT-Flag.  The second\n       packet\
    \ is queued, but it cannot be sent until the first is\n       acknowledged.\n\
    \   (3) Router A receives the first UPDATE packet and processes it as a\n    \
    \   DUAL event.  If the UPDATE contains topology information, the\n       packet\
    \ will be processed and stored in a topology table.  Router\n       B sends its\
    \ first and only UPDATE packet with an accompanied ACK.\n   (4) Router B receives\
    \ UPDATE packet 100 from Router A.  Router B can\n       dequeue packet 10 from\
    \ A's transmission list since the UPDATE\n       acknowledged 10.  It can now\
    \ send UPDATE packet 11 and with an\n       acknowledgment of Router A's UPDATE.\n\
    \   (5) Router A receives the last UPDATE packet from Router B and\n       acknowledges\
    \ it.  The acknowledgment gets lost.\n   (6) Router B later retransmits the UPDATE\
    \ packet to Router A.\n   (7) Router A detects the duplicate and simply acknowledges\
    \ the\n       packet.  Router B dequeues packet 11 from A's transmission list,\n\
    \       and both routers are up and synchronized.\n"
- title: 5.3.5.  Neighbor Formation
  contents:
  - "5.3.5.  Neighbor Formation\n   To prevent packets from being sent to a neighbor\
    \ prior to verifying\n   multicast and unicast packet delivery is reliable, a\
    \ three-way\n   handshake is utilized.\n   During normal adjacency formation,\
    \ multicast HELLOs cause the EIGRP\n   process to place new neighbors into the\
    \ neighbor table.  Unicast\n   packets are then used to exchange known routing\
    \ information and\n   complete the neighbor relationship (Section 5.2).\n   To\
    \ prevent EIGRP from sending sequenced packets to neighbors that\n   fail to have\
    \ bidirectional unicast/multicast, or one neighbor\n   restarts while building\
    \ the relationship, EIGRP MUST place the newly\n   discovered neighbor in a \"\
    pending\" state as follows:\n      when Router A receives the first multicast\
    \ HELLO from Router B, it\n      places Router B in the pending state and transmits\
    \ a unicast\n      UPDATE containing no topology information and SHALL set the\n\
    \      initialization bit.  While Router B is in this state, A will send\n   \
    \   it neither a QUERY nor an UPDATE.  When Router A receives the\n      unicast\
    \ acknowledgment from Router B, it will change the state\n      from \"pending\"\
    \ to \"up\".\n"
- title: 5.3.6.  QUERY Packets during Neighbor Formation
  contents:
  - "5.3.6.  QUERY Packets during Neighbor Formation\n   As described above, during\
    \ the initial formation of the neighbor\n   relationship, EIGRP uses a form of\
    \ three-way handshake to verify both\n   unicast and multicast connectivity are\
    \ working successfully.  During\n   this period of neighbor creation, the new\
    \ neighbor is considered to\n   be in the pending state, and it is not eligible\
    \ to be included in the\n   convergence process.\n   Because of this, any QUERY\
    \ received by an EIGRP router would not\n   cause a QUERY to be sent to the new\
    \ (and pending) neighbor.  It would\n   perform the DUAL process without the new\
    \ peer in the conversation.\n   To do this, when a router in the process of establishing\
    \ a new\n   neighbor receives a QUERY from a fully established neighbor, it\n\
    \   performs the normal DUAL Feasible Successor check to determine\n   whether\
    \ it needs to REPLY with a valid path or whether it needs to\n   enter the ACTIVE\
    \ process on the prefix.\n   If it determines that it must go active, each fully\
    \ established\n   neighbor that participates in the convergence process will be\
    \ sent a\n   QUERY packet, and REPLY packets are expected from each.  Any pending\n\
    \   neighbor will not be expected to REPLY and will not be sent a QUERY\n   directly.\
    \  If it resides on an interface containing a mix of fully\n   established neighbors\
    \ and pending neighbors, it might receive the\n   QUERY, but it will not be expected\
    \ to REPLY to it.\n"
- title: 5.4.  Topology Table
  contents:
  - "5.4.  Topology Table\n   The topology table is populated by the Protocol-Dependent\
    \ Modules\n   (PDMs) (IPv4/IPv6), and it is acted upon by the DUAL finite state\n\
    \   machine.  Associated with each entry are the destination address, a\n   list\
    \ of neighbors that have advertised this destination, and the\n   metric associated\
    \ with the destination.  The metric is referred to as\n   the \"CD\".\n   The\
    \ CD is the best-advertised RD from all neighbors, plus the link\n   cost between\
    \ the receiving router and the neighbor.\n   The \"RD\" is the CD as advertised\
    \ by the Feasible Successor for the\n   destination.  In other words, the Computed\
    \ Distance, when sent by a\n   neighbor, is referred to as the \"Reported Distance\"\
    \ and is the metric\n   that the neighboring router uses to reach the destination\
    \ (its CD as\n   described above).\n   If the router is advertising a destination\
    \ route, it MUST be using\n   the route to forward packets; this is an important\
    \ rule that distance\n   vector protocols MUST follow.\n"
- title: 5.4.1.  Route Management
  contents:
  - "5.4.1.  Route Management\n   Within the topology table, EIGRP has the notion\
    \ of internal and\n   external routes.  Internal routes MUST be preferred over\
    \ external\n   routes, independent of the metric.  In practical terms, if an\n\
    \   internal route is received, the diffusing computation will be run\n   considering\
    \ only the internal routes.  Only when no internal routes\n   for a given destination\
    \ exist will EIGRP choose the successor from\n   the available external routes.\n"
- title: 5.4.1.1.  Internal Routes
  contents:
  - "5.4.1.1.  Internal Routes\n   Internal routes are destinations that have been\
    \ originated within the\n   same EIGRP AS.  Therefore, a directly attached network\
    \ that is\n   configured to run EIGRP is considered an internal route and is\n\
    \   propagated with this information throughout the network topology.\n   Internal\
    \ routes are tagged with the following information:\n      o Router ID of the\
    \ EIGRP router that originated the route.\n      o Configurable administrator\
    \ tag.\n"
- title: 5.4.1.2.  External Routes
  contents:
  - "5.4.1.2.  External Routes\n   External routes are destinations that have been\
    \ learned from another\n   source, such as a different routing protocol or static\
    \ route.  These\n   routes are marked individually with the identity of their\n\
    \   origination.  External routes are tagged with the following\n   information:\n\
    \      o Router ID of the EIGRP router that redistributed the route.\n      o\
    \ AS number where the destination resides.\n      o Configurable administrator\
    \ tag.\n      o Protocol ID of the external protocol.\n      o Metric from the\
    \ external protocol.\n      o Bit flags for default routing.\n   As an example,\
    \ suppose there is an AS with three border routers: BR1,\n   BR2, and BR3.  A\
    \ border router is one that runs more than one routing\n   protocol.  The AS uses\
    \ EIGRP as the routing protocol.  Two of the\n   border routers, BR1 and BR2,\
    \ also use Open Shortest Path First (OSPF)\n   [10] and the other, BR3, also uses\
    \ the Routing Information Protocol\n   (RIP).\n   Routes learned by one of the\
    \ OSPF border routers, BR1, can be\n   conditionally redistributed into EIGRP.\
    \  This means that EIGRP\n   running in BR1 advertises the OSPF routes within\
    \ its own AS.  When it\n   does so, it advertises the route and tags it as an\
    \ OSPF-learned route\n   with a metric equal to the routing table metric of the\
    \ OSPF route.\n   The router-id is set to BR1.  The EIGRP route propagates to\
    \ the other\n   border routers.\n   Let's say that BR3, the RIP border router,\
    \ also advertises the same\n   destinations as BR1.  Therefore, BR3, redistributes\
    \ the RIP routes\n   into the EIGRP AS.  BR2, then, has enough information to\
    \ determine\n   the AS entry point for the route, the original routing protocol\
    \ used,\n   and the metric.\n   Further, the network administrator could assign\
    \ tag values to\n   specific destinations when redistributing the route.  BR2\
    \ can utilize\n   any of this information to use the route or re-advertise it\
    \ back out\n   into OSPF.\n   Using EIGRP route tagging can give a network administrator\
    \ flexible\n   policy controls and help customize routing.  Route tagging is\n\
    \   particularly useful in transit ASes where EIGRP would typically\n   interact\
    \ with an inter-domain routing protocol that implements global\n   policies.\n"
- title: 5.4.2.  Split Horizon and Poison Reverse
  contents:
  - "5.4.2.  Split Horizon and Poison Reverse\n   In some circumstances, EIGRP will\
    \ suppress or poison QUERY and UPDATE\n   information to prevent routing loops\
    \ as changes propagate though the\n   network.\n   Within Cisco, the split horizon\
    \ rule suggests: \"Never advertise a\n   route out of the interface through which\
    \ it was learned\".  EIGRP\n   implements this to mean, \"if you have a successor\
    \ route to a\n   destination, never advertise the route out the interface on which\
    \ it\n   was learned\".\n   The poison reverse rule states: \"A route learned\
    \ through an interface\n   will be advertised as unreachable through that same\
    \ interface\".  As\n   with the case of split horizon, EIGRP applies this rule\
    \ only to\n   interfaces it is using for reaching the destination.  Routes learned\n\
    \   though interfaces that EIGRP is NOT using to reach the destination\n   may\
    \ have the route advertised out those interfaces.\n   In EIGRP, split horizon\
    \ suppresses a QUERY, where as poison reverse\n   advertises a destination as\
    \ unreachable.  This can occur for a\n   destination under any of the following\
    \ conditions:\n      o two routers are in startup or restart mode\n      o advertising\
    \ a topology table change\n      o sending a query\n"
- title: 5.4.2.1.  Startup Mode
  contents:
  - "5.4.2.1.  Startup Mode\n   When two routers first become neighbors, they exchange\
    \ topology\n   tables during startup mode.  For each destination a router receives\n\
    \   during startup mode, it advertises the same destination back to its\n   new\
    \ neighbor with a maximum metric (Poison Route).\n"
- title: 5.4.2.2.  Advertising Topology Table Change
  contents:
  - "5.4.2.2.  Advertising Topology Table Change\n   If a router uses a neighbor as\
    \ the successor for a given destination,\n   it will send an UPDATE for the destination\
    \ with a metric of infinity.\n"
- title: 5.4.2.3.  Sending a QUERY/UPDATE
  contents:
  - "5.4.2.3.  Sending a QUERY/UPDATE\n   In most cases, EIGRP follows normal split-horizon\
    \ rules.  When a\n   metric change is received from the successor via QUERY or\
    \ UPDATE that\n   causes the route to go ACTIVE, the router will send a QUERY\
    \ to\n   neighbors on all interfaces except the interface toward the\n   successor.\n\
    \   In other words, the router does not send the QUERY out of the inbound\n  \
    \ interface through which the information causing the route to go\n   ACTIVE was\
    \ received.\n   An exception to this can occur if a router receives a QUERY from\
    \ its\n   successor while already reacting to an event that did not cause it to\n\
    \   go ACTIVE, for example, a metric change from the successor that did\n   not\
    \ cause an ACTIVE transition, but was followed by the UPDATE/QUERY\n   that does\
    \ result the router to transition to ACTIVE.\n"
- title: 5.5.  EIGRP Metric Coefficients
  contents:
  - "5.5.  EIGRP Metric Coefficients\n   EIGRP allows for modification of the default\
    \ composite metric\n   calculation (see Section 5.6) through the use of coefficients\
    \ (K-\n   values).  This adjustment allows for per-deployment tuning of network\n\
    \   behavior.  Setting K-values up to 254 scales the impact of the scalar\n  \
    \ metric on the final composite metric.\n   EIGRP default coefficients have been\
    \ carefully selected to provide\n   optimal performance in most networks.  The\
    \ default K-values are as\n   follows:\n               K1 == K3 == 1\n       \
    \        K2 == K4 == K5 == 0\n               K6 == 0\n   If K5 is equal to 0,\
    \ then reliability quotient is defined to be 1.\n"
- title: 5.5.1.  Coefficients K1 and K2
  contents:
  - "5.5.1.  Coefficients K1 and K2\n   K1 is used to allow path selection to be based\
    \ on the bandwidth\n   available along the path.  EIGRP can use one of two variations\
    \ of\n   Throughput-based path selection.\n   o  Maximum Theoretical Bandwidth:\
    \ paths chosen based on the highest\n      reported bandwidth\n   o  Network Throughput:\
    \ paths chosen based on the highest \"available\"\n      bandwidth adjusted by\
    \ congestion-based effects (interface reported\n      load)\n   By default, EIGRP\
    \ computes the Throughput using the maximum\n   theoretical Throughput expressed\
    \ in picoseconds per kilobyte of data\n   sent.  This inversion results in a larger\
    \ number (more time)\n   ultimately generating a worse metric.\n   If K2 is used,\
    \ the effect of congestion as a measure of load reported\n   by the interface\
    \ will be used to simulate the \"available Throughput\"\n   by adjusting the maximum\
    \ Throughput.\n"
- title: 5.5.2.  Coefficient K3
  contents:
  - "5.5.2.  Coefficient K3\n   K3 is used to allow delay or latency-based path selection.\
    \  Latency\n   and delay are similar terms that refer to the amount of time it\
    \ takes\n   a bit to be transmitted to an adjacent neighbor.  EIGRP uses one-way-\n\
    \   based values either provided by the interface or computed as a factor\n  \
    \ of the link s bandwidth.\n"
- title: 5.5.3.  Coefficients K4 and K5
  contents:
  - "5.5.3.  Coefficients K4 and K5\n   K4 and K5 are used to allow for path selection\
    \ based on link quality\n   and packet loss.  Packet loss caused by network problems\
    \ results in\n   highly noticeable performance issues or Jitter with streaming\n\
    \   technologies, voice over IP, online gaming and videoconferencing, and\n  \
    \ will affect all other network applications to one degree or another.\n   Critical\
    \ services should pass with less than 1% packet loss.  Lower\n   priority packet\
    \ types might pass with less than 5% and then 10% for\n   the lowest of priority\
    \ of services.  The final metric can be weighted\n   based on the reported link\
    \ quality.\n   The handling of K5 is conditional.  If K5 is equal to 0, then\n\
    \   reliability quotient is defined to be 1.\n"
- title: 5.5.4.  Coefficient K6
  contents:
  - "5.5.4.  Coefficient K6\n   K6 has been introduced with Wide Metric support and\
    \ is used to allow\n   for Extended Attributes, which can be used to reflect in\
    \ a higher\n   aggregate metric than those having lower energy usage.  Currently\n\
    \   there are two Extended Attributes, Jitter and energy, defined in the\n   scope\
    \ of this document.\n"
- title: 5.5.4.1.  Jitter
  contents:
  - "5.5.4.1.  Jitter\n   Use of Jitter-based Path Selection results in a path calculation\
    \ with\n   the lowest reported Jitter.  Jitter is reported as the interval\n \
    \  between the longest and shortest packet delivery and is expressed in\n   microseconds.\
    \  Higher values result in a higher aggregate metric when\n   compared to those\
    \ having lower Jitter calculations.\n   Jitter is measured in microseconds and\
    \ is accumulated along the path,\n   with each hop using an averaged 3-second\
    \ period to smooth out the\n   metric change rate.\n   Presently, EIGRP does not\
    \ have the ability to measure Jitter, and, as\n   such, the default value will\
    \ be zero (0).  Performance-based\n   solutions such as PfR could be used to populate\
    \ this field.\n"
- title: 5.5.4.2.  Energy
  contents:
  - "5.5.4.2.  Energy\n   Use of Energy-based Path Selection results in paths with\
    \ the lowest\n   energy usage being selected in a loop-free and deterministic\
    \ manner.\n   The amount of energy used is accumulative and has results in a higher\n\
    \   aggregate metric than those having lower energy.\n   Presently, EIGRP does\
    \ not report energy usage, and as such the\n   default value will be zero (0).\n"
- title: 5.6.  EIGRP Metric Calculations
  contents:
  - '5.6.  EIGRP Metric Calculations

    '
- title: 5.6.1.  Classic Metrics
  contents:
  - "5.6.1.  Classic Metrics\n   The composite metric is based on bandwidth, delay,\
    \ load, and\n   reliability.  MTU is not an attribute for calculating the composite\n\
    \   metric, but carried in the vector metrics.\n   One of the original goals of\
    \ EIGRP was to offer and enhance routing\n   solutions for IGRP.  To achieve this,\
    \ EIGRP used the same composite\n   metric as IGRP, with the terms multiplied\
    \ by 256 to change the metric\n   from 24 bits to 32 bits.\n"
- title: 5.6.1.1.  Classic Composite Formulation
  contents:
  - "5.6.1.1.  Classic Composite Formulation\n   EIGRP calculates the composite metric\
    \ with the following formula:\n   metric = 256 * ({(K1*BW) + [(K2*BW)/(256-LOAD)]\
    \ + (K3*DELAY)} *\n            (K5/(REL+K4)))\n   In this formula, Bandwidth (BW)\
    \ is the lowest interface bandwidth\n   along the path, and delay (DELAY) is the\
    \ sum of all outbound\n   interface delays along the path.  Load (LOAD) and reliability\
    \ (REL)\n   values are expressed percentages with a value of 1 to 255.\n   Implementation\
    \ note: Cisco IOS routers display reliability as a\n   fraction of 255.  That\
    \ is, 255/255 is 100% reliability or a perfectly\n   stable link; a value of 229/255\
    \ represents a 90% reliable link.  Load\n   is a value between 1 and 255.  A load\
    \ of 255/255 indicates a\n   completely saturated link.  A load of 127/255 represents\
    \ a 50%\n   saturated link.  These values are not dynamically measured; they are\n\
    \   only measured at the time a link changes.\n   Bandwidth is the inverse minimum\
    \ bandwidth (in kbps) of the path in\n   bits per second scaled by a factor of\
    \ 10^7.  The formula for\n   bandwidth is as follows:\n                     (10^7)/BWmin\n\
    \   Implementation note: When converting the real bandwidth to the\n   composite\
    \ bandwidth, truncate before applying the scaling factor.\n   When converting\
    \ the composite bandwidth to the real bandwidth, apply\n   the scaling factor\
    \ before the division and only then truncate.\n   The delay is the sum of the\
    \ outgoing interface delay (in tens of\n   microseconds) to the destination. \
    \ A delay set to it maximum value\n   (hexadecimal 0xFFFFFFFF) indicates that\
    \ the network is unreachable.\n   The formula for delay is as follows:\n     \
    \                [sum of delays]\n   The default composite metric, adjusted for\
    \ scaling factors, for EIGRP\n   is:\n             metric = 256 * { [(10^7)/ BWmin]\
    \ + [sum of delays]}\n   Minimum Bandwidth (BWmin) is represented in kbps, and\
    \ the \"sum of\n   delays\" is represented in tens of microseconds.  The bandwidth\
    \ and\n   delay for an Ethernet interface are 10 Mbps and 1 ms, respectively.\n\
    \   The calculated EIGRP bandwidth (BW) metric is then:\n               256 *\
    \ (10^7)/BW = 256 * {(10^7)/10,000}\n                               = 256 * 1000\n\
    \                               = 256,000\n   And the calculated EIGRP delay metric\
    \ is then:\n            256 * sum of delay = 256 * 100 * 10 microseconds\n   \
    \                            = 25,600 (in tens of microseconds)\n"
- title: 5.6.1.2.  Cisco Interface Delay Compatibility
  contents:
  - "5.6.1.2.  Cisco Interface Delay Compatibility\n   For compatibility with Cisco\
    \ products, the following table shows the\n   times in nanoseconds EIGRP uses\
    \ for bandwidth and delay.\n   Bandwidth        Classic     Wide Metrics     Interface\n\
    \   (kbps)           Delay       Delay            Type\n   ---------------------------------------------------------\n\
    \   9               500000000   500000000         Tunnel\n   56              \
    \ 20000000    20000000         56 kbps\n   64               20000000    20000000\
    \         DS0\n   1544             20000000    20000000         T1\n   2048  \
    \           20000000    20000000         E1\n   10000             1000000    \
    \ 1000000         Ethernet\n   16000              630000      630000         TokRing16\n\
    \   45045            20000000    20000000         HSSI\n   100000            \
    \ 100000      100000         FDDI\n   100000             100000      100000  \
    \       FastEthernet\n   155000             100000      100000         ATM 155\
    \ Mbps\n   1000000             10000       10000         GigaEthernet\n   2000000\
    \             10000        5000         2 Gig\n   5000000             10000  \
    \      2000         5 Gig\n   10000000            10000        1000         10\
    \ Gig\n   20000000            10000          500        20 Gig\n   50000000  \
    \          10000          200        50 Gig\n   100000000           10000    \
    \      100        100 Gig\n   200000000           10000           50        200\
    \ Gig\n   500000000           10000           20        500 Gig\n"
- title: 5.6.2.  Wide Metrics
  contents:
  - "5.6.2.  Wide Metrics\n   To enable EIGRP to perform the path selection for interfaces\
    \ with\n   high bandwidths, both the EIGRP packet and composite metric formula\n\
    \   have been modified.  This change allows EIGRP to choose paths based\n   on\
    \ the computed time (measured in picoseconds) information takes to\n   travel\
    \ though the links.\n"
- title: 5.6.2.1.  Wide Metric Vectors
  contents:
  - "5.6.2.1.  Wide Metric Vectors\n   EIGRP uses five \"vector metrics\": minimum\
    \ Throughput, latency, load,\n   reliability, and MTU.  These values are calculated\
    \ from destination\n   to source as follows:\n              o Throughput    -\
    \ Minimum value\n              o Latency       - accumulative\n              o\
    \ Load          - maximum\n              o Reliability   - minimum\n         \
    \     o MTU           - minimum\n              o Hop count     - accumulative\n\
    \   There are two additional values: Jitter and energy.  These two values\n  \
    \ are accumulated from destination to source:\n           o Jitter - accumulative\n\
    \           o Energy - accumulative\n   These Extended Attributes, as well as\
    \ any future ones, will be\n   controlled via K6.  If K6 is non-zero, these will\
    \ be additive to the\n   path's composite metric.  Higher Jitter or energy usage\
    \ will result\n   in paths that are worse than those that either do not monitor\
    \ these\n   attributes or that have lower values.\n   EIGRP will not send these\
    \ attributes if the router does not provide\n   them.  If the attributes are received,\
    \ then EIGRP will use them in\n   the metric calculation (based on K6) and will\
    \ forward them with those\n   routers values assumed to be \"zero\" and the accumulative\
    \ values are\n   forwarded unchanged.\n   The use of the vector metrics allows\
    \ EIGRP to compute paths based on\n   any of four (bandwidth, delay, reliability,\
    \ and load) path selection\n   schemes.  The schemes are distinguished based on\
    \ the choice of the\n   key-measured network performance metric.\n   Of these\
    \ vector metric components, by default, only minimum\n   Throughput and latency\
    \ are traditionally used to compute the best\n   path.  Unlike most metrics, minimum\
    \ Throughput is set to the minimum\n   value of the entire path, and it does not\
    \ reflect how many hops or\n   low Throughput links are in the path, nor does\
    \ it reflect the\n   availability of parallel links.  Latency is calculated based\
    \ on one-\n   way delays and is a cumulative value, which increases with each\n\
    \   segment in the path.\n   Network Designer note: When trying to manually influence\
    \ EIGRP path\n   selection though interface bandwidth/delay configuration, the\n\
    \   modification of bandwidth is discouraged for following reasons:\n   The change\
    \ will only affect the path selection if the configured\n   value is the lowest\
    \ bandwidth over the entire path.  Changing the\n   bandwidth can have impact\
    \ beyond affecting the EIGRP metrics.  For\n   example, Quality of Service (QoS)\
    \ also looks at the bandwidth on an\n   interface.\n   EIGRP throttles its packet\
    \ transmissions so it will only use 50% of\n   the configured bandwidth.  Lowering\
    \ the bandwidth can cause EIGRP to\n   starve an adjacency, causing slow or failed\
    \ convergence and control-\n   plane operation.\n   Changing the delay does not\
    \ impact other protocols, nor does it cause\n   EIGRP to throttle back; changing\
    \ the delay configured on a link only\n   impacts metric calculation.\n"
- title: 5.6.2.2.  Wide Metric Conversion Constants
  contents:
  - "5.6.2.2.  Wide Metric Conversion Constants\n   EIGRP uses a number of defined\
    \ constants for conversion and\n   calculation of metric values.  These numbers\
    \ are provided here for\n   reference\n           EIGRP_BANDWIDTH            \
    \        10,000,000\n           EIGRP_DELAY_PICO                    1,000,000\n\
    \           EIGRP_INACCESSIBLE       0xFFFFFFFFFFFFFFFFLL\n           EIGRP_MAX_HOPS\
    \                            100\n           EIGRP_CLASSIC_SCALE             \
    \          256\n           EIGRP_WIDE_SCALE                        65536\n   When\
    \ computing the metric using the above units, all capacity\n   information will\
    \ be normalized to kilobytes and picoseconds before\n   being used.  For example,\
    \ delay is expressed in microseconds per\n   kilobyte, and would be converted\
    \ to kilobytes per second; likewise,\n   energy would be expressed in power per\
    \ kilobytes per second of usage.\n"
- title: 5.6.2.3.  Throughput Calculation
  contents:
  - "5.6.2.3.  Throughput Calculation\n   The formula for the conversion for Max-Throughput\
    \ value directly from\n   the interface without consideration of congestion-based\
    \ effects is as\n   follows:\n                                  (EIGRP_BANDWIDTH\
    \ * EIGRP_WIDE_SCALE)\n        Max-Throughput = K1 *     ------------------------------------\n\
    \                                       Interface Bandwidth (kbps)\n   If K2 is\
    \ used, the effect of congestion as a measure of load reported\n   by the interface\
    \ will be used to simulate the \"available Throughput\"\n   by adjusting the maximum\
    \ Throughput according to the formula:\n                                     \
    \      K2 * Max-Throughput\n        Net-Throughput = Max-Throughput + ---------------------\n\
    \                                              256 - Load\n   K2 has the greatest\
    \ effect on the metric occurs when the load\n   increases beyond 90%.\n"
- title: 5.6.2.4.  Latency Calculation
  contents:
  - "5.6.2.4.  Latency Calculation\n   Transmission times derived from physical interfaces\
    \ MUST be n units\n   of picoseconds, converted to picoseconds prior to being\
    \ exchanged\n   between neighbors, or used in the composite metric determination.\n\
    \   This includes delay values present in configuration-based commands\n   (i.e.,\
    \ interface delay, redistribute, default-metric, route-map,\n   etc.).\n   The\
    \ delay value is then converted to a \"latency\" using the formula:\n        \
    \                  Delay * EIGRP_WIDE_SCALE\n        Latency = K3 *   --------------------------\n\
    \                             EIGRP_DELAY_PICO\n"
- title: 5.6.2.5.  Composite Calculation
  contents:
  - "5.6.2.5.  Composite Calculation\n                                           \
    \                     K5\n      metric =[(K1*Net-Throughput) + Latency)+(K6*ExtAttr)]\
    \ * ------\n                                                              K4+Rel\n\
    \   By default, the path selection scheme used by EIGRP is a combination\n   of\
    \ Throughput and Latency where the selection is a product of total\n   latency\
    \ and minimum Throughput of all links along the path:\n      metric = (K1 * min(Throughput))\
    \ + (K3 * sum(Latency)) }\n"
- title: 6.  EIGRP Packet Formats
  contents:
  - '6.  EIGRP Packet Formats

    '
- title: 6.1.  Protocol Number
  contents:
  - "6.1.  Protocol Number\n   The IPv6 and IPv4 protocol identifier number spaces\
    \ are common and\n   will both use protocol identifier 88 [8] [9].\n   EIGRP IPv4\
    \ will transmit HELLO packets using either the unicast\n   destination of a neighbor\
    \ or using a multicast host group address [7]\n   with a source address EIGRP\
    \ IPv4 multicast address [13].\n   EIGRP IPv6 will transmit HELLO packets with\
    \ a source address being\n   the link-local address of the transmitting interface.\
    \  Multicast\n   HELLO packets will have a destination address of EIGRP IPv6 multicast\n\
    \   address [14].  Unicast packets directed to a specific neighbor will\n   contain\
    \ the destination link-local address of the neighbor.\n   There is no requirement\
    \ that two EIGRP IPv6 neighbors share a common\n   prefix on their connecting\
    \ interface.  EIGRP IPv6 will check that a\n   received HELLO contains a valid\
    \ IPv6 link-local source address.\n   Other HELLO processing will follow common\
    \ EIGRP checks, including\n   matching AS number and matching K-values.\n"
- title: 6.2.  Protocol Assignment Encoding
  contents:
  - "6.2.  Protocol Assignment Encoding\n   The External Protocol field is an informational\
    \ assignment to\n   identify the originating routing protocol that this route\
    \ was learned\n   by.  The following values are assigned:\n           Protocols\
    \             Value\n           IGRP                    1\n           EIGRP  \
    \                 2\n           Static                  3\n           RIP    \
    \                 4\n           HELLO                   5\n           OSPF   \
    \                 6\n           ISIS                    7\n           EGP    \
    \                 8\n           BGP                     9\n           IDRP   \
    \                10\n           Connected              11\n"
- title: 6.3.  Destination Assignment Encoding
  contents:
  - "6.3.  Destination Assignment Encoding\n   Destinations types are encoded according\
    \ to the IANA address family\n   number assignments.  Currently only the following\
    \ types are used:\n         AFI Description            AFI Number\n        --------------------------------------\n\
    \         IP (IP version 4)                 1\n         IP6 (IP version 6)   \
    \             2\n         EIGRP Common Service Family   16384\n         EIGRP\
    \ IPv4 Service Family     16385\n         EIGRP IPv6 Service Family     16386\n"
- title: 6.4.  EIGRP Communities Attribute
  contents:
  - "6.4.  EIGRP Communities Attribute\n   EIGRP supports communities similar to the\
    \ BGP Extended Communities\n   RFC 4360 [4] extended type with Type field composed\
    \ of 2 octets and\n   Value field composed of 6 octets.  Each Community is encoded\
    \ as an\n   8-octet quantity, as follows:\n          - Type field: 2 octets\n\
    \          - Value field: Remaining octets\n    0                   1        \
    \           2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9\
    \ 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   | Type high     | Type low      |                               |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\
    \          Value                |\n   |                                      \
    \                         |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   In addition to well-known communities supported by BGP (such as Site\n   of\
    \ Origin), EIGRP defines a number of additional Community values in\n   the \"\
    Experimental Use\" [5] range as follows:\n     Type high: 0x88\n     Type low:\n\
    \       Value       Name               Description\n       ---------------------------------------------------------------\n\
    \         00        EXTCOMM_EIGRP      EIGRP route information appended\n    \
    \     01        EXTCOMM_DAD        Data: AS + Delay\n         02        EXTCOMM_VRHB\
    \       Vector: Reliability + Hop + BW\n         03        EXTCOMM_SRLM      \
    \ System: Reserve + Load + MTU\n         04        EXTCOMM_SAR        System:\
    \ Remote AS + Remote ID\n         05        EXTCOMM_RPM        Remote: Protocol\
    \ + Metric\n         06        EXTCOMM_VRR        Vecmet: Rsvd + RouterID\n"
- title: 6.5.  EIGRP Packet Header
  contents:
  - "6.5.  EIGRP Packet Header\n   The basic EIGRP packet payload format is identical\
    \ for both IPv4 and\n   IPv6, although there are some protocol-specific variations.\
    \  Packets\n   consist of a header, followed by a set of variable-length fields\n\
    \   consisting of Type/Length/Value (TLV) triplets.\n    0                   1\
    \                   2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5\
    \ 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |Header Version | Opcode        |           Checksum            |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                             Flags                             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                        Sequence Number                        |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                     Acknowledgment Number                     |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   | Virtual Router ID             |   Autonomous System Number    |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   Header Version: EIGRP Packet Header Format version.  Current Version\n   \
    \   is 2.  This field is not the same as the TLV Version field.\n   Opcode: Indicates\
    \ the type of the message.  It will be one of the\n      following values:\n \
    \          EIGRP_OPC_UPDATE              1\n           EIGRP_OPC_REQUEST     \
    \        2\n           EIGRP_OPC_QUERY               3\n           EIGRP_OPC_REPLY\
    \               4\n           EIGRP_OPC_HELLO               5\n           Reserved\
    \                      6      (EIGRP_OPC_IPXSAP)\n           Reserved        \
    \              7      (EIGRP_OPC_PROBE)\n           Reserved                 \
    \     8      (EIGRP_OPC_ACK)\n           Reserved                      9\n   \
    \        EIGRP_OPC_SIAQUERY           10\n           EIGRP_OPC_SIAREPLY      \
    \     11\n   Checksum: Each packet will include a checksum for the entire contents\n\
    \      of the packet.  The checksum will be the standard ones' complement\n  \
    \    of the ones' complement sum.  For purposes of computing the\n      checksum,\
    \ the value of the checksum field is zero.  The packet is\n      discarded if\
    \ the packet checksum fails.\n   Flags: Defines special handling of the packet.\
    \  There are currently\n      four defined flag bits.\n   INIT-Flag (0x01): This\
    \ bit is set in the initial UPDATE sent to a\n      newly discovered neighbor.\
    \  It instructs the neighbor to advertise\n      its full set of routes.\n   CR-Flag\
    \ (0x02): This bit indicates that receivers should only accept\n      the packet\
    \ if they are in Conditionally Received mode.  A router\n      enters Conditionally\
    \ Received mode when it receives and processes\n      a HELLO packet with a SEQUENCE\
    \ TLV present.\n   RS-Flag (0x04): The Restart flag is set in the HELLO and the\
    \ UPDATE\n      packets during the restart period.  The router looks at the RS-\n\
    \      Flag to detect if a neighbor is restarting.  From the restarting\n    \
    \  routers perspective, if a neighboring router detects the RS-Flag\n      set,\
    \ it will maintain the adjacency, and will set the RS-Flag in\n      its UPDATE\
    \ packet to indicated it is doing a soft restart.\n   EOT-Flag (0x08): The End-of-Table\
    \ flag marks the end of the startup\n      process with a neighbor.  If the flag\
    \ is set, it indicates the\n      neighbor has completed sending all UPDATEs.\
    \  At this point, the\n      router will remove any stale routes learned from\
    \ the neighbor\n      prior to the restart event.  A stale route is any route\
    \ that\n      existed before the restart and was not refreshed by the neighbor\n\
    \      via and UPDATE.\n   Sequence Number: Each packet that is transmitted will\
    \ have a 32-bit\n      sequence number that is unique with respect to a sending\
    \ router.\n      A value of 0 means that an acknowledgment is not required.\n\
    \   Acknowledgment Number: The 32-bit sequence number that is being\n      acknowledged\
    \ with respect to the receiver of the packet.  If the\n      value is 0, there\
    \ is no acknowledgment present.  A non-zero value\n      can only be present in\
    \ unicast-addressed packets.  A HELLO packet\n      with a non-zero ACK field\
    \ should be decoded as an ACK packet\n      rather than a HELLO packet.\n   Virtual\
    \ Router Identifier (VRID): A 16-bit number that identifies the\n      virtual\
    \ router with which this packet is associated.  Packets\n      received with an\
    \ unknown, or unsupported, value will be discarded.\n             Value Range\
    \       Usage\n               0x0000            Unicast Address Family\n     \
    \          0x0001            Multicast Address Family\n               0x0002-0x7FFF\
    \     Reserved\n               0x8000            Unicast Service Family\n    \
    \           0x8001-0xFFFF     Reserved\n   Autonomous System Number: 16-bit unsigned\
    \ number of the sending\n      system.  This field is indirectly used as an authentication\
    \ value.\n      That is, a router that receives and accepts a packet from a\n\
    \      neighbor must have the same AS number or the packet is ignored.\n     \
    \ The range of valid AS numbers is 1 through 65,535.\n"
- title: 6.6.  EIGRP TLV Encoding Format
  contents:
  - "6.6.  EIGRP TLV Encoding Format\n   The contents of each packet can contain a\
    \ variable number of fields.\n   Each field will be tagged and include a length\
    \ field.  This allows\n   for newer versions of software to add capabilities and\
    \ coexist with\n   old versions of software in the same configuration.  Fields\
    \ that are\n   tagged and not recognized can be skipped over.  Another advantage\
    \ of\n   this encoding scheme is that it allows multiple network-layer\n   protocols\
    \ to carry independent information.  Therefore, if it is\n   later decided to\
    \ implement a single \"integrated\" protocol, this can\n   be done.\n   The format\
    \ of a {type, length, value} (TLV) is encoded as follows:\n    0             \
    \      1                   2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1\
    \ 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   | Type high     | Type low      |            Length             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                    Value (variable length)                    |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   The type values are the ones defined below.  The length value\n   specifies\
    \ the length in octets of the type, length, and value fields.\n   TLVs can appear\
    \ in a packet in any order, and there are no\n   interdependencies among them.\n\
    \   Malformed TLVs contained in EIGRP messages are handled by silently\n   discarding\
    \ the containing message.  A TLV is malformed if the TLV\n   Length is invalid\
    \ or if the TLV extends beyond the end of the\n   containing message.\n"
- title: 6.6.1.  Type Field Encoding
  contents:
  - "6.6.1.  Type Field Encoding\n   The type field is structured as follows: Type\
    \ High: 1 octet that\n   defines the protocol classification:\n            Protocol\
    \            ID   VERSION\n            General            0x00    1.2\n      \
    \      IPv4               0x01    1.2\n            IPv6               0x04   \
    \ 1.2\n            SAF                0x05    3.0\n            Multiprotocol \
    \     0x06    2.0\n   Type Low: 1 octet that defines the TLV Opcode; see TLV Definitions\
    \ in\n      Section 3.\n"
- title: 6.6.2.  Length Field Encoding
  contents:
  - "6.6.2.  Length Field Encoding\n   The Length field is a 2-octet unsigned number,\
    \ which indicates the\n   length of the TLV.  The value includes the Type and\
    \ Length fields.\n"
- title: 6.6.3.  Value Field Encoding
  contents:
  - "6.6.3.  Value Field Encoding\n   The Value field is a multi-octet field containing\
    \ the payload for the\n   TLV.\n"
- title: 6.7.  EIGRP Generic TLV Definitions
  contents:
  - "6.7.  EIGRP Generic TLV Definitions\n                                 Ver 1.2\
    \   Ver 2.0\n   PARAMETER_TYPE                0x0001    0x0001\n   AUTHENTICATION_TYPE\
    \           0x0002    0x0002\n   SEQUENCE_TYPE                 0x0003    0x0003\n\
    \   SOFTWARE_VERSION_TYPE         0x0004    0x0004\n   MULTICAST_SEQUENCE_TYPE\
    \       0x0005    0x0005\n   PEER_INFORMATION_TYPE         0x0006    0x0006\n\
    \   PEER_TERMINATION_TYPE         0x0007    0x0007\n   PEER_TID_LIST_TYPE    \
    \         ---      0x0008\n"
- title: 6.7.1.  0x0001 - PARAMETER_TYPE
  contents:
  - "6.7.1.  0x0001 - PARAMETER_TYPE\n   This TLV is used in HELLO packets to convey\
    \ the EIGRP metric\n   coefficient values: noted as \"K-values\" as well as the\
    \ Hold Time\n   values.  This TLV is also used in an initial UPDATE packet when\
    \ a\n   neighbor is discovered.\n    0                   1                   2\
    \                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5\
    \ 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |            0x0001             |            0x000C             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |       K1      |       K2      |       K3      |       K4      |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |       K5      |       K6      |           Hold Time           |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   K-values: The K-values associated with the EIGRP composite metric\n      equation.\
    \  The default values for weights are:\n                K1 - 1\n             \
    \   K2 - 0\n                K3 - 1\n                K4 - 0\n                K5\
    \ - 0\n                K6 - 0\n   Hold Time: The amount of time in seconds that\
    \ a receiving router\n      should consider the sending neighbor valid.  A valid\
    \ neighbor is\n      one that is able to forward packets and participates in EIGRP.\
    \  A\n      router that considers a neighbor valid will store all routing\n  \
    \    information advertised by the neighbor.\n"
- title: 6.7.2.  0x0002 - AUTHENTICATION_TYPE
  contents:
  - "6.7.2.  0x0002 - AUTHENTICATION_TYPE\n   This TLV may be used in any EIGRP packet\
    \ and conveys the\n   authentication type and data used.  Routers receiving a\
    \ mismatch in\n   authentication shall discard the packet.\n    0            \
    \       1                   2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1\
    \ 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |             0x0002            |            Length             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |   Auth Type    | Auth Length  |      Auth Data (Variable)     |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   Authentication Type: The type of authentication used.\n   Authentication Length:\
    \ The length, measured in octets, of the\n      individual authentication.\n \
    \  Authentication Data: Variable-length field reflected by \"Auth\n      Length\"\
    , which is dependent on the type of authentication used.\n      Multiple authentication\
    \ types can be present in a single\n      AUTHENTICATION_TYPE TLV.\n"
- title: 6.7.2.1.  0x02 - MD5 Authentication Type
  contents:
  - "6.7.2.1.  0x02 - MD5 Authentication Type\n   MD5 Authentication will use Auth\
    \ Type code 0x02, and the Auth Data\n   will be the MD5 Hash value.\n"
- title: 6.7.2.2.  0x03 - SHA2 Authentication Type
  contents:
  - "6.7.2.2.  0x03 - SHA2 Authentication Type\n   SHA2-256 Authentication will use\
    \ Type code 0x03, and the Auth Data\n   will be the 256-bit SHA2 [6] Hash value.\n"
- title: 6.7.3.  0x0003 - SEQUENCE_TYPE
  contents:
  - "6.7.3.  0x0003 - SEQUENCE_TYPE\n   This TLV is used for a sender to tell receivers\
    \ to not accept packets\n   with the CR-Flag set.  This is used to order multicast\
    \ and unicast\n   addressed packets.\n    0                   1              \
    \     2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2\
    \ 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |            0x0003             |            Length             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |Address Length |                 Protocol Address              |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   The Address Length and Protocol Address will be repeated one or more\n   times\
    \ based on the Length field.\n   Address Length: Number of octets for the address\
    \ that follows.  For\n      IPv4, the value is 4.  For IPv6, it is 16.  For AppleTalk,\
    \ the\n      value is 4; for Novell IPX, the value is 10 (both are no longer in\n\
    \      use).\n   Protocol Address: Neighbor address on interface in which the\
    \ HELLO\n      with SEQUENCE TLV is sent.  Each address listed in the HELLO\n\
    \      packet is a neighbor that should not enter Conditionally Received\n   \
    \   mode.\n"
- title: 6.7.4.  0x0004 - SOFTWARE_VERSION_TYPE
  contents:
  - "6.7.4.  0x0004 - SOFTWARE_VERSION_TYPE\n           Field                    \
    \    Length\n           Vender OS major version        1\n           Vender OS\
    \ minor version        1\n           EIGRP major revision           1\n      \
    \     EIGRP minor revision           1\n   The EIGRP TLV Version fields are used\
    \ to determine TLV format\n   versions.  Routers using Version 1.2 TLVs do not\
    \ understand Version\n   2.0 TLVs, therefore Version 2.0 routers must send the\
    \ packet with\n   both TLV formats in a mixed network.\n    0                \
    \   1                   2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3\
    \ 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |            0x0004             |            0x000C             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |Vendor Major V.|Vendor Minor V.| EIGRP Major V.| EIGRP Minor V.|\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n"
- title: 6.7.5.  0x0005 - MULTICAST_SEQUENCE_TYPE
  contents:
  - "6.7.5.  0x0005 - MULTICAST_SEQUENCE_TYPE\n   The next multicast SEQUENCE TLV.\n\
    \    0                   1                   2                   3\n    0 1 2\
    \ 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |            0x0005             |             0x0008            |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                         Sequence Number                       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n"
- title: 6.7.6.  0x0006 - PEER_INFORMATION_TYPE
  contents:
  - "6.7.6.  0x0006 - PEER_INFORMATION_TYPE\n   This TLV is reserved, and not part\
    \ of this document.\n"
- title: 6.7.7.  0x0007 - PEER_ TERMINATION_TYPE
  contents:
  - "6.7.7.  0x0007 - PEER_ TERMINATION_TYPE\n   This TLV is used in HELLO packets\
    \ to notify the list of neighbor(s)\n   the router has reset the adjacency.  This\
    \ TLV is used in HELLO\n   packets to notify the list of neighbors that the router\
    \ has reset the\n   adjacency.  This is used anytime a router needs to reset an\n\
    \   adjacency, or signal an adjacency it is going down.\n    0               \
    \    1                   2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2\
    \ 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |            0x0007             |             Length            |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                      Address List (variable)                  |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   Implementation note: Older Cisco routers implement this using the\n   \"Parameters\
    \ TLV\" with all K-values set to 255 (except K6).\n"
- title: 6.7.8.  0x0008 - TID_LIST_TYPE
  contents:
  - "6.7.8.  0x0008 - TID_LIST_TYPE\n   List of sub-topology identifiers, including\
    \ the Base Topology,\n   supported by the router.\n    0                   1 \
    \                  2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5\
    \ 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |            0x0008             |            Length             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |            Topology Identification List (variable)            |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   If this information changes from the last state, it means either a\n   new\
    \ topology was added or an existing topology was removed.  This TLV\n   is ignored\
    \ until the three-way handshake has finished\n   When the TID list is received,\
    \ it compares the list to the previous\n   list sent.  If a TID is found that\
    \ does not previously exist, the TID\n   is added to the neighbor's topology list,\
    \ and the existing sub-\n   topology is sent to the peer.\n   If a TID that was\
    \ in a previous list is not found, the TID is removed\n   from the neighbor's\
    \ topology list and all routes learned though that\n   neighbor for that sub-topology\
    \ are removed from the topology table.\n"
- title: 6.8.  Classic Route Information TLV Types
  contents:
  - '6.8.  Classic Route Information TLV Types

    '
- title: 6.8.1.  Classic Flag Field Encoding
  contents:
  - "6.8.1.  Classic Flag Field Encoding\n   EIGRP transports a number of flags with\
    \ in the TLVs to indicate\n   addition route state information.  These bits are\
    \ defined as follows:\n   Flags Field\n   -----------\n   Source Withdraw (Bit\
    \ 0) - Indicates if the router that is the\n   original source of the destination\
    \ is withdrawing the route from the\n   network or if the destination is lost\
    \ due as a result of a network\n   failure.\n   Candidate Default (CD) (Bit 1)\
    \ - Set to indicate the destination\n   should be regarded as a candidate for\
    \ the default route.  An EIGRP\n   default route is selected from all the advertised\
    \ candidate default\n   routes with the smallest metric.\n   ACTIVE (Bit 2) -\
    \ Indicates if the route is in the ACTIVE State.\n"
- title: 6.8.2.  Classic Metric Encoding
  contents:
  - "6.8.2.  Classic Metric Encoding\n   The handling of bandwidth and delay for Classic\
    \ TLVs is encoded in\n   the packet \"scaled\" form relative to how they are represented\
    \ on the\n   physical link.\n    0                   1                   2   \
    \                3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6\
    \ 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                          Scaled Delay                         |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                          Scaled Bandwidth                     |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                   MTU                         | Hop Count     |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   | Reliability   |       Load    | Internal Tag  | Flags Field   |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   Scaled Delay: An administrative parameter assigned statically on a\n     \
    \ per-interface-type basis to represent the time it takes along an\n      unloaded\
    \ path.  This is expressed in units of tens of microseconds\n      divvied by\
    \ 256.  A delay of 0xFFFFFFFF indicates an unreachable\n      route.\n   Scaled\
    \ Bandwidth: The path bandwidth measured in bits per second.  In\n      units\
    \ of 2,560,000,000/kbps.\n   MTU: The minimum MTU size for the path to the destination.\n\
    \   Hop Count: The number of router traversals to the destination.\n   Reliability:\
    \ The current error rate for the path, measured as an\n      error percentage.\
    \  A value of 255 indicates 100% reliability\n   Load: The load utilization of\
    \ the path to the destination, measured\n      as a percentage.  A value of 255\
    \ indicates 100% load.\n   Internal-Tag: A tag assigned by the network administrator\
    \ that is\n      untouched by EIGRP.  This allows a network administrator to filter\n\
    \      routes in other EIGRP border routers based on this value.\n   Flags Field:\
    \ See Section 6.8.1.\n"
- title: 6.8.3.  Classic Exterior Encoding
  contents:
  - "6.8.3.  Classic Exterior Encoding\n   Additional routing information so provided\
    \ for destinations outside\n   of the EIGRP AS as follows:\n    0            \
    \       1                   2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1\
    \ 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                      Router Identifier (RID)                  |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |               External Autonomous System (AS) Number          |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                        Administrative Tag                     |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                    External Protocol Metric                   |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |           Reserved            |Extern Protocol|  Flags Field  |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   Router Identifier (RID): A 32-bit number provided by the router\n      sourcing\
    \ the information to uniquely identify it as the source.\n   External Autonomous\
    \ System (AS) Number: A 32-bit number indicating\n      the external AS of which\
    \ the sending router is a member.  If the\n      source protocol is EIGRP, this\
    \ field will be the [VRID, AS] pair.\n      If the external protocol does not\
    \ have an AS, other information\n      can be used (for example, Cisco uses process-id\
    \ for OSPF).\n   Administrative Tag: A tag assigned by the network administrator\
    \ that\n      is untouched by EIGRP.  This allows a network administrator to\n\
    \      filter routes in other EIGRP border routers based on this value.\n   External\
    \ Protocol Metric: 32-bit value of the composite metric that\n      resides in\
    \ the routing table as learned by the foreign protocol.\n      If the External\
    \ Protocol is IGRP or another EIGRP routing process,\n      the value can optionally\
    \ be the composite metric or 0, and the\n      metric information is stored in\
    \ the metric section.\n   External Protocol: Contains an enumerated value defined\
    \ in Section\n      6.2 to identify the routing protocol (external protocol)\n\
    \      redistributing the route.\n   Flags Field: See Section 6.8.1\n"
- title: 6.8.4.  Classic Destination Encoding
  contents:
  - "6.8.4.  Classic Destination Encoding\n   EIGRP carries destination in a compressed\
    \ form, where the number of\n   bits significant in the variable-length address\
    \ field are indicated\n   in a counter.\n    0                   1           \
    \        2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0\
    \ 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   | Subnet Mask   |    Destination Address (variable length)      |\n   | Bit\
    \ Count     |         ((Bit Count - 1) / 8) + 1             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   Subnet Mask Bit Count: 8-bit value used to indicate the number of\n      bits\
    \ in the subnet mask.  A value of 0 indicates the default\n      network, and\
    \ no address is present.\n   Destination Address: A variable-length field used\
    \ to carry the\n      destination address.  The length is determined by the number\
    \ of\n      consecutive bits in the destination address.  The formula to\n   \
    \   calculate the length is address-family dependent:\n      IPv4: ((Bit Count\
    \ - 1) / 8) + 1\n      IPv6: (Bit Count == 128) ? 16 : ((x / 8) + 1)\n"
- title: 6.8.5.  IPv4-Specific TLVs
  contents:
  - "6.8.5.  IPv4-Specific TLVs\n      INTERNAL_TYPE       0x0102\n      EXTERNAL_TYPE\
    \       0x0103\n      COMMUNITY_TYPE      0x0104\n"
- title: 6.8.5.1.  IPv4 INTERNAL_TYPE
  contents:
  - "6.8.5.1.  IPv4 INTERNAL_TYPE\n   This TLV conveys IPv4 destination and associated\
    \ metric information\n   for IPv4 networks.  Routes advertised in this TLV are\
    \ network\n   interfaces that EIGRP is configured on as well as networks that\
    \ are\n   learned via other routers running EIGRP.\n    0                   1\
    \                   2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5\
    \ 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |      0x01     |       0x02    |            Length             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                   Next-Hop Forwarding Address                 |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |            Vector Metric Section (see Section 6.8.2)          |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-|\n\
    \   |                       Destination Section                     |\n   |  \
    \               IPv4 Address (variable length)                |\n   |        \
    \               (see Section 6.8.4)                     |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   Next-Hop Forwarding Address: IPv4 address represented by four 8-bit\n    \
    \  values (total 4 octets).  If the value is zero (0), the IPv4\n      address\
    \ from the received IPv4 header is used as the next hop for\n      the route.\
    \  Otherwise, the specified IPv4 address will be used.\n   Vector Metric Section:\
    \ The vector metrics for destinations contained\n      in this TLV.  See the description\
    \ of \"metric encoding\" in Section\n      6.8.2.\n   Destination Section: The\
    \ network/subnet/host destination address\n      being requested.  See the description\
    \ of \"destination\" in Section\n      6.8.4.\n"
- title: 6.8.5.2.  IPv4 EXTERNAL_TYPE
  contents:
  - "6.8.5.2.  IPv4 EXTERNAL_TYPE\n   This TLV conveys IPv4 destination and metric\
    \ information for routes\n   learned by other routing protocols that EIGRP injects\
    \ into the AS.\n   Available with this information is the identity of the routing\n\
    \   protocol that created the route, the external metric, the AS number,\n   an\
    \ indicator if it should be marked as part of the EIGRP AS, and a\n   network-administrator\
    \ tag used for route filtering at EIGRP AS\n   boundaries.\n    0            \
    \       1                   2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1\
    \ 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |      0x01     |       0x03    |            Length             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                   Next-Hop Forwarding Address                 |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                 Exterior Section (see Section 6.8.3)          |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |            Vector Metric Section (see Section 6.8.2)          |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-|\n\
    \   |                       Destination Section                     |\n   |  \
    \               IPv4 Address (variable length)                |\n   |        \
    \               (see Section 6.8.4)                     |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   Next-Hop Forwarding Address: IPv4 address represented by four 8-bit\n    \
    \  values (total 4 octets).  If the value is zero (0), the IPv4\n      address\
    \ from the received IPv4 header is used as the next hop for\n      the route.\
    \  Otherwise, the specified IPv4 address will be used.\n   Exterior Section: Additional\
    \ routing information provided for a\n      destination that is outside of the\
    \ AS and that has been\n      redistributed into the EIGRP.  See the description\
    \ of \"exterior\n      encoding\" in Section 6.8.3.\n   Vector Metric Section:\
    \ Vector metrics for destinations contained in\n      this TLV.  See the description\
    \ of \"metric encoding\" in Section\n      6.8.2.\n   Destination Section: The\
    \ network/subnet/host destination address\n      being requested.  See the description\
    \ of \"destination\" in Section\n      6.8.4.\n"
- title: 6.8.5.3.  IPv4 COMMUNITY_TYPE
  contents:
  - "6.8.5.3.  IPv4 COMMUNITY_TYPE\n   This TLV is used to provide community tags\
    \ for specific IPv4\n   destinations.\n    0                   1             \
    \      2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\
    \ 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |      0x01     |       0x04    |             Length            |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                          IPv4 Destination                     |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |            Reserved           |       Community Length        |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                         Community List                        |\n   |  \
    \                      (variable length)                      |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   IPv4 Destination: The IPv4 address with which the community\n      information\
    \ should be stored.\n   Community Length: A 2-octet unsigned number that indicates\
    \ the length\n      of the Community List.  The length does not include the IPv4\n\
    \      Address, Reserved, or Length fields.\n   Community List: One or more 8-octet\
    \ EIGRP communities, as defined in\n      Section 6.4.\n"
- title: 6.8.6.  IPv6-Specific TLVs
  contents:
  - "6.8.6.  IPv6-Specific TLVs\n      INTERNAL_TYPE                 0x0402\n    \
    \  EXTERNAL_TYPE                 0x0403\n      COMMUNITY_TYPE                0x0404\n"
- title: 6.8.6.1.  IPv6 INTERNAL_TYPE
  contents:
  - "6.8.6.1.  IPv6 INTERNAL_TYPE\n   This TLV conveys the IPv6 destination and associated\
    \ metric\n   information for IPv6 networks.  Routes advertised in this TLV are\n\
    \   network interfaces that EIGRP is configured on as well as networks\n   that\
    \ are learned via other routers running EIGRP.\n    0                   1    \
    \               2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7\
    \ 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |      0x04     |       0x02    |            Length             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                                                               |\n   |  \
    \                 Next-Hop Forwarding Address                 |\n   |        \
    \                    (16 octets)                        |\n   |              \
    \                                                 |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |            Vector Metric Section (see Section 6.8.2)          |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-|\n\
    \   |                       Destination Section                     |\n   |  \
    \               IPv6 Address (variable length)                |\n   |        \
    \               (see Section 6.8.4)                     |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   Next-Hop Forwarding Address: This IPv6 address is represented by\n      eight\
    \ groups of 16-bit values (total 16 octets).  If the value is\n      zero (0),\
    \ the IPv6 address from the received IPv6 header is used\n      as the next hop\
    \ for the route.  Otherwise, the specified IPv6\n      address will be used.\n\
    \   Vector Metric Section: Vector metrics for destinations contained in\n    \
    \  this TLV.  See the description of \"metric encoding\" in Section\n      6.8.2.\n\
    \   Destination Section: The network/subnet/host destination address\n      being\
    \ requested.  See the description of \"destination\" in Section\n      6.8.4.\n"
- title: 6.8.6.2.  IPv6 EXTERNAL_TYPE
  contents:
  - "6.8.6.2.  IPv6 EXTERNAL_TYPE\n   This TLV conveys IPv6 destination and metric\
    \ information for routes\n   learned by other routing protocols that EIGRP injects\
    \ into the\n   topology.  Available with this information is the identity of the\n\
    \   routing protocol that created the route, the external metric, the AS\n   number,\
    \ an indicator if it should be marked as part of the EIGRP AS,\n   and a network\
    \ administrator tag used for route filtering at EIGRP AS\n   boundaries.\n   \
    \ 0                   1                   2                   3\n    0 1 2 3 4\
    \ 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |      0x04     |        0x03   |           Length              |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                                                               |\n   |  \
    \                 Next-Hop Forwarding Address                 |\n   |        \
    \                     (16 octets)                       |\n   |              \
    \                                                 |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |               Exterior Section (see Section 6.8.3)            |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |            Vector Metric Section (see Section 6.8.2)          |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-|\n\
    \   |                        Destination Section                    |\n   |  \
    \               IPv6 Address (variable length)                |\n   |        \
    \               (see Section 6.8.4)                     |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   Next-Hop Forwarding Address: IPv6 address is represented by eight\n      groups\
    \ of 16-bit values (total 16 octets).  If the value is zero\n      (0), the IPv6\
    \ address from the received IPv6 header is used as the\n      next hop for the\
    \ route.  Otherwise, the specified IPv6 address\n      will be used.\n   Exterior\
    \ Section: Additional routing information provided for a\n      destination that\
    \ is outside of the AS and that has been\n      redistributed into the EIGRP.\
    \  See the description of \"exterior\n      encoding\" in Section 6.8.3.\n   Vector\
    \ Metric Section: vector metrics for destinations contained in\n      this TLV.\
    \  See the description of \"metric encoding\" in Section\n      6.8.2.\n   Destination\
    \ Section: The network/subnet/host destination address\n      being requested.\
    \  See the description of \"destination\" in Section\n      6.8.4.\n"
- title: 6.8.6.3 IPv6 COMMUNITY_TYPE
  contents:
  - "6.8.6.3 IPv6 COMMUNITY_TYPE\n   This TLV is used to provide community tags for\
    \ specific IPv4\n   destinations.\n    0                   1                 \
    \  2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3\
    \ 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |      0x04     |       0x04    |             Length            |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                                                               |\n   |  \
    \                          Destination                        |\n   |        \
    \                    (16 octets)                        |\n   |              \
    \                                                 |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |            Reserved           |       Community Length        |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                         Community List                        |\n   |  \
    \                      (variable length)                      |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   Destination: The IPv6 address with which the community information\n     \
    \ should be stored.\n   Community Length: A 2-octet unsigned number that indicates\
    \ the length\n      of the Community List.  The length does not include the IPv6\n\
    \      Address, Reserved, or Length fields.\n   Community List: One or more 8-octet\
    \ EIGRP communities, as defined in\n      Section 6.4.\n"
- title: 6.9.  Multiprotocol Route Information TLV Types
  contents:
  - "6.9.  Multiprotocol Route Information TLV Types\n   This TLV conveys topology\
    \ and associated metric information.\n    0                   1              \
    \     2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2\
    \ 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |Header Version |    Opcode     |           Checksum            |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                              Flags                            |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                        Sequence Number                        |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                     Acknowledgment Number                     |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   | Virtual Router ID             |   Autonomous System Number    |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                      TLV Header Encoding                      |\n   |  \
    \                    (see Section 6.9.1)                      |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                       Wide Metric Encoding                    |\n   |  \
    \                     (see Section 6.9.2)                     |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                       Destination Descriptor                  |\n   |  \
    \                       (variable length)                     |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n"
- title: 6.9.1.  TLV Header Encoding
  contents:
  - "6.9.1.  TLV Header Encoding\n   There has been a long-standing requirement for\
    \ EIGRP to support\n   routing technologies, such as multi-topologies, and to\
    \ provide the\n   ability to carry destination information independent of the\n\
    \   transport.  To accomplish this, a Vector has been extended to have a\n   new\
    \ \"Header Extension Header\" section.  This is a variable-length\n   field and,\
    \ at a minimum, it will support the following fields:\n    0                 \
    \  1                   2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3\
    \ 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   | Type High     | Type Low      |            Length             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |               AFI             |             TID               |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                    Router Identifier (RID)                    |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                    Value (variable length)                    |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   The available fields are:\n   TYPE - Topology TLVs have the following TYPE\
    \ codes:\n       Type High: 0x06\n       Type Low:\n           REQUEST_TYPE  \
    \               0x01\n           INTERNAL_TYPE                0x02\n         \
    \  EXTERNAL_TYPE                0x03\n   Router Identifier (RID): A 32-bit number\
    \ provided by the router\n      sourcing the information to uniquely identify\
    \ it as the source.\n"
- title: 6.9.2.  Wide Metric Encoding
  contents:
  - "6.9.2.  Wide Metric Encoding\n   Multiprotocol TLVs will provide an extendable\
    \ section of metric\n   information, which is not used for the primary routing\
    \ compilation.\n   Additional per-path information is included to enable per-path\
    \ cost\n   calculations in the future.  Use of the per-path costing along with\n\
    \   the VID/TID will prove a complete solution for multidimensional\n   routing.\n\
    \    0                   1                     2                 3\n    0 1 2\
    \ 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |    Offset     |   Priority    | Reliability   |        Load   |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |               MTU                             |   Hop Count   |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                               Delay                           |\n   |  \
    \                             +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   |        \
    \                       |                               |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\
    \                               |\n   |                             Bandwidth\
    \                         |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |               Reserved        |         Opaque Flags          |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                      Extended Attributes                      |\n   |  \
    \                      (variable length)                      |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   The fields are as follows:\n   Offset: Number of 16-bit words in the Extended\
    \ Attribute section that\n      are used to determine the start of the destination\
    \ information.  A\n      value of zero indicates no Extended Attributes are attached.\n\
    \   Priority: Priority of the prefix when processing a route.  In an AS\n    \
    \  using priority values, a destination with a higher priority\n      receives\
    \ preferential treatment and is serviced before a\n      destination with a lower\
    \ priority.  A value of zero indicates no\n      priority is set.\n   Reliability:\
    \ The current error rate for the path.  Measured as an\n      error percentage.\
    \  A value of 255 indicates 100% reliability\n   Load: The load utilization of\
    \ the path to the destination, measured\n      as a percentage.  A value of 255\
    \ indicates 100% load.\n   MTU: The minimum MTU size for the path to the destination.\
    \  Not used\n      in metric calculation but available to underlying protocols\n\
    \   Hop Count: The number of router traversals to the destination.\n   Delay:\
    \ The one-way latency along an unloaded path to the destination\n      expressed\
    \ in units of picoseconds per kilobit.  This number is not\n      scaled; a value\
    \ of 0xFFFFFFFFFFFF indicates an unreachable route.\n   Bandwidth: The path bandwidth\
    \ measured in kilobit per second as\n      presented by the interface.  This number\
    \ is not scaled; a value of\n      0xFFFFFFFFFFFF indicates an unreachable route.\n\
    \   Reserved: Transmitted as 0x0000.\n   Opaque Flags: 16-bit protocol-specific\
    \ flags.  Values currently\n      defined by Cisco are:\n          OPAQUE_SRCWD\
    \    0x01   Route Source Withdraw\n          OPAQUE_CD       0x02   Candidate\
    \ default route\n          OPAQUE_ACTIVE   0x04   Route is currently in active\
    \ state\n          OPAQUE_REPL     0x08   Route is replicated from another VRF\n\
    \   Extended Attributes (Optional): When present, defines extendable per-\n  \
    \    destination attributes.  This field is not normally transmitted.\n"
- title: 6.9.3.  Extended Metrics
  contents:
  - "6.9.3.  Extended Metrics\n   Extended metrics allow for extensibility of the\
    \ vector metrics in a\n   manner similar to RFC 6390 [11].  Each Extended metric\
    \ shall consist\n   of a header identifying the type (Opcode) and the length (Offset)\n\
    \   followed by application-specific information.  Extended metric values\n  \
    \ not understood must be treated as opaque and passed along with the\n   associated\
    \ route.\n   The general formats for the Extended Metric fields are:\n    0  \
    \                 1                   2                   3\n    0 1 2 3 4 5 6\
    \ 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |     Opcode    |      Offset   |              Data             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   Opcode: Indicates the type of Extended Metric.\n   Offset: Number of 16-bit\
    \ words in the application-specific\n      information.  Offset does not include\
    \ the length of the Opcode or\n      Offset.\n   Data: Zero or more octets of\
    \ data as defined by Opcode.\n"
- title: 6.9.3.1.  0x00 - NoOp
  contents:
  - "6.9.3.1.  0x00 - NoOp\n   This is used to pad the attribute section to ensure\
    \ 32-bit alignment\n   of the metric encoding section.\n    0                \
    \   1                   2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3\
    \ 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |     0x00      |      0x00     |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   The fields are:\n   Opcode: Transmitted as zero (0).\n   Offset: Transmitted\
    \ as zero (0) indicating no data is present.\n   Data: No data is present with\
    \ this attribute.\n"
- title: 6.9.3.2.  0x01 - Scaled Metric
  contents:
  - "6.9.3.2.  0x01 - Scaled Metric\n   If a route is received from a back-rev neighbor,\
    \ and the route is\n   selected as the best path, the scaled metric received in\
    \ the older\n   UPDATE may be attached to the packet.  If received, the value\
    \ is for\n   informational purposes and is not affected by K6.\n    0        \
    \           1                   2                   3\n    0 1 2 3 4 5 6 7 8 9\
    \ 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |       0x01    |       0x04    |          Reserved             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                       Scaled Bandwidth                        |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                         Scaled Delay                          |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   Reserved: Transmitted as 0x0000\n   Scaled Bandwidth: The minimum bandwidth\
    \ along a path expressed in\n      units of 2,560,000,000/kbps.  A bandwidth of\
    \ 0xFFFFFFFF indicates\n      an unreachable route.\n   Scaled Delay: An administrative\
    \ parameter assigned statically on a\n      per-interface-type basis to represent\
    \ the time it takes along an\n      unloaded path.  This is expressed in units\
    \ of tens of microseconds\n      divvied by 256.  A delay of 0xFFFFFFFF indicates\
    \ an unreachable\n      route.\n"
- title: 6.9.3.3.  0x02 - Administrator Tag
  contents:
  - "6.9.3.3.  0x02 - Administrator Tag\n   EIGRP administrative tag does not alter\
    \ the path decision-making\n   process.  Routers can set a tag value on a route\
    \ and use the flags to\n   apply specific routing polices within their network.\n\
    \    0                   1                   2                   3\n    0 1 2\
    \ 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |       0x02    |       0x02    |       Administrator Tag       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   | Administrator Tag (cont.)     |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   Administrator Tag: A tag assigned by the network administrator that\n    \
    \  is untouched by EIGRP.  This allows a network administrator to\n      filter\
    \ routes in other EIGRP border routers based on this value.\n"
- title: 6.9.3.4.  0x03 - Community List
  contents:
  - "6.9.3.4.  0x03 - Community List\n   EIGRP communities themselves do not alter\
    \ the path decision-making\n   process, communities can be used as flags in order\
    \ to mark a set of\n   routes.  Upstream routers can then use these flags to apply\
    \ specific\n   routing polices within their network.\n    0                  \
    \ 1                   2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4\
    \ 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |       0x03    |      Offset   |          Community List       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\
    \                               |\n   |                          (variable length)\
    \                    |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   Offset: Number of 16-bit words in the sub-field.\n   Community List: One or\
    \ more 8-octet EIGRP communities, as defined in\n      Section 6.4.\n"
- title: 6.9.3.5.  0x04 - Jitter
  contents:
  - "6.9.3.5.  0x04 - Jitter\n   (Optional) EIGRP can carry one-way Jitter in networks\
    \ that carry UDP\n   traffic if the node is capable of measuring UDP Jitter. \
    \ The Jitter\n   reported to will be averaged with any existing Jitter data and\n\
    \   include in the route updates.  If no Jitter value is reported by the\n   peer\
    \ for a given destination, EIGRP will use the locally collected\n   value.\n \
    \   0                   1                   2                   3\n    0 1 2 3\
    \ 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |        0x04    |      0x03    |             Jitter            |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\
    \                               |\n   |                                      \
    \                         |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   Jitter: The measure of the variability over time of the latency\n      across\
    \ a network measured in measured in microseconds.\n"
- title: 6.9.3.6.  0x05 - Quiescent Energy
  contents:
  - "6.9.3.6.  0x05 - Quiescent Energy\n   (Optional) EIGRP can carry energy usage\
    \ by nodes in networks if the\n   node is capable of measuring energy.  The Quiescent\
    \ Energy reported\n   will be added to any existing energy data and include in\
    \ the route\n   updates.  If no energy data is reported by the peer for a given\n\
    \   destination, EIGRP will use the locally collected value.\n    0          \
    \         1                   2                   3\n    0 1 2 3 4 5 6 7 8 9 0\
    \ 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |        0x05    |        0x02  |        Q-Energy (high)        |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |          Q-Energy (low)       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   Q-Energy: Paths with higher idle (standby) energy usage will be\n      reflected\
    \ in a higher aggregate metric than those having lower\n      energy usage.  If\
    \ present, this number will represent the idle\n      power consumption expressed\
    \ in milliwatts per kilobit.\n"
- title: 6.9.3.7.  0x06 - Energy
  contents:
  - "6.9.3.7.  0x06 - Energy\n   (Optional) EIGRP can carry energy usage by nodes\
    \ in networks if the\n   node is capable of measuring energy.  The active Energy\
    \ reported will\n   be added to any existing energy data and include in the route\n\
    \   updates.  If no energy data is reported by the peer for a given\n   destination,\
    \ EIGRP will use the locally collected value.\n    0                   1     \
    \              2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7\
    \ 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |        0x06    |      0x02    |          Energy (high)        |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |          Energy (low)         |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   Energy: Paths with higher active energy usage will be reflected in a\n   \
    \   higher aggregate metric than those having lower energy usage.  If\n      present,\
    \ this number will represent the power consumption\n      expressed in milliwatts\
    \ per kilobit.\n"
- title: 6.9.3.8.  0x07 - AddPath
  contents:
  - "6.9.3.8.  0x07 - AddPath\n   The Add Path enables EIGRP to advertise multiple\
    \ best paths to\n   adjacencies.  There will be up to a maximum of four AddPaths\n\
    \   supported, where the format of the field will be as follows.\n    0      \
    \             1                   2                   3\n    0 1 2 3 4 5 6 7 8\
    \ 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |       0x07    |       Offset  |     AddPath (Variable Length) |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   Offset: Number of 16-bit words in the sub-field.\n   AddPath: Length of this\
    \ field will vary in length based on whether it\n      contains IPv4 or IPv6 data.\n"
- title: 6.9.3.8.1.  AddPath with IPv4 Next Hop
  contents:
  - "6.9.3.8.1.  AddPath with IPv4 Next Hop\n    0                   1           \
    \        2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0\
    \ 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |       0x07    |       Offset  | Next-Hop Addr. (Upper 2 bytes)|\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   | IPv4 Address (Lower 2 bytes)  |       RID (Upper 2 bytes)     |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |        RID (Upper 2 bytes)    | Admin Tag (Upper 2 bytes)     |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   | Admin Tag (Upper 2 bytes)     |Extern Protocol| Flags Field   |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   Next-Hop Address: An IPv4 address represented by four 8-bit values\n     \
    \ (total 4 octets).  If the value is zero (0), the IPv6 address from\n      the\
    \ received IPv4 header is used as the next hop for the route.\n      Otherwise,\
    \ the specified IPv4 address will be used.\n   Router Identifier (RID): A 32-bit\
    \ number provided by the router\n      sourcing the information to uniquely identify\
    \ it as the source.\n   Admin Tag: A 32-bit administrative tag assigned by the\
    \ network.  This\n      allows a network administrator to filter routes based\
    \ on this\n      value.\n   If the route is of type external, then two additional\
    \ bytes will be\n   added as follows:\n   External Protocol: Contains an enumerated\
    \ value defined in Section\n      6.2 to identify the routing protocol (external\
    \ protocol)\n      redistributing the route.\n   Flags Field: See Section 6.8.1.\n"
- title: 6.9.3.8.2.  AddPath with IPv6 Next Hop
  contents:
  - "6.9.3.8.2.  AddPath with IPv6 Next Hop\n    0                   1           \
    \        2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0\
    \ 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |       0x07     |       Offset |         Next-Hop Address      |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\
    \                               |\n   |                                      \
    \                         |\n   |                            (16 octets)     \
    \                   |\n   |                               +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-|\n\
    \   |                               |       RID (Upper 2 byes)      |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |        RID (Upper 2 byes)     | Admin Tag (Upper 2 byes)      |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   | Admin Tag (Upper 2 byes)      | Extern Protocol | Flags Field |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   Next-Hop Address: An IPv6 address represented by eight groups of\n      16-bit\
    \ values (total 16 octets).  If the value is zero (0), the\n      IPv6 address\
    \ from the received IPv6 header is used as the next hop\n      for the route.\
    \  Otherwise, the specified IPv6 address will be\n      used.\n   Router Identifier\
    \ (RID): A 32-bit number provided by the router\n      sourcing the information\
    \ to uniquely identify it as the source.\n   Admin Tag: A 32-bit administrative\
    \ tag assigned by the network.  This\n      allows a network administrator to\
    \ filter routes based on this\n      value.  If the route is of type external,\
    \ then two addition bytes\n      will be added as follows:\n   External Protocol:\
    \ Contains an enumerated value defined in Section\n      6.2 to identify the routing\
    \ protocol (external protocol)\n      redistributing the route.\n   Flags Field:\
    \ See Section 6.8.1.\n"
- title: 6.9.4.  Exterior Encoding
  contents:
  - "6.9.4.  Exterior Encoding\n   Additional routing information provided for destinations\
    \ outside of\n   the EIGRP AS as follows:\n    0                   1         \
    \          2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9\
    \ 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                     Router Identifier (RID)                   |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |            External Autonomous System (AS) Number             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                     External Protocol Metric                  |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |            Reserved             |Extern Protocol| Flags Field |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   Router Identifier (RID): A 32-bit number provided by the router\n      sourcing\
    \ the information to uniquely identify it as the source.\n   External Autonomous\
    \ System (AS) Number: A 32-bit number indicating\n      the external AS of which\
    \ the sending router is a member.  If the\n      source protocol is EIGRP, this\
    \ field will be the [VRID, AS] pair.\n      If the external protocol does not\
    \ have an AS, other information\n      can be used (for example, Cisco uses process-id\
    \ for OSPF).\n   External Protocol Metric: A 32-bit value of the metric used by\
    \ the\n      routing table as learned by the foreign protocol.  If the External\n\
    \      Protocol is IGRP or EIGRP, the value can (optionally) be 0, and\n     \
    \ the metric information is stored in the metric section.\n   External Protocol:\
    \ Contains an enumerated value defined in Section\n      6.2 to identify the routing\
    \ protocol (external protocol)\n      redistributing the route.\n   Flags Field:\
    \ See Section 6.8.1.\n"
- title: 6.9.5.  Destination Encoding
  contents:
  - "6.9.5.  Destination Encoding\n   Destination information is encoded in Multiprotocol\
    \ packets in the\n   same manner used by Classic TLVs.  This is accomplished by\
    \ using a\n   counter to indicate how many significant bits are present in the\n\
    \   variable-length address field.\n    0                   1                \
    \   2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3\
    \ 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   | Subnet Mask   |    Destination Address (variable length       |\n   | Bit\
    \ Count     |         ((Bit Count - 1) / 8) + 1             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   Subnet Mask Bit Count: 8-bit value used to indicate the number of\n      bits\
    \ in the subnet mask.  A value of 0 indicates the default\n      network and no\
    \ address is present.\n   Destination Address: A variable-length field used to\
    \ carry the\n      destination address.  The length is determined by the number\
    \ of\n      consecutive bits in the destination address.  The formula to\n   \
    \   calculate the length is address-family dependent:\n      IPv4: ((Bit Count\
    \ - 1) / 8) + 1\n      IPv6: (Bit Count == 128) ? 16 : ((x / 8) + 1)\n"
- title: 6.9.6.  Route Information
  contents:
  - '6.9.6.  Route Information

    '
- title: 6.9.6.1.  INTERNAL TYPE
  contents:
  - "6.9.6.1.  INTERNAL TYPE\n   This TLV conveys destination information based on\
    \ the IANA AFI\n   defined in the TLV Header (see Section 6.9.1), and associated\
    \ metric\n   information.  Routes advertised in this TLV are network interfaces\n\
    \   that EIGRP is configured on as well as networks that are learned via\n   other\
    \ routers running EIGRP.\n"
- title: 6.9.6.2.  EXTERNAL TYPE
  contents:
  - "6.9.6.2.  EXTERNAL TYPE\n   This TLV conveys destination information based on\
    \ the IANA AFI\n   defined in the TLV Header (see Section 6.9.1), and metric information\n\
    \   for routes learned by other routing protocols that EIGRP injects into\n  \
    \ the AS.  Available with this information is the identity of the\n   routing\
    \ protocol that created the route, the external metric, the AS\n   number, an\
    \ indicator if it should be marked as part of the EIGRP AS,\n   and a network\
    \ administrator tag used for route filtering at EIGRP AS\n   boundaries.\n"
- title: 7.  Security Considerations
  contents:
  - "7.  Security Considerations\n   Being promiscuous, EIGRP will neighbor with any\
    \ router that sends a\n   valid HELLO packet.  Due to security considerations,\
    \ this\n   \"completely\" open aspect requires policy capabilities to limit\n\
    \   peering to valid routers.\n   EIGRP does not rely on a PKI or a heavyweight\
    \ authentication system.\n   These systems challenge the scalability of EIGRP,\
    \ which was a primary\n   design goal.\n   Instead, Denial-of-Service (DoS) attack\
    \ prevention will depend on\n   implementations rate-limiting packets to the control\
    \ plane as well as\n   authentication of the neighbor through the use of MD5 or\
    \ SHA2-256\n   [6].\n"
- title: 8.  IANA Considerations
  contents:
  - "8.  IANA Considerations\n   This document serves as the sole reference for two\
    \ multicast\n   addresses: 224.0.0.10 for IPv4 \"EIGRP Routers\" [13] and\n  \
    \ FF02:0:0:0:0:0:0:A for IPv6 \"EIGRP Routers\" [14].  It also serves as\n   assignment\
    \ for protocol number 88 (EIGRP) [15].\n"
- title: 9.  References
  contents:
  - '9.  References

    '
- title: 9.1.  Normative References
  contents:
  - "9.1.  Normative References\n   [1]  Bradner, S., \"Key words for use in RFCs\
    \ to Indicate Requirement\n        Levels\", BCP 14, RFC 2119, DOI 10.17487/RFC2119,\
    \ March 1997,\n        <http://www.rfc-editor.org/info/rfc2119>.\n   [2]  Garcia-Luna-Aceves,\
    \ J.J., \"A Unified Approach to Loop-Free\n        Routing Using Distance Vectors\
    \ or Link States\", SIGCOMM '89,\n        Symposium proceedings on Communications\
    \ architectures &\n        protocols, Volume 19, pages 212-223, ACM\n        089791-332-9/89/0009/0212,\
    \ DOI 10.1145/75247.75268, 1989.\n   [3]  Garcia-Luna-Aceves, J.J., \"Loop-Free\
    \ Routing using Diffusing\n        Computations\", Network Information Systems\
    \ Center, SRI\n        International, appeared in IEEE/ACM Transactions on Networking,\n\
    \        Vol. 1, No. 1, DOI 10.1109/90.222913, 1993.\n   [4]  Rosen, E. and Y.\
    \ Rekhter, \"IANA Registries for BGP Extended\n        Communities\", RFC 7153,\
    \ DOI 10.17487/RFC7153, March 2014,\n        <http://www.rfc-editor.org/info/rfc7153>.\n\
    \   [5]  Narten, T., \"Assigning Experimental and Testing Numbers\n        Considered\
    \ Useful\", BCP 82, RFC 3692, DOI 10.17487/RFC3692,\n        January 2004, <http://www.rfc-editor.org/info/rfc3692>.\n\
    \   [6]  Kelly, S. and S. Frankel, \"Using HMAC-SHA-256, HMAC-SHA-384, and\n \
    \       HMAC-SHA-512 with IPsec\", RFC 4868, DOI 10.17487/RFC4868, May\n     \
    \   2007, <http://www.rfc-editor.org/info/rfc4868>.\n   [7]  Deering, S., \"Host\
    \ extensions for IP multicasting\", STD 5,\n        RFC 1112, DOI 10.17487/RFC1112,\
    \ August 1989,\n        <http://www.rfc-editor.org/info/rfc1112>.\n   [8]  Postel,\
    \ J., \"Internet Protocol\", STD 5, RFC 791,\n        DOI 10.17487/RFC0791, September\
    \ 1981,\n        <http://www.rfc-editor.org/info/rfc791>.\n   [9]  Deering, S.\
    \ and R. Hinden, \"Internet Protocol, Version 6 (IPv6)\n        Specification\"\
    , RFC 2460, DOI 10.17487/RFC2460, December 1998,\n        <http://www.rfc-editor.org/info/rfc2460>.\n"
- title: 9.2.  Informative References
  contents:
  - "9.2.  Informative References\n   [10] Moy, J., \"OSPF Version 2\", STD 54, RFC\
    \ 2328,\n        DOI 10.17487/RFC2328, April 1998,\n        <http://www.rfc-editor.org/info/rfc2328>.\n\
    \   [11] Clark, A. and B. Claise, \"Guidelines for Considering New\n        Performance\
    \ Metric Development\", BCP 170, RFC 6390,\n        DOI 10.17487/RFC6390, October\
    \ 2011,\n        <http://www.rfc-editor.org/info/rfc6390>.\n   [12] IANA, \"Address\
    \ Family Numbers\",\n        <http://www.iana.org/assignments/address-family-numbers>.\n\
    \   [13] IANA, \"IPv4 Multicast Address Space Registry\",\n        <http://www.iana.org/assignments/multicast-addresses>.\n\
    \   [14] IANA, \"IPv6 Multicast Address Space Registry\",\n        <http://www.iana.org/assignments/ipv6-multicast-addresses>.\n\
    \   [15] IANA, \"Protocol Numbers\",\n        <http://www.iana.org/assignments/protocol-numbers>.\n"
- title: Acknowledgments
  contents:
  - "Acknowledgments\n   Thank you goes to Dino Farinacci, Bob Albrightson, and Dave\
    \ Katz.\n   Their significant accomplishments towards the design and development\n\
    \   of the EIGRP provided the bases for this document.\n   A special and appreciative\
    \ thank you goes to the core group of Cisco\n   engineers whose dedication, long\
    \ hours, and hard work led the\n   evolution of EIGRP over the past decade.  They\
    \ are Donnie Savage,\n   Mickel Ravizza, Heidi Ou, Dawn Li, Thuan Tran, Catherine\
    \ Tran, Don\n   Slice, Claude Cartee, Donald Sharp, Steven Moore, Richard Wellum,\
    \ Ray\n   Romney, Jim Mollmann, Dennis Wind, Chris Van Heuveln, Gerald Redwine,\n\
    \   Glen Matthews, Michael Wiebe, and others.\n   The authors would like to gratefully\
    \ acknowledge many people who have\n   contributed to the discussions that lead\
    \ to the making of this\n   proposal.  They include Chris Le, Saul Adler, Scott\
    \ Van de Houten,\n   Lalit Kumar, Yi Yang, Kumar Reddy, David Lapier, Scott Kirby,\
    \ David\n   Prall, Jason Frazier, Eric Voit, Dana Blair, Jim Guichard, and Alvaro\n\
    \   Retana.\n   In addition to the tireless work provided by the Cisco engineers\
    \ over\n   the years, we would like to personally recognize the teams that\n \
    \  created open source versions of EIGRP:\n   o  Linux implementation developed\
    \ by the Quagga team: Jan Janovic,\n      Matej Perina, Peter Orsag, and Peter\
    \ Paluch.\n   o  BSD implementation developed and released by Renato Westphal.\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Donnie V. Savage\n   Cisco Systems, Inc.\n   7025 Kit\
    \ Creek Rd., RTP,\n   Morrisville, NC 27560\n   United States\n   Phone: 919-392-2379\n\
    \   Email: dsavage@cisco.com\n   James Ng\n   Cisco Systems, Inc.\n   7025 Kit\
    \ Creek Rd., RTP,\n   Morrisville, NC 27560\n   United States\n   Phone: 919-392-2582\n\
    \   Email: jamng@cisco.com\n   Steven Moore\n   Cisco Systems, Inc.\n   7025 Kit\
    \ Creek Rd., RTP,\n   Morrisville, NC 27560\n   United States\n   Phone: 408-895-2031\n\
    \   Email: smoore@cisco.com\n   Donald Slice\n   Cumulus Networks\n   Apex, NC\n\
    \   United States\n   Email: dslice@cumulusnetworks.com\n   Peter Paluch\n   University\
    \ of Zilina\n   Univerzitna 8215/1, Zilina 01026\n   Slovakia\n   Phone: 421-905-164432\n\
    \   Email: Peter.Paluch@fri.uniza.sk\n   Russ White\n   LinkedIn\n   Apex, NC\n\
    \   United States\n   Phone: 1-877-308-0993\n   Email: russw@riw.us\n"
