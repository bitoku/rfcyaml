- title: __initial_text__
  contents:
  - ''
- title: Independent Submission                                   D. Harkins, Ed.
  contents:
  - "Independent Submission                                   D. Harkins, Ed.\n  \
    \  Secure Password Ciphersuites for Transport Layer Security (TLS)\n"
- title: Abstract
  contents:
  - "Abstract\n   This memo defines several new ciphersuites for the Transport Layer\n\
    \   Security (TLS) protocol to support certificateless, secure\n   authentication\
    \ using only a simple, low-entropy password.  The\n   exchange is called \"TLS-PWD\"\
    .  The ciphersuites are all based on an\n   authentication and key exchange protocol,\
    \ named \"dragonfly\", that is\n   resistant to offline dictionary attacks.\n"
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This document is not an Internet Standards Track specification;\
    \ it is\n   published for informational purposes.\n   This is a contribution to\
    \ the RFC Series, independently of any other\n   RFC stream.  The RFC Editor has\
    \ chosen to publish this document at\n   its discretion and makes no statement\
    \ about its value for\n   implementation or deployment.  Documents approved for\
    \ publication by\n   the RFC Editor are not candidates for any level of Internet\
    \ Standard;\n   see Section 2 of RFC 7841.\n   Information about the current status\
    \ of this document, any errata,\n   and how to provide feedback on it may be obtained\
    \ at\n   https://www.rfc-editor.org/info/rfc8492.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (c) 2019 IETF Trust and the persons identified\
    \ as the\n   document authors.  All rights reserved.\n   This document is subject\
    \ to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n\
    \   (https://trustee.ietf.org/license-info) in effect on the date of\n   publication\
    \ of this document.  Please review these documents\n   carefully, as they describe\
    \ your rights and restrictions with respect\n   to this document.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1. Introduction and Motivation .....................................3\n\
    \      1.1. The Case for Certificateless Authentication ................3\n  \
    \    1.2. Resistance to Dictionary Attacks ...........................3\n   2.\
    \ Key Words .......................................................4\n   3. Notation\
    \ and Background .........................................4\n      3.1. Notation\
    \ ...................................................4\n      3.2. Discrete Logarithm\
    \ Cryptography ............................5\n           3.2.1. Elliptic Curve\
    \ Cryptography .........................5\n           3.2.2. Finite Field Cryptography\
    \ ...........................7\n      3.3. Instantiating the Random Function ..........................8\n\
    \      3.4. Passwords ..................................................8\n  \
    \    3.5. Assumptions ................................................9\n   4.\
    \ Specification of the TLS-PWD Handshake .........................10\n      4.1.\
    \ TLS-PWD Pre-TLS 1.3 .......................................10\n      4.2. TLS-PWD\
    \ in TLS 1.3 ........................................11\n      4.3. Protecting\
    \ the Username ...................................11\n           4.3.1. Construction\
    \ of a Protected Username ...............12\n           4.3.2. Recovery of a Protected\
    \ Username ...................13\n      4.4. Fixing the Password Element ...............................14\n\
    \           4.4.1. Computing an ECC Password Element ..................16\n  \
    \         4.4.2. Computing an FFC Password Element ..................18\n    \
    \       4.4.3. Password Naming ....................................19\n      \
    \     4.4.4. Generating TLS-PWD Commit ..........................20\n      4.5.\
    \ Changes to Handshake Message Contents .....................20\n           4.5.1.\
    \ Pre-1.3 TLS ........................................20\n                  4.5.1.1.\
    \ ClientHello Changes .......................20\n                  4.5.1.2. ServerKeyExchange\
    \ Changes .................21\n                  4.5.1.3. ClientKeyExchange Changes\
    \ .................23\n           4.5.2. TLS 1.3 ............................................24\n\
    \                  4.5.2.1. TLS 1.3 KeyShare ..........................24\n  \
    \                4.5.2.2. ClientHello Changes .......................24\n    \
    \              4.5.2.3. ServerHello Changes .......................25\n      \
    \            4.5.2.4. HelloRetryRequest Changes .................25\n      4.6.\
    \ Computing the Shared Secret ...............................26\n   5. Ciphersuite\
    \ Definition .........................................26\n   6. IANA Considerations\
    \ ............................................27\n   7. Security Considerations\
    \ ........................................27\n   8. Human Rights Considerations\
    \ ....................................30\n   9. Implementation Considerations\
    \ ..................................31\n   10. References ....................................................32\n\
    \      10.1. Normative References .....................................32\n  \
    \    10.2. Informative References ...................................33\n   Appendix\
    \ A. Example Exchange ......................................35\n   Acknowledgements\
    \ ..................................................40\n   Author's Address ..................................................40\n"
- title: 1.  Introduction and Motivation
  contents:
  - '1.  Introduction and Motivation

    '
- title: 1.1.  The Case for Certificateless Authentication
  contents:
  - "1.1.  The Case for Certificateless Authentication\n   Transport Layer Security\
    \ (TLS) usually uses public key certificates\n   for authentication [RFC5246]\
    \ [RFC8446].  This is problematic in some\n   cases:\n   o  Frequently, TLS [RFC5246]\
    \ is used in devices owned, operated, and\n      provisioned by people who lack\
    \ competency to properly use\n      certificates and merely want to establish\
    \ a secure connection\n      using a more natural credential like a simple password.\
    \  The\n      proliferation of deployments that use a self-signed server\n   \
    \   certificate in TLS [RFC5246] followed by a basic password exchange\n     \
    \ over the unauthenticated channel underscores this case.\n   o  The alternatives\
    \ to TLS-PWD for employing certificateless TLS\n      authentication -- using\
    \ pre-shared keys in an exchange that is\n      susceptible to dictionary attacks\
    \ or using a Secure Remote\n      Password (SRP) exchange that requires users\
    \ to, a priori, be fixed\n      to a specific Finite Field Cryptography (FFC)\
    \ group for all\n      subsequent connections -- are not acceptable for modern\n\
    \      applications that require both security and cryptographic agility.\n  \
    \ o  A password is a more natural credential than a certificate (from\n      early\
    \ childhood, people learn the semantics of a shared secret),\n      so a password-based\
    \ TLS ciphersuite can be used to protect an\n      HTTP-based certificate enrollment\
    \ scheme like Enrollment over\n      Secure Transport (EST) [RFC7030] to parlay\
    \ a simple password into\n      a certificate for subsequent use with any certificate-based\n\
    \      authentication protocol.  This addresses a significant\n      \"chicken-and-egg\"\
    \ dilemma found with certificate-only use of\n      [RFC5246].\n   o  Some PIN-code\
    \ readers will transfer the entered PIN to a smart\n      card in cleartext. \
    \ Assuming a hostile environment, this is a bad\n      practice.  A password-based\
    \ TLS ciphersuite can enable the\n      establishment of an authenticated connection\
    \ between reader and\n      card based on the PIN.\n"
- title: 1.2.  Resistance to Dictionary Attacks
  contents:
  - "1.2.  Resistance to Dictionary Attacks\n   It is a common misconception that\
    \ a protocol that authenticates with\n   a shared and secret credential is resistant\
    \ to dictionary attacks if\n   the credential is assumed to be an N-bit uniformly\
    \ random secret,\n   where N is sufficiently large.  The concept of resistance\
    \ to\n   dictionary attacks really has nothing to do with whether that secret\n\
    \   can be found in a standard collection of a language's defined words\n   (i.e.,\
    \ a dictionary).  It has to do with how an adversary gains an\n   advantage in\
    \ attacking the protocol.\n   For a protocol to be resistant to dictionary attacks,\
    \ any advantage\n   an adversary can gain must be a function of the amount of\n\
    \   interactions she makes with an honest protocol participant and not a\n   function\
    \ of the amount of computation she uses.  This means that the\n   adversary will\
    \ not be able to obtain any information about the\n   password except whether\
    \ a single guess from a single protocol run\n   that she took part in is correct\
    \ or incorrect.\n   It is assumed that the attacker has access to a pool of data\
    \ from\n   which the secret was drawn -- it could be all numbers between 1 and\n\
    \   2^N; it could be all defined words in a dictionary.  The key is that\n   the\
    \ attacker cannot do an attack and then go offline and enumerate\n   through the\
    \ pool trying potential secrets (computation) to see if one\n   is correct.  She\
    \ must do an active attack for each secret she wishes\n   to try (interaction),\
    \ and the only information she can glean from\n   that attack is whether the secret\
    \ used with that particular attack is\n   correct or not.\n"
- title: 2.  Key Words
  contents:
  - "2.  Key Words\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\"\
    , \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"NOT RECOMMENDED\"\
    , \"MAY\", and\n   \"OPTIONAL\" in this document are to be interpreted as described\
    \ in\n   BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all\n\
    \   capitals, as shown here.\n"
- title: 3.  Notation and Background
  contents:
  - '3.  Notation and Background

    '
- title: 3.1.  Notation
  contents:
  - "3.1.  Notation\n   The following notation is used in this memo:\n   password\n\
    \       a secret -- and potentially low-entropy -- word, phrase, code, or\n  \
    \     key used as a credential for authentication.  The password is\n       shared\
    \ between the TLS client and TLS server.\n   y = H(x)\n       a binary string\
    \ of arbitrary length, x, is given to a function H,\n       which produces a fixed-length\
    \ output, y.\n   a | b\n       denotes concatenation of string \"a\" with string\
    \ \"b\".\n   [a]b\n       indicates a string consisting of the single bit \"a\"\
    \ repeated\n       \"b\" times.\n   x mod y\n       indicates the remainder of\
    \ division of x by y.  The result will\n       be between 0 and y.\n   len(x)\n\
    \       indicates the length in bits of the string \"x\".\n   lgr(a, b)\n    \
    \   takes \"a\" and a prime, b, and returns the Legendre symbol (a/b).\n   LSB(x)\n\
    \       returns the least-significant bit of the bitstring \"x\".\n   G.x\n  \
    \     indicates the x-coordinate of a point, G, on an elliptic curve.\n"
- title: 3.2.  Discrete Logarithm Cryptography
  contents:
  - "3.2.  Discrete Logarithm Cryptography\n   The ciphersuites defined in this memo\
    \ use discrete logarithm\n   cryptography (see [SP800-56A]) to produce an authenticated\
    \ and shared\n   secret value that is an Element in a group defined by a set of\
    \ domain\n   parameters.  The domain parameters can be based on either FFC or\n\
    \   Elliptic Curve Cryptography (ECC).\n   Elements in a group -- either an FFC\
    \ or ECC group -- are indicated\n   using uppercase, while scalar values are indicated\
    \ using lowercase.\n"
- title: 3.2.1.  Elliptic Curve Cryptography
  contents:
  - "3.2.1.  Elliptic Curve Cryptography\n   The authenticated key exchange defined\
    \ in this memo uses fundamental\n   algorithms of elliptic curves defined over\
    \ GF(p) as described in\n   [RFC6090].  Ciphersuites defined in this memo SHALL\
    \ only use ECC\n   curves based on the Weierstrass equation y^2 = x^3 + a*x +\
    \ b.\n   Domain parameters for the ECC groups used by this memo are:\n   o  A\
    \ prime, p, determining a prime field GF(p).  The cryptographic\n      group will\
    \ be a subgroup of the full elliptic curve group, which\n      consists of points\
    \ on an elliptic curve -- Elements from GF(p)\n      that satisfy the curve's\
    \ equation -- together with the \"point at\n      infinity\" that serves as the\
    \ identity Element.\n   o  Elements a and b from GF(p) that define the curve's\
    \ equation.  The\n      point (x, y) in GF(p) x GF(p) is on the elliptic curve\
    \ if and only\n      if (y^2 - x^3 - a*x - b) mod p equals zero (0).\n   o  A\
    \ point, G, on the elliptic curve, which serves as a generator for\n      the\
    \ ECC group.  G is chosen such that its order, with respect to\n      elliptic\
    \ curve addition, is a sufficiently large prime.\n   o  A prime, q, which is the\
    \ order of G and thus is also the size of\n      the cryptographic subgroup that\
    \ is generated by G.\n   o  A co-factor, f, defined by the requirement that the\
    \ size of the\n      full elliptic curve group (including the \"point at infinity\"\
    ) be\n      the product of f and q.\n   This memo uses the following ECC functions:\n\
    \   o  Z = elem-op(X, Y) = X + Y: two points on the curve, X and Y, are\n    \
    \  summed to produce another point on the curve, Z.  This is the\n      group\
    \ operation for ECC groups.\n   o  Z = scalar-op(x, Y) = x * Y: an integer scalar,\
    \ x, acts on a point\n      on the curve, Y, via repetitive addition (Y is added\
    \ to itself\n      x times), to produce another ECC Element, Z.\n   o  Y = inverse(X):\
    \ a point on the curve, X, has an inverse, Y, which\n      is also a point on\
    \ the curve, when their sum is the \"point at\n      infinity\" (the identity\
    \ for elliptic curve addition).  In other\n      words, R + inverse(R) = \"0\"\
    .\n   o  z = F(X): the x-coordinate of a point (x, y) on the curve is\n      returned.\
    \  This is a mapping function to convert a group Element\n      into an integer.\n\
    \   Only ECC groups over GF(p) can be used with TLS-PWD.\n   Characteristic-2\
    \ curves SHALL NOT be used by TLS-PWD.  ECC groups\n   over GF(2^m) SHALL NOT\
    \ be used by TLS-PWD.  In addition, ECC groups\n   with a co-factor greater than\
    \ one (1) SHALL NOT be used by TLS-PWD.\n   A composite (x, y) pair can be validated\
    \ as a point on the elliptic\n   curve by checking that 1) both coordinates x\
    \ and y are greater than\n   zero (0) and less than the prime defining the underlying\
    \ field,\n   2) coordinates x and y satisfy the equation of the curve, and 3)\
    \ they\n   do not represent the \"point at infinity\".  If any of those conditions\n\
    \   are not true, the (x, y) pair is not a valid point on the curve.\n   A compliant\
    \ implementation of TLS-PWD SHALL support\n   group twenty-three (23) and SHOULD\
    \ support group twenty-four (24)\n   from the \"TLS Supported Groups\" registry;\
    \ see [TLS_REG].\n"
- title: 3.2.2.  Finite Field Cryptography
  contents:
  - "3.2.2.  Finite Field Cryptography\n   Domain parameters for the FFC groups used\
    \ by this memo are:\n   o  A prime, p, determining a prime field GF(p) (i.e.,\
    \ the integers\n      modulo p).  The FFC group will be a subgroup of GF(p)* (i.e.,\
    \ the\n      multiplicative group of non-zero Elements in GF(p)).\n   o  An Element,\
    \ G, in GF(p)*, which serves as a generator for the FFC\n      group.  G is chosen\
    \ such that its multiplicative order is a\n      sufficiently large prime divisor\
    \ of ((p - 1)/2).\n   o  A prime, q, which is the multiplicative order of G and\
    \ thus is\n      also the size of the cryptographic subgroup of GF(p)* that is\n\
    \      generated by G.\n   This memo uses the following FFC functions:\n   o \
    \ Z = elem-op(X, Y) = (X * Y) mod p: two FFC Elements, X and Y, are\n      multiplied\
    \ modulo the prime, p, to produce another FFC Element, Z.\n      This is the group\
    \ operation for FFC groups.\n   o  Z = scalar-op(x, Y) = Y^x mod p: an integer\
    \ scalar, x, acts on an\n      FFC group Element, Y, via exponentiation modulo\
    \ the prime, p, to\n      produce another FFC Element, Z.\n   o  Y = inverse(X):\
    \ a group Element, X, has an inverse, Y, when the\n      product of the Element\
    \ and its inverse modulo the prime equals\n      one (1).  In other words, (X\
    \ * inverse(X)) mod p = 1.\n   o  z = F(X): is the identity function, since an\
    \ Element in an FFC\n      group is already an integer.  It is included here for\
    \ consistency\n      in the specification.\n   Many FFC groups used in IETF protocols\
    \ are based on safe primes and\n   do not define an order (q).  For these groups,\
    \ the order (q) used in\n   this memo shall be the prime of the group minus one\
    \ divided by two --\n   (p - 1)/2.\n   An integer can be validated as being an\
    \ Element in an FFC group by\n   checking that 1) it is between one (1) and the\
    \ prime, p, exclusive\n   and 2) modular exponentiation of the integer by the\
    \ group order, q,\n   equals one (1).  If either of these conditions is not true,\
    \ the\n   integer is not an Element in the group.\n   A compliant implementation\
    \ of TLS-PWD SHOULD support\n   group two hundred fifty-six (256) and group two\
    \ hundred fifty-eight\n   (258) from the \"TLS Supported Groups\" registry on\
    \ [TLS_REG].\n"
- title: 3.3.  Instantiating the Random Function
  contents:
  - "3.3.  Instantiating the Random Function\n   The protocol described in this memo\
    \ uses a random function, H, which\n   is modeled as a \"random oracle\".  At\
    \ first glance, one may view this\n   as a hash function.  As noted in [RANDOR],\
    \ though, hash functions are\n   too structured to be used directly as a random\
    \ oracle.  But they can\n   be used to instantiate the random oracle.\n   The\
    \ random function, H, in this memo is instantiated by using the\n   hash algorithm\
    \ defined by the particular TLS-PWD ciphersuite in\n   Hashed Message Authentication\
    \ Code (HMAC) mode with a key whose\n   length is equal to the block size of the\
    \ hash algorithm and whose\n   value is zero.  For example, if the ciphersuite\
    \ is\n   TLS_ECCPWD_WITH_AES_128_GCM_SHA256, then H will be instantiated with\n\
    \   SHA256 as:\n      H(x) = HMAC-SHA256([0]32, x)\n"
- title: 3.4.  Passwords
  contents:
  - "3.4.  Passwords\n   The authenticated key exchange used in TLS-PWD requires each\
    \ side to\n   have a common view of a shared credential.  To protect the server's\n\
    \   database of stored passwords, a password MAY be salted.  When\n   [RFC5246]\
    \ or earlier is used, the password SHALL be salted.  When\n   [RFC8446] is used,\
    \ a password MAY be stored with a salt or without.\n   The password, username,\
    \ and, optionally, the salt can create an\n   irreversible digest called the \"\
    base\", which is used in the\n   authenticated key exchange.\n   The salting function\
    \ is defined as:\n      base = HMAC-SHA256(salt, username | password)\n   The\
    \ unsalted function is defined as:\n      base = SHA256(username | password)\n\
    \   The password used for generation of the base SHALL be represented as\n   a\
    \ UTF-8 encoded character string processed according to the rules of\n   the OpaqueString\
    \ profile of [RFC8265], and the salt SHALL be a\n   32-octet random number.  The\
    \ server SHALL store a tuple of the form:\n      { username, base, salt }\n  \
    \ if the password is salted and:\n      { username, base }\n   if it is not. \
    \ When password salting is being used, the client\n   generates the base upon\
    \ receiving the salt from the server;\n   otherwise, it may store the base at\
    \ the time the username and\n   password are provisioned.\n"
- title: 3.5.  Assumptions
  contents:
  - "3.5.  Assumptions\n   The security properties of the authenticated key exchange\
    \ defined in\n   this memo are based on a number of assumptions:\n   1.  The random\
    \ function, H, is a \"random oracle\" as defined in\n       [RANDOR].\n   2. \
    \ The discrete logarithm problem for the chosen group is hard.\n       That is,\
    \ given g, p, and y = g^x mod p, it is computationally\n       infeasible to determine\
    \ x.  Similarly, for an ECC group given the\n       curve definition, a generator\
    \ G, and Y = x * G, it is\n       computationally infeasible to determine x.\n\
    \   3.  Quality random numbers with sufficient entropy can be created.\n     \
    \  This may entail the use of specialized hardware.  If such\n       hardware\
    \ is unavailable, a cryptographic mixing function (like a\n       strong hash\
    \ function) to distill entropy from multiple,\n       uncorrelated sources of\
    \ information and events may be needed.  A\n       very good discussion of this\
    \ can be found in [RFC4086].\n   If the server supports username protection (see\
    \ Section 4.3), it is\n   assumed that the server has chosen a domain parameter\
    \ set and\n   generated a username-protection keypair.  The chosen domain parameter\n\
    \   set and public key are assumed to be conveyed to the client at the\n   time\
    \ the client's username and password were provisioned.\n"
- title: 4.  Specification of the TLS-PWD Handshake
  contents:
  - "4.  Specification of the TLS-PWD Handshake\n   The key exchange underlying TLS-PWD\
    \ is the \"dragonfly\"\n   password-authenticated key exchange (PAKE) as defined\
    \ in [RFC7664].\n   The authenticated key exchange is accomplished by each side\
    \ deriving\n   a Password Element (PE) [RFC7664] in the chosen group, making a\n\
    \   \"commitment\" to a single guess of the password using the PE, and\n   generating\
    \ a shared secret.  The ability of each side to produce a\n   valid finished message\
    \ using a key derived from the shared secret\n   allows each side to authenticates\
    \ itself to the other side.\n   The authenticated key exchange is dropped into\
    \ the standard TLS\n   message handshake by defining extensions to some of the\
    \ messages.\n"
- title: 4.1.  TLS-PWD Pre-TLS 1.3
  contents:
  - "4.1.  TLS-PWD Pre-TLS 1.3\n          Client                                 \
    \           Server\n         --------                                        \
    \  --------\n          ClientHello (name)      -------->\n                   \
    \                                     ServerHello\n                          \
    \               ServerKeyExchange (commit)\n                                 \
    \ <--------        ServerHello Done\n          ClientKeyExchange (commit)\n  \
    \        ChangeCipherSpec\n          Finished                -------->\n     \
    \                                              ChangeCipherSpec\n            \
    \                      <--------                Finished\n          Application\
    \ Data        <------->        Application Data\n                  Figure 1: Pre-TLS\
    \ 1.3 TLS-PWD Handshake\n"
- title: 4.2.  TLS-PWD in TLS 1.3
  contents:
  - "4.2.  TLS-PWD in TLS 1.3\n         Client                                   \
    \         Server\n        --------                                          --------\n\
    \         ClientHello (name)\n         + key_share (commit)       -------->\n\
    \                                                        ServerHello\n       \
    \                                        + key_share (commit)\n              \
    \                                {EncryptedExtensions}\n                     \
    \                                    {Finished}\n                            \
    \        <--------   [Application Data*]\n         {Finished}                \
    \ -------->\n         [Application Data]         <------->    [Application Data]\n\
    \                    Figure 2: TLS 1.3 TLS-PWD Handshake\n"
- title: 4.3.  Protecting the Username
  contents:
  - "4.3.  Protecting the Username\n   The client is required to identify herself\
    \ to the server before the\n   server can look up the appropriate client credential\
    \ with which to\n   perform the authenticated key exchange.  This has negative\
    \ privacy\n   implications and opens up the client to tracking and increased\n\
    \   monitoring.  It is therefore useful for the client to be able to\n   protect\
    \ her username from passive monitors of the exchange and\n   against active attack\
    \ by a malicious server.  TLS-PWD provides such a\n   mechanism.  Support for\
    \ protected usernames is RECOMMENDED.\n   To enable username protection, a server\
    \ chooses a domain parameter\n   set and generates an ephemeral public/private\
    \ keypair.  This keypair\n   SHALL only be used for username protection.  For\
    \ efficiency, the\n   domain parameter set used for username protection MUST be\
    \ based on\n   ECC.  Any ECC group that is appropriate for TLS-PWD (see\n   Section\
    \ 3.2.1) is suitable for this purpose, but for\n   interoperability, prime256v1\
    \ (aka NIST's p256 curve) MUST be\n   supported.  The domain parameter set chosen\
    \ for username protection\n   is independent of the domain parameter set chosen\
    \ for the underlying\n   key exchange -- i.e., they need not be the same.\n  \
    \ When the client's username and password are provisioned on the\n   server, the\
    \ chosen group and its public key are provisioned on the\n   client.  This is\
    \ stored on the client along with the server-specific\n   state (e.g., the hostname)\
    \ it uses to initiate a TLS-PWD exchange.\n   The server uses the same group and\
    \ public key with all clients.\n   To protect a username, the client and server\
    \ perform a static-\n   ephemeral Diffie-Hellman exchange.  Since the y-coordinate\
    \ is not\n   necessary and eliminating it will reduce message size, compact\n\
    \   representation (and therefore compact output; see [RFC6090]) is used\n   in\
    \ the static-ephemeral Diffie-Hellman exchange.  The result of the\n   Diffie-Hellman\
    \ exchange is passed to the HMAC-based Key Derivation\n   Function (HKDF) [RFC5869]\
    \ to create a key-encrypting key suitable for\n   AES-SIV [RFC5297] (where \"\
    AES\" stands for \"Advanced Encryption\n   Standard\" and \"SIV\" stands for \"\
    Synthetic Initialization Vector\") in\n   its deterministic authenticated encryption\
    \ mode.  The length of the\n   key-encrypting key (1) and the hash function to\
    \ use with the HKDF\n   depend on the length of the prime, p, of the group used\
    \ to provide\n   username protection:\n   o  SHA-256, SIV-128, l=256 bits: when\
    \ len(p) <= 256\n   o  SHA-384, SIV-192, l=384 bits: when 256 < len(p) <= 384\n\
    \   o  SHA-512, SIV-256, l=512 bits: when len(p) > 384\n"
- title: 4.3.1.  Construction of a Protected Username
  contents:
  - "4.3.1.  Construction of a Protected Username\n   Prior to initiating a TLS-PWD\
    \ exchange, the client chooses a random\n   secret, c, such that 1 < c < (q -\
    \ 1), where q is the order of the\n   group from which the server's public key\
    \ was generated, and it uses\n   scalar-op() with the group's generator to create\
    \ a public key, C.  It\n   uses scalar-op() with the server's public key and c\
    \ to create a\n   shared secret, and it derives a key-encrypting key, k, using\
    \ the\n   \"saltless\" mode of the HKDF [RFC5869]:\n      C = scalar-op(c, G)\n\
    \      Z = scalar-op(c, S)\n      k = HKDF-expand(HKDF-extract(NULL, Z.x), \"\"\
    , l)\n   where NULL indicates the salt-free invocation and \"\" indicates an\n\
    \   empty string (i.e., there is no \"context\" passed to the HKDF).\n   The client's\
    \ username SHALL be represented as a UTF-8 encoded\n   character string processed\
    \ according to the rules of the OpaqueString\n   profile of [RFC8265].  The output\
    \ of OpaqueString is then passed with\n   the key, k, to SIV-encrypt with no Additional\
    \ Authenticated Data\n   (AAD) and no nonce, to produce an encrypted username,\
    \ u:\n      u = SIV-encrypt(k, username)\n   Note: The format of the ciphertext\
    \ output includes the\n   authenticating SIV.\n   The protected username SHALL\
    \ be the concatenation of the x-coordinate\n   of the client's public key, C,\
    \ and the encrypted username, u.  The\n   length of the x-coordinate of C MUST\
    \ be equal to the length of the\n   group's prime, p, prepended with zeros, if\
    \ necessary.  The protected\n   username is inserted into the extension_data field\
    \ of the pwd_protect\n   extension (see Section 4.4.3).\n   To ensure that the\
    \ username remains confidential, the random secret,\n   c, MUST be generated from\
    \ a source of random entropy; see\n   Section 3.5.\n   The length of the ciphertext\
    \ output from SIV, minus the synthetic\n   initialization vector, will be equal\
    \ to the length of the input\n   plaintext -- in this case, the username.  To\
    \ further foil traffic\n   analysis, it is RECOMMENDED that clients append a series\
    \ of NULL\n   bytes to their usernames prior to passing them to SIV-encrypt()\
    \ such\n   that the resulting padded length of the username is at least\n   128\
    \ octets.\n"
- title: 4.3.2.  Recovery of a Protected Username
  contents:
  - "4.3.2.  Recovery of a Protected Username\n   A server that receives a protected\
    \ username needs to recover the\n   client's username prior to performing the\
    \ key exchange.  To do so,\n   the server computes the client's public key; completes\
    \ the static-\n   ephemeral Diffie-Hellman exchange; derives the key-encrypting\
    \ key, k;\n   and decrypts the username.\n   The length of the x-coordinate of\
    \ the client's public key is known\n   (it is the length of the prime from the\
    \ domain parameter set used to\n   protect usernames) and can easily be separated\
    \ from the ciphertext in\n   the pwd_name extension in the ClientHello -- the\
    \ first len(p) bits\n   are the x-coordinate of the client's public key, and the\
    \ remaining\n   bits are the ciphertext.\n   Since compressed representation is\
    \ used by the client, the server\n   MUST compute the y-coordinate of the client's\
    \ public key by using the\n   equation of the curve:\n      y^2 = x^3 + ax + b\n\
    \   and solving for y.  There are two solutions for y, but since\n   compressed\
    \ output is also being used, the selection is irrelevant.\n   The server reconstructs\
    \ the client's public value, C, from (x, y).\n   If there is no solution for y\
    \ or if (x, y) is not a valid point on\n   the elliptic curve (see Section 3.2.1),\
    \ the server MUST treat the\n   ClientHello as if it did not have a password for\
    \ a given username\n   (see Section 4.5.1.1).\n   The server then uses scalar-op()\
    \ with the reconstructed point C and\n   the private key it uses for protected\
    \ passwords, s, to generate a\n   shared secret, and it derives a key-encrypting\
    \ key, k, in the same\n   manner as that described in Section 4.3.1.\n      Z\
    \ = scalar-op(s, C)\n      k = HKDF-expand(HKDF-extract(NULL, Z.x), \"\", l)\n\
    \   The key, k, and the ciphertext portion of the pwd_name extension, u,\n   are\
    \ passed to SIV-decrypt with no AAD and no nonce, to produce the\n   username:\n\
    \      username = SIV-decrypt(k, u)\n   If SIV-decrypt returns the symbol FAIL\
    \ indicating unsuccessful\n   decryption and verification, the server MUST treat\
    \ the ClientHello as\n   if it did not have a password for a given username (see\n\
    \   Section 4.5.1.1).  If successful, the server has obtained the\n   client's\
    \ username and can process it as needed.  Any NULL octets\n   added by the client\
    \ prior to encryption can be easily stripped off of\n   the string that represents\
    \ the username.\n"
- title: 4.4.  Fixing the Password Element
  contents:
  - "4.4.  Fixing the Password Element\n   Prior to making a \"commitment\", both\
    \ sides must generate a secret\n   Element (PE) in the chosen group, using the\
    \ common password-derived\n   base.  The server generates the PE after it receives\
    \ the ClientHello\n   and chooses the particular group to use, and the client\
    \ generates the\n   PE prior to sending the ClientHello in TLS 1.3 and upon receipt\
    \ of\n   the ServerKeyExchange in TLS pre-1.3.\n   Fixing the PE involves an iterative\
    \ \"hunting-and-pecking\" technique\n   using the prime from the negotiated group's\
    \ domain parameter set and\n   an ECC-specific or FFC-specific operation, depending\
    \ on the\n   negotiated group.\n   To thwart side-channel attacks that attempt\
    \ to determine the number\n   of iterations of the hunting-and-pecking loop that\
    \ are used to find\n   the PE for a given password, a security parameter, m, is\
    \ used to\n   ensure that at least m iterations are always performed.\n   First,\
    \ an 8-bit counter is set to the value one (1).  Then, H is used\n   to generate\
    \ a password seed from the counter, the prime of the\n   selected group, and the\
    \ base (which is derived from the username,\n   password, and, optionally, the\
    \ salt; see Section 3.4):\n   pwd-seed = H(base | counter | p)\n   Next, a context\
    \ is generated consisting of random information.  For\n   versions of TLS less\
    \ than 1.3, the context is a concatenation of the\n   ClientHello random and the\
    \ ServerHello random.  For TLS 1.3, the\n   context is the ClientHello random:\n\
    \   if (version < 1.3) {\n     context = ClientHello.random | ServerHello.random\n\
    \   } else {\n     context = ClientHello.random\n   }\n   Then, using the technique\
    \ from Appendix B.5.1 of [FIPS186-4], the\n   pwd-seed is expanded, using the\
    \ Pseudorandom Function (PRF), to the\n   length of the prime from the negotiated\
    \ group's domain parameter set\n   plus a constant, sixty-four (64), to produce\
    \ an intermediate pwd-tmp,\n   which is modularly reduced to create the pwd-value:\n\
    \   n = len(p) + 64\n   pwd-tmp = PRF(pwd-seed, \"TLS-PWD Hunting And Pecking\"\
    ,\n                 context) [0..n];\n   pwd-value = (pwd-tmp mod (p - 1)) + 1\n\
    \   The pwd-value is then passed to the group-specific operation, which\n   either\
    \ returns the selected PE or fails.  If the group-specific\n   operation fails,\
    \ the counter is incremented, a new pwd-seed is\n   generated, and the hunting-and-pecking\
    \ process continues; this\n   procedure continues until the group-specific operation\
    \ returns the\n   PE.  After the PE has been chosen, the base is changed to a\
    \ random\n   number, the counter is incremented, and the hunting-and-pecking\n\
    \   process continues until the counter is greater than the security\n   parameter,\
    \ m.\n   The probability that one requires more than n iterations of the\n   hunting-and-pecking\
    \ loop to find an ECC PE is roughly (q/2p)^n and to\n   find an FFC PE is roughly\
    \ (q/p)^n, both of which rapidly approach\n   zero (0) as n increases.  The security\
    \ parameter, m, SHOULD be set\n   sufficiently large such that the probability\
    \ that finding the PE\n   would take more than m iterations is sufficiently small\
    \ (see\n   Section 7).\n   When the PE has been discovered, pwd-seed, pwd-tmp,\
    \ and pwd-value\n   SHALL be irretrievably destroyed.\n"
- title: 4.4.1.  Computing an ECC Password Element
  contents:
  - "4.4.1.  Computing an ECC Password Element\n   The group-specific operation for\
    \ ECC groups uses pwd-value, pwd-seed,\n   and the equation for the curve to produce\
    \ the PE.  First, pwd-value\n   is used directly as the x-coordinate, x, with\
    \ the equation for the\n   elliptic curve, with parameters a and b from the domain\
    \ parameter set\n   of the curve, to solve for a y-coordinate, y.  If there is\
    \ no\n   solution to the quadratic equation, this operation fails and the\n  \
    \ hunting-and-pecking process continues.  If a solution is found, then\n   an\
    \ ambiguity exists, as there are technically two solutions to the\n   equation,\
    \ and pwd-seed is used to unambiguously select one of them.\n   If the low-order\
    \ bit of pwd-seed is equal to the low-order bit of y,\n   then a candidate PE\
    \ is defined as the point (x, y); if the low-order\n   bit of pwd-seed differs\
    \ from the low-order bit of y, then a candidate\n   PE is defined as the point\
    \ (x, p - y), where p is the prime over\n   which the curve is defined.  The candidate\
    \ PE becomes the PE, a\n   random number is used instead of the base, and the\
    \ hunting-and-\n   pecking process continues until it has looped through m iterations,\n\
    \   where m is a suitably large number to prevent side-channel attacks\n   (see\
    \ [RFC7664]).\n   Algorithmically, the process looks like this:\n     found =\
    \ 0\n     counter = 0\n     n = len(p) + 64\n     if (version < 1.3)\n       context\
    \ = ClientHello.random | ServerHello.random\n     } else {\n       context = ClientHello.random\n\
    \     }\n     do {\n       counter = counter + 1\n       seed = H(base | counter\
    \ | p)\n       tmp = PRF(seed, \"TLS-PWD Hunting And Pecking\", context) [0..n]\n\
    \       val = (tmp mod (p - 1)) + 1\n       if ( (val^3 + a*val + b) mod p is\
    \ a quadratic residue)\n         then\n         if (found == 0)\n         then\n\
    \           x = val\n           save = seed\n           found = 1\n          \
    \ base = random()\n         fi\n       fi\n     } while ((found == 0) || (counter\
    \ <= m))\n     y = sqrt(x^3 + a*x + b) mod p\n     if ( lsb(y) == lsb(save))\n\
    \     then\n       PE = (x, y)\n     else\n       PE = (x, p - y)\n     fi\n \
    \                   Figure 3: Fixing PE for ECC Groups\n   Checking whether a\
    \ value is a quadratic residue modulo a prime can\n   leak information about that\
    \ value in a side-channel attack.\n   Therefore, it is RECOMMENDED that the technique\
    \ used to determine if\n   the value is a quadratic residue modulo p first blind\
    \ the value with\n   a random number so that the blinded value can take on all\
    \ numbers\n   between 1 and (p - 1) with equal probability.  Determining the\n\
    \   quadratic residue in a fashion that resists leakage of information is\n  \
    \ handled by flipping a coin and multiplying the blinded value by\n   either a\
    \ random quadratic residue or a random quadratic nonresidue\n   and checking whether\
    \ the multiplied value is a quadratic residue or a\n   quadratic nonresidue modulo\
    \ p, respectively.  The random residue and\n   nonresidue can be calculated prior\
    \ to hunting and pecking by\n   calculating the Legendre symbol on random values\
    \ until they are\n   found:\n   do {\n     qr = random()\n   } while ( lgr(qr,\
    \ p) != 1)\n   do {\n     qnr = random()\n   } while ( lgr(qnr, p) != -1)\n  \
    \ Algorithmically, the masking technique to find out whether a value is\n   a\
    \ quadratic residue modulo a prime or not looks like this:\n   is_quadratic_residue\
    \ (val, p) {\n       r = (random() mod (p - 1)) + 1\n       num = (val * r * r)\
    \ mod p\n       if ( lsb(r) == 1 )\n          num = (num * qr) mod p\n       \
    \   if ( lgr(num, p) == 1)\n          then\n             return TRUE\n       \
    \   fi\n       else\n          num = (num * qnr) mod p\n          if ( lgr(num,\
    \ p) == -1)\n          then\n             return TRUE\n          fi\n       fi\n\
    \       return FALSE\n   }\n   The random quadratic residue and quadratic nonresidue\
    \ (qr and qnr\n   above) can be used for all the hunting-and-pecking loops, but\
    \ the\n   blinding value, r, MUST be chosen randomly for each loop.\n"
- title: 4.4.2.  Computing an FFC Password Element
  contents:
  - "4.4.2.  Computing an FFC Password Element\n   The group-specific operation for\
    \ FFC groups takes the prime (p) and\n   the order (q) from the group's domain\
    \ parameter set and the variable\n   pwd-value to directly produce a candidate\
    \ PE, by exponentiating the\n   pwd-value to the value ((p - 1)/q) modulo p. \
    \ See Section 3.2.2 when\n   the order is not part of the defined domain parameter\
    \ set.  If the\n   result is greater than one (1), the candidate PE becomes the\
    \ PE, and\n   the hunting-and-pecking process continues until it has looped through\n\
    \   m iterations, where m is a suitably large number to prevent\n   side-channel\
    \ attacks (see [RFC7664]).\n   Algorithmically, the process looks like this:\n\
    \     found = 0\n     counter = 0\n     n = len(p) + 64\n     if (version < 1.3)\n\
    \       context = ClientHello.random | ServerHello.random\n     } else {\n   \
    \    context = ClientHello.random\n     }\n     do {\n       counter = counter\
    \ + 1\n       pwd-seed = H(base | counter | p)\n       pwd-tmp = PRF(pwd-seed,\
    \ \"TLS-PWD Hunting And Pecking\",\n                     context) [0..n]\n   \
    \    pwd-value = (pwd-tmp mod (p - 1)) + 1\n       PE = pwd-value^((p - 1)/q)\
    \ mod p\n       if (PE > 1)\n       then\n         found = 1\n         base =\
    \ random()\n       fi\n     } while ((found == 0) || (counter <= m))\n       \
    \             Figure 4: Fixing PE for FFC Groups\n"
- title: 4.4.3.  Password Naming
  contents:
  - "4.4.3.  Password Naming\n   The client is required to identify herself to the\
    \ server by adding\n   either a pwd_protect or pwd_clear extension to her ClientHello\n\
    \   message, depending on whether the client wishes to protect her\n   username\
    \ (see Section 4.3) or not, respectively.  The pwd_protect and\n   pwd_clear extensions\
    \ use the standard mechanism defined in [RFC5246].\n   The \"extension data\"\
    \ field of the extension SHALL contain a pwd_name,\n   which is used to identify\
    \ the password shared between the client and\n   server.  If username protection\
    \ is performed and the ExtensionType is\n   pwd_protect, the contents of the pwd_name\
    \ SHALL be constructed\n   according to Section 4.3.1.\n      enum { pwd_protect(29),\
    \ pwd_clear(30) } ExtensionType;\n      opaque pwd_name<1..2^8-1>;\n   An unprotected\
    \ pwd_name SHALL be a UTF-8 encoded character string\n   processed according to\
    \ the rules of the OpaqueString profile of\n   [RFC8265], and a protected pwd_name\
    \ SHALL be a string of bits.\n"
- title: 4.4.4.  Generating TLS-PWD Commit
  contents:
  - "4.4.4.  Generating TLS-PWD Commit\n   The scalar and Element that comprise each\
    \ peer's \"commitment\" are\n   generated as follows.\n   First, two random numbers,\
    \ called \"private\" and \"mask\", between zero\n   and the order of the group\
    \ (exclusive) are generated.  If their sum\n   modulo the order of the group,\
    \ q, equals zero (0) or one (1), the\n   numbers must be thrown away and new random\
    \ numbers generated.  If\n   their sum modulo the order of the group, q, is greater\
    \ than one, the\n   sum becomes the scalar.\n      scalar = (private + mask) mod\
    \ q\n   The Element is then calculated as the inverse of the group's scalar\n\
    \   operation (see the group-specific operations discussed in\n   Section 3.2)\
    \ with the mask and PE.\n      Element = inverse(scalar-op(mask, PE))\n   After\
    \ calculation of the scalar and Element, the mask SHALL be\n   irretrievably destroyed.\n"
- title: 4.5.  Changes to Handshake Message Contents
  contents:
  - '4.5.  Changes to Handshake Message Contents

    '
- title: 4.5.1.  Pre-1.3 TLS
  contents:
  - '4.5.1.  Pre-1.3 TLS

    '
- title: 4.5.1.1.  ClientHello Changes
  contents:
  - "4.5.1.1.  ClientHello Changes\n   A client offering a PWD ciphersuite MUST include\
    \ one of the pwd_name\n   extensions from Section 4.4.3 in her ClientHello.\n\
    \   If a server does not have a password for a client identified by the\n   username\
    \ either extracted from the pwd_name (if unprotected) or\n   recovered using the\
    \ technique provided in Section 4.3.2 (if\n   protected), or if recovery of a\
    \ protected username fails, the server\n   SHOULD hide that fact by simulating\
    \ the protocol -- putting random\n   data in the PWD-specific components of the\
    \ ServerKeyExchange -- and\n   then rejecting the client's finished message with\
    \ a \"bad_record_mac\"\n   alert [RFC8446].  To properly effect a simulated TLS-PWD\
    \ exchange, an\n   appropriate delay SHOULD be inserted between receipt of the\n\
    \   ClientHello and response of the ServerHello.  Alternately, a server\n   MAY\
    \ choose to terminate the exchange if a password is not found.  The\n   security\
    \ implication of terminating the exchange is to expose to an\n   attacker whether\
    \ a username is valid or not.\n   The server decides on a group to use with the\
    \ named user (see\n   Section 9) and generates the PE according to Section 4.4.2.\n"
- title: 4.5.1.2.  ServerKeyExchange Changes
  contents:
  - "4.5.1.2.  ServerKeyExchange Changes\n   The domain parameter set for the selected\
    \ group MUST be explicitly\n   specified by name in the ServerKeyExchange.  ECC\
    \ groups are specified\n   using the NamedCurve enumeration of [RFC8422], and\
    \ FFC groups are\n   specified using the NamedGroup extensions added by [RFC7919]\
    \ to the\n   \"TLS Supported Groups\" registry in [TLS_REG].  In addition to the\n\
    \   group specification, the ServerKeyExchange also contains the server's\n  \
    \ \"commitment\" in the form of a scalar and Element, and the salt that\n   was\
    \ used to store the user's password.\n   Two new values have been added to the\
    \ enumerated KeyExchangeAlgorithm\n   to indicate TLS-PWD using FFC and TLS-PWD\
    \ using ECC: ff_pwd and\n   ec_pwd, respectively.\n                enum { ff_pwd,\
    \ ec_pwd } KeyExchangeAlgorithm;\n                struct {\n                 \
    \ opaque salt<1..2^8-1>;\n                  NamedGroup ff_group;\n           \
    \       opaque ff_selement<1..2^16-1>;\n                  opaque ff_sscalar<1..2^16-1>;\n\
    \                } ServerFFPWDParams;\n                struct {\n            \
    \      opaque salt<1..2^8-1>;\n                  ECParameters curve_params;\n\
    \                  ECPoint ec_selement;\n                  opaque ec_sscalar<1..2^8-1>;\n\
    \                } ServerECPWDParams;\n                struct {\n            \
    \      select (KeyExchangeAlgorithm) {\n                    case ec_pwd:\n   \
    \                   ServerECPWDParams params;\n                    case ff_pwd:\n\
    \                      ServerFFPWDParams params;\n                  };\n     \
    \           } ServerKeyExchange;\n"
- title: 4.5.1.2.1.  Generation of ServerKeyExchange
  contents:
  - "4.5.1.2.1.  Generation of ServerKeyExchange\n   The scalar and Element referenced\
    \ in this section are derived\n   according to Section 4.4.4.\n"
- title: 4.5.1.2.1.1.  ECC ServerKeyExchange
  contents:
  - "4.5.1.2.1.1.  ECC ServerKeyExchange\n   ECC domain parameters are specified in\
    \ the ECParameters component of\n   the ECC-specific ServerKeyExchange as defined\
    \ in [RFC8422].  The\n   scalar SHALL become the ec_sscalar component, and the\
    \ Element SHALL\n   become the ec_selement of the ServerKeyExchange.  If the client\n\
    \   requested a specific point format (compressed or uncompressed) with\n   the\
    \ Supported Point Formats Extension (see [RFC8422]) in its\n   ClientHello, the\
    \ Element MUST be formatted in the ec_selement to\n   conform to that request.\
    \  If the client offered (an) elliptic\n   curve(s) in its ClientHello using the\
    \ Supported Elliptic Curves\n   Extension, the server MUST include (one of the)\
    \ named curve(s) in the\n   ECParameters field in the ServerKeyExchange and the\
    \ key exchange\n   operations specified in Section 4.5.1.2.1 MUST use that group.\n\
    \   As mentioned in Section 3.2.1, characteristic-2 curves and curves\n   with\
    \ a co-factor greater than one (1) SHALL NOT be used by TLS-PWD.\n"
- title: 4.5.1.2.1.2.  FFC ServerKeyExchange
  contents:
  - "4.5.1.2.1.2.  FFC ServerKeyExchange\n   FFC domain parameters use the NamedGroup\
    \ extension specified in\n   [RFC7919].  The scalar SHALL become the ff_sscalar\
    \ component, and the\n   Element SHALL become the ff_selement in the FFC-specific\n\
    \   ServerKeyExchange.\n   As mentioned in Section 3.2.2, if the prime is a safe\
    \ prime and no\n   order is included in the domain parameter set, the order added\
    \ to the\n   ServerKeyExchange SHALL be the prime minus one divided by two --\n\
    \   (p - 1)/2.\n"
- title: 4.5.1.2.2.  Processing of ServerKeyExchange
  contents:
  - "4.5.1.2.2.  Processing of ServerKeyExchange\n   Upon receipt of the ServerKeyExchange,\
    \ the client decides whether to\n   support the indicated group or not.  If the\
    \ client decides to support\n   the indicated group, the server's \"commitment\"\
    \ MUST be validated by\n   ensuring that 1) the server's scalar value is greater\
    \ than one (1)\n   and less than the order of the group, q and 2) the Element\
    \ is valid\n   for the chosen group (see Sections 3.2.1 and 3.2.2 for how to\n\
    \   determine whether an Element is valid for the particular group.  Note\n  \
    \ that if the Element is a compressed point on an elliptic curve, it\n   MUST\
    \ be uncompressed before checking its validity).\n   If the group is acceptable\
    \ and the server's \"commitment\" has been\n   successfully validated, the client\
    \ extracts the salt from the\n   ServerKeyExchange and generates the PE according\
    \ to Sections 3.4 and\n   4.4.2.  If the group is not acceptable or the server's\
    \ \"commitment\"\n   failed validation, the exchange MUST be aborted.\n"
- title: 4.5.1.3.  ClientKeyExchange Changes
  contents:
  - "4.5.1.3.  ClientKeyExchange Changes\n   When the value of KeyExchangeAlgorithm\
    \ is either ff_pwd or ec_pwd,\n   the ClientKeyExchange is used to convey the\
    \ client's \"commitment\" to\n   the server.  It therefore contains a scalar and\
    \ an Element.\n                     struct {\n                       opaque ff_celement<1..2^16-1>;\n\
    \                       opaque ff_cscalar<1..2^16-1>;\n                     }\
    \ ClientFFPWDParams;\n                     struct {\n                       ECPoint\
    \ ec_celement;\n                       opaque ec_cscalar<1..2^8-1>;\n        \
    \             } ClientECPWDParams;\n                     struct {\n          \
    \             select (KeyExchangeAlgorithm) {\n                         case ff_pwd:\
    \ ClientFFPWDParams;\n                         case ec_pwd: ClientECPWDParams;\n\
    \                       } exchange_keys;\n                     } ClientKeyExchange;\n"
- title: 4.5.1.3.1.  Generation of ClientKeyExchange
  contents:
  - "4.5.1.3.1.  Generation of ClientKeyExchange\n   The client's scalar and Element\
    \ are generated in the manner described\n   in Section 4.5.1.2.1.\n   For an FFC\
    \ group, the scalar SHALL become the ff_cscalar component\n   and the Element\
    \ SHALL become the ff_celement in the FFC-specific\n   ClientKeyExchange.\n  \
    \ For an ECC group, the scalar SHALL become the ec_cscalar component\n   and the\
    \ Element SHALL become the ec_celement in the ECC-specific\n   ClientKeyExchange.\
    \  If the client requested a specific point format\n   (compressed or uncompressed)\
    \ with the Supported Point Formats\n   Extension in its ClientHello, then the\
    \ Element MUST be formatted in\n   the ec_celement to conform to its initial request.\n"
- title: 4.5.1.3.2.  Processing of ClientKeyExchange
  contents:
  - "4.5.1.3.2.  Processing of ClientKeyExchange\n   Upon receipt of the ClientKeyExchange,\
    \ the server must validate the\n   client's \"commitment\" by ensuring that 1)\
    \ the client's scalar and\n   Element differ from the server's scalar and Element,\
    \ 2) the client's\n   scalar value is greater than one (1) and less than the order\
    \ of the\n   group, q, and 3) the Element is valid for the chosen group (see\n\
    \   Sections 3.2.1 and 3.2.2 for how to determine whether an Element is\n   valid\
    \ for a particular group.  Note that if the Element is a\n   compressed point\
    \ on an elliptic curve, it MUST be uncompressed before\n   checking its validity).\
    \  If any of these three conditions are not\n   met, the server MUST abort the\
    \ exchange.\n"
- title: 4.5.2.  TLS 1.3
  contents:
  - '4.5.2.  TLS 1.3

    '
- title: 4.5.2.1.  TLS 1.3 KeyShare
  contents:
  - "4.5.2.1.  TLS 1.3 KeyShare\n   TLS 1.3 clients and servers convey their commit\
    \ values in a\n   \"key_share\" extension.  The structure of this extension SHALL\
    \ be:\n             enum { ff_pwd, ec_pwd } KeyExchangeAlgorithm;\n          \
    \   struct {\n                 select (KeyExchangeAlgorithm) {\n             \
    \        case ec_pwd:\n                         opaque elemX[coordinate_length];\n\
    \                         opaque elemY[coordinate_length];\n                 \
    \    case ff_pwd:\n                         opaque elem[coordinate_length];\n\
    \                  };\n                  opaque scalar<1..2^8-1>\n           \
    \  } PWDKeyShareEntry;\n             struct {\n                  NamedGroup group;\n\
    \                  PWDKeyShareEntry pwd_key_exchange<1..2^16-1>;\n           \
    \  } KeyShareEntry;\n"
- title: 4.5.2.2.  ClientHello Changes
  contents:
  - "4.5.2.2.  ClientHello Changes\n   The ClientHello message MUST include a pwd_name\
    \ extension from\n   Section 4.4.3 and it MUST include a key_share extension from\n\
    \   Section 4.5.2.1.\n   Upon receipt of a ClientHello, the server MUST validate\
    \ the key_share\n   extension_data [RFC8446] to ensure that the scalar value is\
    \ greater\n   than one (1) and less than the order of the group q, and that the\n\
    \   Element is valid for the chosen group (see Sections 3.2.1 and 3.2.2).\n  \
    \ If a server does not have a password for a client identified by the\n   username\
    \ either extracted from the pwd_name (if unprotected) or\n   recovered using the\
    \ technique in Section 4.3.2 (if protected), or if\n   recovery of a protected\
    \ username fails, the server SHOULD hide that\n   fact by simulating the protocol\
    \ -- putting random data in the\n   PWD-specific components of its KeyShareEntry\
    \ -- and then rejecting\n   the client's finished message with a \"bad_record_mac\"\
    \ alert.  To\n   properly effect a simulated TLS-PWD exchange, an appropriate\
    \ delay\n   SHOULD be inserted between receipt of the ClientHello and response\
    \ of\n   the ServerHello.  Alternately, a server MAY choose to terminate the\n\
    \   exchange if a password is not found.  The security implication of\n   terminating\
    \ the exchange is to expose to an attacker whether a\n   username is valid or\
    \ not.\n"
- title: 4.5.2.3.  ServerHello Changes
  contents:
  - "4.5.2.3.  ServerHello Changes\n   If the server supports TLS-PWD, agrees with\
    \ the group chosen by the\n   client, and finds an unsalted password indicated\
    \ by the pwd_name\n   extension of the received ClientHello, its ServerHello MUST\
    \ contain a\n   key_share extension from Section 4.5.2.1 in the same group as\
    \ that\n   chosen by the client.\n   Upon receipt of a ServerHello, the client\
    \ MUST validate the key_share\n   extension_data to ensure that the scalar value\
    \ is greater than\n   one (1) and less than the order of the group q, and that\
    \ the Element\n   is valid for the chosen group (see Sections 3.2.1 and 3.2.2).\n"
- title: 4.5.2.4.  HelloRetryRequest Changes
  contents:
  - "4.5.2.4.  HelloRetryRequest Changes\n   The server sends this message in response\
    \ to a ClientHello if it\n   desires a different group or if the password identified\
    \ by the\n   client's password identified by pwd_name is salted.\n   A different\
    \ group is indicated by adding the\n   KeyShareHelloRetryRequest extension to\
    \ the HelloRetryRequest.  The\n   indication of a salted password, and the salt\
    \ used, is done by adding\n   the following structure:\n                 enum\
    \ { password_salt(31) } ExtensionType;\n                 struct {\n          \
    \           opaque pwd_salt<2^16-1>;\n                 } password_salt;\n   A\
    \ client that receives a HelloRetryRequest indicating the password\n   salt SHALL\
    \ delete its computed PE and derive another version using\n   the salt prior to\
    \ sending another ClientHello.\n"
- title: 4.6.  Computing the Shared Secret
  contents:
  - "4.6.  Computing the Shared Secret\n   The client and server use their private\
    \ value as calculated in\n   Section 4.4.4 with the other party's Element and\
    \ scalar for the\n   ServerHello or ClientHello, respectively (here denoted \"\
    Peer_Element\"\n   and \"peer_scalar\") to generate the shared secret z.\n   \
    \        z = F(scalar-op(private,\n                           elem-op(Peer_Element,\n\
    \                                   scalar-op(peer_scalar, PE))))\n   For TLS\
    \ versions prior to 1.3, the intermediate value, z, is then\n   used as the premaster\
    \ secret after any leading bytes of z that\n   contain all zero bits have been\
    \ stripped off.  For TLS version 1.3,\n   leading zero bytes are retained, and\
    \ the intermediate value z is used\n   as the (EC)DHE input in the key schedule.\n"
- title: 5.  Ciphersuite Definition
  contents:
  - "5.  Ciphersuite Definition\n   This memo adds the following ciphersuites:\n \
    \     CipherSuite TLS_ECCPWD_WITH_AES_128_GCM_SHA256 = (0xC0,0xB0);\n      CipherSuite\
    \ TLS_ECCPWD_WITH_AES_256_GCM_SHA384 = (0xC0,0xB1);\n      CipherSuite TLS_ECCPWD_WITH_AES_128_CCM_SHA256\
    \ = (0xC0,0xB2);\n      CipherSuite TLS_ECCPWD_WITH_AES_256_CCM_SHA384 = (0xC0,0xB3);\n\
    \   Implementations conforming to this specification MUST support the\n   TLS_ECCPWD_WITH_AES_128_GCM_SHA256\
    \ ciphersuite; they SHOULD support\n   the remaining ciphersuites.\n   When negotiated\
    \ with a version of TLS prior to 1.2, the PRF from that\n   earlier version is\
    \ used; when the negotiated version of TLS is TLS\n   1.2, the PRF is the TLS\
    \ 1.2 PRF [RFC5246], using the hash function\n   indicated by the ciphersuite;\
    \ when the negotiated version of TLS is\n   TLS 1.3, the PRF is the Derive-Secret\
    \ function from Section 7.1 of\n   [RFC8446].  Regardless of the TLS version,\
    \ the TLS-PWD random\n   function, H, is always instantiated with the hash algorithm\
    \ indicated\n   by the ciphersuite.\n   For those ciphersuites that use Cipher\
    \ Block Chaining (CBC)\n   [SP800-38A] mode, the MAC is HMAC [RFC2104] with the\
    \ hash function\n   indicated by the ciphersuite.\n"
- title: 6.  IANA Considerations
  contents:
  - "6.  IANA Considerations\n   IANA has assigned three values for new TLS extension\
    \ types from the\n   \"TLS ExtensionType Values\" registry defined in [RFC8446]\
    \ and\n   [RFC8447].  They are pwd_protect (29), pwd_clear (30), and\n   password_salt\
    \ (31).  See Sections 4.5.1.1 and 4.5.2.2 for more\n   information.\n   In summary,\
    \ the following rows have been added to the \"TLS\n   ExtensionType Values\" registry:\n\
    \           +-------+----------------+-------------+-----------+\n           |\
    \ Value | Extension Name |   TLS 1.3   | Reference |\n           +-------+----------------+-------------+-----------+\n\
    \           |   29  |  pwd_protect   |      CH     |  RFC 8492 |\n           |\
    \   30  |   pwd_clear    |      CH     |  RFC 8492 |\n           |   31  | password_salt\
    \  | CH, SH, HRR |  RFC 8492 |\n           +-------+----------------+-------------+-----------+\n\
    \   IANA has assigned the following ciphersuites from the \"TLS Cipher\n   Suites\"\
    \ registry defined in [RFC8446] and [RFC8447]:\n      CipherSuite TLS_ECCPWD_WITH_AES_128_GCM_SHA256\
    \ = (0xC0,0xB0);\n      CipherSuite TLS_ECCPWD_WITH_AES_256_GCM_SHA384 = (0xC0,0xB1);\n\
    \      CipherSuite TLS_ECCPWD_WITH_AES_128_CCM_SHA256 = (0xC0,0xB2);\n      CipherSuite\
    \ TLS_ECCPWD_WITH_AES_256_CCM_SHA384 = (0xC0,0xB3);\n   The \"DTLS-OK\" column\
    \ in the registry has been set to \"Y\", and the\n   \"Recommended\" column has\
    \ been set to \"N\" for all ciphersuites defined\n   in this memo.\n"
- title: 7.  Security Considerations
  contents:
  - "7.  Security Considerations\n   A security proof of this key exchange in the\
    \ random oracle model is\n   found in [lanskro].\n   A passive attacker against\
    \ this protocol will see the\n   ServerKeyExchange and the ClientKeyExchange (in\
    \ TLS pre-1.3), or the\n   KeyShare (from TLS 1.3), containing the scalar and\
    \ Element of the\n   server and the client, respectively.  The client and server\n\
    \   effectively hide their secret private value by masking it modulo the\n   order\
    \ of the selected group.  If the order is \"q\", then there are\n   approximately\
    \ \"q\" distinct pairs of numbers that will sum to the\n   scalar values observed.\
    \  It is possible for an attacker to iterate\n   through all such values, but\
    \ for a large value of \"q\", this\n   exhaustive search technique is computationally\
    \ infeasible.  The\n   attacker would have a better chance in solving the discrete\
    \ logarithm\n   problem, which we have already assumed (see Section 3.5) to be\
    \ an\n   intractable problem.\n   A passive attacker can take the Element from\
    \ the ServerKeyExchange or\n   the ClientKeyExchange (in TLS pre-1.3), or from\
    \ the KeyShare (from\n   TLS 1.3), and try to determine the random \"mask\" value\
    \ used in its\n   construction and then recover the other party's \"private\"\
    \ value from\n   the scalar in the same message.  But this requires the attacker\
    \ to\n   solve the discrete logarithm problem, which we assumed was\n   intractable.\n\
    \   Both the client and the server obtain a shared secret based on a\n   secret\
    \ group Element and the private information they contributed to\n   the exchange.\
    \  The secret group Element is based on the password.  If\n   they do not share\
    \ the same password, they will be unable to derive\n   the same secret group Element,\
    \ and if they don't generate the same\n   secret group Element, they will be unable\
    \ to generate the same shared\n   secret.  Seeing a finished message will not\
    \ provide any additional\n   advantage of attack, since it is generated with the\
    \ unknowable\n   secret.\n   In TLS pre-1.3, an active attacker impersonating\
    \ the client can\n   induce a server to send a ServerKeyExchange containing the\
    \ server's\n   scalar and Element.  The attacker can attempt to generate a\n \
    \  ClientKeyExchange and send it to the server, but she is required to\n   send\
    \ a finished message first; therefore, the only information she\n   can obtain\
    \ in this attack is less than the information she can obtain\n   from a passive\
    \ attack, so this particular active attack is not very\n   fruitful.\n   In TLS\
    \ pre-1.3, an active attacker can impersonate the server and\n   send a forged\
    \ ServerKeyExchange after receiving the ClientHello.  The\n   attacker then waits\
    \ until it receives the ClientKeyExchange and\n   finished message from the client.\
    \  Now the attacker can attempt to\n   run through all possible values of the\
    \ password, computing the PE\n   (see Section 4.4), computing candidate premaster\
    \ secrets (see\n   Section 4.6), and attempting to recreate the client's finished\n\
    \   message.\n   But the attacker committed to a single guess of the password\
    \ with her\n   forged ServerKeyExchange.  That value was used by the client in\
    \ her\n   computation of the premaster secret, which was used to produce the\n\
    \   finished message.  Any guess of the password that differs from the\n   password\
    \ used in the forged ServerKeyExchange would result in each\n   side using a different\
    \ PE in the computation of the premaster secret;\n   therefore, the finished message\
    \ cannot be verified as correct, even\n   if a subsequent guess, while running\
    \ through all possible values, was\n   correct.  The attacker gets one guess,\
    \ and one guess only, per active\n   attack.\n   Instead of attempting to guess\
    \ at the password, an attacker can\n   attempt to determine the PE and then launch\
    \ an attack.  But the PE is\n   determined by the output of the random function,\
    \ H, which is\n   indistinguishable from a random source, since H is assumed to\
    \ be a\n   \"random oracle\" (Section 3.5).  Therefore, each Element of the finite\n\
    \   cyclic group will have an equal probability of being the PE.  The\n   probability\
    \ of guessing the PE will be 1/q, where q is the order of\n   the group.  For\
    \ a large value of \"q\", this will be computationally\n   infeasible.\n   The\
    \ implications of resistance to dictionary attacks are significant.\n   An implementation\
    \ can provision a password in a practical and\n   realistic manner -- i.e., it\
    \ MAY be a character string, and it MAY be\n   relatively short -- and still maintain\
    \ security.  The nature of the\n   pool of potential passwords determines the\
    \ size of the pool, D, and\n   countermeasures can prevent an attacker from determining\
    \ the password\n   in the only possible way: repeated, active, guessing attacks.\
    \  For\n   example, a simple four-character string using lowercase English\n \
    \  characters, and assuming random selection of those characters, will\n   result\
    \ in D of over four hundred thousand.  An attacker would need to\n   mount over\
    \ one hundred thousand active, guessing attacks (which will\n   easily be detected)\
    \ before gaining any significant advantage in\n   determining the pre-shared key.\n\
    \   Countermeasures to deal with successive active, guessing attacks are\n   only\
    \ possible by noticing that a certain username is failing\n   repeatedly over\
    \ a certain period of time.  Attacks that attempt to\n   find a password for a\
    \ random user are more difficult to detect.  For\n   instance, if a device uses\
    \ a serial number as a username and the pool\n   of potential passwords is sufficiently\
    \ small, a more effective attack\n   would be to select a password and try all\
    \ potential \"users\" to\n   disperse the attack and confound countermeasures.\
    \  It is therefore\n   RECOMMENDED that implementations of TLS-PWD keep track\
    \ of the total\n   number of failed authentications, regardless of username, in\
    \ an\n   effort to detect and thwart this type of attack.\n   The benefits of\
    \ resistance to dictionary attacks can be lessened by a\n   client using the same\
    \ passwords with multiple servers.  An attacker\n   could redirect a session from\
    \ one server to the other if the attacker\n   knew that the intended server stored\
    \ the same password for the client\n   as another server.\n   An adversary that\
    \ has access to, and a considerable amount of control\n   over, a client or server\
    \ could attempt to mount a side-channel attack\n   to determine the number of\
    \ times it took for a certain password (plus\n   client random and server random)\
    \ to select a PE.  Each such attack\n   could result in a successive \"paring\
    \ down\" of the size of the pool of\n   potential passwords, resulting in a manageably\
    \ small set from which\n   to launch a series of active attacks to determine the\
    \ password.  A\n   security parameter, m, is used to normalize the amount of work\n\
    \   necessary to determine the PE (see Section 4.4).  The probability\n   that\
    \ a password will require more than m iterations is roughly\n   (q/2p)^m for ECC\
    \ groups and (q/p)^m for FFC groups, so it is possible\n   to mitigate side-channel\
    \ attacks at the expense of a constant cost\n   per connection attempt.  But if\
    \ a particular password requires more\n   than k iterations, it will leak k bits\
    \ of information to the\n   side-channel attacker; for some dictionaries, this\
    \ will uniquely\n   identify the password.  Therefore, the security parameter,\
    \ m, needs\n   to be set with great care.  It is RECOMMENDED that an implementation\n\
    \   set the security parameter, m, to a value of at least forty (40),\n   which\
    \ will put the probability that more than forty iterations are\n   needed in the\
    \ order of one in one trillion (1:1,000,000,000,000).\n   A database of salted\
    \ passwords prevents an adversary who gains access\n   to the database from learning\
    \ the client's password; it does not\n   prevent such an adversary from impersonating\
    \ the client back to the\n   server.  Each side uses the salted password, called\
    \ the base, as the\n   authentication credential, so the database of salted passwords\
    \ MUST\n   be afforded the security of a database of plaintext passwords.\n  \
    \ Authentication is performed by proving knowledge of the password.\n   Any third\
    \ party that knows the password shared by the client and\n   server can impersonate\
    \ one to the other.\n   The static-ephemeral Diffie-Hellman exchange used to protect\n\
    \   usernames requires the server to reuse its Diffie-Hellman public key.\n  \
    \ To prevent an \"invalid curve\" attack, an entity that reuses its\n   Diffie-Hellman\
    \ public key needs to check whether the received\n   ephemeral public key is actually\
    \ a point on the curve.  This is done\n   explicitly as part of the server's reconstruction\
    \ of the client's\n   public key out of only its x-coordinate (\"compact representation\"\
    ).\n"
- title: 8.  Human Rights Considerations
  contents:
  - "8.  Human Rights Considerations\n   At the time of publication of this document,\
    \ there was a growing\n   interest in considering the impacts that IETF (and IRTF)\
    \ work can\n   have on human rights; some related research is discussed in\n \
    \  [RFC8280].  As such, the human rights considerations of TLS-PWD are\n   presented\
    \ here.\n   The key exchange underlying TLS-PWD uses public key cryptography to\n\
    \   perform authentication and authenticated key exchange.  The keys it\n   produces\
    \ can be used to establish secure connections between two\n   people to protect\
    \ their communication.  Implementations of TLS-PWD,\n   like implementations of\
    \ other TLS ciphersuites that perform\n   authentication and authenticated key\
    \ establishment, are considered\n   \"armaments\" or \"munitions\" by many governments\
    \ around the world.\n   The most fundamental of human rights is the right to protect\
    \ oneself.\n   The right to keep and bear arms is an example of this right.\n\
    \   Implementations of TLS-PWD can be used as arms, kept and borne, to\n   defend\
    \ oneself against all manner of attackers -- criminals,\n   governments, lawyers,\
    \ etc.  TLS-PWD is a powerful tool in the\n   promotion and defense of universal\
    \ human rights.\n"
- title: 9.  Implementation Considerations
  contents:
  - "9.  Implementation Considerations\n   The selection of the ciphersuite and selection\
    \ of the particular\n   finite cyclic group to use with the ciphersuite are divorced\
    \ in this\n   memo, but they remain intimately close.\n   It is RECOMMENDED that\
    \ implementations take note of the strength\n   estimates of particular groups\
    \ and select a ciphersuite providing\n   commensurate security with its hash and\
    \ encryption algorithms.  A\n   ciphersuite whose encryption algorithm has a keylength\
    \ less than the\n   strength estimate or whose hash algorithm has a block size\
    \ that is\n   less than twice the strength estimate SHOULD NOT be used.\n   For\
    \ example, the elliptic curve named \"brainpoolP256r1\" (whose\n   IANA-assigned\
    \ number is 26) [RFC7027] provides an estimated 128 bits\n   of strength and would\
    \ be compatible with 1) an encryption algorithm\n   supporting a key of that length\
    \ and 2) a hash algorithm that has at\n   least a 256-bit block size.  Therefore,\
    \ a suitable ciphersuite to use\n   with brainpoolP256r1 could be TLS_ECCPWD_WITH_AES_128_GCM_SHA256\
    \ (see\n   Appendix A for an example of such an exchange).\n   Resistance to dictionary\
    \ attacks means that the attacker must launch\n   an active attack to make a single\
    \ guess at the password.  If the size\n   of the pool from which the password\
    \ was extracted was D and each\n   password in the pool has an equal probability\
    \ of being chosen, then\n   the probability of success after a single guess is\
    \ 1/D.  After X\n   guesses and the removal of failed guesses from the pool of\
    \ possible\n   passwords, the probability becomes 1/(D-X).  As X grows, so does\
    \ the\n   probability of success.  Therefore, it is possible for an attacker to\n\
    \   determine the password through repeated brute-force, active, guessing\n  \
    \ attacks.  Implementations SHOULD take note of this fact and choose an\n   appropriate\
    \ pool of potential passwords -- i.e., make D big.\n   Implementations SHOULD\
    \ also take countermeasures -- for instance,\n   refusing authentication attempts\
    \ by a particular username for a\n   certain amount of time, after the number\
    \ of failed authentication\n   attempts reaches a certain threshold.  No such\
    \ threshold or amount of\n   time is recommended in this memo.\n"
- title: 10.  References
  contents:
  - '10.  References

    '
- title: 10.1.  Normative References
  contents:
  - "10.1.  Normative References\n   [RFC2104]  Krawczyk, H., Bellare, M., and R.\
    \ Canetti,\n              \"HMAC: Keyed-Hashing for Message Authentication\",\n\
    \              RFC 2104, DOI 10.17487/RFC2104, February 1997,\n              <https://www.rfc-editor.org/info/rfc2104>.\n\
    \   [RFC2119]  Bradner, S., \"Key words for use in RFCs to Indicate\n        \
    \      Requirement Levels\", BCP 14, RFC 2119,\n              DOI 10.17487/RFC2119,\
    \ March 1997,\n              <https://www.rfc-editor.org/info/rfc2119>.\n   [RFC5246]\
    \  Dierks, T. and E. Rescorla, \"The Transport Layer Security\n              (TLS)\
    \ Protocol Version 1.2\", RFC 5246,\n              DOI 10.17487/RFC5246, August\
    \ 2008,\n              <https://www.rfc-editor.org/info/rfc5246>.\n   [RFC5297]\
    \  Harkins, D., \"Synthetic Initialization Vector (SIV)\n              Authenticated\
    \ Encryption Using the Advanced Encryption\n              Standard (AES)\", RFC\
    \ 5297, DOI 10.17487/RFC5297,\n              October 2008, <https://www.rfc-editor.org/info/rfc5297>.\n\
    \   [RFC5869]  Krawczyk, H. and P. Eronen, \"HMAC-based Extract-and-Expand\n \
    \             Key Derivation Function (HKDF)\", RFC 5869,\n              DOI 10.17487/RFC5869,\
    \ May 2010,\n              <https://www.rfc-editor.org/info/rfc5869>.\n   [RFC7919]\
    \  Gillmor, D., \"Negotiated Finite Field Diffie-Hellman\n              Ephemeral\
    \ Parameters for Transport Layer Security (TLS)\",\n              RFC 7919, DOI\
    \ 10.17487/RFC7919, August 2016,\n              <https://www.rfc-editor.org/info/rfc7919>.\n\
    \   [RFC8174]  Leiba, B., \"Ambiguity of Uppercase vs Lowercase in\n         \
    \     RFC 2119 Key Words\", BCP 14, RFC 8174,\n              DOI 10.17487/RFC8174,\
    \ May 2017,\n              <https://www.rfc-editor.org/info/rfc8174>.\n   [RFC8265]\
    \  Saint-Andre, P. and A. Melnikov, \"Preparation,\n              Enforcement,\
    \ and Comparison of Internationalized Strings\n              Representing Usernames\
    \ and Passwords\", RFC 8265,\n              DOI 10.17487/RFC8265, October 2017,\n\
    \              <https://www.rfc-editor.org/info/rfc8265>.\n   [RFC8422]  Nir,\
    \ Y., Josefsson, S., and M. Pegourie-Gonnard, \"Elliptic\n              Curve\
    \ Cryptography (ECC) Cipher Suites for Transport Layer\n              Security\
    \ (TLS) Versions 1.2 and Earlier\", RFC 8422,\n              DOI 10.17487/RFC8422,\
    \ August 2018,\n              <https://www.rfc-editor.org/info/rfc8422>.\n   [RFC8446]\
    \  Rescorla, E., \"The Transport Layer Security (TLS) Protocol\n             \
    \ Version 1.3\", RFC 8446, DOI 10.17487/RFC8446, August 2018,\n              <https://www.rfc-editor.org/info/rfc8446>.\n\
    \   [RFC8447]  Salowey, J. and S. Turner, \"IANA Registry Updates for TLS\n  \
    \            and DTLS\", RFC 8447, DOI 10.17487/RFC8447, August 2018,\n      \
    \        <https://www.rfc-editor.org/info/rfc8447>.\n   [TLS_REG]  IANA, \"Transport\
    \ Layer Security (TLS) Parameters\",\n              <https://www.iana.org/assignments/tls-parameters/>.\n"
- title: 10.2.  Informative References
  contents:
  - "10.2.  Informative References\n   [FIPS186-4]\n              National Institute\
    \ of Standards and Technology, \"Digital\n              Signature Standard (DSS)\"\
    , Federal Information Processing\n              Standards Publication 186-4, DOI\
    \ 10.6028/NIST.FIPS.186-4,\n              July 2013, <https://nvlpubs.nist.gov/nistpubs/FIPS/\n\
    \              NIST.FIPS.186-4.pdf>.\n   [lanskro]  Lancrenon, J. and M. Skrobot,\
    \ \"On the Provable Security of\n              the Dragonfly Protocol\", ISC 2015\
    \ Proceedings of the 18th\n              International Conference on Information\n\
    \              Security - Volume 9290, pp. 244-261,\n              DOI 10.1007/978-3-319-23318-5_14,\
    \ September 2015.\n   [RANDOR]   Bellare, M. and P. Rogaway, \"Random Oracles\
    \ are Practical:\n              A Paradigm for Designing Efficient Protocols\"\
    , Proceedings\n              of the 1st ACM Conference on Computer and Communications\n\
    \              Security, pp. 62-73, ACM Press, DOI 10.1145/168588.168596,\n  \
    \            November 1993.\n   [RFC4086]  Eastlake 3rd, D., Schiller, J., and\
    \ S. Crocker,\n              \"Randomness Requirements for Security\", BCP 106,\
    \ RFC 4086,\n              DOI 10.17487/RFC4086, June 2005,\n              <https://www.rfc-editor.org/info/rfc4086>.\n\
    \   [RFC6090]  McGrew, D., Igoe, K., and M. Salter, \"Fundamental Elliptic\n \
    \             Curve Cryptography Algorithms\", RFC 6090,\n              DOI 10.17487/RFC6090,\
    \ February 2011,\n              <https://www.rfc-editor.org/info/rfc6090>.\n \
    \  [RFC7027]  Merkle, J. and M. Lochter, \"Elliptic Curve Cryptography\n     \
    \         (ECC) Brainpool Curves for Transport Layer Security\n              (TLS)\"\
    , RFC 7027, DOI 10.17487/RFC7027, October 2013,\n              <https://www.rfc-editor.org/info/rfc7027>.\n\
    \   [RFC7030]  Pritikin, M., Ed., Yee, P., Ed., and D. Harkins, Ed.,\n       \
    \       \"Enrollment over Secure Transport\", RFC 7030,\n              DOI 10.17487/RFC7030,\
    \ October 2013,\n              <https://www.rfc-editor.org/info/rfc7030>.\n  \
    \ [RFC7664]  Harkins, D., Ed., \"Dragonfly Key Exchange\", RFC 7664,\n       \
    \       DOI 10.17487/RFC7664, November 2015,\n              <https://www.rfc-editor.org/info/rfc7664>.\n\
    \   [RFC8280]  ten Oever, N. and C. Cath, \"Research into Human Rights\n     \
    \         Protocol Considerations\", RFC 8280, DOI 10.17487/RFC8280,\n       \
    \       October 2017, <https://www.rfc-editor.org/info/rfc8280>.\n   [SP800-38A]\n\
    \              Dworkin, M., \"Recommendation for Block Cipher Modes of\n     \
    \         Operation - Methods and Techniques\", NIST Special\n              Publication\
    \ 800-38A, DOI 10.6028/NIST.SP.800-38A,\n              December 2001, <https://nvlpubs.nist.gov/nistpubs/\n\
    \              Legacy/SP/nistspecialpublication800-38a.pdf>.\n   [SP800-56A]\n\
    \              Barker, E., Chen, L., Roginsky, A., Vassilev, A., and R.\n    \
    \          Davis, \"Recommendation for Pair-Wise Key-Establishment\n         \
    \     Schemes Using Discrete Logarithm Cryptography\", NIST\n              Special\
    \ Publication 800-56A, Revision 3,\n              DOI 10.6028/NIST.SP.800-56Ar3,\
    \ April 2018,\n              <https://nvlpubs.nist.gov/nistpubs/SpecialPublications/\n\
    \              NIST.SP.800-56Ar3.pdf>.\n"
- title: Appendix A.  Example Exchange
  contents:
  - "Appendix A.  Example Exchange\n   username: fred\n   password: barney\n   ----\
    \ prior to running TLS-PWD ----\n   server generates salt:\n   96 3c 77 cd c1\
    \ 3a 2a 8d 75 cd dd d1 e0 44 99 29\n   84 37 11 c2 1d 47 ce 6e 63 83 cd da 37\
    \ e4 7d a3\n   and a base:\n   6e 7c 79 82 1b 9f 8e 80 21 e9 e7 e8 26 e9 ed 28\n\
    \   c4 a1 8a ef c8 75 0c 72 6f 74 c7 09 61 d7 00 75\n   ---- state derived during\
    \ the TLS-PWD exchange ----\n   client and server agree to use brainpoolP256r1\n\
    \   client and server generate the PE:\n   PE.x:\n   29 b2 38 55 81 9f 9c 3f c3\
    \ 71 ba e2 84 f0 93 a3\n   a4 fd 34 72 d4 bd 2e 9d f7 15 2d 22 ab 37 aa e6\n \
    \  server private and mask:\n   private:\n   21 d9 9d 34 1c 97 97 b3 ae 72 df\
    \ d2 89 97 1f 1b\n   74 ce 9d e6 8a d4 b9 ab f5 48 88 d8 f6 c5 04 3c\n   mask:\n\
    \   0d 96 ab 62 4d 08 2c 71 25 5b e3 64 8d cd 30 3f\n   6a b0 ca 61 a9 50 34 a5\
    \ 53 e3 30 8d 1d 37 44 e5\n   client private and mask:\n   private:\n   17 1d\
    \ e8 ca a5 35 2d 36 ee 96 a3 99 79 b5 b7 2f\n   a1 89 ae 7a 6a 09 c7 7f 7b 43\
    \ 8a f1 6d f4 a8 8b\n   mask:\n   4f 74 5b df c2 95 d3 b3 84 29 f7 eb 30 25 a4\
    \ 88\n   83 72 8b 07 d8 86 05 c0 ee 20 23 16 a0 72 d1 bd\n   both parties generate\
    \ premaster secret and master secret\n   premaster secret:\n   01 f7 a7 bd 37\
    \ 9d 71 61 79 eb 80 c5 49 83 45 11\n   af 58 cb b6 dc 87 e0 18 1c 83 e7 01 e9\
    \ 26 92 a4\n   master secret:\n   65 ce 15 50 ee ff 3d aa 2b f4 78 cb 84 29 88\
    \ a1\n   60 26 a4 be f2 2b 3f ab 23 96 e9 8a 7e 05 a1 0f\n   3d 8c ac 51 4d da\
    \ 42 8d 94 be a9 23 89 18 4c ad\n   ---- ssldump output of exchange ----\n   New\
    \ TCP connection #1: Charlene Client <-> Sammy Server\n   1 1  0.0018 (0.0018)\
    \  C>SV3.3(173)  Handshake\n         ClientHello\n           Version 3.3\n   \
    \        random[32]=\n             52 8f bf 52 17 5d e2 c8 69 84 5f db fa 83 44\
    \ f7\n             d7 32 71 2e bf a6 79 d8 64 3c d3 1a 88 0e 04 3d\n         \
    \  ciphersuites\n           TLS_ECCPWD_WITH_AES_128_GCM_SHA256_PRIV\n        \
    \   TLS_ECCPWD_WITH_AES_256_GCM_SHA384_PRIV\n           Unknown value 0xff\n \
    \          compression methods\n                     NULL\n           extensions\n\
    \           TLS-PWD unprotected name[5]=\n             04 66 72 65 64\n      \
    \     elliptic curve point format[4]=\n             03 00 01 02\n           elliptic\
    \ curve list[58]=\n             00 38 00 0e 00 0d 00 1c 00 19 00 0b 00 0c 00 1b\n\
    \             00 18 00 09 00 0a 00 1a 00 16 00 17 00 08 00 06\n             00\
    \ 07 00 14 00 15 00 04 00 05 00 12 00 13 00 01\n             00 02 00 03 00 0f\
    \ 00 10 00 11\n   Packet data[178]=\n     16 03 03 00 ad 01 00 00 a9 03 03 52\
    \ 8f bf 52 17\n     5d e2 c8 69 84 5f db fa 83 44 f7 d7 32 71 2e bf\n     a6 79\
    \ d8 64 3c d3 1a 88 0e 04 3d 00 00 06 ff b3\n     ff b4 00 ff 01 00 00 7a b8 aa\
    \ 00 05 04 66 72 65\n     64 00 0b 00 04 03 00 01 02 00 0a 00 3a 00 38 00\n  \
    \   0e 00 0d 00 1c 00 19 00 0b 00 0c 00 1b 00 18 00\n     09 00 0a 00 1a 00 16\
    \ 00 17 00 08 00 06 00 07 00\n     14 00 15 00 04 00 05 00 12 00 13 00 01 00 02\
    \ 00\n     03 00 0f 00 10 00 11 00 0d 00 22 00 20 06 01 06\n     02 06 03 05 01\
    \ 05 02 05 03 04 01 04 02 04 03 03\n     01 03 02 03 03 02 01 02 02 02 03 01 01\
    \ 00 0f 00\n     01 01\n   1 2  0.0043 (0.0024)  S>CV3.3(94)  Handshake\n    \
    \     ServerHello\n           Version 3.3\n           random[32]=\n          \
    \   52 8f bf 52 43 78 a1 b1 3b 8d 2c bd 24 70 90 72\n             13 69 f8 bf\
    \ a3 ce eb 3c fc d8 5c bf cd d5 8e aa\n           session_id[32]=\n          \
    \   ef ee 38 08 22 09 f2 c1 18 38 e2 30 33 61 e3 d6\n             e6 00 6d 18\
    \ 0e 09 f0 73 d5 21 20 cf 9f bf 62 88\n           cipherSuite         TLS_ECCPWD_WITH_AES_128_GCM_SHA256_PRIV\n\
    \           compressionMethod                   NULL\n           extensions\n\
    \           renegotiate[1]=\n             00\n           elliptic curve point\
    \ format[4]=\n             03 00 01 02\n           heartbeat[1]=\n           \
    \  01\n   Packet data[99]=\n     16 03 03 00 5e 02 00 00 5a 03 03 52 8f bf 52\
    \ 43\n     78 a1 b1 3b 8d 2c bd 24 70 90 72 13 69 f8 bf a3\n     ce eb 3c fc d8\
    \ 5c bf cd d5 8e aa 20 ef ee 38 08\n     22 09 f2 c1 18 38 e2 30 33 61 e3 d6 e6\
    \ 00 6d 18\n     0e 09 f0 73 d5 21 20 cf 9f bf 62 88 ff b3 00 00\n     12 ff 01\
    \ 00 01 00 00 0b 00 04 03 00 01 02 00 0f\n     00 01 01\n   1 3  0.0043 (0.0000)\
    \  S>CV3.3(141)  Handshake\n         ServerKeyExchange\n           params\n  \
    \           salt[32]=\n               96 3c 77 cd c1 3a 2a 8d 75 cd dd d1 e0 44\
    \ 99 29\n               84 37 11 c2 1d 47 ce 6e 63 83 cd da 37 e4 7d a3\n    \
    \         EC parameters = 3\n             curve id = 26\n             element[65]=\n\
    \               04 22 bb d5 6b 48 1d 7f a9 0c 35 e8 d4 2f cd 06\n            \
    \   61 8a 07 78 de 50 6b 1b c3 88 82 ab c7 31 32 ee\n               f3 7f 02 e1\
    \ 3b d5 44 ac c1 45 bd d8 06 45 0d 43\n               be 34 b9 28 83 48 d0 3d\
    \ 6c d9 83 24 87 b1 29 db\n               e1\n             scalar[32]=\n     \
    \          2f 70 48 96 69 9f c4 24 d3 ce c3 37 17 64 4f 5a\n               df\
    \ 7f 68 48 34 24 ee 51 49 2b b9 66 13 fc 49 21\n   Packet data[146]=\n     16\
    \ 03 03 00 8d 0c 00 00 89 00 20 96 3c 77 cd c1\n     3a 2a 8d 75 cd dd d1 e0 44\
    \ 99 29 84 37 11 c2 1d\n     47 ce 6e 63 83 cd da 37 e4 7d a3 03 00 1a 41 04\n\
    \     22 bb d5 6b 48 1d 7f a9 0c 35 e8 d4 2f cd 06 61\n     8a 07 78 de 50 6b\
    \ 1b c3 88 82 ab c7 31 32 ee f3\n     7f 02 e1 3b d5 44 ac c1 45 bd d8 06 45 0d\
    \ 43 be\n     34 b9 28 83 48 d0 3d 6c d9 83 24 87 b1 29 db e1\n     00 20 2f 70\
    \ 48 96 69 9f c4 24 d3 ce c3 37 17 64\n     4f 5a df 7f 68 48 34 24 ee 51 49 2b\
    \ b9 66 13 fc\n     49 21\n   1 4  0.0043 (0.0000)  S>CV3.3(4)  Handshake\n  \
    \       ServerHelloDone\n   Packet data[9]=\n     16 03 03 00 04 0e 00 00 00\n\
    \   1 5  0.0086 (0.0043)  C>SV3.3(104)  Handshake\n         ClientKeyExchange\n\
    \           element[65]=\n             04 a0 c6 9b 45 0b 85 ae e3 9f 64 6b 6e\
    \ 64 d3 c1\n             08 39 5f 4b a1 19 2d bf eb f0 de c5 b1 89 13 1f\n   \
    \          59 5d d4 ba cd bd d6 83 8d 92 19 fd 54 29 91 b2\n             c0 b0\
    \ e4 c4 46 bf e5 8f 3c 03 39 f7 56 e8 9e fd\n             a0\n           scalar[32]=\n\
    \             66 92 44 aa 67 cb 00 ea 72 c0 9b 84 a9 db 5b b8\n             24\
    \ fc 39 82 42 8f cd 40 69 63 ae 08 0e 67 7a 48\n   Packet data[109]=\n     16\
    \ 03 03 00 68 10 00 00 64 41 04 a0 c6 9b 45 0b\n     85 ae e3 9f 64 6b 6e 64 d3\
    \ c1 08 39 5f 4b a1 19\n     2d bf eb f0 de c5 b1 89 13 1f 59 5d d4 ba cd bd\n\
    \     d6 83 8d 92 19 fd 54 29 91 b2 c0 b0 e4 c4 46 bf\n     e5 8f 3c 03 39 f7\
    \ 56 e8 9e fd a0 00 20 66 92 44\n     aa 67 cb 00 ea 72 c0 9b 84 a9 db 5b b8 24\
    \ fc 39\n     82 42 8f cd 40 69 63 ae 08 0e 67 7a 48\n   1 6  0.0086 (0.0000)\
    \  C>SV3.3(1)  ChangeCipherSpec\n   Packet data[6]=\n     14 03 03 00 01 01\n\
    \   1 7  0.0086 (0.0000)  C>SV3.3(40)  Handshake\n   Packet data[45]=\n     16\
    \ 03 03 00 28 44 cd 3f 26 ed 64 9a 1b bb 07 c7\n     0c 6d 3e 28 af e6 32 b1 17\
    \ 29 49 a1 14 8e cb 7a\n     0b 4b 70 f5 1f 39 c2 9c 7b 6c cc 57 20\n   1 8  0.0105\
    \ (0.0018)  S>CV3.3(1)  ChangeCipherSpec\n   Packet data[6]=\n     14 03 03 00\
    \ 01 01\n   1 9  0.0105 (0.0000)  S>CV3.3(40)  Handshake\n   Packet data[45]=\n\
    \     16 03 03 00 28 fd da 3c 9e 48 0a e7 99 ba 41 8c\n     9f fd 47 c8 41 2c\
    \ fd 22 10 77 3f 0f 78 54 5e 41\n     a2 21 94 90 12 72 23 18 24 21 c3 60 a4\n\
    \   1 10 0.0107 (0.0002)  C>SV3.3(100)  application_data\n   Packet data....\n"
- title: Acknowledgements
  contents:
  - "Acknowledgements\n   The authenticated key exchange defined here has also been\
    \ defined for\n   use in 802.11 networks, as an Extensible Authentication Protocol\n\
    \   (EAP) method, and as an authentication method for the Internet Key\n   Exchange\
    \ Protocol (IKE).  Each of these specifications has elicited\n   very helpful\
    \ comments from a wide collection of people that have\n   allowed the definition\
    \ of the authenticated key exchange to be\n   refined and improved.\n   The author\
    \ would like to thank Scott Fluhrer for discovering the\n   \"password as exponent\"\
    \ attack that was possible in an early version\n   of this key exchange and for\
    \ his very helpful suggestions on the\n   techniques for fixing the PE to prevent\
    \ it.  The author would also\n   like to thank Hideyuki Suzuki for his insight\
    \ in discovering an\n   attack against a previous version of the underlying key\
    \ exchange\n   protocol.  Special thanks to Lily Chen for helpful discussions\
    \ on\n   hashing into an elliptic curve.  Rich Davis suggested the defensive\n\
    \   checks that are part of the processing of the ServerKeyExchange and\n   ClientKeyExchange\
    \ messages, and his various comments have greatly\n   improved the quality of\
    \ this memo and the underlying key exchange on\n   which it is based.\n   Martin\
    \ Rex, Peter Gutmann, Marsh Ray, and Rene Struik discussed on\n   the TLS mailing\
    \ list the possibility of a side-channel attack against\n   the hunting-and-pecking\
    \ loop.  That discussion prompted the addition\n   of the security parameter,\
    \ m, to the hunting-and-pecking loop.  Scott\n   Fluhrer suggested the blinding\
    \ technique to test whether a value is a\n   quadratic residue modulo a prime\
    \ in a manner that does not leak\n   information about the value being tested.\n"
- title: Author's Address
  contents:
  - "Author's Address\n   Dan Harkins (editor)\n   HP Enterprise\n   3333 Scott Blvd.\n\
    \   Santa Clara, CA  95054\n   United States of America\n   Email: dharkins@lounge.org\n"
