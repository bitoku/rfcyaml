- title: __initial_text__
  contents:
  - '                Telnet Data Entry Terminal Option

    '
- title: '1.  Command Name and code:'
  contents:
  - "1.  Command Name and code:\n        DET             20\n"
- title: 2.  Command Meanings
  contents:
  - "2.  Command Meanings\n     IAC WILL DET\n     The sender of this command REQUESTS\
    \ or AGREES  to  send  and\n     receive subcommands to control the Data Entry\
    \ Terminal.\n     IAC WONT DET\n     The sender of this  command  REFUSES  to\
    \  send  and  receive\n     subcommands to control the Data Entry Terminal.\n\
    \     IAC DO DET\n     The sender of this command REQUESTS or AGREES  to  send\
    \  and\n     receive subcommands to control the Data Entry Terminal.\n     IAC\
    \ DONT DET\n     The sender of this  command  REFUSES  to  send  and  receive\n\
    \     subcommands to control the Data Entry Terminal.\n     The DET option  uses\
    \  five  classes  of  subcommands  1)  to\n     establish   the   requirements\
    \   and   capabilities  of  the\n     application and the terminal, 2) to format\
    \ the  screen,  and\n     to  control  the  3)  edit,  4) erasure, and 5) transmission\n\
    \     functions.  The subcommands that perform these functions are\n     described\
    \ below.\n     T\b__\bh_\be_N\b__\be_\bt_\bw_\bo_\br_\bk_V\b__\bi_\br_\bt_\bu_\b\
    a_\bl_D\b__\ba_\bt_\ba_E\b__\bn_\bt_\br_\by_T\b__\be_\br_\bm_\bi_\bn_\ba_\bl(NVDET)\n\
    \        The NVDET  consists  of  a  keyboard  and  a  rectangular\n        display.\
    \   The  keyboard  is capable of generating all of\n        the characters of\
    \ the ASCII character set.  In  addition,\n        the  keyboard may possess a\
    \ number of function keys which\n        when pressed cause a FN subcommand to\
    \ be sent.  (Although\n        most DET's will support one or  more  peripheral\
    \  devices\n        such  as  a  paper  tape reader or a printer, this option\n\
    \                                                          RFC 731\n        does\
    \ not consider their support.  Support  of  peripheral\n        devices should\
    \ be treated by a separate option.)\n        The screen of the data entry terminal\
    \ is  a  rectangle  M\n        characters  by N lines.  The values of M and N\
    \ are set by\n        negotiating the Output Line Width and  Output  Page  Size\n\
    \        options,  respectively.   The next writing position (x,y)\n        on\
    \ the screen (where x is the character position and y is\n        the position\
    \ of the line on the screen) is indicated by a\n        special display character\
    \ called the cursor.  The  cursor\n        may  be  moved  to  any  position \
    \ on  the screen without\n        disturbing any characters already on the screen.\
    \   Cursor\n        addressing   in   existing   terminals  utilizes  several\n\
    \        topologies and addressing methods.  In order to make  the\n        burden\
    \ of implementaton as easy as possible this protocol\n        supports two topologies\
    \ (the finite plane and the helical\n        torus)  and three addressing methods\
    \ ((x,y); x and y, and\n        relative  increments).   Since  the  finite  plane\
    \   with\n        absolute  addressing  is  the  least  ambiguous  and  the\n\
    \        easiest to translate to and from the others,  it  is  the\n        default\
    \ scheme used by the NVDET.  The torodial form with\n        either  relative\
    \  or  absolute addressing is provided for\n        convience.\n        Also \
    \ the NVDET provides a mechanism for defining on  the\n        screen  fields\
    \  with  special  attributes.   For example,\n        characters entered into\
    \ these  fields  may  be  displayed\n        with  brighter intensity, highlighted\
    \ by reverse video or\n        blinking, or protected from  modification  by \
    \ the  user.\n        This  latter  feature is one of the most heavily used for\n\
    \        applications where the DET displays a form to  be  filled\n        out\
    \ by the user.\n        The  definition  of  the   NVDET   uses   Telnet   option\n\
    \        subnegotiations  to  accomplish  all  of  its  functions.\n        Since\
    \ none of the  ASCII  characters  sent  in  the  data\n        stream  have been\
    \ used to define these functions, the DET\n        option can be used in a \"\
    raw\" or even  \"rare\"  mode.   In\n        circumstances  where  the  application\
    \ program knows what\n        kind of terminal is on the other end,  it  can \
    \ send  the\n        ASCII   characters  required  to  control  functions  not\n\
    \        supported by the option or an implementation.  In general\n        keeping\
    \ all  NVDET  functions  out  of  the  data  stream\n        provides better flexibility.\n\
    \     F\b__\ba_\bc_\bi_\bl_\bi_\bt_\by_F\b__\bu_\bn_\bc_\bt_\bi_\bo_\bn_\bs  (for\
    \ detailed semantics see Section 5.)\n     IAC SB DET <DET facility subcommand><facility\
    \ map> IAC SE\n        where  <DET  facility  subcommand>  is  one  8-bit   byte\n\
    \                                                          RFC 731\n        indicating\
    \  the  class of the facilities to be described,\n        and <facility map> is\
    \ a field of one or two  8-bit  bytes\n        containing  flags  describing \
    \ the facilities required or\n        desired by the sender.  The bits of the\
    \ facility maps are\n        numbered from the right starting at zero.  Thus,\
    \ if bit 2\n        is set the field will have a decimal  value  of  4.   The\n\
    \        values of the field are as follows:\n        facility cmd:  EDIT FACILITIES\
    \     subcommand code: 1\n          facility map:                            \
    \  bit numbers\n             Toroidal Cursor Addressing                  6\n \
    \            Incremental Cursor Addressing               5\n             Read\
    \ Cursor Address                         4\n             Line Insert/Delete  \
    \                        3\n             Char Insert/Delete                  \
    \        2\n             Back Tab                                    1\n     \
    \        Positive Addressing only                    0\n        where:\n     \
    \   If the Toroidal Cursor Addressing bit is set, the  sender\n        requests\
    \  or  provides  that the SKIP TO LINE and SKIP TO\n        CHAR subcommands be\
    \ supported.\n        If the Incremental Cursor  Addressing  bit  is  set,  the\n\
    \        sender  requests or provides that the UP, DOWN, LEFT, and\n        RIGHT\
    \ subcommands be supported.\n        If the Read Cursor bit is set,  the  sender\
    \  requests  or\n        provides the READ CURSOR subcommand.\n        If the\
    \ Line Insert/Delete bit is set, the sender requests\n        or  provides  that\
    \  the  LINE  INSERT  and  LINE   DELETE\n        subcommands be supported.\n\
    \        If the Char Insert/Delete bit is set, the sender requests\n        or\
    \  provides  that  the  CHAR  INSERT  and  CHAR   DELETE\n        subcommands\
    \ be supported.\n        If the Back Tab  bit  is  set,  the  sender  requests\
    \  or\n        provides that the BACK TAB subcommand be supported.\n        If\
    \ the Positive Addressing bit is set, then the sender is\n        informing the\
    \ receiver that it can only move  the  cursor\n        in  the  positive direction.\
    \  (Note:  Terminals that have\n        this property also have a Home function\
    \ to  get  back  to\n        the beginning.)\n        facility cmd:  ERASE FACILITIES\
    \     subcommand code:  2\n          facility map:                           \
    \     bit numbers\n                                                          RFC\
    \ 731\n             Erase Field                                     4\n      \
    \       Erase Line                                      3\n             Erase\
    \ Rest of Screen                            2\n             Erase Rest of Line\
    \                              1\n             Erase Rest of Field           \
    \                  0\n        where:\n        If a bit of the facility map for\
    \ this facility command is\n        set,  the  sender  requests  or  provides\
    \  the   facility\n        indicated by the bit.  For a more complete description\
    \ of\n        each  of  these functions see the Erase Functions section\n    \
    \    below.\n        facility cmd:  TRANSMIT FACILITIES     subcommand code: \
    \ 3\n          facility map:                      bit numbers\n             Data\
    \ Transmit                         5\n             Transmit Line             \
    \            4\n             Transmit Field                        3\n       \
    \      Transmit Rest of Screen               2\n             Transmit Rest of\
    \ Line                 1\n             Transmit Rest of Field                0\n\
    \        where:\n        If a bit of the facility map for this facility command\
    \ is\n        set,  the  sender  requests  or  provides  the   facility\n    \
    \    indicated by the bit.  For a more complete description of\n        each \
    \ of  these  functions  see  the  Transmit  Functions\n        section below.\n\
    \        facility cmd:  FORMAT FACILITIES     subcommand code:  4\n          facility\
    \ map:                               bit numbers\n                           \
    \             byte 0\n             Repeat                                    \
    \     4\n             Blinking                                       3\n     \
    \        Reverse Video                                  2\n             Right\
    \ Justification                            1\n             Overstrike        \
    \                             0\n                                        byte\
    \ 1\n             Protection On/Off                              6\n         \
    \    Protection                                     5\n             Alphabetic-only\
    \ Protection                     4\n             Numeric-only Protection     \
    \                   3\n             Intensity                                \
    \      0-2\n        where:\n        If the Repeat bit is set the sender requests\
    \ or  provides\n                                                          RFC\
    \ 731\n        the REPEAT subcommand.\n        If the Blinking  bit  is  set,\
    \  the  sender  requests  or\n        provides  the ability to highlight a string\
    \ of characters\n        by causing them to blink.\n        If the Reverse Video\
    \ bit is set, the sender  requests  or\n        provides  the ability to highlight\
    \ a string of characters\n        by \"reversing the video image,\" i.e., if \
    \ the  characters\n        are  normally  displayed  as  black characters on a\
    \ white\n        background, this is reversed to be white characters on  a\n \
    \       black background, or vice versa.\n        If  the  Right  Justification\
    \  bit  is  set,  the  sender\n        requests or provides the ability to cause\
    \ entries of data\n        to be right justified in the field.\n        If the\
    \ Overstrike bit is  set,  the  sender  requests  or\n        provides  the  ability\
    \  to superimpose one character over\n        another on the screen much  like\
    \  a  hard  copy  terminal\n        would  do if the print mechanism struck the\
    \ same position\n        on the paper with different characters.\n        If the\
    \ Protection On/Off bit is set, the sender  requests\n        or  provides  the\
    \  ability  to  turn  on  and  off  field\n        protection.\n        If the\
    \ Protection bit is  set,  the  sender  requests  or\n        provides  the  ability\
    \  to  protect  certain  strings  of\n        characters displayed on the screen\
    \ from being altered  by\n        the  user of the terminal.  Setting this bit\
    \ also implies\n        that   ERASE   UNPROTECTED   and   TRANSMIT   UNPROTECTED\n\
    \        subcommands (see below) are supported.\n        If the Alphabetic-only\
    \ Protection bit is set, the  sender\n        requests or provides the ability\
    \ to constrain the user of\n        the  terminal such that he may only enter\
    \ alphabetic data\n        into certain areas of the screen.\n        If the Numeric-only\
    \ Protection bit  is  set,  the  sender\n        requests or provides the ability\
    \ to constrain the user of\n        the  terminal  such that he may only enter\
    \ numerical data\n        into certain areas of the screen.\n        The three\
    \ bits of the  Intensity  field  will  contain  a\n        positive  binary  integer\
    \ indicating the number of levels\n        of intensity that the sender  requests\
    \  or  provides  for\n        displaying the data.  The value of the 3 bit field\
    \ should\n        be interpreted in the following way:\n                     \
    \                                     RFC 731\n           1        one visible\
    \ intensity\n           2        two intensities; normal and bright\n        \
    \   3        three intensities; off, normal, and bright\n          >3        >3\
    \ intensities; off, and the remaining levels\n                    proportioned\
    \ from dimmest to brightest intensity.\n        For the all of the above commands,\
    \ if the appropriate bit\n        in <facility map> is not set, then the  sender\
    \  does  not\n        request or provide that facility.\n     E\b__\bd_\bi_\b\
    t_\bi_\bn_\bg_F\b__\bu_\bn_\bc_\bt_\bi_\bo_\bn_\bs\n        IAC SB DET MOVE CURSOR\
    \ <x><y> IAC SE  subcommand code: 5\n        where <x> is an 8-bit byte containing\
    \ a  positive  binary\n        integer   representing  the  character  position\
    \  of  the\n        cursor, <y> is an 8-bit byte containing a positive binary\n\
    \        integer representing the line position of the cursor.\n        This subcommand\
    \ moves the cursor to the  absolute  screen\n        address (x,y) with the following\
    \ boundary conditions:\n          if x>M-1, set x=M-1 and send an ERROR subcommand\n\
    \          if y>N-1, set y=N-1 and send an  ERROR subcommand\n        This describes\
    \ a finite plane topology on the screen.\n        IAC SB DET SKIP TO LINE <y>\
    \ IAC SE    subcommand code: 6\n        where <y> is a positive 8-bit binary number.\n\
    \        This subcommand moves the cursor to the  absolute  screen\n        line\
    \ y.  x remains constant.  For values of y>N-1\n          y = y mod N.\n     \
    \   IAC SB DET SKIP TO CHAR <x> IAC SE   subcommand code: 7\n        where <x>\
    \ is a positive 8-bit binary number.\n        This  subcommand  moves  the  cursor\
    \  to   the   absolute\n        character  position  x.  y remains constant, unless\
    \ x>M-1\n        in which case:\n          x' = (x mod M)\n          y' = (y+(x\
    \ DIV N))\n          where x' and y' are the new values of  the cursor.\n    \
    \    These last two subcommands define a toroidal topology  on\n        the screen.\n\
    \                                                          RFC 731\n        IAC\
    \ SB DET UP IAC SE            subcommand code:  8\n        IAC SB DET DOWN IAC\
    \ SE          subcommand code:  9\n        IAC SB DET LEFT IAC SE          subcommand\
    \ code: 10\n        IAC SB DET RIGHT IAC SE         subcommand code: 11\n    \
    \    These subcommands are provided as a convenience for  some\n        terminals.\
    \   The  commands  UP, DOWN, LEFT, and RIGHT are\n        defined as\n       \
    \ UP:         (x,y)=(x, y-1 mod N)\n        DOWN:       (x,y)=(x, y+1 mod N)\n\
    \        LEFT:       (x,y)=(x-1, y); if x=0 then x-1 = 0\n        RIGHT:     \
    \ (x,y)=(x+1 mod M, y) and y = y+1 if x+1>M-1\n        Note:  DOWN, LEFT, and\
    \ RIGHT cannot always be replaced by\n        the  ASCII  codes  for  linefeed,\
    \  backspace,  and  space\n        respectively.   The latter are format effectors\
    \ while the\n        former are cursor controls.\n        IAC SB DET HOME IAC\
    \ SE      subcommand code:  12\n        This subcommand positions the cursor to\
    \ (0,0).   This  is\n        equivalent  to  a MOVE CURSOR 0,0 or the sequence\
    \ SKIP TO\n        LINE 0, SKIP TO CHAR 0.  This subcommand is provided  for\n\
    \        convenience,  since  most terminals have\x7F it as a separate\n     \
    \   control.\n        IAC SB DET LINE INSERT IAC SE     subcommand code:  13\n\
    \        This subcommand inserts a line of spaces between lines  y\n        (the\
    \  current  line,  determined  by  the position of the\n        cursor) and line\
    \ y-1.  Lines y through N-2 move down  one\n        line,  i.e.  line  y  becomes\
    \ line y+1;  y+1 becomes y+2,\n        ...; N-2 becomes N-1.  Line N-1 is lost\
    \ off the bottom of\n        the  screen.   The  position  of   the   cursor \
    \  remains\n        unchanged.\n        IAC SB DET LINE DELETE IAC SE     subcommand\
    \ code:  14\n        This subcommand deletes line y where  y  is  the  current\n\
    \        line  position of the cursor.  Lines y+1 through N-1 move\n        up\
    \ one line, i.e.  line y+1 becomes line y;  y+2  becomes\n        y+1;  ...; \
    \ N-1  becomes N-2.  The N-1st line position is\n        set  to  all  spaces.\
    \   The   cursor   position   remains\n        unchanged.\n        IAC SB DET\
    \ CHAR INSERT IAC SE     subcommand code: 15\n        This subcommand inserts\
    \ the next character  in  the  data\n        stream  between  the xth and x-1st\
    \ characters, where x is\n                                                   \
    \       RFC 731\n        the current character position of the  cursor.   The\
    \  xth\n        through  M-2nd  characters  on  the  line are shifted one\n  \
    \      character positon to the right.   The  new  character  is\n        inserted\
    \   at   the  vacated  xth  position.   The  M-1st\n        character is lost.\
    \  The position of  the  cursor  remains\n        unchanged.\n        IAC SB DET\
    \ CHAR DELETE IAC SE     subcommand code:  16\n        This subcommand deletes\
    \ the character on  the  screen  at\n        the x-th position.  The x-th character\
    \ is removed and the\n        characters  x+1  through  M-1  are  shifted one\
    \ character\n        position to the left to become  the  x-th  through  M-2nd\n\
    \        characters.   The M-1st character position is left empty.\n        (For\
    \ most terminals it will be set to a  NUL  or  space.)\n        The cursor position\
    \ remains unchanged.\n        IAC SB DET READ CURSOR IAC SE     subcommand code:\
    \  17\n        This subcommand requests the receiver to send the present\n   \
    \     position of the cursor to the sender.\n        IAC SB DET CURSOR POSITION\
    \ <x><y> IAC SE\n                                          subcommand code:  18\n\
    \        where <x> and <y> are positive 8-bit binary integers.\n        This subcommand\
    \ is sent by  a  Telnet  implementation  in\n        response  to  a  READ  CURSOR\
    \  subcommand  to  convey the\n        coordinates of the cursor to the other\
    \ side.  Note: x  is\n        less than  M and y is less than  N.\n        IAC\
    \  SB DET REVERSE TAB IAC SE     subcommand code:  19\n        This subcommand\
    \ causes the cursor to move to the previous\n        tab position.  If none exists\
    \ on the  present  line,  the\n        cursor  moves  to the previous line and\
    \ so on until a tab\n        is found or the address (0,0) is encountered.  When\
    \ field\n        protection is in effect the cursor moves to the beginning\n \
    \       of the preceding unprotected field.\n     T\b__\br_\ba_\bn_\bs_\bm_\b\
    i_\bt_F\b__\bu_\bn_\bc_\bt_\bi_\bo_\bn_\bs  (For detailed semantics see Section\
    \ 5.)\n        IAC SB DET TRANSMIT SCREEN IAC SE     subcommand code: 20\n   \
    \     This subcommand  causes  the  terminal  to  transmit  all\n        characters\
    \   on   the   screen  from  position  (0,0)  to\n        (M-1,N-1).   The  cursor\
    \  will  be  at  (0,0)  after  the\n        operation is complete.\n         \
    \                                                 RFC 731\n        IAC SB DET\
    \ TRANSMIT UNPROTECTED IAC SE\n                                        subcommand\
    \ code:  21\n        This subcommand  causes  the  terminal  to  transmit  all\n\
    \        characters  in  unprotected fields from position (0,0) to\n        (M-1,N-1).\
    \  The unprotected fields are separated  by  the\n        field  separator subcommand.\
    \  The cursor will be at (0,0)\n        or at the beginning of the first unprotected\
    \ field  after\n        the operation is complete.\n        IAC SB DET TRANSMIT\
    \ LINE IAC SE      subcommand code:  22\n        This subcommand causes the terminal\
    \ to transmit all  data\n        on  the  yth  line  where  y is determined by\
    \ the present\n        position of the cursor.   Data  is  sent  from  character\n\
    \        position  (0,y)  to  the  end-of-line or position (M-1,y)\n        whichever\
    \ comes first.  The  cursor  position  after  the\n        transmission  is  one\
    \ character position after the end of\n        line  condition  or  the  beginning\
    \  of  the  next  line,\n        (0,y+1).\n        IAC SB DET TRANSMIT FIELD IAC\
    \ SE     subcommand code:  23\n        This subcommand causes the terminal to\
    \ transmit all  data\n        in  the  field  presently  occupied  by  the cursor.\
    \  The\n        cursor position after the operation is  complete  is  one\n  \
    \      character position after the end of the field or, if that\n        position\
    \  is  protected,  at  the  beginning  of the next\n        unprotected field.\n\
    \        IAC SB DET TRANSMIT REST OF SCREEN IAC SE\n                         \
    \               subcommand code:  24\n        This subcommand  causes  the  terminal\
    \  to  transmit  all\n        characters on the screen from position (x,y) to\
    \ (M-1,N-1)\n        or  until  the end of text.   (x,y) is the current cursor\n\
    \        position.  The cursor position after the operation is one\n        character\
    \ position after  the  last  text  character,  or\n        (0,0) if the last filled\
    \ character position is (M-1,N-1).\n        IAC SB DET TRANSMIT REST OF LINE IAC\
    \ SE\n                                        subcommand code:  25\n        This\
    \ subcommand  causes  the  terminal  to  transmit  all\n        characters on\
    \ the yth line from position (x,y) to the end\n        of  line  or (M-1,y) whichever\
    \ comes first.  (x,y) is the\n        current cursor position.  The cursor position\
    \  after  the\n        operation  is  one  character  position  after  the  last\n\
    \        character of the line or the first character of the  next\n        line.\n\
    \                                                          RFC 731\n        IAC\
    \ SB DET TRANSMIT REST OF FIELD IAC SE\n                                     \
    \   subcommand code:  26\n        This subcommand causes the receiver to transmit\
    \ the  rest\n        of  the characters in the field currently occupied by the\n\
    \        cursor.  The cursor position after the  operation  is  at\n        the\
    \ beginning of the next field.\n        IAC SB DET DATA TRANSMIT <x><y> IAC SE\n\
    \                                        subcommand code:  27\n        This subcommand\
    \ is used to preface  data  sent  from  the\n        terminal  in  response  to\
    \  a  user  action or a TRANSMIT\n        command.  The parameters <x> and <y>\
    \ indicate the initial\n        position of the cursor.   See  the  Transmit \
    \ Subcommands\n        subsection in Section 5 for more details.\n     E\b__\b\
    r_\ba_\bs_\be_F\b__\bu_\bn_\bc_\bt_\bi_\bo_\bn_\bs\n        IAC SB DET ERASE SCREEN\
    \ IAC SE     subcommand code: 28\n        This subcommand causes all characters\
    \ to be removed  from\n        the  screen.   All  fields regardless of their\
    \ attributes\n        are deleted.  The cursor  position  after  the  operation\n\
    \        will  be (0,0).  Most terminals set the erased characters\n        to\
    \ either NUL or space characters.\n        IAC SB DET ERASE LINE IAC SE     subcommand\
    \ code:  29\n        This subcommand causes all characters on the yth line  to\n\
    \        be  removed  from  the screen, where y is the line of the\n        current\
    \ cursor position.  All fields regardless of  their\n        attributes  are \
    \ deleted.  The cursor position after this\n        operation will be (0,y). \
    \ Note:  This  operation  can  be\n        easily  simulated  by  the  sequence:\
    \   LINE DELETE, LINE\n        INSERT.  However, the order is important to  insure\
    \  that\n        no data is lost off the bottom of the screen.\n        IAC SB\
    \ DET ERASE FIELD IAC SE     subcommand code:  30\n        This  subcommand  causes\
    \  all  characters  in  the  field\n        occupied  by  the  cursor  to  be\
    \  removed.   The  cursor\n        position after the operation is at the beginning\
    \  of  the\n        field.\n        IAC SB DET ERASE REST OF SCREEN IAC SE\n \
    \                                       subcommand code:  31\n               \
    \                                           RFC 731\n        This subcommand causes\
    \ all characters from position (x,y)\n        to (M-1,N-1) to be removed from\
    \ the screen.   All  fields\n        regardless  of  their attributes are deleted.\
    \  The cursor\n        position after  the  operation  is  unchanged.   This \
    \ is\n        equivalent  to  doing  an  ERASE REST OF LINE plus a LINE\n    \
    \    DELETE for lines greater than y.\n        IAC SB DET ERASE REST OF LINE IAC\
    \ SE\n                                        subcommand code:  32\n        This\
    \ subcommand causes all characters from position (x,y)\n        to (M-1,y) to\
    \ be  removed  from  the  screen  All  fields\n        regardless  of  their attributes\
    \ are deleted.  The cursor\n        position after the operation is unchanged.\n\
    \        IAC SB DET ERASE REST OF FIELD IAC SE\n                             \
    \           subcommand code:  33\n        This subcommand causes all characters\
    \ from position (x,y)\n        to the end of the current field to be  removed\
    \  from  the\n        screen.   The  cursor  position  after  the  operation is\n\
    \        unchanged.\n        IAC SB DET ERASE UNPROTECTED IAC SE\n           \
    \                             subcommand code:  34\n        This subcommand causes\
    \ all characters on  the  screen  in\n        unprotected  fields  to  be removed\
    \ from the screen.  The\n        cursor position after the operation is at  (0,0)\
    \  or,  if\n        that position is protected, at the beginning of the first\n\
    \        unprotected field.\n     F\b__\bo_\br_\bm_\ba_\bt_F\b__\bu_\bn_\bc_\b\
    t_\bi_\bo_\bn_\bs\n        IAC SB DET FORMAT DATA <format map><count> IAC SE\n\
    \                                        subcommand code:  35\n        where <format\
    \  map>  is  an  8-bit  byte  containing  the\n        following flags:\n    \
    \      Blinking                                 7\n          Reverse Video   \
    \                         6\n          Right Justification                   \
    \   5\n          Protection                              3-4\n          Intensity\
    \                               0-2\n        where:\n        If the Blinking \
    \ bit  is  set,  the  following  field  of\n        <count>  characters  should\
    \  have  the Blinking attribute\n                                            \
    \              RFC 731\n        applied  to it by the receiver.\n        If the\
    \ Reverse Video bit is set, the following  field  of\n        <count>  characters\
    \  should  be displayed by the receiver\n        with video reversed.\n      \
    \  If the Right Justification bit is set, the input  entered\n        into  the\
    \  field  of  <count>  characters should be right\n        justified.\n      \
    \  The Protection field is two bits wide and may take on the\n        following\
    \ values:\n          0         no protection\n          1         protected\n\
    \          2         alphabetic only\n          3         numeric only\n     \
    \   The protection attribute specifies that  the  other  side\n        may  modify\
    \  any  character  (no  protection),  modify no\n        characters   (protected),\
    \   enter    only    alphabetical\n        characters  (A-Z,  and  a-z)  (alphabetic\
    \ only), or enter\n        only numerical characters (0-9,+,.,and -) (numeric\
    \  only)\n        in the following field of <count> bytes.\n        The  Intensity\
    \  field  is  3  bits  wide  and  should  be\n        interpreted in the following\
    \ way:\n        The values 0-6 should be used as  an  indication  of  the\n  \
    \      relative  brightness  to  be  used  when  displaying  the\n        characters\
    \ in or entered into the following field <count>\n        characters wide.  The\
    \  number  of  levels  of  brightness\n        available  should  have  been \
    \ obtained previously by the\n        Format Facility  subcommand.   The  exact\
    \  algorithm  for\n        mapping these values to the available levels of intensity\n\
    \        is  left  to  the  implementors.   A  value  of  7 in the\n        intensity\
    \ field indicates that the brightness  should  be\n        off,  and  any  characters\
    \  in  or entered into the field\n        should not be displayed.\n        <count>\
    \ is 2  bytes  that  should  be  interpreted  as  a\n        positive 16-bit binary\
    \ integer representing the number of\n        characters  following  this command\
    \ which are affected by\n        it.\n        Data sent to the terminal or the\
    \ Using Host for unwritten\n        areas of the screen not in the scope of the\
    \ count  should\n        be  displayed  with the default values of the format\
    \ map.\n        The default values are  No  Blinking,  Normal  Video,  No\n  \
    \      Justification, No Protection and Normal Intensity.\n                  \
    \                                        RFC 731\n        This subcommand is used\
    \ to format data to be displayed on\n        the screen of the terminal.  The\
    \ <format  map>  describes\n        the  attributes  that the field <count> bytes\
    \ wide should\n        have.  This field is to start  at  the  position  of  the\n\
    \        cursor  when the command is acted upon.  The next <count>\n        displayable\
    \ characters in the data  stream  are  used  to\n        fill  the  field.   Subsequent\
    \  REPEAT subcommands may be\n        used to specify the  contents  of  this\
    \  field.   If  the\n        sender  specifies  attributes  that  have not been\
    \ agreed\n        upon by the use of the Format  Facility  subcommand,  the\n\
    \        Telnet  process  should  send  an Error Subcommand to the\n        sender,\
    \ but format the screen as if the bit had not  been\n        set.\n        IAC\
    \ SB DET REPEAT <count><char> IAC SE\n                                       \
    \ subcommand code:  36\n        where  <count>  is  a  positive  8-bit  binary\
    \   integer.\n        <char> is an 8-bit byte containing an ASCII character.\n\
    \        This subcommand is used to perform  data  compression  on\n        data\
    \  being  transferred  to  the  terminal  by  encoding\n        strings of identical\
    \ characters as the  character  and  a\n        count.   The  repeated  characters\
    \ may be part of a field\n        specified\x7F\x7F\n        IAC SB DET SUPPRESS\
    \ PROTECTION <negotiation> IAC SE\n                                          \
    \  subcommand code:  37\n        where <negotiation> may have the  values  of\
    \  the  Telnet\n        option negotiation:\n                    251         \
    \        WILL\n                    252                 WONT\n                \
    \    253                 DO\n                    254                 DONT\n  \
    \      This subcommand is used to suppress the field  protection\n        in \
    \ a  non-destructive manner.  Many data entry terminals\n        provide the means\
    \ by which protection may  be  turned  on\n        and  off  without modifying\
    \ the contents of the screen or\n        the terminal's  memory.   Thus,  the\
    \  protection  may  be\n        turned  off  and back on without retransmitting\
    \ the form.\n        The default setting of the option is that  protection  is\n\
    \        on, in other words\n                    IAC SB DET SUPPRESS PROTECTION\
    \ WONT IAC SE\n                    IAC SB DET SUPPRESS PROTECTION DONT IAC SE\n\
    \                                                          RFC 731\n        Negotiation\
    \ of this subcommand follows the same rules  as\n        negotiations of the Telnet\
    \ options.\n        IAC SB DET FIELD SEPARATOR IAC SE    subcommand code:  38\n\
    \        It is necessary when transmitting  only  the  unprotected\n        portion\
    \  of  the screen to provide a means for delimiting\n        the fields.   Existing\
    \  DET's  use  a  variety  of  ASCII\n        characters  such as Tab, Group Separator,\
    \ Unit Separator,\n        etc.  In order to maintain transparency of the NVDET\
    \ this\n        subcommand is used to separate the fields.  Clearly, this\n  \
    \      incurs  rather  high  overhead.   This  overhead  can  be\n        avoided\
    \ by using the Byte Macro Option (see Appendix 3).\n     M\b__\bi_\bs_\bc_\be_\b\
    l_\bl_\ba_\bn_\be_\bo_\bu_\bs_C\b__\bo_\bm_\bm_\ba_\bn_\bd_\bs\n        IAC SB\
    \ DET FN <code> IAC SE     subcommand code:  39\n        where:  <code> is one\
    \ byte.\n        Many data-entry terminals provide  a  set  of  \"function\"\n\
    \        keys  which  when pressed send a one-character command to\n        the\
    \ server.  This subcommand describes such  a  facility.\n        The  values \
    \ of  the <code> field are defined by the user\n        and server.  The option\
    \  merely  provides  the  means  to\n        transfer the information.\n     \
    \   IAC SB DET ERROR <cmd> <error code> IAC SE\n                             \
    \           subcommand code:  40\n        where:\n               <cmd> is a byte\
    \ containing the subcommand code  of\n        the subcommand in error.\n     \
    \           <error code> is a byte containing an error  code.\n        (For a\
    \ list of the defined error codes see Appendix 2.)\n        This  subcommand \
    \ is   provided  to  allow   DET   option\n        implementations  to  report\
    \  errors  they  detect  to the\n        corresponding Telnet process.  At this\
    \ point it is  worth\n        reiterating  that  the  philosophy of this option\
    \ is that\n        when an error is detected it should be reported; however,\n\
    \        the implementation should  attempt  its  best  effort  to\n        carry\
    \ out the intent of the subcommand or data in error.\n                       \
    \                                   RFC 731\n"
- title: 3.  Default and Minimal Implementation Specifications
  contents:
  - "3.  Default and Minimal Implementation Specifications\n     D\b__\be_\bf_\ba_\b\
    u_\bl_\bt\n        WON'T DET -- DON'T DET\n        Neither host wishes to use\
    \ the Data Entry Terminal option.\n     M\b__\bi_\bn_\bi_\bm_\ba_\bl_I\b__\bm_\b\
    p_\bl_\be_\bm_\be_\bn_\bt_\ba_\bt_\bi_\bo_\bn\n          DET EDIT FACILITIES\n\
    \          DET ERASE FACILITIES\n          DET TRANSMIT FACILITIES\n         \
    \ DET FORMAT FACILITIES\n          DET MOVE CURSOR <x><y>\n          DET HOME\n\
    \          DET ERASE SCREEN\n          DET TRANSMIT SCREEN\n          DET FORMAT\
    \ DATA\n          DET ERROR <cmd> <error code>\n        In  the  case  of  formatting\
    \  the  data,   the   minimal\n        implementation  should  be able to support\
    \ a low and high\n        level  of  intensity  and  protection  for  all   or\
    \   no\n        characters in a field.  These functions, however, are not\n  \
    \      required.\n        The minimal implementation also requires that the  Output\n\
    \        Line  Width  and  Output  Page  Size  Telnet  options  be\n        supported.\n\
    \                                                          RFC 731\n"
- title: 4.  Motivation
  contents:
  - "4.  Motivation\n     The Telnet protocol was originally  designed  to  provide\
    \  a\n     means  for  scroll-mode  terminals,  such  as  the  standard\n    \
    \ teletype, to communicate with processes through the network.\n     This was\
    \ suitable for the vast  majority  of  terminals  and\n     users  at  that  time.\
    \   However,  as use of the network has\n     increased into  other  areas,  especially\
    \  areas  where  the\n     network  is  considered  to provide a production environment\n\
    \     for other work, the desires and  requirements  of  the  user\n     community\
    \  have  changed.   Therefore,  it  is  necessary to\n     consider  supporting\
    \  facilities  that  were  not  initially\n     supported.   This  Telnet  option\
    \  attempts  to  do that for\n     applications that require data entry terminals.\n\
    \     This option in effect defines the Network Virtual Data Entry\n     Terminal.\
    \  Although the description of this option is  quite\n     long, this does not\
    \ imply that the Telnet protocol is a poor\n     vehicle  for this facility. \
    \ Data Entry Terminals are rather\n     complex and varied in their abilities.\
    \  This option attempts\n     to support both the minimal set of useful functions\
    \ that are\n     either common to all or can be easily simulated and the more\n\
    \     sophisticated functions supplied in some terminals.\n     Unlike most real\
    \ data entry  terminals  where  the  terminal\n     functions  are  encoded  into\
    \  one or more characters of the\n     native character set, this option performs\
    \ all such controls\n     within the Telnet  subnegotiation  mechanism.   This\
    \  allows\n     programs  that  are  intimately  familiar  with  the kind of\n\
    \     terminal they are communicating with to send  commands  that\n     may \
    \  not   be   supported  by  either  the  option  or  the\n     implementation.\
    \  In other words, it is possible  to  operate\n     in  a  \"raw\"  or  at  least\
    \ \"rare\" mode using as much of the\n     option as necessary.\n     Although\
    \ many data entry  terminals  support  a  variety  of\n     peripheral  devices\
    \ such as printers, cassettes, etc.  it is\n     beyond  the  scope  of  this\
    \  option   to   entertain   such\n     considerations.   A  separate  option\
    \  should  be defined to\n     handle this aspect of these devices.\n        \
    \                                                  RFC 731\n"
- title: 5.  Description
  contents:
  - '5.  Description

    '
- title: "G\b__\be_\bn_\be_\br_\ba_\bl_N\b__\bo_\bt_\be_\bs"
  contents:
  - "G\b__\be_\bn_\be_\br_\ba_\bl_N\b__\bo_\bt_\be_\bs\n     All implementations of\
    \ this option are required to support a\n     certain minimal set of  the  subcommands\
    \  for  this  option.\n     Section  3  contains  a  complete list of the subcommands\
    \ in\n     this minimal set.   In  keeping  with  the  Telnet  protocol\n    \
    \ philosophy that an implementation should not have to be able\n     to parse\
    \ commands it does not implement, every subcommand of\n     this  option  is \
    \ either in the minimal set or is covered by\n     one of the facility  subcommands.\
    \   An  implementation  must\n     \"negotiate\"  with  its  correspondent  for\
    \ permission to use\n     subcommands not in the minimal set before using  them.\
    \   For\n     details of this negotiation process see the section below on\n \
    \    facility subcommands.\n     Most data entry terminals are used in a  half\
    \  duplex  mode.\n     (Although  most  DET's  on  the market can be used either\
    \ as\n     data entry terminals or as standard  interactive  terminals,\n    \
    \ we  are  only concerned here with their use as DET's.)  When\n     this option\
    \ is used, it  is  suggested  that  the  following\n     Telnet   options   be\
    \   refused:   Echo,  Remote  Controlled\n     Transmission and Echoing, and Suppress\
    \  Go-Ahead.   However,\n     this  option  could  be used to support a simple\
    \ full duplex\n     CRT  based  application  using  the  basic  cursor   control\n\
    \     functions  provided  here.   For these cases, one or more of\n     the above\
    \ list of  options might be required.   (Support  of\n     sophisticated   interactive\
    \   calligraphic  applications  is\n     beyond the scope of this   option  and\
    \  should  be  done  by\n     another option or the Network Graphics Protocol.)\n\
    \     In RFC 728, it was noted that a  synch  sequence  can  cause\n     undesired\
    \  interactions between Telnet Control functions and\n     the data stream.  A\
    \  synch  sequence  causes  data  but  not\n     control  functions  to  be  flushed.\
    \   If a control function\n     which has an effect on the  data immediately following\
    \ it is\n     present in the data stream when a synch sequence occurs, the\n \
    \    control function will have its effect not  on  the  intended\n     data \
    \ but  on  the data immediately following the Data Mark.\n     The  following\
    \  DET  subcommands  are  susceptible  to  this\n     pitfall:\n             \
    \       CHAR INSERT\n                    DATA TRANSMIT\n                    FORMAT\
    \ DATA\n     The undesired interactions are best avoided by the  receiver\n  \
    \                                                        RFC 731\n     of  the\
    \  synch  sequence  deleting these subcommands\x7F and all\n     data associated\
    \ with them before continuing to  process  the\n     control  functions.   This\
    \ implies that the Data Mark should\n     not occur in the middle of the data\
    \  associated  with  these\n     subcommands.\n"
- title: "F\b__\ba_\bc_\bi_\bl_\bi_\bt_\by_S\b__\bu_\bb_\bc_\bo_\bm_\bm_\ba_\bn_\b\
    d_\bs"
  contents:
  - "F\b__\ba_\bc_\bi_\bl_\bi_\bt_\by_S\b__\bu_\bb_\bc_\bo_\bm_\bm_\ba_\bn_\bd_\b\
    s\n     These four subcommands are  used  by  the  User  and  Server\n     implementations\
    \  to negotiate the subcommands and attributes\n     of the terminal that may\
    \ be utilized.  This negotiation  can\n     be  viewed  as  the  terminal  (User\
    \  Host)  indicating what\n     facilities are provided and the Server Host (or\
    \  application\n     program) indicating what facilities are desired.\n     W\b\
    __\bh_\be_\bn_S\b__\be_\bn_\bt:\b_  A Server Telnet  implementation  using  the\
    \  DET\n     option must send a facility subcommand requesting the use of\n  \
    \   a  particular  subcommand  or  terminal attribute not in the\n     minimal\
    \  implementation  before  the  first  use   of   that\n     subcommand  or  attribute.\
    \   The  User Telnet implementation\n     should respond  as  quickly  as  possible\
    \  with  its  reply.\n     Neither  the  User  nor Server are required to negotiate\
    \ one\n     subcommand  at  a  time.   Also,  a  Telnet   implementation\n   \
    \  responding  to a facility subcommand is not required to give\n     permission\
    \ only for that subcommand.   It may send a  format\n     map  indicating  all\
    \  facilities  of  that  class  which  it\n     supports.   However,  a  Telnet\
    \  implementation   requesting\n     facilities  must send a facility subcommand\
    \ before its first\n     use  of  the  subcommand  regardless  of   whether  \
    \ earlier\n     negotiations  have  indicated the facility is provided.  The\n\
    \     facility cannot  be  used  until  a  corresponding  facility\n     subcommand\
    \   has   been   received.    There  are  no  other\n     constraints on when\
    \ the facility subcommands  may  be  sent.\n     In  particular,  it  is  not\
    \ necessary for an application to\n     know at the beginning of a session all\
    \  facilities  that  it\n     will use.\n     A\b__\bc_\bt_\bi_\bo_\bn_W\b__\b\
    h_\be_\bn_R\b__\be_\bc_\bi_\be_\bv_\be_\bd:\b_  There are two possible  actions\
    \  that\n     may   be  taken  when  a  facility  subcommand  is  received\n \
    \    depending on whether  the  receiver  is  a  requestor  or  a\n     provider\
    \ (User).\n     Requestor:  When a facility  subcommand  is  received  by  a\n\
    \     requestor  and it is in the state of Waiting for a Reply, it\n     should\
    \ go into the state of Not  Waiting.   It  should  then\n     take  the  facility\
    \  map   it  had sent and form the logical\n     intersection with  the  facility\
    \  map  received.   (For  the\n     Intensity  attribute,  one  should  take \
    \ the minimum of the\n     number received  and  the  number  requested.)   The\
    \  result\n     indicates  the facilities successfully negotiated.  Note: if\n\
    \                                                          RFC 731\n     the receiver\
    \ is not in the Waiting  for  Reply  state,  then\n     this is the provider case\
    \ described next.\n     Provider:  When  a  facility  subcommand   is  received,\
    \  it\n     should send a facility subcommand with a facility map of the\n   \
    \  facilities  it provides as soon as possible.  It should then\n     determine\
    \ what  new  facilities  it  is  providing  for  the\n     Requestor   by  forming\
    \  the  logical  intersection  of  the\n     facility map received and the one\
    \ sent.\n     Note:  Although in most cases  the  requestor  will  be  the\n \
    \    Server   Host  and  the  provider  will  be  the  User  Host\n     supporting\
    \ the terminal, this distinction may not always  be\n     true.\n"
- title: "T\b__\br_\ba_\bn_\bs_\bm_\bi_\bt_S\b__\bu_\bb_\bc_\bo_\bm_\bm_\ba_\bn_\b\
    d_\bs"
  contents:
  - "T\b__\br_\ba_\bn_\bs_\bm_\bi_\bt_S\b__\bu_\bb_\bc_\bo_\bm_\bm_\ba_\bn_\bd_\b\
    s\n     There are two kinds of transmit subcommands:  those used  to\n     request\
    \  that  data  be  sent  to  the requestor, and one to\n     preface data sent\
    \ to the requestor.  The  first  kind  allow\n     the requestor to control when,\
    \ from where and to some degree\n     how  much  data  is  transmitted  from \
    \ the terminal.  Their\n     explanation is straightforward and may be found \
    \ in  Section\n     2.\n     Data may be sent from  the  terminal  as  a  result\
    \  of  two\n     events:  the user of the terminal caused the transmission or\n\
    \     in  response  to  a  transmit subcommand.  Some programs may\n     wish\
    \ to know from  where  on  the  screen  the  transmission\n     began.   (This\
    \  is  reasonable,  since the terminal user may\n     move the cursor around \
    \ considerably  before  transmitting.)\n     Other  programs  may  not  need \
    \ such information.  The DATA\n     TRANSMIT subcommand is provided in  case \
    \ this  function  is\n     needed.  When used this subcommand prefaces data coming\
    \ from\n     the  terminal.   The parameters  <x> and <y> give the screen\n  \
    \   coordinates of the beginning of the transmission.  <x>  must\n     be  less\
    \  than or equal to M-1 and  <y> must be less than or\n     equal to N-1.  It\
    \ is assumed that all data between this DATA\n     TRANSMIT and the  next one\
    \ starts at the  coordinates  given\n     by  the  first  subcommand   and continues\
    \ filling each line\n     thereafter according to the constraints of  the  screen\
    \  and\n     the  format  effectors  in the data.  Thus an intelligent or\n  \
    \   sloppy user-host DET implementation (depending on your point\n     of view)\
    \ need only include a DATA TRANSMIT  subcommand  when\n     the  new  starting\
    \  point  is different from the last ending\n     point.\n"
- title: 6.  Sample Interaction
  contents:
  - "6.  Sample Interaction\n                                                    \
    \      RFC 731\n"
- title: The nomenclature of RFC 726 will be used to describe this  example.   To
  contents:
  - 'The nomenclature of RFC 726 will be used to describe this  example.   To

    '
- title: 'quote that RFC:'
  contents:
  - "quote that RFC:\n     \"S:\"  is sent from serving host to using host.\n    \
    \ \"U:\"  is sent from using host to serving host.\n     \"T:\"  is entered by\
    \ the terminal user.\n     \"P:\"  is printed on the terminal.\n     Text  surrounded\
    \  by  square  brackets([])  is  commentary.    Text\n     surrounded  by angle\
    \ brackets (<>) is to be taken as a single unit.\n     E.g,  carriage  return\
    \  is  <cr>,  and  the  decimal  value  27  is\n     represented <27>.\n     We\
    \ assume that the user  has  established  the  Telnet  connection,\n     logged\
    \  on, and an application program has just been started either\n     by the user\
    \ directly or through a canned start up  procedure.   The\n     presentation on\
    \ the page is meant to merely group entities together\n     and  does not imply\
    \ the position of message boundaries.  One should\n     assume that any part of\
    \ the dialogue may be sent  as  one  or  many\n     messages.   The  first  action\
    \  of  the  program  or  Telnet  is to\n     negotiate the DET option:\n"
- title: 'S: <IAC><DO><DET>'
  contents:
  - 'S: <IAC><DO><DET>

    '
- title: 'U:  <IAC><WILL><DET>'
  contents:
  - 'U:  <IAC><WILL><DET>

    '
- title: S:<IAC><DO><OUTPUT PAGE SIZE>           [First negotiate the screen
  contents:
  - "S:<IAC><DO><OUTPUT PAGE SIZE>           [First negotiate the screen\n       \
    \                                 size.  In this case we are\n"
- title: U:<IAC><WILL><NAOP>                     asking the user the size of the
  contents:
  - "U:<IAC><WILL><NAOP>                     asking the user the size of the\n   \
    \                                     terminal.  This could have been\n"
- title: U:<IAC><SB><NAOP><DR><25><IAC><SE>      done before the DET option was
  contents:
  - "U:<IAC><SB><NAOP><DR><25><IAC><SE>      done before the DET option was\n    \
    \                                    negotiated.]\n"
- title: S:<IAC><SB><NAOP><DS><0><IAC><SE>
  contents:
  - 'S:<IAC><SB><NAOP><DS><0><IAC><SE>

    '
- title: S:<IAC><DO><OUTPUT LINE WIDTH>
  contents:
  - 'S:<IAC><DO><OUTPUT LINE WIDTH>

    '
- title: U:<IAC><SB><NAOL><DR><80><IAC><SE>      [Defines the screen to be 25
  contents:
  - "U:<IAC><SB><NAOL><DR><80><IAC><SE>      [Defines the screen to be 25\n      \
    \                                  lines by 80 characters.\n"
- title: S:<IAC><SB><NAOL><DS><0><IAC><SE>       The server may use this
  contents:
  - "S:<IAC><SB><NAOL><DS><0><IAC><SE>       The server may use this\n           \
    \                             information when formatting\n                  \
    \                      the screen.]\n"
- title: S:<IAC><SB><DET><FORMAT FACILITIES>     [Now set the terminal attributes.]
  contents:
  - "S:<IAC><SB><DET><FORMAT FACILITIES>     [Now set the terminal attributes.]\n\
    \  <Repeat><Protection, 3 Levels\n  Intensity><IAC><SE>\n"
- title: U:<IAC><SB><DET><FORMAT FACILITIES>
  contents:
  - "U:<IAC><SB><DET><FORMAT FACILITIES>\n  <Repeat, Blinking><Protection, 3\n  Levels\
    \ Intensity><IAC><SE>\n"
- title: S:<IAC><SB><DET><ERASE SCREEN><IAC><SE>     [Erase the screen and
  contents:
  - "S:<IAC><SB><DET><ERASE SCREEN><IAC><SE>     [Erase the screen and\n         \
    \                                                 RFC 731\n                  \
    \                          start sending the form.]\n  <IAC><SB><DET><FORMAT DATA>\n\
    \  <Protection=1, Intensity=1><0>\n  <5><IAC><SE>Name:\n  <IAC><SB><DET><MOVE\
    \ CURSOR><0><1>\n    <IAC><SE>\n  <IAC><SB><DET><FORMAT DATA>\n    Protection=1,\
    \ Intensity=1><0>\n    <8><IAC><SE>\n  Address:\n  <IAC><SB><MOVE CURSOR><0><4><IAC>\n\
    \    <SE>\n  <IAC><SB><DET><FORMAT DATA>\n    Protection=1, Intensity=1><0>\n\
    \    <17><IAC><SE>\n  Telephone number:\n  <IAC><SB><DET><MOVE CURSOR><32><4>\n\
    \  <IAC><SE>\n  <IAC><SB><DET><FORMAT DATA>\n    Protection=1, Intensity=1><0>\n\
    \    <24><IAC><SE>\n  Social Security Number:\n  <IAC><SB><DET><FORMAT DATA> \
    \          [Establish a field that doesn't\n    <Protection=1, Intensity=7>  \
    \       display what is typed into it.]\n    <0><11><IAC><SE>\n  <IAC><SB><DET><MOVE\
    \ CURSOR><32>\n    <5><IAC><SE>\n  <IAC><SB><DET><FORMAT FACILITIES>     [Get\
    \ permission to use Blinking\n    <Blinking><0><IAC><SE>              Attribute.]\n"
- title: U:<IAC><SB><DET><FORMAT FACILITIES>
  contents:
  - "U:<IAC><SB><DET><FORMAT FACILITIES>\n    <Repeat, Blinking><Protection,\n   \
    \ 3 Levels Intensity><IAC><SE>\n"
- title: S:<IAC><SB><DET><FORMAT DATA>
  contents:
  - "S:<IAC><SB><DET><FORMAT DATA>\n  <Blinking=1, Protection=1,\n  Intensity=1><0><29><IAC><SE>\n\
    \  Your SSN will not be printed.\n  <IAC><SB><DET><HOME><IAC><SE>\n          \
    \                                                RFC 731\n  <IAC><GA>\n"
- title: 'The previous exchange has placed a form on the screen that looks like:'
  contents:
  - 'The previous exchange has placed a form on the screen that looks like:

    '
- title: 'Name:'
  contents:
  - 'Name:

    '
- title: 'Address:'
  contents:
  - 'Address:

    '
- title: 'Telephone Number:                       Social Security Number:'
  contents:
  - "Telephone Number:                       Social Security Number:\n           \
    \                        \"Your SSN will not be printed.\"\n"
- title: where the quoted string is blinking.
  contents:
  - 'where the quoted string is blinking.

    '
- title: The terminal user is  now  free  to  fill  in  the  form  provided.   He
  contents:
  - 'The terminal user is  now  free  to  fill  in  the  form  provided.   He

    '
- title: positions  the  cursor at the beginning of the first field (this usually
  contents:
  - 'positions  the  cursor at the beginning of the first field (this usually

    '
- title: is done by hitting the tab key) and begins typing.  We do not show  this
  contents:
  - 'is done by hitting the tab key) and begins typing.  We do not show  this

    '
- title: interaction  since  it  does  not generate any interaction with the User
  contents:
  - 'interaction  since  it  does  not generate any interaction with the User

    '
- title: Telnet program or the network.  After the terminal  user  has  completed
  contents:
  - 'Telnet program or the network.  After the terminal  user  has  completed

    '
- title: filling in the form, he strikes the transmit key to send the unprotected
  contents:
  - 'filling in the form, he strikes the transmit key to send the unprotected

    '
- title: part  of the form, but first the User Telnet program negotiates the Byte
  contents:
  - 'part  of the form, but first the User Telnet program negotiates the Byte

    '
- title: 'Macro Option to condense the Field Separator subcommand:'
  contents:
  - 'Macro Option to condense the Field Separator subcommand:

    '
- title: U:<IAC><DO><BM>                         [Negotiate Byte Macro Option.]
  contents:
  - 'U:<IAC><DO><BM>                         [Negotiate Byte Macro Option.]

    '
- title: S:<IAC><WILL><BM>                       [Define decimal 166 to be the
  contents:
  - "S:<IAC><WILL><BM>                       [Define decimal 166 to be the\n     \
    \                                   Field Separator subcommand\n"
- title: U:<IAC><SB><BM><DEFINE>                 (see Appendix 3)]
  contents:
  - "U:<IAC><SB><BM><DEFINE>                 (see Appendix 3)]\n  <166><6><IAC SB\
    \ DET FIELD\n  SEPARATOR IAC SE><IAC><SE>\n"
- title: S:<IAC><SB><BM><ACCEPT><166>            [The server accepts the macro.]
  contents:
  - "S:<IAC><SB><BM><ACCEPT><166>            [The server accepts the macro.]\n  <IAC><SE>\n"
- title: U:<IAC><SB><DET><DATA TRANSMIT><0><6>
  contents:
  - "U:<IAC><SB><DET><DATA TRANSMIT><0><6>\n  <IAC><SE>\n  John Doe <166> 1515 Elm\
    \ St., Urbana, Il 61801\n  <166> 217-333-9999 <166> 123-45-6789 <166>\n"
- title: S:<IAC><SB><DET><ERASE SCREEN><IAC><SE>
  contents:
  - "S:<IAC><SB><DET><ERASE SCREEN><IAC><SE>\n  Thank you.\n"
- title: And so on.
  contents:
  - "And so on.\n                                                          RFC 731\n"
- title: Appendix 1 - Subcommands, opcodes and syntax
  contents:
  - "Appendix 1 - Subcommands, opcodes and syntax\n               1    EDIT FACILITIES\
    \     <Facilty map>\n               2    ERASE FACILITIES    <Facility map>\n\
    \               3    TRANSMIT FACILITIES <Facility map>\n               4    FORMAT\
    \ FACILITIES    <Facility map 1> <Facility map 2>\n               5    MOVE CURSOR\
    \          <x> <y>\n               6    SKIP TO LINE         <y>\n           \
    \    7    SKIP TO CHAR         <x>\n               8    UP\n               9 \
    \   DOWN\n               10   LEFT\n               11   RIGHT\n              \
    \ 12   HOME\n               13   LINE INSERT\n               14   LINE DELETE\n\
    \               15   CHAR INSERT\n               16   CHAR DELETE\n          \
    \     17   READ CURSOR\n               18   CURSOR POSITION      <x><y>\n    \
    \           19   REVERSE TAB\n               20   TRANSMIT SCREEN\n          \
    \     21   TRANSMIT UNPROTECTED\n               22   TRANSMIT LINE\n         \
    \      23   TRANSMIT FIELD\n               24   TRANSMIT REST OF SCREEN\n    \
    \           25   TRANSMIT REST OF LINE\n               26   TRANSMIT REST OF FIELD\n\
    \               27   DATA TRANSMIT <x><y>\n               28   ERASE SCREEN\n\
    \               29   ERASE LINE\n               30   ERASE FIELD\n           \
    \    31   ERASE REST OF SCREEN\n               32   ERASE REST OF LINE\n     \
    \          33   ERASE REST OF FIELD\n               34   ERASE UNPROTECTED\n \
    \              35   FORMAT DATA <format map>\n               36   REPEAT     <count><char>\n\
    \               37   SUPPRESS PROTECTION <negotiation>\n               38   FIELD\
    \ SEPARATOR\n               39   FN <code>\n               40   ERROR  <cmd><error\
    \ code>\n                                                          RFC 731\n"
- title: Appendix 2 - Error Codes
  contents:
  - "Appendix 2 - Error Codes\n               1    Facility not previously negotiated.\n\
    \               2    Illegal subcommand code.\n               3    Cursor Address\
    \ Out of Bounds.\n               4    Undefined FN value.\n               4  \
    \  Can't negotiate acceptable line width.\n               5    Can't negotiate\
    \ acceptable page length.\n               6    Illegal parameter in subcommand.\n\
    \               7    Syntax error in parsing subcommand.\n               8   \
    \ Too many parameters in subcommand.\n               9    Too few parameters in\
    \ subcommand.\n               10   Undefined parameter value\n               11\
    \   Unsupported combination of Format Attributes\n                           \
    \                               RFC 731\n               Appendix 3 - Use of the\
    \ Byte Macro Option\n     One of the major drawbacks of the DET option is  that\
    \  because  the\n     functions  are  encoded  as  Telnet option subnegotiations\
    \ a fairly\n     high overhead is incurred.  A function like Character Insert\
    \  which\n     is encoded as a single byte in most terminals requires six bytes\
    \ in\n     the DET option.  Originally the only other solution that would have\n\
    \     accomplished  the  same  transparency  that  the use of subcommands\n  \
    \   provides would  have  been  to  define  additional  Telnet  control\n    \
    \ functions.   However,  since  this would entail modification of the\n     Telnet\
    \ protocol itself, it was  felt  that  this  was  not  a  wise\n     solution.\
    \    Since  then the Telnet Byte Macro Option (RFC 729) has\n     been defined.\
    \  This option allows the user and  server  Telnets  to\n     map  an arbitrary\
    \ character string into a single byte which is then\n     transferred over the\
    \ net.  Thus the Byte Macro Option provides  the\n     means  for  implementations\
    \  to avoid the overhead for heavily used\n     subcommands.  The rest of this\
    \ appendix suggests how the Byte Macro\n     Option should be applied to the DET\
    \ option.\n     In keeping with the specification of the Byte Macro Option,  \
    \ macro\n     bytes  will  be  chosen  from  the  range 128 to 239.   For the\
    \ DET\n     option, it is suggested that macro  bytes be chosen by  adding  the\n\
    \     subcommand  code to 128.  In addition, an unofficial DET subcommand\n  \
    \   might be defined indicating that each side was willing  to  support\n    \
    \ macro bytes for all subcommands (but not necessarily support all of\n     the\
    \  subcommands  themselves)  according  to  this algorithm.  This\n     subcommand\
    \ would be:\n     IAC SB DET DET-MACRO <negotiation> IAC SE\n                \
    \                        subcommand code:  254\n     where <negotiation> may \
    \ have  the  values  of  the  Telnet  option\n     negotiation:\n            \
    \        251       WILL\n                    252       WONT\n                \
    \    253       DO\n                    254       DONT\n     This subcommand is\
    \ sent by a Telnet implementation to  indicate its\n     willingness to adopt\
    \ byte macros for all  of  the  DET  subcommands\n     according to the following\
    \ algorithm:\n                                                          RFC 731\n\
    \        The macro byte for subcommand i will be i+128 and will represent\n  \
    \      the following string for parameterless subcommands:\n        IAC SB DET\
    \ <subcommand code> IAC SE\n        and the following string for subcommands \
    \ with  parameters:\n        IAC SB DET <subcommand code>\n        The default\
    \ setting for this subcommand is that the  macros  are\n        not in effect,\
    \ in other words,\n             IAC SB DET DET-MACRO WONT IAC SE\n           \
    \  IAC SB DET DET-MACRO DONT IAC SE\n        Negotiation  of  this  subcommand\
    \  follows  the  same  rules  as\n        negotiations of the Telnet options.\n\
    \                                                          RFC 731\n         \
    \                      References\n     1.  ADM-1 Interactive Display Terminal\
    \ Operator's Handbook\n           Lear-Siegler, Inc. 7410-31.\n     2.  ADM-Interactive\
    \ Display Terminal Operator's Handbook\n            Lear-Siegler, Inc. EID, 1974.\n\
    \     3.  Burroughs TD 700/800 Reference Manual, Burroughs Corp., 1973\n     4.\
    \  Burroughs TD 820 Reference Manual, Burroughs Corp. 1975.\n     5.  CC-40  Communications\
    \ Station:  General Information Manual.\n           Computer Communication, Inc.\
    \  Pub. No. MI-1100. 1974.\n     6.  Crocker, David.  \"Telnet Byte Macro Option,\"\
    \ RFC 729, 1977.\n     7.  Data Entry Virtual Terminal Protocol for Euronet, DRAFT,\
    \ 1977.\n     8.  Day, John.  \"A Minor Pitfall in the Telnet Protocol,\"\n  \
    \         RFC 728, 1977.\n     9.  Hazeltine 2000 Desk Top Display Operating Instructions.\n\
    \           Hazeltine IB-1866A, 1870.\n     10.  How to Use the Consul 980:  A\
    \ Terminal Operator's Guide\n           and Interface Manual.  Applied Digital\
    \ Data Systems, Inc.\n            98-3000.\n     11.  How to Use the Consul 520:\
    \  A Terminal Operator's Guide\n           and Interface Manual.  Applied Digital\
    \ Data Systems, Inc.\n           52-3000.\n     12.  Honeywell 7700 Series Visual\
    \ Information Projection (VIP)\n            Systems:  Preliminary Edition. 1973.\n\
    \     13.  An Introduction to the IBM 3270 Information Display System.\n     \
    \       IBM GA27-2739-4. 1973.\n     14.  Naffah, N.  \"Protocole Appareil Virtuel\
    \ type Ecran\"\n            Reseau Cyclades.  TER 536. 1976.\n               \
    \                                           RFC 731\n     15.  Postel, Jon and\
    \ Crocker, David.  \"Remote Controlled\n            Transmission and Echoing Telnet\
    \ Option\", RFC 726\n            NIC 39237, Mar. 1977.\n     16.  Schicker, Peter.\
    \  \"Virtual Terminal Protocol (Proposal 2).\n            INWG Protocol Note #32.,\
    \ 1976.\n     17.  UNISCOPE Display Terminal :  Programmer Reference .  Sperry-\n\
    \            Univac UP-7807 Rev. 2, 1975.\n     18.  Universal Terminal System\
    \ 400:  System Description.  Sperry-\n            Univac UP-8357, 1976.\n    \
    \ 19.  Walden, David C. \"Telnet Output Line Width Option.\"\n            NIC\
    \ # 20196, 1973, also in ARPANET Protocol Handbook, 1976.\n     20.  Walden, David\
    \ C.  \"Telnet Output Page Size\"  NIC # 20197,\n            1973, also in ARPANET\
    \ Protocol Handbook, 1976.\n"
