- title: __initial_text__
  contents:
  - '                Mutual Authentication Protocol for HTTP

    '
- title: Abstract
  contents:
  - "Abstract\n   This document specifies an authentication scheme for the Hypertext\n\
    \   Transfer Protocol (HTTP) that is referred to as either the Mutual\n   authentication\
    \ scheme or the Mutual authentication protocol.  This\n   scheme provides true\
    \ mutual authentication between an HTTP client and\n   an HTTP server using password-based\
    \ authentication.  Unlike the Basic\n   and Digest authentication schemes, the\
    \ Mutual authentication scheme\n   specified in this document assures the user\
    \ that the server truly\n   knows the user's encrypted password.\n"
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This document is not an Internet Standards Track specification;\
    \ it is\n   published for examination, experimental implementation, and\n   evaluation.\n\
    \   This document defines an Experimental Protocol for the Internet\n   community.\
    \  This document is a product of the Internet Engineering\n   Task Force (IETF).\
    \  It represents the consensus of the IETF\n   community.  It has received public\
    \ review and has been approved for\n   publication by the Internet Engineering\
    \ Steering Group (IESG).  Not\n   all documents approved by the IESG are a candidate\
    \ for any level of\n   Internet Standard; see Section 2 of RFC 7841.\n   Information\
    \ about the current status of this document, any errata,\n   and how to provide\
    \ feedback on it may be obtained at\n   http://www.rfc-editor.org/info/rfc8120.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (c) 2017 IETF Trust and the persons identified\
    \ as the\n   document authors.  All rights reserved.\n   This document is subject\
    \ to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n\
    \   (http://trustee.ietf.org/license-info) in effect on the date of\n   publication\
    \ of this document.  Please review these documents\n   carefully, as they describe\
    \ your rights and restrictions with respect\n   to this document.  Code Components\
    \ extracted from this document must\n   include Simplified BSD License text as\
    \ described in Section 4.e of\n   the Trust Legal Provisions and are provided\
    \ without warranty as\n   described in the Simplified BSD License.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1. Introduction ....................................................3\n\
    \      1.1. Terminology ................................................5\n  \
    \    1.2. Document Structure and Related Documents ...................6\n   2.\
    \ Protocol Overview ...............................................6\n      2.1.\
    \ Messages ...................................................7\n      2.2. Typical\
    \ Flows of the Protocol ..............................8\n      2.3. Alternative\
    \ Flows .........................................10\n   3. Message Syntax .................................................12\n\
    \      3.1. Non-ASCII Extended Header Parameters ......................12\n  \
    \    3.2. Values ....................................................13\n    \
    \       3.2.1. Tokens .............................................13\n      \
    \     3.2.2. Strings ............................................14\n        \
    \   3.2.3. Numbers ............................................14\n   4. Messages\
    \ .......................................................15\n      4.1. 401-INIT\
    \ and 401-STALE ....................................16\n      4.2. req-KEX-C1\
    \ ................................................19\n      4.3. 401-KEX-S1 ................................................19\n\
    \      4.4. req-VFY-C .................................................20\n  \
    \    4.5. 200-VFY-S .................................................21\n   5.\
    \ Authentication Realms ..........................................21\n      5.1.\
    \ Resolving Ambiguities .....................................23\n   6. Session\
    \ Management .............................................24\n   7. Host Validation\
    \ Methods ........................................26\n      7.1. Applicability\
    \ Notes .......................................27\n      7.2. Notes on \"tls-unique\"\
    \ .....................................28\n   8. Authentication Extensions ......................................28\n\
    \   9. String Preparation .............................................29\n  \
    \ 10. Decision Procedure for Clients ................................29\n    \
    \  10.1. General Principles and Requirements ......................29\n      10.2.\
    \ State Machine for the Client (Informative) ...............31\n   11. Decision\
    \ Procedure for Servers ................................36\n   12. Authentication\
    \ Algorithms .....................................39\n      12.1. Support Functions\
    \ and Notations ..........................39\n      12.2. Default Functions for\
    \ Algorithms .........................41\n   13. Application Channel Binding ...................................42\n\
    \   14. Application for Proxy Authentication ..........................42\n  \
    \ 15. Methods to Extend This Protocol ...............................43\n   16.\
    \ IANA Considerations ...........................................44\n      16.1.\
    \ Addition to HTTP Authentication Schemes Registry .........44\n      16.2. Registry\
    \ for Authentication Algorithms ...................44\n      16.3. Registry for\
    \ Validation Methods ..........................45\n   17. Security Considerations\
    \ .......................................46\n      17.1. Security Properties ......................................46\n\
    \      17.2. Secrecy of Credentials ...................................46\n  \
    \    17.3. Denial-of-Service Attacks on Servers .....................47\n    \
    \       17.3.1. Online Active Password Attacks ....................47\n      17.4.\
    \ Communicating the Status of Mutual Authentication\n            with Users ...............................................48\n\
    \      17.5. Implementation Considerations ............................48\n  \
    \    17.6. Usage Considerations .....................................49\n   18.\
    \ References ....................................................49\n      18.1.\
    \ Normative References .....................................49\n      18.2. Informative\
    \ References ...................................51\n   Authors' Addresses ................................................53\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   This document specifies an authentication scheme for the\
    \ Hypertext\n   Transfer Protocol (HTTP) that is referred to as either the Mutual\n\
    \   authentication scheme or the Mutual authentication protocol.  This\n   scheme\
    \ provides true mutual authentication between an HTTP client and\n   an HTTP server\
    \ using just a simple password as a credential.\n   Password-stealing attacks\
    \ are one of the most critical threats for\n   Web systems.  Plain-text password\
    \ authentication techniques (Basic\n   authentication and Web-form-based authentication)\
    \ have been widely\n   used for a long time.  When these techniques are used with\
    \ plain HTTP\n   protocols, it is trivially easy for attackers to sniff the password\n\
    \   credentials on the wire.\n   The Digest authentication scheme [RFC7616] uses\
    \ SHA-256 and\n   SHA-512/256 (formerly SHA-1 and MD5) hash algorithms to hide\
    \ the raw\n   user password from network sniffers.  However, if the number of\n\
    \   possible candidate users' passwords is not enough, newer and more\n   powerful\
    \ computers can compute possible hash values for billions of\n   password candidates\
    \ and compare these with the sniffed values to find\n   out the correct password.\
    \  This kind of attack is called an offline\n   password dictionary attack; the\
    \ search capacity of these newer\n   computers reduces the effectiveness of users'\
    \ memorable passwords,\n   thereby threatening the effectiveness of such hash-based\
    \ password\n   protections.\n   Transport Layer Security (TLS) [RFC5246] provides\
    \ strong\n   cryptographic protection against the network-based sniffing of\n\
    \   passwords and other communication contents.  If TLS is correctly used\n  \
    \ by both server operators and client users, passwords and other\n   credentials\
    \ will not be available to any outside attackers.  However,\n   there is a pitfall\
    \ related to TLS deployment on Web systems: if the\n   users are fraudulently\
    \ routed to a \"wrong Website\" via some kind of\n   social engineering attack\
    \ (e.g., phishing) and tricked into\n   performing authentication on that site,\
    \ the credentials will be sent\n   to the attacker's server and trivially leaked.\
    \  Attacks such as\n   phishing have become a serious threat.  In current Web\
    \ system\n   deployments, TLS certificates will be issued to almost any users\
    \ of\n   the Internet (including malicious attackers).  Although those\n   certificates\
    \ include several levels of the \"validation results\" (such\n   as corporate\
    \ names) of the issued entities, the task of \"checking\"\n   those validation\
    \ results is left to the users of Web browsers, still\n   leaving open the possibility\
    \ of such social engineering attacks.\n   Another way to avoid such threats is\
    \ to avoid password-based\n   authentication and use some kinds of pre-deployed\
    \ strong secret keys\n   (on either the client side or the server side) for authentications.\n\
    \   Several federated authentication frameworks, as well as HTTP\n   Origin-Bound\
    \ Authentication (HOBA) [RFC7486], are proposed and\n   deployed on real Web systems\
    \ to satisfy those needs.  However, a type\n   of authentication based on \"human-memorable\
    \ secrets\" (i.e.,\n   passwords) is still required in several scenarios, such\
    \ as\n   initialization, key deployment to new clients, or recovery of secret\n\
    \   accounts with lost cryptographic keys.\n   The Mutual authentication protocol,\
    \ as proposed in this document, is\n   a strong cryptographic solution for password\
    \ authentications.  It\n   mainly provides the following two key features:\n \
    \  o  No password information at all is exchanged in the communications.\n   \
    \   When the server and the user fail to authenticate with each other,\n     \
    \ the protocol will not reveal even the tiniest bit of information\n      about\
    \ the user's password.  This prevents any kind of offline\n      password dictionary\
    \ attacks, even with the existence of phishing\n      attacks.\n   o  To successfully\
    \ authenticate, the server, as well as client users,\n      must own the valid\
    \ registered credentials (authentication secret).\n      This means that a phishing\
    \ attacker cannot trick users into\n      thinking that it is an \"authentic\"\
    \ server.  (It should be\n      pointed out that this is not true for Basic and\
    \ Digest\n      authentication; for example, servers using Basic authentication\n\
    \      can answer \"YES\" to any clients without actually checking\n      authentication\
    \ at all.)  Client users can ascertain whether or not\n      the communicating\
    \ peer is truly \"the server\" that registered their\n      account beforehand.\
    \  In other words, it provides \"true\" mutual\n      authentication between servers\
    \ and clients.\n   Given the information above, the proposed protocol can serve\
    \ as a\n   strong alternative to the Basic, Digest, and Web-form-based\n   authentication\
    \ schemes and also as a strong companion to the\n   non-password-based authentication\
    \ frameworks.\n   The proposed protocol will serve in the same way as does existing\n\
    \   Basic or Digest authentication: it meets the requirements for new\n   authentication\
    \ schemes for HTTP, as described in Section 5.1.2 of\n   [RFC7235].  Additionally,\
    \ to communicate authentication results more\n   reliably between the server and\
    \ the client user, it suggests that Web\n   browsers have some \"secure\" way\
    \ of displaying the authentication\n   results.  Having such a user interface\
    \ in future browsers will\n   greatly reduce the risk of impersonation by various\
    \ kinds of social\n   engineering attacks, in a manner similar to that of the\n\
    \   \"green padlock\" for Extended Validation TLS certificates.\n   Technically,\
    \ the authentication scheme proposed in this document is a\n   general framework\
    \ for using password-based authenticated key exchange\n   (PAKE) and similar stronger\
    \ cryptographic primitives with HTTP.  The\n   two key features shown above correspond\
    \ to the nature of PAKE.\n"
- title: 1.1.  Terminology
  contents:
  - "1.1.  Terminology\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"\
    SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"NOT\
    \ RECOMMENDED\", \"MAY\", and\n   \"OPTIONAL\" in this document are to be interpreted\
    \ as described in\n   [RFC2119].\n   This document distinguishes the terms \"\
    client\" and \"user\" in the\n   following way: a \"client\" is an entity that\
    \ understands and\n   implements HTTP and the specified authentication protocol\
    \ -- usually\n   computer software; a \"user\" is typically a human being who\
    \ wants to\n   access data resources using a \"client\".\n   The term \"natural\
    \ numbers\" refers to the non-negative integers\n   (including zero) throughout\
    \ this document.\n   This document treats both the input (domain) and the output\n\
    \   (codomain) of hash functions as octet strings.  When a natural number\n  \
    \ output for a hash function is required, it will be written as\n   INT(H(s)).\n"
- title: 1.2.  Document Structure and Related Documents
  contents:
  - "1.2.  Document Structure and Related Documents\n   The entire document is organized\
    \ as follows:\n   o  Section 2 presents an overview of the protocol design.\n\
    \   o  Sections 3 through 11 define a general framework of the Mutual\n      authentication\
    \ protocol.  This framework is independent of\n      specific cryptographic primitives.\n\
    \   o  Section 12 describes properties needed for cryptographic\n      algorithms\
    \ used with this protocol framework and defines a few\n      functions that will\
    \ be shared among such cryptographic algorithms.\n   o  Sections 13 through 15\
    \ contain general normative and informative\n      information about the protocol.\n\
    \   o  Sections 16 and 17 describe IANA considerations and security\n      considerations,\
    \ respectively.\n   In addition, we will refer to the following two companion\
    \ documents,\n   as they are related to this specification:\n   o  [RFC8121] defines\
    \ cryptographic primitives that can be used with\n      this protocol framework.\n\
    \   o  [RFC8053] defines small but useful extensions to the current HTTP\n   \
    \   authentication framework so that it can support application-level\n      semantics\
    \ of existing Web systems.\n"
- title: 2.  Protocol Overview
  contents:
  - "2.  Protocol Overview\n   The protocol, as a whole, is designed as a natural\
    \ extension to HTTP\n   [RFC7230] and uses the framework defined in [RFC7235].\
    \  Internally,\n   the server and the client will first perform a cryptographic\
    \ key\n   exchange, using the secret password as a \"tweak\" to the exchange.\n\
    \   The key exchange will only succeed when the secrets used by both\n   peers\
    \ are correctly related (i.e., generated from the same password).\n   Then, both\
    \ peers will verify the authentication results by confirming\n   the sharing of\
    \ the exchanged key.  This section provides a brief\n   outline of the protocol\
    \ and the exchanged messages.\n"
- title: 2.1.  Messages
  contents:
  - "2.1.  Messages\n   The authentication protocol uses six kinds of messages to\
    \ perform\n   mutual authentication.  These messages have specific names within\n\
    \   this specification.\n   o  Authentication request messages: used by the servers\
    \ to request\n      that clients start mutual authentication.\n      *  401-INIT\
    \ message: a general message to start the authentication\n         protocol. \
    \ It is also used as a message indicating an\n         authentication failure.\n\
    \      *  401-STALE message: a message indicating that the client has to\n   \
    \      start a new key exchange.\n   o  Authenticated key exchange messages: used\
    \ by both peers to perform\n      authentication and the sharing of a cryptographic\
    \ secret.\n      *  req-KEX-C1 message: a message sent from the client.\n    \
    \  *  401-KEX-S1 message: an intermediate response to a req-KEX-C1\n         message\
    \ from the server.\n   o  Authentication verification messages: used by both peers\
    \ to verify\n      the authentication results.\n      *  req-VFY-C message: a\
    \ message used by the client to request that\n         the server authenticate\
    \ and authorize the client.\n      *  200-VFY-S message: a response used by the\
    \ server to indicate\n         that client authentication succeeded.  It also\
    \ contains\n         information necessary for the client to check the authenticity\n\
    \         of the server.\n   In addition to the above six kinds of messages, a\
    \ request or response\n   without any HTTP headers related to this specification\
    \ will be\n   hereafter called a \"normal request\" or \"normal response\",\n\
    \   respectively.\n"
- title: 2.2.  Typical Flows of the Protocol
  contents:
  - "2.2.  Typical Flows of the Protocol\n   In typical cases, client access to a\
    \ resource protected by the\n   Mutual authentication scheme will use the following\
    \ protocol\n   sequence:\n          Client                                 Server\n\
    \            |                                      |\n            |  ---- (1)\
    \ normal request --------->  |\n        GET / HTTP/1.1                       \
    \      |\n            |                                      |\n            |\
    \  <---------------- (2) 401-INIT ---  |\n            |            401 Unauthorized\
    \          |\n            |            WWW-Authenticate: Mutual realm=\"a realm\"\
    \n            |                                      |\n   [user,   |        \
    \                              |\n    pass]-->|                              \
    \        |\n            |  ---- (3) req-KEX-C1 ------------->  |\n        GET\
    \ / HTTP/1.1                             |\n        Authorization: Mutual user=\"\
    john\",         |--> [user DB]\n                       kc1=\"...\", ...      \
    \        |<-- [user info]\n            |                                     \
    \ |\n            |  <-------------- (4) 401-KEX-S1 ---  |\n            |     \
    \      401 Unauthorized           |\n            |           WWW-Authenticate:\
    \ Mutual sid=..., ks1=\"...\", ...\n            |                            \
    \          |\n        [compute] (5) compute session secret   [compute]\n     \
    \       |                                      |\n            |              \
    \                        |\n            |  ---- (6) req-VFY-C -------------->\
    \  |\n        GET / HTTP/1.1                             |--> [verify (6)]\n \
    \       Authorization: Mutual sid=...,             |<-- OK\n                 \
    \      vkc=\"...\", ...              |\n            |                        \
    \              |\n            |  <--------------- (7) 200-VFY-S ---  |\n   [verify\
    \  |           200 OK                     |\n     (7)]<--|           Authentication-Info:\
    \ Mutual vks=\"...\"\n            |                                      |\n \
    \           v                                      v\n     Figure 1: Typical Communication\
    \ Flow for First Access to Resource\n   o  As is typical in general HTTP protocol\
    \ designs, a client will at\n      first request a resource without any authentication\
    \ attempt (1).\n      If the requested resource is protected by the Mutual\n \
    \     authentication protocol, the server will respond with a message\n      requesting\
    \ authentication (401-INIT) (2).\n   o  The client processes the body of the message\
    \ and waits for the\n      user to input the username and password.  If the username\
    \ and\n      password are available, the client will send a message with the\n\
    \      authenticated key exchange (req-KEX-C1) to start the\n      authentication\
    \ (3).\n   o  If the server has received a req-KEX-C1 message, the server\n  \
    \    looks up the user's authentication information within its user\n      database.\
    \  Then, the server creates a new session identifier (sid)\n      that will be\
    \ used to identify sets of the messages that follow it\n      and responds with\
    \ a message containing a server-side authenticated\n      key exchange value (401-KEX-S1)\
    \ (4).\n   o  At this point (5), both peers calculate a shared \"session secret\"\
    \n      using the exchanged values in the key exchange messages.  Only\n     \
    \ when both the server and the client have used secret credentials\n      generated\
    \ from the same password will the session secret values\n      match.  This session\
    \ secret will be used for access authentication\n      of every individual request/response\
    \ pair after this point.\n   o  The client will send a request with a client-side\
    \ authentication\n      verification value (req-VFY-C) (6), calculated from the\n\
    \      client-generated session secret.  The server will check the\n      validity\
    \ of the verification value using its own version of the\n      session secret.\n\
    \   o  If the authentication verification value from the client was\n      correct,\
    \ then the client definitely owns the credential based on\n      the expected\
    \ password (i.e., the client authentication succeeded).\n      The server will\
    \ respond with a successful message (200-VFY-S) (7).\n      Unlike the usual one-way\
    \ authentication (e.g., HTTP Basic\n      authentication or POP APOP authentication\
    \ [RFC1939]), this message\n      also contains a server-side authentication verification\
    \ value.\n      When the client's verification value is incorrect (e.g., because\n\
    \      the user-supplied password was incorrect), the server will respond\n  \
    \    with a 401-INIT message (the same message as the message used\n      in (2))\
    \ instead.\n   o  The client MUST first check the validity of the server-side\n\
    \      authentication verification value contained in the message (7).\n     \
    \ If the value was equal to the expected value, server\n      authentication succeeded.\n\
    \      If it is not the expected value or the message does not contain\n     \
    \ the authentication verification value, then the mutual\n      authentication\
    \ has been broken for some unexpected reason.  The\n      client MUST NOT process\
    \ any body or header values contained in the\n      HTTP response in this case.\
    \  (Note: This case should not happen\n      between a correctly implemented server\
    \ and client without any\n      active attacks; such a scenario could be caused\
    \ by either a\n      man-in-the-middle attack or incorrect implementation.)\n"
- title: 2.3.  Alternative Flows
  contents:
  - "2.3.  Alternative Flows\n   As shown above, the typical flow for a first authentication\
    \ request\n   requires three request-response pairs.  To reduce protocol overhead,\n\
    \   the protocol enables several shortcut flows that require fewer\n   messages.\n\
    \   o  Case A: If the client knows that the resource is likely to require\n  \
    \    authentication, the client MAY omit the first unauthenticated\n      request\
    \ (1) and immediately send a key exchange (req-KEX-C1)\n      message.  This will\
    \ reduce the number of round trips by one.\n   o  Case B: If both the client and\
    \ the server previously shared a\n      session secret associated with a valid\
    \ sid, the client MAY\n      directly send a req-VFY-C message using the existing\
    \ sid and\n      corresponding session secret.  This will further reduce the number\n\
    \      of round trips by one.\n      The server MAY have thrown out the corresponding\
    \ session from the\n      session table.  If so, the server will respond with\
    \ a 401-STALE\n      message, indicating that a new key exchange is required.\
    \  The\n      client SHOULD try again to construct a req-KEX-C1 message in\n \
    \     this case.\n   Figure 2 depicts the shortcut flows described above.  When\
    \ using\n   appropriate settings and implementations, most of the requests to\n\
    \   resources are expected to meet both criteria; thus, only one\n   round trip\
    \ of request/response will be required.\n     Case A: Omit first request\n   \
    \          (2 round trips)\n        Client            Server\n        |      \
    \                |\n        | --- req-KEX-C1 ----> |\n        |              \
    \        |\n        | <---- 401-KEX-S1 --- |\n        |                      |\n\
    \        | ---- req-VFY-C ----> |\n        |                      |\n        |\
    \ <----- 200-VFY-S --- |\n        |                      |\n     Case B: Reuse\
    \ session secret (re-authentication)\n         (B-1) key available        (B-2)\
    \ key expired\n               (1 round trip)             (3 round trips)\n   \
    \     Client            Server   Client              Server\n        |       \
    \               |   |                        |\n        | ---- req-VFY-C ---->\
    \ |   | --- req-VFY-C -------> |\n        |                      |   |       \
    \                 |\n        | <----- 200-VFY-S --- |   | <------- 401-STALE ---\
    \ |\n        |                      |   |                        |\n         \
    \                          | --- req-KEX-C1 ------> |\n                      \
    \             |                        |\n                                   |\
    \ <------ 401-KEX-S1 --- |\n                                   |             \
    \           |\n                                   | --- req-VFY-C -------> |\n\
    \                                   |                        |\n             \
    \                      | <------- 200-VFY-S --- |\n                          \
    \         |                        |\n               Figure 2: Several Alternative\
    \ Protocol Flows\n   For more details, see Sections 10 and 11.\n"
- title: 3.  Message Syntax
  contents:
  - "3.  Message Syntax\n   Throughout this specification, the syntax is denoted in\
    \ the extended\n   augmented BNF syntax as defined in [RFC7230] and [RFC5234].\
    \  The\n   following elements are used in this document per [RFC5234],\n   [RFC7230],\
    \ and [RFC7235]: DIGIT, ALPHA, SP, auth-scheme,\n   quoted-string, auth-param,\
    \ header-field, token, challenge, and\n   credentials.\n   The Mutual authentication\
    \ protocol uses three headers:\n   WWW-Authenticate (usually in responses with\
    \ a 401 status code),\n   Authorization (in requests), and Authentication-Info\
    \ (in responses\n   other than a 401 status code).  These headers follow the frameworks\n\
    \   described in [RFC7235] and [RFC7615].  See Section 4 for more details\n  \
    \ regarding these headers.\n   The framework in [RFC7235] defines the syntax for\
    \ the headers\n   WWW-Authenticate and Authorization as the syntax elements \"\
    challenge\"\n   and \"credentials\", respectively.  The auth-scheme element contained\n\
    \   in those headers MUST be set to \"Mutual\" when using the protocol\n   specified\
    \ in this document.  The syntax for \"challenge\" and\n   \"credentials\" to be\
    \ used with the \"Mutual\" auth-scheme SHALL be\n   name-value pairs (#auth-param),\
    \ not the \"token68\" parameter defined\n   in [RFC7235].\n   The Authentication-Info\
    \ header used in this protocol SHALL follow the\n   syntax defined in [RFC7615].\n\
    \   In HTTP, the WWW-Authenticate header may contain two or more\n   challenges.\
    \  Client implementations SHOULD be aware of, and be\n   capable of correctly\
    \ handling, those cases.\n"
- title: 3.1.  Non-ASCII Extended Header Parameters
  contents:
  - "3.1.  Non-ASCII Extended Header Parameters\n   All of the parameters contained\
    \ in the above three headers, except\n   for the \"realm\" field, MAY be extended\
    \ to ISO 10646-1 values using\n   the framework described in [RFC5987].  All servers\
    \ and clients MUST\n   be capable of receiving and sending values encoded per\
    \ the syntax\n   specified in [RFC5987].\n   If a value to be sent contains only\
    \ ASCII characters, the field MUST\n   be sent using plain syntax as defined in\
    \ RFC 7235.  The syntax as\n   extended by RFC 5987 MUST NOT be used in this case.\n\
    \   If a value (except for the \"realm\" header) contains one or more\n   non-ASCII\
    \ characters, the parameter SHOULD be sent using the syntax\n   defined in Section\
    \ 3.2 of [RFC5987] as \"ext-parameter\".  Such a\n   parameter MUST have a charset\
    \ value of \"UTF-8\", and the language\n   value MUST always be omitted (have\
    \ an empty value).  The same\n   parameter MUST NOT be sent more than once, regardless\
    \ of the\n   syntax used.\n   For example, a parameter \"user\" with the value\
    \ \"Renee of France\"\n   SHOULD be sent as < user=\"Renee of France\" >.  If\
    \ the value is\n   \"Ren<e acute>e of France\", it SHOULD be sent as\n   < user*=UTF-8''Ren%C3%89e%20of%20France\
    \ > instead.\n   [RFC7235] requires that the \"realm\" parameter be in its plain\
    \ form\n   (not as an extended \"realm*\" parameter), so the syntax specified\
    \ in\n   RFC 5987 MUST NOT be used for this parameter.\n"
- title: 3.2.  Values
  contents:
  - "3.2.  Values\n   The parameter values contained in challenges or credentials\
    \ MUST be\n   parsed in strict conformance with HTTP semantics (especially the\n\
    \   unquoting of string parameter values).  In this protocol, those\n   values\
    \ are further categorized into the following value types:\n   tokens (bare-token\
    \ and extensive-token), string, integer,\n   hex-fixed-number, and base64-fixed-number.\n\
    \   For clarity, it is RECOMMENDED that implementations use the canonical\n  \
    \ representations specified in the following subsections for sending\n   values.\
    \  However, recipients MUST accept both quoted and unquoted\n   representations\
    \ interchangeably, as specified in HTTP.\n"
- title: 3.2.1.  Tokens
  contents:
  - "3.2.1.  Tokens\n   For sustaining both security and extensibility at the same\
    \ time, this\n   protocol defines a stricter sub-syntax for the \"token\" to be\
    \ used.\n   Extensive-token values SHOULD use the following syntax (after the\n\
    \   parsing of HTTP values):\n      bare-token           = bare-token-lead-char\
    \ *bare-token-char\n      bare-token-lead-char = %x30-39 / %x41-5A / %x61-7A\n\
    \      bare-token-char      = %x30-39 / %x41-5A / %x61-7A / \"-\" / \"_\"\n  \
    \    extension-token      = \"-\" bare-token 1*(\".\" bare-token)\n      extensive-token\
    \      = bare-token / extension-token\n                   Figure 3: BNF Syntax\
    \ for Token Values\n   The tokens (bare-token and extension-token) are case insensitive.\n\
    \   Senders SHOULD send these in lower case, and receivers MUST accept\n   both\
    \ upper and lower cases.  When tokens are used as (partial) inputs\n   to any\
    \ hash functions or other mathematical functions, they MUST\n   always be used\
    \ in lower case.\n   Extensive-tokens are used in this protocol where the set\
    \ of\n   acceptable tokens may include non-standard extensions.  Any extension\n\
    \   of this protocol MAY use either the bare-tokens allocated by IANA\n   (see\
    \ the procedure described in Section 16) or extension-tokens with\n   the format\
    \ \"-<bare-token>.<domain-name>\", where <domain-name> is a\n   valid (sub)domain\
    \ name on the Internet owned by the party who defines\n   the extension.\n   Bare-tokens\
    \ and extensive-tokens are also used for parameter names,\n   in the unquoted\
    \ form.  Requirements for using the extension-token for\n   the parameter names\
    \ are the same as those described in the previous\n   paragraph.\n   The canonical\
    \ format for bare-tokens and extensive-tokens is the\n   unquoted representation.\n"
- title: 3.2.2.  Strings
  contents:
  - "3.2.2.  Strings\n   All character strings MUST be encoded to octet strings using\
    \ UTF-8\n   encoding [RFC3629] for the Unicode character set [Unicode].  Such\n\
    \   strings MUST NOT contain any leading Byte Order Marks (BOMs) (also\n   known\
    \ as ZERO WIDTH NO-BREAK SPACE, U+FEFF, or EF BB BF).  It is\n   RECOMMENDED that\
    \ both peers reject any invalid UTF-8 sequences that\n   might cause decoding\
    \ ambiguities (e.g., containing <\"> in the second\n   or subsequent bytes of\
    \ the UTF-8 encoded characters).\n   If strings represent a domain name or URI\
    \ that contains non-ASCII\n   characters, the host parts SHOULD be encoded as\
    \ they (the parts) are\n   used in the HTTP protocol layer (e.g., in a Host: header);\
    \ per\n   current standards, the A-label as defined in [RFC5890] will be used.\n\
    \   Lowercase ASCII characters SHOULD be used.\n   The canonical format for strings\
    \ is quoted-string (as it may contain\n   equals signs (\"=\"), plus signs (\"\
    +\"), and slashes (\"/\")), unless the\n   parameter containing the string value\
    \ will use extended syntax as\n   defined in [RFC5987].  (Per [RFC5987], an extended\
    \ parameter will\n   have an unquoted encoded value.)\n"
- title: 3.2.3.  Numbers
  contents:
  - "3.2.3.  Numbers\n   The following syntax definitions provide a syntax for numeric\
    \ values:\n    integer             = \"0\" / (%x31-39 *DIGIT)     ; no leading\
    \ zeros\n    hex-fixed-number    = 1*(2(DIGIT / %x41-46 / %x61-66))\n    base64-fixed-number\
    \ = 1*( ALPHA / DIGIT / \"+\" / \"/\" ) 0*2\"=\"\n                     Figure\
    \ 4: BNF Syntax for Numbers\n   The syntax definition of the integers only allows\
    \ representations\n   that do not contain leading zeros.\n   A number represented\
    \ as a hex-fixed-number MUST include an even\n   number of hexadecimal digits\
    \ (i.e., multiples of eight bits).  Those\n   values are case insensitive and\
    \ SHOULD be sent in lower case.  When\n   these values are generated from any\
    \ cryptographic values, they MUST\n   have their \"natural length\"; if they are\
    \ generated from a hash\n   function, their lengths correspond to the hash size;\
    \ if they\n   represent elements of a mathematical set (or group), their lengths\n\
    \   SHALL be the shortest lengths that represent all the elements in the\n   set.\
    \  For example, the results of the SHA-256 hash function will be\n   represented\
    \ by 64 digits, and any elements in a 2048-bit prime field\n   (modulo a 2048-bit\
    \ integer) will be represented by 512 digits,\n   regardless of how many zeros\
    \ appear in front of such representations.\n   Session identifiers and other non-cryptographically\
    \ generated values\n   are represented in any (even) length determined by the\
    \ side that\n   generates it first, and the same length MUST be used in all\n\
    \   communications by both peers.\n   The numbers represented as base64-fixed-number\
    \ SHALL be generated as\n   follows: first, the number is converted to a big-endian\
    \ radix-256\n   binary representation as an octet string.  The length of the\n\
    \   representation is determined in the same way as the technique\n   mentioned\
    \ above.  Then, the string is encoded using base64 encoding\n   (described in\
    \ Section 4 of [RFC4648]) without any spaces and\n   newlines.  Implementations\
    \ decoding base64-fixed-number SHOULD reject\n   any input data with invalid characters,\
    \ excess or insufficient\n   padding, or non-canonical pad bits (see Sections\
    \ 3.1 through 3.5 of\n   [RFC4648]).\n   The canonical format for integer and\
    \ hex-fixed-number is unquoted\n   tokens, and the canonical format for base64-fixed-number\
    \ is\n   quoted-string.\n"
- title: 4.  Messages
  contents:
  - "4.  Messages\n   In this section, we define the six kinds of messages in the\n\
    \   authentication protocol, along with the formats and requirements of\n   the\
    \ headers for each type of message.\n   To determine under what circumstances\
    \ each message is expected to be\n   sent, see Sections 10 and 11.\n   In the\
    \ descriptions below, the types of allowable values for each\n   header parameter\
    \ are shown in parentheses after each parameter name.\n   The \"algorithm-determined\"\
    \ type means that the acceptable value for\n   the parameter is one of the types\
    \ defined in Section 3 and is\n   determined by the value of the \"algorithm\"\
    \ parameter.  The parameters\n   marked \"mandatory\" SHALL be contained in the\
    \ message.  The parameters\n   marked \"non-mandatory\" MAY be either contained\
    \ in the message or\n   omitted from it.  Each parameter SHALL appear in each\
    \ header exactly\n   once at most.\n   All credentials and challenges MAY contain\
    \ any parameters not\n   explicitly specified in the following sections.  Recipients\
    \ that\n   do not understand such parameters MUST silently ignore them.\n   However,\
    \ all credentials and challenges MUST meet the following\n   criteria:\n   o \
    \ For responses, the parameters \"reason\", any \"ks#\" (where \"#\"\n      stands\
    \ for any decimal integer), and \"vks\" are mutually exclusive;\n      any challenges\
    \ MUST NOT contain two or more parameters among them.\n      They MUST NOT contain\
    \ any \"kc#\" or \"vkc\" parameters.\n   o  For requests, the parameters \"kc#\"\
    \ (where \"#\" stands for any\n      decimal integer) and \"vkc\" are mutually\
    \ exclusive; any challenges\n      MUST NOT contain two or more parameters among\
    \ them.  They MUST NOT\n      contain any \"ks#\" or \"vks\" parameters.\n   Every\
    \ message defined in this section contains a \"version\" field to\n   detect any\
    \ future revisions of the protocol that are incompatible.\n   Implementations\
    \ of the protocol described in this specification MUST\n   always send a token\
    \ \"1\" to represent the version number.  Recipients\n   MUST reject messages\
    \ that contain any other value for the version,\n   unless another specification\
    \ defines specific behavior for that\n   version.\n"
- title: 4.1.  401-INIT and 401-STALE
  contents:
  - "4.1.  401-INIT and 401-STALE\n   Every 401-INIT or 401-STALE message SHALL be\
    \ a valid HTTP 401\n   (Unauthorized) status message (or some other 4xx status\
    \ message, if\n   appropriate) containing one and only one (hereafter not explicitly\n\
    \   noted) WWW-Authenticate header containing a \"reason\" parameter in the\n\
    \   challenge.  The challenge SHALL contain all of the parameters marked\n   \"\
    mandatory\" below and MAY contain those marked \"non-mandatory\".\n   version:\n\
    \      (mandatory extensive-token) should be the token \"1\".\n   algorithm:\n\
    \      (mandatory extensive-token) specifies the authentication algorithm\n  \
    \    to be used.  The value MUST be one of the tokens specified in\n      [RFC8121]\
    \ or another supplemental specification.\n   validation:\n      (mandatory extensive-token)\
    \ specifies the method of host\n      validation.  The value MUST be one of the\
    \ tokens described in\n      Section 7 or the tokens specified in another supplemental\n\
    \      specification.\n   auth-scope:\n      (non-mandatory string) specifies\
    \ the authentication scope, i.e.,\n      the set of hosts for which the authentication\
    \ credentials are\n      valid.  It MUST be one of the strings described in Section\
    \ 5.  If\n      the value is omitted, it is assumed to be the \"single-server\
    \ type\"\n      domain as described in Section 5.\n   realm:\n      (mandatory\
    \ string) is a string representing the name of the\n      authentication realm\
    \ inside the authentication scope.  As\n      specified in [RFC7235], this value\
    \ MUST always be sent in the\n      quoted-string form, and an encoding as specified\
    \ in [RFC5987]\n      MUST NOT be used.\n      The realm value sent from the server\
    \ SHOULD be an ASCII string.\n      Clients MAY treat any non-ASCII value received\
    \ in this field as a\n      binary blob, an NFC-normalized UTF-8 string (\"NFC\"\
    \ stands for\n      \"Normalization Form C\"), or an error.\n   reason:\n    \
    \  (mandatory extensive-token) SHALL be an extensive-token that\n      describes\
    \ the possible reason for the failed authentication or\n      authorization. \
    \ Both servers and clients SHALL understand and\n      support the following three\
    \ tokens:\n      *  initial: Authentication was not attempted because there was\
    \ no\n         Authorization header in the corresponding request.\n      *  stale-session:\
    \ The provided sid in the request was either\n         unknown to the server or\
    \ expired in the server.\n      *  auth-failed: The authentication trial failed\
    \ for some reason,\n         possibly because of a bad authentication credential.\n\
    \      Implementations MAY support the following tokens or any\n      extensive-tokens\
    \ defined outside of this specification.  If\n      clients receive any unknown\
    \ tokens, they SHOULD treat them as if\n      they were \"auth-failed\" or \"\
    initial\".\n      *  reauth-needed: The server-side application requires a new\n\
    \         authentication trial, regardless of the current status.\n      *  invalid-parameters:\
    \ The server did not attempt authentication\n         because some parameters\
    \ were not acceptable.\n      *  internal-error: The server did not attempt authentication\n\
    \         because there are some problems on the server side.\n      *  user-unknown:\
    \ This is a special case of auth-failed; it\n         suggests that the provided\
    \ username is invalid.  Due to\n         security implications, the use of this\
    \ parameter is\n         NOT RECOMMENDED, except for special-purpose applications\
    \ where\n         it would make sense to do so.\n      *  invalid-credential:\
    \ This is another special case of\n         auth-failed; it suggests that the\
    \ provided username was valid\n         but authentication still failed.  For\
    \ security reasons, the use\n         of this parameter is NOT RECOMMENDED.\n\
    \      *  authz-failed: Authentication was successful, but access to the\n   \
    \      specified resource is not authorized to the specific\n         authenticated\
    \ user.  (It might be used along with either a\n         401 (Unauthorized) or\
    \ 403 (Forbidden) status code to indicate\n         that the authentication result\
    \ is one of the existing reasons\n         for the failed authorization.)\n  \
    \    It is RECOMMENDED that the reason for failure be recorded to some\n     \
    \ type of diagnostic log, shown to the client user immediately, or\n      both.\
    \  It will be helpful to find out later whether the reason for\n      the failure\
    \ is technical or caused by user error.\n   The algorithm specified in this header\
    \ will determine the types\n   (among those defined in Section 3) and the values\
    \ for K_c1, K_s1,\n   VK_c, and VK_s.\n   Among these messages, any messages with\
    \ the \"reason\" parameter value\n   \"stale-session\" will be called \"401-STALE\"\
    \ messages hereafter,\n   because these messages have a special meaning in the\
    \ protocol flow.\n   Messages with any other \"reason\" parameters will be called\
    \ \"401-INIT\"\n   messages.\n"
- title: 4.2.  req-KEX-C1
  contents:
  - "4.2.  req-KEX-C1\n   Every req-KEX-C1 message SHALL be a valid HTTP request message\n\
    \   containing an Authorization header with a credential containing a\n   \"kc1\"\
    \ parameter.\n   The credential SHALL contain the parameters with the following\
    \ names:\n   version:\n      (mandatory, extensive-token) should be the token\
    \ \"1\".\n   algorithm, validation, auth-scope, realm:\n      MUST be the same\
    \ values as those received from the server.\n   user:\n      (mandatory, string)\
    \ is the UTF-8 encoded name of the user.  The\n      string SHOULD be prepared\
    \ according to the method presented in\n      Section 9.\n   kc1:\n      (mandatory,\
    \ algorithm-determined) is the client-side key exchange\n      value K_c1, which\
    \ is specified by the algorithm that is used.\n"
- title: 4.3.  401-KEX-S1
  contents:
  - "4.3.  401-KEX-S1\n   Every 401-KEX-S1 message SHALL be a valid HTTP 401 (Unauthorized)\n\
    \   status response message containing a WWW-Authenticate header with a\n   challenge\
    \ containing a \"ks1\" parameter.\n   The challenge SHALL contain the parameters\
    \ with the following names:\n   version:\n      (mandatory, extensive-token) should\
    \ be the token \"1\".\n   algorithm, validation, auth-scope, realm:\n      MUST\
    \ be the same values as those received from the client.\n   sid:\n      (mandatory,\
    \ hex-fixed-number) MUST be a session identifier, which\n      is a random integer.\
    \  The sid SHOULD have uniqueness of at least\n      80 bits or the square of\
    \ the maximum estimated transactions\n      concurrently available in the session\
    \ table, whichever is larger.\n      See Section 6 for more details.\n   ks1:\n\
    \      (mandatory, algorithm-determined) is the server-side key exchange\n   \
    \   value K_s1, which is specified by the algorithm.\n   nc-max:\n      (mandatory,\
    \ integer) is the maximum value of nonce numbers that\n      the server accepts.\n\
    \   nc-window:\n      (mandatory, integer) is the number of available nonce number\
    \ slots\n      that the server will accept.  It is RECOMMENDED that the value\
    \ of\n      the \"nc-window\" parameter be 128 or more.\n   time:\n      (mandatory,\
    \ integer) represents the suggested time (in seconds)\n      that the client can\
    \ reuse the session represented by the sid.  It\n      is RECOMMENDED that the\
    \ time be set to at least 60 (seconds).\n      However, the server is not required\
    \ to guarantee that the session\n      represented by the sid will be available\
    \ (e.g., alive, usable) for\n      the time specified in this parameter.\n   path:\n\
    \      (non-mandatory, string) specifies to which path in the URI space\n    \
    \  the same authentication is expected to be applied.  The value is a\n      space-separated\
    \ list of URIs, in the same format as that specified\n      in the \"domain\"\
    \ parameter [RFC7616] for Digest authentications.\n      All path elements contained\
    \ in the \"path\" parameter MUST be inside\n      the specified auth-scope; if\
    \ not, clients SHOULD ignore such\n      elements.  For better performance, it\
    \ is important that clients\n      recognize and use this parameter.\n"
- title: 4.4.  req-VFY-C
  contents:
  - "4.4.  req-VFY-C\n   Every req-VFY-C message SHALL be a valid HTTP request message\n\
    \   containing an Authorization header with a credential containing a\n   \"vkc\"\
    \ parameter.\n   The parameters contained in the header are as follows:\n   version:\n\
    \      (mandatory, extensive-token) should be the token \"1\".\n   algorithm,\
    \ validation, auth-scope, realm:\n      MUST be the same values as those received\
    \ from the server for the\n      session.\n   sid:\n      (mandatory, hex-fixed-number)\
    \ MUST be one of the sid values that\n      was received from the server for the\
    \ same authentication realm.\n   nc:\n      (mandatory, integer) is a nonce request\
    \ number that is unique\n      among the requests sharing the same sid.  The values\
    \ of the nonce\n      numbers SHOULD satisfy the properties outlined in Section\
    \ 6.\n   vkc:\n      (mandatory, algorithm-determined) is the client-side\n  \
    \    authentication verification value VK_c, which is specified by the\n     \
    \ algorithm.\n"
- title: 4.5.  200-VFY-S
  contents:
  - "4.5.  200-VFY-S\n   Every 200-VFY-S message SHALL be a valid HTTP message that\
    \ does not\n   have a 401 (Unauthorized) status code and SHALL contain an\n  \
    \ Authentication-Info header with a \"vks\" parameter.\n   The parameters contained\
    \ in the header are as follows:\n   version:\n      (mandatory, extensive-token)\
    \ should be the token \"1\".\n   sid:\n      (mandatory, hex-fixed-number) MUST\
    \ be the value received from the\n      client.\n   vks:\n      (mandatory, algorithm-determined)\
    \ is the server-side\n      authentication verification value VK_s, which is specified\
    \ by the\n      algorithm.\n   The header MUST be sent before the content body;\
    \ it MUST NOT be sent\n   in the trailer of a chunked-encoded response.  If a\
    \ \"100 (Continue)\"\n   [RFC7231] response is sent from the server, the Authentication-Info\n\
    \   header SHOULD be included in that response instead of the final\n   response.\n"
- title: 5.  Authentication Realms
  contents:
  - "5.  Authentication Realms\n   In this protocol, an authentication realm is defined\
    \ as a set of\n   resources (URIs) for which the same set of usernames and passwords\
    \ is\n   valid.  If the server requests authentication for an authentication\n\
    \   realm for which the client is already authenticated, the client will\n   automatically\
    \ perform the authentication using the already-known\n   credentials.  However,\
    \ for different authentication realms, clients\n   MUST NOT automatically reuse\
    \ usernames and passwords for another\n   realm.\n   As is the case for the Basic\
    \ and Digest access authentication\n   protocols, the Mutual authentication protocol\
    \ supports multiple,\n   separate protection spaces to be set up inside each host.\n\
    \   Furthermore, the protocol allows a single authentication realm to\n   span\
    \ several hosts within the same Internet domain.\n   Each authentication realm\
    \ is defined and distinguished by the triple\n   of an authentication algorithm,\
    \ an authentication scope, and a\n   \"realm\" parameter.  However, it is NOT\
    \ RECOMMENDED that server\n   operators use the same pair of an authentication\
    \ scope and a realm\n   with different authentication algorithms.\n   The \"realm\"\
    \ parameter is a string as defined in Section 4.\n   Authentication scopes are\
    \ described in the remainder of this section.\n   An authentication scope specifies\
    \ the range of hosts spanned by the\n   authentication realm.  In this protocol,\
    \ it MUST be one of the\n   following kinds of strings:\n   o  Single-server type:\
    \ A string in the format \"<scheme>://<host>\" or\n      \"<scheme>://<host>:<port>\"\
    , where <scheme>, <host>, and <port> are\n      the corresponding URI parts of\
    \ the request URI.  If the default\n      port (i.e., 80 for HTTP and 443 for\
    \ HTTPS) is used for the\n      underlying HTTP communications, the port part\
    \ MUST be omitted,\n      regardless of whether it was present in the request\
    \ URI.  In all\n      other cases, the port part MUST be present, and it MUST\
    \ NOT\n      contain leading zeros.  Use this format when authentication is\n\
    \      only valid for a specific protocol (such as HTTPS).  This format\n    \
    \  is equivalent to the ASCII serialization of a Web origin, as\n      presented\
    \ in Section 6.2 of [RFC6454].\n   o  Single-host type: The \"host\" part of the\
    \ requested URI.  This is\n      the default value.  Authentication realms within\
    \ this kind of\n      authentication scope will span several protocols (e.g.,\
    \ HTTP and\n      HTTPS) and ports but will not span different hosts.\n   o  Wildcard-domain\
    \ type: A string in the format \"*.<domain-postfix>\",\n      where <domain-postfix>\
    \ is either the host part of the requested\n      URI or any domain in which the\
    \ requested host is included (this\n      means that the specification \"*.example.com\"\
    \ is valid for all of\n      hosts \"www.example.com\", \"web.example.com\",\n\
    \      \"www.sales.example.com\", and \"example.com\").  The domain-postfix\n\
    \      sent by the servers MUST be equal to or included in a valid\n      Internet\
    \ domain assigned to a specific organization; if clients\n      know, via some\
    \ means such as a blacklist for HTTP cookies\n      [RFC6265], that the specified\
    \ domain is not to be assigned to any\n      specific organization (e.g., \"*.com\"\
    \ or \"*.jp\"), it is RECOMMENDED\n      that clients reject the authentication\
    \ request.\n   In the above specifications, every \"scheme\", \"host\", and \"\
    domain\"\n   MUST be in lower case, and any internationalized domain names beyond\n\
    \   the ASCII character set SHALL be represented in the way they are sent\n  \
    \ in the underlying HTTP protocol, represented in lowercase characters,\n   i.e.,\
    \ these domain names SHALL be in the form of LDH (\"letters,\n   digits, hyphen\"\
    ) labels as defined in the Internationalized Domain\n   Names for Applications\
    \ (IDNA) specification [RFC5890].  A \"port\" MUST\n   be given in shortest unsigned\
    \ decimal number notation.  Not obeying\n   these requirements will cause valid\
    \ authentication attempts to fail.\n"
- title: 5.1.  Resolving Ambiguities
  contents:
  - "5.1.  Resolving Ambiguities\n   In the above definitions of authentication scopes,\
    \ several scopes may\n   overlap each other.  If a client has already been authenticated\
    \ to\n   several realms applicable to the same server, the client may have\n \
    \  multiple lists of the \"path\" parameters received with the\n   \"401-KEX-S1\"\
    \ message (see Section 4).  If these path lists have any\n   overlap, a single\
    \ URI may belong to multiple possible candidate\n   realms to which the client\
    \ can be authenticated.  In such cases,\n   clients face an ambiguous choice regarding\
    \ which credentials to send\n   for a new request (see Steps 3 and 4 of the decision\
    \ procedure\n   presented in Section 10).\n   In such cases, a client MAY freely\
    \ send requests that belong to any\n   of these candidate realms, or it MAY simply\
    \ send an unauthenticated\n   request and see for which realm the server requests\
    \ an\n   authentication.  It is RECOMMENDED that server operators provide\n  \
    \ properly configured \"path\" parameters (more precisely, disjoint path\n   sets\
    \ for each realm) for clients so that such ambiguities will not\n   occur.\n \
    \  The following procedure is one possible tactic for resolving\n   ambiguities\
    \ in such cases:\n   o  If the client has previously sent a request to the same\
    \ URI and it\n      remembers the authentication realm requested by the 401-INIT\n\
    \      message at that time, use that realm.\n   o  In other cases, use one of\
    \ the authentication realms representing\n      the most-specific authentication\
    \ scopes.  The list of possible\n      domain specifications shown above is given\
    \ from most specific to\n      least specific.\n      If there are several choices\
    \ with different wildcard-domain\n      specifications, the one that has the longest\
    \ domain-postfix has\n      priority over those with shorter domain-postfixes.\n\
    \   o  If there are realms with the same authentication scope, there is\n    \
    \  no defined priority; the client MAY choose any one of the possible\n      choices.\n"
- title: 6.  Session Management
  contents:
  - "6.  Session Management\n   In the Mutual authentication protocol, a session represented\
    \ by\n   an sid is set up using four messages (first request, 401-INIT,\n   req-KEX-C1,\
    \ and 401-KEX-S1), after which a session secret (z)\n   associated with the session\
    \ is established.  After mutually\n   establishing a session secret, this session,\
    \ along with the secret,\n   can be used for one or more requests for resources\
    \ protected by the\n   same realm on the same server.  Note that session management\
    \ is only\n   an inside detail of the protocol and usually not visible to normal\n\
    \   users.  If a session expires, the client and server SHOULD\n   automatically\
    \ re-establish another session without informing\n   the user.\n   Sessions and\
    \ session identifiers are local to each server (defined by\n   scheme, host, and\
    \ port), even if an authentication scope covers\n   multiple servers; clients\
    \ MUST establish separate sessions for each\n   port of a host to be accessed.\
    \  Furthermore, sessions and identifiers\n   are also local to each authentication\
    \ realm, even if they are\n   provided by the same server.  The same session identifiers\
    \ provided\n   either from different servers or for different realms MUST be treated\n\
    \   as being independent of each other.\n   The server SHOULD accept at least\
    \ one req-VFY-C request for each\n   session if the request reaches the server\
    \ in a time window specified\n   by the \"timeout\" parameter in the 401-KEX-S1\
    \ message and if there are\n   no emergent reasons (such as flooding attacks)\
    \ to forget the session.\n   After that, the server MAY discard any session at\
    \ any time and MAY\n   send 401-STALE messages for any further req-VFY-C requests\
    \ received\n   for that session.\n   The client MAY send two or more requests\
    \ using a single session\n   specified by the sid.  However, for all such requests,\
    \ each value of\n   the nonce number (in the \"nc\" parameter) MUST satisfy the\
    \ following\n   conditions:\n   o  It is a natural number.\n   o  The same nonce\
    \ number was not sent within the same session.\n   o  It is not larger than the\
    \ nc-max value that was sent from the\n      server in the session represented\
    \ by the sid.\n   o  It is larger than (largest-nc - nc-window), where largest-nc\
    \ is\n      the largest value of nc that was previously sent in the session\n\
    \      and nc-window is the value of the \"nc-window\" parameter that was\n  \
    \    received from the server for the session.\n   The last condition allows servers\
    \ to reject any nonce numbers that\n   are \"significantly\" smaller than the\
    \ \"current\" value (defined by the\n   value of nc-window) of the nonce number\
    \ used in the session involved.\n   In other words, servers MAY treat such nonce\
    \ numbers as \"already\n   received\".  This restriction enables servers to implement\n\
    \   duplicate-nonce detection in a constant amount of memory for each\n   session.\n\
    \   Servers MUST check for duplication of the received nonce numbers, and\n  \
    \ if any duplication is detected, the server MUST discard the session\n   and\
    \ respond with a 401-STALE message, as outlined in Section 11.  The\n   server\
    \ MAY also reject other invalid nonce numbers (such as those\n   above the nc-max\
    \ limit) by sending a 401-STALE message.\n   For example, assume that the nc-window\
    \ value of the current session\n   is 128 and nc-max is 400, and that the client\
    \ has already used the\n   following nonce numbers: {1-120, 122, 124, 130-238,\
    \ 255-360,\n   363-372}.  The nonce number that can then be used for the next\n\
    \   request is a number from the following set: {245-254, 361, 362,\n   373-400}.\
    \  The values {0, 121, 123, 125-129, 239-244} MAY be rejected\n   by the server\
    \ because they are not above the current \"window limit\"\n   (244 = 372 - 128).\n\
    \   Typically, clients can ensure the above property by using a\n   monotonically\
    \ increasing integer counter that counts from zero up to\n   the value of nc-max.\n\
    \   The values of the nonce numbers and any nonce-related values MUST\n   always\
    \ be treated as natural numbers within an infinite range.\n   Implementations\
    \ that use fixed-width integer representations,\n   fixed-precision floating-point\
    \ numbers, or similar representations\n   SHOULD NOT reject any larger values\
    \ that overflow such representative\n   limits and MUST NOT silently truncate\
    \ them using any modulus-like\n   rounding operation (e.g., by mod 2^32).  Instead,\
    \ the whole protocol\n   is carefully designed so that recipients MAY replace\
    \ any such\n   overflowing values (e.g., 2^80) with some reasonably large maximum\n\
    \   representative integer (e.g., 2^31 - 1 or others).\n"
- title: 7.  Host Validation Methods
  contents:
  - "7.  Host Validation Methods\n   The \"validation method\" specifies a method\
    \ to \"relate\" (or \"bind\")\n   the mutual authentication processed by this\
    \ protocol with other\n   authentications already performed in the underlying\
    \ layers and to\n   prevent man-in-the-middle attacks.  It determines the value\
    \ vh that\n   is an input to the authentication protocols.\n   When HTTPS or another\
    \ possible secure transport is used, this\n   corresponds to the idea of \"channel\
    \ binding\" as described in\n   [RFC5929].  Even when HTTP is used, similar, but\
    \ somewhat limited,\n   \"binding\" is performed to prevent a malicious server\
    \ from trying to\n   authenticate itself to another server as a valid user by\
    \ forwarding\n   the received credentials.\n   The valid tokens for the \"validation\"\
    \ parameter and corresponding\n   values of vh are as follows:\n   host:\n   \
    \   hostname validation.  The value vh will be the ASCII string in the\n     \
    \ following format: \"<scheme>://<host>:<port>\", where <scheme>,\n      <host>,\
    \ and <port> are the URI components corresponding to the\n      server-side resource\
    \ currently being accessed.  The scheme and\n      host are in lower case, and\
    \ the port is listed in shortest decimal\n      notation.  Even if the request\
    \ URI does not have a port part, vh\n      will include the default port number.\n\
    \   tls-server-end-point:\n      TLS endpoint (certificate) validation.  The value\
    \ vh will be the\n      octet string of the hash value of the server's public\
    \ key\n      certificate used in the underlying TLS [RFC5246] connection,\n  \
    \    processed as specified in Section 4.1 of [RFC5929].\n   tls-unique:\n   \
    \   TLS shared-key validation.  The value vh will be the\n      channel-binding\
    \ material derived from the Finished messages,\n      as defined in Section 3.1\
    \ of [RFC5929].  (Note: See Section 7.2\n      for some security-related notes\
    \ regarding this validation method.)\n   If HTTP is used on a non-encrypted channel\
    \ (TCP and the Stream\n   Control Transmission Protocol (SCTP), for example),\
    \ the validation\n   type MUST be \"host\".  If HTTP/TLS [RFC2818] (HTTPS) is\
    \ used with a\n   server certificate, the validation type MUST be\n   \"tls-server-end-point\"\
    .  If HTTP/TLS is used with an anonymous\n   Diffie-Hellman key exchange, the\
    \ validation type MUST be \"tls-unique\"\n   (see the note below).\n   If the\
    \ validation type \"tls-server-end-point\" is used, the server\n   certificate\
    \ provided in the TLS connection MUST be verified at least\n   to make sure that\
    \ the server actually owns the corresponding private\n   key.  (Note: This verification\
    \ is automatic in some RSA-based key\n   exchanges but is NOT automatic in Diffie-Hellman-based\
    \ key exchanges\n   with separate exchanges for server verification.)\n   Clients\
    \ MUST validate this parameter upon receipt of 401-INIT\n   messages.\n   Note:\
    \ The protocol defines two variants of validation on the TLS\n   connections.\
    \  The \"tls-unique\" method is technically more secure.\n   However, there are\
    \ some situations where \"tls-server-end-point\" is\n   preferable:\n   o  When\
    \ TLS accelerating proxies are used.  In this case, it is\n      difficult for\
    \ the authenticating server to acquire the TLS key\n      information that is\
    \ used between the client and the proxy.  This\n      is not the case for client-side\
    \ \"tunneling\" proxies using the HTTP\n      CONNECT method.\n   o  When a black-box\
    \ implementation of the TLS protocol is used on\n      either peer.\n"
- title: 7.1.  Applicability Notes
  contents:
  - "7.1.  Applicability Notes\n   When the client is a Web browser with any scripting\
    \ capabilities\n   (support of dynamic contents), the underlying TLS channel used\
    \ with\n   HTTP/TLS MUST provide server identity verification.  This means that\n\
    \   (1) anonymous Diffie-Hellman key exchange cipher suites MUST NOT be\n   used\
    \ and (2) verification of the server certificate provided by the\n   server MUST\
    \ be performed.  This is to prevent loading identity-\n   unauthenticated scripts\
    \ or dynamic contents, which are referenced\n   from the authenticated page.\n\
    \   For other systems, when the underlying TLS channel used with HTTP/TLS\n  \
    \ does not perform server identity verification, the client SHOULD\n   ensure\
    \ that all responses are validated using the Mutual\n   authentication protocol,\
    \ regardless of the existence of 401-INIT\n   responses.\n"
- title: 7.2.  Notes on "tls-unique"
  contents:
  - "7.2.  Notes on \"tls-unique\"\n   As described in the interoperability note in\
    \ Section 3.1 of\n   [RFC5929], the \"tls-unique\" verification value will be\
    \ changed by\n   possible TLS renegotiation, causing an interoperability problem.\
    \  TLS\n   renegotiations are used in several HTTPS server implementations for\n\
    \   enforcing some security properties (such as cryptographic strength)\n   for\
    \ some specific responses.\n   If an implementation supports the \"tls-unique\"\
    \ verification method,\n   the following precautions SHOULD be taken:\n   o  Both\
    \ peers must be aware that the vh values used for vkc (in\n      req-VFY-C messages)\
    \ and vks (in 200-VFY-S messages) may be\n      different.  These values MUST\
    \ be retrieved from underlying TLS\n      libraries each time they are used.\n\
    \   o  After calculating the values vh and vkc to send a req-VFY-C\n      request,\
    \ clients SHOULD NOT initiate TLS renegotiation until the\n      end of the corresponding\
    \ response header is received.  An\n      exception is that clients can and SHOULD\
    \ perform TLS renegotiation\n      as a response to the server's request for TLS\
    \ renegotiation,\n      before receipt of the beginning of the response header.\n\
    \   Also, implementers MUST take care of session resumption attacks\n   regarding\
    \ \"tls-unique\" channel-binding mechanisms and master secrets.\n   As a mitigation,\
    \ the TLS extension defined in [RFC7627] SHOULD be\n   used when \"tls-unique\"\
    \ host verification is to be used.\n"
- title: 8.  Authentication Extensions
  contents:
  - "8.  Authentication Extensions\n   It is RECOMMENDED that interactive clients\
    \ (e.g., Web browsers)\n   supporting this protocol support non-mandatory authentication\
    \ and the\n   Authentication-Control header defined in [RFC8053], except for the\n\
    \   \"auth-style\" parameter.  This specification also proposes (but does\n  \
    \ not mandate) that the default \"auth-style\" be \"non-modal\".  Web\n   applications\
    \ SHOULD, however, consider the security impacts of the\n   behavior of clients\
    \ that do not support these headers.\n   Authentication-initializing messages\
    \ with the\n   Optional-WWW-Authenticate header are used only where the 401-INIT\n\
    \   response is valid.  It will not replace other 401-type messages such\n   as\
    \ 401-STALE and 401-KEX-S1.  That is, the \"reason\" field of such a\n   message\
    \ MUST be \"initial\" (or any extensive-tokens NOT defined in\n   Section 4.1).\n"
- title: 9.  String Preparation
  contents:
  - "9.  String Preparation\n   For interoperability reasons, it is important that\
    \ usernames and\n   passwords used in this protocol be binary-comparable, regardless\
    \ of\n   the user's input methods and/or environments.  To ensure this, the\n\
    \   following preparation SHOULD be performed:\n   o  Usernames received from\
    \ users SHOULD be prepared using the\n      \"UsernameCasePreserved\" profile\
    \ defined in Section 3.3 of\n      [RFC7613].\n   o  Passwords received from users\
    \ SHOULD be prepared using the\n      \"OpaqueString\" profile defined in Section\
    \ 4.2 of [RFC7613].\n   In both cases, it is the sender's duty to correctly prepare\
    \ the\n   character strings.  If any non-prepared character string is received\n\
    \   from the other peer of the communication, the behavior of its\n   recipient\
    \ is not defined; the recipient MAY either accept or reject\n   such input.\n\
    \   Server applications SHOULD also prepare usernames and passwords\n   accordingly\
    \ upon registration of user credentials.\n   In addition, binary-based \"interfaces\"\
    \ of implementations MAY require\n   and assume that the string is already prepared\
    \ accordingly; when a\n   string is already stored as a binary Unicode string\
    \ form,\n   implementations MAY omit preparation and Unicode normalization\n \
    \  (performing UTF-8 encoding only) before using it.  When a string is\n   already\
    \ stored as an octet blob, implementations MAY send it as is.\n"
- title: 10.  Decision Procedure for Clients
  contents:
  - '10.  Decision Procedure for Clients

    '
- title: 10.1.  General Principles and Requirements
  contents:
  - "10.1.  General Principles and Requirements\n   To securely implement the protocol,\
    \ the client must be careful about\n   accepting the authenticated responses from\
    \ the server.  This also\n   holds true for the reception of a \"normal response\"\
    \ (a response that\n   does not contain mutual-authentication-related headers)\
    \ from HTTP\n   servers.\n   Per typical HTTP authentication, a single user-level\
    \ request may\n   result in the exchange of two or more HTTP requests and responses\
    \ in\n   sequence.  The following normative rules MUST be followed by the\n  \
    \ clients implementing this protocol:\n   o  Any kind of \"normal response\" MUST\
    \ only be accepted for the very\n      first request in the sequence.  Any \"\
    normal response\" returned for\n      the second or subsequent requests in the\
    \ sequence SHALL be\n      considered invalid.\n   o  By the same principle, if\
    \ any response is related to an\n      authentication realm that is different\
    \ from that of the client's\n      request (for example, a 401-INIT message requesting\
    \ authentication\n      on another realm), it MUST only be accepted for the very\
    \ first\n      request in the sequence.  Such a response returned for a second\
    \ or\n      subsequent request in the sequence SHALL be considered invalid.\n\
    \   o  A req-KEX-C1 message MAY be sent as either an initial request or a\n  \
    \    response to a 401-INIT or 401-STALE message.  However, to avoid\n      infinite\
    \ loops of messages, the req-KEX-C1 message SHOULD NOT be\n      sent more than\
    \ once in the sequence for a single authentication\n      realm.  A 401-KEX-S1\
    \ response MUST be accepted only when the\n      corresponding request is req-KEX-C1.\n\
    \   o  A req-VFY-C message MAY be sent if there is a valid session secret\n  \
    \    shared between the client and the server, as established by\n      req-KEX-C1\
    \ and 401-KEX-S1 messages.  If any response with a\n      401 status code is returned\
    \ for such a message, the corresponding\n      session secret SHOULD be discarded\
    \ as unusable.\n      In particular, upon the reception of a 401-STALE response,\
    \ the\n      client SHOULD try to establish a new session by sending a\n     \
    \ req-KEX-C1 message, but only once within the request/response\n      sequence.\n\
    \   o  A 200-VFY-S message MUST be accepted only as a response to a\n      req-VFY-C\
    \ message and nothing else.  The VK_s values of such\n      response messages\
    \ MUST always be checked against the correct\n      value, and if it is incorrect,\
    \ the whole response SHOULD be\n      considered invalid.\n   The final status\
    \ of the client request following the message exchange\n   sequence shall be determined\
    \ as follows:\n   o  AUTH-SUCCEED: A 200-VFY-S message with the correct VK_s value\
    \ was\n      returned in response to the req-VFY-C request in the sequence.\n\
    \   o  AUTH-REQUIRED: Two cases exist:\n      *  A 401-INIT message was returned\
    \ from the server, and the client\n         does not know how to authenticate\
    \ to the given authentication\n         realm.\n      *  A 401-INIT response was\
    \ returned for a req-VFY-C (or\n         req-KEX-C1) message, which means that\
    \ the user-supplied\n         authentication credentials were not accepted.\n\
    \   o  UNAUTHENTICATED: A \"normal response\" is returned for an initial\n   \
    \   request of any kind in the sequence.\n   Any kind of response (including a\
    \ \"normal response\") other than those\n   explicitly allowed in the above rules\
    \ SHOULD be interpreted as a\n   fatal communication error.  In such cases, the\
    \ clients MUST NOT\n   process any data (the response body and other content-related\n\
    \   headers) sent from the server.  However, to handle exceptional error\n   cases,\
    \ clients MAY accept a message without an Authentication-Info\n   header if it\
    \ has a Server Error (5xx) status code.  In such cases,\n   they SHOULD be careful\
    \ about processing the body of the content\n   (ignoring it is still RECOMMENDED,\
    \ as it may possibly be forged by\n   intermediate attackers), and the client\
    \ will then have a status of\n   \"UNAUTHENTICATED\".\n   If a request is a sub-request\
    \ for a resource included in another\n   resource (e.g., embedded images, style\
    \ sheets, frames), clients MAY\n   treat an AUTH-REQUESTED status the same way\
    \ they would treat an\n   UNAUTHENTICATED status.  In other words, the client\
    \ MAY ignore the\n   server's request to start authentication with new credentials\
    \ via\n   sub-requests.\n"
- title: 10.2.  State Machine for the Client (Informative)
  contents:
  - "10.2.  State Machine for the Client (Informative)\n   The following state machine\
    \ describes the possible request-response\n   sequences derived from the above\
    \ normative rules.  If implementers\n   are not quite sure of the security consequences\
    \ of the above rules,\n   we strongly advise that the decision procedure below\
    \ be followed.  In\n   particular, clients SHOULD NOT accept \"normal responses\"\
    \ unless\n   explicitly allowed in the rules.  The labels in the steps below are\n\
    \   for informational purposes only.  Action entries within each step are\n  \
    \ checked in top-to-bottom order, and the first clause satisfied is to\n   be\
    \ followed.\n   Step 1 (step_new_request):\n       If the client software needs\
    \ to access a new Web resource, check\n       to see whether the resource is expected\
    \ to be inside some\n       authentication realm for which the user has already\
    \ been\n       authenticated via the Mutual authentication scheme.  If yes,\n\
    \       go to Step 2.  Otherwise, go to Step 5.\n   Step 2:\n       Check to see\
    \ whether there is an available sid for the expected\n       authentication realm.\
    \  If there is one, go to Step 3.  Otherwise,\n       go to Step 4.\n   Step 3\
    \ (step_send_vfy_1):\n       Send a req-VFY-C request.\n       *  If a 401-INIT\
    \ message is received with a different\n          authentication realm than expected,\
    \ go to Step 6.\n       *  If a 401-STALE message is received, go to Step 9.\n\
    \       *  If a 401-INIT message is received, go to Step 13.\n       *  If a 200-VFY-S\
    \ message is received, go to Step 14.\n       *  If a \"normal response\" is received,\
    \ go to Step 11.\n   Step 4 (step_send_kex1_1):\n       Send a req-KEX-C1 request.\n\
    \       *  If a 401-INIT message is received with a different\n          authentication\
    \ realm than expected, go to Step 6.\n       *  If a 401-KEX-S1 message is received,\
    \ go to Step 10.\n       *  If a 401-INIT message is received with the same authentication\n\
    \          realm, go to Step 13 (see Note 1).\n       *  If a \"normal response\"\
    \ is received, go to Step 11.\n   Step 5 (step_send_normal_1):\n       Send a\
    \ request without any mutual-authentication headers.\n       *  If a 401-INIT\
    \ message is received, go to Step 6.\n       *  If a \"normal response\" is received,\
    \ go to Step 11.\n   Step 6 (step_rcvd_init):\n       Check to see whether the\
    \ user's password for the requested\n       authentication realm is known.  If\
    \ yes, go to Step 7.  Otherwise,\n       go to Step 12.\n   Step 7:\n       Check\
    \ to see whether there is an available sid for the expected\n       authentication\
    \ realm.  If there is one, go to Step 8.  Otherwise,\n       go to Step 9.\n \
    \  Step 8 (step_send_vfy):\n       Send a req-VFY-C request.\n       *  If a 401-STALE\
    \ message is received, go to Step 9.\n       *  If a 401-INIT message is received,\
    \ go to Step 13.\n       *  If a 200-VFY-S message is received, go to Step 14.\n\
    \   Step 9 (step_send_kex1):\n       Send a req-KEX-C1 request.\n       *  If\
    \ a 401-KEX-S1 message is received, go to Step 10.\n       *  If a 401-INIT message\
    \ is received, go to Step 13 (see Note 1).\n   Step 10 (step_rcvd_kex1):\n   \
    \    Send a req-VFY-C request.\n       *  If a 401-INIT message is received, go\
    \ to Step 13.\n       *  If a 200-VFY-S message is received, go to Step 14.\n\
    \   Step 11 (step_rcvd_normal):\n       The requested resource is out of the authenticated\
    \ area.  The\n       client will be in the \"UNAUTHENTICATED\" status.  If the\
    \ response\n       contains a request for authentication other than Mutual\n \
    \      authentication, it MAY be handled normally.\n   Step 12 (step_rcvd_init_unknown):\n\
    \       The requested resource requires Mutual authentication, and the\n     \
    \  user is not yet authenticated.  The client will be in the\n       \"AUTH-REQUESTED\"\
    \ status; it is RECOMMENDED that the client\n       process the content sent from\
    \ the server and ask the user for a\n       username and password.  When those\
    \ are supplied by the user,\n       go to Step 9.\n   Step 13 (step_rcvd_init_failed):\n\
    \       The authentication failed for some reason, possibly because the\n    \
    \   password or username is invalid for the authenticated resource.\n       Forget\
    \ the user-provided credentials for the authentication\n       realm, and go to\
    \ Step 12.\n   Step 14 (step_rcvd_vfy):\n       The received message is the 200-VFY-S\
    \ message, which always\n       contains a \"vks\" field.  Check the validity\
    \ of the received VK_s\n       value.  If it is equal to the expected value, then\
    \ the mutual\n       authentication succeeded.  The client will be in the\n  \
    \     \"AUTH-SUCCEED\" status.\n       An unexpected value is interpreted as a\
    \ fatal communication\n       error.\n       If a user explicitly asks to log\
    \ out (via the user interface),\n       the client MUST forget the user's password,\
    \ go to Step 5, and\n       reload the current resource without an authentication\
    \ header.\n   Note 1:  These transitions MAY be accepted by clients, but it is\n\
    \       NOT RECOMMENDED that servers initiate them.\n   Figure 5 shows an informative\
    \ diagram of the client state.\n         ===========                         \
    \         -(11)------------\n         NEW REQUEST                            \
    \     ( UNAUTHENTICATED )\n         ===========                              \
    \    -----------------\n              |                                      \
    \        ^ normal\n              v                                           \
    \   | response\n   +(1)-------------------+ NO                         +(5)----------+\n\
    \   | The requested URI    |--------------------------->| send normal |\n   |\
    \ known to be auth'ed? |                            |   request   |\n   +----------------------+\
    \                            +-------------+\n          YES |   401-INIT     \
    \                       401-INIT|\n              |   with a different realm  \
    \                    |\n              |          -----------------------------------.\
    \ |\n              |         /                                   v v\n       \
    \       |        |       -(12)------------    NO  +(6)--------+\n            \
    \  |        |      ( AUTH-REQUESTED  )<------| user/pass |\n              |  \
    \      |       -----------------        |   known?  |\n              |       \
    \ |                                +-----------+\n              |        |   \
    \                                   |YES\n              v        |           \
    \                           v\n        +(2)--------+  |                      \
    \          +(7)--------+\n        | session   |  |                           \
    \     | session   | NO\n    NO /| available?|  |                             \
    \   | available?|\\\n      / +-----------+  |                                +-----------+\
    \ |\n     /        |YES     |                                      |YES    |\n\
    \    |         |       /|                                      |       |\n   \
    \ |         v      / |  401-                   401-         v       |\n    | \
    \  +(3)--------+  |  INIT --(13)----------  INIT   +(8)--------+ |\n    |   |\
    \   send    |--+----->/ AUTH-REQUESTED \\<-------|   send    | |\n    |  /| req-VFY-C\
    \ |  |      \\forget password /        | req-VFY-C | |\n     \\/ +-----------+\
    \ /        ----------------        /+-----------+ |\n     /\\           \\ \\\
    /                 ^ 401-INIT     |     |401-     |\n    |  ------      \\/\\ \
    \ 401-STALE      |              |     | STALE  /\n    |        \\     /\\ -----------------+--------------+---.\
    \ |       /\n    |         |   /  \\                 |              |   | |  \
    \    /\n    |         v  /    | 401-           |       401-   |   v v     v\n\
    \    |   +(4)--------+ | KEX-S1   +(10)-------+ KEX-S1 | +(9)--------+\n    |\
    \   |   send    |-|--------->|   send    |<-------+-|   send    |\n    | --| req-KEX-C1|\
    \ |          | req-VFY-C |        | | req-KEX-C1|\n    |/  +-----------+ |   \
    \       +-----------+        | +-----------+\n    |                 |200-VFY-S\
    \      |      200-VFY-S|       ^\n    |normal           |               |200-VFY-S\
    \     /        |\n    |response         |               v             / ==================\n\
    \    v                  \\         -(14)---------    /  USER/PASS INPUTTED\n \
    \   -(11)------------   ------->( AUTH-SUCCEED )<--   ==================\n   (\
    \ UNAUTHENTICATED )           --------------\n    -----------------\n        \
    \            Figure 5: State Diagram for Clients\n"
- title: 11.  Decision Procedure for Servers
  contents:
  - "11.  Decision Procedure for Servers\n   Each server SHOULD have a table of session\
    \ states.  This table need\n   not be persistent over the long term; it MAY be\
    \ cleared upon server\n   restart, reboot, or for other reasons.  Each entry in\
    \ the table\n   SHOULD contain at least the following information:\n   o  The\
    \ session identifier, which is the value of the \"sid\" parameter.\n   o  The\
    \ algorithm used.\n   o  The authentication realm.\n   o  The state of the protocol:\
    \ one of \"key exchanging\",\n      \"authenticated\", \"rejected\", or \"inactive\"\
    .\n   o  The username received from the client.\n   o  A boolean flag indicating\
    \ whether or not the session is fake.\n   o  When the state is \"key exchanging\"\
    , the values of K_c1 and S_s1.\n   o  When the state is \"authenticated\", the\
    \ following information:\n      *  The value of the session secret (z).\n    \
    \  *  The largest nc received from the client (largest-nc).\n      *  For each\
    \ possible nc value between (largest-nc - nc-window + 1)\n         and max_nc,\
    \ a boolean flag indicating whether or not a request\n         with the corresponding\
    \ nc has been received.\n   The table MAY contain other information.\n   Servers\
    \ SHOULD respond to the client requests according to the\n   following procedure\
    \ (see Note 1 below regarding 401-INIT messages\n   with a plus sign):\n   o \
    \ When the server receives a \"normal request\":\n      *  If the requested resource\
    \ is not protected by the Mutual\n         authentication, send a \"normal response\"\
    .\n      *  If the resource is protected by the Mutual authentication, send\n\
    \         a 401-INIT response.\n   o  When the server receives a req-KEX-C1 request:\n\
    \      *  If the requested resource is not protected by the Mutual\n         authentication,\
    \ send a \"normal response\".\n      *  If the authentication realm specified\
    \ in the req-KEX-C1 request\n         is not the expected realm, send a 401-INIT\
    \ response.\n      *  If the server cannot validate the parameter \"kc1\", send\
    \ a\n         401-INIT (+) response.\n      *  If the received username is either\
    \ invalid, unknown, or\n         unacceptable, create a new session, mark it as\
    \ a \"fake\"\n         session, compute a random value as K_s1, and send a fake\n\
    \         401-KEX-S1 response (see Note 2).\n      *  Otherwise, create a new\
    \ session, compute K_s1, and send a\n         401-KEX-S1 response.  The created\
    \ session is marked as not\n         fake, and its largest-nc value is initialized\
    \ to zero.\n      The created session is in the \"key exchanging\" state.\n  \
    \ o  When the server receives a req-VFY-C request:\n      *  If the requested\
    \ resource is not protected by the Mutual\n         authentication, send a \"\
    normal response\".\n      *  If the authentication realm specified in the req-VFY-C\
    \ request\n         is not the expected realm, send a 401-INIT response.\n   \
    \   If none of the above holds true, the server will look up the\n      session\
    \ corresponding to the received sid and the authentication\n      realm.\n   \
    \   *  If the session corresponding to the received sid could not be\n       \
    \  found or it is in the \"inactive\" state, send a 401-STALE\n         response.\n\
    \      *  If the session is in the \"rejected\" state, send either a\n       \
    \  401-INIT (+) response or a 401-STALE message.\n      *  If the nc value in\
    \ the request is larger than the \"nc-max\"\n         parameter sent from the\
    \ server or it is not larger than\n         (largest-nc - nc-window) (when in\
    \ the \"authenticated\" state),\n         the server MAY (but is not REQUIRED\
    \ to; see Note 3) send a\n         401-STALE message.  The session is changed\
    \ to the \"inactive\"\n         state if the 401-STALE message was sent.\n   \
    \   *  If the session is in the \"authenticated\" state and the request\n    \
    \     has an nc value that was previously received from the client,\n        \
    \ send a 401-STALE message.  The session is changed to the\n         \"inactive\"\
    \ state.\n      *  If the session is a \"fake\" session or the received vkc is\n\
    \         incorrect, then send a 401-INIT (+) response.  If the session\n    \
    \     is in the \"key exchanging\" state, it MUST be changed to the\n        \
    \ \"rejected\" state; otherwise, it MAY be either changed to the\n         \"\
    rejected\" state or kept in the previous state.\n      *  Otherwise, send a 200-VFY-S\
    \ response.  If the session was in\n         the \"key exchanging\" state, the\
    \ session SHOULD be changed to\n         the \"authenticated\" state.  The maximum\
    \ nc and nc flags of the\n         state MUST be updated appropriately.\n   At\
    \ any time, the server MAY change any state entries with both the\n   \"rejected\"\
    \ and \"authenticated\" states to the \"inactive\" state and MAY\n   discard any\
    \ \"inactive\" states from the table.  Entries with the \"key\n   exchanging\"\
    \ state SHOULD be kept unless there is an emergency\n   situation such as a server\
    \ reboot or a table capacity overflow.\n   Note 1: In relation to, and following\
    \ the specification of, the\n   optional authentication defined in [RFC8053],\
    \ the 401-INIT messages\n   marked with plus signs cannot be replaced with a successful\
    \ response\n   with an Optional-WWW-Authenticate header.  Every other 401-INIT\
    \ can\n   be a response with an Optional-WWW-Authenticate header.\n   Note 2:\
    \ The server SHOULD NOT send a 401-INIT response in this case,\n   because it\
    \ will leak the information to the client that the specified\n   username will\
    \ not be accepted.  Instead, postpone it until the\n   response to the next req-VFY-C\
    \ request.\n   Note 3: If the request is not rejected in this clause, the server\n\
    \   will be required, in the next step, to determine whether the same nc\n   value\
    \ was previously received from the client.  If that is\n   impossible, the server\
    \ MUST send a 401-STALE response in this step.\n   If the server does not remember\
    \ the whole history of the nc values\n   received from the client, the server\
    \ MUST send a 401-STALE message in\n   this clause.\n"
- title: 12.  Authentication Algorithms
  contents:
  - "12.  Authentication Algorithms\n   Cryptographic authentication algorithms that\
    \ are used with this\n   protocol will be defined separately.  The algorithm definition\
    \ MUST\n   at least provide definitions for the following functions:\n   o  The\
    \ server-side authentication credential J, derived from the\n      client-side\
    \ authentication credential pi.\n   o  Key exchange values K_c1, K_s1 (exchanged\
    \ on the wire) and\n      S_c1, S_s1 (kept secret in each peer).\n   o  Shared\
    \ session secret (z), to be computed by both server and\n      client.\n   o \
    \ A hash function H to be used with the protocol, along with its\n      output\
    \ size hSize.\n   o  The value nIterPi, the number of iterations for the key derivation\n\
    \      operation.\n   Specifications for cryptographic algorithms used with this\
    \ framework\n   MUST specify whether those algorithms will (1) use the default\n\
    \   functions defined below for values pi, VK_c, and VK_s or (2) define\n   their\
    \ own comparable functions.\n   All algorithms used with this protocol SHOULD\
    \ provide secure mutual\n   authentication between clients and servers and generate\
    \ a\n   cryptographically strong shared secret value (z) that is equally\n   strong\
    \ or stronger than the hash function H.  If any passwords (or\n   passphrases\
    \ or any equivalents, i.e., weak secrets) are involved,\n   these SHOULD NOT be\
    \ guessable from any data transmitted in the\n   protocol, even if an attacker\
    \ (either an eavesdropper or an active\n   server) knows the possible thoroughly\
    \ searchable candidate list of\n   passwords.  Furthermore, it is RECOMMENDED\
    \ that the function J for\n   deriving the server-side authentication credential\
    \ J(pi) be one-way,\n   if possible, so that pi cannot be easily computed from\
    \ J(pi).\n"
- title: 12.1.  Support Functions and Notations
  contents:
  - "12.1.  Support Functions and Notations\n   In this section, we define several\
    \ support functions and notations to\n   be shared by several algorithm definitions.\n\
    \   The integers in the specification are in decimal, or in hexadecimal\n   when\
    \ prefixed with \"0x\".\n   The function octet(i) generates an octet string containing\
    \ a single\n   octet of value i.  The operator \"|\", when applied to octet strings,\n\
    \   denotes the concatenation of two operands.\n   The function VI encodes natural\
    \ numbers into octet strings in the\n   following manner: numbers are represented\
    \ as big-endian radix-128\n   strings, where each digit is represented by an octet\
    \ within the range\n   0x80-0xff, except for the last digit, which is represented\
    \ by an\n   octet within the range 0x00-0x7f.  The first octet MUST NOT be 0x80.\n\
    \   For example, VI(i) = octet(i) for i < 128, and\n   VI(i) = octet(0x80 + (i\
    \ >> 7)) | octet(i & 127) for 128 <= i < 16384.\n   This encoding is the same\
    \ as the encoding used for the subcomponents\n   of object identifiers in ASN.1\
    \ encoding [ITU.X690.2015] and is\n   available as a \"w\" conversion in the \"\
    pack\" function of several\n   scripting languages.\n   The function VS encodes\
    \ a variable-length octet string into a\n   uniquely decoded, self-delimited octet\
    \ string in the following\n   manner:\n   VS(s) = VI(length(s)) | s\n   where\
    \ length(s) is a number of octets (not characters) in s.\n   Some examples:\n\
    \      VI(0) = \"\\000\" (in C string notation)\n      VI(100) = \"d\"\n     \
    \ VI(10000) = \"\\316\\020\"\n      VI(1000000) = \"\\275\\204@\"\n      VS(\"\
    \") = \"\\000\"\n      VS(\"Tea\") = \"\\003Tea\"\n      VS(\"Caf<e acute>\" [in\
    \ UTF-8]) = \"\\005Caf\\303\\251\"\n      VS([10000 \"a\"s]) = \"\\316\\020aaaaa...\"\
    \ (10002 octets)\n   (Note: Unlike the colon-separated format used in the Basic\
    \ and Digest\n   HTTP authentication schemes, the string generated by a concatenation\n\
    \   of the VS-encoded strings will be unique, regardless of the\n   characters\
    \ included in the strings to be encoded.)\n   The function OCTETS converts an\
    \ integer into the corresponding\n   radix-256 big-endian octet string having\
    \ its natural length.  See\n   Section 3.2.3 for the definition of \"natural length\"\
    .\n   The function INT converts an octet string into a natural number,\n   where\
    \ the input string is treated as being in radix-256 big-endian\n   notation. \
    \ The identity INT(OCTETS(n)) = n always holds for any\n   natural number n.\n"
- title: 12.2.  Default Functions for Algorithms
  contents:
  - "12.2.  Default Functions for Algorithms\n   The functions defined in this section\
    \ are common default functions\n   among authentication algorithms.\n   The client-side\
    \ password-based (credential) pi used by this\n   authentication is a natural\
    \ number derived in the following manner:\n      pi = INT(PBKDF2(HMAC_H, password,\
    \ VS(algorithm) | VS(auth-scope) |\n      VS(realm) | VS(username), nIterPi, hSize\
    \ / 8))\n   where\n   o  PBKDF2 is the password-based key derivation function\
    \ defined in\n      [RFC8018],\n   o  HMAC_H is the Hashed Message Authentication\
    \ Code (HMAC) function,\n      defined in [RFC2104], composed from the hash function\
    \ H, and\n   o  hSize is the output size of hash H in bits.\n   The values of\
    \ algorithm, realm, and auth-scope are taken from the\n   values contained in\
    \ the 401-INIT message.  If the password comes from\n   user input, it SHOULD\
    \ first be prepared according to the method\n   presented in Section 9.  Then,\
    \ the password SHALL be encoded as a\n   UTF-8 string.\n   The values VK_c and\
    \ VK_s are derived via the following equations:\n      VK_c = INT(H(octet(4) |\
    \ OCTETS(K_c1) | OCTETS(K_s1) | OCTETS(z) |\n      VI(nc) | VS(vh)))\n      VK_s\
    \ = INT(H(octet(3) | OCTETS(K_c1) | OCTETS(K_s1) | OCTETS(z) |\n      VI(nc) |\
    \ VS(vh)))\n"
- title: 13.  Application Channel Binding
  contents:
  - "13.  Application Channel Binding\n   Applications and upper-layer communication\
    \ protocols may need\n   authentication binding to the HTTP-layer authenticated\
    \ user.  Such\n   applications MAY use the following values as a standard shared\n\
    \   secret.\n   These values are parameterized with an optional octet string (t),\n\
    \   which may be arbitrarily chosen by each application or protocol.  If\n   there\
    \ is no appropriate value to be specified, use an empty string\n   for t.\n  \
    \ For applications requiring binding to either an authenticated user or\n   a\
    \ shared-key session (to ensure that the requesting client is\n   authenticated),\
    \ the following value b_1 MAY be used:\n      b_1 = H(H(octet(6) | OCTETS(K_c1)\
    \ | OCTETS(K_s1) | OCTETS(z) |\n      VI(0) | VS(vh)) | VS(t))\n   For applications\
    \ requiring binding to a specific request (to ensure\n   that the payload data\
    \ is generated for the exact HTTP request), the\n   following value b_2 MAY be\
    \ used:\n      b_2 = H(H(octet(7) | OCTETS(K_c1) | OCTETS(K_s1) | OCTETS(z) |\n\
    \      VI(nc) | VS(vh)) | VS(t))\n   Note: Channel bindings to lower-layer transports\
    \ (TCP and TLS) are\n   defined in Section 7.\n"
- title: 14.  Application for Proxy Authentication
  contents:
  - "14.  Application for Proxy Authentication\n   The authentication scheme defined\
    \ in the previous sections can be\n   applied (with modifications) to proxy authentication.\
    \  In such cases,\n   the following alterations MUST be applied:\n   o  The 407\
    \ (Proxy Authentication Required) status code is to be sent\n      and recognized\
    \ in places where the 401 status code is used,\n   o  The Proxy-Authenticate header\
    \ is to be used in places where the\n      WWW-Authenticate header is used,\n\
    \   o  The Proxy-Authorization header is to be used in places where the\n    \
    \  Authorization header is used,\n   o  The Proxy-Authentication-Info header is\
    \ to be used in places where\n      the Authentication-Info header is used,\n\
    \   o  The \"auth-scope\" parameter is fixed to the hostname of the proxy,\n \
    \     which means that it covers all requests processed by the specific\n    \
    \  proxy,\n   o  The limitation for the paths contained in the \"path\" parameter\
    \ of\n      401-KEX-S1 messages is disregarded,\n   o  The omission of the \"\
    path\" parameter of 401-KEX-S1 messages means\n      that the authentication realm\
    \ will potentially cover all requests\n      processed by the proxy,\n   o  The\
    \ scheme, hostname, and port of the proxy are used for host\n      validation\
    \ tokens, and\n   o  Authentication extensions defined in [RFC8053] are not applicable.\n"
- title: 15.  Methods to Extend This Protocol
  contents:
  - "15.  Methods to Extend This Protocol\n   If a private extension to this protocol\
    \ is implemented, it MUST use\n   the extension-tokens defined in Section 3 to\
    \ avoid conflicts with\n   this protocol and other extensions.  (Standardized\
    \ extensions, as\n   well as extensions that are in the process of being standardized,\
    \ MAY\n   use either bare-tokens or extension-tokens.)\n   Specifications defining\
    \ authentication algorithms MAY use other\n   representations for the parameters\
    \ \"kc1\", \"ks1\", \"vkc\", and \"vks\";\n   replace those parameter names; and/or\
    \ add parameters to the messages\n   containing those parameters in supplemental\
    \ specifications, provided\n   that syntactic and semantic requirements in Section\
    \ 3 of this\n   document, [RFC7230], and [RFC7235] are satisfied.  Any parameters\n\
    \   starting with \"kc\", \"ks\", \"vkc\", or \"vks\" and followed by decimal\n\
    \   natural numbers (e.g., kc2, ks0, vkc1, vks3) are reserved for this\n   purpose.\
    \  If those specifications use names other than those\n   mentioned above, it\
    \ is RECOMMENDED that extension-tokens be used to\n   avoid any parameter-name\
    \ conflicts with future extensions to this\n   protocol.\n   Extension-tokens\
    \ MAY be freely used for any non-standard, private,\n   and/or experimental uses\
    \ for those parameters provided that the\n   domain part in the token is used\
    \ in the manner defined in Section 3.\n"
- title: 16.  IANA Considerations
  contents:
  - '16.  IANA Considerations

    '
- title: 16.1.  Addition to HTTP Authentication Schemes Registry
  contents:
  - "16.1.  Addition to HTTP Authentication Schemes Registry\n   IANA has added the\
    \ following entry to the \"HTTP Authentication\n   Schemes\" registry:\n   o \
    \ Authentication Scheme Name: Mutual\n   o  Reference: RFC 8120\n"
- title: 16.2.  Registry for Authentication Algorithms
  contents:
  - "16.2.  Registry for Authentication Algorithms\n   This document establishes the\
    \ \"HTTP Mutual Authentication Algorithms\"\n   registry.  The registry manages\
    \ case-insensitive ASCII strings.  The\n   strings MUST follow the extensive-token\
    \ syntax defined in Section 3.\n   When bare-tokens are used for the authentication-algorithm\
    \ parameter,\n   they MUST be allocated by IANA.  To acquire registered tokens,\
    \ the\n   usage of such tokens MUST be reviewed by a Designated Expert, as\n \
    \  outlined in [RFC5226].\n   Registrations for an authentication algorithm are\
    \ required to include\n   descriptions of the authentication algorithms.  Reviewers\
    \ assigned by\n   the IESG are advised to examine minimum security requirements\
    \ and\n   consistency of the key exchange algorithm descriptions.\n   It is advised\
    \ that new registrations provide the following\n   information:\n   o  Token:\
    \ A token used in HTTP headers for identifying the algorithm.\n   o  Description:\
    \ A brief description of the algorithm.\n   o  Specification: A reference for\
    \ a specification defining the\n      algorithm.\n   [RFC8121] defines the initial\
    \ contents of this registry.\n"
- title: 16.3.  Registry for Validation Methods
  contents:
  - "16.3.  Registry for Validation Methods\n   This document establishes the \"HTTP\
    \ Mutual Authentication Host\n   Validation Methods\" registry.  The registry\
    \ manages case-insensitive\n   ASCII strings.  The strings MUST follow the extensive-token\
    \ syntax\n   defined in Section 3.\n   When bare-tokens are used for the validation\
    \ parameter, they MUST be\n   allocated by IANA.  To acquire registered tokens,\
    \ the usage of such\n   tokens MUST be reviewed by a Designated Expert, as outlined\
    \ in\n   [RFC5226].\n   Registrations for a validation method are required to\
    \ include a\n   description of the validation method.  Reviewers assigned by the\
    \ IESG\n   are advised to examine its use-case requirements and any security\n\
    \   consequences related to its introduction.\n   It is advised that new registrations\
    \ provide the following\n   information:\n   o  Token: A token used in HTTP headers\
    \ for identifying the method.\n   o  Description: A brief description of the method.\n\
    \   o  Specification: A reference for a specification defining the\n      method.\n\
    \   The initial contents of this registry are as follows:\n   +----------------------+------------------------+----------------+\n\
    \   | Token                | Description            | Reference      |\n   +----------------------+------------------------+----------------+\n\
    \   | host                 | Hostname verification  | RFC 8120,      |\n   | \
    \                     | only                   | Section 7      |\n   |      \
    \                |                        |                |\n   | tls-server-end-point\
    \ | TLS certificate-based  | RFC 8120,      |\n   |                      |   \
    \                     | Section 7      |\n   |                      |        \
    \                |                |\n   | tls-unique           | TLS unique key-based\
    \   | RFC 8120,      |\n   |                      |                        | Section\
    \ 7      |\n   +----------------------+------------------------+----------------+\n"
- title: 17.  Security Considerations
  contents:
  - '17.  Security Considerations

    '
- title: 17.1.  Security Properties
  contents:
  - "17.1.  Security Properties\n   o  The protocol is secure against passive eavesdropping\
    \ and replay\n      attacks.  However, the protocol relies on transport security\n\
    \      (including DNS integrity) for data secrecy and integrity.\n      HTTP/TLS\
    \ SHOULD be used where transport security is not assured\n      and/or data confidentiality\
    \ is important.\n   o  When used with HTTP/TLS, if TLS server certificates are\
    \ reliably\n      verified, the protocol provides true protection against active\n\
    \      man-in-the-middle attacks.\n   o  Even if the server certificate is not\
    \ used or is unreliable, the\n      protocol provides protection against active\
    \ man-in-the-middle\n      attacks for each HTTP request/response pair.  However,\
    \ in such\n      cases, JavaScript or similar scripts that are not authenticated\
    \ by\n      this authentication mechanism can affect mutually authenticated\n\
    \      contents to circumvent the protection.  This is why this protocol\n   \
    \   stipulates that valid TLS server certificates MUST be shown from\n      the\
    \ server to the client (Section 7).\n"
- title: 17.2.  Secrecy of Credentials
  contents:
  - "17.2.  Secrecy of Credentials\n   The client-side password credential MUST always\
    \ be kept secret and\n   SHOULD NOT be used for any other (possibly insecure)\
    \ authentication\n   purposes.  Loss of control of the credential will directly\
    \ affect the\n   control of the corresponding server-side account.\n   The use\
    \ of a client-side credential with THIS authentication scheme\n   is always safe,\
    \ even if the connected server peer is not trustworthy\n   (e.g., a phishing scenario).\
    \  However, if it is used with other\n   authentication schemes (such as Web forms)\
    \ and the recipient is\n   rogue, the result will be obvious.\n   It is also important\
    \ that the server-side password credential (J) be\n   kept secret.  If it is stolen\
    \ and the client's choice of password is\n   not strong, anyone who is aware of\
    \ the server-side password\n   credential can employ an offline dictionary attack\
    \ to search for the\n   client's password.  However, if the client has chosen\
    \ a strong\n   password so that an attacker cannot guess the client's password\
    \ from\n   dictionary candidates, the client is still well protected from any\n\
    \   attacks.\n   The shared session secret (z) MUST be kept secret inside the\n\
    \   server/client software; if it is lost and the session is still\n   active,\
    \ session hijacking will result.  After the session expires,\n   the key is of\
    \ no value to attackers.\n"
- title: 17.3.  Denial-of-Service Attacks on Servers
  contents:
  - "17.3.  Denial-of-Service Attacks on Servers\n   The protocol requires a server-side\
    \ table of active sessions, which\n   may become a critical point for server resource\
    \ consumption.  For\n   proper operation, the protocol requires that at least\
    \ one key\n   verification request be processed for each session identifier. \
    \ After\n   that, servers MAY discard sessions internally at any time without\n\
    \   causing any operational problems for clients.  Clients will then\n   silently\
    \ re-establish a new session.\n   However, if a malicious client sends too many\
    \ requests for key\n   exchanges (req-KEX-C1 messages) only, resource starvation\
    \ might\n   occur.  In such critical situations, servers MAY discard any kind\
    \ of\n   existing sessions, regardless of their statuses.  One way to mitigate\n\
    \   such attacks is that servers MAY set number and time limits for\n   unverified,\
    \ pending key exchange requests (in the \"key exchanging\"\n   state).\n   This\
    \ is a common weakness of authentication protocols with almost any\n   kind of\
    \ negotiations or states, including the Digest authentication\n   scheme and most\
    \ cookie-based authentication implementations.\n   However, regarding resource\
    \ consumption, the situation for the\n   Mutual authentication scheme is slightly\
    \ better than that for Digest,\n   because HTTP requests without any kind of authentication\
    \ requests\n   will not generate any kind of sessions.  Session identifiers are\
    \ only\n   generated after a client starts a key negotiation, so that simple\n\
    \   clients such as Web crawlers will not accidentally consume\n   server-side\
    \ resources for session management.\n"
- title: 17.3.1.  Online Active Password Attacks
  contents:
  - "17.3.1.  Online Active Password Attacks\n   Although the protocol provides very\
    \ strong protection against offline\n   dictionary attacks from eavesdropped traffic,\
    \ the protocol, by its\n   nature, cannot prevent active password attacks in which\
    \ an attacker\n   sends so many authentication trial requests for every possible\n\
    \   password.\n   Possible countermeasures for preventing such attacks may be\
    \ the\n   rate-limiting of password authentication trials, statistics-based\n\
    \   intrusion-detection measures, or similar protection schemes.  If the\n   server\
    \ operators assume that the passwords of users are not strong\n   enough, it may\
    \ be desirable to introduce such ad hoc countermeasures.\n"
- title: 17.4.  Communicating the Status of Mutual Authentication with Users
  contents:
  - "17.4.  Communicating the Status of Mutual Authentication with Users\n   This\
    \ protocol is designed with two goals in mind.  The first goal is\n   simply to\
    \ provide a secure alternative to existing Basic and Digest\n   authentication\
    \ schemes.  The second goal is to provide users with a\n   way to detect forged\
    \ rogue servers imitating (e.g., via a phishing\n   attack) a user's registered\
    \ account on a server.\n   For this protocol to effectively work as a countermeasure\
    \ against\n   such attacks, it is very important that end users of clients be\n\
    \   notified of the result of mutual authentication performed by this\n   protocol,\
    \ especially the three states \"AUTH-SUCCEED\",\n   \"AUTH-REQUIRED\", and \"\
    UNAUTHENTICATED\" as defined in Section 10.  The\n   design of secure user interfaces\
    \ for HTTP interactive clients is out\n   of scope for this document, but if possible,\
    \ having some kind of UI\n   indication for the three states above will be desirable\
    \ from the\n   standpoint of providing user security.\n   Of course, in such cases,\
    \ the user interfaces for requesting\n   passwords for this authentication shall\
    \ be protected against\n   imitation (for example, by other insecure password\
    \ input fields, such\n   as forms).  If the passwords are known to malicious attackers\
    \ outside\n   of the protocol, the protocol cannot work as an effective security\n\
    \   measure.\n"
- title: 17.5.  Implementation Considerations
  contents:
  - "17.5.  Implementation Considerations\n   o  To securely implement the protocol,\
    \ the Authentication-Info\n      headers in the 200-VFY-S messages MUST always\
    \ be validated by the\n      client.  If the validation fails, the client MUST\
    \ NOT process any\n      content sent with the message, including other headers\
    \ and the\n      body part.  Non-compliance with this requirement will allow\n\
    \      phishing attacks.\n   o  For HTTP/TLS communications, when a Web form is\
    \ submitted from\n      mutually authenticated pages via the \"tls-server-end-point\"\
    \n      validation method to a URI that is protected by the same realm\n     \
    \ (so indicated by the \"path\" parameter), if the server certificate\n      has\
    \ been changed since the pages were received, it is RECOMMENDED\n      that the\
    \ peer be revalidated using a req-KEX-C1 message with an\n      \"Expect: 100-continue\"\
    \ header.  The same applies when the page is\n      received via the \"tls-unique\"\
    \ validation method and when the TLS\n      session has expired.\n   o  For better\
    \ protection against possible password database stealing,\n      server-side storage\
    \ of user passwords should contain the values\n      encrypted by the one-way\
    \ function J(pi) instead of the real\n      passwords or those hashed by pi.\n\
    \   o  If TLS 1.2 [RFC5246] is used for underlying HTTP/TLS\n      communications,\
    \ follow the best practices specified in [RFC7525].\n"
- title: 17.6.  Usage Considerations
  contents:
  - "17.6.  Usage Considerations\n   o  The usernames inputted by a user may be sent\
    \ automatically to any\n      servers sharing the same auth-scope.  This means\
    \ that when a\n      host-type auth-scope is used for authentication on an HTTPS\
    \ site\n      and an HTTP server on the same host requests the Mutual\n      authentication\
    \ scheme within the same realm, the client will send\n      the username in clear\
    \ text.  If usernames have to be kept secret\n      (protected from eavesdroppers),\
    \ the server must use the\n      full-scheme-type \"auth-scope\" parameter and\
    \ HTTPS.  Passwords, on\n      the other hand, are not exposed to eavesdroppers,\
    \ even in HTTP\n      requests.\n   o  If the server provides several ways to\
    \ store server-side password\n      secrets in the password database, it is desirable,\
    \ for purposes of\n      better security, to store the values encrypted by using\
    \ the\n      one-way function J(pi) instead of the real passwords or those\n \
    \     hashed by pi.\n"
- title: 18.  References
  contents:
  - '18.  References

    '
- title: 18.1.  Normative References
  contents:
  - "18.1.  Normative References\n   [RFC2104]  Krawczyk, H., Bellare, M., and R.\
    \ Canetti, \"HMAC:\n              Keyed-Hashing for Message Authentication\",\
    \ RFC 2104,\n              DOI 10.17487/RFC2104, February 1997,\n            \
    \  <http://www.rfc-editor.org/info/rfc2104>.\n   [RFC2119]  Bradner, S., \"Key\
    \ words for use in RFCs to Indicate\n              Requirement Levels\", BCP 14,\
    \ RFC 2119,\n              DOI 10.17487/RFC2119, March 1997,\n              <http://www.rfc-editor.org/info/rfc2119>.\n\
    \   [RFC3629]  Yergeau, F., \"UTF-8, a transformation format of\n            \
    \  ISO 10646\", STD 63, RFC 3629, DOI 10.17487/RFC3629,\n              November\
    \ 2003, <http://www.rfc-editor.org/info/rfc3629>.\n   [RFC4648]  Josefsson, S.,\
    \ \"The Base16, Base32, and Base64 Data\n              Encodings\", RFC 4648,\
    \ DOI 10.17487/RFC4648, October 2006,\n              <http://www.rfc-editor.org/info/rfc4648>.\n\
    \   [RFC5234]  Crocker, D., Ed., and P. Overell, \"Augmented BNF for\n       \
    \       Syntax Specifications: ABNF\", STD 68, RFC 5234,\n              DOI 10.17487/RFC5234,\
    \ January 2008,\n              <http://www.rfc-editor.org/info/rfc5234>.\n   [RFC5246]\
    \  Dierks, T. and E. Rescorla, \"The Transport Layer Security\n              (TLS)\
    \ Protocol Version 1.2\", RFC 5246,\n              DOI 10.17487/RFC5246, August\
    \ 2008,\n              <http://www.rfc-editor.org/info/rfc5246>.\n   [RFC5987]\
    \  Reschke, J., \"Character Set and Language Encoding for\n              Hypertext\
    \ Transfer Protocol (HTTP) Header Field\n              Parameters\", RFC 5987,\
    \ DOI 10.17487/RFC5987, August 2010,\n              <http://www.rfc-editor.org/info/rfc5987>.\n\
    \   [RFC7230]  Fielding, R., Ed., and J. Reschke, Ed., \"Hypertext\n         \
    \     Transfer Protocol (HTTP/1.1): Message Syntax and Routing\",\n          \
    \    RFC 7230, DOI 10.17487/RFC7230, June 2014,\n              <http://www.rfc-editor.org/info/rfc7230>.\n\
    \   [RFC7235]  Fielding, R., Ed., and J. Reschke, Ed., \"Hypertext\n         \
    \     Transfer Protocol (HTTP/1.1): Authentication\", RFC 7235,\n            \
    \  DOI 10.17487/RFC7235, June 2014,\n              <http://www.rfc-editor.org/info/rfc7235>.\n\
    \   [RFC7613]  Saint-Andre, P. and A. Melnikov, \"Preparation,\n             \
    \ Enforcement, and Comparison of Internationalized Strings\n              Representing\
    \ Usernames and Passwords\", RFC 7613,\n              DOI 10.17487/RFC7613, August\
    \ 2015,\n              <http://www.rfc-editor.org/info/rfc7613>.\n   [RFC7615]\
    \  Reschke, J., \"HTTP Authentication-Info and\n              Proxy-Authentication-Info\
    \ Response Header Fields\",\n              RFC 7615, DOI 10.17487/RFC7615, September\
    \ 2015,\n              <http://www.rfc-editor.org/info/rfc7615>.\n   [RFC8018]\
    \  Moriarty, K., Ed., Kaliski, B., and A. Rusch, \"PKCS #5:\n              Password-Based\
    \ Cryptography Specification Version 2.1\",\n              RFC 8018, DOI 10.17487/RFC8018,\
    \ January 2017,\n              <http://www.rfc-editor.org/info/rfc8018>.\n   [RFC8053]\
    \  Oiwa, Y., Watanabe, H., Takagi, H., Maeda, K., Hayashi,\n              T.,\
    \ and Y. Ioku, \"HTTP Authentication Extensions for\n              Interactive\
    \ Clients\", RFC 8053, DOI 10.17487/RFC8053,\n              January 2017, <http://www.rfc-editor.org/info/rfc8053>.\n\
    \   [Unicode]  The Unicode Consortium, \"The Unicode Standard\",\n           \
    \   <http://www.unicode.org/versions/latest/>.\n"
- title: 18.2.  Informative References
  contents:
  - "18.2.  Informative References\n   [ITU.X690.2015]\n              International\
    \ Telecommunication Union, \"Information\n              Technology - ASN.1 encoding\
    \ rules: Specification of Basic\n              Encoding Rules (BER), Canonical\
    \ Encoding Rules (CER) and\n              Distinguished Encoding Rules (DER)\"\
    , ITU-T Recommendation\n              X.690, ISO/IEC 8825-1, August 2015,\n  \
    \            <https://www.itu.int/rec/T-REC-X.690/>.\n   [RFC1939]  Myers, J.\
    \ and M. Rose, \"Post Office Protocol - Version 3\",\n              STD 53, RFC\
    \ 1939, DOI 10.17487/RFC1939, May 1996,\n              <http://www.rfc-editor.org/info/rfc1939>.\n\
    \   [RFC2818]  Rescorla, E., \"HTTP Over TLS\", RFC 2818,\n              DOI 10.17487/RFC2818,\
    \ May 2000,\n              <http://www.rfc-editor.org/info/rfc2818>.\n   [RFC5226]\
    \  Narten, T. and H. Alvestrand, \"Guidelines for Writing an\n              IANA\
    \ Considerations Section in RFCs\", BCP 26, RFC 5226,\n              DOI 10.17487/RFC5226,\
    \ May 2008,\n              <http://www.rfc-editor.org/info/rfc5226>.\n   [RFC5890]\
    \  Klensin, J., \"Internationalized Domain Names for\n              Applications\
    \ (IDNA): Definitions and Document Framework\",\n              RFC 5890, DOI 10.17487/RFC5890,\
    \ August 2010,\n              <http://www.rfc-editor.org/info/rfc5890>.\n   [RFC5929]\
    \  Altman, J., Williams, N., and L. Zhu, \"Channel Bindings\n              for\
    \ TLS\", RFC 5929, DOI 10.17487/RFC5929, July 2010,\n              <http://www.rfc-editor.org/info/rfc5929>.\n\
    \   [RFC6265]  Barth, A., \"HTTP State Management Mechanism\", RFC 6265,\n   \
    \           DOI 10.17487/RFC6265, April 2011,\n              <http://www.rfc-editor.org/info/rfc6265>.\n\
    \   [RFC6454]  Barth, A., \"The Web Origin Concept\", RFC 6454,\n            \
    \  DOI 10.17487/RFC6454, December 2011,\n              <http://www.rfc-editor.org/info/rfc6454>.\n\
    \   [RFC7231]  Fielding, R., Ed., and J. Reschke, Ed., \"Hypertext\n         \
    \     Transfer Protocol (HTTP/1.1): Semantics and Content\",\n              RFC\
    \ 7231, DOI 10.17487/RFC7231, June 2014,\n              <http://www.rfc-editor.org/info/rfc7231>.\n\
    \   [RFC7486]  Farrell, S., Hoffman, P., and M. Thomas, \"HTTP\n             \
    \ Origin-Bound Authentication (HOBA)\", RFC 7486,\n              DOI 10.17487/RFC7486,\
    \ March 2015,\n              <http://www.rfc-editor.org/info/rfc7486>.\n   [RFC7525]\
    \  Sheffer, Y., Holz, R., and P. Saint-Andre,\n              \"Recommendations\
    \ for Secure Use of Transport Layer\n              Security (TLS) and Datagram\
    \ Transport Layer Security\n              (DTLS)\", BCP 195, RFC 7525, DOI 10.17487/RFC7525,\n\
    \              May 2015, <http://www.rfc-editor.org/info/rfc7525>.\n   [RFC7616]\
    \  Shekh-Yusef, R., Ed., Ahrens, D., and S. Bremer, \"HTTP\n              Digest\
    \ Access Authentication\", RFC 7616,\n              DOI 10.17487/RFC7616, September\
    \ 2015,\n              <http://www.rfc-editor.org/info/rfc7616>.\n   [RFC7627]\
    \  Bhargavan, K., Ed., Delignat-Lavaud, A., Pironti, A.,\n              Langley,\
    \ A., and M. Ray, \"Transport Layer Security (TLS)\n              Session Hash\
    \ and Extended Master Secret Extension\",\n              RFC 7627, DOI 10.17487/RFC7627,\
    \ September 2015,\n              <http://www.rfc-editor.org/info/rfc7627>.\n \
    \  [RFC8121]  Oiwa, Y., Watanabe, H., Takagi, H., Maeda, K., Hayashi,\n      \
    \        T., and Y. Ioku, \"Mutual Authentication Protocol for HTTP:\n       \
    \       Cryptographic Algorithms Based on the Key Agreement\n              Mechanism\
    \ 3 (KAM3)\", RFC 8121, DOI 10.17487/RFC8121,\n              April 2017, <http://www.rfc-editor.org/info/rfc8121>.\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Yutaka Oiwa\n   National Institute of Advanced Industrial\
    \ Science and Technology\n   Information Technology Research Institute\n   Tsukuba\
    \ Central 1\n   1-1-1 Umezono\n   Tsukuba-shi, Ibaraki\n   Japan\n   Email: y.oiwa@aist.go.jp\n\
    \   Hajime Watanabe\n   National Institute of Advanced Industrial Science and\
    \ Technology\n   Information Technology Research Institute\n   Tsukuba Central\
    \ 1\n   1-1-1 Umezono\n   Tsukuba-shi, Ibaraki\n   Japan\n   Email: h-watanabe@aist.go.jp\n\
    \   Hiromitsu Takagi\n   National Institute of Advanced Industrial Science and\
    \ Technology\n   Information Technology Research Institute\n   Tsukuba Central\
    \ 1\n   1-1-1 Umezono\n   Tsukuba-shi, Ibaraki\n   Japan\n   Email: takagi.hiromitsu@aist.go.jp\n\
    \   Kaoru Maeda\n   Individual Contributor\n   Email: kaorumaeda.ml@gmail.com\n\
    \   Tatsuya Hayashi\n   Lepidum Co. Ltd.\n   Village Sasazuka 3, Suite #602\n\
    \   1-30-3 Sasazuka\n   Shibuya-ku, Tokyo\n   Japan\n   Email: hayashi@lepidum.co.jp\n\
    \   Yuichi Ioku\n   Individual Contributor\n   Email: mutual-work@ioku.org\n"
