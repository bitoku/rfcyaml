- contents:
  - '          Generic Security Service API Version 2 : C-bindings

    '
  title: __initial_text__
- contents:
  - "Status of this Memo\n   This document specifies an Internet standards track protocol
    for the\n   Internet community, and requests discussion and suggestions for\n
    \  improvements.  Please refer to the current edition of the \"Internet\n   Official
    Protocol Standards\" (STD 1) for the standardization state\n   and status of this
    protocol.  Distribution of this memo is unlimited.\n"
  title: Status of this Memo
- contents:
  - "Copyright Notice\n   Copyright (C) The Internet Society (2000).  All Rights Reserved.\n"
  title: Copyright Notice
- contents:
  - "Abstract\n   This document specifies C language bindings for Version 2, Update
    1\n   of the Generic Security Service Application Program Interface (GSS-\n   API),
    which is described at a language-independent conceptual level\n   in RFC-2743
    [GSSAPI].  It obsoletes RFC-1509, making specific\n   incremental changes in response
    to implementation experience and\n   liaison requests.  It is intended, therefore,
    that this memo or a\n   successor version thereof will become the basis for subsequent\n
    \  progression of the GSS-API specification on the standards track.\n   The Generic
    Security Service Application Programming Interface\n   provides security services
    to its callers, and is intended for\n   implementation atop a variety of underlying
    cryptographic mechanisms.\n   Typically, GSS-API callers will be application protocols
    into which\n   security enhancements are integrated through invocation of services\n
    \  provided by the GSS-API. The GSS-API allows a caller application to\n   authenticate
    a principal identity associated with a peer application,\n   to delegate rights
    to a peer, and to apply security services such as\n   confidentiality and integrity
    on a per-message basis.\n"
  title: Abstract
- contents:
  - "1.   Introduction\n   The Generic Security Service Application Programming Interface\n
    \  [GSSAPI] provides security services to calling applications.  It\n   allows
    a communicating application to authenticate the user\n   associated with another
    application, to delegate rights to another\n   application, and to apply security
    services such as confidentiality\n   and integrity on a per-message basis.\n   There
    are four stages to using the GSS-API:\n   a) The application acquires a set of
    credentials with which it may\n      prove its identity to other processes. The
    application's\n      credentials vouch for its global identity, which may or may
    not be\n      related to any local username under which it may be running.\n   b)
    A pair of communicating applications establish a joint security\n      context
    using their credentials.  The security context is a pair\n      of GSS-API data
    structures that contain shared state information,\n      which is required in
    order that per-message security services may\n      be provided.  Examples of
    state that might be shared between\n      applications as part of a security context
    are cryptographic keys,\n      and message sequence numbers.  As part of the establishment
    of a\n      security context, the context initiator is authenticated to the\n
    \     responder, and may require that the responder is authenticated in\n      turn.
    \ The initiator may optionally give the responder the right\n      to initiate
    further security contexts, acting as an agent or\n      delegate of the initiator.
    \ This transfer of rights is termed\n      delegation, and is achieved by creating
    a set of credentials,\n      similar to those used by the initiating application,
    but which may\n      be used by the responder.\n      To establish and maintain
    the shared information that makes up the\n      security context, certain GSS-API
    calls will return a token data\n      structure, which is an opaque data type
    that may contain\n      cryptographically protected data.  The caller of such
    a GSS-API\n      routine is responsible for transferring the token to the peer\n
    \     application, encapsulated if necessary in an application-\n      application
    protocol.  On receipt of such a token, the peer\n      application should pass
    it to a corresponding GSS-API routine\n      which will decode the token and extract
    the information, updating\n      the security context state information accordingly.\n
    \  c) Per-message services are invoked to apply either:\n      integrity and data
    origin authentication, or confidentiality,\n      integrity and data origin authentication
    to application data,\n      which are treated by GSS-API as arbitrary octet-strings.
    \ An\n      application transmitting a message that it wishes to protect will\n
    \     call the appropriate GSS-API routine (gss_get_mic or gss_wrap) to\n      apply
    protection, specifying the appropriate security context, and\n      send the resulting
    token to the receiving application.  The\n      receiver will pass the received
    token (and, in the case of data\n      protected by gss_get_mic, the accompanying
    message-data) to the\n      corresponding decoding routine (gss_verify_mic or
    gss_unwrap) to\n      remove the protection and validate the data.\n   d) At the
    completion of a communications session (which may extend\n      across several
    transport connections), each application calls a\n      GSS-API routine to delete
    the security context.  Multiple contexts\n      may also be used (either successively
    or simultaneously) within a\n      single communications association, at the option
    of the\n      applications.\n"
  title: 1.   Introduction
- contents:
  - "2.   GSS-API Routines\n      This section lists the routines that make up the
    GSS-API, and\n      offers a brief description of the purpose of each routine.\n
    \     Detailed descriptions of each routine are listed in alphabetical\n      order
    in section 5.\n   Table 2-1  GSS-API Credential-management Routines\n   Routine
    \               Section              Function\n   -------                -------
    \             --------\n   gss_acquire_cred           5.2  Assume a global identity;
    Obtain\n                                   a GSS-API credential handle for\n                                   pre-existing
    credentials.\n   gss_add_cred               5.3  Construct credentials\n                                   incrementally\n
    \  gss_inquire_cred           5.21 Obtain information about a\n                                   credential\n
    \  gss_inquire_cred_by_mech   5.22 Obtain per-mechanism information\n                                   about
    a credential.\n   gss_release_cred           5.27 Discard a credential handle.\n
    \  Table 2-2  GSS-API Context-Level Routines\n   Routine                 Section
    \             Function\n   -------                 -------              --------\n
    \  gss_init_sec_context       5.19 Initiate a security context with\n                                   a
    peer application\n   gss_accept_sec_context     5.1  Accept a security context\n
    \                                  initiated by a\n                                   peer
    application\n   gss_delete_sec_context     5.9  Discard a security context\n   gss_process_context_token
    \ 5.25 Process a token on a security\n                                   context
    from a peer application\n   gss_context_time           5.7  Determine for how
    long a context\n                                   will remain valid\n   gss_inquire_context
    \       5.20 Obtain information about a\n                                   security
    context\n   gss_wrap_size_limit        5.34 Determine token-size limit for\n                                   gss_wrap
    on a context\n   gss_export_sec_context     5.14 Transfer a security context to\n
    \                                  another process\n   gss_import_sec_context
    \    5.17 Import a transferred context\n   Table 2-3  GSS-API Per-message Routines\n
    \  Routine                 Section              Function\n   -------                 -------
    \             --------\n   gss_get_mic                5.15 Calculate a cryptographic
    message\n                                   integrity code (MIC) for a\n                                   message;
    integrity service\n   gss_verify_mic             5.32 Check a MIC against a message;\n
    \                                  verify integrity of a received\n                                   message\n
    \  gss_wrap                   5.33 Attach a MIC to a message, and\n                                   optionally
    encrypt the message\n                                   content;\n                                   confidentiality
    service\n   gss_unwrap                 5.31 Verify a message with attached\n                                   MIC,
    and decrypt message content\n                                   if necessary.\n
    \  Table 2-4  GSS-API Name manipulation Routines\n   Routine                 Section
    \             Function\n   -------                 -------              --------\n
    \  gss_import_name            5.16 Convert a contiguous string name\n                                   to
    internal-form\n   gss_display_name           5.10 Convert internal-form name to\n
    \                                  text\n   gss_compare_name           5.6  Compare
    two internal-form names\n   gss_release_name           5.28 Discard an internal-form
    name\n   gss_inquire_names_for_mech 5.24 List the name-types supported by\n                                   the
    specified mechanism\n   gss_inquire_mechs_for_name 5.23 List mechanisms that support
    the\n                                   specified name-type\n   gss_canonicalize_name
    \     5.5  Convert an internal name to an MN\n   gss_export_name            5.13
    Convert an MN to export form\n   gss_duplicate_name         5.12 Create a copy
    of an internal name\n   Table 2-5  GSS-API Miscellaneous Routines\n   Routine
    \               Section              Function\n   -------                -------
    \             --------\n   gss_add_oid_set_member    5.4  Add an object identifier
    to\n                                  a set\n   gss_display_status        5.11
    Convert a GSS-API status code\n                                  to text\n   gss_indicate_mechs
    \       5.18 Determine available underlying\n                                  authentication
    mechanisms\n   gss_release_buffer        5.26 Discard a buffer\n   gss_release_oid_set
    \      5.29 Discard a set of object\n                                  identifiers\n
    \  gss_create_empty_oid_set  5.8  Create a set containing no\n                                  object
    identifiers\n   gss_test_oid_set_member   5.30 Determines whether an object\n
    \                                      identifier is a member of a set.\n   Individual
    GSS-API implementations may augment these routines by\n   providing additional
    mechanism-specific routines if required\n   functionality is not available from
    the generic forms. Applications\n   are encouraged to use the generic routines
    wherever possible on\n   portability grounds.\n"
  title: 2.   GSS-API Routines
- contents:
  - "3.   Data Types and Calling Conventions\n   The following conventions are used
    by the GSS-API C-language\n   bindings:\n"
  - contents:
    - "3.1. Integer types\n   GSS-API uses the following integer data type:\n   OM_uint32
      \   32-bit unsigned integer\n   Where guaranteed minimum bit-count is important,
      this portable data\n   type is used by the GSS-API routine definitions.  Individual
      GSS-API\n   implementations will include appropriate typedef definitions to
      map\n   this type onto a built-in data type.  If the platform supports the\n
      \  X/Open xom.h header file, the OM_uint32 definition contained therein\n   should
      be used; the GSS-API header file in Appendix A contains logic\n   that will
      detect the prior inclusion of xom.h, and will not attempt\n   to re-declare
      OM_uint32.  If the X/Open header file is not available\n   on the platform,
      the GSS-API implementation should use the smallest\n   natural unsigned integer
      type that provides at least 32 bits of\n   precision.\n"
    title: 3.1. Integer types
  - contents:
    - "3.2. String and similar data\n   Many of the GSS-API routines take arguments
      and return values that\n   describe contiguous octet-strings.  All such data
      is passed between\n   the GSS-API and the caller using the gss_buffer_t data
      type.  This\n   data type is a pointer to a buffer descriptor, which consists
      of a\n   length field that contains the total number of bytes in the datum,\n
      \  and a value field which contains a pointer to the actual datum:\n   typedef
      struct gss_buffer_desc_struct {\n      size_t    length;\n      void      *value;\n
      \  } gss_buffer_desc, *gss_buffer_t;\n   Storage for data returned to the application
      by a GSS-API routine\n   using the gss_buffer_t conventions is allocated by
      the GSS-API\n   routine.  The application may free this storage by invoking
      the\n   gss_release_buffer routine.  Allocation of the gss_buffer_desc object\n
      \  is always the responsibility of the application;  unused\n   gss_buffer_desc
      objects may be initialized to the value\n   GSS_C_EMPTY_BUFFER.\n"
    - contents:
      - "3.2.1. Opaque data types\n   Certain multiple-word data items are considered
        opaque data types at\n   the GSS-API, because their internal structure has
        no significance\n   either to the GSS-API or to the caller.  Examples of such
        opaque data\n   types are the input_token parameter to gss_init_sec_context
        (which is\n   opaque to the caller), and the input_message parameter to gss_wrap\n
        \  (which is opaque to the GSS-API).  Opaque data is passed between the\n
        \  GSS-API and the application using the gss_buffer_t datatype.\n"
      title: 3.2.1. Opaque data types
    - contents:
      - "3.2.2. Character strings\n   Certain multiple-word data items may be regarded
        as simple ISO\n   Latin-1 character strings.  Examples are the printable strings
        passed\n   to gss_import_name via the input_name_buffer parameter. Some GSS-API\n
        \  routines also return character strings.  All such character strings\n   are
        passed between the application and the GSS-API implementation\n   using the
        gss_buffer_t datatype, which is a pointer to a\n   gss_buffer_desc object.\n
        \  When a gss_buffer_desc object describes a printable string, the\n   length
        field of the gss_buffer_desc should only count printable\n   characters within
        the string.  In particular, a trailing NUL\n   character should NOT be included
        in the length count, nor should\n   either the GSS-API implementation or the
        application assume the\n   presence of an uncounted trailing NUL.\n"
      title: 3.2.2. Character strings
    title: 3.2. String and similar data
  - contents:
    - "3.3. Object Identifiers\n   Certain GSS-API procedures take parameters of the
      type gss_OID, or\n   Object identifier.  This is a type containing ISO-defined
      tree-\n   structured values, and is used by the GSS-API caller to select an\n
      \  underlying security mechanism and to specify namespaces.  A value of\n   type
      gss_OID has the following structure:\n   typedef struct gss_OID_desc_struct
      {\n      OM_uint32   length;\n      void        *elements;\n   } gss_OID_desc,
      *gss_OID;\n   The elements field of this structure points to the first byte
      of an\n   octet string containing the ASN.1 BER encoding of the value portion\n
      \  of the normal BER TLV encoding of the gss_OID.  The length field\n   contains
      the number of bytes in this value.  For example, the gss_OID\n   value corresponding
      to {iso(1) identified-organization(3) icd-\n   ecma(12) member-company(2) dec(1011)
      cryptoAlgorithms(7) DASS(5)},\n   meaning the DASS X.509 authentication mechanism,
      has a length field\n   of 7 and an elements field pointing to seven octets containing
      the\n   following octal values: 53,14,2,207,163,7,5. GSS-API implementations\n
      \  should provide constant gss_OID values to allow applications to\n   request
      any supported mechanism, although applications are encouraged\n   on portability
      grounds to accept the default mechanism.  gss_OID\n   values should also be
      provided to allow applications to specify\n   particular name types (see section
      3.10).  Applications should treat\n   gss_OID_desc values returned by GSS-API
      routines as read-only.  In\n   particular, the application should not attempt
      to deallocate them\n   with free().  The gss_OID_desc datatype is equivalent
      to the X/Open\n   OM_object_identifier datatype[XOM].\n"
    title: 3.3. Object Identifiers
  - contents:
    - "3.4. Object Identifier Sets\n   Certain GSS-API procedures take parameters
      of the type gss_OID_set.\n   This type represents one or more object identifiers
      (section 2.3).  A\n   gss_OID_set object has the following structure:\n   typedef
      struct gss_OID_set_desc_struct {\n      size_t    count;\n      gss_OID   elements;\n
      \  } gss_OID_set_desc, *gss_OID_set;\n   The count field contains the number
      of OIDs within the set.  The\n   elements field is a pointer to an array of
      gss_OID_desc objects, each\n   of which describes a single OID.  gss_OID_set
      values are used to name\n   the available mechanisms supported by the GSS-API,
      to request the use\n   of specific mechanisms, and to indicate which mechanisms
      a given\n   credential supports.\n   All OID sets returned to the application
      by GSS-API are dynamic\n   objects (the gss_OID_set_desc, the \"elements\" array
      of the set, and\n   the \"elements\" array of each member OID are all dynamically\n
      \  allocated), and this storage must be deallocated by the application\n   using
      the gss_release_oid_set() routine.\n"
    title: 3.4. Object Identifier Sets
  - contents:
    - "3.5. Credentials\n   A credential handle is a caller-opaque atomic datum that
      identifies a\n   GSS-API credential data structure.  It is represented by the
      caller-\n   opaque type gss_cred_id_t, which should be implemented as a pointer\n
      \  or arithmetic type.  If a pointer implementation is chosen, care must\n   be
      taken to ensure that two gss_cred_id_t values may be compared with\n   the ==
      operator.\n   GSS-API credentials can contain mechanism-specific principal\n
      \  authentication data for multiple mechanisms.  A GSS-API credential is\n   composed
      of a set of credential-elements, each of which is applicable\n   to a single
      mechanism.  A credential may contain at most one\n   credential-element for
      each supported mechanism. A credential-element\n   identifies the data needed
      by a single mechanism to authenticate a\n   single principal, and conceptually
      contains two credential-references\n   that describe the actual mechanism-specific
      authentication data, one\n   to be used by GSS-API for initiating contexts,
      \ and one to be used\n   for accepting contexts.  For mechanisms that do not
      distinguish\n   between acceptor and initiator credentials, both references
      would\n   point to the same underlying mechanism-specific authentication data.\n
      \  Credentials describe a set of mechanism-specific principals, and give\n   their
      holder the ability to act as any of those principals. All\n   principal identities
      asserted by a single GSS-API credential should\n   belong to the same entity,
      although enforcement of this property is\n   an implementation-specific matter.
      \ The GSS-API does not make the\n   actual credentials available to applications;
      instead a credential\n   handle is used to identify a particular credential,
      held internally\n   by GSS-API.  The combination of GSS-API credential handle
      and\n   mechanism identifies the principal whose identity will be asserted by\n
      \  the credential when used with that mechanism.\n   The gss_init_sec_context
      and gss_accept_sec_context routines allow\n   the value GSS_C_NO_CREDENTIAL
      to be specified as their credential\n   handle parameter.  This special credential-handle
      indicates a desire\n   by the application to act as a default principal.  While
      individual\n   GSS-API implementations are free to determine such default behavior\n
      \  as appropriate to the mechanism, the following default behavior by\n   these
      routines is recommended for portability:\n   gss_init_sec_context\n      1)
      If there is only a single principal capable of initiating\n         security
      contexts for the chosen mechanism that the application\n         is authorized
      to act on behalf of, then that principal shall be\n         used, otherwise\n
      \     2) If the platform maintains a concept of a default network-\n         identity
      for the chosen mechanism, and if the application is\n         authorized to
      act on behalf of that identity for the purpose of\n         initiating security
      contexts, then the principal corresponding\n         to that identity shall
      be used, otherwise\n      3) If the platform maintains a concept of a default
      local\n         identity, and provides a means to map local identities into\n
      \        network-identities for the chosen mechanism, and if the\n         application
      is authorized to act on behalf of the network-\n         identity image of the
      default local identity for the purpose of\n         initiating security contexts
      using the chosen mechanism, then\n         the principal corresponding to that
      identity shall be used,\n         otherwise\n      4) A user-configurable default
      identity should be used.\n   gss_accept_sec_context\n      1) If there is only
      a single authorized principal identity capable\n         of accepting security
      contexts for the chosen mechanism, then\n         that principal shall be used,
      otherwise\n      2) If the mechanism can determine the identity of the target\n
      \        principal by examining the context-establishment token, and if\n         the
      accepting application is authorized to act as that\n         principal for the
      purpose of accepting security contexts using\n         the chosen mechanism,
      then that principal identity shall be\n         used, otherwise\n      3) If
      the mechanism supports context acceptance by any principal,\n         and if
      mutual authentication was not requested, any principal\n         that the application
      is authorized to accept security contexts\n         under using the chosen mechanism
      may be used, otherwise\n      4)A user-configurable default identity shall be
      used.\n   The purpose of the above rules is to allow security contexts to be\n
      \  established by both initiator and acceptor using the default behavior\n   wherever
      possible.  Applications requesting default behavior are\n   likely to be more
      portable across mechanisms and platforms than ones\n   that use gss_acquire_cred
      to request a specific identity.\n"
    title: 3.5. Credentials
  - contents:
    - "3.6. Contexts\n   The gss_ctx_id_t data type contains a caller-opaque atomic
      value that\n   identifies one end of a GSS-API security context.  It should
      be\n   implemented as a pointer or arithmetic type.  If a pointer type is\n
      \  chosen, care should be taken to ensure that two gss_ctx_id_t values\n   may
      be compared with the == operator.\n   The security context holds state information
      about each end of a peer\n   communication, including cryptographic state information.\n"
    title: 3.6. Contexts
  - contents:
    - "3.7. Authentication tokens\n   A token is a caller-opaque type that GSS-API
      uses to maintain\n   synchronization between the context data structures at
      each end of a\n   GSS-API security context.  The token is a cryptographically
      protected\n   octet-string, generated by the underlying mechanism at one end
      of a\n   GSS-API security context for use by the peer mechanism at the other\n
      \  end.  Encapsulation (if required) and transfer of the token are the\n   responsibility
      of the peer applications.  A token is passed between\n   the GSS-API and the
      application using the gss_buffer_t conventions.\n"
    title: 3.7. Authentication tokens
  - contents:
    - "3.8. Interprocess tokens\n   Certain GSS-API routines are intended to transfer
      data between\n   processes in multi-process programs.  These routines use a
      caller-\n   opaque octet-string, generated by the GSS-API in one process for
      use\n   by the GSS-API in another process.  The calling application is\n   responsible
      for transferring such tokens between processes in an OS-\n   specific manner.
      \ Note that, while GSS-API implementors are\n   encouraged to avoid placing
      sensitive information within interprocess\n   tokens, or to cryptographically
      protect them, many implementations\n   will be unable to avoid placing key material
      or other sensitive data\n   within them.  It is the application's responsibility
      to ensure that\n   interprocess tokens are protected in transit, and transferred
      only to\n   processes that are trustworthy. An interprocess token is passed\n
      \  between the GSS-API and the application using the gss_buffer_t\n   conventions.\n"
    title: 3.8. Interprocess tokens
  - contents:
    - "3.9. Status values\n   Every GSS-API routine returns two distinct values to
      report status\n   information to the caller: GSS status codes and Mechanism
      status\n   codes.\n"
    - contents:
      - "3.9.1. GSS status codes\n   GSS-API routines return GSS status codes as their
        OM_uint32 function\n   value.  These codes indicate errors that are independent
        of the\n   underlying mechanism(s) used to provide the security service.  The\n
        \  errors that can be indicated via a GSS status code are either generic\n
        \  API routine errors (errors that are defined in the GSS-API\n   specification)
        or calling errors (errors that are specific to these\n   language bindings).\n
        \  A GSS status code can indicate a single fatal generic API error from\n
        \  the routine and a single calling error.  In addition, supplementary\n   status
        information may be indicated via the setting of bits in the\n   supplementary
        info field of a GSS status code.\n   These errors are encoded into the 32-bit
        GSS status code as follows:\n      MSB                                                        LSB\n
        \     |------------------------------------------------------------|\n      |
        \ Calling Error | Routine Error  |    Supplementary Info    |\n      |------------------------------------------------------------|\n
        \  Bit 31            24 23            16 15                       0\n   Hence
        if a GSS-API routine returns a GSS status code whose upper 16\n   bits contain
        a non-zero value, the call failed.  If the calling error\n   field is non-zero,
        the invoking application's call of the routine was\n   erroneous.  Calling
        errors are defined in table 5-1.  If the routine\n   error field is non-zero,
        the routine failed for one of the routine-\n   specific reasons listed below
        in table 5-2.  Whether or not the upper\n   16 bits indicate a failure or
        a success, the routine may indicate\n   additional information by setting
        bits in the supplementary info\n   field of the status code. The meaning of
        individual bits is listed\n   below in table 5-3.\n   Table 3-1  Calling Errors\n
        \  Name                   Value in field           Meaning\n   ----                   --------------
        \          -------\n   GSS_S_CALL_INACCESSIBLE_READ  1       A required input
        parameter\n                                         could not be read\n   GSS_S_CALL_INACCESSIBLE_WRITE
        2       A required output parameter\n                                          could
        not be written.\n   GSS_S_CALL_BAD_STRUCTURE      3       A parameter was
        malformed\n   Table 3-2  Routine Errors\n   Name                   Value in
        field           Meaning\n   ----                   --------------           -------\n
        \  GSS_S_BAD_MECH                1       An unsupported mechanism\n                                         was
        requested\n   GSS_S_BAD_NAME                2       An invalid name was\n
        \                                        supplied\n   GSS_S_BAD_NAMETYPE            3
        \      A supplied name was of an\n                                         unsupported
        type\n   GSS_S_BAD_BINDINGS            4       Incorrect channel bindings\n
        \                                        were supplied\n   GSS_S_BAD_STATUS
        \             5       An invalid status code was\n                                         supplied\n
        \  GSS_S_BAD_MIC GSS_S_BAD_SIG   6       A token had an invalid MIC\n   GSS_S_NO_CRED
        \                7       No credentials were\n                                         supplied,
        or the\n                                         credentials were\n                                         unavailable
        or\n                                         inaccessible.\n   GSS_S_NO_CONTEXT
        \             8       No context has been\n                                         established\n
        \  GSS_S_DEFECTIVE_TOKEN         9       A token was invalid\n   GSS_S_DEFECTIVE_CREDENTIAL
        \  10       A credential was invalid\n   GSS_S_CREDENTIALS_EXPIRED    11       The
        referenced credentials\n                                         have expired\n
        \  GSS_S_CONTEXT_EXPIRED        12       The context has expired\n   GSS_S_FAILURE
        \               13       Miscellaneous failure (see\n                                         text)\n
        \  GSS_S_BAD_QOP                14       The quality-of-protection\n                                         requested
        could not be\n                                         provided\n   GSS_S_UNAUTHORIZED
        \          15       The operation is forbidden\n                                         by
        local security policy\n   GSS_S_UNAVAILABLE            16       The operation
        or option is\n                                         unavailable\n   GSS_S_DUPLICATE_ELEMENT
        \     17       The requested credential\n                                         element
        already exists\n   GSS_S_NAME_NOT_MN            18       The provided name
        was not a\n                                         mechanism name\n   Table
        3-3  Supplementary Status Bits\n   Name                   Bit Number           Meaning\n
        \  ----                   ----------           -------\n   GSS_S_CONTINUE_NEEDED
        \  0 (LSB)   Returned only by\n                                     gss_init_sec_context
        or\n                                     gss_accept_sec_context. The\n                                     routine
        must be called again\n                                     to complete its
        function.\n                                     See routine documentation
        for\n                                     detailed description\n   GSS_S_DUPLICATE_TOKEN
        \  1         The token was a duplicate of\n                                     an
        earlier token\n   GSS_S_OLD_TOKEN         2         The token's validity period\n
        \                                    has expired\n   GSS_S_UNSEQ_TOKEN       3
        \        A later token has already been\n                                     processed\n
        \  GSS_S_GAP_TOKEN         4         An expected per-message token\n                                     was
        not received\n   The routine documentation also uses the name GSS_S_COMPLETE,
        which is\n   a zero value, to indicate an absence of any API errors or\n   supplementary
        information bits.\n   All GSS_S_xxx symbols equate to complete OM_uint32 status
        codes,\n   rather than to bitfield values.  For example, the actual value
        of the\n   symbol GSS_S_BAD_NAMETYPE (value 3 in the routine error field)
        is\n   3<<16.  The macros GSS_CALLING_ERROR(), GSS_ROUTINE_ERROR() and\n   GSS_SUPPLEMENTARY_INFO()
        are provided, each of which takes a GSS\n   status code and removes all but
        the relevant field.  For example, the\n   value obtained by applying GSS_ROUTINE_ERROR
        to a status code removes\n   the calling errors and supplementary info fields,
        leaving only the\n   routine errors field.  The values delivered by these
        macros may be\n   directly compared with a GSS_S_xxx symbol of the appropriate
        type.\n   The macro GSS_ERROR() is also provided, which when applied to a
        GSS\n   status code returns a non-zero value if the status code indicated
        a\n   calling or routine error, and a zero value otherwise.  All macros\n
        \  defined by GSS-API evaluate their argument(s) exactly once.\n   A GSS-API
        implementation may choose to signal calling errors in a\n   platform-specific
        manner instead of, or in addition to the routine\n   value;  routine errors
        and supplementary info should be returned via\n   major status values only.\n
        \  The GSS major status code GSS_S_FAILURE is used to indicate that the\n
        \  underlying mechanism detected an error for which no specific GSS\n   status
        code is defined.  The mechanism-specific status code will\n   provide more
        details about the error.\n"
      title: 3.9.1. GSS status codes
    - contents:
      - "3.9.2. Mechanism-specific status codes\n   GSS-API routines return a minor_status
        parameter, which is used to\n   indicate specialized errors from the underlying
        security mechanism.\n   This parameter may contain a single mechanism-specific
        error,\n   indicated by a OM_uint32 value.\n   The minor_status parameter
        will always be set by a GSS-API routine,\n   even if it returns a calling
        error or one of the generic API errors\n   indicated above as fatal, although
        most other output parameters may\n   remain unset in such cases.  However,
        output parameters that are\n   expected to return pointers to storage allocated
        by a routine must\n   always be set by the routine, even in the event of an
        error, although\n   in such cases the GSS-API routine may elect to set the
        returned\n   parameter value to NULL to indicate that no storage was actually\n
        \  allocated.  Any length field associated with such pointers (as in a\n   gss_buffer_desc
        structure) should also be set to zero in such cases.\n"
      title: 3.9.2. Mechanism-specific status codes
    title: 3.9. Status values
  - contents:
    - "3.10. Names\n   A name is used to identify a person or entity.  GSS-API authenticates\n
      \  the relationship between a name and the entity claiming the name.\n   Since
      different authentication mechanisms may employ different\n   namespaces for
      identifying their principals, GSSAPI's naming support\n   is necessarily complex
      in multi-mechanism environments (or even in\n   some single-mechanism environments
      where the underlying mechanism\n   supports multiple namespaces).\n   Two distinct
      representations are defined for names:\n   An internal form.  This is the GSS-API
      \"native\" format for names,\n      represented by the implementation-specific
      gss_name_t type.  It is\n      opaque to GSS-API callers.  A single gss_name_t
      object may contain\n      multiple names from different namespaces, but all
      names should\n      refer to the same entity.  An example of such an internal
      name\n      would be the name returned from a call to the gss_inquire_cred\n
      \     routine, when applied to a credential containing credential\n      elements
      for multiple authentication mechanisms employing\n      different namespaces.
      \ This gss_name_t object will contain a\n      distinct name for the entity
      for each authentication mechanism.\n      For GSS-API implementations supporting
      multiple namespaces,\n      objects of type gss_name_t must contain sufficient
      information to\n      determine the namespace to which each primitive name belongs.\n
      \  Mechanism-specific contiguous octet-string forms.  A format\n      capable
      of containing a single name (from a single namespace).\n      Contiguous string
      names are always accompanied by an object\n      identifier specifying the namespace
      to which the name belongs, and\n      their format is dependent on the authentication
      mechanism that\n      employs the name.  Many, but not all, contiguous string
      names will\n      be printable, and may therefore be used by GSS-API applications\n
      \     for communication with their users.\n   Routines (gss_import_name and
      gss_display_name) are provided to\n   convert names between contiguous string
      representations and the\n   internal gss_name_t type.  gss_import_name may support
      multiple\n   syntaxes for each supported namespace, allowing users the freedom
      to\n   choose a preferred name representation. gss_display_name should use\n
      \  an implementation-chosen printable syntax for each supported name-\n   type.\n
      \  If an application calls gss_display_name(), passing the internal name\n   resulting
      from a call to gss_import_name(), there is no guarantee the\n   the resulting
      contiguous string name will be the same as the original\n   imported string
      name.  Nor do name-space identifiers necessarily\n   survive unchanged after
      a journey through the internal name-form.  An\n   example of this might be a
      mechanism that authenticates X.500 names,\n   but provides an algorithmic mapping
      of Internet DNS names into X.500.\n   That mechanism's implementation of gss_import_name()
      might, when\n   presented with a DNS name, generate an internal name that contained\n
      \  both the original DNS name and the equivalent X.500 name.\n   Alternatively,
      it might only store the X.500 name.  In the latter\n   case, gss_display_name()
      would most likely generate a printable X.500\n   name, rather than the original
      DNS name.\n   The process of authentication delivers to the context acceptor
      an\n   internal name.  Since this name has been authenticated by a single\n
      \  mechanism, it contains only a single name (even if the internal name\n   presented
      by the context initiator to gss_init_sec_context had\n   multiple components).
      \ Such names are termed internal mechanism\n   names, or \"MN\"s and the names
      emitted by gss_accept_sec_context() are\n   always of this type.  Since some
      applications may require MNs without\n   wanting to incur the overhead of an
      authentication operation, a\n   second function, gss_canonicalize_name(), is
      provided to convert a\n   general internal name into an MN.\n   Comparison of
      internal-form names may be accomplished via the\n   gss_compare_name() routine,
      which returns true if the two names being\n   compared refer to the same entity.
      \ This removes the need for the\n   application program to understand the syntaxes
      of the various\n   printable names that a given GSS-API implementation may support.\n
      \  Since GSS-API assumes that all primitive names contained within a\n   given
      internal name refer to the same entity, gss_compare_name() can\n   return true
      if the two names have at least one primitive name in\n   common.  If the implementation
      embodies knowledge of equivalence\n   relationships between names taken from
      different namespaces, this\n   knowledge may also allow successful comparison
      of internal names\n   containing no overlapping primitive elements.\n   When
      used in large access control lists, the overhead of invoking\n   gss_import_name()
      and gss_compare_name() on each name from the ACL\n   may be prohibitive.  As
      an alternative way of supporting this case,\n   GSS-API defines a special form
      of the contiguous string name which\n   may be compared directly (e.g. with
      memcmp()).  Contiguous names\n   suitable for comparison are generated by the
      gss_export_name()\n   routine, which requires an MN as input.  Exported names
      may be re-\n   imported by the gss_import_name() routine, and the resulting
      internal\n   name will also be an MN.  The gss_OID constant GSS_C_NT_EXPORT_NAME\n
      \  indentifies the \"export name\" type, and the value of this constant is\n
      \  given in Appendix A.  Structurally, an exported name object consists\n   of
      a header containing an OID identifying the mechanism that\n   authenticated
      the name, and a trailer containing the name itself,\n   where the syntax of
      the trailer is defined by the individual\n   mechanism specification.   The
      precise format of an export name is\n   defined in the language-independent
      GSS-API specification [GSSAPI].\n   Note that the results obtained by using
      gss_compare_name() will in\n   general be different from those obtained by invoking\n
      \  gss_canonicalize_name() and gss_export_name(), and then comparing the\n   exported
      names.  The first series of operation determines whether two\n   (unauthenticated)
      names identify the same principal; the second\n   whether a particular mechanism
      would authenticate them as the same\n   principal.  These two operations will
      in general give the same\n   results only for MNs.\n   The gss_name_t datatype
      should be implemented as a pointer type. To\n   allow the compiler to aid the
      application programmer by performing\n   type-checking, the use of (void *)
      is discouraged.  A pointer to an\n   implementation-defined type is the preferred
      choice.\n   Storage is allocated by routines that return gss_name_t values.
      A\n   procedure, gss_release_name, is provided to free storage associated\n
      \  with an internal-form name.\n"
    title: 3.10. Names
  - contents:
    - "3.11. Channel Bindings\n   GSS-API supports the use of user-specified tags
      to identify a given\n   context to the peer application.  These tags are intended
      to be used\n   to identify the particular communications channel that carries
      the\n   context.  Channel bindings are communicated to the GSS-API using the\n
      \  following structure:\n   typedef struct gss_channel_bindings_struct {\n      OM_uint32
      \      initiator_addrtype;\n      gss_buffer_desc initiator_address;\n      OM_uint32
      \      acceptor_addrtype;\n      gss_buffer_desc acceptor_address;\n      gss_buffer_desc
      application_data;\n   } *gss_channel_bindings_t;\n   The initiator_addrtype
      and acceptor_addrtype fields denote the type\n   of addresses contained in the
      initiator_address and acceptor_address\n   buffers.  The address type should
      be one of the following:\n   GSS_C_AF_UNSPEC     Unspecified address type\n
      \  GSS_C_AF_LOCAL      Host-local address type\n   GSS_C_AF_INET       Internet
      address type (e.g. IP)\n   GSS_C_AF_IMPLINK    ARPAnet IMP address type\n   GSS_C_AF_PUP
      \       pup protocols (eg BSP) address type\n   GSS_C_AF_CHAOS      MIT CHAOS
      protocol address type\n   GSS_C_AF_NS         XEROX NS address type\n   GSS_C_AF_NBS
      \       nbs address type\n   GSS_C_AF_ECMA       ECMA address type\n   GSS_C_AF_DATAKIT
      \   datakit protocols address type\n   GSS_C_AF_CCITT      CCITT protocols\n
      \  GSS_C_AF_SNA        IBM SNA address type\n   GSS_C_AF_DECnet     DECnet address
      type\n   GSS_C_AF_DLI        Direct data link interface address type\n   GSS_C_AF_LAT
      \       LAT address type\n   GSS_C_AF_HYLINK     NSC Hyperchannel address type\n
      \  GSS_C_AF_APPLETALK  AppleTalk address type\n   GSS_C_AF_BSC        BISYNC
      2780/3780 address type\n   GSS_C_AF_DSS        Distributed system services address
      type\n   GSS_C_AF_OSI        OSI TP4 address type\n   GSS_C_AF_X25        X.25\n
      \  GSS_C_AF_NULLADDR   No address specified\n   Note that these symbols name
      address families rather than specific\n   addressing formats.  For address families
      that contain several\n   alternative address forms, the initiator_address and
      acceptor_address\n   fields must contain sufficient information to determine
      which address\n   form is used.  When not otherwise specified, addresses should
      be\n   specified in network byte-order (that is, native byte-ordering for\n
      \  the address family).\n   Conceptually, the GSS-API concatenates the initiator_addrtype,\n
      \  initiator_address, acceptor_addrtype, acceptor_address and\n   application_data
      to form an octet string.  The mechanism calculates a\n   MIC over this octet
      string, and binds the MIC to the context\n   establishment token emitted by
      gss_init_sec_context. The same\n   bindings are presented by the context acceptor
      to\n   gss_accept_sec_context, and a MIC is calculated in the same way. The\n
      \  calculated MIC is compared with that found in the token, and if the\n   MICs
      differ, gss_accept_sec_context will return a GSS_S_BAD_BINDINGS\n   error, and
      the context will not be established.  Some mechanisms may\n   include the actual
      channel binding data in the token (rather than\n   just a MIC); applications
      should therefore not use confidential data\n   as channel-binding components.\n
      \  Individual mechanisms may impose additional constraints on addresses\n   and
      address types that may appear in channel bindings.  For example,\n   a mechanism
      may verify that the initiator_address field of the\n   channel bindings presented
      to gss_init_sec_context contains the\n   correct network address of the host
      system.  Portable applications\n   should therefore ensure that they either
      provide correct information\n   for the address fields, or omit addressing information,
      specifying\n   GSS_C_AF_NULLADDR as the address-types.\n"
    title: 3.11. Channel Bindings
  - contents:
    - "3.12. Optional parameters\n   Various parameters are described as optional.
      \ This means that they\n   follow a convention whereby a default value may be
      requested.  The\n   following conventions are used for omitted parameters.  These\n
      \  conventions apply only to those parameters that are explicitly\n   documented
      as optional.\n"
    - contents:
      - "3.12.1. gss_buffer_t types\n   Specify GSS_C_NO_BUFFER as a value.  For an
        input parameter this\n   signifies that default behavior is requested, while
        for an output\n   parameter it indicates that the information that would be
        returned\n   via the parameter is not required by the application.\n"
      title: 3.12.1. gss_buffer_t types
    - contents:
      - "3.12.2. Integer types (input)\n   Individual parameter documentation lists
        values to be used to\n   indicate default actions.\n"
      title: 3.12.2. Integer types (input)
    - contents:
      - "3.12.3. Integer types (output)\n   Specify NULL as the value for the pointer.\n"
      title: 3.12.3. Integer types (output)
    - contents:
      - "3.12.4. Pointer types\n   Specify NULL as the value.\n"
      title: 3.12.4. Pointer types
    - contents:
      - "3.12.5. Object IDs\n   Specify GSS_C_NO_OID as the value.\n"
      title: 3.12.5. Object IDs
    - contents:
      - "3.12.6. Object ID Sets\n   Specify GSS_C_NO_OID_SET as the value.\n"
      title: 3.12.6. Object ID Sets
    - contents:
      - "3.12.7. Channel Bindings\n   Specify GSS_C_NO_CHANNEL_BINDINGS to indicate
        that channel bindings\n   are not to be used.\n"
      title: 3.12.7. Channel Bindings
    title: 3.12. Optional parameters
  title: 3.   Data Types and Calling Conventions
- contents:
  - "4.   Additional Controls\n   This section discusses the optional services that
    a context initiator\n   may request of the GSS-API at context establishment. Each
    of these\n   services is requested by setting a flag in the req_flags input\n
    \  parameter to gss_init_sec_context.\n   The optional services currently defined
    are:\n   Delegation - The (usually temporary) transfer of rights from\n       initiator
    to acceptor, enabling the acceptor to authenticate\n       itself as an agent
    of the initiator.\n   Mutual Authentication - In addition to the initiator authenticating\n
    \      its identity to the context acceptor, the context acceptor should\n       also
    authenticate itself to the initiator.\n   Replay detection - In addition to providing
    message integrity\n       services, gss_get_mic and gss_wrap should include message\n
    \      numbering information to enable gss_verify_mic and gss_unwrap to\n       detect
    if a message has been duplicated.\n   Out-of-sequence detection - In addition
    to providing message\n       integrity services, gss_get_mic and gss_wrap should
    include\n       message sequencing information to enable gss_verify_mic and\n
    \      gss_unwrap to detect if a message has been received out of\n       sequence.\n
    \  Anonymous authentication - The establishment of the security context\n       should
    not reveal the initiator's identity to the context\n       acceptor.\n   Any currently
    undefined bits within such flag arguments should be\n   ignored by GSS-API implementations
    when presented by an application,\n   and should be set to zero when returned
    to the application by the\n   GSS-API implementation.\n   Some mechanisms may
    not support all optional services, and some\n   mechanisms may only support some
    services in conjunction with others.\n   Both gss_init_sec_context and gss_accept_sec_context
    inform the\n   applications which services will be available from the context
    when\n   the establishment phase is complete, via the ret_flags output\n   parameter.
    \ In general, if the security mechanism is capable of\n   providing a requested
    service, it should do so, even if additional\n   services must be enabled in order
    to provide the requested service.\n   If the mechanism is incapable of providing
    a requested service, it\n   should proceed without the service, leaving the application
    to abort\n   the context establishment process if it considers the requested\n
    \  service to be mandatory.\n   Some mechanisms may specify that support for some
    services is\n   optional, and that implementors of the mechanism need not provide
    it.\n   This is most commonly true of the confidentiality service, often\n   because
    of legal restrictions on the use of data-encryption, but may\n   apply to any
    of the services.  Such mechanisms are required to send\n   at least one token
    from acceptor to initiator during context\n   establishment when the initiator
    indicates a desire to use such a\n   service, so that the initiating GSS-API can
    correctly indicate\n   whether the service is supported by the acceptor's GSS-API.\n"
  - contents:
    - "4.1. Delegation\n   The GSS-API allows delegation to be controlled by the initiating\n
      \  application via a boolean parameter to gss_init_sec_context(), the\n   routine
      that establishes a security context.  Some mechanisms do not\n   support delegation,
      and for such mechanisms attempts by an\n   application to enable delegation
      are ignored.\n   The acceptor of a security context for which the initiator
      enabled\n   delegation will receive (via the delegated_cred_handle parameter
      of\n   gss_accept_sec_context) a credential handle that contains the\n   delegated
      identity, and this credential handle may be used to\n   initiate subsequent
      GSS-API security contexts as an agent or delegate\n   of the initiator.  If
      the original initiator's identity is \"A\" and\n   the delegate's identity is
      \"B\", then, depending on the underlying\n   mechanism, the identity embodied
      by the delegated credential may be\n   either \"A\" or \"B acting for A\".\n
      \  For many mechanisms that support delegation, a simple boolean does\n   not
      provide enough control.  Examples of additional aspects of\n   delegation control
      that a mechanism might provide to an application\n   are duration of delegation,
      network addresses from which delegation\n   is valid, and constraints on the
      tasks that may be performed by a\n   delegate.  Such controls are presently
      outside the scope of the GSS-\n   API.  GSS-API implementations supporting mechanisms
      offering\n   additional controls should provide extension routines that allow\n
      \  these controls to be exercised (perhaps by modifying the initiator's\n   GSS-API
      credential prior to its use in establishing a context).\n   However, the simple
      delegation control provided by GSS-API should\n   always be able to over-ride
      other mechanism-specific delegation\n   controls - If the application instructs
      gss_init_sec_context() that\n   delegation is not desired, then the implementation
      must not permit\n   delegation to occur. This is an exception to the general
      rule that a\n   mechanism may enable services even if they are not requested
      -\n   delegation may only be provided at the explicit request of the\n   application.\n"
    title: 4.1. Delegation
  - contents:
    - "4.2. Mutual authentication\n   Usually, a context acceptor will require that
      a context initiator\n   authenticate itself so that the acceptor may make an
      access-control\n   decision prior to performing a service for the initiator.
      \ In some\n   cases, the initiator may also request that the acceptor authenticate\n
      \  itself.  GSS-API allows the initiating application to request this\n   mutual
      authentication service by setting a flag when calling\n   gss_init_sec_context.\n
      \  The initiating application is informed as to whether or not the\n   context
      acceptor has authenticated itself.  Note that some mechanisms\n   may not support
      mutual authentication, and other mechanisms may\n   always perform mutual authentication,
      whether or not the initiating\n   application requests it.  In particular, mutual
      authentication my be\n   required by some mechanisms in order to support replay
      or out-of-\n   sequence message detection, and for such mechanisms a request
      for\n   either of these services will automatically enable mutual\n   authentication.\n"
    title: 4.2. Mutual authentication
  - contents:
    - "4.3. Replay and out-of-sequence detection\n   The GSS-API may provide detection
      of mis-ordered message once a\n   security context has been established.  Protection
      may be applied to\n   messages by either application, by calling either gss_get_mic
      or\n   gss_wrap, and verified by the peer application by calling\n   gss_verify_mic
      or gss_unwrap.\n   gss_get_mic calculates a cryptographic MIC over an application\n
      \  message, and returns that MIC in a token.  The application should\n   pass
      both the token and the message to the peer application, which\n   presents them
      to gss_verify_mic.\n   gss_wrap calculates a cryptographic MIC of an application
      message,\n   and places both the MIC and the message inside a single token.
      \ The\n   Application should pass the token to the peer application, which\n
      \  presents it to gss_unwrap to extract the message and verify the MIC.\n   Either
      pair of routines may be capable of detecting out-of-sequence\n   message delivery,
      or duplication of messages. Details of such mis-\n   ordered messages are indicated
      through supplementary status bits in\n   the major status code returned by gss_verify_mic
      or gss_unwrap.  The\n   relevant supplementary bits are:\n   GSS_S_DUPLICATE_TOKEN
      - The token is a duplicate of one that has\n                    already been
      received and processed.  Only\n                    contexts that claim to provide
      replay detection\n                    may set this bit.\n   GSS_S_OLD_TOKEN
      - The token is too old to determine whether or\n                    not it is
      a duplicate.  Contexts supporting\n                    out-of-sequence detection
      but not replay\n                    detection should always set this bit if\n
      \                   GSS_S_UNSEQ_TOKEN is set; contexts that support\n                    replay
      detection should only set this bit if the\n                    token is so old
      that it cannot be checked for\n                    duplication.\n   GSS_S_UNSEQ_TOKEN
      - A later token has already been processed.\n   GSS_S_GAP_TOKEN - An earlier
      token has not yet been received.\n   A mechanism need not maintain a list of
      all tokens that have been\n   processed in order to support these status codes.
      \ A typical\n   mechanism might retain information about only the most recent
      \"N\"\n   tokens processed, allowing it to distinguish duplicates and missing\n
      \  tokens within the most recent \"N\" messages; the receipt of a token\n   older
      than the most recent \"N\" would result in a GSS_S_OLD_TOKEN\n   status.\n"
    title: 4.3. Replay and out-of-sequence detection
  - contents:
    - "4.4. Anonymous Authentication\n   In certain situations, an application may
      wish to initiate the\n   authentication process to authenticate a peer, without
      revealing its\n   own identity.  As an example, consider an application providing\n
      \  access to a database containing medical information, and offering\n   unrestricted
      access to the service.  A client of such a service might\n   wish to authenticate
      the service (in order to establish trust in any\n   information retrieved from
      it), but might not wish the service to be\n   able to obtain the client's identity
      (perhaps due to privacy concerns\n   about the specific inquiries, or perhaps
      simply to avoid being placed\n   on mailing-lists).\n   In normal use of the
      GSS-API, the initiator's identity is made\n   available to the acceptor as a
      result of the context establishment\n   process.  However, context initiators
      may request that their identity\n   not be revealed to the context acceptor.
      Many mechanisms do not\n   support anonymous authentication, and for such mechanisms
      the request\n   will not be honored.  An authentication token will be still
      be\n   generated, but the application is always informed if a requested\n   service
      is unavailable, and has the option to abort context\n   establishment if anonymity
      is valued above the other security\n   services that would require a context
      to be established.\n   In addition to informing the application that a context
      is\n   established anonymously (via the ret_flags outputs from\n   gss_init_sec_context
      and gss_accept_sec_context), the optional\n   src_name output from gss_accept_sec_context
      and gss_inquire_context\n   will, for such contexts, return a reserved internal-form
      name,\n   defined by the implementation.\n   When presented to gss_display_name,
      this reserved internal-form name\n   will result in a printable name that is
      syntactically distinguishable\n   from any valid principal name supported by
      the implementation,\n   associated with a name-type object identifier with the
      value\n   GSS_C_NT_ANONYMOUS, whose value us given in Appendix A.  The\n   printable
      form of an anonymous name should be chosen such that it\n   implies anonymity,
      since this name may appear in, for example, audit\n   logs.  For example, the
      string \"<anonymous>\" might be a good choice,\n   if no valid printable names
      supported by the implementation can begin\n   with \"<\" and end with \">\".\n"
    title: 4.4. Anonymous Authentication
  - contents:
    - "4.5. Confidentiality\n   If a context supports the confidentiality service,
      gss_wrap may be\n   used to encrypt application messages.  Messages are selectively\n
      \  encrypted, under the control of the conf_req_flag input parameter to\n   gss_wrap.\n"
    title: 4.5. Confidentiality
  - contents:
    - "4.6. Inter-process context transfer\n   GSS-API V2 provides routines (gss_export_sec_context
      and\n   gss_import_sec_context) which allow a security context to be\n   transferred
      between processes on a single machine.  The most common\n   use for such a feature
      is a client-server design where the server is\n   implemented as a single process
      that accepts incoming security\n   contexts, which then launches child processes
      to deal with the data\n   on these contexts.  In such a design, the child processes
      must have\n   access to the security context data structure created within the\n
      \  parent by its call to gss_accept_sec_context so that they can use\n   per-message
      protection services and delete the security context when\n   the communication
      session ends.\n   Since the security context data structure is expected to contain\n
      \  sequencing information, it is impractical in general to share a\n   context
      between processes.  Thus GSS-API provides a call\n   (gss_export_sec_context)
      that the process which currently owns the\n   context can call to declare that
      it has no intention to use the\n   context subsequently, and to create an inter-process
      token containing\n   information needed by the adopting process to successfully
      import the\n   context.  After successful completion of gss_export_sec_context,
      the\n   original security context is made inaccessible to the calling process\n
      \  by GSS-API, and any context handles referring to this context are no\n   longer
      valid.  The originating process transfers the inter-process\n   token to the
      adopting process, which passes it to\n   gss_import_sec_context, and a fresh
      gss_ctx_id_t is created such that\n   it is functionally identical to the original
      context.\n   The inter-process token may contain sensitive data from the original\n
      \  security context (including cryptographic keys). Applications using\n   inter-process
      tokens to transfer security contexts must take\n   appropriate steps to protect
      these tokens in transit.\n   Implementations are not required to support the
      inter-process\n   transfer of security contexts.  The ability to transfer a
      security\n   context is indicated when the context is created, by\n   gss_init_sec_context
      or gss_accept_sec_context setting the\n   GSS_C_TRANS_FLAG bit in their ret_flags
      parameter.\n"
    title: 4.6. Inter-process context transfer
  - contents:
    - "4.7. The use of incomplete contexts\n   Some mechanisms may allow the per-message
      services to be used before\n   the context establishment process is complete.
      \ For example, a\n   mechanism may include sufficient information in its initial
      context-\n   level token for the context acceptor to immediately decode messages\n
      \  protected with gss_wrap or gss_get_mic.  For such a mechanism, the\n   initiating
      application need not wait until subsequent context-level\n   tokens have been
      sent and received before invoking the per-message\n   protection services.\n
      \  The ability of a context to provide per-message services in advance\n   of
      complete context establishment is indicated by the setting of the\n   GSS_C_PROT_READY_FLAG
      bit in the ret_flags parameter from\n   gss_init_sec_context and gss_accept_sec_context.
      Applications wishing\n   to use per-message protection services on partially-established\n
      \  contexts should check this flag before attempting to invoke gss_wrap\n   or
      gss_get_mic.\n"
    title: 4.7. The use of incomplete contexts
  title: 4.   Additional Controls
- contents:
  - "5. GSS-API Routine Descriptions\n   In addition to the explicit major status
    codes documented here, the\n   code GSS_S_FAILURE may be returned by any routine,
    indicating an\n   implementation-specific or mechanism-specific error condition,\n
    \  further details of which are reported via the minor_status parameter.\n"
  - contents:
    - "5.1. gss_accept_sec_context\n   OM_uint32 gss_accept_sec_context (\n     OM_uint32
      \          *minor_status,\n     gss_ctx_id_t        *context_handle,\n     const
      gss_cred_id_t acceptor_cred_handle,\n     const gss_buffer_t  input_token_buffer,\n
      \    const gss_channel_bindings_t  input_chan_bindings,\n     const gss_name_t
      \   *src_name,\n     gss_OID             *mech_type,\n     gss_buffer_t        output_token,\n
      \    OM_uint32           *ret_flags,\n     OM_uint32           *time_rec,\n
      \    gss_cred_id_t       *delegated_cred_handle)\n   Purpose:\n   Allows a remotely
      initiated security context between the application\n   and a remote peer to
      be established.  The routine may return a\n   output_token which should be transferred
      to the peer application,\n   where the peer application will present it to gss_init_sec_context.\n
      \  If no token need be sent, gss_accept_sec_context will indicate this\n   by
      setting the length field of the output_token argument to zero.  To\n   complete
      the context establishment, one or more reply tokens may be\n   required from
      the peer application; if so, gss_accept_sec_context\n   will return a status
      flag of GSS_S_CONTINUE_NEEDED, in which case it\n   should be called again when
      the reply token is received from the peer\n   application, passing the token
      to gss_accept_sec_context via the\n   input_token parameters.\n   Portable applications
      should be constructed to use the token length\n   and return status to determine
      whether a token needs to be sent or\n   waited for.  Thus a typical portable
      caller should always invoke\n   gss_accept_sec_context within a loop:\n   gss_ctx_id_t
      context_hdl = GSS_C_NO_CONTEXT;\n   do {\n     receive_token_from_peer(input_token);\n
      \    maj_stat = gss_accept_sec_context(&min_stat,\n                                       &context_hdl,\n
      \                                      cred_hdl,\n                                       input_token,\n
      \                                      input_bindings,\n                                       &client_name,\n
      \                                      &mech_type,\n                                       output_token,\n
      \                                      &ret_flags,\n                                       &time_rec,\n
      \                                      &deleg_cred);\n     if (GSS_ERROR(maj_stat))
      {\n       report_error(maj_stat, min_stat);\n     };\n     if (output_token->length
      != 0) {\n       send_token_to_peer(output_token);\n       gss_release_buffer(&min_stat,
      output_token);\n     };\n     if (GSS_ERROR(maj_stat)) {\n       if (context_hdl
      != GSS_C_NO_CONTEXT)\n         gss_delete_sec_context(&min_stat,\n                                &context_hdl,\n
      \                               GSS_C_NO_BUFFER);\n       break;\n     };\n
      \  } while (maj_stat & GSS_S_CONTINUE_NEEDED);\n   Whenever the routine returns
      a major status that includes the value\n   GSS_S_CONTINUE_NEEDED, the context
      is not fully established and the\n   following restrictions apply to the output
      parameters:\n   The value returned via the time_rec parameter is undefined Unless
      the\n   accompanying ret_flags parameter contains the bit\n   GSS_C_PROT_READY_FLAG,
      indicating that per-message services may be\n   applied in advance of a successful
      completion status, the value\n   returned via the mech_type parameter may be
      undefined until the\n   routine returns a major status value of GSS_S_COMPLETE.\n
      \  The values of the GSS_C_DELEG_FLAG,\n   GSS_C_MUTUAL_FLAG,GSS_C_REPLAY_FLAG,
      GSS_C_SEQUENCE_FLAG,\n   GSS_C_CONF_FLAG,GSS_C_INTEG_FLAG and GSS_C_ANON_FLAG
      bits returned\n   via the ret_flags parameter should contain the values that
      the\n   implementation expects would be valid if context establishment were\n
      \  to succeed.\n   The values of the GSS_C_PROT_READY_FLAG and GSS_C_TRANS_FLAG
      bits\n   within ret_flags should indicate the actual state at the time\n   gss_accept_sec_context
      returns, whether or not the context is fully\n   established.\n   Although this
      requires that GSS-API implementations set the\n   GSS_C_PROT_READY_FLAG in the
      final ret_flags returned to a caller\n   (i.e. when accompanied by a GSS_S_COMPLETE
      status code), applications\n   should not rely on this behavior as the flag
      was not defined in\n   Version 1 of the GSS-API. Instead, applications should
      be prepared to\n   use per-message services after a successful context establishment,\n
      \  according to the GSS_C_INTEG_FLAG and GSS_C_CONF_FLAG values.\n   All other
      bits within the ret_flags argument should be set to zero.\n   While the routine
      returns GSS_S_CONTINUE_NEEDED, the values returned\n   via the ret_flags argument
      indicate the services that the\n   implementation expects to be available from
      the established context.\n   If the initial call of gss_accept_sec_context()
      fails, the\n   implementation should not create a context object, and should
      leave\n   the value of the context_handle parameter set to GSS_C_NO_CONTEXT
      to\n   indicate this.  In the event of a failure on a subsequent call, the\n
      \  implementation is permitted to delete the \"half-built\" security\n   context
      (in which case it should set the context_handle parameter to\n   GSS_C_NO_CONTEXT),
      but the preferred behavior is to leave the\n   security context (and the context_handle
      parameter) untouched for the\n   application to delete (using gss_delete_sec_context).\n
      \  During context establishment, the informational status bits\n   GSS_S_OLD_TOKEN
      and GSS_S_DUPLICATE_TOKEN indicate fatal errors, and\n   GSS-API mechanisms
      should always return them in association with a\n   routine error of GSS_S_FAILURE.
      \ This requirement for pairing did not\n   exist in version 1 of the GSS-API
      specification, so applications that\n   wish to run over version 1 implementations
      must special-case these\n   codes.\n   Parameters:\n   context_handle    gss_ctx_id_t,
      read/modify context handle for new\n                        context.  Supply
      GSS_C_NO_CONTEXT for first\n                        call; use value returned
      in subsequent calls.\n                        Once gss_accept_sec_context()
      has returned a\n                        value via this parameter, resources
      have been\n                        assigned to the corresponding context, and
      must\n                        be freed by the application after use with a\n
      \                       call to gss_delete_sec_context().\n   acceptor_cred_handle
      \ gss_cred_id_t, read Credential handle claimed\n                         by
      context acceptor. Specify\n                         GSS_C_NO_CREDENTIAL to accept
      the context as a\n                         default principal.  If GSS_C_NO_CREDENTIAL
      is\n                         specified, but no default acceptor principal is\n
      \                        defined, GSS_S_NO_CRED will be returned.\n   input_token_buffer
      \  buffer, opaque, read token obtained from remote\n                        application.\n
      \  input_chan_bindings  channel bindings, read, optional Application-\n                        specified
      bindings.  Allows application to\n                        securely bind channel
      identification information\n                        to the security context.
      \ If channel bindings\n                        are not used, specify GSS_C_NO_CHANNEL_BINDINGS.\n
      \  src_name             gss_name_t, modify, optional Authenticated name\n                        of
      context initiator.  After use, this name\n                        should be
      deallocated by passing it to\n                        gss_release_name().  If
      not required, specify\n                        NULL.\n   mech_type            Object
      ID, modify, optional Security mechanism\n                        used.  The
      returned OID value will be a pointer\n                        into static storage,
      and should be treated as\n                        read-only by the caller (in
      particular, it does\n                        not need to be freed).  If not
      required, specify\n                        NULL.\n   output_token         buffer,
      opaque, modify Token to be passed to\n                        peer application.
      \ If the length field of the\n                        returned token buffer
      is 0, then no token need\n                        be passed to the peer application.
      \ If a non-\n                        zero length field is returned, the associated\n
      \                       storage must be freed after use by the\n                        application
      with a call to gss_release_buffer().\n   ret_flags            bit-mask, modify,
      optional Contains various\n                        independent flags, each of
      which indicates that\n                        the context supports a specific
      service option.\n                        If not needed, specify NULL.  Symbolic
      names are\n                        provided for each flag, and the symbolic
      names\n                        corresponding to the required flags should be\n
      \                       logically-ANDed with the ret_flags value to test\n                        whether
      a given option is supported by the\n                        context.  The flags
      are:\n                        GSS_C_DELEG_FLAG\n                        True
      - Delegated credentials are available\n                               via the
      delegated_cred_handle\n                               parameter\n                        False
      - No credentials were delegated\n                        GSS_C_MUTUAL_FLAG\n
      \                       True - Remote peer asked for mutual\n                               authentication\n
      \                       False - Remote peer did not ask for mutual\n                                authentication\n
      \                       GSS_C_REPLAY_FLAG\n                        True - replay
      of protected messages\n                               will be detected\n                        False
      - replayed messages will not be\n                                detected\n
      \                       GSS_C_SEQUENCE_FLAG\n                        True -
      out-of-sequence protected\n                               messages will be detected\n
      \                       False - out-of-sequence messages will not\n                                be
      detected\n                        GSS_C_CONF_FLAG\n                        True
      - Confidentiality service may be\n                               invoked by
      calling the gss_wrap\n                               routine\n                        False
      - No confidentiality service (via\n                                gss_wrap)
      available. gss_wrap will\n                                provide message encapsulation,\n
      \                               data-origin authentication and\n                                integrity
      services only.\n                        GSS_C_INTEG_FLAG\n                        True
      - Integrity service may be invoked by\n                               calling
      either gss_get_mic or\n                               gss_wrap routines.\n                        False
      - Per-message integrity service\n                                unavailable.\n
      \                       GSS_C_ANON_FLAG\n                        True - The
      initiator does not wish to\n                               be authenticated;
      the src_name\n                               parameter (if requested) contains\n
      \                              an anonymous internal name.\n                        False
      - The initiator has been\n                                authenticated normally.\n
      \                       GSS_C_PROT_READY_FLAG\n                        True
      - Protection services (as specified\n                               by the states
      of the GSS_C_CONF_FLAG\n                               and GSS_C_INTEG_FLAG)
      are available\n                               if the accompanying major status\n
      \                              return value is either GSS_S_COMPLETE\n                               or
      GSS_S_CONTINUE_NEEDED.\n                        False - Protection services
      (as specified\n                                by the states of the GSS_C_CONF_FLAG\n
      \                               and GSS_C_INTEG_FLAG) are available\n                                only
      if the accompanying major status\n                                return value
      is GSS_S_COMPLETE.\n                        GSS_C_TRANS_FLAG\n                        True
      - The resultant security context may\n                               be transferred
      to other processes via\n                               a call to gss_export_sec_context().\n
      \                       False - The security context is not\n                                transferable.\n
      \                       All other bits should be set to zero.\n   time_rec             Integer,
      modify, optional\n                        number of seconds for which the context
      will\n                        remain valid. Specify NULL if not required.\n
      \  delegated_cred_handle\n                        gss_cred_id_t, modify, optional
      credential\n                        handle for credentials received from context\n
      \                       initiator.  Only valid if deleg_flag in\n                        ret_flags
      is true, in which case an explicit\n                        credential handle
      (i.e. not GSS_C_NO_CREDENTIAL)\n                        will be returned; if
      deleg_flag is false,\n                        gss_accept_context() will set
      this parameter to\n                        GSS_C_NO_CREDENTIAL.  If a credential
      handle is\n                        returned, the associated resources must be\n
      \                       released by the application after use with a\n                        call
      to gss_release_cred().  Specify NULL if not\n                        required.\n
      \  minor_status         Integer, modify\n                        Mechanism specific
      status code.\n   GSS_S_CONTINUE_NEEDED Indicates that a token from the peer\n
      \                        application is required to complete the\n                         context,
      and that gss_accept_sec_context must\n                         be called again
      with that token.\n   GSS_S_DEFECTIVE_TOKEN Indicates that consistency checks
      performed on\n                         the input_token failed.\n   GSS_S_DEFECTIVE_CREDENTIAL
      Indicates that consistency checks\n                         performed on the
      credential failed.\n   GSS_S_NO_CRED     The supplied credentials were not valid
      for context\n                         acceptance, or the credential handle did
      not\n                         reference any credentials.\n   GSS_S_CREDENTIALS_EXPIRED
      The referenced credentials have expired.\n   GSS_S_BAD_BINDINGS  The input_token
      contains different channel\n                         bindings to those specified
      via the\n                         input_chan_bindings parameter.\n   GSS_S_NO_CONTEXT
      \ Indicates that the supplied context handle did not\n                         refer
      to a valid context.\n   GSS_S_BAD_SIG     The input_token contains an invalid
      MIC.\n   GSS_S_OLD_TOKEN   The input_token was too old.  This is a fatal error\n
      \                        during context establishment.\n   GSS_S_DUPLICATE_TOKEN
      The input_token is valid, but is a duplicate of\n                         a
      token already processed.  This is a fatal\n                         error during
      context establishment.\n   GSS_S_BAD_MECH    The received token specified a
      mechanism that is\n                         not supported by the implementation
      or the\n                         provided credential.\n"
    title: 5.1. gss_accept_sec_context
  - contents:
    - "5.2. gss_acquire_cred\n   OM_uint32 gss_acquire_cred (\n     OM_uint32         *minor_status,\n
      \    const gss_name_t  desired_name,\n     OM_uint32         time_req,\n     const
      gss_OID_set desired_mechs,\n     gss_cred_usage_t  cred_usage,\n     gss_cred_id_t
      \    *output_cred_handle,\n     gss_OID_set       *actual_mechs,\n     OM_uint32
      \        *time_rec)\n   Purpose:\n   Allows an application to acquire a handle
      for a pre-existing\n   credential by name.  GSS-API implementations must impose
      a local\n   access-control policy on callers of this routine to prevent\n   unauthorized
      callers from acquiring credentials to which they are not\n   entitled.  This
      routine is not intended to provide a \"login to the\n   network\" function,
      as such a function would involve the creation of\n   new credentials rather
      than merely acquiring a handle to existing\n   credentials.  Such functions,
      if required, should be defined in\n   implementation-specific extensions to
      the API.\n   If desired_name is GSS_C_NO_NAME, the call is interpreted as a\n
      \  request for a credential handle that will invoke default behavior\n   when
      passed to gss_init_sec_context() (if cred_usage is\n   GSS_C_INITIATE or GSS_C_BOTH)
      or gss_accept_sec_context() (if\n   cred_usage is GSS_C_ACCEPT or GSS_C_BOTH).\n
      \  Mechanisms should honor the desired_mechs parameter, and return a\n   credential
      that is suitable to use only with the requested\n   mechanisms.  An exception
      to this is the case where one underlying\n   credential element can be shared
      by multiple mechanisms; in this case\n   it is permissible for an implementation
      to indicate all mechanisms\n   with which the credential element may be used.
      \ If desired_mechs is\n   an empty set, behavior is undefined.\n   This routine
      is expected to be used primarily by context acceptors,\n   since implementations
      are likely to provide mechanism-specific ways\n   of obtaining GSS-API initiator
      credentials from the system login\n   process.  Some implementations may therefore
      not support the\n   acquisition of GSS_C_INITIATE or GSS_C_BOTH credentials
      via\n   gss_acquire_cred for any name other than GSS_C_NO_NAME, or a name\n
      \  produced by applying either gss_inquire_cred to a valid credential,\n   or
      gss_inquire_context to an active context.\n   If credential acquisition is time-consuming
      for a mechanism, the\n   mechanism may choose to delay the actual acquisition
      until the\n   credential is required (e.g. by gss_init_sec_context or\n   gss_accept_sec_context).
      \ Such mechanism-specific implementation\n   decisions should be invisible to
      the calling application; thus a call\n   of gss_inquire_cred immediately following
      the call of\n   gss_acquire_cred must return valid credential data, and may
      therefore\n   incur the overhead of a deferred credential acquisition.\n   Parameters:\n
      \  desired_name      gss_name_t, read\n                     Name of principal
      whose credential\n                     should be acquired\n   time_req          Integer,
      read, optional\n                     number of seconds that credentials\n                     should
      remain valid. Specify GSS_C_INDEFINITE\n                     to request that
      the credentials have the maximum\n                     permitted lifetime.\n
      \  desired_mechs     Set of Object IDs, read, optional\n                     set
      of underlying security mechanisms that\n                     may be used.  GSS_C_NO_OID_SET
      may be used\n                     to obtain an implementation-specific default.\n
      \  cred_usage        gss_cred_usage_t, read\n                     GSS_C_BOTH
      - Credentials may be used\n                        either to initiate or accept\n
      \                       security contexts.\n                     GSS_C_INITIATE
      - Credentials will only be\n                        used to initiate security
      contexts.\n                     GSS_C_ACCEPT - Credentials will only be used
      to\n                        accept security contexts.\n   output_cred_handle
      \ gss_cred_id_t, modify\n                       The returned credential handle.
      \ Resources\n                       associated with this credential handle must\n
      \                      be released by the application after use\n                       with
      a call to gss_release_cred().\n   actual_mechs      Set of Object IDs, modify,
      optional\n                     The set of mechanisms for which the\n                     credential
      is valid.  Storage associated\n                     with the returned OID-set
      must be released by\n                     the application after use with a call
      to\n                     gss_release_oid_set().  Specify NULL if not\n                     required.\n
      \  time_rec          Integer, modify, optional\n                     Actual
      number of seconds for which the\n                     returned credentials will
      remain valid.  If the\n                     implementation does not support
      expiration of\n                     credentials, the value GSS_C_INDEFINITE
      will\n                     be returned. Specify NULL if not required\n   minor_status
      \     Integer, modify\n                     Mechanism specific status code.\n
      \  Function value:  GSS status code\n   GSS_S_COMPLETE    Successful completion\n
      \  GSS_S_BAD_MECH    Unavailable mechanism requested\n   GSS_S_BAD_NAMETYPE
      Type contained within desired_name parameter\n                      is not supported\n
      \  GSS_S_BAD_NAME    Value supplied for desired_name parameter is ill\n                     formed.\n
      \  GSS_S_CREDENTIALS_EXPIRED The credentials could not be acquired\n                             Because
      they have expired.\n   GSS_S_NO_CRED     No credentials were found for the specified
      name.\n"
    title: 5.2. gss_acquire_cred
  - contents:
    - "5.3. gss_add_cred\n   OM_uint32 gss_add_cred (\n     OM_uint32           *minor_status,\n
      \    const gss_cred_id_t input_cred_handle,\n     const gss_name_t    desired_name,\n
      \    const gss_OID       desired_mech,\n     gss_cred_usage_t    cred_usage,\n
      \    OM_uint32           initiator_time_req,\n     OM_uint32           acceptor_time_req,\n
      \    gss_cred_id_t       *output_cred_handle,\n     gss_OID_set         *actual_mechs,\n
      \    OM_uint32           *initiator_time_rec,\n     OM_uint32           *acceptor_time_rec)\n
      \  Purpose:\n   Adds a credential-element to a credential.  The credential-element
      is\n   identified by the name of the principal to which it refers.  GSS-API\n
      \  implementations must impose a local access-control policy on callers\n   of
      this routine to prevent unauthorized callers from acquiring\n   credential-elements
      to which they are not entitled. This routine is\n   not intended to provide
      a \"login to the network\" function, as such a\n   function would involve the
      creation of new mechanism-specific\n   authentication data, rather than merely
      acquiring a GSS-API handle to\n   existing data.  Such functions, if required,
      should be defined in\n   implementation-specific extensions to the API.\n   If
      desired_name is GSS_C_NO_NAME, the call is interpreted as a\n   request to add
      a credential element that will invoke default behavior\n   when passed to gss_init_sec_context()
      (if cred_usage is\n   GSS_C_INITIATE or GSS_C_BOTH) or gss_accept_sec_context()
      (if\n   cred_usage is GSS_C_ACCEPT or GSS_C_BOTH).\n   This routine is expected
      to be used primarily by context acceptors,\n   since implementations are likely
      to provide mechanism-specific ways\n   of obtaining GSS-API initiator credentials
      from the system login\n   process.  Some implementations may therefore not support
      the\n   acquisition of GSS_C_INITIATE or GSS_C_BOTH credentials via\n   gss_acquire_cred
      for any name other than GSS_C_NO_NAME, or a name\n   produced by applying either
      gss_inquire_cred to a valid credential,\n   or gss_inquire_context to an active
      context.\n   If credential acquisition is time-consuming for a mechanism, the\n
      \  mechanism may choose to delay the actual acquisition until the\n   credential
      is required (e.g. by gss_init_sec_context or\n   gss_accept_sec_context).  Such
      mechanism-specific implementation\n   decisions should be invisible to the calling
      application; thus a call\n   of gss_inquire_cred immediately following the call
      of gss_add_cred\n   must return valid credential data, and may therefore incur
      the\n   overhead of a deferred credential acquisition.\n   This routine can
      be used to either compose a new credential\n   containing all credential-elements
      of the original in addition to the\n   newly-acquire credential-element, or
      to add the new credential-\n   element to an existing credential. If NULL is
      specified for the\n   output_cred_handle parameter argument, the new credential-element\n
      \  will be added to the credential identified by input_cred_handle; if a\n   valid
      pointer is specified for the output_cred_handle parameter, a\n   new credential
      handle will be created.\n   If GSS_C_NO_CREDENTIAL is specified as the input_cred_handle,\n
      \  gss_add_cred will compose a credential (and set the\n   output_cred_handle
      parameter accordingly) based on default behavior.\n   That is, the call will
      have the same effect as if the application had\n   first made a call to gss_acquire_cred(),
      specifying the same usage\n   and passing GSS_C_NO_NAME as the desired_name
      parameter to obtain an\n   explicit credential handle embodying default behavior,
      passed this\n   credential handle to gss_add_cred(), and finally called\n   gss_release_cred()
      on the first credential handle.\n   If GSS_C_NO_CREDENTIAL is specified as the
      input_cred_handle\n   parameter, a non-NULL output_cred_handle must be supplied.\n
      \  Parameters:\n   minor_status      Integer, modify\n                     Mechanism
      specific status code.\n   input_cred_handle gss_cred_id_t, read, optional\n
      \                    The credential to which a credential-element\n                     will
      be added.  If GSS_C_NO_CREDENTIAL is\n                     specified, the routine
      will compose the new\n                     credential based on default behavior
      (see\n                     description above).  Note that, while the\n                     credential-handle
      is not modified by\n                     gss_add_cred(), the underlying credential\n
      \                    will be modified if output_credential_handle\n                     is
      NULL.\n   desired_name      gss_name_t, read.\n                     Name of
      principal whose credential\n                     should be acquired.\n   desired_mech
      \     Object ID, read\n                     Underlying security mechanism with
      which the\n                     credential may be used.\n   cred_usage        gss_cred_usage_t,
      read\n                     GSS_C_BOTH - Credential may be used\n                     either
      to initiate or accept\n                     security contexts.\n                     GSS_C_INITIATE
      - Credential will only be\n                                      used to initiate
      security\n                                      contexts.\n                     GSS_C_ACCEPT
      - Credential will only be used to\n                                    accept
      security contexts.\n   initiator_time_req Integer, read, optional\n                      number
      of seconds that the credential\n                      should remain valid for
      initiating security\n                      contexts.  This argument is ignored
      if the\n                      composed credentials are of type GSS_C_ACCEPT.\n
      \                     Specify GSS_C_INDEFINITE to request that the\n                      credentials
      have the maximum permitted\n                      initiator lifetime.\n   acceptor_time_req
      Integer, read, optional\n                     number of seconds that the credential\n
      \                    should remain valid for accepting security\n                     contexts.
      \ This argument is ignored if the\n                     composed credentials
      are of type GSS_C_INITIATE.\n                     Specify GSS_C_INDEFINITE to
      request that the\n                     credentials have the maximum permitted
      initiator\n                     lifetime.\n   output_cred_handle gss_cred_id_t,
      modify, optional\n                      The returned credential handle, containing\n
      \                     the new credential-element and all the\n                      credential-elements
      from input_cred_handle.\n                      If a valid pointer to a gss_cred_id_t
      is\n                      supplied for this parameter, gss_add_cred\n                      creates
      a new credential handle containing all\n                      credential-elements
      from the input_cred_handle\n                      and the newly acquired credential-element;
      if\n                      NULL is specified for this parameter, the newly\n
      \                     acquired credential-element will be added\n                      to
      the credential identified by input_cred_handle.\n                      The resources
      associated with any credential\n                      handle returned via this
      parameter must be\n                      released by the application after use
      with a\n                      call to gss_release_cred().\n   actual_mechs      Set
      of Object IDs, modify, optional\n                     The complete set of mechanisms
      for which\n                     the new credential is valid.  Storage for\n
      \                    the returned OID-set must be freed by the\n                     application
      after use with a call to\n                     gss_release_oid_set(). Specify
      NULL if\n                     not required.\n   initiator_time_rec Integer,
      modify, optional\n                      Actual number of seconds for which the\n
      \                     returned credentials will remain valid for\n                      initiating
      contexts using the specified\n                      mechanism.  If the implementation
      or mechanism\n                      does not support expiration of credentials,
      the\n                      value GSS_C_INDEFINITE will be returned. Specify\n
      \                     NULL if not required\n   acceptor_time_rec Integer, modify,
      optional\n                     Actual number of seconds for which the\n                     returned
      credentials will remain valid for\n                     accepting security contexts
      using the specified\n                     mechanism.  If the implementation
      or mechanism\n                     does not support expiration of credentials,
      the\n                     value GSS_C_INDEFINITE will be returned. Specify\n
      \                    NULL if not required\n   Function value:   GSS status code\n
      \  GSS_S_COMPLETE    Successful completion\n   GSS_S_BAD_MECH    Unavailable
      mechanism requested\n   GSS_S_BAD_NAMETYPE Type contained within desired_name
      parameter\n                     is not supported\n   GSS_S_BAD_NAME    Value
      supplied for desired_name parameter is\n                     ill-formed.\n   GSS_S_DUPLICATE_ELEMENT
      The credential already contains an element\n                     for the requested
      mechanism with overlapping\n                     usage and validity period.\n
      \  GSS_S_CREDENTIALS_EXPIRED The required credentials could not be\n                     added
      because they have expired.\n   GSS_S_NO_CRED     No credentials were found for
      the specified name.\n"
    title: 5.3. gss_add_cred
  - contents:
    - "5.4. gss_add_oid_set_member\n   OM_uint32 gss_add_oid_set_member (\n     OM_uint32
      \      *minor_status,\n     const gss_OID   member_oid,\n     gss_OID_set     *oid_set)\n
      \  Purpose:\n   Add an Object Identifier to an Object Identifier set.  This
      routine\n   is intended for use in conjunction with gss_create_empty_oid_set
      when\n   constructing a set of mechanism OIDs for input to gss_acquire_cred.\n
      \  The oid_set parameter must refer to an OID-set that was created by\n   GSS-API
      (e.g. a set returned by gss_create_empty_oid_set()). GSS-API\n   creates a copy
      of the member_oid and inserts this copy into the set,\n   expanding the storage
      allocated to the OID-set's elements array if\n   necessary.  The routine may
      add the new member OID anywhere within\n   the elements array, and implementations
      should verify that the new\n   member_oid is not already contained within the
      elements array; if the\n   member_oid is already present, the oid_set should
      remain unchanged.\n   Parameters:\n      minor_status      Integer, modify\n
      \                       Mechanism specific status code\n      member_oid        Object
      ID, read\n                        The object identifier to copied into\n                        the
      set.\n      oid_set           Set of Object ID, modify\n                        The
      set in which the object identifier\n                        should be inserted.\n
      \  Function value:   GSS status code\n      GSS_S_COMPLETE    Successful completion\n"
    title: 5.4. gss_add_oid_set_member
  - contents:
    - "5.5. gss_canonicalize_name\n   OM_uint32 gss_canonicalize_name (\n     OM_uint32
      \       *minor_status,\n     const gss_name_t input_name,\n     const gss_OID
      \   mech_type,\n     gss_name_t       *output_name)\n   Purpose:\n   Generate
      a canonical mechanism name (MN) from an arbitrary internal\n   name.  The mechanism
      name is the name that would be returned to a\n   context acceptor on successful
      authentication of a context where the\n   initiator used the input_name in a
      successful call to\n   gss_acquire_cred, specifying an OID set containing <mech_type>
      as its\n   only member, followed by a call to gss_init_sec_context, specifying\n
      \  <mech_type> as the authentication mechanism.\n   Parameters:\n   minor_status
      \     Integer, modify\n                     Mechanism specific status code\n
      \  input_name        gss_name_t, read\n                     The name for which
      a canonical form is\n                     desired\n   mech_type         Object
      ID, read\n                     The authentication mechanism for which the\n
      \                    canonical form of the name is desired.  The\n                     desired
      mechanism must be specified explicitly;\n                     no default is
      provided.\n   output_name       gss_name_t, modify\n                     The
      resultant canonical name.  Storage\n                     associated with this
      name must be freed by\n                     the application after use with a
      call to\n                     gss_release_name().\n   Function value:   GSS
      status code\n   GSS_S_COMPLETE    Successful completion.\n   GSS_S_BAD_MECH
      \   The identified mechanism is not supported.\n   GSS_S_BAD_NAMETYPE The provided
      internal name contains no elements\n                     that could be processed
      by the specified\n                     mechanism.\n   GSS_S_BAD_NAME    The
      provided internal name was ill-formed.\n"
    title: 5.5. gss_canonicalize_name
  - contents:
    - "5.6. gss_compare_name\n   OM_uint32 gss_compare_name (\n     OM_uint32        *minor_status,\n
      \    const gss_name_t name1,\n     const gss_name_t name2,\n     int              *name_equal)\n
      \  Purpose:\n   Allows an application to compare two internal-form names to
      determine\n   whether they refer to the same entity.\n   If either name presented
      to gss_compare_name denotes an anonymous\n   principal, the routines should
      indicate that the two names do not\n   refer to the same identity.\n   Parameters:\n
      \  minor_status      Integer, modify\n                     Mechanism specific
      status code.\n   name1             gss_name_t, read\n                     internal-form
      name\n   name2             gss_name_t, read\n                     internal-form
      name\n   name_equal        boolean, modify\n                     non-zero -
      names refer to same entity\n                     zero - names refer to different
      entities\n                           (strictly, the names are not known\n                           to
      refer to the same identity).\n   Function value:   GSS status code\n   GSS_S_COMPLETE
      \   Successful completion\n   GSS_S_BAD_NAMETYPE The two names were of incomparable
      types.\n   GSS_S_BAD_NAME    One or both of name1 or name2 was ill-formed.\n"
    title: 5.6. gss_compare_name
  - contents:
    - "5.7. gss_context_time\n   OM_uint32 gss_context_time (\n     OM_uint32          *minor_status,\n
      \    const gss_ctx_id_t context_handle,\n     OM_uint32          *time_rec)\n
      \  Purpose:\n   Determines the number of seconds for which the specified context
      will\n   remain valid.\n   Parameters:\n   minor_status      Integer, modify\n
      \                    Implementation specific status code.\n   context_handle
      \   gss_ctx_id_t, read\n                     Identifies the context to be interrogated.\n
      \  time_rec          Integer, modify\n                     Number of seconds
      that the context will remain\n                     valid.  If the context has
      already expired,\n                     zero will be returned.\n   Function value:
      \  GSS status code\n   GSS_S_COMPLETE    Successful completion\n   GSS_S_CONTEXT_EXPIRED
      The context has already expired\n   GSS_S_NO_CONTEXT  The context_handle parameter
      did not identify\n                     a valid context\n"
    title: 5.7. gss_context_time
  - contents:
    - "5.8. gss_create_empty_oid_set\n   OM_uint32 gss_create_empty_oid_set (\n     OM_uint32
      \   *minor_status,\n     gss_OID_set  *oid_set)\n   Purpose:\n   Create an object-identifier
      set containing no object identifiers, to\n   which members may be subsequently
      added using the\n   gss_add_oid_set_member() routine.  These routines are intended
      to be\n   used to construct sets of mechanism object identifiers, for input
      to\n   gss_acquire_cred.\n   Parameters:\n   minor_status      Integer, modify\n
      \                    Mechanism specific status code\n   oid_set           Set
      of Object IDs, modify\n                     The empty object identifier set.\n
      \                    The routine will allocate the\n                     gss_OID_set_desc
      object, which the\n                     application must free after use with\n
      \                    a call to gss_release_oid_set().\n   Function value:   GSS
      status code\n   GSS_S_COMPLETE    Successful completion\n"
    title: 5.8. gss_create_empty_oid_set
  - contents:
    - "5.9. gss_delete_sec_context\n   OM_uint32 gss_delete_sec_context (\n     OM_uint32
      \   *minor_status,\n     gss_ctx_id_t *context_handle,\n     gss_buffer_t output_token)\n
      \  Purpose:\n   Delete a security context.  gss_delete_sec_context will delete
      the\n   local data structures associated with the specified security context,\n
      \  and may generate an output_token, which when passed to the peer\n   gss_process_context_token
      will instruct it to do likewise.  If no\n   token is required by the mechanism,
      the GSS-API should set the length\n   field of the output_token (if provided)
      to zero.  No further security\n   services may be obtained using the context
      specified by\n   context_handle.\n   In addition to deleting established security
      contexts,\n   gss_delete_sec_context must also be able to delete \"half-built\"\n
      \  security contexts resulting from an incomplete sequence of\n   gss_init_sec_context()/gss_accept_sec_context()
      calls.\n   The output_token parameter is retained for compatibility with version\n
      \  1 of the GSS-API.  It is recommended that both peer applications\n   invoke
      gss_delete_sec_context passing the value GSS_C_NO_BUFFER for\n   the output_token
      parameter, indicating that no token is required, and\n   that gss_delete_sec_context
      should simply delete local context data\n   structures.  If the application
      does pass a valid buffer to\n   gss_delete_sec_context, mechanisms are encouraged
      to return a zero-\n   length token, indicating that no peer action is necessary,
      and that\n   no token should be transferred by the application.\n   Parameters:\n
      \  minor_status      Integer, modify\n                     Mechanism specific
      status code.\n   context_handle    gss_ctx_id_t, modify\n                     context
      handle identifying context to delete.\n                     After deleting the
      context, the GSS-API will set\n                     this context handle to GSS_C_NO_CONTEXT.\n
      \  output_token      buffer, opaque, modify, optional\n                     token
      to be sent to remote application to\n                     instruct it to also
      delete the context.  It\n                     is recommended that applications
      specify\n                     GSS_C_NO_BUFFER for this parameter, requesting\n
      \                    local deletion only.  If a buffer parameter is\n                     provided
      by the application, the mechanism may\n                     return a token in
      it;  mechanisms that implement\n                     only local deletion should
      set the length field of\n                     this token to zero to indicate
      to the application\n                     that no token is to be sent to the
      peer.\n   Function value:   GSS status code\n   GSS_S_COMPLETE    Successful
      completion\n   GSS_S_NO_CONTEXT  No valid context was supplied\n"
    title: 5.9. gss_delete_sec_context
  - contents:
    - "5.10.gss_display_name\n   OM_uint32 gss_display_name (\n     OM_uint32        *minor_status,\n
      \    const gss_name_t input_name,\n     gss_buffer_t     output_name_buffer,\n
      \    gss_OID          *output_name_type)\n   Purpose:\n   Allows an application
      to obtain a textual representation of an opaque\n   internal-form  name for
      display purposes.  The syntax of a printable\n   name is defined by the GSS-API
      implementation.\n   If input_name denotes an anonymous principal, the implementation\n
      \  should return the gss_OID value GSS_C_NT_ANONYMOUS as the\n   output_name_type,
      and a textual name that is syntactically distinct\n   from all valid supported
      printable names in output_name_buffer.\n   If input_name was created by a call
      to gss_import_name, specifying\n   GSS_C_NO_OID as the name-type, implementations
      that employ lazy\n   conversion between name types may return GSS_C_NO_OID via
      the\n   output_name_type parameter.\n   Parameters:\n   minor_status      Integer,
      modify\n                     Mechanism specific status code.\n   input_name
      \       gss_name_t, read\n                     name to be displayed\n   output_name_buffer
      \ buffer, character-string, modify\n                     buffer to receive textual
      name string.\n                     The application must free storage associated\n
      \                    with this name after use with a call to\n                     gss_release_buffer().\n
      \  output_name_type  Object ID, modify, optional\n                     The type
      of the returned name.  The returned\n                     gss_OID will be a
      pointer into static storage,\n                     and should be treated as
      read-only by the caller\n                     (in particular, the application
      should not attempt\n                     to free it). Specify NULL if not required.\n
      \  Function value:   GSS status code\n   GSS_S_COMPLETE    Successful completion\n
      \  GSS_S_BAD_NAME    input_name was ill-formed\n"
    title: 5.10.gss_display_name
  - contents:
    - "5.11.gss_display_status\n   OM_uint32 gss_display_status (\n     OM_uint32
      \     *minor_status,\n     OM_uint32      status_value,\n     int            status_type,\n
      \    const gss_OID  mech_type,\n     OM_uint32      *message_context,\n     gss_buffer_t
      \  status_string)\n   Purpose:\n   Allows an application to obtain a textual
      representation of a GSS-API\n   status code, for display to the user or for
      logging purposes.  Since\n   some status values may indicate multiple conditions,
      applications may\n   need to call gss_display_status multiple times, each call
      generating\n   a single text string.  The message_context parameter is used
      by\n   gss_display_status to store state information about which error\n   messages
      have already been extracted from a given status_value;\n   message_context must
      be initialized to 0 by the application prior to\n   the first call, and gss_display_status
      will return a non-zero value\n   in this parameter if there are further messages
      to extract.\n   The message_context parameter contains all state information
      required\n   by gss_display_status in order to extract further messages from
      the\n   status_value;  even when a non-zero value is returned in this\n   parameter,
      the application is not required to call gss_display_status\n   again unless
      subsequent messages are desired.  The following code\n   extracts all messages
      from a given status code and prints them to\n   stderr:\n   OM_uint32 message_context;\n
      \  OM_uint32 status_code;\n   OM_uint32 maj_status;\n   OM_uint32 min_status;\n
      \  gss_buffer_desc status_string;\n          ...\n   message_context = 0;\n
      \  do {\n     maj_status = gss_display_status (\n                     &min_status,\n
      \                    status_code,\n                     GSS_C_GSS_CODE,\n                     GSS_C_NO_OID,\n
      \                    &message_context,\n                     &status_string)\n
      \    fprintf(stderr,\n             \"%.*s\\n\",\n            (int)status_string.length,\n
      \           (char *)status_string.value);\n     gss_release_buffer(&min_status,
      &status_string);\n   } while (message_context != 0);\n   Parameters:\n   minor_status
      \     Integer, modify\n                     Mechanism specific status code.\n
      \  status_value      Integer, read\n                     Status value to be
      converted\n   status_type       Integer, read\n                     GSS_C_GSS_CODE
      - status_value is a GSS status\n                     code\n   GSS_C_MECH_CODE
      - status_value is a mechanism\n                     status code\n   mech_type
      \        Object ID, read, optional\n                     Underlying mechanism
      (used to interpret a\n                     minor status value) Supply GSS_C_NO_OID
      to\n                     obtain the system default.\n   message_context   Integer,
      read/modify\n                     Should be initialized to zero by the\n                     application
      prior to the first call.\n                     On return from gss_display_status(),\n
      \                    a non-zero status_value parameter indicates\n                     that
      additional messages may be extracted\n                     from the status code
      via subsequent calls\n                     to gss_display_status(), passing
      the same\n                     status_value, status_type, mech_type, and\n                     message_context
      parameters.\n   status_string     buffer, character string, modify\n                     textual
      interpretation of the status_value.\n                     Storage associated
      with this parameter must\n                     be freed by the application after
      use with\n                     a call to gss_release_buffer().\n   Function
      value:   GSS status code\n   GSS_S_COMPLETE    Successful completion\n   GSS_S_BAD_MECH
      \   Indicates that translation in accordance with\n                     an unsupported
      mechanism type was requested\n   GSS_S_BAD_STATUS  The status value was not
      recognized, or the\n                     status type was neither GSS_C_GSS_CODE
      nor\n                     GSS_C_MECH_CODE.\n"
    title: 5.11.gss_display_status
  - contents:
    - "5.12. gss_duplicate_name\n   OM_uint32 gss_duplicate_name (\n     OM_uint32
      \       *minor_status,\n     const gss_name_t src_name,\n     gss_name_t       *dest_name)\n
      \  Purpose:\n   Create an exact duplicate of the existing internal name src_name.\n
      \  The new dest_name will be independent of src_name (i.e. src_name and\n   dest_name
      must both be released, and the release of one shall not\n   affect the validity
      of the other).\n   Parameters:\n   minor_status      Integer, modify\n                     Mechanism
      specific status code.\n   src_name          gss_name_t, read\n                     internal
      name to be duplicated.\n   dest_name         gss_name_t, modify\n                     The
      resultant copy of <src_name>.\n                     Storage associated with
      this name must\n                     be freed by the application after use\n
      \                    with a call to gss_release_name().\n   Function value:
      \  GSS status code\n   GSS_S_COMPLETE    Successful completion\n   GSS_S_BAD_NAME
      \   The src_name parameter was ill-formed.\n"
    title: 5.12. gss_duplicate_name
  - contents:
    - "5.13. gss_export_name\n   OM_uint32 gss_export_name (\n     OM_uint32        *minor_status,\n
      \    const gss_name_t input_name,\n     gss_buffer_t     exported_name)\n   Purpose:\n
      \  To produce a canonical contiguous string representation of a\n   mechanism
      name (MN), suitable for direct comparison (e.g. with\n   memcmp) for use in
      authorization functions (e.g. matching entries in\n   an access-control list).
      \ The <input_name> parameter must specify a\n   valid MN (i.e. an internal name
      generated by gss_accept_sec_context\n   or by gss_canonicalize_name).\n   Parameters:\n
      \  minor_status      Integer, modify\n                     Mechanism specific
      status code\n   input_name        gss_name_t, read\n                     The
      MN to be exported\n   exported_name     gss_buffer_t, octet-string, modify\n
      \                    The canonical contiguous string form of\n                     <input_name>.
      \ Storage associated with\n                     this string must freed by the
      application\n                     after use with gss_release_buffer().\n   Function
      value:   GSS status code\n   GSS_S_COMPLETE    Successful completion\n   GSS_S_NAME_NOT_MN
      The provided internal name was not a mechanism\n                     name.\n
      \  GSS_S_BAD_NAME    The provided internal name was ill-formed.\n   GSS_S_BAD_NAMETYPE
      The internal name was of a type not supported\n                     by the GSS-API
      implementation.\n"
    title: 5.13. gss_export_name
  - contents:
    - "5.14. gss_export_sec_context\n   OM_uint32 gss_export_sec_context (\n     OM_uint32
      \   *minor_status,\n     gss_ctx_id_t *context_handle,\n     gss_buffer_t interprocess_token)\n
      \  Purpose:\n   Provided to support the sharing of work between multiple processes.\n
      \  This routine will typically be used by the context-acceptor, in an\n   application
      where a single process receives incoming connection\n   requests and accepts
      security contexts over them, then passes the\n   established context to one
      or more other processes for message\n   exchange. gss_export_sec_context() deactivates
      the security context\n   for the calling process and creates an interprocess
      token which, when\n   passed to gss_import_sec_context in another process, will
      re-activate\n   the context in the second process. Only a single instantiation
      of a\n   given context may be active at any one time; a subsequent attempt by\n
      \  a context exporter to access the exported security context will fail.\n   The
      implementation may constrain the set of processes by which the\n   interprocess
      token may be imported, either as a function of local\n   security policy, or
      as a result of implementation decisions.  For\n   example, some implementations
      may constrain contexts to be passed\n   only between processes that run under
      the same account, or which are\n   part of the same process group.\n   The interprocess
      token may contain security-sensitive information\n   (for example cryptographic
      keys).  While mechanisms are encouraged to\n   either avoid placing such sensitive
      information within interprocess\n   tokens, or to encrypt the token before returning
      it to the\n   application, in a typical object-library GSS-API implementation
      this\n   may not be possible. Thus the application must take care to protect\n
      \  the interprocess token, and ensure that any process to which the\n   token
      is transferred is trustworthy.\n   If creation of the interprocess token is
      successful, the\n   implementation shall deallocate all process-wide resources
      associated\n   with the security context, and set the context_handle to\n   GSS_C_NO_CONTEXT.
      \ In the event of an error that makes it impossible\n   to complete the export
      of the security context, the implementation\n   must not return an interprocess
      token, and should strive to leave the\n   security context referenced by the
      context_handle parameter\n   untouched.  If this is impossible, it is permissible
      for the\n   implementation to delete the security context, providing it also
      sets\n   the context_handle parameter to GSS_C_NO_CONTEXT.\n   Parameters:\n
      \  minor_status      Integer, modify\n                     Mechanism specific
      status code\n   context_handle    gss_ctx_id_t, modify\n                     context
      handle identifying the context to\n                     transfer.\n   interprocess_token
      \  buffer, opaque, modify\n                        token to be transferred to
      target process.\n                        Storage associated with this token
      must be\n                        freed by the application after use with a\n
      \                       call to gss_release_buffer().\n   Function value:   GSS
      status code\n   GSS_S_COMPLETE    Successful completion\n   GSS_S_CONTEXT_EXPIRED
      The context has expired\n   GSS_S_NO_CONTEXT  The context was invalid\n   GSS_S_UNAVAILABLE
      The operation is not supported.\n"
    title: 5.14. gss_export_sec_context
  - contents:
    - "5.15. gss_get_mic\n   OM_uint32 gss_get_mic (\n     OM_uint32          *minor_status,\n
      \    const gss_ctx_id_t context_handle,\n     gss_qop_t             qop_req,\n
      \    const gss_buffer_t message_buffer,\n     gss_buffer_t       msg_token)\n
      \  Purpose:\n   Generates a cryptographic MIC for the supplied message, and
      places\n   the MIC in a token for transfer to the peer application. The qop_req\n
      \  parameter allows a choice between several cryptographic algorithms,\n   if
      supported by the chosen mechanism.\n   Since some application-level protocols
      may wish to use tokens emitted\n   by gss_wrap() to provide \"secure framing\",
      implementations must\n   support derivation of MICs from zero-length messages.\n
      \  Parameters:\n   minor_status      Integer, modify\n                     Implementation
      specific status code.\n   context_handle    gss_ctx_id_t, read\n                     identifies
      the context on which the message\n                     will be sent\n   qop_req
      \          gss_qop_t, read, optional\n                     Specifies requested
      quality of protection.\n                     Callers are encouraged, on portability
      grounds,\n                     to accept the default quality of protection\n
      \                    offered by the chosen mechanism, which may be\n                     requested
      by specifying GSS_C_QOP_DEFAULT for\n                     this parameter.  If
      an unsupported protection\n                     strength is requested, gss_get_mic
      will return a\n                     major_status of GSS_S_BAD_QOP.\n   message_buffer
      \   buffer, opaque, read\n                     message to be protected\n   msg_token
      \        buffer, opaque, modify\n                     buffer to receive token.
      \ The application must\n                     free storage associated with this
      buffer after\n                     use with a call to gss_release_buffer().\n
      \  Function value:   GSS status code\n   GSS_S_COMPLETE    Successful completion\n
      \  GSS_S_CONTEXT_EXPIRED The context has already expired\n   GSS_S_NO_CONTEXT
      \ The context_handle parameter did not identify\n                     a valid
      context\n   GSS_S_BAD_QOP     The specified QOP is not supported by the\n                     mechanism.\n"
    title: 5.15. gss_get_mic
  - contents:
    - "5.16. gss_import_name\n   OM_uint32 gss_import_name (\n     OM_uint32          *minor_status,\n
      \    const gss_buffer_t input_name_buffer,\n     const gss_OID      input_name_type,\n
      \    gss_name_t         *output_name)\n   Purpose:\n   Convert a contiguous
      string name to internal form.  In general, the\n   internal name returned (via
      the <output_name> parameter) will not be\n   an MN; the exception to this is
      if the <input_name_type> indicates\n   that the contiguous string provided via
      the <input_name_buffer>\n   parameter is of type GSS_C_NT_EXPORT_NAME, in which
      case the returned\n   internal name will be an MN for the mechanism that exported
      the name.\n   Parameters:\n   minor_status      Integer, modify\n                     Mechanism
      specific status code\n   input_name_buffer  buffer, octet-string, read\n                     buffer
      containing contiguous string name to convert\n   input_name_type   Object ID,
      read, optional\n                     Object ID specifying type of printable\n
      \                    name.  Applications may specify either\n                     GSS_C_NO_OID
      to use a mechanism-specific\n                     default printable syntax,
      or an OID recognized\n                     by the GSS-API implementation to
      name a\n                     specific namespace.\n   output_name       gss_name_t,
      modify\n                     returned name in internal form.  Storage\n                     associated
      with this name must be freed\n                     by the application after
      use with a call\n                     to gss_release_name().\n   Function value:
      \  GSS status code\n   GSS_S_COMPLETE    Successful completion\n   GSS_S_BAD_NAMETYPE
      The input_name_type was unrecognized\n   GSS_S_BAD_NAME    The input_name parameter
      could not be interpreted\n                     as a name of the specified type\n
      \  GSS_S_BAD_MECH    The input name-type was GSS_C_NT_EXPORT_NAME,\n                     but
      the mechanism contained within the\n                     input-name is not supported\n"
    title: 5.16. gss_import_name
  - contents:
    - "5.17. gss_import_sec_context\n   OM_uint32 gss_import_sec_context (\n     OM_uint32
      \         *minor_status,\n     const gss_buffer_t interprocess_token,\n     gss_ctx_id_t
      \      *context_handle)\n   Purpose:\n   Allows a process to import a security
      context established by another\n   process.  A given interprocess token may
      be imported only once.  See\n   gss_export_sec_context.\n   Parameters:\n   minor_status
      \     Integer, modify\n                     Mechanism specific status code\n
      \  interprocess_token  buffer, opaque, modify\n                       token
      received from exporting process\n   context_handle    gss_ctx_id_t, modify\n
      \                    context handle of newly reactivated context.\n                     Resources
      associated with this context handle\n                     must be released by
      the application after use\n                     with a call to gss_delete_sec_context().\n
      \  Function value:   GSS status code\n   GSS_S_COMPLETE    Successful completion.\n
      \  GSS_S_NO_CONTEXT  The token did not contain a valid context\n   reference.\n
      \  GSS_S_DEFECTIVE_TOKEN The token was invalid.\n   GSS_S_UNAVAILABLE The operation
      is unavailable.\n   GSS_S_UNAUTHORIZED Local policy prevents the import of this
      context\n                      by the current process.\n"
    title: 5.17. gss_import_sec_context
  - contents:
    - "5.18. gss_indicate_mechs\n   OM_uint32 gss_indicate_mechs (\n     OM_uint32
      \  *minor_status,\n     gss_OID_set *mech_set)\n   Purpose:\n   Allows an application
      to determine which underlying security\n   mechanisms are available.\n   Parameters:\n
      \  minor_status      Integer, modify\n                     Mechanism specific
      status code.\n   mech_set          set of Object IDs, modify\n                     set
      of implementation-supported mechanisms.\n                     The returned gss_OID_set
      value will be a\n                     dynamically-allocated OID set, that should\n
      \                    be released by the caller after use with a\n                     call
      to gss_release_oid_set().\n   Function value:   GSS status code\n   GSS_S_COMPLETE
      \   Successful completion\n"
    title: 5.18. gss_indicate_mechs
  - contents:
    - "5.19. gss_init_sec_context\n   OM_uint32 gss_init_sec_context (\n     OM_uint32
      \                   *minor_status,\n     const gss_cred_id_t          initiator_cred_handle,\n
      \    gss_ctx_id_t                 *context_handle,\\\n     const gss_name_t
      \            target_name,\n     const gss_OID                mech_type,\n     OM_uint32
      \                   req_flags,\n     OM_uint32                    time_req,\n
      \    const gss_channel_bindings_t input_chan_bindings,\n     const gss_buffer_t
      \          input_token\n     gss_OID                      *actual_mech_type,\n
      \    gss_buffer_t                 output_token,\n     OM_uint32                    *ret_flags,\n
      \    OM_uint32                    *time_rec )\n   Purpose:\n   Initiates the
      establishment of a security context between the\n   application and a remote
      peer.  Initially, the input_token parameter\n   should be specified either as
      GSS_C_NO_BUFFER, or as a pointer to a\n   gss_buffer_desc object whose length
      field contains the value zero.\n   The routine may return a output_token which
      should be transferred to\n   the peer application, where the peer application
      will present it to\n   gss_accept_sec_context.  If no token need be sent,\n
      \  gss_init_sec_context will indicate this by setting the length field\n   of
      the output_token argument to zero. To complete the context\n   establishment,
      one or more reply tokens may be required from the peer\n   application; if so,
      gss_init_sec_context will return a status\n   containing the supplementary information
      bit GSS_S_CONTINUE_NEEDED.\n   In this case, gss_init_sec_context should be
      called again when the\n   reply token is received from the peer application,
      passing the reply\n   token to gss_init_sec_context via the input_token parameters.\n
      \  Portable applications should be constructed to use the token length\n   and
      return status to determine whether a token needs to be sent or\n   waited for.
      \ Thus a typical portable caller should always invoke\n   gss_init_sec_context
      within a loop:\n   int context_established = 0;\n   gss_ctx_id_t context_hdl
      = GSS_C_NO_CONTEXT;\n          ...\n   input_token->length = 0;\n   while (!context_established)
      {\n     maj_stat = gss_init_sec_context(&min_stat,\n                                     cred_hdl,\n
      \                                    &context_hdl,\n                                     target_name,\n
      \                                    desired_mech,\n                                     desired_services,\n
      \                                    desired_time,\n                                     input_bindings,\n
      \                                    input_token,\n                                     &actual_mech,\n
      \                                    output_token,\n                                     &actual_services,\n
      \                                    &actual_time);\n     if (GSS_ERROR(maj_stat))
      {\n       report_error(maj_stat, min_stat);\n     };\n     if (output_token->length
      != 0) {\n       send_token_to_peer(output_token);\n       gss_release_buffer(&min_stat,
      output_token)\n     };\n     if (GSS_ERROR(maj_stat)) {\n       if (context_hdl
      != GSS_C_NO_CONTEXT)\n         gss_delete_sec_context(&min_stat,\n                                &context_hdl,\n
      \                               GSS_C_NO_BUFFER);\n       break;\n     };\n
      \    if (maj_stat & GSS_S_CONTINUE_NEEDED) {\n       receive_token_from_peer(input_token);\n
      \    } else {\n       context_established = 1;\n     };\n   };\n   Whenever
      the routine returns a major status that includes the value\n   GSS_S_CONTINUE_NEEDED,
      the context is not fully established and the\n   following restrictions apply
      to the output parameters:\n      The value returned via the time_rec parameter
      is undefined Unless\n      the accompanying ret_flags parameter contains the
      bit\n      GSS_C_PROT_READY_FLAG, indicating that per-message services may be\n
      \     applied in advance of a successful completion status, the value\n      returned
      via the actual_mech_type parameter is undefined until the\n      routine returns
      a major status value of GSS_S_COMPLETE.\n      The values of the GSS_C_DELEG_FLAG,
      GSS_C_MUTUAL_FLAG,\n      GSS_C_REPLAY_FLAG, GSS_C_SEQUENCE_FLAG, GSS_C_CONF_FLAG,\n
      \     GSS_C_INTEG_FLAG and GSS_C_ANON_FLAG bits returned via the\n      ret_flags
      parameter should contain the values that the\n      implementation expects would
      be valid if context establishment\n      were to succeed.  In particular, if
      the application has requested\n      a service such as delegation or anonymous
      authentication via the\n      req_flags argument, and such a service is unavailable
      from the\n      underlying mechanism, gss_init_sec_context should generate a
      token\n      that will not provide the service, and indicate via the ret_flags\n
      \     argument that the service will not be supported.  The application\n      may
      choose to abort the context establishment by calling\n      gss_delete_sec_context
      (if it cannot continue in the absence of\n      the service), or it may choose
      to transmit the token and continue\n      context establishment (if the service
      was merely desired but not\n      mandatory).\n      The values of the GSS_C_PROT_READY_FLAG
      and GSS_C_TRANS_FLAG bits\n      within ret_flags should indicate the actual
      state at the time\n      gss_init_sec_context returns, whether or not the context
      is fully\n      established.\n      GSS-API implementations that support per-message
      protection are\n      encouraged to set the GSS_C_PROT_READY_FLAG in the final
      ret_flags\n      returned to a caller (i.e. when accompanied by a GSS_S_COMPLETE\n
      \     status code).  However, applications should not rely on this\n      behavior
      as the flag was not defined in Version 1 of the GSS-API.\n      Instead, applications
      should determine what per-message services\n      are available after a successful
      context establishment according\n      to the GSS_C_INTEG_FLAG and GSS_C_CONF_FLAG
      values.\n      All other bits within the ret_flags argument should be set to\n
      \     zero.\n   If the initial call of gss_init_sec_context() fails, the\n   implementation
      should not create a context object, and should leave\n   the value of the context_handle
      parameter set to GSS_C_NO_CONTEXT to\n   indicate this.  In the event of a failure
      on a subsequent call, the\n   implementation is permitted to delete the \"half-built\"
      security\n   context (in which case it should set the context_handle parameter
      to\n   GSS_C_NO_CONTEXT), but the preferred behavior is to leave the\n   security
      context untouched for the application to delete (using\n   gss_delete_sec_context).\n
      \  During context establishment, the informational status bits\n   GSS_S_OLD_TOKEN
      and GSS_S_DUPLICATE_TOKEN indicate fatal errors, and\n   GSS-API mechanisms
      should always return them in association with a\n   routine error of GSS_S_FAILURE.
      \ This requirement for pairing did not\n   exist in version 1 of the GSS-API
      specification, so applications that\n   wish to run over version 1 implementations
      must special-case these\n   codes.\n   Parameters:\n   minor_status      Integer,
      \ modify\n                     Mechanism specific status code.\n   initiator_cred_handle
      \ gss_cred_id_t, read, optional\n                          handle for credentials
      claimed.  Supply\n                          GSS_C_NO_CREDENTIAL to act as a
      default\n                          initiator principal.  If no default\n                          initiator
      is defined, the function will\n                          return GSS_S_NO_CRED.\n
      \  context_handle    gss_ctx_id_t, read/modify\n                     context
      handle for new context.  Supply\n                     GSS_C_NO_CONTEXT for first
      call; use value\n                     returned by first call in continuation
      calls.\n                     Resources associated with this context-handle\n
      \                    must be released by the application after use\n                     with
      a call to gss_delete_sec_context().\n   target_name       gss_name_t, read\n
      \                    Name of target\n   mech_type         OID, read, optional\n
      \                    Object ID of desired mechanism. Supply\n                     GSS_C_NO_OID
      to obtain an implementation\n                     specific default\n   req_flags
      \        bit-mask, read\n                     Contains various independent flags,
      each of\n                     which requests that the context support a\n                     specific
      service option.  Symbolic\n                     names are provided for each
      flag, and the\n                     symbolic names corresponding to the required\n
      \                    flags should be logically-ORed\n                     together
      to form the bit-mask value.  The\n                     flags are:\n                     GSS_C_DELEG_FLAG\n
      \                      True - Delegate credentials to remote peer\n                       False
      - Don't delegate\n                     GSS_C_MUTUAL_FLAG\n                       True
      - Request that remote peer\n                              authenticate itself\n
      \                      False - Authenticate self to remote peer\n                               only\n
      \                    GSS_C_REPLAY_FLAG\n                       True - Enable
      replay detection for\n                              messages protected with
      gss_wrap\n                              or gss_get_mic\n                       False
      - Don't attempt to detect\n                               replayed messages\n
      \                    GSS_C_SEQUENCE_FLAG\n                       True - Enable
      detection of out-of-sequence\n                              protected messages\n
      \                      False - Don't attempt to detect\n                               out-of-sequence
      messages\n                     GSS_C_CONF_FLAG\n                       True
      - Request that confidentiality service\n                              be made
      available (via gss_wrap)\n                       False - No per-message confidentiality
      service\n                               is required.\n                     GSS_C_INTEG_FLAG\n
      \                      True - Request that integrity service be\n                              made
      available (via gss_wrap or\n                              gss_get_mic)\n                       False
      - No per-message integrity service\n                               is required.\n
      \                    GSS_C_ANON_FLAG\n                       True - Do not reveal
      the initiator's\n                              identity to the acceptor.\n                       False
      - Authenticate normally.\n   time_req          Integer, read, optional\n                     Desired
      number of seconds for which context\n                     should remain valid.
      \ Supply 0 to request a\n                     default validity period.\n   input_chan_bindings
      \ channel bindings, read, optional\n                        Application-specified
      bindings.  Allows\n                        application to securely bind channel\n
      \                       identification information to the security\n                        context.
      \ Specify GSS_C_NO_CHANNEL_BINDINGS\n                        if channel bindings
      are not used.\n   input_token       buffer, opaque, read, optional (see text)\n
      \                    Token received from peer application.\n                     Supply
      GSS_C_NO_BUFFER, or a pointer to\n                     a buffer containing the
      value GSS_C_EMPTY_BUFFER\n                     on initial call.\n   actual_mech_type
      \ OID, modify, optional\n                     Actual mechanism used.  The OID
      returned via\n                     this parameter will be a pointer to static\n
      \                    storage that should be treated as read-only;\n                     In
      particular the application should not attempt\n                     to free
      it.  Specify NULL if not required.\n   output_token      buffer, opaque, modify\n
      \                    token to be sent to peer application.  If\n                     the
      length field of the returned buffer is\n                     zero, no token
      need be sent to the peer\n                     application.  Storage associated
      with this\n                     buffer must be freed by the application\n                     after
      use with a call to gss_release_buffer().\n   ret_flags         bit-mask, modify,
      optional\n                     Contains various independent flags, each of which\n
      \                    indicates that the context supports a specific\n                     service
      option.  Specify NULL if not\n                     required.  Symbolic names
      are provided\n                     for each flag, and the symbolic names\n                     corresponding
      to the required flags should be\n                     logically-ANDed with the
      ret_flags value to test\n                     whether a given option is supported
      by the\n                     context.  The flags are:\n                     GSS_C_DELEG_FLAG\n
      \                      True - Credentials were delegated to\n                              the
      remote peer\n                       False - No credentials were delegated\n
      \                    GSS_C_MUTUAL_FLAG\n                       True - The remote
      peer has authenticated\n                              itself.\n                       False
      - Remote peer has not authenticated\n                               itself.\n
      \                    GSS_C_REPLAY_FLAG\n                       True - replay
      of protected messages\n                              will be detected\n                       False
      - replayed messages will not be\n                               detected\n                     GSS_C_SEQUENCE_FLAG\n
      \                      True - out-of-sequence protected\n                              messages
      will be detected\n                       False - out-of-sequence messages will\n
      \                              not be detected\n                     GSS_C_CONF_FLAG\n
      \                      True - Confidentiality service may be\n                              invoked
      by calling gss_wrap routine\n                       False - No confidentiality
      service (via\n                               gss_wrap) available. gss_wrap will\n
      \                              provide message encapsulation,\n                               data-origin
      authentication and\n                               integrity services only.\n
      \                    GSS_C_INTEG_FLAG\n                       True - Integrity
      service may be invoked by\n                              calling either gss_get_mic
      or gss_wrap\n                              routines.\n                       False
      - Per-message integrity service\n                               unavailable.\n
      \                    GSS_C_ANON_FLAG\n                       True - The initiator's
      identity has not been\n                              revealed, and will not
      be revealed if\n                              any emitted token is passed to
      the\n                              acceptor.\n                       False -
      The initiator's identity has been or\n                               will be
      authenticated normally.\n                     GSS_C_PROT_READY_FLAG\n                       True
      - Protection services (as specified\n                              by the states
      of the GSS_C_CONF_FLAG\n                              and GSS_C_INTEG_FLAG)
      are available for\n                              use if the accompanying major
      status\n                              return value is either GSS_S_COMPLETE
      or\n                              GSS_S_CONTINUE_NEEDED.\n                       False
      - Protection services (as specified\n                               by the states
      of the GSS_C_CONF_FLAG\n                               and GSS_C_INTEG_FLAG)
      are available\n                               only if the accompanying major
      status\n                               return value is GSS_S_COMPLETE.\n                     GSS_C_TRANS_FLAG\n
      \                      True - The resultant security context may\n                              be
      transferred to other processes via\n                              a call to
      gss_export_sec_context().\n                       False - The security context
      is not\n                               transferable.\n                     All
      other bits should be set to zero.\n   time_rec          Integer, modify, optional\n
      \                    number of seconds for which the context\n                     will
      remain valid. If the implementation does\n                     not support context
      expiration, the value\n                     GSS_C_INDEFINITE will be returned.
      \ Specify\n                     NULL if not required.\n   Function value:   GSS
      status code\n   GSS_S_COMPLETE    Successful completion\n   GSS_S_CONTINUE_NEEDED
      Indicates that a token from the peer\n                         application is
      required to complete the\n                         context, and that gss_init_sec_context\n
      \                        must be called again with that token.\n   GSS_S_DEFECTIVE_TOKEN
      Indicates that consistency checks performed\n                         on the
      input_token failed\n   GSS_S_DEFECTIVE_CREDENTIAL Indicates that consistency
      checks\n                              performed on the credential failed.\n
      \  GSS_S_NO_CRED     The supplied credentials were not valid for\n                     context
      initiation, or the credential handle\n                     did not reference
      any credentials.\n   GSS_S_CREDENTIALS_EXPIRED The referenced credentials have
      expired\n   GSS_S_BAD_BINDINGS The input_token contains different channel\n
      \                     bindings to those specified via the\n                      input_chan_bindings
      parameter\n   GSS_S_BAD_SIG     The input_token contains an invalid MIC, or
      a MIC\n                     that could not be verified\n   GSS_S_OLD_TOKEN   The
      input_token was too old.  This is a fatal\n                     error during
      context establishment\n   GSS_S_DUPLICATE_TOKEN The input_token is valid, but
      is a duplicate\n                         of a token already processed.  This
      is a\n                         fatal error during context establishment.\n   GSS_S_NO_CONTEXT
      \ Indicates that the supplied context handle did\n                     not refer
      to a valid context\n   GSS_S_BAD_NAMETYPE The provided target_name parameter
      contained an\n                      invalid or unsupported type of name\n   GSS_S_BAD_NAME
      \   The provided target_name parameter was ill-formed.\n   GSS_S_BAD_MECH    The
      specified mechanism is not supported by the\n                     provided credential,
      or is unrecognized by the\n                     implementation.\n"
    title: 5.19. gss_init_sec_context
  - contents:
    - "5.20. gss_inquire_context\n   OM_uint32 gss_inquire_context (\n     OM_uint32
      \         *minor_status,\n     const gss_ctx_id_t context_handle,\n     gss_name_t
      \        *src_name,\n     gss_name_t         *targ_name,\n     OM_uint32          *lifetime_rec,\n
      \    gss_OID            *mech_type,\n     OM_uint32          *ctx_flags,\n     int
      \               *locally_initiated,\n     int                *open )\n   Purpose:\n
      \  Obtains information about a security context.  The caller must\n   already
      have obtained a handle that refers to the context, although\n   the context
      need not be fully established.\n   Parameters:\n   minor_status      Integer,
      modify\n                     Mechanism specific status code\n   context_handle
      \   gss_ctx_id_t, read\n                     A handle that refers to the security
      context.\n   src_name          gss_name_t, modify, optional\n                     The
      name of the context initiator.\n                     If the context was established
      using anonymous\n                     authentication, and if the application
      invoking\n                     gss_inquire_context is the context acceptor,\n
      \                    an anonymous name will be returned.  Storage\n                     associated
      with this name must be freed by the\n                     application after
      use with a call to\n                     gss_release_name().  Specify NULL if
      not\n                     required.\n   targ_name         gss_name_t, modify,
      optional\n                     The name of the context acceptor.\n                     Storage
      associated with this name must be\n                     freed by the application
      after use with a call\n                     to gss_release_name().  If the context
      acceptor\n                     did not authenticate itself, and if the initiator\n
      \                    did not specify a target name in its call to\n                     gss_init_sec_context(),
      the value GSS_C_NO_NAME\n                     will be returned.  Specify NULL
      if not required.\n   lifetime_rec      Integer, modify, optional\n                     The
      number of seconds for which the context\n                     will remain valid.
      \ If the context has\n                     expired, this parameter will be set
      to zero.\n                     If the implementation does not support\n                     context
      expiration, the value\n                     GSS_C_INDEFINITE will be returned.
      \ Specify\n                     NULL if not required.\n   mech_type         gss_OID,
      modify, optional\n                     The security mechanism providing the\n
      \                    context.  The returned OID will be a\n                     pointer
      to static storage that should\n                     be treated as read-only
      by the application;\n                     in particular the application should
      not\n                     attempt to free it.  Specify NULL if not\n                     required.\n
      \  ctx_flags         bit-mask, modify, optional\n                     Contains
      various independent flags, each of\n                     which indicates that
      the context supports\n                     (or is expected to support, if ctx_open
      is\n                     false) a specific service option.  If not\n                     needed,
      specify NULL.  Symbolic names are\n                     provided for each flag,
      and the symbolic names\n                     corresponding to the required flags\n
      \                    should be logically-ANDed with the ret_flags\n                     value
      to test whether a given option is\n                     supported by the context.
      \ The flags are:\n                     GSS_C_DELEG_FLAG\n                       True
      - Credentials were delegated from\n                              the initiator
      to the acceptor.\n                       False - No credentials were delegated\n
      \                    GSS_C_MUTUAL_FLAG\n                       True - The acceptor
      was authenticated\n                              to the initiator\n                       False
      - The acceptor did not authenticate\n                               itself.\n
      \                    GSS_C_REPLAY_FLAG\n                       True - replay
      of protected messages\n                              will be detected\n                       False
      - replayed messages will not be\n                               detected\n                     GSS_C_SEQUENCE_FLAG\n
      \                      True - out-of-sequence protected\n                              messages
      will be detected\n                       False - out-of-sequence messages will
      not\n                               be detected\n                     GSS_C_CONF_FLAG\n
      \                      True - Confidentiality service may be invoked\n                              by
      calling gss_wrap routine\n                       False - No confidentiality
      service (via\n                               gss_wrap) available. gss_wrap will\n
      \                              provide message encapsulation,\n                               data-origin
      authentication and\n                               integrity services only.\n
      \                    GSS_C_INTEG_FLAG\n                       True - Integrity
      service may be invoked by\n                              calling either gss_get_mic
      or gss_wrap\n                              routines.\n                       False
      - Per-message integrity service\n                               unavailable.\n
      \                    GSS_C_ANON_FLAG\n                       True - The initiator's
      identity will not\n                              be revealed to the acceptor.\n
      \                             The src_name parameter (if\n                              requested)
      contains an anonymous\n                              internal name.\n                       False
      - The initiator has been\n                               authenticated normally.\n
      \                    GSS_C_PROT_READY_FLAG\n                       True - Protection
      services (as specified\n                              by the states of the GSS_C_CONF_FLAG\n
      \                             and GSS_C_INTEG_FLAG) are available\n                              for
      use.\n                       False - Protection services (as specified\n                               by
      the states of the GSS_C_CONF_FLAG\n                               and GSS_C_INTEG_FLAG)
      are available\n                               only if the context is fully\n
      \                              established (i.e. if the open parameter\n                               is
      non-zero).\n                     GSS_C_TRANS_FLAG\n                       True
      - The resultant security context may\n                              be transferred
      to other processes via\n                              a call to gss_export_sec_context().\n
      \                      False - The security context is not\n                               transferable.\n
      \  locally_initiated Boolean, modify\n                     Non-zero if the invoking
      application is the\n                     context initiator.\n                     Specify
      NULL if not required.\n   open              Boolean, modify\n                     Non-zero
      if the context is fully established;\n                     Zero if a context-establishment
      token\n                     is expected from the peer application.\n                     Specify
      NULL if not required.\n   Function value:   GSS status code\n   GSS_S_COMPLETE
      \   Successful completion\n   GSS_S_NO_CONTEXT  The referenced context could
      not be accessed.\n"
    title: 5.20. gss_inquire_context
  - contents:
    - "5.21. gss_inquire_cred\n   OM_uint32 gss_inquire_cred (\n     OM_uint32           *minor_status,\n
      \    const gss_cred_id_t cred_handle,\n     gss_name_t          *name,\n     OM_uint32
      \          *lifetime,\n     gss_cred_usage_t    *cred_usage,\n     gss_OID_set
      \        *mechanisms )\n   Purpose:\n   Obtains information about a credential.\n
      \  Parameters:\n   minor_status      Integer, modify\n                     Mechanism
      specific status code\n   cred_handle       gss_cred_id_t, read\n                     A
      handle that refers to the target credential.\n                     Specify GSS_C_NO_CREDENTIAL
      to inquire about\n                     the default initiator principal.\n   name
      \             gss_name_t, modify, optional\n                     The name whose
      identity the credential asserts.\n                     Storage associated with
      this name should be freed\n                     by the application after use
      with a call to\n                     gss_release_name().  Specify NULL if not
      required.\n   lifetime          Integer, modify, optional\n                     The
      number of seconds for which the credential\n                     will remain
      valid.  If the credential has\n                     expired, this parameter
      will be set to zero.\n                     If the implementation does not support\n
      \                    credential expiration, the value\n                     GSS_C_INDEFINITE
      will be returned.  Specify\n                     NULL if not required.\n   cred_usage
      \       gss_cred_usage_t, modify, optional\n                     How the credential
      may be used.  One of the\n                     following:\n                     GSS_C_INITIATE\n
      \                    GSS_C_ACCEPT\n                     GSS_C_BOTH\n                     Specify
      NULL if not required.\n   mechanisms        gss_OID_set, modify, optional\n
      \                    Set of mechanisms supported by the credential.\n                     Storage
      associated with this OID set must be\n                     freed by the application
      after use with a call\n                     to gss_release_oid_set().  Specify
      NULL if not\n                     required.\n   Function value:   GSS status
      code\n   GSS_S_COMPLETE    Successful completion\n   GSS_S_NO_CRED     The referenced
      credentials could not be accessed.\n   GSS_S_DEFECTIVE_CREDENTIAL The referenced
      credentials were invalid.\n   GSS_S_CREDENTIALS_EXPIRED The referenced credentials
      have expired.\n                     If the lifetime parameter was not passed
      as NULL,\n                     it will be set to 0.\n"
    title: 5.21. gss_inquire_cred
  - contents:
    - "5.22. gss_inquire_cred_by_mech\n   OM_uint32 gss_inquire_cred_by_mech (\n     OM_uint32
      \          *minor_status,\n     const gss_cred_id_t cred_handle,\n     const
      gss_OID       mech_type,\n     gss_name_t          *name,\n     OM_uint32           *initiator_lifetime,\n
      \    OM_uint32           *acceptor_lifetime,\n     gss_cred_usage_t    *cred_usage
      )\n   Purpose:\n   Obtains per-mechanism information about a credential.\n   Parameters:\n
      \  minor_status      Integer, modify\n                     Mechanism specific
      status code\n   cred_handle       gss_cred_id_t, read\n                     A
      handle that refers to the target credential.\n                     Specify GSS_C_NO_CREDENTIAL
      to inquire about\n                     the default initiator principal.\n   mech_type
      \        gss_OID, read\n                     The mechanism for which information
      should be\n                     returned.\n   name              gss_name_t,
      modify, optional\n                     The name whose identity the credential
      asserts.\n                     Storage associated with this name must be\n                     freed
      by the application after use with a call\n                     to gss_release_name().
      \ Specify NULL if not\n                     required.\n   initiator_lifetime
      \ Integer, modify, optional\n                     The number of seconds for
      which the credential\n                     will remain capable of initiating
      security contexts\n                     under the specified mechanism.  If the
      credential\n                     can no longer be used to initiate contexts,
      or if\n                     the credential usage for this mechanism is\n                     GSS_C_ACCEPT,
      this parameter will be set to zero.\n                     If the implementation
      does not support expiration\n                     of initiator credentials,
      the value\n                     GSS_C_INDEFINITE will be returned.  Specify
      NULL\n                     if not required.\n   acceptor_lifetime Integer, modify,
      optional\n                     The number of seconds for which the credential\n
      \                    will remain capable of accepting security contexts\n                     under
      the specified mechanism.  If the credential\n                     can no longer
      be used to accept contexts, or if\n                     the credential usage
      for this mechanism is\n                     GSS_C_INITIATE, this parameter will
      be set to zero.\n                     If the implementation does not support
      expiration\n                     of acceptor credentials, the value GSS_C_INDEFINITE\n
      \                    will be returned.  Specify NULL if not required.\n   cred_usage
      \       gss_cred_usage_t, modify, optional\n                     How the credential
      may be used with the specified\n                     mechanism.  One of the
      following:\n                       GSS_C_INITIATE\n                       GSS_C_ACCEPT\n
      \                      GSS_C_BOTH\n                     Specify NULL if not
      required.\n   Function value:   GSS status code\n   GSS_S_COMPLETE    Successful
      completion\n   GSS_S_NO_CRED     The referenced credentials could not be accessed.\n
      \  GSS_S_DEFECTIVE_CREDENTIAL The referenced credentials were invalid.\n   GSS_S_CREDENTIALS_EXPIRED
      The referenced credentials have expired.\n                    If the lifetime
      parameter was not passed as NULL,\n                    it will be set to 0.\n"
    title: 5.22. gss_inquire_cred_by_mech
  - contents:
    - "5.23. gss_inquire_mechs_for_name\n   OM_uint32 gss_inquire_mechs_for_name (\n
      \    OM_uint32        *minor_status,\n     const gss_name_t input_name,\n     gss_OID_set
      \     *mech_types )\n   Purpose:\n   Returns the set of mechanisms supported
      by the GSS-API implementation\n   that may be able to process the specified
      name.\n   Each mechanism returned will recognize at least one element within\n
      \  the name.  It is permissible for this routine to be implemented\n   within
      a mechanism-independent GSS-API layer, using the type\n   information contained
      within the presented name, and based on\n   registration information provided
      by individual mechanism\n   implementations.  This means that the returned mech_types
      set may\n   indicate that a particular mechanism will understand the name when
      in\n   fact it would refuse to accept the name as input to\n   gss_canonicalize_name,
      gss_init_sec_context, gss_acquire_cred or\n   gss_add_cred (due to some property
      of the specific name, as opposed\n   to the name type).  Thus this routine should
      be used only as a pre-\n   filter for a call to a subsequent mechanism-specific
      routine.\n   Parameters:\n   minor_status      Integer, modify\n                     Implementation
      specific status code.\n   input_name        gss_name_t, read\n                     The
      name to which the inquiry relates.\n   mech_types        gss_OID_set, modify\n
      \                    Set of mechanisms that may support the\n                     specified
      name.  The returned OID set\n                     must be freed by the caller
      after use\n                     with a call to gss_release_oid_set().\n   Function
      value:   GSS status code\n   GSS_S_COMPLETE    Successful completion\n   GSS_S_BAD_NAME
      \   The input_name parameter was ill-formed.\n   GSS_S_BAD_NAMETYPE The input_name
      parameter contained an invalid or\n                      unsupported type of
      name\n"
    title: 5.23. gss_inquire_mechs_for_name
  - contents:
    - "5.24. gss_inquire_names_for_mech\n   OM_uint32 gss_inquire_names_for_mech (\n
      \    OM_uint32     *minor_status,\n     const gss_OID mechanism,\n     gss_OID_set
      \  *name_types)\n   Purpose:\n   Returns the set of nametypes supported by the
      specified mechanism.\n   Parameters:\n   minor_status      Integer, modify\n
      \                    Implementation specific status code.\n   mechanism         gss_OID,
      read\n                     The mechanism to be interrogated.\n   name_types
      \       gss_OID_set, modify\n                     Set of name-types supported
      by the specified\n                     mechanism.  The returned OID set must
      be\n                     freed by the application after use with a\n                     call
      to gss_release_oid_set().\n   Function value:   GSS status code\n   GSS_S_COMPLETE
      \   Successful completion\n"
    title: 5.24. gss_inquire_names_for_mech
  - contents:
    - "5.25. gss_process_context_token\n   OM_uint32 gss_process_context_token (\n
      \    OM_uint32          *minor_status,\n     const gss_ctx_id_t context_handle,\n
      \    const gss_buffer_t token_buffer)\n        Purpose:\n   Provides a way to
      pass an asynchronous token to the security service.\n   Most context-level tokens
      are emitted and processed synchronously by\n   gss_init_sec_context and gss_accept_sec_context,
      and the application\n   is informed as to whether further tokens are expected
      by the\n   GSS_C_CONTINUE_NEEDED major status bit.  Occasionally, a mechanism\n
      \  may need to emit a context-level token at a point when the peer\n   entity
      is not expecting a token.  For example, the initiator's final\n   call to gss_init_sec_context
      may emit a token and return a status of\n   GSS_S_COMPLETE, but the acceptor's
      call to gss_accept_sec_context may\n   fail.  The acceptor's mechanism may wish
      to send a token containing\n   an error indication to the initiator, but the
      initiator is not\n   expecting a token at this point, believing that the context
      is fully\n   established.  Gss_process_context_token provides a way to pass
      such a\n   token to the mechanism at any time.\n   Parameters:\n   minor_status
      \     Integer, modify\n                     Implementation specific status code.\n
      \  context_handle    gss_ctx_id_t, read\n                     context handle
      of context on which token is to\n                     be processed\n   token_buffer
      \     buffer, opaque, read\n                     token to process\n   Function
      value:   GSS status code\n   GSS_S_COMPLETE    Successful completion\n   GSS_S_DEFECTIVE_TOKEN
      Indicates that consistency checks performed\n                     on the token
      failed\n   GSS_S_NO_CONTEXT  The context_handle did not refer to a valid context\n"
    title: 5.25. gss_process_context_token
  - contents:
    - "5.26. gss_release_buffer\n   OM_uint32 gss_release_buffer (\n     OM_uint32
      \   *minor_status,\n     gss_buffer_t buffer)\n   Purpose:\n   Free storage
      associated with a buffer.  The storage must have been\n   allocated by a GSS-API
      routine.  In addition to freeing the\n   associated storage, the routine will
      zero the length field in the\n   descriptor to which the buffer parameter refers,
      and implementations\n   are encouraged to additionally set the pointer field
      in the\n   descriptor to NULL.  Any buffer object returned by a GSS-API routine\n
      \  may be passed to gss_release_buffer (even if there is no storage\n   associated
      with the buffer).\n   Parameters:\n   minor_status      Integer, modify\n                     Mechanism
      specific status code\n   buffer            buffer, modify\n                     The
      storage associated with the buffer will be\n                     deleted.  The
      gss_buffer_desc object will not\n                     be freed, but its length
      field will be zeroed.\n   Function value:   GSS status code\n   GSS_S_COMPLETE
      \   Successful completion\n"
    title: 5.26. gss_release_buffer
  - contents:
    - "5.27. gss_release_cred\n   OM_uint32 gss_release_cred (\n     OM_uint32     *minor_status,\n
      \    gss_cred_id_t *cred_handle)\n   Purpose:\n   Informs GSS-API that the specified
      credential handle is no longer\n   required by the application, and frees associated
      resources.\n   Implementations are encouraged to set the cred_handle to\n   GSS_C_NO_CREDENTIAL
      on successful completion of this call.\n   Parameters:\n   cred_handle       gss_cred_id_t,
      modify, optional\n                     Opaque handle identifying credential\n
      \                    to be released.  If GSS_C_NO_CREDENTIAL\n                     is
      supplied, the routine will complete\n                     successfully, but
      will do nothing.\n   minor_status      Integer, modify\n                     Mechanism
      specific status code.\n   Function value:   GSS status code\n   GSS_S_COMPLETE
      \   Successful completion\n   GSS_S_NO_CRED     Credentials could not be accessed.\n"
    title: 5.27. gss_release_cred
  - contents:
    - "5.28. gss_release_name\n   OM_uint32 gss_release_name (\n     OM_uint32  *minor_status,\n
      \    gss_name_t *name)\n   Purpose:\n   Free GSSAPI-allocated storage associated
      with an internal-form name.\n   Implementations are encouraged to set the name
      to GSS_C_NO_NAME on\n   successful completion of this call.\n   Parameters:\n
      \  minor_status      Integer, modify\n                     Mechanism specific
      status code\n   name              gss_name_t, modify\n                     The
      name to be deleted\n   Function value:   GSS status code\n   GSS_S_COMPLETE
      \   Successful completion\n   GSS_S_BAD_NAME    The name parameter did not contain
      a valid name\n"
    title: 5.28. gss_release_name
  - contents:
    - "5.29. gss_release_oid_set\n   OM_uint32 gss_release_oid_set (\n     OM_uint32
      \  *minor_status,\n     gss_OID_set *set)\n   Purpose:\n   Free storage associated
      with a GSSAPI-generated gss_OID_set object.\n   The set parameter must refer
      to an OID-set that was returned from a\n   GSS-API routine.  gss_release_oid_set()
      will free the storage\n   associated with each individual member OID, the OID
      set's elements\n   array, and the gss_OID_set_desc.\n   Implementations are
      encouraged to set the gss_OID_set parameter to\n   GSS_C_NO_OID_SET on successful
      completion of this routine.\n   Parameters:\n   minor_status      Integer, modify\n
      \                    Mechanism specific status code\n   set               Set
      of Object IDs, modify\n                     The storage associated with the
      gss_OID_set\n                     will be deleted.\n   Function value:   GSS
      status code\n   GSS_S_COMPLETE    Successful completion\n"
    title: 5.29. gss_release_oid_set
  - contents:
    - "5.30. gss_test_oid_set_member\n   OM_uint32 gss_test_oid_set_member (\n     OM_uint32
      \        *minor_status,\n     const gss_OID     member,\n     const gss_OID_set
      set,\n     int               *present)\n   Purpose:\n   Interrogate an Object
      Identifier set to determine whether a specified\n   Object Identifier is a member.
      \ This routine is intended to be used\n   with OID sets returned by gss_indicate_mechs(),
      gss_acquire_cred(),\n   and gss_inquire_cred(), but will also work with user-generated
      sets.\n   Parameters:\n   minor_status      Integer, modify\n                     Mechanism
      specific status code\n   member            Object ID, read\n                     The
      object identifier whose presence\n                     is to be tested.\n   set
      \              Set of Object ID, read\n                     The Object Identifier
      set.\n   present           Boolean, modify\n                     non-zero if
      the specified OID is a member\n                     of the set, zero if not.\n
      \  Function value:   GSS status code\n   GSS_S_COMPLETE    Successful completion\n"
    title: 5.30. gss_test_oid_set_member
  - contents:
    - "5.31. gss_unwrap\n   OM_uint32 gss_unwrap (\n     OM_uint32          *minor_status,\n
      \    const gss_ctx_id_t context_handle,\n     const gss_buffer_t input_message_buffer,\n
      \    gss_buffer_t       output_message_buffer,\n     int                *conf_state,\n
      \    gss_qop_t          *qop_state)\n   Purpose:\n   Converts a message previously
      protected by gss_wrap back to a usable\n   form, verifying the embedded MIC.
      \ The conf_state parameter indicates\n   whether the message was encrypted;
      the qop_state parameter indicates\n   the strength of protection that was used
      to provide the\n   confidentiality and integrity services.\n   Since some application-level
      protocols may wish to use tokens emitted\n   by gss_wrap() to provide \"secure
      framing\", implementations must\n   support the wrapping and unwrapping of zero-length
      messages.\n   Parameters:\n   minor_status      Integer, modify\n                     Mechanism
      specific status code.\n   context_handle    gss_ctx_id_t, read\n                     Identifies
      the context on which the message\n                     arrived\n   input_message_buffer
      \ buffer, opaque, read\n                     protected message\n   output_message_buffer
      \ buffer, opaque, modify\n                     Buffer to receive unwrapped message.\n
      \                    Storage associated with this buffer must\n                     be
      freed by the application after use use\n                     with a call to
      gss_release_buffer().\n   conf_state        boolean, modify, optional\n                     Non-zero
      - Confidentiality and integrity\n                                protection
      were used\n                     Zero - Integrity service only was used\n                     Specify
      NULL if not required\n   qop_state         gss_qop_t, modify, optional\n                     Quality
      of protection provided.\n                     Specify NULL if not required\n
      \  Function value:   GSS status code\n   GSS_S_COMPLETE    Successful completion\n
      \  GSS_S_DEFECTIVE_TOKEN The token failed consistency checks\n   GSS_S_BAD_SIG
      \    The MIC was incorrect\n   GSS_S_DUPLICATE_TOKEN The token was valid, and
      contained a correct\n                         MIC for the message, but it had
      already been\n                         processed\n   GSS_S_OLD_TOKEN   The token
      was valid, and contained a correct MIC\n                     for the message,
      but it is too old to check for\n                     duplication.\n   GSS_S_UNSEQ_TOKEN
      The token was valid, and contained a correct MIC\n                     for the
      message, but has been verified out of\n                     sequence; a later
      token has already been\n                     received.\n   GSS_S_GAP_TOKEN   The
      token was valid, and contained a correct MIC\n                     for the message,
      but has been verified out of\n                     sequence; an earlier expected
      token has not yet\n                     been received.\n   GSS_S_CONTEXT_EXPIRED
      The context has already expired\n   GSS_S_NO_CONTEXT  The context_handle parameter
      did not identify\n                     a valid context\n"
    title: 5.31. gss_unwrap
  - contents:
    - "5.32. gss_verify_mic\n   OM_uint32 gss_verify_mic (\n     OM_uint32          *minor_status,\n
      \    const gss_ctx_id_t context_handle,\n     const gss_buffer_t message_buffer,\n
      \    const gss_buffer_t token_buffer,\n     gss_qop_t          *qop_state)\n
      \  Purpose:\n   Verifies that a cryptographic MIC, contained in the token parameter,\n
      \  fits the supplied message.  The qop_state parameter allows a message\n   recipient
      to determine the strength of protection that was applied to\n   the message.\n
      \  Since some application-level protocols may wish to use tokens emitted\n   by
      gss_wrap() to provide \"secure framing\", implementations must\n   support the
      calculation and verification of MICs over zero-length\n   messages.\n   Parameters:\n
      \  minor_status      Integer, modify\n                     Mechanism specific
      status code.\n   context_handle    gss_ctx_id_t, read\n                     Identifies
      the context on which the message\n                     arrived\n   message_buffer
      \   buffer, opaque, read\n                     Message to be verified\n   token_buffer
      \     buffer, opaque, read\n                     Token associated with message\n
      \  qop_state         gss_qop_t, modify, optional\n                     quality
      of protection gained from MIC\n                     Specify NULL if not required\n
      \  Function value:   GSS status code\n   GSS_S_COMPLETE    Successful completion\n
      \  GSS_S_DEFECTIVE_TOKEN The token failed consistency checks\n   GSS_S_BAD_SIG
      \    The MIC was incorrect\n   GSS_S_DUPLICATE_TOKEN The token was valid, and
      contained a correct\n                     MIC for the message, but it had already
      been\n                     processed\n   GSS_S_OLD_TOKEN   The token was valid,
      and contained a correct MIC\n                     for the message, but it is
      too old to check for\n                     duplication.\n   GSS_S_UNSEQ_TOKEN
      The token was valid, and contained a correct MIC\n                     for the
      message, but has been verified out of\n                     sequence; a later
      token has already been received.\n   GSS_S_GAP_TOKEN   The token was valid,
      and contained a correct MIC\n                     for the message, but has been
      verified out of\n                     sequence; an earlier expected token has
      not yet\n                     been received.\n   GSS_S_CONTEXT_EXPIRED The context
      has already expired\n   GSS_S_NO_CONTEXT  The context_handle parameter did not
      identify a\n                     valid context\n"
    title: 5.32. gss_verify_mic
  - contents:
    - "5.33. gss_wrap\n   OM_uint32 gss_wrap (\n     OM_uint32          *minor_status,\n
      \    const gss_ctx_id_t context_handle,\n     int               conf_req_flag,\n
      \    gss_qop_t          qop_req\n     const gss_buffer_t input_message_buffer,\n
      \    int                *conf_state,\n     gss_buffer_t       output_message_buffer
      )\n   Purpose:\n   Attaches a cryptographic MIC and optionally encrypts the
      specified\n   input_message.  The output_message contains both the MIC and the\n
      \  message.  The qop_req parameter allows a choice between several\n   cryptographic
      algorithms, if supported by the chosen mechanism.\n   Since some application-level
      protocols may wish to use tokens emitted\n   by gss_wrap() to provide \"secure
      framing\", implementations must\n   support the wrapping of zero-length messages.\n
      \  Parameters:\n   minor_status      Integer, modify\n                     Mechanism
      specific status code.\n   context_handle    gss_ctx_id_t, read\n                     Identifies
      the context on which the message\n                     will be sent\n   conf_req_flag
      \    boolean, read\n                     Non-zero - Both confidentiality and
      integrity\n                                services are requested\n                     Zero
      - Only integrity service is requested\n   qop_req           gss_qop_t, read,
      optional\n                     Specifies required quality of protection.  A\n
      \                    mechanism-specific default may be requested by\n                     setting
      qop_req to GSS_C_QOP_DEFAULT.  If an\n                     unsupported protection
      strength is requested,\n                     gss_wrap will return a major_status
      of\n                     GSS_S_BAD_QOP.\n   input_message_buffer  buffer, opaque,
      read\n                     Message to be protected\n   conf_state        boolean,
      modify, optional\n                     Non-zero - Confidentiality, data origin\n
      \                               authentication and integrity\n                                services
      have been applied\n                     Zero - Integrity and data origin services
      only\n                            has been applied.\n                     Specify
      NULL if not required\n   output_message_buffer  buffer, opaque, modify\n                     Buffer
      to receive protected message.\n                     Storage associated with
      this message must\n                     be freed by the application after use
      with\n                     a call to gss_release_buffer().\n   Function value:
      \  GSS status code\n   GSS_S_COMPLETE    Successful completion\n   GSS_S_CONTEXT_EXPIRED
      The context has already expired\n   GSS_S_NO_CONTEXT  The context_handle parameter
      did not identify a\n                     valid context\n   GSS_S_BAD_QOP     The
      specified QOP is not supported by the\n                     mechanism.\n"
    title: 5.33. gss_wrap
  - contents:
    - "5.34. gss_wrap_size_limit\n   OM_uint32 gss_wrap_size_limit (\n     OM_uint32
      \         *minor_status,\n     const gss_ctx_id_t context_handle,\n     int
      \               conf_req_flag,\n     gss_qop_t          qop_req,\n     OM_uint32
      \         req_output_size,\n     OM_uint32          *max_input_size)\n   Purpose:\n
      \  Allows an application to determine the maximum message size that, if\n   presented
      to gss_wrap with the same conf_req_flag and qop_req\n   parameters, will result
      in an output token containing no more than\n   req_output_size bytes.\n   This
      call is intended for use by applications that communicate over\n   protocols
      that impose a maximum message size.  It enables the\n   application to fragment
      messages prior to applying protection.\n   GSS-API implementations are recommended
      but not required to detect\n   invalid QOP values when gss_wrap_size_limit()
      is called. This routine\n   guarantees only a maximum message size, not the
      availability of\n   specific QOP values for message protection.\n   Successful
      completion of this call does not guarantee that gss_wrap\n   will be able to
      protect a message of length max_input_size bytes,\n   since this ability may
      depend on the availability of system resources\n   at the time that gss_wrap
      is called.  However, if the implementation\n   itself imposes an upper limit
      on the length of messages that may be\n   processed by gss_wrap, the implementation
      should not return a value\n   via max_input_bytes that is greater than this
      length.\n   Parameters:\n   minor_status      Integer, modify\n                     Mechanism
      specific status code\n   context_handle    gss_ctx_id_t, read\n                     A
      handle that refers to the security over\n                     which the messages
      will be sent.\n   conf_req_flag     Boolean, read\n                     Indicates
      whether gss_wrap will be asked\n                     to apply confidentiality
      protection in\n                     addition to integrity protection.  See\n
      \                    the routine description for gss_wrap\n                     for
      more details.\n   qop_req           gss_qop_t, read\n                     Indicates
      the level of protection that\n                     gss_wrap will be asked to
      provide.  See\n                     the routine description for gss_wrap for\n
      \                    more details.\n   req_output_size   Integer, read\n                     The
      desired maximum size for tokens emitted\n                     by gss_wrap.\n
      \  max_input_size    Integer, modify\n                     The maximum input
      message size that may\n                     be presented to gss_wrap in order
      to\n                     guarantee that the emitted token shall\n                     be
      no larger than req_output_size bytes.\n   Function value:   GSS status code\n
      \  GSS_S_COMPLETE    Successful completion\n   GSS_S_NO_CONTEXT  The referenced
      context could not be accessed.\n   GSS_S_CONTEXT_EXPIRED The context has expired.\n
      \  GSS_S_BAD_QOP     The specified QOP is not supported by the\n                     mechanism.\n"
    title: 5.34. gss_wrap_size_limit
  title: 5. GSS-API Routine Descriptions
- contents:
  - "6.   Security Considerations\n   This document specifies a service interface
    for security facilities\n   and services; as such, security considerations appear
    throughout the\n   specification. Nonetheless, it is appropriate to summarize
    certain\n   specific points relevant to GSS-API implementors and calling\n   applications.
    Usage of the GSS-API interface does not in itself\n   provide security services
    or assurance; instead, these attributes are\n   dependent on the underlying mechanism(s)
    which support a GSS-API\n   implementation. Callers must be attentive to the requests
    made to\n   GSS-API calls and to the status indicators returned by GSS-API, as\n
    \  these specify the security service characteristics which GSS-API will\n   provide.
    When the interprocess context transfer facility is used,\n   appropriate local
    controls should be applied to constrain access to\n   interprocess tokens and
    to the sensitive data which they contain.\n   Appendix A. GSS-API C header file
    gssapi.h\n   C-language GSS-API implementations should include a copy of the\n
    \  following header-file.\n   #ifndef GSSAPI_H_\n   #define GSSAPI_H_\n   /*\n
    \   * First, include stddef.h to get size_t defined.\n    */\n   #include <stddef.h>\n
    \  /*\n    * If the platform supports the xom.h header file, it should be\n    *
    included here.\n    */\n   #include <xom.h>\n   /*\n    * Now define the three
    implementation-dependent types.\n    */\n   typedef <platform-specific> gss_ctx_id_t;\n
    \  typedef <platform-specific> gss_cred_id_t;\n   typedef <platform-specific>
    gss_name_t;\n   /*\n    * The following type must be defined as the smallest natural\n
    \   * unsigned integer supported by the platform that has at least\n    * 32 bits
    of precision.\n    */\n   typedef <platform-specific> gss_uint32;\n   #ifdef OM_STRING\n
    \  /*\n    * We have included the xom.h header file.  Verify that OM_uint32\n
    \   * is defined correctly.\n    */\n   #if sizeof(gss_uint32) != sizeof(OM_uint32)\n
    \  #error Incompatible definition of OM_uint32 from xom.h\n   #endif\n   typedef
    OM_object_identifier gss_OID_desc, *gss_OID;\n   #else\n   /*\n    * We can't
    use X/Open definitions, so roll our own.\n    */\n   typedef gss_uint32 OM_uint32;\n
    \  typedef struct gss_OID_desc_struct {\n     OM_uint32 length;\n     void      *elements;\n
    \  } gss_OID_desc, *gss_OID;\n   #endif\n   typedef struct gss_OID_set_desc_struct
    \ {\n     size_t     count;\n     gss_OID    elements;\n   } gss_OID_set_desc,
    *gss_OID_set;\n   typedef struct gss_buffer_desc_struct {\n     size_t length;\n
    \    void *value;\n   } gss_buffer_desc, *gss_buffer_t;\n   typedef struct gss_channel_bindings_struct
    {\n     OM_uint32 initiator_addrtype;\n     gss_buffer_desc initiator_address;\n
    \    OM_uint32 acceptor_addrtype;\n     gss_buffer_desc acceptor_address;\n     gss_buffer_desc
    application_data;\n   } *gss_channel_bindings_t;\n   /*\n    * For now, define
    a QOP-type as an OM_uint32\n    */\n   typedef OM_uint32 gss_qop_t;\n   typedef
    int gss_cred_usage_t;\n   /*\n    * Flag bits for context-level services.\n    */\n
    \  #define GSS_C_DELEG_FLAG      1\n   #define GSS_C_MUTUAL_FLAG     2\n   #define
    GSS_C_REPLAY_FLAG     4\n   #define GSS_C_SEQUENCE_FLAG   8\n   #define GSS_C_CONF_FLAG
    \      16\n   #define GSS_C_INTEG_FLAG      32\n   #define GSS_C_ANON_FLAG       64\n
    \  #define GSS_C_PROT_READY_FLAG 128\n   #define GSS_C_TRANS_FLAG      256\n   /*\n
    \   * Credential usage options\n    */\n   #define GSS_C_BOTH     0\n   #define
    GSS_C_INITIATE 1\n   #define GSS_C_ACCEPT   2\n   /*\n    * Status code types
    for gss_display_status\n    */\n   #define GSS_C_GSS_CODE  1\n   #define GSS_C_MECH_CODE
    2\n   /*\n    * The constant definitions for channel-bindings address families\n
    \   */\n   #define GSS_C_AF_UNSPEC     0\n   #define GSS_C_AF_LOCAL      1\n   #define
    GSS_C_AF_INET       2\n   #define GSS_C_AF_IMPLINK    3\n   #define GSS_C_AF_PUP
    \       4\n   #define GSS_C_AF_CHAOS      5\n   #define GSS_C_AF_NS         6\n
    \  #define GSS_C_AF_NBS        7\n   #define GSS_C_AF_ECMA       8\n   #define
    GSS_C_AF_DATAKIT    9\n   #define GSS_C_AF_CCITT      10\n   #define GSS_C_AF_SNA
    \       11\n   #define GSS_C_AF_DECnet     12\n   #define GSS_C_AF_DLI        13\n
    \  #define GSS_C_AF_LAT        14\n   #define GSS_C_AF_HYLINK     15\n   #define
    GSS_C_AF_APPLETALK  16\n   #define GSS_C_AF_BSC        17\n   #define GSS_C_AF_DSS
    \       18\n   #define GSS_C_AF_OSI        19\n   #define GSS_C_AF_X25        21\n
    \  #define GSS_C_AF_NULLADDR   255\n   /*\n    * Various Null values\n    */\n
    \  #define GSS_C_NO_NAME ((gss_name_t) 0)\n   #define GSS_C_NO_BUFFER ((gss_buffer_t)
    0)\n   #define GSS_C_NO_OID ((gss_OID) 0)\n   #define GSS_C_NO_OID_SET ((gss_OID_set)
    0)\n   #define GSS_C_NO_CONTEXT ((gss_ctx_id_t) 0)\n   #define GSS_C_NO_CREDENTIAL
    ((gss_cred_id_t) 0)\n   #define GSS_C_NO_CHANNEL_BINDINGS ((gss_channel_bindings_t)
    0)\n   #define GSS_C_EMPTY_BUFFER {0, NULL}\n   /*\n    * Some alternate names
    for a couple of the above\n    * values.  These are defined for V1 compatibility.\n
    \   */\n   #define GSS_C_NULL_OID GSS_C_NO_OID\n   #define GSS_C_NULL_OID_SET
    GSS_C_NO_OID_SET\n   /*\n    * Define the default Quality of Protection for per-message\n
    \   * services.  Note that an implementation that offers multiple\n    * levels
    of QOP may define GSS_C_QOP_DEFAULT to be either zero\n    * (as done here) to
    mean \"default protection\", or to a specific\n    * explicit QOP value.  However,
    a value of 0 should always be\n    * interpreted by a GSS-API implementation as
    a request for the\n    * default protection level.\n    */\n   #define GSS_C_QOP_DEFAULT
    0\n   /*\n    * Expiration time of 2^32-1 seconds means infinite lifetime for
    a\n    * credential or security context\n    */\n   #define GSS_C_INDEFINITE 0xfffffffful\n
    \  /*\n    * The implementation must reserve static storage for a\n    * gss_OID_desc
    object containing the value\n    * {10, (void *)\"\\x2a\\x86\\x48\\x86\\xf7\\x12\"\n
    \   * \"\\x01\\x02\\x01\\x01\"},\n    * corresponding to an object-identifier
    value of\n    * {iso(1) member-body(2) United States(840) mit(113554)\n    * infosys(1)
    gssapi(2) generic(1) user_name(1)}.  The constant\n    * GSS_C_NT_USER_NAME should
    be initialized to point\n    * to that gss_OID_desc.\n    */\n   extern gss_OID
    GSS_C_NT_USER_NAME;\n   /*\n    * The implementation must reserve static storage
    for a\n    * gss_OID_desc object containing the value\n    * {10, (void *)\"\\x2a\\x86\\x48\\x86\\xf7\\x12\"\n
    \   *              \"\\x01\\x02\\x01\\x02\"},\n    * corresponding to an object-identifier
    value of\n    * {iso(1) member-body(2) United States(840) mit(113554)\n    * infosys(1)
    gssapi(2) generic(1) machine_uid_name(2)}.\n    * The constant GSS_C_NT_MACHINE_UID_NAME
    should be\n    * initialized to point to that gss_OID_desc.\n    */\n   extern
    gss_OID GSS_C_NT_MACHINE_UID_NAME;\n   /*\n    * The implementation must reserve
    static storage for a\n    * gss_OID_desc object containing the value\n    * {10,
    (void *)\"\\x2a\\x86\\x48\\x86\\xf7\\x12\"\n    *              \"\\x01\\x02\\x01\\x03\"},\n
    \   * corresponding to an object-identifier value of\n    * {iso(1) member-body(2)
    United States(840) mit(113554)\n    * infosys(1) gssapi(2) generic(1) string_uid_name(3)}.\n
    \   * The constant GSS_C_NT_STRING_UID_NAME should be\n    * initialized to point
    to that gss_OID_desc.\n    */\n   extern gss_OID GSS_C_NT_STRING_UID_NAME;\n   /*\n
    \   * The implementation must reserve static storage for a\n    * gss_OID_desc
    object containing the value\n    * {6, (void *)\"\\x2b\\x06\\x01\\x05\\x06\\x02\"},\n
    \   * corresponding to an object-identifier value of\n    * {iso(1) org(3) dod(6)
    internet(1) security(5)\n    * nametypes(6) gss-host-based-services(2)).  The
    constant\n    * GSS_C_NT_HOSTBASED_SERVICE_X should be initialized to point\n
    \   * to that gss_OID_desc.  This is a deprecated OID value, and\n    * implementations
    wishing to support hostbased-service names\n    * should instead use the GSS_C_NT_HOSTBASED_SERVICE
    OID,\n    * defined below, to identify such names;\n    * GSS_C_NT_HOSTBASED_SERVICE_X
    should be accepted a synonym\n    * for GSS_C_NT_HOSTBASED_SERVICE when presented
    as an input\n    * parameter, but should not be emitted by GSS-API\n    * implementations\n
    \   */\n   extern gss_OID GSS_C_NT_HOSTBASED_SERVICE_X;\n   /*\n    * The implementation
    must reserve static storage for a\n    * gss_OID_desc object containing the value\n
    \   * {10, (void *)\"\\x2a\\x86\\x48\\x86\\xf7\\x12\"\n    *              \"\\x01\\x02\\x01\\x04\"},
    corresponding to an\n    * object-identifier value of {iso(1) member-body(2)\n
    \   * Unites States(840) mit(113554) infosys(1) gssapi(2)\n    * generic(1) service_name(4)}.
    \ The constant\n    * GSS_C_NT_HOSTBASED_SERVICE should be initialized\n    *
    to point to that gss_OID_desc.\n    */\n   extern gss_OID GSS_C_NT_HOSTBASED_SERVICE;\n
    \  /*\n    * The implementation must reserve static storage for a\n    * gss_OID_desc
    object containing the value\n    * {6, (void *)\"\\x2b\\x06\\01\\x05\\x06\\x03\"},\n
    \   * corresponding to an object identifier value of\n    * {1(iso), 3(org), 6(dod),
    1(internet), 5(security),\n    * 6(nametypes), 3(gss-anonymous-name)}.  The constant\n
    \   * and GSS_C_NT_ANONYMOUS should be initialized to point\n    * to that gss_OID_desc.\n
    \   */\n   extern gss_OID GSS_C_NT_ANONYMOUS;\n   /*\n    * The implementation
    must reserve static storage for a\n    * gss_OID_desc object containing the value\n
    \   * {6, (void *)\"\\x2b\\x06\\x01\\x05\\x06\\x04\"},\n    * corresponding to
    an object-identifier value of\n    * {1(iso), 3(org), 6(dod), 1(internet), 5(security),\n
    \   * 6(nametypes), 4(gss-api-exported-name)}.  The constant\n    * GSS_C_NT_EXPORT_NAME
    should be initialized to point\n    * to that gss_OID_desc.\n    */\n   extern
    gss_OID GSS_C_NT_EXPORT_NAME;\n   /* Major status codes */\n   #define GSS_S_COMPLETE
    0\n   /*\n    * Some \"helper\" definitions to make the status code macros obvious.\n
    \   */\n   #define GSS_C_CALLING_ERROR_OFFSET 24\n   #define GSS_C_ROUTINE_ERROR_OFFSET
    16\n   #define GSS_C_SUPPLEMENTARY_OFFSET 0\n   #define GSS_C_CALLING_ERROR_MASK
    0377ul\n   #define GSS_C_ROUTINE_ERROR_MASK 0377ul\n   #define GSS_C_SUPPLEMENTARY_MASK
    0177777ul\n   /*\n    * The macros that test status codes for error conditions.\n
    \   * Note that the GSS_ERROR() macro has changed slightly from\n    * the V1
    GSS-API so that it now evaluates its argument\n    * only once.\n    */\n   #define
    GSS_CALLING_ERROR(x) \\\n    (x & (GSS_C_CALLING_ERROR_MASK << GSS_C_CALLING_ERROR_OFFSET))\n
    \  #define GSS_ROUTINE_ERROR(x) \\\n    (x & (GSS_C_ROUTINE_ERROR_MASK << GSS_C_ROUTINE_ERROR_OFFSET))\n
    \  #define GSS_SUPPLEMENTARY_INFO(x) \\\n    (x & (GSS_C_SUPPLEMENTARY_MASK <<
    GSS_C_SUPPLEMENTARY_OFFSET))\n   #define GSS_ERROR(x) \\\n    (x & ((GSS_C_CALLING_ERROR_MASK
    << GSS_C_CALLING_ERROR_OFFSET) | \\\n          (GSS_C_ROUTINE_ERROR_MASK << GSS_C_ROUTINE_ERROR_OFFSET)))\n
    \  /*\n    * Now the actual status code definitions\n    */\n   /*\n    * Calling
    errors:\n    */\n   #define GSS_S_CALL_INACCESSIBLE_READ \\\n   (1ul << GSS_C_CALLING_ERROR_OFFSET)\n
    \  #define GSS_S_CALL_INACCESSIBLE_WRITE \\\n   (2ul << GSS_C_CALLING_ERROR_OFFSET)\n
    \  #define GSS_S_CALL_BAD_STRUCTURE \\\n   (3ul << GSS_C_CALLING_ERROR_OFFSET)\n
    \  /*\n    * Routine errors:\n    */\n   #define GSS_S_BAD_MECH             (1ul
    <<\n   GSS_C_ROUTINE_ERROR_OFFSET)\n   #define GSS_S_BAD_NAME             (2ul
    <<\n   GSS_C_ROUTINE_ERROR_OFFSET)\n   #define GSS_S_BAD_NAMETYPE         (3ul
    <<\n   GSS_C_ROUTINE_ERROR_OFFSET)\n   #define GSS_S_BAD_BINDINGS         (4ul
    <<\n   GSS_C_ROUTINE_ERROR_OFFSET)\n   #define GSS_S_BAD_STATUS           (5ul
    <<\n   GSS_C_ROUTINE_ERROR_OFFSET)\n   #define GSS_S_BAD_SIG              (6ul
    <<\n   GSS_C_ROUTINE_ERROR_OFFSET)\n   #define GSS_S_BAD_MIC GSS_S_BAD_SIG\n   #define
    GSS_S_NO_CRED              (7ul <<\n   GSS_C_ROUTINE_ERROR_OFFSET)\n   #define
    GSS_S_NO_CONTEXT           (8ul <<\n   GSS_C_ROUTINE_ERROR_OFFSET)\n   #define
    GSS_S_DEFECTIVE_TOKEN      (9ul <<\n   GSS_C_ROUTINE_ERROR_OFFSET)\n   #define
    GSS_S_DEFECTIVE_CREDENTIAL (10ul <<\n   GSS_C_ROUTINE_ERROR_OFFSET)\n   #define
    GSS_S_CREDENTIALS_EXPIRED  (11ul <<\n   GSS_C_ROUTINE_ERROR_OFFSET)\n   #define
    GSS_S_CONTEXT_EXPIRED      (12ul <<\n   GSS_C_ROUTINE_ERROR_OFFSET)\n   #define
    GSS_S_FAILURE              (13ul <<\n   GSS_C_ROUTINE_ERROR_OFFSET)\n   #define
    GSS_S_BAD_QOP              (14ul <<\n   GSS_C_ROUTINE_ERROR_OFFSET)\n   #define
    GSS_S_UNAUTHORIZED         (15ul <<\n   GSS_C_ROUTINE_ERROR_OFFSET)\n   #define
    GSS_S_UNAVAILABLE          (16ul <<\n   GSS_C_ROUTINE_ERROR_OFFSET)\n   #define
    GSS_S_DUPLICATE_ELEMENT    (17ul <<\n   GSS_C_ROUTINE_ERROR_OFFSET)\n   #define
    GSS_S_NAME_NOT_MN          (18ul <<\n   GSS_C_ROUTINE_ERROR_OFFSET)\n   /*\n    *
    Supplementary info bits:\n    */\n   #define GSS_S_CONTINUE_NEEDED \\\n            (1ul
    << (GSS_C_SUPPLEMENTARY_OFFSET + 0))\n   #define GSS_S_DUPLICATE_TOKEN \\\n            (1ul
    << (GSS_C_SUPPLEMENTARY_OFFSET + 1))\n   #define GSS_S_OLD_TOKEN \\\n            (1ul
    << (GSS_C_SUPPLEMENTARY_OFFSET + 2))\n   #define GSS_S_UNSEQ_TOKEN \\\n            (1ul
    << (GSS_C_SUPPLEMENTARY_OFFSET + 3))\n   #define GSS_S_GAP_TOKEN \\\n            (1ul
    << (GSS_C_SUPPLEMENTARY_OFFSET + 4))\n   /*\n    * Finally, function prototypes
    for the GSS-API routines.\n    */\n   OM_uint32 gss_acquire_cred\n                 (OM_uint32
    ,             /*  minor_status */\n                  const gss_name_t,       /*
    desired_name */\n                  OM_uint32,              /* time_req */\n                  const
    gss_OID_set,      /* desired_mechs */\n                  gss_cred_usage_t,       /*
    cred_usage */\n                  gss_cred_id_t ,         /* output_cred_handle
    */\n                  gss_OID_set ,           /* actual_mechs */\n                  OM_uint32
    *             /* time_rec */\n                 );\n   OM_uint32 gss_release_cred\n
    \                (OM_uint32 ,             /* minor_status */\n                  gss_cred_id_t
    *         /* cred_handle */\n                 );\n   OM_uint32 gss_init_sec_context\n
    \                (OM_uint32 ,             /* minor_status */\n                  const
    gss_cred_id_t,    /* initiator_cred_handle */\n                  gss_ctx_id_t
    ,          /* context_handle */\n                  const gss_name_t,       /*
    target_name */\n                  const gss_OID,          /* mech_type */\n                  OM_uint32,
    \             /* req_flags */\n                  OM_uint32,              /* time_req
    */\n                  const gss_channel_bindings_t,\n                                          /*
    input_chan_bindings */\n                  const gss_buffer_t,     /* input_token
    */\n                  gss_OID ,               /* actual_mech_type */\n                  gss_buffer_t,
    \          /* output_token */\n                  OM_uint32 ,             /* ret_flags
    */\n                  OM_uint32 *             /* time_rec */\n                 );\n
    \  OM_uint32 gss_accept_sec_context\n                 (OM_uint32 ,             /*
    minor_status */\n                  gss_ctx_id_t ,          /* context_handle */\n
    \                 const gss_cred_id_t,    /* acceptor_cred_handle */\n                  const
    gss_buffer_t,     /* input_token_buffer */\n                  const gss_channel_bindings_t,\n
    \                                         /* input_chan_bindings */\n                  gss_name_t
    ,            /* src_name */\n                  gss_OID ,               /* mech_type
    */\n                  gss_buffer_t,           /* output_token */\n                  OM_uint32
    ,             /* ret_flags */\n                  OM_uint32 ,             /* time_rec
    */\n                  gss_cred_id_t *         /* delegated_cred_handle */\n                 );\n
    \  OM_uint32 gss_process_context_token\n                 (OM_uint32 ,             /*
    minor_status */\n                  const gss_ctx_id_t,     /* context_handle */\n
    \                 const gss_buffer_t      /* token_buffer */\n                 );\n
    \  OM_uint32 gss_delete_sec_context\n                 (OM_uint32 ,             /*
    minor_status */\n                  gss_ctx_id_t ,          /* context_handle */\n
    \                 gss_buffer_t            /* output_token */\n                 );\n
    \  OM_uint32 gss_context_time\n                 (OM_uint32 ,             /* minor_status
    */\n                  const gss_ctx_id_t,     /* context_handle */\n                  OM_uint32
    *             /* time_rec */\n                 );\n   OM_uint32 gss_get_mic\n
    \                (OM_uint32 ,             /* minor_status */\n                  const
    gss_ctx_id_t,     /* context_handle */\n                  gss_qop_t,              /*
    qop_req */\n                  const gss_buffer_t,     /* message_buffer */\n                  gss_buffer_t
    \           /* message_token */\n                 );\n   OM_uint32 gss_verify_mic\n
    \                (OM_uint32 ,             /* minor_status */\n                  const
    gss_ctx_id_t,     /* context_handle */\n                  const gss_buffer_t,
    \    /* message_buffer */\n                  const gss_buffer_t,     /* token_buffer
    */\n                  gss_qop_t *             /* qop_state */\n                 );\n
    \  OM_uint32 gss_wrap\n                 (OM_uint32 ,             /* minor_status
    */\n                  const gss_ctx_id_t,     /* context_handle */\n                  int,
    \                   /* conf_req_flag */\n                  gss_qop_t,              /*
    qop_req */\n                  const gss_buffer_t,     /* input_message_buffer
    */\n                  int ,                   /* conf_state */\n                  gss_buffer_t
    \           /* output_message_buffer */\n                 );\n   OM_uint32 gss_unwrap\n
    \                (OM_uint32 ,             /* minor_status */\n                  const
    gss_ctx_id_t,     /* context_handle */\n                  const gss_buffer_t,
    \    /* input_message_buffer */\n                  gss_buffer_t,           /*
    output_message_buffer */\n                  int ,                   /* conf_state
    */\n                  gss_qop_t *             /* qop_state */\n                 );\n
    \  OM_uint32 gss_display_status\n                 (OM_uint32 ,             /*
    minor_status */\n                  OM_uint32,              /* status_value */\n
    \                 int,                    /* status_type */\n                  const
    gss_OID,          /* mech_type */\n                  OM_uint32 ,             /*
    message_context */\n                  gss_buffer_t            /* status_string
    */\n                 );\n   OM_uint32 gss_indicate_mechs\n                 (OM_uint32
    ,             /* minor_status */\n                  gss_OID_set *           /*
    mech_set */\n                 );\n   OM_uint32 gss_compare_name\n                 (OM_uint32
    ,             /* minor_status */\n                  const gss_name_t,       /*
    name1 */\n                  const gss_name_t,       /* name2 */\n                  int
    *                   /* name_equal */\n                 );\n   OM_uint32 gss_display_name\n
    \                (OM_uint32 ,             /* minor_status */\n                  const
    gss_name_t,       /* input_name */\n                  gss_buffer_t,           /*
    output_name_buffer */\n                  gss_OID *               /* output_name_type
    */\n                 );\n   OM_uint32 gss_import_name\n                 (OM_uint32
    ,             /* minor_status */\n                  const gss_buffer_t,     /*
    input_name_buffer */\n                  const gss_OID,          /* input_name_type
    */\n                  gss_name_t *            /* output_name */\n                 );\n
    \  OM_uint32 gss_export_name\n                 (OM_uint32,              /* minor_status
    */\n                  const gss_name_t,       /* input_name */\n                  gss_buffer_t
    \           /* exported_name */\n                 );\n   OM_uint32 gss_release_name\n
    \                (OM_uint32 *,            /* minor_status */\n                  gss_name_t
    *            /* input_name */\n                 );\n   OM_uint32 gss_release_buffer\n
    \                (OM_uint32 ,             /* minor_status */\n                  gss_buffer_t
    \           /* buffer */\n                 );\n   OM_uint32 gss_release_oid_set\n
    \                (OM_uint32 ,             /* minor_status */\n                  gss_OID_set
    *           /* set */\n                 );\n   OM_uint32 gss_inquire_cred\n                 (OM_uint32
    ,             /* minor_status */\n                  const gss_cred_id_t,    /*
    cred_handle */\n                  gss_name_t ,            /* name */\n                  OM_uint32
    ,             /* lifetime */\n                  gss_cred_usage_t ,      /* cred_usage
    */\n                  gss_OID_set *           /* mechanisms */\n                 );\n
    \  OM_uint32 gss_inquire_context (\n                  OM_uint32 ,             /*
    minor_status */\n                  const gss_ctx_id_t,     /* context_handle */\n
    \                 gss_name_t ,            /* src_name */\n                  gss_name_t
    ,            /* targ_name */\n                  OM_uint32 ,             /* lifetime_rec
    */\n                  gss_OID ,               /* mech_type */\n                  OM_uint32
    ,             /* ctx_flags */\n                  int ,                   /* locally_initiated
    */\n                  int *                   /* open */\n                 );\n
    \  OM_uint32 gss_wrap_size_limit (\n                  OM_uint32 ,             /*
    minor_status */\n                  const gss_ctx_id_t,     /* context_handle */\n
    \                 int,                    /* conf_req_flag */\n                  gss_qop_t,
    \             /* qop_req */\n                  OM_uint32,              /* req_output_size
    */\n                  OM_uint32 *             /* max_input_size */\n                 );\n
    \  OM_uint32 gss_add_cred (\n                  OM_uint32 ,             /* minor_status
    */\n                  const gss_cred_id_t,    /* input_cred_handle */\n                  const
    gss_name_t,       /* desired_name */\n                  const gss_OID,          /*
    desired_mech */\n                  gss_cred_usage_t,       /* cred_usage */\n
    \                 OM_uint32,              /* initiator_time_req */\n                  OM_uint32,
    \             /* acceptor_time_req */\n                  gss_cred_id_t ,         /*
    output_cred_handle */\n                  gss_OID_set ,           /* actual_mechs
    */\n                  OM_uint32 ,             /* initiator_time_rec */\n                  OM_uint32
    *             /* acceptor_time_rec */\n                 );\n   OM_uint32 gss_inquire_cred_by_mech
    (\n                  OM_uint32 ,             /* minor_status */\n                  const
    gss_cred_id_t,    /* cred_handle */\n                  const gss_OID,          /*
    mech_type */\n                  gss_name_t ,            /* name */\n                  OM_uint32
    ,             /* initiator_lifetime */\n                  OM_uint32 ,             /*
    acceptor_lifetime */\n                  gss_cred_usage_t *      /* cred_usage
    */\n                 );\n   OM_uint32 gss_export_sec_context (\n                  OM_uint32
    ,             /* minor_status */\n                  gss_ctx_id_t ,          /*
    context_handle */\n                  gss_buffer_t            /* interprocess_token
    */\n                 );\n   OM_uint32 gss_import_sec_context (\n                  OM_uint32
    ,             /* minor_status */\n                  const gss_buffer_t,     /*
    interprocess_token */\n                  gss_ctx_id_t *          /* context_handle
    */\n                 );\n   OM_uint32 gss_create_empty_oid_set (\n                  OM_uint32
    ,             /* minor_status */\n                  gss_OID_set *           /*
    oid_set */\n                 );\n   OM_uint32 gss_add_oid_set_member (\n                  OM_uint32
    ,             /* minor_status */\n                  const gss_OID,          /*
    member_oid */\n                  gss_OID_set *           /* oid_set */\n                 );\n
    \  OM_uint32 gss_test_oid_set_member (\n                  OM_uint32 ,             /*
    minor_status */\n                  const gss_OID,          /* member */\n                  const
    gss_OID_set,      /* set */\n                  int *                   /* present
    */\n                 );\n   OM_uint32 gss_inquire_names_for_mech (\n                  OM_uint32
    ,             /* minor_status */\n                  const gss_OID,          /*
    mechanism */\n                  gss_OID_set *           /* name_types */\n                 );\n
    \  OM_uint32 gss_inquire_mechs_for_name (\n                  OM_uint32 ,             /*
    minor_status */\n                  const gss_name_t,       /* input_name */\n
    \                 gss_OID_set *           /* mech_types */\n                 );\n
    \  OM_uint32 gss_canonicalize_name (\n                  OM_uint32 ,             /*
    minor_status */\n                  const gss_name_t,       /* input_name */\n
    \                 const gss_OID,          /* mech_type */\n                  gss_name_t
    *            /* output_name */\n                 );\n   OM_uint32 gss_duplicate_name
    (\n                  OM_uint32 ,             /* minor_status */\n                  const
    gss_name_t,       /* src_name */\n                  gss_name_t *            /*
    dest_name */\n                 );\n   /*\n    * The following routines are obsolete
    variants of gss_get_mic,\n    * gss_verify_mic, gss_wrap and gss_unwrap.  They
    should be\n    * provided by GSS-API V2 implementations for backwards\n    * compatibility
    with V1 applications.  Distinct entrypoints\n    * (as opposed to #defines) should
    be provided, both to allow\n    * GSS-API V1 applications to link against GSS-API
    V2\n      implementations,\n    * and to retain the slight parameter type differences
    between the\n    * obsolete versions of these routines and their current forms.\n
    \   */\n   OM_uint32 gss_sign\n                 (OM_uint32 ,        /* minor_status
    */\n                  gss_ctx_id_t,      /* context_handle */\n                  int,
    \              /* qop_req */\n                  gss_buffer_t,      /* message_buffer
    */\n                  gss_buffer_t       /* message_token */\n                 );\n
    \  OM_uint32 gss_verify\n                 (OM_uint32 ,        /* minor_status
    */\n                  gss_ctx_id_t,      /* context_handle */\n                  gss_buffer_t,
    \     /* message_buffer */\n                  gss_buffer_t,      /* token_buffer
    */\n                  int *              /* qop_state */\n                 );\n
    \  OM_uint32 gss_seal\n                 (OM_uint32 ,        /* minor_status */\n
    \                 gss_ctx_id_t,      /* context_handle */\n                  int,
    \              /* conf_req_flag */\n                  int,               /* qop_req
    */\n                  gss_buffer_t,      /* input_message_buffer */\n                  int
    ,              /* conf_state */\n                  gss_buffer_t       /* output_message_buffer
    */\n                 );\n   OM_uint32 gss_unseal\n                 (OM_uint32
    ,        /* minor_status */\n                  gss_ctx_id_t,      /* context_handle
    */\n                  gss_buffer_t,      /* input_message_buffer */\n                  gss_buffer_t,
    \     /* output_message_buffer */\n                  int ,              /* conf_state
    */\n                  int *              /* qop_state */\n                 );\n
    \  #endif /* GSSAPI_H_ */\n"
  title: 6.   Security Considerations
- contents:
  - "Appendix B. Additional constraints for application binary portability\n   The
    purpose of this C-bindings document is to encourage source-level\n   portability
    of applications across GSS-API implementations on\n   different platforms and
    atop different mechanisms.  Additional goals\n   that have not been explicitly
    addressed by this document are link-\n   time and run-time portability.\n   Link-time
    portability provides the ability to compile an application\n   against one implementation
    of GSS-API, and then link it against a\n   different implementation on the same
    platform.  It is a stricter\n   requirement than source-level portability.\n   Run-time
    portability differs from link-time portability only on those\n   platforms that
    implement dynamically loadable GSS-API\n   implementations, but do not offer load-time
    symbol resolution. On\n   such platforms, run-time portability is a stricter requirement
    than\n   link-time portability, and will typically include the precise\n   placement
    of the various GSS-API routines within library entrypoint\n   vectors.\n   Individual
    platforms will impose their own rules that must be\n   followed to achieve link-time
    (and run-time, if different)\n   portability.  In order to ensure either form
    of binary portability,\n   an ABI specification must be written for GSS-API implementations
    on\n   that platform.  However, it is recognized that there are some issues\n
    \  that are likely to be common to all such ABI specifications. This\n   appendix
    is intended to be a repository for such common issues, and\n   contains some suggestions
    that individual ABI specifications may\n   choose to reference. Since machine
    architectures vary greatly, it may\n   not be possible or desirable to follow
    these suggestions on all\n   platforms.\n"
  - contents:
    - "B.1. Pointers\n   While ANSI-C provides a single pointer type for each declared
      type,\n   plus a single (void *) type, some platforms (notably those using\n
      \  segmented memory architectures) augment this with various modified\n   pointer
      types (e.g. far pointers, near pointers). These language\n   bindings assume
      ANSI-C, and thus do not address such non-standard\n   implementations.  GSS-API
      implementations for such platforms must\n   choose an appropriate memory model,
      and should use it consistently\n   throughout.  For example, if a memory model
      is chosen that requires\n   the use of far pointers when passing routine parameters,
      then far\n   pointers should also be used within the structures defined by GSS-\n
      \  API.\n"
    title: B.1. Pointers
  - contents:
    - "B.2. Internal structure alignment\n   GSS-API defines several data-structures
      containing differently-sized\n   fields.  An ABI specification should include
      a detailed description\n   of how the fields of such structures are aligned,
      and if there is any\n   internal padding in these data structures.  The use
      of compiler\n   defaults for the platform is recommended.\n"
    title: B.2. Internal structure alignment
  - contents:
    - "B.3. Handle types\n   The C bindings specify that the gss_cred_id_t and gss_ctx_id_t
      types\n   should be implemented as either pointer or arithmetic types, and that\n
      \  if pointer types are used, care should be taken to ensure that two\n   handles
      may be compared with the == operator. Note that ANSI-C does\n   not guarantee
      that two pointer values may be compared with the ==\n   operator unless either
      the two pointers point to members of a single\n   array, or at least one of
      the pointers contains a NULL value.\n   For binary portability, additional constraints
      are required. The\n   following is an attempt at defining platform-independent
      constraints.\n   The size of the handle type must be the same as sizeof(void
      *), using\n   the appropriate memory model.\n   The == operator for the chosen
      type must be a simple bit-wise\n   comparison.  That is, for two in-memory handle
      objects h1 and h2, the\n   boolean value of the expression\n      (h1 == h2)\n
      \  should always be the same as the boolean value of the expression\n      (memcmp(&h1,
      &h2, sizeof(h1)) == 0)\n   The actual use of the type (void *) for handle types
      is discouraged,\n   not for binary portability reasons, but since it effectively
      disables\n   much of the compile-time type-checking that the compiler can\n
      \  otherwise perform, and is therefore not \"programmer-friendly\".  If a\n
      \  pointer implementation is desired, and if the platform's\n   implementation
      of pointers permits, the handles should be implemented\n   as pointers to distinct
      implementation-defined types.\n"
    title: B.3. Handle types
  - contents:
    - "B.4. The gss_name_t type\n   The gss_name_t type, representing the internal
      name object, should be\n   implemented as a pointer type.  The use of the (void
      *) type is\n   discouraged as it does not allow the compiler to perform strong\n
      \  type-checking.  However, the pointer type chosen should be of the\n   same
      size as the (void *) type.  Provided this rule is obeyed, ABI\n   specifications
      need not further constrain the implementation of\n   gss_name_t objects.\n"
    title: B.4. The gss_name_t type
  - contents:
    - "B.5. The int and size_t types\n   Some platforms may support differently sized
      implementations of the\n   \"int\" and \"size_t\" types, perhaps chosen through
      compiler switches,\n   and perhaps dependent on memory model.  An ABI specification
      for such\n   a platform should include required implementations for these types.\n
      \  It is recommended that the default implementation (for the chosen\n   memory
      model, if appropriate) is chosen.\n"
    title: B.5. The int and size_t types
  - contents:
    - "B.6. Procedure-calling conventions\n   Some platforms support a variety of
      different binary conventions for\n   calling procedures.  Such conventions cover
      things like the format of\n   the stack frame, the order in which the routine
      parameters are pushed\n   onto the stack, whether or not a parameter count is
      pushed onto the\n   stack, whether some argument(s) or return values are to
      be passed in\n   registers, and whether the called routine or the caller is\n
      \  responsible for removing the stack frame on return.  For such\n   platforms,
      an ABI specification should specify which calling\n   convention is to be used
      for GSS-API implementations.\n"
    title: B.6. Procedure-calling conventions
  title: Appendix B. Additional constraints for application binary portability
- contents:
  - "References\n   [GSSAPI]    Linn, J., \"Generic Security Service Application Program\n
    \              Interface Version 2, Update 1\", RFC 2743, January 2000.\n   [XOM]
    \      OSI Object Management API Specification, Version 2.0 t\",\n               X.400
    API Association & X/Open Company Limited, August\n               24, 1990 Specification
    of datatypes and routines for\n               manipulating information objects.\n"
  title: References
- contents:
  - "Author's Address\n   John Wray\n   Iris Associates\n   5 Technology Park Drive,\n
    \  Westford, MA  01886\n   USA\n   Phone: +1-978-392-6689\n   EMail: John_Wray@Iris.com\n"
  title: Author's Address
- contents:
  - "Full Copyright Statement\n   Copyright (C) The Internet Society (2000).  All
    Rights Reserved.\n   This document and translations of it may be copied and furnished
    to\n   others, and derivative works that comment on or otherwise explain it\n
    \  or assist in its implementation may be prepared, copied, published\n   and
    distributed, in whole or in part, without restriction of any\n   kind, provided
    that the above copyright notice and this paragraph are\n   included on all such
    copies and derivative works.  However, this\n   document itself may not be modified
    in any way, such as by removing\n   the copyright notice or references to the
    Internet Society or other\n   Internet organizations, except as needed for the
    purpose of\n   developing Internet standards in which case the procedures for\n
    \  copyrights defined in the Internet Standards process must be\n   followed,
    or as required to translate it into languages other than\n   English.\n   The
    limited permissions granted above are perpetual and will not be\n   revoked by
    the Internet Society or its successors or assigns.\n   This document and the information
    contained herein is provided on an\n   \"AS IS\" basis and THE INTERNET SOCIETY
    AND THE INTERNET ENGINEERING\n   TASK FORCE DISCLAIMS ALL WARRANTIES, EXPRESS
    OR IMPLIED, INCLUDING\n   BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE
    INFORMATION\n   HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES
    OF\n   MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.\n"
  title: Full Copyright Statement
- contents:
  - "Acknowledgement\n   Funding for the RFC Editor function is currently provided
    by the\n   Internet Society.\n"
  title: Acknowledgement
