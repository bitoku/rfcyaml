Abstract The de facto standard application program interface (API) for TCP/IP applications is the "sockets" interface.
Although this API was developed for Unix in the early 1980s it has also been implemented on a wide variety of non Unix systems.
TCP/IP applications written using the sockets API have in the past enjoyed a high degree of portability and we would like the same portability with IPv6 applications.
But changes are required to the sockets API to support IPv6 and this memo describes these changes.
These include a new socket address structure to carry IPv6 addresses, new address conversion functions, and some new socket options.
These extensions are designed to provide access to the basic IPv6 features required by TCP and UDP applications, including multicasting, while introducing a minimum of change into the system and providing complete compatibility for existing IPv4 applications.
Additional extensions for advanced IPv6 features (raw sockets and access to the IPv6 extension headers) are defined in another document [4].
While IPv4 addresses are 32 bits long, IPv6 interfaces are identified by 128 bit addresses.
The socket interface makes the size of an IP address quite visible to an application; virtually all TCP/IP applications for BSD based systems have knowledge of the size of an IP address.
Those parts of the API that expose the addresses must be changed to accommodate the larger IPv6 address size.
IPv6 also introduces new features (e.g., traffic class and flowlabel), some of which must be made visible to applications via the API.
This memo defines a set of extensions to the socket interface to support the larger address size and new features of IPv6. 2.
There are a number of important considerations in designing changes to this well worn API: The API changes should provide both source and binary compatibility for programs written to the original API.
That is, existing program binaries should continue to operate when run on a system supporting the new API.
In addition, existing applications that are re compiled and run on a system supporting the new API should continue to operate.
Simply put, the API changes for IPv6 should not break existing programs.
An additonal mechanism for implementations to verify this is to verify the new symbols are protected by Feature Test Macros as described in IEEE Std 1003.1.
(Such Feature Test Macros are not defined by this RFC.)
The changes to the API should be as small as possible in order to simplify the task of converting existing IPv4 applications to IPv6.
Where possible, applications should be able to use this API to interoperate with both IPv6 and IPv4 hosts.
Applications should not need to know which type of host they are communicating with.
IPv6 addresses carried in data structures should be 64 bit aligned.
This is necessary in order to obtain optimum performance on 64 bit machine architectures.
Because of the importance of providing IPv4 compatibility in the API, these extensions are explicitly designed to operate on machines that provide complete support for both IPv4 and IPv6.
A subset of this API could probably be designed for operation on systems that support only IPv6.
However, this is not addressed in this memo.
What Needs to be Changed
The socket interface API consists of a few distinct components:  Core socket functions.
Name to address translation functions.
those functions that deal with such things as setting up and tearing down TCP connections, and sending and receiving UDP packets   were designed to be transport independent.
Where protocol addresses are passed as function arguments, they are carried via opaque pointers.
A protocol specific address data structure is defined for each protocol that the socket functions support.
Applications must cast pointers to these protocol specific address structures into pointers to the generic "sockaddr" address structure when using the socket functions.
These functions need not change for IPv6, but a new IPv6 specific address data structure is needed.
The "sockaddr in" structure is the protocol specific data structure for IPv4.
This data structure actually includes 8 octets of unused space, and it is tempting to try to use this space to adapt the sockaddr in structure to IPv6.
Unfortunately, the sockaddr in structure is not large enough to hold the 16 octet IPv6 address as well as the other information (address family and port number) that is needed.
So a new address data structure must be defined for IPv6.
IPv6 addresses are scoped [2]
so they could be link local, site, organization, global, or other scopes at this time undefined.
To support applications that want to be able to identify a set of interfaces for a specific scope, the IPv6 sockaddr in structure must support a field that can be used by an implementation to identify a set of interfaces identifying the scope for an IPv6 address.
The name to address translation functions in the socket interface are gethostbyname() and gethostbyaddr().
These are left as is and new functions are defined to support IPv4 and IPv6.
Additionally, the POSIX 1003.g draft [3] specifies a new nodename to address translation function which is protocol independent.
This function can also be used with IPv4 and IPv6.
These functions are quite specific to 32 bit IPv4 addresses.
We have designed two analogous functions that convert both IPv4 and IPv6 addresses, and carry an address type parameter so that they can be extended to other protocol families as well.
Finally, a few miscellaneous features are needed to support IPv6.
New interfaces are needed to support the IPv6 traffic class, flow label, and hop limit header fields.
New socket options are needed to control the sending and receiving of IPv6 multicast packets.
The socket interface will be enhanced in the future to provide access to other IPv6 features.
These extensions are described in [4].
The data types of the structure elements given in this memo are intended to be examples, not absolute requirements.
Whenever possible, data types from Draft 6.6 (March 1997) of POSIX 1003.1g are used: uintN t means an unsigned integer of exactly N bits (e.g., uint16 t).
We also assume the argument data types from 1003.1g when possible (e.g., the final argument to setsockopt() is a size t value).
Whenever buffer sizes are specified, the POSIX 1003.1 size t data type is used (e.g., the two length arguments to getnameinfo()).
When function prototypes and structures are shown we show the headers that must be #included to cause that item to be defined.
When structures are described the members shown are the ones that must appear in an implementation.
Additional, nonstandard members may also be defined by an implementation.
As an additional precaution nonstandard members could be verified by Feature Test Macros as described in IEEE Std 1003.1.
(Such Feature Test Macros are not defined by this RFC.)
The ordering shown for the members of a structure is the recommended ordering, given alignment considerations of multibyte members, but an implementation may order the members differently.
This section specifies the socket interface changes for IPv6.
Address Family and Protocol Family
A new address family name, AF INET6, is defined in <sys/socket.h
The AF INET6 definition distinguishes between the original sockaddr in address data structure, and the new sockaddr in6 data structure.
A new protocol family name, PF INET6, is defined in <sys/socket.h
Like most of the other protocol family names, this will usually be defined to have the same value as the corresponding address family name: #define
The PF INET6 is used in the first argument to the socket() function to indicate that an IPv6 socket is being created.
A new in6 addr structure holds a single IPv6 address and is defined as a result of including <netinet/in.h>:
The IPv6 address is stored in network byte order.
The structure in6 addr above is usually implemented with an embedded union with extra fields that force the desired alignment level in a manner similar to BSD implementations of "struct in addr".
Those additional implementation details are omitted here for simplicity.
An example is as follows: struct in6 addr { union { uint8 t   S6 u8[16];
S6 u8 3.3 Socket Address Structure for 4.3BSD Based Systems
In the socket interface, a different protocol specific data structure is defined to carry the addresses for each protocol suite.
Each protocol  specific data structure is designed so it can be cast into a protocol  independent data structure   the "sockaddr" structure.
Each has a "family" field that overlays the "sa family" of the sockaddr data structure.
This field identifies the type of the data structure.
The sockaddr in structure is the protocol specific address data structure for IPv4.
It is used to pass addresses between applications and the system in the socket functions.
The following sockaddr in6 structure holds IPv6 addresses and is defined as a result of including the <netinet/in.h> header:
traffic class & flow info
The sin6 family field identifies this as a sockaddr in6 structure.
This field overlays the sa family field when the buffer is cast to a sockaddr data structure.
The value of this field must be AF INET6.
The sin6 port field contains the 16 bit UDP or TCP port number.
This field is used in the same way as the sin port field of the sockaddr in structure.
The port number is stored in network byte order.
The sin6 flowinfo field is a 32 bit field that contains two pieces of information: the traffic class and the flow label.
The contents and interpretation of this member is specified in [1].
The sin6 flowinfo field SHOULD be set to zero by an implementation prior to using the sockaddr in6 structure by an application on receive operations.
The sin6 addr field is a single in6 addr structure (defined in the previous section).
This field holds one 128 bit IPv6 address.
The address is stored in network byte order.
The ordering of elements in this structure is specifically designed so that when sin6 addr field is aligned on a 64 bit boundary, the start of the structure will also be aligned on a 64 bit boundary.
This is done for optimum performance on 64 bit architectures.
id field is a 32 bit integer that identifies a set of interfaces as appropriate for the scope of the address carried in the sin6 addr field.
For a link scope sin6 addr sin6 scope
id would be an interface index.
For a site scope sin6 addr, sin6 scope id would be a site identifier.
The mapping of sin6 scope id to an interface or set of interfaces is left to implementation and future specifications on the subject of site identifiers.
Notice that the sockaddr in6 structure will normally be larger than the generic sockaddr structure.
On many existing implementations the sizeof(struct sockaddr in) equals sizeof(struct sockaddr), with both being 16 bytes.
Any existing code that makes this assumption needs to be examined carefully when converting to IPv6.
3.4 Socket Address Structure for 4.4BSD Based Systems
The 4.4BSD release includes a small, but incompatible change to the socket interface.
The "sa family" field of the sockaddr data structure was changed from a 16 bit value to an 8 bit value, and the space saved used to hold a length field, named "sa len".
The sockaddr in6 data structure given in the previous section cannot be correctly cast into the newer sockaddr data structure.
For this reason, the following alternative IPv6 address data structure is provided to be used on systems based on 4.4BSD.
It is defined as a result of including the <netinet/in.h> header.
The definitions of all the other fields are identical to the structure defined in the previous section.
Systems that provide this version of the sockaddr in6 data structure must also declare SIN6 LEN as a result of including the <netinet/in.h> header.
This macro allows applications to determine whether they are being built on a system that supports the 4.3BSD or 4.4BSD variants of the data structure.
The Socket Functions Applications call the socket() function to create a socket descriptor that represents a communication endpoint.
The arguments to the socket() function tell the system which protocol to use, and what format address structure will be used in subsequent functions.
For example, to create an IPv4/TCP socket, applications make the call
: s   socket(PF INET, SOCK STREAM, 0); To create an IPv4/UDP socket, applications make the call
: s   socket(PF INET, SOCK DGRAM, 0); Applications may create IPv6/TCP and IPv6/UDP sockets by simply using the constant PF INET6 instead of PF INET in the first argument.
For example, to create an IPv6/TCP socket, applications make the call
: s   socket(PF INET6, SOCK STREAM, 0); To create an IPv6/UDP socket, applications make the call
: s   socket(PF INET6, SOCK DGRAM, 0); Once the application has created a PF INET6 socket, it must use the sockaddr in6 address structure when passing addresses in to the system.
The functions that the application uses to pass addresses into the system are: bind() connect()
The system will use the sockaddr in6 address structure to return addresses to applications that are using PF INET6 sockets.
The functions that return an address from the system to an application are: accept(
) recvfrom() recvmsg() getpeername() getsockname()
No changes to the syntax of the socket functions are needed to support IPv6, since all of the "address carrying" functions use an opaque address pointer, and carry an address length as a function argument.
3.6 Compatibility with IPv4 Applications
In order to support the large base of applications using the original API, system implementations must provide complete source and binary compatibility with the original API.
This means that systems must continue to support PF INET sockets and the sockaddr in address structure.
Applications must be able to create IPv4/TCP and IPv4/UDP sockets using the PF INET constant in the socket
() function, as described in the previous section.
Applications should be able to hold a combination of IPv4/TCP, IPv4/UDP, IPv6/TCP and IPv6/UDP sockets simultaneously within the same process.
Applications using the original API should continue to operate as they did on systems supporting only IPv4.
That is, they should continue to interoperate with IPv4 nodes.
3.7 Compatibility with IPv4 Nodes
The API also provides a different type of compatibility: the ability for IPv6 applications to interoperate with IPv4 applications.
This feature uses the IPv4 mapped IPv6 address format defined in the IPv6 addressing architecture specification [2].
This address format allows the IPv4 address of an IPv4 node to be represented as an IPv6 address.
The IPv4 address is encoded into the low order 32 bits of the IPv6 address, and the high order 96 bits hold the fixed prefix 0:0:0:0:0:FFFF.
IPv4  mapped addresses are written as follows: ::FFFF:<IPv4 address
These addresses can be generated automatically by the getipnodebyname() function when the specified host has only IPv4 addresses (as described in Section 6.1).
Applications may use PF INET6 sockets to open TCP connections to IPv4 nodes, or send UDP packets to IPv4 nodes, by simply encoding the destination's IPv4 address as an IPv4 mapped IPv6 address, and passing that address, within a sockaddr in6 structure, in the connect() or sendto() call.
When applications use PF INET6 sockets to accept TCP connections from IPv4 nodes, or receive UDP packets from IPv4 nodes, the system returns the peer's address to the application in the accept(), recvfrom(), or getpeername()
call using a sockaddr in6 structure encoded this way.
Few applications will likely need to know which type of node they are interoperating with.
However, for those applications that do need to know, the IN6 IS ADDR V4MAPPED
() macro, defined in Section 6.7, is provided.
While the bind() function allows applications to select the source IP address of UDP packets and TCP connections, applications often want the system to select the source address for them.
With IPv4, one specifies the address as the symbolic constant INADDR ANY (called the "wildcard" address) in the bind() call, or simply omits the bind() entirely.
Since the IPv6 address type is a structure (struct in6 addr), a symbolic constant can be used to initialize an IPv6 address variable, but cannot be used in an assignment.
Therefore systems provide the IPv6 wildcard address in two forms.
The first version is a global variable named "in6addr
any" that is an in6 addr structure.
The extern declaration for this variable is defined in <netinet/in.h>:
extern const struct in6 addr in6addr
any similarly to the way they use INADDR ANY in IPv4.
; sin6.sin6 flowinfo   0; sin6.sin6 port   htons(23); sin6.sin6 addr   in6addr
The other version is a symbolic constant named IN6ADDR ANY INIT and is defined in <netinet/in.h
This constant can be used to initialize an in6 addr structure: struct in6 addr anyaddr
; Note that this constant can be used ONLY at declaration time.
It can not be used to assign a previously declared in6 addr structure.
For example, the following code will not work: /
Be aware that the IPv4 INADDR xxx constants are all defined in host byte order but the IPv6 IN6ADDR xxx constants and the IPv6 in6addr
xxx externals are defined in network byte order.
Loopback Address Applications may need to send UDP packets to, or originate TCP connections to, services residing on the local node.
In IPv4, they can do this by using the constant IPv4 address INADDR LOOPBACK in their connect(), sendto(), or sendmsg() call.
IPv6 also provides a loopback address to contact local TCP and UDP services.
Like the unspecified address, the IPv6 loopback address is provided in two forms   a global variable and a symbolic constant.
The global variable is an in6 addr structure named "in6addr
The extern declaration for this variable is defined in <netinet/in.h>:
extern const struct in6 addr in6addr
loopback as they would use INADDR LOOPBACK in IPv4 applications (but beware of the byte ordering difference mentioned at the end of the previous section).
; sin6.sin6 flowinfo   0; sin6.sin6 port   htons(23); sin6.sin6 addr   in6addr
The symbolic constant is named IN6ADDR LOOPBACK INIT and is defined in <netinet/in.h
It can be used at declaration time ONLY; for example: struct in6 addr loopbackaddr   IN6ADDR LOOPBACK INIT; Like IN6ADDR ANY INIT, this constant cannot be used in an assignment to a previously declared IPv6 address variable.
One simple addition to the sockets API that can help application writers is the "struct sockaddr storage".
This data structure can simplify writing code portable across multiple address families and platforms.
This data structure is designed with the following goals.
It has a large enough implementation specific maximum size to store the desired set of protocol specific socket address data structures.
Specifically, it is at least large enough to accommodate sockaddr in and sockaddr in6 and possibly other protocol specific socket addresses too.
It is aligned at an appropriate boundary so protocol specific socket address data structure pointers can be cast to it and access their fields without alignment problems.
(e.g. pointers to sockaddr in6 and/or sockaddr in can be cast to it and access fields without alignment problems).
It has the initial field(s) isomorphic to the fields of the "struct sockaddr" data structure on that implementation which can be used as a discriminants for deriving the protocol in use.
These initial field(s) would on most implementations either be a single field of type "sa family t" (isomorphic to sa family field, 16 bits) or two fields of type uint8 t and sa family t respectively, (isomorphic to sa len and sa family t, 8 bits each).
An example implementation design of such a data structure would be as follows. /
Desired design of maximum size and alignment  /
( SS ALIGNSIZE sizeof (sa family t))
( SS MAXSIZE (sizeof (sa family t)   SS PAD1SIZE    SS ALIGNSIZE)) struct sockaddr storage { sa family t   ss family;
PAD1SIZE ( SS ALIGNSIZE (sizeof (uint8 t)   sizeof (sa family t))
/ sa family t   ss family;
Following fields are implementation specific
An implementation specific field " ss align" along " ss pad1" is used to force a 64 bit alignment which covers proper alignment good enough for needs of sockaddr in6 (IPv6), sockaddr in (IPv4) address data structures.
The size of padding fields
ss pad1 depends on the chosen alignment boundary.
The size of padding field  ss pad2 depends on the value of overall size chosen for the total size of the structure.
This size and alignment are represented in the above example by implementation specific (not required) constants  SS MAXSIZE (chosen value 128) and  SS ALIGNMENT (with chosen value 8).
PAD1SIZE (derived value 6) and  SS
PAD2SIZE (derived value 112) are also for illustration and not required.
The implementation specific definitions and structure field names above start with an underscore to denote implementation private namespace.
Portable code is not expected to access or reference those fields or constants.
The sockaddr storage structure solves the problem of declaring storage for automatic variables which is large enough and aligned enough for storing socket address data structure of any family.
For example, code with a file descriptor and without the context of the address family can pass a pointer to a variable of this type where a pointer to a socket address structure is expected in calls such as getpeername() and determine the address family by accessing the received content after the call.
The sockaddr storage structure may also be useful and applied to certain other interfaces where a generic socket address large enough and aligned for use with multiple address families may be needed.
A discussion of those interfaces is outside the scope of this document.
Also, much existing code assumes that any socket address structure can fit in a generic sockaddr structure.
While this has been true for IPv4 socket address structures, it has always been false for Unix domain socket address structures (but in practice this has not been a problem) and it is also false for IPv6 socket address structures (which can be a problem).
This API uses an interface index (a small positive integer) to identify the local interface on which a multicast group is joined (Section 5.3).
Additionally, the advanced API [4] uses these same interface indexes to identify the interface on which a datagram is received, or to specify the interface on which a datagram is to be sent.
Interfaces are normally known by names such as "le0", "sl1", "ppp2", and the like.
On Berkeley derived implementations, when an interface is made known to the system, the kernel assigns a unique positive integer value (called the interface index) to that interface.
These are small positive integers that start at 1.
(Note that 0 is never used for an interface index.)
There may be gaps so that there is no current interface for a particular positive interface index.
This API defines two functions that map between an interface name and index, a third function that returns all the interface names and indexes, and a fourth function to return the dynamic memory allocated by the previous function.
How these functions are implemented is left up to the implementation.
4.4BSD implementations can implement these functions using the existing sysctl() function with the NET RT IFLIST command.
Other implementations may wish to use ioctl() for this purpose.
The first function maps an interface name into its corresponding index.
if nametoindex(const char  ifname); If the specified interface name does not exist, the return value is 0, and errno is set to ENXIO.
If there was a system error (such as running out of memory), the return value is 0 and errno is set to the proper value (e.g., ENOMEM).
The second function maps an interface index into its corresponding name.
if indextoname(unsigned int ifindex, char  ifname); The ifname argument must point to a buffer of at least IF NAMESIZE bytes into which the interface name corresponding to the specified index is returned.
(IF NAMESIZE is also defined in <net/if.h> and its value includes a terminating null byte at the end of the interface name.)
This pointer is also the return value of the function.
If there is no interface corresponding to the specified index, NULL is returned, and errno is set to ENXIO, if there was a system error (such as running out of memory), if indextoname returns NULL and errno would be set to the proper value (e.g., ENOMEM).
4.3 Return All Interface Names and Indexes
The if nameindex structure holds the information about a single interface and is defined as a result of including the <net/if.h> header.
struct if nameindex   if nameindex(void)
; The end of the array of structures is indicated by a structure with an if index of 0 and an if name of NULL.
The function returns a NULL pointer upon an error, and would set errno to the appropriate value.
The memory used for this array of structures along with the interface names pointed to by the if name members is obtained dynamically.
This memory is freed by the next function.
The following function frees the dynamic memory that was allocated by if nameindex().
if freenameindex(struct if nameindex  ptr); The argument to this function must be a pointer that was returned by if nameindex().
Currently net/if.h doesn't have prototype definitions for functions and it is recommended that these definitions be defined in net/if.h as well and the struct if nameindex{}.
A number of new socket options are defined for IPv6.
All of these new options are at the IPPROTO IPV6 level.
That is, the "level" parameter in the getsockopt() and setsockopt()
calls is IPPROTO IPV6 when using these options.
The constant name prefix IPV6  is used in all of the new socket options.
This serves to clearly identify these options as applying to IPv6.
The declaration for IPPROTO IPV6, the new IPv6 socket options, and related constants defined in this section are obtained by including the header <netinet/in.h>.
A new setsockopt() option controls the hop limit used in outgoing unicast IPv6 packets.
The name of this option is IPV6 UNICAST HOPS, and it is used at the IPPROTO IPV6 layer.
The following example illustrates how it is used: int
perror("setsockopt IPV6 UNICAST HOPS"); When the IPV6 UNICAST HOPS option is set with setsockopt(), the option value given is used as the hop limit for all subsequent unicast packets sent via that socket.
If the option is not set, the system selects a default value.
The integer hop limit value (called x) is interpreted as follows:
return an error of EINVAL
The IPV6 UNICAST HOPS option may be used with getsockopt() to determine the hop limit value that the system will use for subsequent unicast packets sent via that socket.
For example: int  hoplimit; size t  len
Three socket options at the IPPROTO IPV6 layer control some of the parameters for sending multicast packets.
Setting these options is not required: applications may send multicast packets without using these options.
The setsockopt() options for controlling the sending of multicast packets are summarized below.
These three options can also be used with getsockopt().
IF Set the interface to use for outgoing multicast packets.
The argument is the index of the interface to use.
unsigned int IPV6 MULTICAST HOPS Set the hop limit to use for outgoing multicast packets.
IPV6 UNICAST HOPS is provided to set the hop limit to use for outgoing unicast packets.)
The interpretation of the argument is the same as for the IPV6 UNICAST HOPS option:
return an error of EINVAL
If IPV6 MULTICAST HOPS is not set, the default is 1 (same as IPv4 today)
If a multicast datagram is sent to a group to which the sending host itself belongs (on the outgoing interface), a copy of the datagram is looped back by the IP layer for local delivery if this option is set to 1.
If this option is set to 0 a copy is not looped back.
Other option values return an error of EINVAL.
If IPV6 MULTICAST LOOP is not set, the default is 1 (loopback; same as IPv4 today).
The reception of multicast packets is controlled by the two setsockopt() options summarized below.
An error of EOPNOTSUPP is returned if these two options are used with getsockopt().
IPV6 JOIN GROUP Join a multicast group on a specified local interface.
If the interface index is specified as 0, the kernel chooses the local interface.
For example, some kernels look up the multicast group in the normal IPv6 routing table and using the resulting interface.
struct ipv6 mreq IPV6 LEAVE GROUP Leave a multicast group on a specified interface.
The argument type of both of these options is the ipv6 mreq structure, defined as a result of including the <netinet/in.h> header; struct ipv6 mreq { struct in6 addr ipv6mr multiaddr;
; Note that to receive multicast datagrams a process must join the multicast group and bind the UDP port to which datagrams will be sent.
Some processes also bind the multicast group address to the socket, in addition to the port, to prevent other datagrams destined to that same port from being delivered to the socket.
Library Functions New library functions are needed to perform a variety of operations with IPv6 addresses.
Functions are needed to lookup IPv6 addresses in the Domain Name System (DNS).
Both forward lookup (nodename to  address translation) and reverse lookup (address to nodename translation) need to be supported.
Functions are also needed to convert IPv6 addresses between their binary and textual form.
We note that the two existing functions, gethostbyname() and gethostbyaddr(), are left as is.
New functions are defined to handle both IPv4 and IPv6 addresses.
6.1 Nodename to Address Translation
The commonly used function gethostbyname() is inadequate for many applications, first because it provides no way for the caller to specify anything about the types of addresses desired (
, IPv6 only, IPv4 mapped IPv6 are OK, etc.), and second because many implementations of this function are not thread safe.
RFC 2133 defined a function named gethostbyname2() but this function was also inadequate, first because its use required setting a global option (RES USE INET6) when IPv6 addresses were required, and second because a flag argument is needed to provide the caller with additional control over the types of addresses required.
The following function is new and must be thread safe:
getipnodebyname(const char  name, int af,
int flags int  error num)
; The name argument can be either a node name or a numeric address string (i.e., a dotted decimal IPv4 address or an IPv6 hex address).
The af argument specifies the address family, either AF INET or AF INET6.
The error num value is returned to the caller, via a pointer, with the appropriate error code in error num, to support thread safe error code returns.
error num will be set to one of the following values: HOST NOT FOUND No such host is known.
The server recognised the request and the name but no address is available.
Another type of request to the name server for the domain might return an answer.
An unexpected server failure occurred which cannot be recovered.
A temporary and possibly transient error occurred, such as a failure of a server to respond.
The flags argument specifies the types of addresses that are searched for, and the types of addresses that are returned.
We note that a special flags value of AI DEFAULT (defined below) should handle most applications.
That is, porting simple applications to use IPv6 replaces the call hptr
getipnodebyname(name, AF INET6, AI DEFAULT, &error num); and changes any subsequent error diagnosis code to use error num instead of externally declared variables, such as h errno.
Applications desiring finer control over the types of addresses searched for and returned, can specify other combinations of the flags argument.
A flags of 0 implies a strict interpretation of the af argument: If flags is 0 and af is AF INET, then the caller wants only IPv4 addresses.
A query is made for A records.
If successful, the IPv4 addresses are returned and the h length member of the hostent structure will be 4, else the function returns a NULL pointer.
If flags is 0 and if af is AF INET6, then the caller wants only IPv6 addresses.
A query is made for AAAA records.
If successful, the IPv6 addresses are returned and the h length member of the hostent structure will be 16, else the function returns a NULL pointer.
Other constants can be logically ORed into the flags argument, to modify the behavior of the function.
If the AI V4MAPPED flag is specified along with an af of AF INET6, then the caller will accept IPv4 mapped IPv6 addresses.
That is, if no AAAA records are found then a query is made for A records and any found are returned as IPv4 mapped IPv6 addresses (h length will be 16).
The AI V4MAPPED flag is ignored unless af equals AF INET6.
The AI ALL flag is used in conjunction with the AI V4MAPPED flag, and is only used with the IPv6 address family.
When AI ALL is logically or'd with AI V4MAPPED flag then the caller wants all addresses: IPv6 and IPv4 mapped IPv6.
A query is first made for AAAA records and if successful, the IPv6 addresses are returned.
Another query is then made for A records and any found are returned as IPv4 mapped IPv6 addresses.
h length will be 16.
Only if both queries fail does the function return a NULL pointer.
This flag is ignored unless af equals AF INET6.
The AI ADDRCONFIG flag specifies that a query for AAAA records should occur only if the node has at least one IPv6 source address configured and a query for A records should occur only if the node has at least one IPv4 source address configured.
For example, if the node has no IPv6 source addresses configured, and af equals AF INET6, and the node name being looked up
has both AAAA and A records, then: (a) if only AI ADDRCONFIG is specified, the function returns a NULL pointer;
AI V4MAPPED is specified, the A records are returned as IPv4 mapped IPv6 addresses; The special flags value of AI DEFAULT is defined as #define  AI DEFAULT
We noted that the getipnodebyname() function must allow the name argument to be either a node name or a literal address string (i.e., a dotted decimal IPv4 address or an IPv6 hex address).
This saves applications from having to call inet pton() to handle literal address strings.
There are four scenarios based on the type of literal address string and the value of the af argument.
The two simple cases are: When name is a dotted decimal IPv4 address and af equals AF INET, or when name is an IPv6 hex address and af equals AF INET6.
The members of the returned hostent structure are: h name points to a copy of the name argument, h aliases is a NULL pointer, h addrtype is a copy of the af argument, h length is either 4 (for AF INET) or 16 (for AF INET6),
h addr list[0] is a pointer to the 4 byte or 16 byte binary address, and h addr list[1] is a NULL pointer.
When name is a dotted decimal IPv4 address and af equals AF INET6, and flags equals AI V4MAPPED,
an IPv4 mapped IPv6 address is returned:  h name points to an IPv6 hex address containing the IPv4  mapped IPv6 address, h aliases is a NULL pointer, h addrtype is AF INET6,
h length is 16, h addr list[0] is a pointer to the 16 byte binary address, and h addr list[1] is a NULL pointer.
If AI V4MAPPED is set (with or without AI ALL) return IPv4 mapped
It is an error when name is an IPv6 hex address and af equals AF INET.
The function's return value is a NULL pointer and error
The following function has the same arguments as the existing gethostbyaddr() function, but adds an error number.
void  src, size t len, int af, int  error num); As with getipnodebyname(), getipnodebyaddr() must be thread safe.
The error num value is returned to the caller with the appropriate error code, to support thread safe error code returns.
The following error conditions may be returned for error num:
HOST NOT FOUND No such host is known.
The server recognized the request and the name but no address is available.
Another type of request to the name server for the domain might return an answer.
An unexpected server failure occurred which cannot be recovered.
A temporary and possibly transient error occurred, such as a failure of a server to respond.
One possible source of confusion is the handling of IPv4 mapped IPv6 addresses and IPv4 compatible IPv6 addresses, but the following logic should apply.
If af is AF INET6, and if len equals 16, and if the IPv6 address is an IPv4 mapped IPv6 address or an IPv4 compatible IPv6 address, then skip over the first 12 bytes of the IPv6 address, set af to AF INET, and set len to 4. 2.
If af is AF INET, lookup the name for the given IPv4 address (e.g., query for a PTR record in the in addr.arpa domain).
If af is AF INET6, lookup the name for the given IPv6 address (e.g., query for a PTR record in the ip6.int domain).
If the function is returning success, then the single address that is returned in the hostent structure is a copy of the first argument to the function with the same address family that was passed as an argument to this function.
All four steps listed are performed, in order.
Also for the macro in section 6.7 IN6 IS ADDR
6.3 Freeing memory for getipnodebyname and getipnodebyaddr The hostent structure does not change from its existing definition.
This structure, and the information pointed to by this structure, are dynamically allocated by getipnodebyname and getipnodebyaddr.
The following function frees this memory:
freehostent(struct hostent  ptr); 6.4 Protocol Independent Nodename and Service Name Translation Nodename to address translation is done in a protocol independent fashion using the getaddrinfo() function that is taken from the Institute of Electrical and Electronic Engineers (IEEE)
POSIX 1003.1g (Protocol Independent Interfaces)
The official specification for this function will be the final POSIX standard, with the following additional requirements:  getaddrinfo() (along with the getnameinfo() function described in the next section) must be thread safe.
The AI NUMERICHOST is new with this document.
All fields in socket address structures returned by getaddrinfo() that are not filled in through an explicit argument (e.g., sin6 flowinfo and sin zero) must be set to 0.
(This makes it easier to compare socket address structures.)
getaddrinfo() must fill in the length field of a socket address structure (e.g., sin6 len) on systems that support this field.
We are providing this independent description of the function because POSIX standards are not freely available (as are IETF documents).
int getaddrinfo(const char  nodename, const char
servname, const struct addrinfo  hints, struct addrinfo   res); The addrinfo structure is defined as a result of including the <netdb.h> header.
The following names are the nonzero error codes from getaddrinfo(), and are defined in <netdb.h
servname not supported for ai socktype EAI SOCKTYPE
The nodename and servname arguments are pointers to null terminated strings or NULL.
One or both of these two arguments must be a non  NULL pointer.
In the normal client scenario, both the nodename and servname are specified.
In the normal server scenario, only the servname is specified.
A non NULL nodename string can be either a node name or a numeric host address string (i.e., a dotted decimal IPv4 address or an IPv6 hex address).
A non NULL servname string can be either a service name or a decimal port number.
The caller can optionally pass an addrinfo structure, pointed to by the third argument, to provide hints concerning the type of socket that the caller supports.
In this hints structure all members other than ai flags, ai family, ai socktype, and ai protocol must be zero or a NULL pointer.
A value of PF UNSPEC for ai family means the caller will accept any protocol family.
A value of 0 for ai socktype means the caller will accept any socket type.
A value of 0 for ai protocol means the caller will accept any protocol.
For example, if the caller handles only TCP and not UDP, then the ai socktype member of the hints structure should be set to SOCK STREAM when getaddrinfo() is called.
If the caller handles only IPv4 and not IPv6, then the ai family member of the hints structure should be set to PF INET when getaddrinfo() is called.
If the third argument to getaddrinfo() is a NULL pointer, this is the same as if the caller had filled in an addrinfo structure initialized to zero with ai family set to PF UNSPEC.
Upon successful return a pointer to a linked list of one or more addrinfo structures is returned through the final argument.
The caller can process each addrinfo structure in this list by following the ai next pointer, until a NULL pointer is encountered.
In each returned addrinfo structure
the three members ai family, ai socktype, and ai protocol
are the corresponding arguments for a call to the socket() function.
In each addrinfo structure the ai addr member points to a filled in socket address structure whose length is specified by the ai addrlen member.
If the AI PASSIVE bit is set in the ai flags member of the hints structure, then the caller plans to use the returned socket address structure in a call to bind().
In this case, if the nodename argument is a NULL pointer, then the IP address portion of the socket address structure will be set to INADDR ANY for an IPv4 address or
ANY INIT for an IPv6 address.
If the AI PASSIVE bit is not set in the ai flags member of the hints structure, then the returned socket address structure will be ready for a call to connect() (for a connection oriented protocol) or either connect(), sendto(), or sendmsg() (for a connectionless protocol).
In this case, if the nodename argument is a NULL pointer, then the IP address portion of the socket address structure will be set to the loopback address.
If the AI CANONNAME bit is set in the ai flags member of the hints structure, then upon successful return the ai canonname member of the first addrinfo structure in the linked list will point to a null  terminated string containing the canonical name of the specified nodename.
If the AI NUMERICHOST bit is set in the ai flags member of the hints structure, then a non NULL nodename string must be a numeric host address string.
Otherwise an error of EAI NONAME is returned.
This flag prevents any type of name resolution service (e.g., the DNS) from being called.
All of the information returned by getaddrinfo() is dynamically allocated: the addrinfo structures, and the socket address structures and canonical node name strings pointed to by the addrinfo structures.
To return this information to the system the function freeaddrinfo() is called: #include <sys/socket.h
> void freeaddrinfo(struct addrinfo  ai)
; The addrinfo structure pointed to by the ai argument is freed, along with any dynamic storage pointed to by the structure.
This operation is repeated until a NULL ai next pointer is encountered.
To aid applications in printing error messages based on the EAI xxx codes returned by getaddrinfo(), the following function is defined.
> #include <netdb.h> char  gai strerror(int ecode); The argument is one of the EAI xxx values defined earlier and the return value points to a string describing the error.
If the argument is not one of the EAI xxx values, the function still returns a pointer to a string whose contents indicate an unknown error.
6.5 Socket Address Structure to Nodename and Service Name
The POSIX 1003.1g specification includes no function to perform the reverse conversion from getaddrinfo(): to look up a nodename and service name, given the binary address and port.
Therefore, we define the following function:
struct sockaddr  sa, socklen t salen,
char  host, size t hostlen, char  serv, size t servlen, int flags); This function looks up an IP address and port number provided by the caller in the DNS and system specific database, and returns text strings for both in buffers provided by the caller.
The function indicates successful completion by a zero return value; a non zero return value indicates failure.
The first argument, sa, points to either a sockaddr in structure (for IPv4) or a sockaddr in6 structure (for IPv6) that holds the IP address and port number.
The salen argument gives the length of the sockaddr in or sockaddr in6 structure.
The function returns the nodename associated with the IP address in the buffer pointed to by the host argument.
The caller provides the size of this buffer via the hostlen argument.
The service name associated with the port number is returned in the buffer pointed to by serv, and the servlen argument gives the length of this buffer.
The caller specifies not to return either string by providing a zero value for the hostlen or servlen arguments.
Otherwise, the caller must provide buffers large enough to hold the nodename and the service name, including the terminating null characters.
Unfortunately most systems do not provide constants that specify the maximum size of either a fully qualified domain name or a service name.
Therefore to aid the application in allocating buffers for these two returned strings the following constants are defined in <netdb.h
The first value is actually defined as the constant MAXDNAME in recent versions of BIND's <arpa/nameser.h> header (older versions of BIND define this constant to be 256) and the second is a guess based on the services listed in the current Assigned Numbers RFC.
The final argument is a flag that changes the default actions of this function.
By default the fully qualified domain name (FQDN) for the host is looked up in the DNS and returned.
If the flag bit NI NOFQDN is set, only the nodename portion of the FQDN is returned for local hosts.
If the flag bit NI NUMERICHOST is set, or if the host's name cannot be located in the DNS, the numeric form of the host's address is returned instead of its name (e.g., by calling inet ntop() instead of getipnodebyaddr()).
If the flag bit NI NAMEREQD is set, an error is returned if the host's name cannot be located in the DNS.
If the flag bit NI NUMERICSERV is set, the numeric form of the service address is returned (e.g., its port number) instead of its name.
The two NI NUMERICxxx flags are required to support the " n" flag that many commands provide.
A fifth flag bit, NI DGRAM, specifies that the service is a datagram service, and causes getservbyport() to be called with a second argument of "udp" instead of its default of "tcp".
This is required for the few ports (e.g. 512 514) that have different services for UDP and TCP.
These NI xxx flags are defined in <netdb.h> along with the AI xxx flags already defined for getaddrinfo().
The two functions inet addr() and inet ntoa() convert an IPv4 address between binary and text form.
IPv6 applications need similar functions.
The following two functions convert both IPv6 and IPv4 addresses:
src, char  dst, size t size);
The inet pton() function converts an address in its standard text presentation form into its numeric binary form.
The af argument specifies the family of the address.
Currently the AF INET and AF INET6 address families are supported.
The src argument points to the string being passed in.
The dst argument points to a buffer into which the function stores the numeric address.
The address is returned in network byte order.
Inet pton() returns 1 if the conversion succeeds, 0 if the input is not a valid IPv4 dotted  decimal string or a valid IPv6 address string, or  1 with errno set to EAFNOSUPPORT if the af argument is unknown.
The calling application must ensure that the buffer referred to by dst is large enough to hold the numeric address (e.g., 4 bytes for AF INET or 16 bytes for AF INET6).
If the af argument is AF INET, the function accepts a string in the standard IPv4 dotted decimal form: ddd.ddd.ddd.ddd where ddd is a one to three digit decimal number between 0 and 255.
Note that many implementations of the existing inet addr() and inet aton() functions accept nonstandard input: octal numbers, hexadecimal numbers, and fewer than four numbers.
inet pton() does not accept these formats.
If the af argument is AF INET6, then the function accepts a string in one of the standard IPv6 text forms defined in Section 2.2 of the addressing architecture specification [2].
The inet ntop() function converts a numeric address into a text string suitable for presentation.
The af argument specifies the family of the address.
This can be AF INET or AF INET6.
The src argument points to a buffer holding an IPv4 address if the af argument is AF INET, or an IPv6 address if the af argument is AF INET6
, the address must be in network byte order.
The dst argument points to a buffer where the function will store the resulting text string.
The size argument specifies the size of this buffer.
The application must specify a non NULL dst argument.
For IPv6 addresses, the buffer must be at least 46 octets.
For IPv4 addresses, the buffer must be at least 16 octets.
In order to allow applications to easily declare buffers of the proper size to store IPv4 and IPv6 addresses in string form, the following two constants are defined in <netinet/in.h>:
The inet ntop() function returns a pointer to the buffer containing the text string if the conversion succeeds, and NULL otherwise.
Upon failure, errno is set to EAFNOSUPPORT if the af argument is invalid or ENOSPC if the size of the result buffer is inadequate.
The following macros can be used to test for special IPv6 addresses.
The last five test the scope of a multicast address and return true if the address is a multicast address of the specified scope or false if the address is either not a multicast address or not of the specified scope.
Note that IN6 IS ADDR LINKLOCAL and IN6
IS ADDR SITELOCAL return true only for the two local use IPv6 unicast addresses.
These two macros do not return true for IPv6 multicast addresses of either link local scope or site local scope.
The following list summarizes the constants, structure, and extern definitions discussed in this memo, sorted by header.
INIT <netinet/in.h>  IN6ADDR LOOPBACK INIT <netinet/in.h
IPV6 JOIN GROUP <netinet/in.h>  IPV6 LEAVE GROUP <netinet/in.h>
IPV6 MULTICAST HOPS <netinet/in.h>  IPV6 MULTICAST IF <netinet/in.h>
extern const struct in6 addr in6addr
extern const struct in6 addr in6addr
struct sockaddr storage; The following list summarizes the function and macro prototypes discussed in this memo, sorted by header.
int IN6 IS ADDR LOOPBACK(const
int IN6 IS ADDR MC
int IN6 IS ADDR MC SITELOCAL(const
int IN6 IS ADDR UNSPECIFIED(const
int IN6 IS ADDR V4COMPAT(const struct
ADDR V4MAPPED(const struct in6 addr  );
Security Considerations IPv6 provides a number of new security mechanisms, many of which need to be accessible to applications.
Companion memos detailing the extensions to the socket interfaces to support IPv6 security are being written.
There are no issues for this memo concerning the Year 2000 issue regarding the use of dates.
Changes From RFC 2133 Changes made in the March 1998 Edition ( 01 draft): Changed all "hostname" to "nodename" for consistency with other IPv6 documents.
Section 3.3: changed comment for sin6 flowinfo to be "traffic class & flow info" and updated corresponding text description to current definition of these two fields.
Section 3.10 ("Portability Additions") is new.
a new paragraph was added reiterating that the existing gethostbyname() and gethostbyaddr() are not changed.
Section 6.1: change gethostbyname3() to getnodebyname().
Add AI DEFAULT to handle majority of applications.
Renamed AI V6ADDRCONFIG to AI ADDRCONFIG and define it for A records and IPv4 addresses too.
Defined exactly what getnodebyname() must return if the name argument is a numeric address string.
Section 6.2: change gethostbyaddr() to getnodebyaddr().
Reword items 2 and 3 in the description of how to handle IPv4 mapped and IPv4  compatible addresses to "lookup a name" for a given address, instead of specifying what type of DNS query to issue.
Section 6.3: added two more requirements to getaddrinfo().
Section 7: added the following constants to the list for <
netdb.h>:  AI ADDRCONFIG, AI ALL, and AI V4MAPPED.
Add union sockaddr union and SA LEN to the lists for <
Changes made in the November 1997 Edition ( 00 draft): The data types have been changed to conform with Draft 6.6 of the Posix 1003.1g standard.
Section 3.2: data type of s6 addr changed to "uint8 t".
Section 3.3: data type of sin6 family changed to "sa family t".
data type of sin6 port changed to "in port t", data type of sin6 flowinfo changed to "uint32 t".
Section 3.4: same as Section 3.3, plus data type of sin6 len changed to "uint8 t".
Section 6.2: first argument of gethostbyaddr() changed from "const char  " to "const void  " and second argument changed from "int" to "size t".
Section 6.4: second argument of getnameinfo() changed from "size t" to "socklen t".
NET RT LIST changed to NET RT IFLIST.
The IPV6 ADDRFORM socket option was removed.
Section 5.3: Added a note that an option value other than 0 or 1 for IPV6 MULTICAST LOOP returns an error.
Added a note that IPV6 MULTICAST IF, IPV6 MULTICAST HOPS, and IPV6 MULTICAST LOOP can also be used with getsockopt(), but IPV6 ADD MEMBERSHIP and IPV6 DROP MEMBERSHIP cannot be used with getsockopt().
Section 6.1: Removed the description of gethostbyname2() and its associated RES USE INET6 option, replacing it with gethostbyname3().
Added requirement that gethostbyaddr() be thread safe.
Reworded step 4 to avoid using the RES USE INET6 option.
Section 6.3: Added the requirement that getaddrinfo() and getnameinfo() be thread safe.
Added the AI NUMERICHOST flag.
Section 6.6: Added clarification about IN6 IS ADDR LINKLOCAL and IN6 IS ADDR SITELOCAL macros.
Changes made to the draft  01 specification Sept 98 Changed priority to traffic class in the spec.
Added the need for scope identification in section 2.1.
id to struct sockaddr in6 in sections 3.3 and 3.4.
Changed 3.10 to use generic storage structure to support holding IPv6 addresses and removed the SA LEN macro.
Distinguished between invalid input parameters and system failures for Interface Identification in Section 4.1 and 4.2.
Added defaults for multicast operations in section 5.2 and changed the names from ADD to JOIN and DROP to LEAVE to be consistent with IPv6 multicast terminology.
Changed getnodebyname to getipnodebyname, getnodebyaddr to getipnodebyaddr, and added MT safe error code to function parameters in section 6.
Moved freehostent to its own sub section after getipnodebyaddr now 6.3 (so this bumps all remaining sections in section 6.
Clarified the use of AI ALL and AI V4MAPPED that these are dependent on the AF parameter and must be used as a conjunction in section 6.1.
Removed the restriction that literal addresses cannot be used with a flags argument in section 6.1.
Added Year 2000 Section to the draft Deleted Reference to the following because the attached is deleted from the ID directory and has expired.
But the logic from the aforementioned draft still applies, so that was kept in Section 6.2 bullets after 3rd paragraph.
[7]  P. Vixie, "Reverse Name Lookups of Encapsulated IPv4 Addresses in IPv6", Internet Draft, <draft vixie
Deleted the following reference as it is no longer referenced.
And the draft has expired.
[3]  D. McDonald, "A Simple IP Security API Extension to BSD Sockets", Internet Draft, <draft mcdonald simple ipsec api
Deleted the following reference as it is no longer referenced.
[4]  C. Metz, "Network Security API for Sockets", Internet Draft, <draft metz net security api
Update current references to current status.
Added alignment notes for in6 addr and sin6 addr.
Clarified further that AI V4MAPPED must be used with a dotted IPv4 literal address for getipnodebyname(), when address family is AF INET6.
and "::1" when used by getipnodebyaddr().
