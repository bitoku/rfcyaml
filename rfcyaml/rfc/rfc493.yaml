- title: __initial_text__
  contents:
  - "                           GRAPHICS PROTOCOL\nIntroduction\n   This document\
    \ reflects opinions expressed and decisions reached at\n   the second meeting\
    \ of the Network Graphics Group, held at the\n   Stanford Artificial Intelligence\
    \ Laboratory in late November 1971.\n   It describes part of a proposed Network\
    \ Standard Graphics Protocol\n   for transmitting graphics data within the ARPA\
    \ network.  The\n   particular aspects of the protocol covered in this document\
    \ relate to\n   the form and content of graphics information sent from a source\
    \ of\n   graphical information (an application program, say, in the \"Serving\n\
    \   Host\") to a display package for output to a graphics console (at the\n  \
    \ \"Using Host\").  This will take the form of a sequence of 8-bit bytes,\n  \
    \ and will be called the graphics output byte stream.\n   This document is intended\
    \ to serve as a basis for discussion and for\n   experimentation over the network.\
    \  This document does not include\n   form or content of graphics input (data\
    \ sent from the Using Host to\n   the Serving Host) nor does it cover how the\
    \ connection is established\n   between the hosts.  A proposal for the former\
    \ will be generated\n   eventually by this committee; the latter is the job of\
    \ the Connection\n   Committee (of the Network Graphics Group).\n   This RFC describes\
    \ the commands which are available in the protocol\n   in terms of the effect\
    \ they would have at the receiving (Using Host)\n   end.  Clearly, some subroutine\
    \ package is desirable at the Serving\n   Host for use by applications in transmitting\
    \ graphics data, but on\n   this topic this RFC does not intend to comment.\n\
    \   It may be observed by the reader that no facility is specified in\n   this\
    \ protocol allowing the Using Host to report logical errors in the\n   graphics\
    \ output byte stream to the Serving Host.  Such a facility\n   would have to be\
    \ integrated with the graphics input byte stream,\n   since it involves most of\
    \ the problems related to synchrony of\n   independent hosts.\nBackground\n  \
    \ The reader should probably peruse RFC 282: \"Graphics Meeting Report\"\n   by\
    \ Mike Padlipsky to obtain some of the framework surrounding this\n   discussion\
    \ of network graphics.  Also it might be valuable to make\n   note of the model\
    \ described in RFC 285: \"Network Graphics\" by Donald\n   Huff.\nLevels and Ground\
    \ Rules Pertaining Thereto\n   Functions within the graphics protocol will be\
    \ classified into a\n   number of levels depending partly on how difficult it\
    \ is to implement\n   those functions.  It is intended that any host which claims\
    \ to\n   implement the functions of level N must implement all lower levels as\n\
    \   well.  Thus, it is envisioned that sites will implement levels\n   inclemently.\
    \  Implementations will be improved as a continuing\n   process to include more\
    \ and more functions, and it is intended that\n   each implementation will be\
    \ able to identify its own level to a\n   graphics protocol at a remote site which\
    \ is requesting a graphics\n   interchange.  A side result is that each site will\
    \ be able to\n   determine its own priorities in committing programmers to the\n\
    \   graphics protocol as opposed to other efforts.\n   It is also our intention\
    \ that implementation of level N will require\n   no knowledge of level N+1. \
    \ Thus a site can implement a level in the\n   (reasonably) firm knowledge that\
    \ no changes at higher levels will\n   alter the level implemented.  At some time\
    \ it may be decided by the\n   Network Graphics Group to redefine a level which\
    \ has previously been\n   firmed up.  It is not our intention that this shall\
    \ happen but one\n   must recognize that the proposed Graphics Protocol is experimental\n\
    \   and may have to be changed.\n   One further ground rule: a stream of commands\
    \ and data which is valid\n   at a given level, K, shall produce \"identical\"\
    \ results on any\n   interpreter of level K or higher.  By this we mean that as\
    \ long as\n   the commands and data take advantage only of strictly defined\n\
    \   operations, similar pictures should result.  Aspects of the protocol\n   which\
    \ are not strictly defined (at this time) include character size,\n   character\
    \ position relative to the beam, how control characters in\n   text output affect\
    \ the terminal and what happens when the beam is\n   moved or a line drawn outside\
    \ of the logical screen boundary.  This\n   rule forces upwards compatibility,\
    \ so that an application written\n   using features of a low numbered level will\
    \ still work at sites which\n   have moved on to implement higher levels.  Additionally,\
    \ any aspects\n   of this protocol which are explicitly \"left unspecified\" in\
    \ the\n   detailed operations descriptions below shall be explicitly specified\n\
    \   in any public description of an actual implementation.\n   We now describe\
    \ the framework which will be common to all levels.\nBasic Data Forms\n   Information\
    \ in the Network Standard Graphics Protocol will be\n   expressed as a sequence\
    \ of 8-bit bytes.  A command will consist of a\n   command byte followed by zero\
    \ or more arguments.  The same command\n   byte will always take the same number\
    \ of arguments in the same form.\n   The length of each argument may be fixed\
    \ or variable depending on the\n   argument.\n   A simple type of argument is\
    \ a \"value\", which is a 8-bit integer.\n   Another type of argument is a \"\
    string\" which is a count followed by\n   (count) number of 8-bit bytes.  If the\
    \ count is between 0 and 127, it\n   is sent in a single byte.  If the count is\
    \ between 128 and 2**15-1\n   (**means exponentiation), it is sent in two bytes\
    \ with the high order\n   bit of the first byte set to one.  The first byte contains\
    \ the seven\n   high order bits of the number and the second byte contains the\
    \ eight\n   low order bits.  A string is the only type of argument of a command\n\
    \   which can vary in length.  For example, whenever a command has\n   optional\
    \ arguments, they will be represented inside of a string.\n   Coordinate data\
    \ engendered considerable discussion at the second\n   Network Graphics Group\
    \ meeting.  It was decided that a two-\n   dimensional Logical Coordinate System\
    \ was required, and each\n   interpreter for the graphic command byte stream would\
    \ be responsible\n   for mapping this coordinate system to physical device coordinates.\n\
    \   It was decided that data in the logical coordinate system would be in\n  \
    \ twos-complement notation, that it would be fractional, that each edge\n   of\
    \ the screen would have unit length, and that the origin would\n   correspond\
    \ to the center of the screen on the output device.  The\n   vertical (horizontal)\
    \ edges of the screen of the output device\n   correspond to the lines X (Y) =\
    \ -1/2 or X=+1/2-e where e is a small\n   positive number determined by the precision\
    \ of the fractional data.\n   Particularly the points (-1/2, -1/2) (-1/2, 1/2-e),\
    \ (1/2-e, -1/2) and\n   (1/2-e, 1/2-e) shall be visible points at the corners\
    \ of the logical\n   screen. (In the case of a non-square display surface, the\
    \ implementer\n   may take his own decision.  Thus we shall say that the Logical\n\
    \   Coordinate System contains points whose coordinates range from -1/2\n   to\
    \ a little less than +1/2.\n   Commands which take coordinate data will be available\
    \ in various\n   modes.  In absolute mode, a position is specified by giving its\n\
    \   coordinates in the Logical Coordinate System.  In relative mode, the\n   difference\
    \ between the coordinates of the position and the\n   coordinates of the current\
    \ position must be specified.  Thus a\n   coordinate datum which is an argument\
    \ for an absolute mode operation\n   should be in the range -1/2 to +1/2-e, while\
    \ one for a relative mode\n   operation should be in the range -1+e to +1-e.\n\
    \   Interest was expressed at the second Graphics Group Meeting in\n   eventually\
    \ allowing a very large coordinate space (many bits of\n   precision in each fractional\
    \ coordinate).  This is to be done by\n   permitting the length, in 8-bit bytes,\
    \ of each coordinate datum to be\n   set (as a mode).  It was decided at the meeting\
    \ that two bytes per\n   coordinate would suffice for now.  Thus \"e\" in the\
    \ above discussion\n   is 2**(-15) (one in the least significant bit of a 15-bit\
    \ plus sign\n   fractional coordinate).\n   Text data will be transmitted as an\
    \ argument of various commands for\n   display on the output device.  Network\
    \ ASCII will be used to\n   represent characters.  At the lowest-levels of the\
    \ protocol only one\n   character size will be available -- whatever is \"normal\"\
    \ on the\n   display device.  If the device has no \"normal\" size, 72 characters\n\
    \   per line would be desirable.  At higher levels the size of each\n   individual\
    \ character can be specified.\n   Also, at the lowest levels, control characters\
    \ will be passed along\n   to the device for it to do the best it can.  However,\
    \ the consensus\n   of the graphics meeting was that at some reasonably low (but\
    \ non-\n   zero) level, carriage return, line feed, and backspace should be\n\
    \   interpreted to do the right thing.\nPicture Subroutines and Related Topics\n\
    \   At the second Network Graphics Group meeting, it was decided that two\n  \
    \ sorts of picture subroutines were desirable, the primary distinction\n   between\
    \ them being relative difficulty of implementation.  At the\n   meeting, the simpler\
    \ variety was called a subpicture, and the more\n   complex was called a subroutine.\
    \  This author believes that these\n   terms do not embody enough semantics to\
    \ facilitate keeping the two\n   straight and so proposes to standardize on \"\
    simple subroutine\" and\n   \"full subpicture\" instead.\n   The only parameter\
    \ which can be passed to a simple subpicture is the\n   \"current beam position\"\
    .  In other words, if such a subpicture is\n   called more than once in a picture,\
    \ the only difference in appearance\n   between the various calls is a translation\
    \ due to the beam position\n   at the time of the call.  Full subpictures, on\
    \ the other hand, take\n   parameters which can cause scaling, rotation, reflection,\
    \ or anything\n   else we come up with.\n   It is planned that a subpicture definition\
    \ need be transmitted only\n   once (per network connection) and would not be\
    \ deleted by a \"new\n   picture\" operation.  Thus a changing picture could be\
    \ subdivided into\n   several parts on a basis of static versus changing information;\
    \ only\n   definitions of parts which change need be transmitted to redraw the\n\
    \   picture.\n   Traditionally, picture subroutines which depend only on the initial\n\
    \   beam position have been restricted to relative data mode drawing\n   operations.\
    \  In view of the fact that subpictures will probably be\n   used to save static\
    \ picture information, it is desirable to allow\n   absolute data mode operations\
    \ in simple subpictures.\n   The next question naturally arises -- what does absolute\
    \ data mean in\n   a full subpicture which takes both position and scale parameters?\
    \ Is\n   absolute data really absolute in this case? This author believes that\n\
    \   the answer is as follows: the full subpicture is really a picture in\n   its\
    \ own right, so it has its own logical coordinate system, and its\n   absolute\
    \ data is really within this coordinate system.  Thus\n   \"shifting and scaling\"\
    \ a full subpicture really means \"scale the\n   subpicture in its own coordinate\
    \ system and shift the result as a\n   whole\".\n   In summary, then, a major\
    \ difference between simple and full\n   subpictures is that a full subpicture\
    \ has its own logical coordinate\n   system and a simple subpicture uses the logical\
    \ coordinate system of\n   whoever calls it.  This distinction is the reason why\
    \ full\n   subpictures are harder to implement than simple subpictures.\n   Another\
    \ point discussed at the meeting was a special data mode\n   whereby a subpicture\
    \ can display data at absolute positions on the\n   screen, i.e., absolutely in\
    \ the main (picture) program.  To achieve\n   this, the meeting proposed special\
    \ data modes for the three\n   operations: move beam invisibly, draw line, and\
    \ display dot.  The\n   intent of these data modes was to bypass all rotation,\
    \ scaling, and\n   clipping functions associated with the current level of subpicture\n\
    \   nesting until this mode was cleared in a certain way.  This same\n   effect\
    \ can be achieved more directly and implemented more efficiently\n   by two commands:\
    \ one to save and one to re-establish the logical\n   coordinate system for the\
    \ current subpicture. (Additionally, of\n   course, the \"save\" operation would\
    \ establish the initial, highest\n   level, logical coordinate system.)\nSimple\
    \ Subpicture Calls\n   Besides the <identifier> of the subpicture to be called,\
    \ a simple\n   subpicture call may specify two optional parameters; the first\
    \ is an\n   <identifier> which is the \"name\" (in a sense described below) of\
    \ this\n   particular subpicture call and the second is an absolute position on\n\
    \   the calling page to be invisibly moved to, prior to calling the\n   subpicture.\
    \  When (eventually) the viewer is allowed to interact by\n   \"picking\" information\
    \ displayed before him, if the information is\n   part of a subpicture, then the\
    \ \"name\" of the subpicture call will be\n   part of the \"graphic input\" reported\
    \ to the serving host.  If the\n   information picked by the viewer is within\
    \ several levels of\n   subpicture calls, the names of each of the calls will\
    \ be reported in\n   a manner which indicates their nesting. (Note that just the\
    \ name of\n   the subpicture by itself is not sufficient, since one subpicture\
    \ may\n   be displayed in several positions and the application may wish to\n\
    \   distinguish between individual calls.) If the identifier is not\n   specified\
    \ it defaults to the null string.  If the position (for the\n   invisible move)\
    \ is not specified, the current beam position is used.\n   Which of these two\
    \ parameters are present is encoded by two bits in a\n   code byte which precedes\
    \ the parameters.  If both parameters are\n   present then they are always in\
    \ the same order; this order and the\n   bits of the code byte assigned to the\
    \ two parameters are specified in\n   the detailed description of the Simple Instance\
    \ command (and in the\n   BNF in Appendix 1).  Preceding even the code byte, and\
    \ immediately\n   following the name of the subpicture which is being called upon,\
    \ is a\n   count of the data in the remainder of the instance command.  Thus is\n\
    \   included so that it is not necessary to decode the code byte to\n   determine\
    \ the total length of any one Simple Instance operation.\nWindowing: Clipping,\
    \ Blanking, or (?)\n   While on the subject of coordinate systems and subpictures,\
    \ it might\n   be good to touch on the topic of: who (which end of the connection)\n\
    \   is responsible for doing what, when a picture is potentially going to\n  \
    \ be displayed beyond the edge of the virtual screen? It was the\n   consensus\
    \ at the graphics meeting that the interpreter of the\n   graphics protocol (i.e.,\
    \ the using end) would not be held responsible\n   for doing anything reasonable\
    \ in case a picture displays information\n   beyond the edge of the screen (e.g.,\
    \ by relative moves and draws).\n   The interpreter must react properly to the\
    \ next absolute data in the\n   proper range, however.  Various solutions to this\
    \ situation in\n   existing graphics systems include:\n      clipping a line to\
    \ display as much as is proper,\n      blanking the whole of a line if any part\
    \ is invisible, or\n      discarding high order bits of the current position register,\
    \ so\n      that no invisible positions can be represented (\"wraparound\").\n\
    \   In addition to problems of the edge effects at the highest level,\n   problems\
    \ arise with respect to (full) subpictures.  It is nice to be\n   able to select\
    \ a rectangular portion of a subpicture to be displayed\n   as part of a subpicture\
    \ call. (See: Newman, Display procedures,\n   Communications of the ACM, Volume\
    \ 14, Number 10, October 1971,\n   pp651-660).  In accordance with the consensus\
    \ of the meeting, which\n   was to make this capability optional, this author\
    \ merely hopes to\n   include in the protocol a method of encoding this information\
    \ since\n   his site a) can handle some such windowing, and b) hopes to provide\
    \ a\n   service facility to perform this function.\n   Appendix 2 describes how\
    \ to concatenate several levels of portions\n   into a single rectangular test,\
    \ as long as no rotations are involved.\n   It also outlines the problems related\
    \ to rotations and portioning.\nFull Subpicture Calls\n   We are now in position\
    \ to consider what may be specified as part of a\n   full subpicture call, in\
    \ addition to the name of the subpicture being\n   called, which is, of course,\
    \ required.  The data described below will\n   all be optional: a single code\
    \ byte will precede all these data; the\n   presence or absence of one of the\
    \ parameters will be indicated by a\n   bit in the code byte being one or zero.\
    \  The parameters will always\n   appear in the same order, if they are present.\
    \  This order is given\n   below in the detailed description of the Full Instance\
    \ command (and\n   in the BNF in Appendix 1).  Additionally, preceding even the\
    \ code\n   byte, will be a <count> of the following bytes, including the code\n\
    \   byte to determine the total length of any particular Full Instance\n   operation.\n\
    \   One parameter is an <identifier> which can be used to distinguish\n   this\
    \ particular call to this subpicture from all other calls to the\n   subpicture.\
    \  This parameter was already described under Simple\n   Subpicture Calls.\n \
    \  On parameter which may be specified is a translation: this will be\n   specified\
    \ by giving the absolute coordinates of the center (on the\n   calling page) of\
    \ the image of the subpicture; this will default to\n   the beam position current\
    \ at the time of the call.\n   A rotation may be specified by giving a 16-bit\
    \ fraction in the range\n   0 to .1111111111111111 (binary) inclusive; this fraction\
    \ will\n   represent what part of a full circle (2pi) the rotation is.  The\n\
    \   default value of angle of rotation will be zero.\n   (Actually, the rotation\
    \ representation scheme works identically if\n   one thinks of it as a two's complement\
    \ fraction from -1/2 to just\n   less than +1/2.  That is, the same bit configurations\
    \ encode the same\n   rotation, due to the periodic nature of sine and cosine.\
    \  For\n   example, binary zero always represents 0 pi 010000...0 denotes pi/2\n\
    \   in both schemes; 100...00 denotes 1/2 in one scheme and -1/2 in the\n   other,\
    \ which correspond to rotations of +pi and -pi respectively,\n   i.e. identical\
    \ rotations.)\n   Also specifiable as apart of a full subpicture call is a rectangular\n\
    \   portion of the called picture to be imaged on the calling picture\n   (see\
    \ previous section for a discussion of clipping).  This rectangle\n   is specified\
    \ by its center and one half its total size in x and y.\n   That is, the rectangle\
    \ will consist of all points whose x coordinate\n   differs from that of the center\
    \ by no more than the specified x-size\n   and whose y coordinate satisfies a\
    \ similar condition.  The default\n   for these values will place the center at\
    \ the origin and give both\n   the x half width and the y half width the value\
    \ of +1/2.  Thus the\n   default includes the whole of the logical coordinate\
    \ system of the\n   called page (and also some points one of whose coordinates\
    \ are +1/2,\n   which, strictly speaking, lie \"outside\" of the coordinate system;\
    \ how\n   this inconsistency is resolved is left unspecified).\n   Finally, one\
    \ must specify the scaling to be applied in determining\n   the image; this can\
    \ be done in many ways.  One way is to specify a\n   uniform magnification to\
    \ be applied to the subpicture.  So that\n   magnifications in a wide range can\
    \ be achieved, it is the author's\n   opinion that some form of scientific notation\
    \ (i.e., floating point)\n   will have to be employed.  If there is already a\
    \ network standard\n   floating point notation (which I am not aware of) it should\
    \ be\n   employed.  Failing that, it is suggested that this notation consist\n\
    \   of an 8-bit (two's complement) exponent followed by a 16-bit (two's\n   complement)\
    \ fractional part.\n   Another form of scaling is to specify separate magnifications\
    \ in x\n   and in y, to be applied to the subpicture before any rotation is\n\
    \   performed.  Yet a third way is to specify a rectangular area in the\n   calling\
    \ picture's coordinate system to be filled with the image of\n   the subpicture.\
    \  Since the center of the image is already specified\n   (by the translation),\
    \ this image information consists only of half-\n   edge size data.  If none of\
    \ the three methods of scaling are chosen\n   (and an affine transformation (see\
    \ below) is not given explicitly),\n   then a uniform magnification of unity (i.e.,\
    \ no scaling) is used.\n   Note that the three forms of scaling tend to contradict\
    \ each other\n   and only one of them should be used in any one call.  What happens\
    \ if\n   self-contradictory information is given in these fields is left\n   unspecified.\n\
    \   Appendix 2 presents the mathematics involved in transforming the\n   subpicture's\
    \ coordinate system into the calling picture's coordinate\n   system.  It is shown\
    \ there that all the individual operations\n   (scaling, rotating, and translating)\
    \ can be represented as a single\n   affine transformation (which consists of\
    \ 6 values).  It might be nice\n   to permit the serving program to specify this\
    \ transformation\n   directly.  Accordingly, one possible parameter of a full\
    \ subpicture\n   call will consist of six floating point numbers (of the form\n\
    \   described under magnification, above) to be interpreted as an affine\n   transformation.\
    \  Indeed, if the affine transformation has the\n   following form:\n   /_ |x\
    \  |y_/ = /_ x y_/ * / L11 L12  / + /_ T1 T2_/\n                           /_\
    \ L21 L22 _/\n   then the values shall (arbitrarily) be sent in the following\n\
    \   (columnar) order: L11, L21, L12, L22, T1, T2.  This affine\n   transformation\
    \ should be invertible that is, L11*L22 - L21*L12 should\n   not be zero.\nViewporting\n\
    \   Another topic discussed at the meeting, and referred to the protocol\n   committee\
    \ for decision, was the capability of placing the \"top level\"\n   picture in\
    \ some rectangle of the virtual screen.  The default\n   rectangle might be the\
    \ full screen.  Alternatively it might be left\n   up to the viewer to specify\
    \ the default (via) interaction with the\n   graphics system at the Using Host).\
    \  In general, viewporting allows\n   more than one \"top level\" picture to be\
    \ viewed at once.  The desire\n   to view several different pictures on the same\
    \ screen arises in cases\n   where multiple users are working together and in\
    \ cases where one user\n   is interacting with a group of applications (in separate\
    \ serving\n   hosts).  This author maintains that the coordinate transformations\n\
    \   required by this feature are simpler than that of \"full subpictures\"\n \
    \  since no rotations are involved, and would be part of the same\n   mechanism\
    \ in its implementation.  In particular, merely another\n   affine transformation\
    \ (see Appendix 2) would be added to the levels\n   caused by full subpicture\
    \ calls.  All that is required is keeping\n   track of viewport identifiers and\
    \ the associated rectangles.  Since\n   little extra work is involved, it is proposed\
    \ that this feature be\n   included at some high level of the protocol.\nCommand\
    \ Codes\n   Each command in the graphics protocol will be assigned a non-negative\n\
    \   value which will represent this command in the byte stream.  The\n   algorithm\
    \ whereby values and commands are associated is, it turns\n   out, a very touchy\
    \ subject.  There are five or ten different criteria\n   for a \"best\" algorithm,\
    \ each criterion different in emphasis.  This\n   Gordian knot will be cut, in\
    \ this proposal, by ordering the commands\n   approximately according to level,\
    \ and then just numbering them.  In\n   addition, if several closely related commands\
    \ occur at the same\n   level, some attempt will be made to encode variations\
    \ of meanings in\n   terms of bit configurations.  Even if some later consideration\
    \ causes\n   a change in ordering to be proposed, it is this committee's feeling\n\
    \   that the numbering should not be altered.  However, until this matter\n  \
    \ is firmly settled, it is strongly advised that any implementation\n   take into\
    \ account the possibility of reassignment of command codes.\nParticular Proposal\
    \ for Level 0 Protocol\n   It is proposed that level 0 be kept very simple.  This\
    \ is so that\n   implementation can be quickly accomplished and experimentation\
    \ with\n   the protocol begun.  Another reason is that the least powerful host\n\
    \   and even programmable terminals should be able to implement it.  In\n   accordance\
    \ with this, the \"rule\" was made that a command be included\n   only if its\
    \ output is a function solely of the current command and\n   the \"beam position\"\
    \ current at the start of the command.  In other\n   words, the interpreter for\
    \ level 0 need have no internal storage for\n   \"modes\" or pushdown stacks.\
    \  With this restriction it is hoped that a\n   very simple implementation will\
    \ be possible for level 0.  In\n   particular, perhaps one could eventually build\
    \ a hardware translator\n   from level 0 code to one's own particular terminal's\
    \ code.\n   Note that in the opcode assignment for level 0, bits 4, 2, and 1 have\n\
    \   special meaning for the move, line, and dot commands.  In particular,\n  \
    \ the 1 bit encodes absolute versus relative data mode, the 4 bit\n   encodes\
    \ whether any visible output occurs, and the 2 bit determines\n   whether the\
    \ visible output is a line or a dot.\nLevel 0: Command Summary\n   The following\
    \ is a list of commands (and their syntax) in level zero.\n   Detailed descriptions\
    \ of these commands follow in the next section.\n   Commands dealing with protocol\
    \ may be added by the Connection\n   Committee. (They currently request opcodes\
    \ in the range 128 to 255.)\n   (As described in Basic Data Forms, above, <x coordinate>,\
    \ <y\n   coordinate>, <x delta> and <y delta> are two-byte coordinate values,\n\
    \   <string> is a count followed by <count> many bytes and <value> is an\n   eight\
    \ bit number.)\nDecimal  Octal   Binary    Format\n0        0       00000000 \
    \ Null\n1        1       00000001  Erase screen and reset beam\n2        2   \
    \    00000010  Move Absolute <x coordinate> <y coordinate>\n3        3       00000011\
    \  Move Relative <x delta> <y delta>\n4        4       00000100  Draw Absolute\
    \ <x coordinate> <y coordinate>\n5        5       00000101  Draw Relative <x delta>\
    \ <y delta>\n6        6       00000110  Dot Absolute <x coordinate> <y coordinate>\n\
    7        7       00000111  Dot relative <x delta> <y delta>\n8        10     \
    \ 00001000  Text <string>\n9        11      00001001  TextR <string>\n10     \
    \  12      00001010  End of Picture\n11       13      00001011  Escape <value>\
    \ <string>\nLevel 0: Command Descriptions\n0       Null Statement (\"NULL\").\n\
    This statement has no arguments--and no effect, either.\n1       Erase screen\
    \ and reset beam to origin (\"ERASE\").\nThis command indicates that a new picture\
    \ is about to be drawn.  It\nshould always be (eventually) paired with a following\
    \ End of Picture\ncommand.\n2       Move beam invisibly to absolute position\n\
    (\"MOVEA\") <x coordinate> <y coordinate>.\nNothing is drawn; the beam is positioned\
    \ to the specified absolute x,y\nposition.\n3       Move beam invisibly by relative\
    \ amount\n(\"MOVER\") <x coordinate> <y coordinate>.\nNothing is drawn; the beam\
    \ is shifted by the specified amount in x and\ny.\n4       Draw line to absolute\
    \ position\n(\"DRAWA\") <x coordinate> <y coordinate>.\nA line is drawn from the\
    \ current beam position to the specified absolute\nx,y position.\n5       Draw\
    \ line to relative position\n(\"DRAWR\") <x delta> <y delta>.\nA line is drawn\
    \ from the current beam position to the position delta x\nand delta y away.\n\
    6       Display a Dot at absolute position\n(\"DOTA\") <x coordinate> <y coordinate>.\n\
    The beam is moved invisibly to absolute position x,y and a dot is\ndisplayed there.\n\
    7       Display a Dot at relative position\n(\"DOTR\") <x delta> <y delta>.\n\
    The beam is moved invisibly by the specified amount in x and y and a dot\nis displayed\
    \ there.\n8       Display text (\"TEXT\") <string>.\nAt the current beam position,\
    \ display some characters at the normal size\nfor the device being operated. <string>\
    \ consists of a <count> followed\nby count many characters.  If there is no \"\
    normal size\", choose the size\nso that seventy-two characters are displayed per\
    \ line. The characters in\nthe string are coded in network ASCII all codes between\
    \ 0 and 127\n(decimal) inclusive are permitted. (At level zero, what happens to\n\
    control characters is left unspecified.) Where the beam is, following\nexecution\
    \ of this command, is left unspecified, except that another\nDisplay Text command\
    \ immediately following will append its text to the\nprevious string. (The use\
    \ of the TEXT command is discouraged; use TextR\ninstead.) The position of the\
    \ first character relative to the initial\nbeam position is left unspecified.\n\
    9       Display text and restore beam (\"TEXTR\") <string>.\nAt the current beam\
    \ position, display a string of characters at the\nnormal size for the device\
    \ being operated; then reposition the beam to\nwhere it was before the command.\
    \ <string> consists of a <count> followed\nby count many characters. If there\
    \ is no \"normal size\", choose the size\nso that seventy-two characters are displayed\
    \ per line. The characters in\nthe string are coded in network ASCII; all codes\
    \ between 0 and 127\n(decimal) inclusive are permitted. (At level zero, what happens\
    \ to\ncontrol characters is left unspecified.) The position of the first\ncharacter\
    \ relative to the initial beam position is left unspecified.\n10      End of Picture\
    \ (\"ENDPIC\").\nThis command denotes the end of a new picture. It must be paired\
    \ with a\npreceding ERASE command.\n11      Escape to device specifics (\"ESCDEV\"\
    ) <value> <string>.\nIf \"value\" is the code assigned (by the Protocol Committee)\
    \ to the\ndevice being operated, then transmit the eight-bit bytes in <string>\n\
    (which starts with a <count> indicating the number of bytes) to the\ndevice without\
    \ examining them. Otherwise ignore this command. If the\ndevice does not accept\
    \ 8-bit information, reformat the data in some\ndevice specific way; an example\
    \ would be throwing away the high order\nbit for a seven bit device, or gathering\
    \ 5 8-bit bytes into one 36-bit\nword, again discarding the high order bits, perhaps.\
    \ The action of the\nbytes in the string should leave alone (or at least restore)\
    \ any\nhardware beam position registers in the device which the interpreter\n\
    might conceivably depend on.\nThis command really should not be used it was included\
    \ at level 0 so\nthat specific applications can do mode setting and other device\
    \ specific\nmanipulations. For example, ARDS terminals may optionally have several\n\
    independently addressable output scopes. The selection mechanism changes\nstate\
    \ only when a particular sequence of ASCII characters reaches the\nterminal. Thus\
    \ ESCDEV would be used to select which scope(s) is/are to\nbe affected by following\
    \ commands. (The current state is invisible to\nthe graphics package at the Using\
    \ Host.)\nFurther, suppose that another make of terminal has a similar option,\n\
    which responds to a different code sequence. This possibility is the\nmotivation\
    \ for conditionally ignoring the ESCDEV command based on the\n\"<value>\" specified.\
    \ Given that a particular application will only be\nused to output to either an\
    \ ARDS or this second make (with the multiple\nscope option), then the application\
    \ could always send two ESCDEV\ncommands, one applicable only to ARDS terminals,\
    \ and the other\napplicable only to the second make.\nLEVEL 1\n   *Set Line mode\
    \ (\"LINMOD\") <value>.\n   This command sets the current line mode possible modes\
    \ and the\n   <value> which sets each are: solid (0), dashed (1), dotted (2),\
    \ and\n   others (3 or >). At the beginning of a new picture (i.e., after an\n\
    \   Erase and Reset command), line mode is solid. If a site does not have\n  \
    \ a certain mode readily available, it may a) simulate it in software,\n   b)\
    \ substitute another in its place (dashed for dotted, or vice versa)\n   c) ignore\
    \ it entirely. What is provided should be clearly indicated\n   in any public\
    \ document. It is strongly recommend that at least solid\n   and one other mode\
    \ be provided.\n   *Set intensity (\"SETINT\") <value>.\n   This command sets\
    \ the intensity of lines, dots and characters\n   displayed following the command.\
    \ If <value> is 128 decimal, normal\n   intensity should be set. If <value> is\
    \ 255 decimal, brightest should\n   be selected, and if it is 0, then the beam\
    \ should be blanked.\n   Intermediate values should be mapped appropriately as\
    \ the implementer\n   sees fit. For instance, if brightest is the same as normal,\
    \ all\n   values from 128 through 255 should be mapped to normal. Information\n\
    \   displayed between the start of a new picture (the ERASE command) and\n   the\
    \ first SETINT command appears at normal intensity.\n   *Text out (\"TEXTO\")\
    \ <string>.\n   Starting from the current beam position, this command displays\
    \ the\n   <string> (of network ASCII characters) formatted as if it were typed\n\
    \   material (at the current intensity). <string> consists of a <count>\n   followed\
    \ by count many characters. That is, text extending past the\n   right margin\
    \ will be broken and repositioned at the left margin on\n   the next line down.\
    \ Of the control characters, only carriage return,\n   line feed, and backspace\
    \ are required to be interpreted properly.\n   *Subpicture header (\"SUBHED\"\
    ) <identifier> <count> <header info>.\n   This command begins the definition of\
    \ a subpicture named\n   \"<identifier>\". This definition is terminated by a\
    \ matching SUBEND\n   command. The definition will be remembered until a new one\
    \ is\n   specified or until the graphics network connection is broken. Note\n\
    \   that <identifier> is a <string> consisting solely of capital letters\n   and\
    \ numbers.\n   Subpicture definitions may be nested this will be equivalent to\n\
    \   transmitting the two definitions separately. In other words, all\n   subpicture\
    \ names are globals and are \"known\" to all other\n   subpictures. If a subpicture\
    \ definition has not been received prior\n   to its use in a picture, the empty\
    \ subpicture should be displayed in\n   its place until a definition is received.\n\
    \   A subpicture definition need not be transmitted as part of a picture\n   (i.e.,\
    \ within an ERASE and END command pair). Indeed, all subpicture\n   definitions\
    \ might precede the main picture.\n   Currently, the <count> will always be 1,\
    \ indicating only one byte of\n   <header info> follows, but at higher levels\
    \ of the protocol room for\n   expansion may be required. In the <header info>,\
    \ the 80 hex bit will\n   be set if this subpicture can be a simple subpicture,\
    \ and the 40 hex\n   bit will be set if the subpicture can be a full subpicture.\
    \ (It is\n   possible that one subpicture can be both.)\n   Other information\
    \ that may eventually be present in <header info>\n   include whether the current\
    \ value of a certain mode or parameter\n   should be saved on entry to, and restored\
    \ on exit from, this\n   subroutine whenever it is called. These modes and parameters\
    \ include:\n   line mode, intensity, character size, and data length.\n   *Subpicture\
    \ end (\"SUBEND\").\n   This command ends the definition of a subpicture. Each\
    \ SUBEND must\n   match a preceding SUBHED command.\n   *Simple instance (\"INSTS\"\
    ) <identifier> <simple instance tail>\n   This command indicates that the subpicture\
    \ <identifier> is to be\n   called (instanced). At this level, level 1, no subpicture\
    \ may call\n   another; if one does, what happens is left unspecified. Also, this\n\
    \   must be a call to a simple subpicture. Thus the 80 hex bit of the\n   single\
    \ byte of <header info> must have been set in the SUBHED command\n   which started\
    \ the definition of <identifier>. If the subpicture\n   <identifier> has never\
    \ been defined, the empty subpicture should be\n   displayed in its place.\n \
    \  The <simple instance tail> begins with a count of the amount of\n   information\
    \ which follows. This count may be zero. If non-zero, the\n   next byte is a code\
    \ byte to be interpreted to see what further\n   information follows. If the 80-hex\
    \ bit is set, next in the byte\n   stream is an <identifier> (called \"AS information\"\
    ). This\n   <identifier> is the name of this particular instance of the\n   subpicture\
    \ as described under Simple Subpicture Calls. If the 40-hex\n   bit is set, then\
    \ next in the byte stream (following the AS\n   information, if present) is an\
    \ x,y position (in the calling picture's\n   coordinate scheme) at which the subpicture\
    \ will be centered. (This is\n   called AT information.)\n   If AT information\
    \ is not specified, the current beam position is used\n   as a default. If AS\
    \ information is not specified, it defaults to the\n   <string> containing zero\
    \ characters. If neither the 40 hex nor the 80\n   hex bits are set, then neither\
    \ the AT information not the AS\n   information is present, and the code byte\
    \ should be zero. (Also, the\n   length count had better be 1.)\n   Changes to\
    \ levels 0 commands for level 1.\n   TEXT and TEXTR -- Carriage return, line feed\
    \ and backspace characters\n   should definitely be interpreted whenever they\
    \ appear in <string>.\n   The results of other control characters remain unspecified.\
    \ The\n   intensity of the characters shall be affected by the SETINT command.\n\
    \   ERASE -- Normal intensity and solid line mode must be established at\n   the\
    \ start of a new picture.\n   DRAWA and DRAWR -- Line mode and intensity shall\
    \ be affected by the\n   LINMOD and SETINT commands.\n   DOTA and DOTR -- Intensity\
    \ shall be affected by the SETINT command.\nLEVEL 2\n   *Mark (\"MARK\").\n  \
    \ This command causes the current x,y beam position to be saved on a\n   pushdown\
    \ stack. This pushdown stack must be separate from the\n   subpicture call pushdown\
    \ stack.\n   *Move to mark and pop (\"MOVEMK\").\n   This command sets the current\
    \ beam position equal to the x,y position\n   at the top of the \"mark\" pushdown\
    \ stack. If the stack is empty, the\n   origin is used, instead. Then the stack\
    \ is popped up (unless it is\n   empty).\n   *Draw to mark and pop (\"DRAWMK\"\
    ).\n   If the \"mark\" pushdown stack is not empty, this command draws a line\n\
    \   (of the current line mode and intensity) from the current beam\n   position\
    \ to the x,y position at the top of the \"mark\" pushdown stack,\n   and sets\
    \ the beam position to that value. Then the stack is popped.\n   If the stack\
    \ is empty, the line is drawn to the origin and the beam\n   position is set there\
    \ also.\n   Changes to level 0 and 1 for level 2.\n   INTS -- arbitrary levels\
    \ of simple subpictures must be supported.\n   (Note that recursive use of subpictures\
    \ is not allowed:  once\n   recursion starts, it can never be stopped.) The pushdown\
    \ stack for\n   subpicture calls must be kept separate from the \"mark\" pushdown\n\
    \   stack.\nLevel 3\n   (Perhaps all rotational transformations should be put\
    \ at a higher\n   level, for instance higher than viewport operations.)\n   *Full\
    \ Instance (\"INSTF\") <identifier> <full instance tail>\n   This command indicates\
    \ that the subpicture <identifier> is to be\n   called (instanced) in a \"full\"\
    \ manner as described in an explanatory\n   section. For one thing, this means\
    \ that the 40 hex bit of the single\n   byte of <header info> must have been set\
    \ in the SUBHED command which\n   started the definition of <identifier>. If <identifier>\
    \ has never\n   been defined, the empty subpicture (i.e., nothing) should be\n\
    \   displayed in its place.\n   The <full instance tail> is similar to the <simple\
    \ instance tail>\n   described under the INSTS command, but the former contains\
    \ more\n   information. Below is a list of the information which can be\n   specified,\
    \ and the bit assigned to the presence/absence of each piece\n   of information.\
    \ The pieces of information which are present always\n   appear in the byte stream\
    \ in the order they are described in this\n   list. (All pieces of information\
    \ are described more fully in Full\n   Subpicture Calls, except for the \"AS information\"\
    \ which is described\n   in Simple Subpicture Calls.)\nBit (hex)   Information\n\
    80          As information --\"name\" of this particular instance.\n         \
    \   Consists of an <identifier>.\n40          Translation information -- Center\
    \ of the subpicture's image\n            on the calling page.  Consists of an\
    \ <x coordinate> and a\n            <y coordinate>.\n20          Rotation -- Fractional\
    \ part of 2pi to rotate the image\n            counterclockwise.  Consists of\
    \ a 16-bit unsigned fraction.\n10          Portion Information -- Rectangular\
    \ part of subpicture which\n            is to be displayed.  Consists of <x coordinate>,\n\
    \            <y coordinate>, <x delta>, and <y delta>.\n8           Uniform Magnification\
    \ -- Amount to scale the whole\n            subpicture.  Consists of a floating\
    \ point number (which\n            should not be zero).\n4           Separate\
    \ x and y magnification -- Separate scales for the x\n            and y axes of\
    \ the subpicture.  Consists of two floating\n            point numbers (neither\
    \ of which should be zero).\n2           Image Size -- How large a rectangle on\
    \ the calling page is\n            the image to occupy.  Consists of an <x delta>\
    \ and a\n            <y delta> (neither of which should be zero).\n1         \
    \  Affine transformation -- The map from the called to the\n            calling\
    \ coordinates system.  Consists of six floating point\n            numbers.\n\
    \   Notes:\n   1) At most one of the three bits: 8, 4, and 2, should be set.\n\
    \   2) If the 1 bit is set, bits 2, 4, 8, 20, and 40, should not be set.\n   3)\
    \ If additional optional parameters are ever added to the full\n   subpicture\
    \ call, another code byte could follow all the above\n   information.  In that\
    \ case, the <count> part of the <full instance\n   tail> would include this second\
    \ code byte and any additional bytes of\n   information.\n   *Escape to top level\
    \ coordinate system (\"ESCTOP\").\n   Until a RESLEV command is (subsequently)\
    \ executed, all display\n   commands (moves, draws, dots, and texts) shall operate\
    \ as if they\n   were issued by the top level (main) picture instead of the subpicture\n\
    \   containing them.  That is, they shall be mapped to the screen\n   according\
    \ to the map for the highest level.  Subpicture calls\n   themselves, which are\
    \ made while an ESCTOP command is in effect, are\n   not affected by the command.\
    \  That is, transformations are calculated\n   as if the command were not in effect.\
    \  The calculated transformations\n   are ignored, however, and information displayed\
    \ by the subpicture\n   still appears to be at the top level, until a RESLEV command\n\
    \   nullifies the ESCTOP mode.  Thus a subpicture call executed while an\n   ESCTOP\
    \ command is in effect, acts as if a RESLEV were executed\n   immediately before\
    \ the call, and an ESCTOP command were executed as\n   the first command of the\
    \ subpicture.  Similar considerations hold for\n   returning from subpictures.\n\
    \   *Resume current level coordinate system (\"RESLEV\").\n   This command restores\
    \ the logical coordinate system corresponding to\n   the subpicture currently\
    \ executing, in case that coordinate system\n   was disabled by an ESCTOP command.\
    \ (See ESCTOP.)\n   Changes to levels 0, 1, and 2 for level 3.\n   MARK -- the\
    \ saved beam position shall be in terms of the logical\n   coordinate system,\
    \ not the physical coordinate system.\n   TEXTR, TEXT, TEXTO -- Since a full subpicture\
    \ is supposed to be\n   transformed as a whole, as if it were a picture in its\
    \ own right, it\n   appears to this author that, in particular, all beam movements\n\
    \   related to characters should be affected.  This includes character\n   size,\
    \ tab, carriage return and line feed.  In particular, carriage\n   return should\
    \ set the beam to the left margin--that is, to the left\n   edge of the logical\
    \ coordinate system of the called subpicture.  All\n   these changes may be very\
    \ hard to accomplish, and what should be done\n   will be left unspecified at\
    \ this time, with comment from readers\n   particularly invited.\nLevel 4\n  \
    \ (Perhaps viewpoint operations can be included in level 3.)\n   *Declare Viewport\n\
    \   (\"SETVW\") <viewport id> <x coordinate> <y coordinate> <x delta>\n   <y delta>\n\
    \   Set the viewport identified by <viewport id> to represent the\n   indicated\
    \ area of the logical screen.  The x and y data are not\n   physical screen coordinates,\
    \ since that would involve device\n   dependencies.  This command completely supersedes\
    \ any previous\n   declaration of the same viewport.  If information is already\n\
    \   displayed within the viewport specified, this command causes the\n   displayed\
    \ information to be relocated on the screen to its new\n   position.\n   If the\
    \ area specified exceeds the limits of the graphics standard\n   display screen,\
    \ what happens is left unspecified.  Viewports need not\n   be disjoint; in other\
    \ words, two viewports can present display\n   information at the same point on\
    \ the screen.\n   If <x delta> or <y delta> are negative, the viewport named should\
    \ be\n   deleted.  All information displayed by it shall no longer appear.\n \
    \  Because it affects the top level picture, this author feels that this\n   command\
    \ should not occur as part of a picture or in a subpicture\n   declaration.\n\
    \   *Add subpicture to viewport (\"ADDSVW\") <identifier> <viewport id>\n   The\
    \ subpicture named <identifier> is displayed within the viewport\n   specified,\
    \ if it is not already displayed there. (If it is, nothing\n   is done.) The subpicture\
    \ must be capable of being called via a full\n   subpicture call.  If the viewport\
    \ has never been declared via a SETVW\n   command what happens is left unspecified.\
    \ (Three possibilities are:\n   nothing is displayed; the viewport defaults to\
    \ the whole logical\n   screen; the human viewer is permitted by the Using Host\
    \ to specify\n   the viewport.) If the viewport is subsequently declared, the\n\
    \   subpicture shall be displayed in it.  If the subpicture has never be\n   declared,\
    \ nothing is displayed for it; when and if it is subsequently\n   declared, the\
    \ new definition is displayed in the viewport.  More than\n   one subpicture may\
    \ be displayed in a single viewport at once.\n   Because it affects the top level\
    \ picture, this author feels that this\n   command should not occur as part of\
    \ a picture or in a subpicture\n   declaration.\n   *Clear viewport (\"CLVW\"\
    ) <viewport id>\n   All subpictures which have been added with the ADDSVW command\
    \ to the\n   viewport specified in this command are removed from it.  Thus the\n\
    \   specified viewport contributes nothing to what the human viewer sees.\n  \
    \ (After a CLVW, the area of the viewport may not be blank due to\n   other, non-cleared\
    \ viewports which overlap it.)\n   Because it affects the top level picture, this\
    \ author feels that this\n   command should not occur as part of a picture or\
    \ in a subpicture\n   declaration.\n   Changes to levels 0, 1, 2, and 3 for level\
    \ 4.\n   ERASE -- All viewports are cleared (as in the CLVW command) but their\n\
    \   declarations are remembered.\n   ENDPIC -- This command partially loses its\
    \ purpose: it no longer\n   serves to mark the end of all picture information\
    \ to be presented to\n   the user, since viewport operations may follow which\
    \ amend or alter\n   the picture.  This function is partially taken over by the\
    \ DELAY and\n   NODELAY commands described below.\nLevel ?\n   *Set Character\
    \ Size (\"SETCHS\") <x delta> <y delta>.\n   Until further notice, characters\
    \ shall be displayed so that each\n   occupies approximately <x delta> and <y\
    \ delta> in the appropriate\n   coordinate direction in the current logical coordinate\
    \ system.\n   Inter-character and inter-line spacing could be certain percentages\n\
    \   (any ideas?) more than <x delta> and <y delta>, or they could be\n   specified\
    \ separately.  In any case, only a \"best effort\" would be\n   expected at a\
    \ site.  Character size is always set to normal (as\n   defined by level 0 character\
    \ size being normal) by the ERASE command.\n   <x delta> and <y delta> should\
    \ be positive, except that if <x delta>\n   is equal to zero, then <y delta> being\
    \ negative, zero, or positive,\n   correspond to a character size which is \"\
    smaller than normal\",\n   \"normal\", or \"larger than normal\".  How much smaller\
    \ or larger than\n   normal is left up to the site.\n   Changes to levels 0 and\
    \ 1 for level ?.\n   TEXTR, TEXT, and TEXTO -- Characters are to be displayed\
    \ according to\n   the current character size.\n   ERASE -- Must establish normal\
    \ character size, normal being that for\n   level 0.\nLevel ?'\n   *Set Data Length\
    \ (\"SETDLN\") <value>.\n   Until this mode is explicitly changed with another\
    \ SETDLN, various\n   data will consist of <value> number of bytes. <value> may\
    \ be 1, 2, 3,\n   or 4.  Affected are the following syntactic types (refer to\
    \ Appendix\n   1): <coordinate>, <x coordinate>, <y coordinate>, <double\n   coordinate>,\
    \ <x delta>, <y delta>, <angle>, and the fractional part\n   of a floating point\
    \ number.  When a network connection is initially\n   established, the data length\
    \ is two.\nLevel ?''\n   (These commands should probably be at the same level\
    \ as viewport\n   operations, if not earlier.)\n   *Extensive Changes Follow (\"\
    DELAY\").\n   This optional command is designed to eliminate futile effort on\
    \ the\n   part of the Using Host programs.  At some hosts and/or with some\n \
    \  output devices (particularly storage tubes) a non-negligible amount\n   of\
    \ time may be required to present an image to the human viewer.  If\n   extensive\
    \ changes are going to be made, this command would be used to\n   prevent the\
    \ Using Host graphics package from updating the image after\n   every change.\
    \  A NODELAY command exits from the DELAY mode and causes\n   the image to be\
    \ prepared and presented to the viewer.\n   For example, the current picture may\
    \ display four subpictures each of\n   which is going to be redefined.  Without\
    \ a DELAY command, the viewer\n   would see successive stages of the change, each\
    \ possibly involving a\n   large amount of computation or transmission time.\n\
    \   *End of Extensive Changes (\"NODELAY\")\n   This optional command undoes the\
    \ effect of the DELAY command.\nAppendix 1: BNF for the Graphics Protocol Byte\
    \ Stream\nKey to below:\nNon-terminals are represented in < >.\nTerminals which\
    \ are keywords standing for particular eight-bit values\nare in capitals.\nTerminals\
    \ whose meaning should be clear to the reader are in lower case.\nNote that \"\
    empty_string\" means \"zero bytes\", not \"a <string> whose\n<count> is zero.\"\
    \n<graphics output byte stream> ::= empty_string\n           | <picture> <graphics\
    \ output byte stream>\n           | <subpicture declaration> <graphics output\
    \ byte stream>\n           | <viewport operation> <graphics output byte stream>\n\
    \           | <transmission control stt> <graphics output byte stream>\n<picture>\
    \ ::= <new picture sst> <program stt group> <end picture stt>\n<subpicture declaration>\
    \ ::= <subpicture header stt> <program stt\n                              group><subpicture\
    \ end stt>\n<viewport operation> ::= <declare viewport stt>\n           | <add\
    \ subpicture to viewport stt>\n           | <clear viewport stt>\n<transmission\
    \ control stt> ::= <set data length stt>\n           | <extensive changes follow\
    \ stt>\n           | <end of extensive changes stt>\n<program stt group> ::= empty_string\
    \ | <program stt <program stt group>\n<program stt> ::= <picture control stt>\
    \ | <display stt> |\n              <transmission control stt>\n<picture control\
    \ stt> ::= <escape to device stt>\n           | <escape to highest coordinate\
    \ system stt>\n           | <restore coordinate system stt>\n           | <mark\
    \ stt>\n           | <null stt>\n           | <line mode stt>\n           | <set\
    \ intensity stt>\n           | <subpicture declaration>\n           | <simple\
    \ instance stt>\n           | <full instance stt>\n           | <set character\
    \ size stt>\n<display stt> ::= <move absolute stt>\n           | <move relative\
    \ stt>\n           | <draw absolute stt>\n           | <draw relative stt>\n \
    \          | <dot absolute stt>\n           | <dot relative stt>\n           |\
    \ <move to mark and pop stt>\n           | <draw to mark and pop stt>\n      \
    \     | <text and restore beam stt>\n           | <text stt>\n           | <text\
    \ out stt>\n<new picture stt> ::= ERASE\n<end picture stt> ::= ENDPIC\n<subpicture\
    \ header stt> ::= SUBHED <identifier> count> <header info>\n<header info> ::=\
    \ 80-hex | 40-hex | C0-hex\n<subpicture end stt> ::= SUBEND\n<set viewport stt>\
    \ ::= SETVW <viewport id> <x coordinate>\n                       <y coordinate>\
    \ <x delta> <y delta>\n<add subpicture to viewport stt> ::= AADSVW <identifier>\
    \ <viewport id>\n<clear viewport stt> ::= CLVW <viewport id>\n<extensive changes\
    \ follow stt> ::= DELAY\n<end of extensive changes stt> ::= NODELAY\n<escape to\
    \ device stt> ::= ESCDEV <device code> <string>\n<escape to highest coordinate\
    \ system stt> ::= ESCTOP\n<restore coordinate system stt> ::= RESLEV\n<null stt>\
    \ ::= NULL\n<mark stt> ::= MARK\n<line mode stt> ::= LINMOD <value>\n<set character\
    \ size stt> ::= SETCHS <x delta> <y delta>\n<set data length stt> ::= SETDLN <value>\n\
    <move absolute stt> ::= MOVEA <x coordinate> <y coordinate>\n<move relative stt>\
    \ ::= MOVER <x delta> <y delta>\n<draw absolute stt> ::= DRAWA <x coordinate>\
    \ <y coordinate>\n<draw relative stt> ::= DRAWR <x delta> <y delta>\n<dot absolute\
    \ stt> ::= DOTA <x coordinate> <y coordinate>\n<dot relative stt> ::= DOTR <x\
    \ delta> <y delta>\n<move to mark and pop stt> ::= MOVEMK\n<draw to mark and pop\
    \ stt> ::= DRAWMK\n<text and restore beam stt> ::= TEXTR <string>\n<text stt>\
    \ ::= TEXT <string>\n<text out stt> ::= TEXTO <string>\n<simple instance stt>\
    \ ::= INST <identifier> <simple instance tail>\n<full instance stt> ::= INSTF\
    \ <identifier> <full instance tail>\n<simple instance tail> ::= eight_bits_of_binary_0\n\
    \                    | <count> <tail code> <as clause> <at clause>\n<tail code>\
    \ ::= bit_pattern_indicating_what_clauses_follow\n<full instance tail> ::= eight_bits_of_binary_0\n\
    \                    | <count> <tail code> <as clause> <at clause>\n         \
    \           <rotation clause> <portion clause>\n                    <uniform magnification\
    \ clause>\n                    <separate magnification clause> <image size\n \
    \                   clause> <complete transformation clause>\n<as clause> ::=\
    \ empty_string | <identifier>\n<at clause> ::= empty_string | <x coordinate> <y\
    \ coordinate>\n<rotation clause> ::= empty_string | <angle>\n<portion clause>\
    \ ::= empty_string | <x coordinate> <y coordinate>\n                     <x delta>\
    \ <y delta>\n<uniform magnification clause> ::= empty_string |floating point number>\n\
    <separate magnification clause> ::= empty_string |\n                    <floating\
    \ point number> <floating point number>\n<image size clause> ::= empty_string\
    \ | <x delta> <y delta>\n<complete transformation clause> ::= empty_string | six_<floating\
    \ point\n                    number>'s\n<angle> ::= 16-bit_non-negative_fractional_part_of_a_circle\n\
    <x coordinate> ::= <coordinate>\n<y coordinate> ::= <coordinate>\n<x delta> ::=\
    \ <double coordinate>\n<y delta> ::= <double coordinate>\n<coordinate> ::= signed,_two_s-complement,_fraction_in_range\n\
    \                    -1/2_to_less_than_+1/2\n<double coordinate> ::= signed,_two_s_complement,_fraction,\n\
    \                    range _strictly_between_-1_and_+1\n<floating point number>\
    \ ::= network_standard_floating_point\n                    number_if_any\n   \
    \                 | 8-bit_two_s_complement_exponent_part and a\n             \
    \       16-bit_two_s_complement_fraction_part <count>\n                    ::=\
    \ 7-bit_non-negative_integer\n                    | 15-bit_non-negative_integer_represented_in\n\
    \                    \"excess_2**15\"_notation\n<string> ::= <count> count_8-bit_bytes\n\
    <identifier> ::= <count> count_upper_case_letters_or_numbers\n<viewport id> ::=\
    \ <identifier>\n<device code> ::= 8-bit_integer\n<value> ::= 8-bit_integer\nAppendix\
    \ 2.  Mathematical Formulae for Subpictures\nTransformations\nIn this appendix\
    \ positions in a logical coordinate system will be\nrepresented by a row vector\
    \ with two elements, as in /_ x y_/.  Vectors\nand matrices will be delimited\
    \ by these funny brackets: /_ _/.  Various\nsymbols will be used to represent\
    \ parameters in a full subpicture call\nrelating to a transformation from one\
    \ coordinate system to another;\nthese are defined below:\nMx and My : magnifications\
    \ in x and y to be applied before any\n            rotation.\n            They\
    \ may be negative indicating reflection.\nA: an angle of rotation in the range\
    \ 0 to just less than 2pi.\n/_ |cx |cy_/ : the center (in the calling picture)\
    \ of the image of the\n          subpicture.\n|sx |sy : the half-sizes, in the\
    \ x and y directions, of the\n           image on the calling page in terms of\
    \ the calling page's\n           coordinate system.\n           They may be negative\
    \ to indicate reflection.\n/_ x y_/ : a position on the called page.\n/_ |x |y_/\
    \ : the position on the calling page corresponding to /_x y_/.\n/_ Pcx Pcy_/ :\
    \ The center of the portion of the called subpicture's\n               coordinate\
    \ system which is to be mapped to the calling\n               page.\n        \
    \       This defaults to /_ 0 0_/ if not specified.\nPsx and Psy : The half-sizes\
    \ in x and y of the portion of the\n              subpicture to be mapped. These\
    \ both default to +1/2\n              in not specified.\n(If a uniform magnification\
    \ is specified, set Mx and My equal to it and\nproceed below as if they were specified.)\n\
    If magnifications are specified, the following holds:\n/_ |x |y_/ = (/_ x y_/\
    \ - /_ Pcx Pcy_>) * / Mx/Psx  0    / *\n                                     \
    \   /_   0  My/Psy_/\n          / cos 0 sin 0 / * / 1/2 0  / + /_ |cx |cy_/\n\
    \         /_ -sin0 cos0_/  /_ 0  1/2_/\nor in other words,\n1)\n/_|x |y_/ = /_\
    \ x-Pcx y-Pcy_/ * / Mx cosA/2Psx Mx sinA/2Psx /\n                            \
    \ /_ -My sinA/2Psy My cosA/2Psy_/\n            +/_ |cx |cy_/\n(The factor of 1/2\
    \ is necessary because, for instance, (x-Pcx)/Psx\nranges from -1 to +1 for x\
    \ values within the portion (i.e., such that\n|x-Pcx| <|Psx| ) whereas the image,\
    \ in the calling subpicture's\ncoordinate system, should only range from -1/2\
    \ to +1/2.)\nIf the image size is specified instead of the magnification, we have\
    \ the\nfollowing:\n/_ |x |y_/ = (/_ x y_/ - /_Pcx Pcy_/) * / 1/Psx  0    / *\n\
    \                                       /_  0  1/Psy _/\n          / cosA sinA\
    \    / * / |sx 0    / + /_ |cx |cy_/\n         /_ -sinA cosA _/   /_ 0  |sy _/\n\
    or, in other words,\n2)\n/_|x |y_/ = /_x-Pcx y-Pcy_/ * /|sx cosA/Psx |sy sinA/Psx\
    \ /\n                            /_-|sx sinA/Psy |sy cosA/Psy_/\n           +\
    \ /_|cx |cy_/\nExpanding the parenthesized quantities in equations 1) and 2),\
    \ we\nhave:\n3a) /_|x |y_/ = /_x y_/ * /Mx cosA/2Psx   Mx  sinA/2Psx /\n     \
    \                    /_-My sinA/2Psy  My cosA/2Psy_/\n           + /_|cx-PcxMxcosA/2Psx+PcyMysinA/2Psy\n\
    \                      |cy-PcxMxsinA/2Psx-PcyMycosA/2Psy _/\nand\n3b) /_|x |y_/\
    \ = /_x y_/ * /|sx cosA/Psx |sy sinA/Psx  /\n                        /_-|sx sinA/Psy\
    \ |sy cosA/Psy_/\n           + /_|cx-Pcx|sxcosA/Psx+Pcy|sxsinA/Psy\n         \
    \             |cy-Pcy|sysinA/Psx-Pcy|sycosA/Psy_/\nVarious interesting substitutions\
    \ can be made in 3a) and 3b).\nFor example, if A=0 (no rotation), then we have:\n\
    4a) /_|x |y_/ = /_x y_/ * /Mx/2Psx 0 / + /_|cx-PcxMx/2Psx\n|cy-PcyMy/2Psy_/\n\
    \                         /_ 0 My/2Psy_/\n4b) /_|x |y_/ = /_x y_/ *  /|sx/Psx\
    \ 0 / + /_|cx-Pcx|sx/Psx\n|cy-Pcy|sy/Psy_/\n                          /_ 0 |sy/Psy_/\n\
    Another example is if no portioning is done (Pcx=Pcy=0, Psx=Psy=1/2):\n5a) /_|x\
    \ |y_/ = /_ x y_/  * /Mx cosA Mx sinA   / + /_|cx |cy_/\n                    \
    \       /_-My sinA My sinA_/\n5b) /_|x |y_/ = /_ x y_/ * /2|sx cosA 2|sy sinA\
    \   / + /_|cx |cy_/\n                          /_-2|sx sinA 2|sx cosA_/\nIf in\
    \ addition, 0=0, we have:\n6a) /_|x |y_/ =  /_ xMx+|cx  yMy+|cy_/\n6b) /_|x |y_/\
    \ = /_ x*2|sx+|cx y*2|sy+|cy_/\nOf course, in all cases, the transformation from\
    \ /_x y_/ to /_|x |y_/\ncan be written in the form:\n/_|x |y_/ = /_x y_/ * / 2\
    \ by 2 / + /_ translation _/\n                     /_ matrix _/\nIn general, a\
    \ transformation combining a linear transformation and a\ntranslation is called\
    \ an affine transformation.\nTransformations with Nested Levels\nThe combination\
    \ of two affine transformations is again an affine\ntransformation.  Indeed, if\n\
    /_|x |y_/ = /_x y_/ * / Mat1 / + /_ Tran1 _/\n                     /_     _/\n\
    and\n/_|x_ |y__/ = /_|x |y_/ * ( / Mat1 / * / Mat2 /)\n                      \
    \     /_    _/   /_    _/\n            + (/_ Tran2 _/ + /_ Tran1 _/ * / Mat2 /)\n\
    \                                          /_    _/\nThus if one has nested full\
    \ subpicture calls, the data at any level need\nbe transformed only once, namely,\
    \ by the transformation which is the\ncombination of the single step transformations\
    \ at each level of nesting.\nA new \"grand combination\" affine transformation\
    \ should be computed\nwhenever a full subpicture is called (after pushing down\
    \ the current\ntransformation) by combining the current grand combination with\
    \ the\naffine transformation for this particular subpicture call.\nPortions with\
    \ Nested Levels\n   As long as no rotations are involved, or even only rotations\
    \ in\n   multiples of pi/2, then multiple levels of portions are easy to\n   implement.\
    \  In the discussion in the next two paragraphs let us\n   assume that no rotations\
    \ other than whole multiples of pi/2 are\n   involved.\n   Just as one can keep\
    \ track of a \"grand combination\" affine\n   transformation, so can one keep\
    \ a grand combination of portions.  At\n   each level, one can proceed as follows:\
    \ Save a copy of the current\n   grand portion, and use the inverse of the single\
    \ level affine\n   transformation (specified in the subpicture call) to determine\
    \ what\n   rectangle of the called page corresponds to the current grand portion\n\
    \   (on calling page).\n   Various relations may exist between this rectangle\
    \ and the rectangle\n   specified (or defaulted) in the subpicture call.  They\
    \ may be\n   disjoint (in which case this subpicture need not be called at all);\n\
    \   they may be equal (an easy case); one may contain the other or they\n   may\
    \ partially overlap.  If there is any intersection, it will be a\n   rectangle,\
    \ and this rectangle becomes the new grand combination\n   portion.\n   The problem\
    \ with rotations other than multiples of pi/2 is that the\n   inverse image of\
    \ the rectangle is no longer in the standard\n   orientation (vertical and horizontal\
    \ edges).  This means that its\n   intersection with the portion specified on\
    \ the subpicture call may\n   have 3, 4, 5, 6, 7, or 8 edges (if it is non-empty).\
    \  Deeper levels\n   may get even worse if they involve rotations too.  While\
    \ there may be\n   no conceptual difficulty (for some) in working with such a\
    \ situation,\n   significantly more computation is involved than in the simple\n\
    \   horizontal and vertical edge case.\n   This protocol puts forward no recommendation\
    \ in the case that\n   rotations other than whole multiples of pi/2 are involved\
    \ with\n   portions.  It does suggest that nested portions be handled as\n   described\
    \ above in the more straightforward case.\n          [This RFC was put into machine\
    \ readable form for entry]\n    [into the online RFC archives by Helene Morin,\
    \ Via Genie, 12/1999]\n"
