- title: __initial_text__
  contents:
  - '               Data Link Switching Remote Access Protocol

    '
- title: Status of this Memo
  contents:
  - "Status of this Memo\n   This memo provides information for the Internet community.\
    \  This memo\n   does not specify an Internet standard of any kind.  Distribution\
    \ of\n   this memo is unlimited.\n"
- title: Abstract
  contents:
  - "Abstract\n   This memo describes the Data Link Switching Remote Access Protocol\n\
    \   that is used between workstations and routers to transport SNA/\n   NetBIOS\
    \ traffic over TCP sessions. Any questions or comments should\n   be sent to drap@cisco.com.\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   Since the Data Link Switching Protocol, RFC 1795, was published,\
    \ some\n   software vendors have begun implementing DLSw on workstations. The\n\
    \   implementation of DLSw on a large number of workstations raises\n   several\
    \ important issues that must be addressed. Scalability is the\n   major concern.\
    \ For example, the number of TCP sessions to the DLSw\n   router increases in\
    \ direct proportion to the number of workstations\n   added. Another concern is\
    \ efficiency. Since DLSw is a switch-to-\n   switch protocol, it is not efficient\
    \ when implemented on\n   workstations.\n   DRAP addresses the above issues. It\
    \ introduces a hierarchical\n   structure to resolve the scalability problems.\
    \ All workstations are\n   clients to the router (server) rather than peers to\
    \ the router. This\n   creates a client/server model. It also provides a more\
    \ efficient\n   protocol between the workstation (client) and the router (server).\n"
- title: 2.  Overview
  contents:
  - '2.  Overview

    '
- title: 2.1.  DRAP Client/Server Model
  contents:
  - "2.1.  DRAP Client/Server Model\n      +-----------+              +-----------+\
    \       +---------+\n      | Mainframe |              | IP Router +- ppp -+ DLSw\
    \    |\n      +--+--------+              +-----+-----+       | Work    |\n   \
    \      |                             |             | Station |\n         |   \
    \                          |             +---------+\n      +--+--+      +-------------+\
    \     |\n      | FEP +- TR -+ DLSw Router +-- IP Backbone\n      +-----+     \
    \ +-------------+     |\n                                       |\n          \
    \                             |\n                                 +-----------+\
    \       +---------+\n                                 | IP Router +- ppp -+ DLSw\
    \    |\n                                 +-----+-----+       | Work    |\n   \
    \                                                  | Station |\n             \
    \                                        +---------+\n                       \
    \    |         DLSw Session          |\n                           +-------------------------------+\n\
    \  Figure 2-1. Running DLSw on a large number of workstations creates a\n    \
    \                     scalability problem.\n   Figure 2-1 shows a typical DLSw\
    \ implementation on a workstation. The\n   workstations are connected to the central\
    \ site DLSw router over the\n   IP network.  As the network grows, scalability\
    \ will become an issue\n   as the number of TCP sessions increases due to the\
    \ growing number of\n   workstations.\n                                  +-----------+\
    \       +-------+\n       +-----------+              | DLSw/DRAP |       | DRAP\
    \  |\n       | Mainframe |              |   Router  +- ppp -+ Client|\n      \
    \ +--+--------+              +-----+-----+       +-------+\n          |      \
    \                       |\n          |                             |\n       +--+--+\
    \      +-------------+     |\n       | FEP +- TR -+ DLSw Router +-- IP Backbone\n\
    \       +-----+      +-------------+     |\n                                 \
    \       |\n                                        |\n                       \
    \           +-----------+       +-------+\n                                  |\
    \ DLSw/DRAP |       | DRAP  |\n                                  |   Router  +-\
    \ ppp -+ Client|\n                                  +-----+-----+       +-------+\n\
    \                         | DLSw Session |  | DRAP Session |\n               \
    \          +--------------+  +--------------+\n"
- title: Figure 2-2. DLSw Remote Access Protocol solves the scalability problem.
  contents:
  - "Figure 2-2. DLSw Remote Access Protocol solves the scalability problem.\n   In\
    \ a large network, DRAP addresses the scalability problem by\n   significantly\
    \ reducing the number of peers that connect to the\n   central site router. The\
    \ workstations (DRAP client) and the router\n   (DRAP server) behave in a Client/Server\
    \ relationship. Workstations\n   are attached to a DRAP server. A DRAP server\
    \ has a single peer\n   connection to the central site router.\n"
- title: 2.2.  Dynamic Address Resolution
  contents:
  - "2.2.  Dynamic Address Resolution\n   In a DLSw network, each workstation needs\
    \ a MAC address to\n   communicate with a FEP attached to a LAN. When DLSw is\
    \ implemented on\n   a workstation, it does not always have a MAC address defined.\
    \ For\n   example, when a workstation connects to a router through a modem via\n\
    \   PPP, it only consists of an IP address. In this case, the user must\n   define\
    \ a virtual MAC address. This is administratively intensive\n   since each workstation\
    \ must have an unique MAC address.\n   DRAP uses the Dynamic Address Resolution\
    \ protocol to solve this\n   problem. The Dynamic Address Resolution protocol\
    \ permits the server\n   to dynamically assign a MAC address to a client without\
    \ complex\n   configuration.\n   For a client to initiate a session to a server,\
    \ the workstation sends\n   a direct request to the server. The request contains\
    \ the destination\n   MAC address and the destination SAP. The workstation can\
    \ either\n   specify its own MAC address, or request the server to assign one\
    \ to\n   it. The server's IP address must be pre-configured on the\n   workstation.\
    \ If IP addresses are configured for multiple servers at a\n   workstation, the\
    \ request can be sent to these servers and the first\n   one to respond will be\
    \ used.\n   For a server to initiate a session to a client, the server sends a\n\
    \   directed request to the workstation. The workstation must pre-\n   register\
    \ its MAC address at the server. This can be done either by\n   configuration\
    \ on the server or registration at the server (both MAC\n   addresses and IP addresses\
    \ will be registered).\n"
- title: 2.3.  TCP Connection
  contents:
  - "2.3.  TCP Connection\n   The transport used between the client and the server\
    \ is TCP. Before a\n   TCP session is established between the client and the server,\
    \ no\n   message can be sent. The default parameters associated with the TCP\n\
    \   connections between the client and the server are as follows:\n      Socket\
    \ Family     AF_INET        (Internet protocols)\n      Socket Type       SOCK_STREAM\
    \    (stream socket)\n      Port Number       1973\n   There is only one TCP connection\
    \ between the client and the server.\n   It is used for both read and write operations.\n"
- title: 3.  DRAP Format
  contents:
  - '3.  DRAP Format

    '
- title: 3.1.  General Frame Format
  contents:
  - "3.1.  General Frame Format\n   The General format of the DRAP frame is as follows:\n\
    \             +-------------+-----------+-----------+\n             | DRAP Header\
    \ | DRAP Data | User Data |\n             +-------------+-----------+-----------+\n\
    \                     Figure 3-1. DRAP Frame Format\n   The DRAP protocol is contained\
    \ in the DRAP header, which is common to\n   all frames passed between the DRAP\
    \ client and the server. This header\n   is 4 bytes long. The next section will\
    \ explain the details.\n   The next part is the DRAP Data. The structure and the\
    \ size are based\n   on the type of messages carried in the DRAP frame. The DRAP\
    \ data is\n   used to process the frame, but it is optional.\n   The third part\
    \ of the frame is the user data, which is sent by the\n   local system to the\
    \ remote system. The size of this block is variable\n   and is included in the\
    \ frame only when there is data to be sent to\n   the remote system.\n"
- title: 3.2.  Header Format
  contents:
  - "3.2.  Header Format\n   The DRAP header is used to identify the message type\
    \ and the length\n   of the frame. This is a general purpose header used for each\
    \ frame\n   that is passed between the DRAP server and the client. More\n   information\
    \ is needed for frames like CAN_U_REACH and I_CAN_REACH,\n   therefore, it is\
    \ passed to the peer as DRAP data. The structure of\n   the DRAP data depends\
    \ on the type of frames, and will be discussed in\n   detail in later sections.\n\
    \   The DRAP Header is given below:\n             +-------------------------------------------+\n\
    \             | DRAP Packet Header (Each row is one byte) |\n             +===========================================+\n\
    \           0 | Protocol ID / Version Number              |\n             +-------------------------------------------+\n\
    \           1 | Message Type                              |\n             +-------------------------------------------+\n\
    \           2 | Packet Length                             |\n             + -\
    \ - - - - - - - - - - - - - - - - - - - - +\n           3 |                  \
    \                         |\n             +-------------------------------------------+\n\
    \                     Figure 3-2. DRAP Header Format\n   o The Protocol ID uses\
    \ the first 4 bits of this field and is set to\n     \"1000\".\n   o The Version\
    \ Number uses the next 4 bits in this field and is set\n     to \"0001\".\n  \
    \ o The message type is the DRAP message type.\n   o The Total Packet length is\
    \ the length of the packet including the\n     DRAP header, DRAP data and User\
    \ Data. The minimum size of the\n     packet is 4, which is the length of the\
    \ header.\n"
- title: 3.3.  DRAP Messages
  contents:
  - "3.3.  DRAP Messages\n   Most of the Drap frames are based on the existing DLSw\
    \ frames and\n   have the same names. The information in the corresponding DRAP\
    \ and\n   DLSw frames may differ; but the functionalities are the same. Thus\n\
    \   the DLSw State Machine is used to handle these DRAP frames. Some new\n   DRAP\
    \ frames were created to handle special DRAP functions. For\n   example, the new\
    \ DRAP frames, I_CANNOT_REACH and START_DL_FAILED\n   provide negative acknowledgment.\
    \ The DLSw frames not needed for DRAP,\n   are dropped.\n   The following table\
    \ lists and describes all available DRAP messages:\n   DRAP Frame Name     Code\
    \  Function\n   ---------------     ----  --------\n   CAN_U_REACH         0x01\
    \  Find if the station given is reachable\n   I_CAN_REACH         0x02  Positive\
    \ response to CAN_U_REACH\n   I_CANNOT_REACH      0x03  Negative response to CAN_U_REACH\n\
    \   START_DL            0x04  Setup session for given addresses\n   DL_STARTED\
    \          0x05  Session Started\n   START_DL_FAILED     0x06  Session Start failed\n\
    \   XID_FRAME           0x07  XID Frame\n   CONTACT_STN         0x08  Contact\
    \ destination to establish SABME\n   STN_CONTACTED       0x09  Station contacted\
    \ - SABME mode set\n   DATA_FRAME          0x0A  Connectionless Data Frame for\
    \ a link\n   INFO_FRAME          0x0B  Connection oriented I-Frame\n   HALT_DL\
    \             0x0C  Halt Data Link session\n   HALT_DL_NOACK       0x0D  Halt\
    \ Data Link session without ack\n   DL_HALTED           0x0E  Session Halted\n\
    \   FCM_FRAME           0x0F  Data Link Session Flow Control Message\n   DGRM_FRAME\
    \          0x11  Connectionless Datagram Frame for a circuit\n   CAP_XCHANGE \
    \        0x12  Capabilities Exchange Message\n   CLOSE_PEER_REQUEST  0x13  Disconnect\
    \ Peer Connection Request\n   CLOSE_PEER_RESPONSE 0x14  Disconnect Peer Connection\
    \ Response\n   PEER_TEST_REQ       0x1D  Peer keepalive test request\n   PEER_TEST_RSP\
    \       0x1E  Peer keepalive response\n                         Table 3-1. DRAP\
    \ Frames\n"
- title: 3.4.  DRAP Data formats
  contents:
  - "3.4.  DRAP Data formats\n   The DRAP data is used to carry information required\
    \ for each DRAP\n   frame. This information is used by the Server or the Client\
    \ and it\n   does not contain any user data. The DRAP data frame types are listed\n\
    \   in the following sections. Please note that the sender should set the\n  \
    \ reserved fields to zero and the receiver should ignore these fields.\n"
- title: 3.4.1.  CAN_U_REACH, I_CAN_REACH, and I_CANNOT_REACH Frames
  contents:
  - "3.4.1.  CAN_U_REACH, I_CAN_REACH, and I_CANNOT_REACH Frames\n   These frame types\
    \ are used to locate resources in a network. A\n   CAN_U_REACH frame is sent to\
    \ the server to determine if the resource\n   is reachable. The server responds\
    \ with an I_CAN_REACH frame if it can\n   reach the workstation identified in\
    \ the CAN_U_REACH frame, or with an\n   I_CANNOT_REACH if the station is not reachable.\
    \ The server should not\n   send the CAN_U_REACH frame to the clients. When a\
    \ server receives an\n   explorer whose destination is a known client, the server\
    \ should\n   respond to it directly.\n           +---------------+-----------------------+\n\
    \           | Field Name    | Information           |\n           +---------------+-----------------------+\n\
    \           | Message Type  | 0x01, 0x02, or 0x03   |\n           +---------------+-----------------------+\n\
    \           | Packet Length | 0x0C                  |\n           +---------------+-----------------------+\n\
    \    Figure 3-3. CAN_U_REACH, I_CAN_REACH, and I_CANNOT_REACH Header\n       \
    \      +-----------------------------------+\n             | Field Name (Each\
    \ row is one byte) |\n             +===================================+\n   \
    \        0 | Target MAC Address                |\n             + - - - - - - -\
    \ - - - - - - - - - - +\n           1 |                                   |\n\
    \             + - - - - - - - - - - - - - - - - - +\n           2 |          \
    \                         |\n             + - - - - - - - - - - - - - - - - -\
    \ +\n           3 |                                   |\n             + - - -\
    \ - - - - - - - - - - - - - - +\n           4 |                              \
    \     |\n             + - - - - - - - - - - - - - - - - - +\n           5 |  \
    \                                 |\n             +-----------------------------------+\n\
    \           6 | Source SAP                        |\n             +-----------------------------------+\n\
    \           7 | Reserved                          |\n             +-----------------------------------+\n\
    \     Figure 3-4. CAN_U_REACH, I_CAN_REACH, and I_CANNOT_REACH Data\n   The MAC\
    \ Address field carries the MAC address of the target\n   workstation that is\
    \ being searched. This is a six-byte MAC Address\n   field. The same MAC Address\
    \ is returned in the I_CAN_REACH and the\n   I_CANNOT_REACH frames.\n   Byte 6\
    \ is the source SAP. The destination SAP is set to zero when an\n   explorer frame\
    \ is sent to the network.\n   If the sender did not receive a positive acknowledgment\
    \ within a\n   recommended threshold value of 60 seconds, the destination is\n\
    \   considered not reachable.\n"
- title: 3.4.2.  START_DL, DL_STARTED, and START_DL_FAILED Frames
  contents:
  - "3.4.2.  START_DL, DL_STARTED, and START_DL_FAILED Frames\n   These frame types\
    \ are used by DRAP to establish a link station\n   (circuit). The START_DL frame\
    \ is sent directly to the server that\n   responds to the CAN_U_REACH frame. When\
    \ the server receives this\n   frame, it establishes a link station with the source\
    \ and destination\n   addresses and saps provided in the START_DL frame. If the\
    \ circuit\n   establishment is successful, a DL_STARTED frame is sent back as\
    \ a\n   response. A failure will result in a START_DL_FAILED response. The\n \
    \  server can also send START_DL frames to clients, to establish\n   circuits.\n\
    \           +---------------+-----------------------+\n           | Field Name\
    \    | Information           |\n           +---------------+-----------------------+\n\
    \           | Message Type  | 0x04, 0x05, or 0x06   |\n           +---------------+-----------------------+\n\
    \           | Packet Length | 0x18                  |\n           +---------------+-----------------------+\n\
    \      Figure 3-5. START_DL, DL_STARTED, and START_DL_FAILED Header\n        \
    \     +-----------------------------------+\n             | Field Name (Each row\
    \ is one byte) |\n             +===================================+\n       \
    \    0 | Host MAC Address                  |\n             + - - - - - - - - -\
    \ - - - - - - - - +\n           1 |                                   |\n    \
    \         + - - - - - - - - - - - - - - - - - +\n           2 |              \
    \                     |\n             + - - - - - - - - - - - - - - - - - +\n\
    \           3 |                                   |\n             + - - - - -\
    \ - - - - - - - - - - - - +\n           4 |                                  \
    \ |\n             + - - - - - - - - - - - - - - - - - +\n           5 |      \
    \                             |\n             +-----------------------------------+\n\
    \           6 | Host SAP                          |\n             +-----------------------------------+\n\
    \           7 | Client SAP                        |\n             +-----------------------------------+\n\
    \           8 | Origin Session ID                 |\n             +-----------------------------------+\n\
    \           9 |                                   |\n             + - - - - -\
    \ - - - - - - - - - - - - +\n           10|                                  \
    \ |\n             + - - - - - - - - - - - - - - - - - +\n           11|      \
    \                             |\n             +-----------------------------------+\n\
    \           12| Target Session ID                 |\n             + - - - - -\
    \ - - - - - - - - - - - - +\n           13|                                  \
    \ |\n             + - - - - - - - - - - - - - - - - - +\n           14|      \
    \                             |\n             + - - - - - - - - - - - - - - -\
    \ - - +\n           15|                                   |\n             +-----------------------------------+\n\
    \           16| Largest Frame Size                |\n             +-----------------------------------+\n\
    \           17| Initial Window size               |\n             +-----------------------------------+\n\
    \           18| Reserved                          |\n             + - - - - -\
    \ - - - - - - - - - - - - +\n           19|                                  \
    \ |\n             +-----------------------------------+\n       Figure 3-6. START_DL,\
    \ DL_STARTED, and START_DL_FAILED Data\n   The Host MAC address is the address\
    \ of the target station if the\n   session is initiated from the client, or it\
    \ is the address of the\n   originating station if the session is initiated from\
    \ the server.\n   The next two fields are the Host and Client SAPs. Each is one\
    \ byte\n   long. The Host SAP is the SAP used by the station with the Host MAC\n\
    \   address. The Client SAP is the SAP used by the client.\n   The Origin Session\
    \ ID, is the ID of the originating station that\n   initiates the circuit. The\
    \ originating station uses this ID to\n   identify the newly created circuit.\
    \ Before the START_DL frame is sent\n   to the target station, the originating\
    \ station sets up a control\n   block for the circuit. This link station information\
    \ is set because\n   DRAP does not use a three-way handshake for link station\n\
    \   establishment. In the DL_STARTED and the START_DL_FAILED messages,\n   the\
    \ Origin Session ID is returned as received in the START_DL frame.\n   The Target\
    \ Session ID is set by the target station and returned in\n   the DL_STARTED message.\n\
    \   The Target Session ID is not valid for the START_DL and the\n   START_DL_FAILED\
    \ frame, and should be treated as Reserved fields. In\n   the DL_STARTED frame,\
    \ it is the session ID that is used to set up\n   this circuit by the target station.\n\
    \   The Largest Frame Size field is used to indicate the maximum frame\n   size\
    \ that can be used by the client. It is valid only when it is set\n   by the server.\
    \ The Largest Frame Size field must be set to zero when\n   a frame is sent by\
    \ the client. Both START_DL and DL_STARTED use the\n   Largest Frame Size field\
    \ and only its rightmost 6 bits are used.  The\n   format is defined in the IEEE\
    \ 802.1D Standard, Annex C, Largest Frame\n   Bits (LF). Bit 3 to bit 5 are base\
    \ bits. Bit 0 to bit 2 are extended\n   bits. The Largest Frame Size field is\
    \ not used in the START_DL_FAILED\n   frame and must be set to zero.\n       \
    \    bit   7    6    5    4    3    2    1    0\n                 r    r    b\
    \    b    b    e    e    e\n                     Figure 3-7. Largest Frame Size\n\
    \   Please note that if the client is a PU 2.1 node, the client should\n   use\
    \ the maximum I-frame size negotiated in the XID3 exchange.\n   The Initial window\
    \ size in the START_DL frame gives the receive\n   window size on the originating\
    \ side, and the target DRAP station\n   returns its receive window size in the\
    \ DL_STARTED frame. The field is\n   reserved in the START_DL_FAILED frame. The\
    \ usage of the window size\n   is the same as the one used in DLSw.  Please refer\
    \ to RFC 1795 for\n   details.\n   The last two bits are reserved for future use.\
    \ They must be set to\n   zero by the sender and ignored by the receiver.\n  \
    \ If the sender of the START_DL frame did not receive a START_DL_FAILED\n   frame\
    \ within a recommended threshold value of 60 seconds, the\n   connection is considered\
    \ unsuccessful.\n"
- title: 3.4.3.  HALT_DL, HALT_DL_NOACK, and DL_HALTED Frames
  contents:
  - "3.4.3.  HALT_DL, HALT_DL_NOACK, and DL_HALTED Frames\n   These frame types are\
    \ used by DRAP to disconnect a link station. A\n   HALT_DL frame is sent directly\
    \ to the remote workstation to indicate\n   that the sender wishes to disconnect.\
    \ When the receiver receives this\n   frame, it tears down the session that is\
    \ associated with the Original\n   Session ID and the Target Session ID provided\
    \ in the HALT_DL frame.\n   The receiver should respond with the DL_HALTED frame.\
    \ The DL_HALTED\n   frame should use the same Session ID values as the received\
    \ HALT_DL\n   message without swapping them. The HALT_DL_NOACK frame is used when\n\
    \   the response is not required.\n           +---------------+-----------------------+\n\
    \           | Field Name    | Information           |\n           +---------------+-----------------------+\n\
    \           | Message Type  | 0x0C, 0x0D, or 0x0E   |\n           +---------------+-----------------------+\n\
    \           | Packet Length | 0x10                  |\n           +---------------+-----------------------+\n\
    \        Figure 3-8. HALT_DL, HALT_DL_NOACK, and DL_HALTED Header\n          \
    \   +-----------------------------------+\n             | Field Name (Each row\
    \ is one byte) |\n             +===================================+\n       \
    \    0 | Sender Session ID                 |\n             + - - - - - - - - -\
    \ - - - - - - - - +\n           1 |                                   |\n    \
    \         + - - - - - - - - - - - - - - - - - +\n           2 |              \
    \                     |\n             + - - - - - - - - - - - - - - - - - +\n\
    \           3 |                                   |\n             +-----------------------------------+\n\
    \           4 | Receiver Session ID               |\n             + - - - - -\
    \ - - - - - - - - - - - - +\n           5 |                                  \
    \ |\n             + - - - - - - - - - - - - - - - - - +\n           6 |      \
    \                             |\n             + - - - - - - - - - - - - - - -\
    \ - - +\n           7 |                                   |\n             +-----------------------------------+\n\
    \           8 | Reserved                          |\n             + - - - - -\
    \ - - - - - - - - - - - - +\n           9 |                                  \
    \ |\n             + - - - - - - - - - - - - - - - - - +\n           10|      \
    \                             |\n             + - - - - - - - - - - - - - - -\
    \ - - +\n           11|                                   |\n             +-----------------------------------+\n\
    \       Figure 3-9. START_DL, DL_STARTED, and START_DL_FAILED Data\n"
- title: 3.4.4.  XID_FRAME, CONTACT_STN, STN_CONTACTED, INFO_FRAME, FCM_FRAME,
  contents:
  - "3.4.4.  XID_FRAME, CONTACT_STN, STN_CONTACTED, INFO_FRAME, FCM_FRAME,\n     \
    \   and DGRM_FRAME\n   These frame types are used to carry the end-to-end data\
    \ or establish\n   a circuit. The Destination Session ID is the Session ID created\
    \ in\n   the START_DL frame or the DL_STARTED frame by the receiver. The usage\n\
    \   of the flow control flag is the same as the one used in DLSw.  Please\n  \
    \ refer to RFC 1795 for details.\n           +---------------+----------------------------+\n\
    \           | Field Name    | Information                |\n           +---------------+----------------------------+\n\
    \           | Message Type  | Based on Message type      |\n           +---------------+----------------------------+\n\
    \           | Packet Length | 0x0C + length of user data |\n           +---------------+----------------------------+\n\
    \                    Figure 3-10. Generic DRAP Header\n             +-----------------------------------+\n\
    \             | Field Name (Each row is one byte) |\n             +===================================+\n\
    \           0 | Destination Session ID            |\n             + - - - - -\
    \ - - - - - - - - - - - - +\n           1 |                                  \
    \ |\n             + - - - - - - - - - - - - - - - - - +\n           2 |      \
    \                             |\n             + - - - - - - - - - - - - - - -\
    \ - - +\n           3 |                                   |\n             +-----------------------------------+\n\
    \           4 | Flow Control Flags                |\n             +-----------------------------------+\n\
    \           5 | Reserved                          |\n             + - - - - -\
    \ - - - - - - - - - - - - +\n           6 |                                  \
    \ |\n             + - - - - - - - - - - - - - - - - - +\n           7 |      \
    \                             |\n             +-----------------------------------+\n\
    \                 Figure 3-11. Generic DRAP Data Format\n"
- title: 3.4.5.  DATA_FRAME
  contents:
  - "3.4.5.  DATA_FRAME\n   This frame type is used to send connectionless SNA and\
    \ NetBIOS\n   Datagram (UI) frames that do not have a link station associated\
    \ with\n   the source and destination MAC/SAP pair. The difference between\n \
    \  DGRM_FRAME and DATA_FRAME is that DGRM_FRAME is used to send UI\n   frames\
    \ received for stations that have a link station opened, whereas\n   DATA_FRAME\
    \ is used for frames with no link station established.\n           +---------------+-----------------------------+\n\
    \           | Field Name    | Information                 |\n           +---------------+-----------------------------+\n\
    \           | Message Type  | 0x0A                        |\n           +---------------+-----------------------------+\n\
    \           | Packet Length | 0x10 + Length of user data  |\n           +---------------+-----------------------------+\n\
    \                     Figure 3-12. DATA_FRAME Header\n             +-----------------------------------+\n\
    \             | Field Name (Each row is one byte) |\n             +===================================+\n\
    \           0 | Host MAC Address                  |\n             + - - - - -\
    \ - - - - - - - - - - - - +\n           1 |                                  \
    \ |\n             + - - - - - - - - - - - - - - - - - +\n           2 |      \
    \                             |\n             + - - - - - - - - - - - - - - -\
    \ - - +\n           3 |                                   |\n             + -\
    \ - - - - - - - - - - - - - - - - +\n           4 |                          \
    \         |\n             + - - - - - - - - - - - - - - - - - +\n           5\
    \ |                                   |\n             +-----------------------------------+\n\
    \           6 | Host SAP                          |\n             +-----------------------------------+\n\
    \           7 | Client SAP                        |\n             +-----------------------------------+\n\
    \           8 | Broadcast Type                    |\n             +-----------------------------------+\n\
    \           9 | Reserved                          |\n             + - - - - -\
    \ - - - - - - - - - - - - +\n           10|                                  \
    \ |\n             + - - - - - - - - - - - - - - - - - +\n           11|      \
    \                             |\n             +-----------------------------------+\n\
    \                  Figure 3-13. DATA_FRAME Data Format\n   The definition of the\
    \ first 8 bytes is the same as the START_DL\n   frame. The Broadcast Type field\
    \ indicates the type of broadcast\n   frames in use; Single Route Broadcast, All\
    \ Route Broadcast, or\n   Directed. The target side will use the same broadcast\
    \ type. In the\n   case of Directed frame, if the RIF information is known, the\
    \ target\n   peer can send a directed frame. If not, a Single Route Broadcast\n\
    \   frame is sent.\n"
- title: 3.4.6.  CAP_XCHANGE Frame
  contents:
  - "3.4.6.  CAP_XCHANGE Frame\n   In DRAP, the capability exchange frame is used\
    \ to exchange the\n   client's information, such as its MAC address, with the\
    \ server. If a\n   DRAP client has its own MAC address defined, it should put\
    \ it in the\n   MAC address field. Otherwise, that field must be set to zero.\n\
    \   When the DRAP server receives the CAP_XCHANGE frame, it should cache\n   the\
    \ MAC address if it is non zero. The DRAP server also verifies that\n   the MAC\
    \ address is unique. The server should return a CAP_XCHANGE\n   response frame\
    \ with the MAC address supplied by the client if the MAC\n   address is accepted.\
    \ If a client does not have its own MAC address,\n   the server should assign\
    \ a MAC address to the client and put that\n   address in the CAP_XCHANGE command\
    \ frame.\n   A client should record the new MAC address assigned by the server\
    \ and\n   return a response with the assigned MAC address. If the client cannot\n\
    \   accept the assigned MAC address, another CAP_XCHANGE command with the\n  \
    \ MAC address field set to zero should be sent to the server. The\n   server should\
    \ allocate a new MAC address for this client.\n   During the capability exchange,\
    \ both the client and the server can\n   send command frames. The process stops\
    \ when either side sends a\n   CAP_XCHANGE response frame. When the response frame\
    \ is sent, the MAC\n   address in the CAP_XCHANGE frame should be the same as\
    \ the one in the\n   previous received command. The sender of the CAP_XCHANGE\
    \ response\n   agrees to use the MAC address defined in the previous command.\n\
    \   The number of CAP_XCHANGE frames that need to be exchanged is\n   determined\
    \ by the client and the server independently. When the\n   number of exchange\
    \ frames has exceeded the pre-defined number set by\n   either the server or the\
    \ client, the session should be brought down.\n   The flag is used to show the\
    \ capability of the sender. The following\n   list shows the valid flags:\n  \
    \ 0x01 NetBIOS support. If a client sets this bit on, the server will\n      \
    \  pass all NetBIOS explorers to this client. If this bit is not\n        set,\
    \ only SNA traffic will be sent to this client.\n   0x02 TCP Listen Mode support.\
    \ If a client supports TCP listen mode,\n        the server will keep the client's\
    \ MAC and IP addresses even\n        after the TCP session is down. The cached\
    \ information will be\n        used for server to connect out. If a client does\
    \ not support\n        TCP listen mode, the cache will be deleted as soon as the\
    \ TCP\n        session is down.\n   0x04 Command/Response. If this bit is set,\
    \ it is a command,\n        otherwise, it is a response.\n   The values 0x01 and\
    \ 0x02 are used only by the client. When a server\n   sends the command/response\
    \ to a client, the server does not return\n   these values.\n   Starting with\
    \ the Reserved field, implementors can optionally\n   implement the Capability\
    \ Exchange Control Vector. Each Capability\n   Exchange Control Vector consists\
    \ of three fields: Length (1 byte),\n   Type (1 byte), and Data (Length - 2 bytes).\
    \ Two types of Control\n   Vectors are defined: SAP_LIST and VENDOR_CODE (described\
    \ below). To\n   ensure compatibility, implementors should ignore the unknown\
    \ Control\n   Vectors instead of treating them as errors.\n   0x01 SAP_LIST. Length:\
    \ 2+n bytes, where n ranges from 1 to 16.\n      This control vector lists the\
    \ SAPs that the client can support.\n      The maximum number of SAPs a client\
    \ can define is 16. Therefore,\n      the length of this Control Vector ranges\
    \ from 3 to 18. If the\n      SAP_LIST is not specified in the capability exchange,\
    \ the server\n      assumes that the client can support all the SAP values. For\n\
    \      example, if a client can only support SAP 4 and 8, then the\n      following\
    \ Control Vectors should be sent: \"0x04, 0x01, 0x04,\n      0x08\". The first\
    \ byte indicates the length of 4. The second byte\n      indicates the control\
    \ vector type of SAP_LIST. The last two bytes\n      indicate the supported SAP\
    \ values; 0x04 and 0x08. This Control\n      Vector is used only by the client.\
    \ If the server accepts this\n      Control Vector, it must return the same Control\
    \ Vector to the\n      client.\n   0x02 VENDOR_CODE. Length: 6 bytes.\n      Each\
    \ vendor is assigned a vendor code that identifies the vendor.\n      This Control\
    \ Vector does not require a response.\n   After the receiver responds to a Control\
    \ Vector, if the capability\n   exchange is not done, the sender does not have\
    \ to send the same\n   Control Vector again.\n           +---------------+-----------------------+\n\
    \           | Field Name    | Information           |\n           +---------------+-----------------------+\n\
    \           | Message Type  | 0x12                  |\n           +---------------+-----------------------+\n\
    \           | Packet Length | 0x1C                  |\n           +---------------+-----------------------+\n\
    \                    Figure 3-14. CAP_XCHANGE Header\n             +-----------------------------------+\n\
    \             | Field Name (Each row is one byte) |\n             +===================================+\n\
    \           0 | MAC Address                       |\n             + - - - - -\
    \ - - - - - - - - - - - - +\n           1 |                                  \
    \ |\n             + - - - - - - - - - - - - - - - - - +\n           2 |      \
    \                             |\n             + - - - - - - - - - - - - - - -\
    \ - - +\n           3 |                                   |\n             + -\
    \ - - - - - - - - - - - - - - - - +\n           4 |                          \
    \         |\n             + - - - - - - - - - - - - - - - - - +\n           5\
    \ |                                   |\n             +-----------------------------------+\n\
    \           6 | Flag                              |\n             +-----------------------------------+\n\
    \           7 | Reserved                          |\n             +-----------------------------------+\n\
    \                  Figure 3-15. CAP_XCHANGE Data Format\n"
- title: 3.4.7.  CLOSE_PEER_REQ Frames
  contents:
  - "3.4.7.  CLOSE_PEER_REQ Frames\n   This frame is used for peer connection management\
    \ and contains a\n   reason code field. The following list describes the valid\
    \ reason\n   codes:\n   0x01 System shutdown. This indicates shutdown in progress.\n\
    \   0x02 Suspend. This code is used when there is no traffic between the\n   \
    \   server and the client, and the server or the client wishes to\n      suspend\
    \ the TCP session. When the TCP session is suspended, all\n      circuits should\
    \ remain intact. The TCP session should be re-\n      established when new user\
    \ data needs to be sent. When the TCP\n      session is re-established, there\
    \ is no need to send the\n      CAP_XCHANGE frame again.\n   0x03 No MAC address\
    \ available. This code is sent by the server when\n      there is no MAC address\
    \ is available from the MAC address pool.\n           +---------------+-----------------------+\n\
    \           | Field Name    | Information           |\n           +---------------+-----------------------+\n\
    \           | Message Type  | 0x13                  |\n           +---------------+-----------------------+\n\
    \           | Packet Length | 0x08                  |\n           +---------------+-----------------------+\n\
    \                   Figure 3-16. CLOSE_PEER_REQ Header\n             +-----------------------------------+\n\
    \             | Field Name (Each row is one byte) |\n             +===================================+\n\
    \           0 | Reason Code                       |\n             +-----------------------------------+\n\
    \           1 | Reserved                          |\n             + - - - - -\
    \ - - - - - - - - - - - - +\n           2 |                                  \
    \ |\n             + - - - - - - - - - - - - - - - - - +\n           3 |      \
    \                             |\n             +-----------------------------------+\n\
    \                Figure 3-17. CLOSE_PEER_REQ Data Format\n"
- title: 3.4.8.  CLOSE_PEER_RSP, PEER_TEST_REQ, and PEER_TEST_RSP Frames
  contents:
  - "3.4.8.  CLOSE_PEER_RSP, PEER_TEST_REQ, and PEER_TEST_RSP Frames\n   These three\
    \ frames are used for peer connection management. There is\n   no data associated\
    \ with them.\n   o CLOSE_PEER_RSP\n     CLOSE_PEER_RSP is the response for CLOSE_PEER_REQ.\n\
    \   o PEER_TEST_REQ and PEER_TEST_RSP\n     PEER_TEST_REQ and PEER_TEST_RSP are\
    \ used for peer level keepalive.\n     Implementing PEER_TEST_REQ is optional,\
    \ but PEER_TEST_RSP must be\n     implemented to respond to the PEER_TEST_REQ\
    \ frame. When a\n     PEER_TEST_REQ frame is sent to the remote station, the sender\n\
    \     expects to receive the PEER_TEST_RSP frame in a predefined time\n     interval\
    \ (the recommended value is 60 seconds). If the\n     PEER_TEST_RSP frame is not\
    \ received in the predefined time\n     interval, the sender can send the PEER_TEST_REQ\
    \ frame again. If a\n     predefined number of PEER_TEST_REQ frames is sent to\
    \ the remote\n     station, but no PEER_TEST_RSP frame is received (the recommended\n\
    \     number is 3), the sender should close the TCP session with this\n     remote\
    \ station and terminate all associated circuits.\n           +---------------+-----------------------+\n\
    \           | Field Name    | Information           |\n           +---------------+-----------------------+\n\
    \           | Message Type  | 0x14, 0x1D, or 0x1E   |\n           +---------------+-----------------------+\n\
    \           | Packet Length | 0x04                  |\n           +---------------+-----------------------+\n\
    \   Figure 3-18. CLOSE_PEER_RSP, PEER_TEST_REQ, and PEER_TEST_RSP DRAP\n"
- title: 4.  References
  contents:
  - "4.  References\n   [1] Wells, L., Chair, and A. Bartky, Editor, \"DLSw: Switch-to-Switch\n\
    \       Protocol\", RFC 1795, October 1993.\n   [2] IEEE 802.1D Standard.\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Steve T. Chiang\n   InterWorks Business Unit\n   Cisco\
    \ Systems, Inc.\n   170 Tasman Drive\n   San Jose, CA 95134\n   Phone: (408) 526-5189\n\
    \   EMail: schiang@cisco.com\n   Joseph S. Lee\n   InterWorks Business Unit\n\
    \   Cisco Systems, Inc.\n   170 Tasman Drive\n   San Jose, CA 95134\n   Phone:\
    \ (408) 526-5232\n   EMail: jolee@cisco.com\n   Hideaki Yasuda\n   System Product\
    \ Center\n   Network Products Department\n   Network Software Products Section\
    \ B\n   Mitsubishi Electric Corp.\n   Information Systems Engineering Center\n\
    \   325, Kamimachiya Kamakura Kanagawa 247, Japan\n   Phone: +81-467-47-2120\n\
    \   EMail: yasuda@eme068.cow.melco.co.jp\n"
