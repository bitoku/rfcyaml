- contents:
  - '    Bidirectional Forwarding Detection (BFD) Multipoint Active Tails

    '
  title: __initial_text__
- contents:
  - "Abstract\n   This document describes active tail extensions to the Bidirectional\n
    \  Forwarding Detection (BFD) protocol for multipoint networks.\n"
  title: Abstract
- contents:
  - "Status of This Memo\n   This is an Internet Standards Track document.\n   This
    document is a product of the Internet Engineering Task Force\n   (IETF).  It represents
    the consensus of the IETF community.  It has\n   received public review and has
    been approved for publication by the\n   Internet Engineering Steering Group (IESG).
    \ Further information on\n   Internet Standards is available in Section 2 of RFC
    7841.\n   Information about the current status of this document, any errata,\n
    \  and how to provide feedback on it may be obtained at\n   https://www.rfc-editor.org/info/rfc8563.\n"
  title: Status of This Memo
- contents:
  - "Copyright Notice\n   Copyright (c) 2019 IETF Trust and the persons identified
    as the\n   document authors.  All rights reserved.\n   This document is subject
    to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n
    \  (https://trustee.ietf.org/license-info) in effect on the date of\n   publication
    of this document.  Please review these documents\n   carefully, as they describe
    your rights and restrictions with respect\n   to this document.  Code Components
    extracted from this document must\n   include Simplified BSD License text as described
    in Section 4.e of\n   the Trust Legal Provisions and are provided without warranty
    as\n   described in the Simplified BSD License.\n"
  title: Copyright Notice
- contents:
  - "Table of Contents\n   1.  Introduction  . . . . . . . . . . . . . . . . . . .
    . . . . .   3\n   2.  Terminology and Acronyms  . . . . . . . . . . . . . . .
    . . .   3\n   3.  Keywords  . . . . . . . . . . . . . . . . . . . . . . . . .
    .   3\n   4.  Overview  . . . . . . . . . . . . . . . . . . . . . . . . . .   4\n
    \  5.  Operational Scenarios . . . . . . . . . . . . . . . . . . . .   5\n     5.1.
    \ No Head Notification  . . . . . . . . . . . . . . . . . .   5\n     5.2.  Head
    Notification . . . . . . . . . . . . . . . . . . . .   5\n       5.2.1.  Head
    Notification without Polling . . . . . . . . . .   5\n       5.2.2.  Head Notification
    and Tail Solicitation with\n               Multipoint Polling  . . . . . . . .
    . . . . . . . . .   6\n       5.2.3.  Head Notification with Composite Polling
    \ . . . . . .   6\n   6.  Protocol Details  . . . . . . . . . . . . . . . . .
    . . . . .   7\n     6.1.  Multipoint Client Session . . . . . . . . . . . . .
    . . .   8\n     6.2.  Multipoint Client Session Failure . . . . . . . . . . .
    .   8\n     6.3.  State Variables . . . . . . . . . . . . . . . . . . . . .   8\n
    \      6.3.1.  New State Variables . . . . . . . . . . . . . . . . .   8\n       6.3.2.
    \ New State Variable Value  . . . . . . . . . . . . . .   9\n       6.3.3.  State
    Variable Initialization and Maintenance . . . .  10\n     6.4.  Controlling Multipoint
    BFD Options  . . . . . . . . . . .  11\n     6.5.  State Machine . . . . . . .
    . . . . . . . . . . . . . . .  11\n     6.6.  Session Establishment . . . . .
    . . . . . . . . . . . . .  12\n     6.7.  Discriminators and Packet Demultiplexing
    \ . . . . . . . .  12\n     6.8.  Controlling Tail Packet Transmission  . . .
    . . . . . . .  12\n     6.9.  Soliciting the Tails  . . . . . . . . . . . . .
    . . . . .  13\n     6.10. Verifying Connectivity to Specific Tails  . . . . .
    . . .  13\n     6.11. Detection Times . . . . . . . . . . . . . . . . . . . .
    .  14\n     6.12. MultipointClient Down/AdminDown Sessions  . . . . . . . .  15\n
    \    6.13. Base BFD for Multipoint Networks Specification Text\n           Replacement
    . . . . . . . . . . . . . . . . . . . . . . .  15\n       6.13.1.  Reception of
    BFD Control Packets . . . . . . . . . .  15\n       6.13.2.  Demultiplexing BFD
    Control Packets . . . . . . . . .  16\n       6.13.3.  Transmitting BFD Control
    Packets . . . . . . . . . .  16\n   7.  Assumptions . . . . . . . . . . . . .
    . . . . . . . . . . . .  17\n   8.  Operational Considerations  . . . . . . .
    . . . . . . . . . .  18\n   9.  IANA Considerations . . . . . . . . . . . . .
    . . . . . . . .  18\n   10. Security Considerations . . . . . . . . . . . . .
    . . . . . .  18\n   11. Normative References  . . . . . . . . . . . . . . . .
    . . . .  19\n   Acknowledgments . . . . . . . . . . . . . . . . . . . . . . .
    . .  19\n   Contributors  . . . . . . . . . . . . . . . . . . . . . . . . . .
    \ 19\n   Authors' Addresses  . . . . . . . . . . . . . . . . . . . . . . .  20\n"
  title: Table of Contents
- contents:
  - "1.  Introduction\n   This application of BFD is an extension to Multipoint BFD
    [RFC8562],\n   which allows tails to notify the head of the lack of multipoint\n
    \  connectivity.  As a further option, heads can request a notification\n   from
    the tails by means of a polling mechanism.  Notification to the\n   head can be
    enabled for all tails, or for only a subset of the tails.\n   The goal of this
    application is for the head to have reasonably rapid\n   knowledge of tails that
    have lost connectivity from the head.\n   Since scaling is a primary concern (particularly
    state explosion\n   toward the head), it is required that the head be in control
    of all\n   timing aspects of the mechanism and that BFD packets from the tails\n
    \  to the head not be synchronized.\n   Throughout this document, the term \"multipoint\"
    is defined as a\n   mechanism by which one or more systems receive packets sent
    by a\n   single sender.  This specifically includes such things as IP\n   multicast
    and point-to-multipoint MPLS.\n   The term \"connectivity\" in this document is
    not being used in the\n   context of connectivity verification in a transport
    network but as an\n   alternative to \"continuity\", i.e., the existence of a
    path between\n   the sender and the receiver.\n   This document effectively modifies
    and adds to Sections 5.12 and 5.13\n   of the base BFD multipoint networks specification
    [RFC8562].\n"
  title: 1.  Introduction
- contents:
  - "2.  Terminology and Acronyms\n   BFD: Bidirectional Forwarding Detection\n   c-poll:
    Composite Poll\n   m-poll: Multipoint Poll\n"
  title: 2.  Terminology and Acronyms
- contents:
  - "3.  Keywords\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\",
    \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"NOT RECOMMENDED\",
    \"MAY\", and\n   \"OPTIONAL\" in this document are to be interpreted as described
    in\n   BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all\n   capitals,
    as shown here.\n"
  title: 3.  Keywords
- contents:
  - "4.  Overview\n   A head may wish to be alerted of the tails' connectivity (or
    lack\n   thereof), and there are a number of options to achieve that.  First,\n
    \  if all that is needed is a best-effort failure notification, as\n   discussed
    in Section 5.2.1, the tails can send unsolicited unicast\n   BFD Control packets
    to the head when the path fails, as described in\n   Section 6.4.\n   If the head
    wishes to know of the active tails on the multipoint\n   path, it may send a multipoint
    BFD Control packet with the Poll (P)\n   bit set, which will induce the tails
    to return a unicast BFD Control\n   packet with the Final (F) bit set (see a detailed
    description in\n   Section 5.2.2).  The head can then create BFD session state
    for each\n   of the tails that have multipoint connectivity.  If the head sends\n
    \  such a packet on occasion, it can keep track of which tails answer,\n   thus
    providing a more deterministic mechanism for detecting which\n   tails fail to
    respond (implying a loss of multipoint connectivity).\n   In this document, this
    method is referred to as the Multipoint Poll\n   (m-poll).\n   If the head wishes
    the definite indication of the tails'\n   connectivity, it may do all of the above,
    but if it detects that a\n   tail did not answer the previous multipoint poll,
    it may initiate a\n   Demand mode Poll Sequence as a unicast to that tail (see
    a detailed\n   description in Section 5.2.3).  This covers the case where either
    the\n   multipoint poll or the single reply is also lost in transit.  If\n   desired,
    the head may Poll one or more tails proactively to track the\n   tails' connectivity.
    \ In this document, the method that combines the\n   use of multipoint and unicast
    polling of tails by the head is\n   referred to as the Composite Poll (c-poll).\n
    \  If the awareness of the state of some nodes is more important for the\n   head,
    in the sense that the head needs to detect the lack of\n   multipoint connectivity
    to a subset of tails at a different rate, the\n   head may transmit unicast BFD
    Polls to that subset of tails.  In this\n   case, the timing may be independent
    on a tail-by-tail basis.\n   Individual tails may be configured so that they never
    send BFD\n   Control packets to the head.  Such tails will never be known to the\n
    \  head but will still be able to detect multipoint path failures from\n   the
    head.\n"
  title: 4.  Overview
- contents:
  - "5.  Operational Scenarios\n   It is worth analyzing how this protocol reacts
    to various scenarios.\n   There are three path components present: namely, the
    multipoint path,\n   the forward unicast path (from the head to a particular tail),
    and\n   the reverse unicast path (from a tail to the head).  There are also\n
    \  four options as to how the head is notified about failures from the\n   tail.
    \ For the different modes described below, the setting of new\n   state variables
    are given even if these are only introduced later in\n   the document (see Section
    6.3).\n"
  - contents:
    - "5.1.  No Head Notification\n   In this scenario, only the multipoint path is
      used and none of the\n   others matter.  A failure in the multipoint path will
      result in the\n   tail noticing the failure within a Detection Time, and the
      head will\n   remain ignorant of the tail state.  This mode emulates the behavior\n
      \  described in [RFC8562].  In this mode, bfd.SessionType is\n   MultipointTail,
      and the variable bfd.SilentTail (see Section 6.3.1)\n   MUST be set to 1.  If
      bfd.SessionType is MultipointHead or\n   MultipointClient, bfd.ReportTailDown
      MUST be set to zero.  The head\n   MAY set bfd.RequiredMinRxInterval to zero
      and thus suppress tails\n   sending any BFD Control packets.\n"
    title: 5.1.  No Head Notification
  - contents:
    - "5.2.  Head Notification\n   In these scenarios, the tail sends unsolicited
      or solicited BFD\n   packets in response to the detection of a multipoint path
      failure.\n   All these scenarios have common settings:\n   o  if bfd.SessionType
      is MultipointTail, the variable bfd.SilentTail\n      (see Section 6.3.1) MUST
      be set to zero;\n   o  if bfd.SessionType is MultipointHead or MultipointClient,\n
      \     bfd.ReportTailDown MUST be set to 1;\n   o  the head MUST set bfd.RequiredMinRxInterval
      to nonzero and thus\n      allow tails to send BFD Control packets.\n"
    - contents:
      - "5.2.1.  Head Notification without Polling\n   In this scenario, the tail
        sends unsolicited BFD packets in response\n   to the detection of a multipoint
        path failure.  It uses the reverse\n   unicast path, but not the forward unicast
        path.\n   If the multipoint path fails but the reverse unicast path stays
        up,\n   the tail will detect the failure within a Detection Time, and the\n
        \  head will know about it within one reverse packet time (since the\n   notification
        is delayed).\n   If both the multipoint path and the reverse unicast paths
        fail, the\n   tail will detect the failure, but the head will remain unaware
        of it.\n"
      title: 5.2.1.  Head Notification without Polling
    - contents:
      - "5.2.2.  Head Notification and Tail Solicitation with Multipoint Polling\n
        \  In this scenario, the head sends occasional multipoint Polls in\n   addition
        to (or in lieu of) non-Poll multipoint BFD Control packets,\n   expecting
        the tails to reply with Final.  This also uses the reverse\n   unicast path,
        but not the forward unicast path.\n   If the multipoint path fails but the
        reverse unicast path stays up,\n   the tail will detect the failure within
        a Detection Time, and the\n   head will know about it within one reverse packet
        time (the\n   notification is delayed to avoid synchronization of the tails).\n
        \  If both the multipoint path and the reverse unicast paths fail, the\n   tail
        will detect the failure, but the head will remain unaware of\n   this fact.\n
        \  If the reverse unicast path fails but the multipoint path stays up,\n   the
        head will see the BFD session fail, but the state of the\n   multipoint path
        will be unknown to the head.  The tail will continue\n   to receive multipoint
        data traffic.\n   If either the multipoint Poll or the unicast reply is lost
        in\n   transit, the head will see the BFD session fail, but the state of the\n
        \  multipoint path will be unknown to the head.  The tail will continue\n
        \  to receive multipoint data traffic.\n"
      title: 5.2.2.  Head Notification and Tail Solicitation with Multipoint Polling
    - contents:
      - "5.2.3.  Head Notification with Composite Polling\n   In this scenario, the
        head sends occasional multipoint Polls in\n   addition to (or in lieu of)
        non-Poll multipoint BFD Control packets,\n   expecting the tails to reply
        with Final.  If a tail that had\n   previously replied to a multipoint Poll
        fails to reply (or if the\n   head simply wishes to verify tail connectivity),
        the head issues a\n   unicast Poll Sequence to the tail.  This scenario makes
        use of all\n   three paths.  In this mode for bfd.SessionType of MultipointTail,\n
        \  variable bfd.SilentTail (see Section 6.3.1) MUST be set to zero.\n   If
        the multipoint path fails but the two unicast paths stay up, the\n   tail
        will detect the failure within a Detection Time, and the head\n   will know
        about it within one reverse packet time (since the\n   notification is delayed).
        \ Note that the reverse packet time may be\n   smaller in this case if the
        head has previously issued a unicast Poll\n   (since the tail will not delay
        transmission of the notification in\n   this case).\n   If both the multipoint
        path and the reverse unicast paths fail\n   (regardless of the state of the
        forward unicast path), the tail will\n   detect the failure, but the head
        will remain unaware of this fact.\n   The head will detect a BFD session failure
        to the tail but cannot\n   make a determination about the state of the tail's
        multipoint\n   connectivity.\n   If the forward unicast path fails but the
        reverse unicast path stays\n   up, the head will detect a BFD session failure
        to the tail if it\n   happens to send a unicast Poll sequence but cannot make
        a\n   determination about the state of the tail's multipoint connectivity.\n
        \  If the multipoint path to the tail fails prior to any unicast Poll\n   being
        sent, the tail will detect the failure within a Detection Time,\n   and the
        head will know about it within one reverse packet time (since\n   the notification
        is delayed).\n   If the multipoint path stays up but the reverse unicast path
        fails,\n   the head will see the particular MultipointClient session fail
        if it\n   happens to send a Poll Sequence, but the state of the multipoint
        path\n   will be unknown to the head.  The tail will continue to receive\n
        \  multipoint data traffic.\n   If the multipoint path and the reverse unicast
        path both stay up but\n   the forward unicast path fails, neither side will
        notice this failure\n   as long as a unicast Poll Sequence is never sent by
        the head.  If the\n   head sends a unicast Poll Sequence, the head will detect
        the failure\n   in the forward unicast path.  The state of the multipoint
        path will\n   be determined by the multipoint Poll.  The tail will continue
        to\n   receive multipoint data traffic.\n"
      title: 5.2.3.  Head Notification with Composite Polling
    title: 5.2.  Head Notification
  title: 5.  Operational Scenarios
- contents:
  - "6.  Protocol Details\n   This section describes the operation of the BFD Multipoint
    active\n   tail in detail.  This section modifies Section 4 of [RFC8562] as\n
    \  follows:\n   o  Section 6.3 introduces new state variables and modifies the
    usage\n      of a few existing ones;\n   o  Section 6.13 replaces the corresponding
    sections in the base BFD\n      for multipoint networks specification.\n"
  - contents:
    - "6.1.  Multipoint Client Session\n   If the head is keeping track of some or
      all of the tails, it has a\n   session of type MultipointClient per tail that
      it cares about.  All\n   of the MultipointClient sessions for tails on a particular
      multipoint\n   path are associated with the MultipointHead session to which
      the\n   clients are listening.  A BFD Poll Sequence may be sent over a\n   MultipointClient
      session to a tail if the head wishes to verify\n   connectivity.  These sessions
      receive any BFD Control packets sent by\n   the tails and MUST NOT transmit
      periodic BFD Control packets other\n   than Poll Sequences (since periodic transmission
      is always done by\n   the MultipointHead session).  Note that the settings of
      all BFD\n   variables in a MultipointClient session for a particular tail\n
      \  override the corresponding settings in the MultipointHead session.\n"
    title: 6.1.  Multipoint Client Session
  - contents:
    - "6.2.  Multipoint Client Session Failure\n   If a MultipointClient session receives
      a BFD Control packet from the\n   tail with state Down or AdminDown, the head
      reliably knows that the\n   tail has lost multipoint connectivity.  If the Detection
      Time expires\n   on a MultipointClient session, it is ambiguous as to whether
      the\n   multipoint connectivity failed or whether there was a unicast path\n
      \  problem in one direction or the other, so the head does not reliably\n   know
      the tail's state.\n"
    title: 6.2.  Multipoint Client Session Failure
  - contents:
    - "6.3.  State Variables\n   BFD Multipoint active tail introduces new state variables
      and\n   modifies the usage of a few existing ones defined in Section 5.4 of\n
      \  [RFC8562].\n"
    - contents:
      - "6.3.1.  New State Variables\n   A few state variables are added in support
        of multipoint BFD active\n   tail.\n      bfd.SilentTail\n         If zero,
        a tail may send packets to the head according to other\n         parts of
        this specification.  Setting this to 1 allows tails to\n         be provisioned
        to always be silent, even when the head is\n         soliciting traffic from
        the tails.  This can be useful, for\n         example, in deployments of a
        large number of tails when the\n         head wishes to track the state of
        a subset of them.  This\n         variable MUST be initialized based on configuration.
        \ The\n         default value MUST be 1.\n         This variable is only pertinent
        when bfd.SessionType is\n         MultipointTail and SHOULD NOT be modified
        after the\n         MultipointTail session has been created.\n      bfd.ReportTailDown\n
        \        Set to 1 if the head wishes tails to notify the head, via\n         periodic
        BFD Control packets, when they see the BFD session\n         fail.  If zero,
        the tail will never send periodic BFD Control\n         packets, and the head
        will not be notified of session failures\n         by the tails.  This variable
        MUST be initialized based on\n         configuration.  The default value MUST
        be zero.\n         This variable is only pertinent when bfd.SessionType is\n
        \        MultipointHead or MultipointClient.\n      bfd.UnicastRcvd\n         Set
        to 1 if a tail has received a unicast BFD Control packet\n         from the
        head while being in Up state.  This variable MUST be\n         set to zero
        if the session transitions from Up state to some\n         other state.\n
        \        This variable MUST be initialized to zero.\n         This variable
        is only pertinent when bfd.SessionType is\n         MultipointTail.\n"
      title: 6.3.1.  New State Variables
    - contents:
      - "6.3.2.  New State Variable Value\n   A new state variable value being added
        to:\n   bfd.SessionType\n      The type of this session as defined in [RFC7880].
        \ A new value\n      introduced is:\n         MultipointClient: A session
        on the head that tracks the state\n         of an individual tail, when desirable.\n
        \     This variable MUST be initialized to the appropriate type when the\n
        \     session is created, according to the rules in Section 5.4 of\n      [RFC8562].\n"
      title: 6.3.2.  New State Variable Value
    - contents:
      - "6.3.3.  State Variable Initialization and Maintenance\n   Some state variables
        defined in Section 6.8.1 of [RFC5880] need to be\n   initialized or manipulated
        differently depending on the session type.\n   The values of some of these
        variables relate to those of the same\n   variables of a MultipointHead session
        (see Section 5.4.2 of\n   [RFC8562]).\n      bfd.LocalDiscr\n         For
        session type MultipointClient, this variable MUST always\n         match the
        value of bfd.LocalDiscr in the associated\n         MultipointHead session.\n
        \     bfd.DesiredMinTxInterval\n         For session type MultipointClient,
        this variable MUST always\n         match the value of bfd.DesiredMinTxInterval
        in the associated\n         MultipointHead session.\n      bfd.RequiredMinRxInterval\n
        \        It MAY be set to zero at the head BFD system to suppress\n         traffic
        from the tails.  Setting it to zero in the\n         MultipointHead session
        suppresses traffic from all tails; the\n         setting in a MultipointClient
        session suppresses traffic from a\n         single tail.\n      bfd.DemandMode\n
        \        This variable MUST be initialized to 1 for session types\n         MultipointClient.\n
        \     bfd.DetectMult\n         For session type MultipointClient, this variable
        MUST always\n         match the value of bfd.DetectMult in the associated\n
        \        MultipointHead session.\n"
      title: 6.3.3.  State Variable Initialization and Maintenance
    title: 6.3.  State Variables
  - contents:
    - "6.4.  Controlling Multipoint BFD Options\n   The state variables defined above
      are used to choose which\n   operational options are active.\n   The most basic
      form of the BFD operation in multipoint networks is\n   explained in [RFC8562].
      \ In this scenario, BFD Control packets flow\n   only from the head, and no
      tracking of tail state at the head is\n   desired.  That can be accomplished
      by setting bfd.ReportTailDown to\n   zero in the MultipointHead session (Section
      5.1).\n   If the head wishes to know of active tails, it sends multipoint Polls\n
      \  as needed.  Previously known tails that don't respond to the Polls\n   will
      be detected (as per Section 5.2.2).\n   If the head wishes to request a notification
      from the tails when they\n   lose connectivity, it sets bfd.ReportTailDown to
      1 in either the\n   MultipointHead session (if such notification is desired
      from all\n   tails) or the MultipointClient session (if notification is desired\n
      \  from a particular tail).  Note that the setting of this variable in a\n   MultipointClient
      session for a particular tail overrides the setting\n   in the MultipointHead
      session.\n   If the head wishes to verify the state of a tail on an ongoing
      basis,\n   it sends a Poll Sequence from the MultipointClient session associated\n
      \  with that tail as needed.  This has the effect of eliminating the\n   initial
      delay, as described in Section 6.13.3, that the tail would\n   otherwise insert
      prior to transmission of the packet; thus, the head\n   may have notification
      of the session failure more quickly when\n   comparing with use of m-poll.\n
      \  If a tail wishes to operate silently (sending no BFD Control packets\n   to
      the head), it sets bfd.SilentTail to 1 in the MultipointTail\n   session.  This
      allows a tail to be silent independent of the settings\n   on the head.\n"
    title: 6.4.  Controlling Multipoint BFD Options
  - contents:
    - "6.5.  State Machine\n   Though the state transitions for the state machine,
      as defined in\n   Section 5.5 of [RFC8562], for a session type MultipointHead
      are only\n   administratively driven, the state machine for a session of type\n
      \  MultipointClient is the same, and the diagram is applicable.\n"
    title: 6.5.  State Machine
  - contents:
    - "6.6.  Session Establishment\n   If BFD Control packets are received at the
      head, they are\n   demultiplexed to sessions of type MultipointClient, which
      represent\n   the set of tails that the head is interested in tracking.  These\n
      \  sessions will typically also be established dynamically based on the\n   receipt
      of BFD Control packets.  The head has broad latitude in\n   choosing which tails
      to track, if any, without affecting the basic\n   operation of the protocol.
      \ The head directly controls whether or not\n   tails are allowed to send BFD
      Control packets back to the head by\n   setting bfd.RequiredMinRxInterval to
      zero in a MultipointHead or a\n   MultipointClient session.\n"
    title: 6.6.  Session Establishment
  - contents:
    - "6.7.  Discriminators and Packet Demultiplexing\n   When the tails send BFD
      Control packets to the head from the\n   MultipointTail session, the contents
      of Your Discriminator (the\n   discriminator received from the head) will not
      be sufficient for the\n   head to demultiplex the packet, since the same value
      will be received\n   from all tails on the multicast tree.  In this case, the
      head MUST\n   demultiplex packets based on the source address and the value
      of Your\n   Discriminator, which together uniquely identify the tail and the\n
      \  multipoint path.\n   When the head sends unicast BFD Control packets to a
      tail from a\n   MultipointClient session, the value of Your Discriminator will
      be\n   valid, and the tail MUST demultiplex the packet based solely on Your\n
      \  Discriminator.\n"
    title: 6.7.  Discriminators and Packet Demultiplexing
  - contents:
    - "6.8.  Controlling Tail Packet Transmission\n   As the fan-in from the tails
      to the head may be very large, it is\n   critical that the flow of BFD Control
      packets from the tails is\n   controlled.\n   The head always operates in Demand
      mode.  This means that no tail\n   will send an asynchronous BFD Control packet
      as long as the session\n   is Up.\n   The value of Required Min Rx Interval
      received by a tail in a unicast\n   BFD Control packet, if any, always takes
      precedence over the value\n   received in multipoint BFD Control packets.  This
      allows the packet\n   rate from individual tails to be controlled separately
      as desired by\n   sending a BFD Control packet from the corresponding MultipointClient\n
      \  session.  This also eliminates the random delay, as discussed in\n   Section
      6.13.3, prior to transmission from the tail that would\n   otherwise be inserted,
      reducing the latency of reporting a failure to\n   the head.\n   If the head
      wishes to suppress traffic from the tails when they\n   detect a session failure,
      it MAY set bfd.RequiredMinRxInterval to\n   zero, which is a reserved value
      that indicates that the sender wishes\n   to receive no periodic traffic.  This
      can be set in the\n   MultipointHead session (suppressing traffic from all tails),
      or it\n   can be set in a MultipointClient session (suppressing traffic from\n
      \  only a single tail).\n   Any tail may be provisioned to never send *any*
      BFD Control packets\n   to the head by setting bfd.SilentTail to 1.  This provides
      a\n   mechanism by which only a subset of tails reports their session\n   status
      to the head.\n"
    title: 6.8.  Controlling Tail Packet Transmission
  - contents:
    - "6.9.  Soliciting the Tails\n   If the head wishes to know of the active tails,
      the MultipointHead\n   session can send a BFD Control packet as specified in
      Section 6.13.3,\n   with the Poll (P) bit set to 1.  This will cause all of
      the tails to\n   reply with a unicast BFD Control Packet, randomized across
      one packet\n   interval.\n   The decision as to when to send a multipoint Poll
      is outside the\n   scope of this specification.  However, it MUST NOT be sent
      more often\n   than the regular multipoint BFD Control packet.  Since the tail
      will\n   treat a multipoint Poll like any other multipoint BFD Control packet,\n
      \  Polls may be sent in lieu of non-Poll packets.\n   Soliciting the tails also
      starts the Detection Timer for each of the\n   associated MultipointClient sessions,
      which will cause those sessions\n   to time out if the associated tails do not
      respond.\n   Note that for this mechanism to work properly, the Detection Time\n
      \  (which is equal to bfd.DesiredMinTxInterval) MUST be greater than the\n   round-trip
      time of BFD Control packets from the head to the tail (via\n   the multipoint
      path) and back (via a unicast path).  See Section 6.11\n   for more details.\n"
    title: 6.9.  Soliciting the Tails
  - contents:
    - "6.10.  Verifying Connectivity to Specific Tails\n   If the head wishes to verify
      connectivity to a specific tail, the\n   corresponding MultipointClient session
      can send a BFD Poll Sequence\n   to said tail.  This might be done in reaction
      to the expiration of\n   the Detection Timer (the tail didn't respond to a multipoint
      Poll),\n   or it might be done on a proactive basis.\n   The interval between
      transmitted packets in the Poll Sequence MUST be\n   calculated as specified
      in the base BFD specification [RFC5880] (the\n   greater of bfd.DesiredMinTxInterval
      and bfd.RemoteMinRxInterval).\n   The value transmitted in Required Min RX Interval
      will be used by the\n   tail (rather than the value received in any multipoint
      packet) when\n   it transmits BFD Control packets to the head to notify it of
      a\n   session failure, and the transmitted packets will not be delayed.\n   This
      value can potentially be set much lower than in the multipoint\n   case, in
      order to speed up a notification to the head, since the\n   value will be used
      only by the single tail.  This value (and the lack\n   of delay) are \"sticky\",
      in that once the tail receives it, it will\n   continue to use it indefinitely.
      \ Therefore, if the head no longer\n   wishes to single out the tail, it SHOULD
      reset the timer to the\n   default by sending a Poll Sequence with the same
      value of Required\n   Min Rx Interval as is carried in the multipoint packets,
      or it MAY\n   reset the tail session by sending a Poll Sequence with state\n
      \  AdminDown (after the completion of which the session will come back\n   up).\n
      \  Note that a failure of the head to receive a response to a Poll\n   Sequence
      does not necessarily mean that the tail has lost multipoint\n   connectivity,
      though a reply to a Poll Sequence does reliably\n   indicate connectivity or
      lack thereof (by virtue of the tail's state\n   not being Up in the BFD Control
      packet).\n"
    title: 6.10.  Verifying Connectivity to Specific Tails
  - contents:
    - "6.11.  Detection Times\n   MultipointClient sessions at the head are always
      in the Demand mode,\n   and as such only care about Detection Time in two cases.
      \ First, if a\n   Poll Sequence is being sent on a MultipointClient session,
      the\n   Detection Time on this session is calculated according to the base\n
      \  BFD specification [RFC5880], that is, the transmission interval\n   multiplied
      by bfd.DetectMult.  Second, when a multipoint Poll is sent\n   to solicit tail
      replies, the Detection Time on all associated\n   MultipointClient sessions
      that aren't currently sending Poll\n   Sequences is set to a value greater than
      or equal to\n   bfd.RequiredMinRxInterval (one packet time).  This value can
      be made\n   arbitrarily large in order to ensure that the Detection Time is\n
      \  greater than the round-trip time of a BFD Control packet between the\n   head
      and the tail with no ill effects, other than delaying the\n   detection of unresponsive
      tails.  Note that a Detection Time\n   expiration on a MultipointClient session
      at the head, while\n   indicating a BFD session failure, cannot be construed
      to mean that\n   the tail is not hearing multipoint packets from the head.\n"
    title: 6.11.  Detection Times
  - contents:
    - "6.12.  MultipointClient Down/AdminDown Sessions\n   If the MultipointHead session
      is in Down/AdminDown state (which only\n   happens administratively), all associated
      MultipointClient sessions\n   SHOULD be destroyed as they are superfluous.\n
      \  If a MultipointClient session goes down due to the receipt of an\n   unsolicited
      BFD Control packet from the tail with state Down or\n   AdminDown (not in response
      to a Poll), and tail connectivity\n   verification is not being done, the session
      MAY be destroyed.  If\n   verification is desired, the session SHOULD send a
      Poll Sequence and\n   the session SHOULD be maintained.\n   If the tail replies
      to a Poll Sequence with state Down or AdminDown,\n   it means that the tail
      session is definitely down.  In this case, the\n   session MAY be destroyed.\n
      \  If the Detection Time expires on a MultipointClient session (meaning\n   that
      the tail did not reply to a Poll Sequence), the session MAY be\n   destroyed.\n"
    title: 6.12.  MultipointClient Down/AdminDown Sessions
  - contents:
    - "6.13.  Base BFD for Multipoint Networks Specification Text Replacement\n   The
      following sections are meant to extend the corresponding sections\n   in the
      base BFD for multipoint networks specification [RFC8562].\n"
    - contents:
      - "6.13.1.  Reception of BFD Control Packets\n   The following procedure modifies
        parts of Section 5.13.1 of\n   [RFC8562].\n   When a BFD Control packet is
        received, the procedure defined in\n   Section 5.13.1 of [RFC8562] MUST be
        followed, in the order specified.\n   If the packet is discarded according
        to these rules, processing of\n   the packet MUST cease at that point.  In
        addition to that, if tail\n   tracking is desired by the head, the following
        procedure MUST be\n   applied.\n      If bfd.SessionType is MultipointTail\n
        \        If bfd.UnicastRcvd is zero or the Multipoint (M) bit is clear,\n
        \        set bfd.RemoteMinRxInterval to the value of Required Min RX\n         Interval.\n
        \        If the Multipoint (M) bit is clear, set bfd.UnicastRcvd to 1.\n      Else
        (not MultipointTail)\n         Set bfd.RemoteMinRxInterval to the value of
        Required Min RX\n         Interval.\n      If the Poll (P) bit is set, and
        bfd.SilentTail is zero, send a BFD\n      Control packet to the remote system
        with the Poll (P) bit clear\n      and the Final (F) bit set (see Section
        6.13.3).\n"
      title: 6.13.1.  Reception of BFD Control Packets
    - contents:
      - "6.13.2.  Demultiplexing BFD Control Packets\n   This section is part of the
        addition to Section 5.13.2 of [RFC8562],\n   separated for clarity.\n      If
        the Multipoint (M) bit is clear\n         If the Your Discriminator field
        is nonzero:\n            Select a session based on the value of Your Discriminator.\n
        \           If no session is found, the packet MUST be discarded.\n            If
        bfd.SessionType is MultipointHead:\n               Find a MultipointClient
        session grouped to this\n               MultipointHead session, based on the
        source address and\n               the value of Your Discriminator.  If a
        session is found\n               and is not MultipointClient, the packet MUST
        be\n               discarded.  If no session is found, a new session of type\n
        \              MultipointClient MAY be created, or the packet MAY be\n               discarded.
        \ This choice is outside the scope of this\n               specification.\n
        \              If bfd.SessionType is not MultipointClient, the packet\n               MUST
        be discarded.\n"
      title: 6.13.2.  Demultiplexing BFD Control Packets
    - contents:
      - "6.13.3.  Transmitting BFD Control Packets\n   A system MUST NOT periodically
        transmit BFD Control packets if\n   bfd.SessionType is MultipointClient and
        a Poll Sequence is not being\n   transmitted.\n   If the bfd.SessionType value
        is MultipointTail and the periodic\n   transmission of BFD Control packets
        is just starting (due to Demand\n   mode not being active on the remote system),
        the first packet to be\n   transmitted MUST be delayed by a random amount
        of time between zero\n   and (0.9 * bfd.RemoteMinRxInterval).\n   If a BFD
        Control packet is received with the Poll (P) bit set to 1,\n   the receiving
        system MUST transmit a BFD Control packet with the Poll\n   (P) bit clear
        and the Final (F) bit, without respect to the\n   transmission timer or any
        other transmission limitations, the session\n   state, and whether Demand
        mode is active on either system.  A system\n   MAY limit the rate at which
        such packets are transmitted.  If rate\n   limiting is in effect, the advertised
        value of Desired Min TX\n   Interval MUST be greater than or equal to the
        interval between\n   transmitted packets imposed by the rate-limiting function.
        \ If the\n   Multipoint (M) bit is set in the received packet, the packet\n
        \  transmission MUST be delayed by a random amount of time between zero\n
        \  and (0.9 * bfd.RemoteMinRxInterval).  Otherwise, the packet MUST be\n   transmitted
        as soon as practicable.\n   A system MUST NOT set the Demand (D) bit if bfd.SessionType
        is\n   MultipointClient unless bfd.DemandMode is 1, bfd.SessionState is Up,\n
        \  and bfd.RemoteSessionState is Up.\n   Content of the transmitted packet
        MUST be as explained in\n   Section 5.13.3 of [RFC8562].\n"
      title: 6.13.3.  Transmitting BFD Control Packets
    title: 6.13.  Base BFD for Multipoint Networks Specification Text Replacement
  title: 6.  Protocol Details
- contents:
  - "7.  Assumptions\n   If the head notification is to be used, it is assumed that
    a\n   multipoint BFD packet encapsulation contains enough information so\n   that
    a tail can address a unicast BFD packet to the head.\n   If the head notification
    is to be used, it is assumed that there is\n   bidirectional unicast communication
    available (at the same protocol\n   layer within which BFD is being run) between
    the tail and head.\n   For the head to know reliably that a tail has lost multipoint\n
    \  connectivity, the unicast paths in both directions between that tail\n   and
    the head must remain operational when the multipoint path fails.\n   It is thus
    desirable that unicast paths not share fate with the\n   multipoint path to the
    extent possible if the head wants more\n   definite knowledge of the tail state.\n
    \  Since the normal BFD three-way handshake is not used in this\n   application,
    a tail transitioning from state Up to Down and back to\n   Up again may not be
    reliably detected at the head.\n"
  title: 7.  Assumptions
- contents:
  - "8.  Operational Considerations\n   Section 7 of [RFC5880] includes the requirements
    for implementation\n   of a congestion control mechanism when BFD is used across
    multiple\n   hops and a mechanism that uses congestion detection to reduce the\n
    \  amount of BFD packets the system generates.  These requirements are\n   also
    applicable to this specification.  When this specification is\n   used in the
    mode with no head notifications by tails, as discussed in\n   Section 5.1, the
    head MUST limit the packet transmission rate to no\n   higher than one BFD packet
    per second (see Section 5.13.3 of\n   [RFC8562]).  When the BFD uses one of the
    notifications by the tails\n   to the head mechanisms described in Section 5.2,
    Min RX Interval can\n   be used by the tail to control the packet transmission
    rate of the\n   head.  The exact mechanism of processing changes in the Min RX\n
    \  Interval value in the received from the tail response to multicast or\n   the
    unicast Poll BFD packet is outside the scope of this document.\n   As noted in
    Section 7 of [RFC5880], \"any mechanism that increases the\n   transmit or receive
    intervals will increase the Detection Time for\n   the session\".\n"
  title: 8.  Operational Considerations
- contents:
  - "9.  IANA Considerations\n   This document has no IANA actions.\n"
  title: 9.  IANA Considerations
- contents:
  - "10.  Security Considerations\n   The same security considerations as those described
    in [RFC5880] and\n   [RFC8562] apply to this document.\n   Additionally, implementations
    that create MultpointClient sessions\n   dynamically upon receipt of a BFD Control
    packet from a tail MUST\n   implement protective measures to prevent a number
    of MultipointClient\n   sessions from being created and growing out of control.
    \ Below are\n   some points to be considered in such implementations.\n      When
    the number of MultipointClient sessions exceeds the number of\n      expected
    tails, the implementation should generate an alarm to\n      users to indicate
    the anomaly.\n      The implementation should have a reasonable upper bound on
    the\n      number of MultipointClient sessions that can be created, with the\n
    \     upper bound potentially being computed based on the number of\n      multicast
    streams that the system is expecting.\n   This specification does not raise any
    additional security issues\n   beyond those of the specifications referred to
    in the list of\n   normative references.\n"
  title: 10.  Security Considerations
- contents:
  - "11.  Normative References\n   [RFC2119]  Bradner, S., \"Key words for use in
    RFCs to Indicate\n              Requirement Levels\", BCP 14, RFC 2119,\n              DOI
    10.17487/RFC2119, March 1997,\n              <https://www.rfc-editor.org/info/rfc2119>.\n
    \  [RFC5880]  Katz, D. and D. Ward, \"Bidirectional Forwarding Detection\n              (BFD)\",
    RFC 5880, DOI 10.17487/RFC5880, June 2010,\n              <https://www.rfc-editor.org/info/rfc5880>.\n
    \  [RFC7880]  Pignataro, C., Ward, D., Akiya, N., Bhatia, M., and\n              S.
    Pallagatti, \"Seamless Bidirectional Forwarding\n              Detection (S-BFD)\",
    RFC 7880, DOI 10.17487/RFC7880, July\n              2016, <https://www.rfc-editor.org/info/rfc7880>.\n
    \  [RFC8174]  Leiba, B., \"Ambiguity of Uppercase vs Lowercase in RFC\n              2119
    Key Words\", BCP 14, RFC 8174, DOI 10.17487/RFC8174,\n              May 2017,
    <https://www.rfc-editor.org/info/rfc8174>.\n   [RFC8562]  Katz, D., Ward, D.,
    Pallagatti, S., Ed., and G. Mirsky,\n              Ed., \"Bidirectional Forwarding
    Detection (BFD) for\n              Multipoint Networks\", RFC 8562, DOI 10.17487/RFC8562,\n
    \             April 2019, <https://www.rfc-editor.org/info/rfc8562>.\n"
  title: 11.  Normative References
- contents:
  - "Acknowledgments\n   The authors would like to thank Nobo Akiya, Vengada Prasad
    Govindan,\n   Jeff Haas, Wim Henderickx, and Mingui Zhang who have greatly\n   contributed
    to this document.\n"
  title: Acknowledgments
- contents:
  - "Contributors\n   Rahul Aggarwal of Juniper Networks and George Swallow of Cisco\n
    \  Systems provided the initial idea for this specification and\n   contributed
    to its development.\n"
  title: Contributors
- contents:
  - "Authors' Addresses\n   Dave Katz\n   Juniper Networks\n   1194 N. Mathilda Ave.\n
    \  Sunnyvale, California  94089-1206\n   United States of America\n   Email: dkatz@juniper.net\n
    \  Dave Ward\n   Cisco Systems\n   170 West Tasman Dr.\n   San Jose, California
    \ 95134\n   United States of America\n   Email: wardd@cisco.com\n   Santosh Pallagatti
    (editor)\n   VMware\n   Email: santosh.pallagatti@gmail.com\n   Greg Mirsky (editor)\n
    \  ZTE Corp.\n   Email: gregimirsky@gmail.com\n"
  title: Authors' Addresses
