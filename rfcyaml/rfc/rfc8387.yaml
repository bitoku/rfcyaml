- title: __initial_text__
  contents:
  - "       Practical Considerations and Implementation Experiences in\n         \
    \            Securing Smart Object Networks\n"
- title: Abstract
  contents:
  - "Abstract\n   This memo describes challenges associated with securing resource-\n\
    \   constrained smart object devices.  The memo describes a possible\n   deployment\
    \ model where resource-constrained devices sign message\n   objects, discusses\
    \ the availability of cryptographic libraries for\n   resource-constrained devices,\
    \ and presents some preliminary\n   experiences with those libraries for message\
    \ signing on resource-\n   constrained devices.  Lastly, the memo discusses trade-offs\
    \ involving\n   different types of security approaches.\n"
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This document is not an Internet Standards Track specification;\
    \ it is\n   published for informational purposes.\n   This document is a product\
    \ of the Internet Engineering Task Force\n   (IETF).  It represents the consensus\
    \ of the IETF community.  It has\n   received public review and has been approved\
    \ for publication by the\n   Internet Engineering Steering Group (IESG).  Not\
    \ all documents\n   approved by the IESG are candidates for any level of Internet\n\
    \   Standard; see Section 2 of RFC 7841.\n   Information about the current status\
    \ of this document, any errata,\n   and how to provide feedback on it may be obtained\
    \ at\n   https://www.rfc-editor.org/info/rfc8387.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (c) 2018 IETF Trust and the persons identified\
    \ as the\n   document authors.  All rights reserved.\n   This document is subject\
    \ to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n\
    \   (https://trustee.ietf.org/license-info) in effect on the date of\n   publication\
    \ of this document.  Please review these documents\n   carefully, as they describe\
    \ your rights and restrictions with respect\n   to this document.  Code Components\
    \ extracted from this document must\n   include Simplified BSD License text as\
    \ described in Section 4.e of\n   the Trust Legal Provisions and are provided\
    \ without warranty as\n   described in the Simplified BSD License.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1.  Introduction  . . . . . . . . . . . . . . . . . . .\
    \ . . . . .   3\n   2.  Related Work  . . . . . . . . . . . . . . . . . . . .\
    \ . . . .   3\n   3.  Challenges  . . . . . . . . . . . . . . . . . . . . . .\
    \ . . .   4\n   4.  Proposed Deployment Model . . . . . . . . . . . . . . . .\
    \ . .   6\n     4.1.  Provisioning  . . . . . . . . . . . . . . . . . . . . .\
    \ .   6\n     4.2.  Protocol Architecture . . . . . . . . . . . . . . . . . .\
    \   9\n   5.  Code Availability . . . . . . . . . . . . . . . . . . . . . .  10\n\
    \   6.  Implementation Experiences  . . . . . . . . . . . . . . . . .  12\n  \
    \ 7.  Example Application . . . . . . . . . . . . . . . . . . . . .  18\n   8.\
    \  Design Trade-Offs . . . . . . . . . . . . . . . . . . . . . .  21\n     8.1.\
    \  Feasibility . . . . . . . . . . . . . . . . . . . . . . .  21\n     8.2.  Freshness\
    \ . . . . . . . . . . . . . . . . . . . . . . . .  22\n     8.3.  Layering  .\
    \ . . . . . . . . . . . . . . . . . . . . . . .  24\n     8.4.  Symmetric vs.\
    \ Asymmetric Crypto . . . . . . . . . . . . .  26\n   9.  Summary . . . . . .\
    \ . . . . . . . . . . . . . . . . . . . . .  27\n   10. Security Considerations\
    \ . . . . . . . . . . . . . . . . . . .  27\n   11. IANA Considerations . . .\
    \ . . . . . . . . . . . . . . . . . .  27\n   12. Informative References  . .\
    \ . . . . . . . . . . . . . . . . .  27\n   Acknowledgments . . . . . . . . .\
    \ . . . . . . . . . . . . . . . .  33\n   Authors' Addresses  . . . . . . . .\
    \ . . . . . . . . . . . . . . .  33\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   This memo describes challenges associated with securing\
    \ smart object\n   devices in constrained implementations and environments.  In\n\
    \   Section 3, we specifically discuss three challenges: the\n   implementation\
    \ difficulties encountered on resource-constrained\n   platforms, the problem\
    \ of provisioning keys, and making the choice of\n   implementing security at\
    \ the appropriate layer.\n   Section 4 discusses a potential deployment model\
    \ for constrained\n   environments.  The model requires a minimal amount of configuration,\n\
    \   and we believe it is a natural fit with the typical communication\n   practices\
    \ in smart object networking environments.\n   Section 5 discusses the availability\
    \ of cryptographic libraries.\n   Section 6 presents some experiences in implementing\
    \ cryptography on\n   resource-constrained devices using those libraries, including\n\
    \   information about achievable code sizes and speeds on typical\n   hardware.\
    \  Section 7 describes an example proof-of-concept prototype\n   implementation\
    \ that uses public-key cryptography on resource-\n   constrained devices to provide\
    \ end-to-end data authenticity and\n   integrity protection.\n   Finally, Section\
    \ 8 discusses trade-offs involving different types of\n   security approaches.\n"
- title: 2.  Related Work
  contents:
  - "2.  Related Work\n   The Constrained Application Protocol (CoAP) [RFC7252] is\
    \ a\n   lightweight protocol designed to be used in machine-to-machine\n   applications\
    \ such as smart energy and building automation.  Our\n   discussion uses this\
    \ protocol as an example, but the conclusions may\n   apply to other similar protocols.\
    \  The CoAP base specification\n   [RFC7252] outlines how to use DTLS [RFC6347]\
    \ and IPsec [RFC4303] for\n   securing the protocol.  DTLS can be applied with\
    \ pairwise shared\n   keys, raw public keys, or certificates.  The security model\
    \ in all\n   cases is mutual authentication, so while there is some commonality\
    \ to\n   HTTP [RFC7230] in verifying the server identity, in practice the\n  \
    \ models are quite different.  The use of IPsec with CoAP is described\n   with\
    \ regards to the protocol requirements, noting that lightweight\n   implementations\
    \ of the Internet Key Exchange Protocol Version 2\n   (IKEv2) exist [RFC7815].\
    \  However, the CoAP specification is silent\n   on policy and other aspects that\
    \ are normally necessary in order to\n   implement interoperable use of IPsec\
    \ in any environment [RFC5406].\n   [IoT-SECURITY] documents the different stages\
    \ in the life cycle of a\n   smart object.  Next, it highlights the security threats\
    \ for smart\n   objects and the challenges that one might face to protect against\n\
    \   these threats.  The document also looks at various security protocols\n  \
    \ available, including IKEv2/IPsec [RFC7296], TLS/SSL [RFC5246], DTLS\n   [RFC6347],\
    \ the Host Identity Protocol (HIP) [RFC7401], HIP Diet\n   EXchange [HIP-DEX],\
    \ a Protocol for Carrying Authentication for\n   Network Access (PANA) [RFC5191],\
    \ and the Extensible Authentication\n   Protocol (EAP) [RFC3748].  Lastly, [IoT-BOOTSTRAPPING]\
    \ discusses\n   bootstrapping mechanisms available for resource-constrained Internet\n\
    \   of Things (IoT) devices.\n   [RFC6574] gives an overview of the security discussions\
    \ at the March\n   2011 IAB workshop on smart objects.  The workshop recommended\
    \ that\n   additional work should be undertaken in developing suitable\n   credential\
    \ management mechanisms (perhaps something similar to the\n   Bluetooth pairing\
    \ mechanism), understanding the implementability of\n   standard security mechanisms\
    \ in resource-constrained devices, and\n   conducting additional research in the\
    \ area of lightweight\n   cryptographic primitives.\n   [HIP-DEX] defines a lightweight\
    \ version of the HIP protocol for low-\n   power nodes.  This version uses a fixed\
    \ set of algorithms, Elliptic\n   Curve Cryptography (ECC), and eliminates hash\
    \ functions.  The\n   protocol still operates based on host identities and runs\
    \ end-to-end\n   between hosts, protecting all IP-layer communications.  [RFC6078]\n\
    \   describes an extension of HIP that can be used to send upper-layer\n   protocol\
    \ messages without running the usual HIP base exchange at all.\n   [IPV6-LOWPAN-SEC]\
    \ makes a comprehensive analysis of security issues\n   related to IPv6 over Low-Power\
    \ Wireless Personal Area Network\n   (6LoWPAN) networks, but its findings also\
    \ apply more generally for\n   all low-powered networks.  Some of the issues this\
    \ document discusses\n   include the need to minimize the number of transmitted\
    \ bits and\n   simplify implementations, threats in the smart object networking\n\
    \   environments, and the suitability of 6LoWPAN security mechanisms,\n   IPsec,\
    \ and key management protocols for implementation in these\n   environments.\n"
- title: 3.  Challenges
  contents:
  - "3.  Challenges\n   This section discusses three challenges: 1) implementation\n\
    \   difficulties, 2) practical provisioning problems, and 3) layering and\n  \
    \ communication models.\n   One of the most often discussed issues in the security\
    \ for the\n   Internet of Things relate to implementation difficulties.  The desire\n\
    \   to build resource-constrained, battery-operated, and inexpensive\n   devices\
    \ drives the creation of devices with a limited protocol and\n   application suite.\
    \  Some of the typical limitations include running\n   CoAP instead of HTTP, limited\
    \ support for security mechanisms,\n   limited processing power for long key lengths,\
    \ a sleep schedule that\n   does not allow communication at all times, and so\
    \ on.  In addition,\n   the devices typically have very limited support for configuration,\n\
    \   making it hard to set up secrets and trust anchors.\n   The implementation\
    \ difficulties are important, but they should not be\n   overemphasized.  It is\
    \ important to select the right security\n   mechanisms and avoid duplicated or\
    \ unnecessary functionality.  But at\n   the end of the day, if strong cryptographic\
    \ security is needed, the\n   implementations have to support that.  It is important\
    \ for developers\n   and product designers to determine what security threats\
    \ they want to\n   tackle and the resulting security requirements before selecting\
    \ the\n   hardware.  Often, development work in the wild happens in the wrong\n\
    \   order: a particular platform with a resource-constrained\n   microcontroller\
    \ is chosen first, and then the security features that\n   can fit on it are decided.\
    \  Also, the most lightweight algorithms and\n   cryptographic primitives are\
    \ useful but should not be the only\n   consideration in the design and development.\
    \  Interoperability is\n   also important, and often other parts of the system,\
    \ such as key\n   management protocols or certificate formats, are heavier to\
    \ implement\n   than the algorithms themselves.\n   The second challenge relates\
    \ to practical provisioning problems.\n   This is perhaps the most fundamental\
    \ and difficult issue and is\n   unfortunately often neglected in the design.\
    \  There are several\n   problems in the provisioning and management of smart\
    \ object networks:\n   o  Resource-constrained devices have no natural user interface\
    \ for\n      configuration that would be required for the installation of\n  \
    \    shared secrets and other security-related parameters.  Typically,\n     \
    \ there is no keyboard or display, and there may not even be buttons\n      to\
    \ press.  Some devices may only have one interface, the interface\n      to the\
    \ network.\n   o  Manual configuration is rarely, if at all, possible, as the\n\
    \      necessary skills are missing in typical installation environments\n   \
    \   (such as in family homes).\n   o  There may be a large number of devices.\
    \  Configuration tasks that\n      may be acceptable when performed for one device\
    \ may become\n      unacceptable with dozens or hundreds of devices.\n   o  Smart\
    \ object networks may rely on different radio technologies.\n      Provisioning\
    \ methods that rely on specific link-layer features may\n      not work with other\
    \ radio technologies in a heterogeneous network.\n   o  Network configurations\
    \ evolve over the lifetime of the devices, as\n      additional devices are introduced\
    \ or addresses change.  Various\n      central nodes may also receive more frequent\
    \ updates than\n      individual devices such as sensors embedded in building\
    \ materials.\n   In light of the above challenges, resource-constrained devices\
    \ are\n   often shipped with a single static identity.  In many cases, it is a\n\
    \   single raw public key.  These long-term static identities makes it\n   easy\
    \ to track the devices (and their owners) when they move.  The\n   static identities\
    \ may also allow an attacker to track these devices\n   across ownership changes.\n\
    \   Finally, layering and communication models present difficulties for\n   straightforward\
    \ use of the most obvious security mechanisms.  Smart\n   object networks typically\
    \ pass information through multiple\n   participating nodes [CoAP-SENSORS], and\
    \ end-to-end security for IP or\n   transport layers may not fit such communication\
    \ models very well.\n   The primary reasons for needing middleboxes relate to\
    \ the need to\n   accommodate for sleeping nodes as well to enable the implementation\n\
    \   of nodes that store or aggregate information.\n"
- title: 4.  Proposed Deployment Model
  contents:
  - "4.  Proposed Deployment Model\n   [CoAP-SECURITY] recognizes the provisioning\
    \ model as the driver of\n   what kind of security architecture is useful.  This\
    \ section\n   reintroduces this model briefly here in order to facilitate the\n\
    \   discussion of the various design alternatives later.\n   The basis of the\
    \ proposed architecture are self-generated secure\n   identities, similar to Cryptographically\
    \ Generated Addresses (CGAs)\n   [RFC3972] or Host Identity Tags (HITs) [RFC7401].\
    \  That is, we assume\n   the following holds:\n      I = h(P|O)\n   where I is\
    \ the secure identity of the device, h is a hash function, P\n   is the public\
    \ key from a key pair generated by the device, and O is\n   optional other information.\
    \ \"|\" (vertical bar) here denotes the\n   concatenation operator.\n"
- title: 4.1.  Provisioning
  contents:
  - "4.1.  Provisioning\n   As it is difficult to provision security credentials,\
    \ shared secrets,\n   and policy information, the provisioning model is based\
    \ only on the\n   secure identities.  A typical network installation involves\
    \ physical\n   placement of a number of devices while noting the identities of\
    \ these\n   devices.  This list of short identifiers can then be fed to a central\n\
    \   server as a list of authorized devices.  Secure communications can\n   then\
    \ commence with the devices, at least as far as information from\n   the devices\
    \ to the server is concerned, which is what is needed for\n   sensor networks.\n\
    \   The above architecture is a perfect fit for sensor networks where\n   information\
    \ flows from a large number of devices to a small number of\n   servers.  But\
    \ it is not sufficient alone for other types of\n   applications.  For instance,\
    \ in actuator applications, a large number\n   of devices need to take commands\
    \ from somewhere else.  In such\n   applications, it is necessary to secure that\
    \ the commands come from\n   an authorized source.\n   This can be supported,\
    \ with some additional provisioning effort and\n   optional pairing protocols.\
    \  The basic provisioning approach is as\n   described earlier; however, in addition\
    \ there must be something that\n   informs the devices of the identity of the\
    \ trusted server(s).  There\n   are multiple ways to provide this information.\
    \  One simple approach\n   is to feed the identities of the trusted server(s)\
    \ to devices at\n   installation time.  This requires a separate user interface,\
    \ a local\n   connection (such as USB), or use of the network interface of the\n\
    \   device for configuration.  In any case, as with sensor networks, the\n   amount\
    \ of configuration information is minimized: just one short\n   identity value\
    \ needs to be fed in (not both an identity and\n   certificate or shared secrets\
    \ that must be kept confidential).  An\n   even simpler provisioning approach\
    \ is that the devices in the device\n   group trust each other.  Then no configuration\
    \ is needed at\n   installation time.\n   Once both the parties interested in\
    \ communicating know the expected\n   cryptographic identity of the other offline,\
    \ secure communications\n   can commence.  Alternatively, various pairing schemes\
    \ can be\n   employed.  Note that these schemes can benefit from the already\n\
    \   secure identifiers on the device side.  For instance, the server can\n   send\
    \ a pairing message to each device after their initial power-on\n   and before\
    \ they have been paired with anyone, encrypted with the\n   public key of the\
    \ device.  As with all pairing schemes that do not\n   employ a shared secret\
    \ or the secure identity of both parties, there\n   are some remaining vulnerabilities\
    \ that may or may not be acceptable\n   for the application in question.  For\
    \ example, many pairing methods\n   based on \"leap of faith\" or \"trust on first\
    \ use\" assume that the\n   attacker is not present during the initial setup.\
    \  Therefore, they\n   are vulnerable to eavesdropping or man-in-the-middle (MitM)\
    \ attacks.\n   In any case, the secure identities help again in ensuring that\
    \ the\n   operations are as simple as possible.  Only identities need to be\n\
    \   communicated to the devices, not certificates, shared secrets, or,\n   e.g.,\
    \ IPsec policy rules.\n   Where necessary, the information collected at installation\
    \ time may\n   also include other parameters relevant to the application, such\
    \ as\n   the location or purpose of the devices.  This would enable the server\n\
    \   to know, for instance, that a particular device is the temperature\n   sensor\
    \ for the kitchen.\n   Collecting the identity information at installation time\
    \ can be\n   arranged in a number of ways.  One simple but not completely secure\n\
    \   method is where the last few digits of the identity are printed on a\n   tiny\
    \ device just a few millimeters across.  Alternatively, the\n   packaging for\
    \ the device may include the full identity (typically 32\n   hex digits) retrieved\
    \ from the device at manufacturing time.  This\n   identity can be read, for instance,\
    \ by a bar code reader carried by\n   the installation personnel.  (Note that\
    \ the identities are not\n   secret; the security of the system is not dependent\
    \ on the identity\n   information leaking to others.  The real owner of an identity\
    \ can\n   always prove its ownership with the private key, which never leaves\n\
    \   the device.)  Finally, the device may use its wired network interface\n  \
    \ or proximity-based communications, such as Near-Field Communications\n   (NFC)\
    \ or Radio-Frequency Identity (RFID) tags.  Such interfaces allow\n   secure communication\
    \ of the device identity to an information\n   gathering device at installation\
    \ time.\n   No matter what the method of information collection is, this\n   provisioning\
    \ model minimizes the effort required to set up the\n   security.  Each device\
    \ generates its own identity in a random, secure\n   key-generation process. \
    \ The identities are self-securing in the\n   sense that if you know the identity\
    \ of the peer you want to\n   communicate with, messages from the peer can be\
    \ signed by the peer's\n   private key, and it is trivial to verify that the message\
    \ came from\n   the expected peer.  There is no need to configure an identity\
    \ and\n   certificate of that identity separately.  There is no need to\n   configure\
    \ a group secret or a shared secret.  There is no need to\n   configure a trust\
    \ anchor.  In addition, the identities are typically\n   collected anyway for\
    \ application purposes (such as identifying which\n   sensor is in which room).\
    \  Under most circumstances, there is\n   actually no additional configuration\
    \ effort needed for provisioning\n   security.\n   As discussed in the previous\
    \ section, long-term static identities\n   negatively affect the privacy of the\
    \ devices and their owners.\n   Therefore, it is beneficial for devices to generate\
    \ new identities at\n   appropriate times during their life cycle; an example\
    \ is after a\n   factory reset or an ownership handover.  Thus, in our proposed\n\
    \   deployment model, the devices would generate a new asymmetric key\n   pair\
    \ and use the new public-key P' to generate the new identity I'.\n   It is also\
    \ desirable that these identities are only used during the\n   provisioning stage.\
    \  Temporary identities (such as dynamic IPv6\n   addresses) can be used for network\
    \ communication protocols once the\n   device is operational.\n   Groups of devices\
    \ can be managed through single identifiers as well.\n   In these deployment cases,\
    \ it is also possible to configure the\n   identity of an entire group of devices,\
    \ rather than registering the\n   individual devices.  For instance, many installations\
    \ employ a kit of\n   devices bought from the same manufacturer in one package.\
    \  It is easy\n   to provide an identity for such a set of devices as follows:\n\
    \      Idev = h(Pdev|Potherdev1|Potherdev2|...|Potherdevn)\n      Igrp = h(Pdev1|Pdev2|...|Pdevm)\n\
    \   where Idev is the identity of an individual device, Pdev is the\n   public\
    \ key of that device, Potherdevi are the public keys of other\n   devices in the\
    \ group, n is all the devices in the group except the\n   device with Pdev as\
    \ its public key, and m is the total number of\n   devices in the group.  Now,\
    \ we can define the secure identity of the\n   group (Igrp) as a hash of all the\
    \ public keys of the devices in the\n   group (Pdevi).\n   The installation personnel\
    \ can scan the identity of the group from\n   the box that the kit came in, and\
    \ this identity can be stored in a\n   server that is expected to receive information\
    \ from the nodes.  Later\n   when the individual devices contact this server,\
    \ they will be able to\n   show that they are part of the group, as they can reveal\
    \ their own\n   public key and the public keys of the other devices.  Devices\
    \ that do\n   not belong to the kit cannot claim to be in the group, because the\n\
    \   group identity would change if any new keys were added to the\n   identity\
    \ of the group (Igrp).\n"
- title: 4.2.  Protocol Architecture
  contents:
  - "4.2.  Protocol Architecture\n   As noted above, the starting point of the architecture\
    \ is that nodes\n   self-generate secure identities, which are then communicated\
    \ out of\n   band to the peers that need to know what devices to trust.  To\n\
    \   support this model in a protocol architecture, we also need to use\n   these\
    \ secure identities to implement secure messaging between the\n   peers, explain\
    \ how the system can respond to different types of\n   attacks such as replay\
    \ attempts, and decide what protocol layer and\n   endpoints the architecture\
    \ should use.\n   The deployment itself is suitable for a variety of design choices\n\
    \   regarding layering and protocol mechanisms.  [CoAP-SECURITY] was\n   mostly\
    \ focused on employing end-to-end data-object security as\n   opposed to hop-by-hop\
    \ security.  But other approaches are possible.\n   For instance, HIP in its opportunistic\
    \ mode could be used to\n   implement largely the same functionality at the IP\
    \ layer.  However,\n   it is our belief that the right layer for this solution\
    \ is at the\n   application layer, and more specifically, in the data formats\n\
    \   transported in the payload part of CoAP.  This approach provides the\n   following\
    \ benefits:\n   o  Ability for intermediaries to act as caches to support different\n\
    \      sleep schedules, without the security model being impacted.\n   o  Ability\
    \ for intermediaries to be built to perform aggregation,\n      filtering, storage,\
    \ and other actions, again without impacting the\n      security of the data being\
    \ transmitted or stored.\n   o  Ability to operate in the presence of traditional\
    \ middleboxes,\n      such as a protocol translators or even NATs (not that we\
    \ recommend\n      their use in these environments).\n   However, as we will see\
    \ later, there are also some technical\n   implications, namely that link, network,\
    \ and transport-layer\n   solutions are more likely to be able to benefit from\
    \ sessions where\n   the cost of expensive operations can be amortized over multiple\
    \ data\n   transmissions.  While this is not impossible in data-object security\n\
    \   solutions, it is generally not the typical arrangement.\n"
- title: 5.  Code Availability
  contents:
  - "5.  Code Availability\n   For implementing public-key cryptography on resource-constrained\n\
    \   environments, we chose the Arduino Uno board [arduino-uno] as the\n   test\
    \ platform.  Arduino Uno has an ATmega328 microcontroller, an\n   8-bit processor\
    \ with a clock speed of 16 MHz, 2 kB of RAM, and 32 kB\n   of flash memory.  Our\
    \ choice of an 8-bit platform may seem surprising\n   since cheaper and more energy-efficient\
    \ 32-bit platforms are\n   available.  However, our intention was to evaluate\
    \ the performance of\n   public-key cryptography on the most resource-constrained\
    \ platforms\n   available.  It is reasonable to expect better performance results\n\
    \   from 32-bit microcontrollers.\n   For selecting potential asymmetric cryptographic\
    \ libraries, we\n   surveyed and came up with a set of possible code sources and\n\
    \   performed an initial analysis of how well they fit the Arduino\n   environment.\
    \  Note that the results are preliminary and could easily\n   be affected in any\
    \ direction by implementation bugs, configuration\n   errors, and other mistakes.\
    \  It is advisable to verify the numbers\n   before relying on them for building\
    \ something.  No significant effort\n   was done to optimize ROM memory usage\
    \ beyond what the libraries\n   provided themselves, so those numbers should be\
    \ taken as upper\n   limits.\n   Here is the set of libraries we found:\n   o\
    \  AVRCryptoLib [avr-cryptolib]: This library provides symmetric key\n      algorithms\
    \ such as AES.  It provides RSA as an asymmetric key\n      algorithm.  Parts\
    \ of the library were written in AVR 8-bit\n      assembly language to reduce\
    \ the size and optimize the performance.\n   o  Relic-toolkit [relic-toolkit]:\
    \ This library is written entirely in\n      C and provides a highly flexible\
    \ and customizable implementation\n      of a large variety of cryptographic algorithms.\
    \  This not only\n      includes RSA and ECC but also pairing-based asymmetric\n\
    \      cryptography, Boneh-Lynn-Shacham signatures, and Boneh-Boyen short\n  \
    \    signatures.  The library has also added support for curve25519\n      (for\
    \ Elliptic Curve Diffie-Hellman key exchange) [RFC7748] and\n      edwards25519\
    \ (for elliptic curve digital signatures) [RFC8032].\n      The toolkit provides\
    \ an option to build only the desired\n      components for the required platform.\n\
    \   o  TinyECC [tinyecc]: TinyECC was designed for using elliptic-curve-\n   \
    \   based public-key cryptography on sensor networks.  It is written\n      in\
    \ the nesC programming language [nesC] and as such is designed\n      for specific\
    \ use on TinyOS.  However, the library can be ported to\n      standard C either\
    \ with tool chains or by manually rewriting parts\n      of the code.  It also\
    \ has one of the smallest memory footprints\n      among the set of elliptic curve\
    \ libraries surveyed so far.\n   o  Wiselib [wiselib]: Wiselib is a generic library\
    \ written for sensor\n      networks containing a wide variety of algorithms.\
    \  While the\n      stable version contains algorithms for routing only, the test\n\
    \      version includes algorithms for cryptography, localization,\n      topology\
    \ management, and many more.  The library was designed with\n      the idea of\
    \ making it easy to interface the library with operating\n      systems like iSense\
    \ and Contiki.  However, since the library is\n      written entirely in C++ with\
    \ a template-based model similar to\n      Boost/CGAL, it can be used on any platform\
    \ directly without using\n      any of the operating system interfaces provided.\
    \  This approach\n      was taken to test the code on Arduino Uno.\n   o  MatrixSSL\
    \ [matrix-ssl]: This library provides a low footprint\n      implementation of\
    \ several cryptographic algorithms including RSA\n      and ECC (with a commercial\
    \ license).  The library in the original\n      form takes about 50 kB of ROM\
    \ and is intended for 32-bit\n      platforms.\n   This is by no means an exhaustive\
    \ list, and there exists other\n   cryptographic libraries targeting resource-constrained\
    \ devices.\n   There are also a number of operating systems that are specifically\n\
    \   targeted for resource-constrained devices.  These operating systems\n   may\
    \ include libraries and code for security.  Hahm et al. [hahmos]\n   conducted\
    \ a survey of such operating systems.  The ARM Mbed OS [mbed]\n   is one such\
    \ operating system that provides various cryptographic\n   primitives that are\
    \ necessary for SSL/TLS protocol implementation as\n   well as X509 certificate\
    \ handling.  The library provides an API for\n   developers with a minimal code\
    \ footprint.  It is intended for various\n   ARM platforms such as ARM Cortex\
    \ M0, ARM Cortex M0+, and ARM Cortex\n   M3.\n"
- title: 6.  Implementation Experiences
  contents:
  - "6.  Implementation Experiences\n   While evaluating the implementation experiences,\
    \ we were particularly\n   interested in the signature generation operation. \
    \ This was because\n   our example application discussed in Section 7 required\
    \ only the\n   signature generation operation on the resource-constrained platforms.\n\
    \   We have summarized the initial results of RSA private-key\n   exponentiation\
    \ performance using AVRCryptoLib [avr-crypto-lib] in\n   Table 1.  All results\
    \ are from a single run since repeating the test\n   did not change (or had only\
    \ minimal impact on) the results.  The\n   execution time for a key size of 2048\
    \ bits was inordinately long and\n   would be a deterrent in real-world deployments.\n\
    \   +--------------+------------------------+---------------------------+\n  \
    \ | Key length   | Execution time (ms);   | Memory footprint (bytes); |\n   |\
    \ (bits)       | key in RAM             | key in RAM                |\n   +--------------+------------------------+---------------------------+\n\
    \   | 2048         | 1587567                | 1280                      |\n  \
    \ +--------------+------------------------+---------------------------+\n    \
    \          Table 1: RSA Private-Key Operation Performance\n   The code size was\
    \ about 3.6 kB with potential for further reduction.\n   It is also worth noting\
    \ that the implementation performs basic\n   exponentiation and multiplication\
    \ operations without using any\n   mathematical optimizations such as Montgomery\
    \ multiplication,\n   optimized squaring, etc., as described in [rsa-high-speed].\
    \  With\n   more RAM, we believe that 2048-bit operations can be performed in\n\
    \   much less time as has been shown in [rsa-8bit].\n   In Table 2, we present\
    \ the results obtained by manually porting\n   TinyECC into the C99 standard and\
    \ running the Elliptic Curve Digital\n   Signature Algorithm (ECDSA) on the Arduino\
    \ Uno board.  TinyECC\n   supports a variety of SEC-2-recommended elliptic curve\
    \ domain\n   parameters [sec2ecc].  The execution time and memory footprint are\n\
    \   shown next to each of the curve parameters.  These results were\n   obtained\
    \ by turning on all the optimizations and using assembly code\n   where available.\n\
    \   The results from the performance evaluation of ECDSA in the following\n  \
    \ tables also contain a column stating the approximate comparable RSA\n   key\
    \ length as documented in [sec2ecc].  It is clearly observable that\n   for similar\
    \ security levels, elliptic curve public-key cryptography\n   outperforms RSA.\n\
    \   +-------------+---------------+-----------------+-------------------+\n  \
    \ | Curve       | Execution     | Memory          | Comparable RSA    |\n   |\
    \ parameters  | time (ms)     | footprint       | key length        |\n   |  \
    \           |               | (bytes)         |                   |\n   +-------------+---------------+-----------------+-------------------+\n\
    \   | secp160k1   | 2228          | 892             | 1024              |\n  \
    \ | secp160r1   | 2250          | 892             | 1024              |\n   |\
    \ secp160r2   | 2467          | 892             | 1024              |\n   | secp192k1\
    \   | 3425          | 1008            | 1536              |\n   | secp192r1  \
    \ | 3578          | 1008            | 1536              |\n   +-------------+---------------+-----------------+-------------------+\n\
    \         Table 2: Performance of ECDSA Sign Operation with TinyECC\n   We also\
    \ performed experiments by removing the assembly optimization\n   and using a\
    \ C-only form of the library.  This gives us an idea of the\n   performance that\
    \ can be achieved with TinyECC on any platform\n   regardless of what kind of\
    \ OS and assembly instruction set is\n   available.  The memory footprint remains\
    \ the same with or without\n   assembly code.  The tables contain the maximum\
    \ RAM that is used when\n   all the possible optimizations are on.  However, if\
    \ the amount of RAM\n   available is smaller in size, some of the optimizations\
    \ can be turned\n   off to reduce the memory consumption accordingly.\n   +-------------+---------------+-----------------+-------------------+\n\
    \   | Curve       | Execution     | Memory          | Comparable RSA    |\n  \
    \ | parameters  | time (ms)     | footprint       | key length        |\n   |\
    \             |               | (bytes)         |                   |\n   +-------------+---------------+-----------------+-------------------+\n\
    \   | secp160k1   | 3795          | 892             | 1024              |\n  \
    \ | secp160r1   | 3841          | 892             | 1024              |\n   |\
    \ secp160r2   | 4118          | 892             | 1024              |\n   | secp192k1\
    \   | 6091          | 1008            | 1536              |\n   | secp192r1  \
    \ | 6217          | 1008            | 1536              |\n   +-------------+---------------+-----------------+-------------------+\n\
    \         Table 3: Performance of ECDSA Sign Operation with TinyECC\n        \
    \                (No Assembly Optimizations)\n   Table 4 documents the performance\
    \ of Wiselib.  Since there were no\n   optimizations that could be turned on or\
    \ off, we have only one set of\n   results.  By default, Wiselib only supports\
    \ some of the standard SEC\n   2 elliptic curves, but it is easy to change the\
    \ domain parameters and\n   obtain results for all the 128-, 160-, and 192-bit\
    \ SEC 2 elliptic\n   curves.  The ROM size for all the experiments was less than\
    \ 16 kB.\n   +-------------+---------------+-----------------+-------------------+\n\
    \   | Curve       | Execution     | Memory          | Comparable RSA    |\n  \
    \ | parameters  | time (ms)     | footprint       | key length        |\n   |\
    \             |               | (bytes)         |                   |\n   +-------------+---------------+-----------------+-------------------+\n\
    \   | secp160k1   | 10957         | 842             | 1024              |\n  \
    \ | secp160r1   | 10972         | 842             | 1024              |\n   |\
    \ secp160r2   | 10971         | 842             | 1024              |\n   | secp192k1\
    \   | 18814         | 952             | 1536              |\n   | secp192r1  \
    \ | 18825         | 952             | 1536              |\n   +-------------+---------------+-----------------+-------------------+\n\
    \          Table 4: Performance ECDSA Sign Operation with Wiselib\n   For testing\
    \ the relic-toolkit, we used a different board because it\n   required more RAM/ROM,\
    \ and we were unable to perform experiments with\n   it on Arduino Uno.  Arduino\
    \ Mega has the same 8-bit architecture as\n   Arduino Uno, but it has a much larger\
    \ RAM/ROM.  We used Arduino Mega\n   for experimenting with the relic-toolkit.\
    \  Again, it is important to\n   mention that we used Arduino as it is a convenient\
    \ prototyping\n   platform.  Our intention was to demonstrate the feasibility\
    \ of the\n   entire architecture with public-key cryptography on an 8-bit\n  \
    \ microcontroller.  However, it is important to state that 32-bit\n   microcontrollers\
    \ are much more easily available, at lower costs, and\n   are more power efficient.\
    \  Therefore, real deployments are better off\n   using 32-bit microcontrollers\
    \ that allow developers to include the\n   necessary cryptographic libraries.\
    \  There is no good reason to choose\n   platforms that do not provide sufficient\
    \ computing power to run the\n   necessary cryptographic operations.\n   The relic-toolkit\
    \ supports Koblitz curves over prime as well as\n   binary fields.  We have experimented\
    \ with Koblitz curves over binary\n   fields only.  We do not run our experiments\
    \ with all the curves\n   available in the library since the aim of this work\
    \ is not to prove\n   which curves perform the fastest but rather to show that\
    \ asymmetric\n   cryptography is possible on resource-constrained devices.\n \
    \  The results from relic-toolkit are documented separately in Tables 5\n   and\
    \ 6.  The first set of results were performed with the library\n   configured\
    \ for high-speed performance with no consideration given to\n   the amount of\
    \ memory used.  For the second set, the library was\n   configured for low-memory\
    \ usage irrespective of the execution time\n   required by different curves. \
    \ By turning on/off optimizations\n   included in the library, a trade-off between\
    \ memory and execution\n   time between these values can be achieved.\n   +-----------------+--------------+----------------+-----------------+\n\
    \   | Curve           | Execution    | Memory         | Comparable RSA  |\n  \
    \ | parameters      | time (ms)    | footprint      | key length      |\n   |\
    \                 |              | (bytes)        |                 |\n   +-----------------+--------------+----------------+-----------------+\n\
    \   | sect163k1       | 261          | 2804           | 1024            |\n  \
    \ | (assembly math) |              |                |                 |\n   |\
    \ sect163k1       | 932          | 2750           | 1024            |\n   | sect163r2\
    \       | 2243         | 2444           | 1024            |\n   | sect233k1  \
    \     | 1736         | 3675           | 2048            |\n   | sect233r1    \
    \   | 4471         | 3261           | 2048            |\n   +-----------------+--------------+----------------+-----------------+\n\
    \             Table 5: Performance of ECDSA Sign Operation with\n            \
    \               relic-toolkit (Fast)\n   +-----------------+--------------+----------------+-----------------+\n\
    \   | Curve           | Execution    | Memory         | Comparable RSA  |\n  \
    \ | parameters      | time (ms)    | footprint      | key length      |\n   |\
    \                 |              | (bytes)        |                 |\n   +-----------------+--------------+----------------+-----------------+\n\
    \   | sect163k1       | 592          | 2087           | 1024            |\n  \
    \ | (assembly math) |              |                |                 |\n   |\
    \ sect163k1       | 2950         | 2215           | 1024            |\n   | sect163r2\
    \       | 3213         | 2071           | 1024            |\n   | sect233k1  \
    \     | 6450         | 2935           | 2048            |\n   | sect233r1    \
    \   | 6100         | 2737           | 2048            |\n   +-----------------+--------------+----------------+-----------------+\n\
    \      Table 6: Performance of ECDSA Sign Operation with relic-toolkit\n     \
    \                          (Low Memory)\n   It is important to note the following\
    \ points about the elliptic curve\n   measurements:\n   o  Some boards (e.g.,\
    \ Arduino Uno) do not provide a hardware random\n      number generator.  On such\
    \ boards, obtaining cryptographic-quality\n      randomness is a challenge.  Real-world\
    \ deployments must rely on a\n      hardware random number generator for cryptographic\
    \ operations such\n      as generating a public-private key pair.  The Nordic\
    \ nRF52832\n      board [nordic], for example, provides a hardware random number\n\
    \      generator.  A detailed discussion on requirements and best\n      practices\
    \ for cryptographic-quality randomness is documented in\n      [RFC4086]\n   o\
    \  For measuring the memory footprint of all the ECC libraries, we\n      used\
    \ the Avrora simulator [avrora].  Only stack memory was used to\n      easily\
    \ track the RAM consumption.\n   Tschofenig and Pegourie-Gonnard [armecdsa] have\
    \ also evaluated the\n   performance of ECC on an ARM Coretex platform.  The results\
    \ for the\n   ECDSA sign operation shown in Table 7 are performed on a Freescale\n\
    \   FRDM-KL25Z board [freescale] that has an ARM Cortex-M0+ 48MHz\n   microcontroller\
    \ with 128 kB of flash memory and 16 kB of RAM.  The\n   sliding window technique\
    \ for efficient exponentiation was used with a\n   window size of 2.  All other\
    \ optimizations were disabled for these\n   measurements.\n   +------------------+---------------------+--------------------------+\n\
    \   | Curve parameters | Execution time (ms) | Comparable RSA key       |\n  \
    \ |                  |                     | length                   |\n   +------------------+---------------------+--------------------------+\n\
    \   | secp192r1        | 2165                | 1536                     |\n  \
    \ | secp224r1        | 3014                | 2048                     |\n   |\
    \ secp256r1        | 3649                | 2048                     |\n   +------------------+---------------------+--------------------------+\n\
    \     Table 7: Performance of ECDSA Sign Operation with an ARM Mbed TLS\n    \
    \                   Stack on Freescale FRDM-KL25Z\n   Tschofenig and Pegourie-Gonnard\
    \ [armecdsa] also measured the\n   performance of curves on an ST Nucleo F091\
    \ (STM32F091RCT6) board\n   [stnucleo] that has an ARM Cortex-M0 48 MHz microcontroller\
    \ with 256\n   kB of flash memory and 32 kB of RAM.  The execution time for the\n\
    \   ECDSA sign operation with different curves is shown in Table 8.  The\n   sliding\
    \ window technique for efficient exponentiation was used with a\n   window size\
    \ of 7.  Fixed-point optimization and NIST curve-specific\n   optimizations were\
    \ used for these measurements.\n   +------------------+---------------------+--------------------------+\n\
    \   | Curve parameters | Execution time (ms) | Comparable RSA key       |\n  \
    \ |                  |                     | length                   |\n   +------------------+---------------------+--------------------------+\n\
    \   | secp192k1        | 291                 | 1536                     |\n  \
    \ | secp192r1        | 225                 | 1536                     |\n   |\
    \ secp224k1        | 375                 | 2048                     |\n   | secp224r1\
    \        | 307                 | 2048                     |\n   | secp256k1  \
    \      | 486                 | 2048                     |\n   | secp256r1    \
    \    | 459                 | 2048                     |\n   | secp384r1      \
    \  | 811                 | 7680                     |\n   | secp521r1        |\
    \ 1602                | 15360                    |\n   +------------------+---------------------+--------------------------+\n\
    \   Table 8: ECDSA Signature Performance with an ARM Mbed TLS Stack on ST\n  \
    \                      Nucleo F091 (STM32F091RCT6)\n   Finally, Tschofenig and\
    \ Pegourie-Gonnard [armecdsa] also measured the\n   RAM consumption by calculating\
    \ the heap consumed for the\n   cryptographic operations using a custom memory\
    \ allocation handler.\n   They did not measure the minimal stack memory consumption.\
    \  Depending\n   on the curve and the different optimizations enable or disabled,\
    \ the\n   memory consumption for the ECDSA sign operation varied from 1500\n \
    \  bytes to 15000 bytes.\n   At the time of performing these measurements and\
    \ this study, it was\n   unclear which exact elliptic curve(s) would be selected\
    \ by the IETF\n   community for use with resource-constrained devices.  However,\n\
    \   [RFC7748] defines two elliptic curves over prime fields (Curve25519\n   and\
    \ Curve448) that offer a high-level of practical security for\n   Diffie-Hellman\
    \ key exchange.  Correspondingly, there is ongoing work\n   to specify elliptic\
    \ curve signature schemes with Edwards-curve\n   Digital Signature Algorithm (EdDSA).\
    \  [RFC8032] specifies the\n   recommended parameters for the edwards25519 and\
    \ edwards448 curves.\n   From these, curve25519 (for Elliptic Curve Diffie-Hellman\
    \ key\n   exchange) and edwards25519 (for elliptic curve digital signatures)\n\
    \   are especially suitable for resource-constrained devices.\n   We found that\
    \ the NaCl [nacl] and MicoNaCl [micronacl] libraries\n   provide highly efficient\
    \ implementations of Diffie-Hellman key\n   exchange with curve25519.  The results\
    \ have shown that these\n   libraries with curve25519 outperform other elliptic\
    \ curves that\n   provide similar levels of security.  Hutter and Schwabe [naclavr]\n\
    \   also show that the signing of data using the curve Ed25519 from the\n   NaCl\
    \ library needs only 23216241 cycles on the same microcontroller\n   that we used\
    \ for our evaluations (Arduino Mega ATmega2560).  This\n   corresponds to about\
    \ 1451 milliseconds of execution time.  When\n   compared to the results for other\
    \ curves and libraries that offer a\n   similar level of security (such as sect233r1\
    \ and sect233k1), this\n   implementation far outperforms all others.  As such,\
    \ it is\n   recommended that the IETF community use these curves for protocol\n\
    \   specification and implementations.\n   A summary library flash memory use\
    \ is shown in Table 9.\n      +------------------------+------------------------------------+\n\
    \      | Library                | Flash memory footprint (kilobytes) |\n     \
    \ +------------------------+------------------------------------+\n      | AVRCryptoLib\
    \           | 3.6                                |\n      | Wiselib          \
    \      | 16                                 |\n      | TinyECC               \
    \ | 18                                 |\n      | Relic-toolkit          | 29\
    \                                 |\n      | NaCl Ed25519 [naclavr] | 17-29  \
    \                            |\n      +------------------------+------------------------------------+\n\
    \           Table 9: Summary of Library Flash Memory Consumption\n   All the measurements\
    \ here are only provided as an example to show\n   that asymmetric-key cryptography\
    \ (particularly, digital signatures)\n   is possible on resource-constrained devices.\
    \  By no means are these\n   numbers the final source for measurements, and some\
    \ curves presented\n   here may no longer be acceptable for real in-the-wild deployments.\n\
    \   For example, Mosdorf et al. [mosdorf] and Liu et al. [tinyecc] also\n   document\
    \ the performance of ECDSA on similar resource-constrained\n   devices.\n"
- title: 7.  Example Application
  contents:
  - "7.  Example Application\n   We developed an example application on the Arduino\
    \ platform to use\n   public-key cryptography, data-object security, and an easy\n\
    \   provisioning model.  Our application was originally developed to test\n  \
    \ different approaches to supporting communications to \"always off\"\n   sensor\
    \ nodes.  These battery-operated or energy-scavenging nodes do\n   not have enough\
    \ power to stay on at all times.  They wake up\n   periodically and transmit their\
    \ readings.\n   Such sensor nodes can be supported in various ways.  [CoAP-SENSORS]\n\
    \   was an early multicast-based approach.  In the current application,\n   we\
    \ have switched to using resource directories [CoRE-RD] and publish-\n   subscribe\
    \ brokers [CoAP-BROKER] instead.  Architecturally, the idea\n   is that sensors\
    \ can delegate a part of their role to a node in the\n   network.  Such a network\
    \ node could be either a local resource or\n   something in the Internet.  In\
    \ the case of CoAP publish-subscribe\n   brokers, the network node agrees to hold\
    \ the web resources on behalf\n   of the sensor, while the sensor is asleep. \
    \ The only role that the\n   sensor has is to register itself at the publish-subscribe\
    \ broker and\n   periodically update the readings.  All queries from the rest\
    \ of the\n   world go to the publish-subscribe broker.\n   We constructed a system\
    \ with four entities:\n   Sensor:  This is an Arduino-based device that runs a\
    \ CoAP publish-\n      subscribe broker client and relic-toolkit.  Relic takes\
    \ 29 kB of\n      flash memory, and the simple CoAP client takes roughly 3 kB.\n\
    \   Publish-Subscribe Broker:  This is a publish-subscribe broker that\n     \
    \ holds resources on the sensor's behalf.  The sensor registers\n      itself\
    \ to this node.\n   Resource Directory:  While physically in the same node in\
    \ our\n      implementation, a resource directory is a logical function that\n\
    \      allows sensors and publish-subscribe brokers to register resources\n  \
    \    in the directory.  These resources can be queried by applications.\n   Application:\
    \  This is a simple application that runs on a general\n      purpose computer\
    \ and can retrieve both registrations from the\n      resource directory and most\
    \ recent sensor readings from the\n      publish-subscribe broker.\n   The security\
    \ of this system relies on a secure-shell-like approach.\n   In Step 1, upon first\
    \ boot, sensors generate keys and register\n   themselves in the publish-subscribe\
    \ broker.  Their public key is\n   submitted along with the registration as an\
    \ attribute in the CoRE\n   Link Format data [RFC6690].\n   In Step 2, when the\
    \ sensor makes a measurement, it sends an update to\n   the publish-subscribe\
    \ broker and signs the message contents with a\n   JSON Object Signing and Encryption\
    \ (JOSE) signature on the used JSON\n   [RFC7515] and Sensor Measurement List\
    \ (SenML) payload [MT-SenML].\n   The sensor can also alternatively use CBOR Object\
    \ Signing and\n   Encryption (COSE) [RFC8152] for signing the sensor measurement.\n\
    \   In Step 3, any other device in the network -- including the publish-\n   subscribe\
    \ broker, resource directory, and the application -- can\n   check that the public\
    \ key from the registration corresponds to the\n   private key used to make the\
    \ signature in the data update.\n   Note that checks can be done at any time,\
    \ and there is no need for\n   the sensor and the checking node to be awake at\
    \ the same time.  In\n   our implementation, the checking is done in the application\
    \ node.\n   This demonstrates how it is possible to implement end-to-end security\n\
    \   even with the presence of assisting middleboxes.\n   To verify the feasibility\
    \ of our architecture, we developed a\n   proof-of-concept prototype.  In our\
    \ prototype, the sensor was\n   implemented using the Arduino Ethernet shield\
    \ over an Arduino Mega\n   board.  Our implementation uses the standard C99 programming\
    \ language\n   on the Arduino Mega board.  In this prototype, the publish-subscribe\n\
    \   broker and the Resource Directory (RD) reside on the same physical\n   host.\
    \  A 64-bit x86 Linux machine serves as the broker and the RD,\n   while a similar\
    \ but physically distinct 64-bit x86 Linux machine\n   serves as the client that\
    \ requests data from the sensor.  We chose\n   the Relic library version 0.3.1\
    \ for our sample prototype as it can be\n   easily compiled for different bit-length\
    \ processors.  Therefore, we\n   were able to use it on the 8-bit processor of\
    \ the Arduino Mega, as\n   well as on the 64-bit processor of the x86 client.\
    \  We used ECDSA to\n   sign and verify data updates with the standard sect163k1\
    \ curve\n   parameters.  While compiling Relic for our prototype, we used the\n\
    \   fast configuration without any assembly optimizations.\n   The gateway implements\
    \ the CoAP base specification in the Java\n   programming language and extends\
    \ it to add support for publish-\n   subscribe broker and Resource Directory Representational\
    \ State\n   Transfer (REST) interfaces.  We also developed a minimalistic CoAP\n\
    \   C-library for the Arduino sensor and for the client requesting data\n   updates\
    \ for a resource.  The library has small RAM requirements and\n   uses stack-based\
    \ allocation only.  It is interoperable with the Java\n   implementation of CoAP\
    \ running on the gateway.  The location of the\n   resource directory was configured\
    \ into the smart object sensor by\n   hardcoding the IP address.  A real implementation\
    \ based on this\n   prototype would instead use the domain name system for obtaining\
    \ the\n   location of the resource directory.\n   Our intention was to demonstrate\
    \ that it is possible to implement the\n   entire architecture with public-key\
    \ cryptography on an 8-bit\n   microcontroller.  The stated values can be improved\
    \ further by a\n   considerable amount.  For example, the flash memory and RAM\n\
    \   consumption is relatively high because some of the Arduino libraries\n   were\
    \ used out of the box, and there are several functions that can be\n   removed.\
    \  Similarly, we used the fast version of the Relic library in\n   the prototype\
    \ instead of the low-memory version.  However, it is\n   important to note that\
    \ this was only a research prototype to verify\n   the feasibility of this architecture\
    \ and, as stated elsewhere, most\n   modern development boards have a 32-bit microcontroller\
    \ since they\n   are more economical and have better energy efficiency.\n"
- title: 8.  Design Trade-Offs
  contents:
  - "8.  Design Trade-Offs\n   This section attempts to make some early conclusions\
    \ regarding trade-\n   offs in the design space, based on deployment considerations\
    \ for\n   various mechanisms and the relative ease or difficulty of\n   implementing\
    \ them.  In particular, this analysis looks at layering,\n   freshness, and the\
    \ choice of symmetric vs. asymmetric cryptography.\n"
- title: 8.1.  Feasibility
  contents:
  - "8.1.  Feasibility\n   The first question is whether using cryptographic security\
    \ and\n   asymmetric cryptography in particular is feasible at all on resource-\n\
    \   constrained devices.  The numbers above give a mixed message.\n   Clearly,\
    \ an implementation of a significant cryptographic operation\n   such as public-key\
    \ signing can be done in a surprisingly small amount\n   of code space.  It could\
    \ even be argued that our chosen prototype\n   platform was unnecessarily restrictive\
    \ in the amount of code space it\n   allows: we chose this platform on purpose\
    \ to demonstrate something\n   that is as resource constrained and difficult as\
    \ possible.\n   A recent trend in microcontrollers is the introduction of 32-bit\
    \ CPUs\n   that are becoming cheaper and more easily available than 8-bit CPUs,\n\
    \   in addition to being more easily programmable.  The flash memory size\n  \
    \ is probably easier to grow than other parameters in microcontrollers.\n   Flash\
    \ memory size is not expected to be the most significant limiting\n   factor.\
    \  Before picking a platform, developers should also plan for\n   firmware updates.\
    \  This would essentially mean that the platform\n   should at least have a flash\
    \ memory size of the total code size * 2,\n   plus some space for buffer.\n  \
    \ The situation is less clear with regards to the amount of CPU power\n   needed\
    \ to run the algorithms.  The demonstrated speeds are sufficient\n   for many\
    \ applications.  For instance, a sensor that wakes up every\n   now and then can\
    \ likely spend a fraction of a second, or even spend\n   multiple seconds in some\
    \ cases, for the computation of a signature\n   for the message that it is about\
    \ to send.  Most applications that use\n   protocols such as DTLS that use public-key\
    \ cryptography only at the\n   beginning of the session would also be fine with\
    \ any of these\n   execution times.\n   Yet, with reasonably long key sizes, the\
    \ execution times are in the\n   seconds, dozens of seconds, or even longer. \
    \ For some applications,\n   this is too long.  Nevertheless, these algorithms\
    \ can successfully be\n   employed in resource-constrained devices for the following\
    \ reasons:\n   o  With the right selection of algorithms and libraries, the\n\
    \      execution times can actually be very small (less than 500 ms).\n   o  As\
    \ discussed in [wiman], in general, the power requirements\n      necessary to\
    \ turn the radio on/off and sending or receiving\n      messages are far bigger\
    \ than those needed to execute cryptographic\n      operations.  While there are\
    \ newer radios that significantly lower\n      the energy consumption of sending\
    \ and receiving messages, there is\n      no good reason to choose platforms that\
    \ do not provide sufficient\n      computing power to run the necessary cryptographic\
    \ operations.\n   o  Commercial libraries and the use of full potential for various\n\
    \      optimizations will provide a better result than what we arrived at\n  \
    \    in this memo.\n   o  Using public-key cryptography only at the beginning\
    \ of a session\n      will reduce the per-packet processing times significantly.\n\
    \   While we did not do an exhaustive performance evaluation of\n   asymmetric\
    \ key-pair generation on resource-constrained devices, we\n   did note that it\
    \ is possible for such devices to generate a new key\n   pair.  Given that this\
    \ operation would only occur in rare\n   circumstances (such as a factory reset\
    \ or ownership change) and its\n   potential privacy benefits, developers should\
    \ provide mechanisms for\n   generating new identities.  However, it is extremely\
    \ important to\n   note that the security of this operation relies on access to\n\
    \   cryptographic-quality randomness.\n"
- title: 8.2.  Freshness
  contents:
  - "8.2.  Freshness\n   In our architecture, if implemented as described thus far,\
    \ messages\n   along with their signatures sent from the sensors to the publish-\n\
    \   subscribe broker can be recorded and replayed by an eavesdropper.\n   The\
    \ publish-subscribe broker has no mechanism to distinguish\n   previously received\
    \ packets from those that are retransmitted by the\n   sender or replayed by an\
    \ eavesdropper.  Therefore, it is essential\n   for the smart objects to ensure\
    \ that data updates include a freshness\n   indicator.  However, ensuring freshness\
    \ on constrained devices can be\n   non-trivial because of several reasons, which\
    \ include:\n   o  Communication is mostly unidirectional to save energy.\n   o\
    \  Internal clocks might not be accurate and may be reset several\n      times\
    \ during the operational phase of the smart object.\n   o  Network time synchronization\
    \ protocols such as the Network Time\n      Protocol (NTP) [RFC5905] are resource\
    \ intensive and therefore may\n      be undesirable in many smart object networks.\n\
    \   There are several different methods that can be used in our\n   architecture\
    \ for replay protection.  The selection of the appropriate\n   choice depends\
    \ on the actual deployment scenario.\n   Including sequence numbers in signed\
    \ messages can provide an\n   effective method of replay protection.  The publish-subscribe\
    \ broker\n   should verify the sequence number of each incoming message and accept\n\
    \   it only if it is greater than the highest previously seen sequence\n   number.\
    \  The publish-subscribe broker drops any packet with a\n   sequence number that\
    \ has already been received or if the received\n   sequence number is greater\
    \ than the highest previously seen sequence\n   number by an amount larger than\
    \ the preset threshold.\n   Sequence numbers can wrap around at their maximum\
    \ value; therefore,\n   it is essential to ensure that sequence numbers are sufficiently\n\
    \   long.  However, including long sequence numbers in packets can\n   increase\
    \ the network traffic originating from the sensor and can thus\n   decrease its\
    \ energy efficiency.  To overcome the problem of long\n   sequence numbers, we\
    \ can use a scheme similar to that of Huang\n   [huang], where the sender and\
    \ receiver maintain and sign long\n   sequence numbers of equal bit lengths, but\
    \ they transmit only the\n   least-significant bits.\n   It is important for the\
    \ smart object to write the sequence number\n   into the permanent flash memory\
    \ after each increment and before it is\n   included in the message to be transmitted.\
    \  This ensures that the\n   sensor can obtain the last sequence number it had\
    \ intended to send in\n   case of a reset or a power failure.  However, the sensor\
    \ and the\n   publish-subscribe broker can still end up in a discordant state\
    \ where\n   the sequence number received by the publish-subscribe broker exceeds\n\
    \   the expected sequence number by an amount greater than the preset\n   threshold.\
    \  This may happen because of a prolonged network outage or\n   if the publish-subscribe\
    \ broker experiences a power failure for some\n   reason.  Therefore, it is essential\
    \ for sensors that normally send\n   Non-Confirmable data updates to send some\
    \ Confirmable updates and\n   resynchronize with the publish-subscribe broker\
    \ if a reset message is\n   received.  The sensors resynchronize by sending a\
    \ new registration\n   message with the current sequence number.\n   Although\
    \ sequence numbers protect the system from replay attacks, a\n   publish-subscribe\
    \ broker has no mechanism to determine the time at\n   which updates were created\
    \ by the sensor.  Moreover, if sequence\n   numbers are the only freshness indicator\
    \ used, a malicious\n   eavesdropper can induce inordinate delays to the communication\
    \ of\n   signed updates by buffering messages.  It may be important in certain\n\
    \   smart object networks for sensors to send data updates that include\n   timestamps\
    \ to allow the publish-subscribe broker to determine the\n   time when the update\
    \ was created.  For example, when the publish-\n   subscribe broker is collecting\
    \ temperature data, it may be necessary\n   to know when exactly the temperature\
    \ measurement was made by the\n   sensor.  A simple solution to this problem is\
    \ for the publish-\n   subscribe broker to assume that the data object was created\
    \ when it\n   receives the update.  In a relatively reliable network with low\
    \ RTT,\n   it can be acceptable to make such an assumption.  However, most\n \
    \  networks are susceptible to packet loss and hostile attacks making\n   this\
    \ assumption unsustainable.\n   Depending on the hardware used by the smart objects,\
    \ they may have\n   access to accurate hardware clocks, which can be used to include\n\
    \   timestamps in the signed updates.  These timestamps are included in\n   addition\
    \ to sequence numbers.  The clock time in the smart objects\n   can be set by\
    \ the manufacturer, or the current time can be\n   communicated by the publish-subscribe\
    \ broker during the registration\n   phase.  However, these approaches require\
    \ the smart objects to either\n   rely on the long-term accuracy of the clock\
    \ set by the manufacturer\n   or trust the publish-subscribe broker thereby increasing\
    \ the\n   potential vulnerability of the system.  The smart objects could also\n\
    \   obtain the current time from NTP, but this may consume additional\n   energy\
    \ and give rise to security issues discussed in [RFC5905].  The\n   smart objects\
    \ could also have access to a mobile network or the\n   Global Positioning System\
    \ (GPS), and they can be used obtain the\n   current time.  Finally, if the sensors\
    \ need to coordinate their sleep\n   cycles, or if the publish-subscribe broker\
    \ computes an average or\n   mean of updates collected from multiple smart objects,\
    \ it is\n   important for the network nodes to synchronize the time among them.\n\
    \   This can be done by using existing synchronization schemes.\n"
- title: 8.3.  Layering
  contents:
  - "8.3.  Layering\n   It would be useful to select just one layer where security\
    \ is\n   provided at.  Otherwise, a simple device needs to implement multiple\n\
    \   security mechanisms.  While some code can probably be shared across\n   such\
    \ implementations (like algorithms), it is likely that most of the\n   code involving\
    \ the actual protocol machinery cannot.  Looking at the\n   different layers,\
    \ here are the choices and their implications:\n   link layer:  This is probably\
    \ the most common solution today.  The\n      primary benefits of this choice\
    \ of layer are that security\n      services are commonly available (WLAN secrets,\
    \ cellular SIM cards,\n      etc.) and that their application protects the entire\n\
    \      communications.\n      The main drawback is that there is no security beyond\
    \ the first\n      hop.  This can be problematic, e.g., in many devices that\n\
    \      communicate to a server in the Internet.  A smart home weighing\n     \
    \ scale, for instance, can support WLAN security, but without some\n      level\
    \ of end-to-end security, it would be difficult to prevent\n      fraudulent data\
    \ submissions to the servers.\n      Another drawback is that some commonly implemented\
    \ link-layer\n      security designs use group secrets.  This allows any device\
    \ within\n      the local network (e.g., an infected laptop) to attack the\n \
    \     communications.\n   network layer:  There are a number of solutions in this\
    \ space and\n      many new ones and variations thereof being proposed: IPsec,\
    \ PANA,\n      and so on.  In general, these solutions have similar\n      characteristics\
    \ to those in the transport layer: they work across\n      forwarding hops but\
    \ only as far as to the next middlebox or\n      application entity.  There is\
    \ plenty of existing solutions and\n      designs.\n      Experience has shown\
    \ that it is difficult to control IP-layer\n      entities from an application\
    \ process.  While this is theoretically\n      easy, in practice the necessary\
    \ APIs do not exist.  For instance,\n      most IPsec software has been built\
    \ for the VPN use case and is\n      difficult or impossible to tweak to be used\
    \ on a per-application\n      basis.  As a result, the authors are not particularly\
    \ enthusiastic\n      about recommending these solutions.\n   transport and application\
    \ layer:  This is another popular solution\n      along with link-layer designs.\
    \  TLS with HTTP (HTTPS) and DTLS\n      with CoAP are examples of solutions in\
    \ this space and have been\n      proven to work well.  These solutions are typically\
    \ easy to take\n      into use in an application, without assuming anything from\
    \ the\n      underlying OS, and they are easy to control as needed by the\n  \
    \    applications.  The main drawback is that generally speaking, these\n    \
    \  solutions only run as far as the next application level entity.\n      And\
    \ even for this case, HTTPS can be made to work through proxies,\n      so this\
    \ limit is not unsolvable.  Another drawback is that attacks\n      on the link\
    \ layer, network layer, and in some cases, transport\n      layer, cannot be protected\
    \ against.  However, if the upper layers\n      have been protected, such attacks\
    \ can at most result in a denial\n      of service.  Since denial of service can\
    \ often be caused anyway,\n      it is not clear if this is a real drawback.\n\
    \   data-object layer:  This solution does not protect any of the\n      protocol\
    \ layers but protects individual data elements being sent.\n      It works particularly\
    \ well when there are multiple application-\n      layer entities on the path\
    \ of the data.  Smart object networks are\n      likely to employ such entities\
    \ for storage, filtering, aggregation\n      and other reasons, and as such, an\
    \ end-to-end solution is the only\n      one that can protect the actual data.\n\
    \      The downside is that the lower layers are not protected.  But\n      again,\
    \ as long as the data is protected and checked upon every\n      time it passes\
    \ through an application-level entity, it is not\n      clear that there are attacks\
    \ beyond denial of service.\n      The main question mark is whether this type\
    \ of a solution provides\n      sufficient advantages over the more commonly implemented\
    \ transport\n      and application-layer solutions.\n"
- title: 8.4.  Symmetric vs. Asymmetric Crypto
  contents:
  - "8.4.  Symmetric vs. Asymmetric Crypto\n   The second trade-off that is worth\
    \ discussing is the use of plain\n   asymmetric cryptographic mechanisms, plain\
    \ symmetric cryptographic\n   mechanisms, or some mixture thereof.\n   Contrary\
    \ to popular cryptographic community beliefs, a symmetric\n   cryptographic solution\
    \ can be deployed in large scale.  In fact, one\n   of the largest deployments\
    \ of cryptographic security, the cellular\n   network authentication system, uses\
    \ Subscriber Identification Module\n   (SIM) cards that are based on symmetric\
    \ secrets.  In contrast,\n   public-key systems have yet to show an ability to\
    \ scale to hundreds\n   of millions of devices, let alone billions.  But the authors\
    \ do not\n   believe scaling is an important differentiator when comparing the\n\
    \   solutions.\n   As can be seen from Section 6, the time needed to calculate\
    \ some of\n   the asymmetric cryptographic operations with reasonable key lengths\n\
    \   can be significant.  There are two contrary observations that can be\n   made\
    \ from this.  First, recent wisdom indicates that computing power\n   on resource-constrained\
    \ devices is far cheaper than transmission\n   power [wiman], and it keeps on\
    \ becoming more efficient very quickly.\n   From this we can conclude that the\
    \ sufficient CPU is or at least will\n   be easily available.\n   But the other\
    \ observation is that when there are very costly\n   asymmetric operations, doing\
    \ a key exchange followed by the use of\n   generated symmetric keys would make\
    \ sense.  This model works very\n   well for DTLS and other transport-layer solutions,\
    \ but it works less\n   well for data-object security, particularly when the number\
    \ of\n   communicating entities is not exactly two.\n"
- title: 9.  Summary
  contents:
  - "9.  Summary\n   This document makes several security recommendations based on\
    \ our\n   implementation experience.  We summarize some of the important ones\n\
    \   here:\n   o  Developers and product designers should choose the hardware after\n\
    \      determining the security requirements for their application\n      scenario.\n\
    \   o  ECC outperforms RSA-based operations; therefore, it is recommended\n  \
    \    for resource-constrained devices.\n   o  Cryptographic-quality randomness\
    \ is needed for many security\n      protocols.  Developers and vendors should\
    \ ensure that the\n      sufficient randomness is available for security critical\
    \ tasks.\n   o  32-bit microcontrollers are much more easily available, at lower\n\
    \      costs, and are more power efficient.  Therefore, real-world\n      deployments\
    \ are better off using 32-bit microcontrollers.\n   o  Developers should provide\
    \ mechanisms for devices to generate new\n      identities at appropriate times\
    \ during their life cycle, for\n      example, after a factory reset or an ownership\
    \ handover.\n   o  Planning for firmware updates is important.  The hardware platform\n\
    \      chosen should at least have a flash memory size of the total code\n   \
    \   size * 2, plus some space for buffer.\n"
- title: 10.  Security Considerations
  contents:
  - "10.  Security Considerations\n   This entire memo deals with security issues.\n"
- title: 11.  IANA Considerations
  contents:
  - "11.  IANA Considerations\n   This document has no IANA actions.\n"
- title: 12.  Informative References
  contents:
  - "12.  Informative References\n   [arduino-uno]\n              Arduino, \"Arduino\
    \ Uno REV3\",\n              <http://arduino.cc/en/Main/arduinoBoardUno>.\n  \
    \ [armecdsa] Tschofenig, H. and M. Pegourie-Gonnard, \"Performance\n         \
    \     Investigations\", March 2015,\n              <https://www.ietf.org/proceedings/92/slides/\n\
    \              slides-92-lwig-3.pdf>.\n   [avr-crypto-lib]\n              Das\
    \ Labor, \"AVR-Crypto-Lib\", February 2014,\n              <http://www.das-labor.org/wiki/AVR-Crypto-Lib/en>.\n\
    \   [avr-cryptolib]\n              \"AVRCryptoLib\", <http://www.emsign.nl/>.\n\
    \   [avrora]   Avora, \"The AVR Simulation and Analysis Framework\",\n       \
    \       <http://compilers.cs.ucla.edu/avrora/>.\n   [CoAP-BROKER]\n          \
    \    Koster, M., Keranen, A., and J. Jimenez, \"Publish-\n              Subscribe\
    \ Broker for the Constrained Application Protocol\n              (CoAP)\", Work\
    \ in Progress, draft-ietf-core-coap-pubsub-04,\n              March 2018.\n  \
    \ [CoAP-SECURITY]\n              Arkko, J. and A. Keranen, \"CoAP Security Architecture\"\
    ,\n              Work n Progress, draft-arkko-core-security-arch-00, July\n  \
    \            2011.\n   [CoAP-SENSORS]\n              Arkko, J., Rissanen, H.,\
    \ Loreto, S., Turanyi, Z., and O.\n              Novo, \"Implementing Tiny COAP\
    \ Sensors\", Wok in Progress,\n              draft-arkko-core-sleepy-sensors-01,\
    \ July 2011.\n   [CoRE-RD]  Shelby, Z., Koster, M., Bormann, C., Stok, P., and\
    \ C.\n              Amsuess, \"CoRE Resource Directory\", Work in Progress,\n\
    \              draft-ietf-core-resource-directory-13, March 2018.\n   [freescale]\n\
    \              ARM Mbed, \"FRDM-KL25Z\",\n              <https://developer.mbed.org/platforms/KL25Z/>.\n\
    \   [hahmos]   Hahm, O., Baccelli, E., Petersen, H., and N. Tsiftes,\n       \
    \       \"Operating systems for low-end devices in the internet of\n         \
    \     things: a survey\", IEEE Internet of Things Journal,\n              Vol.\
    \ 3, Issue 5, DOI 10.1109/JIOT.2015.2505901, October\n              2016.\n  \
    \ [HIP-DEX]  Moskowitz, R., Ed. and R. Hummen, \"HIP Diet EXchange\n         \
    \     (DEX)\", Work in Progress, draft-ietf-hip-dex-06, December\n           \
    \   2017.\n   [huang]    Huang, C., \"LOFT: Low-overhead freshness transmission\
    \ in\n              sensor networks\", IEEE, DOI 10.1109/SUTC.2008.38, June\n\
    \              2008.\n   [IoT-BOOTSTRAPPING]\n              Sarikaya, B., Sethi,\
    \ M., and A. Sangi, \"Secure IoT\n              Bootstrapping: A Survey\", Work\
    \ in Progress,\n              draft-sarikaya-t2trg-sbootstrapping-03, February\
    \ 2017.\n   [IoT-SECURITY]\n              Garcia-Morchon, O., Kumar, S., and M.\
    \ Sethi,\n              \"State-of-the-Art and Challenges for the Internet of\n\
    \              Things Security\", Work in Progress,\n              draft-irtf-t2trg-iot-seccons-14,\
    \ April 2018.\n   [IPV6-LOWPAN-SEC]\n              Park, S., Kim, K., Haddad,\
    \ W., Chakrabarti, S., and J.\n              Laganier, \"IPv6 over Low Power WPAN\
    \ Security Analysis\",\n              Work in Progress, draft-daniel-6lowpan-security-\n\
    \              analysis-05, March 2011.\n   [matrix-ssl]\n              Inside\
    \ Secure, \"GUARD TLS Toolkit (formerly Matrix SSL)\",\n              <http://www.matrixssl.org/>.\n\
    \   [mbed]     ARM Mbed, \"Mbed TLS\",\n              <https://www.mbed.com/en/technologies/security/mbed-tls/>.\n\
    \   [micronacl]\n              MicroNaCl, \"The Networking and Cryptography library\
    \ for\n              microcontrollers\", <http://munacl.cryptojedi.org/>.\n  \
    \ [mosdorf]  Mosdorf, M. and W. Zabolotny, \"Implementation of elliptic\n    \
    \          curve cryptography for 8-bit and 32-bit embedded systems -\n      \
    \        time efficiency and power consumption analysis\", Pomiary\n         \
    \     Automatyka  Kontrola, 2010.\n   [MT-SenML] Jennings, C., Shelby, Z., Arkko,\
    \ J., Keranen, A., and C.\n              Bormann, \"Sensor Measurement Lists (SenML)\"\
    , Work in\n              Progress, draft-ietf-core-senml-15, May 2018.\n   [nacl]\
    \     NaCl, \"Networking and Cryptography library\",\n              <http://nacl.cr.yp.to/>.\n\
    \   [naclavr]  Hutter, M. and P. Schwabe, \"NaCl on 8-Bit AVR\n              Microcontrollers\"\
    , International Conference on\n              Cryptology in Africa, Computer Science,\
    \ Vol. 7918, pp.\n              156-172, February 2013,\n              <https://doi.org/10.1007/978-3-642-38553-7_9>.\n\
    \   [nesC]     Gay, D., Levis, P., von Behren, R., Welsh, M., Brewer, E.,\n  \
    \            and D. Culler, \"The nesC language: A holistic approach to\n    \
    \          networked embedded systems\", ACM SIGPLAN Notices, Vol. 38,\n     \
    \         Issue 5, DOI 10.1145/781131.781133, 2003.\n   [nordic]   Nordic Semiconductor,\
    \ \"nRF52832 Product Specification\n              v1.3\", March 2017, <http://infocenter.nordicsemi.com/pdf/\n\
    \              nRF52832_PS_v1.3.pdf>.\n   [relic-toolkit]\n              \"relic\"\
    , March 2017,\n              <https://github.com/relic-toolkit/relic>.\n   [RFC3748]\
    \  Aboba, B., Blunk, L., Vollbrecht, J., Carlson, J., and H.\n              Levkowetz,\
    \ Ed., \"Extensible Authentication Protocol\n              (EAP)\", RFC 3748,\
    \ DOI 10.17487/RFC3748, June 2004,\n              <https://www.rfc-editor.org/info/rfc3748>.\n\
    \   [RFC3972]  Aura, T., \"Cryptographically Generated Addresses (CGA)\",\n  \
    \            RFC 3972, DOI 10.17487/RFC3972, March 2005,\n              <https://www.rfc-editor.org/info/rfc3972>.\n\
    \   [RFC4086]  Eastlake 3rd, D., Schiller, J., and S. Crocker,\n             \
    \ \"Randomness Requirements for Security\", BCP 106, RFC 4086,\n             \
    \ DOI 10.17487/RFC4086, June 2005,\n              <https://www.rfc-editor.org/info/rfc4086>.\n\
    \   [RFC4303]  Kent, S., \"IP Encapsulating Security Payload (ESP)\",\n      \
    \        RFC 4303, DOI 10.17487/RFC4303, December 2005,\n              <https://www.rfc-editor.org/info/rfc4303>.\n\
    \   [RFC5191]  Forsberg, D., Ohba, Y., Ed., Patil, B., Tschofenig, H.,\n     \
    \         and A. Yegin, \"Protocol for Carrying Authentication for\n         \
    \     Network Access (PANA)\", RFC 5191, DOI 10.17487/RFC5191,\n             \
    \ May 2008, <https://www.rfc-editor.org/info/rfc5191>.\n   [RFC5246]  Dierks,\
    \ T. and E. Rescorla, \"The Transport Layer Security\n              (TLS) Protocol\
    \ Version 1.2\", RFC 5246,\n              DOI 10.17487/RFC5246, August 2008,\n\
    \              <https://www.rfc-editor.org/info/rfc5246>.\n   [RFC5406]  Bellovin,\
    \ S., \"Guidelines for Specifying the Use of IPsec\n              Version 2\"\
    , BCP 146, RFC 5406, DOI 10.17487/RFC5406,\n              February 2009, <https://www.rfc-editor.org/info/rfc5406>.\n\
    \   [RFC5905]  Mills, D., Martin, J., Ed., Burbank, J., and W. Kasch,\n      \
    \        \"Network Time Protocol Version 4: Protocol and Algorithms\n        \
    \      Specification\", RFC 5905, DOI 10.17487/RFC5905, June 2010,\n         \
    \     <https://www.rfc-editor.org/info/rfc5905>.\n   [RFC6078]  Camarillo, G.\
    \ and J. Melen, \"Host Identity Protocol (HIP)\n              Immediate Carriage\
    \ and Conveyance of Upper-Layer Protocol\n              Signaling (HICCUPS)\"\
    , RFC 6078, DOI 10.17487/RFC6078,\n              January 2011, <https://www.rfc-editor.org/info/rfc6078>.\n\
    \   [RFC6347]  Rescorla, E. and N. Modadugu, \"Datagram Transport Layer\n    \
    \          Security Version 1.2\", RFC 6347, DOI 10.17487/RFC6347,\n         \
    \     January 2012, <https://www.rfc-editor.org/info/rfc6347>.\n   [RFC6574] \
    \ Tschofenig, H. and J. Arkko, \"Report from the Smart Object\n              Workshop\"\
    , RFC 6574, DOI 10.17487/RFC6574, April 2012,\n              <https://www.rfc-editor.org/info/rfc6574>.\n\
    \   [RFC6690]  Shelby, Z., \"Constrained RESTful Environments (CoRE) Link\n  \
    \            Format\", RFC 6690, DOI 10.17487/RFC6690, August 2012,\n        \
    \      <https://www.rfc-editor.org/info/rfc6690>.\n   [RFC7230]  Fielding, R.,\
    \ Ed. and J. Reschke, Ed., \"Hypertext Transfer\n              Protocol (HTTP/1.1):\
    \ Message Syntax and Routing\",\n              RFC 7230, DOI 10.17487/RFC7230,\
    \ June 2014,\n              <https://www.rfc-editor.org/info/rfc7230>.\n   [RFC7252]\
    \  Shelby, Z., Hartke, K., and C. Bormann, \"The Constrained\n              Application\
    \ Protocol (CoAP)\", RFC 7252,\n              DOI 10.17487/RFC7252, June 2014,\n\
    \              <https://www.rfc-editor.org/info/rfc7252>.\n   [RFC7296]  Kaufman,\
    \ C., Hoffman, P., Nir, Y., Eronen, P., and T.\n              Kivinen, \"Internet\
    \ Key Exchange Protocol Version 2\n              (IKEv2)\", STD 79, RFC 7296,\
    \ DOI 10.17487/RFC7296, October\n              2014, <https://www.rfc-editor.org/info/rfc7296>.\n\
    \   [RFC7401]  Moskowitz, R., Ed., Heer, T., Jokela, P., and T.\n            \
    \  Henderson, \"Host Identity Protocol Version 2 (HIPv2)\",\n              RFC\
    \ 7401, DOI 10.17487/RFC7401, April 2015,\n              <https://www.rfc-editor.org/info/rfc7401>.\n\
    \   [RFC7515]  Jones, M., Bradley, J., and N. Sakimura, \"JSON Web\n         \
    \     Signature (JWS)\", RFC 7515, DOI 10.17487/RFC7515, May\n              2015,\
    \ <https://www.rfc-editor.org/info/rfc7515>.\n   [RFC7748]  Langley, A., Hamburg,\
    \ M., and S. Turner, \"Elliptic Curves\n              for Security\", RFC 7748,\
    \ DOI 10.17487/RFC7748, January\n              2016, <https://www.rfc-editor.org/info/rfc7748>.\n\
    \   [RFC7815]  Kivinen, T., \"Minimal Internet Key Exchange Version 2\n      \
    \        (IKEv2) Initiator Implementation\", RFC 7815,\n              DOI 10.17487/RFC7815,\
    \ March 2016,\n              <https://www.rfc-editor.org/info/rfc7815>.\n   [RFC8032]\
    \  Josefsson, S. and I. Liusvaara, \"Edwards-Curve Digital\n              Signature\
    \ Algorithm (EdDSA)\", RFC 8032,\n              DOI 10.17487/RFC8032, January\
    \ 2017,\n              <https://www.rfc-editor.org/info/rfc8032>.\n   [RFC8152]\
    \  Schaad, J., \"CBOR Object Signing and Encryption (COSE)\",\n              RFC\
    \ 8152, DOI 10.17487/RFC8152, July 2017,\n              <https://www.rfc-editor.org/info/rfc8152>.\n\
    \   [rsa-8bit] Gura, N., Patel, A., Wander, A., Eberle, H., and S.\n         \
    \     Shantz, \"Comparing Elliptic Curve Cryptography and RSA on\n           \
    \   8-bit CPUs\", DOI 10.1007/978-3-540-28632-5_9, 2004.\n   [rsa-high-speed]\n\
    \              Koc, C., \"High-Speed RSA Implementation\", November 1994,\n  \
    \            <http://storage.jak-stik.ac.id/rsasecurity/tr201.pdf>.\n   [sec2ecc]\
    \  Certicom Research, \"SEC 2: Recommended Elliptic Curve\n              Domain\
    \ Parameters\", Version 2.0, January 2010.\n   [stnucleo] STMicroelectronics,\
    \ \"NUCLEO-F091RC\",\n              <http://www.st.com/en/evaluation-tools/\n\
    \              nucleo-f091rc.html/>.\n   [tinyecc]  Liu, A. and P. Nig, \"TinyECC:\
    \ A Configurable Library for\n              Elliptic Curve Cryptography in Wireless\
    \ Sensor Networks\n              (Version 2.0)\", NCSU College of Engineering,\
    \ February\n              2011, <http://discovery.csc.ncsu.edu/software/TinyECC/>.\n\
    \   [wiman]    Margi, C., Oliveira, B., Sousa, G., Simplicio, M., Paulo,\n   \
    \           S., Carvalho, T., Naslund, M., and R. Gold, \"Impact of\n        \
    \      Operating Systems on Wireless Sensor Networks (Security)\n            \
    \  Applications and Testbeds\", Proceedings of the 19th\n              International\
    \ Conference on Computer Communciations and\n              Networks, DOI 10.1109/ICCCN.2010.5560028,\
    \ 2010.\n   [wiselib]  \"wiselib\", February 2015,\n              <https://github.com/ibr-alg/wiselib>.\n"
- title: Acknowledgments
  contents:
  - "Acknowledgments\n   The authors would like to thank Mats Naslund, Salvatore Loreto,\
    \ Bob\n   Moskowitz, Oscar Novo, Vlasios Tsiatsis, Daoyuan Li, Muhammad Waqas,\n\
    \   Eric Rescorla, and Tero Kivinen for interesting discussions in this\n   problem\
    \ space.  The authors would also like to thank Diego Aranha for\n   helping with\
    \ the relic-toolkit configurations and Tobias Baumgartner\n   for helping with\
    \ questions regarding wiselib.\n   Tim Chown, Samita Chakrabarti, Christian Huitema,\
    \ Dan Romascanu, Eric\n   Vyncke, and Emmanuel Baccelli provided valuable comments\
    \ that helped\n   us improve this document.\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Mohit Sethi\n   Ericsson\n   Jorvas  02420\n   Finland\n\
    \   Email: mohit@piuha.net\n   Jari Arkko\n   Ericsson\n   Jorvas  02420\n   Finland\n\
    \   Email: jari.arkko@piuha.net\n   Ari Keranen\n   Ericsson\n   Jorvas  02420\n\
    \   Finland\n   Email: ari.keranen@ericsson.com\n   Heidi-Maria Back\n   Nokia\n\
    \   Helsinki  00181\n   Finland\n   Email: heidi.back@nokia.com\n"
