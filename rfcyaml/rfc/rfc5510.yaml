- contents:
  - '          Reed-Solomon Forward Error Correction (FEC) Schemes

    '
  title: __initial_text__
- contents:
  - "Status of This Memo\n   This document specifies an Internet standards track protocol
    for the\n   Internet community, and requests discussion and suggestions for\n
    \  improvements.  Please refer to the current edition of the \"Internet\n   Official
    Protocol Standards\" (STD 1) for the standardization state\n   and status of this
    protocol.  Distribution of this memo is unlimited.\n"
  title: Status of This Memo
- contents:
  - "Copyright Notice\n   Copyright (c) 2009 IETF Trust and the persons identified
    as the\n   document authors.  All rights reserved.\n   This document is subject
    to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents
    in effect on the date of\n   publication of this document (http://trustee.ietf.org/license-info).\n
    \  Please review these documents carefully, as they describe your rights\n   and
    restrictions with respect to this document.\n   This document may contain material
    from IETF Documents or IETF\n   Contributions published or made publicly available
    before November\n   10, 2008.  The person(s) controlling the copyright in some
    of this\n   material may not have granted the IETF Trust the right to allow\n
    \  modifications of such material outside the IETF Standards Process.\n   Without
    obtaining an adequate license from the person(s) controlling\n   the copyright
    in such materials, this document may not be modified\n   outside the IETF Standards
    Process, and derivative works of it may\n   not be created outside the IETF Standards
    Process, except to format\n   it for publication as an RFC or to translate it
    into languages other\n   than English.\n"
  title: Copyright Notice
- contents:
  - "Abstract\n   This document describes a Fully-Specified Forward Error Correction\n
    \  (FEC) Scheme for the Reed-Solomon FEC codes over GF(2^^m), where m is\n   in
    {2..16}, and its application to the reliable delivery of data\n   objects on the
    packet erasure channel (i.e., a communication path\n   where packets are either
    received without any corruption or discarded\n   during transmission).  This document
    also describes a Fully-Specified\n   FEC Scheme for the special case of Reed-Solomon
    codes over GF(2^^8)\n   when there is no encoding symbol group.  Finally, in the
    context of\n   the Under-Specified Small Block Systematic FEC Scheme (FEC Encoding\n
    \  ID 129), this document assigns an FEC Instance ID to the special case\n   of
    Reed-Solomon codes over GF(2^^8).\n   Reed-Solomon codes belong to the class of
    Maximum Distance Separable\n   (MDS) codes, i.e., they enable a receiver to recover
    the k source\n   symbols from any set of k received symbols.  The schemes described\n
    \  here are compatible with the implementation from Luigi Rizzo.\n"
  title: Abstract
- contents:
  - "Table of Contents\n   1. Introduction ....................................................4\n
    \  2. Terminology .....................................................5\n   3.
    Definitions Notations and Abbreviations .........................5\n      3.1.
    Definitions ................................................5\n      3.2. Notations
    ..................................................6\n      3.3. Abbreviations
    ..............................................7\n   4. Formats and Codes with
    FEC Encoding ID 2 ........................7\n      4.1. FEC Payload ID .............................................7\n
    \     4.2. FEC Object Transmission Information ........................8\n           4.2.1.
    Mandatory Elements ..................................8\n           4.2.2. Common
    Elements .....................................8\n           4.2.3. Scheme-Specific
    Elements ............................9\n           4.2.4. Encoding Format .....................................9\n
    \  5. Formats and Codes with FEC Encoding ID 5 .......................11\n      5.1.
    FEC Payload ID ............................................11\n      5.2. FEC
    Object Transmission Information .......................12\n           5.2.1. Mandatory
    Elements .................................12\n           5.2.2. Common Elements
    ....................................12\n           5.2.3. Scheme-Specific Elements
    ...........................12\n           5.2.4. Encoding Format ....................................12\n
    \  6. Procedures with FEC Encoding IDs 2 and 5 .......................13\n      6.1.
    Determining the Maximum Source Block Length (B) ...........13\n      6.2. Determining
    the Number of Encoding Symbols of a Block .....14\n   7. Small Block Systematic
    FEC Scheme (FEC Encoding ID 129)\n      and Reed-Solomon Codes over GF(2^^8) ...........................15\n
    \  8. Reed-Solomon Codes Specification for the Erasure Channel .......16\n      8.1.
    Finite Field ..............................................16\n      8.2. Reed-Solomon
    Encoding Algorithm ...........................17\n           8.2.1. Encoding Principles
    ................................17\n           8.2.2. Encoding Complexity ................................18\n
    \     8.3. Reed-Solomon Decoding Algorithm ...........................18\n           8.3.1.
    Decoding Principles ................................18\n           8.3.2. Decoding
    Complexity ................................19\n      8.4. Implementation for the
    Packet Erasure Channel .............19\n   9. Security Considerations ........................................22\n
    \     9.1. Problem Statement .........................................22\n      9.2.
    Attacks against the Data Flow .............................23\n           9.2.1.
    Access to Confidential Objects .....................23\n           9.2.2. Content
    Corruption .................................23\n      9.3. Attacks against the
    FEC Parameters ........................24\n   10. IANA Considerations ...........................................25\n
    \  11. Acknowledgments ...............................................25\n   12.
    References ....................................................26\n      12.1.
    Normative References .....................................26\n      12.2. Informative
    References ...................................26\n"
  title: Table of Contents
- contents:
  - "1.  Introduction\n   The use of Forward Error Correction (FEC) codes is a classical\n
    \  solution to improve the reliability of multicast and broadcast\n   transmissions.
    \ The [RFC5052] document describes a general framework\n   to use FEC in Content
    Delivery Protocols (CDPs).  The companion\n   document [RFC3453] describes some
    applications of FEC codes for\n   content delivery.\n   Recent FEC schemes like
    [RFC5053] and [RFC5170] proposed erasure\n   codes based on sparse graphs/matrices.
    \ These codes are efficient in\n   terms of processing but not optimal in terms
    of correction\n   capabilities when dealing with \"small\" objects.\n   The FEC
    schemes described in this document belongs to the class of\n   Maximum Distance
    Separable codes that are optimal in terms of erasure\n   correction capability.
    \ In others words, it enables a receiver to\n   recover the k source symbols from
    any set of exactly k encoding\n   symbols.  They are also systematic codes, which
    means that the k\n   source symbols are part of the encoding symbols.  Even if
    the\n   encoding/decoding complexity is larger than that of [RFC5053] or\n   [RFC5170],
    this family of codes is very useful.\n   Many applications dealing with content
    transmission or content\n   storage already rely on packet-based Reed-Solomon
    codes.  In\n   particular, many of them use the Reed-Solomon codec of Luigi Rizzo\n
    \  [RS-codec] [Rizzo97].  The goal of the present document is to specify\n   an
    implementation of Reed-Solomon codes that is compatible with this\n   codec.\n
    \  The present document:\n   o  introduces the Fully-Specified FEC Scheme with
    FEC Encoding ID 2,\n      which specifies the use of Reed-Solomon codes over GF(2^^m),
    where\n      m is in {2..16},\n   o  introduces the Fully-Specified FEC Scheme
    with FEC Encoding ID 5,\n      which focuses on the special case of Reed-Solomon
    codes over\n      GF(2^^8) and no encoding symbol group (i.e., exactly one symbol\n
    \     per packet), and\n   o  in the context of the Under-Specified Small Block
    Systematic FEC\n      Scheme (FEC Encoding ID 129) [RFC5445], assigns the FEC
    Instance\n      ID 0 to the special case of Reed-Solomon codes over GF(2^^8) and\n
    \     no encoding symbol group.\n   For a definition of the terms Fully-Specified
    and Under-Specified FEC\n   Schemes, see [RFC5052], Section 4.\n"
  title: 1.  Introduction
- contents:
  - "2.  Terminology\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\",
    \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\"
    in this\n   document are to be interpreted as described in RFC 2119 [RFC2119].\n"
  title: 2.  Terminology
- contents:
  - '3.  Definitions Notations and Abbreviations

    '
  - contents:
    - "3.1.  Definitions\n   This document uses the same terms and definitions as
      those specified\n   in [RFC5052].  Additionally, it uses the following definitions:\n
      \     Source symbol:  unit of data used during the encoding process.\n      Encoding
      symbol:  unit of data generated by the encoding process.\n      Repair symbol:
      \ encoding symbol that is not a source symbol.\n      Code rate:  the k/n ratio,
      i.e., the ratio between the number of\n         source symbols and the number
      of encoding symbols.  By\n         definition, the code rate is such that: 0
      < code rate <= 1.  A\n         code rate close to 1 indicates that a small number
      of repair\n         symbols have been produced during the encoding process.\n
      \     Systematic code:  FEC code in which the source symbols are part of\n         the
      encoding symbols.\n      Source block:  a block of k source symbols that are
      considered\n         together for the encoding.\n      Encoding Symbol Group:
      \ a group of encoding symbols that are sent\n         together within the same
      packet, and whose relationships to the\n         source block can be derived
      from a single Encoding Symbol ID.\n      Source Packet:  a data packet containing
      only source symbols.\n      Repair Packet:  a data packet containing only repair
      symbols.\n      Packet Erasure Channel:  a communication path where packets
      are\n         either dropped (e.g., by a congested router, or because the\n
      \        number of transmission errors exceeds the correction\n         capabilities
      of the physical layer codes) or received.  When a\n         packet is received,
      it is assumed that this packet is not\n         corrupted.\n"
    title: 3.1.  Definitions
  - contents:
    - "3.2.  Notations\n   This document uses the following notations:\n      L      the
      object transfer length in bytes.\n      k      the number of source symbols
      in a source block.\n      n_r    the number of repair symbols generated for
      a source block.\n      n      the encoding block length, i.e., the number of
      encoding\n             symbols generated for a source block.  Therefore: n =
      k +\n             n_r.\n      max_n  the maximum number of encoding symbols
      generated for any\n             source block.\n      B      the maximum source
      block length in symbols, i.e., the\n             maximum number of source symbols
      per source block.\n      N      the number of source blocks into which the object
      shall be\n             partitioned.\n      E      the encoding symbol length
      in bytes.\n      S      the symbol size in units of m-bit elements.  When m
      = 8,\n             then S and E are equal.\n      m      the length of the elements
      in the finite field, in bits.\n             In this document, m belongs to {2..16}.\n
      \     q      the number of elements in the finite field.  We have: q =\n             2^^m
      in this specification.\n      G      the number of encoding symbols per group,
      i.e., the number\n             of symbols sent in the same packet.\n      GM
      \    the Generator Matrix of a Reed-Solomon code.\n      CR     the \"code rate\",
      i.e., the k/n ratio.\n      a^^b   a raised to the power b.\n      a^^-1  the
      inverse of a.\n      I_k    the k*k identity matrix.\n"
    title: 3.2.  Notations
  - contents:
    - "3.3.  Abbreviations\n   This document uses the following abbreviations:\n      ESI
      \     Encoding Symbol ID.\n      FEC OTI  FEC Object Transmission Information.\n
      \     RS       Reed-Solomon.\n      MDS      Maximum Distance Separable code.\n
      \     GF(q)    a finite field (also known as Galois Field) with q\n               elements.
      \ We assume that q = 2^^m in this document.\n"
    title: 3.3.  Abbreviations
  title: 3.  Definitions Notations and Abbreviations
- contents:
  - "4.  Formats and Codes with FEC Encoding ID 2\n   This section introduces the
    formats and codes associated with the\n   Fully-Specified FEC Scheme with FEC
    Encoding ID 2, which specifies\n   the use of Reed-Solomon codes over GF(2^^m).\n"
  - contents:
    - "4.1.  FEC Payload ID\n   The FEC Payload ID is composed of the Source Block
      Number and the\n   Encoding Symbol ID.  The lengths of these two fields depend
      on the\n   parameter m (which is transmitted in the FEC OTI) as follows:\n   o
      \ The Source Block Number (field of size 32-m bits) identifies from\n      which
      source block of the object the encoding symbol(s) in the\n      payload are
      generated.  There is a maximum of 2^^(32-m) blocks per\n      object.\n   o
      \ The Encoding Symbol ID (field of size m bits) identifies which\n      specific
      encoding symbol(s) generated from the source block are\n      carried in the
      packet payload.  There is a maximum of 2^^m\n      encoding symbols per block.
      \ The first k values (0 to k - 1)\n      identify source symbols, the remaining
      n-k values identify repair\n      symbols.\n   There MUST be exactly one FEC
      Payload ID per source or repair packet.\n   In case of an Encoding Symbol Group,
      when multiple encoding symbols\n   are sent in the same packet, the FEC Payload
      ID refers to the first\n   symbol of the packet.  The other symbols can be deduced
      from the ESI\n   of the first symbol by incrementing sequentially the ESI.\n
      \   0                   1                   2                   3\n    0 1 2
      3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  |     Source Block Number (32-8=24 bits)        | Enc. Symb. ID |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \      Figure 1: FEC Payload ID Encoding Format for m = 8 (Default)\n    0                   1
      \                  2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4
      5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  | Src Block Nb (32-16=16 bits)  |  Enc. Symbol ID (m=16 bits)   |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \           Figure 2: FEC Payload ID Encoding Format for m = 16\n   The formats
      of the FEC Payload ID for m = 8 and m = 16 are\n   illustrated in Figure 1 and
      Figure 2, respectively.\n"
    title: 4.1.  FEC Payload ID
  - contents:
    - '4.2.  FEC Object Transmission Information

      '
    - contents:
      - "4.2.1.  Mandatory Elements\n   o  FEC Encoding ID: the Fully-Specified FEC
        Scheme described in this\n      section uses FEC Encoding ID 2.\n"
      title: 4.2.1.  Mandatory Elements
    - contents:
      - "4.2.2.  Common Elements\n   The following elements MUST be defined with the
        present FEC scheme.\n   o  Transfer-Length (L): a non-negative integer indicating
        the length\n      of the object in bytes.  There are some restrictions on
        the\n      maximum Transfer-Length that can be supported:\n         max_transfer_length
        = 2^^(32-m) * B * E\n      For instance, for m = 8, for B = 2^^8 - 1 (because
        the codec\n      operates on a finite field with 2^^8 elements), and if E
        = 1024\n      bytes, then the maximum transfer length is approximately equal
        to\n      2^^42 bytes (i.e., 4 terabytes).  Similarly, for m = 16, for B =\n
        \     2^^16 - 1, and if E = 1024 bytes, then the maximum transfer length\n
        \     is also approximately equal to 2^^42 bytes.  For larger objects,\n      another
        FEC scheme, with a larger Source Block Number field in the\n      FEC Payload
        ID, could be defined.  Another solution consists in\n      fragmenting large
        objects into smaller objects, each of them\n      complying with the above
        limits.\n   o  Encoding-Symbol-Length (E): a non-negative integer indicating
        the\n      length of each encoding symbol in bytes.\n   o  Maximum-Source-Block-Length
        (B): a non-negative integer indicating\n      the maximum number of source
        symbols in a source block.\n   o  Max-Number-of-Encoding-Symbols (max_n):
        a non-negative integer\n      indicating the maximum number of encoding symbols
        generated for\n      any source block.\n   Section 6 explains how to derive
        the values of each of these\n   elements.\n"
      title: 4.2.2.  Common Elements
    - contents:
      - "4.2.3.  Scheme-Specific Elements\n   The following element MUST be defined
        with the present FEC scheme.\n   It contains two distinct pieces of information:\n
        \  o  G: a non-negative integer indicating the number of encoding\n      symbols
        per group used for the object.  The default value is 1,\n      meaning that
        each packet contains exactly one symbol.  When no G\n      parameter is communicated
        to the decoder, then the latter MUST\n      assume that G = 1.\n   o  m: The
        m parameter is the length of the finite field elements, in\n      bits.  It
        also characterizes the number of elements in the finite\n      field: q =
        2^^m elements.  The default value is m = 8.  When no\n      finite field size
        parameter is communicated to the decoder, then\n      the latter MUST assume
        that m = 8.\n"
      title: 4.2.3.  Scheme-Specific Elements
    - contents:
      - "4.2.4.  Encoding Format\n   This section shows the two possible encoding
        formats of the above FEC\n   OTI.  The present document does not specify when
        one encoding format\n   or the other should be used.\n"
      - contents:
        - "4.2.4.1.  Using the General EXT_FTI Format\n   The FEC OTI binary format
          is the following, when the EXT_FTI\n   mechanism is used (e.g., within the
          ALC [ALC] or NORM [NORM]\n   protocols).\n    0                   1                   2
          \                  3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2
          3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
          \  |   HET = 64    |    HEL = 4    |                               |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
          \                              +\n   |                      Transfer Length
          (L)                      |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
          \  |       m       |       G       |   Encoding Symbol Length (E)  |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
          \  |  Max Source Block Length (B)  |  Max Nb Enc. Symbols (max_n)  |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
          \                     Figure 3: EXT_FTI Header Format\n"
        title: 4.2.4.1.  Using the General EXT_FTI Format
      - contents:
        - "4.2.4.2.  Using the FDT Instance (FLUTE specific)\n   When it is desired
          that the FEC OTI be carried in the FDT (File\n   Delivery Table) Instance
          of a FLUTE session [FLUTE], the following\n   XML attributes must be described
          for the associated object:\n   o  FEC-OTI-FEC-Encoding-ID\n   o  FEC-OTI-Transfer-Length
          (L)\n   o  FEC-OTI-Encoding-Symbol-Length (E)\n   o  FEC-OTI-Maximum-Source-Block-Length
          (B)\n   o  FEC-OTI-Max-Number-of-Encoding-Symbols (max_n)\n   o  FEC-OTI-Scheme-Specific-Info\n
          \  The FEC-OTI-Scheme-Specific-Info contains the string resulting from\n
          \  the Base64 encoding (in the XML Schema xs:base64Binary sense) of the\n
          \  following value:\n    0                   1\n    0 1 2 3 4 5 6 7 8 9
          0 1 2 3 4 5\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   |       m       |
          \      G       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n    Figure 4: FEC
          OTI Scheme Specific Information To Be Included in the\n                               FDT
          Instance\n   When no m parameter is to be carried in the FEC OTI, the m
          field is\n   set to 0 (which is not a valid seed value).  Otherwise, the
          m field\n   contains a valid value as explained in Section 4.2.3.  Similarly,\n
          \  when no G parameter is to be carried in the FEC OTI, the G field is\n
          \  set to 0 (which is not a valid seed value).  Otherwise, the G field\n
          \  contains a valid value as explained in Section 4.2.3.  When neither m\n
          \  nor G are to be carried in the FEC OTI, then the sender simply omits\n
          \  the FEC-OTI-Scheme-Specific-Info attribute.\n   During Base64 encoding,
          the 2 bytes of the FEC OTI Scheme-Specific\n   Information are transformed
          into a string of 4 printable characters\n   (in the 64-character alphabet)
          that is added to the FEC-OTI-Scheme-\n   Specific-Info attribute.\n"
        title: 4.2.4.2.  Using the FDT Instance (FLUTE specific)
      title: 4.2.4.  Encoding Format
    title: 4.2.  FEC Object Transmission Information
  title: 4.  Formats and Codes with FEC Encoding ID 2
- contents:
  - "5.  Formats and Codes with FEC Encoding ID 5\n   This section introduces the
    formats and codes associated with the\n   Fully-Specified FEC Scheme with FEC
    Encoding ID 5, which focuses on\n   the special case of Reed-Solomon codes over
    GF(2^^8) and no encoding\n   symbol group.\n"
  - contents:
    - "5.1.  FEC Payload ID\n   The FEC Payload ID is composed of the Source Block
      Number and the\n   Encoding Symbol ID:\n   o  The Source Block Number (24-bit
      field) identifies from which\n      source block of the object the encoding
      symbol in the payload is\n      generated.  There is a maximum of 2^^24 blocks
      per object.\n   o  The Encoding Symbol ID (8-bit field) identifies which specific\n
      \     encoding symbol generated from the source block is carried in the\n      packet
      payload.  There is a maximum of 2^^8 encoding symbols per\n      block.  The
      first k values (0 to k - 1) identify source symbols;\n      the remaining n-k
      values identify repair symbols.\n   There MUST be exactly one FEC Payload ID
      per source or repair packet.\n   This FEC Payload ID refers to the one and only
      symbol of the packet.\n    0                   1                   2                   3\n
      \   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  |        Source Block Number (24 bits)          | Enc. Symb. ID |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \     Figure 5: FEC Payload ID Encoding Format with FEC Encoding ID 5\n"
    title: 5.1.  FEC Payload ID
  - contents:
    - '5.2.  FEC Object Transmission Information

      '
    - contents:
      - "5.2.1.  Mandatory Elements\n   o  FEC Encoding ID: the Fully-Specified FEC
        Scheme described in this\n      section uses FEC Encoding ID 5.\n"
      title: 5.2.1.  Mandatory Elements
    - contents:
      - "5.2.2.  Common Elements\n   The Common elements are the same as those specified
        in Section 4.2.2\n   when m = 8 and G = 1.\n"
      title: 5.2.2.  Common Elements
    - contents:
      - "5.2.3.  Scheme-Specific Elements\n   No Scheme-Specific elements are defined
        by this FEC scheme.\n"
      title: 5.2.3.  Scheme-Specific Elements
    - contents:
      - "5.2.4.  Encoding Format\n   This section shows the two possible encoding
        formats of the above FEC\n   OTI.  The present document does not specify when
        one encoding format\n   or the other should be used.\n"
      - contents:
        - "5.2.4.1.  Using the General EXT_FTI Format\n   The FEC OTI binary format
          is the following, when the EXT_FTI\n   mechanism is used (e.g., within the
          ALC [ALC] or NORM [NORM]\n   protocols).\n    0                   1                   2
          \                  3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2
          3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
          \  |   HET = 64    |    HEL = 3    |                               |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
          \                              +\n   |                      Transfer Length
          (L)                      |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
          \  |   Encoding Symbol Length (E)  | MaxBlkLen (B) |     max_n     |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
          \         Figure 6: EXT_FTI Header Format with FEC Encoding ID 5\n"
        title: 5.2.4.1.  Using the General EXT_FTI Format
      - contents:
        - "5.2.4.2.  Using the FDT Instance (FLUTE specific)\n   When it is desired
          that the FEC OTI be carried in the FDT Instance of\n   a FLUTE session [FLUTE],
          the following XML attributes must be\n   described for the associated object:\n
          \  o  FEC-OTI-FEC-Encoding-ID\n   o  FEC-OTI-Transfer-Length (L)\n   o  FEC-OTI-Encoding-Symbol-Length
          (E)\n   o  FEC-OTI-Maximum-Source-Block-Length (B)\n   o  FEC-OTI-Max-Number-of-Encoding-Symbols
          (max_n)\n"
        title: 5.2.4.2.  Using the FDT Instance (FLUTE specific)
      title: 5.2.4.  Encoding Format
    title: 5.2.  FEC Object Transmission Information
  title: 5.  Formats and Codes with FEC Encoding ID 5
- contents:
  - "6.  Procedures with FEC Encoding IDs 2 and 5\n   This section defines procedures
    that are common to FEC Encoding IDs 2\n   and 5.  In case of FEC Encoding ID 5,
    m = 8 and G = 1.  The block\n   partitioning algorithm that is defined in Section
    9.1 of [RFC5052]\n   MUST be used with FEC Encoding IDs 2 and 5.\n"
  - contents:
    - "6.1.  Determining the Maximum Source Block Length (B)\n   The finite field
      size parameter, m, defines the number of non-zero\n   elements in this field,
      which is equal to: q - 1 = 2^^m - 1.  Note\n   that q - 1 is also the theoretical
      maximum number of encoding symbols\n   that can be produced for a source block.
      \ For instance, when m = 8\n   (default) there is a maximum of 2^^8 - 1 = 255
      encoding symbols.\n   Given the target FEC code rate (e.g., provided by the
      user when\n   starting a FLUTE sending application), the sender calculates:\n
      \     max1_B = floor((2^^m - 1) * CR)\n   This max1_B value leaves enough room
      for the sender to produce the\n   desired number of parity symbols.\n   Additionally,
      a codec MAY impose other limitations on the maximum\n   block size.  Yet it
      is not expected that such limits exist when using\n   the default m = 8 value.
      \ This decision MUST be clarified at\n   implementation time, when the target
      use case is known.  This results\n   in a max2_B limitation.\n   Then, B is
      given by:\n      B = min(max1_B, max2_B)\n   Note that this calculation is only
      required at the coder, since the B\n   parameter is communicated to the decoder
      through the FEC OTI.\n"
    title: 6.1.  Determining the Maximum Source Block Length (B)
  - contents:
    - "6.2.  Determining the Number of Encoding Symbols of a Block\n   The following
      algorithm, also called \"n-algorithm\", explains how to\n   determine the maximum
      number of encoding symbols generated for any\n   source block (max_n) and the
      number of encoding symbols for a given\n   block (n) as a function of the target
      code rate.\n   AT A SENDER:\n   Input:\n      B: Maximum source block length,
      for any source block.  Section 6.1\n      explains how to determine its value.\n
      \     k: Current source block length.  This parameter is given by the\n      block
      partitioning algorithm.\n      CR: FEC code rate, which is given by the user
      (e.g., when starting\n      a FLUTE sending application).  It is expressed as
      a floating point\n      value.\n   Output:\n      max_n: Maximum number of encoding
      symbols generated for any source\n      block.\n      n: Number of encoding
      symbols generated for this source block.\n   Algorithm:\n      max_n = ceil(B
      / CR);\n      if (max_n > 2^^m - 1), then return an error (\"invalid code rate\");\n
      \     n = floor(k * max_n / B);\n   AT A RECEIVER:\n   Input:\n      B: Extracted
      from the received FEC OTI.\n      max_n: Extracted from the received FEC OTI.\n
      \     k: Given by the block partitioning algorithm.\n   Output:\n      n\n   Algorithm:\n
      \     n = floor(k * max_n / B);\n   It is RECOMMENDED that the \"n-algorithm\"
      be used by a sender, but\n   other algorithms remain possible to determine max_n
      and/or n.\n   At a receiver, the max_n value is extracted from the received
      FEC\n   OTI.  Since the Reed-Solomon decoder does not need to know the actual\n
      \  n value, using the receiver part of the \"n-algorithm\" is not\n   necessary
      from a decoding point of view.\n   However, a receiver may want to have an estimate
      of n for other\n   reasons (e.g., for memory management purposes).  In that
      case, a\n   receiver knows that the number of encoding symbols of a block cannot\n
      \  exceed max_n.  Additionally, if a receiver believes that a sender\n   uses
      the \"n-algorithm\", this receiver MAY use the receiver part of\n   the \"n-algorithm\"
      to get a better estimate of n.  When this is the\n   case, a receiver MUST be
      prepared to handle symbols with an Encoding\n   Symbol ID superior or equal
      to the computed n value (e.g., it can\n   choose to simply drop them).\n"
    title: 6.2.  Determining the Number of Encoding Symbols of a Block
  title: 6.  Procedures with FEC Encoding IDs 2 and 5
- contents:
  - "7.  Small Block Systematic FEC Scheme (FEC Encoding ID 129) and Reed-\n    Solomon
    Codes over GF(2^^8)\n   In the context of the Under-Specified Small Block Systematic
    FEC\n   Scheme (FEC Encoding ID 129) [RFC5445], this document assigns the FEC\n
    \  Instance ID 0 to the special case of Reed-Solomon codes over GF(2^^8)\n   and
    no encoding symbol group.\n   The FEC Instance ID 0 uses the Formats and Codes
    specified in\n   [RFC5445].\n   The FEC scheme with FEC Instance ID 0 MAY use
    the block partitioning\n   algorithm defined in Section 9.1 of [RFC5052] to partition
    the object\n   into source blocks.  This FEC scheme MAY also use another algorithm.\n
    \  For instance, the CDP sender may change the length of each source\n   block
    dynamically, depending on some external criteria (e.g., to\n   adjust the FEC
    coding rate to the current loss rate experienced by\n   NORM receivers) and inform
    the CDP receivers of the current block\n   length by means of the EXT_FTI mechanism.
    \ This choice is out of the\n   scope of the current document.\n"
  title: 7.  Small Block Systematic FEC Scheme (FEC Encoding ID 129) and Reed-
- contents:
  - "8.  Reed-Solomon Codes Specification for the Erasure Channel\n   Reed-Solomon
    (RS) codes are linear block codes.  They also belong to\n   the class of MDS codes.
    \ A [n,k]-RS code encodes a sequence of k\n   source elements defined over a finite
    field GF(q) into a sequence of\n   n encoding elements, where n is upper bounded
    by q - 1.  The\n   implementation described in this document is based on a generator\n
    \  matrix built from a Vandermonde matrix put into systematic form.\n   Sections
    8.1 to 8.3 specify the [n,k]-RS codes when applied to m-bit\n   elements, and
    Section 8.4 specifies the use of [n,k]-RS codes when\n   applied to symbols composed
    of several m-bit elements.  The use\n   described in Section 8.4 is the crux of
    this specification.\n   A reader who wants to understand the underlying theory
    is invited to\n   refer to references [Rizzo97] and [MWS77].\n"
  - contents:
    - "8.1.  Finite Field\n   A finite field GF(q) is defined as a finite set of q
      elements that\n   has a structure of field.  It contains necessarily q = p^^m
      elements,\n   where p is a prime number.  With packet erasure channels, p is
      always\n   set to 2.  The elements of the field GF(2^^m) can be represented
      by\n   polynomials with binary coefficients (i.e., over GF(2)) of degree\n   lower
      or equal to m-1.  The polynomials can be associated with binary\n   vectors
      of length m.  For example, the vector (11001) represents the\n   polynomial
      1 + x + x^^4.  This representation is often called\n   polynomial representation.
      \ The addition between two elements is\n   defined as the addition of binary
      polynomials in GF(2) and the\n   multiplication is the multiplication modulo
      a given irreducible\n   polynomial over GF(2) of degree m.  Note that all the
      roots of this\n   polynomial are in GF(2^^m) but not in GF(2).\n   The chosen
      polynomial representation of the finite field GF(2^^m) is\n   completely characterized
      by the irreducible polynomial.  The\n   following polynomials are chosen to
      represent the field GF(2^^m), for\n   m varying from 2 to 16:\n      m = 2,
      \"111\" (1+x+x^^2)\n      m = 3, \"1101\", (1+x+x^^3)\n      m = 4, \"11001\",
      (1+x+x^^4)\n      m = 5, \"101001\", (1+x^^2+x^^5)\n      m = 6, \"1100001\",
      (1+x+x^^6)\n      m = 7, \"10010001\", (1+x^^3+x^^7)\n      m = 8, \"101110001\",
      (1+x^^2+x^^3+x^^4+x^^8)\n      m = 9, \"1000100001\", (1+x^^4+x^^9)\n      m
      = 10, \"10010000001\", (1+x^^3+x^^10)\n      m = 11, \"101000000001\", (1+x^^2+x^^11)\n
      \     m = 12, \"1100101000001\", (1+x+x^^4+x^^6+x^^12)\n      m = 13, \"11011000000001\",
      (1+x+x^^3+x^^4+x^^13)\n      m = 14, \"110000100010001\", (1+x+x^^6+x^^10+x^^14)\n
      \     m = 15, \"1100000000000001\", (1+x+x^^15)\n      m = 16, \"11010000000010001\",
      (1+x+x^^3+x^^12+x^^16)\n   In order to facilitate the implementation, these
      polynomials are also\n   primitive.  This means that any element of GF(2^^m)
      can be expressed\n   as a power of a given root of this polynomial.  These polynomials
      are\n   also chosen so that they contain the minimum number of monomials.\n"
    title: 8.1.  Finite Field
  - contents:
    - '8.2.  Reed-Solomon Encoding Algorithm

      '
    - contents:
      - "8.2.1.  Encoding Principles\n   Let s = (s_0, ..., s_{k-1}) be a source vector
        of k elements over\n   GF(2^^m).  Let e = (e_0, ..., e_{n-1}) be the corresponding
        encoding\n   vector of n elements over GF(2^^m).  Being a linear code, encoding
        is\n   performed by multiplying the source vector by a generator matrix, GM,\n
        \  of k rows and n columns over GF(2^^m).  Thus:\n      e = s * GM.\n   The
        definition of the generator matrix completely characterizes the\n   RS code.\n
        \  Let us consider that n = 2^^m - 1 and that 0 < k <= n.  Let us denote\n
        \  by alpha the root of the primitive polynomial of degree m chosen in\n   the
        list of Section 8.1 for the corresponding value of m.  Let us\n   consider
        a Vandermonde matrix of k rows and n columns, denoted by\n   V_{k,n}, and
        built as follows: the {i, j} entry of V_{k,n} is v_{i,j}\n   = alpha^^(i*j),
        where 0 <= i <= k - 1 and 0 <= j <= n - 1.  This\n   matrix generates a MDS
        code.  However, this MDS code is not\n   systematic, which is a problem for
        many networking applications.  To\n   obtain a systematic matrix (and code),
        the simplest solution consists\n   in considering the matrix V_{k,k} formed
        by the first k columns of\n   V_{k,n}, then to invert it and to multiply this
        inverse by V_{k,n}.\n   Clearly, the product V_{k,k}^^-1 * V_{k,n} contains
        the identity\n   matrix I_k on its first k columns, meaning that the first
        k encoding\n   elements are equal to source elements.  Besides, the associated
        code\n   keeps the MDS property.\n   Therefore, the generator matrix of the
        code considered in this\n   document is:\n      GM = (V_{k,k}^^-1) * V_{k,n}\n
        \  Note that, in practice, the [n,k]-RS code can be shortened to a\n   [n',k]-RS
        code, where k <= n' < n, by considering the sub-matrix\n   formed by the n'
        first columns of GM.\n"
      title: 8.2.1.  Encoding Principles
    - contents:
      - "8.2.2.  Encoding Complexity\n   Encoding can be performed by first pre-computing
        GM and by\n   multiplying the source vector (k elements) by GM (k rows and
        n\n   columns).  The complexity of the pre-computation of the generator\n
        \  matrix can be estimated as the complexity of the multiplication of\n   the
        inverse of a Vandermonde matrix by n-k vectors (i.e., the last\n   n-k columns
        of V_{k,n}).  Since the complexity of the inverse of a\n   k*k-Vandermonde
        matrix by a vector is O(k * (log(k))^^2), the\n   generator matrix can be
        computed in 0((n-k)* k * (log(k))^^2))\n   operations.  When the generator
        matrix is pre-computed, the encoding\n   needs k operations per repair element
        (vector-matrix multiplication).\n   Encoding can also be performed by first
        computing the product s *\n   V_{k,k}^^-1 and then by multiplying the result
        with V_{k,n}.  The\n   multiplication by the inverse of a square Vandermonde
        matrix is known\n   as the interpolation problem and its complexity is O(k
        *\n   (log(k))^^2).  The multiplication by a Vandermonde matrix, known as\n
        \  the multipoint evaluation problem, requires O((n-k) * log(k)) by\n   using
        Fast Fourier Transform, as explained in [GO94].  The total\n   complexity
        of this encoding algorithm is then O((k/(n-k)) *\n   (log(k))^^2 + log(k))
        operations per repair element.\n"
      title: 8.2.2.  Encoding Complexity
    title: 8.2.  Reed-Solomon Encoding Algorithm
  - contents:
    - '8.3.  Reed-Solomon Decoding Algorithm

      '
    - contents:
      - "8.3.1.  Decoding Principles\n   The Reed-Solomon decoding algorithm for the
        erasure channel allows\n   the recovery of the k source elements from any
        set of k received\n   elements.  It is based on the fundamental property of
        the generator\n   matrix, which is such that any k*k-submatrix is invertible
        (see\n   [MWS77]).  The first step of the decoding consists in extracting
        the\n   k*k submatrix of the generator matrix obtained by considering the\n
        \  columns corresponding to the received elements.  Indeed, since any\n   encoding
        element is obtained by multiplying the source vector by one\n   column of
        the generator matrix, the received vector of k encoding\n   elements can be
        considered as the result of the multiplication of the\n   source vector by
        a k*k submatrix of the generator matrix.  Since this\n   submatrix is invertible,
        the second step of the algorithm is to\n   invert this matrix and to multiply
        the received vector by the\n   obtained matrix to recover the source vector.\n"
      title: 8.3.1.  Decoding Principles
    - contents:
      - "8.3.2.  Decoding Complexity\n   The decoding algorithm described previously
        includes the matrix\n   inversion and the vector-matrix multiplication.  With
        the classical\n   Gauss-Jordan algorithm, the matrix inversion requires O(k^^3)\n
        \  operations and the vector-matrix multiplication is performed in\n   O(k^^2)
        operations.\n   This complexity can be improved by considering that the received\n
        \  submatrix of GM is the product between the inverse of a Vandermonde\n   matrix
        (V_(k,k)^^-1) and another Vandermonde matrix (denoted by V',\n   which is
        a submatrix of V_(k,n)).  The decoding can be done by\n   multiplying the
        received vector by V'^^-1 (interpolation problem with\n   complexity O( k
        * (log(k))^^2) ) then by V_{k,k} (multipoint\n   evaluation with complexity
        O(k * log(k))).  The global decoding\n   complexity is then O((log(k))^^2)
        operations per source element.\n"
      title: 8.3.2.  Decoding Complexity
    title: 8.3.  Reed-Solomon Decoding Algorithm
  - contents:
    - "8.4.  Implementation for the Packet Erasure Channel\n   In a packet erasure
      channel, each packet (including its symbol(s),\n   since packets contain G >=
      1 symbols) is either correctly received or\n   erased.  The location of the
      erased symbols in the sequence of\n   symbols MUST be known.  The following
      specification describes the use\n   of Reed-Solomon codes for generating redundant
      symbols from the k\n   source symbols and for recovering the source symbols
      from any set of\n   k received symbols.\n   The k source symbols of a source
      block are assumed to be composed of\n   S m-bit elements.  Each m-bit element
      corresponds to an element of\n   the finite field GF(2^^m) through the polynomial
      representation\n   (Section 8.1).  If some of the source symbols contain less
      than S\n   elements, they MUST be virtually padded with zero elements (this
      can\n   be the case for the last symbol of the last block of the object).\n
      \  However, this padding does not need to be actually sent with the data\n   to
      the receivers.\n   The encoding process produces n encoding symbols of size
      S m-bit\n   elements, of which k are source symbols (this is a systematic code)\n
      \  and n-k are repair symbols (Figure 7).  The m-bit elements of the\n   repair
      symbols are calculated using the corresponding m-bit elements\n   of the source
      symbol set.  A logical u-th source vector, comprised of\n   the u-th elements
      from the set of source symbols, is used to\n   calculate a u-th encoding vector.
      \ This u-th encoding vector then\n   provides the u-th elements for the set
      encoding symbols calculated\n   for the block.  As a systematic code, the first
      k encoding symbols\n   are the same as the k source symbols, and the last n-k
      repair symbols\n   are the result of the Reed-Solomon encoding.\n          Input:
      \ k source symbols\n    0             u                                S-1\n
      \  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   |             |X|
      \                                | source symbol 0\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   |             |X|
      \                                | source symbol 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \               . . .\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  |             |X|                                 | source symbol k-1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \                 *\n        +--------------------+\n        |  generator matrix
      \ |\n        |         GM         |\n        |       (k x n)      |\n        +--------------------+\n
      \                 |\n                  V\n        Output: n encoding symbols
      (source + repair)\n    0             u                                S-1\n
      \  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   |             |X|
      \                                | enc. symbol 0\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   |             |X|
      \                                | enc. symbol 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \               . . .\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  |             |Y|                                 | enc. symbol n-1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \                    Figure 7: Packet Encoding Scheme\n   An asset of this scheme
      is that the loss of some encoding symbols\n   produces the same erasure pattern
      for each of the S encoding vectors.\n   It follows that the matrix inversion
      must be done only once and will\n   be used by all the S encoding vectors.  For
      large S, this matrix\n   inversion cost becomes negligible in front of the S
      vector-matrix\n   multiplications.\n   Another asset is that the n-k repair
      symbols can be produced on\n   demand.  For instance, a sender can start by
      producing a limited\n   number of repair symbols and later on, depending on
      the observed\n   erasures on the channel, decide to produce additional repair
      symbols,\n   up to the n-k upper limit.  Indeed, to produce the repair symbol
      e_j,\n   where k <= j < n, it is sufficient to multiply the S source vectors\n
      \  with column j of GM.\n"
    title: 8.4.  Implementation for the Packet Erasure Channel
  title: 8.  Reed-Solomon Codes Specification for the Erasure Channel
- contents:
  - '9.  Security Considerations

    '
  - contents:
    - "9.1.  Problem Statement\n   A content delivery system is potentially subject
      to many attacks:\n   some of them target the network (e.g., to compromise the
      routing\n   infrastructure, by compromising the congestion control component),\n
      \  others target the Content Delivery Protocol (CDP) (e.g., to\n   compromise
      its normal behavior), and finally some attacks target the\n   content itself.
      \ Since this document focuses on a FEC building block\n   independently of any
      particular CDP (even if ALC and NORM are two\n   natural candidates), this section
      only discusses the additional\n   threats that an arbitrary CDP may be exposed
      to when using this\n   building block.\n   More specifically, several kinds
      of attacks exist:\n   o  those that are meant to give access to confidential
      content (e.g.,\n      in case of non-free content),\n   o  those that try to
      corrupt the object being transmitted (e.g., to\n      inject malicious code
      within an object or to prevent a receiver\n      from using an object),\n   o
      \ and those that try to compromise the receiver's behavior (e.g., by\n      making
      the decoding of an object computationally expensive).\n   These attacks can
      be launched either against the data flow itself\n   (e.g., by sending forged
      symbols) or against the FEC parameters that\n   are sent either in-band (e.g.,
      in an EXT_FTI or FDT Instance) or out-\n   of-band (e.g., in a session description).\n"
    title: 9.1.  Problem Statement
  - contents:
    - "9.2.  Attacks against the Data Flow\n   First of all, let us consider the attacks
      against the data flow.\n"
    - contents:
      - "9.2.1.  Access to Confidential Objects\n   Access control to the object being
        transmitted is typically provided\n   by means of encryption.  This encryption
        can be done over the whole\n   object (e.g., by the content provider, before
        the FEC encoding\n   process), or be done on a packet per-packet basis (e.g.,
        when IPsec\n   Encapsulating Security Payload (ESP) is used [RFC4303]).  If
        access\n   control is a concern, it is RECOMMENDED that one of these solutions\n
        \  be used.  Even if we mention these attacks here, they are not related\n
        \  nor facilitated by the use of FEC.\n"
      title: 9.2.1.  Access to Confidential Objects
    - contents:
      - "9.2.2.  Content Corruption\n   Protection against corruptions (e.g., after
        sending forged packets)\n   is achieved by means of a content integrity verification/sender\n
        \  authentication scheme.  This service can be provided at the object\n   level,
        but in that case a receiver has no way to identify which\n   symbol(s) are
        corrupted if the object is detected as corrupted.  This\n   service can also
        be provided at the packet level.  In this case,\n   after removing all forged
        packets, the object may be recovered\n   sometimes.  Several techniques can
        provide this source\n   authentication/content integrity service:\n   o  At
        the object level, the object MAY be digitally signed (with\n      public key
        cryptography), for instance by using RSASSA-PKCS1-v1_5\n      [RFC3447].  This
        signature enables a receiver to check the object\n      integrity, once the
        object has been fully decoded.  Even if\n      digital signatures are computationally
        expensive, this calculation\n      occurs only once per object, which is usually
        acceptable.\n   o  At the packet level, each packet can be digitally signed.
        \ A major\n      limitation is the high computational and transmission overheads\n
        \     that this solution requires (unless Elliptic Curve Cryptography\n      (ECC)
        is used).  To avoid this problem, the signature may span a\n      set of symbols
        (instead of a single one) in order to amortize the\n      signature calculation.
        \ But if a single symbol is missing, the\n      integrity of the whole set
        cannot be checked.\n   o  At the packet level, a Group Message Authentication
        Code (MAC)\n      [RFC2104] scheme can be used; for instance, by using HMAC-SHA-256\n
        \     with a secret key shared by all the group members (i.e., the\n      sender(s)
        and receivers).  Thanks to the secret key, this\n      technique creates a
        cryptographically secured digest of a packet\n      that is sent along with
        the packet.  The Group MAC scheme does not\n      create prohibitive processing
        load nor transmission overhead, but\n      it has a major limitation: it only
        provides a group\n      authentication/integrity service since all group members
        share the\n      same secret group key, which means that each member can send
        a\n      forged packet.  It is therefore restricted to situations where\n
        \     group members are fully trusted (or in association with another\n      technique
        as a pre-check).\n   o  At the packet level, TESLA [RFC4082] is a very attractive
        and\n      efficient solution that is robust to losses, provides a true\n
        \     authentication/integrity service, and does not create any\n      prohibitive
        processing load or transmission overhead.  Yet\n      checking a packet requires
        a small delay (a second or more) after\n      its reception.\n   Techniques
        relying on public key cryptography (digital signatures and\n   TESLA during
        the bootstrap process, when used) require that public\n   keys be securely
        associated to the entities.  This can be achieved by\n   a Public Key Infrastructure
        (PKI), or by a PGP Web of Trust, or by\n   pre-distributing the public keys
        of each group member.\n   Techniques relying on symmetric key cryptography
        (group MAC) require\n   that a secret key be shared by all group members.
        \ This can be\n   achieved by means of a group key management protocol, or
        simply by\n   pre-distributing the secret key (but this manual solution has
        many\n   limitations).\n   It is up to the developer and deployer, who know
        the security\n   requirements and features of the target application area,
        to define\n   which solution is the most appropriate.  Nonetheless, in case
        there\n   is any concern of the threat of object corruption, it is RECOMMENDED\n
        \  that at least one of these techniques be used.\n"
      title: 9.2.2.  Content Corruption
    title: 9.2.  Attacks against the Data Flow
  - contents:
    - "9.3.  Attacks against the FEC Parameters\n   Let us now consider attacks against
      the FEC parameters (or FEC OTI).\n   The FEC OTI can either be sent in-band
      (i.e., in an EXT_FTI or in an\n   FDT Instance containing FEC OTI for the object)
      or out-of-band (e.g.,\n   in a session description).  Attacks on these FEC parameters
      can\n   prevent the decoding of the associated object: for instance,\n   modifying
      the B parameter will lead to a different block partitioning\n   at a receiver
      thereby compromising decoding; or setting the m\n   parameter to 16 instead
      of 8 with FEC Encoding ID 2 will increase the\n   processing load while compromising
      decoding.\n   It is therefore RECOMMENDED that security measures be taken to\n
      \  guarantee the FEC OTI integrity.  To that purpose, the packets\n   carrying
      the FEC parameters sent in-band in an EXT_FTI header\n   extension SHOULD be
      protected by one of the per-packet techniques\n   described above: digital signature,
      group MAC, or TESLA.  When FEC\n   OTI is contained in an FDT Instance, this
      FDT Instance object SHOULD\n   be protected, for instance, by digitally signing
      it with XML digital\n   signatures [RFC3275].  Finally, when FEC OTI is sent
      out-of-band\n   (e.g., in a session description), this FEC OTI SHOULD be protected,\n
      \  for instance, by digitally signing the object that includes this FEC\n   OTI.\n
      \  The same considerations concerning the key management aspects apply\n   here
      also.\n"
    title: 9.3.  Attacks against the FEC Parameters
  title: 9.  Security Considerations
- contents:
  - "10.  IANA Considerations\n   Values of FEC Encoding IDs and FEC Instance IDs
    are subject to IANA\n   registration.  For general guidelines on IANA considerations
    as they\n   apply to this document, see [RFC5052].\n   This document assigns the
    Fully-Specified FEC Encoding ID 2 under the\n   \"ietf:rmt:fec:encoding\" name-space
    to \"Reed-Solomon Codes over\n   GF(2^^m)\".\n   This document assigns the Fully-Specified
    FEC Encoding ID 5 under the\n   \"ietf:rmt:fec:encoding\" name-space to \"Reed-Solomon
    Codes over\n   GF(2^^8)\".\n   This document assigns the FEC Instance ID 0 scoped
    by the Under-\n   Specified FEC Encoding ID 129 to \"Reed-Solomon Codes over GF(2^^8)\".\n
    \  More specifically, under the \"ietf:rmt:fec:encoding:instance\" sub-\n   name-space
    that is scoped by the \"ietf:rmt:fec:encoding\" called\n   \"Small Block Systematic
    FEC Codes\", this document assigns FEC\n   Instance ID 0 to \"Reed-Solomon Codes
    over GF(2^^8)\".\n"
  title: 10.  IANA Considerations
- contents:
  - "11.  Acknowledgments\n   The authors want to thank Brian Adamson, Igor Slepchin,
    Stephen Kent,\n   Francis Dupont, Elwyn Davies, Magnus Westerlund, and Alfred
    Hoenes\n   for their valuable comments.  The authors also want to thank Luigi\n
    \  Rizzo for his comments and for the design of the reference Reed-\n   Solomon
    codec.\n"
  title: 11.  Acknowledgments
- contents:
  - '12.  References

    '
  - contents:
    - "12.1.  Normative References\n   [RFC2119]   Bradner, S., \"Key words for use
      in RFCs to Indicate\n               Requirement Levels\", BCP 14, RFC 2119,
      March 1997.\n   [RFC5052]   Watson, M., Luby, M., and L. Vicisano, \"Forward
      Error\n               Correction (FEC) Building Block\", RFC 5052, August 2007.\n
      \  [RFC5445]   Watson, M., \"Basic Forward Error Correction (FEC)\n               Schemes\",
      RFC 5445, March 2009.\n"
    title: 12.1.  Normative References
  - contents:
    - "12.2.  Informative References\n   [RFC3453]   Luby, M., Vicisano, L., Gemmell,
      J., Rizzo, L., Handley,\n               M., and J. Crowcroft, \"The Use of Forward
      Error\n               Correction (FEC) in Reliable Multicast\", RFC 3453,\n
      \              December 2002.\n   [RS-codec]  Rizzo, L., \"Reed-Solomon FEC
      codec\", available at\n               http://info.iet.unipi.it/~luigi/vdm98/vdm980702.tgz
      and\n               mirrored at http://planete-bcast.inrialpes.fr/, revised\n
      \              version of July 1998.\n   [Rizzo97]   Rizzo, L., \"Effective
      Erasure Codes for Reliable Computer\n               Communication Protocols\",
      ACM SIGCOMM Computer\n               Communication Review Vol.27, No.2, pp.24-36,
      April 1997.\n   [MWS77]     Mac Williams, F. and N. Sloane, \"The Theory of
      Error\n               Correcting Codes\", North Holland, 1977.\n   [GO94]      Gohberg,
      I. and V. Olshevsky, \"Fast algorithms with\n               preprocessing for
      matrix-vector multiplication problems\",\n               Journal of Complexity,
      pp. 411-427, vol. 10, 1994.\n   [RFC5170]   Roca, V., Neumann, C., and D. Furodet,
      \"Low Density\n               Parity Check (LDPC) Forward Error Correction\",
      RFC 5170,\n               June 2008.\n   [RFC5053]   Luby, M., Shokrollahi,
      A., Watson, M., and T.\n               Stockhammer, \"Raptor Forward Error Correction
      Scheme\",\n               RFC 5053, October 2007.\n   [ALC]       Luby, M.,
      Watson, M., and L. Vicisano, \"Asynchronous\n               Layered Coding (ALC)
      Protocol Instantiation\", Work\n               in Progress, November 2008.\n
      \  [NORM]      Adamson, B., Bormann, C., Handley, M., and J. Macker,\n               \"NACK-Oriented
      Reliable Multicast Protocol\", Work\n               in Progress, March 2009.\n
      \  [FLUTE]     Paila, T., Walsh, R., Luby, M., Lehtonen, R., and V.\n               Roca,
      \"FLUTE - File Delivery over Unidirectional\n               Transport\", Work
      in Progress, September 2008.\n   [RFC3447]   Jonsson, J. and B. Kaliski, \"Public-Key
      Cryptography\n               Standards (PKCS) #1: RSA Cryptography Specifications\n
      \              Version 2.1\", RFC 3447, February 2003.\n   [RFC4303]   Kent,
      S., \"IP Encapsulating Security Payload (ESP)\",\n               RFC 4303, December
      2005.\n   [RFC2104]   \"HMAC: Keyed-Hashing for Message Authentication\",\n
      \              RFC 2104, February 1997.\n   [RFC4082]   \"Timed Efficient Stream
      Loss-Tolerant Authentication\n               (TESLA): Multicast Source Authentication
      Transform\n               Introduction\", RFC 4082, June 2005.\n   [RFC3275]
      \  Eastlake 3rd, D., Reagle, J., and D. Solo, \"(Extensible\n               Markup
      Language) XML-Signature Syntax and Processing\",\n               RFC 3275, March
      2002.\n"
    title: 12.2.  Informative References
  title: 12.  References
- contents:
  - "Authors' Addresses\n   Jerome Lacan\n   ISAE/LAAS-CNRS\n   1, place Emile Blouin\n
    \  Toulouse  31056\n   France\n   EMail: jerome.lacan@isae.fr\n   URI:   http://pagespro.isae.fr/jerome-lacan/\n
    \  Vincent Roca\n   INRIA\n   655, av. de l'Europe\n   Inovallee; Montbonnot\n
    \  ST ISMIER cedex  38334\n   France\n   EMail: vincent.roca@inria.fr\n   URI:
    \  http://planete.inrialpes.fr/people/roca/\n   Jani Peltotalo\n   Tampere University
    of Technology\n   P.O. Box 553 (Korkeakoulunkatu 1)\n   Tampere  FIN-33101\n   Finland\n
    \  EMail: jani.peltotalo@tut.fi\n   URI:   http://mad.cs.tut.fi/\n   Sami Peltotalo\n
    \  Tampere University of Technology\n   P.O. Box 553 (Korkeakoulunkatu 1)\n   Tampere
    \ FIN-33101\n   Finland\n   EMail: sami.peltotalo@tut.fi\n   URI:   http://mad.cs.tut.fi/\n"
  title: Authors' Addresses
