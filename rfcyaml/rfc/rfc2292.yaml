- title: __initial_text__
  contents:
  - '                     Advanced Sockets API for IPv6

    '
- title: Status of this Memo
  contents:
  - "Status of this Memo\n   This memo provides information for the Internet community.\
    \  It does\n   not specify an Internet standard of any kind.  Distribution of\
    \ this\n   memo is unlimited.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (C) The Internet Society (1998).  All Rights Reserved.\n"
- title: Abstract
  contents:
  - "Abstract\n   Specifications are in progress for changes to the sockets API to\n\
    \   support IP version 6 [RFC-2133].  These changes are for TCP and UDP-\n   based\
    \ applications and will support most end-user applications in use\n   today: Telnet\
    \ and FTP clients and servers, HTTP clients and servers,\n   and the like.\n \
    \  But another class of applications exists that will also be run under\n   IPv6.\
    \  We call these \"advanced\" applications and today this includes\n   programs\
    \ such as Ping, Traceroute, routing daemons, multicast routing\n   daemons, router\
    \ discovery daemons, and the like.  The API feature\n   typically used by these\
    \ programs that make them \"advanced\" is a raw\n   socket to access ICMPv4, IGMPv4,\
    \ or IPv4, along with some knowledge\n   of the packet header formats used by\
    \ these protocols.  To provide\n   portability for applications that use raw sockets\
    \ under IPv6, some\n   standardization is needed for the advanced API features.\n\
    \   There are other features of IPv6 that some applications will need to\n   access:\
    \ interface identification (specifying the outgoing interface\n   and determining\
    \ the incoming interface) and IPv6 extension headers\n   that are not addressed\
    \ in [RFC-2133]: Hop-by-Hop options, Destination\n   options, and the Routing\
    \ header (source routing).  This document\n   provides API access to these features\
    \ too.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n    1.  Introduction ................................................3\n\
    \    2.  Common Structures and Definitions ...........................5\n    \
    \   2.1.  The ip6_hdr Structure ..................................5\n        \
    \    2.1.1.  IPv6 Next Header Values .........................6\n            2.1.2.\
    \  IPv6 Extension Headers ..........................6\n       2.2.  The icmp6_hdr\
    \ Structure ................................8\n            2.2.1.  ICMPv6 Type\
    \ and Code Values .....................8\n            2.2.2.  ICMPv6 Neighbor\
    \ Discovery Type and Code Values ..9\n       2.3.  Address Testing Macros .................................12\n\
    \       2.4.  Protocols File .........................................12\n   \
    \ 3.  IPv6 Raw Sockets ............................................13\n      \
    \ 3.1.  Checksums ..............................................14\n       3.2.\
    \  ICMPv6 Type Filtering ..................................14\n    4.  Ancillary\
    \ Data ..............................................17\n       4.1.  The msghdr\
    \ Structure ...................................18\n       4.2.  The cmsghdr Structure\
    \ ..................................18\n       4.3.  Ancillary Data Object Macros\
    \ ...........................19\n            4.3.1.  CMSG_FIRSTHDR ...................................20\n\
    \            4.3.2.  CMSG_NXTHDR .....................................22\n   \
    \         4.3.3.  CMSG_DATA .......................................22\n      \
    \      4.3.4.  CMSG_SPACE ......................................22\n         \
    \   4.3.5.  CMSG_LEN ........................................22\n       4.4. \
    \ Summary of Options Described Using Ancillary Data ......23\n       4.5.  IPV6_PKTOPTIONS\
    \ Socket Option ..........................24\n            4.5.1.  TCP Sticky Options\
    \ ..............................25\n            4.5.2.  UDP and Raw Socket Sticky\
    \ Options ...............26\n    5.  Packet Information ..........................................26\n\
    \       5.1.  Specifying/Receiving the Interface .....................27\n   \
    \    5.2.  Specifying/Receiving Source/Destination Address ........27\n      \
    \ 5.3.  Specifying/Receiving the Hop Limit .....................28\n       5.4.\
    \  Specifying the Next Hop Address ........................29\n       5.5.  Additional\
    \ Errors with sendmsg() .......................29\n    6.  Hop-By-Hop Options\
    \ ..........................................30\n       6.1.  Receiving Hop-by-Hop\
    \ Options ...........................31\n       6.2.  Sending Hop-by-Hop Options\
    \ .............................31\n       6.3.  Hop-by-Hop and Destination Options\
    \ Processing ..........32\n            6.3.1.  inet6_option_space ..............................32\n\
    \            6.3.2.  inet6_option_init ...............................32\n   \
    \         6.3.3.  inet6_option_append .............................33\n      \
    \      6.3.4.  inet6_option_alloc ..............................33\n         \
    \   6.3.5.  inet6_option_next ...............................34\n            6.3.6.\
    \  inet6_option_find ...............................35\n            6.3.7.  Options\
    \ Examples ................................35\n    7.  Destination Options .........................................42\n\
    \       7.1.  Receiving Destination Options ..........................42\n   \
    \    7.2.  Sending Destination Options ............................43\n    8.\
    \  Routing Header Option .......................................43\n       8.1.\
    \  inet6_rthdr_space ......................................44\n       8.2.  inet6_rthdr_init\
    \ .......................................45\n       8.3.  inet6_rthdr_add ........................................45\n\
    \       8.4.  inet6_rthdr_lasthop ....................................46\n   \
    \    8.5.  inet6_rthdr_reverse ....................................46\n      \
    \ 8.6.  inet6_rthdr_segments ...................................46\n       8.7.\
    \  inet6_rthdr_getaddr ....................................46\n       8.8.  inet6_rthdr_getflags\
    \ ...................................47\n       8.9.  Routing Header Example .................................47\n\
    \    9.  Ordering of Ancillary Data and IPv6 Extension Headers .......53\n   10.\
    \  IPv6-Specific Options with IPv4-Mapped IPv6 Addresses .......54\n   11.  rresvport_af\
    \ ................................................55\n   12.  Future Items ................................................55\n\
    \       12.1.  Flow Labels ...........................................55\n   \
    \    12.2.  Path MTU Discovery and UDP ............................56\n      \
    \ 12.3.  Neighbor Reachability and UDP .........................56\n   13.  Summary\
    \ of New Definitions ..................................56\n   14.  Security Considerations\
    \ .....................................59\n   15.  Change History ..............................................59\n\
    \   16.  References ..................................................65\n   17.\
    \  Acknowledgments .............................................65\n   18.  Authors'\
    \ Addresses ..........................................66\n   19.  Full Copyright\
    \ Statement ....................................67\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   Specifications are in progress for changes to the sockets\
    \ API to\n   support IP version 6 [RFC-2133].  These changes are for TCP and UDP-\n\
    \   based applications.  The current document defines some the \"advanced\"\n\
    \   features of the sockets API that are required for applications to\n   take\
    \ advantage of additional features of IPv6.\n   Today, the portability of applications\
    \ using IPv4 raw sockets is\n   quite high, but this is mainly because most IPv4\
    \ implementations\n   started from a common base (the Berkeley source code) or\
    \ at least\n   started with the Berkeley headers.  This allows programs such as\
    \ Ping\n   and Traceroute, for example, to compile with minimal effort on many\n\
    \   hosts that support the sockets API.  With IPv6, however, there is no\n   common\
    \ source code base that implementors are starting from, and the\n   possibility\
    \ for divergence at this level between different\n   implementations is high.\
    \  To avoid a complete lack of portability\n   amongst applications that use raw\
    \ IPv6 sockets, some standardization\n   is necessary.\n   There are also features\
    \ from the basic IPv6 specification that are\n   not addressed in [RFC-2133]:\
    \ sending and receiving Hop-by-Hop\n   options, Destination options, and Routing\
    \ headers, specifying the\n   outgoing interface, and being told of the receiving\
    \ interface.\n   This document can be divided into the following main sections.\n\
    \   1.  Definitions of the basic constants and structures required for\n     \
    \  applications to use raw IPv6 sockets.  This includes structure\n       definitions\
    \ for the IPv6 and ICMPv6 headers and all associated\n       constants (e.g.,\
    \ values for the Next Header field).\n   2.  Some basic semantic definitions for\
    \ IPv6 raw sockets.  For\n       example, a raw ICMPv4 socket requires the application\
    \ to\n       calculate and store the ICMPv4 header checksum.  But with IPv6\n\
    \       this would require the application to choose the source IPv6\n       address\
    \ because the source address is part of the pseudo header\n       that ICMPv6\
    \ now uses for its checksum computation.  It should be\n       defined that with\
    \ a raw ICMPv6 socket the kernel always\n       calculates and stores the ICMPv6\
    \ header checksum.\n   3.  Packet information: how applications can obtain the\
    \ received\n       interface, destination address, and received hop limit, along\n\
    \       with specifying these values on a per-packet basis.  There are a\n   \
    \    class of applications that need this capability and the technique\n     \
    \  should be portable.\n   4.  Access to the optional Hop-by-Hop, Destination,\
    \ and Routing\n       headers.\n   5.  Additional features required for IPv6 application\
    \ portability.\n   The packet information along with access to the extension headers\n\
    \   (Hop-by-Hop options, Destination options, and Routing header) are\n   specified\
    \ using the \"ancillary data\" fields that were added to the\n   4.3BSD Reno sockets\
    \ API in 1990.  The reason is that these ancillary\n   data fields are part of\
    \ the Posix.1g standard (which should be\n   approved in 1997) and should therefore\
    \ be adopted by most vendors.\n   This document does not address application access\
    \ to either the\n   authentication header or the encapsulating security payload\
    \ header.\n   All examples in this document omit error checking in favor of brevity\n\
    \   and clarity.\n   We note that many of the functions and socket options defined\
    \ in this\n   document may have error returns that are not defined in this\n \
    \  document.  Many of these possible error returns will be recognized\n   only\
    \ as implementations proceed.\n   Datatypes in this document follow the Posix.1g\
    \ format: intN_t means a\n   signed integer of exactly N bits (e.g., int16_t)\
    \ and uintN_t means an\n   unsigned integer of exactly N bits (e.g., uint32_t).\n\
    \   Note that we use the (unofficial) terminology ICMPv4, IGMPv4, and\n   ARPv4\
    \ to avoid any confusion with the newer ICMPv6 protocol.\n"
- title: 2.  Common Structures and Definitions
  contents:
  - "2.  Common Structures and Definitions\n   Many advanced applications examine\
    \ fields in the IPv6 header and set\n   and examine fields in the various ICMPv6\
    \ headers.  Common structure\n   definitions for these headers are required, along\
    \ with common\n   constant definitions for the structure members.\n   Two new\
    \ headers are defined: <netinet/ip6.h> and <netinet/icmp6.h>.\n   When an include\
    \ file is specified, that include file is allowed to\n   include other files that\
    \ do the actual declaration or definition.\n"
- title: 2.1.  The ip6_hdr Structure
  contents:
  - "2.1.  The ip6_hdr Structure\n   The following structure is defined as a result\
    \ of including\n   <netinet/ip6.h>.  Note that this is a new header.\n    struct\
    \ ip6_hdr {\n      union {\n        struct ip6_hdrctl {\n          uint32_t ip6_un1_flow;\
    \   /* 24 bits of flow-ID */\n          uint16_t ip6_un1_plen;   /* payload length\
    \ */\n          uint8_t  ip6_un1_nxt;    /* next header */\n          uint8_t\
    \  ip6_un1_hlim;   /* hop limit */\n        } ip6_un1;\n        uint8_t ip6_un2_vfc;\
    \       /* 4 bits version, 4 bits priority */\n      } ip6_ctlun;\n      struct\
    \ in6_addr ip6_src;      /* source address */\n      struct in6_addr ip6_dst;\
    \      /* destination address */\n    };\n    #define ip6_vfc   ip6_ctlun.ip6_un2_vfc\n\
    \    #define ip6_flow  ip6_ctlun.ip6_un1.ip6_un1_flow\n    #define ip6_plen  ip6_ctlun.ip6_un1.ip6_un1_plen\n\
    \    #define ip6_nxt   ip6_ctlun.ip6_un1.ip6_un1_nxt\n    #define ip6_hlim  ip6_ctlun.ip6_un1.ip6_un1_hlim\n\
    \    #define ip6_hops  ip6_ctlun.ip6_un1.ip6_un1_hlim\n"
- title: 2.1.1.  IPv6 Next Header Values
  contents:
  - "2.1.1.  IPv6 Next Header Values\n   IPv6 defines many new values for the Next\
    \ Header field.  The\n   following constants are defined as a result of including\n\
    \   <netinet/in.h>.\n   #define IPPROTO_HOPOPTS        0 /* IPv6 Hop-by-Hop options\
    \ */\n   #define IPPROTO_IPV6          41 /* IPv6 header */\n   #define IPPROTO_ROUTING\
    \       43 /* IPv6 Routing header */\n   #define IPPROTO_FRAGMENT      44 /* IPv6\
    \ fragmentation header */\n   #define IPPROTO_ESP           50 /* encapsulating\
    \ security payload */\n   #define IPPROTO_AH            51 /* authentication header\
    \ */\n   #define IPPROTO_ICMPV6        58 /* ICMPv6 */\n   #define IPPROTO_NONE\
    \          59 /* IPv6 no next header */\n   #define IPPROTO_DSTOPTS       60 /*\
    \ IPv6 Destination options */\n   Berkeley-derived IPv4 implementations also define\
    \ IPPROTO_IP to be 0.\n   This should not be a problem since IPPROTO_IP is used\
    \ only with IPv4\n   sockets and IPPROTO_HOPOPTS only with IPv6 sockets.\n"
- title: 2.1.2.  IPv6 Extension Headers
  contents:
  - "2.1.2.  IPv6 Extension Headers\n   Six extension headers are defined for IPv6.\
    \  We define structures for\n   all except the Authentication header and Encapsulating\
    \ Security\n   Payload header, both of which are beyond the scope of this document.\n\
    \   The following structures are defined as a result of including\n   <netinet/ip6.h>.\n\
    \   /* Hop-by-Hop options header */\n   /* XXX should we pad it to force alignment\
    \ on an 8-byte boundary? */\n   struct ip6_hbh {\n     uint8_t  ip6h_nxt;    \
    \    /* next header */\n     uint8_t  ip6h_len;        /* length in units of 8\
    \ octets */\n       /* followed by options */\n   };\n   /* Destination options\
    \ header */\n   /* XXX should we pad it to force alignment on an 8-byte boundary?\
    \ */\n   struct ip6_dest {\n     uint8_t  ip6d_nxt;        /* next header */\n\
    \     uint8_t  ip6d_len;        /* length in units of 8 octets */\n       /* followed\
    \ by options */\n   };\n   /* Routing header */\n   struct ip6_rthdr {\n     uint8_t\
    \  ip6r_nxt;        /* next header */\n     uint8_t  ip6r_len;        /* length\
    \ in units of 8 octets */\n     uint8_t  ip6r_type;       /* routing type */\n\
    \     uint8_t  ip6r_segleft;    /* segments left */\n       /* followed by routing\
    \ type specific data */\n   };\n   /* Type 0 Routing header */\n   struct ip6_rthdr0\
    \ {\n     uint8_t  ip6r0_nxt;       /* next header */\n     uint8_t  ip6r0_len;\
    \       /* length in units of 8 octets */\n     uint8_t  ip6r0_type;      /* always\
    \ zero */\n     uint8_t  ip6r0_segleft;   /* segments left */\n     uint8_t  ip6r0_reserved;\
    \  /* reserved field */\n     uint8_t  ip6r0_slmap[3];  /* strict/loose bit map\
    \ */\n     struct in6_addr  ip6r0_addr[1];  /* up to 23 addresses */\n   };\n\
    \   /* Fragment header */\n   struct ip6_frag {\n     uint8_t   ip6f_nxt;    \
    \   /* next header */\n     uint8_t   ip6f_reserved;  /* reserved field */\n \
    \    uint16_t  ip6f_offlg;     /* offset, reserved, and flag */\n     uint32_t\
    \  ip6f_ident;     /* identification */\n   };\n   #if     BYTE_ORDER == BIG_ENDIAN\n\
    \   #define IP6F_OFF_MASK       0xfff8  /* mask out offset from _offlg */\n  \
    \ #define IP6F_RESERVED_MASK  0x0006  /* reserved bits in ip6f_offlg */\n   #define\
    \ IP6F_MORE_FRAG      0x0001  /* more-fragments flag */\n   #else   /* BYTE_ORDER\
    \ == LITTLE_ENDIAN */\n   #define IP6F_OFF_MASK       0xf8ff  /* mask out offset\
    \ from _offlg */\n   #define IP6F_RESERVED_MASK  0x0600  /* reserved bits in ip6f_offlg\
    \ */\n   #define IP6F_MORE_FRAG      0x0100  /* more-fragments flag */\n   #endif\n\
    \   Defined constants for fields larger than 1 byte depend on the byte\n   ordering\
    \ that is used.  This API assumes that the fields in the\n   protocol headers\
    \ are left in the network byte order, which is big-\n   endian for the Internet\
    \ protocols.  If not, then either these\n   constants or the fields being tested\
    \ must be converted at run-time,\n   using something like htons() or htonl().\n\
    \   (Note: We show an implementation that supports both big-endian and\n   little-endian\
    \ byte ordering, assuming a hypothetical compile-time #if\n   test to determine\
    \ the byte ordering.  The constant that we show,\n   BYTE_ORDER, with values of\
    \ BIG_ENDIAN and LITTLE_ENDIAN, are for\n   example purposes only.  If an implementation\
    \ runs on only one type of\n   hardware it need only define the set of constants\
    \ for that hardware's\n   byte ordering.)\n"
- title: 2.2.  The icmp6_hdr Structure
  contents:
  - "2.2.  The icmp6_hdr Structure\n   The ICMPv6 header is needed by numerous IPv6\
    \ applications including\n   Ping, Traceroute, router discovery daemons, and neighbor\
    \ discovery\n   daemons.  The following structure is defined as a result of including\n\
    \   <netinet/icmp6.h>.  Note that this is a new header.\n   struct icmp6_hdr {\n\
    \     uint8_t     icmp6_type;   /* type field */\n     uint8_t     icmp6_code;\
    \   /* code field */\n     uint16_t    icmp6_cksum;  /* checksum field */\n  \
    \   union {\n       uint32_t  icmp6_un_data32[1]; /* type-specific field */\n\
    \       uint16_t  icmp6_un_data16[2]; /* type-specific field */\n       uint8_t\
    \   icmp6_un_data8[4];  /* type-specific field */\n     } icmp6_dataun;\n   };\n\
    \   #define icmp6_data32    icmp6_dataun.icmp6_un_data32\n   #define icmp6_data16\
    \    icmp6_dataun.icmp6_un_data16\n   #define icmp6_data8     icmp6_dataun.icmp6_un_data8\n\
    \   #define icmp6_pptr      icmp6_data32[0]  /* parameter prob */\n   #define\
    \ icmp6_mtu       icmp6_data32[0]  /* packet too big */\n   #define icmp6_id \
    \       icmp6_data16[0]  /* echo request/reply */\n   #define icmp6_seq      \
    \ icmp6_data16[1]  /* echo request/reply */\n   #define icmp6_maxdelay  icmp6_data16[0]\
    \  /* mcast group membership */\n"
- title: 2.2.1.  ICMPv6 Type and Code Values
  contents:
  - "2.2.1.  ICMPv6 Type and Code Values\n   In addition to a common structure for\
    \ the ICMPv6 header, common\n   definitions are required for the ICMPv6 type and\
    \ code fields.  The\n   following constants are also defined as a result of including\n\
    \   <netinet/icmp6.h>.\n"
- title: '#define ICMP6_DST_UNREACH             1'
  contents:
  - '#define ICMP6_DST_UNREACH             1

    '
- title: '#define ICMP6_PACKET_TOO_BIG          2'
  contents:
  - '#define ICMP6_PACKET_TOO_BIG          2

    '
- title: '#define ICMP6_TIME_EXCEEDED           3'
  contents:
  - '#define ICMP6_TIME_EXCEEDED           3

    '
- title: '#define ICMP6_PARAM_PROB              4'
  contents:
  - '#define ICMP6_PARAM_PROB              4

    '
- title: '#define ICMP6_INFOMSG_MASK  0x80    /* all informational messages */'
  contents:
  - '#define ICMP6_INFOMSG_MASK  0x80    /* all informational messages */

    '
- title: '#define ICMP6_ECHO_REQUEST          128'
  contents:
  - '#define ICMP6_ECHO_REQUEST          128

    '
- title: '#define ICMP6_ECHO_REPLY            129'
  contents:
  - '#define ICMP6_ECHO_REPLY            129

    '
- title: '#define ICMP6_MEMBERSHIP_QUERY      130'
  contents:
  - '#define ICMP6_MEMBERSHIP_QUERY      130

    '
- title: '#define ICMP6_MEMBERSHIP_REPORT     131'
  contents:
  - '#define ICMP6_MEMBERSHIP_REPORT     131

    '
- title: '#define ICMP6_MEMBERSHIP_REDUCTION  132'
  contents:
  - '#define ICMP6_MEMBERSHIP_REDUCTION  132

    '
- title: '#define ICMP6_DST_UNREACH_NOROUTE     0 /* no route to destination */'
  contents:
  - '#define ICMP6_DST_UNREACH_NOROUTE     0 /* no route to destination */

    '
- title: '#define ICMP6_DST_UNREACH_ADMIN       1 /* communication with */'
  contents:
  - "#define ICMP6_DST_UNREACH_ADMIN       1 /* communication with */\n          \
    \                              /* destination */\n                           \
    \             /* administratively */\n                                       \
    \ /* prohibited */\n"
- title: '#define ICMP6_DST_UNREACH_NOTNEIGHBOR 2 /* not a neighbor */'
  contents:
  - '#define ICMP6_DST_UNREACH_NOTNEIGHBOR 2 /* not a neighbor */

    '
- title: '#define ICMP6_DST_UNREACH_ADDR        3 /* address unreachable */'
  contents:
  - '#define ICMP6_DST_UNREACH_ADDR        3 /* address unreachable */

    '
- title: '#define ICMP6_DST_UNREACH_NOPORT      4 /* bad port */'
  contents:
  - '#define ICMP6_DST_UNREACH_NOPORT      4 /* bad port */

    '
- title: '#define ICMP6_TIME_EXCEED_TRANSIT     0 /* Hop Limit == 0 in transit */'
  contents:
  - '#define ICMP6_TIME_EXCEED_TRANSIT     0 /* Hop Limit == 0 in transit */

    '
- title: '#define ICMP6_TIME_EXCEED_REASSEMBLY  1 /* Reassembly time out */'
  contents:
  - '#define ICMP6_TIME_EXCEED_REASSEMBLY  1 /* Reassembly time out */

    '
- title: '#define ICMP6_PARAMPROB_HEADER        0 /* erroneous header field */'
  contents:
  - '#define ICMP6_PARAMPROB_HEADER        0 /* erroneous header field */

    '
- title: '#define ICMP6_PARAMPROB_NEXTHEADER    1 /* unrecognized Next Header */'
  contents:
  - '#define ICMP6_PARAMPROB_NEXTHEADER    1 /* unrecognized Next Header */

    '
- title: '#define ICMP6_PARAMPROB_OPTION        2 /* unrecognized IPv6 option */'
  contents:
  - "#define ICMP6_PARAMPROB_OPTION        2 /* unrecognized IPv6 option */\n   The\
    \ five ICMP message types defined by IPv6 neighbor discovery (133-\n   137) are\
    \ defined in the next section.\n"
- title: 2.2.2.  ICMPv6 Neighbor Discovery Type and Code Values
  contents:
  - "2.2.2.  ICMPv6 Neighbor Discovery Type and Code Values\n   The following structures\
    \ and definitions are defined as a result of\n   including <netinet/icmp6.h>.\n\
    \   #define ND_ROUTER_SOLICIT           133\n   #define ND_ROUTER_ADVERT     \
    \       134\n   #define ND_NEIGHBOR_SOLICIT         135\n   #define ND_NEIGHBOR_ADVERT\
    \          136\n   #define ND_REDIRECT                 137\n   struct nd_router_solicit\
    \ {     /* router solicitation */\n     struct icmp6_hdr  nd_rs_hdr;\n       /*\
    \ could be followed by options */\n   };\n   #define nd_rs_type              \
    \ nd_rs_hdr.icmp6_type\n   #define nd_rs_code               nd_rs_hdr.icmp6_code\n\
    \   #define nd_rs_cksum              nd_rs_hdr.icmp6_cksum\n   #define nd_rs_reserved\
    \           nd_rs_hdr.icmp6_data32[0]\n   struct nd_router_advert {      /* router\
    \ advertisement */\n     struct icmp6_hdr  nd_ra_hdr;\n     uint32_t   nd_ra_reachable;\
    \   /* reachable time */\n     uint32_t   nd_ra_retransmit;  /* retransmit timer\
    \ */\n       /* could be followed by options */\n   };\n   #define nd_ra_type\
    \               nd_ra_hdr.icmp6_type\n   #define nd_ra_code               nd_ra_hdr.icmp6_code\n\
    \   #define nd_ra_cksum              nd_ra_hdr.icmp6_cksum\n   #define nd_ra_curhoplimit\
    \        nd_ra_hdr.icmp6_data8[0]\n   #define nd_ra_flags_reserved     nd_ra_hdr.icmp6_data8[1]\n\
    \   #define ND_RA_FLAG_MANAGED       0x80\n   #define ND_RA_FLAG_OTHER       \
    \  0x40\n   #define nd_ra_router_lifetime    nd_ra_hdr.icmp6_data16[1]\n   struct\
    \ nd_neighbor_solicit {   /* neighbor solicitation */\n     struct icmp6_hdr \
    \ nd_ns_hdr;\n     struct in6_addr   nd_ns_target; /* target address */\n    \
    \   /* could be followed by options */\n   };\n   #define nd_ns_type         \
    \      nd_ns_hdr.icmp6_type\n   #define nd_ns_code               nd_ns_hdr.icmp6_code\n\
    \   #define nd_ns_cksum              nd_ns_hdr.icmp6_cksum\n   #define nd_ns_reserved\
    \           nd_ns_hdr.icmp6_data32[0]\n   struct nd_neighbor_advert {    /* neighbor\
    \ advertisement */\n     struct icmp6_hdr  nd_na_hdr;\n     struct in6_addr  \
    \ nd_na_target; /* target address */\n       /* could be followed by options */\n\
    \   };\n   #define nd_na_type               nd_na_hdr.icmp6_type\n   #define nd_na_code\
    \               nd_na_hdr.icmp6_code\n   #define nd_na_cksum              nd_na_hdr.icmp6_cksum\n\
    \   #define nd_na_flags_reserved     nd_na_hdr.icmp6_data32[0]\n   #if     BYTE_ORDER\
    \ == BIG_ENDIAN\n   #define ND_NA_FLAG_ROUTER        0x80000000\n   #define ND_NA_FLAG_SOLICITED\
    \     0x40000000\n   #define ND_NA_FLAG_OVERRIDE      0x20000000\n   #else   /*\
    \ BYTE_ORDER == LITTLE_ENDIAN */\n   #define ND_NA_FLAG_ROUTER        0x00000080\n\
    \   #define ND_NA_FLAG_SOLICITED     0x00000040\n   #define ND_NA_FLAG_OVERRIDE\
    \      0x00000020\n   #endif\n   struct nd_redirect {           /* redirect */\n\
    \     struct icmp6_hdr  nd_rd_hdr;\n     struct in6_addr   nd_rd_target; /* target\
    \ address */\n     struct in6_addr   nd_rd_dst;    /* destination address */\n\
    \       /* could be followed by options */\n   };\n   #define nd_rd_type     \
    \          nd_rd_hdr.icmp6_type\n   #define nd_rd_code               nd_rd_hdr.icmp6_code\n\
    \   #define nd_rd_cksum              nd_rd_hdr.icmp6_cksum\n   #define nd_rd_reserved\
    \           nd_rd_hdr.icmp6_data32[0]\n   struct nd_opt_hdr {           /* Neighbor\
    \ discovery option header */\n     uint8_t  nd_opt_type;\n     uint8_t  nd_opt_len;\
    \        /* in units of 8 octets */\n       /* followed by option specific data\
    \ */\n   };\n   #define  ND_OPT_SOURCE_LINKADDR       1\n   #define  ND_OPT_TARGET_LINKADDR\
    \       2\n   #define  ND_OPT_PREFIX_INFORMATION    3\n   #define  ND_OPT_REDIRECTED_HEADER\
    \     4\n   #define  ND_OPT_MTU                   5\n   struct nd_opt_prefix_info\
    \ {    /* prefix information */\n     uint8_t   nd_opt_pi_type;\n     uint8_t\
    \   nd_opt_pi_len;\n     uint8_t   nd_opt_pi_prefix_len;\n     uint8_t   nd_opt_pi_flags_reserved;\n\
    \     uint32_t  nd_opt_pi_valid_time;\n     uint32_t  nd_opt_pi_preferred_time;\n\
    \     uint32_t  nd_opt_pi_reserved2;\n     struct in6_addr  nd_opt_pi_prefix;\n\
    \   };\n   #define ND_OPT_PI_FLAG_ONLINK        0x80\n   #define ND_OPT_PI_FLAG_AUTO\
    \          0x40\n   struct nd_opt_rd_hdr {         /* redirected header */\n \
    \    uint8_t   nd_opt_rh_type;\n     uint8_t   nd_opt_rh_len;\n     uint16_t \
    \ nd_opt_rh_reserved1;\n     uint32_t  nd_opt_rh_reserved2;\n       /* followed\
    \ by IP header and data */\n   };\n   struct nd_opt_mtu {            /* MTU option\
    \ */\n     uint8_t   nd_opt_mtu_type;\n     uint8_t   nd_opt_mtu_len;\n     uint16_t\
    \  nd_opt_mtu_reserved;\n     uint32_t  nd_opt_mtu_mtu;\n   };\n   We note that\
    \ the nd_na_flags_reserved flags have the same byte\n   ordering problems as we\
    \ discussed with ip6f_offlg.\n"
- title: 2.3.  Address Testing Macros
  contents:
  - "2.3.  Address Testing Macros\n   The basic API ([RFC-2133]) defines some macros\
    \ for testing an IPv6\n   address for certain properties.  This API extends those\
    \ definitions\n   with additional address testing macros, defined as a result\
    \ of\n   including <netinet/in.h>.\n    int  IN6_ARE_ADDR_EQUAL(const struct in6_addr\
    \ *,\n                            const struct in6_addr *);\n"
- title: 2.4.  Protocols File
  contents:
  - "2.4.  Protocols File\n   Many hosts provide the file /etc/protocols that contains\
    \ the names of\n   the various IP protocols and their protocol number (e.g., the\
    \ value\n   of the protocol field in the IPv4 header for that protocol, such as\
    \ 1\n   for ICMP).  Some programs then call the function getprotobyname() to\n\
    \   obtain the protocol value that is then specified as the third\n   argument\
    \ to the socket() function.  For example, the Ping program\n   contains code of\
    \ the form\n       struct protoent  *proto;\n       proto = getprotobyname(\"\
    icmp\");\n       s = socket(AF_INET, SOCK_RAW, proto->p_proto);\n   Common names\
    \ are required for the new IPv6 protocols in this file, to\n   provide portability\
    \ of applications that call the getprotoXXX()\n   functions.\n   We define the\
    \ following protocol names with the values shown.  These\n   are taken from ftp://ftp.isi.edu/in-notes/iana/assignments/protocol-\n\
    \   numbers.\n       hopopt           0    # hop-by-hop options for ipv6\n   \
    \    ipv6            41    # ipv6\n       ipv6-route      43    # routing header\
    \ for ipv6\n       ipv6-frag       44    # fragment header for ipv6\n       esp\
    \             50    # encapsulating security payload for ipv6\n       ah     \
    \         51    # authentication header for ipv6\n       ipv6-icmp       58  \
    \  # icmp for ipv6\n       ipv6-nonxt      59    # no next header for ipv6\n \
    \      ipv6-opts       60    # destination options for ipv6\n"
- title: 3.  IPv6 Raw Sockets
  contents:
  - "3.  IPv6 Raw Sockets\n   Raw sockets bypass the transport layer (TCP or UDP).\
    \  With IPv4, raw\n   sockets are used to access ICMPv4, IGMPv4, and to read and\
    \ write IPv4\n   datagrams containing a protocol field that the kernel does not\n\
    \   process.  An example of the latter is a routing daemon for OSPF,\n   since\
    \ it uses IPv4 protocol field 89.  With IPv6 raw sockets will be\n   used for\
    \ ICMPv6 and to read and write IPv6 datagrams containing a\n   Next Header field\
    \ that the kernel does not process.  Examples of the\n   latter are a routing\
    \ daemon for OSPF for IPv6 and RSVP (protocol\n   field 46).\n   All data sent\
    \ via raw sockets MUST be in network byte order and all\n   data received via\
    \ raw sockets will be in network byte order.  This\n   differs from the IPv4 raw\
    \ sockets, which did not specify a byte\n   ordering and typically used the host's\
    \ byte order.\n   Another difference from IPv4 raw sockets is that complete packets\n\
    \   (that is, IPv6 packets with extension headers) cannot be read or\n   written\
    \ using the IPv6 raw sockets API.  Instead, ancillary data\n   objects are used\
    \ to transfer the extension headers, as described\n   later in this document.\
    \  Should an application need access to the\n   complete IPv6 packet, some other\
    \ technique, such as the datalink\n   interfaces BPF or DLPI, must be used.\n\
    \   All fields in the IPv6 header that an application might want to\n   change\
    \ (i.e., everything other than the version number) can be\n   modified using ancillary\
    \ data and/or socket options by the\n   application for output.  All fields in\
    \ a received IPv6 header (other\n   than the version number and Next Header fields)\
    \ and all extension\n   headers are also made available to the application as\
    \ ancillary data\n   on input.  Hence there is no need for a socket option similar\
    \ to the\n   IPv4 IP_HDRINCL socket option.\n   When writing to a raw socket the\
    \ kernel will automatically fragment\n   the packet if its size exceeds the path\
    \ MTU, inserting the required\n   fragmentation headers.  On input the kernel\
    \ reassembles received\n   fragments, so the reader of a raw socket never sees\
    \ any fragment\n   headers.\n   When we say \"an ICMPv6 raw socket\" we mean a\
    \ socket created by\n   calling the socket function with the three arguments PF_INET6,\n\
    \   SOCK_RAW, and IPPROTO_ICMPV6.\n   Most IPv4 implementations give special treatment\
    \ to a raw socket\n   created with a third argument to socket() of IPPROTO_RAW,\
    \ whose value\n   is normally 255.  We note that this value has no special meaning\
    \ to\n   an IPv6 raw socket (and the IANA currently reserves the value of 255\n\
    \   when used as a next-header field).  (Note: This feature was added to\n   IPv4\
    \ in 1988 by Van Jacobson to support traceroute, allowing a\n   complete IP header\
    \ to be passed by the application, before the\n   IP_HDRINCL socket option was\
    \ added.)\n"
- title: 3.1.  Checksums
  contents:
  - "3.1.  Checksums\n   The kernel will calculate and insert the ICMPv6 checksum\
    \ for ICMPv6\n   raw sockets, since this checksum is mandatory.\n   For other\
    \ raw IPv6 sockets (that is, for raw IPv6 sockets created\n   with a third argument\
    \ other than IPPROTO_ICMPV6), the application\n   must set the new IPV6_CHECKSUM\
    \ socket option to have the kernel (1)\n   compute and store a checksum for output,\
    \ and (2) verify the received\n   checksum on input, discarding the packet if\
    \ the checksum is in error.\n   This option prevents applications from having\
    \ to perform source\n   address selection on the packets they send.  The checksum\
    \ will\n   incorporate the IPv6 pseudo-header, defined in Section 8.1 of [RFC-\n\
    \   1883].  This new socket option also specifies an integer offset into\n   the\
    \ user data of where the checksum is located.\n    int  offset = 2;\n    setsockopt(fd,\
    \ IPPROTO_IPV6, IPV6_CHECKSUM, &offset, sizeof(offset));\n   By default, this\
    \ socket option is disabled.  Setting the offset to -1\n   also disables the option.\
    \  By disabled we mean (1) the kernel will\n   not calculate and store a checksum\
    \ for outgoing packets, and (2) the\n   kernel will not verify a checksum for\
    \ received packets.\n   (Note: Since the checksum is always calculated by the\
    \ kernel for an\n   ICMPv6 socket, applications are not able to generate ICMPv6\
    \ packets\n   with incorrect checksums (presumably for testing purposes) using\
    \ this\n   API.)\n"
- title: 3.2.  ICMPv6 Type Filtering
  contents:
  - "3.2.  ICMPv6 Type Filtering\n   ICMPv4 raw sockets receive most ICMPv4 messages\
    \ received by the\n   kernel.  (We say \"most\" and not \"all\" because Berkeley-derived\n\
    \   kernels never pass echo requests, timestamp requests, or address mask\n  \
    \ requests to a raw socket.  Instead these three messages are processed\n   entirely\
    \ by the kernel.)  But ICMPv6 is a superset of ICMPv4, also\n   including the\
    \ functionality of IGMPv4 and ARPv4.  This means that an\n   ICMPv6 raw socket\
    \ can potentially receive many more messages than\n   would be received with an\
    \ ICMPv4 raw socket: ICMP messages similar to\n   ICMPv4, along with neighbor\
    \ solicitations, neighbor advertisements,\n   and the three group membership messages.\n\
    \   Most applications using an ICMPv6 raw socket care about only a small\n   subset\
    \ of the ICMPv6 message types.  To transfer extraneous ICMPv6\n   messages from\
    \ the kernel to user can incur a significant overhead.\n   Therefore this API\
    \ includes a method of filtering ICMPv6 messages by\n   the ICMPv6 type field.\n\
    \   Each ICMPv6 raw socket has an associated filter whose datatype is\n   defined\
    \ as\n       struct icmp6_filter;\n   This structure, along with the macros and\
    \ constants defined later in\n   this section, are defined as a result of including\
    \ the\n   <netinet/icmp6.h> header.\n   The current filter is fetched and stored\
    \ using getsockopt() and\n   setsockopt() with a level of IPPROTO_ICMPV6 and an\
    \ option name of\n   ICMP6_FILTER.\n   Six macros operate on an icmp6_filter structure:\n\
    \       void ICMP6_FILTER_SETPASSALL (struct icmp6_filter *);\n       void ICMP6_FILTER_SETBLOCKALL(struct\
    \ icmp6_filter *);\n       void ICMP6_FILTER_SETPASS ( int, struct icmp6_filter\
    \ *);\n       void ICMP6_FILTER_SETBLOCK( int, struct icmp6_filter *);\n     \
    \  int  ICMP6_FILTER_WILLPASS (int, const struct icmp6_filter *);\n       int\
    \  ICMP6_FILTER_WILLBLOCK(int, const struct icmp6_filter *);\n   The first argument\
    \ to the last four macros (an integer) is an ICMPv6\n   message type, between\
    \ 0 and 255.  The pointer argument to all six\n   macros is a pointer to a filter\
    \ that is modified by the first four\n   macros examined by the last two macros.\n\
    \   The first two macros, SETPASSALL and SETBLOCKALL, let us specify that\n  \
    \ all ICMPv6 messages are passed to the application or that all ICMPv6\n   messages\
    \ are blocked from being passed to the application.\n   The next two macros, SETPASS\
    \ and SETBLOCK, let us specify that\n   messages of a given ICMPv6 type should\
    \ be passed to the application\n   or not passed to the application (blocked).\n\
    \   The final two macros, WILLPASS and WILLBLOCK, return true or false\n   depending\
    \ whether the specified message type is passed to the\n   application or blocked\
    \ from being passed to the application by the\n   filter pointed to by the second\
    \ argument.\n   When an ICMPv6 raw socket is created, it will by default pass\
    \ all\n   ICMPv6 message types to the application.\n   As an example, a program\
    \ that wants to receive only router\n   advertisements could execute the following:\n"
- title: struct icmp6_filter  myfilt;
  contents:
  - 'struct icmp6_filter  myfilt;

    '
- title: fd = socket(PF_INET6, SOCK_RAW, IPPROTO_ICMPV6);
  contents:
  - 'fd = socket(PF_INET6, SOCK_RAW, IPPROTO_ICMPV6);

    '
- title: ICMP6_FILTER_SETBLOCKALL(&myfilt);
  contents:
  - 'ICMP6_FILTER_SETBLOCKALL(&myfilt);

    '
- title: ICMP6_FILTER_SETPASS(ND_ROUTER_ADVERT, &myfilt);
  contents:
  - 'ICMP6_FILTER_SETPASS(ND_ROUTER_ADVERT, &myfilt);

    '
- title: setsockopt(fd, IPPROTO_ICMPV6, ICMP6_FILTER, &myfilt, sizeof(myfilt));
  contents:
  - "setsockopt(fd, IPPROTO_ICMPV6, ICMP6_FILTER, &myfilt, sizeof(myfilt));\n   The\
    \ filter structure is declared and then initialized to block all\n   messages\
    \ types.  The filter structure is then changed to allow router\n   advertisement\
    \ messages to be passed to the application and the filter\n   is installed using\
    \ setsockopt().\n   The icmp6_filter structure is similar to the fd_set datatype\
    \ used\n   with the select() function in the sockets API.  The icmp6_filter\n\
    \   structure is an opaque datatype and the application should not care\n   how\
    \ it is implemented.  All the application does with this datatype\n   is allocate\
    \ a variable of this type, pass a pointer to a variable of\n   this type to getsockopt()\
    \ and setsockopt(), and operate on a variable\n   of this type using the six macros\
    \ that we just defined.\n   Nevertheless, it is worth showing a simple implementation\
    \ of this\n   datatype and the six macros.\n"
- title: struct icmp6_filter {
  contents:
  - "struct icmp6_filter {\n  uint32_t  icmp6_filt[8];  /* 8*32 = 256 bits */\n"
- title: '};'
  contents:
  - '};

    '
- title: '#define ICMP6_FILTER_WILLPASS(type, filterp) \'
  contents:
  - "#define ICMP6_FILTER_WILLPASS(type, filterp) \\\n    ((((filterp)->icmp6_filt[(type)\
    \ >> 5]) & (1 << ((type) & 31))) != 0)\n"
- title: '#define ICMP6_FILTER_WILLBLOCK(type, filterp) \'
  contents:
  - "#define ICMP6_FILTER_WILLBLOCK(type, filterp) \\\n    ((((filterp)->icmp6_filt[(type)\
    \ >> 5]) & (1 << ((type) & 31))) == 0)\n"
- title: '#define ICMP6_FILTER_SETPASS(type, filterp) \'
  contents:
  - "#define ICMP6_FILTER_SETPASS(type, filterp) \\\n    ((((filterp)->icmp6_filt[(type)\
    \ >> 5]) |=  (1 << ((type) & 31))))\n"
- title: '#define ICMP6_FILTER_SETBLOCK(type, filterp) \'
  contents:
  - "#define ICMP6_FILTER_SETBLOCK(type, filterp) \\\n    ((((filterp)->icmp6_filt[(type)\
    \ >> 5]) &= ~(1 << ((type) & 31))))\n"
- title: '#define ICMP6_FILTER_SETPASSALL(filterp) \'
  contents:
  - "#define ICMP6_FILTER_SETPASSALL(filterp) \\\n    memset((filterp), 0xFF, sizeof(struct\
    \ icmp6_filter))\n"
- title: '#define ICMP6_FILTER_SETBLOCKALL(filterp) \'
  contents:
  - "#define ICMP6_FILTER_SETBLOCKALL(filterp) \\\n    memset((filterp), 0, sizeof(struct\
    \ icmp6_filter))\n   (Note: These sample definitions have two limitations that\
    \ an\n   implementation may want to change.  The first four macros evaluate\n\
    \   their first argument two times.  The second two macros require the\n   inclusion\
    \ of the <string.h> header for the memset() function.)\n"
- title: 4.  Ancillary Data
  contents:
  - "4.  Ancillary Data\n   4.2BSD allowed file descriptors to be transferred between\
    \ separate\n   processes across a UNIX domain socket using the sendmsg() and\n\
    \   recvmsg() functions.  Two members of the msghdr structure,\n   msg_accrights\
    \ and msg_accrightslen, were used to send and receive the\n   descriptors.  When\
    \ the OSI protocols were added to 4.3BSD Reno in\n   1990 the names of these two\
    \ fields in the msghdr structure were\n   changed to msg_control and msg_controllen,\
    \ because they were used by\n   the OSI protocols for \"control information\"\
    , although the comments in\n   the source code call this \"ancillary data\".\n\
    \   Other than the OSI protocols, the use of ancillary data has been\n   rare.\
    \  In 4.4BSD, for example, the only use of ancillary data with\n   IPv4 is to\
    \ return the destination address of a received UDP datagram\n   if the IP_RECVDSTADDR\
    \ socket option is set.  With Unix domain sockets\n   ancillary data is still\
    \ used to send and receive descriptors.\n   Nevertheless the ancillary data fields\
    \ of the msghdr structure\n   provide a clean way to pass information in addition\
    \ to the data that\n   is being read or written.  The inclusion of the msg_control\
    \ and\n   msg_controllen members of the msghdr structure along with the cmsghdr\n\
    \   structure that is pointed to by the msg_control member is required by\n  \
    \ the Posix.1g sockets API standard (which should be completed during\n   1997).\n\
    \   In this document ancillary data is used to exchange the following\n   optional\
    \ information between the application and the kernel:\n       1.  the send/receive\
    \ interface and source/destination address,\n       2.  the hop limit,\n     \
    \  3.  next hop address,\n       4.  Hop-by-Hop options,\n       5.  Destination\
    \ options, and\n       6.  Routing header.\n   Before describing these uses in\
    \ detail, we review the definition of\n   the msghdr structure itself, the cmsghdr\
    \ structure that defines an\n   ancillary data object, and some functions that\
    \ operate on the\n   ancillary data objects.\n"
- title: 4.1.  The msghdr Structure
  contents:
  - "4.1.  The msghdr Structure\n   The msghdr structure is used by the recvmsg()\
    \ and sendmsg()\n   functions.  Its Posix.1g definition is:\n    struct msghdr\
    \ {\n      void      *msg_name;        /* ptr to socket address structure */\n\
    \      socklen_t  msg_namelen;     /* size of socket address structure */\n  \
    \    struct iovec  *msg_iov;     /* scatter/gather array */\n      size_t    \
    \ msg_iovlen;      /* # elements in msg_iov */\n      void      *msg_control;\
    \     /* ancillary data */\n      socklen_t  msg_controllen;  /* ancillary data\
    \ buffer length */\n      int        msg_flags;       /* flags on received message\
    \ */\n    };\n   The structure is declared as a result of including <sys/socket.h>.\n\
    \   (Note: Before Posix.1g the two \"void *\" pointers were typically \"char\n\
    \   *\", and the two socklen_t members and the size_t member were\n   typically\
    \ integers.  Earlier drafts of Posix.1g had the two socklen_t\n   members as size_t,\
    \ but Draft 6.6 of Posix.1g, apparently the final\n   draft, changed these to\
    \ socklen_t to simplify binary portability for\n   64-bit implementations and\
    \ to align Posix.1g with X/Open's Networking\n   Services, Issue 5.  The change\
    \ in msg_control to a \"void *\" pointer\n   affects any code that increments\
    \ this pointer.)\n   Most Berkeley-derived implementations limit the amount of\
    \ ancillary\n   data in a call to sendmsg() to no more than 108 bytes (an mbuf).\n\
    \   This API requires a minimum of 10240 bytes of ancillary data, but it\n   is\
    \ recommended that the amount be limited only by the buffer space\n   reserved\
    \ by the socket (which can be modified by the SO_SNDBUF socket\n   option).  (Note:\
    \ This magic number 10240 was picked as a value that\n   should always be large\
    \ enough.  108 bytes is clearly too small as the\n   maximum size of a Type 0\
    \ Routing header is 376 bytes.)\n"
- title: 4.2.  The cmsghdr Structure
  contents:
  - "4.2.  The cmsghdr Structure\n   The cmsghdr structure describes ancillary data\
    \ objects transferred by\n   recvmsg() and sendmsg().  Its Posix.1g definition\
    \ is:\n    struct cmsghdr {\n      socklen_t  cmsg_len;   /* #bytes, including\
    \ this header */\n      int        cmsg_level; /* originating protocol */\n  \
    \    int        cmsg_type;  /* protocol-specific type */\n                 /*\
    \ followed by unsigned char cmsg_data[]; */\n    };\n   This structure is declared\
    \ as a result of including <sys/socket.h>.\n   As shown in this definition, normally\
    \ there is no member with the\n   name cmsg_data[].  Instead, the data portion\
    \ is accessed using the\n   CMSG_xxx() macros, as described shortly.  Nevertheless,\
    \ it is common\n   to refer to the cmsg_data[] member.\n   (Note: Before Posix.1g\
    \ the cmsg_len member was an integer, and not a\n   socklen_t.  See the Note in\
    \ the previous section for why socklen_t is\n   used here.)\n   When ancillary\
    \ data is sent or received, any number of ancillary data\n   objects can be specified\
    \ by the msg_control and msg_controllen\n   members of the msghdr structure, because\
    \ each object is preceded by a\n   cmsghdr structure defining the object's length\
    \ (the cmsg_len member).\n   Historically Berkeley-derived implementations have\
    \ passed only one\n   object at a time, but this API allows multiple objects to\
    \ be passed\n   in a single call to sendmsg() or recvmsg().  The following example\n\
    \   shows two ancillary data objects in a control buffer.\n"
- title: '|<--------------------------- msg_controllen -------------------------->|'
  contents:
  - '|<--------------------------- msg_controllen -------------------------->|

    '
- title: '|                                                                       |'
  contents:
  - '|                                                                       |

    '
- title: '|<----- ancillary data object ----->|<----- ancillary data object ----->|'
  contents:
  - '|<----- ancillary data object ----->|<----- ancillary data object ----->|

    '
- title: '|<---------- CMSG_SPACE() --------->|<---------- CMSG_SPACE() --------->|'
  contents:
  - '|<---------- CMSG_SPACE() --------->|<---------- CMSG_SPACE() --------->|

    '
- title: '|                                   |                                   |'
  contents:
  - '|                                   |                                   |

    '
- title: '|<---------- cmsg_len ---------->|  |<--------- cmsg_len ----------->|  |'
  contents:
  - '|<---------- cmsg_len ---------->|  |<--------- cmsg_len ----------->|  |

    '
- title: '|<--------- CMSG_LEN() --------->|  |<-------- CMSG_LEN() ---------->|  |'
  contents:
  - '|<--------- CMSG_LEN() --------->|  |<-------- CMSG_LEN() ---------->|  |

    '
- title: '|                                |  |                                |  |'
  contents:
  - '|                                |  |                                |  |

    '
- title: +-----+-----+-----+--+-----------+--+-----+-----+-----+--+-----------+--+
  contents:
  - '+-----+-----+-----+--+-----------+--+-----+-----+-----+--+-----------+--+

    '
- title: '|cmsg_|cmsg_|cmsg_|XX|           |XX|cmsg_|cmsg_|cmsg_|XX|           |XX|'
  contents:
  - '|cmsg_|cmsg_|cmsg_|XX|           |XX|cmsg_|cmsg_|cmsg_|XX|           |XX|

    '
- title: '|len  |level|type |XX|cmsg_data[]|XX|len  |level|type |XX|cmsg_data[]|XX|'
  contents:
  - '|len  |level|type |XX|cmsg_data[]|XX|len  |level|type |XX|cmsg_data[]|XX|

    '
- title: +-----+-----+-----+--+-----------+--+-----+-----+-----+--+-----------+--+
  contents:
  - "+-----+-----+-----+--+-----------+--+-----+-----+-----+--+-----------+--+\n ^\n\
    \ |\n"
- title: msg_control
  contents:
  - 'msg_control

    '
- title: points here
  contents:
  - "points here\n   The fields shown as \"XX\" are possible padding, between the\
    \ cmsghdr\n   structure and the data, and between the data and the next cmsghdr\n\
    \   structure, if required by the implementation.\n"
- title: 4.3.  Ancillary Data Object Macros
  contents:
  - "4.3.  Ancillary Data Object Macros\n   To aid in the manipulation of ancillary\
    \ data objects, three macros\n   from 4.4BSD are defined by Posix.1g: CMSG_DATA(),\
    \ CMSG_NXTHDR(), and\n   CMSG_FIRSTHDR().  Before describing these macros, we\
    \ show the\n   following example of how they might be used with a call to recvmsg().\n\
    \    struct msghdr   msg;\n    struct cmsghdr  *cmsgptr;\n    /* fill in msg */\n\
    \    /* call recvmsg() */\n    for (cmsgptr = CMSG_FIRSTHDR(&msg); cmsgptr !=\
    \ NULL;\n         cmsgptr = CMSG_NXTHDR(&msg, cmsgptr)) {\n        if (cmsgptr->cmsg_level\
    \ == ... && cmsgptr->cmsg_type == ... ) {\n            u_char  *ptr;\n       \
    \     ptr = CMSG_DATA(cmsgptr);\n            /* process data pointed to by ptr\
    \ */\n        }\n    }\n   We now describe the three Posix.1g macros, followed\
    \ by two more that\n   are new with this API: CMSG_SPACE() and CMSG_LEN().  All\
    \ these macros\n   are defined as a result of including <sys/socket.h>.\n"
- title: 4.3.1.  CMSG_FIRSTHDR
  contents:
  - "4.3.1.  CMSG_FIRSTHDR\n       struct cmsghdr *CMSG_FIRSTHDR(const struct msghdr\
    \ *mhdr);\n   CMSG_FIRSTHDR() returns a pointer to the first cmsghdr structure\
    \ in\n   the msghdr structure pointed to by mhdr.  The macro returns NULL if\n\
    \   there is no ancillary data pointed to the by msghdr structure (that\n   is,\
    \ if either msg_control is NULL or if msg_controllen is less than\n   the size\
    \ of a cmsghdr structure).\n   One possible implementation could be\n       #define\
    \ CMSG_FIRSTHDR(mhdr) \\\n           ( (mhdr)->msg_controllen >= sizeof(struct\
    \ cmsghdr) ? \\\n             (struct cmsghdr *)(mhdr)->msg_control : \\\n   \
    \          (struct cmsghdr *)NULL )\n   (Note: Most existing implementations do\
    \ not test the value of\n   msg_controllen, and just return the value of msg_control.\
    \  The value\n   of msg_controllen must be tested, because if the application\
    \ asks\n   recvmsg() to return ancillary data, by setting msg_control to point\n\
    \   to the application's buffer and setting msg_controllen to the length\n   of\
    \ this buffer, the kernel indicates that no ancillary data is\n   available by\
    \ setting msg_controllen to 0 on return.  It is also\n   easier to put this test\
    \ into this macro, than making the application\n   perform the test.)\n"
- title: 4.3.2.  CMSG_NXTHDR
  contents:
  - "4.3.2.  CMSG_NXTHDR\n       struct cmsghdr *CMSG_NXTHDR(const struct msghdr *mhdr,\n\
    \                                   const struct cmsghdr *cmsg);\n   CMSG_NXTHDR()\
    \ returns a pointer to the cmsghdr structure describing\n   the next ancillary\
    \ data object.  mhdr is a pointer to a msghdr\n   structure and cmsg is a pointer\
    \ to a cmsghdr structure.  If there is\n   not another ancillary data object,\
    \ the return value is NULL.\n   The following behavior of this macro is new to\
    \ this API: if the value\n   of the cmsg pointer is NULL, a pointer to the cmsghdr\
    \ structure\n   describing the first ancillary data object is returned.  That\
    \ is,\n   CMSG_NXTHDR(mhdr, NULL) is equivalent to CMSG_FIRSTHDR(mhdr).  If\n\
    \   there are no ancillary data objects, the return value is NULL.  This\n   provides\
    \ an alternative way of coding the processing loop shown\n   earlier:\n"
- title: struct msghdr  msg;
  contents:
  - 'struct msghdr  msg;

    '
- title: struct cmsghdr  *cmsgptr = NULL;
  contents:
  - 'struct cmsghdr  *cmsgptr = NULL;

    '
- title: /* fill in msg */
  contents:
  - '/* fill in msg */

    '
- title: /* call recvmsg() */
  contents:
  - '/* call recvmsg() */

    '
- title: while ((cmsgptr = CMSG_NXTHDR(&msg, cmsgptr)) != NULL) {
  contents:
  - "while ((cmsgptr = CMSG_NXTHDR(&msg, cmsgptr)) != NULL) {\n    if (cmsgptr->cmsg_level\
    \ == ... && cmsgptr->cmsg_type == ... ) {\n        u_char  *ptr;\n        ptr\
    \ = CMSG_DATA(cmsgptr);\n        /* process data pointed to by ptr */\n    }\n"
- title: '}'
  contents:
  - "}\n   One possible implementation could be:\n    #define CMSG_NXTHDR(mhdr, cmsg)\
    \ \\\n        ( ((cmsg) == NULL) ? CMSG_FIRSTHDR(mhdr) : \\\n          (((u_char\
    \ *)(cmsg) + ALIGN((cmsg)->cmsg_len) \\\n                             + ALIGN(sizeof(struct\
    \ cmsghdr)) > \\\n            (u_char *)((mhdr)->msg_control) + (mhdr)->msg_controllen)\
    \ ? \\\n           (struct cmsghdr *)NULL : \\\n           (struct cmsghdr *)((u_char\
    \ *)(cmsg) + ALIGN((cmsg)->cmsg_len))) )\n   The macro ALIGN(), which is implementation\
    \ dependent, rounds its\n   argument up to the next even multiple of whatever\
    \ alignment is\n   required (probably a multiple of 4 or 8 bytes).\n"
- title: 4.3.3.  CMSG_DATA
  contents:
  - "4.3.3.  CMSG_DATA\n       unsigned char *CMSG_DATA(const struct cmsghdr *cmsg);\n\
    \   CMSG_DATA() returns a pointer to the data (what is called the\n   cmsg_data[]\
    \ member, even though such a member is not defined in the\n   structure) following\
    \ a cmsghdr structure.\n   One possible implementation could be:\n       #define\
    \ CMSG_DATA(cmsg) ( (u_char *)(cmsg) + \\\n                                 ALIGN(sizeof(struct\
    \ cmsghdr)) )\n"
- title: 4.3.4.  CMSG_SPACE
  contents:
  - "4.3.4.  CMSG_SPACE\n       unsigned int CMSG_SPACE(unsigned int length);\n  \
    \ This macro is new with this API.  Given the length of an ancillary\n   data\
    \ object, CMSG_SPACE() returns the space required by the object\n   and its cmsghdr\
    \ structure, including any padding needed to satisfy\n   alignment requirements.\
    \  This macro can be used, for example, to\n   allocate space dynamically for\
    \ the ancillary data.  This macro should\n   not be used to initialize the cmsg_len\
    \ member of a cmsghdr structure;\n   instead use the CMSG_LEN() macro.\n   One\
    \ possible implementation could be:\n       #define CMSG_SPACE(length) ( ALIGN(sizeof(struct\
    \ cmsghdr)) + \\\n                                    ALIGN(length) )\n"
- title: 4.3.5.  CMSG_LEN
  contents:
  - "4.3.5.  CMSG_LEN\n       unsigned int CMSG_LEN(unsigned int length);\n   This\
    \ macro is new with this API.  Given the length of an ancillary\n   data object,\
    \ CMSG_LEN() returns the value to store in the cmsg_len\n   member of the cmsghdr\
    \ structure, taking into account any padding\n   needed to satisfy alignment requirements.\n\
    \   One possible implementation could be:\n       #define CMSG_LEN(length) ( ALIGN(sizeof(struct\
    \ cmsghdr)) + length\n       )\n   Note the difference between CMSG_SPACE() and\
    \ CMSG_LEN(), shown also\n   in the figure in Section 4.2: the former accounts\
    \ for any required\n   padding at the end of the ancillary data object and the\
    \ latter is the\n   actual length to store in the cmsg_len member of the ancillary\
    \ data\n   object.\n"
- title: 4.4.  Summary of Options Described Using Ancillary Data
  contents:
  - "4.4.  Summary of Options Described Using Ancillary Data\n   There are six types\
    \ of optional information described in this\n   document that are passed between\
    \ the application and the kernel using\n   ancillary data:\n       1.  the send/receive\
    \ interface and source/destination address,\n       2.  the hop limit,\n     \
    \  3.  next hop address,\n       4.  Hop-by-Hop options,\n       5.  Destination\
    \ options, and\n       6.  Routing header.\n   First, to receive any of this optional\
    \ information (other than the\n   next hop address, which can only be set), the\
    \ application must call\n   setsockopt() to turn on the corresponding flag:\n\
    \       int  on = 1;\n       setsockopt(fd, IPPROTO_IPV6, IPV6_PKTINFO,  &on,\
    \ sizeof(on));\n       setsockopt(fd, IPPROTO_IPV6, IPV6_HOPLIMIT, &on, sizeof(on));\n\
    \       setsockopt(fd, IPPROTO_IPV6, IPV6_HOPOPTS,  &on, sizeof(on));\n      \
    \ setsockopt(fd, IPPROTO_IPV6, IPV6_DSTOPTS,  &on, sizeof(on));\n       setsockopt(fd,\
    \ IPPROTO_IPV6, IPV6_RTHDR,    &on, sizeof(on));\n   When any of these options\
    \ are enabled, the corresponding data is\n   returned as control information by\
    \ recvmsg(), as one or more\n   ancillary data objects.\n   Nothing special need\
    \ be done to send any of this optional\n   information; the application just calls\
    \ sendmsg() and specifies one\n   or more ancillary data objects as control information.\n\
    \   We also summarize the three cmsghdr fields that describe the\n   ancillary\
    \ data objects:\n       cmsg_level    cmsg_type      cmsg_data[]             \
    \  #times\n       ------------  ------------   ------------------------  ------\n\
    \       IPPROTO_IPV6  IPV6_PKTINFO   in6_pktinfo structure     once\n       IPPROTO_IPV6\
    \  IPV6_HOPLIMIT  int                       once\n       IPPROTO_IPV6  IPV6_NEXTHOP\
    \   socket address structure  once\n       IPPROTO_IPV6  IPV6_HOPOPTS   implementation\
    \ dependent  mult.\n       IPPROTO_IPV6  IPV6_DSTOPTS   implementation dependent\
    \  mult.\n       IPPROTO_IPV6  IPV6_RTHDR     implementation dependent  once\n\
    \   The final column indicates how many times an ancillary data object of\n  \
    \ that type can appear as control information.  The Hop-by-Hop and\n   Destination\
    \ options can appear multiple times, while all the others\n   can appear only\
    \ one time.\n   All these options are described in detail in following sections.\
    \  All\n   the constants beginning with IPV6_ are defined as a result of\n   including\
    \ the <netinet/in.h> header.\n   (Note: We intentionally use the same constant\
    \ for the cmsg_level\n   member as is used as the second argument to getsockopt()\
    \ and\n   setsockopt() (what is called the \"level\"), and the same constant for\n\
    \   the cmsg_type member as is used as the third argument to getsockopt()\n  \
    \ and setsockopt() (what is called the \"option name\").  This is\n   consistent\
    \ with the existing use of ancillary data in 4.4BSD:\n   returning the destination\
    \ address of an IPv4 datagram.)\n   (Note: It is up to the implementation what\
    \ it passes as ancillary\n   data for the Hop-by-Hop option, Destination option,\
    \ and Routing\n   header option, since the API to these features is through a\
    \ set of\n   inet6_option_XXX() and inet6_rthdr_XXX() functions that we define\n\
    \   later.  These functions serve two purposes: to simplify the interface\n  \
    \ to these features (instead of requiring the application to know the\n   intimate\
    \ details of the extension header formats), and to hide the\n   actual implementation\
    \ from the application.  Nevertheless, we show\n   some examples of these features\
    \ that store the actual extension\n   header as the ancillary data.  Implementations\
    \ need not use this\n   technique.)\n"
- title: 4.5.  IPV6_PKTOPTIONS Socket Option
  contents:
  - "4.5.  IPV6_PKTOPTIONS Socket Option\n   The summary in the previous section assumes\
    \ a UDP socket.  Sending\n   and receiving ancillary data is easy with UDP: the\
    \ application calls\n   sendmsg() and recvmsg() instead of sendto() and recvfrom().\n\
    \   But there might be cases where a TCP application wants to send or\n   receive\
    \ this optional information.  For example, a TCP client might\n   want to specify\
    \ a Routing header and this needs to be done before\n   calling connect().  Similarly\
    \ a TCP server might want to know the\n   received interface after accept() returns\
    \ along with any Destination\n   options.\n   A new socket option is defined that\
    \ provides access to the optional\n   information described in the previous section,\
    \ but without using\n   recvmsg() and sendmsg().  Setting the socket option specifies\
    \ any of\n   the optional output fields:\n       setsockopt(fd, IPPROTO_IPV6,\
    \ IPV6_PKTOPTIONS, &buf, len);\n   The fourth argument points to a buffer containing\
    \ one or more\n   ancillary data objects, and the fifth argument is the total\
    \ length of\n   all these objects.  The application fills in this buffer exactly\
    \ as\n   if the buffer were being passed to sendmsg() as control information.\n\
    \   The options set by calling setsockopt() for IPV6_PKTOPTIONS are\n   called\
    \ \"sticky\" options because once set they apply to all packets\n   sent on that\
    \ socket.  The application can call setsockopt() again to\n   change all the sticky\
    \ options, or it can call setsockopt() with a\n   length of 0 to remove all the\
    \ sticky options for the socket.\n   The corresponding receive option\n      \
    \ getsockopt(fd, IPPROTO_IPV6, IPV6_PKTOPTIONS, &buf, &len);\n   returns a buffer\
    \ with one or more ancillary data objects for all the\n   optional receive information\
    \ that the application has previously\n   specified that it wants to receive.\
    \  The fourth argument points to\n   the buffer that is filled in by the call.\
    \  The fifth argument is a\n   pointer to a value-result integer: when the function\
    \ is called the\n   integer specifies the size of the buffer pointed to by the\
    \ fourth\n   argument, and on return this integer contains the actual number of\n\
    \   bytes that were returned.  The application processes this buffer\n   exactly\
    \ as if the buffer were returned by recvmsg() as control\n   information.\n  \
    \ To simplify this document, in the remaining sections when we say \"can\n   be\
    \ specified as ancillary data to sendmsg()\" we mean \"can be\n   specified as\
    \ ancillary data to sendmsg() or specified as a sticky\n   option using setsockopt()\
    \ and the IPV6_PKTOPTIONS socket option\".\n   Similarly when we say \"can be\
    \ returned as ancillary data by\n   recvmsg()\" we mean \"can be returned as ancillary\
    \ data by recvmsg() or\n   returned by getsockopt() with the IPV6_PKTOPTIONS socket\
    \ option\".\n"
- title: 4.5.1.  TCP Sticky Options
  contents:
  - "4.5.1.  TCP Sticky Options\n   When using getsockopt() with the IPV6_PKTOPTIONS\
    \ option and a TCP\n   socket, only the options from the most recently received\
    \ segment are\n   retained and returned to the caller, and only after the socket\
    \ option\n   has been set.  That is, TCP need not start saving a copy of the\n\
    \   options until the application says to do so.\n   The application is not allowed\
    \ to specify ancillary data in a call to\n   sendmsg() on a TCP socket, and none\
    \ of the ancillary data that we\n   describe in this document is ever returned\
    \ as control information by\n   recvmsg() on a TCP socket.\n"
- title: 4.5.2.  UDP and Raw Socket Sticky Options
  contents:
  - "4.5.2.  UDP and Raw Socket Sticky Options\n   The IPV6_PKTOPTIONS socket option\
    \ can also be used with a UDP socket\n   or with a raw IPv6 socket, normally to\
    \ set some of the options once,\n   instead of with each call to sendmsg().\n\
    \   Unlike the TCP case, the sticky options can be overridden on a per-\n   packet\
    \ basis with ancillary data specified in a call to sendmsg() on\n   a UDP or raw\
    \ IPv6 socket.  If any ancillary data is specified in a\n   call to sendmsg(),\
    \ none of the sticky options are sent with that\n   datagram.\n"
- title: 5.  Packet Information
  contents:
  - "5.  Packet Information\n   There are four pieces of information that an application\
    \ can specify\n   for an outgoing packet using ancillary data:\n       1.  the\
    \ source IPv6 address,\n       2.  the outgoing interface index,\n       3.  the\
    \ outgoing hop limit, and\n       4.  the next hop address.\n   Three similar\
    \ pieces of information can be returned for a received\n   packet as ancillary\
    \ data:\n       1.  the destination IPv6 address,\n       2.  the arriving interface\
    \ index, and\n       3.  the arriving hop limit.\n   The first two pieces of information\
    \ are contained in an in6_pktinfo\n   structure that is sent as ancillary data\
    \ with sendmsg() and received\n   as ancillary data with recvmsg().  This structure\
    \ is defined as a\n   result of including the <netinet/in.h> header.\n       struct\
    \ in6_pktinfo {\n         struct in6_addr ipi6_addr;    /* src/dst IPv6 address\
    \ */\n         unsigned int    ipi6_ifindex; /* send/recv interface index */\n\
    \       };\n   In the cmsghdr structure containing this ancillary data, the\n\
    \   cmsg_level member will be IPPROTO_IPV6, the cmsg_type member will be\n   IPV6_PKTINFO,\
    \ and the first byte of cmsg_data[] will be the first\n   byte of the in6_pktinfo\
    \ structure.\n   This information is returned as ancillary data by recvmsg() only\
    \ if\n   the application has enabled the IPV6_PKTINFO socket option:\n       int\
    \  on = 1;\n       setsockopt(fd, IPPROTO_IPV6, IPV6_PKTINFO, &on, sizeof(on));\n\
    \   Nothing special need be done to send this information: just specify\n   the\
    \ control information as ancillary data for sendmsg().\n   (Note: The hop limit\
    \ is not contained in the in6_pktinfo structure\n   for the following reason.\
    \  Some UDP servers want to respond to client\n   requests by sending their reply\
    \ out the same interface on which the\n   request was received and with the source\
    \ IPv6 address of the reply\n   equal to the destination IPv6 address of the request.\
    \  To do this the\n   application can enable just the IPV6_PKTINFO socket option\
    \ and then\n   use the received control information from recvmsg() as the outgoing\n\
    \   control information for sendmsg().  The application need not examine\n   or\
    \ modify the in6_pktinfo structure at all.  But if the hop limit\n   were contained\
    \ in this structure, the application would have to parse\n   the received control\
    \ information and change the hop limit member,\n   since the received hop limit\
    \ is not the desired value for an outgoing\n   packet.)\n"
- title: 5.1.  Specifying/Receiving the Interface
  contents:
  - "5.1.  Specifying/Receiving the Interface\n   Interfaces on an IPv6 node are identified\
    \ by a small positive\n   integer, as described in Section 4 of [RFC-2133].  That\
    \ document also\n   describes a function to map an interface name to its interface\
    \ index,\n   a function to map an interface index to its interface name, and a\n\
    \   function to return all the interface names and indexes.  Notice from\n   this\
    \ document that no interface is ever assigned an index of 0.\n   When specifying\
    \ the outgoing interface, if the ipi6_ifindex value is\n   0, the kernel will\
    \ choose the outgoing interface.  If the application\n   specifies an outgoing\
    \ interface for a multicast packet, the interface\n   specified by the ancillary\
    \ data overrides any interface specified by\n   the IPV6_MULTICAST_IF socket option\
    \ (described in [RFC-2133]), for\n   that call to sendmsg() only.\n   When the\
    \ IPV6_PKTINFO socket option is enabled, the received\n   interface index is always\
    \ returned as the ipi6_ifindex member of the\n   in6_pktinfo structure.\n"
- title: 5.2.  Specifying/Receiving Source/Destination Address
  contents:
  - "5.2.  Specifying/Receiving Source/Destination Address\n   The source IPv6 address\
    \ can be specified by calling bind() before\n   each output operation, but supplying\
    \ the source address together with\n   the data requires less overhead (i.e.,\
    \ fewer system calls) and\n   requires less state to be stored and protected in\
    \ a multithreaded\n   application.\n   When specifying the source IPv6 address\
    \ as ancillary data, if the\n   ipi6_addr member of the in6_pktinfo structure\
    \ is the unspecified\n   address (IN6ADDR_ANY_INIT), then (a) if an address is\
    \ currently bound\n   to the socket, it is used as the source address, or (b)\
    \ if no address\n   is currently bound to the socket, the kernel will choose the\
    \ source\n   address.  If the ipi6_addr member is not the unspecified address,\
    \ but\n   the socket has already bound a source address, then the ipi6_addr\n\
    \   value overrides the already-bound source address for this output\n   operation\
    \ only.\n   The kernel must verify that the requested source address is indeed\
    \ a\n   unicast address assigned to the node.\n   When the in6_pktinfo structure\
    \ is returned as ancillary data by\n   recvmsg(), the ipi6_addr member contains\
    \ the destination IPv6 address\n   from the received packet.\n"
- title: 5.3.  Specifying/Receiving the Hop Limit
  contents:
  - "5.3.  Specifying/Receiving the Hop Limit\n   The outgoing hop limit is normally\
    \ specified with either the\n   IPV6_UNICAST_HOPS socket option or the IPV6_MULTICAST_HOPS\
    \ socket\n   option, both of which are described in [RFC-2133].  Specifying the\n\
    \   hop limit as ancillary data lets the application override either the\n   kernel's\
    \ default or a previously specified value, for either a\n   unicast destination\
    \ or a multicast destination, for a single output\n   operation.  Returning the\
    \ received hop limit is useful for programs\n   such as Traceroute and for IPv6\
    \ applications that need to verify that\n   the received hop limit is 255 (e.g.,\
    \ that the packet has not been\n   forwarded).\n   The received hop limit is returned\
    \ as ancillary data by recvmsg()\n   only if the application has enabled the IPV6_HOPLIMIT\
    \ socket option:\n       int  on = 1;\n       setsockopt(fd, IPPROTO_IPV6, IPV6_HOPLIMIT,\
    \ &on, sizeof(on));\n   In the cmsghdr structure containing this ancillary data,\
    \ the\n   cmsg_level member will be IPPROTO_IPV6, the cmsg_type member will be\n\
    \   IPV6_HOPLIMIT, and the first byte of cmsg_data[] will be the first\n   byte\
    \ of the integer hop limit.\n   Nothing special need be done to specify the outgoing\
    \ hop limit: just\n   specify the control information as ancillary data for sendmsg().\
    \  As\n   specified in [RFC-2133], the interpretation of the integer hop limit\n\
    \   value is\n       x < -1:        return an error of EINVAL\n       x == -1:\
    \       use kernel default\n       0 <= x <= 255: use x\n       x >= 256:    \
    \  return an error of EINVAL\n"
- title: 5.4.  Specifying the Next Hop Address
  contents:
  - "5.4.  Specifying the Next Hop Address\n   The IPV6_NEXTHOP ancillary data object\
    \ specifies the next hop for the\n   datagram as a socket address structure. \
    \ In the cmsghdr structure\n   containing this ancillary data, the cmsg_level\
    \ member will be\n   IPPROTO_IPV6, the cmsg_type member will be IPV6_NEXTHOP,\
    \ and the\n   first byte of cmsg_data[] will be the first byte of the socket\n\
    \   address structure.\n   This is a privileged option.  (Note: It is implementation\
    \ defined and\n   beyond the scope of this document to define what \"privileged\"\
    \ means.\n   Unix systems use this term to mean the process must have an effective\n\
    \   user ID of 0.)\n   If the socket address structure contains an IPv6 address\
    \ (e.g., the\n   sin6_family member is AF_INET6), then the node identified by\
    \ that\n   address must be a neighbor of the sending host.  If that address\n\
    \   equals the destination IPv6 address of the datagram, then this is\n   equivalent\
    \ to the existing SO_DONTROUTE socket option.\n"
- title: 5.5.  Additional Errors with sendmsg()
  contents:
  - "5.5.  Additional Errors with sendmsg()\n   With the IPV6_PKTINFO socket option\
    \ there are no additional errors\n   possible with the call to recvmsg().  But\
    \ when specifying the\n   outgoing interface or the source address, additional\
    \ errors are\n   possible from sendmsg().  The following are examples, but some\
    \ of\n   these may not be provided by some implementations, and some\n   implementations\
    \ may define additional errors:\n   ENXIO         The interface specified by ipi6_ifindex\
    \ does not exist.\n   ENETDOWN      The interface specified by ipi6_ifindex is\
    \ not enabled\n                 for IPv6 use.\n   EADDRNOTAVAIL ipi6_ifindex specifies\
    \ an interface but the address\n                 ipi6_addr is not available for\
    \ use on that interface.\n   EHOSTUNREACH  No route to the destination exists\
    \ over the interface\n                 specified by ifi6_ifindex.\n"
- title: 6.  Hop-By-Hop Options
  contents:
  - "6.  Hop-By-Hop Options\n   A variable number of Hop-by-Hop options can appear\
    \ in a single Hop-\n   by-Hop options header.  Each option in the header is TLV-encoded\
    \ with\n   a type, length, and value.\n   Today only three Hop-by-Hop options\
    \ are defined for IPv6 [RFC-1883]:\n   Jumbo Payload, Pad1, and PadN, although\
    \ a proposal exists for a\n   router-alert Hop-by-Hop option.  The Jumbo Payload\
    \ option should not\n   be passed back to an application and an application should\
    \ receive an\n   error if it attempts to set it.  This option is processed entirely\
    \ by\n   the kernel.  It is indirectly specified by datagram-based\n   applications\
    \ as the size of the datagram to send and indirectly\n   passed back to these\
    \ applications as the length of the received\n   datagram.  The two pad options\
    \ are for alignment purposes and are\n   automatically inserted by a sending kernel\
    \ when needed and ignored by\n   the receiving kernel.  This section of the API\
    \ is therefore defined\n   for future Hop-by-Hop options that an application may\
    \ need to specify\n   and receive.\n   Individual Hop-by-Hop options (and Destination\
    \ options, which are\n   described shortly, and which are similar to the Hop-by-Hop\
    \ options)\n   may have specific alignment requirements.  For example, the 4-byte\n\
    \   Jumbo Payload length should appear on a 4-byte boundary, and IPv6\n   addresses\
    \ are normally aligned on an 8-byte boundary.  These\n   requirements and the\
    \ terminology used with these options are\n   discussed in Section 4.2 and Appendix\
    \ A of [RFC-1883].  The alignment\n   of each option is specified by two values,\
    \ called x and y, written as\n   \"xn + y\".  This states that the option must\
    \ appear at an integer\n   multiple of x bytes from the beginning of the options\
    \ header (x can\n   have the values 1, 2, 4, or 8), plus y bytes (y can have a\
    \ value\n   between 0 and 7, inclusive).  The Pad1 and PadN options are inserted\n\
    \   as needed to maintain the required alignment.  Whatever code builds\n   either\
    \ a Hop-by-Hop options header or a Destination options header\n   must know the\
    \ values of x and y for each option.\n   Multiple Hop-by-Hop options can be specified\
    \ by the application.\n   Normally one ancillary data object describes all the\
    \ Hop-by-Hop\n   options (since each option is itself TLV-encoded) but the application\n\
    \   can specify multiple ancillary data objects for the Hop-by-Hop\n   options,\
    \ each object specifying one or more options.  Care must be\n   taken designing\
    \ the API for these options since\n   1.   it may be possible for some future\
    \ Hop-by-Hop options to be\n        generated by the application and processed\
    \ entirely by the\n        application (e.g., the kernel may not know the alignment\n\
    \        restrictions for the option),\n   2.   it must be possible for the kernel\
    \ to insert its own Hop-by-Hop\n        options in an outgoing packet (e.g., the\
    \ Jumbo Payload option),\n   3.   the application can place one or more Hop-by-Hop\
    \ options into a\n        single ancillary data object,\n   4.   if the application\
    \ specifies multiple ancillary data objects,\n        each containing one or more\
    \ Hop-by-Hop options, the kernel must\n        combine these a single Hop-by-Hop\
    \ options header, and\n   5.   it must be possible for the kernel to remove some\
    \ Hop-by-Hop\n        options from a received packet before returning the remaining\n\
    \        Hop-by-Hop options to the application.  (This removal might\n       \
    \ consist of the kernel converting the option into a pad option of\n        the\
    \ same length.)\n   Finally, we note that access to some Hop-by-Hop options or\
    \ to some\n   Destination options, might require special privilege.  That is,\n\
    \   normal applications (without special privilege) might be forbidden\n   from\
    \ setting certain options in outgoing packets, and might never see\n   certain\
    \ options in received packets.\n"
- title: 6.1.  Receiving Hop-by-Hop Options
  contents:
  - "6.1.  Receiving Hop-by-Hop Options\n   To receive Hop-by-Hop options the application\
    \ must enable the\n   IPV6_HOPOPTS socket option:\n       int  on = 1;\n     \
    \  setsockopt(fd, IPPROTO_IPV6, IPV6_HOPOPTS, &on, sizeof(on));\n   All the Hop-by-Hop\
    \ options are returned as one ancillary data object\n   described by a cmsghdr\
    \ structure.  The cmsg_level member will be\n   IPPROTO_IPV6 and the cmsg_type\
    \ member will be IPV6_HOPOPTS.  These\n   options are then processed by calling\
    \ the inet6_option_next() and\n   inet6_option_find() functions, described shortly.\n"
- title: 6.2.  Sending Hop-by-Hop Options
  contents:
  - "6.2.  Sending Hop-by-Hop Options\n   To send one or more Hop-by-Hop options,\
    \ the application just\n   specifies them as ancillary data in a call to sendmsg().\
    \  No socket\n   option need be set.\n   Normally all the Hop-by-Hop options are\
    \ specified by a single\n   ancillary data object.  Multiple ancillary data objects,\
    \ each\n   containing one or more Hop-by-Hop options, can also be specified, in\n\
    \   which case the kernel will combine all the Hop-by-Hop options into a\n   single\
    \ Hop-by-Hop extension header.  But it should be more efficient\n   to use a single\
    \ ancillary data object to describe all the Hop-by-Hop\n   options.  The cmsg_level\
    \ member is set to IPPROTO_IPV6 and the\n   cmsg_type member is set to IPV6_HOPOPTS.\
    \  The option is normally\n   constructed using the inet6_option_init(), inet6_option_append(),\
    \ and\n   inet6_option_alloc() functions, described shortly.\n   Additional errors\
    \ may be possible from sendmsg() if the specified\n   option is in error.\n"
- title: 6.3.  Hop-by-Hop and Destination Options Processing
  contents:
  - "6.3.  Hop-by-Hop and Destination Options Processing\n   Building and parsing\
    \ the Hop-by-Hop and Destination options is\n   complicated for the reasons given\
    \ earlier.  We therefore define a set\n   of functions to help the application.\
    \  The function prototypes for\n   these functions are all in the <netinet/in.h>\
    \ header.\n"
- title: 6.3.1.  inet6_option_space
  contents:
  - "6.3.1.  inet6_option_space\n       int inet6_option_space(int nbytes);\n   This\
    \ function returns the number of bytes required to hold an option\n   when it\
    \ is stored as ancillary data, including the cmsghdr structure\n   at the beginning,\
    \ and any padding at the end (to make its size a\n   multiple of 8 bytes).  The\
    \ argument is the size of the structure\n   defining the option, which must include\
    \ any pad bytes at the\n   beginning (the value y in the alignment term \"xn +\
    \ y\"), the type\n   byte, the length byte, and the option data.\n   (Note: If\
    \ multiple options are stored in a single ancillary data\n   object, which is\
    \ the recommended technique, this function\n   overestimates the amount of space\
    \ required by the size of N-1 cmsghdr\n   structures, where N is the number of\
    \ options to be stored in the\n   object.  This is of little consequence, since\
    \ it is assumed that most\n   Hop-by-Hop option headers and Destination option\
    \ headers carry only\n   one option (p. 33 of [RFC-1883]).)\n"
- title: 6.3.2.  inet6_option_init
  contents:
  - "6.3.2.  inet6_option_init\n       int inet6_option_init(void *bp, struct cmsghdr\
    \ **cmsgp, int\n       type);\n   This function is called once per ancillary data\
    \ object that will\n   contain either Hop-by-Hop or Destination options.  It returns\
    \ 0 on\n   success or -1 on an error.\n   bp is a pointer to previously allocated\
    \ space that will contain the\n   ancillary data object.  It must be large enough\
    \ to contain all the\n   individual options to be added by later calls to\n  \
    \ inet6_option_append() and inet6_option_alloc().\n   cmsgp is a pointer to a\
    \ pointer to a cmsghdr structure.  *cmsgp is\n   initialized by this function\
    \ to point to the cmsghdr structure\n   constructed by this function in the buffer\
    \ pointed to by bp.\n   type is either IPV6_HOPOPTS or IPV6_DSTOPTS.  This type\
    \ is stored in\n   the cmsg_type member of the cmsghdr structure pointed to by\
    \ *cmsgp.\n"
- title: 6.3.3.  inet6_option_append
  contents:
  - "6.3.3.  inet6_option_append\n       int inet6_option_append(struct cmsghdr *cmsg,\
    \ const uint8_t *typep,\n                               int multx, int plusy);\n\
    \   This function appends a Hop-by-Hop option or a Destination option\n   into\
    \ an ancillary data object that has been initialized by\n   inet6_option_init().\
    \  This function returns 0 if it succeeds or -1 on\n   an error.\n   cmsg is a\
    \ pointer to the cmsghdr structure that must have been\n   initialized by inet6_option_init().\n\
    \   typep is a pointer to the 8-bit option type.  It is assumed that this\n  \
    \ field is immediately followed by the 8-bit option data length field,\n   which\
    \ is then followed immediately by the option data.  The caller\n   initializes\
    \ these three fields (the type-length-value, or TLV) before\n   calling this function.\n\
    \   The option type must have a value from 2 to 255, inclusive.  (0 and 1\n  \
    \ are reserved for the Pad1 and PadN options, respectively.)\n   The option data\
    \ length must have a value between 0 and 255,\n   inclusive, and is the length\
    \ of the option data that follows.\n   multx is the value x in the alignment term\
    \ \"xn + y\" described\n   earlier.  It must have a value of 1, 2, 4, or 8.\n\
    \   plusy is the value y in the alignment term \"xn + y\" described\n   earlier.\
    \  It must have a value between 0 and 7, inclusive.\n"
- title: 6.3.4.  inet6_option_alloc
  contents:
  - "6.3.4.  inet6_option_alloc\n       uint8_t *inet6_option_alloc(struct cmsghdr\
    \ *cmsg, int datalen,\n                                    int multx, int plusy);\n\
    \   This function appends a Hop-by-Hop option or a Destination option\n   into\
    \ an ancillary data object that has been initialized by\n   inet6_option_init().\
    \  This function returns a pointer to the 8-bit\n   option type field that starts\
    \ the option on success, or NULL on an\n   error.\n   The difference between this\
    \ function and inet6_option_append() is\n   that the latter copies the contents\
    \ of a previously built option into\n   the ancillary data object while the current\
    \ function returns a\n   pointer to the space in the data object where the option's\
    \ TLV must\n   then be built by the caller.\n   cmsg is a pointer to the cmsghdr\
    \ structure that must have been\n   initialized by inet6_option_init().\n   datalen\
    \ is the value of the option data length byte for this option.\n   This value\
    \ is required as an argument to allow the function to\n   determine if padding\
    \ must be appended at the end of the option.  (The\n   inet6_option_append() function\
    \ does not need a data length argument\n   since the option data length must already\
    \ be stored by the caller.)\n   multx is the value x in the alignment term \"\
    xn + y\" described\n   earlier.  It must have a value of 1, 2, 4, or 8.\n   plusy\
    \ is the value y in the alignment term \"xn + y\" described\n   earlier.  It must\
    \ have a value between 0 and 7, inclusive.\n"
- title: 6.3.5.  inet6_option_next
  contents:
  - "6.3.5.  inet6_option_next\n       int inet6_option_next(const struct cmsghdr\
    \ *cmsg, uint8_t\n       **tptrp);\n   This function processes the next Hop-by-Hop\
    \ option or Destination\n   option in an ancillary data object.  If another option\
    \ remains to be\n   processed, the return value of the function is 0 and *tptrp\
    \ points to\n   the 8-bit option type field (which is followed by the 8-bit option\n\
    \   data length, followed by the option data).  If no more options remain\n  \
    \ to be processed, the return value is -1 and *tptrp is NULL.  If an\n   error\
    \ occurs, the return value is -1 and *tptrp is not NULL.\n   cmsg is a pointer\
    \ to cmsghdr structure of which cmsg_level equals\n   IPPROTO_IPV6 and cmsg_type\
    \ equals either IPV6_HOPOPTS or\n   IPV6_DSTOPTS.\n   tptrp is a pointer to a\
    \ pointer to an 8-bit byte and *tptrp is used\n   by the function to remember\
    \ its place in the ancillary data object\n   each time the function is called.\
    \  The first time this function is\n   called for a given ancillary data object,\
    \ *tptrp must be set to NULL.\n   Each time this function returns success, *tptrp\
    \ points to the 8-bit\n   option type field for the next option to be processed.\n"
- title: 6.3.6.  inet6_option_find
  contents:
  - "6.3.6.  inet6_option_find\n       int inet6_option_find(const struct cmsghdr\
    \ *cmsg, uint8_t *tptrp,\n                             int type);\n   This function\
    \ is similar to the previously described\n   inet6_option_next() function, except\
    \ this function lets the caller\n   specify the option type to be searched for,\
    \ instead of always\n   returning the next option in the ancillary data object.\
    \  cmsg is a\n   pointer to cmsghdr structure of which cmsg_level equals IPPROTO_IPV6\n\
    \   and cmsg_type equals either IPV6_HOPOPTS or IPV6_DSTOPTS.\n   tptrp is a pointer\
    \ to a pointer to an 8-bit byte and *tptrp is used\n   by the function to remember\
    \ its place in the ancillary data object\n   each time the function is called.\
    \  The first time this function is\n   called for a given ancillary data object,\
    \ *tptrp must be set to NULL.\n   This function starts searching for an option\
    \ of the specified type\n   beginning after the value of *tptrp.  If an option\
    \ of the specified\n   type is located, this function returns 0 and *tptrp points\
    \ to the 8-\n   bit option type field for the option of the specified type.  If\
    \ an\n   option of the specified type is not located, the return value is -1\n\
    \   and *tptrp is NULL.  If an error occurs, the return value is -1 and\n   *tptrp\
    \ is not NULL.\n"
- title: 6.3.7.  Options Examples
  contents:
  - "6.3.7.  Options Examples\n   We now provide an example that builds two Hop-by-Hop\
    \ options.  First\n   we define two options, called X and Y, taken from the example\
    \ in\n   Appendix A of [RFC-1883].  We assume that all options will have\n   structure\
    \ definitions similar to what is shown below.\n        /* option X and option\
    \ Y are defined in [RFC-1883], pp. 33-34 */\n"
- title: '#define IP6_X_OPT_TYPE       X   /* replace X with assigned value */'
  contents:
  - '#define IP6_X_OPT_TYPE       X   /* replace X with assigned value */

    '
- title: '#define IP6_X_OPT_LEN       12'
  contents:
  - '#define IP6_X_OPT_LEN       12

    '
- title: '#define IP6_X_OPT_MULTX      8   /* 8n + 2 alignment */'
  contents:
  - '#define IP6_X_OPT_MULTX      8   /* 8n + 2 alignment */

    '
- title: '#define IP6_X_OPT_OFFSETY    2'
  contents:
  - '#define IP6_X_OPT_OFFSETY    2

    '
- title: struct ip6_X_opt {
  contents:
  - "struct ip6_X_opt {\n  uint8_t   ip6_X_opt_pad[IP6_X_OPT_OFFSETY];\n  uint8_t\
    \   ip6_X_opt_type;\n  uint8_t   ip6_X_opt_len;\n  uint32_t  ip6_X_opt_val1;\n\
    \  uint64_t  ip6_X_opt_val2;\n"
- title: '};'
  contents:
  - '};

    '
- title: '#define IP6_Y_OPT_TYPE       Y   /* replace Y with assigned value */'
  contents:
  - '#define IP6_Y_OPT_TYPE       Y   /* replace Y with assigned value */

    '
- title: '#define IP6_Y_OPT_LEN        7'
  contents:
  - '#define IP6_Y_OPT_LEN        7

    '
- title: '#define IP6_Y_OPT_MULTX      4   /* 4n + 3 alignment */'
  contents:
  - '#define IP6_Y_OPT_MULTX      4   /* 4n + 3 alignment */

    '
- title: '#define IP6_Y_OPT_OFFSETY    3'
  contents:
  - '#define IP6_Y_OPT_OFFSETY    3

    '
- title: struct ip6_Y_opt {
  contents:
  - "struct ip6_Y_opt {\n  uint8_t   ip6_Y_opt_pad[IP6_Y_OPT_OFFSETY];\n  uint8_t\
    \   ip6_Y_opt_type;\n  uint8_t   ip6_Y_opt_len;\n  uint8_t   ip6_Y_opt_val1;\n\
    \  uint16_t  ip6_Y_opt_val2;\n  uint32_t  ip6_Y_opt_val3;\n"
- title: '};'
  contents:
  - "};\n   We now show the code fragment to build one ancillary data object\n   containing\
    \ both options.\n"
- title: struct msghdr  msg;
  contents:
  - 'struct msghdr  msg;

    '
- title: struct cmsghdr  *cmsgptr;
  contents:
  - 'struct cmsghdr  *cmsgptr;

    '
- title: struct ip6_X_opt  optX;
  contents:
  - 'struct ip6_X_opt  optX;

    '
- title: struct ip6_Y_opt  optY;
  contents:
  - 'struct ip6_Y_opt  optY;

    '
- title: msg.msg_control = malloc(inet6_option_space(sizeof(optX) +
  contents:
  - "msg.msg_control = malloc(inet6_option_space(sizeof(optX) +\n                \
    \                            sizeof(optY)));\n"
- title: inet6_option_init(msg.msg_control, &cmsgptr, IPV6_HOPOPTS);
  contents:
  - 'inet6_option_init(msg.msg_control, &cmsgptr, IPV6_HOPOPTS);

    '
- title: optX.ip6_X_opt_type = IP6_X_OPT_TYPE;
  contents:
  - 'optX.ip6_X_opt_type = IP6_X_OPT_TYPE;

    '
- title: optX.ip6_X_opt_len  = IP6_X_OPT_LEN;
  contents:
  - 'optX.ip6_X_opt_len  = IP6_X_OPT_LEN;

    '
- title: optX.ip6_X_opt_val1 = <32-bit value>;
  contents:
  - 'optX.ip6_X_opt_val1 = <32-bit value>;

    '
- title: optX.ip6_X_opt_val2 = <64-bit value>;
  contents:
  - 'optX.ip6_X_opt_val2 = <64-bit value>;

    '
- title: inet6_option_append(cmsgptr, &optX.ip6_X_opt_type,
  contents:
  - "inet6_option_append(cmsgptr, &optX.ip6_X_opt_type,\n                    IP6_X_OPT_MULTX,\
    \ IP6_X_OPT_OFFSETY);\n"
- title: optY.ip6_Y_opt_type = IP6_Y_OPT_TYPE;
  contents:
  - 'optY.ip6_Y_opt_type = IP6_Y_OPT_TYPE;

    '
- title: optY.ip6_Y_opt_len  = IP6_Y_OPT_LEN;
  contents:
  - 'optY.ip6_Y_opt_len  = IP6_Y_OPT_LEN;

    '
- title: optY.ip6_Y_opt_val1 = <8-bit value>;
  contents:
  - 'optY.ip6_Y_opt_val1 = <8-bit value>;

    '
- title: optY.ip6_Y_opt_val2 = <16-bit value>;
  contents:
  - 'optY.ip6_Y_opt_val2 = <16-bit value>;

    '
- title: optY.ip6_Y_opt_val3 = <32-bit value>;
  contents:
  - 'optY.ip6_Y_opt_val3 = <32-bit value>;

    '
- title: inet6_option_append(cmsgptr, &optY.ip6_Y_opt_type,
  contents:
  - "inet6_option_append(cmsgptr, &optY.ip6_Y_opt_type,\n                    IP6_Y_OPT_MULTX,\
    \ IP6_Y_OPT_OFFSETY);\n"
- title: msg.msg_controllen = cmsgptr->cmsg_len;
  contents:
  - "msg.msg_controllen = cmsgptr->cmsg_len;\n   The call to inet6_option_init() builds\
    \ the cmsghdr structure in the\n   control buffer.\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |       cmsg_len = CMSG_LEN(0) = 12                             |\n    \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     |  \
    \     cmsg_level = IPPROTO_IPV6                               |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |       cmsg_type = IPV6_HOPOPTS                                |\n    \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   Here we\
    \ assume a 32-bit architecture where sizeof(struct cmsghdr)\n   equals 12, with\
    \ a desired alignment of 4-byte boundaries (that is,\n   the ALIGN() macro shown\
    \ in the sample implementations of the\n   CMSG_xxx() macros rounds up to a multiple\
    \ of 4).\n   The first call to inet6_option_append() appends the X option.  Since\n\
    \   this is the first option in the ancillary data object, 2 bytes are\n   allocated\
    \ for the Next Header byte and for the Hdr Ext Len byte.  The\n   former will\
    \ be set by the kernel, depending on the type of header\n   that follows this\
    \ header, and the latter byte is set to 1.  These 2\n   bytes form the 2 bytes\
    \ of padding (IP6_X_OPT_OFFSETY) required at the\n   beginning of this option.\n\
    \     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n    \
    \ |       cmsg_len = 28                                           |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |       cmsg_level = IPPROTO_IPV6                               |\n    \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     |  \
    \     cmsg_type = IPV6_HOPOPTS                                |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |  Next Header  | Hdr Ext Len=1 | Option Type=X |Opt Data Len=12|\n    \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     |  \
    \                       4-octet field                         |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |                                                               |\n    \
    \ +                         8-octet field                         +\n     |  \
    \                                                             |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   The cmsg_len member of the cmsghdr structure is incremented by 16,\n   the\
    \ size of the option.\n   The next call to inet6_option_append() appends the Y\
    \ option to the\n   ancillary data object.\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |       cmsg_len = 44                                           |\n    \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     |  \
    \     cmsg_level = IPPROTO_IPV6                               |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |       cmsg_type = IPV6_HOPOPTS                                |\n    \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     |  Next\
    \ Header  | Hdr Ext Len=3 | Option Type=X |Opt Data Len=12|\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |                         4-octet field                         |\n    \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     |  \
    \                                                             |\n     +      \
    \                   8-octet field                         +\n     |          \
    \                                                     |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     | PadN Option=1 |Opt Data Len=1 |       0       | Option Type=Y |\n    \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     |Opt\
    \ Data Len=7 | 1-octet field |         2-octet field         |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |                         4-octet field                         |\n    \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     | PadN\
    \ Option=1 |Opt Data Len=2 |       0       |       0       |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   16 bytes are appended by this function, so cmsg_len becomes 44.  The\n   inet6_option_append()\
    \ function notices that the appended data\n   requires 4 bytes of padding at the\
    \ end, to make the size of the\n   ancillary data object a multiple of 8, and\
    \ appends the PadN option\n   before returning.  The Hdr Ext Len byte is incremented\
    \ by 2 to become\n   3.\n   Alternately, the application could build two ancillary\
    \ data objects,\n   one per option, although this will probably be less efficient\
    \ than\n   combining the two options into a single ancillary data object (as\n\
    \   just shown).  The kernel must combine these into a single Hop-by-Hop\n   extension\
    \ header in the final IPv6 packet.\n       struct msghdr  msg;\n       struct\
    \ cmsghdr  *cmsgptr;\n       struct ip6_X_opt  optX;\n       struct ip6_Y_opt\
    \  optY;\n       msg.msg_control = malloc(inet6_option_space(sizeof(optX)) +\n\
    \                                inet6_option_space(sizeof(optY)));\n       inet6_option_init(msg.msg_control,\
    \ &cmsgptr, IPPROTO_HOPOPTS);\n       optX.ip6_X_opt_type = IP6_X_OPT_TYPE;\n\
    \       optX.ip6_X_opt_len  = IP6_X_OPT_LEN;\n       optX.ip6_X_opt_val1 = <32-bit\
    \ value>;\n       optX.ip6_X_opt_val2 = <64-bit value>;\n       inet6_option_append(cmsgptr,\
    \ &optX.ip6_X_opt_type,\n                           IP6_X_OPT_MULTX, IP6_X_OPT_OFFSETY);\n\
    \       msg.msg_controllen = CMSG_SPACE(sizeof(optX));\n       inet6_option_init((u_char\
    \ *)msg.msg_control + msg.msg_controllen,\n                         &cmsgptr,\
    \ IPPROTO_HOPOPTS);\n       optY.ip6_Y_opt_type = IP6_Y_OPT_TYPE;\n       optY.ip6_Y_opt_len\
    \  = IP6_Y_OPT_LEN;\n       optY.ip6_Y_opt_val1 = <8-bit value>;\n       optY.ip6_Y_opt_val2\
    \ = <16-bit value>;\n       optY.ip6_Y_opt_val3 = <32-bit value>;\n       inet6_option_append(cmsgptr,\
    \ &optY.ip6_Y_opt_type,\n                           IP6_Y_OPT_MULTX, IP6_Y_OPT_OFFSETY);\n\
    \       msg.msg_controllen += cmsgptr->cmsg_len;\n   Each call to inet6_option_init()\
    \ builds a new cmsghdr structure, and\n   the final result looks like the following:\n\
    \     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n    \
    \ |       cmsg_len = 28                                           |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |       cmsg_level = IPPROTO_IPV6                               |\n    \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     |  \
    \     cmsg_type = IPV6_HOPOPTS                                |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |  Next Header  | Hdr Ext Len=1 | Option Type=X |Opt Data Len=12|\n    \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     |  \
    \                       4-octet field                         |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |                                                               |\n    \
    \ +                         8-octet field                         +\n     |  \
    \                                                             |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |       cmsg_len = 28                                           |\n    \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     |  \
    \     cmsg_level = IPPROTO_IPV6                               |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |       cmsg_type = IPV6_HOPOPTS                                |\n    \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     |  Next\
    \ Header  | Hdr Ext Len=1 | Pad1 Option=0 | Option Type=Y |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |Opt Data Len=7 | 1-octet field |         2-octet field         |\n    \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     |  \
    \                       4-octet field                         |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     | PadN Option=1 |Opt Data Len=2 |       0       |       0       |\n    \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   When the\
    \ kernel combines these two options into a single Hop-by-Hop\n   extension header,\
    \ the first 3 bytes of the second ancillary data\n   object (the Next Header byte,\
    \ the Hdr Ext Len byte, and the Pad1\n   option) will be combined into a PadN\
    \ option occupying 3 bytes.\n   The following code fragment is a redo of the first\
    \ example shown\n   (building two options in a single ancillary data object) but\
    \ this\n   time we use inet6_option_alloc().\n"
- title: uint8_t  *typep;
  contents:
  - 'uint8_t  *typep;

    '
- title: struct msghdr  msg;
  contents:
  - 'struct msghdr  msg;

    '
- title: struct cmsghdr  *cmsgptr;
  contents:
  - 'struct cmsghdr  *cmsgptr;

    '
- title: struct ip6_X_opt  *optXp;  /* now a pointer, not a struct */
  contents:
  - 'struct ip6_X_opt  *optXp;  /* now a pointer, not a struct */

    '
- title: struct ip6_Y_opt  *optYp;  /* now a pointer, not a struct */
  contents:
  - 'struct ip6_Y_opt  *optYp;  /* now a pointer, not a struct */

    '
- title: msg.msg_control = malloc(inet6_option_space(sizeof(*optXp) +
  contents:
  - "msg.msg_control = malloc(inet6_option_space(sizeof(*optXp) +\n              \
    \                              sizeof(*optYp)));\n"
- title: inet6_option_init(msg.msg_control, &cmsgptr, IPV6_HOPOPTS);
  contents:
  - 'inet6_option_init(msg.msg_control, &cmsgptr, IPV6_HOPOPTS);

    '
- title: typep = inet6_option_alloc(cmsgptr, IP6_X_OPT_LEN,
  contents:
  - "typep = inet6_option_alloc(cmsgptr, IP6_X_OPT_LEN,\n                        \
    \   IP6_X_OPT_MULTX, IP6_X_OPT_OFFSETY);\n"
- title: optXp = (struct ip6_X_opt *) (typep - IP6_X_OPT_OFFSETY);
  contents:
  - 'optXp = (struct ip6_X_opt *) (typep - IP6_X_OPT_OFFSETY);

    '
- title: optXp->ip6_X_opt_type = IP6_X_OPT_TYPE;
  contents:
  - 'optXp->ip6_X_opt_type = IP6_X_OPT_TYPE;

    '
- title: optXp->ip6_X_opt_len  = IP6_X_OPT_LEN;
  contents:
  - 'optXp->ip6_X_opt_len  = IP6_X_OPT_LEN;

    '
- title: optXp->ip6_X_opt_val1 = <32-bit value>;
  contents:
  - 'optXp->ip6_X_opt_val1 = <32-bit value>;

    '
- title: optXp->ip6_X_opt_val2 = <64-bit value>;
  contents:
  - 'optXp->ip6_X_opt_val2 = <64-bit value>;

    '
- title: typep = inet6_option_alloc(cmsgptr, IP6_Y_OPT_LEN,
  contents:
  - "typep = inet6_option_alloc(cmsgptr, IP6_Y_OPT_LEN,\n                        \
    \   IP6_Y_OPT_MULTX, IP6_Y_OPT_OFFSETY);\n"
- title: optYp = (struct ip6_Y_opt *) (typep - IP6_Y_OPT_OFFSETY);
  contents:
  - 'optYp = (struct ip6_Y_opt *) (typep - IP6_Y_OPT_OFFSETY);

    '
- title: optYp->ip6_Y_opt_type = IP6_Y_OPT_TYPE;
  contents:
  - 'optYp->ip6_Y_opt_type = IP6_Y_OPT_TYPE;

    '
- title: optYp->ip6_Y_opt_len  = IP6_Y_OPT_LEN;
  contents:
  - 'optYp->ip6_Y_opt_len  = IP6_Y_OPT_LEN;

    '
- title: optYp->ip6_Y_opt_val1 = <8-bit value>;
  contents:
  - 'optYp->ip6_Y_opt_val1 = <8-bit value>;

    '
- title: optYp->ip6_Y_opt_val2 = <16-bit value>;
  contents:
  - 'optYp->ip6_Y_opt_val2 = <16-bit value>;

    '
- title: optYp->ip6_Y_opt_val3 = <32-bit value>;
  contents:
  - 'optYp->ip6_Y_opt_val3 = <32-bit value>;

    '
- title: msg.msg_controllen = cmsgptr->cmsg_len;
  contents:
  - "msg.msg_controllen = cmsgptr->cmsg_len;\n   Notice that inet6_option_alloc()\
    \ returns a pointer to the 8-bit\n   option type field.  If the program wants\
    \ a pointer to an option\n   structure that includes the padding at the front\
    \ (as shown in our\n   definitions of the ip6_X_opt and ip6_Y_opt structures),\
    \ the y-offset\n   at the beginning of the structure must be subtracted from the\n\
    \   returned pointer.\n   The following code fragment shows the processing of\
    \ Hop-by-Hop\n   options using the inet6_option_next() function.\n    struct msghdr\
    \   msg;\n    struct cmsghdr  *cmsgptr;\n    /* fill in msg */\n    /* call recvmsg()\
    \ */\n    for (cmsgptr = CMSG_FIRSTHDR(&msg); cmsgptr != NULL;\n         cmsgptr\
    \ = CMSG_NXTHDR(&msg, cmsgptr)) {\n        if (cmsgptr->cmsg_level == IPPROTO_IPV6\
    \ &&\n            cmsgptr->cmsg_type == IPV6_HOPOPTS) {\n            uint8_t \
    \ *tptr = NULL;\n            while (inet6_option_next(cmsgptr, &tptr) == 0) {\n\
    \                if (*tptr == IP6_X_OPT_TYPE) {\n                    struct ip6_X_opt\
    \  *optXp;\n                    optXp = (struct ip6_X_opt *) (tptr - IP6_X_OPT_OFFSETY);\n\
    \                    <do whatever with> optXp->ip6_X_opt_val1;\n             \
    \       <do whatever with> optXp->ip6_X_opt_val2;\n                } else if (*tptr\
    \ == IP6_Y_OPT_TYPE) {\n                    struct ip6_Y_opt  *optYp;\n      \
    \              optYp = (struct ip6_Y_opt *) (tptr - IP6_Y_OPT_OFFSETY);\n    \
    \                <do whatever with> optYp->ip6_Y_opt_val1;\n                 \
    \   <do whatever with> optYp->ip6_Y_opt_val2;\n                    <do whatever\
    \ with> optYp->ip6_Y_opt_val3;\n                }\n            }\n           \
    \ if (tptr != NULL)\n                <error encountered by inet6_option_next()>;\n\
    \        }\n    }\n"
- title: 7.  Destination Options
  contents:
  - "7.  Destination Options\n   A variable number of Destination options can appear\
    \ in one or more\n   Destination option headers.  As defined in [RFC-1883], a\
    \ Destination\n   options header appearing before a Routing header is processed\
    \ by the\n   first destination plus any subsequent destinations specified in the\n\
    \   Routing header, while a Destination options header appearing after a\n   Routing\
    \ header is processed only by the final destination.  As with\n   the Hop-by-Hop\
    \ options, each option in a Destination options header\n   is TLV-encoded with\
    \ a type, length, and value.\n   Today no Destination options are defined for\
    \ IPv6 [RFC-1883],\n   although proposals exist to use Destination options with\
    \ mobility and\n   anycasting.\n"
- title: 7.1.  Receiving Destination Options
  contents:
  - "7.1.  Receiving Destination Options\n   To receive Destination options the application\
    \ must enable the\n   IPV6_DSTOPTS socket option:\n       int  on = 1;\n     \
    \  setsockopt(fd, IPPROTO_IPV6, IPV6_DSTOPTS, &on, sizeof(on));\n   All the Destination\
    \ options appearing before a Routing header are\n   returned as one ancillary\
    \ data object described by a cmsghdr\n   structure and all the Destination options\
    \ appearing after a Routing\n   header are returned as another ancillary data\
    \ object described by a\n   cmsghdr structure.  For these ancillary data objects,\
    \ the cmsg_level\n   member will be IPPROTO_IPV6 and the cmsg_type member will\
    \ be\n   IPV6_HOPOPTS.  These options are then processed by calling the\n   inet6_option_next()\
    \ and inet6_option_find() functions.\n"
- title: 7.2.  Sending Destination Options
  contents:
  - "7.2.  Sending Destination Options\n   To send one or more Destination options,\
    \ the application just\n   specifies them as ancillary data in a call to sendmsg().\
    \  No socket\n   option need be set.\n   As described earlier, one set of Destination\
    \ options can appear\n   before a Routing header, and one set can appear after\
    \ a Routing\n   header.  Each set can consist of one or more options.\n   Normally\
    \ all the Destination options in a set are specified by a\n   single ancillary\
    \ data object, since each option is itself TLV-\n   encoded.  Multiple ancillary\
    \ data objects, each containing one or\n   more Destination options, can also\
    \ be specified, in which case the\n   kernel will combine all the Destination\
    \ options in the set into a\n   single Destination extension header.  But it should\
    \ be more efficient\n   to use a single ancillary data object to describe all\
    \ the Destination\n   options in a set.  The cmsg_level member is set to IPPROTO_IPV6\
    \ and\n   the cmsg_type member is set to IPV6_DSTOPTS.  The option is normally\n\
    \   constructed using the inet6_option_init(), inet6_option_append(), and\n  \
    \ inet6_option_alloc() functions.\n   Additional errors may be possible from sendmsg()\
    \ if the specified\n   option is in error.\n"
- title: 8.  Routing Header Option
  contents:
  - "8.  Routing Header Option\n   Source routing in IPv6 is accomplished by specifying\
    \ a Routing header\n   as an extension header.  There can be different types of\
    \ Routing\n   headers, but IPv6 currently defines only the Type 0 Routing header\n\
    \   [RFC-1883].  This type supports up to 23 intermediate nodes.  With\n   this\
    \ maximum number of intermediate nodes, a source, and a\n   destination, there\
    \ are 24 hops, each of which is defined as a strict\n   or loose hop.\n   Source\
    \ routing with IPv4 sockets API (the IP_OPTIONS socket option)\n   requires the\
    \ application to build the source route in the format that\n   appears as the\
    \ IPv4 header option, requiring intimate knowledge of\n   the IPv4 options format.\
    \  This IPv6 API, however, defines eight\n   functions that the application calls\
    \ to build and examine a Routing\n   header.  Four functions build a Routing header:\n\
    \   inet6_rthdr_space()    - return #bytes required for ancillary data\n   inet6_rthdr_init()\
    \     - initialize ancillary data for Routing header\n   inet6_rthdr_add()   \
    \   - add IPv6 address & flags to Routing header\n   inet6_rthdr_lasthop()  -\
    \ specify the flags for the final hop\n   Four functions deal with a returned\
    \ Routing header:\n    inet6_rthdr_reverse()  - reverse a Routing header\n   \
    \ inet6_rthdr_segments() - return #segments in a Routing header\n    inet6_rthdr_getaddr()\
    \  - fetch one address from a Routing header\n    inet6_rthdr_getflags() - fetch\
    \ one flag from a Routing header\n   The function prototypes for these functions\
    \ are all in the\n   <netinet/in.h> header.\n   To receive a Routing header the\
    \ application must enable the\n   IPV6_RTHDR socket option:\n       int  on =\
    \ 1;\n       setsockopt(fd, IPPROTO_IPV6, IPV6_RTHDR, &on, sizeof(on));\n   To\
    \ send a Routing header the application just specifies it as\n   ancillary data\
    \ in a call to sendmsg().\n   A Routing header is passed between the application\
    \ and the kernel as\n   an ancillary data object.  The cmsg_level member has a\
    \ value of\n   IPPROTO_IPV6 and the cmsg_type member has a value of IPV6_RTHDR.\
    \  The\n   contents of the cmsg_data[] member is implementation dependent and\n\
    \   should not be accessed directly by the application, but should be\n   accessed\
    \ using the eight functions that we are about to describe.\n   The following constants\
    \ are defined in the <netinet/in.h> header:\n    #define IPV6_RTHDR_LOOSE    \
    \ 0 /* this hop need not be a neighbor */\n    #define IPV6_RTHDR_STRICT    1\
    \ /* this hop must be a neighbor */\n    #define IPV6_RTHDR_TYPE_0    0 /* IPv6\
    \ Routing header type 0 */\n   When a Routing header is specified, the destination\
    \ address specified\n   for connect(), sendto(), or sendmsg() is the final destination\n\
    \   address of the datagram.  The Routing header then contains the\n   addresses\
    \ of all the intermediate nodes.\n"
- title: 8.1.  inet6_rthdr_space
  contents:
  - "8.1.  inet6_rthdr_space\n       size_t inet6_rthdr_space(int type, int segments);\n\
    \   This function returns the number of bytes required to hold a Routing\n   header\
    \ of the specified type containing the specified number of\n   segments (addresses).\
    \  For an IPv6 Type 0 Routing header, the number\n   of segments must be between\
    \ 1 and 23, inclusive.  The return value\n   includes the size of the cmsghdr\
    \ structure that precedes the Routing\n   header, and any required padding.\n\
    \   If the return value is 0, then either the type of the Routing header\n   is\
    \ not supported by this implementation or the number of segments is\n   invalid\
    \ for this type of Routing header.\n   (Note: This function returns the size but\
    \ does not allocate the space\n   required for the ancillary data.  This allows\
    \ an application to\n   allocate a larger buffer, if other ancillary data objects\
    \ are\n   desired, since all the ancillary data objects must be specified to\n\
    \   sendmsg() as a single msg_control buffer.)\n"
- title: 8.2.  inet6_rthdr_init
  contents:
  - "8.2.  inet6_rthdr_init\n       struct cmsghdr *inet6_rthdr_init(void *bp, int\
    \ type);\n   This function initializes the buffer pointed to by bp to contain\
    \ a\n   cmsghdr structure followed by a Routing header of the specified type.\n\
    \   The cmsg_len member of the cmsghdr structure is initialized to the\n   size\
    \ of the structure plus the amount of space required by the\n   Routing header.\
    \  The cmsg_level and cmsg_type members are also\n   initialized as required.\n\
    \   The caller must allocate the buffer and its size can be determined by\n  \
    \ calling inet6_rthdr_space().\n   Upon success the return value is the pointer\
    \ to the cmsghdr\n   structure, and this is then used as the first argument to\
    \ the next\n   two functions.  Upon an error the return value is NULL.\n"
- title: 8.3.  inet6_rthdr_add
  contents:
  - "8.3.  inet6_rthdr_add\n    int inet6_rthdr_add(struct cmsghdr *cmsg,\n      \
    \                  const struct in6_addr *addr, unsigned int flags);\n   This\
    \ function adds the address pointed to by addr to the end of the\n   Routing header\
    \ being constructed and sets the type of this hop to the\n   value of flags. \
    \ For an IPv6 Type 0 Routing header, flags must be\n   either IPV6_RTHDR_LOOSE\
    \ or IPV6_RTHDR_STRICT.\n   If successful, the cmsg_len member of the cmsghdr\
    \ structure is\n   updated to account for the new address in the Routing header\
    \ and the\n   return value of the function is 0.  Upon an error the return value\
    \ of\n   the function is -1.\n"
- title: 8.4.  inet6_rthdr_lasthop
  contents:
  - "8.4.  inet6_rthdr_lasthop\n       int inet6_rthdr_lasthop(struct cmsghdr *cmsg,\n\
    \                               unsigned int flags);\n   This function specifies\
    \ the Strict/Loose flag for the final hop of a\n   Routing header.  For an IPv6\
    \ Type 0 Routing header, flags must be\n   either IPV6_RTHDR_LOOSE or IPV6_RTHDR_STRICT.\n\
    \   The return value of the function is 0 upon success, or -1 upon an\n   error.\n\
    \   Notice that a Routing header specifying N intermediate nodes requires\n  \
    \ N+1 Strict/Loose flags.  This requires N calls to inet6_rthdr_add()\n   followed\
    \ by one call to inet6_rthdr_lasthop().\n"
- title: 8.5.  inet6_rthdr_reverse
  contents:
  - "8.5.  inet6_rthdr_reverse\n    int inet6_rthdr_reverse(const struct cmsghdr *in,\
    \ struct cmsghdr *out);\n   This function takes a Routing header that was received\
    \ as ancillary\n   data (pointed to by the first argument) and writes a new Routing\n\
    \   header that sends datagrams along the reverse of that route.  Both\n   arguments\
    \ are allowed to point to the same buffer (that is, the\n   reversal can occur\
    \ in place).\n   The return value of the function is 0 on success, or -1 upon\
    \ an\n   error.\n"
- title: 8.6.  inet6_rthdr_segments
  contents:
  - "8.6.  inet6_rthdr_segments\n       int inet6_rthdr_segments(const struct cmsghdr\
    \ *cmsg);\n   This function returns the number of segments (addresses) contained\
    \ in\n   the Routing header described by cmsg.  On success the return value is\n\
    \   between 1 and 23, inclusive.  The return value of the function is -1\n   upon\
    \ an error.\n"
- title: 8.7.  inet6_rthdr_getaddr
  contents:
  - "8.7.  inet6_rthdr_getaddr\n    struct in6_addr *inet6_rthdr_getaddr(struct cmsghdr\
    \ *cmsg, int\n    index);\n   This function returns a pointer to the IPv6 address\
    \ specified by\n   index (which must have a value between 1 and the value returned\
    \ by\n   inet6_rthdr_segments()) in the Routing header described by cmsg.  An\n\
    \   application should first call inet6_rthdr_segments() to obtain the\n   number\
    \ of segments in the Routing header.\n   Upon an error the return value of the\
    \ function is NULL.\n"
- title: 8.8.  inet6_rthdr_getflags
  contents:
  - "8.8.  inet6_rthdr_getflags\n       int inet6_rthdr_getflags(const struct cmsghdr\
    \ *cmsg, int index);\n   This function returns the flags value specified by index\
    \ (which must\n   have a value between 0 and the value returned by\n   inet6_rthdr_segments())\
    \ in the Routing header described by cmsg.  For\n   an IPv6 Type 0 Routing header\
    \ the return value will be either\n   IPV6_RTHDR_LOOSE or IPV6_RTHDR_STRICT.\n\
    \   Upon an error the return value of the function is -1.\n   (Note: Addresses\
    \ are indexed starting at 1, and flags starting at 0,\n   to maintain consistency\
    \ with the terminology and figures in [RFC-\n   1883].)\n"
- title: 8.9.  Routing Header Example
  contents:
  - "8.9.  Routing Header Example\n   As an example of these Routing header functions,\
    \ we go through the\n   function calls for the example on p. 18 of [RFC-1883].\
    \  The source is\n   S, the destination is D, and the three intermediate nodes\
    \ are I1, I2,\n   and I3.  f0, f1, f2, and f3 are the Strict/Loose flags for each\
    \ hop.\n                   f0        f1        f2        f3\n               S\
    \ -----> I1 -----> I2 -----> I3 -----> D\n       src:    *    S         S    \
    \     S         S   S\n       dst:    D   I1        I2        I3         D   D\n\
    \       A[1]:  I1   I2        I1        I1        I1  I1\n       A[2]:  I2   I3\
    \        I3        I2        I2  I2\n       A[3]:  I3    D         D         D\
    \        I3  I3\n       #seg:   3    3         2         1         0   3\n   \
    \    check: f0        f1        f2        f3\n   src and dst are the source and\
    \ destination IPv6 addresses in the IPv6\n   header.  A[1], A[2], and A[3] are\
    \ the three addresses in the Routing\n   header.  #seg is the Segments Left field\
    \ in the Routing header.\n   check indicates which bit of the Strict/Loose Bit\
    \ Map (0 through 3,\n   specified as f0 through f3) that node checks.\n   The\
    \ six values in the column beneath node S are the values in the\n   Routing header\
    \ specified by the application using sendmsg().  The\n   function calls by the\
    \ sender would look like:\n       void  *ptr;\n       struct msghdr  msg;\n  \
    \     struct cmsghdr  *cmsgptr;\n       struct sockaddr_in6  I1, I2, I3, D;\n\
    \       unsigned int  f0, f1, f2, f3;\n       ptr = malloc(inet6_rthdr_space(IPV6_RTHDR_TYPE_0,\
    \ 3));\n       cmsgptr = inet6_rthdr_init(ptr, IPV6_RTHDR_TYPE_0);\n       inet6_rthdr_add(cmsgptr,\
    \ &I1.sin6_addr, f0);\n       inet6_rthdr_add(cmsgptr, &I2.sin6_addr, f1);\n \
    \      inet6_rthdr_add(cmsgptr, &I3.sin6_addr, f2);\n       inet6_rthdr_lasthop(cmsgptr,\
    \ f3);\n       msg.msg_control = ptr;\n       msg.msg_controllen = cmsgptr->cmsg_len;\n\
    \       /* finish filling in msg{}, msg_name = D */\n       /* call sendmsg()\
    \ */\n   We also assume that the source address for the socket is not\n   specified\
    \ (i.e., the asterisk in the figure).\n   The four columns of six values that\
    \ are then shown between the five\n   nodes are the values of the fields in the\
    \ packet while the packet is\n   in transit between the two nodes.  Notice that\
    \ before the packet is\n   sent by the source node S, the source address is chosen\
    \ (replacing\n   the asterisk), I1 becomes the destination address of the datagram,\n\
    \   the two addresses A[2] and A[3] are \"shifted up\", and D is moved to\n  \
    \ A[3].  If f0 is IPV6_RTHDR_STRICT, then I1 must be a neighbor of S.\n   The\
    \ columns of values that are shown beneath the destination node are\n   the values\
    \ returned by recvmsg(), assuming the application has\n   enabled both the IPV6_PKTINFO\
    \ and IPV6_RTHDR socket options.  The\n   source address is S (contained in the\
    \ sockaddr_in6 structure pointed\n   to by the msg_name member), the destination\
    \ address is D (returned as\n   an ancillary data object in an in6_pktinfo structure),\
    \ and the\n   ancillary data object specifying the Routing header will contain\n\
    \   three addresses (I1, I2, and I3) and four flags (f0, f1, f2, and f3).\n  \
    \ The number of segments in the Routing header is known from the Hdr\n   Ext Len\
    \ field in the Routing header (a value of 6, indicating 3\n   addresses).\n  \
    \ The return value from inet6_rthdr_segments() will be 3 and\n   inet6_rthdr_getaddr(1)\
    \ will return I1, inet6_rthdr_getaddr(2) will\n   return I2, and inet6_rthdr_getaddr(3)\
    \ will return I3, The return\n   value from inet6_rthdr_flags(0) will be f0, inet6_rthdr_flags(1)\
    \ will\n   return f1, inet6_rthdr_flags(2) will return f2, and\n   inet6_rthdr_flags(3)\
    \ will return f3.\n   If the receiving application then calls inet6_rthdr_reverse(),\
    \ the\n   order of the three addresses will become I3, I2, and I1, and the\n \
    \  order of the four Strict/Loose flags will become f3, f2, f1, and f0.\n   We\
    \ can also show what an implementation might store in the ancillary\n   data object\
    \ as the Routing header is being built by the sending\n   process.  If we assume\
    \ a 32-bit architecture where sizeof(struct\n   cmsghdr) equals 12, with a desired\
    \ alignment of 4-byte boundaries,\n   then the call to inet6_rthdr_space(3) returns\
    \ 68: 12 bytes for the\n   cmsghdr structure and 56 bytes for the Routing header\
    \ (8 + 3*16).\n   The call to inet6_rthdr_init() initializes the ancillary data\
    \ object\n   to contain a Type 0 Routing header:\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |       cmsg_len = 20                                           |\n    \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     |  \
    \     cmsg_level = IPPROTO_IPV6                               |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |       cmsg_type = IPV6_RTHDR                                  |\n    \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     |  Next\
    \ Header  | Hdr Ext Len=0 | Routing Type=0|  Seg Left=0   |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |   Reserved    |             Strict/Loose Bit Map              |\n    \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   The first\
    \ call to inet6_rthdr_add() adds I1 to the list.\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |       cmsg_len = 36                                           |\n    \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     |  \
    \     cmsg_level = IPPROTO_IPV6                               |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |       cmsg_type = IPV6_RTHDR                                  |\n    \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     |  Next\
    \ Header  | Hdr Ext Len=2 | Routing Type=0|  Seg Left=1   |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |   Reserved    |X|           Strict/Loose Bit Map              |\n    \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     |  \
    \                                                             |\n     +      \
    \                                                         +\n     |          \
    \                                                     |\n     +              \
    \             Address[1] = I1                     +\n     |                  \
    \                                             |\n     +                      \
    \                                         +\n     |                          \
    \                                     |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   Bit 0 of the Strict/Loose Bit Map contains the value f0, which we\n   just\
    \ mark as X.  cmsg_len is incremented by 16, the Hdr Ext Len field\n   is incremented\
    \ by 2, and the Segments Left field is incremented by 1.\n   The next call to\
    \ inet6_rthdr_add() adds I2 to the list.\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |       cmsg_len = 52                                           |\n    \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     |  \
    \     cmsg_level = IPPROTO_IPV6                               |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |       cmsg_type = IPV6_RTHDR                                  |\n    \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     |  Next\
    \ Header  | Hdr Ext Len=4 | Routing Type=0|  Seg Left=2   |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |   Reserved    |X|X|         Strict/Loose Bit Map              |\n    \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     |  \
    \                                                             |\n     +      \
    \                                                         +\n     |          \
    \                                                     |\n     +              \
    \             Address[1] = I1                     +\n     |                  \
    \                                             |\n     +                      \
    \                                         +\n     |                          \
    \                                     |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |                                                               |\n    \
    \ +                                                               +\n     |  \
    \                                                             |\n     +      \
    \                     Address[2] = I2                     +\n     |          \
    \                                                     |\n     +              \
    \                                                 +\n     |                  \
    \                                             |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   The next bit of the Strict/Loose Bit Map contains the value f1.\n   cmsg_len\
    \ is incremented by 16, the Hdr Ext Len field is incremented\n   by 2, and the\
    \ Segments Left field is incremented by 1.\n   The last call to inet6_rthdr_add()\
    \ adds I3 to the list.\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |       cmsg_len = 68                                           |\n    \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     |  \
    \     cmsg_level = IPPROTO_IPV6                               |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |       cmsg_type = IPV6_RTHDR                                  |\n    \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     |  Next\
    \ Header  | Hdr Ext Len=6 | Routing Type=0|  Seg Left=3   |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |   Reserved    |X|X|X|       Strict/Loose Bit Map              |\n    \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     |  \
    \                                                             |\n     +      \
    \                                                         +\n     |          \
    \                                                     |\n     +              \
    \             Address[1] = I1                     +\n     |                  \
    \                                             |\n     +                      \
    \                                         +\n     |                          \
    \                                     |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |                                                               |\n    \
    \ +                                                               +\n     |  \
    \                                                             |\n     +      \
    \                     Address[2] = I2                     +\n     |          \
    \                                                     |\n     +              \
    \                                                 +\n     |                  \
    \                                             |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |                                                               |\n    \
    \ +                                                               +\n     |  \
    \                                                             |\n     +      \
    \                     Address[3] = I3                     +\n     |          \
    \                                                     |\n     +              \
    \                                                 +\n     |                  \
    \                                             |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   The next bit of the Strict/Loose Bit Map contains the value f2.\n   cmsg_len\
    \ is incremented by 16, the Hdr Ext Len field is incremented\n   by 2, and the\
    \ Segments Left field is incremented by 1.\n   Finally, the call to inet6_rthdr_lasthop()\
    \ sets the next bit of the\n   Strict/Loose Bit Map to the value specified by\
    \ f3.  All the lengths\n   remain unchanged.\n"
- title: 9.  Ordering of Ancillary Data and IPv6 Extension Headers
  contents:
  - "9.  Ordering of Ancillary Data and IPv6 Extension Headers\n   Three IPv6 extension\
    \ headers can be specified by the application and\n   returned to the application\
    \ using ancillary data with sendmsg() and\n   recvmsg(): Hop-by-Hop options, Destination\
    \ options, and the Routing\n   header.  When multiple ancillary data objects are\
    \ transferred via\n   sendmsg() or recvmsg() and these objects represent any of\
    \ these three\n   extension headers, their placement in the control buffer is\
    \ directly\n   tied to their location in the corresponding IPv6 datagram.  This\
    \ API\n   imposes some ordering constraints when using multiple ancillary data\n\
    \   objects with sendmsg().\n   When multiple IPv6 Hop-by-Hop options having the\
    \ same option type are\n   specified, these options will be inserted into the\
    \ Hop-by-Hop options\n   header in the same order as they appear in the control\
    \ buffer.  But\n   when multiple Hop-by-Hop options having different option types\
    \ are\n   specified, these options may be reordered by the kernel to reduce\n\
    \   padding in the Hop-by-Hop options header.  Hop-by-Hop options may\n   appear\
    \ anywhere in the control buffer and will always be collected by\n   the kernel\
    \ and placed into a single Hop-by-Hop options header that\n   immediately follows\
    \ the IPv6 header.\n   Similar rules apply to the Destination options: (1) those\
    \ of the same\n   type will appear in the same order as they are specified, and\
    \ (2)\n   those of differing types may be reordered.  But the kernel will build\n\
    \   up to two Destination options headers: one to precede the Routing\n   header\
    \ and one to follow the Routing header.  If the application\n   specifies a Routing\
    \ header then all Destination options that appear\n   in the control buffer before\
    \ the Routing header will appear in a\n   Destination options header before the\
    \ Routing header and these\n   options might be reordered, subject to the two\
    \ rules that we just\n   stated.  Similarly all Destination options that appear\
    \ in the control\n   buffer after the Routing header will appear in a Destination\
    \ options\n   header after the Routing header, and these options might be\n  \
    \ reordered, subject to the two rules that we just stated.\n   As an example,\
    \ assume that an application specifies control\n   information to sendmsg() containing\
    \ six ancillary data objects: the\n   first containing two Hop-by-Hop options,\
    \ the second containing one\n   Destination option, the third containing two Destination\
    \ options, the\n   fourth containing a Routing header, the fifth containing a\
    \ Hop-by-Hop\n   option, and the sixth containing two Destination options.  We\
    \ also\n   assume that all the Hop-by-Hop options are of different types, as are\n\
    \   all the Destination options.  We number these options 1-9,\n   corresponding\
    \ to their order in the control buffer, and show them on\n   the left below.\n\
    \   In the middle we show the final arrangement of the options in the\n   extension\
    \ headers built by the kernel.  On the right we show the four\n   ancillary data\
    \ objects returned to the receiving application.\n          Sender's         \
    \                              Receiver's\n       Ancillary Data      -->   IPv6\
    \ Extension   -->  Ancillary Data\n          Objects                    Headers\
    \              Objects\n       ------------------        ---------------     \
    \  --------------\n       HOPOPT-1,2 (first)        HOPHDR(J,7,1,2)       HOPOPT-7,1,2\n\
    \       DSTOPT-3                  DSTHDR(4,5,3)         DSTOPT-4,5,3\n       DSTOPT-4,5\
    \                RTHDR(6)              RTHDR-6\n       RTHDR-6               \
    \    DSTHDR(8,9)           DSTOPT-8,9\n       HOPOPT-7\n       DSTOPT-8,9 (last)\n\
    \   The sender's two Hop-by-Hop ancillary data objects are reordered, as\n   are\
    \ the first two Destination ancillary data objects.  We also show a\n   Jumbo\
    \ Payload option (denoted as J) inserted by the kernel before the\n   sender's\
    \ three Hop-by-Hop options.  The first three Destination\n   options must appear\
    \ in a Destination header before the Routing\n   header, and the final two Destination\
    \ options must appear in a\n   Destination header after the Routing header.\n\
    \   If Destination options are specified in the control buffer after a\n   Routing\
    \ header, or if Destination options are specified without a\n   Routing header,\
    \ the kernel will place those Destination options after\n   an authentication\
    \ header and/or an encapsulating security payload\n   header, if present.\n"
- title: 10.  IPv6-Specific Options with IPv4-Mapped IPv6 Addresses
  contents:
  - "10.  IPv6-Specific Options with IPv4-Mapped IPv6 Addresses\n   The various socket\
    \ options and ancillary data specifications defined\n   in this document apply\
    \ only to true IPv6 sockets.  It is possible to\n   create an IPv6 socket that\
    \ actually sends and receives IPv4 packets,\n   using IPv4-mapped IPv6 addresses,\
    \ but the mapping of the options\n   defined in this document to an IPv4 datagram\
    \ is beyond the scope of\n   this document.\n   In general, attempting to specify\
    \ an IPv6-only option, such as the\n   Hop-by-Hop options, Destination options,\
    \ or Routing header on an IPv6\n   socket that is using IPv4-mapped IPv6 addresses,\
    \ will probably result\n   in an error.  Some implementations, however, may provide\
    \ access to\n   the packet information (source/destination address, send/receive\n\
    \   interface, and hop limit) on an IPv6 socket that is using IPv4-mapped\n  \
    \ IPv6 addresses.\n"
- title: 11.  rresvport_af
  contents:
  - "11.  rresvport_af\n   The rresvport() function is used by the rcmd() function,\
    \ and this\n   function is in turn called by many of the \"r\" commands such as\n\
    \   rlogin.  While new applications are not being written to use the\n   rcmd()\
    \ function, legacy applications such as rlogin will continue to\n   use it and\
    \ these will be ported to IPv6.\n   rresvport() creates an IPv4/TCP socket and\
    \ binds a \"reserved port\" to\n   the socket.  Instead of defining an IPv6 version\
    \ of this function we\n   define a new function that takes an address family as\
    \ its argument.\n       #include <unistd.h>\n       int  rresvport_af(int *port,\
    \ int family);\n   This function behaves the same as the existing rresvport()\
    \ function,\n   but instead of creating an IPv4/TCP socket, it can also create\
    \ an\n   IPv6/TCP socket.  The family argument is either AF_INET or AF_INET6,\n\
    \   and a new error return is EAFNOSUPPORT if the address family is not\n   supported.\n\
    \   (Note: There is little consensus on which header defines the\n   rresvport()\
    \ and rcmd() function prototypes.  4.4BSD defines it in\n   <unistd.h>, others\
    \ in <netdb.h>, and others don't define the function\n   prototypes at all.)\n\
    \   (Note: We define this function only, and do not define something like\n  \
    \ rcmd_af() or rcmd6().  The reason is that rcmd() calls\n   gethostbyname(),\
    \ which returns the type of address: AF_INET or\n   AF_INET6.  It should therefore\
    \ be possible to modify rcmd() to\n   support either IPv4 or IPv6, based on the\
    \ address family returned by\n   gethostbyname().)\n"
- title: 12.  Future Items
  contents:
  - "12.  Future Items\n   Some additional items may require standardization, but\
    \ no concrete\n   proposals have been made for the API to perform these tasks.\
    \  These\n   may be addressed in a later document.\n"
- title: 12.1.  Flow Labels
  contents:
  - "12.1.  Flow Labels\n   Earlier revisions of this document specified a set of\n\
    \   inet6_flow_XXX() functions to assign, share, and free IPv6 flow\n   labels.\
    \  Consensus, however, indicated that it was premature to\n   specify this part\
    \ of the API.\n"
- title: 12.2.  Path MTU Discovery and UDP
  contents:
  - "12.2.  Path MTU Discovery and UDP\n   A standard method may be desirable for\
    \ a UDP application to determine\n   the \"maximum send transport-message size\"\
    \ (Section 5.1 of [RFC-1981])\n   to a given destination.  This would let the\
    \ UDP application send\n   smaller datagrams to the destination, avoiding fragmentation.\n"
- title: 12.3.  Neighbor Reachability and UDP
  contents:
  - "12.3.  Neighbor Reachability and UDP\n   A standard method may be desirable for\
    \ a UDP application to tell the\n   kernel that it is making forward progress\
    \ with a given peer (Section\n   7.3.1 of [RFC-1970]).  This could save unneeded\
    \ neighbor\n   solicitations and neighbor advertisements.\n"
- title: 13.  Summary of New Definitions
  contents:
  - "13.  Summary of New Definitions\n   The following list summarizes the constants\
    \ and structure,\n   definitions discussed in this memo, sorted by header.\n \
    \    <netinet/icmp6.h> ICMP6_DST_UNREACH\n     <netinet/icmp6.h> ICMP6_DST_UNREACH_ADDR\n\
    \     <netinet/icmp6.h> ICMP6_DST_UNREACH_ADMIN\n     <netinet/icmp6.h> ICMP6_DST_UNREACH_NOPORT\n\
    \     <netinet/icmp6.h> ICMP6_DST_UNREACH_NOROUTE\n     <netinet/icmp6.h> ICMP6_DST_UNREACH_NOTNEIGHBOR\n\
    \     <netinet/icmp6.h> ICMP6_ECHO_REPLY\n     <netinet/icmp6.h> ICMP6_ECHO_REQUEST\n\
    \     <netinet/icmp6.h> ICMP6_INFOMSG_MASK\n     <netinet/icmp6.h> ICMP6_MEMBERSHIP_QUERY\n\
    \     <netinet/icmp6.h> ICMP6_MEMBERSHIP_REDUCTION\n     <netinet/icmp6.h> ICMP6_MEMBERSHIP_REPORT\n\
    \     <netinet/icmp6.h> ICMP6_PACKET_TOO_BIG\n     <netinet/icmp6.h> ICMP6_PARAMPROB_HEADER\n\
    \     <netinet/icmp6.h> ICMP6_PARAMPROB_NEXTHEADER\n     <netinet/icmp6.h> ICMP6_PARAMPROB_OPTION\n\
    \     <netinet/icmp6.h> ICMP6_PARAM_PROB\n     <netinet/icmp6.h> ICMP6_TIME_EXCEEDED\n\
    \     <netinet/icmp6.h> ICMP6_TIME_EXCEED_REASSEMBLY\n     <netinet/icmp6.h> ICMP6_TIME_EXCEED_TRANSIT\n\
    \     <netinet/icmp6.h> ND_NA_FLAG_OVERRIDE\n     <netinet/icmp6.h> ND_NA_FLAG_ROUTER\n\
    \     <netinet/icmp6.h> ND_NA_FLAG_SOLICITED\n     <netinet/icmp6.h> ND_NEIGHBOR_ADVERT\n\
    \     <netinet/icmp6.h> ND_NEIGHBOR_SOLICIT\n     <netinet/icmp6.h> ND_OPT_MTU\n\
    \     <netinet/icmp6.h> ND_OPT_PI_FLAG_AUTO\n     <netinet/icmp6.h> ND_OPT_PI_FLAG_ONLINK\n\
    \     <netinet/icmp6.h> ND_OPT_PREFIX_INFORMATION\n     <netinet/icmp6.h> ND_OPT_REDIRECTED_HEADER\n\
    \     <netinet/icmp6.h> ND_OPT_SOURCE_LINKADDR\n     <netinet/icmp6.h> ND_OPT_TARGET_LINKADDR\n\
    \     <netinet/icmp6.h> ND_RA_FLAG_MANAGED\n     <netinet/icmp6.h> ND_RA_FLAG_OTHER\n\
    \     <netinet/icmp6.h> ND_REDIRECT\n     <netinet/icmp6.h> ND_ROUTER_ADVERT\n\
    \     <netinet/icmp6.h> ND_ROUTER_SOLICIT\n     <netinet/icmp6.h> struct icmp6_filter{};\n\
    \     <netinet/icmp6.h> struct icmp6_hdr{};\n     <netinet/icmp6.h> struct nd_neighbor_advert{};\n\
    \     <netinet/icmp6.h> struct nd_neighbor_solicit{};\n     <netinet/icmp6.h>\
    \ struct nd_opt_hdr{};\n     <netinet/icmp6.h> struct nd_opt_mtu{};\n     <netinet/icmp6.h>\
    \ struct nd_opt_prefix_info{};\n     <netinet/icmp6.h> struct nd_opt_rd_hdr{};\n\
    \     <netinet/icmp6.h> struct nd_redirect{};\n     <netinet/icmp6.h> struct nd_router_advert{};\n\
    \     <netinet/icmp6.h> struct nd_router_solicit{};\n     <netinet/in.h>    IPPROTO_AH\n\
    \     <netinet/in.h>    IPPROTO_DSTOPTS\n     <netinet/in.h>    IPPROTO_ESP\n\
    \     <netinet/in.h>    IPPROTO_FRAGMENT\n     <netinet/in.h>    IPPROTO_HOPOPTS\n\
    \     <netinet/in.h>    IPPROTO_ICMPV6\n     <netinet/in.h>    IPPROTO_IPV6\n\
    \     <netinet/in.h>    IPPROTO_NONE\n     <netinet/in.h>    IPPROTO_ROUTING\n\
    \     <netinet/in.h>    IPV6_DSTOPTS\n     <netinet/in.h>    IPV6_HOPLIMIT\n \
    \    <netinet/in.h>    IPV6_HOPOPTS\n     <netinet/in.h>    IPV6_NEXTHOP\n   \
    \  <netinet/in.h>    IPV6_PKTINFO\n     <netinet/in.h>    IPV6_PKTOPTIONS\n  \
    \   <netinet/in.h>    IPV6_RTHDR\n     <netinet/in.h>    IPV6_RTHDR_LOOSE\n  \
    \   <netinet/in.h>    IPV6_RTHDR_STRICT\n     <netinet/in.h>    IPV6_RTHDR_TYPE_0\n\
    \     <netinet/in.h>    struct in6_pktinfo{};\n     <netinet/ip6.h>   IP6F_OFF_MASK\n\
    \     <netinet/ip6.h>   IP6F_RESERVED_MASK\n     <netinet/ip6.h>   IP6F_MORE_FRAG\n\
    \     <netinet/ip6.h>   struct ip6_dest{};\n     <netinet/ip6.h>   struct ip6_frag{};\n\
    \     <netinet/ip6.h>   struct ip6_hbh{};\n     <netinet/ip6.h>   struct ip6_hdr{};\n\
    \     <netinet/ip6.h>   struct ip6_rthdr{};\n     <netinet/ip6.h>   struct ip6_rthdr0{};\n\
    \     <sys/socket.h>    struct cmsghdr{};\n     <sys/socket.h>    struct msghdr{};\n\
    \   The following list summarizes the function and macro prototypes\n   discussed\
    \ in this memo, sorted by header.\n"
- title: <netinet/icmp6.h> void ICMP6_FILTER_SETBLOCK(int,
  contents:
  - "<netinet/icmp6.h> void ICMP6_FILTER_SETBLOCK(int,\n                         \
    \                       struct icmp6_filter *);\n"
- title: <netinet/icmp6.h> void ICMP6_FILTER_SETBLOCKALL(struct icmp6_filter *);
  contents:
  - '<netinet/icmp6.h> void ICMP6_FILTER_SETBLOCKALL(struct icmp6_filter *);

    '
- title: <netinet/icmp6.h> void ICMP6_FILTER_SETPASS(int, struct icmp6_filter *);
  contents:
  - '<netinet/icmp6.h> void ICMP6_FILTER_SETPASS(int, struct icmp6_filter *);

    '
- title: <netinet/icmp6.h> void ICMP6_FILTER_SETPASSALL(struct icmp6_filter *);
  contents:
  - '<netinet/icmp6.h> void ICMP6_FILTER_SETPASSALL(struct icmp6_filter *);

    '
- title: <netinet/icmp6.h> int  ICMP6_FILTER_WILLBLOCK(int,
  contents:
  - "<netinet/icmp6.h> int  ICMP6_FILTER_WILLBLOCK(int,\n                        \
    \                   const struct icmp6_filter *);\n"
- title: <netinet/icmp6.h> int  ICMP6_FILTER_WILLPASS(int,
  contents:
  - "<netinet/icmp6.h> int  ICMP6_FILTER_WILLPASS(int,\n                         \
    \                  const struct icmp6_filter *);\n"
- title: <netinet/in.h>    int IN6_ARE_ADDR_EQUAL(const struct in6_addr *,
  contents:
  - "<netinet/in.h>    int IN6_ARE_ADDR_EQUAL(const struct in6_addr *,\n         \
    \                                const struct in6_addr *);\n"
- title: <netinet/in.h>    uint8_t *inet6_option_alloc(struct cmsghdr *,
  contents:
  - "<netinet/in.h>    uint8_t *inet6_option_alloc(struct cmsghdr *,\n           \
    \                                    int, int, int);\n"
- title: <netinet/in.h>    int inet6_option_append(struct cmsghdr *,
  contents:
  - "<netinet/in.h>    int inet6_option_append(struct cmsghdr *,\n               \
    \                           const uint8_t *, int, int);\n"
- title: <netinet/in.h>    int inet6_option_find(const struct cmsghdr *,
  contents:
  - "<netinet/in.h>    int inet6_option_find(const struct cmsghdr *,\n           \
    \                             uint8_t *, int);\n"
- title: <netinet/in.h>    int inet6_option_init(void *, struct cmsghdr **, int);
  contents:
  - '<netinet/in.h>    int inet6_option_init(void *, struct cmsghdr **, int);

    '
- title: <netinet/in.h>    int inet6_option_next(const struct cmsghdr *,
  contents:
  - "<netinet/in.h>    int inet6_option_next(const struct cmsghdr *,\n           \
    \                             uint8_t **);\n"
- title: <netinet/in.h>    int inet6_option_space(int);
  contents:
  - '<netinet/in.h>    int inet6_option_space(int);

    '
- title: <netinet/in.h>    int inet6_rthdr_add(struct cmsghdr *,
  contents:
  - "<netinet/in.h>    int inet6_rthdr_add(struct cmsghdr *,\n                   \
    \                   const struct in6_addr *,\n                               \
    \       unsigned int);\n"
- title: <netinet/in.h>    struct in6_addr inet6_rthdr_getaddr(struct cmsghdr *,
  contents:
  - "<netinet/in.h>    struct in6_addr inet6_rthdr_getaddr(struct cmsghdr *,\n   \
    \                                                   int);\n"
- title: <netinet/in.h>    int inet6_rthdr_getflags(const struct cmsghdr *, int);
  contents:
  - '<netinet/in.h>    int inet6_rthdr_getflags(const struct cmsghdr *, int);

    '
- title: <netinet/in.h>    struct cmsghdr *inet6_rthdr_init(void *, int);
  contents:
  - '<netinet/in.h>    struct cmsghdr *inet6_rthdr_init(void *, int);

    '
- title: <netinet/in.h>    int inet6_rthdr_lasthop(struct cmsghdr *,
  contents:
  - "<netinet/in.h>    int inet6_rthdr_lasthop(struct cmsghdr *,\n               \
    \                                           unsigned int);\n"
- title: <netinet/in.h>    int inet6_rthdr_reverse(const struct cmsghdr *,
  contents:
  - "<netinet/in.h>    int inet6_rthdr_reverse(const struct cmsghdr *,\n         \
    \                                 struct cmsghdr *);\n"
- title: <netinet/in.h>    int inet6_rthdr_segments(const struct cmsghdr *);
  contents:
  - '<netinet/in.h>    int inet6_rthdr_segments(const struct cmsghdr *);

    '
- title: <netinet/in.h>    size_t inet6_rthdr_space(int, int);
  contents:
  - '<netinet/in.h>    size_t inet6_rthdr_space(int, int);

    '
- title: <sys/socket.h>    unsigned char *CMSG_DATA(const struct cmsghdr *);
  contents:
  - '<sys/socket.h>    unsigned char *CMSG_DATA(const struct cmsghdr *);

    '
- title: <sys/socket.h>    struct cmsghdr *CMSG_FIRSTHDR(const struct msghdr *);
  contents:
  - '<sys/socket.h>    struct cmsghdr *CMSG_FIRSTHDR(const struct msghdr *);

    '
- title: <sys/socket.h>    unsigned int CMSG_LEN(unsigned int);
  contents:
  - '<sys/socket.h>    unsigned int CMSG_LEN(unsigned int);

    '
- title: <sys/socket.h>    struct cmsghdr *CMSG_NXTHDR(const struct msghdr *mhdr,
  contents:
  - "<sys/socket.h>    struct cmsghdr *CMSG_NXTHDR(const struct msghdr *mhdr,\n  \
    \                                            const struct cmsghdr *);\n"
- title: <sys/socket.h>    unsigned int CMSG_SPACE(unsigned int);
  contents:
  - '<sys/socket.h>    unsigned int CMSG_SPACE(unsigned int);

    '
- title: <unistd.h>        int rresvport_af(int *, int);
  contents:
  - '<unistd.h>        int rresvport_af(int *, int);

    '
- title: 14.  Security Considerations
  contents:
  - "14.  Security Considerations\n   The setting of certain Hop-by-Hop options and\
    \ Destination options may\n   be restricted to privileged processes.  Similarly\
    \ some Hop-by-Hop\n   options and Destination options may not be returned to nonprivileged\n\
    \   applications.\n"
- title: 15.  Change History
  contents:
  - "15.  Change History\n   Changes from the June 1997 Edition (-03 draft)\n    -\
    \  Added a note that defined constants for multibyte fields are in\n       network\
    \ byte order.  This affects the ip6f_offlg member of the\n       Fragment header\
    \ (Section 2.1.2) and the nd_na_flags_reserved\n       member of the nd_neighbor_advert\
    \ structure (Section 2.2.2).\n    -  Section 5: the ipi6_ifindex member of the\
    \ in6_pktinfo structure\n       should be \"unsigned int\" instead of \"int\"\
    , for consistency with\n       the interface indexes in [RFC-2133].\n    -  Section\
    \ 6.3.7: the three calls to inet6_option_space() in the\n       examples needed\
    \ to be arguments to malloc().  The final one of\n       these was missing the\
    \ \"6\" in the name \"inet6_option_space\".\n    -  Section 8.6: the function\
    \ prototype for inet6_rthdr_segments()\n       was missing the ending semicolon.\n\
    \   Changes from the March 1997 Edition (-02 draft)\n    -  In May 1997 Draft\
    \ 6.6 of Posix 1003.1g (called Posix.1g herein)\n       passed ballot and will\
    \ be forwarded to the IEEE Standards Board\n       later in 1997 for final approval.\
    \  Some changes made for this\n       final Posix draft are incorporated into\
    \ this Internet Draft,\n       specifically the datatypes mentioned in Section\
    \ 1 (and used\n       throughout the text), and the socklen_t datatype used in\
    \ Section\n       4.1 and 4.2.\n    -  Section 1: Added the intN_t signed datatypes,\
    \ changed the\n       datatype u_intN_t to uintN_t (no underscore after the \"\
    u\"), and\n       removed the datatype u_intNm_t, as per Draft 6.6 of Posix.1g.\n\
    \    -  Name space issues for structure and constant names in Section 2:\n   \
    \    Many of the structure member names and constant names were\n       changed\
    \ so that the prefixes are the same.  The following\n       prefixes are used\
    \ for structure members: \"ip6_\", \"icmp6_\", and\n       \"nd_\".  All constants\
    \ have the prefixes \"ICMP6_\" and \"ND_\".\n    -  New definitions: Section 2.1.2:\
    \ contains definitions for the IPv6\n       extension headers, other than AH and\
    \ ESP.  Section 2.2.2:\n       contains additional structures and constants for\
    \ the neighbor\n       discovery option header and redirected header.\n    - \
    \ Section 2.2.2: the enum for the neighbor discovery option field\n       was\
    \ changed to be a set of #define constants.\n    -  Changed the word \"function\"\
    \ to \"macro\" for references to all the\n       uppercase names in Sections 2.3\
    \ (IN6_ARE_ADDR_EQUAL), 3.2\n       (ICMPV6_FILTER_xxx), and 4.3 (CMSG_xxx).\n\
    \    -  Added more protocols to the /etc/protocols file (Section 2.4) and\n  \
    \     changed the name of \"icmpv6\" to \"ipv6-icmp\".\n    -  Section 3: Made\
    \ it more explicit that an application cannot read\n       or write entire IPv6\
    \ packets, that all extension headers are\n       passed as ancillary data.  Added\
    \ a sentence that the kernel\n       fragments packets written to an IPv6 raw\
    \ socket when necessary.\n       Added a note that IPPROTO_RAW raw IPv6 sockets\
    \ are not special.\n    -  Section 3.1: Explicitly stated that the checksum option\
    \ applies\n       to both outgoing packets and received packets.\n    -  Section\
    \ 3.2: Changed the array name within the icmp6_filter\n       structure from \"\
    data\" to \"icmp6_filt\".  Changes the prefix for\n       the filter macros from\
    \ \"ICMPV6_\" to \"ICMP6_\", for consistency\n       with the names in Section\
    \ 2.2.  Changed the example from a ping\n       program to a program that wants\
    \ to receive only router\n       advertisements.\n    -  Section 4.1: Changed\
    \ msg_namelen and msg_controllen from size_t\n       to the Posix.1g socklen_t\
    \ datatype.  Updated the Note that\n       follows.\n    -  Section 4.2: Changed\
    \ cmsg_len from size_t to the Posix.1g\n       socklen_t datatype.  Updated the\
    \ Note that follows.\n    -  Section 4.4: Added a Note that the second and third\
    \ arguments to\n       getsockopt() and setsockopt() are intentionally the same\
    \ as the\n       cmsg_level and cmsg_type members.\n    -  Section 4.5: Reorganized\
    \ the section into a description of the\n       option, followed by the TCP semantics,\
    \ and the UDP and raw socket\n       semantics.  Added a sentence on how to clear\
    \ all the sticky\n       options.  Added a note that TCP need not save the options\
    \ from\n       the most recently received segment until the application says to\n\
    \       do so.  Added the statement that ancillary data is never passed\n    \
    \   with sendmsg() or recvmsg() on a TCP socket.  Simplified the\n       interaction\
    \ of the sticky options with ancillary data for UDP or\n       raw IP: none of\
    \ the sticky options are sent if ancillary data is\n       specified.\n    - \
    \ Final paragraph of Section 5.1: ipi6_index should be\n       ipi6_ifindex.\n\
    \    -  Section 5.4: Added a note on the term \"privileged\".\n    -  Section\
    \ 5.5: Noted that the errors listed are examples, and the\n       actual errors\
    \ depend on the implementation.\n    -  Removed Section 6 (\"Flow Labels\") as\
    \ the consensus is that it is\n       premature to try and specify an API for\
    \ this feature.  Access to\n       the flow label field in the IPv6 header is\
    \ still provided through\n       the sin6_flowinfo member of the IPv6 socket address\
    \ structure in\n       [RFC-2133].  Added a subsection to Section 13 that this\
    \ is a\n       future item.\n       All remaining changes are identified by their\
    \ section number in\n       the previous draft.  With the removal of Section 6,\
    \ the section\n       numbers are decremented by one.\n    -  Section 7.3.7: the\
    \ calls to malloc() in all three examples should\n       be calls to inet6_option_space()\
    \ instead.  The two calls to\n       inet6_option_append() in the third example\
    \ should be calls to\n       inet6_option_alloc().  The two calls to CMSG_SPACE()\
    \ in the first\n       and third examples should be calls to CMSG_LEN().  The\
    \ second\n       call to CMSG_SPACE() in the second example should be a call to\n\
    \       CMSG_LEN().\n    -  Section 7.3.7: All the opt_X_ and opt_Y_ structure\
    \ member names\n       were changed to be ip6_X_opt_ and ip6_Y_opt_.  The two\
    \ structure\n       names ipv6_opt_X and ipv6_opt_Y were changed to ip6_X_opt\
    \ and\n       ip6_Y_opt.  The constants beginning with IPV6_OPT_X_ and\n     \
    \  IPV6_OPT_Y_ were changed to begin with IP6_X_OPT_ and IP6_Y_OPT_.\n    -  Use\
    \ the term \"Routing header\" throughout the draft, instead of\n       \"source\
    \ routing\".  Changed the names of the eight\n       inet6_srcrt_XXX() functions\
    \ in Section 9 to inet6_rthdr_XXX().\n       Changed the name of the socket option\
    \ from IPV6_SRCRT to\n       IPV6_RTHDR, and the names of the three IPV6_SRCRT_xxx\
    \ constants\n       in Section 9 to IPV6_RTHDR_xxx.\n    -  Added a paragraph\
    \ to Section 9 on how to receive and send a\n       Routing header.\n    -  Changed\
    \ inet6_rthdr_add() and inet6_rthdr_reverse() so that they\n       return -1 upon\
    \ an error, instead of an Exxx errno value.\n    -  In the description of inet6_rthdr_space()\
    \ in Section 9.1, added\n       the qualifier \"For an IPv6 Type 0 Routing header\"\
    \ to the\n       restriction of between 1 and 23 segments.\n    -  Refer to final\
    \ function argument in Sections 9.7 and 9.8 as\n       index, not offset.\n  \
    \  -  Updated Section 14 with new names from Section 2.\n    -  Changed the References\
    \ from \"[n]\" to \"[RFC-abcd]\".\n   Changes from the February 1997 Edition (-01\
    \ draft)\n    -  Changed the name of the ip6hdr structure to ip6_hdr (Section\
    \ 2.1)\n       for consistency with the icmp6hdr structure.  Also changed the\n\
    \       name of the ip6hdrctl structure contained within the ip6_hdr\n       structure\
    \ to ip6_hdrctl (Section 2.1).  Finally, changed the name\n       of the icmp6hdr\
    \ structure to icmp6_hdr (Section 2.2).  All other\n       occurrences of this\
    \ structure name, within the Neighbor Discovery\n       structures in Section\
    \ 2.2.1, already contained the underscore.\n    -  The \"struct nd_router_solicit\"\
    \ and \"struct nd_router_advert\"\n       should both begin with \"nd6_\". (Section\
    \ 2.2.2).\n    -  Changed the name of in6_are_addr_equal to IN6_ARE_ADDR_EQUAL\n\
    \       (Section 2.3) for consistency with basic API address testing\n       functions.\
    \  The header defining this macro is <netinet/in.h>.\n    -  getprotobyname(\"\
    ipv6\") now returns 41, not 0 (Section 2.4).\n    -  The first occurrence of \"\
    struct icmpv6_filter\" in Section 3.2\n       should be \"struct icmp6_filter\"\
    .\n    -  Changed the name of the CMSG_LENGTH() macro to CMSG_LEN()\n       (Section\
    \ 4.3.5), since LEN is used throughout the <netinet/*.h>\n       headers.\n  \
    \  -  Corrected the argument name for the sample implementations of the\n    \
    \   CMSG_SPACE() and CMSG_LEN() macros to be \"length\" (Sections 4.3.4\n    \
    \   and 4.3.5).\n    -  Corrected the socket option mentioned in Section 5.1 to\
    \ specify\n       the interface for multicasting from IPV6_ADD_MEMBERSHIP to\n\
    \       IPV6_MULTICAST_IF.\n    -  There were numerous errors in the previous\
    \ draft that specified\n       <netinet/ip6.h> that should have been <netinet/in.h>.\
    \  These have\n       all been corrected and the locations of all definitions\
    \ is now\n       summarized in the new Section 14 (\"Summary of New Definitions\"\
    ).\n    Changes from the October 1996 Edition (-00 draft)\n    -  Numerous rationale\
    \ added using the format (Note: ...).\n    -  Added note that not all errors may\
    \ be defined.\n    -  Added note about ICMPv4, IGMPv4, and ARPv4 terminology.\n\
    \    -  Changed the name of <netinet/ip6_icmp.h> to <netinet/icmp6.h>.\n    -\
    \  Changed some names in Section 2.2.1: ICMPV6_PKT_TOOBIG to\n       ICMPV6_PACKET_TOOBIG,\
    \ ICMPV6_TIME_EXCEED to ICMPV6_TIME_EXCEEDED,\n       ICMPV6_ECHORQST to ICMPV6_ECHOREQUEST,\
    \ ICMPV6_ECHORPLY to\n       ICMPV6_ECHOREPLY, ICMPV6_PARAMPROB_HDR to\n     \
    \  ICMPV6_PARAMPROB_HEADER, ICMPV6_PARAMPROB_NXT_HDR to\n       ICMPV6_PARAMPROB_NEXTHEADER,\
    \ and ICMPV6_PARAMPROB_OPTS to\n       ICMPV6_PARAMPROB_OPTION.\n    -  Prepend\
    \ the prefix \"icmp6_\" to the three members of the\n       icmp6_dataun union\
    \ of the icmp6hdr structure (Section 2.2).\n    -  Moved the neighbor discovery\
    \ definitions into the\n       <netinet/icmp6.h> header, instead of being in their\
    \ own header\n       (Section 2.2.1).\n    -  Changed Section 2.3 (\"Address Testing\"\
    ).  The basic macros are\n       now in the basic API.\n    -  Added the new Section\
    \ 2.4 on \"Protocols File\".\n    -  Added note to raw sockets description that\
    \ something like BPF or\n       DLPI must be used to read or write entire IPv6\
    \ packets.\n    -  Corrected example of IPV6_CHECKSUM socket option (Section 3.1).\n\
    \       Also defined value of -1 to disable.\n    -  Noted that <netinet/icmp6.h>\
    \ defines all the ICMPv6 filtering\n       constants, macros, and structures (Section\
    \ 3.2).\n    -  Added note on magic number 10240 for amount of ancillary data\n\
    \       (Section 4.1).\n    -  Added possible padding to picture of ancillary\
    \ data (Section\n       4.2).\n    -  Defined <sys/socket.h> header for CMSG_xxx()\
    \ functions (Section\n       4.2).\n    -  Note that the data returned by getsockopt(IPV6_PKTOPTIONS)\
    \ for a\n       TCP socket is just from the optional headers, if present, of the\n\
    \       most recently received segment.  Also note that control\n       information\
    \ is never returned by recvmsg() for a TCP socket.\n    -  Changed header for\
    \ struct in6_pktinfo from <netinet.in.h> to\n       <netinet/ip6.h> (Section 5).\n\
    \    -  Removed the old Sections 5.1 and 5.2, because the interface\n       identification\
    \ functions went into the basic API.\n    -  Redid Section 5 to support the hop\
    \ limit field.\n    -  New Section 5.4 (\"Next Hop Address\").\n    -  New Section\
    \ 6 (\"Flow Labels\").\n    -  Changed all of Sections 7 and 8 dealing with Hop-by-Hop\
    \ and\n       Destination options.  We now define a set of inet6_option_XXX()\n\
    \       functions.\n    -  Changed header for IPV6_SRCRT_xxx constants from <netinet.in.h>\n\
    \       to <netinet/ip6.h> (Section 9).\n    -  Add inet6_rthdr_lasthop() function,\
    \ and fix errors in description\n       of Routing header (Section 9).\n    -\
    \  Reworded some of the Routing header descriptions to conform to\n       the\
    \ terminology in [RFC-1883].\n    -  Added the example from [RFC-1883] for the\
    \ Routing header (Section\n       9.9).\n    -  Expanded the example in Section\
    \ 10 to show multiple options per\n       ancillary data object, and to show the\
    \ receiver's ancillary data\n       objects.\n    -  New Section 11 (\"IPv6-Specific\
    \ Options with IPv4-Mapped IPv6\n       Addresses\").\n    -  New Section 12 (\"\
    rresvport_af\").\n    -  Redid old Section 10 (\"Additional Items\") into new\
    \ Section 13\n       (\"Future Items\").\n"
- title: 16.  References
  contents:
  - "16.  References\n   [RFC-1883]  Deering, S., and R. Hinden, \"Internet Protocol,\
    \ Version 6\n               (IPv6), Specification\", RFC 1883, December 1995.\n\
    \   [RFC-2133]  Gilligan, R., Thomson, S., Bound, J., and W. Stevens,\n      \
    \         \"Basic Socket Interface Extensions for IPv6\", RFC 2133,\n        \
    \       April 1997.\n   [RFC-1981]  McCann, J., Deering, S., and J. Mogul, \"\
    Path MTU\n   Discovery\n               for IP version 6\", RFC 1981, August 1996.\n\
    \   [RFC-1970]  Narten, T., Nordmark, E., and W. Simpson, \"Neighbor\n       \
    \        Discovery for IP Version 6 (IPv6)\", RFC 1970, August\n             \
    \  1996.\n"
- title: 17.  Acknowledgments
  contents:
  - "17.  Acknowledgments\n   Matt Thomas and Jim Bound have been working on the technical\
    \ details\n   in this draft for over a year.  Keith Sklower is the original\n\
    \   implementor of ancillary data in the BSD networking code.  Craig Metz\n  \
    \ provided lots of feedback, suggestions, and comments based on his\n   implementing\
    \ many of these features as the document was being\n   written.\n   The following\
    \ provided comments on earlier drafts: Pascal Anelli,\n   Hamid Asayesh, Ran Atkinson,\
    \ Karl Auerbach, Hamid Asayesh, Matt\n   Crawford, Sam T. Denton, Richard Draves,\
    \ Francis Dupont, Bob\n   Gilligan, Tim Hartrick, Masaki Hirabaru, Yoshinobu Inoue,\
    \ Mukesh\n   Kacker, A. N. Kuznetsov, Pedro Marques, Jack McCann, der Mouse, John\n\
    \   Moy, Thomas Narten, Erik Nordmark, Steve Parker, Charles Perkins, Tom\n  \
    \ Pusateri, Pedro Roque, Sameer Shah, Peter Sjodin, Stephen P.\n   Spackman, Jinmei\
    \ Tatuya, Karen Tracey, Quaizar Vohra, Carl Williams,\n   Steve Wise, and Kazu\
    \ Yamamoto.\n"
- title: 18.  Authors' Addresses
  contents:
  - "18.  Authors' Addresses\n   W. Richard Stevens\n   1202 E. Paseo del Zorro\n\
    \   Tucson, AZ  85718\n   EMail: rstevens@kohala.com\n   Matt Thomas\n   AltaVista\
    \ Internet Software\n   LJO2-1/J8\n   30 Porter Rd\n   Littleton, MA  01460\n\
    \   EMail: matt.thomas@altavista-software.com\n"
- title: 19.  Full Copyright Statement
  contents:
  - "19.  Full Copyright Statement\n   Copyright (C) The Internet Society (1998).\
    \  All Rights Reserved.\n   This document and translations of it may be copied\
    \ and furnished to\n   others, and derivative works that comment on or otherwise\
    \ explain it\n   or assist in its implementation may be prepared, copied, published\n\
    \   and distributed, in whole or in part, without restriction of any\n   kind,\
    \ provided that the above copyright notice and this paragraph are\n   included\
    \ on all such copies and derivative works.  However, this\n   document itself\
    \ may not be modified in any way, such as by removing\n   the copyright notice\
    \ or references to the Internet Society or other\n   Internet organizations, except\
    \ as needed for the purpose of\n   developing Internet standards in which case\
    \ the procedures for\n   copyrights defined in the Internet Standards process\
    \ must be\n   followed, or as required to translate it into languages other than\n\
    \   English.\n   The limited permissions granted above are perpetual and will\
    \ not be\n   revoked by the Internet Society or its successors or assigns.\n \
    \  This document and the information contained herein is provided on an\n   \"\
    AS IS\" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING\n   TASK FORCE\
    \ DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING\n   BUT NOT LIMITED\
    \ TO ANY WARRANTY THAT THE USE OF THE INFORMATION\n   HEREIN WILL NOT INFRINGE\
    \ ANY RIGHTS OR ANY IMPLIED WARRANTIES OF\n   MERCHANTABILITY OR FITNESS FOR A\
    \ PARTICULAR PURPOSE.\n"
