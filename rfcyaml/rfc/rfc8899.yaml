- contents:
  - '     Packetization Layer Path MTU Discovery for Datagram Transports

    '
  title: __initial_text__
- contents:
  - "Abstract\n   This document specifies Datagram Packetization Layer Path MTU\n
    \  Discovery (DPLPMTUD).  This is a robust method for Path MTU Discovery\n   (PMTUD)
    for datagram Packetization Layers (PLs).  It allows a PL, or\n   a datagram application
    that uses a PL, to discover whether a network\n   path can support the current
    size of datagram.  This can be used to\n   detect and reduce the message size
    when a sender encounters a packet\n   black hole.  It can also probe a network
    path to discover whether the\n   maximum packet size can be increased.  This provides
    functionality\n   for datagram transports that is equivalent to the PLPMTUD\n
    \  specification for TCP, specified in RFC 4821, which it updates.  It\n   also
    updates the UDP Usage Guidelines to refer to this method for use\n   with UDP
    datagrams and updates SCTP.\n   The document provides implementation notes for
    incorporating Datagram\n   PMTUD into IETF datagram transports or applications
    that use datagram\n   transports.\n   This specification updates RFC 4960, RFC
    4821, RFC 6951, RFC 8085,\n   and RFC 8261.\n"
  title: Abstract
- contents:
  - "Status of This Memo\n   This is an Internet Standards Track document.\n   This
    document is a product of the Internet Engineering Task Force\n   (IETF).  It represents
    the consensus of the IETF community.  It has\n   received public review and has
    been approved for publication by the\n   Internet Engineering Steering Group (IESG).
    \ Further information on\n   Internet Standards is available in Section 2 of RFC
    7841.\n   Information about the current status of this document, any errata,\n
    \  and how to provide feedback on it may be obtained at\n   https://www.rfc-editor.org/info/rfc8899.\n"
  title: Status of This Memo
- contents:
  - "Copyright Notice\n   Copyright (c) 2020 IETF Trust and the persons identified
    as the\n   document authors.  All rights reserved.\n   This document is subject
    to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n
    \  (https://trustee.ietf.org/license-info) in effect on the date of\n   publication
    of this document.  Please review these documents\n   carefully, as they describe
    your rights and restrictions with respect\n   to this document.  Code Components
    extracted from this document must\n   include Simplified BSD License text as described
    in Section 4.e of\n   the Trust Legal Provisions and are provided without warranty
    as\n   described in the Simplified BSD License.\n"
  title: Copyright Notice
- contents:
  - "Table of Contents\n   1.  Introduction\n     1.1.  Classical Path MTU Discovery\n
    \    1.2.  Packetization Layer Path MTU Discovery\n     1.3.  Path MTU Discovery
    for Datagram Services\n   2.  Terminology\n   3.  Features Required to Provide
    Datagram PLPMTUD\n   4.  DPLPMTUD Mechanisms\n     4.1.  PLPMTU Probe Packets\n
    \    4.2.  Confirmation of Probed Packet Size\n     4.3.  Black Hole Detection
    and Reducing the PLPMTU\n     4.4.  The Maximum Packet Size (MPS)\n     4.5.  Disabling
    the Effect of PMTUD\n     4.6.  Response to PTB Messages\n       4.6.1.  Validation
    of PTB Messages\n       4.6.2.  Use of PTB Messages\n   5.  Datagram Packetization
    Layer PMTUD\n     5.1.  DPLPMTUD Components\n       5.1.1.  Timers\n       5.1.2.
    \ Constants\n       5.1.3.  Variables\n       5.1.4.  Overview of DPLPMTUD Phases\n
    \    5.2.  State Machine\n     5.3.  Search to Increase the PLPMTU\n       5.3.1.
    \ Probing for a Larger PLPMTU\n       5.3.2.  Selection of Probe Sizes\n       5.3.3.
    \ Resilience to Inconsistent Path Information\n     5.4.  Robustness to Inconsistent
    Paths\n   6.  Specification of Protocol-Specific Methods\n     6.1.  Application
    Support for DPLPMTUD with UDP or UDP-Lite\n       6.1.1.  Application Request\n
    \      6.1.2.  Application Response\n       6.1.3.  Sending Application Probe
    Packets\n       6.1.4.  Initial Connectivity\n       6.1.5.  Validating the Path\n
    \      6.1.6.  Handling of PTB Messages\n     6.2.  DPLPMTUD for SCTP\n       6.2.1.
    \ SCTP/IPv4 and SCTP/IPv6\n         6.2.1.1.  Initial Connectivity\n         6.2.1.2.
    \ Sending SCTP Probe Packets\n         6.2.1.3.  Validating the Path with SCTP\n
    \        6.2.1.4.  PTB Message Handling by SCTP\n       6.2.2.  DPLPMTUD for SCTP/UDP\n
    \        6.2.2.1.  Initial Connectivity\n         6.2.2.2.  Sending SCTP/UDP Probe
    Packets\n         6.2.2.3.  Validating the Path with SCTP/UDP\n         6.2.2.4.
    \ Handling of PTB Messages by SCTP/UDP\n       6.2.3.  DPLPMTUD for SCTP/DTLS\n
    \        6.2.3.1.  Initial Connectivity\n         6.2.3.2.  Sending SCTP/DTLS
    Probe Packets\n         6.2.3.3.  Validating the Path with SCTP/DTLS\n         6.2.3.4.
    \ Handling of PTB Messages by SCTP/DTLS\n     6.3.  DPLPMTUD for QUIC\n   7.  IANA
    Considerations\n   8.  Security Considerations\n   9.  References\n     9.1.  Normative
    References\n     9.2.  Informative References\n   Acknowledgments\n   Authors'
    Addresses\n"
  title: Table of Contents
- contents:
  - "1.  Introduction\n   The IETF has specified datagram transport using UDP, Stream
    Control\n   Transmission Protocol (SCTP), and Datagram Congestion Control\n   Protocol
    (DCCP), as well as protocols layered on top of these\n   transports (e.g., SCTP/UDP,
    DCCP/UDP, QUIC/UDP) and direct datagram\n   transport over the IP network layer.
    \ This document describes a\n   robust method for Path MTU Discovery (PMTUD) that
    can be used with\n   these transport protocols (or the applications that use their\n
    \  transport service) to discover an appropriate size of packet to use\n   across
    an Internet path.\n"
  - contents:
    - "1.1.  Classical Path MTU Discovery\n   Classical Path Maximum Transmission
      Unit Discovery (PMTUD) can be\n   used with any transport that is able to process
      ICMP Packet Too Big\n   (PTB) messages (e.g., [RFC1191] and [RFC8201]).  In
      this document,\n   the term PTB message is applied to both IPv4 ICMP Unreachable\n
      \  messages (Type 3) that carry the error Fragmentation Needed (Type 3,\n   Code
      4) [RFC0792] and ICMPv6 Packet Too Big messages (Type 2)\n   [RFC4443].  When
      a sender receives a PTB message, it reduces the\n   effective MTU to the value
      reported as the link MTU in the PTB\n   message.  Classical PMTUD specifies
      a method of periodically\n   increasing the packet size in an attempt to discover
      an increase in\n   the supported PMTU.  The packets sent with a size larger
      than the\n   current effective PMTU are known as probe packets.\n   Packets
      not intended as probe packets are either fragmented to the\n   current effective
      PMTU, or the attempt to send fails with an error\n   code.  Applications can
      be provided with a primitive to let them read\n   the Maximum Packet Size (MPS),
      which is derived from the current\n   effective PMTU.\n   Classical PMTUD is
      subject to protocol failures.  One failure arises\n   when traffic using a packet
      size larger than the actual PMTU is\n   black-holed (all datagrams larger than
      the actual PMTU are\n   discarded).  This could arise when the PTB messages
      are not sent back\n   to the sender for some reason (for example, see [RFC2923]).\n
      \  Examples of where PTB messages are not delivered include the\n   following:\n
      \  *  The generation of ICMP messages is usually rate limited.  This\n      could
      result in no PTB messages being generated to the sender (see\n      Section
      2.4 of [RFC4443]).\n   *  ICMP messages can be filtered by middleboxes, including
      firewalls\n      [RFC4890].  A firewall could be configured with a policy to
      block\n      incoming ICMP messages, which would prevent reception of PTB\n
      \     messages by a sending endpoint behind this firewall.\n   *  When the router
      issuing the ICMP message drops a tunneled packet,\n      the resulting ICMP
      message is directed to the tunnel ingress.\n      This tunnel endpoint is responsible
      for forwarding the ICMP\n      message, processing the quoted packet within
      the payload field to\n      remove the effect of the tunnel and returning a
      correctly\n      formatted ICMP message to the sender [TUNNELS].  Failure to
      do\n      this prevents the PTB message from reaching the original sender.\n
      \  *  Asymmetry in forwarding can result in there being no return route\n      to
      the original sender, which would prevent an ICMP message from\n      being delivered
      to the sender.  This issue can also arise when\n      either policy-based or
      Equal-Cost Multipath (ECMP) routing is used\n      or when a middlebox acts
      as an application load balancer.  An\n      example of which is an ECMP router
      choosing a path toward the\n      server based on the bytes in the IP payload.
      \ In this case, if a\n      packet sent by the server encounters a problem after
      the ECMP\n      router, then the ECMP router needs to direct any resulting ICMP\n
      \     message toward the original sender.\n   *  There are additional cases
      where the next-hop destination fails to\n      receive a packet because of its
      size.  This could be due to\n      misconfiguration of the layer 2 path between
      nodes, for instance\n      the MTU configured in a layer 2 switch, or misconfiguration
      of the\n      Maximum Receive Unit (MRU).  If a packet is dropped by the link,\n
      \     this will not cause a PTB message to be sent to the original\n      sender.\n
      \  Another failure could result if a node that is not on the network\n   path
      sends a PTB message that attempts to force a sender to change\n   the effective
      PMTU [RFC8201].  A sender can protect itself from\n   reacting to such messages
      by utilizing the quoted packet within a PTB\n   message payload to validate
      that the received PTB message was\n   generated in response to a packet that
      had actually originated from\n   the sender.  However, there are situations
      where a sender would be\n   unable to provide this validation.  Examples where
      the validation of\n   the PTB message is not possible include the following:\n
      \  *  When a router issuing the ICMP message implements RFC 792\n      [RFC0792],
      it is only required to include the first 64 bits of the\n      IP payload of
      the packet within the quoted payload.  There could\n      be insufficient bytes
      remaining for the sender to interpret the\n      quoted transport information.\n
      \     Note: The recommendation in RFC 1812 [RFC1812] is that IPv4\n      routers
      return a quoted packet with as much of the original\n      datagram as possible
      without the length of the ICMP datagram\n      exceeding 576 bytes.  IPv6 routers
      include as much of the invoking\n      packet as possible without the ICMPv6
      packet exceeding 1280 bytes\n      [RFC4443].\n   *  The use of tunnels and/or
      encryption can reduce the size of the\n      quoted packet returned to the original
      source address, increasing\n      the risk that there could be insufficient
      bytes remaining for the\n      sender to interpret the quoted transport information.\n
      \  *  Even when the PTB message includes sufficient bytes of the quoted\n      packet,
      the network layer could lack sufficient context to\n      validate the message
      because validation depends on information\n      about the active transport
      flows at an endpoint node (e.g., the\n      socket/address pairs being used
      and other protocol header\n      information).\n   *  When a packet is encapsulated/tunneled
      over an encrypted\n      transport, the tunnel/encapsulation ingress might have\n
      \     insufficient context, or computational power, to reconstruct the\n      transport
      header that would be needed to perform validation.\n   *  When an ICMP message
      is generated by a router in a network segment\n      that has inserted a header
      into a packet, the quoted packet could\n      contain additional protocol header
      information that was not\n      included in the original sent packet and that
      the PL sender does\n      not process or may not know how to process.  This
      could disrupt\n      the ability of the sender to validate this PTB message.\n
      \  *  A Network Address Translation (NAT) device that translates a\n      packet
      header ought to also translate ICMP messages and update the\n      ICMP-quoted
      packet [RFC5508] in that message.  If this is not\n      correctly translated,
      then the sender would not be able to\n      associate the message with the PL
      that originated the packet, and\n      hence this ICMP message cannot be validated.\n"
    title: 1.1.  Classical Path MTU Discovery
  - contents:
    - "1.2.  Packetization Layer Path MTU Discovery\n   The term Packetization Layer
      (PL) has been introduced to describe the\n   layer that is responsible for placing
      data blocks into the payload of\n   IP packets and selecting an appropriate
      MPS.  This function is often\n   performed by a transport protocol (e.g., DCCP,
      RTP, SCTP, QUIC) but\n   can also be performed by other encapsulation methods
      working above\n   the transport layer.\n   In contrast to PMTUD, Packetization
      Layer Path MTU Discovery\n   (PLPMTUD) [RFC4821] introduces a method that does
      not rely upon\n   reception and validation of PTB messages.  It is therefore
      more\n   robust than Classical PMTUD.  This has become the recommended\n   approach
      for implementing discovery of the PMTU [BCP145].\n   This document updates [RFC4821]
      to specify the PLPMTUD method for\n   datagram PLs and also updates [BCP145]
      to refer to the method\n   specified in this document for use with UDP datagrams
      instead of the\n   method in [RFC4821].\n   It uses a general strategy in which
      the PL sends probe packets to\n   search for the largest size of unfragmented
      datagram that can be sent\n   over a network path.  Probe packets are sent to
      explore using a\n   larger packet size.  If a probe packet is successfully delivered
      (as\n   determined by the PL), then the PLPMTU is raised to the size of the\n
      \  successful probe.  If a black hole is detected (e.g., where packets\n   of
      size PLPMTU are consistently not received), the method reduces the\n   PLPMTU.\n
      \  Datagram PLPMTUD introduces flexibility in implementation.  At one\n   extreme,
      it can be configured to only perform black hole detection\n   and recovery with
      increased robustness compared to Classical PMTUD.\n   At the other extreme,
      all PTB processing can be disabled, and PLPMTUD\n   replaces Classical PMTUD.\n
      \  PLPMTUD can also include additional consistency checks without\n   increasing
      the risk that data is lost when probing to discover the\n   Path MTU.  For example,
      information available at the PL, or higher\n   layers, enables received PTB
      messages to be validated before being\n   utilized.\n"
    title: 1.2.  Packetization Layer Path MTU Discovery
  - contents:
    - "1.3.  Path MTU Discovery for Datagram Services\n   Section 5 of this document
      presents a set of algorithms for datagram\n   protocols to discover the largest
      size of unfragmented datagram that\n   can be sent over a network path.  The
      method relies upon features of\n   the PL described in Section 3 and applies
      to transport protocols\n   operating over IPv4 and IPv6.  It does not require
      cooperation from\n   the lower layers, although it can utilize PTB messages
      when these\n   received messages are made available to the PL.\n   The message
      size guidelines in Section 3.2 of the UDP Usage\n   Guidelines [BCP145] state
      that \"an application SHOULD either use the\n   Path MTU information provided
      by the IP layer or implement Path MTU\n   Discovery (PMTUD)\" but do not provide
      a mechanism for discovering the\n   largest size of unfragmented datagram that
      can be used on a network\n   path.  The present document updates RFC 8085 to
      specify this method\n   in place of PLPMTUD [RFC4821] and provides a mechanism
      for sharing\n   the discovered largest size as the MPS (see Section 4.4).\n
      \  Section 10.2 of [RFC4821] recommended a PLPMTUD probing method for\n   the
      Stream Control Transport Protocol (SCTP).  SCTP utilizes probe\n   packets consisting
      of a minimal-sized HEARTBEAT chunk bundled with a\n   PAD chunk as defined in
      [RFC4820].  However, RFC 4821 did not provide\n   a complete specification.
      \ The present document replaces that\n   description by providing a complete
      specification.\n   The Datagram Congestion Control Protocol (DCCP) [RFC4340]
      requires\n   implementations to support Classical PMTUD and states that a DCCP\n
      \  sender \"MUST maintain the MPS allowed for each active DCCP session\".\n
      \  It also defines the current congestion control MPS (CCMPS) supported\n   by
      a network path.  This recommends use of PMTUD and suggests use of\n   control
      packets (DCCP-Sync) as path probe packets because they do not\n   risk application
      data loss.  The method defined in this specification\n   can be used with DCCP.\n
      \  Section 4 and Section 5 define the protocol mechanisms and\n   specification
      for Datagram Packetization Layer Path MTU Discovery\n   (DPLPMTUD).\n   Section
      6 specifies the method for datagram transports and provides\n   information
      to enable the implementation of PLPMTUD with other\n   datagram transports and
      applications that use datagram transports.\n   Section 6 also provides recommendations
      for SCTP endpoints, updating\n   [RFC4960], [RFC6951], and [RFC8261] to use
      the method specified in\n   this document instead of the method in [RFC4821].\n"
    title: 1.3.  Path MTU Discovery for Datagram Services
  title: 1.  Introduction
- contents:
  - "2.  Terminology\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\",
    \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"NOT RECOMMENDED\",
    \"MAY\", and\n   \"OPTIONAL\" in this document are to be interpreted as described
    in\n   BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all\n   capitals,
    as shown here.\n   The following terminology is defined.  Relevant terms are directly\n
    \  copied from [RFC4821], and the definitions in [RFC1122] apply.\n   Acknowledged
    PL:  A PL that includes a mechanism that can confirm\n      successful delivery
    of datagrams to the remote PL endpoint (e.g.,\n      SCTP).  Typically, the PL
    receiver returns acknowledgments\n      corresponding to the received datagrams,
    which can be utilized to\n      detect black-holing of packets (c.f., Unacknowledged
    PL).\n   Actual PMTU:  The actual PMTU is the PMTU of a network path between a\n
    \     sender PL and a destination PL, which the DPLPMTUD algorithm seeks\n      to
    determine.\n   Black Hole:  A black hole is encountered when a sender is unaware\n
    \     that packets are not being delivered to the destination endpoint.\n      Two
    types of black hole are relevant to DPLPMTUD:\n      *  Packets encounter a packet
    black hole when packets are not\n         delivered to the destination endpoint
    (e.g., when the sender\n         transmits packets of a particular size with a
    previously known\n         effective PMTU, and they are discarded by the network).\n
    \     *  An ICMP black hole is encountered when the sender is unaware\n         that
    packets are not delivered to the destination endpoint\n         because PTB messages
    are not received by the originating PL\n         sender.\n   Classical Path MTU
    Discovery:  Classical PMTUD is a process described\n      in [RFC1191] and [RFC8201]
    in which nodes rely on PTB messages to\n      learn the largest size of unfragmented
    packet that can be used\n      across a network path.\n   Datagram:  A datagram
    is a transport-layer protocol data unit,\n      transmitted in the payload of
    an IP packet.\n   DPLPMTUD:  Datagram Packetization Layer Path MTU Discovery\n
    \     (DPLPMTUD), PLPMTUD performed using a datagram transport protocol.\n   Effective
    PMTU:  The effective PMTU is the current estimated value\n      for PMTU that
    is used by a PMTUD.  This is equivalent to the\n      PLPMTU derived by PLPMTUD
    plus the size of any headers added below\n      the PL, including the IP layer
    headers.\n   EMTU_S:  The effective MTU for sending (EMTU_S) is defined in\n      [RFC1122]
    as \"the maximum IP datagram size that may be sent, for a\n      particular combination
    of IP source and destination addresses...\".\n   EMTU_R:  The effective MTU for
    receiving (EMTU_R) is designated in\n      [RFC1122] as \"the largest datagram
    size that can be reassembled\".\n   Link:  A link is a communication facility
    or medium over which nodes\n      can communicate at the link layer, i.e., a layer
    below the IP\n      layer.  Examples are Ethernet LANs and Internet (or higher)
    layer\n      tunnels.\n   Link MTU:  The link Maximum Transmission Unit (MTU)
    is the size in\n      bytes of the largest IP packet, including the IP header
    and\n      payload, that can be transmitted over a link.  Note that this\n      could
    more properly be called the IP MTU, to be consistent with\n      how other standards
    organizations use the acronym.  This includes\n      the IP header but excludes
    link layer headers and other framing\n      that is not part of IP or the IP payload.
    \ Other standards\n      organizations generally define the link MTU to include
    the link\n      layer headers.  This specification continues the requirement in\n
    \     [RFC4821] that states, \"All links MUST enforce their MTU: links\n      that
    might non-deterministically deliver packets that are larger\n      than their
    rated MTU MUST consistently discard such packets.\"\n   MAX_PLPMTU:  The MAX_PLPMTU
    is the largest size of PLPMTU that\n      DPLPMTUD will attempt to use (see the
    constants defined in\n      Section 5.1.2).\n   MIN_PLPMTU:  The MIN_PLPMTU is
    the smallest size of PLPMTU that\n      DPLPMTUD will attempt to use (see the
    constants defined in\n      Section 5.1.2).\n   MPS:  The Maximum Packet Size
    (MPS) is the largest size of\n      application data block that can be sent across
    a network path by a\n      PL using a single datagram (see Section 4.4).\n   MSL:
    \ The Maximum Segment Lifetime (MSL) is the maximum delay a\n      packet is expected
    to experience across a path, taken as 2 minutes\n      [BCP145].\n   Packet:  A
    packet is the IP header(s) and any extension headers/\n      options plus the
    IP payload.\n   Packetization Layer (PL):  The PL is a layer of the network stack\n
    \     that places data into packets and performs transport protocol\n      functions.
    \ Examples of a PL include TCP, SCTP, SCTP over UDP,\n      SCTP over DTLS, or
    QUIC.\n   Path:  The path is the set of links and routers traversed by a packet\n
    \     between a source node and a destination node by a particular flow.\n   Path
    MTU (PMTU):  The Path MTU (PMTU) is the minimum of the link MTU\n      of all
    the links forming a network path between a source node and\n      a destination
    node, as used by PMTUD.\n   PTB:  In this document, the term PTB message is applied
    to both IPv4\n      ICMP Unreachable messages (Type 3) that carry the error\n
    \     Fragmentation Needed (Type 3, Code 4) [RFC0792] and ICMPv6 Packet\n      Too
    Big messages (Type 2) [RFC4443].\n   PTB_SIZE:  The PTB_SIZE is a value reported
    in a validated PTB\n      message that indicates next-hop link MTU of a router
    along the\n      path.\n   PL_PTB_SIZE:  The size reported in a validated PTB
    message, reduced\n      by the size of all headers added by layers below the PL.\n
    \  PLPMTU:  The Packetization Layer PMTU is an estimate of the largest\n      size
    of PL datagram that can be sent by a path, controlled by\n      PLPMTUD.\n   PLPMTUD:
    \ Packetization Layer Path MTU Discovery (PLPMTUD), the\n      method described
    in this document for datagram PLs, which is an\n      extension to Classical PMTU
    Discovery.\n   Probe packet:  A probe packet is a datagram sent with a purposely\n
    \     chosen size (typically the current PLPMTU or larger) to detect if\n      packets
    of this size can be successfully sent end-to-end across\n      the network path.\n
    \  Unacknowledged PL:  A PL that does not itself provide a mechanism to\n      confirm
    delivery of datagrams to the remote PL endpoint (e.g.,\n      UDP), and therefore
    requires DPLPMTUD to provide a mechanism to\n      detect black-holing of packets
    (c.f., Acknowledged PL).\n"
  title: 2.  Terminology
- contents:
  - "3.  Features Required to Provide Datagram PLPMTUD\n   The principles expressed
    in [RFC4821] apply to the use of the\n   technique with any PL.  TCP PLPMTUD has
    been defined using standard\n   TCP protocol mechanisms.  Unlike TCP, a datagram
    PL requires\n   additional mechanisms and considerations to implement PLPMTUD.\n
    \  The requirements for datagram PLPMTUD are:\n   1.  Managing the PLPMTU: For
    datagram PLs, the PLPMTU is managed by\n       DPLPMTUD.  A PL MUST NOT send a
    datagram (other than a probe\n       packet) with a size at the PL that is larger
    than the current\n       PLPMTU.\n   2.  Probe packets: The network interface
    below the PL is REQUIRED to\n       provide a way to transmit a probe packet that
    is larger than the\n       PLPMTU.  In IPv4, a probe packet MUST be sent with
    the Don't\n       Fragment (DF) bit set in the IP header and without network layer\n
    \      endpoint fragmentation.  In IPv6, a probe packet is always sent\n       without
    source fragmentation (as specified in Section 5.4 of\n       [RFC8201]).\n   3.
    \ Reception feedback: The destination PL endpoint is REQUIRED to\n       provide
    a feedback method that indicates to the DPLPMTUD sender\n       when a probe packet
    has been received by the destination PL\n       endpoint.  Section 6 provides
    examples of how a PL can provide\n       this acknowledgment of received probe
    packets.\n   4.  Probe loss recovery: It is RECOMMENDED to use probe packets that\n
    \      do not carry any user data that would require retransmission if\n       lost.
    \ Most datagram transports permit this.  If a probe packet\n       contains user
    data requiring retransmission in case of loss, the\n       PL (or layers above)
    is REQUIRED to arrange any retransmission\n       and/or repair of any resulting
    loss.  The PL is REQUIRED to be\n       robust in the case where probe packets
    are lost due to other\n       reasons (including link transmission error, congestion).\n
    \  5.  PMTU parameters: A DPLPMTUD sender is RECOMMENDED to utilize\n       information
    about the maximum size of packet that can be\n       transmitted by the sender
    on the local link (e.g., the local link\n       MTU).  A PL sender MAY utilize
    similar information about the\n       maximum size of network-layer packet that
    a receiver can accept\n       when this is supplied (note this could be less than
    EMTU_R).\n       This avoids implementations trying to send probe packets that\n
    \      cannot be transferred by the local link.  Too high of a value\n       could
    reduce the efficiency of the search algorithm.  Some\n       applications also
    have a maximum transport protocol data unit\n       (PDU) size, in which case
    there is no benefit from probing for a\n       size larger than this (unless a
    transport allows multiplexing\n       multiple applications' PDUs into the same
    datagram).\n   6.  Processing PTB messages: A DPLPMTUD sender MAY optionally utilize\n
    \      PTB messages received from the network layer to help identify\n       when
    a network path does not support the current size of probe\n       packet.  Any
    received PTB message MUST be validated before it is\n       used to update the
    PLPMTU discovery information [RFC8201].  This\n       validation confirms that
    the PTB message was sent in response to\n       a packet originated by the sender
    and needs to be performed\n       before the PLPMTU discovery method reacts to
    the PTB message.  A\n       PTB message MUST NOT be used to increase the PLPMTU
    [RFC8201] but\n       could trigger a probe to test for a larger PLPMTU.  A valid\n
    \      PTB_SIZE is converted to a PL_PTB_SIZE before it is to be used in\n       the
    DPLPMTUD state machine.  A PL_PTB_SIZE that is greater than\n       that currently
    probed SHOULD be ignored.  (This PTB message ought\n       to be discarded without
    further processing but could be utilized\n       as an input that enables a resilience
    mode).\n   7.  Probing and congestion control: A PL MAY use a congestion\n       controller
    to decide when to send a probe packet.  If\n       transmission of probe packets
    is limited by the congestion\n       controller, this could result in transmission
    of probe packets\n       being delayed or suspended during congestion.  When the\n
    \      transmission of probe packets is not controlled by the congestion\n       controller,
    the interval between probe packets MUST be at least\n       one RTT.  Loss of
    a probe packet SHOULD NOT be treated as an\n       indication of congestion and
    SHOULD NOT trigger a congestion\n       control reaction [RFC4821] because this
    could result in\n       unnecessary reduction of the sending rate.  An update
    to the\n       PLPMTU (or MPS) MUST NOT increase the congestion window measured\n
    \      in bytes [RFC4821].  Therefore, an increase in the packet size\n       does
    not cause an increase in the data rate in bytes per second.\n       A PL that
    maintains the congestion window in terms of a limit to\n       the number of outstanding
    fixed-size packets SHOULD adapt this\n       limit to compensate for the size
    of the actual packets.  The\n       transmission of probe packets can interact
    with the operation of\n       a PL that performs burst mitigation or pacing, and
    the PL could\n       need transmission of probe packets to be regulated by these\n
    \      methods.\n   8.  Probing and flow control: Flow control at the PL concerns
    the\n       end-to-end flow of data using the PL service.  Flow control\n       SHOULD
    NOT apply to DPLPMTU when probe packets use a design that\n       does not carry
    user data to the remote application.\n   9.  Shared PLPMTU state: The PMTU value
    calculated from the PLPMTU\n       MAY also be stored with the corresponding entry
    associated with\n       the destination in the IP layer cache and used by other
    PL\n       instances.  The specification of PLPMTUD [RFC4821] states, \"If\n       PLPMTUD
    updates the MTU for a particular path, all Packetization\n       Layer sessions
    that share the path representation (as described\n       in Section 5.2) SHOULD
    be notified to make use of the new MTU\".\n       Such methods MUST be robust
    to the wide variety of underlying\n       network forwarding behaviors.  Section
    5.2 of [RFC8201] provides\n       guidance on the caching of PMTU information
    and also the relation\n       to IPv6 flow labels.\n   In addition, the following
    principles are stated for design of a\n   DPLPMTUD method:\n   *  A PL MAY be
    designed to segment data blocks larger than the MPS\n      into multiple datagrams.
    \ However, not all datagram PLs support\n      segmentation of data blocks.  It
    is RECOMMENDED that methods avoid\n      forcing an application to use an arbitrary
    small MPS for\n      transmission while the method is searching for the currently\n
    \     supported PLPMTU.  A reduced MPS can adversely impact the\n      performance
    of an application.\n   *  To assist applications in choosing a suitable data block
    size, the\n      PL is RECOMMENDED to provide a primitive that returns the MPS\n
    \     derived from the PLPMTU to the higher layer using the PL.  The\n      value
    of the MPS can change following a change in the path or loss\n      of probe packets.\n
    \  *  Path validation: It is RECOMMENDED that methods are robust to path\n      changes
    that could have occurred since the path characteristics\n      were last confirmed
    and to the possibility of inconsistent path\n      information being received.\n
    \  *  Datagram reordering: A method is REQUIRED to be robust to the\n      possibility
    that a flow encounters reordering or that the traffic\n      (including probe
    packets) is divided over more than one network\n      path.\n   *  Datagram delay
    and duplication: The feedback mechanism is REQUIRED\n      to be robust to the
    possibility that packets could be\n      significantly delayed or duplicated along
    a network path.\n   *  When to probe: It is RECOMMENDED that methods determine
    whether\n      the path has changed since it last measured the path.  This can\n
    \     help determine when to probe the path again.\n"
  title: 3.  Features Required to Provide Datagram PLPMTUD
- contents:
  - "4.  DPLPMTUD Mechanisms\n   This section lists the protocol mechanisms used in
    this\n   specification.\n"
  - contents:
    - "4.1.  PLPMTU Probe Packets\n   The DPLPMTUD method relies upon the PL sender
      being able to generate\n   probe packets with a specific size.  TCP is able
      to generate these\n   probe packets by choosing to appropriately segment data
      being sent\n   [RFC4821].  In contrast, a datagram PL that constructs a probe
      packet\n   has to either request an application to send a data block that is\n
      \  larger than that generated by an application, or to utilize padding\n   functions
      to extend a datagram beyond the size of the application\n   data block.  Protocols
      that permit exchange of control messages\n   (without an application data block)
      can generate a probe packet by\n   extending a control message with padding
      data.  The total size of a\n   probe packet includes all headers and padding
      added to the payload\n   data being sent (e.g., including protocol option fields,
      security-\n   related fields such as an Authenticated Encryption with Associated\n
      \  Data (AEAD) tag, and TLS record layer padding).\n   A receiver is REQUIRED
      to be able to distinguish an in-band data\n   block from any added padding.
      \ This is needed to ensure that any\n   added padding is not passed on to an
      application at the receiver.\n   This results in three possible ways that a
      sender can create a probe\n   packet:\n   Probing using padding data:  A probe
      packet that contains only\n      control information together with any padding,
      which is needed to\n      inflate to the size of the probe packet.  Since these
      probe\n      packets do not carry an application-supplied data block, they do\n
      \     not typically require retransmission, although they do still\n      consume
      network capacity and incur endpoint processing.\n   Probing using application
      data and padding data:  A probe packet that\n      contains a data block supplied
      by an application that is combined\n      with padding to inflate the length
      of the datagram to the size of\n      the probe packet.\n   Probing using application
      data:  A probe packet that contains a data\n      block supplied by an application
      that matches the size of the\n      probe packet.  This method requests the
      application to issue a\n      data block of the desired probe size.\n   A PL
      that uses a probe packet carrying application data and that\n   needs protection
      from the loss of this probe packet could perform\n   transport-layer retransmission/repair
      of the data block (e.g., by\n   retransmitting after loss is detected or by
      duplicating the data\n   block in a datagram without the padding data).  This
      retransmitted\n   data block might possibly need to be sent using a smaller
      PLPMTU,\n   which could force the PL to use a smaller packet size to traverse
      the\n   end-to-end path.  (This could utilize endpoint network-layer\n   fragmentation
      or a PL that can resegment the data block into multiple\n   datagrams).\n   DPLPMTUD
      MAY choose to use only one of these methods to simplify the\n   implementation.\n
      \  Probe messages sent by a PL MUST contain enough information to\n   uniquely
      identify the probe within the Maximum Segment Lifetime\n   (e.g., including
      a unique identifier from the PL or the DPLPMTUD\n   implementation), while being
      robust to reordering and replay of probe\n   response and PTB messages.\n"
    title: 4.1.  PLPMTU Probe Packets
  - contents:
    - "4.2.  Confirmation of Probed Packet Size\n   The PL needs a method to determine
      (confirm) when probe packets have\n   been successfully received end-to-end
      across a network path.\n   Transport protocols can include end-to-end methods
      that detect and\n   report reception of specific datagrams that they send (e.g.,
      DCCP,\n   SCTP, and QUIC provide keep-alive/heartbeat features).  When\n   supported,
      this mechanism MAY also be used by DPLPMTUD to acknowledge\n   reception of
      a probe packet.\n   A PL that does not acknowledge data reception (e.g., UDP
      and UDP-\n   Lite) is unable itself to detect when the packets that it sends
      are\n   discarded because their size is greater than the actual PMTU.  These\n
      \  PLs need to rely on an application protocol to detect this loss.\n   Section
      6 specifies this function for a set of IETF-specified\n   protocols.\n"
    title: 4.2.  Confirmation of Probed Packet Size
  - contents:
    - "4.3.  Black Hole Detection and Reducing the PLPMTU\n   The description that
      follows uses the set of constants defined in\n   Section 5.1.2 and variables
      defined in Section 5.1.3.\n   Black hole detection is triggered by an indication
      that the network\n   path could be unable to support the current PLPMTU size.\n
      \  There are three indicators that can be used to detect black holes:\n   *
      \ A validated PTB message can be received that indicates a\n      PL_PTB_SIZE
      less than the current PLPMTU.  A DPLPMTUD method MUST\n      NOT rely solely
      on this method.\n   *  A PL can use the DPLPMTUD probing mechanism to periodically\n
      \     generate probe packets of the size of the current PLPMTU (e.g.,\n      using
      the CONFIRMATION_TIMER, Section 5.1.1).  A timer tracks\n      whether acknowledgments
      are received.  Successive loss of probes\n      is an indication that the current
      path no longer supports the\n      PLPMTU (e.g., when the number of probe packets
      sent without\n      receiving an acknowledgment, PROBE_COUNT, becomes greater
      than\n      MAX_PROBES).\n   *  A PL can utilize an event that indicates the
      network path no\n      longer sustains the sender's PLPMTU size.  This could
      use a\n      mechanism implemented within the PL to detect excessive loss of\n
      \     data sent with a specific packet size and then conclude that this\n      excessive
      loss could be a result of an invalid PLPMTU (as in\n      PLPMTUD for TCP [RFC4821]).\n
      \  The three methods can result in different transmission patterns for\n   packet
      probes and are expected to result in different responsiveness\n   following
      a change in the actual PMTU.\n   A PL MAY inhibit sending probe packets when
      no application data has\n   been sent since the previous probe packet.  A PL
      that resumes sending\n   user data MAY continue PLPMTU discovery for each path.
      \ This allows\n   it to use an up-to-date PLPMTU.  However, this could result
      in\n   additional packets being sent.\n   When the method detects that the current
      PLPMTU is not supported,\n   DPLPMTUD sets a lower PLPMTU and a lower MPS.  The
      PL then confirms\n   that the new PLPMTU can be successfully used across the
      path.  A\n   probe packet could need to be smaller than the size of the data
      block\n   generated by the application.\n"
    title: 4.3.  Black Hole Detection and Reducing the PLPMTU
  - contents:
    - "4.4.  The Maximum Packet Size (MPS)\n   The result of probing determines a
      usable PLPMTU, which is used to\n   set the MPS used by the application.  The
      MPS is smaller than the\n   PLPMTU because it is reduced by the size of PL headers
      (including the\n   overhead of security-related fields such as an AEAD tag and
      TLS\n   record layer padding).  The relationship between the MPS and the\n   PLPMTUD
      is illustrated in Figure 1.\n   Any additional\n     headers         .--- MPS
      -----.\n            v        v             v\n     | IP | ** | PL | protocol
      data |\n                <----- PLPMTU ----->\n     <---------- PMTU -------------->\n
      \              Figure 1: Relationship between MPS and PLPMTU\n   A PL is unable
      to send a packet (other than a probe packet) with a\n   size larger than the
      current PLPMTU at the network layer.  To avoid\n   this, a PL MAY be designed
      to segment data blocks larger than the MPS\n   into multiple datagrams.\n   DPLPMTUD
      seeks to avoid IP fragmentation.  An attempt to send a data\n   block larger
      than the MPS will therefore fail if a PL is unable to\n   segment data.  To
      determine the largest data block that can be sent,\n   a PL SHOULD provide applications
      with a primitive that returns the\n   MPS, derived from the current PLPMTU.\n
      \  If DPLPMTUD results in a change to the MPS, the application needs to\n   adapt
      to the new MPS.  A particular case can arise when packets have\n   been sent
      with a size less than the MPS and the PLPMTU was\n   subsequently reduced.  If
      these packets are lost, the PL MAY segment\n   the data using the new MPS.  If
      a PL is unable to resegment a\n   previously sent datagram (e.g., [RFC4960]),
      then the sender either\n   discards the datagram or could perform retransmission
      using network-\n   layer fragmentation to form multiple IP packets not larger
      than the\n   PLPMTU.  For IPv4, the use of endpoint fragmentation by the sender
      is\n   preferred over clearing the DF bit in the IPv4 header.  Operational\n
      \  experience reveals that IP fragmentation can reduce the reliability\n   of
      Internet communication [RFC8900], which may reduce the probability\n   of successful
      retransmission.\n"
    title: 4.4.  The Maximum Packet Size (MPS)
  - contents:
    - "4.5.  Disabling the Effect of PMTUD\n   A PL implementing this specification
      MUST suspend network layer\n   processing of outgoing packets that enforces
      a PMTU\n   [RFC1191][RFC8201] for each flow utilizing DPLPMTUD and instead use\n
      \  DPLPMTUD to control the size of packets that are sent by a flow.\n   This
      removes the need for the network layer to drop or to fragment\n   sent packets
      that have a size greater than the PMTU.\n"
    title: 4.5.  Disabling the Effect of PMTUD
  - contents:
    - "4.6.  Response to PTB Messages\n   This method requires the DPLPMTUD sender
      to validate any received PTB\n   message before using the PTB information.  The
      response to a PTB\n   message depends on the PL_PTB_SIZE calculated from the
      PTB_SIZE in\n   the PTB message, the state of the PLPMTUD state machine, and
      the IP\n   protocol being used.\n   Section 4.6.1 describes validation for both
      IPv4 ICMP Unreachable\n   messages (Type 3) and ICMPv6 Packet Too Big messages,
      both of which\n   are referred to as PTB messages in this document.\n"
    - contents:
      - "4.6.1.  Validation of PTB Messages\n   This section specifies utilization
        and validation of PTB messages.\n   *  A simple implementation MAY ignore
        received PTB messages, and in\n      this case, the PLPMTU is not updated
        when a PTB message is\n      received.\n   *  A PL that supports PTB messages
        MUST validate these messages\n      before they are further processed.\n   A
        PL that receives a PTB message from a router or middlebox performs\n   ICMP
        validation (see Section 4 of [RFC8201] and Section 5.2 of\n   [BCP145]).  Because
        DPLPMTUD operates at the PL, the PL needs to\n   check that each received
        PTB message is received in response to a\n   packet transmitted by the endpoint
        PL performing DPLPMTUD.\n   The PL MUST check the protocol information in
        the quoted packet\n   carried in an ICMP PTB message payload to validate the
        message\n   originated from the sending node.  This validation includes\n
        \  determining that the combination of the IP addresses, the protocol,\n   the
        source port, and destination port match those returned in the\n   quoted packet
        -- this is also necessary for the PTB message to be\n   passed to the corresponding
        PL.\n   The validation SHOULD utilize information that is not simple for an\n
        \  off-path attacker to determine [BCP145].  For example, it could check\n
        \  the value of a protocol header field known only to the two PL\n   endpoints.
        \ A datagram application that uses well-known source and\n   destination ports
        ought to also rely on other information to complete\n   this validation.\n
        \  These checks are intended to provide protection from packets that\n   originate
        from a node that is not on the network path.  A PTB message\n   that does
        not complete the validation MUST NOT be further utilized by\n   the DPLPMTUD
        method, as discussed in the Security Considerations\n   section (Section 8).\n
        \  Section 4.6.2 describes this processing of PTB messages.\n"
      title: 4.6.1.  Validation of PTB Messages
    - contents:
      - "4.6.2.  Use of PTB Messages\n   PTB messages that have been validated MAY
        be utilized by the DPLPMTUD\n   algorithm but MUST NOT be used directly to
        set the PLPMTU.\n   Before using the size reported in the PTB message, it
        must first be\n   converted to a PL_PTB_SIZE.  The PL_PTB_SIZE is smaller
        than the\n   PTB_SIZE because it is reduced by headers below the PL, including
        any\n   IP options or extensions added to the PL packet.\n   A method that
        utilizes these PTB messages can improve the speed at\n   which the algorithm
        detects an appropriate PLPMTU by triggering an\n   immediate probe for the
        PL_PTB_SIZE (resulting in a network-layer\n   packet of size PTB_SIZE), compared
        to one that relies solely on\n   probing using a timer-based search algorithm.\n
        \  A set of checks are intended to provide protection from a router that\n
        \  reports an unexpected PTB_SIZE.  The PL also needs to check that the\n
        \  indicated PL_PTB_SIZE is less than the size used by probe packets and\n
        \  at least the minimum size accepted.\n   This section provides a summary
        of how PTB messages can be utilized,\n   using the set of constants defined
        in Section 5.1.2.  This processing\n   depends on the PL_PTB_SIZE and the
        current value of a set of\n   variables:\n   PL_PTB_SIZE < MIN_PLPMTU\n      *
        \ Invalid PL_PTB_SIZE, see Section 4.6.1.\n      *  PTB message ought to be
        discarded without further processing\n         (i.e., PLPMTU is not modified).\n
        \     *  The information could be utilized as an input that triggers the\n
        \        enabling of a resilience mode (see Section 5.3.3).\n   MIN_PLPMTU
        < PL_PTB_SIZE < BASE_PLPMTU\n      *  A robust PL MAY enter an error state
        (see Section 5.2) for an\n         IPv4 path when the PL_PTB_SIZE reported
        in the PTB message is\n         larger than or equal to 68 bytes [RFC0791]
        and when this is\n         less than the BASE_PLPMTU.\n      *  A robust PL
        MAY enter an error state (see Section 5.2) for an\n         IPv6 path when
        the PL_PTB_SIZE reported in the PTB message is\n         larger than or equal
        to 1280 bytes [RFC8200] and when this is\n         less than the BASE_PLPMTU.\n
        \  BASE_PLPMTU <= PL_PTB_SIZE < PLPMTU\n      *  This could be an indication
        of a black hole.  The PLPMTU SHOULD\n         be set to BASE_PLPMTU (the PLPMTU
        is reduced to the BASE_PLPMTU\n         to avoid unnecessary packet loss when
        a black hole is\n         encountered).\n      *  The PL ought to start a
        search to quickly discover the new\n         PLPMTU.  The PL_PTB_SIZE reported
        in the PTB message can be\n         used to initialize a search algorithm.\n
        \  PLPMTU < PL_PTB_SIZE < PROBED_SIZE\n      *  The PLPMTU continues to be
        valid, but the size of a packet used\n         to search (PROBED_SIZE) was
        larger than the actual PMTU.\n      *  The PLPMTU is not updated.\n      *
        \ The PL can use the reported PL_PTB_SIZE from the PTB message as\n         the
        next search point when it resumes the search algorithm.\n   PL_PTB_SIZE >=
        PROBED_SIZE\n      *  Inconsistent network signal.\n      *  PTB message ought
        to be discarded without further processing\n         (i.e., PLPMTU is not
        modified).\n      *  The information could be utilized as an input to trigger
        the\n         enabling of a resilience mode.\n"
      title: 4.6.2.  Use of PTB Messages
    title: 4.6.  Response to PTB Messages
  title: 4.  DPLPMTUD Mechanisms
- contents:
  - "5.  Datagram Packetization Layer PMTUD\n   This section specifies Datagram PLPMTUD
    (DPLPMTUD).  The method can\n   be introduced at various points (as indicated
    with * in Figure 2) in\n   the IP protocol stack to discover the PLPMTU so that
    an application\n   can utilize an appropriate MPS for the current network path.\n
    \  DPLPMTUD SHOULD only be performed at one layer between a pair of\n   endpoints.
    \ Therefore, an upper PL or application should avoid using\n   DPLPMTUD when this
    is already enabled in a lower layer.  A PL MUST\n   adjust the MPS indicated by
    DPLPMTUD to account for any additional\n   overhead introduced by the PL.\n   +----------------------+\n
    \  |     Application*     |\n   +-----+------------+---+\n         |            |\n
    \    +---+--+      +--+--+\n     | QUIC*|      |SCTP*|\n     +---+--+      +-+-+-+\n
    \        |           | |\n         +---+  +----+ |\n             |  |      |\n
    \          +-+--+-+    |\n           | UDP  |    |\n           +---+--+    |\n
    \              |       |\n   +-----------+-------+--+\n   |  Network Interface
    \  |\n   +----------------------+\n            Figure 2: Examples Where DPLPMTUD
    Can Be Implemented\n   The central idea of DPLPMTUD is probing by a sender.  Probe
    packets\n   are sent to find the maximum size of user message that can be\n   completely
    transferred across the network path from the sender to the\n   destination.\n
    \  The following sections identify the components needed for\n   implementation,
    provide an overview of the phases of operation, and\n   specify the state machine
    and search algorithm.\n"
  - contents:
    - "5.1.  DPLPMTUD Components\n   This section describes the timers, constants,
      and variables of\n   DPLPMTUD.\n"
    - contents:
      - "5.1.1.  Timers\n   The method utilizes up to three timers:\n   PROBE_TIMER:
        \ The PROBE_TIMER is configured to expire after a period\n      longer than
        the maximum time to receive an acknowledgment to a\n      probe packet.  This
        value MUST NOT be smaller than 1 second and\n      SHOULD be larger than 15
        seconds.  Guidance on the selection of\n      the timer value is provided
        in Section 3.1.1 of the UDP Usage\n      Guidelines [BCP145].\n   PMTU_RAISE_TIMER:
        \ The PMTU_RAISE_TIMER is configured to the period a\n      sender will continue
        to use the current PLPMTU, after which it\n      reenters the Search Phase.
        \ This timer has a period of 600\n      seconds, as recommended by PLPMTUD
        [RFC4821].\n      DPLPMTUD MAY inhibit sending probe packets when no application\n
        \     data has been sent since the previous probe packet.  A PL\n      preferring
        to use an up-to-date PMTU once user data is sent again\n      can choose to
        continue PMTU discovery for each path.  However,\n      this will result in
        sending additional packets.\n   CONFIRMATION_TIMER:  When an acknowledged
        PL is used, this timer MUST\n      NOT be used.  For other PLs, the CONFIRMATION_TIMER
        is configured\n      to the period a PL sender waits before confirming the
        current\n      PLPMTU is still supported.  This is less than the PMTU_RAISE_TIMER\n
        \     and used to decrease the PLPMTU (e.g., when a black hole is\n      encountered).
        \ Confirmation needs to be frequent enough when data\n      is flowing that
        the sending PL does not black hole extensive\n      amounts of traffic.  Guidance
        on selection of the timer value are\n      provided in Section 3.1.1 of the
        UDP Usage Guidelines [BCP145].\n      DPLPMTUD MAY inhibit sending probe packets
        when no application\n      data has been sent since the previous probe packet.
        \ A PL\n      preferring to use an up-to-date PMTU once user data is sent
        again,\n      can choose to continue PMTU discovery for each path.  However,\n
        \     this could result in sending additional packets.\n   DPLPMTUD specifies
        various timers; however, an implementation could\n   choose to realize these
        timer functions using a single timer.\n"
      title: 5.1.1.  Timers
    - contents:
      - "5.1.2.  Constants\n   The following constants are defined:\n   MAX_PROBES:
        \ The MAX_PROBES is the maximum value of the PROBE_COUNT\n      counter (see
        Section 5.1.3).  MAX_PROBES represents the limit for\n      the number of
        consecutive probe attempts of any size.  Search\n      algorithms benefit
        from a MAX_PROBES value greater than 1 because\n      this can provide robustness
        to isolated packet loss.  The default\n      value of MAX_PROBES is 3.\n   MIN_PLPMTU:
        \ The MIN_PLPMTU is the smallest size of PLPMTU that\n      DPLPMTUD will
        attempt to use.  An endpoint could need to configure\n      the MIN_PLPMTU
        to provide space for extension headers and other\n      encapsulations at
        layers below the PL.  This value can be\n      interface and path dependent.
        \ For IPv6, this size is greater than\n      or equal to the size at the PL
        that results in an 1280-byte IPv6\n      packet, as specified in [RFC8200].
        \ For IPv4, this size is greater\n      than or equal to the size at the PL
        that results in an 68-byte\n      IPv4 packet.  Note: An IPv4 router is required
        to be able to\n      forward a datagram of 68 bytes without further fragmentation.\n
        \     This is the combined size of an IPv4 header and the minimum\n      fragment
        size of 8 bytes.  In addition, receivers are required to\n      be able to
        reassemble fragmented datagrams at least up to 576\n      bytes, as stated
        in Section 3.3.3 of [RFC1122].\n   MAX_PLPMTU:  The MAX_PLPMTU is the largest
        size of PLPMTU.  This has\n      to be less than or equal to the maximum size
        of the PL packet that\n      can be sent on the outgoing interface (constrained
        by the local\n      interface MTU).  When known, this also ought to be less
        than the\n      maximum size of PL packet that can be received by the remote\n
        \     endpoint (constrained by EMTU_R).  It can be limited by the design\n
        \     or configuration of the PL being used.  An application, or PL, MAY\n
        \     choose a smaller MAX_PLPMTU when there is no need to send packets\n
        \     larger than a specific size.\n   BASE_PLPMTU:  The BASE_PLPMTU is a
        configured size expected to work\n      for most paths.  The size is equal
        to or larger than the\n      MIN_PLPMTU and smaller than the MAX_PLPMTU.  For
        most PLs, a\n      suitable BASE_PLPMTU will be larger than 1200 bytes.  When
        using\n      IPv4, there is no currently equivalent size specified, and a\n
        \     default BASE_PLPMTU of 1200 bytes is RECOMMENDED.\n"
      title: 5.1.2.  Constants
    - contents:
      - "5.1.3.  Variables\n   This method utilizes a set of variables:\n   PROBED_SIZE:
        \ The PROBED_SIZE is the size of the current probe packet\n      as determined
        at the PL.  This is a tentative value for the\n      PLPMTU, which is awaiting
        confirmation by an acknowledgment.\n   PROBE_COUNT:  The PROBE_COUNT is a
        count of the number of successive\n      unsuccessful probe packets that have
        been sent.  Each time a probe\n      packet is acknowledged, the value is
        set to zero.  (Some probe\n      loss is expected while searching, therefore
        loss of a single probe\n      is not an indication of a PMTU problem.)\n   Figure
        3 illustrates the relationship between the packet size\n   constants and variables
        at a point of time when the DPLPMTUD\n   algorithm performs path probing to
        increase the size of the PLPMTU.\n   A probe packet has been sent of size
        PROBED_SIZE.  Once this is\n   acknowledged, the PLPMTU will raise to PROBED_SIZE,
        allowing the\n   DPLPMTUD algorithm to further increase PROBED_SIZE toward
        sending a\n   probe with the size of the actual PMTU.\n        MIN_PLPMTU
        \                               MAX_PLPMTU\n                         v        |
        \    |\n                   BASE_PLPMTU    |     v\n    Figure 3: Relationships
        between Packet Size Constants and Variables\n"
      title: 5.1.3.  Variables
    - contents:
      - "5.1.4.  Overview of DPLPMTUD Phases\n   This section provides a high-level,
        informative view of the DPLPMTUD\n   method, by describing the movement of
        the method through several\n   phases of operation.  More detail is available
        in the state machine,\n   Section 5.2.\n              +------->| Base |-----------------+
        Connectivity\n              |           | Connectivity    +-------+\n              |
        \          | and BASE_PLPMTU | Error |\n              |           | confirmed
        \      +-------+\n              |           v                     | connectivity\n
        \  Black Hole |       +--------+                | and BASE_PLPMTU\n    detected
        \ |       | Search |<---------------+ confirmed\n              |          ^
        \ |\n              |          |  |\n              |    Raise |  | Search\n
        \             |    timer |  | algorithm\n              |  expired |  | completed\n
        \             |          |  |\n              |          |  v\n              +---|
        Search Complete |\n                         Figure 4: DPLPMTUD Phases\n   Base:
        \ The Base Phase confirms connectivity to the remote peer using\n      packets
        of the BASE_PLPMTU.  The confirmation of connectivity is\n      implicit for
        a connection-oriented PL (where it can be performed\n      in a PL connection
        handshake).  A connectionless PL sends a probe\n      packet and uses acknowledgment
        of this probe packet to confirm\n      that the remote peer is reachable.\n
        \     The sender also confirms that BASE_PLPMTU is supported across the\n
        \     network path.  This may be achieved by using a PL mechanism (e.g.,\n
        \     using a handshake packet of size BASE_PLPMTU) or by sending a\n      probe
        packet of size BASE_PLPMTU and confirming that this is\n      received.\n
        \     A probe packet of size BASE_PLPMTU can be sent immediately on the\n
        \     initial entry to the Base Phase (following a connectivity check).\n
        \     A PL that does not wish to support a path with a PLPMTU less than\n
        \     BASE_PLPMTU can simplify the phase into a single step by\n      performing
        the connectivity checks with a probe of the BASE_PLPMTU\n      size.\n      Once
        confirmed, DPLPMTUD enters the Search Phase.  If the Base\n      Phase fails
        to confirm the BASE_PLPMTU, DPLPMTUD enters the Error\n      Phase.\n   Search:
        \ The Search Phase utilizes a search algorithm to send probe\n      packets
        to seek to increase the PLPMTU.  The algorithm concludes\n      when it has
        found a suitable PLPMTU by entering the Search\n      Complete Phase.\n      A
        PL could respond to PTB messages using the PTB to advance or\n      terminate
        the search, see Section 4.6.\n   Search Complete:  The Search Complete Phase
        is entered when the\n      PLPMTU is supported across the network path.  A
        PL can use a\n      CONFIRMATION_TIMER to periodically repeat a probe packet
        for the\n      current PLPMTU size.  If the sender is unable to confirm\n
        \     reachability (e.g., if the CONFIRMATION_TIMER expires) or the PL\n      signals
        a lack of reachability, a black hole has been detected and\n      DPLPMTUD
        enters the Base Phase.\n      The PMTU_RAISE_TIMER is used to periodically
        resume the Search\n      Phase to discover if the PLPMTU can be raised.  Black
        hole\n      detection causes the sender to enter the Base Phase.\n   Error:
        \ The Error Phase is entered when there is conflicting or\n      invalid PLPMTU
        information for the path (e.g., a failure to\n      support the BASE_PLPMTU)
        that causes DPLPMTUD to be unable to\n      progress, and the PLPMTU is lowered.\n
        \     DPLPMTUD remains in the Error Phase until a consistent view of the\n
        \     path can be discovered and it has also been confirmed that the\n      path
        supports the BASE_PLPMTU (or DPLPMTUD is suspended).\n   A method that only
        reduces the PLPMTU to a suitable size would be\n   sufficient to ensure reliable
        operation but can be very inefficient\n   when the actual PMTU changes or
        when the method (for whatever reason)\n   makes a suboptimal choice for the
        PLPMTU.\n   A full implementation of DPLPMTUD provides an algorithm enabling
        the\n   DPLPMTUD sender to increase the PLPMTU following a change in the\n
        \  characteristics of the path, such as when a link is reconfigured with\n
        \  a larger MTU, or when there is a change in the set of links traversed\n
        \  by an end-to-end flow (e.g., after a routing or path failover\n   decision).\n"
      title: 5.1.4.  Overview of DPLPMTUD Phases
    title: 5.1.  DPLPMTUD Components
  - contents:
    - "5.2.  State Machine\n   A state machine for DPLPMTUD is depicted in Figure
      5.  If multipath\n   or multihoming is supported, a state machine is needed
      for each path.\n   Note: Not all changes are shown to simplify the diagram.\n
      \     |         |\n      | Start   | PL indicates loss\n      |         |  of
      connectivity\n      v         v\n   |    DISABLED   |                                   |
      \    ERROR     |\n           | PL indicates     PROBE_COUNT = MAX_PROBES or
      \   ^      |\n           | connectivity  PTB: PL_PTB_SIZE < BASE_PLPMTU    |
      \     |\n            Black hole detected | |    |  | Black hole detected     |\n
      \          |                PROBE_TIMER expiry:                |    |\n           |
      \            PROBE_COUNT < MAX_PROBES              |    |\n           |               PMTU_RAISE_TIMER
      expiry             |    |\n   |SEARCH_COMPLETE|                                   |
      \  SEARCHING   |\n      |    |            MAX_PLPMTU Probe acked or              |
      \   |\n      |    |  PROBE_TIMER expiry: PROBE_COUNT = MAX_PROBES or  |    |\n
      \     +----+            PTB: PL_PTB_SIZE = PLPMTU              +----+\n   CONFIRMATION_TIMER
      expiry:                        PROBE_TIMER expiry:\n   PROBE_COUNT < MAX_PROBES
      or               PROBE_COUNT < MAX_PROBES or\n        PLPMTU Probe acked                           Probe
      acked or PTB:\n                Figure 5: State Machine for Datagram PLPMTUD\n
      \  The following states are defined:\n   DISABLED:  The DISABLED state is the
      initial state before probing has\n      started.  It is also entered from any
      other state, when the PL\n      indicates loss of connectivity.  This state
      is left once the PL\n      indicates connectivity to the remote PL.  When transitioning
      to\n      the BASE state, a probe packet of size BASE_PLPMTU can be sent\n      immediately.\n
      \  BASE:  The BASE state is used to confirm that the BASE_PLPMTU size is\n      supported
      by the network path and is designed to allow an\n      application to continue
      working when there are transient\n      reductions in the actual PMTU.  It also
      seeks to avoid long\n      periods when a sender searching for a larger PLPMTU
      is unaware\n      that packets are not being delivered due to a packet or ICMP
      black\n      hole.\n      On entry, the PROBED_SIZE is set to the BASE_PLPMTU
      size, and the\n      PROBE_COUNT is set to zero.\n      Each time a probe packet
      is sent, the PROBE_TIMER is started.  The\n      state is exited when the probe
      packet is acknowledged, and the PL\n      sender enters the SEARCHING state.\n
      \     The state is also left when the PROBE_COUNT reaches MAX_PROBES or\n      a
      received PTB message is validated.  This causes the PL sender to\n      enter
      the ERROR state.\n   SEARCHING:  The SEARCHING state is the main probing state.
      \ This\n      state is entered when probing for the BASE_PLPMTU completes.\n
      \     Each time a probe packet is acknowledged, the PROBE_COUNT is set\n      to
      zero, the PLPMTU is set to the PROBED_SIZE, and then the\n      PROBED_SIZE
      is increased using the search algorithm (as described\n      in Section 5.3).\n
      \     When a probe packet is sent and not acknowledged within the period\n      of
      the PROBE_TIMER, the PROBE_COUNT is incremented, and a new\n      probe packet
      is transmitted.\n      The state is exited to enter SEARCH_COMPLETE when the
      PROBE_COUNT\n      reaches MAX_PROBES, a validated PTB is received that corresponds\n
      \     to the last successfully probed size (PL_PTB_SIZE = PLPMTU), or a\n      probe
      of size MAX_PLPMTU is acknowledged (PLPMTU = MAX_PLPMTU).\n      When a black
      hole is detected in the SEARCHING state, this causes\n      the PL sender to
      enter the BASE state.\n   SEARCH_COMPLETE:  The SEARCH_COMPLETE state indicates
      that a search\n      has completed.  This is the normal maintenance state, where
      the PL\n      is not probing to update the PLPMTU.  DPLPMTUD remains in this\n
      \     state until either the PMTU_RAISE_TIMER expires or a black hole is\n      detected.\n
      \     When DPLPMTUD uses an unacknowledged PL and is in the\n      SEARCH_COMPLETE
      state, a CONFIRMATION_TIMER periodically resets\n      the PROBE_COUNT and schedules
      a probe packet with the size of the\n      PLPMTU.  If MAX_PROBES successive
      PLPMTUD-sized probes fail to be\n      acknowledged, the method enters the BASE
      state.  When used with an\n      acknowledged PL (e.g., SCTP), DPLPMTUD SHOULD
      NOT continue to\n      generate PLPMTU probes in this state.\n   ERROR:  The
      ERROR state represents the case where either the network\n      path is not
      known to support a PLPMTU of at least the BASE_PLPMTU\n      size or when there
      is contradictory information about the network\n      path that would otherwise
      result in excessive variation in the MPS\n      signaled to the higher layer.
      \ The state implements a method to\n      mitigate oscillation in the state-event
      engine.  It signals a\n      conservative value of the MPS to the higher layer
      by the PL.  The\n      state is exited when packet probes no longer detect the
      error.\n      The PL sender then enters the SEARCHING state.\n      Implementations
      are permitted to enable endpoint fragmentation if\n      the DPLPMTUD is unable
      to validate MIN_PLPMTU within PROBE_COUNT\n      probes.  If DPLPMTUD is unable
      to validate MIN_PLPMTU, the\n      implementation will transition to the DISABLED
      state.\n      Note: MIN_PLPMTU could be identical to BASE_PLPMTU, simplifying\n
      \     the actions in this state.\n"
    title: 5.2.  State Machine
  - contents:
    - "5.3.  Search to Increase the PLPMTU\n   This section describes the algorithms
      used by DPLPMTUD to search for\n   a larger PLPMTU.\n"
    - contents:
      - "5.3.1.  Probing for a Larger PLPMTU\n   Implementations use a search algorithm
        across the search range to\n   determine whether a larger PLPMTU can be supported
        across a network\n   path.\n   The method discovers the search range by confirming
        the minimum\n   PLPMTU and then using the probe method to select a PROBED_SIZE
        less\n   than or equal to MAX_PLPMTU.  MAX_PLPMTU is the minimum of the local\n
        \  MTU and EMTU_R (when this is learned from the remote endpoint).  The\n
        \  MAX_PLPMTU MAY be reduced by an application that sets a maximum to\n   the
        size of datagrams it will send.\n   The PROBE_COUNT is initialized to zero
        when the first probe with a\n   size greater than or equal to PLPMTU is sent.
        \ Each probe packet\n   successfully sent to the remote peer is confirmed
        by acknowledgment\n   at the PL (see Section 4.1).\n   Each time a probe packet
        is sent to the destination, the PROBE_TIMER\n   is started.  The timer is
        canceled when the PL receives\n   acknowledgment that the probe packet has
        been successfully sent\n   across the path (Section 4.1).  This confirms that
        the PROBED_SIZE is\n   supported, and the PROBED_SIZE value is then assigned
        to the PLPMTU.\n   The search algorithm can continue to send subsequent probe
        packets of\n   an increasing size.\n   If the timer expires before a probe
        packet is acknowledged, the probe\n   has failed to confirm the PROBED_SIZE.
        \ Each time the PROBE_TIMER\n   expires, the PROBE_COUNT is incremented, the
        PROBE_TIMER is\n   reinitialized, and a new probe of the same size or any
        other size\n   (determined by the search algorithm) can be sent.  The maximum
        number\n   of consecutive failed probes is configured (MAX_PROBES).  If the\n
        \  value of the PROBE_COUNT reaches MAX_PROBES, probing will stop, and\n   the
        PL sender enters the SEARCH_COMPLETE state.\n"
      title: 5.3.1.  Probing for a Larger PLPMTU
    - contents:
      - "5.3.2.  Selection of Probe Sizes\n   The search algorithm determines a minimum
        useful gain in PLPMTU.  It\n   would not be constructive for a PL sender to
        attempt to probe for all\n   sizes.  This would incur unnecessary load on
        the path.\n   Implementations SHOULD select the set of probe packet sizes
        to\n   maximize the gain in PLPMTU from each search step.\n   Implementations
        could optimize the search procedure by selecting step\n   sizes from a table
        of common PMTU sizes.  When selecting the\n   appropriate next size to search,
        an implementer ought to also\n   consider that there can be common sizes of
        MPS that applications seek\n   to use, and there could be common sizes of
        MTU used within the\n   network.\n"
      title: 5.3.2.  Selection of Probe Sizes
    - contents:
      - "5.3.3.  Resilience to Inconsistent Path Information\n   A decision to increase
        the PLPMTU needs to be resilient to the\n   possibility that information learned
        about the network path is\n   inconsistent.  A path is inconsistent when,
        for example, probe\n   packets are lost due to other reasons (i.e., not packet
        size) or due\n   to frequent path changes.  Frequent path changes could occur
        by\n   unexpected \"flapping\" -- where some packets from a flow pass along\n
        \  one path, but other packets follow a different path with different\n   properties.\n
        \  A PL sender is able to detect inconsistency either from the sequence\n
        \  of PLPMTU probes that are acknowledged or from the sequence of PTB\n   messages
        that it receives.  When inconsistent path information is\n   detected, a PL
        sender could use an alternate search mode that clamps\n   the offered MPS
        to a smaller value for a period of time.  This avoids\n   unnecessary loss
        of packets.\n"
      title: 5.3.3.  Resilience to Inconsistent Path Information
    title: 5.3.  Search to Increase the PLPMTU
  - contents:
    - "5.4.  Robustness to Inconsistent Paths\n   Some paths could be unable to sustain
      packets of the BASE_PLPMTU\n   size.  The Error State could be implemented to
      provide robustness to\n   such paths.  This allows fallback to a smaller than
      desired PLPMTU\n   rather than suffer connectivity failure.  This could utilize
      methods\n   such as endpoint IP fragmentation to enable the PL sender to\n   communicate
      using packets smaller than the BASE_PLPMTU.\n"
    title: 5.4.  Robustness to Inconsistent Paths
  title: 5.  Datagram Packetization Layer PMTUD
- contents:
  - "6.  Specification of Protocol-Specific Methods\n   DPLPMTUD requires protocol-specific
    details to be specified for each\n   PL that is used.\n   The first subsection
    provides guidance on how to implement the\n   DPLPMTUD method as a part of an
    application using UDP or UDP-Lite.\n   The guidance also applies to other datagram
    services that do not\n   include a specific transport protocol (such as a tunnel\n
    \  encapsulation).  The following subsections describe how DPLPMTUD can\n   be
    implemented as a part of the transport service, allowing\n   applications using
    the service to benefit from discovery of the\n   PLPMTU without themselves needing
    to implement this method when using\n   SCTP and QUIC.\n"
  - contents:
    - "6.1.  Application Support for DPLPMTUD with UDP or UDP-Lite\n   The current
      specifications of UDP [RFC0768] and UDP-Lite [RFC3828] do\n   not define a method
      in the RFC series that supports PLPMTUD.  In\n   particular, the UDP transport
      does not provide the transport features\n   needed to implement datagram PLPMTUD.\n
      \  The DPLPMTUD method can be implemented as a part of an application\n   built
      directly or indirectly on UDP or UDP-Lite but relies on higher-\n   layer protocol
      features to implement the method [BCP145].\n   Some primitives used by DPLPMTUD
      might not be available via the\n   Datagram API (e.g., the ability to access
      the PLPMTU from the IP-\n   layer cache or to interpret received PTB messages).\n
      \  In addition, it is recommended that PMTU discovery is not performed\n   by
      multiple protocol layers.  An application SHOULD avoid using\n   DPLPMTUD when
      the underlying transport system provides this\n   capability.  A common method
      for managing the PLPMTU has benefits,\n   both in the ability to share state
      between different processes and in\n   opportunities to coordinate probing for
      different PL instances.\n"
    - contents:
      - "6.1.1.  Application Request\n   An application needs an application-layer
        protocol mechanism (such as\n   a message acknowledgment method) that solicits
        a response from a\n   destination endpoint.  The method SHOULD allow the sender
        to check\n   the value returned in the response to provide additional protection\n
        \  from off-path insertion of data [BCP145].  Suitable methods include a\n
        \  parameter known only to the two endpoints, such as a session ID or\n   initialized
        sequence number.\n"
      title: 6.1.1.  Application Request
    - contents:
      - "6.1.2.  Application Response\n   An application needs an application-layer
        protocol mechanism to\n   communicate the response from the destination endpoint.
        \ This\n   response could indicate successful reception of the probe across
        the\n   path but could also indicate that some (or all packets) have failed\n
        \  to reach the destination.\n"
      title: 6.1.2.  Application Response
    - contents:
      - "6.1.3.  Sending Application Probe Packets\n   A probe packet can carry an
        application data block, but the\n   successful transmission of this data is
        at risk when used for\n   probing.  Some applications might prefer to use
        a probe packet that\n   does not carry an application data block to avoid
        disruption of data\n   transfer.\n"
      title: 6.1.3.  Sending Application Probe Packets
    - contents:
      - "6.1.4.  Initial Connectivity\n   An application that does not have other
        higher-layer information\n   confirming connectivity with the remote peer
        SHOULD implement a\n   connectivity mechanism using acknowledged probe packets
        before\n   entering the BASE state.\n"
      title: 6.1.4.  Initial Connectivity
    - contents:
      - "6.1.5.  Validating the Path\n   An application that does not have other higher-layer
        information\n   confirming correct delivery of datagrams SHOULD implement
        the\n   CONFIRMATION_TIMER to periodically send probe packets while in the\n
        \  SEARCH_COMPLETE state.\n"
      title: 6.1.5.  Validating the Path
    - contents:
      - "6.1.6.  Handling of PTB Messages\n   An application that is able and wishes
        to receive PTB messages MUST\n   perform ICMP validation as specified in Section
        5.2 of [BCP145].\n   This requires that the application checks each received
        PTB message\n   to validate that it was is received in response to transmitted\n
        \  traffic and that the reported PL_PTB_SIZE is less than the current\n   probed
        size (see Section 4.6.2).  A validated PTB message MAY be used\n   as input
        to the DPLPMTUD algorithm but MUST NOT be used directly to\n   set the PLPMTU.\n"
      title: 6.1.6.  Handling of PTB Messages
    title: 6.1.  Application Support for DPLPMTUD with UDP or UDP-Lite
  - contents:
    - "6.2.  DPLPMTUD for SCTP\n   Section 10.2 of [RFC4821] specifies a recommended
      PLPMTUD probing\n   method for SCTP, and Section 7.3 of [RFC4960] recommends
      an endpoint\n   apply the techniques in RFC 4821 on a per-destination-address
      basis.\n   The specification for DPLPMTUD continues the practice of using the
      PL\n   to discover the PMTU but updates RFC4960 with a recommendation to use\n
      \  the method specified in this document: The RECOMMENDED method for\n   generating
      probes is to add a chunk consisting only of padding to an\n   SCTP message.
      \ The PAD chunk defined in [RFC4820] SHOULD be attached\n   to a minimum-length
      HEARTBEAT (HB) chunk to build a probe packet.\n   This enables probing without
      affecting the transfer of user messages\n   and without being limited by congestion
      control or flow control.\n   This is preferred to using DATA chunks (with padding
      as required) as\n   path probes.\n   Section 6.9 of [RFC4960] describes dividing
      the user messages into\n   DATA chunks sent by the PL when using SCTP.  This
      notes that once an\n   SCTP message has been sent, it cannot be resegmented.
      \ [RFC4960]\n   describes the method for retransmitting DATA chunks when the
      MPS has\n   been reduced, and Section 6.9 of [RFC4960] describes use of IP\n
      \  fragmentation for this case.  This is unchanged by this document.\n"
    - contents:
      - '6.2.1.  SCTP/IPv4 and SCTP/IPv6

        '
      - contents:
        - "6.2.1.1.  Initial Connectivity\n   The base protocol is specified in [RFC4960].
          \ This provides an\n   acknowledged PL.  A sender can therefore enter the
          BASE state as soon\n   as connectivity has been confirmed.\n"
        title: 6.2.1.1.  Initial Connectivity
      - contents:
        - "6.2.1.2.  Sending SCTP Probe Packets\n   Probe packets consist of an SCTP
          common header followed by a\n   HEARTBEAT chunk and a PAD chunk.  The PAD
          chunk is used to control\n   the length of the probe packet.  The HEARTBEAT
          chunk is used to\n   trigger the sending of a HEARTBEAT ACK chunk.  The
          reception of the\n   HEARTBEAT ACK chunk acknowledges reception of a successful
          probe.  A\n   successful probe updates the association and path counters,
          but an\n   unsuccessful probe is discounted (assumed to be a result of choosing\n
          \  too large a PLPMTU).\n   The SCTP sender needs to be able to determine
          the total size of a\n   probe packet.  The HEARTBEAT chunk could carry a
          Heartbeat\n   Information parameter that includes, besides the information\n
          \  suggested in [RFC4960], the probe size to help an implementation\n   associate
          a HEARTBEAT ACK with the size of probe that was sent.  The\n   sender could
          also use other methods, such as sending a nonce and\n   verifying the information
          returned also contains the corresponding\n   nonce.  The length of the PAD
          chunk is computed by reducing the\n   probing size by the size of the SCTP
          common header and the HEARTBEAT\n   chunk.  The payload of the PAD chunk
          contains arbitrary data.  When\n   transmitted at the IP layer, the PMTU
          size also includes the IPv4 or\n   IPv6 header(s).\n   Probing can start
          directly after the PL handshake; this can be done\n   before data is sent.
          \ Assuming this behavior (i.e., the PMTU is\n   smaller than or equal to
          the interface MTU), this process will take\n   several round-trip time periods,
          dependent on the number of DPLPMTUD\n   probes sent.  The Heartbeat timer
          can be used to implement the\n   PROBE_TIMER.\n"
        title: 6.2.1.2.  Sending SCTP Probe Packets
      - contents:
        - "6.2.1.3.  Validating the Path with SCTP\n   Since SCTP provides an acknowledged
          PL, a sender MUST NOT implement\n   the CONFIRMATION_TIMER while in the
          SEARCH_COMPLETE state.\n"
        title: 6.2.1.3.  Validating the Path with SCTP
      - contents:
        - "6.2.1.4.  PTB Message Handling by SCTP\n   Normal ICMP validation MUST
          be performed as specified in Appendix C\n   of [RFC4960].  This requires
          that the first 8 bytes of the SCTP\n   common header are quoted in the payload
          of the PTB message, which can\n   be the case for ICMPv4 and is normally
          the case for ICMPv6.\n   When a PTB message has been validated, the PL_PTB_SIZE
          calculated\n   from the PTB_SIZE reported in the PTB message SHOULD be used
          with the\n   DPLPMTUD algorithm, provided that the reported PL_PTB_SIZE
          is less\n   than the current probe size (see Section 4.6).\n"
        title: 6.2.1.4.  PTB Message Handling by SCTP
      title: 6.2.1.  SCTP/IPv4 and SCTP/IPv6
    - contents:
      - "6.2.2.  DPLPMTUD for SCTP/UDP\n   The UDP encapsulation of SCTP is specified
        in [RFC6951].\n   This specification updates the reference to RFC 4821 in
        Section 5.6\n   of RFC 6951 to refer to this document (RFC 8899).  RFC 6951
        is\n   updated by the addition of the following sentence at the end of\n   Section
        5.6:\n   |  The RECOMMENDED method for determining the MTU of the path is\n
        \  |  specified in RFC 8899.\n"
      - contents:
        - "6.2.2.1.  Initial Connectivity\n   A sender can enter the BASE state as
          soon as SCTP connectivity has\n   been confirmed.\n"
        title: 6.2.2.1.  Initial Connectivity
      - contents:
        - "6.2.2.2.  Sending SCTP/UDP Probe Packets\n   Packet probing can be performed
          as specified in Section 6.2.1.2.  The\n   size of the probe packet includes
          the 8 bytes of UDP header.  This\n   has to be considered when filling the
          probe packet with the PAD\n   chunk.\n"
        title: 6.2.2.2.  Sending SCTP/UDP Probe Packets
      - contents:
        - "6.2.2.3.  Validating the Path with SCTP/UDP\n   SCTP provides an acknowledged
          PL; therefore, a sender does not\n   implement the CONFIRMATION_TIMER while
          in the SEARCH_COMPLETE state.\n"
        title: 6.2.2.3.  Validating the Path with SCTP/UDP
      - contents:
        - "6.2.2.4.  Handling of PTB Messages by SCTP/UDP\n   ICMP validation MUST
          be performed for PTB messages as specified in\n   Appendix C of [RFC4960].
          \ This requires that the first 8 bytes of the\n   SCTP common header are
          contained in the PTB message, which can be the\n   case for ICMPv4 (but
          note the UDP header also consumes a part of the\n   quoted packet header)
          and is normally the case for ICMPv6.  When the\n   validation is completed,
          the PL_PTB_SIZE calculated from the PTB_SIZE\n   in the PTB message SHOULD
          be used with the DPLPMTUD providing that\n   the reported PL_PTB_SIZE is
          less than the current probe size.\n"
        title: 6.2.2.4.  Handling of PTB Messages by SCTP/UDP
      title: 6.2.2.  DPLPMTUD for SCTP/UDP
    - contents:
      - "6.2.3.  DPLPMTUD for SCTP/DTLS\n   The Datagram Transport Layer Security
        (DTLS) encapsulation of SCTP is\n   specified in [RFC8261].  This is used
        for data channels in WebRTC\n   implementations.  This specification updates
        the reference to RFC\n   4821 in Section 5 of RFC 8261 to refer to this document
        (RFC 8899).\n"
      - contents:
        - "6.2.3.1.  Initial Connectivity\n   A sender can enter the BASE state as
          soon as SCTP connectivity has\n   been confirmed.\n"
        title: 6.2.3.1.  Initial Connectivity
      - contents:
        - "6.2.3.2.  Sending SCTP/DTLS Probe Packets\n   Packet probing can be done
          as specified in Section 6.2.1.2.  The\n   maximum payload is reduced by
          the size of the DTLS headers, which has\n   to be considered when filling
          the PAD chunk.  The size of the probe\n   packet includes the DTLS PL headers.
          \ This has to be considered when\n   filling the probe packet with the PAD
          chunk.\n"
        title: 6.2.3.2.  Sending SCTP/DTLS Probe Packets
      - contents:
        - "6.2.3.3.  Validating the Path with SCTP/DTLS\n   Since SCTP provides an
          acknowledged PL, a sender MUST NOT implement\n   the CONFIRMATION_TIMER
          while in the SEARCH_COMPLETE state.\n"
        title: 6.2.3.3.  Validating the Path with SCTP/DTLS
      - contents:
        - "6.2.3.4.  Handling of PTB Messages by SCTP/DTLS\n   [RFC4960] does not
          specify a way to validate SCTP/DTLS ICMP message\n   payload and neither
          does this document.  This can prevent processing\n   of PTB messages at
          the PL.\n"
        title: 6.2.3.4.  Handling of PTB Messages by SCTP/DTLS
      title: 6.2.3.  DPLPMTUD for SCTP/DTLS
    title: 6.2.  DPLPMTUD for SCTP
  - contents:
    - "6.3.  DPLPMTUD for QUIC\n   QUIC [QUIC] is a UDP-based PL that provides reception
      feedback.  The\n   UDP payload includes a QUIC packet header, a protected payload,
      and\n   any authentication fields.  It supports padding and packet\n   coalescence
      that can be used to construct probe packets.  From the\n   perspective of DPLPMTUD,
      QUIC can function as an acknowledged PL.\n   [QUIC] describes the method for
      using DPLPMTUD with QUIC packets.\n"
    title: 6.3.  DPLPMTUD for QUIC
  title: 6.  Specification of Protocol-Specific Methods
- contents:
  - "7.  IANA Considerations\n   This document has no IANA actions.\n"
  title: 7.  IANA Considerations
- contents:
  - "8.  Security Considerations\n   The security considerations for the use of UDP
    and SCTP are provided\n   in the referenced RFCs.\n   To avoid excessive load,
    the interval between individual probe\n   packets MUST be at least one RTT, and
    the interval between rounds of\n   probing is determined by the PMTU_RAISE_TIMER.\n
    \  A PL sender needs to ensure that the method used to confirm reception\n   of
    probe packets protects from off-path attackers injecting packets\n   into the
    path.  This protection is provided in IETF-defined protocols\n   (e.g., TCP, SCTP)
    using a randomly initialized sequence number.  A\n   description of one way to
    do this when using UDP is provided in\n   Section 5.1 of [BCP145]).\n   There
    are cases where ICMP Packet Too Big (PTB) messages are not\n   delivered due to
    policy, configuration, or equipment design (see\n   Section 1.1).  This method
    therefore does not rely upon PTB messages\n   being received but is able to utilize
    these when they are received by\n   the sender.  PTB messages could potentially
    be used to cause a node\n   to inappropriately reduce the PLPMTU.  A node supporting
    DPLPMTUD\n   MUST therefore appropriately validate the payload of PTB messages
    to\n   ensure these are received in response to transmitted traffic (i.e., a\n
    \  reported error condition that corresponds to a datagram actually sent\n   by
    the path layer, see Section 4.6.1).\n   An on-path attacker able to create a PTB
    message could forge PTB\n   messages that include a valid quoted IP packet.  Such
    an attack could\n   be used to drive down the PLPMTU.  An on-path device could
    similarly\n   force a reduction of the PLPMTU by implementing a policy that drops\n
    \  packets larger than a configured size.  There are two ways this\n   method
    can be mitigated against such attacks: first, by ensuring that\n   a PL sender
    never reduces the PLPMTU below the base size solely in\n   response to receiving
    a PTB message.  This is achieved by first\n   entering the BASE state when such
    a message is received.  Second, the\n   design does not require processing of
    PTB messages; a PL sender could\n   therefore suspend processing of PTB messages
    (e.g., in a robustness\n   mode after detecting that subsequent probes actually
    confirm that a\n   size larger than the PTB_SIZE is supported by a path).\n   Parsing
    the quoted packet inside a PTB message can introduce\n   additional per-packet
    processing at the PL sender.  This processing\n   SHOULD be limited to avoid a
    denial-of-service attack when arbitrary\n   headers are included.  Rate-limiting
    the processing could result in\n   PTB messages not being received by a PL; however,
    the DPLPMTUD method\n   is robust to such loss.\n   The successful processing
    of an ICMP message can trigger a probe when\n   the reported PTB size is valid,
    but this does not directly update the\n   PLPMTU for the path.  This prevents
    a message attempting to black\n   hole data by indicating a size larger than supported
    by the path.\n   It is possible that the information about a path is not stable.
    \ This\n   could be a result of forwarding across more than one path that has
    a\n   different actual PMTU or a single path presents a varying PMTU.  The\n   design
    of a PLPMTUD implementation SHOULD consider how to mitigate\n   the effects of
    varying path information.  One possible mitigation is\n   to provide robustness
    (see Section 5.4) in the method that avoids\n   oscillation in the MPS.\n   DPLPMTUD
    methods can introduce padding data to inflate the length of\n   the datagram to
    the total size required for a probe packet.  The\n   total size of a probe packet
    includes all headers and padding added\n   to the payload data being sent (e.g.,
    including security-related\n   fields such as an AEAD tag and TLS record layer
    padding).  The value\n   of the padding data does not influence the DPLPMTUD search
    algorithm,\n   and therefore needs to be set consistent with the policy of the
    PL.\n   If a PL can make use of cryptographic confidentiality or data-\n   integrity
    mechanisms, then the design ought to avoid adding anything\n   (e.g., padding)
    to DPLPMTUD probe packets that is not also protected\n   by those cryptographic
    mechanisms.\n"
  title: 8.  Security Considerations
- contents:
  - '9.  References

    '
  - contents:
    - "9.1.  Normative References\n   [BCP145]   Eggert, L., Fairhurst, G., and G.
      Shepherd, \"UDP Usage\n              Guidelines\", BCP 145, RFC 8085, March
      2017,\n              <https://www.rfc-editor.org/info/bcp145>.\n   [RFC0768]
      \ Postel, J., \"User Datagram Protocol\", STD 6, RFC 768,\n              DOI
      10.17487/RFC0768, August 1980,\n              <https://www.rfc-editor.org/info/rfc768>.\n
      \  [RFC0791]  Postel, J., \"Internet Protocol\", STD 5, RFC 791,\n              DOI
      10.17487/RFC0791, September 1981,\n              <https://www.rfc-editor.org/info/rfc791>.\n
      \  [RFC1191]  Mogul, J. and S. Deering, \"Path MTU discovery\", RFC 1191,\n
      \             DOI 10.17487/RFC1191, November 1990,\n              <https://www.rfc-editor.org/info/rfc1191>.\n
      \  [RFC2119]  Bradner, S., \"Key words for use in RFCs to Indicate\n              Requirement
      Levels\", BCP 14, RFC 2119,\n              DOI 10.17487/RFC2119, March 1997,\n
      \             <https://www.rfc-editor.org/info/rfc2119>.\n   [RFC3828]  Larzon,
      L-A., Degermark, M., Pink, S., Jonsson, L-E., Ed.,\n              and G. Fairhurst,
      Ed., \"The Lightweight User Datagram\n              Protocol (UDP-Lite)\", RFC
      3828, DOI 10.17487/RFC3828, July\n              2004, <https://www.rfc-editor.org/info/rfc3828>.\n
      \  [RFC4820]  Tuexen, M., Stewart, R., and P. Lei, \"Padding Chunk and\n              Parameter
      for the Stream Control Transmission Protocol\n              (SCTP)\", RFC 4820,
      DOI 10.17487/RFC4820, March 2007,\n              <https://www.rfc-editor.org/info/rfc4820>.\n
      \  [RFC4960]  Stewart, R., Ed., \"Stream Control Transmission Protocol\",\n
      \             RFC 4960, DOI 10.17487/RFC4960, September 2007,\n              <https://www.rfc-editor.org/info/rfc4960>.\n
      \  [RFC6951]  Tuexen, M. and R. Stewart, \"UDP Encapsulation of Stream\n              Control
      Transmission Protocol (SCTP) Packets for End-Host\n              to End-Host
      Communication\", RFC 6951,\n              DOI 10.17487/RFC6951, May 2013,\n
      \             <https://www.rfc-editor.org/info/rfc6951>.\n   [RFC8174]  Leiba,
      B., \"Ambiguity of Uppercase vs Lowercase in RFC\n              2119 Key Words\",
      BCP 14, RFC 8174, DOI 10.17487/RFC8174,\n              May 2017, <https://www.rfc-editor.org/info/rfc8174>.\n
      \  [RFC8200]  Deering, S. and R. Hinden, \"Internet Protocol, Version 6\n              (IPv6)
      Specification\", STD 86, RFC 8200,\n              DOI 10.17487/RFC8200, July
      2017,\n              <https://www.rfc-editor.org/info/rfc8200>.\n   [RFC8201]
      \ McCann, J., Deering, S., Mogul, J., and R. Hinden, Ed.,\n              \"Path
      MTU Discovery for IP version 6\", STD 87, RFC 8201,\n              DOI 10.17487/RFC8201,
      July 2017,\n              <https://www.rfc-editor.org/info/rfc8201>.\n   [RFC8261]
      \ Tuexen, M., Stewart, R., Jesup, R., and S. Loreto,\n              \"Datagram
      Transport Layer Security (DTLS) Encapsulation of\n              SCTP Packets\",
      RFC 8261, DOI 10.17487/RFC8261, November\n              2017, <https://www.rfc-editor.org/info/rfc8261>.\n"
    title: 9.1.  Normative References
  - contents:
    - "9.2.  Informative References\n   [QUIC]     Iyengar, J., Ed. and M. Thomson,
      Ed., \"QUIC: A UDP-Based\n              Multiplexed and Secure Transport\",
      Work in Progress,\n              Internet-Draft, draft-ietf-quic-transport-29,
      10 June\n              2020, <https://tools.ietf.org/html/draft-ietf-quic-\n
      \             transport-29>.\n   [RFC0792]  Postel, J., \"Internet Control Message
      Protocol\", STD 5,\n              RFC 792, DOI 10.17487/RFC0792, September 1981,\n
      \             <https://www.rfc-editor.org/info/rfc792>.\n   [RFC1122]  Braden,
      R., Ed., \"Requirements for Internet Hosts -\n              Communication Layers\",
      STD 3, RFC 1122,\n              DOI 10.17487/RFC1122, October 1989,\n              <https://www.rfc-editor.org/info/rfc1122>.\n
      \  [RFC1812]  Baker, F., Ed., \"Requirements for IP Version 4 Routers\",\n              RFC
      1812, DOI 10.17487/RFC1812, June 1995,\n              <https://www.rfc-editor.org/info/rfc1812>.\n
      \  [RFC2923]  Lahey, K., \"TCP Problems with Path MTU Discovery\",\n              RFC
      2923, DOI 10.17487/RFC2923, September 2000,\n              <https://www.rfc-editor.org/info/rfc2923>.\n
      \  [RFC4340]  Kohler, E., Handley, M., and S. Floyd, \"Datagram\n              Congestion
      Control Protocol (DCCP)\", RFC 4340,\n              DOI 10.17487/RFC4340, March
      2006,\n              <https://www.rfc-editor.org/info/rfc4340>.\n   [RFC4443]
      \ Conta, A., Deering, S., and M. Gupta, Ed., \"Internet\n              Control
      Message Protocol (ICMPv6) for the Internet\n              Protocol Version 6
      (IPv6) Specification\", STD 89,\n              RFC 4443, DOI 10.17487/RFC4443,
      March 2006,\n              <https://www.rfc-editor.org/info/rfc4443>.\n   [RFC4821]
      \ Mathis, M. and J. Heffner, \"Packetization Layer Path MTU\n              Discovery\",
      RFC 4821, DOI 10.17487/RFC4821, March 2007,\n              <https://www.rfc-editor.org/info/rfc4821>.\n
      \  [RFC4890]  Davies, E. and J. Mohacsi, \"Recommendations for Filtering\n              ICMPv6
      Messages in Firewalls\", RFC 4890,\n              DOI 10.17487/RFC4890, May
      2007,\n              <https://www.rfc-editor.org/info/rfc4890>.\n   [RFC5508]
      \ Srisuresh, P., Ford, B., Sivakumar, S., and S. Guha, \"NAT\n              Behavioral
      Requirements for ICMP\", BCP 148, RFC 5508,\n              DOI 10.17487/RFC5508,
      April 2009,\n              <https://www.rfc-editor.org/info/rfc5508>.\n   [RFC8900]
      \ Bonica, R., Baker, F., Huston, G., Hinden, R., Troan, O.,\n              and
      F. Gont, \"IP Fragmentation Considered Fragile\",\n              RFC 8900, BCP
      230, September 2020,\n              <https://www.rfc-editor.org/info/rfc8900>.\n
      \  [TUNNELS]  Touch, J. and M. Townsley, \"IP Tunnels in the Internet\n              Architecture\",
      Work in Progress, Internet-Draft, draft-\n              ietf-intarea-tunnels-10,
      12 September 2019,\n              <https://tools.ietf.org/html/draft-ietf-intarea-tunnels-\n
      \             10>.\n"
    title: 9.2.  Informative References
  title: 9.  References
- contents:
  - "Acknowledgments\n   This work was partially funded by the European Union Horizon
    2020\n   Research and Innovation Programme under grant agreement No. 644334,\n
    \  \"A New, Evolutive API and Transport-Layer Architecture for the\n   Internet\"
    (NEAT).  The views expressed are solely those of the\n   author(s).\n   Thanks
    to all who have commented or contributed, the TSVWG and QUIC\n   working groups,
    and Mathew Calder and Julius Flohr for providing\n   early implementations.\n"
  title: Acknowledgments
- contents:
  - "Authors' Addresses\n   Godred Fairhurst\n   University of Aberdeen\n   School
    of Engineering\n   Fraser Noble Building\n   Aberdeen\n   AB24 3UE\n   United
    Kingdom\n   Email: gorry@erg.abdn.ac.uk\n   Tom Jones\n   University of Aberdeen\n
    \  School of Engineering\n   Fraser Noble Building\n   Aberdeen\n   AB24 3UE\n
    \  United Kingdom\n   Email: tom@erg.abdn.ac.uk\n   Michael T\xFCxen\n   M\xFCnster
    University of Applied Sciences\n   Stegerwaldstrasse 39\n   48565 Steinfurt\n
    \  Germany\n   Email: tuexen@fh-muenster.de\n   Irene R\xFCngeler\n   M\xFCnster
    University of Applied Sciences\n   Stegerwaldstrasse 39\n   48565 Steinfurt\n
    \  Germany\n   Email: i.ruengeler@fh-muenster.de\n   Timo V\xF6lker\n   M\xFCnster
    University of Applied Sciences\n   Stegerwaldstrasse 39\n   48565 Steinfurt\n"
  title: Authors' Addresses
