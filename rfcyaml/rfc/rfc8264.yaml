- contents:
  - "     PRECIS Framework: Preparation, Enforcement, and Comparison of\n           Internationalized
    Strings in Application Protocols\n"
  title: __initial_text__
- contents:
  - "Abstract\n   Application protocols using Unicode code points in protocol strings\n
    \  need to properly handle such strings in order to enforce\n   internationalization
    rules for strings placed in various protocol\n   slots (such as addresses and
    identifiers) and to perform valid\n   comparison operations (e.g., for purposes
    of authentication or\n   authorization).  This document defines a framework enabling\n
    \  application protocols to perform the preparation, enforcement, and\n   comparison
    of internationalized strings (\"PRECIS\") in a way that\n   depends on the properties
    of Unicode code points and thus is more\n   agile with respect to versions of
    Unicode.  As a result, this\n   framework provides a more sustainable approach
    to the handling of\n   internationalized strings than the previous framework,
    known as\n   Stringprep (RFC 3454).  This document obsoletes RFC 7564.\n"
  title: Abstract
- contents:
  - "Status of This Memo\n   This is an Internet Standards Track document.\n   This
    document is a product of the Internet Engineering Task Force\n   (IETF).  It represents
    the consensus of the IETF community.  It has\n   received public review and has
    been approved for publication by the\n   Internet Engineering Steering Group (IESG).
    \ Further information on\n   Internet Standards is available in Section 2 of RFC
    7841.\n   Information about the current status of this document, any errata,\n
    \  and how to provide feedback on it may be obtained at\n   https://www.rfc-editor.org/info/rfc8264.\n"
  title: Status of This Memo
- contents:
  - "Copyright Notice\n   Copyright (c) 2017 IETF Trust and the persons identified
    as the\n   document authors.  All rights reserved.\n   This document is subject
    to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n
    \  (https://trustee.ietf.org/license-info) in effect on the date of\n   publication
    of this document.  Please review these documents\n   carefully, as they describe
    your rights and restrictions with respect\n   to this document.  Code Components
    extracted from this document must\n   include Simplified BSD License text as described
    in Section 4.e of\n   the Trust Legal Provisions and are provided without warranty
    as\n   described in the Simplified BSD License.\n"
  title: Copyright Notice
- contents:
  - "Table of Contents\n   1.  Introduction  . . . . . . . . . . . . . . . . . . .
    . . . . .   3\n   2.  Terminology . . . . . . . . . . . . . . . . . . . . . .
    . . .   6\n   3.  Preparation, Enforcement, and Comparison  . . . . . . . . .
    .   6\n   4.  String Classes  . . . . . . . . . . . . . . . . . . . . . . .   8\n
    \    4.1.  Overview  . . . . . . . . . . . . . . . . . . . . . . . .   8\n     4.2.
    \ IdentifierClass . . . . . . . . . . . . . . . . . . . . .   9\n       4.2.1.
    \ Valid . . . . . . . . . . . . . . . . . . . . . . . .   9\n       4.2.2.  Contextual
    Rule Required  . . . . . . . . . . . . . .  10\n       4.2.3.  Disallowed  . .
    . . . . . . . . . . . . . . . . . . .  10\n       4.2.4.  Unassigned  . . . .
    . . . . . . . . . . . . . . . . .  10\n       4.2.5.  Examples  . . . . . . .
    . . . . . . . . . . . . . . .  11\n     4.3.  FreeformClass . . . . . . . . .
    . . . . . . . . . . . . .  11\n       4.3.1.  Valid . . . . . . . . . . . . .
    . . . . . . . . . . .  11\n       4.3.2.  Contextual Rule Required  . . . . .
    . . . . . . . . .  12\n       4.3.3.  Disallowed  . . . . . . . . . . . . . .
    . . . . . . .  12\n       4.3.4.  Unassigned  . . . . . . . . . . . . . . . .
    . . . . .  12\n       4.3.5.  Examples  . . . . . . . . . . . . . . . . . . .
    . . .  12\n     4.4.  Summary . . . . . . . . . . . . . . . . . . . . . . . .
    .  12\n   5.  Profiles  . . . . . . . . . . . . . . . . . . . . . . . . . .  14\n
    \    5.1.  Profiles Must Not Be Multiplied beyond Necessity  . . . .  14\n     5.2.
    \ Rules . . . . . . . . . . . . . . . . . . . . . . . . . .  15\n       5.2.1.
    \ Width Mapping Rule  . . . . . . . . . . . . . . . . .  15\n       5.2.2.  Additional
    Mapping Rule . . . . . . . . . . . . . . .  15\n       5.2.3.  Case Mapping Rule
    . . . . . . . . . . . . . . . . . .  16\n       5.2.4.  Normalization Rule  .
    . . . . . . . . . . . . . . . .  16\n       5.2.5.  Directionality Rule . . .
    . . . . . . . . . . . . . .  17\n     5.3.  A Note about Spaces . . . . . . .
    . . . . . . . . . . . .  18\n   6.  Applications  . . . . . . . . . . . . . .
    . . . . . . . . . .  18\n     6.1.  How to Use PRECIS in Applications . . . .
    . . . . . . . .  18\n     6.2.  Further Excluded Characters . . . . . . . . .
    . . . . . .  20\n     6.3.  Building Application-Layer Constructs . . . . . .
    . . . .  20\n   7.  Order of Operations . . . . . . . . . . . . . . . . . . .
    . .  21\n   8.  Code Point Properties . . . . . . . . . . . . . . . . . . . .
    \ 21\n   9.  Category Definitions Used to Calculate Derived Property . . .  24\n
    \    9.1.  LetterDigits (A)  . . . . . . . . . . . . . . . . . . . .  25\n     9.2.
    \ Unstable (B)  . . . . . . . . . . . . . . . . . . . . . .  25\n     9.3.  IgnorableProperties
    (C) . . . . . . . . . . . . . . . . .  25\n     9.4.  IgnorableBlocks (D) . .
    . . . . . . . . . . . . . . . . .  25\n     9.5.  LDH (E) . . . . . . . . . .
    . . . . . . . . . . . . . . .  25\n     9.6.  Exceptions (F)  . . . . . . . .
    . . . . . . . . . . . . .  25\n     9.7.  BackwardCompatible (G)  . . . . . .
    . . . . . . . . . . .  25\n     9.8.  JoinControl (H) . . . . . . . . . . . .
    . . . . . . . . .  26\n     9.9.  OldHangulJamo (I) . . . . . . . . . . . . .
    . . . . . . .  26\n     9.10. Unassigned (J)  . . . . . . . . . . . . . . . .
    . . . . .  26\n     9.11. ASCII7 (K)  . . . . . . . . . . . . . . . . . . . .
    . . .  26\n     9.12. Controls (L)  . . . . . . . . . . . . . . . . . . . . .
    .  27\n     9.13. PrecisIgnorableProperties (M) . . . . . . . . . . . . . .  27\n
    \    9.14. Spaces (N)  . . . . . . . . . . . . . . . . . . . . . . .  27\n     9.15.
    Symbols (O) . . . . . . . . . . . . . . . . . . . . . . .  27\n     9.16. Punctuation
    (P) . . . . . . . . . . . . . . . . . . . . .  27\n     9.17. HasCompat (Q) .
    . . . . . . . . . . . . . . . . . . . . .  28\n     9.18. OtherLetterDigits (R)
    . . . . . . . . . . . . . . . . . .  28\n   10. Guidelines for Designated Experts
    . . . . . . . . . . . . . .  28\n   11. IANA Considerations . . . . . . . . .
    . . . . . . . . . . . .  29\n     11.1.  PRECIS Derived Property Value Registry
    . . . . . . . . .  29\n     11.2.  PRECIS Base Classes Registry . . . . . . .
    . . . . . . .  29\n     11.3.  PRECIS Profiles Registry . . . . . . . . . . .
    . . . . .  30\n   12. Security Considerations . . . . . . . . . . . . . . . .
    . . .  32\n     12.1.  General Issues . . . . . . . . . . . . . . . . . . . .
    .  32\n     12.2.  Use of the IdentifierClass . . . . . . . . . . . . . . .  33\n
    \    12.3.  Use of the FreeformClass . . . . . . . . . . . . . . . .  33\n     12.4.
    \ Local Character Set Issues . . . . . . . . . . . . . . .  33\n     12.5.  Visually
    Similar Characters  . . . . . . . . . . . . . .  33\n     12.6.  Security of Passwords
    \ . . . . . . . . . . . . . . . . .  35\n   13. Interoperability Considerations
    . . . . . . . . . . . . . . .  36\n     13.1.  Coded Character Sets . . . . .
    . . . . . . . . . . . . .  36\n     13.2.  Dependency on Unicode  . . . . . .
    . . . . . . . . . . .  37\n     13.3.  Encoding . . . . . . . . . . . . . . .
    . . . . . . . . .  37\n     13.4.  Unicode Versions . . . . . . . . . . . . .
    . . . . . . .  37\n     13.5.  Potential Changes to Handling of Certain Unicode
    Code\n            Points . . . . . . . . . . . . . . . . . . . . . . . . .  37\n
    \  14. References  . . . . . . . . . . . . . . . . . . . . . . . . .  38\n     14.1.
    \ Normative References . . . . . . . . . . . . . . . . . .  38\n     14.2.  Informative
    References . . . . . . . . . . . . . . . . .  39\n   Appendix A.  Changes from
    RFC 7564  . . . . . . . . . . . . . . .  43\n   Acknowledgements  . . . . . .
    . . . . . . . . . . . . . . . . . .  43\n   Authors' Addresses  . . . . . . .
    . . . . . . . . . . . . . . . .  43\n"
  title: Table of Contents
- contents:
  - "1.  Introduction\n   Application protocols using Unicode code points [Unicode]
    in protocol\n   strings need to properly handle such strings in order to enforce\n
    \  internationalization rules for strings placed in various protocol\n   slots
    (such as addresses and identifiers) and to perform valid\n   comparison operations
    (e.g., for purposes of authentication or\n   authorization).  This document defines
    a framework enabling\n   application protocols to perform the preparation, enforcement,
    and\n   comparison of internationalized strings (\"PRECIS\") in a way that\n   depends
    on the properties of Unicode code points and thus is more\n   agile with respect
    to versions of Unicode.  (Note: PRECIS is\n   restricted to Unicode and does not
    support any other coded character\n   set [RFC6365].)\n   As described in the
    PRECIS problem statement [RFC6885], many IETF\n   protocols have used the Stringprep
    framework [RFC3454] as the basis\n   for preparing, enforcing, and comparing protocol
    strings that contain\n   Unicode code points, especially code points outside the
    ASCII range\n   [RFC20].  The Stringprep framework was developed during work on
    the\n   original technology for internationalized domain names (IDNs), here\n
    \  called \"IDNA2003\" [RFC3490], and Nameprep [RFC3491] was the\n   Stringprep
    profile for IDNs.  At the time, Stringprep was designed as\n   a general framework
    so that other application protocols could define\n   their own Stringprep profiles.
    \ Indeed, a number of application\n   protocols defined such profiles.\n   After
    the publication of [RFC3454] in 2002, several significant\n   issues arose with
    the use of Stringprep in the IDN case, as\n   documented in the IAB's recommendations
    regarding IDNs [RFC4690]\n   (most significantly, Stringprep was tied to Unicode
    version 3.2).\n   Therefore, the newer IDNA specifications, here called \"IDNA2008\"\n
    \  [RFC5890] [RFC5891] [RFC5892] [RFC5893] [RFC5894], no longer use\n   Stringprep
    and Nameprep.  This migration away from Stringprep for\n   IDNs prompted other
    \"customers\" of Stringprep to consider new\n   approaches to the preparation,
    enforcement, and comparison of\n   internationalized strings, as described in
    [RFC6885].\n   This document defines a framework for a post-Stringprep approach
    to\n   the preparation, enforcement, and comparison of internationalized\n   strings
    in application protocols, based on several principles:\n   1.  Define a small
    set of string classes that specify the Unicode\n       code points appropriate
    for common application-protocol\n       constructs (where possible, maintaining
    compatibility with\n       IDNA2008 to help ensure a more consistent user experience).\n
    \  2.  Define each PRECIS string class in terms of Unicode code points\n       and
    their properties so that an algorithm can be used to\n       determine whether
    each code point or character category is\n       (a) valid, (b) allowed in certain
    contexts, (c) disallowed, or\n       (d) unassigned.\n   3.  Use an \"inclusion
    model\" such that a string class consists only\n       of code points that are
    explicitly allowed, with the result that\n       any code point not explicitly
    allowed is forbidden.\n   4.  Enable application protocols to define profiles
    of the PRECIS\n       string classes if necessary (addressing matters such as
    width\n       mapping, case mapping, Unicode normalization, and\n       directionality),
    but strongly discourage the multiplication of\n       profiles beyond necessity
    in order to avoid violations of the\n       \"Principle of Least Astonishment\".\n
    \  It is expected that this framework will yield the following benefits:\n   o
    \ Application protocols will be more agile with regard to Unicode\n      versions
    (recognizing that complete agility cannot be realized in\n      practice).\n   o
    \ Implementers will be able to share code point tables and software\n      code
    across application protocols, most likely by means of\n      software libraries.\n
    \  o  End users will be able to acquire more accurate expectations about\n      the
    code points that are acceptable in various contexts.  Given\n      this more uniform
    set of string classes, it is also expected that\n      copy/paste operations between
    software implementing different\n      application protocols will be more predictable
    and coherent.\n   Whereas the string classes define the \"baseline\" code points
    for a\n   range of applications, profiling enables application protocols to\n
    \  apply the string classes in ways that are appropriate for common\n   constructs
    such as usernames [RFC8265], opaque strings such as\n   passwords [RFC8265], and
    nicknames [RFC8266].  Profiles are\n   responsible for defining the handling of
    right-to-left code points as\n   well as various mapping operations of the kind
    also discussed for\n   IDNs in [RFC5895], such as case preservation or lowercasing,
    Unicode\n   normalization, mapping of certain code points to other code points
    or\n   to nothing, and mapping of fullwidth and halfwidth code points.\n   When
    an application applies a profile of a PRECIS string class, it\n   transforms an
    input string (which might or might not be conforming)\n   into an output string
    that definitively conforms to the profile.  In\n   particular, this document focuses
    on the resulting ability to achieve\n   the following objectives:\n   a.  Enforcing
    all the rules of a profile for a single output string\n       to check whether
    the output string conforms to the rules of the\n       profile and thus determine
    if a string can be included in a\n       protocol slot, communicated to another
    entity within a protocol,\n       stored in a retrieval system, etc.\n   b.  Comparing
    two output strings to determine if they are equivalent,\n       typically through
    octet-for-octet matching to test for\n       \"bit-string identity\" (e.g., to
    make an access decision for\n       purposes of authentication or authorization
    as further described\n       in [RFC6943]).\n   The opportunity to define profiles
    naturally introduces the\n   possibility of a proliferation of profiles, thus
    potentially\n   mitigating the benefits of common code and violating user\n   expectations.
    \ See Section 5 for a discussion of this important\n   topic.\n   In addition,
    it is extremely important for protocol designers and\n   application developers
    to understand that the transformation of an\n   input string to an output string
    is rarely reversible.  As one\n   relatively simple example, case mapping would
    transform an input\n   string of \"StPeter\" to an output string of \"stpeter\",
    thus leading to\n   a loss of information about the capitalization of the first
    and third\n   characters.  Similar considerations apply to other forms of mapping\n
    \  and normalization.\n   Although this framework is similar to IDNA2008 and includes
    by\n   reference some of the character categories defined in [RFC5892], it\n   defines
    additional character categories to meet the needs of common\n   application protocols
    other than DNS.\n   The character categories and calculation rules defined under\n
    \  Sections 8 and 9 are normative and apply to all Unicode code points.\n   The
    code point table that results from applying the character\n   categories and calculation
    rules to the latest version of Unicode can\n   be found in an IANA registry (see
    Section 11).\n"
  title: 1.  Introduction
- contents:
  - "2.  Terminology\n   Many important terms used in this document are defined in
    [RFC5890],\n   [RFC6365], [RFC6885], and [Unicode].  The terms \"left-to-right\"
    (LTR)\n   and \"right-to-left\" (RTL) are defined in Unicode Standard Annex #9\n
    \  [UAX9].\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\",
    \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"NOT RECOMMENDED\",
    \"MAY\", and\n   \"OPTIONAL\" in this document are to be interpreted as described
    in\n   BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all\n   capitals,
    as shown here.\n"
  title: 2.  Terminology
- contents:
  - "3.  Preparation, Enforcement, and Comparison\n   This document distinguishes
    between three different actions that an\n   entity can take with regard to a string:\n
    \  o  Enforcement entails applying all of the rules specified for a\n      particular
    string class, or profile thereof, to a single input\n      string, for the purpose
    of checking whether the string conforms to\n      all of the rules and thus determining
    if the string can be used in\n      a given protocol slot.\n   o  Comparison entails
    applying all of the rules specified for a\n      particular string class, or profile
    thereof, to two separate input\n      strings, for the purpose of determining
    if the two strings are\n      equivalent.\n   o  Preparation primarily entails
    ensuring that the code points in a\n      single input string are allowed by the
    underlying PRECIS string\n      class, and sometimes also entails applying one
    or more of the\n      rules specified for a particular string class or profile
    thereof.\n      Preparation can be appropriate for constrained devices that can
    to\n      some extent restrict the code points in a string to a limited\n      repertoire
    of characters but that do not have the processing power\n      or onboard memory
    to perform operations such as Unicode\n      normalization.  However, preparation
    does not ensure that an input\n      string conforms to all of the rules for a
    string class or profile\n      thereof.\n         Note: The term \"preparation\"
    as used in this specification and\n         related documents has a much more
    limited scope than it did in\n         Stringprep; it essentially refers to a
    kind of preprocessing of\n         an input string, not the actual operations
    that apply\n         internationalization rules to produce an output string (here\n
    \        termed \"enforcement\") or to compare two output strings (here\n         termed
    \"comparison\").\n   In most cases, authoritative entities such as servers are
    responsible\n   for enforcement, whereas subsidiary entities such as clients are\n
    \  responsible only for preparation.  The rationale for this distinction\n   is
    that clients might not have the facilities (in terms of device\n   memory and
    processing power) to enforce all the rules regarding\n   internationalized strings
    (such as width mapping and Unicode\n   normalization), although they can more
    easily limit the repertoire of\n   characters they offer to an end user.  By contrast,
    it is assumed\n   that a server would have more capacity to enforce the rules,
    and in\n   any case a server acts as an authority regarding allowable strings
    in\n   protocol slots such as addresses and endpoint identifiers.  In\n   addition,
    a client cannot necessarily be trusted to properly generate\n   such strings,
    especially for security-sensitive contexts such as\n   authentication and authorization.\n"
  title: 3.  Preparation, Enforcement, and Comparison
- contents:
  - '4.  String Classes

    '
  - contents:
    - "4.1.  Overview\n   Starting in 2010, various \"customers\" of Stringprep began
      to discuss\n   the need to define a post-Stringprep approach to the preparation
      and\n   comparison of internationalized strings other than IDNs.  This\n   community
      analyzed the existing Stringprep profiles and also weighed\n   the costs and
      benefits of defining a relatively small set of Unicode\n   code points that
      would minimize the potential for user confusion\n   caused by visually similar
      code points (and thus be relatively\n   \"safe\") vs. defining a much larger
      set of Unicode code points that\n   would maximize the potential for user creativity
      (and thus be\n   relatively \"expressive\").  As a result, the community concluded
      that\n   most existing uses could be addressed by two string classes:\n   IdentifierClass:
      \ a sequence of letters, numbers, and some symbols\n      that is used to identify
      or address a network entity such as a\n      user account, a venue (e.g., a
      chat room), an information source\n      (e.g., a data feed), or a collection
      of data (e.g., a file); the\n      intent is that this class will minimize user
      confusion in a wide\n      variety of application protocols, with the result
      that safety has\n      been prioritized over expressiveness for this class.\n
      \  FreeformClass:  a sequence of letters, numbers, symbols, spaces, and\n      other
      code points that is used for free-form strings, including\n      passwords as
      well as display elements such as human-friendly\n      nicknames for devices
      or for participants in a chat room; the\n      intent is that this class will
      allow nearly any Unicode code\n      point, with the result that expressiveness
      has been prioritized\n      over safety for this class.  Note well that protocol
      designers,\n      application developers, service providers, and end users might
      not\n      understand or be able to enter all of the code points that can be\n
      \     included in the FreeformClass (see Section 12.3 for details).\n   Future
      specifications might define additional PRECIS string classes,\n   such as a
      class that falls somewhere between the IdentifierClass and\n   the FreeformClass.
      \ At this time, it is not clear how useful such a\n   class would be.  In any
      case, because application developers are able\n   to define profiles of PRECIS
      string classes, a protocol needing a\n   construct between the IdentifierClass
      and the FreeformClass could\n   define a restricted profile of the FreeformClass
      if needed.\n   The following subsections discuss the IdentifierClass and\n   FreeformClass
      in more detail, with reference to the dimensions\n   described in Section 5
      of [RFC6885].  Each string class is defined by\n   the following behavioral
      rules:\n   Valid:  Defines which code points are treated as valid for the\n
      \     string.\n   Contextual Rule Required:  Defines which code points are treated
      as\n      allowed only if the requirements of a contextual rule are met\n      (i.e.,
      either CONTEXTJ or CONTEXTO as originally defined in the\n      IDNA2008 specifications).\n
      \  Disallowed:  Defines which code points need to be excluded from the\n      string.\n
      \  Unassigned:  Defines application behavior in the presence of code\n      points
      that are unknown (i.e., not yet designated) for the version\n      of Unicode
      used by the application.\n   This document defines the valid, contextual rule
      required,\n   disallowed, and unassigned rules for the IdentifierClass and\n
      \  FreeformClass.  As described under Section 5, profiles of these\n   string
      classes are responsible for defining the width mapping,\n   additional mapping,
      case mapping, normalization, and directionality\n   rules.\n"
    title: 4.1.  Overview
  - contents:
    - "4.2.  IdentifierClass\n   Most application technologies need strings that can
      be used to refer\n   to, include, or communicate protocol strings like usernames,\n
      \  filenames, data feed identifiers, and chat room names.  We group such\n   strings
      into a class called \"IdentifierClass\" having the following\n   features.\n"
    - contents:
      - "4.2.1.  Valid\n   o  Code points traditionally used as letters and numbers
        in writing\n      systems, i.e., the LetterDigits (\"A\") category first defined
        in\n      [RFC5892] and listed here under Section 9.1.\n   o  Code points
        in the range U+0021 through U+007E, i.e., the\n      (printable) ASCII7 (\"K\")
        category defined under Section 9.11.\n      These code points are \"grandfathered\"
        into PRECIS and thus are\n      valid even if they would otherwise be disallowed
        according to the\n      property-based rules specified in the next section.\n
        \     Note: Although the PRECIS IdentifierClass reuses the LetterDigits\n
        \     category from IDNA2008, the range of code points allowed in the\n      IdentifierClass
        is wider than the range of code points allowed in\n      IDNA2008.  The main
        reason is that IDNA2008 applies the\n      Unstable (\"B\") category (Section
        9.2) before the LetterDigits\n      category, thus disallowing uppercase code
        points, whereas the\n      IdentifierClass does not apply the Unstable category.\n"
      title: 4.2.1.  Valid
    - contents:
      - "4.2.2.  Contextual Rule Required\n   o  A number of code points from the
        Exceptions (\"F\") category defined\n      under Section 9.6.\n   o  Joining
        code points, i.e., the JoinControl (\"H\") category defined\n      under Section
        9.8.\n"
      title: 4.2.2.  Contextual Rule Required
    - contents:
      - "4.2.3.  Disallowed\n   o  Old Hangul Jamo code points, i.e., the OldHangulJamo
        (\"I\")\n      category defined under Section 9.9.\n   o  Control code points,
        i.e., the Controls (\"L\") category defined\n      under Section 9.12.\n   o
        \ Ignorable code points, i.e., the PrecisIgnorableProperties (\"M\")\n      category
        defined under Section 9.13.\n   o  Space code points, i.e., the Spaces (\"N\")
        category defined under\n      Section 9.14.\n   o  Symbol code points, i.e.,
        the Symbols (\"O\") category defined under\n      Section 9.15.\n   o  Punctuation
        code points, i.e., the Punctuation (\"P\") category\n      defined under Section
        9.16.\n   o  Any code point that is decomposed and recomposed into something\n
        \     other than itself under Unicode Normalization Form KC, i.e., the\n      HasCompat
        (\"Q\") category defined under Section 9.17.  These code\n      points are
        disallowed even if they would otherwise be valid\n      according to the property-based
        rules specified in the previous\n      section.\n   o  Letters and digits
        other than the \"traditional\" letters and digits\n      allowed in IDNs,
        i.e., the OtherLetterDigits (\"R\") category\n      defined under Section
        9.18.\n"
      title: 4.2.3.  Disallowed
    - contents:
      - "4.2.4.  Unassigned\n   Any code points that are not yet designated in the
        Unicode coded\n   character set are considered unassigned for purposes of
        the\n   IdentifierClass, and such code points are to be treated as\n   disallowed.
        \ See Section 9.10.\n"
      title: 4.2.4.  Unassigned
    - contents:
      - "4.2.5.  Examples\n   As described in the Introduction to this document, the
        string classes\n   do not handle all issues related to string preparation
        and comparison\n   (such as case mapping); instead, such issues are handled
        at the level\n   of profiles.  Examples for profiles of the IdentifierClass
        can be\n   found in [RFC8265] (the UsernameCaseMapped and UsernameCasePreserved\n
        \  profiles).\n"
      title: 4.2.5.  Examples
    title: 4.2.  IdentifierClass
  - contents:
    - "4.3.  FreeformClass\n   Some application technologies need strings that can
      be used in a\n   free-form way, e.g., as a password in an authentication exchange
      (see\n   [RFC8265]) or a nickname in a chat room (see [RFC8266]).  We group\n
      \  such things into a class called \"FreeformClass\" having the following\n
      \  features.\n      Security Warning: As mentioned, the FreeformClass prioritizes\n
      \     expressiveness over safety; Section 12.3 describes some of the\n      security
      hazards involved with using or profiling the\n      FreeformClass.\n      Security
      Warning: Consult Section 12.6 for relevant security\n      considerations when
      strings conforming to the FreeformClass, or a\n      profile thereof, are used
      as passwords.\n"
    - contents:
      - "4.3.1.  Valid\n   o  Traditional letters and numbers, i.e., the LetterDigits
        (\"A\")\n      category first defined in [RFC5892] and listed here under\n
        \     Section 9.1.\n   o  Code points in the range U+0021 through U+007E,
        i.e., the\n      (printable) ASCII7 (\"K\") category defined under Section
        9.11.\n   o  Space code points, i.e., the Spaces (\"N\") category defined
        under\n      Section 9.14.\n   o  Symbol code points, i.e., the Symbols (\"O\")
        category defined under\n      Section 9.15.\n   o  Punctuation code points,
        i.e., the Punctuation (\"P\") category\n      defined under Section 9.16.\n
        \  o  Any code point that is decomposed and recomposed into something\n      other
        than itself under Unicode Normalization Form KC, i.e., the\n      HasCompat
        (\"Q\") category defined under Section 9.17.\n   o  Letters and digits other
        than the \"traditional\" letters and digits\n      allowed in IDNs, i.e.,
        the OtherLetterDigits (\"R\") category\n      defined under Section 9.18.\n"
      title: 4.3.1.  Valid
    - contents:
      - "4.3.2.  Contextual Rule Required\n   o  A number of code points from the
        Exceptions (\"F\") category defined\n      under Section 9.6.\n   o  Joining
        code points, i.e., the JoinControl (\"H\") category defined\n      under Section
        9.8.\n"
      title: 4.3.2.  Contextual Rule Required
    - contents:
      - "4.3.3.  Disallowed\n   o  Old Hangul Jamo code points, i.e., the OldHangulJamo
        (\"I\")\n      category defined under Section 9.9.\n   o  Control code points,
        i.e., the Controls (\"L\") category defined\n      under Section 9.12.\n   o
        \ Ignorable code points, i.e., the PrecisIgnorableProperties (\"M\")\n      category
        defined under Section 9.13.\n"
      title: 4.3.3.  Disallowed
    - contents:
      - "4.3.4.  Unassigned\n   Any code points that are not yet designated in the
        Unicode coded\n   character set are considered unassigned for purposes of
        the\n   FreeformClass, and such code points are to be treated as disallowed.\n"
      title: 4.3.4.  Unassigned
    - contents:
      - "4.3.5.  Examples\n   As described in the Introduction to this document, the
        string classes\n   do not handle all issues related to string preparation
        and comparison\n   (such as case mapping); instead, such issues are handled
        at the level\n   of profiles.  Examples for profiles of the FreeformClass
        can be found\n   in [RFC8265] (the OpaqueString profile) and [RFC8266] (the
        Nickname\n   profile).\n"
      title: 4.3.5.  Examples
    title: 4.3.  FreeformClass
  - contents:
    - "4.4.  Summary\n   The following table summarizes the differences between the\n
      \  IdentifierClass and the FreeformClass (i.e., the disposition of a\n   code
      point as valid, contextual rule required, disallowed, or\n   unassigned), depending
      on its PRECIS category.\n    +===============================+=================+===============+\n
      \   |        CATEGORY               | IDENTIFIERCLASS | FREEFORMCLASS |\n    +===============================+=================+===============+\n
      \   | (A) LetterDigits              | Valid           | Valid         |\n    +-------------------------------+-----------------+---------------+\n
      \   | (B) Unstable                  |          [N/A (unused)]         |\n    +-------------------------------+-----------------+---------------+\n
      \   | (C) IgnorableProperties       |          [N/A (unused)]         |\n    +-------------------------------+-----------------+---------------+\n
      \   | (D) IgnorableBlocks           |          [N/A (unused)]         |\n    +-------------------------------+-----------------+---------------+\n
      \   | (E) LDH                       |          [N/A (unused)]         |\n    +-------------------------------+-----------------+---------------+\n
      \   | (F) Exceptions                | Contextual      | Contextual    |\n    |
      \                              | Rule Required   | Rule Required |\n    +-------------------------------+-----------------+---------------+\n
      \   | (G) BackwardCompatible        |      [Handled by IDNA Rules]    |\n    +-------------------------------+-----------------+---------------+\n
      \   | (H) JoinControl               | Contextual      | Contextual    |\n    |
      \                              | Rule Required   | Rule Required |\n    +-------------------------------+-----------------+---------------+\n
      \   | (I) OldHangulJamo             | Disallowed      | Disallowed    |\n    +-------------------------------+-----------------+---------------+\n
      \   | (J) Unassigned                | Unassigned      | Unassigned    |\n    +-------------------------------+-----------------+---------------+\n
      \   | (K) ASCII7                    | Valid           | Valid         |\n    +-------------------------------+-----------------+---------------+\n
      \   | (L) Controls                  | Disallowed      | Disallowed    |\n    +-------------------------------+-----------------+---------------+\n
      \   | (M) PrecisIgnorableProperties | Disallowed      | Disallowed    |\n    +-------------------------------+-----------------+---------------+\n
      \   | (N) Spaces                    | Disallowed      | Valid         |\n    +-------------------------------+-----------------+---------------+\n
      \   | (O) Symbols                   | Disallowed      | Valid         |\n    +-------------------------------+-----------------+---------------+\n
      \   | (P) Punctuation               | Disallowed      | Valid         |\n    +-------------------------------+-----------------+---------------+\n
      \   | (Q) HasCompat                 | Disallowed      | Valid         |\n    +-------------------------------+-----------------+---------------+\n
      \   | (R) OtherLetterDigits         | Disallowed      | Valid         |\n    +-------------------------------+-----------------+---------------+\n
      \             Table 1: Comparative Disposition of Code Points\n"
    title: 4.4.  Summary
  title: 4.  String Classes
- contents:
  - "5.  Profiles\n   This framework document defines the valid, contextual rule required,\n
    \  disallowed, and unassigned rules for the IdentifierClass and the\n   FreeformClass.
    \ A profile of a PRECIS string class MUST define the\n   width mapping, additional
    mapping (if any), case mapping,\n   normalization, and directionality rules.  A
    profile MAY also restrict\n   the allowable code points above and beyond the definition
    of the\n   relevant PRECIS string class (but MUST NOT add as valid any code\n
    \  points that are disallowed by the relevant PRECIS string class).\n   These
    matters are discussed in the following subsections.\n   Profiles of the PRECIS
    string classes are registered with the IANA as\n   described under Section 11.3.
    \ Profile names use the following\n   convention: they are of the form \"Profilename
    of BaseClass\", where\n   the \"Profilename\" string is a differentiator and \"BaseClass\"
    is the\n   name of the PRECIS string class being profiled; for example, the\n
    \  profile used for opaque strings such as passwords is the OpaqueString\n   profile
    of the FreeformClass [RFC8265].\n"
  - contents:
    - "5.1.  Profiles Must Not Be Multiplied beyond Necessity\n   The risk of profile
      proliferation is significant because having too\n   many profiles will result
      in different behavior across various\n   applications, thus violating what is
      known in user interface design\n   as the \"Principle of Least Astonishment\".\n
      \  Indeed, we already have too many profiles.  Ideally, we would have at\n   most
      two or three profiles.  Unfortunately, numerous application\n   protocols exist
      with their own quirks regarding protocol strings.\n   Domain names, email addresses,
      instant messaging addresses, chat room\n   names, user nicknames or display
      names, filenames, authentication\n   identifiers, passwords, and other strings
      already exist in the wild\n   and need to be supported in existing application
      protocols such as\n   DNS, SMTP, the Extensible Messaging and Presence Protocol
      (XMPP),\n   Internet Relay Chat (IRC), NFS, the Internet Small Computer System\n
      \  Interface (iSCSI), the Extensible Authentication Protocol (EAP), and\n   the
      Simple Authentication and Security Layer (SASL) [RFC4422], among\n   others.\n
      \  Nevertheless, profiles must not be multiplied beyond necessity.\n   To help
      prevent profile proliferation, this document recommends\n   sensible defaults
      for the various options offered to profile creators\n   (such as width mapping
      and Unicode normalization).  In addition, the\n   guidelines for designated
      experts provided under Section 10 are meant\n   to encourage a high level of
      due diligence regarding new profiles.\n"
    title: 5.1.  Profiles Must Not Be Multiplied beyond Necessity
  - contents:
    - '5.2.  Rules

      '
    - contents:
      - "5.2.1.  Width Mapping Rule\n   The width mapping rule of a profile specifies
        whether width mapping\n   is performed on a string and how the mapping is
        done.  Typically,\n   such mapping consists of mapping fullwidth and halfwidth
        code points,\n   i.e., code points with a Decomposition Type of Wide or Narrow,
        to\n   their decomposition mappings; as an example, \"\uFF10\" (FULLWIDTH
        DIGIT\n   ZERO, U+FF10) would be mapped to \"0\" (DIGIT ZERO U+0030).\n   The
        normalization form specified by a profile (see below) has an\n   impact on
        the need for width mapping.  Because width mapping is\n   performed as a part
        of compatibility decomposition, a profile\n   employing either Normalization
        Form KD (NFKD) or Normalization\n   Form KC (NFKC) does not need to specify
        width mapping.  However, if\n   Unicode Normalization Form C (NFC) is used
        (as is recommended), then\n   the profile needs to specify whether to apply
        width mapping; in this\n   case, width mapping is in general RECOMMENDED because
        allowing\n   fullwidth and halfwidth code points to remain unmapped to their\n
        \  compatibility variants would violate the \"Principle of Least\n   Astonishment\".
        \ For more information about the concept of width in\n   East Asian scripts
        within Unicode, see Unicode Standard Annex #11\n   [UAX11].\n      Note: Because
        the East Asian width property is not guaranteed to\n      be stable by the
        Unicode Standard (see\n      <http://unicode.org/policies/stability_policy.html>
        for details),\n      the results of applying a given width mapping rule might
        not be\n      consistent across different versions of Unicode.\n"
      title: 5.2.1.  Width Mapping Rule
    - contents:
      - "5.2.2.  Additional Mapping Rule\n   The additional mapping rule of a profile
        specifies whether additional\n   mappings are performed on a string, such
        as:\n   o  Mapping of delimiter code points (such as '@', ':', '/', '+',\n
        \     and '-').\n   o  Mapping of special code points (e.g., non-ASCII space
        code points\n      to SPACE (U+0020) or control code points to nothing).\n
        \  The PRECIS mappings document [RFC7790] describes such mappings in\n   more
        detail.\n"
      title: 5.2.2.  Additional Mapping Rule
    - contents:
      - "5.2.3.  Case Mapping Rule\n   The case mapping rule of a profile specifies
        whether case mapping\n   (instead of case preservation) is performed on a
        string and how the\n   mapping is applied (e.g., mapping uppercase and titlecase
        code points\n   to their lowercase equivalents).\n   If case mapping is desired
        (instead of case preservation), it is\n   RECOMMENDED to use the Unicode toLowerCase()
        operation defined in the\n   Unicode Standard [Unicode].  In contrast to the
        Unicode toCaseFold()\n   operation, the toLowerCase() operation is less likely
        to violate the\n   \"Principle of Least Astonishment\", especially when an
        application\n   merely wishes to convert uppercase and titlecase code points
        to their\n   lowercase equivalents while preserving lowercase code points.\n
        \  Although the toCaseFold() operation can be appropriate when an\n   application
        needs to compare two strings (such as in search\n   operations), in general
        few application developers and even fewer\n   users understand its implications,
        so toLowerCase() is almost always\n   the safer choice.\n      Note: Neither
        toLowerCase() nor toCaseFold() is designed to handle\n      various language-specific
        issues, such as the character \"\u0131\" (LATIN\n      SMALL LETTER DOTLESS
        I, U+0131) in several Turkic languages.  The\n      reader is referred to
        the PRECIS mappings document [RFC7790],\n      which describes these issues
        in greater detail.\n   In order to maximize entropy and minimize the potential
        for false\n   accepts, it is NOT RECOMMENDED for application protocols to
        map\n   uppercase and titlecase code points to their lowercase equivalents\n
        \  when strings conforming to the FreeformClass, or a profile thereof,\n   are
        used in passwords; instead, it is RECOMMENDED to preserve the\n   case of
        all code points contained in such strings and then perform\n   case-sensitive
        comparison.  See also the related discussion in\n   Section 12.6 of this document
        and in [RFC8265].\n"
      title: 5.2.3.  Case Mapping Rule
    - contents:
      - "5.2.4.  Normalization Rule\n   The normalization rule of a profile specifies
        which Unicode\n   Normalization Form (D, KD, C, or KC) is to be applied (see
        Unicode\n   Standard Annex #15 [UAX15] for background information).\n   In
        accordance with [RFC5198], Normalization Form C (NFC) is\n   RECOMMENDED.\n
        \  Protocol designers and application developers need to understand that\n
        \  certain Unicode normalization forms, especially NFKC and NFKD, can\n   result
        in significant loss of information in various circumstances\n   and that these
        circumstances can depend on the language and script of\n   the strings to
        which the normalization forms are applied.  Extreme\n   care should be taken
        when specifying the use of these normalization\n   forms.\n"
      title: 5.2.4.  Normalization Rule
    - contents:
      - "5.2.5.  Directionality Rule\n   The directionality rule of a profile specifies
        how to treat strings\n   containing what are often called \"right-to-left\"
        (RTL) code points\n   (see Unicode Standard Annex #9 [UAX9]).  RTL code points
        come from\n   scripts that are normally written from right to left and are\n
        \  considered by Unicode to, themselves, have right-to-left\n   directionality.
        \ Some strings containing RTL code points also contain\n   \"left-to-right\"
        (LTR) code points, such as ASCII numerals, as well as\n   code points without
        directional properties.  Consequently, such\n   strings are known as \"bidirectional
        strings\".\n   Presenting bidirectional strings in different layout systems
        (e.g., a\n   user interface that is configured to handle primarily an RTL
        script\n   vs. an interface that is configured to handle primarily an LTR\n
        \  script) can yield display results that, while predictable to those\n   who
        understand the display rules, are counterintuitive to casual\n   users.  In
        particular, the same bidirectional string (in PRECIS\n   terms) might not
        be presented in the same way to users of those\n   different layout systems,
        even though the presentation is consistent\n   within any particular layout
        system.  In some applications, these\n   presentation differences might be
        considered problematic and thus the\n   application designers might wish to
        restrict the use of bidirectional\n   strings by specifying a directionality
        rule.  In other applications,\n   these presentation differences might not
        be considered problematic\n   (this especially tends to be true of more \"free-form\"
        strings) and\n   thus no directionality rule is needed.\n   The PRECIS framework
        does not directly address how to deal with\n   bidirectional strings across
        all string classes and profiles nor does\n   it define any new directionality
        rules, because at present there is\n   no widely accepted and implemented
        solution for the safe display of\n   arbitrary bidirectional strings beyond
        the Unicode bidirectional\n   algorithm [UAX9].  Although rules for management
        and display of\n   bidirectional strings have been defined for domain name
        labels and\n   similar identifiers through the \"Bidi Rule\" specified in
        the IDNA2008\n   specification on right-to-left scripts [RFC5893], those rules
        are\n   quite restrictive and are not necessarily applicable to all\n   bidirectional
        strings.\n   The authors of a PRECIS profile might believe that they need
        to\n   define a new directionality rule of their own.  Because of the\n   complexity
        of the issues involved, such a belief is almost always\n   misguided, even
        if the authors have done a great deal of careful\n   research into the challenges
        of displaying bidirectional strings.\n   This document strongly suggests that
        profile authors who are thinking\n   about defining a new directionality rule
        should think again and\n   instead consider using the \"Bidi Rule\" [RFC5893]
        (for profiles based\n   on the IdentifierClass) or following the Unicode bidirectional\n
        \  algorithm [UAX9] (for profiles based on the FreeformClass or in\n   situations
        where the IdentifierClass is not appropriate).\n"
      title: 5.2.5.  Directionality Rule
    title: 5.2.  Rules
  - contents:
    - "5.3.  A Note about Spaces\n   With regard to the IdentifierClass, the consensus
      of the PRECIS\n   Working Group was that spaces are problematic for many reasons,\n
      \  including the following:\n   o  Many Unicode code points are confusable with
      SPACE (U+0020).\n   o  Even if non-ASCII space code points are mapped to SPACE
      (U+0020),\n      space code points are often not rendered in user interfaces,\n
      \     leading to the possibility that a human user might consider a\n      string
      containing spaces to be equivalent to the same string\n      without spaces.\n
      \  o  In some locales, some devices are known to generate a code point\n      other
      than SPACE (U+0020), such as ZERO WIDTH JOINER (U+200D),\n      when a user
      performs an action like pressing the space bar on a\n      keyboard.\n   One
      consequence of disallowing space code points in the\n   IdentifierClass might
      be to effectively discourage their use within\n   identifiers created in newer
      application protocols; given the\n   challenges involved with properly handling
      space code points\n   (especially non-ASCII space code points) in identifiers
      and other\n   protocol strings, the PRECIS Working Group considered this to
      be a\n   feature, not a bug.\n   However, the FreeformClass does allow spaces;
      this in turn enables\n   application protocols to define profiles of the FreeformClass
      that\n   are more flexible than any profiles of the IdentifierClass.  In\n   addition,
      as explained in Section 6.3, application protocols can also\n   define application-layer
      constructs containing spaces.\n"
    title: 5.3.  A Note about Spaces
  title: 5.  Profiles
- contents:
  - '6.  Applications

    '
  - contents:
    - "6.1.  How to Use PRECIS in Applications\n   Although PRECIS has been designed
      with applications in mind,\n   internationalization is not suddenly made easy
      through the use of\n   PRECIS.  Indeed, because it is extremely difficult for
      protocol\n   designers and application developers to do the right thing for
      all\n   users when supporting internationalized strings, often the safest\n
      \  option is to support only the ASCII range [RFC20] in various protocol\n   slots.
      \ This state of affairs is unfortunate but is the direct result\n   of the complexities
      involved with human languages (e.g., the vast\n   number of code points, scripts,
      user communities, and rules with\n   their inevitable exceptions), which kinds
      of strings application\n   developers and their users wish to support, the wide
      range of devices\n   that users employ to access services enabled by various
      Internet\n   protocols, and so on.\n   Despite these significant challenges,
      application and protocol\n   developers sometimes persevere in attempting to
      support\n   internationalized strings in their systems.  These developers need
      to\n   think carefully about how they will use the PRECIS string classes, or\n
      \  profiles thereof, in their applications.  This section provides some\n   guidelines
      to application developers (and to expert reviewers of\n   application-protocol
      specifications).\n   o  Don't define your own profile unless absolutely necessary
      (see\n      Section 5.1).  Existing profiles have been designed for wide\n      reuse.
      \ It is highly likely that an existing profile will meet\n      your needs,
      especially given the ability to specify further\n      excluded code points
      (Section 6.2) and to build application-layer\n      constructs (see Section
      6.3).\n   o  Do specify:\n      *  Exactly which entities are responsible for
      preparation,\n         enforcement, and comparison of internationalized strings
      (e.g.,\n         servers or clients).\n      *  Exactly when those entities
      need to complete their tasks (e.g.,\n         a server might need to enforce
      the rules of a profile before\n         allowing a client to gain network access).\n
      \     *  Exactly which protocol slots need to be checked against which\n         profiles
      (e.g., checking the address of a message's intended\n         recipient against
      the UsernameCaseMapped profile [RFC8265] of\n         the IdentifierClass or
      checking the password of a user against\n         the OpaqueString profile [RFC8265]
      of the FreeformClass).\n      See [RFC8265] and [RFC7622] for definitions of
      these matters for\n      several applications.\n"
    title: 6.1.  How to Use PRECIS in Applications
  - contents:
    - "6.2.  Further Excluded Characters\n   An application protocol that uses a profile
      MAY specify particular\n   code points that are not allowed in relevant slots
      within that\n   application protocol, above and beyond those excluded by the
      string\n   class or profile.\n   That is, an application protocol MAY do either
      of the following:\n   1.  Exclude specific code points that are allowed by the
      relevant\n       string class.\n   2.  Exclude code points matching certain
      Unicode properties (e.g.,\n       math symbols) that are included in the relevant
      PRECIS string\n       class.\n   As a result of such exclusions, code points
      that are defined as valid\n   for the PRECIS string class or profile will be
      defined as disallowed\n   for the relevant protocol slot.\n   Typically, such
      exclusions are defined for the purpose of backward\n   compatibility with legacy
      formats within an application protocol.\n   These are defined for application
      protocols, not profiles, in order\n   to prevent multiplication of profiles
      beyond necessity (see\n   Section 5.1).\n"
    title: 6.2.  Further Excluded Characters
  - contents:
    - "6.3.  Building Application-Layer Constructs\n   Sometimes, an application-layer
      construct does not map in a\n   straightforward manner to one of the PRECIS
      string classes or a\n   profile thereof.  Consider, for example, the \"simple
      username\"\n   construct in SASL [RFC4422].  Depending on the deployment, a
      simple\n   username might take the form of a user's full name (e.g., the user's\n
      \  personal name followed by a space and then the user's family name).\n   Such
      a simple username cannot be defined as an instance of the\n   IdentifierClass
      or a profile thereof, because space code points are\n   not allowed in the IdentifierClass;
      however, it could be defined\n   using a space-separated sequence of IdentifierClass
      instances, as in\n   the following ABNF [RFC5234] from [RFC8265]:\n      username
      \  = userpart *(1*SP userpart)\n      userpart   = 1*(idpoint)\n                   ;\n
      \                  ; an \"idpoint\" is a Unicode code point that\n                   ;
      can be contained in a string conforming to\n                   ; the PRECIS
      IdentifierClass\n                   ;\n   Similar techniques could be used to
      define many application-layer\n   constructs, say of the form \"user@domain\"
      or \"/path/to/file\".\n"
    title: 6.3.  Building Application-Layer Constructs
  title: 6.  Applications
- contents:
  - "7.  Order of Operations\n   To ensure proper comparison, the rules specified
    for a particular\n   string class or profile MUST be applied in the following
    order:\n   1.  Width Mapping Rule\n   2.  Additional Mapping Rule\n   3.  Case
    Mapping Rule\n   4.  Normalization Rule\n   5.  Directionality Rule\n   6.  Behavioral
    rules for determining whether a code point is valid,\n       allowed under a contextual
    rule, disallowed, or unassigned\n   As already described, the width mapping, additional
    mapping, case\n   mapping, normalization, and directionality rules are specified
    for\n   each profile, whereas the behavioral rules are specified for each\n   string
    class.  Some of the logic behind this order is provided under\n   Section 5.2.1
    (see also the PRECIS mappings document [RFC7790]).  In\n   addition, this order
    is consistent with IDNA2008, and with both\n   IDNA2003 and Stringprep before
    then, for the purpose of enabling code\n   reuse and of ensuring as much continuity
    as possible with the\n   Stringprep profiles that are obsoleted by several PRECIS
    profiles.\n   Because of the order of operations specified here, applying the
    rules\n   for any given PRECIS profile is not necessarily an idempotent\n   procedure
    (e.g., under certain circumstances, such as when Unicode\n   Normalization Form
    KC is used, performing Unicode normalization after\n   case mapping can still
    yield uppercase characters for certain code\n   points).  Therefore, an implementation
    SHOULD apply the rules\n   repeatedly until the output string is stable; if the
    output string\n   does not stabilize after reapplying the rules three (3) additional\n
    \  times after the first application, the implementation SHOULD\n   terminate
    application of the rules and reject the input string as\n   invalid.\n"
  title: 7.  Order of Operations
- contents:
  - "8.  Code Point Properties\n   In order to implement the string classes described
    above, this\n   document does the following:\n   1.  Reviews and classifies the
    collections of code points in the\n       Unicode coded character set by examining
    various code point\n       properties.\n   2.  Defines an algorithm for determining
    a derived property value,\n       which can depend on the string class being used
    by the relevant\n       application protocol.\n   This document is not intended
    to specify precisely how derived\n   property values are to be applied in protocol
    strings.  That\n   information is the responsibility of the protocol specification
    that\n   uses or profiles a PRECIS string class from this document.  The value\n
    \  of the property is to be interpreted as follows.\n   PROTOCOL VALID  Those
    code points that are allowed to be used in any\n      PRECIS string class (currently,
    IdentifierClass and\n      FreeformClass).  The abbreviated term \"PVALID\" is
    used to refer to\n      this value in the remainder of this document.\n   SPECIFIC
    CLASS PROTOCOL VALID  Those code points that are allowed to\n      be used in
    specific string classes.  In the remainder of this\n      document, the abbreviated
    term *_PVAL is used, where * = (ID |\n      FREE), i.e., either \"FREE_PVAL\"
    for the FreeformClass or \"ID_PVAL\"\n      for the IdentifierClass.  In practice,
    the derived property\n      ID_PVAL is not used in this specification, because
    every ID_PVAL\n      code point is PVALID.\n   CONTEXTUAL RULE REQUIRED  Some
    characteristics of the code point,\n      such as its being invisible in certain
    contexts or problematic in\n      others, require that it not be used in a string
    unless specific\n      other code points or properties are present in the string.
    \ As in\n      IDNA2008, there are two subdivisions of CONTEXTUAL RULE REQUIRED:\n
    \     the first for Join_controls (called \"CONTEXTJ\") and the second for\n      other
    code points (called \"CONTEXTO\").  A string MUST NOT contain\n      any characters
    whose validity is context-dependent, unless the\n      validity is positively
    confirmed by a contextual rule.  To check\n      this, each code point identified
    as CONTEXTJ or CONTEXTO in the\n      \"PRECIS Derived Property Value\" registry
    (Section 11.1) MUST have\n      a non-null rule.  If such a code point is missing
    a rule, the\n      string is invalid.  If the rule exists but the result of applying\n
    \     the rule is negative or inconclusive, the proposed string is\n      invalid.
    \ The most notable of the CONTEXTUAL RULE REQUIRED code\n      points are the
    Join Control code points ZERO WIDTH JOINER (U+200D)\n      and ZERO WIDTH NON-JOINER
    (U+200C), which have a derived property\n      value of CONTEXTJ.  See Appendix
    A of [RFC5892] for more\n      information.\n   DISALLOWED  Those code points
    that are not permitted in any PRECIS\n      string class.\n   SPECIFIC CLASS DISALLOWED
    \ Those code points that are not to be\n      included in one of the string classes
    but that might be permitted\n      in others.  In the remainder of this document,
    the abbreviated\n      term *_DIS is used, where * = (ID | FREE), i.e., either
    \"FREE_DIS\"\n      for the FreeformClass or \"ID_DIS\" for the IdentifierClass.
    \ In\n      practice, the derived property FREE_DIS is not used in this\n      specification,
    because every FREE_DIS code point is DISALLOWED.\n   UNASSIGNED  Those code points
    that are not designated (i.e., are\n      unassigned) in the Unicode Standard.\n
    \  The algorithm to calculate the value of the derived property is as\n   follows
    (implementations MUST NOT modify the order of operations\n   within this algorithm,
    because doing so would cause inconsistent\n   results across implementations):\n
    \  If .cp. .in. Exceptions Then Exceptions(cp);\n   Else If .cp. .in. BackwardCompatible
    Then BackwardCompatible(cp);\n   Else If .cp. .in. Unassigned Then UNASSIGNED;\n
    \  Else If .cp. .in. ASCII7 Then PVALID;\n   Else If .cp. .in. JoinControl Then
    CONTEXTJ;\n   Else If .cp. .in. OldHangulJamo Then DISALLOWED;\n   Else If .cp.
    .in. PrecisIgnorableProperties Then DISALLOWED;\n   Else If .cp. .in. Controls
    Then DISALLOWED;\n   Else If .cp. .in. HasCompat Then ID_DIS or FREE_PVAL;\n   Else
    If .cp. .in. LetterDigits Then PVALID;\n   Else If .cp. .in. OtherLetterDigits
    Then ID_DIS or FREE_PVAL;\n   Else If .cp. .in. Spaces Then ID_DIS or FREE_PVAL;\n
    \  Else If .cp. .in. Symbols Then ID_DIS or FREE_PVAL;\n   Else If .cp. .in. Punctuation
    Then ID_DIS or FREE_PVAL;\n   Else DISALLOWED;\n   The value of the derived property
    calculated can depend on the string\n   class; for example, if an identifier used
    in an application protocol\n   is defined as profiling the PRECIS IdentifierClass
    then a space\n   character such as SPACE (U+0020) would be assigned to ID_DIS,
    whereas\n   if an identifier is defined as profiling the PRECIS FreeformClass\n
    \  then the character would be assigned to FREE_PVAL.  For the sake of\n   brevity,
    the designation \"FREE_PVAL\" is used herein, instead of the\n   longer designation
    \"ID_DIS or FREE_PVAL\".  In practice, the derived\n   properties ID_PVAL and
    FREE_DIS are not used in this specification,\n   because every ID_PVAL code point
    is PVALID and every FREE_DIS code\n   point is DISALLOWED.\n   Use of the name
    of a rule (such as \"Exceptions\") implies the set of\n   code points that the
    rule defines, whereas the same name as a\n   function call (such as \"Exceptions(cp)\")
    implies the value that the\n   code point has in the Exceptions table.\n   The
    mechanisms described here allow determination of the value of the\n   property
    for future versions of Unicode (including code points added\n   after Unicode
    5.2 or 7.0, depending on the category, because some\n   categories mentioned in
    this document are simply pointers to IDNA2008\n   and therefore were defined at
    the time of Unicode 5.2).  Changes in\n   Unicode properties that do not affect
    the outcome of this process\n   therefore do not affect this framework.  For example,
    a code point\n   can have its Unicode General_Category value change from So to
    Sm, or\n   from Lo to Ll, without affecting the algorithm results.  Moreover,\n
    \  even if such changes were to result, the BackwardCompatible list\n   (Section
    9.7) can be adjusted to ensure the stability of the results.\n"
  title: 8.  Code Point Properties
- contents:
  - "9.  Category Definitions Used to Calculate Derived Property\n   The derived property
    obtains its value based on a two-step procedure:\n   1.  Code points are placed
    in one or more character categories either\n       (1) based on core properties
    defined by the Unicode Standard or\n       (2) by treating the code point as an
    exception and addressing the\n       code point based on its code point value.
    \ These categories are\n       not mutually exclusive.\n   2.  Set operations
    are used with these categories to determine the\n       values for a property
    specific to a given string class.  These\n       operations are specified under
    Section 8.\n      Note: Unicode property names and property value names might
    have\n      short abbreviations, such as \"gc\" for the General_Category\n      property
    and \"Ll\" for the Lowercase_Letter property value of the\n      gc property.\n
    \  In the following specification of character categories, the operation\n   that
    returns the value of a particular Unicode code point property\n   for a code point
    is designated by using the formal name of that\n   property (from the Unicode
    PropertyAliases.txt file [PropertyAliases]\n   followed by \"(cp)\" for \"code
    point\".  For example, the value of the\n   General_Category property for a code
    point is indicated by\n   General_Category(cp).\n   The first ten categories (A-J)
    shown below were previously defined\n   for IDNA2008 and are referenced from [RFC5892]
    to ease the\n   understanding of how PRECIS handles various code points.  Some
    of\n   these categories are reused in PRECIS, and some of them are not;\n   however,
    the lettering of categories is retained to prevent overlap\n   and to ease implementation
    of both IDNA2008 and PRECIS in a single\n   software application.  The next eight
    categories (K-R) are specific\n   to PRECIS.\n"
  - contents:
    - "9.1.  LetterDigits (A)\n   This category is defined in Section 2.1 of [RFC5892]
      and is included\n   by reference for use in PRECIS.\n"
    title: 9.1.  LetterDigits (A)
  - contents:
    - "9.2.  Unstable (B)\n   This category is defined in Section 2.2 of [RFC5892].
      \ However, it is\n   not used in PRECIS.\n"
    title: 9.2.  Unstable (B)
  - contents:
    - "9.3.  IgnorableProperties (C)\n   This category is defined in Section 2.3 of
      [RFC5892].  However, it is\n   not used in PRECIS.\n   Note: See the PrecisIgnorableProperties
      (\"M\") category below for a\n   more inclusive category used in PRECIS identifiers.\n"
    title: 9.3.  IgnorableProperties (C)
  - contents:
    - "9.4.  IgnorableBlocks (D)\n   This category is defined in Section 2.4 of [RFC5892].
      \ However, it is\n   not used in PRECIS.\n"
    title: 9.4.  IgnorableBlocks (D)
  - contents:
    - "9.5.  LDH (E)\n   This category is defined in Section 2.5 of [RFC5892].  However,
      it is\n   not used in PRECIS.\n   Note: See the ASCII7 (\"K\") category below
      for a more inclusive\n   category used in PRECIS identifiers.\n"
    title: 9.5.  LDH (E)
  - contents:
    - "9.6.  Exceptions (F)\n   This category is defined in Section 2.6 of [RFC5892]
      and is included\n   by reference for use in PRECIS.\n"
    title: 9.6.  Exceptions (F)
  - contents:
    - "9.7.  BackwardCompatible (G)\n   This category is defined in Section 2.7 of
      [RFC5892] and is included\n   by reference for use in PRECIS.\n   Note: Management
      of this category is handled via the processes\n   specified in [RFC5892].  At
      the time of this writing (and also at the\n   time that RFC 5892 was published),
      this category consisted of the\n   empty set; however, that is subject to change
      as described in\n   RFC 5892.\n"
    title: 9.7.  BackwardCompatible (G)
  - contents:
    - "9.8.  JoinControl (H)\n   This category is defined in Section 2.8 of [RFC5892]
      and is included\n   by reference for use in PRECIS.\n   Note: In particular,
      the code points ZERO WIDTH JOINER (U+200D) and\n   ZERO WIDTH NON-JOINER (U+200C)
      are necessary to produce certain\n   combinations of characters in certain scripts
      (e.g., Arabic, Persian,\n   and Indic scripts), but if used in other contexts,
      they can have\n   consequences that violate the \"Principle of Least Astonishment\".\n
      \  Therefore, these code points are allowed only in contexts where they\n   are
      appropriate, specifically where the relevant rule (CONTEXTJ or\n   CONTEXTO)
      has been defined.  See [RFC5892] and [RFC5894] for further\n   discussion.\n"
    title: 9.8.  JoinControl (H)
  - contents:
    - "9.9.  OldHangulJamo (I)\n   This category is defined in Section 2.9 of [RFC5892]
      and is included\n   by reference for use in PRECIS.\n   Note: Exclusion of these
      code points results in disallowing certain\n   archaic Korean syllables and
      in restricting supported Korean\n   syllables to preformed, modern Hangul characters.\n"
    title: 9.9.  OldHangulJamo (I)
  - contents:
    - "9.10.  Unassigned (J)\n   This category is defined in Section 2.10 of [RFC5892]
      and is included\n   by reference for use in PRECIS.\n"
    title: 9.10.  Unassigned (J)
  - contents:
    - "9.11.  ASCII7 (K)\n   This PRECIS-specific category consists of all printable,
      non-space\n   code points from the 7-bit ASCII range.  By applying this category,\n
      \  the algorithm specified under Section 8 exempts these code points\n   from
      other rules that might be applied during PRECIS processing, on\n   the assumption
      that these code points are in such wide use that\n   disallowing them would
      be counterproductive.\n   K: cp is in {0021..007E}\n"
    title: 9.11.  ASCII7 (K)
  - contents:
    - "9.12.  Controls (L)\n   This PRECIS-specific category consists of all control
      code points,\n   such as LINE FEED (U+000A).\n   L: Control(cp) = True\n"
    title: 9.12.  Controls (L)
  - contents:
    - "9.13.  PrecisIgnorableProperties (M)\n   This PRECIS-specific category is used
      to group code points that are\n   discouraged from use in PRECIS string classes.\n
      \  M: Default_Ignorable_Code_Point(cp) = True or\n      Noncharacter_Code_Point(cp)
      = True\n   The definition for Default_Ignorable_Code_Point can be found in the\n
      \  DerivedCoreProperties.txt file [DerivedCoreProperties].\n   Note: In general,
      these code points are constructs such as so-called\n   \"soft hyphens\", certain
      joining code points, various specialized code\n   points for use within Unicode
      itself (e.g., language tags and\n   variation selectors), and so on.  Disallowing
      these code points in\n   PRECIS reduces the potential for unexpected results
      in the use of\n   internationalized strings.\n"
    title: 9.13.  PrecisIgnorableProperties (M)
  - contents:
    - "9.14.  Spaces (N)\n   This PRECIS-specific category is used to group code points
      that are\n   spaces.\n   N: General_Category(cp) is in {Zs}\n"
    title: 9.14.  Spaces (N)
  - contents:
    - "9.15.  Symbols (O)\n   This PRECIS-specific category is used to group code
      points that are\n   symbols.\n   O: General_Category(cp) is in {Sm, Sc, Sk,
      So}\n"
    title: 9.15.  Symbols (O)
  - contents:
    - "9.16.  Punctuation (P)\n   This PRECIS-specific category is used to group code
      points that are\n   punctuation.\n   P: General_Category(cp) is in {Pc, Pd,
      Ps, Pe, Pi, Pf, Po}\n"
    title: 9.16.  Punctuation (P)
  - contents:
    - "9.17.  HasCompat (Q)\n   This PRECIS-specific category is used to group any
      code point that is\n   decomposed and recomposed into something other than itself
      under\n   Unicode Normalization Form KC.\n   Q: toNFKC(cp) != cp\n   Typically,
      this category is true of code points that are\n   \"compatibility decomposable
      characters\" as defined in the Unicode\n   Standard.\n   The toNFKC() operation
      returns the code point in Normalization\n   Form KC.  For more information,
      see Unicode Standard Annex #15\n   [UAX15].\n"
    title: 9.17.  HasCompat (Q)
  - contents:
    - "9.18.  OtherLetterDigits (R)\n   This PRECIS-specific category is used to group
      code points that are\n   letters and digits other than the \"traditional\" letters
      and digits\n   grouped under the LetterDigits (\"A\") category (see Section
      9.1).\n   R: General_Category(cp) is in {Lt, Nl, No, Me}\n"
    title: 9.18.  OtherLetterDigits (R)
  title: 9.  Category Definitions Used to Calculate Derived Property
- contents:
  - "10.  Guidelines for Designated Experts\n   Experience with internationalization
    in application protocols has\n   shown that protocol designers and application
    developers usually do\n   not understand the subtleties and trade-offs involved
    with\n   internationalization and that they need considerable guidance in\n   making
    reasonable decisions with regard to the options before them.\n   Therefore:\n
    \  o  Protocol designers are strongly encouraged to question the\n      assumption
    that they need to define new profiles, because existing\n      profiles are designed
    for wide reuse (see Section 5 for further\n      discussion).\n   o  Those who
    persist in defining new profiles are strongly encouraged\n      to clearly explain
    a strong justification for doing so and to\n      publish a stable specification
    that provides all of the\n      information described under Section 11.3.\n   o
    \ The designated experts for profile registration requests ought to\n      seek
    answers to all of the questions provided under Section 11.3\n      and ought to
    encourage applicants to provide a stable\n      specification documenting the
    profile (even though the\n      registration policy for PRECIS profiles is \"Expert
    Review\" and a\n      stable specification is not strictly required).\n   o  Developers
    of applications that use PRECIS are strongly encouraged\n      to apply the guidelines
    provided under Section 6 and to seek out\n      the advice of the designated experts
    or other knowledgeable\n      individuals in doing so.\n   o  All parties are
    strongly encouraged to help prevent the\n      multiplication of profiles beyond
    necessity, as described under\n      Section 5.1, and to use PRECIS in ways that
    will minimize user\n      confusion and insecure application behavior.\n   Internationalization
    can be difficult and contentious; designated\n   experts, profile registrants,
    and application developers are strongly\n   encouraged to work together in a spirit
    of good faith and mutual\n   understanding to achieve rough consensus on profile
    registration\n   requests and the use of PRECIS in particular applications.  They
    are\n   also encouraged to bring additional expertise into the discussion if\n
    \  that would be helpful in adding perspective or otherwise resolving\n   issues.\n"
  title: 10.  Guidelines for Designated Experts
- contents:
  - '11.  IANA Considerations

    '
  - contents:
    - "11.1.  PRECIS Derived Property Value Registry\n   IANA has created and now
      maintains the \"PRECIS Derived Property\n   Value\" registry (<https://www.iana.org/assignments/precis-tables/>),\n
      \  which records the derived properties for each version of Unicode\n   released
      starting from version 6.3.  The derived property value is to\n   be calculated
      in cooperation with a designated expert [RFC8126]\n   according to the rules
      specified under Sections 8 and 9.\n   The IESG is to be notified if backward-incompatible
      changes to the\n   table of derived properties are discovered or if other problems
      arise\n   during the process of creating the table of derived property values\n
      \  or during Expert Review.  Changes to the rules defined under\n   Sections
      8 and 9 require IETF Review.\n   Note: IANA is requested to not make further
      updates to this registry\n   until it receives notice from the IESG that the
      issues described in\n   [IAB-Statement] and Section 13.5 of this document have
      been settled.\n"
    title: 11.1.  PRECIS Derived Property Value Registry
  - contents:
    - "11.2.  PRECIS Base Classes Registry\n   IANA has created the \"PRECIS Base
      Classes\" registry\n   (<https://www.iana.org/assignments/precis-parameters/>).
      \ In\n   accordance with [RFC8126], the registration policy is \"RFC Required\".\n
      \  The registration template is as follows:\n   Base Class:  [the name of the
      PRECIS string class]\n   Description:  [a brief description of the PRECIS string
      class and its\n      intended use, e.g., \"A sequence of letters, numbers, and
      symbols\n      that is used to identify or address a network entity.\"]\n   Reference:
      \ [the RFC number]\n   The initial registrations are as follows:\n   Base Class:
      FreeformClass\n   Description: A sequence of letters, numbers, symbols, spaces,
      and\n         other code points that is used for free-form strings.\n   Specification:
      Section 4.3 of RFC 8264\n   Base Class: IdentifierClass\n   Description: A sequence
      of letters, numbers, and symbols that is\n         used to identify or address
      a network entity.\n   Specification: Section 4.2 of RFC 8264\n"
    title: 11.2.  PRECIS Base Classes Registry
  - contents:
    - "11.3.  PRECIS Profiles Registry\n   IANA has created the \"PRECIS Profiles\"
      registry\n   (<https://www.iana.org/assignments/precis-parameters/>) to identify\n
      \  profiles that use the PRECIS string classes.  In accordance with\n   [RFC8126],
      the registration policy is \"Expert Review\".  This policy\n   was chosen in
      order to ease the burden of registration while ensuring\n   that \"customers\"
      of PRECIS receive appropriate guidance regarding the\n   sometimes complex and
      subtle internationalization issues related to\n   profiles of PRECIS string
      classes.\n   The registration template is as follows:\n   Name:  [the name of
      the profile]\n   Base Class:  [which PRECIS string class is being profiled]\n
      \  Applicability:  [the specific protocol elements to which this profile\n      applies,
      e.g., \"Usernames in security and application protocols.\"]\n   Replaces:  [the
      Stringprep profile that this PRECIS profile replaces,\n      if any]\n   Width
      Mapping Rule:  [the behavioral rule for handling of width,\n      e.g., \"Map
      fullwidth and halfwidth code points to their\n      compatibility variants.\"]\n
      \  Additional Mapping Rule:  [any additional mappings that are required\n      or
      recommended, e.g., \"Map non-ASCII space code points to SPACE\n      (U+0020).\"]\n
      \  Case Mapping Rule:  [the behavioral rule for handling of case, e.g.,\n      \"Apply
      the Unicode toLowerCase() operation.\"]\n   Normalization Rule:  [which Unicode
      normalization form is applied,\n      e.g., \"NFC\"]\n   Directionality Rule:
      \ [the behavioral rule for handling of right-to-\n      left code points, e.g.,
      \"The 'Bidi Rule' defined in RFC 5893\n      applies.\"]\n   Enforcement:  [which
      entities enforce the rules, and when that\n      enforcement occurs during protocol
      operations]\n   Specification:  [a pointer to relevant documentation, such as
      an RFC\n      or Internet-Draft]\n   In order to request a review, the registrant
      shall send a completed\n   template to the <precis@ietf.org> list or its designated
      successor.\n   Factors to focus on while defining profiles and reviewing profile\n
      \  registrations include the following:\n   o  Would an existing PRECIS string
      class or profile solve the\n      problem?  If not, why not?  (See Section 5.1
      for related\n      considerations.)\n   o  Is the problem being addressed by
      this profile well defined?\n   o  Does the specification define what kinds of
      applications are\n      involved and the protocol elements to which this profile
      applies?\n   o  Is the profile clearly defined?\n   o  Is the profile based
      on an appropriate dividing line between user\n      interface (culture, context,
      intent, locale, device limitations,\n      etc.) and the use of conformant strings
      in protocol elements?\n   o  Are the width mapping, case mapping, additional
      mapping,\n      normalization, and directionality rules appropriate for the\n
      \     intended use?\n   o  Does the profile explain which entities enforce the
      rules and when\n      such enforcement occurs during protocol operations?\n
      \  o  Does the profile reduce the degree to which human users could be\n      surprised
      or confused by application behavior (the \"Principle of\n      Least Astonishment\")?\n
      \  o  Does the profile introduce any new security concerns such as those\n      described
      under Section 12 of this document (e.g., false accepts\n      for authentication
      or authorization)?\n"
    title: 11.3.  PRECIS Profiles Registry
  title: 11.  IANA Considerations
- contents:
  - '12.  Security Considerations

    '
  - contents:
    - "12.1.  General Issues\n   If input strings that appear \"the same\" to users
      are programmatically\n   considered to be distinct in different systems or if
      input strings\n   that appear distinct to users are programmatically considered
      to be\n   \"the same\" in different systems, then users can be confused.  Such\n
      \  confusion can have security implications, such as the false accepts\n   and
      false rejects discussed in [RFC6943] (the terms \"false positives\"\n   and
      \"false negatives\" are used in that document).  One starting goal\n   of work
      on the PRECIS framework was to limit the number of times that\n   users are
      confused (consistent with the \"Principle of Least\n   Astonishment\").  Unfortunately,
      this goal has been difficult to\n   achieve given the large number of application
      protocols already in\n   existence.  Despite these difficulties, profiles should
      not be\n   multiplied beyond necessity (see Section 5.1).  In particular,\n
      \  designers of application protocols should think long and hard before\n   defining
      a new profile instead of using one that has already been\n   defined, and if
      they decide to define a new profile then they should\n   clearly explain their
      reasons for doing so.\n   The security of applications that use this framework
      can depend in\n   part on the proper preparation, enforcement, and comparison
      of\n   internationalized strings.  For example, such strings can be used to\n
      \  make authentication and authorization decisions, and the security of\n   an
      application could be compromised if an entity providing a given\n   string is
      connected to the wrong account or online resource based on\n   different interpretations
      of the string (again, see [RFC6943]).\n   Specifications of application protocols
      that use this framework are\n   strongly encouraged to describe how internationalized
      strings are\n   used in the protocol, including the security implications of
      any\n   false accepts and false rejects that might result from various\n   enforcement
      and comparison operations.  For some helpful guidelines,\n   refer to [RFC6943],
      [RFC5890], [UTR36], and [UTS39].\n"
    title: 12.1.  General Issues
  - contents:
    - "12.2.  Use of the IdentifierClass\n   Strings that conform to the IdentifierClass,
      and any profile thereof,\n   are intended to be relatively safe for use in a
      broad range of\n   applications, primarily because they include only letters,
      digits,\n   and \"grandfathered\" non-space code points from the ASCII range;
      thus,\n   they exclude spaces, code points with compatibility equivalents, and\n
      \  almost all symbols and punctuation marks.  However, because such\n   strings
      can still include so-called \"confusable code points\" (see\n   Section 12.5),
      protocol designers and implementers are encouraged to\n   pay close attention
      to the security considerations described\n   elsewhere in this document.\n"
    title: 12.2.  Use of the IdentifierClass
  - contents:
    - "12.3.  Use of the FreeformClass\n   Strings that conform to the FreeformClass,
      and many profiles thereof,\n   can include virtually any Unicode code point.
      \ This makes the\n   FreeformClass quite expressive, but also problematic from
      the\n   perspective of possible user confusion.  Protocol designers are\n   hereby
      warned that the FreeformClass contains code points they might\n   not understand,
      and they are encouraged to profile the\n   IdentifierClass wherever feasible;
      however, if an application\n   protocol requires more code points than are allowed
      by the\n   IdentifierClass, protocol designers are encouraged to define a\n
      \  profile of the FreeformClass that restricts the allowable code points\n   as
      tightly as possible.  (The PRECIS Working Group considered the\n   option of
      allowing \"superclasses\" as well as profiles of PRECIS\n   string classes but
      decided against allowing superclasses to reduce\n   the likelihood of security
      and interoperability problems.)\n"
    title: 12.3.  Use of the FreeformClass
  - contents:
    - "12.4.  Local Character Set Issues\n   When systems use local character sets
      other than ASCII and Unicode,\n   this specification leaves the problem of converting
      between the local\n   character set and Unicode up to the application or local
      system.  If\n   different applications (or different versions of one application)\n
      \  implement different rules for conversions among coded character sets,\n   they
      could interpret the same name differently and contact different\n   application
      servers or other network entities.  This problem is not\n   solved by security
      protocols, such as Transport Layer Security (TLS)\n   [RFC5246] and SASL [RFC4422],
      that do not take local character sets\n   into account.\n"
    title: 12.4.  Local Character Set Issues
  - contents:
    - "12.5.  Visually Similar Characters\n   Some code points are visually similar
      and thus can cause confusion\n   among humans.  Such characters are often called
      \"confusable\n   characters\" or \"confusables\".\n   The problem of confusable
      characters is not necessarily caused by the\n   use of Unicode code points outside
      the ASCII range.  For example, in\n   some presentations and to some individuals
      the string \"ju1iet\"\n   (spelled with DIGIT ONE (U+0031) as the third character)
      might appear\n   to be the same as \"juliet\" (spelled with LATIN SMALL LETTER
      L\n   (U+006C)), especially on casual visual inspection.  This phenomenon\n
      \  is sometimes called \"typejacking\".\n   However, the problem is made more
      serious by introducing the full\n   range of Unicode code points into protocol
      strings.  A well-known\n   example is confusion between \"\u0430\" CYRILLIC
      SMALL LETTER A (U+0430) and\n   \"a\" LATIN SMALL LETTER A (U+0061).  As another
      example, the\n   characters \"\u13DA\u13A2\u13B5\u13CB\u13A2\u13CB\u13D2\" (U+13DA
      U+13A2 U+13B5 U+13AC U+13A2 U+13AC\n   U+13D2) from the Cherokee block look
      similar to the ASCII code points\n   representing \"STPETER\" as they might
      appear when presented using a\n   \"creative\" font family.  Confusion among
      such characters is perhaps\n   not unexpected, given that the alphabetic writing
      systems involved\n   all bear a family resemblance or historical lineage.  Perhaps
      more\n   surprising is confusion among characters from disparate writing\n   systems,
      such as \"O\" (LATIN CAPITAL LETTER O, U+004F), \"0\" (DIGIT\n   ZERO, U+0030),
      \"\u0ED0\" (LAO DIGIT ZERO, U+0ED0), \"\u12D0\" (ETHIOPIC SYLLABLE\n   PHARYNGEAL
      A, U+12D0), and other graphemes that have the appearance\n   of open circles.
      \ And the reader needs to be aware that the foregoing\n   represent merely a
      small sample of characters that are confusable in\n   Unicode.\n   In some instances
      of confusable characters, it is unlikely that the\n   average human could tell
      the difference between the real string and\n   the fake string.  (Indeed, there
      is no programmatic way to\n   distinguish with full certainty which is the fake
      string and which is\n   the real string; in some contexts, the string formed
      of Cherokee code\n   points might be the real string and the string formed of
      ASCII code\n   points might be the fake string.)  Because PRECIS-compliant strings\n
      \  can contain almost any properly encoded Unicode code point, it can be\n   relatively
      easy to fake or mimic some strings in systems that use the\n   PRECIS framework.
      \ The fact that some strings are easily confused\n   introduces security vulnerabilities
      of the kind that have also\n   plagued the World Wide Web, specifically the
      phenomenon known as\n   phishing.\n   Despite the fact that some specific suggestions
      about identification\n   and handling of confusable characters appear in the
      Unicode Security\n   Considerations [UTR36] and the Unicode Security Mechanisms
      [UTS39],\n   it is also true (as noted in [RFC5890]) that \"there are no\n   comprehensive
      technical solutions to the problems of confusable\n   characters.\"  Because
      it is impossible to map visually similar\n   characters without a great deal
      of context (such as knowing the font\n   families used), the PRECIS framework
      does nothing to map similar-\n   looking characters together, nor does it prohibit
      some characters\n   because they look like others.\n   Nevertheless, specifications
      for application protocols that use this\n   framework are strongly encouraged
      to describe how confusable\n   characters can be abused to compromise the security
      of systems that\n   use the protocol in question, along with any protocol-specific\n
      \  suggestions for overcoming those threats.  In particular, software\n   implementations
      and service deployments that use PRECIS-based\n   technologies are strongly
      encouraged to define and implement\n   consistent policies regarding the registration,
      storage, and\n   presentation of visually similar characters.  The following\n
      \  recommendations are appropriate:\n   1.  An application service SHOULD define
      a policy that specifies the\n       scripts or blocks of code points that the
      service will allow to\n       be registered (e.g., in an account name) or stored
      (e.g., in a\n       filename).  Such a policy SHOULD be informed by the languages
      and\n       scripts that are used to write registered account names; in\n       particular,
      to reduce confusion, the service SHOULD forbid\n       registration or storage
      of strings that contain code points from\n       more than one script and SHOULD
      restrict registrations to code\n       points drawn from a very small number
      of scripts (e.g., scripts\n       that are well understood by the administrators
      of the service, to\n       improve manageability).\n   2.  User-oriented application
      software SHOULD define a policy that\n       specifies how internationalized
      strings will be presented to a\n       human user.  Because every human user
      of such software has a\n       preferred language or a small set of preferred
      languages, the\n       software SHOULD gather that information either explicitly
      from\n       the user or implicitly via the operating system of the user's\n
      \      device.\n   The challenges inherent in supporting the full range of Unicode
      code\n   points have in the past led some to hope for a way to\n   programmatically
      negotiate more restrictive ranges based on locale,\n   script, or other relevant
      factors; to tag the locale associated with\n   a particular string; etc.  As
      a general-purpose internationalization\n   technology, the PRECIS framework
      does not include such mechanisms.\n"
    title: 12.5.  Visually Similar Characters
  - contents:
    - "12.6.  Security of Passwords\n   Two goals of passwords are to maximize the
      amount of entropy and to\n   minimize the potential for false accepts.  These
      goals can be\n   achieved in part by allowing a wide range of code points and
      by\n   ensuring that passwords are handled in such a way that code points\n
      \  are not compared aggressively.  Therefore, it is NOT RECOMMENDED for\n   application
      protocols to profile the FreeformClass for use in\n   passwords in a way that
      removes entire categories (e.g., by\n   disallowing symbols or punctuation).
      \ Furthermore, it is\n   NOT RECOMMENDED for application protocols to map uppercase
      and\n   titlecase code points to their lowercase equivalents in such strings;\n
      \  instead, it is RECOMMENDED to preserve the case of all code points\n   contained
      in such strings and to compare them in a case-sensitive\n   manner.\n   That
      said, software implementers need to be aware that there exist\n   trade-offs
      between entropy and usability.  For example, allowing a\n   user to establish
      a password containing \"uncommon\" code points might\n   make it difficult for
      the user to access a service when using an\n   unfamiliar or constrained input
      device.\n   Some application protocols use passwords directly, whereas others\n
      \  reuse technologies that themselves process passwords (one example of\n   such
      a technology is SASL [RFC4422]).  Moreover, passwords are often\n   carried
      by a sequence of protocols with backend authentication\n   systems or data storage
      systems such as RADIUS [RFC2865] and the\n   Lightweight Directory Access Protocol
      (LDAP) [RFC4510].  Developers\n   of application protocols are encouraged to
      look into reusing these\n   profiles instead of defining new ones, so that end-user
      expectations\n   about passwords are consistent no matter which application
      protocol\n   is used.\n   In protocols that provide passwords as input to a
      cryptographic\n   algorithm such as a hash function, the client will need to
      perform\n   proper preparation of the password before applying the algorithm,\n
      \  because the password is not available to the server in plaintext\n   form.\n
      \  Further discussion of password handling can be found in [RFC8265].\n"
    title: 12.6.  Security of Passwords
  title: 12.  Security Considerations
- contents:
  - '13.  Interoperability Considerations

    '
  - contents:
    - "13.1.  Coded Character Sets\n   It is known that some existing applications
      and systems do not\n   support the full Unicode coded character set, or even
      any characters\n   outside the ASCII repertoire [RFC20].  If two (or more) applications\n
      \  or systems need to interoperate when exchanging data (e.g., for the\n   purpose
      of authenticating the combination of a username and\n   password), naturally
      they will need to have in common at least one\n   coded character set and the
      repertoire of characters being exchanged\n   (see [RFC6365] for definitions
      of these terms).  Establishing such a\n   baseline is a matter for the application
      or system that uses PRECIS,\n   not for the PRECIS framework.\n"
    title: 13.1.  Coded Character Sets
  - contents:
    - "13.2.  Dependency on Unicode\n   The only coded character set supported by
      PRECIS is Unicode.  If an\n   application or system does not support Unicode
      or uses a different\n   coded character set [RFC6365], then the PRECIS rules
      cannot be\n   applied to that application or system.\n"
    title: 13.2.  Dependency on Unicode
  - contents:
    - "13.3.  Encoding\n   Although strings that are consumed in PRECIS-based application\n
      \  protocols are often encoded using UTF-8 [RFC3629], the exact encoding\n   is
      a matter for the application protocol that uses PRECIS, not for\n   the PRECIS
      framework or for specifications that define PRECIS string\n   classes or profiles
      thereof.\n"
    title: 13.3.  Encoding
  - contents:
    - "13.4.  Unicode Versions\n   It is extremely important for protocol designers
      and application\n   developers to understand that various changes can occur
      across\n   versions of the Unicode Standard, and such changes can result in\n
      \  instability of PRECIS categories.  The following are merely a few\n   examples:\n
      \  o  As described in [RFC6452], between Unicode 5.2 (current at the\n      time
      IDNA2008 was originally published) and Unicode 6.0, three\n      code points
      underwent changes in their GeneralCategory, resulting\n      in modified handling,
      depending on which version of Unicode is\n      available on the underlying
      system.\n   o  The HasCompat() categorization of a given input string could\n
      \     change if, for example, the string includes a precomposed\n      character
      that was added in a recent version of Unicode.\n   o  The East Asian width property,
      which is used in many PRECIS width\n      mapping rules, is not guaranteed to
      be stable across Unicode\n      versions.\n"
    title: 13.4.  Unicode Versions
  - contents:
    - "13.5.  Potential Changes to Handling of Certain Unicode Code Points\n   As
      part of the review of Unicode 7.0 for IDNA, a question was raised\n   about
      a newly added code point that led to a re-analysis of the\n   normalization
      rules used by IDNA and inherited by this document\n   (Section 5.2.4).  Some
      of the general issues are described in\n   [IAB-Statement] and pursued in more
      detail in [IDNA-Unicode].\n   At the time of this writing, these issues have
      yet to be settled.\n   However, implementers need to be aware that this specification
      is\n   likely to be updated in the future to address these issues.  The\n   potential
      changes include but might not be limited to the following:\n   o  The range
      of code points in the LetterDigits category\n      (Sections 4.2.1 and 9.1)
      might be narrowed.\n   o  Some code points with special properties that are
      now allowed\n      might be excluded.\n   o  More additional mapping rules (Section
      5.2.2) might be defined.\n   o  Alternative normalization methods might be added.\n
      \  As described in Section 11.1, until these issues are settled, it is\n   reasonable
      for the IANA to apply the same precautionary principle\n   described in [IAB-Statement]
      to the \"PRECIS Derived Property Value\"\n   registry as is applied to the \"IDNA
      Parameters\" registry\n   <https://www.iana.org/assignments/idna-tables/>: that
      is, to not make\n   further updates to the registry.\n   Nevertheless, implementations
      and deployments are unlikely to\n   encounter significant problems as a consequence
      of these issues or\n   potential changes if they follow the advice given in
      this\n   specification to use the more restrictive IdentifierClass whenever\n
      \  possible or, if using the FreeformClass, to allow only a restricted\n   set
      of code points, particularly avoiding code points whose\n   implications they
      do not understand.\n"
    title: 13.5.  Potential Changes to Handling of Certain Unicode Code Points
  title: 13.  Interoperability Considerations
- contents:
  - '14.  References

    '
  - contents:
    - "14.1.  Normative References\n   [RFC20]    Cerf, V., \"ASCII format for network
      interchange\", STD 80,\n              RFC 20, DOI 10.17487/RFC0020, October
      1969,\n              <https://www.rfc-editor.org/info/rfc20>.\n   [RFC2119]
      \ Bradner, S., \"Key words for use in RFCs to Indicate\n              Requirement
      Levels\", BCP 14, RFC 2119,\n              DOI 10.17487/RFC2119, March 1997,\n
      \             <https://www.rfc-editor.org/info/rfc2119>.\n   [RFC5198]  Klensin,
      J. and M. Padlipsky, \"Unicode Format for Network\n              Interchange\",
      RFC 5198, DOI 10.17487/RFC5198, March 2008,\n              <https://www.rfc-editor.org/info/rfc5198>.\n
      \  [RFC6365]  Hoffman, P. and J. Klensin, \"Terminology Used in\n              Internationalization
      in the IETF\", BCP 166, RFC 6365,\n              DOI 10.17487/RFC6365, September
      2011,\n              <https://www.rfc-editor.org/info/rfc6365>.\n   [RFC8174]
      \ Leiba, B., \"Ambiguity of Uppercase vs Lowercase in RFC\n              2119
      Key Words\", BCP 14, RFC 8174, DOI 10.17487/RFC8174,\n              May 2017,
      <https://www.rfc-editor.org/info/rfc8174>.\n   [Unicode]  The Unicode Consortium,
      \"The Unicode Standard\",\n              <http://www.unicode.org/versions/latest/>.\n"
    title: 14.1.  Normative References
  - contents:
    - "14.2.  Informative References\n   [DerivedCoreProperties]\n              The
      Unicode Consortium, \"DerivedCoreProperties-\n              10.0.0.txt\", Unicode
      Character Database, March 2017,\n              <http://www.unicode.org/Public/UCD/latest/ucd/\n
      \             DerivedCoreProperties.txt>.\n   [Err4568]  RFC Errata, Erratum
      ID 4568, RFC 7564,\n              <https://www.rfc-editor.org/errata/eid4568>.\n
      \  [IAB-Statement]\n              Internet Architecture Board, \"IAB Statement
      on Identifiers\n              and Unicode 7.0.0\", February 2015,\n              <https://www.iab.org/documents/\n
      \             correspondence-reports-documents/2015-2/\n              iab-statement-on-identifiers-and-unicode-7-0-0/>.\n
      \  [IDNA-Unicode]\n              Klensin, J. and P. Faltstrom, \"IDNA Update
      for Unicode\n              7.0.0\", Work in Progress, draft-klensin-idna-5892upd-\n
      \             unicode70-04, March 2015.\n   [PropertyAliases]\n              The
      Unicode Consortium, \"PropertyAliases-10.0.0.txt\",\n              Unicode Character
      Database, February 2017,\n              <http://www.unicode.org/Public/UCD/latest/ucd/\n
      \             PropertyAliases.txt>.\n   [RFC2865]  Rigney, C., Willens, S.,
      Rubens, A., and W. Simpson,\n              \"Remote Authentication Dial In User
      Service (RADIUS)\",\n              RFC 2865, DOI 10.17487/RFC2865, June 2000,\n
      \             <https://www.rfc-editor.org/info/rfc2865>.\n   [RFC3454]  Hoffman,
      P. and M. Blanchet, \"Preparation of\n              Internationalized Strings
      (\"stringprep\")\", RFC 3454,\n              DOI 10.17487/RFC3454, December
      2002,\n              <https://www.rfc-editor.org/info/rfc3454>.\n   [RFC3490]
      \ Faltstrom, P., Hoffman, P., and A. Costello,\n              \"Internationalizing
      Domain Names in Applications (IDNA)\",\n              RFC 3490, DOI 10.17487/RFC3490,
      March 2003,\n              <https://www.rfc-editor.org/info/rfc3490>.\n   [RFC3491]
      \ Hoffman, P. and M. Blanchet, \"Nameprep: A Stringprep\n              Profile
      for Internationalized Domain Names (IDN)\",\n              RFC 3491, DOI 10.17487/RFC3491,
      March 2003,\n              <https://www.rfc-editor.org/info/rfc3491>.\n   [RFC3629]
      \ Yergeau, F., \"UTF-8, a transformation format of ISO\n              10646\",
      STD 63, RFC 3629, DOI 10.17487/RFC3629, November\n              2003, <https://www.rfc-editor.org/info/rfc3629>.\n
      \  [RFC4422]  Melnikov, A., Ed. and K. Zeilenga, Ed., \"Simple\n              Authentication
      and Security Layer (SASL)\", RFC 4422,\n              DOI 10.17487/RFC4422,
      June 2006,\n              <https://www.rfc-editor.org/info/rfc4422>.\n   [RFC4510]
      \ Zeilenga, K., Ed., \"Lightweight Directory Access Protocol\n              (LDAP):
      Technical Specification Road Map\", RFC 4510,\n              DOI 10.17487/RFC4510,
      June 2006,\n              <https://www.rfc-editor.org/info/rfc4510>.\n   [RFC4690]
      \ Klensin, J., Faltstrom, P., Karp, C., and IAB, \"Review and\n              Recommendations
      for Internationalized Domain Names\n              (IDNs)\", RFC 4690, DOI 10.17487/RFC4690,
      September 2006,\n              <https://www.rfc-editor.org/info/rfc4690>.\n
      \  [RFC5234]  Crocker, D., Ed. and P. Overell, \"Augmented BNF for Syntax\n
      \             Specifications: ABNF\", STD 68, RFC 5234,\n              DOI 10.17487/RFC5234,
      January 2008,\n              <https://www.rfc-editor.org/info/rfc5234>.\n   [RFC5246]
      \ Dierks, T. and E. Rescorla, \"The Transport Layer Security\n              (TLS)
      Protocol Version 1.2\", RFC 5246,\n              DOI 10.17487/RFC5246, August
      2008,\n              <https://www.rfc-editor.org/info/rfc5246>.\n   [RFC5890]
      \ Klensin, J., \"Internationalized Domain Names for\n              Applications
      (IDNA): Definitions and Document Framework\",\n              RFC 5890, DOI 10.17487/RFC5890,
      August 2010,\n              <https://www.rfc-editor.org/info/rfc5890>.\n   [RFC5891]
      \ Klensin, J., \"Internationalized Domain Names in\n              Applications
      (IDNA): Protocol\", RFC 5891,\n              DOI 10.17487/RFC5891, August 2010,\n
      \             <https://www.rfc-editor.org/info/rfc5891>.\n   [RFC5892]  Faltstrom,
      P., Ed., \"The Unicode Code Points and\n              Internationalized Domain
      Names for Applications (IDNA)\",\n              RFC 5892, DOI 10.17487/RFC5892,
      August 2010,\n              <https://www.rfc-editor.org/info/rfc5892>.\n   [RFC5893]
      \ Alvestrand, H., Ed. and C. Karp, \"Right-to-Left Scripts\n              for
      Internationalized Domain Names for Applications\n              (IDNA)\", RFC
      5893, DOI 10.17487/RFC5893, August 2010,\n              <https://www.rfc-editor.org/info/rfc5893>.\n
      \  [RFC5894]  Klensin, J., \"Internationalized Domain Names for\n              Applications
      (IDNA): Background, Explanation, and\n              Rationale\", RFC 5894, DOI
      10.17487/RFC5894, August 2010,\n              <https://www.rfc-editor.org/info/rfc5894>.\n
      \  [RFC5895]  Resnick, P. and P. Hoffman, \"Mapping Characters for\n              Internationalized
      Domain Names in Applications (IDNA)\n              2008\", RFC 5895, DOI 10.17487/RFC5895,
      September 2010,\n              <https://www.rfc-editor.org/info/rfc5895>.\n
      \  [RFC6452]  Faltstrom, P., Ed. and P. Hoffman, Ed., \"The Unicode Code\n              Points
      and Internationalized Domain Names for Applications\n              (IDNA) -
      Unicode 6.0\", RFC 6452, DOI 10.17487/RFC6452,\n              November 2011,
      <https://www.rfc-editor.org/info/rfc6452>.\n   [RFC6885]  Blanchet, M. and A.
      Sullivan, \"Stringprep Revision and\n              Problem Statement for the
      Preparation and Comparison of\n              Internationalized Strings (PRECIS)\",
      RFC 6885,\n              DOI 10.17487/RFC6885, March 2013,\n              <https://www.rfc-editor.org/info/rfc6885>.\n
      \  [RFC6943]  Thaler, D., Ed., \"Issues in Identifier Comparison for\n              Security
      Purposes\", RFC 6943, DOI 10.17487/RFC6943, May\n              2013, <https://www.rfc-editor.org/info/rfc6943>.\n
      \  [RFC7564]  Saint-Andre, P. and M. Blanchet, \"PRECIS Framework:\n              Preparation,
      Enforcement, and Comparison of\n              Internationalized Strings in Application
      Protocols\",\n              RFC 7564, DOI 10.17487/RFC7564, May 2015,\n              <https://www.rfc-editor.org/info/rfc7564>.\n
      \  [RFC7622]  Saint-Andre, P., \"Extensible Messaging and Presence\n              Protocol
      (XMPP): Address Format\", RFC 7622,\n              DOI 10.17487/RFC7622, September
      2015,\n              <https://www.rfc-editor.org/info/rfc7622>.\n   [RFC7790]
      \ Yoneya, Y. and T. Nemoto, \"Mapping Characters for Classes\n              of
      the Preparation, Enforcement, and Comparison of\n              Internationalized
      Strings (PRECIS)\", RFC 7790,\n              DOI 10.17487/RFC7790, February
      2016,\n              <https://www.rfc-editor.org/info/rfc7790>.\n   [RFC8126]
      \ Cotton, M., Leiba, B., and T. Narten, \"Guidelines for\n              Writing
      an IANA Considerations Section in RFCs\", BCP 26,\n              RFC 8126, DOI
      10.17487/RFC8126, June 2017,\n              <https://www.rfc-editor.org/info/rfc8126>.\n
      \  [RFC8265]  Saint-Andre, P. and A. Melnikov, \"Preparation,\n              Enforcement,
      and Comparison of Internationalized Strings\n              Representing Usernames
      and Passwords\", RFC 8265,\n              DOI 10.17487/RFC8265, October 2017,\n
      \             <https://www.rfc-editor.org/info/rfc8265>.\n   [RFC8266]  Saint-Andre,
      P., \"Preparation, Enforcement, and Comparison\n              of Internationalized
      Strings Representing Nicknames\",\n              RFC 8266, DOI 10.17487/RFC8266,
      October 2017,\n              <https://www.rfc-editor.org/info/rfc8266>.\n   [UAX11]
      \   Unicode Standard Annex #11, \"East Asian Width\", edited by\n              Ken
      Lunde.  An integral part of The Unicode Standard,\n              <http://unicode.org/reports/tr11/>.\n
      \  [UAX15]    Unicode Standard Annex #15, \"Unicode Normalization Forms\",\n
      \             edited by Mark Davis and Ken Whistler.  An integral part\n              of
      The Unicode Standard,\n              <http://unicode.org/reports/tr15/>.\n   [UAX9]
      \    Unicode Standard Annex #9, \"Unicode Bidirectional\n              Algorithm\",
      edited by Mark Davis, Aharon Lanin, and Andrew\n              Glass.  An integral
      part of The Unicode Standard,\n              <http://unicode.org/reports/tr9/>.\n
      \  [UTR36]    Unicode Technical Report #36, \"Unicode Security\n              Considerations\",
      edited by Mark Davis and Michel Suignard,\n              <http://unicode.org/reports/tr36/>.\n
      \  [UTS39]    Unicode Technical Standard #39, \"Unicode Security\n              Mechanisms\",
      edited by Mark Davis and Michel Suignard,\n              <http://unicode.org/reports/tr39/>.\n"
    title: 14.2.  Informative References
  title: 14.  References
- contents:
  - "Appendix A.  Changes from RFC 7564\n   The following changes were made from [RFC7564].\n
    \  o  Recommended the Unicode toLowerCase() operation over the Unicode\n      toCaseFold()
    operation in most PRECIS applications.\n   o  Clarified the meaning of \"preparation\",
    and described the\n      motivation for including it in PRECIS.\n   o  Updated
    references.\n   See [RFC7564] for a description of the differences from [RFC3454].\n"
  title: Appendix A.  Changes from RFC 7564
- contents:
  - "Acknowledgements\n   Thanks to Martin Duerst, William Fisher, John Klensin, Christian\n
    \  Schudt, and Sam Whited for their feedback.  Thanks to Sam Whited also\n   for
    submitting [Err4568].\n   See [RFC7564] for acknowledgements related to the specification
    that\n   this document supersedes.\n   Some algorithms and textual descriptions
    have been borrowed from\n   [RFC5892].  Some text regarding security has been
    borrowed from\n   [RFC5890], [RFC8265], and [RFC7622].\n"
  title: Acknowledgements
- contents:
  - "Authors' Addresses\n   Peter Saint-Andre\n   Jabber.org\n   P.O. Box 787\n   Parker,
    CO  80134\n   United States of America\n   Phone: +1 720 256 6756\n   Email: stpeter@jabber.org\n
    \  URI:   https://www.jabber.org/\n   Marc Blanchet\n   Viagenie\n   246 Aberdeen\n
    \  Qu\xE9bec, QC  G1R 2E1\n   Canada\n   Email: Marc.Blanchet@viagenie.ca\n   URI:
    \  http://www.viagenie.ca/\n"
  title: Authors' Addresses
