- title: __initial_text__
  contents:
  - "                PKCS #1: RSA Cryptography Specifications\n                  \
    \            Version 2.0\n"
- title: Status of this Memo
  contents:
  - "Status of this Memo\n   This memo provides information for the Internet community.\
    \  It does\n   not specify an Internet standard of any kind.  Distribution of\
    \ this\n   memo is unlimited.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (C) The Internet Society (1998).  All Rights Reserved.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1.       Introduction.....................................2\n\
    \   1.1      Overview.........................................3\n   2.       Notation.........................................3\n\
    \   3.       Key types........................................5\n   3.1      RSA\
    \ public key...................................5\n   3.2      RSA private key..................................5\n\
    \   4.       Data conversion primitives.......................6\n   4.1      I2OSP............................................6\n\
    \   4.2      OS2IP............................................7\n   5.       Cryptographic\
    \ primitives.........................8\n   5.1      Encryption and decryption\
    \ primitives.............8\n   5.1.1    RSAEP............................................8\n\
    \   5.1.2    RSADP............................................9\n   5.2      Signature\
    \ and verification primitives...........10\n   5.2.1    RSASP1..........................................10\n\
    \   5.2.2    RSAVP1..........................................11\n   6.       Overview\
    \ of schemes.............................11\n   7.       Encryption schemes..............................12\n\
    \   7.1      RSAES-OAEP......................................13\n   7.1.1    Encryption\
    \ operation............................13\n   7.1.2    Decryption operation............................14\n\
    \   7.2      RSAES-PKCS1-v1_5................................15\n   7.2.1    Encryption\
    \ operation............................17\n   7.2.2    Decryption operation............................17\n\
    \   8.       Signature schemes with appendix.................18\n   8.1      RSASSA-PKCS1-v1_5...............................19\n\
    \   8.1.1    Signature generation operation..................20\n   8.1.2    Signature\
    \ verification operation................21\n   9.       Encoding methods................................22\n\
    \   9.1      Encoding methods for encryption.................22\n   9.1.1    EME-OAEP........................................22\n\
    \   9.1.2    EME-PKCS1-v1_5..................................24\n   9.2      Encoding\
    \ methods for signatures with appendix...26\n   9.2.1    EMSA-PKCS1-v1_5.................................26\n\
    \   10.      Auxiliary Functions.............................27\n   10.1     Hash\
    \ Functions..................................27\n   10.2     Mask Generation Functions.......................28\n\
    \   10.2.1   MGF1............................................28\n   11.      ASN.1\
    \ syntax....................................29\n   11.1     Key representation..............................29\n\
    \   11.1.1   Public-key syntax...............................30\n   11.1.2   Private-key\
    \ syntax..............................30\n   11.2     Scheme identification...........................31\n\
    \   11.2.1   Syntax for RSAES-OAEP...........................31\n   11.2.2   Syntax\
    \ for RSAES-PKCS1-v1_5.....................32\n   11.2.3   Syntax for RSASSA-PKCS1-v1_5....................33\n\
    \   12       Patent Statement................................33\n   12.1     Patent\
    \ statement for the RSA algorithm..........34\n   13.      Revision history................................35\n\
    \   14.      References......................................35\n            Security\
    \ Considerations.........................37\n            Acknowledgements................................37\n\
    \            Authors' Addresses..............................38\n            Full\
    \ Copyright Statement........................39\n"
- title: 1. Introduction
  contents:
  - "1. Introduction\n   This memo is the successor to RFC 2313. This document provides\n\
    \   recommendations for the implementation of public-key cryptography\n   based\
    \ on the RSA algorithm [18], covering the following aspects:\n      -cryptographic\
    \ primitives\n      -encryption schemes\n      -signature schemes with appendix\n\
    \      -ASN.1 syntax for representing keys and for identifying the\n       schemes\n\
    \   The recommendations are intended for general application within\n   computer\
    \ and communications systems, and as such include a fair\n   amount of flexibility.\
    \ It is expected that application standards\n   based on these specifications\
    \ may include additional constraints. The\n   recommendations are intended to\
    \ be compatible with draft standards\n   currently being developed by the ANSI\
    \ X9F1 [1] and IEEE P1363 working\n   groups [14].  This document supersedes PKCS\
    \ #1 version 1.5 [20].\n   Editor's note. It is expected that subsequent versions\
    \ of PKCS #1 may\n   cover other aspects of the RSA algorithm such as key size,\
    \ key\n   generation, key validation, and signature schemes with message\n   recovery.\n"
- title: 1.1 Overview
  contents:
  - "1.1 Overview\n   The organization of this document is as follows:\n      -Section\
    \ 1 is an introduction.\n      -Section 2 defines some notation used in this document.\n\
    \      -Section 3 defines the RSA public and private key types.\n      -Sections\
    \ 4 and 5 define several primitives, or basic mathematical\n       operations.\
    \ Data conversion primitives are in Section 4, and\n       cryptographic primitives\
    \ (encryption-decryption,\n       signature-verification) are in Section 5.\n\
    \      -Section 6, 7 and 8 deal with the encryption and signature schemes\n  \
    \     in this document. Section 6 gives an overview. Section 7 defines\n     \
    \  an OAEP-based [2] encryption scheme along with the method found\n       in\
    \ PKCS #1 v1.5.  Section 8 defines a signature scheme with\n       appendix; the\
    \ method is identical to that of PKCS #1 v1.5.\n      -Section 9 defines the encoding\
    \ methods for the encryption and\n       signature schemes in Sections 7 and 8.\n\
    \      -Section 10 defines the hash functions and the mask generation\n      \
    \ function used in this document.\n      -Section 11 defines the ASN.1 syntax\
    \ for the keys defined in\n       Section 3 and the schemes gives in Sections\
    \ 7 and 8.\n      -Section 12 outlines the revision history of PKCS #1.\n    \
    \  -Section 13 contains references to other publications and\n       standards.\n"
- title: 2. Notation
  contents:
  - "2. Notation\n   (n, e)        RSA public key\n   c             ciphertext representative,\
    \ an integer between 0 and n-1\n   C             ciphertext, an octet string\n\
    \   d             private exponent\n   dP            p's exponent, a positive\
    \ integer such that:\n                  e(dP)\\equiv 1 (mod(p-1))\n   dQ     \
    \       q's exponent, a positive integer such that:\n                  e(dQ)\\\
    equiv 1 (mod(q-1))\n   e             public exponent\n   EM            encoded\
    \ message, an octet string\n   emLen         intended length in octets of an encoded\
    \ message\n   H             hash value, an output of Hash\n   Hash          hash\
    \ function\n   hLen          output length in octets of hash function Hash\n \
    \  K             RSA private key\n   k             length in octets of the modulus\n\
    \   l             intended length of octet string\n   lcm(.,.)      least common\
    \ multiple of two\n                 nonnegative integers\n   m             message\
    \ representative, an integer between\n                 0 and n-1\n   M       \
    \      message, an octet string\n   MGF           mask generation function\n \
    \  n             modulus\n   P             encoding parameters, an octet string\n\
    \   p,q           prime factors of the modulus\n   qInv          CRT coefficient,\
    \ a positive integer less\n                 than p such: q(qInv)\\equiv 1 (mod\
    \ p)\n   s             signature representative, an integer\n                \
    \ between 0 and n-1\n   S             signature, an octet string\n   x       \
    \      a nonnegative integer\n   X             an octet string corresponding to\
    \ x\n   \\xor          bitwise exclusive-or of two octet strings\n   \\lambda(n)\
    \    lcm(p-1, q-1), where n = pq\n   ||            concatenation operator\n  \
    \ ||.||         octet length operator\n"
- title: 3. Key types
  contents:
  - "3. Key types\n   Two key types are employed in the primitives and schemes defined\
    \ in\n   this document: RSA public key and RSA private key. Together, an RSA\n\
    \   public key and an RSA private key form an RSA key pair.\n"
- title: 3.1 RSA public key
  contents:
  - "3.1 RSA public key\n   For the purposes of this document, an RSA public key consists\
    \ of two\n   components:\n   n, the modulus, a nonnegative integer\n   e, the\
    \ public exponent, a nonnegative integer\n   In a valid RSA public key, the modulus\
    \ n is a product of two odd\n   primes p and q, and the public exponent e is an\
    \ integer between 3 and\n   n-1 satisfying gcd (e, \\lambda(n)) = 1, where \\\
    lambda(n) = lcm (p-\n   1,q-1).  A recommended syntax for interchanging RSA public\
    \ keys\n   between implementations is given in Section 11.1.1; an\n   implementation's\
    \ internal representation may differ.\n"
- title: 3.2 RSA private key
  contents:
  - "3.2 RSA private key\n   For the purposes of this document, an RSA private key\
    \ may have either\n   of two representations.\n   1. The first representation\
    \ consists of the pair (n, d), where the\n   components have the following meanings:\n\
    \   n, the modulus, a nonnegative integer\n   d, the private exponent, a nonnegative\
    \ integer\n   2. The second representation consists of a quintuple (p, q, dP,\
    \ dQ,\n   qInv), where the components have the following meanings:\n   p, the\
    \ first factor, a nonnegative integer\n   q, the second factor, a nonnegative\
    \ integer\n   dP, the first factor's exponent, a nonnegative integer\n   dQ, the\
    \ second factor's exponent, a nonnegative integer\n   qInv, the CRT coefficient,\
    \ a nonnegative integer\n   In a valid RSA private key with the first representation,\
    \ the modulus\n   n is the same as in the corresponding public key and is the\
    \ product\n   of two odd primes p and q, and the private exponent d is a positive\n\
    \   integer less than n satisfying:\n   ed \\equiv 1 (mod \\lambda(n))\n   where\
    \ e is the corresponding public exponent and \\lambda(n) is as\n   defined above.\n\
    \   In a valid RSA private key with the second representation, the two\n   factors\
    \ p and q are the prime factors of the modulus n, the exponents\n   dP and dQ\
    \ are positive integers less than p and q respectively\n   satisfying\n   e(dP)\\\
    equiv 1(mod(p-1))\n   e(dQ)\\equiv 1(mod(q-1)),\n   and the CRT coefficient qInv\
    \ is a positive integer less than p\n   satisfying:\n   q(qInv)\\equiv 1 (mod\
    \ p).\n   A recommended syntax for interchanging RSA private keys between\n  \
    \ implementations, which includes components from both representations,\n   is\
    \ given in Section 11.1.2; an implementation's internal\n   representation may\
    \ differ.\n"
- title: 4. Data conversion primitives
  contents:
  - "4. Data conversion primitives\n   Two data conversion primitives are employed\
    \ in the schemes defined in\n   this document:\n   I2OSP: Integer-to-Octet-String\
    \ primitive\n   OS2IP: Octet-String-to-Integer primitive\n   For the purposes\
    \ of this document, and consistent with ASN.1 syntax, an\n   octet string is an\
    \ ordered sequence of octets (eight-bit bytes). The\n   sequence is indexed from\
    \ first (conventionally, leftmost) to last\n   (rightmost). For purposes of conversion\
    \ to and from integers, the first\n   octet is considered the most significant\
    \ in the following conversion\n   primitives\n"
- title: 4.1 I2OSP
  contents:
  - "4.1 I2OSP\n   I2OSP converts a nonnegative integer to an octet string of a specified\n\
    \   length.\n   I2OSP (x, l)\n   Input:\n   x         nonnegative integer to be\
    \ converted\n   l         intended length of the resulting octet string\n   Output:\n\
    \   X         corresponding octet string of length l; or\n             \"integer\
    \ too large\"\n   Steps:\n   1. If x>=256^l, output \"integer too large\" and\
    \ stop.\n   2. Write the integer x in its unique l-digit representation base 256:\n\
    \   x = x_{l-1}256^{l-1} + x_{l-2}256^{l-2} +... + x_1 256 + x_0\n   where 0 <=\
    \ x_i < 256 (note that one or more leading digits will be\n   zero if x < 256^{l-1}).\n\
    \   3. Let the octet X_i have the value x_{l-i} for 1 <= i <= l.  Output\n   the\
    \ octet string:\n   X = X_1 X_2 ... X_l.\n"
- title: 4.2 OS2IP
  contents:
  - "4.2 OS2IP\n   OS2IP converts an octet string to a nonnegative integer.\n   OS2IP\
    \ (X)\n   Input:\n   X         octet string to be converted\n   Output:\n   x\
    \         corresponding nonnegative integer\n   Steps:\n   1. Let X_1 X_2 ...\
    \ X_l  be the octets of X from first to last, and\n   let x{l-i} have value X_i\
    \ for 1<= i <= l.\n   2. Let x = x{l-1} 256^{l-1} + x_{l-2} 256^{l-2} +...+ x_1\
    \ 256 + x_0.\n   3. Output x.\n"
- title: 5. Cryptographic primitives
  contents:
  - "5. Cryptographic primitives\n   Cryptographic primitives are basic mathematical\
    \ operations on which\n   cryptographic schemes can be built. They are intended\
    \ for\n   implementation in hardware or as software modules, and are not\n   intended\
    \ to provide security apart from a scheme.\n   Four types of primitive are specified\
    \ in this document, organized in\n   pairs: encryption and decryption; and signature\
    \ and verification.\n   The specifications of the primitives assume that certain\
    \ conditions\n   are met by the inputs, in particular that public and private\
    \ keys are\n   valid.\n"
- title: 5.1 Encryption and decryption primitives
  contents:
  - "5.1 Encryption and decryption primitives\n   An encryption primitive produces\
    \ a ciphertext representative from a\n   message representative under the control\
    \ of a public key, and a\n   decryption primitive recovers the message representative\
    \ from the\n   ciphertext representative under the control of the corresponding\n\
    \   private key.\n   One pair of encryption and decryption primitives is employed\
    \ in the\n   encryption schemes defined in this document and is specified here:\n\
    \   RSAEP/RSADP. RSAEP and RSADP involve the same mathematical operation,\n  \
    \ with different keys as input.\n   The primitives defined here are the same as\
    \ in the draft IEEE P1363\n   and are compatible with PKCS #1 v1.5.\n   The main\
    \ mathematical operation in each primitive is exponentiation.\n"
- title: 5.1.1 RSAEP
  contents:
  - "5.1.1 RSAEP\n   RSAEP((n, e), m)\n   Input:\n   (n, e)    RSA public key\n  \
    \ m         message representative, an integer between 0 and n-1\n   Output:\n\
    \   c         ciphertext representative, an integer between 0 and n-1;\n     \
    \        or \"message representative out of range\"\n   Assumptions: public key\
    \ (n, e) is valid\n   Steps:\n   1. If the message representative m is not between\
    \ 0 and n-1, output\n   message representative out of range and stop.\n   2. Let\
    \ c = m^e mod n.\n   3. Output c.\n"
- title: 5.1.2 RSADP
  contents:
  - "5.1.2 RSADP\n   RSADP (K, c)\n   Input:\n   K         RSA private key, where\
    \ K has one of the following forms\n                 -a pair (n, d)\n        \
    \         -a quintuple (p, q, dP, dQ, qInv)\n   c         ciphertext representative,\
    \ an integer between 0 and n-1\n   Output:\n   m         message representative,\
    \ an integer between 0 and n-1; or\n             \"ciphertext representative out\
    \ of range\"\n   Assumptions: private key K is valid\n   Steps:\n   1. If the\
    \ ciphertext representative c is not between 0 and n-1,\n   output \"ciphertext\
    \ representative out of range\" and stop.\n   2. If the first form (n, d) of K\
    \ is used:\n   2.1 Let m = c^d mod n.          Else, if the second form (p, q,\
    \ dP,\n   dQ, qInv) of K is used:\n   2.2 Let m_1 = c^dP mod p.\n   2.3 Let m_2\
    \ = c^dQ mod q.\n   2.4 Let h = qInv ( m_1 - m_2 ) mod p.\n   2.5 Let m = m_2\
    \ + hq.\n   3. Output m.\n"
- title: 5.2 Signature and verification primitives
  contents:
  - "5.2 Signature and verification primitives\n   A signature primitive produces\
    \ a signature representative from a\n   message representative under the control\
    \ of a private key, and a\n   verification primitive recovers the message representative\
    \ from the\n   signature representative under the control of the corresponding\n\
    \   public key. One pair of signature and verification primitives is\n   employed\
    \ in the signature schemes defined in this document and is\n   specified here:\
    \ RSASP1/RSAVP1.\n   The primitives defined here are the same as in the draft\
    \ IEEE P1363\n   and are compatible with PKCS #1 v1.5.\n   The main mathematical\
    \ operation in each primitive is exponentiation,\n   as in the encryption and\
    \ decryption primitives of Section 5.1. RSASP1\n   and RSAVP1 are the same as\
    \ RSADP and RSAEP except for the names of\n   their input and output arguments;\
    \ they are distinguished as they are\n   intended for different purposes.\n"
- title: 5.2.1 RSASP1
  contents:
  - "5.2.1 RSASP1\n   RSASP1 (K, m)\n   Input:\n   K             RSA private key,\
    \ where K has one of the following\n                 forms:\n                \
    \    -a pair (n, d)\n                    -a quintuple (p, q, dP, dQ, qInv)\n \
    \  m             message representative, an integer between 0 and n-1\n   Output:\n\
    \   s             signature representative, an integer between  0 and\n      \
    \           n-1, or \"message representative out of range\"\n   Assumptions:\n\
    \   private key K is valid\n   Steps:\n   1. If the message representative m is\
    \ not between 0 and n-1, output\n   \"message representative out of range\" and\
    \ stop.\n   2. If the first form (n, d) of K is used:\n   2.1 Let s = m^d mod\
    \ n.          Else, if the second form (p, q, dP,\n   dQ, qInv) of K is used:\n\
    \   2.2 Let s_1 = m^dP mod p.\n   2.3 Let s_2 = m^dQ mod q.\n   2.4 Let h = qInv\
    \ ( s_1 - s_2 ) mod p.\n   2.5 Let s = s_2 + hq.\n   3. Output S.\n"
- title: 5.2.2 RSAVP1
  contents:
  - "5.2.2 RSAVP1\n   RSAVP1 ((n, e), s)\n   Input:\n   (n, e)  RSA public key\n \
    \  s       signature representative, an integer between 0 and n-1\n   Output:\n\
    \   m       message representative, an integer between 0 and n-1;\n          \
    \ or \"invalid\"\n   Assumptions:\n   public key (n, e) is valid\n   Steps:\n\
    \   1. If the signature representative s is not between 0 and n-1, output\n  \
    \ \"invalid\" and stop.\n   2. Let m = s^e mod n.\n   3. Output m.\n"
- title: 6. Overview of schemes
  contents:
  - "6. Overview of schemes\n   A scheme combines cryptographic primitives and other\
    \ techniques to\n   achieve a particular security goal. Two types of scheme are\
    \ specified\n   in this document: encryption schemes and signature schemes with\n\
    \   appendix.\n   The schemes specified in this document are limited in scope\
    \ in that\n   their operations consist only of steps to process data with a key,\n\
    \   and do not include steps for obtaining or validating the key. Thus,\n   in\
    \ addition to the scheme operations, an application will typically\n   include\
    \ key management operations by which parties may select public\n   and private\
    \ keys for a scheme operation. The specific additional\n   operations and other\
    \ details are outside the scope of this document.\n   As was the case for the\
    \ cryptographic primitives (Section 5), the\n   specifications of scheme operations\
    \ assume that certain conditions\n   are met by the inputs, in particular that\
    \ public and private keys are\n   valid. The behavior of an implementation is\
    \ thus unspecified when a\n   key is invalid. The impact of such unspecified behavior\
    \ depends on\n   the application. Possible means of addressing key validation\
    \ include\n   explicit key validation by the application; key validation within\
    \ the\n   public-key infrastructure; and assignment of liability for operations\n\
    \   performed with an invalid key to the party who generated the key.\n"
- title: 7. Encryption schemes
  contents:
  - "7. Encryption schemes\n   An encryption scheme consists of an encryption operation\
    \ and a\n   decryption operation, where the encryption operation produces a\n\
    \   ciphertext from a message with a recipient's public key, and the\n   decryption\
    \ operation recovers the message from the ciphertext with\n   the recipient's\
    \ corresponding private key.\n   An encryption scheme can be employed in a variety\
    \ of applications. A\n   typical application is a key establishment protocol,\
    \ where the\n   message contains key material to be delivered confidentially from\
    \ one\n   party to another. For instance, PKCS #7 [21] employs such a protocol\n\
    \   to deliver a content-encryption key from a sender to a recipient; the\n  \
    \ encryption schemes defined here would be suitable key-encryption\n   algorithms\
    \ in that context.\n   Two encryption schemes are specified in this document:\
    \ RSAES-OAEP and\n   RSAES-PKCS1-v1_5. RSAES-OAEP is recommended for new applications;\n\
    \   RSAES-PKCS1-v1_5 is included only for compatibility with existing\n   applications,\
    \ and is not recommended for new applications.\n   The encryption schemes given\
    \ here follow a general model similar to\n   that employed in IEEE P1363, by combining\
    \ encryption and decryption\n   primitives with an encoding method for encryption.\
    \ The encryption\n   operations apply a message encoding operation to a message\
    \ to produce\n   an encoded message, which is then converted to an integer message\n\
    \   representative. An encryption primitive is applied to the message\n   representative\
    \ to produce the ciphertext. Reversing this, the\n   decryption operations apply\
    \ a decryption primitive to the ciphertext\n   to recover a message representative,\
    \ which is then converted to an\n   octet string encoded message. A message decoding\
    \ operation is applied\n   to the encoded message to recover the message and verify\
    \ the\n   correctness of the decryption.\n"
- title: 7.1 RSAES-OAEP
  contents:
  - "7.1 RSAES-OAEP\n   RSAES-OAEP combines the RSAEP and RSADP primitives (Sections\
    \ 5.1.1\n   and 5.1.2) with the EME-OAEP encoding method (Section 9.1.1) EME-OAEP\n\
    \   is based on the method found in [2]. It is compatible with the IFES\n   scheme\
    \ defined in the draft P1363 where the encryption and decryption\n   primitives\
    \ are IFEP-RSA and IFDP-RSA and the message encoding method\n   is EME-OAEP. RSAES-OAEP\
    \ can operate on messages of length up to k-2-\n   2hLen octets, where hLen is\
    \ the length of the hash function output\n   for EME-OAEP and k is the length\
    \ in octets of the recipient's RSA\n   modulus.  Assuming that the hash function\
    \ in EME-OAEP has appropriate\n   properties, and the key size is sufficiently\
    \ large, RSAEP-OAEP\n   provides \"plaintext-aware encryption,\" meaning that\
    \ it is\n   computationally infeasible to obtain full or partial information\n\
    \   about a message from a ciphertext, and computationally infeasible to\n   generate\
    \ a valid ciphertext without knowing the corresponding\n   message.  Therefore,\
    \ a chosen-ciphertext attack is ineffective\n   against a plaintext-aware encryption\
    \ scheme such as RSAES-OAEP.\n   Both the encryption and the decryption operations\
    \ of RSAES-OAEP take\n   the value of the parameter string P as input. In this\
    \ version of PKCS\n   #1, P is an octet string that is specified explicitly. See\
    \ Section\n   11.2.1 for the relevant ASN.1 syntax. We briefly note that to receive\n\
    \   the full security benefit of RSAES-OAEP, it should not be used in a\n   protocol\
    \ involving RSAES-PKCS1-v1_5. It is possible that in a\n   protocol on which both\
    \ encryption schemes are present, an adaptive\n   chosen ciphertext attack such\
    \ as [4] would be useful.\n   Both the encryption and the decryption operations\
    \ of RSAES-OAEP take\n   the value of the parameter string P as input. In this\
    \ version of PKCS\n   #1, P is an octet string that is specified explicitly. See\
    \ Section\n   11.2.1 for the relevant ASN.1 syntax.\n"
- title: 7.1.1 Encryption operation
  contents:
  - "7.1.1 Encryption operation\n   RSAES-OAEP-ENCRYPT ((n, e), M, P)\n   Input:\n\
    \   (n, e)    recipient's RSA public key\n   M         message to be encrypted,\
    \ an octet string of length at\n             most k-2-2hLen, where k is the length\
    \ in octets of the\n             modulus n and hLen is the length in octets of\
    \ the hash\n             function output for EME-OAEP\n   P         encoding parameters,\
    \ an octet string that may be empty\n   Output:\n   C         ciphertext, an octet\
    \ string of length k; or \"message too\n             long\"\n   Assumptions: public\
    \ key (n, e) is valid\n   Steps:\n   1. Apply the EME-OAEP encoding operation\
    \ (Section 9.1.1.2) to the\n   message M and the encoding parameters P to produce\
    \ an encoded message\n   EM of length k-1 octets:\n   EM = EME-OAEP-ENCODE (M,\
    \ P, k-1)\n   If the encoding operation outputs \"message too long,\" then output\n\
    \   \"message too long\" and stop.\n   2. Convert the encoded message EM to an\
    \ integer message\n   representative m: m = OS2IP (EM)\n   3. Apply the RSAEP\
    \ encryption primitive (Section 5.1.1) to the public\n   key (n, e) and the message\
    \ representative m to produce an integer\n   ciphertext representative c:\n  \
    \ c = RSAEP ((n, e), m)\n   4. Convert the ciphertext representative c to a ciphertext\
    \ C of\n   length k octets: C = I2OSP (c, k)\n   5. Output the ciphertext C.\n"
- title: 7.1.2 Decryption operation
  contents:
  - "7.1.2 Decryption operation\n   RSAES-OAEP-DECRYPT (K, C, P)\n   Input:\n   K\
    \          recipient's RSA private key\n   C          ciphertext to be decrypted,\
    \ an octet string of length\n              k, where k is the length in octets\
    \ of the modulus n\n   P          encoding parameters, an octet string that may\
    \ be empty\n   Output:\n   M          message, an octet string of length at most\
    \ k-2-2hLen,\n              where hLen is the length in octets of the hash\n \
    \             function output for EME-OAEP; or \"decryption error\"\n   Steps:\n\
    \   1. If the length of the ciphertext C is not k octets, output\n   \"decryption\
    \ error\" and stop.\n   2. Convert the ciphertext C to an integer ciphertext representative\n\
    \   c: c = OS2IP (C).\n   3. Apply the RSADP decryption primitive (Section 5.1.2)\
    \ to the\n   private key K and the ciphertext representative c to produce an\n\
    \   integer message representative m:\n   m = RSADP (K, c)\n   If RSADP outputs\
    \ \"ciphertext out of range,\" then output \"decryption\n   error\" and stop.\n\
    \   4. Convert the message representative m to an encoded message EM of\n   length\
    \ k-1 octets: EM = I2OSP (m, k-1)\n   If I2OSP outputs \"integer too large,\"\
    \ then output \"decryption error\"\n   and stop.\n   5. Apply the EME-OAEP decoding\
    \ operation to the encoded message EM\n   and the encoding parameters P to recover\
    \ a message M:\n   M = EME-OAEP-DECODE (EM, P)\n   If the decoding operation outputs\
    \ \"decoding error,\" then output\n   \"decryption error\" and stop.\n   6. Output\
    \ the message M.\n   Note. It is important that the error messages output in steps\
    \ 4 and 5\n   be the same, otherwise an adversary may be able to extract useful\n\
    \   information from the type of error message received. Error message\n   information\
    \ is used to mount a chosen-ciphertext attack on PKCS #1\n   v1.5 encrypted messages\
    \ in [4].\n"
- title: 7.2 RSAES-PKCS1-v1_5
  contents:
  - "7.2 RSAES-PKCS1-v1_5\n   RSAES-PKCS1-v1_5 combines the RSAEP and RSADP primitives\
    \ with the\n   EME-PKCS1-v1_5 encoding method. It is the same as the encryption\n\
    \   scheme in PKCS #1 v1.5. RSAES-PKCS1-v1_5 can operate on messages of\n   length\
    \ up to k-11 octets, although care should be taken to avoid\n   certain attacks\
    \ on low-exponent RSA due to Coppersmith, et al. when\n   long messages are encrypted\
    \ (see the third bullet in the notes below\n   and [7]).\n   RSAES-PKCS1-v1_5\
    \ does not provide \"plaintext aware\" encryption. In\n   particular, it is possible\
    \ to generate valid ciphertexts without\n   knowing the corresponding plaintexts,\
    \ with a reasonable probability\n   of success. This ability can be exploited\
    \ in a chosen ciphertext\n   attack as shown in [4]. Therefore, if RSAES-PKCS1-v1_5\
    \ is to be used,\n   certain easily implemented countermeasures should be taken\
    \ to thwart\n   the attack found in [4]. The addition of structure to the data\
    \ to be\n   encoded, rigorous checking of PKCS #1 v1.5 conformance and other\n\
    \   redundancy in decrypted messages, and the consolidation of error\n   messages\
    \ in a client-server protocol based on PKCS #1 v1.5 can all be\n   effective countermeasures\
    \ and don't involve changes to a PKCS #1\n   v1.5-based protocol. These and other\
    \ countermeasures are discussed in\n   [5].\n   Notes. The following passages\
    \ describe some security recommendations\n   pertaining to the use of RSAES-PKCS1-v1_5.\
    \ Recommendations from\n   version 1.5 of this document are included as well as\
    \ new\n   recommendations motivated by cryptanalytic advances made in the\n  \
    \ intervening years.\n   -It is recommended that the pseudorandom octets in EME-PKCS1-v1_5\
    \ be\n   generated independently for each encryption process, especially if\n\
    \   the same data is input to more than one encryption process. Hastad's\n   results\
    \ [13] are one motivation for this recommendation.\n   -The padding string PS\
    \ in EME-PKCS1-v1_5 is at least eight octets\n   long, which is a security condition\
    \ for public-key operations that\n   prevents an attacker from recovering data\
    \ by trying all possible\n   encryption blocks.\n   -The pseudorandom octets can\
    \ also help thwart an attack due to\n   Coppersmith et al. [7] when the size of\
    \ the message to be encrypted\n   is kept small. The attack works on low-exponent\
    \ RSA when similar\n   messages are encrypted with the same public key. More specifically,\n\
    \   in one flavor of the attack, when two inputs to RSAEP agree on a\n   large\
    \ fraction of bits (8/9) and low-exponent RSA (e = 3) is used to\n   encrypt both\
    \ of them, it may be possible to recover both inputs with\n   the attack. Another\
    \ flavor of the attack is successful in decrypting\n   a single ciphertext when\
    \ a large fraction (2/3) of the input to RSAEP\n   is already known. For typical\
    \ applications, the message to be\n   encrypted is short (e.g., a 128-bit symmetric\
    \ key) so not enough\n   information will be known or common between two messages\
    \ to enable\n   the attack.  However, if a long message is encrypted, or if part\
    \ of a\n   message is known, then the attack may be a concern. In any case, the\n\
    \   RSAEP-OAEP scheme overcomes the attack.\n"
- title: 7.2.1 Encryption operation
  contents:
  - "7.2.1 Encryption operation\n   RSAES-PKCS1-V1_5-ENCRYPT ((n, e), M)\n   Input:\n\
    \   (n, e)  recipient's RSA public key\n   M       message to be encrypted, an\
    \ octet string of length at\n           most k-11 octets, where k is the length\
    \ in octets of the\n           modulus n\n   Output:\n   C       ciphertext, an\
    \ octet string of length k; or \"message too\n           long\"\n   Steps:\n \
    \  1. Apply the EME-PKCS1-v1_5 encoding operation (Section 9.1.2.1) to\n   the\
    \ message M to produce an encoded message EM of length k-1 octets:\n   EM = EME-PKCS1-V1_5-ENCODE\
    \ (M, k-1)\n   If the encoding operation outputs \"message too long,\" then output\n\
    \   \"message too long\" and stop.\n   2. Convert the encoded message EM to an\
    \ integer message\n   representative m: m = OS2IP (EM)\n   3. Apply the RSAEP\
    \ encryption primitive (Section 5.1.1) to the public\n   key (n, e) and the message\
    \ representative m to produce an integer\n   ciphertext representative c: c =\
    \ RSAEP ((n, e), m)\n   4. Convert the ciphertext representative c to a ciphertext\
    \ C of\n   length k octets: C = I2OSP (c, k)\n   5. Output the ciphertext C.\n"
- title: 7.2.2 Decryption operation
  contents:
  - "7.2.2 Decryption operation\n   RSAES-PKCS1-V1_5-DECRYPT (K, C)\n   Input:\n \
    \  K       recipient's RSA private key\n   C       ciphertext to be decrypted,\
    \ an octet string of length k,\n           where k is the length in octets of\
    \ the modulus n\n   Output:\n   M       message, an octet string of length at\
    \ most k-11; or\n           \"decryption error\"\n   Steps:\n   1. If the length\
    \ of the ciphertext C is not k octets, output\n   \"decryption error\" and stop.\n\
    \   2. Convert the ciphertext C to an integer ciphertext representative\n   c:\
    \ c = OS2IP (C).\n   3. Apply the RSADP decryption primitive to the private key\
    \ (n, d) and\n   the ciphertext representative c to produce an integer message\n\
    \   representative m: m = RSADP ((n, d), c).\n   If RSADP outputs \"ciphertext\
    \ out of range,\" then output \"decryption\n   error\" and stop.\n   4. Convert\
    \ the message representative m to an encoded message EM of\n   length k-1 octets:\
    \ EM = I2OSP (m, k-1)\n   If I2OSP outputs \"integer too large,\" then output\
    \ \"decryption error\"\n   and stop.\n   5. Apply the EME-PKCS1-v1_5 decoding\
    \ operation to the encoded message\n   EM to recover a message M: M = EME-PKCS1-V1_5-DECODE\
    \ (EM).\n   If the decoding operation outputs \"decoding error,\" then output\n\
    \   \"decryption error\" and stop.\n   6. Output the message M.\n   Note. It is\
    \ important that only one type of error message is output\n   by EME-PKCS1-v1_5,\
    \ as ensured by steps 4 and 5. If this is not done,\n   then an adversary may\
    \ be able to use information extracted form the\n   type of error message received\
    \ to mount a chosen-ciphertext attack\n   such as the one found in [4].\n"
- title: 8. Signature schemes with appendix
  contents:
  - "8. Signature schemes with appendix\n   A signature scheme with appendix consists\
    \ of a signature generation\n   operation and a signature verification operation,\
    \ where the signature\n   generation operation produces a signature from a message\
    \ with a\n   signer's private key, and the signature verification operation\n\
    \   verifies the signature on the message with the signer's corresponding\n  \
    \ public key.  To verify a signature constructed with this type of\n   scheme\
    \ it is necessary to have the message itself. In this way,\n   signature schemes\
    \ with appendix are distinguished from signature\n   schemes with message recovery,\
    \ which are not supported in this\n   document.\n   A signature scheme with appendix\
    \ can be employed in a variety of\n   applications. For instance, X.509 [6] employs\
    \ such a scheme to\n   authenticate the content of a certificate; the signature\
    \ scheme with\n   appendix defined here would be a suitable signature algorithm\
    \ in that\n   context. A related signature scheme could be employed in PKCS #7\n\
    \   [21], although for technical reasons, the current version of PKCS #7\n   separates\
    \ a hash function from a signature scheme, which is different\n   than what is\
    \ done here.\n   One signature scheme with appendix is specified in this document:\n\
    \   RSASSA-PKCS1-v1_5.\n   The signature scheme with appendix given here follows\
    \ a general model\n   similar to that employed in IEEE P1363, by combining signature\
    \ and\n   verification primitives with an encoding method for signatures. The\n\
    \   signature generation operations apply a message encoding operation to\n  \
    \ a message to produce an encoded message, which is then converted to\n   an integer\
    \ message representative. A signature primitive is then\n   applied to the message\
    \ representative to produce the signature. The\n   signature verification operations\
    \ apply a signature verification\n   primitive to the signature to recover a message\
    \ representative, which\n   is then converted to an octet string. The message\
    \ encoding operation\n   is again applied to the message, and the result is compared\
    \ to the\n   recovered octet string. If there is a match, the signature is\n \
    \  considered valid. (Note that this approach assumes that the signature\n   and\
    \ verification primitives have the message-recovery form and the\n   encoding\
    \ method is deterministic, as is the case for RSASP1/RSAVP1\n   and EMSA-PKCS1-v1_5.\
    \ The signature generation and verification\n   operations have a different form\
    \ in P1363 for other primitives and\n   encoding methods.)\n   Editor's note.\
    \ RSA Laboratories is investigating the possibility of\n   including a scheme\
    \ based on the PSS encoding methods specified in\n   [3], which would be recommended\
    \ for new applications.\n"
- title: 8.1 RSASSA-PKCS1-v1_5
  contents:
  - "8.1 RSASSA-PKCS1-v1_5\n   RSASSA-PKCS1-v1_5 combines the RSASP1 and RSAVP1 primitives\
    \ with the\n   EME-PKCS1-v1_5 encoding method. It is compatible with the IFSSA\n\
    \   scheme defined in the draft P1363 where the signature and\n   verification\
    \ primitives are IFSP-RSA1 and IFVP-RSA1 and the message\n   encoding method is\
    \ EMSA-PKCS1-v1_5 (which is not defined in P1363).\n   The length of messages\
    \ on which RSASSA-PKCS1-v1_5 can operate is\n   either unrestricted or constrained\
    \ by a very large number, depending\n   on the hash function underlying the message\
    \ encoding method.\n   Assuming that the hash function in EMSA-PKCS1-v1_5 has\
    \ appropriate\n   properties and the key size is sufficiently large, RSASSA-PKCS1-v1_5\n\
    \   provides secure signatures, meaning that it is computationally\n   infeasible\
    \ to generate a signature without knowing the private key,\n   and computationally\
    \ infeasible to find a message with a given\n   signature or two messages with\
    \ the same signature. Also, in the\n   encoding method EMSA-PKCS1-v1_5, a hash\
    \ function identifier is\n   embedded in the encoding.  Because of this feature,\
    \ an adversary must\n   invert or find collisions of the particular hash function\
    \ being used;\n   attacking a different hash function than the one selected by\
    \ the\n   signer is not useful to the adversary.\n"
- title: 8.1.1 Signature generation operation
  contents:
  - "8.1.1 Signature generation operation\n   RSASSA-PKCS1-V1_5-SIGN (K, M)\n   Input:\n\
    \   K         signer's RSA private ke\n   M         message to be signed, an octet\
    \ string\n   Output:\n   S         signature, an octet string of length k, where\
    \ k is the\n             length in octets of the modulus n; \"message too long\"\
    \ or\n             \"modulus too short\"\n   Steps:\n   1. Apply the EMSA-PKCS1-v1_5\
    \ encoding operation (Section 9.2.1) to\n   the message M to produce an encoded\
    \ message EM of length k-1 octets:\n   EM = EMSA-PKCS1-V1_5-ENCODE (M, k-1)\n\
    \   If the encoding operation outputs \"message too long,\" then output\n   \"\
    message too long\" and stop. If the encoding operation outputs\n   \"intended\
    \ encoded message length too short\" then output \"modulus too\n   short\".\n\
    \   2. Convert the encoded message EM to an integer message\n   representative\
    \ m: m = OS2IP (EM)\n   3. Apply the RSASP1 signature primitive (Section 5.2.1)\
    \ to the\n   private key K and the message representative m to produce an integer\n\
    \   signature representative s: s = RSASP1 (K, m)\n   4. Convert the signature\
    \ representative s to a signature S of length\n   k octets: S = I2OSP (s, k)\n\
    \   5. Output the signature S.\n"
- title: 8.1.2 Signature verification operation
  contents:
  - "8.1.2 Signature verification operation\n   RSASSA-PKCS1-V1_5-VERIFY ((n, e),\
    \ M, S)\n   Input:\n   (n, e)    signer's RSA public key\n   M         message\
    \ whose signature is to be verified, an octet string\n   S         signature to\
    \ be verified, an octet string of length k,\n             where k is the length\
    \ in octets of the modulus n\n   Output: \"valid signature,\" \"invalid signature,\"\
    \ or \"message too\n   long\", or \"modulus too short\"\n   Steps:\n   1. If the\
    \ length of the signature S is not k octets, output \"invalid\n   signature\"\
    \ and stop.\n   2. Convert the signature S to an integer signature representative\
    \ s:\n   s = OS2IP (S)\n   3. Apply the RSAVP1 verification primitive (Section\
    \ 5.2.2) to the\n   public key (n, e) and the signature representative s to produce\
    \ an\n   integer message representative m:\n   m = RSAVP1 ((n, e), s)        \
    \          If RSAVP1 outputs \"invalid\"\n   then output \"invalid signature\"\
    \ and stop.\n   4. Convert the message representative m to an encoded message\
    \ EM of\n   length k-1 octets: EM = I2OSP (m, k-1)\n   If I2OSP outputs \"integer\
    \ too large,\" then output \"invalid signature\"\n   and stop.\n   5. Apply the\
    \ EMSA-PKCS1-v1_5 encoding operation (Section 9.2.1) to\n   the message M to produce\
    \ a second encoded message EM' of length k-1\n   octets:\n   EM' = EMSA-PKCS1-V1_5-ENCODE\
    \ (M, k-1)\n   If the encoding operation outputs \"message too long,\" then output\n\
    \   \"message too long\" and stop. If the encoding operation outputs\n   \"intended\
    \ encoded message length too short\" then output \"modulus too\n   short\".\n\
    \   6. Compare the encoded message EM and the second encoded message EM'.\n  \
    \ If they are the same, output \"valid signature\"; otherwise, output\n   \"invalid\
    \ signature.\"\n"
- title: 9. Encoding methods
  contents:
  - "9. Encoding methods\n   Encoding methods consist of operations that map between\
    \ octet string\n   messages and integer message representatives.\n   Two types\
    \ of encoding method are considered in this document:\n   encoding methods for\
    \ encryption, encoding methods for signatures with\n   appendix.\n"
- title: 9.1 Encoding methods for encryption
  contents:
  - "9.1 Encoding methods for encryption\n   An encoding method for encryption consists\
    \ of an encoding operation\n   and a decoding operation. An encoding operation\
    \ maps a message M to a\n   message representative EM of a specified length; the\
    \ decoding\n   operation maps a message representative EM back to a message. The\n\
    \   encoding and decoding operations are inverses.\n   The message representative\
    \ EM will typically have some structure that\n   can be verified by the decoding\
    \ operation; the decoding operation\n   will output \"decoding error\" if the\
    \ structure is not present. The\n   encoding operation may also introduce some\
    \ randomness, so that\n   different applications of the encoding operation to\
    \ the same message\n   will produce different representatives.\n   Two encoding\
    \ methods for encryption are employed in the encryption\n   schemes and are specified\
    \ here: EME-OAEP and EME-PKCS1-v1_5.\n"
- title: 9.1.1 EME-OAEP
  contents:
  - "9.1.1 EME-OAEP\n   This encoding method is parameterized by the choice of hash\
    \ function\n   and mask generation function. Suggested hash and mask generation\n\
    \   functions are given in Section 10. This encoding method is based on\n   the\
    \ method found in [2].\n"
- title: 9.1.1.1 Encoding operation
  contents:
  - "9.1.1.1 Encoding operation\n   EME-OAEP-ENCODE (M, P, emLen)\n   Options:\n \
    \  Hash      hash function (hLen denotes the length in octet of the\n        \
    \     hash function output)\n   MGF       mask generation function\n   Input:\n\
    \   M         message to be encoded, an octet string of length at most\n     \
    \        emLen-1-2hLen\n   P         encoding parameters, an octet string\n  \
    \ emLen     intended length in octets of the encoded message, at least\n     \
    \        2hLen+1\n   Output:\n   EM        encoded message, an octet string of\
    \ length emLen;\n             \"message too long\" or \"parameter string too long\"\
    \n   Steps:\n   1. If the length of P is greater than the input limitation for\
    \ the\n   hash function (2^61-1 octets for SHA-1) then output \"parameter string\n\
    \   too long\" and stop.\n   2. If ||M|| > emLen-2hLen-1 then output \"message\
    \ too long\" and stop.\n   3. Generate an octet string PS consisting of emLen-||M||-2hLen-1\
    \ zero\n   octets. The length of PS may be 0.\n   4. Let pHash = Hash(P), an octet\
    \ string of length hLen.\n   5. Concatenate pHash, PS, the message M, and other\
    \ padding to form a\n   data block DB as: DB = pHash || PS || 01 || M\n   6. Generate\
    \ a random octet string seed of length hLen.\n   7. Let dbMask = MGF(seed, emLen-hLen).\n\
    \   8. Let maskedDB = DB \\xor dbMask.\n   9. Let seedMask = MGF(maskedDB, hLen).\n\
    \   10. Let maskedSeed = seed \\xor seedMask.\n   11. Let EM = maskedSeed || maskedDB.\n\
    \   12. Output EM.\n"
- title: 9.1.1.2 Decoding operation EME-OAEP-DECODE (EM, P)
  contents:
  - "9.1.1.2 Decoding operation EME-OAEP-DECODE (EM, P)\n   Options:\n   Hash    \
    \  hash function (hLen denotes the length in octet of the hash\n             function\
    \ output)\n   MGF       mask generation function\n   Input:\n   EM        encoded\
    \ message, an octet string of length at least 2hLen+1\n   P         encoding parameters,\
    \ an octet string\n   Output:\n   M         recovered message, an octet string\
    \ of length at most\n             ||EM||-1-2hLen; or \"decoding error\"\n   Steps:\n\
    \   1. If the length of P is greater than the input limitation for the\n   hash\
    \ function (2^61-1 octets for SHA-1) then output \"parameter string\n   too long\"\
    \ and stop.\n   2. If ||EM|| < 2hLen+1, then output \"decoding error\" and stop.\n\
    \   3. Let maskedSeed be the first hLen octets of EM and let maskedDB be\n   the\
    \ remaining ||EM|| - hLen octets.\n   4. Let seedMask = MGF(maskedDB, hLen).\n\
    \   5. Let seed = maskedSeed \\xor seedMask.\n   6. Let dbMask = MGF(seed, ||EM||\
    \ - hLen).\n   7. Let DB = maskedDB \\xor dbMask.\n   8. Let pHash = Hash(P),\
    \ an octet string of length hLen.\n   9. Separate DB into an octet string pHash'\
    \ consisting of the first\n   hLen octets of DB, a (possibly empty) octet string\
    \ PS consisting of\n   consecutive zero octets following pHash', and a message\
    \ M as:\n   DB = pHash' || PS || 01 || M\n   If there is no 01 octet to separate\
    \ PS from M, output \"decoding\n   error\" and stop.\n   10. If pHash' does not\
    \ equal pHash, output \"decoding error\" and stop.\n   11. Output M.\n"
- title: 9.1.2 EME-PKCS1-v1_5
  contents:
  - "9.1.2 EME-PKCS1-v1_5\n   This encoding method is the same as in PKCS #1 v1.5,\
    \ Section 8:\n   Encryption Process.\n"
- title: 9.1.2.1 Encoding operation
  contents:
  - "9.1.2.1 Encoding operation\n   EME-PKCS1-V1_5-ENCODE (M, emLen)\n   Input:\n\
    \   M         message to be encoded, an octet string of length at most\n     \
    \        emLen-10\n   emLen     intended length in octets of the encoded message\n\
    \   Output:\n   EM        encoded message, an octet string of length emLen; or\n\
    \             \"message too long\"\n   Steps:\n   1. If the length of the message\
    \ M is greater than emLen - 10 octets,\n   output \"message too long\" and stop.\n\
    \   2. Generate an octet string PS of length emLen-||M||-2 consisting of\n   pseudorandomly\
    \ generated nonzero octets. The length of PS will be at\n   least 8 octets.\n\
    \   3. Concatenate PS, the message M, and other padding to form the\n   encoded\
    \ message EM as:\n   EM = 02 || PS || 00 || M\n   4. Output EM.\n"
- title: 9.1.2.2 Decoding operation
  contents:
  - "9.1.2.2 Decoding operation\n   EME-PKCS1-V1_5-DECODE (EM)\n   Input:\n   EM \
    \     encoded message, an octet string of length at least 10\n   Output:\n   M\
    \       recovered message, an octet string of length at most\n           ||EM||-10;\
    \ or \"decoding error\"\n   Steps:\n   1. If the length of the encoded message\
    \ EM is less than 10, output\n   \"decoding error\" and stop.\n   2. Separate\
    \ the encoded message EM into an octet string PS consisting\n   of nonzero octets\
    \ and a message M as: EM = 02 || PS || 00 || M.\n   If the first octet of EM is\
    \ not 02, or if there is no 00 octet to\n   separate PS from M, output \"decoding\
    \ error\" and stop.\n   3. If the length of PS is less than 8 octets, output \"\
    decoding error\"\n   and stop.\n   4. Output M.\n"
- title: 9.2 Encoding methods for signatures with appendix
  contents:
  - "9.2 Encoding methods for signatures with appendix\n   An encoding method for\
    \ signatures with appendix, for the purposes of\n   this document, consists of\
    \ an encoding operation. An encoding\n   operation maps a message M to a message\
    \ representative EM of a\n   specified length. (In future versions of this document,\
    \ encoding\n   methods may be added that also include a decoding operation.)\n\
    \   One encoding method for signatures with appendix is employed in the\n   encryption\
    \ schemes and is specified here: EMSA-PKCS1-v1_5.\n"
- title: 9.2.1 EMSA-PKCS1-v1_5
  contents:
  - "9.2.1 EMSA-PKCS1-v1_5\n   This encoding method only has an encoding operation.\n\
    \   EMSA-PKCS1-v1_5-ENCODE (M, emLen)\n   Option:\n   Hash      hash function\
    \ (hLen denotes the length in octet of the hash\n             function output)\n\
    \   Input:\n   M         message to be encoded\n   emLen     intended length in\
    \ octets of the encoded message, at least\n             ||T|| + 10, where T is\
    \ the DER encoding of a certain value\n             computed during the encoding\
    \ operation\n   Output:\n   EM        encoded message, an octet string of length\
    \ emLen; or \"message\n             too long\" or \"intended encoded message length\
    \ too short\"\n   Steps:\n   1. Apply the hash function to the message M to produce\
    \ a hash value\n   H:\n   H = Hash(M).\n   If the hash function outputs \"message\
    \ too long,\" then output \"message\n   too long\".\n   2. Encode the algorithm\
    \ ID for the hash function and the hash value\n   into an ASN.1 value of type\
    \ DigestInfo (see Section 11) with the\n   Distinguished Encoding Rules (DER),\
    \ where the type DigestInfo has the\n   syntax\n   DigestInfo::=SEQUENCE{\n  \
    \   digestAlgorithm  AlgorithmIdentifier,\n     digest OCTET STRING }\n   The\
    \ first field identifies the hash function and the second contains\n   the hash\
    \ value. Let T be the DER encoding.\n   3. If emLen is less than ||T|| + 10 then\
    \ output \"intended encoded\n   message length too short\".\n   4. Generate an\
    \ octet string PS consisting of emLen-||T||-2 octets\n   with value FF (hexadecimal).\
    \ The length of PS will be at least 8\n   octets.\n   5. Concatenate PS, the DER\
    \ encoding T, and other padding to form the\n   encoded message EM as: EM = 01\
    \ || PS || 00 || T\n   6. Output EM.\n"
- title: 10. Auxiliary Functions
  contents:
  - "10. Auxiliary Functions\n   This section specifies the hash functions and the\
    \ mask generation\n   functions that are mentioned in the encoding methods (Section\
    \ 9).\n"
- title: 10.1 Hash Functions
  contents:
  - "10.1 Hash Functions\n   Hash functions are used in the operations contained in\
    \ Sections 7, 8\n   and 9. Hash functions are deterministic, meaning that the\
    \ output is\n   completely determined by the input. Hash functions take octet\
    \ strings\n   of variable length, and generate fixed length octet strings. The\
    \ hash\n   functions used in the operations contained in Sections 7, 8 and 9\n\
    \   should be collision resistant. This means that it is infeasible to\n   find\
    \ two distinct inputs to the hash function that produce the same\n   output. A\
    \ collision resistant hash function also has the desirable\n   property of being\
    \ one-way; this means that given an output, it is\n   infeasible to find an input\
    \ whose hash is the specified output. The\n   property of collision resistance\
    \ is especially desirable for RSASSA-\n   PKCS1-v1_5, as it makes it infeasible\
    \ to forge signatures. In\n   addition to the requirements, the hash function\
    \ should yield a mask\n   generation function  (Section 10.2) with pseudorandom\
    \ output.\n   Three hash functions are recommended for the encoding methods in\
    \ this\n   document: MD2 [15], MD5 [17], and SHA-1 [16]. For the EME-OAEP\n  \
    \ encoding method, only SHA-1 is recommended. For the EMSA-PKCS1-v1_5\n   encoding\
    \ method, SHA-1 is recommended for new applications. MD2 and\n   MD5 are recommended\
    \ only for compatibility with existing applications\n   based on PKCS #1 v1.5.\n\
    \   The hash functions themselves are not defined here; readers are\n   referred\
    \ to the appropriate references ([15], [17] and [16]).\n   Note. Version 1.5 of\
    \ this document also allowed for the use of MD4 in\n   signature schemes. The\
    \ cryptanalysis of MD4 has progressed\n   significantly in the intervening years.\
    \ For example, Dobbertin [10]\n   demonstrated how to find collisions for MD4\
    \ and that the first two\n   rounds of MD4 are not one-way [11]. Because of these\
    \ results and\n   others (e.g. [9]), MD4 is no longer recommended. There have\
    \ also been\n   advances in the cryptanalysis of MD2 and MD5, although not enough\
    \ to\n   warrant removal from existing applications. Rogier and Chauvaud [19]\n\
    \   demonstrated how to find collisions in a modified version of MD2. No\n   one\
    \ has demonstrated how to find collisions for the full MD5\n   algorithm, although\
    \ partial results have been found (e.g. [8]). For\n   new applications, to address\
    \ these concerns, SHA-1 is preferred.\n"
- title: 10.2 Mask Generation Functions
  contents:
  - "10.2 Mask Generation Functions\n   A mask generation function takes an octet\
    \ string of variable length\n   and a desired output length as input, and outputs\
    \ an octet string of\n   the desired length. There may be restrictions on the\
    \ length of the\n   input and output octet strings, but such bounds are generally\
    \ very\n   large. Mask generation functions are deterministic; the octet string\n\
    \   output is completely determined by the input octet string. The output\n  \
    \ of a mask generation function should be pseudorandom, that is, if the\n   seed\
    \ to the function is unknown, it should be infeasible to\n   distinguish the output\
    \ from a truly random string. The plaintext-\n   awareness of RSAES-OAEP relies\
    \ on the random nature of the output of\n   the mask generation function, which\
    \ in turn relies on the random\n   nature of the underlying hash.\n   One mask\
    \ generation function is recommended for the encoding methods\n   in this document,\
    \ and is defined here: MGF1, which is based on a hash\n   function. Future versions\
    \ of this document may define other mask\n   generation functions.\n"
- title: 10.2.1 MGF1
  contents:
  - "10.2.1 MGF1\n   MGF1 is a Mask Generation Function based on a hash function.\n\
    \   MGF1 (Z, l)\n   Options:\n   Hash    hash function (hLen denotes the length\
    \ in octets of the hash\n           function output)\n   Input:\n   Z       seed\
    \ from which mask is generated, an octet string\n   l       intended length in\
    \ octets of the mask, at most 2^32(hLen)\n   Output:\n   mask    mask, an octet\
    \ string of length l; or \"mask too long\"\n   Steps:\n   1.If l > 2^32(hLen),\
    \ output \"mask too long\" and stop.\n   2.Let T  be the empty octet string.\n\
    \   3.For counter from 0 to \\lceil{l / hLen}\\rceil-1, do the following:\n  \
    \ a.Convert counter to an octet string C of length 4 with the primitive\n   I2OSP:\
    \ C = I2OSP (counter, 4)\n   b.Concatenate the hash of the seed Z and C to the\
    \ octet string T: T =\n   T || Hash (Z || C)\n   4.Output the leading l octets\
    \ of T as the octet string mask.\n"
- title: 11. ASN.1 syntax
  contents:
  - '11. ASN.1 syntax

    '
- title: 11.1 Key representation
  contents:
  - "11.1 Key representation\n   This section defines ASN.1 object identifiers for\
    \ RSA public and\n   private keys, and defines the types RSAPublicKey and RSAPrivateKey.\n\
    \   The intended application of these definitions includes X.509\n   certificates,\
    \ PKCS #8 [22], and PKCS #12 [23].\n   The object identifier rsaEncryption identifies\
    \ RSA public and private\n   keys as defined in Sections 11.1.1 and 11.1.2. The\
    \ parameters field\n   associated with this OID in an AlgorithmIdentifier shall\
    \ have type\n   NULL.\n   rsaEncryption OBJECT IDENTIFIER ::= {pkcs-1 1}\n   All\
    \ of the definitions in this section are the same as in PKCS #1\n   v1.5.\n"
- title: 11.1.1 Public-key syntax
  contents:
  - "11.1.1 Public-key syntax\n   An RSA public key should be represented with the\
    \ ASN.1 type\n   RSAPublicKey:\n   RSAPublicKey::=SEQUENCE{\n     modulus INTEGER,\
    \ -- n\n     publicExponent INTEGER -- e }\n   (This type is specified in X.509\
    \ and is retained here for\n   compatibility.)\n   The fields of type RSAPublicKey\
    \ have the following meanings:\n   -modulus is the modulus n.\n   -publicExponent\
    \ is the public exponent e.\n"
- title: 11.1.2 Private-key syntax
  contents:
  - "11.1.2 Private-key syntax\n   An RSA private key should be represented with ASN.1\
    \ type\n   RSAPrivateKey:\n   RSAPrivateKey ::= SEQUENCE {\n     version Version,\n\
    \     modulus INTEGER, -- n\n     publicExponent INTEGER, -- e\n     privateExponent\
    \ INTEGER, -- d\n     prime1 INTEGER, -- p\n     prime2 INTEGER, -- q\n     exponent1\
    \ INTEGER, -- d mod (p-1)\n     exponent2 INTEGER, -- d mod (q-1)\n     coefficient\
    \ INTEGER -- (inverse of q) mod p }\n   Version ::= INTEGER\n   The fields of\
    \ type RSAPrivateKey have the following meanings:\n   -version is the version\
    \ number, for compatibility with future\n   revisions of this document. It shall\
    \ be 0 for this version of the\n   document.\n   -modulus is the modulus n.\n\
    \   -publicExponent is the public exponent e.\n   -privateExponent is the private\
    \ exponent d.\n   -prime1 is the prime factor p of n.\n   -prime2 is the prime\
    \ factor q of n.\n   -exponent1 is d mod (p-1).\n   -exponent2 is d mod (q-1).\n\
    \   -coefficient is the Chinese Remainder Theorem coefficient q-1 mod p.\n"
- title: 11.2 Scheme identification
  contents:
  - "11.2 Scheme identification\n   This section defines object identifiers for the\
    \ encryption and\n   signature schemes. The schemes compatible with PKCS #1 v1.5\
    \ have the\n   same definitions as in PKCS #1 v1.5. The intended application of\n\
    \   these definitions includes X.509 certificates and PKCS #7.\n"
- title: 11.2.1 Syntax for RSAES-OAEP
  contents:
  - "11.2.1 Syntax for RSAES-OAEP\n   The object identifier id-RSAES-OAEP identifies\
    \ the RSAES-OAEP\n   encryption scheme.\n   id-RSAES-OAEP OBJECT IDENTIFIER ::=\
    \ {pkcs-1 7}\n   The parameters field associated with this OID in an\n   AlgorithmIdentifier\
    \ shall have type RSAEP-OAEP-params:\n   RSAES-OAEP-params ::=  SEQUENCE {\n \
    \    hashFunc [0] AlgorithmIdentifier {{oaepDigestAlgorithms}}\n       DEFAULT\
    \ sha1Identifier,\n     maskGenFunc [1] AlgorithmIdentifier {{pkcs1MGFAlgorithms}}\n\
    \       DEFAULT mgf1SHA1Identifier,\n     pSourceFunc [2] AlgorithmIdentifier\n\
    \       {{pkcs1pSourceAlgorithms}}\n       DEFAULT pSpecifiedEmptyIdentifier }\n\
    \   The fields of type RSAES-OAEP-params have the following meanings:\n   -hashFunc\
    \ identifies the hash function. It shall be an algorithm ID\n   with an OID in\
    \ the set oaepDigestAlgorithms, which for this version\n   shall consist of id-sha1,\
    \ identifying the SHA-1 hash function. The\n   parameters field for id-sha1 shall\
    \ have type NULL.\n   oaepDigestAlgorithms ALGORITHM-IDENTIFIER ::= {\n     {NULL\
    \ IDENTIFIED BY id-sha1} }\n   id-sha1 OBJECT IDENTIFIER ::=\n     {iso(1) identified-organization(3)\
    \ oiw(14) secsig(3)\n       algorithms(2) 26}\n   The default hash function is\
    \ SHA-1:\n   sha1Identifier ::= AlgorithmIdentifier {id-sha1, NULL}\n   -maskGenFunc\
    \ identifies the mask generation function. It shall be an\n   algorithm ID with\
    \ an OID in the set pkcs1MGFAlgorithms, which for\n   this version shall consist\
    \ of id-mgf1, identifying the MGF1 mask\n   generation function (see Section 10.2.1).\
    \ The parameters field for\n   id-mgf1 shall have type AlgorithmIdentifier, identifying\
    \ the hash\n   function on which MGF1 is based, where the OID for the hash function\n\
    \   shall be in the set oaepDigestAlgorithms.\n   pkcs1MGFAlgorithms ALGORITHM-IDENTIFIER\
    \ ::= {\n     {AlgorithmIdentifier {{oaepDigestAlgorithms}} IDENTIFIED\n     \
    \  BY id-mgf1} }\n   id-mgf1 OBJECT IDENTIFIER ::= {pkcs-1 8}\n   The default\
    \ mask generation function is MGF1 with SHA-1:\n   mgf1SHA1Identifier ::= AlgorithmIdentifier\
    \ {\n     id-mgf1, sha1Identifier }\n   -pSourceFunc identifies the source (and\
    \ possibly the value) of the\n   encoding parameters P. It shall be an algorithm\
    \ ID with an OID in the\n   set pkcs1pSourceAlgorithms, which for this version\
    \ shall consist of\n   id-pSpecified, indicating that the encoding parameters\
    \ are specified\n   explicitly. The parameters field for id-pSpecified shall have\
    \ type\n   OCTET STRING, containing the encoding parameters.\n   pkcs1pSourceAlgorithms\
    \ ALGORITHM-IDENTIFIER ::= {\n     {OCTET STRING IDENTIFIED BY id-pSpecified}\
    \ }\n   id-pSpecified OBJECT IDENTIFIER ::= {pkcs-1 9}\n   The default encoding\
    \ parameters is an empty string (so that pHash in\n   EME-OAEP will contain the\
    \ hash of the empty string):\n   pSpecifiedEmptyIdentifier ::= AlgorithmIdentifier\
    \ {\n     id-pSpecified, OCTET STRING SIZE (0) }\n   If all of the default values\
    \ of the fields in RSAES-OAEP-params are\n   used, then the algorithm identifier\
    \ will have the following value:\n   RSAES-OAEP-Default-Identifier ::= AlgorithmIdentifier\
    \ {\n     id-RSAES-OAEP,\n     {sha1Identifier,\n      mgf1SHA1Identifier,\n \
    \     pSpecifiedEmptyIdentifier } }\n"
- title: 11.2.2 Syntax for RSAES-PKCS1-v1_5
  contents:
  - "11.2.2 Syntax for RSAES-PKCS1-v1_5\n   The object identifier rsaEncryption (Section\
    \ 11.1) identifies the\n   RSAES-PKCS1-v1_5 encryption scheme. The parameters\
    \ field associated\n   with this OID in an AlgorithmIdentifier shall have type\
    \ NULL. This is\n   the same as in PKCS #1 v1.5.\n   RsaEncryption   OBJECT IDENTIFIER\
    \ ::= {PKCS-1 1}\n"
- title: 11.2.3 Syntax for RSASSA-PKCS1-v1_5
  contents:
  - "11.2.3 Syntax for RSASSA-PKCS1-v1_5\n   The object identifier for RSASSA-PKCS1-v1_5\
    \ shall be one of the\n   following. The choice of OID depends on the choice of\
    \ hash algorithm:\n   MD2, MD5 or SHA-1. Note that if either MD2 or MD5 is used\
    \ then the\n   OID is just as in PKCS #1 v1.5. For each OID, the parameters field\n\
    \   associated with this OID in an AlgorithmIdentifier shall have type\n   NULL.\n\
    \   If the hash function to be used is MD2, then the OID should be:\n   md2WithRSAEncryption\
    \ ::= {PKCS-1 2}\n   If the hash function to be used is MD5, then the OID should\
    \ be:\n   md5WithRSAEncryption ::= {PKCS-1 4}\n   If the hash function to be used\
    \ is SHA-1, then the OID should be:\n   sha1WithRSAEncryption ::= {pkcs-1 5}\n\
    \   In the digestInfo type mentioned in Section 9.2.1 the OIDS for the\n   digest\
    \ algorithm are the following:\n   id-SHA1 OBJECT IDENTIFIER ::=\n           {iso(1)\
    \ identified-organization(3) oiw(14) secsig(3)\n            algorithms(2) 26 }\n\
    \   md2 OBJECT IDENTIFIER ::=\n           {iso(1) member-body(2) US(840) rsadsi(113549)\n\
    \            digestAlgorithm(2) 2}\n   md5 OBJECT IDENTIFIER ::=\n           {iso(1)\
    \ member-body(2) US(840) rsadsi(113549)\n            digestAlgorithm(2) 5}\n \
    \  The parameters field of the digest algorithm has ASN.1 type NULL for\n   these\
    \ OIDs.\n"
- title: 12. Patent statement
  contents:
  - "12. Patent statement\n   The Internet Standards Process as defined in RFC 1310\
    \ requires a\n   written statement from the Patent holder that a license will\
    \ be made\n   available to applicants under reasonable terms and conditions prior\n\
    \   to approving a specification as a Proposed, Draft or Internet\n   Standard.\n\
    \   The Internet Society, Internet Architecture Board, Internet\n   Engineering\
    \ Steering Group and the Corporation for National Research\n   Initiatives take\
    \ no position on the validity or scope of the\n   following patents and patent\
    \ applications, nor on the appropriateness\n   of the terms of the assurance.\
    \ The Internet Society and other groups\n   mentioned above have not made any\
    \ determination as to any other\n   intellectual property rights which may apply\
    \ to the practice of this\n   standard.  Any further consideration of these matters\
    \ is the user's\n   responsibility.\n"
- title: 12.1 Patent statement for the RSA algorithm
  contents:
  - "12.1 Patent statement for the RSA algorithm\n   The Massachusetts Institute of\
    \ Technology has granted RSA Data\n   Security, Inc., exclusive sub-licensing\
    \ rights to the following\n   patent issued in the United States:\n   Cryptographic\
    \ Communications System and Method (\"RSA\"), No. 4,405,829\n   RSA Data Security,\
    \ Inc. has provided the following statement with\n   regard to this patent:\n\
    \   It is RSA's business practice to make licenses to its patents\n   available\
    \ on reasonable and nondiscriminatory terms. Accordingly, RSA\n   is willing,\
    \ upon request, to grant non-exclusive licenses to such\n   patent on reasonable\
    \ and non-discriminatory terms and conditions to\n   those who respect RSA's intellectual\
    \ property rights and subject to\n   RSA's then current royalty rate for the patent\
    \ licensed. The royalty\n   rate for the RSA patent is presently set at 2% of\
    \ the licensee's\n   selling price for each product covered by the patent.  Any\
    \ requests\n   for license information may be directed to:\n            Director\
    \ of Licensing\n            RSA Data Security, Inc.\n            2955 Campus Drive\n\
    \            Suite 400\n            San Mateo, CA 94403\n   A license under RSA's\
    \ patent(s) does not include any rights to know-\n   how or other technical information\
    \ or license under other\n   intellectual property rights.  Such license does\
    \ not extend to any\n   activities which constitute infringement or inducement\
    \ thereto. A\n   licensee must make his own determination as to whether a license\
    \ is\n   necessary under patents of others.\n"
- title: 13. Revision history
  contents:
  - "13. Revision history\n   Versions 1.0-1.3\n   Versions 1.0-1.3 were distributed\
    \ to participants in RSA Data\n   Security, Inc.'s Public-Key Cryptography Standards\
    \ meetings in\n   February and March 1991.\n   Version 1.4\n   Version 1.4 was\
    \ part of the June 3, 1991 initial public release of\n   PKCS. Version 1.4 was\
    \ published as NIST/OSI Implementors' Workshop\n   document SEC-SIG-91-18.\n \
    \  Version 1.5\n   Version 1.5 incorporates several editorial changes, including\
    \ updates\n   to the references and the addition of a revision history. The\n\
    \   following substantive changes were made: -Section 10: \"MD4 with RSA\"\n \
    \  signature and verification processes were added.\n   -Section 11: md4WithRSAEncryption\
    \ object identifier was added.\n   Version 2.0 [DRAFT]\n   Version 2.0 incorporates\
    \ major editorial changes in terms of the\n   document structure, and introduces\
    \ the RSAEP-OAEP encryption scheme.\n   This version continues to support the\
    \ encryption and signature\n   processes in version 1.5, although the hash algorithm\
    \ MD4 is no\n   longer allowed due to cryptanalytic advances in the intervening\n\
    \   years.\n"
- title: 14. References
  contents:
  - "14. References\n   [1] ANSI, ANSI X9.44: Key Management Using Reversible Public\
    \ Key\n       Cryptography for the Financial Services Industry. Work in\n    \
    \   Progress.\n   [2] M. Bellare and P. Rogaway. Optimal Asymmetric Encryption\
    \ - How to\n       Encrypt with RSA. In Advances in Cryptology-Eurocrypt '94,\
    \ pp.\n       92-111, Springer-Verlag, 1994.\n   [3] M. Bellare and P. Rogaway.\
    \ The Exact Security of Digital\n       Signatures - How to Sign with RSA and\
    \ Rabin. In Advances in\n       Cryptology-Eurocrypt '96, pp. 399-416, Springer-Verlag,\
    \ 1996.\n   [4] D. Bleichenbacher. Chosen Ciphertext Attacks against Protocols\n\
    \       Based on the RSA Encryption Standard PKCS #1. To appear in\n       Advances\
    \ in Cryptology-Crypto '98.\n   [5] D. Bleichenbacher, B. Kaliski and J. Staddon.\
    \ Recent Results on\n       PKCS #1: RSA Encryption Standard. RSA Laboratories'\
    \ Bulletin,\n       Number 7, June 24, 1998.\n   [6] CCITT. Recommendation X.509:\
    \ The Directory-Authentication\n       Framework. 1988.\n   [7] D. Coppersmith,\
    \ M. Franklin, J. Patarin and M. Reiter. Low-\n       Exponent RSA with Related\
    \ Messages. In Advances in Cryptology-\n       Eurocrypt '96, pp. 1-9, Springer-Verlag,\
    \ 1996\n   [8] B. Den Boer and Bosselaers. Collisions for the Compression\n  \
    \     Function of MD5. In Advances in Cryptology-Eurocrypt '93, pp\n       293-304,\
    \ Springer-Verlag, 1994.\n   [9] B. den Boer, and A. Bosselaers. An Attack on\
    \ the Last Two Rounds\n       of MD4. In Advances in Cryptology-Crypto '91, pp.194-203,\n\
    \       Springer-Verlag, 1992.\n   [10] H. Dobbertin. Cryptanalysis of MD4. Fast\
    \ Software Encryption.\n        Lecture Notes in Computer Science, Springer-Verlag\
    \ 1996, pp.\n        55-72.\n   [11] H. Dobbertin. Cryptanalysis of MD5 Compress.\
    \ Presented at the\n        rump session of Eurocrypt `96, May 14, 1996\n   [12]\
    \ H. Dobbertin.The First Two Rounds of MD4 are Not One-Way. Fast\n        Software\
    \ Encryption. Lecture Notes in Computer Science,\n        Springer-Verlag 1998,\
    \ pp. 284-292.\n   [13] J. Hastad. Solving Simultaneous Modular Equations of Low\
    \ Degree.\n        SIAM Journal of Computing, 17, 1988, pp. 336-341.\n   [14]\
    \ IEEE. IEEE P1363: Standard Specifications for Public Key\n        Cryptography.\
    \ Draft Version 4.\n   [15] Kaliski, B., \"The MD2 Message-Digest Algorithm\"\
    , RFC 1319, April\n        1992.\n   [16] National Institute of Standards and\
    \ Technology (NIST). FIPS\n        Publication 180-1: Secure Hash Standard. April\
    \ 1994.\n   [17] Rivest, R., \"The MD5 Message-Digest Algorithm\", RFC 1321, April\n\
    \        1992.\n   [18] R. Rivest, A. Shamir and L. Adleman. A Method for Obtaining\n\
    \        Digital Signatures and Public-Key Cryptosystems. Communications\n   \
    \     of the ACM, 21(2), pp. 120-126, February 1978.\n   [19] N. Rogier and P.\
    \ Chauvaud. The Compression Function of MD2 is\n        not Collision Free. Presented\
    \ at Selected Areas of Cryptography\n        `95. Carleton University, Ottawa,\
    \ Canada. May 18-19, 1995.\n   [20] RSA Laboratories. PKCS #1: RSA Encryption\
    \ Standard. Version 1.5,\n        November 1993.\n   [21] RSA Laboratories. PKCS\
    \ #7: Cryptographic Message Syntax\n        Standard. Version 1.5, November 1993.\n\
    \   [22] RSA  Laboratories. PKCS #8: Private-Key Information Syntax\n        Standard.\
    \ Version 1.2, November 1993.\n   [23] RSA Laboratories. PKCS #12: Personal Information\
    \ Exchange Syntax\n        Standard. Version 1.0, Work in Progress, April 1997.\n"
- title: Security Considerations
  contents:
  - "Security Considerations\n   Security issues are discussed throughout this memo.\n"
- title: Acknowledgements
  contents:
  - "Acknowledgements\n   This document is based on a contribution of RSA Laboratories,\
    \ a\n   division of RSA Data Security, Inc.  Any substantial use of the text\n\
    \   from this document must acknowledge RSA Data Security, Inc. RSA Data\n   Security,\
    \ Inc. requests that all material mentioning or referencing\n   this document\
    \ identify this as \"RSA Data Security, Inc. PKCS #1\n   v2.0\".\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Burt Kaliski\n   RSA Laboratories East\n   20 Crosby Drive\n\
    \   Bedford, MA  01730\n   Phone: (617) 687-7000\n   EMail: burt@rsa.com\n   Jessica\
    \ Staddon\n   RSA Laboratories West\n   2955 Campus Drive\n   Suite 400\n   San\
    \ Mateo, CA 94403\n   Phone: (650) 295-7600\n   EMail: jstaddon@rsa.com\n"
- title: Full Copyright Statement
  contents:
  - "Full Copyright Statement\n   Copyright (C) The Internet Society (1998).  All\
    \ Rights Reserved.\n   This document and translations of it may be copied and\
    \ furnished to\n   others, and derivative works that comment on or otherwise explain\
    \ it\n   or assist in its implementation may be prepared, copied, published\n\
    \   and distributed, in whole or in part, without restriction of any\n   kind,\
    \ provided that the above copyright notice and this paragraph are\n   included\
    \ on all such copies and derivative works.  However, this\n   document itself\
    \ may not be modified in any way, such as by removing\n   the copyright notice\
    \ or references to the Internet Society or other\n   Internet organizations, except\
    \ as needed for the purpose of\n   developing Internet standards in which case\
    \ the procedures for\n   copyrights defined in the Internet Standards process\
    \ must be\n   followed, or as required to translate it into languages other than\n\
    \   English.\n   The limited permissions granted above are perpetual and will\
    \ not be\n   revoked by the Internet Society or its successors or assigns.\n \
    \  This document and the information contained herein is provided on an\n   \"\
    AS IS\" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING\n   TASK FORCE\
    \ DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING\n   BUT NOT LIMITED\
    \ TO ANY WARRANTY THAT THE USE OF THE INFORMATION\n   HEREIN WILL NOT INFRINGE\
    \ ANY RIGHTS OR ANY IMPLIED WARRANTIES OF\n   MERCHANTABILITY OR FITNESS FOR A\
    \ PARTICULAR PURPOSE.\n"
