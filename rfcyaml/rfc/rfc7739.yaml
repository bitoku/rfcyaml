- title: __initial_text__
  contents:
  - '  Security Implications of Predictable Fragment Identification Values

    '
- title: Abstract
  contents:
  - "Abstract\n   IPv6 specifies the Fragment Header, which is employed for the\n\
    \   fragmentation and reassembly mechanisms.  The Fragment Header\n   contains\
    \ an \"Identification\" field that, together with the IPv6\n   Source Address\
    \ and the IPv6 Destination Address of a packet,\n   identifies fragments that\
    \ correspond to the same original datagram,\n   such that they can be reassembled\
    \ together by the receiving host.\n   The only requirement for setting the Identification\
    \ field is that the\n   corresponding value must be different than that employed\
    \ for any\n   other fragmented datagram sent recently with the same Source Address\n\
    \   and Destination Address.  Some implementations use a simple global\n   counter\
    \ for setting the Identification field, thus leading to\n   predictable Identification\
    \ values.  This document analyzes the\n   security implications of predictable\
    \ Identification values, and\n   provides implementation guidance for setting\
    \ the Identification field\n   of the Fragment Header, such that the aforementioned\
    \ security\n   implications are mitigated.\n"
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This document is not an Internet Standards Track specification;\
    \ it is\n   published for informational purposes.\n   This document is a product\
    \ of the Internet Engineering Task Force\n   (IETF).  It represents the consensus\
    \ of the IETF community.  It has\n   received public review and has been approved\
    \ for publication by the\n   Internet Engineering Steering Group (IESG).  Not\
    \ all documents\n   approved by the IESG are a candidate for any level of Internet\n\
    \   Standard; see Section 2 of RFC 5741.\n   Information about the current status\
    \ of this document, any errata,\n   and how to provide feedback on it may be obtained\
    \ at\n   http://www.rfc-editor.org/info/rfc7739.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (c) 2016 IETF Trust and the persons identified\
    \ as the\n   document authors.  All rights reserved.\n   This document is subject\
    \ to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n\
    \   (http://trustee.ietf.org/license-info) in effect on the date of\n   publication\
    \ of this document.  Please review these documents\n   carefully, as they describe\
    \ your rights and restrictions with respect\n   to this document.  Code Components\
    \ extracted from this document must\n   include Simplified BSD License text as\
    \ described in Section 4.e of\n   the Trust Legal Provisions and are provided\
    \ without warranty as\n   described in the Simplified BSD License.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1.  Introduction  . . . . . . . . . . . . . . . . . . .\
    \ . . . . .   3\n   2.  Terminology . . . . . . . . . . . . . . . . . . . . .\
    \ . . . .   3\n   3.  Security Implications of Predictable Fragment Identification\n\
    \       Values  . . . . . . . . . . . . . . . . . . . . . . . . . . .   3\n  \
    \ 4.  Constraints for the Selection of Fragment Identification\n       Values\
    \  . . . . . . . . . . . . . . . . . . . . . . . . . . .   7\n   5.  Algorithms\
    \ for Selecting Fragment Identification Values . . .   8\n     5.1.  Per-Destination\
    \ Counter (Initialized to a Random Value) .   8\n     5.2.  Randomized Identification\
    \ Values  . . . . . . . . . . . .   9\n     5.3.  Hash-Based Fragment Identification\
    \ Selection Algorithm  .  10\n   6.  Security Considerations . . . . . . . . .\
    \ . . . . . . . . . .  12\n   7.  References  . . . . . . . . . . . . . . . .\
    \ . . . . . . . . .  13\n     7.1.  Normative References  . . . . . . . . . .\
    \ . . . . . . . .  13\n     7.2.  Informative References  . . . . . . . . . .\
    \ . . . . . . .  14\n   Appendix A.  Information Leakage Produced by Vulnerable\n\
    \                Implementations  . . . . . . . . . . . . . . . . . .  16\n  \
    \ Appendix B.  Survey of Fragment Identification Selection\n                Algorithms\
    \ Employed by Popular IPv6 Implementations   18\n   Acknowledgements  . . . .\
    \ . . . . . . . . . . . . . . . . . . . .  20\n   Author's Address  . . . . .\
    \ . . . . . . . . . . . . . . . . . . .  20\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   IPv6 specifies the Fragment Header, which is employed for\
    \ the\n   fragmentation and reassembly mechanisms.  The Fragment Header\n   contains\
    \ an \"Identification\" field that, together with the IPv6\n   Source Address\
    \ and the IPv6 Destination Address of a packet,\n   identifies fragments that\
    \ correspond to the same original datagram,\n   such that they can be reassembled\
    \ together by the receiving host.\n   The only requirement for setting the Identification\
    \ field is that its\n   value must be different than that employed for any other\
    \ fragmented\n   datagram sent recently with the same Source Address and Destination\n\
    \   Address.\n   The most trivial algorithm to avoid reusing Identification values\
    \ too\n   quickly is to maintain a global counter that is incremented for each\n\
    \   fragmented datagram that is transmitted.  However, this trivial\n   algorithm\
    \ leads to predictable Identification values that can be\n   leveraged to perform\
    \ a variety of attacks.\n   Section 3 of this document analyzes the security implications\
    \ of\n   predictable Identification values.  Section 4 discusses constraints\n\
    \   in the possible algorithms for selecting Identification values.\n   Section\
    \ 5 specifies a number of algorithms that could be used for\n   generating Identification\
    \ values that mitigate the issues discussed\n   in this document.  Finally, Appendix\
    \ B contains a survey of the\n   algorithms employed by popular IPv6 implementations\
    \ for generating\n   the Identification values.\n"
- title: 2.  Terminology
  contents:
  - "2.  Terminology\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\"\
    , \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and\
    \ \"OPTIONAL\" in this\n   document are to be interpreted as described in RFC\
    \ 2119 [RFC2119].\n"
- title: 3.  Security Implications of Predictable Fragment Identification Values
  contents:
  - "3.  Security Implications of Predictable Fragment Identification Values\n   Predictable\
    \ Identification values result in an information leakage\n   that can be exploited\
    \ in a number of ways.  Among others, they may\n   potentially be exploited to:\n\
    \   o  determine the packet rate at which a given system is transmitting\n   \
    \   information\n   o  perform stealth port scans to a third party\n   o  uncover\
    \ the rules of a number of firewalls\n   o  count the number of systems behind\
    \ a middle-box\n   o  perform Denial-of-Service (DoS) attacks, or\n   o  perform\
    \ data injection attacks against transport or application\n      protocols\n \
    \  The security implications introduced by predictable Identification\n   values\
    \ in IPv6 are very similar to those of predictable\n   Identification values in\
    \ IPv4.\n   NOTE:\n      [Sanfilippo1998a] originally pointed out how the IPv4\n\
    \      Identification field could be examined to determine the packet\n      rate\
    \ at which a given system is transmitting information.  Later,\n      [Sanfilippo1998b]\
    \ described how a system with such an\n      implementation could be used to perform\
    \ a stealth port scan to a\n      third (victim) host.  [Sanfilippo1999] explained\
    \ how to exploit\n      this implementation strategy to uncover the rules of a\
    \ number of\n      firewalls.  [Bellovin2002] explained how the IPv4 Identification\n\
    \      field could be exploited to count the number of systems behind a\n    \
    \  NAT.  [Fyodor2004] is an entire paper on most (if not all) the\n      ways\
    \ to exploit the information provided by the Identification\n      field of the\
    \ IPv4 header (and these results apply in a similar way\n      to IPv6).  [Zalewski2003]\
    \ originally envisioned the exploitation\n      of IP fragmentation/reassembly\
    \ for performing data injection\n      attacks against upper-layer protocols.\
    \  [Herzberg2013] explores\n      the use of IPv4/IPv6 fragmentation and predictable\
    \ Identification\n      values for performing DNS cache poisoning attacks in great\
    \ detail.\n      [RFC6274] covers the security implications of the IPv4 case in\n\
    \      detail.\n   One key difference between the IPv4 case and the IPv6 case\
    \ is that,\n   in IPv4, the Identification field is part of the fixed IPv4 header\n\
    \   (and thus usually set for all packets), while in IPv6 the\n   Identification\
    \ field is present only in those packets that carry a\n   Fragment Header.  As\
    \ a result, successful exploitation of the\n   Identification field depends on\
    \ two different factors:\n   o  vulnerable Identification generators, and\n  \
    \ o  the ability of an attacker to trigger the use of IPv6\n      fragmentation\
    \ for packets sent from/to the victim node\n   The scenarios in which an attacker\
    \ may successfully perform the\n   aforementioned attacks depend on the specific\
    \ attack type.  For\n   example, in order to perform a DoS attack on communications\
    \ between\n   two hosts, an attacker would need to know the IPv6 addresses employed\n\
    \   by the aforementioned two nodes.  Such knowledge may be readily\n   available\
    \ if the target of the attack is the communication between\n   two specific BGP\
    \ peers, two specific SMTP servers, or one specific\n   primary DNS server and\
    \ one of its secondary DNS servers, but may not\n   be easily available if the\
    \ goal is a DoS attack on all communications\n   between arbitrary IPv6 hosts\
    \ (e.g., the goal is to perform a DoS\n   attack on all communications involving\
    \ one specific node with\n   arbitrary/unknown hosts).  Other attacks, such as\
    \ performing stealth\n   port scans to a third party or determining the packet\
    \ rate at which a\n   given system is transmitting information, only require the\
    \ attacker\n   to know the IPv6 address of a vulnerable implementation.\n   As\
    \ noted in Section 1, some implementations have been known to use\n   predictable\
    \ Identification values.  For instance, Appendix B of this\n   document shows\
    \ that recent versions of a number of popular IPv6\n   implementations employ\
    \ predictable values for the Identification\n   field of the Fragment Header.\n\
    \   Additionally, we note that [RFC2460] states that when an ICMPv6\n   Packet\
    \ Too Big (PTB) error message advertising a Maximum Transfer\n   Unit (MTU) smaller\
    \ than 1280 bytes is received, the receiving host is\n   not required to reduce\
    \ the Path-MTU for the corresponding Destination\n   Address, but must simply\
    \ include a Fragment Header in all subsequent\n   packets sent to that destination.\
    \  This triggers the use of the so-\n   called IPv6 \"atomic fragments\" [RFC6946]:\
    \ IPv6 fragments with a\n   Fragment Offset equal to 0, and the \"M\" (\"More\
    \ fragments\") bit clear.\n   [DEPGEN] documents the motivation of deprecating\
    \ the generation of\n   IPv6 atomic fragments in [RFC2460].\n   Thus, an attacker\
    \ can usually cause a victim host to \"fragment\" its\n   outgoing packets by\
    \ sending it a forged ICMPv6 Packet Too Big (PTB)\n   error message that advertises\
    \ an MTU smaller than 1280 bytes.\n   There are a number of aspects that should\
    \ be considered, though:\n   o  All the implementations the author is aware of\
    \ record the Path-MTU\n      information on a per-destination basis.  Thus, an\
    \ attacker can\n      only cause the victim to enable fragmentation for those\
    \ packets\n      sent to the Source Address of IPv6 packet embedded in the payload\n\
    \      of the ICMPv6 PTB message.  However, we note that Section 5.2 of\n    \
    \  [RFC1981] notes that an implementation could maintain a single\n      system-wide\
    \ Path MTU (PMTU) value to be used for all packets sent\n      to that node. \
    \ Clearly, such implementations would exacerbate the\n      problem of any attacks\
    \ based on Path MTU Discovery (PMTUD)\n      [RFC5927] or IPv6 fragmentation.\n\
    \   o  If the victim node implements some of the counter-measures for\n      ICMP\
    \ attacks described in RFC 5927 [RFC5927], it might be\n      difficult for an\
    \ attacker to cause the victim node to employ\n      fragmentation for its outgoing\
    \ packets.  However, many current\n      implementations fail to enforce these\
    \ validation checks.  For\n      example, Linux 2.6.38-8 does not even require\
    \ received ICMPv6\n      error messages to correspond to an ongoing communication\
    \ instance.\n   o  Some implementations (notably Linux) have already been updated\n\
    \      according to [DEPGEN] such that ICMPv6 PTB messages do not result\n   \
    \   in the generation of IPv6 atomic fragments.\n   Implementations that employ\
    \ predictable Identification values and\n   also fail to enforce validation checks\
    \ on ICMPv6 error messages\n   become vulnerable to the same type of attacks that\
    \ can be exploited\n   with IPv4 fragmentation, discussed earlier in this section.\n\
    \   One possible way in which predictable Identification values could be\n   leveraged\
    \ for performing a DoS attack is as follows: Let us assume\n   that Host A is\
    \ communicating with Host B, and that an attacker wants\n   to perform a DoS attack\
    \ such communication.  The attacker would learn\n   the Identification value currently\
    \ in use by Host A, possibly by\n   sending any packet that would elicit a fragmented\
    \ response (e.g., an\n   ICPMv6 echo request with a large payload).  The attacker\
    \ would then\n   send a forged ICMPv6 PTB error message to Host A (with the IPv6\n\
    \   Source Address of the embedded IPv6 packet set to the IPv6 address of\n  \
    \ Host A, and the Destination Address of the embedded IPv6 packet set\n   to the\
    \ IPv6 address of a Host B), such that any subsequent packets\n   sent by Host\
    \ A to Host B include a Fragment Header.  Finally, the\n   attacker would send\
    \ forged IPv6 fragments to Host B, with their IPv6\n   Source Address set to that\
    \ of Host A, and Identification values that\n   would result in collisions with\
    \ the Identification values employed\n   for the legitimate traffic sent by Host\
    \ A to Host B.  If Host B\n   discards fragments that result in collisions of\
    \ Identification values\n   (e.g., such fragments overlap, and the host implements\
    \ [RFC5722]),\n   the attacker could simply trash the Identification space by\
    \ sending\n   multiple forged fragments with different Identification values,\
    \ such\n   that any subsequent packets from Host A to Host B are discarded at\n\
    \   Host B as a result of the malicious fragments sent by the attacker.\n   NOTE:\n\
    \      For example, Linux 2.6.38-10 is vulnerable to the aforementioned\n    \
    \  issue.\n      [RFC6946] describes an improved processing of these packets that\n\
    \      would eliminate this specific attack vector, at least in the case\n   \
    \   of TCP connections that employ the Path-MTU Discovery mechanism.\n   The aforementioned\
    \ attack scenario is simply included to illustrate\n   the problem of employing\
    \ predictable Identification values.  We note\n   that regardless of the attacker's\
    \ ability to cause a victim host to\n   employ fragmentation when communicating\
    \ with third parties, use of\n   predictable Identification values makes communication\
    \ flows that\n   employ fragmentation vulnerable to any fragmentation-based attacks.\n"
- title: 4.  Constraints for the Selection of Fragment Identification Values
  contents:
  - "4.  Constraints for the Selection of Fragment Identification Values\n   The Identification\
    \ field of the Fragment Header is 32-bits long.\n   However, when translators\
    \ (e.g.  [RFC6145]) are employed, the high-\n   order 16 bits of the Identification\
    \ field are effectively ignored.\n   NOTE:\n      [RFC6145] notes that, when translating\
    \ in the IPv6-to-IPv4\n      direction, \"if there is a Fragment Header in the\
    \ IPv6 packet, the\n      last 16 bits of its value MUST be used for the IPv4\
    \ identification\n      value\".\n      Additionally, Section 3.3 of [RFC6052]\
    \ encourages operators to use\n      a Network-Specific Prefix (NSP) that maps\
    \ the IPv4 address space\n      into IPv6.  Thus, when an NSP is being used, IPv6\
    \ addresses\n      representing IPv4 nodes (reached through a stateless translator)\n\
    \      are indistinguishable from native IPv6 addresses.\n   Thus, when translators\
    \ are employed, the \"effective\" length of the\n   Identification field is 16\
    \ bits and, as a result, at least during the\n   IPv6/IPv4 transition/co-existence\
    \ phase, it is probably safer to\n   assume that only the low-order 16 bits of\
    \ the Identification field\n   are of use to the destination system.\n   Regarding\
    \ the selection of Identification values, the only\n   requirement specified in\
    \ [RFC2460] is that the Identification value\n   must be different than that of\
    \ any other fragmented packet sent\n   recently with the same Source Address and\
    \ Destination Address.\n   Failure to comply with this requirement could lead\
    \ to the\n   interoperability problems discussed in [RFC4963].\n   From a security\
    \ standpoint, unpredictable Identification values are\n   desirable.  However,\
    \ this is somewhat at odds with the \"reuse\"\n   requirements specified in [RFC2460],\
    \ that specifies that an\n   Identification value must be different than that\
    \ employed for any\n   other fragmented packet sent recently with the same Source\
    \ Address\n   and Destination Address.\n   Finally, since Identification values\
    \ need to be selected for each\n   outgoing datagram that requires fragmentation,\
    \ the performance impact\n   should be considered when choosing an algorithm for\
    \ the selection of\n   Identification values.\n"
- title: 5.  Algorithms for Selecting Fragment Identification Values
  contents:
  - "5.  Algorithms for Selecting Fragment Identification Values\n   There are a number\
    \ of algorithms that may be used for setting the\n   Identification field such\
    \ that the security issues discussed in this\n   document are avoided.  This section\
    \ presents three of those.\n   The algorithm in Section 5.1 typically leads to\
    \ a low Identification\n   reuse frequency at the expense of keeping per-destination\
    \ state; this\n   algorithm only uses a Pseudorandom Number Generator (PNRG) when\
    \ the\n   host communicates with a new destination.  The algorithm in\n   Section\
    \ 5.2 may result in a higher Identification reuse frequency.\n   It also uses\
    \ a PRNG for each datagram that needs to be fragmented.\n   Hence, the algorithm\
    \ in Section 5.1 will likely result in better\n   performance properties.  Finally,\
    \ the algorithm in Section 5.3\n   achieves a similar Identification reuse frequency\
    \ to that of the\n   algorithm in Section 5.1 without the need of keeping state,\
    \ but\n   possibly at the expense of lower per-packet performance.\n   NOTE:\n\
    \      Since the specific algorithm to be employed for the PRNGs in\n      Section\
    \ 5.1 and Section 5.2, and the specific algorithms to be\n      employed for the\
    \ hash functions in Section 5.3 have not been\n      specified, it is impossible\
    \ to provide a quantitative performance\n      comparison of the algorithms described\
    \ in this section.\n"
- title: 5.1.  Per-Destination Counter (Initialized to a Random Value)
  contents:
  - "5.1.  Per-Destination Counter (Initialized to a Random Value)\n   This algorithm\
    \ consists of the following steps:\n   1.  Whenever a packet must be sent with\
    \ a Fragment Header, the\n       sending host should look up in the Destination\
    \ Cache an entry\n       corresponding to the Destination Address of the packet.\n\
    \   2.  If such an entry exists, it contains the last Identification\n       value\
    \ used for that Destination Address.  Therefore, such a value\n       should be\
    \ incremented by 1 and used for setting the\n       Identification field of the\
    \ outgoing packet.  Additionally, the\n       updated value should be recorded\
    \ in the corresponding entry of\n       the Destination Cache [RFC4861].\n   3.\
    \  If such an entry does not exist, it should be created, and the\n       Identification\
    \ value for that destination should be initialized\n       with a random value\
    \ (e.g., with a Pseudorandom Number Generator),\n       and used for setting the\
    \ Identification field of the Fragment\n       Header of the outgoing fragmented\
    \ datagram.\n   The advantages of this algorithm are:\n   o  It is simple to implement,\
    \ with the only complexity residing in\n      the PRNG used to initialize the\
    \ Identification value contained in\n      each entry of the Destination Cache.\n\
    \   o  The Identification reuse frequency will typically be lower than\n     \
    \ that achieved by a global counter (when sending traffic to\n      multiple destinations),\
    \ since this algorithm uses per-destination\n      counters (rather than a single\
    \ system-wide counter).\n   o  It has good performance properties (once the corresponding\
    \ entry\n      in the Destination Cache has been created and initialized, each\n\
    \      subsequent Identification value simply involves the increment of a\n  \
    \    counter).\n   The possible drawbacks of this algorithm are:\n   o  If, as\
    \ a result of resource management, an entry of the\n      Destination Cache must\
    \ be removed, the last Identification value\n      used for that Destination will\
    \ be lost.  Thus, subsequent traffic\n      to that destination would cause that\
    \ entry to be recreated and\n      reinitialized to random value, thus possibly\
    \ leading to\n      Identification \"collisions\".\n   o  Since the Identification\
    \ values are predictable by the destination\n      host, a vulnerable host might\
    \ possibly leak to third parties the\n      Identification values used by other\
    \ hosts to send traffic to it\n      (i.e., Host B could leak to Host C the Identification\
    \ values that\n      Host A is using to send packets to Host B).  Appendix A describes\n\
    \      one possible scenario for such leakage in detail.\n"
- title: 5.2.  Randomized Identification Values
  contents:
  - "5.2.  Randomized Identification Values\n   Clearly, use of a Pseudorandom Number\
    \ Generator for selecting the\n   Identification would be desirable from a security\
    \ standpoint.  With\n   such a scheme, the Identification of each fragmented datagram\
    \ would\n   be selected as:\n                  Identification = random()\n   where\
    \ \"random()\" is the PRNG.\n   The specific properties of such scheme would clearly\
    \ depend on the\n   specific PRNG employed.  For example, some PRNGs may result\
    \ in higher\n   Identification reuse frequencies than others, in the same way\
    \ that\n   some PRNGs may be more expensive (in terms of processing requirements\n\
    \   and/or implementation complexity) than others.\n   Discussion of the properties\
    \ of possible PRNGs is considered out of\n   the scope of this document.  However,\
    \ we do note that some PRNGs\n   employed in the past by some implementations\
    \ have been found to be\n   predictable [Klein2007].  Please see [RFC4086] for\
    \ randomness\n   requirements for security.\n"
- title: 5.3.  Hash-Based Fragment Identification Selection Algorithm
  contents:
  - "5.3.  Hash-Based Fragment Identification Selection Algorithm\n   Another alternative\
    \ is to implement a hash-based algorithm similar to\n   that specified in [RFC6056]\
    \ for the selection of transport port\n   numbers.  With such a scheme, the Identification\
    \ value of each\n   fragmented datagram would be selected with the expression:\n\
    \   Identification = F(Src IP, Dst IP, secret1)  +\n                    counter[G(Src\
    \ IP, Dst Pref, secret2)]\n   where:\n   Identification:\n      Identification\
    \ value to be used for the fragmented datagram.\n   F():\n      Hash function.\n\
    \   Src IP:\n      IPv6 Source Address of the datagram to be fragmented.\n   Dst\
    \ IP:\n      IPv6 Destination Address of the datagram to be fragmented.\n   secret1:\n\
    \      Secret data unknown to the attacker.  This value can be\n      initialized\
    \ to a pseudo-random value during the system\n      bootstrapping sequence.  It\
    \ should remain constant at least while\n      there could be previously sent\
    \ fragments still in the network or\n      at the fragment reassembly buffer of\
    \ the corresponding destination\n      system(s).\n   counter[]:\n      System-wide\
    \ array of 32-bit counters (e.g. with 8K elements or\n      more).  Each counter\
    \ should be initialized to a pseudo-random\n      value during the system bootstrapping\
    \ sequence.\n   G():\n      Hash function.  It may or may not be the same hash\
    \ function as\n      that used for F().\n   Dst Pref:\n      IPv6 \"Destination\
    \ Prefix\" of the datagram to be fragmented (can be\n      assumed to be the first\
    \ eight bytes of the Destination Address of\n      such packet).  Note: the \"\
    Destination Prefix\" (rather than\n      Destination Address) is used, such that\
    \ the ability of an attacker\n      of searching the \"increments\" space by using\
    \ multiple addresses of\n      the same subnet is reduced.\n   secret2:\n    \
    \  Secret data unknown to the attacker.  This value can be\n      initialized\
    \ to a pseudo-random value during the system\n      bootstrapping sequence.  It\
    \ should remain constant at least while\n      there could be previously sent\
    \ fragments still in the network or\n      at the fragment reassembly buffer of\
    \ the corresponding destination\n      system(s).\n   NOTE:\n      counter[G(src\
    \ IP, Dst Pref, secret2)] should be incremented by one\n      each time an Identification\
    \ value is selected.\n   The output of F() will be constant for each (Src IP,\
    \ Dst IP) pair.\n   Similarly, the output of G() will be constant for each (Src\
    \ IP, Dst\n   Pref) pair.  Thus, the resulting Identification value will be the\n\
    \   result of a random offset plus a linear function (provided by\n   counter[]),\
    \ therefore resulting in a monotonically increasing\n   sequence of Identification\
    \ values for each (src IP, Dst IP) pair.\n   NOTE:\n      F() essentially provides\
    \ the unpredictability (by off-path\n      attackers) of the resulting Identification\
    \ values, while counter[]\n      provides a linear function such that the Identification\
    \ values are\n      different for each fragmented packet while the Identification\n\
    \      reuse frequency is minimized.\n   The advantages of this algorithm are:\n\
    \   o  The Identification reuse frequency will typically be lower than\n     \
    \ that achieved by a global counter (when sending traffic to\n      multiple destinations),\
    \ since this algorithm uses multiple system-\n      wide counters (rather than\
    \ a single system-wide counter).  The\n      extent to which the reuse frequency\
    \ will be lower depends on the\n      number of elements in counter[], and the\
    \ number of other active\n      flows that result in the same value of G() (and\
    \ hence cause the\n      same counter to be incremented for each datagram that\
    \ is\n      fragmented).\n   o  It is possible to implement the algorithm such\
    \ that good\n      performance is achieved.  For example, the result of F() could\
    \ be\n      stored in the Destination Cache (such that it need not be\n      recomputed\
    \ for each packet that must be sent) along with the\n      computed index/argument\
    \ for counter[].\n      NOTE:\n         If this implementation approach is followed,\
    \ and an entry of\n         the Destination Cache must be removed as a result\
    \ of resource\n         management, the last Identification value used for that\n\
    \         Destination will *not* be lost.  This is an improvement over\n     \
    \    the algorithm specified in Section 5.1.\n   The possible drawbacks of this\
    \ algorithm are:\n   o  Since the Identification values are predictable by the\
    \ destination\n      host, a vulnerable host could possibly leak to third parties\
    \ the\n      Identification values used by other hosts to send traffic to it\n\
    \      (i.e., Host B could leak to Host C the Identification values that\n   \
    \   Host A is using to send packets to Host B).  Appendix A describes\n      a\
    \ possible scenario in which that information leakage could take\n      place.\
    \  We note, however, that this algorithm makes the\n      aforementioned attack\
    \ less reliable for the attacker, since each\n      counter could be possibly\
    \ shared by multiple traffic flows (i.e.,\n      packets destined to other destinations\
    \ might cause the same\n      counter to be incremented).\n   This algorithm might\
    \ be preferable (over the one specified in\n   Section 5.1) in those scenarios\
    \ in which a node is expected to\n   communicate with a large number of destinations,\
    \ and thus it is\n   desirable to limit the amount of information to be maintained\
    \ in\n   memory.\n   NOTE:\n      In such scenarios, if the algorithm specified\
    \ in Section 5.1 were\n      implemented, entries from the Destination Cache might\
    \ need to be\n      pruned frequently, thus increasing the risk of Identification\n\
    \      \"collisions\".\n"
- title: 6.  Security Considerations
  contents:
  - "6.  Security Considerations\n   This document discusses the security implications\
    \ of predictable\n   Identification values, and provides implementation guidance\
    \ such that\n   the aforementioned security implications can be mitigated.\n \
    \  A number of possible algorithms are described, to provide some\n   implementation\
    \ alternatives to implementers.  We note that the\n   selection of such an algorithm\
    \ usually implies a number of trade-offs\n   (security, performance, implementation\
    \ complexity, interoperability\n   properties, etc.).\n"
- title: 7.  References
  contents:
  - '7.  References

    '
- title: 7.1.  Normative References
  contents:
  - "7.1.  Normative References\n   [RFC1981]  McCann, J., Deering, S., and J. Mogul,\
    \ \"Path MTU Discovery\n              for IP version 6\", RFC 1981, DOI 10.17487/RFC1981,\
    \ August\n              1996, <http://www.rfc-editor.org/info/rfc1981>.\n   [RFC2119]\
    \  Bradner, S., \"Key words for use in RFCs to Indicate\n              Requirement\
    \ Levels\", BCP 14, RFC 2119,\n              DOI 10.17487/RFC2119, March 1997,\n\
    \              <http://www.rfc-editor.org/info/rfc2119>.\n   [RFC2460]  Deering,\
    \ S. and R. Hinden, \"Internet Protocol, Version 6\n              (IPv6) Specification\"\
    , RFC 2460, DOI 10.17487/RFC2460,\n              December 1998, <http://www.rfc-editor.org/info/rfc2460>.\n\
    \   [RFC4086]  Eastlake 3rd, D., Schiller, J., and S. Crocker,\n             \
    \ \"Randomness Requirements for Security\", BCP 106, RFC 4086,\n             \
    \ DOI 10.17487/RFC4086, June 2005,\n              <http://www.rfc-editor.org/info/rfc4086>.\n\
    \   [RFC4861]  Narten, T., Nordmark, E., Simpson, W., and H. Soliman,\n      \
    \        \"Neighbor Discovery for IP version 6 (IPv6)\", RFC 4861,\n         \
    \     DOI 10.17487/RFC4861, September 2007,\n              <http://www.rfc-editor.org/info/rfc4861>.\n\
    \   [RFC5722]  Krishnan, S., \"Handling of Overlapping IPv6 Fragments\",\n   \
    \           RFC 5722, DOI 10.17487/RFC5722, December 2009,\n              <http://www.rfc-editor.org/info/rfc5722>.\n\
    \   [RFC6052]  Bao, C., Huitema, C., Bagnulo, M., Boucadair, M., and X.\n    \
    \          Li, \"IPv6 Addressing of IPv4/IPv6 Translators\", RFC 6052,\n     \
    \         DOI 10.17487/RFC6052, October 2010,\n              <http://www.rfc-editor.org/info/rfc6052>.\n\
    \   [RFC6056]  Larsen, M. and F. Gont, \"Recommendations for Transport-\n    \
    \          Protocol Port Randomization\", BCP 156, RFC 6056,\n              DOI\
    \ 10.17487/RFC6056, January 2011,\n              <http://www.rfc-editor.org/info/rfc6056>.\n\
    \   [RFC6145]  Li, X., Bao, C., and F. Baker, \"IP/ICMP Translation\n        \
    \      Algorithm\", RFC 6145, DOI 10.17487/RFC6145, April 2011,\n            \
    \  <http://www.rfc-editor.org/info/rfc6145>.\n   [RFC6946]  Gont, F., \"Processing\
    \ of IPv6 \"Atomic\" Fragments\",\n              RFC 6946, DOI 10.17487/RFC6946,\
    \ May 2013,\n              <http://www.rfc-editor.org/info/rfc6946>.\n"
- title: 7.2.  Informative References
  contents:
  - "7.2.  Informative References\n   [RFC4963]  Heffner, J., Mathis, M., and B. Chandler,\
    \ \"IPv4 Reassembly\n              Errors at High Data Rates\", RFC 4963,\n  \
    \            DOI 10.17487/RFC4963, July 2007,\n              <http://www.rfc-editor.org/info/rfc4963>.\n\
    \   [RFC5927]  Gont, F., \"ICMP Attacks against TCP\", RFC 5927,\n           \
    \   DOI 10.17487/RFC5927, July 2010,\n              <http://www.rfc-editor.org/info/rfc5927>.\n\
    \   [RFC6274]  Gont, F., \"Security Assessment of the Internet Protocol\n    \
    \          Version 4\", RFC 6274, DOI 10.17487/RFC6274, July 2011,\n         \
    \     <http://www.rfc-editor.org/info/rfc6274>.\n   [DEPGEN]   Gont, F., Liu,\
    \ S., and T. Anderson, \"Generation of IPv6\n              Atomic Fragments Considered\
    \ Harmful\", Work in Progress,\n              draft-ietf-6man-deprecate-atomfrag-generation-05,\
    \ January\n              2016.\n   [Bellovin2002]\n              Bellovin, S.,\
    \ \"A Technique for Counting NATted Hosts\",\n              IMW'02 Nov. 6-8, 2002,\
    \ Marseille, France,\n              DOI 10.1145/637201.637243, 2002.\n   [Fyodor2004]\n\
    \              Lyon, G., \"TCP Idle Scan\", from Chapter 5 of \"Nmap Network\n\
    \              Scanning\", 2004,\n              <http://www.insecure.org/nmap/idlescan.html>.\n\
    \   [Herzberg2013]\n              Herzberg, A. and H. Shulman, \"Fragmentation\
    \ Considered\n              Poisonous\", Technical Report 13-03, March 2013,\n\
    \              <http://u.cs.biu.ac.il/~herzbea/security/13-03-frag.pdf>.\n   [Klein2007]\n\
    \              Klein, A., \"OpenBSD DNS Cache Poisoning and Multiple O/S\n   \
    \           Predictable IP ID Vulnerability\", 2007,\n              <http://www.trusteer.com/files/OpenBSD_DNS_Cache_Poisoning\n\
    \              _and_Multiple_OS_Predictable_IP_ID_Vulnerability.pdf>.\n   [Sanfilippo1998a]\n\
    \              Sanfilippo, S., \"Subject: about the ip header id\", message\n\
    \              to Bugtraq mailing list, 14 December 1998,\n              <http://diswww.mit.edu/menelaus.mit.edu/bt/8704>.\n\
    \   [Sanfilippo1998b]\n              Sanfilippo, S., \"Subject: new tcp scan method\"\
    , message\n              to Bugtraq mailing list, 18 December 1998,\n        \
    \      <http://diswww.mit.edu/menelaus.mit.edu/bt/8736>.\n   [Sanfilippo1999]\n\
    \              Sanfilippo, S., \"Subject: more about IP ID\", message\n      \
    \        to Bugtraq mailing list, 20 November 1999,\n              <http://diswww.mit.edu/menelaus.mit.edu/bt/12686>.\n\
    \   [SI6-IPv6] SI6 Networks, \"SI6 Networks' IPv6 Toolkit\",\n              <http://www.si6networks.com/tools/ipv6toolkit>.\n\
    \   [Zalewski2003]\n              Zalewski, M., \"Subject: A new TCP/IP blind\
    \ data injection\n              technique?\", message to Bugtraq mailing list,\
    \ 11 December\n              2003, <http://lcamtuf.coredump.cx/ipfrag.txt>.\n"
- title: Appendix A.  Information Leakage Produced by Vulnerable Implementations
  contents:
  - "Appendix A.  Information Leakage Produced by Vulnerable Implementations\n   Section\
    \ 3 provides a number of references describing a number of ways\n   in which a\
    \ vulnerable implementation may reveal the Identification\n   values to be used\
    \ in subsequent packets, thus opening the door to a\n   number of attacks.  In\
    \ all of those scenarios, a vulnerable\n   implementation leaks/reveals its own\
    \ Identification number.\n   This section presents a different attack scenario,\
    \ in which a\n   vulnerable implementation leaks/reveals the Identification number\
    \ of\n   a non-vulnerable implementation.  That is, a vulnerable\n   implementation\
    \ (Host A) leaks the current Identification value in use\n   by a third-party\
    \ host (Host B) to send fragmented datagrams from Host\n   B to Host A.\n   NOTE:\n\
    \      For the most part, this section is included to illustrate how a\n     \
    \ vulnerable implementation might be leveraged to leak out the\n      Identification\
    \ value of an otherwise non-vulnerable\n      implementation.\n   The following\
    \ scenarios assume:\n   Host A:\n      An IPv6 host that implements the algorithm\
    \ specified in\n      Section 5.1, implements [RFC5722], but does not implement\n\
    \      [RFC6946].\n   Host B:\n      Victim node.  Selects the Identification\
    \ values from a global\n      counter.\n   Host C:\n      Attacker.  Can forge\
    \ the IPv6 Source Address of his packets at\n      will.\n   In the following\
    \ scenarios, large ICMPv6 Echo Request packets are\n   employed to \"sample\"\
    \ the Identification value of a host.  We note\n   that while the figures show\
    \ only one packet for the ICMPv6 Echo\n   Request and the ICMPv6 Echo Reply packets,\
    \ each of those packets will\n   typically comprise two fragments, such that the\
    \ corresponding\n   unfragmented datagram is larger than the MTU of the networks\
    \ to which\n   Host B and Host C are attached.  Additionally, the following\n\
    \   scenarios assume that Host A employs a Fragment Header when sending\n   traffic\
    \ to Host B (typically the so-called \"IPv6 atomic fragments\"\n   [RFC6946]):\
    \ this behavior may be triggered by forged ICMPv6 PTB\n   messages that advertise\
    \ an MTU smaller than 1280 bytes (assuming the\n   victim still generates atomic\
    \ fragments [DEPGEN]).\n   In lines #1-#2 (and lines #7-#8), the attacker samples\
    \ the current\n   Identification value at Host B.  In line #3, the attacker sends\
    \ a\n   forged TCP SYN segment to Host A.  In line 4, the attacker sends a\n \
    \  forged TCP segment to Host B as an incomplete IPv6 fragmented\n   datagram\
    \ (e.g., a single fragment with Fragment Offset=0, More\n   fragments=1).  If\
    \ corresponding TCP port is closed, and the attacker\n   fails when trying to\
    \ produce a collision of Identification values\n   (see line #4), the following\
    \ packet exchange might take place:\n       A                          B     \
    \                         C\n   #1                              <------ Echo Req\
    \ #1 -----------\n   #2                              --- Echo Repl #1, FID=5000\
    \ --->\n   #3  <------------------- SYN #1, src= B -----------------------\n \
    \  #4                              <--- SYN/ACK, FID=42 src=A ----\n   #5  ----\
    \ SYN/ACK, FID=9000 --->\n   #6  <----- RST, FID= 5001 -----\n   #7          \
    \                    <-------- Echo Req #2 ---------\n   #8                  \
    \            --- Echo Repl #2, FID=5002 --->\n   The RST segment in line #6 is\
    \ elicited by the SYN/ACK segment from\n   line #5 (illegitimately elicited by\
    \ the SYN segment from line #3).\n   The packet from line #4, sent as an incomplete\
    \ IPv6 datagram,\n   eventually times out.\n   On the other hand, if the attacker\
    \ succeeds to produce a collision of\n   Identification values, the following\
    \ packet exchange could take\n   place:\n       A                          B \
    \                             C\n   #1                              <------- Echo\
    \ Req #1 ----------\n   #2                              --- Echo Repl #1, FID=5000\
    \ --->\n   #3  <------------------- SYN #1, src= B -----------------------\n \
    \  #4                              <-- SYN/ACK, FID=9000 src=A ---\n   #5  ----\
    \ SYN/ACK, FID=9000 --->\n                           ... (RFC5722) ...\n   #6\
    \                              <------- Echo Req #2 ----------\n   #7        \
    \                      ---- Echo Repl #2, FID=5001 -->\n   Clearly, the Identification\
    \ value sampled from the second ICMPv6 Echo\n   Reply packet (\"Echo Repl #2\"\
    ) implicitly indicates whether the\n   Identification value in the forged SYN/ACK\
    \ (see line #4 in both\n   figures) was the current Identification value in use\
    \ by Host A.\n   As a result, the attacker could employ this technique to learn\
    \ the\n   current Identification value used by host A to send packets to host\n\
    \   B, even when Host A itself has a non-vulnerable implementation.\n"
- title: Appendix B.  Survey of Fragment Identification Selection Algorithms
  contents:
  - "Appendix B.  Survey of Fragment Identification Selection Algorithms\n       \
    \      Employed by Popular IPv6 Implementations\n   This section includes a survey\
    \ of the Identification selection\n   algorithms employed by some popular operating\
    \ systems.\n   NOTE:\n      The survey was produced with the SI6 Networks' IPv6\
    \ toolkit\n      [SI6-IPv6].\n   +------------------------------+------------------------------------+\n\
    \   |       Operating System       |             Algorithm              |\n  \
    \ +------------------------------+------------------------------------+\n   |\
    \        Cisco IOS 15.3        |    Predictable (Global Counter,    |\n   |  \
    \                            |          Init=0, Incr=1)           |\n   +------------------------------+------------------------------------+\n\
    \   |         FreeBSD 9.0          |       Unpredictable (Random)       |\n  \
    \ +------------------------------+------------------------------------+\n   |\
    \        Linux 3.0.0-15        |    Predictable (Global Counter,    |\n   |  \
    \                            |          Init=0, Incr=1)           |\n   +------------------------------+------------------------------------+\n\
    \   |        Linux-current         |  Unpredictable (Per-dest Counter,  |\n  \
    \ |                              |        Init=random, Incr=1)        |\n   +------------------------------+------------------------------------+\n\
    \   |          NetBSD 5.1          |       Unpredictable (Random)       |\n  \
    \ +------------------------------+------------------------------------+\n   |\
    \       OpenBSD-current        |   Unpredictable (Random, SKIP32)   |\n   +------------------------------+------------------------------------+\n\
    \   |          Solaris 10          |   Predictable (Per-dst Counter,    |\n  \
    \ |                              |          Init=0, Incr=1)           |\n   +------------------------------+------------------------------------+\n\
    \   |        Windows XP SP2        |    Predictable (Global Counter,    |\n  \
    \ |                              |          Init=0, Incr=2)           |\n   +------------------------------+------------------------------------+\n\
    \   |   Windows XP Professional    |    Predictable (Global Counter,    |\n  \
    \ |          32bit, SP3          |          Init=0, Incr=2)           |\n   +------------------------------+------------------------------------+\n\
    \   |  Windows Vista (Build 6000)  |    Predictable (Global Counter,    |\n  \
    \ |                              |          Init=0, Incr=2)           |\n   +------------------------------+------------------------------------+\n\
    \   |    Windows Vista Business    |    Predictable (Global Counter,    |\n  \
    \ |          64bit, SP1          |          Init=0, Incr=2)           |\n   +------------------------------+------------------------------------+\n\
    \   |    Windows 7 Home Premium    |    Predictable (Global Counter,    |\n  \
    \ |                              |          Init=0, Incr=2)           |\n   +------------------------------+------------------------------------+\n\
    \   |    Windows Server 2003 R2    |    Predictable (Global Counter,    |\n  \
    \ |     Standard 64bit, SP2      |          Init=0, Incr=2)           |\n   +------------------------------+------------------------------------+\n\
    \   | Windows Server 2008 Standard |    Predictable (Global Counter,    |\n  \
    \ |          32bit, SP1          |          Init=0, Incr=2)           |\n   +------------------------------+------------------------------------+\n\
    \   |    Windows Server 2008 R2    |    Predictable (Global Counter,    |\n  \
    \ |     Standard 64bit, SP1      |          Init=0, Incr=2)           |\n   +------------------------------+------------------------------------+\n\
    \   | Windows Server 2012 Standard |    Predictable (Global Counter,    |\n  \
    \ |            64bit             |          Init=0, Incr=2)           |\n   +------------------------------+------------------------------------+\n\
    \   |    Windows 7 Home Premium    |    Predictable (Global Counter,    |\n  \
    \ |          32bit, SP1          |          Init=0, Incr=2)           |\n   +------------------------------+------------------------------------+\n\
    \   |  Windows 7 Ultimate 32bit,   |    Predictable (Global Counter,    |\n  \
    \ |             SP1              |          Init=0, Incr=2)           |\n   +------------------------------+------------------------------------+\n\
    \   | Windows 8 Enterprise 32 bit  |  Unpredictable (Alg. from Section  |\n  \
    \ |                              |                5.3)                |\n   +------------------------------+------------------------------------+\n\
    \   Table 1: Fragment Identification algorithms employed by different OSs\n  \
    \ NOTE:\n      In the text above, \"predictable\" should be taken as \"easily\n\
    \      guessable by an off-path attacker, by sending a few probe\n      packets\"\
    .\n"
- title: Acknowledgements
  contents:
  - "Acknowledgements\n   The author would like to thank Ivan Arce for proposing the\
    \ attack\n   scenario described in Appendix A.\n   The author would like to thank\
    \ Ivan Arce, Stephen Bensley, Ron\n   Bonica, Tassos Chatzithomaoglou, Guillermo\
    \ Gont, Brian Haberman, Bob\n   Hinden, Sheng Jiang, Tatuya Jinmei, Merike Kaeo,\
    \ Will Liu, Juan\n   Antonio Matos, Simon Perreault, Hosnieh Rafiee, Meral Shirazipour,\n\
    \   Mark Smith, Dave Thaler, and Klaas Wierenga, for providing valuable\n   comments\
    \ on earlier draft versions of this document.\n   This document is based on work\
    \ performed by Fernando Gont on behalf\n   of the UK Centre for the Protection\
    \ of National Infrastructure\n   (CPNI).\n   The author would like to thank Buffy\
    \ for her love and support.\n"
- title: Author's Address
  contents:
  - "Author's Address\n   Fernando Gont\n   Huawei Technologies\n   Evaristo Carriego\
    \ 2644\n   Haedo, Provincia de Buenos Aires  1706\n   Argentina\n   Phone: +54\
    \ 11 4650 8472\n   Email: fgont@si6networks.com\n   URI:   http://www.si6networks.com\n"
