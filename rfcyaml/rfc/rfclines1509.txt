Abstract This document specifies C language bindings for the Generic Security Service Application Program Interface (GSS API), which is described at a language independent conceptual level in other documents.
The Generic Security Service Application Programming Interface (GSS  API) provides security services to its callers, and is intended for implementation atop alternative underlying cryptographic mechanisms.
Typically, GSS API callers will be application protocols into which security enhancements are integrated through invocation of services provided by the GSS API.
The GSS API allows a caller application to authenticate a principal identity associated with a peer application, to delegate rights to a peer, and to apply security services such as confidentiality and integrity on a per message basis.
1. INTRODUCTION The Generic Security Service Application Programming Interface [1] provides security services to calling applications.
It allows a communicating application to authenticate the user associated with another application, to delegate rights to another application, and to apply security services such as confidentiality and integrity on a per message basis.
There are four stages to using the GSSAPI: (a)
The application acquires a set of credentials with which it may prove its identity to other processes.
The application's credentials vouch for its global identity, which may or may not be related to the local username under which it is running.
A pair of communicating applications establish a joint security context using their credentials.
The security context is a pair of GSSAPI data structures that contain shared state information, which is required in order that per message security services may be provided.
As part of the establishment of a security context, the context initiator is authenticated to the responder, and may require that the responder is authenticated in turn.
The initiator may optionally give the responder the right to initiate further security contexts.
This transfer of rights is termed delegation, and is achieved by creating a set of credentials, similar to those used by the originating application, but which may be used by the responder.
To establish and maintain the shared information that makes up the security context, certain GSSAPI calls will return a token data structure, which is a cryptographically protected opaque data type.
The caller of such a GSSAPI routine is responsible for transferring the token to the peer application, which should then pass it to a corresponding GSSAPI routine which will decode it and extract the information.
(c) Per message services are invoked to apply either:
(i) integrity and data origin authentication, or (ii) confidentiality, integrity and data origin authentication to application data, which are treated by GSSAPI as arbitrary octet strings.
The application transmitting a message that it wishes to protect will call the appropriate GSSAPI routine (sign or seal) to apply protection, specifying the appropriate security context, and send the result to the receiving application.
The receiver will pass the received data to the corresponding decoding routine (verify or unseal) to remove the protection and validate the data.
At the completion of a communications session (which may extend across several connections), the peer applications call GSSAPI routines to delete the security context.
Multiple contexts may also be used (either successively or simultaneously) within a single communications association.
This section lists the functions performed by each of the GSSAPI routines and discusses their major parameters, describing how they are to be passed to the routines.
The routines are listed in figure 4 1.
a global identity gss release cred
a security context gss context time
Determine for how long a context will remain
Convert a textual name to internal form gss release name
Applications are encouraged to use the generic routines wherever possible on portability grounds.
Data Types and Calling Conventions
The following conventions are used by the GSSAPI:
Wherever these GSSAPI C bindings describe structured data, only fields that must be provided by all GSSAPI implementation are documented.
Individual implementations may provide additional fields, either for internal use within GSSAPI routines, or for use by non portable applications.
Integer types GSSAPI defines the following integer data type:
Individual GSSAPI implementations will include appropriate typedef definitions to map this type onto a built in data type.
Many of the GSSAPI routines take arguments and return values that describe contiguous multiple byte data.
All such data is passed between the GSSAPI and the caller using the gss buffer t data type.
This data type is a pointer to a buffer descriptor, which consists of a length field that contains the total number of bytes in the datum, and a value field which contains a pointer to the actual datum:
; Storage for data passed to the application by a GSSAPI routine using the gss buffer t conventions is allocated by the GSSAPI routine.
The application may free this storage by invoking the gss release buffer routine.
Allocation of the gss buffer desc object is always the responsibility of the application;  Unused gss buffer desc objects may be initialized to the value GSS C EMPTY BUFFER.
Certain multiple word data items are considered opaque data types at the GSSAPI, because their internal structure has no significance either to the GSSAPI or to the caller.
Examples of such opaque data types are the input token parameter to gss init sec context (which is opaque to the caller), and the input message parameter to gss seal (which is opaque to the GSSAPI).
Opaque data is passed between the GSSAPI and the application using the gss buffer t datatype.
Certain multiple word data items may be regarded as simple ISO Latin 1 character strings.
An example of this is the input name buffer parameter to gss import name.
Some GSSAPI routines also return character strings.
Character strings are passed between the application and the GSSAPI using the gss buffer t datatype, defined earlier.
Certain GSSAPI procedures take parameters of the type gss OID, or Object identifier.
This is a type containing
ISO defined tree  structured values, and is used by the GSSAPI caller to select an underlying security mechanism.
A value of type gss OID has the following structure: typedef struct gss OID desc struct { OM uint32 length;
The length field contains the number of bytes in this value.
For example, the  gss OID value corresponding to {iso(1) identified  oganization(3)
} meaning SPX (Digital's X.509 authentication mechanism) has a length field of 7 and an elements field pointing to seven octets containing the following octal values: 53,14,2,207,163,7,5.
GSSAPI implementations should provide constant gss OID values to allow callers to request any supported mechanism, although applications are encouraged on portability grounds to accept the default mechanism.
gss OID values should also be provided to allow applications to specify particular name types (see section 2.1.10).
Applications should treat gss OID desc values returned by GSSAPI routines as read only.
In particular, the application should not attempt to deallocate them.
The gss OID desc datatype is equivalent to the X/Open OM object identifier datatype [2].
Object Identifier Sets Certain GSSAPI procedures take parameters of the type gss OID set.
This type represents one or more object identifiers (section 2.1.4).
The elements field is a pointer to an array of gss OID desc objects, each of which describes a single OID.
gss OID set values are used to name the available mechanisms supported by the GSSAPI, to request the use of specific mechanisms, and to indicate which mechanisms a given credential supports.
Storage associated with gss OID set values returned to the application by the GSSAPI
may be deallocated by the gss release oid set routine.
Credentials A credential handle is a caller opaque atomic datum that identifies a GSSAPI credential data structure.
It is represented by the caller
opaque type gss cred id t, which may be implemented as either an arithmetic or a pointer type.
Credentials describe a principal, and they give their holder the ability to act as that principal.
The GSSAPI does not make the actual credentials available to applications; instead the credential handle is used to identify a particular credential, held internally by GSSAPI or underlying mechanism.
Thus the credential handle contains no security relavent information, and requires no special protection by the application.
Depending on the implementation, a given credential handle may refer to different credentials when presented to the GSSAPI by different callers.
Individual GSSAPI implementations should define both the scope of a credential handle and the scope of a credential itself (which must be at least as wide as that of a handle).
Possibilities for credential handle scope include the process that acquired the handle, the acquiring process and its children, or all processes sharing some local identification information (e.g., UID).
If no handles exist by which a given credential may be reached, the GSSAPI may delete the credential.
Certain routines allow credential handle parameters to be omitted to indicate the use of a default credential.
The mechanism by which a default credential is established and its scope should be defined by the individual GSSAPI implementation.
t data type contains a caller opaque atomic value that identifies one end of a GSSAPI security context.
It may be implemented as either an arithmetic or a pointer type.
Depending on the implementation, a given gss ctx
d t value may refer to different GSSAPI security contexts when presented to the GSSAPI by different callers.
The security context holds state information about each end of a peer communication, including cryptographic state information.
Individual GSSAPI implementations should define the scope of a context.
Since no way is provided by which a new gss ctx id t value may be obtained for an existing context, the scope of a context should be the same as the scope of a gss ctx
A token is a caller opaque type that GSSAPI uses to maintain synchronization between the context data structures at each end of a GSSAPI security context.
The token is a cryptographically protected bit string, generated by the underlying mechanism at one end of a GSSAPI security context for use by the peer mechanism at the other end.
Encapsulation (if required) and transfer of the token are the responsibility of the peer applications.
A token is passed between the GSSAPI and the application using the gss buffer t conventions.
One or more status codes are returned by each GSSAPI routine.
Two distinct sorts of status codes are returned.
These are termed GSS status codes and Mechanism status codes.
GSS status codes GSSAPI routines return GSS status codes as their OM uint32 function value.
These codes indicate errors that are independent of the underlying mechanism used to provide the security service.
The errors that can be indicated via a GSS status code are either generic API routine errors (errors that are defined in the GSSAPI specification) or calling errors (errors that are specific to these bindings).
A GSS status code can indicate a single fatal generic API error from the routine and a single calling error.
In addition, supplementary status information may be indicated via the setting of bits in the supplementary info field of a GSS status code.
These errors are encoded into the 32 bit GSS status code as follows:
Hence if a GSSAPI routine returns a GSS status code whose upper 16 bits contain a non zero value, the call failed.
If the calling error field is non zero, the invoking application's call of the routine was erroneous.
Calling errors are defined in table 5 1.
If the routine error field is non zero,
the routine failed for one of the routine  specific reasons listed below in table 5 2.
Whether or not the upper 16 bits indicate a failure or a success, the routine may indicate additional information by setting bits in the supplementary info field of the status code.
The meaning of individual bits is listed below in table 5 3.
GSS S CALL INACCESSIBLE WRITE
A supplied name was of an unsupported type GSS S BAD BINDINGS
A token had an invalid signature GSS S
No credentials were supplied GSS S
A token was invalid GSS S DEFECTIVE CREDENTIAL 10
A credential was invalid GSS S CREDENTIALS EXPIRED
The referenced credentials have expired
The routine must be called again to complete its function.
See routine documentation for detailed description.
has expired GSS S UNSEQ
A later token has already been processed The routine documentation also uses the name GSS S COMPLETE, which is a zero value, to indicate an absence of any API errors or supplementary information bits.
All GSS S xxx symbols equate to complete OM uint32 status codes, rather than to bitfield values.
For example, the actual value of the symbol GSS S BAD NAMETYPE (value 3 in the routine error field) is 3 << 16.
The macros GSS CALLING ERROR(), GSS ROUTINE ERROR() and GSS SUPPLEMENTARY INFO() are provided, each of which takes a GSS status code and removes all but the relevant field.
For example, the value obtained by applying GSS ROUTINE ERROR to a status code removes the calling errors and supplementary info fields, leaving only the routine errors field.
The values delivered by these macros may be directly compared with a GSS S xxx symbol of the appropriate type.
The macro GSS ERROR() is also provided, which when applied to a GSS status code returns a non zero value if the status code indicated a calling or routine error, and a zero value otherwise.
A GSSAPI implementation may choose to signal calling errors in a platform specific manner instead of, or in addition to the routine value; routine errors and supplementary info should be returned via routine status values only.
Mechanism specific status codes GSSAPI routines return a minor status parameter, which is used to indicate specialized errors from the underlying security mechanism.
This parameter may contain a single mechanism specific error, indicated by a OM uint32 value.
The minor status parameter will always be set by a GSSAPI routine, even if it returns a calling error or one of the generic API errors indicated above as fatal, although other output parameters may remain unset in such cases.
However, output parameters that are expected to return pointers to storage allocated by a routine must always set set by the routine, even in the event of an error, although in such cases the GSSAPI routine may elect to set the returned parameter value to NULL to indicate that no storage was actually allocated.
Any length field associated with such pointers (as in a gss buffer desc structure) should also be set to zero in such cases.
The GSS status code GSS S FAILURE is used to indicate that the underlying mechanism detected an error for which no specific GSS status code is defined.
The mechanism status code will provide more details about the error.
A name is used to identify a person or entity.
GSSAPI authenticates the relationship between a name and the entity claiming the name.
Two distinct representations are defined for names: (a)
A printable form, for presentation to a user (b) An internal form, for presentation at the API
The syntax of a printable name is defined by the GSSAPI implementation, and may be dependent on local system configuration, or on individual user preference.
The internal form provides a canonical representation of the name that is independent of configuration.
A given GSSAPI implementation may support names drawn from multiple namespaces.
In such an implementation, the internal form of the name must include fields that identify the namespace from which the name is drawn.
The namespace from which a printable name is drawn is specified by an accompanying object identifier.
Routines (gss import name and  gss display name) are provided to convert names between their printable representations and the gss name t type.
gss import name may support multiple syntaxes for each supported namespace, allowing users the freedom to choose a preferred name representation.
gss display name should use an implementation chosen preferred syntax for each supported name type.
Comparison of internal form names is accomplished via the gss
This removes the need for the application program to understand the syntaxes of the various printable names that a given GSSAPI implementation may support.
Storage is allocated by routines that return gss name t values.
A procedure, gss release name, is provided to free storage associated with a name.
Channel Bindings GSSAPI supports the use of user specified tags to identify a given context to the peer application.
These tags are used to identify the particular communications channel that carries the context.
Channel bindings are communicated to the GSSAPI using the following structure:
The address type should be one of the following:
XEROX NS address type GSS C AF
IBM SNA address type GSS C AF DECnet
GSS C AF APPLETALK   AppleTalk
address type GSS C AF
No address specified Note that these name address families rather than specific addressing formats.
For address families that contain several alternative address forms, the initiator address and acceptor address fields must contain sufficient information to determine which address form is used.
When not otherwise specified, addresses should be specified in network byte order.
Conceptually, the GSSAPI concatenates the initiator addrtype, initiator address, acceptor addrtype, acceptor address and application data to form an octet string.
The mechanism signs this octet string, and binds the signature to the context establishment token emitted by gss init sec context.
The same bindings are presented by the context acceptor to gss accept sec context, and a signature is calculated in the same way.
The calculated signature is compared with that found in the token, and if the signatures differ, gss accept sec context will return a GSS S BAD BINDINGS error, and the context will not be established.
Some mechanisms may include the actual channel binding data in the token (rather than just a signature); applications should therefore not use confidential data as channel binding components.
Individual mechanisms may impose additional constraints on addresses and address types that may appear in channel bindings.
For example, a mechanism may verify that the initiator address field of the channel bindings presented to gss init sec context contains the correct network address of the host system.
Optional parameters Various parameters are described as optional.
This means that they follow a convention whereby a default value may be requested.
The following conventions are used for omitted parameters.
These conventions apply only to those parameters that are explicitly documented as optional.
gss buffer t types Specify GSS C NO BUFFER as a value.
For an input parameter this signifies that default behavior is requested, while for an output parameter it indicates that the information that would be returned via the parameter is not required by the application.
Individual parameter documentation lists values to be used to indicate default actions.
Integer types (output) Specify NULL as the value for the pointer.
Pointer types Specify NULL as the value.
Object IDs Specify GSS C NULL OID as the value.
Object ID Sets Specify GSS C NULL OID SET as the value.
Credentials Specify GSS C NO CREDENTIAL to use the default credential handle.
GSS C NO CHANNEL BINDINGS to indicate that channel bindings are not to be used.
gss acquire cred OM uint32
: Allows an application to acquire a handle for a pre existing credential by name.
GSSAPI implementations must impose a local access control policy on callers of this routine to prevent unauthorized callers from acquiring credentials to which they are not entitled.
This routine is not intended to provide a "login to the network" function, as such a function would result in the creation of new credentials rather than merely acquiring a handle to existing credentials.
Such functions, if required, should be defined in implementation specific extensions to the API.
If credential acquisition is time consuming for a mechanism, the mechanism may chooses to delay the actual acquisition until the credential is required (e.g., by gss init sec context or gss accept sec context).
Such mechanism specific implementation decisions should be invisible to the calling application; thus a call of gss inquire cred immediately following the call of gss acquire cred must return valid credential data, and may therefore incur the overhead of a deferred credential acquisition.
GSS C NULL OID SET may be used to obtain an implementation specific default.
BOTH Credentials may be used either to initiate or accept security contexts.
GSS C INITIATE Credentials will only be used to initiate security contexts.
GSS C ACCEPT Credentials will only be used to accept security contexts.
gss cred id t, modify The returned credential handle.
The set of mechanisms for which the credential is valid.
Specify NULL if not required.
If the implementation does not support expiration of credentials, the value GSS C INDEFINITE will be returned.
Successful completion GSS S BAD MECH    Unavailable mechanism requested
GSS S BAD NAMETYPE Type contained within desired name parameter is not supported
GSS S BAD NAME    Value supplied for desired name parameter is ill formed.
The minor status parameter contains more detailed information 3.2.
gss release cred OM uint32
Informs GSSAPI that the specified credential handle is no longer required by the process.
When all processes have released a credential, it will be deleted.
id t, modify, optional buffer containing opaque credential handle.
Credentials could not be accessed.
gss init sec context OM uint32
claimant cred handle, gss ctx i
: Initiates the establishment of a security context between the application and a remote peer.
Initially, the input token parameter should be specified as GSS C NO BUFFER.
The routine may return a output token which should be transferred to the peer application, where the peer application will present it to gss accept sec context.
If no token need be sent, gss init sec context will indicate this by setting the length field of the output token argument to zero.
To complete the context establishment, one or more reply tokens may be required from the peer application; if so, gss init sec context will return a status indicating GSS S CONTINUE NEEDED in which case it should be called again when the reply token is received from the peer application, passing the token to gss init sec context via the input token parameters.
The values returned via the ret flags and time rec parameters are not defined unless the routine returns GSS S COMPLETE.
gss cred id t, read, optional handle for credentials claimed.
Supply GSS C NO CREDENTIAL to use default credentials.
t, read/modify context handle for new context.
NO CONTEXT for first call;
use value returned by first call in continuation calls.
Symbolic names are provided for each flag, and the symbolic names corresponding to the required flags should be logically ORed together to form the bit mask value.
The flags are: GSS C DELEG FLAG True Delegate credentials to remote peer False
Don't delegate GSS C MUTUAL FLAG True Request that remote peer authenticate itself False Authenticate self to remote peer
only GSS C REPLAY FLAG
True Enable replay detection for signed or sealed messages False Don't attempt to detect replayed messages GSS C SEQUENCE FLAG
True Enable detection of out of sequence signed or sealed messages False
Supply 0 to request a default validity period.
Allows application to securely bind channel identification information to the security context.
Token received from peer application.
NO BUFFER on initial call.
actual mech type  OID, modify actual mechanism used.
If the length field of the returned buffer is zero, no token need be sent to the peer application.
modify Contains six independent flags, each of which indicates that the context supports a specific service option.
Symbolic names are provided for each flag, and the symbolic names corresponding to the required flags should be logically ANDed with the ret flags value to test whether a given option is supported by the context.
The flags are: GSS C DELEG FLAG True Credentials were delegated to the remote peer False
No credentials were delegated GSS C MUTUAL FLAG
True Remote peer has been asked to authenticated itself False Remote peer has not been asked to authenticate itself GSS C REPLAY FLAG True replay of signed or sealed messages will be detected False
replayed messages will not be detected GSS C SEQUENCE FLAG True out of sequence
signed or sealed messages will be detected False out of sequence messages will not be detected GSS C CONF FLAG True Confidentiality service may be invoked by calling seal routine False No confidentiality service (via seal) available.
seal will provide message encapsulation, data origin authentication and integrity services only.
True Integrity service may be invoked by calling either gss sign or gss seal routines.
False Per message integrity service unavailable.
If the implementation does not support credential expiration, the value GSS C INDEFINITE will be returned.
Specify NULL if not required.
NEEDED Indicates that a token from the peer application is required to complete thecontext, and that gss init sec context must be called again with that token.
GSS S DEFECTIVE TOKEN Indicates that consistency checks performed on the input token failed GSS S DEFECTIVE CREDENTIAL
Indicates that consistency checks performed on the credential failed.
The supplied credentials were not valid for context initiation, or the credential handle did not reference any credentials.
GSS S CREDENTIALS EXPIRED The referenced credentials have expired GSS S BAD BINDINGS
The input token contains different channel bindings to those specified via the input chan bindings parameter GSS S BAD SIG
The input token contains an invalid signature, or a signature that could not be verified GSS S OLD TOKEN
The input token was too old.
This is a fatal error during context establishment GSS S DUPLICATE TOKEN
The input token is valid, but is a duplicate of a token already processed.
This is a fatal error during context establishment.
Indicates that the supplied context handle did not refer to a valid context GSS S BAD NAMETYPE
The provided target name parameter contained an invalid or unsupported type of name GSS S BAD NAME
The provided target name parameter was ill formed.
See minor status for more information 3.4.
gss accept sec context OM uint32
: Allows a remotely initiated security context between the application and a remote peer to be established.
The routine may return a output token which should be transferred to the peer application, where the peer application will present it to gss init sec context.
If no token need be sent, gss accept sec context will indicate this by setting the length field of the output token argument to zero.
To complete the context establishment, one or more reply tokens may be required from the peer application; if so, gss accept sec context will return a status flag of GSS S CONTINUE NEEDED, in which case it should be called again when the reply token is received from the peer application, passing the token to gss accept sec context via the input token parameters.
The values returned via the src name, ret flags, time rec, and delegated cred handle parameters are not defined unless the routine returns GSS S COMPLETE.
Parameters: context handle    gss ctx
t, read/modify context handle for new context.
NO CONTEXT for first call;
use value returned in subsequent calls.
gss cred id t, read, optional Credential handle claimed by context acceptor.
C NO CREDENTIAL to use default credentials.
If GSS C NO CREDENTIAL is specified, but the caller has no default credentials established, an implementation defined default credential may be used.
Allows application to securely bind channel identification information to the security context.
After use, this name should be deallocated by passing it to gss release name.
If not required, specify NULL.
The returned OID value will be a pointer into static storage, and should be treated as read only by the caller.
modify Token to be passed to peer application.
If the length field of the returned token buffer is 0, then no token need be passed to the peer application.
modify Contains six independent flags, each of which indicates that the context supports a specific service option.
Symbolic names are provided for each flag, and the symbolic names corresponding to the required flags should be logically ANDed with the ret flags value to test whether a given option is supported by the context.
The flags are: GSS C DELEG FLAG
True Delegated credentials are available via the delegated cred handle parameter False
No credentials were delegated GSS C MUTUAL FLAG
True Remote peer asked for mutual authentication False Remote peer did not ask for mutual authentication GSS C REPLAY FLAG True replay of signed or sealed messages will be detected False replayed messages will not be detected GSS C SEQUENCE FLAG True out of sequence signed or sealed messages will be detected False out of sequence messages will not be detected GSS C CONF FLAG True Confidentiality service may be invoked by calling seal routine False No confidentiality service (via seal) available.
seal will provide message encapsulation, data origin authentication and integrity services only.
True Integrity service may be invoked by calling either gss sign or gss seal routines.
False Per message integrity service unavailable.
delegated cred handle gss cred
t, modify credential handle for credentials received from context initiator.
Only valid if deleg flag in ret flags is true.
NEEDED Indicates that a token from the peer application is required to complete the context, and that gss accept sec context must be called again with that token.
GSS S DEFECTIVE TOKEN Indicates that consistency checks performed on the input token failed.
GSS S DEFECTIVE CREDENTIAL Indicates that consistency checks performed on the credential failed.
The supplied credentials were not valid for context acceptance, or the credential handle did not reference any credentials.
GSS S CREDENTIALS EXPIRED The referenced credentials have expired.
The input token contains different channel bindings to those specified via the input chan bindings parameter.
NO CONTEXT Indicates that the supplied context handle did not refer to a valid context.
The input token contains an invalid signature.
The input token was too old.
This is a fatal error during context establishment.
The input token is valid, but is a duplicate of a token already processed.
This is a fatal error during context establishment.
See minor status for more information.
gss process context token OM uint32
, gss buffer t    token buffer)
: Provides a way to pass a token to the security service.
Usually, tokens are associated either with context establishment (when they would be passed to gss init sec context or gss accept sec context) or with per message security service (when they would be passed to gss verify or gss unseal).
Occasionally, tokens may be received at other times, and gss process context token allows such tokens to be passed to the underlying security service for processing.
At present, such additional tokens may only be generated by gss delete sec context.
GSSAPI implementation may use this service to implement deletion of the security context.
See minor status for more information GSS S
The context handle did not refer to a valid context 3.6.
gss delete sec context OM uint32
gss delete sec context will delete the local data structures associated with the specified security context, and generate an output token, which when passed to the peer gss process context token will instruct it to do likewise.
No further security services may be obtained using the context specified by context handle.
, modify context handle identifying context to delete.
, see minor status for more information GSS S
No valid context was supplied 3.7.
Determines the number of seconds for which the specified context will remain valid.
id t, read Identifies the context to be interrogated.
If the context has already expired, zero will be returned.
The context has already expired GSS S CREDENTIALS EXPIRED
The context is recognized, but associated credentials have expired GSS S
The context handle parameter did not identify a valid context 3.8.
, gss buffer t    message buffer
Purpose: Generates a cryptographic signature for the supplied message, and places the signature in a token for transfer to the peer application.
The qop req parameter allows a choice between several cryptographic algorithms, if supported by the chosen mechanism.
Callers are encouraged, on portability grounds, to accept the default quality of protection offered by the chosen mechanism, which may be requested by specifying GSS C QOP DEFAULT for this parameter.
If an unsupported protection strength is requested, gss sign will return a major status of GSS S FAILURE.
The context has already expired GSS S CREDENTIALS EXPIRED
The context is recognized, but associated credentials have expired GSS S
See minor status for more information.
) Purpose: Verifies that a cryptographic signature, contained in the token parameter, fits the supplied message.
The qop state parameter allows a message recipient to determine the strength of protection that was applied to the message.
Successful completion GSS S DEFECTIVE TOKEN
The token failed consistency checks GSS S BAD SIG
The signature was incorrect GSS S DUPLICATE TOKEN
The token was valid, and contained a correct signature for the message, but it had already been processed GSS S OLD TOKEN
The token was valid, and contained a correct signature for the message, but it is too old GSS S
The token was valid, and contained a correct signature for the message, but has been verified out of sequence; an earlier token has been signed or sealed by the remote application, but not yet been processed locally.
The context has already expired GSS S CREDENTIALS EXPIRED
The context is recognized, but associated credentials have expired GSS S
See minor status for more information.
Cryptographically signs and optionally encrypts the specified input message.
The output message contains both the signature and the message.
The qop req parameter allows a choice between several cryptographic algorithms, if supported by the chosen mechanism.
A mechanism specific default may be requested by setting qop req to GSS C QOP DEFAULT.
If an unsupported protection strength is requested, gss seal will return a major status of GSS S FAILURE.
output message buffer  buffer, opaque, modify buffer to receive sealed message Function value:
The context has already expired GSS S CREDENTIALS EXPIRED
The context is recognized, but associated credentials have expired GSS S
See minor status for more information.
Converts a previously sealed message back to a usable form, verifying the embedded signature.
The conf state parameter indicates whether the message was encrypted; the qop state parameter indicates the strength of protection that was used to provide the confidentiality and integrity services.
, read identifies the context on which the message arrived input message buffer   buffer, opaque, read sealed message output message buffer  buffer, opaque,
Successful completion GSS S DEFECTIVE TOKEN
The token failed consistency checks GSS S BAD SIG
The signature was incorrect GSS S DUPLICATE TOKEN
The token was valid, and contained a correct signature for the message, but it had already been processed GSS S OLD TOKEN
The token was valid, and contained a correct signature for the message, but it is too old GSS S
The token was valid, and contained a correct signature for the message, but has been verified out of sequence; an earlier token has been signed or sealed by the remote application, but not yet been processed locally.
The context has already expired GSS S CREDENTIALS EXPIRED
The context is recognized, but associated credentials have expired GSS S
See minor status for more information.
gss display status OM uint32
Purpose: Allows an application to obtain a textual representation of a GSSAPI status code, for display to the user or for logging purposes.
Since some status values may indicate multiple errors, applications may need to call gss display status multiple times, each call generating a single text string.
The message context parameter is used to indicate which error message should be extracted from a given status value; message context should be initialized to 0, and gss display status will return a non zero value if there are further messages to extract.
Supply GSS C NULL OID to obtain the system default.
integer, read/modify Should be initialized to zero by caller on first call.
If further messages are contained in the status value parameter, message context will be non zero on return, and this value should be passed back to subsequent calls, along with the same status value, status type and mech type parameters.
Successful completion GSS S BAD MECH    Indicates that translation in accordance with an unsupported mechanism type was requested
The status value was not recognized, or the status type was neither GSS C GSS CODE nor GSS C MECH CODE.
gss indicate mechs OM uint32
Purpose: Allows an application to determine which underlying security mechanisms are available.
The returned gss OID set value will be a pointer into static storage, and should be treated as read only by the caller.
GSS S COMPLETE    Successful completion 3.14.
Purpose: Allows an application to compare two internal form names to determine whether they refer to the same entity.
boolean, modify True names refer to same entity False names refer to different entities (strictly, the names are not known to refer to the same identity).
The type contained within either name1 or name2 was unrecognized, or the names were of incomparable types.
One or both of name1 or name2 was ill formed 3.15.
gss display name OM uint32
Purpose: Allows an application to obtain a textual representation of an opaque internal form  name for display purposes.
The syntax of a printable name is defined by the GSSAPI implementation.
modify buffer to receive textual name string output name type  Object ID, modify The type of the returned name.
The returned gss OID will be a pointer into static storage, and should be treated as read only by the caller Function value:
The type of input name was not recognized
GSS S BAD NAME    input name was ill formed 3.16.
: Convert a printable name to internal form.
modify Mechanism specific status code input name buffer    buffer, character string,
read buffer containing printable name to convert input name type   Object ID, read, optional Object Id specifying type of printable name.
Applications may specify either GSS C NULL OID to use a local system specific printable syntax, or an OID registered by the GSSAPI implementation to name a particular namespace.
, modify returned name in internal form Function value:
GSS status code GSS S COMPLETE
The input name type was unrecognized GSS S BAD NAME
The input name parameter could not be interpreted as a name of the specified type 3.17.
Free GSSAPI allocated storage associated with an internal form name.
GSS status code GSS S COMPLETE
Successful completion GSS S BAD NAME
The name parameter did not contain a valid name 3.18.
Free storage associated with a buffer format name.
The storage must have been allocated by a GSSAPI routine.
In addition to freeing the associated storage, the routine will zero the length field in the buffer parameter.
The gss buffer desc object will not be freed, but its length field will be zeroed.
GSS status code GSS S COMPLETE
gss release oid set OM uint32
Free storage associated with a gss OID set object.
The storage must have been allocated by a GSSAPI routine.
The storage associated with the gss OID set will be deleted.
GSS status code GSS S COMPLETE
Obtains information about a credential.
The caller must already have obtained a handle that refers to the credential.
modify Mechanism specific status code cred handle
gss cred id t, read A handle that refers to the target credential.
C NO CREDENTIAL to inquire about the default credential.
Specify NULL if not required.
If the credential has expired, this parameter will be set to zero.
If the implementation does not support credential expiration, the value GSS C INDEFINITE will be returned.
Specify NULL if not required.
GSS C INITIATE GSS C ACCEPT GSS C
BOTH Specify NULL if not required.
Specify NULL if not required.
GSS status code GSS S COMPLETE
The referenced credentials could not be accessed.
The referenced credentials were invalid.
GSS S CREDENTIALS EXPIRED The referenced credentials have expired.
If the lifetime parameter was not passed as NULL, it will be set to 0.
First, define the platform dependent types.
/ typedef <platform specific> OM uint32; typedef <platform specific> gss ctx
id t; typedef <platform specific>
id t; typedef <platform specific> gss name t
/ typedef struct gss OID desc struct { OM uint32 length;
define GSS C DELEG FLAG 1 #
define GSS C MUTUAL FLAG 2
define GSS C REPLAY FLAG 4
define GSS C SEQUENCE FLAG 8
define GSS C CONF FLAG 16
define GSS C INITIATE 1
#define GSS C GSS CODE 1
define GSS C MECH CODE 2
The constant definitions for channel bindings address families  /
#define GSS C AF APPLETALK  16;
#define GSS C NULL OID ((gss OID) 0)
#define GSS C NULL OID
#define GSS C EMPTY BUFFER {0, NULL}
Note that an implementation that offers multiple   levels of QOP may either reserve a value (for example zero,   as assumed here)
to mean "default protection", or alternatively   may simply equate GSS C QOP DEFAULT to a specific explicit QOP   value.
GSS C INDEFINITE 0xfffffffful /  Major status codes  /
define GSS C ROUTINE ERROR
#define GSS C CALLING ERROR MASK 0377ul #
define GSS C ROUTINE ERROR
MASK 0377ul #define GSS C SUPPLEMENTARY MASK 0177777ul /
The macros that test status codes for error conditions  /
(x & (GSS C CALLING
< GSS C CALLING ERROR OFFSET))
(GSS C ROUTINE ERROR MASK <<
GSS C ROUTINE ERROR OFFSET))
(x & (GSS C SUPPLEMENTARY MASK << GSS C SUPPLEMENTARY OFFSET))
Now the actual status code definitions
(1ul << GSS C CALLING ERROR OFFSET)
(2ul << GSS C CALLING ERROR OFFSET)
(3ul << GSS C CALLING ERROR OFFSET)
< GSS C ROUTINE ERROR OFFSET)
2ul << GSS C ROUTINE ERROR OFFSET)
#define GSS S BAD NAMETYPE (
3ul << GSS C ROUTINE ERROR OFFSET)
#define GSS S BAD BINDINGS (4ul << GSS C ROUTINE ERROR OFFSET)
<< GSS C ROUTINE ERROR OFFSET)
#define GSS S BAD SIG (6ul
<< GSS C ROUTINE ERROR OFFSET)
NO CRED (7ul << GSS C ROUTINE
<< GSS C ROUTINE ERROR OFFSET)
(9ul << GSS C ROUTINE ERROR OFFSET)
#define GSS S DEFECTIVE CREDENTIAL
<< GSS C ROUTINE ERROR OFFSET)
GSS S CREDENTIALS EXPIRED (11ul
<< GSS C ROUTINE ERROR OFFSET)
#define GSS S CONTEXT EXPIRED (
<< GSS C ROUTINE ERROR OFFSET)
FAILURE (13ul << GSS C ROUTINE ERROR OFFSET) /
#define GSS S DUPLICATE TOKEN
#define GSS S OLD TOKEN
cred usage  / gss cred
OM uint32 gss release cred, (
/ gss cred id t
context handle  / gss name t,
time rec  / gss cred i
; OM uint32 gss process context token (
OM uint32 gss inquire cred
