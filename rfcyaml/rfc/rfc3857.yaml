- contents:
  - "           A Watcher Information Event Template-Package for\n                 the
    Session Initiation Protocol (SIP)\n"
  title: __initial_text__
- contents:
  - "Status of this Memo\n   This document specifies an Internet standards track protocol
    for the\n   Internet community, and requests discussion and suggestions for\n
    \  improvements.  Please refer to the current edition of the \"Internet\n   Official
    Protocol Standards\" (STD 1) for the standardization state\n   and status of this
    protocol.  Distribution of this memo is unlimited.\n"
  title: Status of this Memo
- contents:
  - "Copyright Notice\n   Copyright (C) The Internet Society (2004).\n"
  title: Copyright Notice
- contents:
  - "Abstract\n   This document defines the watcher information template-package for\n
    \  the Session Initiation Protocol (SIP) event framework.  Watcher\n   information
    refers to the set of users subscribed to a particular\n   resource within a particular
    event package.  Watcher information\n   changes dynamically as users subscribe,
    unsubscribe, are approved, or\n   are rejected.  A user can subscribe to this
    information, and\n   therefore learn about changes to it.  This event package
    is a\n   template-package because it can be applied to any event package,\n   including
    itself.\n"
  title: Abstract
- contents:
  - "Table of Contents\n   1.   Introduction ........................................
    \   2\n   2.   Terminology .........................................    3\n   3.
    \  Usage Scenarios .....................................    3\n        3.1.  Presence
    Authorization ........................    4\n        3.2.  Blacklist Alerts ..............................
    \   5\n   4.   Package Definition ..................................    5\n        4.1.
    \ Event Package Name ............................    5\n        4.2.  Event Package
    Parameters ......................    5\n        4.3.  SUBSCRIBE Bodies ..............................
    \   6\n        4.4.  Subscription Duration .........................    6\n        4.5.
    \ NOTIFY Bodies .................................    7\n        4.6.  Notifier
    Processing of SUBSCRIBE Requests......    7\n        4.7.  Notifier Generation
    of NOTIFY Requests ........    8\n              4.7.1.  The Subscription State
    Machine.........    9\n              4.7.2.  Applying the State Machine.............
    \  11\n        4.8.  Subscriber Processing of NOTIFY Requests ......   12\n        4.9.
    \ Handling of Forked Requests ...................   12\n        4.10. Rate of
    Notifications .........................   13\n        4.11. State Agents ..................................
    \  13\n   5.   Example Usage .......................................   14\n   6.
    \  Security Considerations .............................   17\n        6.1.  Denial
    of Service Attacks .....................   17\n        6.2.  Divulging Sensitive
    Information ...............   17\n   7.   IANA Considerations .................................
    \  18\n   8.   Acknowledgements ....................................   18\n   9.
    \  Normative References ................................   18\n   10.  Informative
    References ..............................   19\n   11.  Author's Address ....................................
    \  19\n   12.  Full Copyright Statement ............................   20\n"
  title: Table of Contents
- contents:
  - "1.  Introduction\n   The Session Initiation Protocol (SIP) event framework is
    described in\n   RFC 3265 [1].  It defines a generic framework for subscription
    to,\n   and notification of, events related to SIP systems.  The framework\n   defines
    the methods SUBSCRIBE and NOTIFY, and introduces the notion\n   of a package.
    \ A package is a concrete application of the event\n   framework to a particular
    class of events.  Packages have been\n   defined for user presence [5], for example.\n
    \  This document defines a \"template-package\" within the SIP event\n   framework.
    \ A template-package has all the properties of a regular\n   SIP event package.
    \ However, it is always associated with some other\n   event package, and can
    always be applied to any event package,\n   including the template-package itself.\n
    \  The template-package defined here is for watcher information, and is\n   denoted
    with the token \"winfo\".  For any event package, such as\n   presence, there
    exists a set (perhaps an empty set) of subscriptions\n   that have been created
    or requested by users trying to ascertain the\n   state of a resource in that
    package.  This set of subscriptions\n   changes over time as new subscriptions
    are requested by users, old\n   subscriptions expire, and subscriptions are approved
    or rejected by\n   the owners of that resource.  The set of users subscribed to
    a\n   particular resource for a specific event package, and the state of\n   their
    subscriptions, is referred to as watcher information.  Since\n   this state is
    itself dynamic, it is reasonable to subscribe to it in\n   order to learn about
    changes to it.  The watcher information event\n   template-package is meant to
    facilitate exactly that - tracking the\n   state of subscriptions to a resource
    in another package.\n   To denote this template-package, the name is constructed
    by appending\n   \".winfo\" to the name of whatever package is being tracked.
    \ For\n   example, the set of people subscribed to presence is defined by the\n
    \  \"presence.winfo\" package.\n"
  title: 1.  Introduction
- contents:
  - "2.  Terminology\n   In this document, the key words \"MUST\", \"MUST NOT\", \"REQUIRED\",\n
    \  \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\",\n
    \  and \"OPTIONAL\" are to be interpreted as described in BCP14, RFC 2119\n   [2]
    and indicate requirement levels for compliant implementations.\n   This document
    fundamentally deals with recursion - subscriptions to\n   subscriptions.  Therefore,
    the term \"subscription\" itself can be\n   confusing in this document.  To reduce
    confusion, the term\n   \"watcherinfo subscription\" refers to a subscription
    to watcher\n   information, and the term \"watcherinfo subscriber\" refers to
    a user\n   that has subscribed to watcher information.  The term \"watcherinfo\n
    \  notification\" refers to a NOTIFY request sent as part of a\n   watcherinfo
    subscription.  When the terms \"subscription\",\n   \"subscriber\", and \"notification\"
    are used unqualified, they refer to\n   the \"inner\" subscriptions, subscribers
    and notifications - those that\n   are being monitored through the watcherinfo
    subscriptions.  We also\n   use the term \"watcher\" to refer to a subscriber
    to the \"inner\"\n   resource.  Information on watchers is reported through watcherinfo\n
    \  subscriptions.\n"
  title: 2.  Terminology
- contents:
  - "3.  Usage Scenarios\n   There are many useful applications for the watcher information\n
    \  template-package.\n"
  - contents:
    - "3.1.  Presence Authorization\n   The motivating application for this template-package
      is presence\n   authorization.  When user A subscribes to the presence of user
      B, the\n   subscription needs to be authorized.  Frequently, that authorization\n
      \  needs to occur through direct user intervention.  For that to happen,\n   B's
      software needs to become aware that a presence subscription has\n   been requested.
      \ This is supported through watcher information.  B's\n   client software would
      SUBSCRIBE to the watcher information for the\n   presence of B:\n   SUBSCRIBE
      sip:B@example.com SIP/2.0\n   Via: SIP/2.0/UDP pc34.example.com;branch=z9hG4bKnashds7\n
      \  From: sip:B@example.com;tag=123s8a\n   To: sip:B@example.com\n   Call-ID:
      9987@pc34.example.com\n   Max-Forwards: 70\n   CSeq: 9887 SUBSCRIBE\n   Contact:
      sip:B@pc34.example.com\n   Event: presence.winfo\n   The policy of the server
      is such that it allows B to subscribe to its\n   own watcher information.  So,
      when A subscribes to B's presence, B\n   gets a notification of the change in
      watcher information state:\n   NOTIFY sip:B@pc34.example.com SIP/2.0\n   Via:
      SIP/2.0/UDP server.example.com;branch=z9hG4bKna66g\n   From: sip:B@example.com;tag=xyz887\n
      \  To: sip:B@example.com;tag=123s8a\n   Call-ID: 9987@pc34.example.com\n   Max-Forwards:
      70\n   CSeq: 1288 NOTIFY\n   Contact: sip:B@server.example.com\n   Event: presence.winfo\n
      \  Content-Type: application/watcherinfo+xml\n   Content-Length: ...\n   <?xml
      version=\"1.0\"?>\n   <watcherinfo xmlns=\"urn:ietf:params:xml:ns:watcherinfo\"\n
      \               version=\"0\" state=\"full\">\n      <watcher-list resource=\"sip:B@example.com\"
      package=\"presence\">\n        <watcher id=\"7768a77s\" event=\"subscribe\"\n
      \                status=\"pending\">sip:A@example.com</watcher>\n      </watcher-list>\n
      \  </watcherinfo>\n   This indicates to B that A has subscribed, and that the
      subscription\n   is pending (meaning, it is awaiting authorization).  B's software
      can\n   alert B that this subscription is awaiting authorization.  B can then\n
      \  set policy for that subscription.\n"
    title: 3.1.  Presence Authorization
  - contents:
    - "3.2.  Blacklist Alerts\n   Applications can subscribe to watcher information
      in order to provide\n   value-added features.  An example application is \"blacklist
      alerts\".\n   In this scenario, an application server maintains a list of known\n
      \  \"bad guys\".  A user, Joe, signs up for service with the application\n   provider,
      presumably by going to a web page and entering in his\n   presence URI.  The
      application server subscribes to the watcher\n   information for Joe's presence.
      \ When someone attempts to SUBSCRIBE\n   to Joe's user presence, the application
      learns of this subscription\n   as a result of its watcher info subscription.
      \ It checks the\n   watcher's URI against the database of known bad guys.  If
      there is a\n   match, it sends email to Joe letting him know about this.\n   For
      this application to work, Joe needs to make sure that the\n   application is
      allowed to subscribe to his presence.winfo.\n"
    title: 3.2.  Blacklist Alerts
  title: 3.  Usage Scenarios
- contents:
  - "4.  Package Definition\n   This section fills in the details needed to specify
    an event package\n   as defined in Section 4.4 of RFC 3265 [1].\n"
  - contents:
    - "4.1.  Event Package Name\n   RFC 3265 [1] requires package definitions to specify
      the name of\n   their package or template-package.\n   The name of this template-package
      is \"winfo\".  It can be applied to\n   any other package.  Watcher information
      for any package foo is\n   denoted by the name \"foo.winfo\".  Recursive template-packaging
      is\n   explicitly allowed (and useful), so that \"foo.winfo.winfo\" is a valid\n
      \  package name.\n"
    title: 4.1.  Event Package Name
  - contents:
    - "4.2.  Event Package Parameters\n   RFC 3265 [1] requires package and template-package
      definitions to\n   specify any package specific parameters of the Event header
      field.\n   No package specific Event header field parameters are defined for\n
      \  this event template-package.\n"
    title: 4.2.  Event Package Parameters
  - contents:
    - "4.3.  SUBSCRIBE Bodies\n   RFC 3265 [1] requires package or template-package
      definitions to\n   define the usage, if any, of bodies in SUBSCRIBE requests.\n
      \  A SUBSCRIBE request for watcher information MAY contain a body.  This\n   body
      would serve the purpose of filtering the watcherinfo\n   subscription.  The
      definition of such a body is outside the scope of\n   this specification.  For
      example, in the case of presence, the body\n   might indicate that notifications
      should contain full state every\n   time something changes, and that the time
      the subscription was first\n   made should not be included in the watcherinfo
      notifications.\n   A SUBSCRIBE request for a watcher information package MAY
      be sent\n   without a body.  This implies the default watcherinfo subscription\n
      \  filtering policy has been requested.  The default policy is:\n   o  Watcherinfo
      notifications are generated every time there is any\n      change in the state
      of the watcher information.\n   o  Watcherinfo notifications triggered from
      a SUBSCRIBE contain full\n      state (the list of all watchers that the watcherinfo
      subscriber is\n      permitted to know about).  Watcherinfo notifications triggered\n
      \     from a change in watcher state only contain information on the\n      watcher
      whose state has changed.\n   Of course, the server can apply any policy it likes
      to the\n   subscription.\n"
    title: 4.3.  SUBSCRIBE Bodies
  - contents:
    - "4.4.  Subscription Duration\n   RFC 3265 [1] requires package definitions to
      define a default value\n   for subscription durations, and to discuss reasonable
      choices for\n   durations when they are explicitly specified.\n   Watcher information
      changes as users subscribe to a particular\n   resource for some package, or
      their subscriptions time out.  As a\n   result, the state of watcher information
      can change very dynamically,\n   depending on the number of subscribers for
      a particular resource in a\n   given package.  The rate at which subscriptions
      time out depends on\n   how long a user maintains its subscription.  Typically,
      watcherinfo\n   subscriptions will be timed to span the lifetime of the subscriptions\n
      \  being watched, and therefore range from minutes to days.\n   As a result
      of these factors, it is difficult to define a broadly\n   useful default value
      for the lifetime of a watcherinfo subscription.\n   We arbitrarily choose one
      hour.  However, clients SHOULD use an\n   Expires header field to specify their
      preferred duration.\n"
    title: 4.4.  Subscription Duration
  - contents:
    - "4.5.  NOTIFY Bodies\n   RFC 3265 [1] requires package definitions to describe
      the allowed set\n   of body types in NOTIFY requests, and to specify the default
      value to\n   be used when there is no Accept header field in the SUBSCRIBE\n
      \  request.\n   The body of the watcherinfo notification contains a watcher\n
      \  information document.  This document describes some or all of the\n   watchers
      for a resource within a given package, and the state of\n   their subscriptions.
      \ All watcherinfo subscribers and notifiers MUST\n   support the application/watcherinfo+xml
      format described in [3], and\n   MUST list its MIME type, application/watcherinfo+xml,
      in any Accept\n   header field present in the SUBSCRIBE request.\n   Other watcher
      information formats might be defined in the future.  In\n   that case, the watcherinfo
      subscriptions MAY indicate support for\n   other formats.  However, they MUST
      always support and list\n   application/watcherinfo+xml as an allowed format.\n
      \  Of course, the watcherinfo notifications generated by the server MUST\n   be
      in one of the formats specified in the Accept header field in the\n   SUBSCRIBE
      request.  If no Accept header field was present, the\n   notifications MUST
      use the application/watcherinfo+xml format\n   described in [3].\n"
    title: 4.5.  NOTIFY Bodies
  - contents:
    - "4.6.  Notifier Processing of SUBSCRIBE Requests\n   RFC 3265 [1] specifies
      that packages should define any package-\n   specific processing of SUBSCRIBE
      requests at a notifier, specifically\n   with regards to authentication and
      authorization.\n   The watcher information for a particular package contains
      sensitive\n   information.  Therefore, all watcherinfo subscriptions SHOULD
      be\n   authenticated and then authorized before approval.  Authentication\n
      \  MAY be performed using any of the techniques available through SIP,\n   including
      digest, S/MIME, TLS or other transport specific mechanisms\n   [4].  Authorization
      policy is at the discretion of the administrator,\n   as always.  However, a
      few recommendations can be made.\n   It is RECOMMENDED that user A be allowed
      to subscribe to their own\n   watcher information for any package.  This is
      true recursively, so\n   that it is RECOMMENDED that a user be able to subscribe
      to the\n   watcher information for their watcher information for any package.\n
      \  It is RECOMMENDED that watcherinfo subscriptions for some package foo\n   for
      user A be allowed from some other user B, if B is an authorized\n   subscriber
      to A within the package foo.  However, it is RECOMMENDED\n   that the watcherinfo
      notifications sent to B only contain the state\n   of B's own subscription.
      \ In other words, it is RECOMMENDED that a\n   user be allowed to monitor the
      state of their own subscription.\n   To avoid infinite recursion of authorization
      policy, it is\n   RECOMMENDED that only user A be allowed to subscribe to\n
      \  foo.winfo.winfo for user A, for any foo.  It is also RECOMMENDED that\n   by
      default, a server does not authorize any subscriptions to\n   foo.winfo.winfo.winfo
      or any other deeper recursions.\n"
    title: 4.6.  Notifier Processing of SUBSCRIBE Requests
  - contents:
    - "4.7.  Notifier Generation of NOTIFY Requests\n   The SIP Event framework requests
      that packages specify the conditions\n   under which notifications are sent
      for that package, and how such\n   notifications are constructed.\n   Each watcherinfo
      subscription is associated with a set of \"inner\"\n   subscriptions being watched.
      \ This set is defined by the URI in the\n   Request URI of the watcherinfo SUBSCRIBE
      request, along with the\n   parent event package of the watcherinfo subscription.
      \ The parent\n   event package is obtained by removing the trailing \".winfo\"
      from the\n   value of the Event header field from the watcherinfo SUBSCRIBE\n
      \  request.  If the Event header field in the watcherinfo subscription\n   has
      a value of \"presence.winfo\", the parent event package is\n   \"presence\".
      \ If the Event header field has a value of\n   \"presence.winfo.winfo\", the
      parent event package is \"presence.winfo\".\n   Normally, the URI in the Request
      URI of the watcherinfo SUBSCRIBE\n   identifies an address-of-record within
      the domain.  In that case, the\n   set of subscriptions to be watched are all
      of the subscriptions for\n   the parent event package that have been made to
      the resource in the\n   Request URI of the watcherinfo SUBSCRIBE.  However,
      the Request URI\n   can contain a URI that identifies any set of subscriptions,
      including\n   the subscriptions to a larger collection of resources.  For example,\n
      \  sip:all-resources@example.com might be defined within example.com to\n   refer
      to all resources.  In that case, a watcherinfo subscription for\n   \"presence.winfo\"
      to sip:all-resources@example.com is requesting\n   notifications any time the
      state of any presence subscription for any\n   resource within example.com changes.
      \ A watcherinfo notifier MAY\n   generate a notification any time the state
      of any of the watched\n   subscriptions changes.\n   Because a watcherinfo subscription
      is made to a collection of\n   subscriptions, the watcher information package
      needs a model of\n   subscription state.  This is accomplished by specifying
      a\n   subscription Fine State Machine (FSM), described below, which governs\n
      \  the subscription state of a user in any package.  Watcherinfo\n   notifications
      MAY be generated on transitions in this state machine.\n   It's important to
      note that this FSM is just a model of the\n   subscription state machinery maintained
      by a server.  An\n   implementation would map its own state machines to this
      one in an\n   implementation-specific manner.\n"
    - contents:
      - "4.7.1.  The Subscription State Machine\n   The underlying state machine for
        a subscription is shown in Figure 1.\n   It derives almost entirely from the
        descriptions in RFC 3265 [1], but\n   adds the notion of a waiting state.\n
        \  When a SUBSCRIBE request arrives, the subscription FSM is created in\n
        \  the init state. This state is transient.  The next state depends on\n   whether
        policy exists for the subscription.  If there is an existing\n   policy that
        determines that the subscription is forbidden, it moves\n   into the terminated
        state immediately, where the FSM can be\n   destroyed.  If there is existing
        policy that determines that the\n   subscription is authorized, the FSM moves
        into the active state.\n   This state indicates that the subscriber will receive
        notifications.\n   If, when a subscription arrives, there is no authorization
        policy in\n   existence, the subscription moves into the pending state.  In
        this\n   state, the server is awaiting an authorization decision.  No\n   notifications
        are generated on changes in presence state (an initial\n   NOTIFY will have
        been delivered as per RFC 3265 [1]), but the\n   subscription FSM is maintained.
        \ If the authorization decision comes\n   back positive, the subscription
        is approved, and moves into the\n   active state.  If the authorization is
        negative, the subscription is\n   rejected, and the FSM goes into the terminated
        state.  It is possible\n   that the authorization decision can take a very
        long time.  In fact,\n   no authorization decision may arrive until after
        the subscription\n   itself expires.  If a pending subscription suffers a
        timeout, it\n   moves into the waiting state.  At any time, the server can
        decide to\n   end a pending or waiting subscription because it is concerned
        about\n   allocating memory and CPU resources to unauthorized subscription\n
        \  state.  If this happens, a \"giveup\" event is generated by the server,\n
        \  moving the subscription to terminated.\n   The waiting state is similar
        to pending, in that no notifications are\n   generated.  However, if the subscription
        is approved or denied, the\n   FSM enters the terminated state, and is destroyed.
        Furthermore, if\n   another subscription is received to the same resource,
        from the same\n   watcher, for the same event package, event package parameters
        and\n   filter in the body of the SUBSCRIBE request (if one was present\n
        \  initially), the FSM enters the terminated state with a \"giveup\"\n   event,
        and is destroyed.  This transition occurs because, on arrival\n   of a new
        subscription with identical parameters, it will enter the\n   pending state,
        making the waiting state for the prior subscription\n   redundant.  The purpose
        of the waiting state is so that a user can\n   fetch watcherinfo state at
        any time, and learn of any subscriptions\n   that arrived previously (and
        which may arrive again) which require an\n   authorization decision.  Consider
        an example.  A subscribes to B.  B\n   has not defined policy about this subscription,
        so it moves into the\n   pending state.  B is not \"online\", so that B's
        software agent cannot\n   be contacted to approve the subscription.  The subscription
        expires.\n   Let's say it were destroyed.  B logs in, and fetches its watcherinfo\n
        \  state.  There is no record of the subscription from A, so no policy\n   decision
        is made about subscriptions from A.  B logs off.  A\n   refreshes its subscription.
        \ Once more, the subscription is pending\n   since no policy is defined for
        it.  This process could continue\n   indefinitely.  The waiting state ensures
        that B can find out about\n   this subscription attempt.\n         subscribe,\n
        \        policy=       +----------+\n         reject        |          |<------------------------+\n
        \        +------------>|terminated|<---------+              |\n         |
        \            |          |          |              |\n         |             |
        \         |          |noresource    |\n         |             +----------+
        \         |rejected      |\n         |                  ^noresource      |deactivated
        \  |\n         |                  |rejected        |probation     |\n         |
        \                 |deactivated     |timeout       |noresource\n         |
        \                 |probation       |              |rejected\n         |                  |giveup
        \         |              |giveup\n         |                  |                |
        \             |approved\n      +-------+         +-------+        +-------+
        \         |\n      |       |subscribe|       |approved|       |          |\n
        \     | init  |-------->|pending|------->|active |          |\n      |       |no
        policy|       |        |       |          |\n      |       |         |       |
        \       |       |          |\n      +-------+         +-------+        +-------+
        \         |\n         |                  |                ^              |\n
        \        | subscribe,       |                |              |\n         +-----------------------------------+
        \             |\n           policy = accept  |            +-------+          |\n
        \                           |            |       |          |\n                            |
        \           |waiting|----------+\n                            +----------->|
        \      |\n                             timeout     |       |\n                                         +-------+\n
        \                  Figure 1: Subscription State Machine\n   The waiting state
        is also needed to allow for authorization of fetch\n   attempts, which are
        subscriptions that expire immediately.\n   Of course, policy may never be
        specified for the subscription.  As a\n   result, the server can generate
        a giveup event to move the waiting\n   subscription to the terminated state.
        \ The amount of time to wait\n   before issuing a giveup event is system dependent.\n
        \  The giveup event is generated in either the waiting or pending states\n
        \  to destroy resources associated with unauthorized subscriptions.\n   This
        event is generated when a giveup timer fires. This timer is set\n   to a timeout
        value when entering either the pending or waiting\n   states.  Servers need
        to exercise care in selecting this value.  It\n   needs to be large in order
        to provide a useful user experience; a\n   user should be able to log in days
        later and see that someone tried\n   to subscribe to them.  However, allocating
        state to unauthorized\n   subscriptions can be used as a source of DoS attacks.
        \ Therefore, it\n   is RECOMMENDED that servers that retain state for unauthorized\n
        \  subscriptions add policies which prohibit a particular subscriber\n   from
        having more than some number of pending or waiting\n   subscriptions.\n   At
        any time, the server can deactivate a subscription.  Deactivation\n   implies
        that the subscription is discarded without a change in\n   authorization policy.
        \ This may be done in order to trigger refreshes\n   of subscriptions for
        a graceful shutdown or subscription migration\n   operation.  A related event
        is probation, where a subscription is\n   terminated, and the subscriber is
        requested to wait some amount of\n   time before trying again.  The meaning
        of these events is described\n   in more detail in Section 3.2.4 of RFC 3265
        [1].\n   A subscription can be terminated at any time because the resource\n
        \  associated with that subscription no longer exists.  This corresponds\n
        \  to the noresource event.\n"
      title: 4.7.1.  The Subscription State Machine
    - contents:
      - "4.7.2.  Applying the State Machine\n   The server MAY generate a notification
        to watcherinfo subscribers on\n   a transition of the state machine.  Whether
        it does or not is policy\n   dependent.  However, several guidelines are defined.\n
        \  Consider some event package foo.  A subscribes to B for events within\n
        \  that package.  A also subscribes to foo.winfo for B.  In this\n   scenario
        (where the subscriber to foo.winfo is also a subscriber to\n   foo for the
        same resource), it is RECOMMENDED that A receive\n   watcherinfo notifications
        only about the changes in its own\n   subscription.  Normally, A will receive
        notifications about changes\n   in its subscription to foo through the Subscription-State
        header\n   field.  This will frequently obviate the need for a separate\n
        \  subscription to foo.winfo.  However, if such a subscription is\n   performed
        by A, the foo.winfo notifications SHOULD NOT report any\n   state changes
        which would not be reported (because of authorization\n   policy) in the Subscription-State
        header field in notifications on\n   foo.\n   As a general rule, when a watcherinfo
        subscriber is authorized to\n   receive watcherinfo notifications about more
        than one watcher, it is\n   RECOMMENDED that watcherinfo notifications contain
        information about\n   those watchers which have changed state (and thus triggered
        a\n   notification), instead of delivering the current state of every\n   watcher
        in every watcherinfo notification.  However, watcherinfo\n   notifications
        triggered as a result of a fetch operation (a SUBSCRIBE\n   with Expires of
        0) SHOULD result in the full state of all watchers\n   (of course, only those
        watchers that have been authorized to be\n   divulged to the watcherinfo subscriber)
        to be present in the NOTIFY.\n   Frequently, states in the subscription state
        machine will be\n   transient.  For example, if an authorized watcher performs
        a fetch\n   operation, this will cause the state machine to be created,\n
        \  transition from init to active, and then from active to terminated,\n   followed
        by a destruction of the FSM.  In such cases, watcherinfo\n   notifications
        SHOULD NOT be sent for any transient states.  In the\n   prior example, the
        server wouldn't send any notifications, since all\n   of the states are transient.\n"
      title: 4.7.2.  Applying the State Machine
    title: 4.7.  Notifier Generation of NOTIFY Requests
  - contents:
    - "4.8.  Subscriber Processing of NOTIFY Requests\n   RFC 3265 [1] expects packages
      to specify how a subscriber processes\n   NOTIFY requests in any package specific
      ways, and in particular, how\n   it uses the NOTIFY requests to construct a
      coherent view of the state\n   of the subscribed resource.  Typically, the watcherinfo
      NOTIFY will\n   only contain information about those watchers whose state has\n
      \  changed.  To construct a coherent view of the total state of all\n   watchers,
      a watcherinfo subscriber will need to combine NOTIFYs\n   received over time.
      \ This details of this process depend on the\n   document format.  See [3] for
      details on the\n   application/watcherinfo+xml format.\n"
    title: 4.8.  Subscriber Processing of NOTIFY Requests
  - contents:
    - "4.9.  Handling of Forked Requests\n   The SIP Events framework mandates that
      packages indicate whether or\n   not forked SUBSCRIBE requests can install multiple
      subscriptions.\n   When a user wishes to obtain watcher information for some
      resource\n   for package foo, the SUBSCRIBE to the watcher information will
      need\n   to reach a collection of servers that have, unioned together,\n   complete
      information about all watchers on that resource for package\n   foo.  If there
      are a multiplicity of servers handling subscriptions\n   for that resource for
      package foo (for load balancing reasons,\n   typically), it is very likely that
      no single server will have the\n   complete set of watcher information.  There
      are several solutions in\n   this case.  This specification does not mandate
      a particular one, nor\n   does it rule out others.  It merely ensures that a
      broad range of\n   solutions can be built.\n   One solution is to use forking.
      \ The system can be designed so that a\n   SUBSCRIBE for watcher information
      arrives at a special proxy which is\n   aware of the requirements for watcher
      information.  This proxy would\n   fork the SUBSCRIBE request to all of the
      servers which could possibly\n   maintain subscriptions for that resource for
      that package.  Each of\n   these servers, whether or not they have any current
      subscribers for\n   that resource, would accept the watcherinfo subscription.
      \ Each needs\n   to accept because they may all eventually receive a subscription
      for\n   that resource.  The watcherinfo subscriber would receive some number\n
      \  of watcherinfo NOTIFY requests, each of which establishes a separate\n   dialog.
      \ By aggregating the information across each dialog, the\n   watcherinfo subscriber
      can compute full watcherinfo state.  In many\n   cases, a particular dialog
      might never generate any watcherinfo\n   notifications; this would happen if
      the servers never receive any\n   subscriptions for the resource.\n   In order
      for such a system to be built in an interoperable fashion,\n   all watcherinfo
      subscribers MUST be prepared to install multiple\n   subscriptions as a result
      of a multiplicity of NOTIFY messages in\n   response to a single SUBSCRIBE.\n
      \  Another approach for handling the server multiplicity problem is to\n   use
      state agents.  See Section 4.11 for details.\n"
    title: 4.9.  Handling of Forked Requests
  - contents:
    - "4.10.  Rate of Notifications\n   RFC 3265 [1] mandates that packages define
      a maximum rate of\n   notifications for their package.\n   For reasons of congestion
      control, it is important that the rate of\n   notifications not become excessive.
      \ As a result, it is RECOMMENDED\n   that the server not generate watcherinfo
      notifications for a single\n   watcherinfo subscriber at a rate faster than
      once every 5 seconds.\n"
    title: 4.10.  Rate of Notifications
  - contents:
    - "4.11.  State Agents\n   RFC 3265 [1] asks packages to consider the role of
      state agents in\n   their design.\n   State agents play an important role in
      this package.  As discussed in\n   Section 4.9, there may be a multiplicity
      of servers sharing the load\n   of subscriptions for a particular package.  A
      watcherinfo\n   subscription might require subscription state spread across
      all of\n   those servers. To handle that, a farm of state agents can be used.\n
      \  Each of these state agents would know the entire watcherinfo state\n   for
      some set of resources.  The means by which the state agents would\n   determine
      the full watcherinfo state is outside the scope of this\n   specification. When
      a watcherinfo subscription is received, it would\n   be routed to a state agent
      that has the full watcherinfo state for\n   the requested resource.  This server
      would accept the watcherinfo\n   subscription (assuming it was authorized, of
      course), and generate\n   watcherinfo notifications as the watcherinfo state
      changed.  The\n   watcherinfo subscriber would only have a single dialog in
      this case.\n"
    title: 4.11.  State Agents
  title: 4.  Package Definition
- contents:
  - "5.  Example Usage\n   The following section discusses an example application
    and call flows\n   using the watcherinfo package.\n   In this example, a user
    Joe, sip:joe@example.com provides presence\n   through the example.com presence
    server.  Joe subscribes to his own\n   watcher information, in order to learn
    about people who subscribe to\n   his presence, so that he can approve or reject
    their subscriptions.\n   Joe sends the following SUBSCRIBE request:\n   SUBSCRIBE
    sip:joe@example.com SIP/2.0\n   Via: SIP/2.0/UDP pc34.example.com;branch=z9hG4bKnashds7\n
    \  From: sip:joe@example.com;tag=123aa9\n   To: sip:joe@example.com\n   Call-ID:
    9987@pc34.example.com\n   CSeq: 9887 SUBSCRIBE\n   Contact: sip:joe@pc34.example.com\n
    \  Event: presence.winfo\n   Max-Forwards: 70\n   The server responds with a 401
    to authenticate, and Joe resubmits the\n   SUBSCRIBE with credentials (message
    not shown).  The server then\n   authorizes the subscription, since it allows
    Joe to subscribe to his\n   own watcher information for presence.  It responds
    with a 200 OK:\n   SIP/2.0 200 OK\n   Via: SIP/2.0/UDP pc34.example.com;branch=z9hG4bKnashds8\n
    \    ;received=192.0.2.8\n   From: sip:joe@example.com;tag=123aa9\n   To: sip:joe@example.com;tag=xyzygg\n
    \  Call-ID: 9987@pc34.example.com\n   CSeq: 9988 SUBSCRIBE\n   Contact: sip:server19.example.com\n
    \  Expires: 3600\n   Event: presence.winfo\n   The server then sends a NOTIFY
    with the current state of\n   presence.winfo for joe@example.com:\n   NOTIFY sip:joe@pc34.example.com
    SIP/2.0\n   Via: SIP/2.0/UDP server19.example.com;branch=z9hG4bKnasaii\n   From:
    sip:joe@example.com;tag=xyzygg\n   To: sip:joe@example.com;tag=123aa9\n   Call-ID:
    9987@pc34.example.com\n   CSeq: 1288 NOTIFY\n   Contact: sip:server19.example.com\n
    \  Event: presence.winfo\n   Subscription-State: active\n   Max-Forwards: 70\n
    \  Content-Type: application/watcherinfo+xml\n   Content-Length: ...\n   <?xml
    version=\"1.0\"?>\n   <watcherinfo xmlns=\"urn:ietf:params:xml:ns:watcherinfo\"\n
    \               version=\"0\" state=\"full\">\n     <watcher-list resource=\"sip:joe@example.com\"
    package=\"presence\">\n       <watcher id=\"77ajsyy76\" event=\"subscribe\"\n
    \               status=\"pending\">sip:A@example.com</watcher>\n     </watcher-list>\n
    \  </watcherinfo>\n   Joe then responds with a 200 OK to the NOTIFY:\n   SIP/2.0
    200 OK\n   Via: SIP/2.0/UDP server19.example.com;branch=z9hG4bKnasaii\n     ;received=192.0.2.7\n
    \  From: sip:joe@example.com;tag=xyzygg\n   To: sip:joe@example.com;tag=123aa9\n
    \  Call-ID: 9987@pc34.example.com\n   CSeq: 1288 NOTIFY\n   The NOTIFY tells Joe
    that user A currently has a pending\n   subscription.  Joe then authorizes A's
    subscription through some\n   means.  This causes a change in the status of the
    subscription (which\n   moves from pending to active), and the delivery of another\n
    \  notification:\n   NOTIFY sip:joe@pc34.example.com SIP/2.0\n   Via: SIP/2.0/UDP
    server19.example.com;branch=z9hG4bKnasaij\n   From: sip:joe@example.com;tag=xyzygg\n
    \  To: sip:joe@example.com;tag=123aa9\n   Call-ID: 9987@pc34.example.com\n   CSeq:
    1289 NOTIFY\n   Contact: sip:server19.example.com\n   Event: presence.winfo\n
    \  Subscription-State: active\n   Max-Forwards: 70\n   Content-Type: application/watcherinfo+xml\n
    \  Content-Length: ...\n   <?xml version=\"1.0\"?>\n   <watcherinfo xmlns=\"urn:ietf:params:xml:ns:watcherinfo\"\n
    \               version=\"1\" state=\"partial\">\n     <watcher-list resource=\"sip:joe@example.com\"
    package=\"presence\">\n       <watcher id=\"77ajsyy76\" event=\"approved\"\n                status=\"active\">sip:A@example.com</watcher>\n
    \    </watcher-list>\n   </watcherinfo>\n   B then responds with a 200 OK to the
    NOTIFY:\n   SIP/2.0 200 OK\n   Via: SIP/2.0/UDP server19.example.com;branch=z9hG4bKnasaij\n
    \    ;received=192.0.2.7\n   From: sip:joe@example.com;tag=xyzygg\n   To: sip:joe@example.com;tag=123aa9\n
    \  Call-ID: 9987@pc34.example.com\n   CSeq: 1289 NOTIFY\n"
  title: 5.  Example Usage
- contents:
  - '6.  Security Considerations

    '
  - contents:
    - "6.1.  Denial of Service Attacks\n   Watcher information generates notifications
      about changes in the\n   state of watchers for a particular resource.  It is
      possible for a\n   single resource to have many watchers, resulting in the possibility\n
      \  of a large volume of notifications.  This makes watcherinfo\n   subscription
      a potential tool for denial of service attacks.\n   Preventing these can be
      done through a combination of sensible\n   authorization policies and good operating
      principles.\n   First, when a resource has a lot of watchers, watcherinfo\n
      \  subscriptions to that resource should only be allowed from explicitly\n   authorized
      entities, whose identity has been properly authenticated.\n   That prevents
      a watcherinfo NOTIFY stream from being generated from\n   subscriptions made
      by an attacker.\n   Even when watcherinfo subscriptions are properly authenticated,
      there\n   are still potential attacks.  For example, consider a valid user,
      T,\n   who is to be the target of an attack.  T has subscribed to their own\n
      \  watcher information.  The attacker generates a large number of\n   subscriptions
      (not watcherinfo subscriptions).  If the server creates\n   subscription state
      for unauthenticated subscriptions, and reports\n   those changes in watcherinfo
      notifications, user T would receive a\n   flood of watcherinfo notifications.
      \ In fact, if the server generates\n   a watcherinfo notification when the subscription
      is created, and\n   another when it is terminated, there will be an amplification
      by a\n   factor of two.  The amplification would actually be substantial if\n
      \  the server generates full state in each watcherinfo notification.\n   Indeed,
      the amount of data sent to T would be the square of the data\n   generated by
      the attacker! Each of the N subscriptions generated by\n   the attacker would
      result in a watcherinfo NOTIFY being sent to T,\n   each of which would report
      on up to N watchers.  To avoid this,\n   servers should never generate subscription
      state for unauthenticated\n   SUBSCRIBE requests, and should never generate
      watcherinfo\n   notifications for them either.\n"
    title: 6.1.  Denial of Service Attacks
  - contents:
    - "6.2.  Divulging Sensitive Information\n   Watcher information indicates what
      users are interested in a\n   particular resource.  Depending on the package
      and the resource, this\n   can be very sensitive information.  For example,
      in the case of\n   presence, the watcher information for some user represents
      the\n   friends, family, and business relations of that person.  This\n   information
      can be used for a variety of malicious purposes.\n   One way in which this information
      can be revealed is eavesdropping.\n   An attacker can observe watcherinfo notifications,
      and learn this\n   information.  To prevent that, watchers MAY use the sips
      URI scheme\n   when subscribing to a watcherinfo resource.  Notifiers for\n
      \  watcherinfo MUST support TLS and sips as if they were a proxy (see\n   Section
      26.3.1 of RFC 3261).\n   SIP encryption, using S/MIME, MAY be used end-to-end
      for the\n   transmission of both SUBSCRIBE and NOTIFY requests.\n   Another
      way in which this information can be revealed is through\n   spoofed subscriptions.
      \ These attacks can be prevented by\n   authenticating and authorizing all watcherinfo
      subscriptions.  In\n   order for the notifier to authenticate the subscriber,
      it MAY use\n   HTTP Digest (Section 22 of RFC 3261).  As a result, all watchers
      MUST\n   support HTTP Digest.  This is a redundant requirement, however, since\n
      \  all SIP user agents are mandated to support it by RFC 3261.\n"
    title: 6.2.  Divulging Sensitive Information
  title: 6.  Security Considerations
- contents:
  - "7.  IANA Considerations\n   This specification registers an event template package
    as specified\n   in Section 6.2 of RFC 3265 [1].\n   Package Name: winfo\n   Template
    Package: yes\n   Published Specification: RFC 3857\n   Person to Contact: Jonathan
    Rosenberg, jdrosen@jdrosen.net.\n"
  title: 7.  IANA Considerations
- contents:
  - "8.  Acknowledgements\n   The authors would like to thank Adam Roach, Allison
    Mankin and Brian\n   Stucker for their detailed comments.\n"
  title: 8.  Acknowledgements
- contents:
  - "9.  Normative References\n   [1]  Roach, A.B., \"Session Initiation Protocol
    (SIP)-Specific Event\n        Notification\", RFC 3265, June 2002.\n   [2]  Bradner,
    S., \"Key Words for Use in RFCs to Indicate Requirement\n        Levels\", BCP
    14, RFC 2119, March 1997.\n   [3]  Rosenberg, J., \"An Extensible Markup Language
    (XML) Based Format\n        for Watcher Information\", RFC 3858, August 2004.\n
    \  [4]  Rosenberg, J., Schulzrinne, H., Camarillo, G., Johnston, A.,\n        Peterson,
    J., Sparks, R., Handley, M., and E. Schooler, \"SIP:\n        Session Initiation
    Protocol\", RFC 3261, June 2002.\n"
  title: 9.  Normative References
- contents:
  - "10.  Informative References\n   [5]  Rosenberg, J., \"A Presence Event Package
    for the Session\n        Initiation Protocol (SIP)\", RFC 3856, July 2004.\n"
  title: 10.  Informative References
- contents:
  - "11.  Author's Address\n   Jonathan Rosenberg\n   dynamicsoft\n   600 Lanidex
    Plaza\n   Parsippany, NJ 07054\n   EMail: jdrosen@dynamicsoft.com\n"
  title: 11.  Author's Address
- contents:
  - "12. Full Copyright Statement\n   Copyright (C) The Internet Society (2004).  This
    document is subject\n   to the rights, licenses and restrictions contained in
    BCP 78, and\n   except as set forth therein, the authors retain all their rights.\n
    \  This document and the information contained herein are provided on an\n   \"AS
    IS\" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS\n   OR IS SPONSORED
    BY (IF ANY), THE INTERNET SOCIETY AND THE INTERNET\n   ENGINEERING TASK FORCE
    DISCLAIM ALL WARRANTIES, EXPRESS OR IMPLIED,\n   INCLUDING BUT NOT LIMITED TO
    ANY WARRANTY THAT THE USE OF THE\n   INFORMATION HEREIN WILL NOT INFRINGE ANY
    RIGHTS OR ANY IMPLIED\n   WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR
    PURPOSE.\n"
  title: 12. Full Copyright Statement
- contents:
  - "Intellectual Property\n   The IETF takes no position regarding the validity or
    scope of any\n   Intellectual Property Rights or other rights that might be claimed
    to\n   pertain to the implementation or use of the technology described in\n   this
    document or the extent to which any license under such rights\n   might or might
    not be available; nor does it represent that it has\n   made any independent effort
    to identify any such rights.  Information\n   on the procedures with respect to
    rights in RFC documents can be\n   found in BCP 78 and BCP 79.\n   Copies of IPR
    disclosures made to the IETF Secretariat and any\n   assurances of licenses to
    be made available, or the result of an\n   attempt made to obtain a general license
    or permission for the use of\n   such proprietary rights by implementers or users
    of this\n   specification can be obtained from the IETF on-line IPR repository
    at\n   http://www.ietf.org/ipr.\n   The IETF invites any interested party to bring
    to its attention any\n   copyrights, patents or patent applications, or other
    proprietary\n   rights that may cover technology that may be required to implement\n
    \  this standard.  Please address the information to the IETF at ietf-\n   ipr@ietf.org.\n"
  title: Intellectual Property
- contents:
  - "Acknowledgement\n   Funding for the RFC Editor function is currently provided
    by the\n   Internet Society.\n"
  title: Acknowledgement
