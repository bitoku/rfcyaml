- title: __initial_text__
  contents:
  - "        STUN - Simple Traversal of User Datagram Protocol (UDP)\n           \
    \    Through Network Address Translators (NATs)\n"
- title: Status of this Memo
  contents:
  - "Status of this Memo\n   This document specifies an Internet standards track protocol\
    \ for the\n   Internet community, and requests discussion and suggestions for\n\
    \   improvements.  Please refer to the current edition of the \"Internet\n   Official\
    \ Protocol Standards\" (STD 1) for the standardization state\n   and status of\
    \ this protocol.  Distribution of this memo is unlimited.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (C) The Internet Society (2003).  All Rights Reserved.\n"
- title: Abstract
  contents:
  - "Abstract\n   Simple Traversal of User Datagram Protocol (UDP) Through Network\n\
    \   Address Translators (NATs) (STUN) is a lightweight protocol that\n   allows\
    \ applications to discover the presence and types of NATs and\n   firewalls between\
    \ them and the public Internet.  It also provides the\n   ability for applications\
    \ to determine the public Internet Protocol\n   (IP) addresses allocated to them\
    \ by the NAT.  STUN works with many\n   existing NATs, and does not require any\
    \ special behavior from them.\n   As a result, it allows a wide variety of applications\
    \ to work through\n   existing NAT infrastructure.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1.   Applicability Statement ...................................\
    \    3\n   2.   Introduction ..............................................  \
    \  3\n   3.   Terminology ...............................................    4\n\
    \   4.   Definitions ...............................................    5\n  \
    \ 5.   NAT Variations ............................................    5\n   6.\
    \   Overview of Operation .....................................    6\n   7.  \
    \ Message Overview ..........................................    8\n   8.   Server\
    \ Behavior ...........................................   10\n        8.1   Binding\
    \ Requests ....................................   10\n        8.2   Shared Secret\
    \ Requests ..............................   13\n   9.   Client Behavior ...........................................\
    \   14\n        9.1   Discovery ...........................................  \
    \ 15\n        9.2   Obtaining a Shared Secret ...........................   15\n\
    \        9.3   Formulating the Binding Request .....................   17\n  \
    \      9.4   Processing Binding Responses ........................   17\n   10.\
    \  Use Cases .................................................   19\n        10.1\
    \  Discovery Process ...................................   19\n        10.2  Binding\
    \ Lifetime Discovery ..........................   21\n        10.3  Binding Acquisition\
    \ .................................   23\n   11.  Protocol Details ..........................................\
    \   24\n        11.1  Message Header ......................................  \
    \ 25\n        11.2  Message Attributes ..................................   26\n\
    \              11.2.1  MAPPED-ADDRESS ..............................   27\n  \
    \            11.2.2  RESPONSE-ADDRESS ............................   27\n    \
    \          11.2.3  CHANGED-ADDRESS .............................   28\n      \
    \        11.2.4  CHANGE-REQUEST ..............................   28\n        \
    \      11.2.5  SOURCE-ADDRESS ..............................   28\n          \
    \    11.2.6  USERNAME ....................................   28\n            \
    \  11.2.7  PASSWORD ....................................   29\n              11.2.8\
    \  MESSAGE-INTEGRITY ...........................   29\n              11.2.9  ERROR-CODE\
    \ ..................................   29\n              11.2.10 UNKNOWN-ATTRIBUTES\
    \ ..........................   31\n              11.2.11 REFLECTED-FROM ..............................\
    \   31\n   12.  Security Considerations ...................................  \
    \ 31\n        12.1  Attacks on STUN .....................................   31\n\
    \              12.1.1  Attack I: DDOS Against a Target .............   32\n  \
    \            12.1.2  Attack II: Silencing a Client ...............   32\n    \
    \          12.1.3  Attack III: Assuming the Identity of a Client   32\n      \
    \        12.1.4  Attack IV: Eavesdropping ....................   33\n        12.2\
    \  Launching the Attacks ...............................   33\n              12.2.1\
    \  Approach I: Compromise a Legitimate\n                      STUN Server .................................\
    \   33\n              12.2.2  Approach II: DNS Attacks ....................  \
    \ 34\n              12.2.3  Approach III: Rogue Router or NAT ...........   34\n\
    \              12.2.4  Approach IV: MITM ...........................   35\n  \
    \            12.2.5  Approach V: Response Injection Plus DoS .....   35\n    \
    \          12.2.6  Approach VI: Duplication ....................   35\n      \
    \  12.3  Countermeasures .....................................   36\n        12.4\
    \  Residual Threats ....................................   37\n   13.  IANA Considerations\
    \ .......................................   38\n   14.  IAB Considerations ........................................\
    \   38\n        14.1  Problem Definition ..................................  \
    \ 38\n        14.2  Exit Strategy .......................................   39\n\
    \        14.3  Brittleness Introduced by STUN ......................   40\n  \
    \      14.4  Requirements for a Long Term Solution ...............   42\n    \
    \    14.5  Issues with Existing NAPT Boxes .....................   43\n      \
    \  14.6  In Closing ..........................................   43\n   15.  Acknowledgments\
    \ ...........................................   44\n   16.  Normative References\
    \ ......................................   44\n   17.  Informative References\
    \ ....................................   44\n   18.  Authors' Addresses ........................................\
    \   46\n   19.  Full Copyright Statement...................................  \
    \ 47\n"
- title: 1.  Applicability Statement
  contents:
  - "1.  Applicability Statement\n   This protocol is not a cure-all for the problems\
    \ associated with NAT.\n   It does not enable incoming TCP connections through\
    \ NAT.  It allows\n   incoming UDP packets through NAT, but only through a subset\
    \ of\n   existing NAT types.  In particular, STUN does not enable incoming UDP\n\
    \   packets through symmetric NATs (defined below), which are common in\n   large\
    \ enterprises.  STUN's discovery procedures are based on\n   assumptions on NAT\
    \ treatment of UDP; such assumptions may prove\n   invalid down the road as new\
    \ NAT devices are deployed.  STUN does not\n   work when it is used to obtain\
    \ an address to communicate with a peer\n   which happens to be behind the same\
    \ NAT.  STUN does not work when the\n   STUN server is not in a common shared\
    \ address realm.  For a more\n   complete discussion of the limitations of STUN,\
    \ see Section 14.\n"
- title: 2.  Introduction
  contents:
  - "2.  Introduction\n   Network Address Translators (NATs), while providing many\
    \ benefits,\n   also come with many drawbacks.  The most troublesome of those\n\
    \   drawbacks is the fact that they break many existing IP applications,\n   and\
    \ make it difficult to deploy new ones.  Guidelines have been\n   developed [8]\
    \ that describe how to build \"NAT friendly\" protocols,\n   but many protocols\
    \ simply cannot be constructed according to those\n   guidelines.  Examples of\
    \ such protocols include almost all peer-to-\n   peer protocols, such as multimedia\
    \ communications, file sharing and\n   games.\n   To combat this problem, Application\
    \ Layer Gateways (ALGs) have been\n   embedded in NATs.  ALGs perform the application\
    \ layer functions\n   required for a particular protocol to traverse a NAT.  Typically,\n\
    \   this involves rewriting application layer messages to contain\n   translated\
    \ addresses, rather than the ones inserted by the sender of\n   the message. \
    \ ALGs have serious limitations, including scalability,\n   reliability, and speed\
    \ of deploying new applications.  To resolve\n   these problems, the Middlebox\
    \ Communications (MIDCOM) protocol is\n   being developed [9].  MIDCOM allows\
    \ an application entity, such as an\n   end client or network server of some sort\
    \ (like a Session Initiation\n   Protocol (SIP) proxy [10]) to control a NAT (or\
    \ firewall), in order\n   to obtain NAT bindings and open or close pinholes. \
    \ In this way, NATs\n   and applications can be separated once more, eliminating\
    \ the need for\n   embedding ALGs in NATs, and resolving the limitations imposed\
    \ by\n   current architectures.\n   Unfortunately, MIDCOM requires upgrades to\
    \ existing NAT and\n   firewalls, in addition to application components.  Complete\
    \ upgrades\n   of these NAT and firewall products will take a long time, potentially\n\
    \   years.  This is due, in part, to the fact that the deployers of NAT\n   and\
    \ firewalls are not the same people who are deploying and using\n   applications.\
    \  As a result, the incentive to upgrade these devices\n   will be low in many\
    \ cases.  Consider, for example, an airport\n   Internet lounge that provides\
    \ access with a NAT.  A user connecting\n   to the NATed network may wish to use\
    \ a peer-to-peer service, but\n   cannot, because the NAT doesn't support it.\
    \  Since the administrators\n   of the lounge are not the ones providing the service,\
    \ they are not\n   motivated to upgrade their NAT equipment to support it, using\
    \ either\n   an ALG, or MIDCOM.\n   Another problem is that the MIDCOM protocol\
    \ requires that the agent\n   controlling the middleboxes know the identity of\
    \ those middleboxes,\n   and have a relationship with them which permits control.\
    \  In many\n   configurations, this will not be possible.  For example, many cable\n\
    \   access providers use NAT in front of their entire access network.\n   This\
    \ NAT could be in addition to a residential NAT purchased and\n   operated by\
    \ the end user.  The end user will probably not have a\n   control relationship\
    \ with the NAT in the cable access network, and\n   may not even know of its existence.\n\
    \   Many existing proprietary protocols, such as those for online games\n   (such\
    \ as the games described in RFC 3027 [11]) and Voice over IP,\n   have developed\
    \ tricks that allow them to operate through NATs without\n   changing those NATs.\
    \  This document is an attempt to take some of\n   those ideas, and codify them\
    \ into an interoperable protocol that can\n   meet the needs of many applications.\n\
    \   The protocol described here, Simple Traversal of UDP Through NAT\n   (STUN),\
    \ allows entities behind a NAT to first discover the presence\n   of a NAT and\
    \ the type of NAT, and then to learn the addresses\n   bindings allocated by the\
    \ NAT.  STUN requires no changes to NATs, and\n   works with an arbitrary number\
    \ of NATs in tandem between the\n   application entity and the public Internet.\n"
- title: 3.  Terminology
  contents:
  - "3.  Terminology\n   In this document, the key words \"MUST\", \"MUST NOT\", \"\
    REQUIRED\",\n   \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\"\
    , \"MAY\",\n   and \"OPTIONAL\" are to be interpreted as described in BCP 14,\
    \ RFC 2119\n   [1] and indicate requirement levels for compliant STUN\n   implementations.\n"
- title: 4.  Definitions
  contents:
  - "4.  Definitions\n   STUN Client: A STUN client (also just referred to as a client)\n\
    \      is an entity that generates STUN requests.  A STUN client can\n      execute\
    \ on an end system, such as a user's PC, or can run in a\n      network element,\
    \ such as a conferencing server.\n   STUN Server: A STUN Server (also just referred\
    \ to as a server)\n      is an entity that receives STUN requests, and sends STUN\n\
    \      responses.  STUN servers are generally attached to the public\n      Internet.\n"
- title: 5.  NAT Variations
  contents:
  - "5.  NAT Variations\n   It is assumed that the reader is familiar with NATs. \
    \ It has been\n   observed that NAT treatment of UDP varies among implementations.\
    \  The\n   four treatments observed in implementations are:\n   Full Cone: A full\
    \ cone NAT is one where all requests from the\n      same internal IP address\
    \ and port are mapped to the same external\n      IP address and port.  Furthermore,\
    \ any external host can send a\n      packet to the internal host, by sending\
    \ a packet to the mapped\n      external address.\n   Restricted Cone: A restricted\
    \ cone NAT is one where all requests\n      from the same internal IP address\
    \ and port are mapped to the same\n      external IP address and port.  Unlike\
    \ a full cone NAT, an external\n      host (with IP address X) can send a packet\
    \ to the internal host\n      only if the internal host had previously sent a\
    \ packet to IP\n      address X.\n   Port Restricted Cone: A port restricted cone\
    \ NAT is like a\n      restricted cone NAT, but the restriction includes port\
    \ numbers.\n      Specifically, an external host can send a packet, with source\
    \ IP\n      address X and source port P, to the internal host only if the\n  \
    \    internal host had previously sent a packet to IP address X and\n      port\
    \ P.\n   Symmetric: A symmetric NAT is one where all requests from the\n     \
    \ same internal IP address and port, to a specific destination IP\n      address\
    \ and port, are mapped to the same external IP address and\n      port.  If the\
    \ same host sends a packet with the same source\n      address and port, but to\
    \ a different destination, a different\n      mapping is used.  Furthermore, only\
    \ the external host that\n      receives a packet can send a UDP packet back to\
    \ the internal host.\n   Determining the type of NAT is important in many cases.\
    \  Depending on\n   what the application wants to do, it may need to take the\
    \ particular\n   behavior into account.\n"
- title: 6.  Overview of Operation
  contents:
  - "6.  Overview of Operation\n   This section is descriptive only.  Normative behavior\
    \ is described in\n   Sections 8 and 9.\n                            /-----\\\n\
    \                          // STUN  \\\\\n                         |   Server\
    \  |\n                          \\\\       //\n                            \\\
    -----/\n                       +--------------+             Public Internet\n\
    \       ................|     NAT 2    |.......................\n            \
    \           +--------------+\n                       +--------------+        \
    \     Private NET 2\n       ................|     NAT 1    |.......................\n\
    \                       +--------------+\n                            /-----\\\
    \n                          // STUN  \\\\\n                         |   Client\
    \  |\n                          \\\\       //               Private NET 1\n  \
    \                          \\-----/\n                     Figure 1: STUN Configuration\n\
    \   The typical STUN configuration is shown in Figure 1.  A STUN client\n   is\
    \ connected to private network 1.  This network connects to private\n   network\
    \ 2 through NAT 1.  Private network 2 connects to the public\n   Internet through\
    \ NAT 2.  The STUN server resides on the public\n   Internet.\n   STUN is a simple\
    \ client-server protocol.  A client sends a request to\n   a server, and the server\
    \ returns a response.  There are two types of\n   requests - Binding Requests,\
    \ sent over UDP, and Shared Secret\n   Requests, sent over TLS [2] over TCP. \
    \ Shared Secret Requests ask the\n   server to return a temporary username and\
    \ password.  This username\n   and password are used in a subsequent Binding Request\
    \ and Binding\n   Response, for the purposes of authentication and message integrity.\n\
    \   Binding requests are used to determine the bindings allocated by\n   NATs.\
    \  The client sends a Binding Request to the server, over UDP.\n   The server\
    \ examines the source IP address and port of the request,\n   and copies them\
    \ into a response that is sent back to the client.\n   There are some parameters\
    \ in the request that allow the client to ask\n   that the response be sent elsewhere,\
    \ or that the server send the\n   response from a different address and port.\
    \  There are attributes for\n   providing message integrity and authentication.\n\
    \   The trick is using STUN to discover the presence of NAT, and to learn\n  \
    \ and use the bindings they allocate.\n   The STUN client is typically embedded\
    \ in an application which needs\n   to obtain a public IP address and port that\
    \ can be used to receive\n   data.  For example, it might need to obtain an IP\
    \ address and port to\n   receive Real Time Transport Protocol (RTP) [12] traffic.\
    \  When the\n   application starts, the STUN client within the application sends\
    \ a\n   STUN Shared Secret Request to its server, obtains a username and\n   password,\
    \ and then sends it a Binding Request.  STUN servers can be\n   discovered through\
    \ DNS SRV records [3], and it is generally assumed\n   that the client is configured\
    \ with the domain to use to find the STUN\n   server.  Generally, this will be\
    \ the domain of the provider of the\n   service the application is using (such\
    \ a provider is incented to\n   deploy STUN servers in order to allow its customers\
    \ to use its\n   application through NAT).  Of course, a client can determine\
    \ the\n   address or domain name of a STUN server through other means.  A STUN\n\
    \   server can even be embedded within an end system.\n   The STUN Binding Request\
    \ is used to discover the presence of a NAT,\n   and to discover the public IP\
    \ address and port mappings generated by\n   the NAT.  Binding Requests are sent\
    \ to the STUN server using UDP.\n   When a Binding Request arrives at the STUN\
    \ server, it may have passed\n   through one or more NATs between the STUN client\
    \ and the STUN server.\n   As a result, the source address of the request received\
    \ by the server\n   will be the mapped address created by the NAT closest to the\
    \ server.\n   The STUN server copies that source IP address and port into a STUN\n\
    \   Binding Response, and sends it back to the source IP address and port\n  \
    \ of the STUN request.  For all of the NAT types above, this response\n   will\
    \ arrive at the STUN client.\n   When the STUN client receives the STUN Binding\
    \ Response, it compares\n   the IP address and port in the packet with the local\
    \ IP address and\n   port it bound to when the request was sent.  If these do\
    \ not match,\n   the STUN client is behind one or more NATs.  In the case of a\
    \ full-\n   cone NAT, the IP address and port in the body of the STUN response\n\
    \   are public, and can be used by any host on the public Internet to\n   send\
    \ packets to the application that sent the STUN request.  An\n   application need\
    \ only listen on the IP address and port from which\n   the STUN request was sent.\
    \ Any packets sent by a host on the public\n   Internet to the public address\
    \ and port learned by STUN will be\n   received by the application.\n   Of course,\
    \ the host may not be behind a full-cone NAT.  Indeed, it\n   doesn't yet know\
    \ what type of NAT it is behind.  To determine that,\n   the client uses additional\
    \ STUN Binding Requests.  The exact\n   procedure is flexible, but would generally\
    \ work as follows.  The\n   client would send a second STUN Binding Request, this\
    \ time to a\n   different IP address, but from the same source IP address and\
    \ port.\n   If the IP address and port in the response are different from those\n\
    \   in the first response, the client knows it is behind a symmetric NAT.\n  \
    \ To determine if it's behind a full-cone NAT, the client can send a\n   STUN\
    \ Binding Request with flags that tell the STUN server to send a\n   response\
    \ from a different IP address and port than the request was\n   received on. \
    \ In other words, if the client sent a Binding Request to\n   IP address/port\
    \ A/B using a source IP address/port of X/Y, the STUN\n   server would send the\
    \ Binding Response to X/Y using source IP\n   address/port C/D.  If the client\
    \ receives this response, it knows it\n   is behind a full cone NAT.\n   STUN\
    \ also allows the client to ask the server to send the Binding\n   Response from\
    \ the same IP address the request was received on, but\n   with a different port.\
    \  This can be used to detect whether the client\n   is behind a port restricted\
    \ cone NAT or just a restricted cone NAT.\n   It should be noted that the configuration\
    \ in Figure 1 is not the only\n   permissible configuration.  The STUN server\
    \ can be located anywhere,\n   including within another client.  The only requirement\
    \ is that the\n   STUN server is reachable by the client, and if the client is\
    \ trying\n   to obtain a publicly routable address, that the server reside on\
    \ the\n   public Internet.\n"
- title: 7.  Message Overview
  contents:
  - "7.  Message Overview\n   STUN messages are TLV (type-length-value) encoded using\
    \ big endian\n   (network ordered) binary.  All STUN messages start with a STUN\n\
    \   header, followed by a STUN payload.  The payload is a series of STUN\n   attributes,\
    \ the set of which depends on the message type.  The STUN\n   header contains\
    \ a STUN message type, transaction ID, and length.  The\n   message type can be\
    \ Binding Request, Binding Response, Binding Error\n   Response, Shared Secret\
    \ Request, Shared Secret Response, or Shared\n   Secret Error Response.  The transaction\
    \ ID is used to correlate\n   requests and responses.  The length indicates the\
    \ total length of the\n   STUN payload, not including the header.  This allows\
    \ STUN to run over\n   TCP.  Shared Secret Requests are always sent over TCP (indeed,\
    \ using\n   TLS over TCP).\n   Several STUN attributes are defined.  The first\
    \ is a MAPPED-ADDRESS\n   attribute, which is an IP address and port.  It is always\
    \ placed in\n   the Binding Response, and it indicates the source IP address and\
    \ port\n   the server saw in the Binding Request.  There is also a RESPONSE-\n\
    \   ADDRESS attribute, which contains an IP address and port.  The\n   RESPONSE-ADDRESS\
    \ attribute can be present in the Binding Request, and\n   indicates where the\
    \ Binding Response is to be sent.  It's optional,\n   and when not present, the\
    \ Binding Response is sent to the source IP\n   address and port of the Binding\
    \ Request.\n   The third attribute is the CHANGE-REQUEST attribute, and it contains\n\
    \   two flags to control the IP address and port used to send the\n   response.\
    \  These flags are called \"change IP\" and \"change port\"\n   flags.  The CHANGE-REQUEST\
    \ attribute is allowed only in the Binding\n   Request.  The \"change IP\" and\
    \ \"change port\" flags are useful for\n   determining whether the client is behind\
    \ a restricted cone NAT or\n   restricted port cone NAT.  They instruct the server\
    \ to send the\n   Binding Responses from a different source IP address and port.\
    \  The\n   CHANGE-REQUEST attribute is optional in the Binding Request.\n   The\
    \ fourth attribute is the CHANGED-ADDRESS attribute.  It is present\n   in Binding\
    \ Responses.  It informs the client of the source IP address\n   and port that\
    \ would be used if the client requested the \"change IP\"\n   and \"change port\"\
    \ behavior.\n   The fifth attribute is the SOURCE-ADDRESS attribute.  It is only\n\
    \   present in Binding Responses.  It indicates the source IP address and\n  \
    \ port where the response was sent from.  It is useful for detecting\n   twice\
    \ NAT configurations.\n   The sixth attribute is the USERNAME attribute.  It is\
    \ present in a\n   Shared Secret Response, which provides the client with a temporary\n\
    \   username and password (encoded in the PASSWORD attribute).  The\n   USERNAME\
    \ is also present in Binding Requests, serving as an index to\n   the shared secret\
    \ used for the integrity protection of the Binding\n   Request.  The seventh attribute,\
    \ PASSWORD, is only found in Shared\n   Secret Response messages.  The eight attribute\
    \ is the MESSAGE-\n   INTEGRITY attribute, which contains a message integrity\
    \ check over\n   the Binding Request or Binding Response.\n   The ninth attribute\
    \ is the ERROR-CODE attribute.  This is present in\n   the Binding Error Response\
    \ and Shared Secret Error Response.  It\n   indicates the error that has occurred.\
    \  The tenth attribute is the\n   UNKNOWN-ATTRIBUTES attribute, which is present\
    \ in either the Binding\n   Error Response or Shared Secret Error Response.  It\
    \ indicates the\n   mandatory attributes from the request which were unknown.\
    \  The\n   eleventh attribute is the REFLECTED-FROM attribute, which is present\n\
    \   in Binding Responses.  It indicates the IP address and port of the\n   sender\
    \ of a Binding Request, used for traceability purposes to\n   prevent certain\
    \ denial-of-service attacks.\n"
- title: 8.  Server Behavior
  contents:
  - "8.  Server Behavior\n   The server behavior depends on whether the request is\
    \ a Binding\n   Request or a Shared Secret Request.\n"
- title: 8.1  Binding Requests
  contents:
  - "8.1  Binding Requests\n   A STUN server MUST be prepared to receive Binding Requests\
    \ on four\n   address/port combinations - (A1, P1), (A2, P1), (A1, P2), and (A2,\n\
    \   P2).  (A1, P1) represent the primary address and port, and these are\n   the\
    \ ones obtained through the client discovery procedures below.\n   Typically,\
    \ P1 will be port 3478, the default STUN port.  A2 and P2\n   are arbitrary. \
    \ A2 and P2 are advertised by the server through the\n   CHANGED-ADDRESS attribute,\
    \ as described below.\n   It is RECOMMENDED that the server check the Binding\
    \ Request for a\n   MESSAGE-INTEGRITY attribute.  If not present, and the server\
    \ requires\n   integrity checks on the request, it generates a Binding Error\n\
    \   Response with an ERROR-CODE attribute with response code 401.  If the\n  \
    \ MESSAGE-INTEGRITY attribute was present, the server computes the HMAC\n   over\
    \ the request as described in Section 11.2.8.  The key to use\n   depends on the\
    \ shared secret mechanism.  If the STUN Shared Secret\n   Request was used, the\
    \ key MUST be the one associated with the\n   USERNAME attribute present in the\
    \ request.  If the USERNAME attribute\n   was not present, the server MUST generate\
    \ a Binding Error Response.\n   The Binding Error Response MUST include an ERROR-CODE\
    \ attribute with\n   response code 432.  If the USERNAME is present, but the server\n\
    \   doesn't remember the shared secret for that USERNAME (because it\n   timed\
    \ out, for example), the server MUST generate a Binding Error\n   Response.  The\
    \ Binding Error Response MUST include an ERROR-CODE\n   attribute with response\
    \ code 430.  If the server does know the shared\n   secret, but the computed HMAC\
    \ differs from the one in the request,\n   the server MUST generate a Binding\
    \ Error Response with an ERROR-CODE\n   attribute with response code 431.  The\
    \ Binding Error Response is sent\n   to the IP address and port the Binding Request\
    \ came from, and sent\n   from the IP address and port the Binding Request was\
    \ sent to.\n   Assuming the message integrity check passed, processing continues.\n\
    \   The server MUST check for any attributes in the request with values\n   less\
    \ than or equal to 0x7fff which it does not understand.  If it\n   encounters\
    \ any, the server MUST generate a Binding Error Response,\n   and it MUST include\
    \ an ERROR-CODE attribute with a 420 response code.\n   That response MUST contain\
    \ an UNKNOWN-ATTRIBUTES attribute listing\n   the attributes with values less\
    \ than or equal to 0x7fff which were\n   not understood.  The Binding Error Response\
    \ is sent to the IP address\n   and port the Binding Request came from, and sent\
    \ from the IP address\n   and port the Binding Request was sent to.\n   Assuming\
    \ the request was correctly formed, the server MUST generate a\n   single Binding\
    \ Response.  The Binding Response MUST contain the same\n   transaction ID contained\
    \ in the Binding Request.  The length in the\n   message header MUST contain the\
    \ total length of the message in bytes,\n   excluding the header.  The Binding\
    \ Response MUST have a message type\n   of \"Binding Response\".\n   The server\
    \ MUST add a MAPPED-ADDRESS attribute to the Binding\n   Response.  The IP address\
    \ component of this attribute MUST be set to\n   the source IP address observed\
    \ in the Binding Request.  The port\n   component of this attribute MUST be set\
    \ to the source port observed\n   in the Binding Request.\n   If the RESPONSE-ADDRESS\
    \ attribute was absent from the Binding\n   Request, the destination address and\
    \ port of the Binding Response\n   MUST be the same as the source address and\
    \ port of the Binding\n   Request.  Otherwise, the destination address and port\
    \ of the Binding\n   Response MUST be the value of the IP address and port in\
    \ the\n   RESPONSE-ADDRESS attribute.\n   The source address and port of the Binding\
    \ Response depend on the\n   value of the CHANGE-REQUEST attribute and on the\
    \ address and port the\n   Binding Request was received on, and are summarized\
    \ in Table 1.\n   Let Da represent the destination IP address of the Binding Request\n\
    \   (which will be either A1 or A2), and Dp represent the destination\n   port\
    \ of the Binding Request (which will be either P1 or P2).  Let Ca\n   represent\
    \ the other address, so that if Da is A1, Ca is A2.  If Da is\n   A2, Ca is A1.\
    \  Similarly, let Cp represent the other port, so that if\n   Dp is P1, Cp is\
    \ P2.  If Dp is P2, Cp is P1.  If the \"change port\"\n   flag was set in CHANGE-REQUEST\
    \ attribute of the Binding Request, and\n   the \"change IP\" flag was not set,\
    \ the source IP address of the\n   Binding Response MUST be Da and the source\
    \ port of the Binding\n   Response MUST be Cp.  If the \"change IP\" flag was\
    \ set in the Binding\n   Request, and the \"change port\" flag was not set, the\
    \ source IP\n   address of the Binding Response MUST be Ca and the source port\
    \ of the\n   Binding Response MUST be Dp.  When both flags are set, the source\
    \ IP\n   address of the Binding Response MUST be Ca and the source port of the\n\
    \   Binding Response MUST be Cp.  If neither flag is set, or if the\n   CHANGE-REQUEST\
    \ attribute is absent entirely, the source IP address of\n   the Binding Response\
    \ MUST be Da and the source port of the Binding\n   Response MUST be Dp.\n   \
    \   Flags          Source Address  Source Port   CHANGED-ADDRESS\n      none \
    \          Da              Dp            Ca:Cp\n      Change IP      Ca      \
    \        Dp            Ca:Cp\n      Change port    Da              Cp        \
    \    Ca:Cp\n      Change IP and\n        Change port  Ca              Cp     \
    \       Ca:Cp\n   Table 1: Impact of Flags on Packet Source and CHANGED-ADDRESS\n\
    \   The server MUST add a SOURCE-ADDRESS attribute to the Binding\n   Response,\
    \ containing the source address and port used to send the\n   Binding Response.\n\
    \   The server MUST add a CHANGED-ADDRESS attribute to the Binding\n   Response.\
    \  This contains the source IP address and port that would be\n   used if the\
    \ client had set the \"change IP\" and \"change port\" flags in\n   the Binding\
    \ Request.  As summarized in Table 1, these are Ca and Cp,\n   respectively, regardless\
    \ of the value of the CHANGE-REQUEST flags.\n   If the Binding Request contained\
    \ both the USERNAME and MESSAGE-\n   INTEGRITY attributes, the server MUST add\
    \ a MESSAGE-INTEGRITY\n   attribute to the Binding Response.  The attribute contains\
    \ an HMAC\n   [13] over the response, as described in Section 11.2.8.  The key\
    \ to\n   use depends on the shared secret mechanism.  If the STUN Shared\n   Secret\
    \ Request was used, the key MUST be the one associated with the\n   USERNAME attribute\
    \ present in the Binding Request.\n   If the Binding Request contained a RESPONSE-ADDRESS\
    \ attribute, the\n   server MUST add a REFLECTED-FROM attribute to the response.\
    \  If the\n   Binding Request was authenticated using a username obtained from\
    \ a\n   Shared Secret Request, the REFLECTED-FROM attribute MUST contain the\n\
    \   source IP address and port where that Shared Secret Request came\n   from.\
    \  If the username present in the request was not allocated using\n   a Shared\
    \ Secret Request, the REFLECTED-FROM attribute MUST contain\n   the source address\
    \ and port of the entity which obtained the\n   username, as best can be verified\
    \ with the mechanism used to allocate\n   the username.  If the username was not\
    \ present in the request, and\n   the server was willing to process the request,\
    \ the REFLECTED-FROM\n   attribute SHOULD contain the source IP address and port\
    \ where the\n   request came from.\n   The server SHOULD NOT retransmit the response.\
    \  Reliability is\n   achieved by having the client periodically resend the request,\
    \ each\n   of which triggers a response from the server.\n"
- title: 8.2 Shared Secret Requests
  contents:
  - "8.2 Shared Secret Requests\n   Shared Secret Requests are always received on\
    \ TLS connections.  When\n   the server receives a request from the client to\
    \ establish a TLS\n   connection, it MUST proceed with TLS, and SHOULD present\
    \ a site\n   certificate.  The TLS ciphersuite TLS_RSA_WITH_AES_128_CBC_SHA [4]\n\
    \   SHOULD be used.  Client TLS authentication MUST NOT be done, since\n   the\
    \ server is not allocating any resources to clients, and the\n   computational\
    \ burden can be a source of attacks.\n   If the server receives a Shared Secret\
    \ Request, it MUST verify that\n   the request arrived on a TLS connection.  If\
    \ it did not receive the\n   request over TLS, it MUST generate a Shared Secret\
    \ Error Response,\n   and it MUST include an ERROR-CODE attribute with a 433 response\
    \ code.\n   The destination for the error response depends on the transport on\n\
    \   which the request was received.  If the Shared Secret Request was\n   received\
    \ over TCP, the Shared Secret Error Response is sent over the\n   same connection\
    \ the request was received on.  If the Shared Secret\n   Request was receive over\
    \ UDP, the Shared Secret Error Response is\n   sent to the source IP address and\
    \ port that the request came from.\n   The server MUST check for any attributes\
    \ in the request with values\n   less than or equal to 0x7fff which it does not\
    \ understand.  If it\n   encounters any, the server MUST generate a Shared Secret\
    \ Error\n   Response, and it MUST include an ERROR-CODE attribute with a 420\n\
    \   response code.  That response MUST contain an UNKNOWN-ATTRIBUTES\n   attribute\
    \ listing the attributes with values less than or equal to\n   0x7fff which were\
    \ not understood.  The Shared Secret Error Response\n   is sent over the TLS connection.\n\
    \   All Shared Secret Error Responses MUST contain the same transaction\n   ID\
    \ contained in the Shared Secret Request. The length in the message\n   header\
    \ MUST contain the total length of the message in bytes,\n   excluding the header.\
    \  The Shared Secret Error Response MUST have a\n   message type of \"Shared Secret\
    \ Error Response\" (0x0112).\n   Assuming the request was properly constructed,\
    \ the server creates a\n   Shared Secret Response.  The Shared Secret Response\
    \ MUST contain the\n   same transaction ID contained in the Shared Secret Request.\
    \  The\n   length in the message header MUST contain the total length of the\n\
    \   message in bytes, excluding the header.  The Shared Secret Response\n   MUST\
    \ have a message type of \"Shared Secret Response\".  The Shared\n   Secret Response\
    \ MUST contain a USERNAME attribute and a PASSWORD\n   attribute.  The USERNAME\
    \ attribute serves as an index to the\n   password, which is contained in the\
    \ PASSWORD attribute.  The server\n   can use any mechanism it chooses to generate\
    \ the username.  However,\n   the username MUST be valid for a period of at least\
    \ 10 minutes.\n   Validity means that the server can compute the password for\
    \ that\n   username.  There MUST be a single password for each username.  In\n\
    \   other words, the server cannot, 10 minutes later, assign a different\n   password\
    \ to the same username.  The server MUST hand out a different\n   username for\
    \ each distinct Shared Secret Request.  Distinct, in this\n   case, implies a\
    \ different transaction ID.  It is RECOMMENDED that the\n   server explicitly\
    \ invalidate the username after ten minutes.  It MUST\n   invalidate the username\
    \ after 30 minutes.  The PASSWORD contains the\n   password bound to that username.\
    \  The password MUST have at least 128\n   bits.  The likelihood that the server\
    \ assigns the same password for\n   two different usernames MUST be vanishingly\
    \ small, and the passwords\n   MUST be unguessable.  In other words, they MUST\
    \ be a\n   cryptographically random function of the username.\n   These requirements\
    \ can still be met using a stateless server, by\n   intelligently computing the\
    \ USERNAME and PASSWORD.  One approach is\n   to construct the USERNAME as:\n\
    \      USERNAME = <prefix,rounded-time,clientIP,hmac>\n   Where prefix is some\
    \ random text string (different for each shared\n   secret request), rounded-time\
    \ is the current time modulo 20 minutes,\n   clientIP is the source IP address\
    \ where the Shared Secret Request\n   came from, and hmac is an HMAC [13] over\
    \ the prefix, rounded-time,\n   and client IP, using a server private key.\n \
    \  The password is then computed as:\n      password = <hmac(USERNAME,anotherprivatekey)>\n\
    \   With this structure, the username itself, which will be present in\n   the\
    \ Binding Request, contains the source IP address where the Shared\n   Secret\
    \ Request came from.  That allows the server to meet the\n   requirements specified\
    \ in Section 8.1 for constructing the\n   REFLECTED-FROM attribute.  The server\
    \ can verify that the username\n   was not tampered with, using the hmac present\
    \ in the username.\n   The Shared Secret Response is sent over the same TLS connection\
    \ the\n   request was received on.  The server SHOULD keep the connection open,\n\
    \   and let the client close it.\n"
- title: 9.  Client Behavior
  contents:
  - "9.  Client Behavior\n   The behavior of the client is very straightforward. \
    \ Its task is to\n   discover the STUN server, obtain a shared secret, formulate\
    \ the\n   Binding Request, handle request reliability, and process the Binding\n\
    \   Responses.\n"
- title: 9.1  Discovery
  contents:
  - "9.1  Discovery\n   Generally, the client will be configured with a domain name\
    \ of the\n   provider of the STUN servers.  This domain name is resolved to an\
    \ IP\n   address and port using the SRV procedures specified in RFC 2782 [3].\n\
    \   Specifically, the service name is \"stun\".  The protocol is \"udp\" for\n\
    \   sending Binding Requests, or \"tcp\" for sending Shared Secret\n   Requests.\
    \  The procedures of RFC 2782 are followed to determine the\n   server to contact.\
    \  RFC 2782 spells out the details of how a set of\n   SRV records are sorted\
    \ and then tried.  However, it only states that\n   the client should \"try to\
    \ connect to the (protocol, address,\n   service)\" without giving any details\
    \ on what happens in the event of\n   failure.  Those details are described here\
    \ for STUN.\n   For STUN requests, failure occurs if there is a transport failure\
    \ of\n   some sort (generally, due to fatal ICMP errors in UDP or connection\n\
    \   failures in TCP).  Failure also occurs if the transaction fails due\n   to\
    \ timeout.  This occurs 9.5 seconds after the first request is sent,\n   for both\
    \ Shared Secret Requests and Binding Requests.  See Section\n   9.3 for details\
    \ on transaction timeouts for Binding Requests.  If a\n   failure occurs, the\
    \ client SHOULD create a new request, which is\n   identical to the previous,\
    \ but has a different transaction ID and\n   MESSAGE INTEGRITY attribute (the\
    \ HMAC will change because the\n   transaction ID has changed).  That request\
    \ is sent to the next\n   element in the list as specified by RFC 2782.\n   The\
    \ default port for STUN requests is 3478, for both TCP and UDP.\n   Administrators\
    \ SHOULD use this port in their SRV records, but MAY use\n   others.\n   If no\
    \ SRV records were found, the client performs an A record lookup\n   of the domain\
    \ name.  The result will be a list of IP addresses, each\n   of which can be contacted\
    \ at the default port.\n   This would allow a firewall admin to open the STUN\
    \ port, so hosts\n   within the enterprise could access new applications. Whether\
    \ they\n   will or won't do this is a good question.\n"
- title: 9.2 Obtaining a Shared Secret
  contents:
  - "9.2 Obtaining a Shared Secret\n   As discussed in Section 12, there are several\
    \ attacks possible on\n   STUN systems.  Many of these are prevented through integrity\
    \ of\n   requests and responses.  To provide that integrity, STUN makes use of\n\
    \   a shared secret between client and server, used as the keying\n   material\
    \ for an HMAC used in both the Binding Request and Binding\n   Response.  STUN\
    \ allows for the shared secret to be obtained in any\n   way (for example, Kerberos\
    \ [14]).  However, it MUST have at least 128\n   bits of randomness.  In order\
    \ to ensure interoperability, this\n   specification describes a TLS-based mechanism.\
    \  This mechanism,\n   described in this section, MUST be implemented by clients\
    \ and\n   servers.\n   First, the client determines the IP address and port that\
    \ it will\n   open a TCP connection to.  This is done using the discovery\n  \
    \ procedures in Section 9.1.  The client opens up the connection to\n   that address\
    \ and port, and immediately begins TLS negotiation [2].\n   The client MUST verify\
    \ the identity of the server.  To do that, it\n   follows the identification procedures\
    \ defined in Section 3.1 of RFC\n   2818 [5]. Those procedures assume the client\
    \ is dereferencing a URI.\n   For purposes of usage with this specification, the\
    \ client treats the\n   domain name or IP address used in Section 9.1 as the host\
    \ portion of\n   the URI that has been dereferenced.\n   Once the connection is\
    \ opened, the client sends a Shared Secret\n   request.  This request has no attributes,\
    \ just the header.  The\n   transaction ID in the header MUST meet the requirements\
    \ outlined for\n   the transaction ID in a binding request, described in Section\
    \ 9.3\n   below.  The server generates a response, which can either be a Shared\n\
    \   Secret Response or a Shared Secret Error Response.\n   If the response was\
    \ a Shared Secret Error Response, the client checks\n   the response code in the\
    \ ERROR-CODE attribute.  Interpretation of\n   those response codes is identical\
    \ to the processing of Section 9.4\n   for the Binding Error Response.\n   If\
    \ a client receives a Shared Secret Response with an attribute whose\n   type\
    \ is greater than 0x7fff, the attribute MUST be ignored.  If the\n   client receives\
    \ a Shared Secret Response with an attribute whose type\n   is less than or equal\
    \ to 0x7fff, the response is ignored.\n   If the response was a Shared Secret\
    \ Response, it will contain a short\n   lived username and password, encoded in\
    \ the USERNAME and PASSWORD\n   attributes, respectively.\n   The client MAY generate\
    \ multiple Shared Secret Requests on the\n   connection, and it MAY do so before\
    \ receiving Shared Secret Responses\n   to previous Shared Secret Requests.  The\
    \ client SHOULD close the\n   connection as soon as it has finished obtaining\
    \ usernames and\n   passwords.\n   Section 9.3 describes how these passwords are\
    \ used to provide\n   integrity protection over Binding Requests, and Section\
    \ 8.1 describes\n   how it is used in Binding Responses.\n"
- title: 9.3  Formulating the Binding Request
  contents:
  - "9.3  Formulating the Binding Request\n   A Binding Request formulated by the\
    \ client follows the syntax rules\n   defined in Section 11.  Any two requests\
    \ that are not bit-wise\n   identical, and not sent to the same server from the\
    \ same IP address\n   and port, MUST carry different transaction IDs. The transaction\
    \ ID\n   MUST be uniformly and randomly distributed between 0 and 2**128 - 1.\n\
    \   The large range is needed because the transaction ID serves as a form\n  \
    \ of randomization, helping to prevent replays of previously signed\n   responses\
    \ from the server.  The message type of the request MUST be\n   \"Binding Request\"\
    .\n   The RESPONSE-ADDRESS attribute is optional in the Binding Request.\n   It\
    \ is used if the client wishes the response to be sent to a\n   different IP address\
    \ and port than the one the request was sent from.\n   This is useful for determining\
    \ whether the client is behind a\n   firewall, and for applications that have\
    \ separated control and data\n   components.  See Section 10.3 for more details.\
    \  The CHANGE-REQUEST\n   attribute is also optional.  Whether it is present depends\
    \ on what\n   the application is trying to accomplish.  See Section 10 for some\n\
    \   example uses.\n   The client SHOULD add a MESSAGE-INTEGRITY and USERNAME attribute\
    \ to\n   the Binding Request.  This MESSAGE-INTEGRITY attribute contains an\n\
    \   HMAC [13].  The value of the username, and the key to use in the\n   MESSAGE-INTEGRITY\
    \ attribute depend on the shared secret mechanism.\n   If the STUN Shared Secret\
    \ Request was used, the USERNAME must be a\n   valid username obtained from a\
    \ Shared Secret Response within the last\n   nine minutes.  The shared secret\
    \ for the HMAC is the value of the\n   PASSWORD attribute obtained from the same\
    \ Shared Secret Response.\n   Once formulated, the client sends the Binding Request.\
    \  Reliability\n   is accomplished through client retransmissions.  Clients SHOULD\n\
    \   retransmit the request starting with an interval of 100ms, doubling\n   every\
    \ retransmit until the interval reaches 1.6s.  Retransmissions\n   continue with\
    \ intervals of 1.6s until a response is received, or a\n   total of 9 requests\
    \ have been sent. If no response is received by 1.6\n   seconds after the last\
    \ request has been sent, the client SHOULD\n   consider the transaction to have\
    \ failed. In other words, requests\n   would be sent at times 0ms, 100ms, 300ms,\
    \ 700ms, 1500ms, 3100ms,\n   4700ms, 6300ms, and 7900ms. At 9500ms, the client\
    \ considers the\n   transaction to have failed if no response has been received.\n"
- title: 9.4  Processing Binding Responses
  contents:
  - "9.4  Processing Binding Responses\n   The response can either be a Binding Response\
    \ or Binding Error\n   Response.  Binding Error Responses are always received\
    \ on the source\n   address and port the request was sent from.  A Binding Response\
    \ will\n   be received on the address and port placed in the RESPONSE-ADDRESS\n\
    \   attribute of the request.  If none was present, the Binding Responses\n  \
    \ will be received on the source address and port the request was sent\n   from.\n\
    \   If the response is a Binding Error Response, the client checks the\n   response\
    \ code from the ERROR-CODE attribute of the response.  For a\n   400 response\
    \ code, the client SHOULD display the reason phrase to the\n   user.  For a 420\
    \ response code, the client SHOULD retry the request,\n   this time omitting any\
    \ attributes listed in the UNKNOWN-ATTRIBUTES\n   attribute of the response. \
    \ For a 430 response code, the client\n   SHOULD obtain a new shared secret, and\
    \ retry the Binding Request with\n   a new transaction.  For 401 and 432 response\
    \ codes, if the client had\n   omitted the USERNAME or MESSAGE-INTEGRITY attribute\
    \ as indicated by\n   the error, it SHOULD try again with those attributes.  For\
    \ a 431\n   response code, the client SHOULD alert the user, and MAY try the\n\
    \   request again after obtaining a new username and password.  For a 500\n  \
    \ response code, the client MAY wait several seconds and then retry the\n   request.\
    \  For a 600 response code, the client MUST NOT retry the\n   request, and SHOULD\
    \ display the reason phrase to the user.  Unknown\n   attributes between 400 and\
    \ 499 are treated like a 400, unknown\n   attributes between 500 and 599 are treated\
    \ like a 500, and unknown\n   attributes between 600 and 699 are treated like\
    \ a 600.  Any response\n   between 100 and 399 MUST result in the cessation of\
    \ request\n   retransmissions, but otherwise is discarded.\n   If a client receives\
    \ a response with an attribute whose type is\n   greater than 0x7fff, the attribute\
    \ MUST be ignored.  If the client\n   receives a response with an attribute whose\
    \ type is less than or\n   equal to 0x7fff, request retransmissions MUST cease,\
    \ but the entire\n   response is otherwise ignored.\n   If the response is a Binding\
    \ Response, the client SHOULD check the\n   response for a MESSAGE-INTEGRITY attribute.\
    \  If not present, and the\n   client placed a MESSAGE-INTEGRITY attribute into\
    \ the request, it MUST\n   discard the response.  If present, the client computes\
    \ the HMAC over\n   the response as described in Section 11.2.8.  The key to use\
    \ depends\n   on the shared secret mechanism.  If the STUN Shared Secret Request\n\
    \   was used, the key MUST be same as used to compute the MESSAGE-\n   INTEGRITY\
    \ attribute in the request.  If the computed HMAC differs\n   from the one in\
    \ the response, the client MUST discard the response,\n   and SHOULD alert the\
    \ user about a possible attack.  If the computed\n   HMAC matches the one from\
    \ the response, processing continues.\n   Reception of a response (either Binding\
    \ Error Response or Binding\n   Response) to a Binding Request will terminate\
    \ retransmissions of that\n   request.  However, clients MUST continue to listen\
    \ for responses to a\n   Binding Request for 10 seconds after the first response.\
    \  If it\n   receives any responses in this interval with different message types\n\
    \   (Binding Responses and Binding Error Responses, for example) or\n   different\
    \ MAPPED-ADDRESSes, it is an indication of a possible attack.\n   The client MUST\
    \ NOT use the MAPPED-ADDRESS from any of the responses\n   it received (either\
    \ the first or the additional ones), and SHOULD\n   alert the user.\n   Furthermore,\
    \ if a client receives more than twice as many Binding\n   Responses as the number\
    \ of Binding Requests it sent, it MUST NOT use\n   the MAPPED-ADDRESS from any\
    \ of those responses, and SHOULD alert the\n   user about a potential attack.\n\
    \   If the Binding Response is authenticated, and the MAPPED-ADDRESS was\n   not\
    \ discarded because of a potential attack, the CLIENT MAY use the\n   MAPPED-ADDRESS\
    \ and SOURCE-ADDRESS attributes.\n"
- title: 10.  Use Cases
  contents:
  - "10.  Use Cases\n   The rules of Sections 8 and 9 describe exactly how a client\
    \ and\n   server interact to send requests and get responses.  However, they do\n\
    \   not dictate how the STUN protocol is used to accomplish useful tasks.\n  \
    \ That is at the discretion of the client.  Here, we provide some\n   useful scenarios\
    \ for applying STUN.\n"
- title: 10.1  Discovery Process
  contents:
  - "10.1  Discovery Process\n   In this scenario, a user is running a multimedia\
    \ application which\n   needs to determine which of the following scenarios applies\
    \ to it:\n   o  On the open Internet\n   o  Firewall that blocks UDP\n   o  Firewall\
    \ that allows UDP out, and responses have to come back to\n      the source of\
    \ the request (like a symmetric NAT, but no\n      translation.  We call this\
    \ a symmetric UDP Firewall)\n   o  Full-cone NAT\n   o  Symmetric NAT\n   o  Restricted\
    \ cone or restricted port cone NAT\n   Which of the six scenarios applies can\
    \ be determined through the flow\n   chart described in Figure 2.  The chart refers\
    \ only to the sequence\n   of Binding Requests; Shared Secret Requests will, of\
    \ course, be\n   needed to authenticate each Binding Request used in the sequence.\n\
    \   The flow makes use of three tests.  In test I, the client sends a\n   STUN\
    \ Binding Request to a server, without any flags set in the\n   CHANGE-REQUEST\
    \ attribute, and without the RESPONSE-ADDRESS attribute.\n   This causes the server\
    \ to send the response back to the address and\n   port that the request came\
    \ from.  In test II, the client sends a\n   Binding Request with both the \"change\
    \ IP\" and \"change port\" flags\n   from the CHANGE-REQUEST attribute set.  In\
    \ test III, the client sends\n   a Binding Request with only the \"change port\"\
    \ flag set.\n   The client begins by initiating test I.  If this test yields no\n\
    \   response, the client knows right away that it is not capable of UDP\n   connectivity.\
    \  If the test produces a response, the client examines\n   the MAPPED-ADDRESS\
    \ attribute.  If this address and port are the same\n   as the local IP address\
    \ and port of the socket used to send the\n   request, the client knows that it\
    \ is not natted.  It executes test\n   II.\n   If a response is received, the\
    \ client knows that it has open access\n   to the Internet (or, at least, its\
    \ behind a firewall that behaves\n   like a full-cone NAT, but without the translation).\
    \  If no response\n   is received, the client knows its behind a symmetric UDP\
    \ firewall.\n   In the event that the IP address and port of the socket did not\
    \ match\n   the MAPPED-ADDRESS attribute in the response to test I, the client\n\
    \   knows that it is behind a NAT.  It performs test II.  If a response\n   is\
    \ received, the client knows that it is behind a full-cone NAT.  If\n   no response\
    \ is received, it performs test I again, but this time,\n   does so to the address\
    \ and port from the CHANGED-ADDRESS attribute\n   from the response to test I.\
    \  If the IP address and port returned in\n   the MAPPED-ADDRESS attribute are\
    \ not the same as the ones from the\n   first test I, the client knows its behind\
    \ a symmetric NAT.  If the\n   address and port are the same, the client is either\
    \ behind a\n   restricted or port restricted NAT.  To make a determination about\n\
    \   which one it is behind, the client initiates test III.  If a response\n  \
    \ is received, its behind a restricted NAT, and if no response is\n   received,\
    \ its behind a port restricted NAT.\n   This procedure yields substantial information\
    \ about the operating\n   condition of the client application.  In the event of\
    \ multiple NATs\n   between the client and the Internet, the type that is discovered\
    \ will\n   be the type of the most restrictive NAT between the client and the\n\
    \   Internet.  The types of NAT, in order of restrictiveness, from most\n   to\
    \ least, are symmetric, port restricted cone, restricted cone, and\n   full cone.\n\
    \   Typically, a client will re-do this discovery process periodically to\n  \
    \ detect changes, or look for inconsistent results.  It is important to\n   note\
    \ that when the discovery process is redone, it should not\n   generally be done\
    \ from the same local address and port used in the\n   previous discovery process.\
    \  If the same local address and port are\n   reused, bindings from the previous\
    \ test may still be in existence,\n   and these will invalidate the results of\
    \ the test.  Using a different\n   local address and port for subsequent tests\
    \ resolves this problem.\n   An alternative is to wait sufficiently long to be\
    \ confident that the\n   old bindings have expired (half an hour should more than\
    \ suffice).\n"
- title: 10.2 Binding Lifetime Discovery
  contents:
  - "10.2 Binding Lifetime Discovery\n   STUN can also be used to discover the lifetimes\
    \ of the bindings\n   created by the NAT.  In many cases, the client will need\
    \ to refresh\n   the binding, either through a new STUN request, or an application\n\
    \   packet, in order for the application to continue to use the binding.\n   By\
    \ discovering the binding lifetime, the client can determine how\n   frequently\
    \ it needs to refresh.\n                        +--------+\n                 \
    \       |  Test  |\n                        |   I    |\n                     \
    \   +--------+\n                             |\n                             |\n\
    \                             V\n                            /\\             \
    \ /\\\n                         N /  \\ Y          /  \\ Y             +--------+\n\
    \          UDP     <-------/Resp\\--------->/ IP \\------------->|  Test  |\n\
    \          Blocked         \\ ?  /          \\Same/              |   II   |\n\
    \                           \\  /            \\? /               +--------+\n\
    \                            \\/              \\/                    |\n     \
    \                                        | N                  |\n            \
    \                                 |                    V\n                   \
    \                          V                    /\\\n                        \
    \                 +--------+  Sym.      N /  \\\n                            \
    \             |  Test  |  UDP    <---/Resp\\\n                               \
    \          |   II   |  Firewall   \\ ?  /\n                                  \
    \       +--------+              \\  /\n                                      \
    \       |                    \\/\n                                           \
    \  V                     |Y\n                  /\\                         /\\\
    \                    |\n   Symmetric  N  /  \\       +--------+   N  /  \\   \
    \                V\n      NAT  <--- / IP \\<-----|  Test  |<--- /Resp\\      \
    \         Open\n                \\Same/      |   I    |     \\ ?  /          \
    \     Internet\n                 \\? /       +--------+      \\  /\n         \
    \         \\/                         \\/\n                  |               \
    \            |Y\n                  |                           |\n           \
    \       |                           V\n                  |                   \
    \        Full\n                  |                           Cone\n          \
    \        V              /\\\n              +--------+        /  \\ Y\n       \
    \       |  Test  |------>/Resp\\---->Restricted\n              |   III  |    \
    \   \\ ?  /\n              +--------+        \\  /\n                         \
    \        \\/\n                                  |N\n                         \
    \         |       Port\n                                  +------>Restricted\n\
    \                 Figure 2: Flow for type discovery process\n   To determine the\
    \ binding lifetime, the client first sends a Binding\n   Request to the server\
    \ from a particular socket, X.  This creates a\n   binding in the NAT.  The response\
    \ from the server contains a MAPPED-\n   ADDRESS attribute, providing the public\
    \ address and port on the NAT.\n   Call this Pa and Pp, respectively.  The client\
    \ then starts a timer\n   with a value of T seconds.  When this timer fires, the\
    \ client sends\n   another Binding Request to the server, using the same destination\n\
    \   address and port, but from a different socket, Y.  This request\n   contains\
    \ a RESPONSE-ADDRESS address attribute, set to (Pa,Pp).  This\n   will create\
    \ a new binding on the NAT, and cause the STUN server to\n   send a Binding Response\
    \ that would match the old binding, if it still\n   exists.  If the client receives\
    \ the Binding Response on socket X, it\n   knows that the binding has not expired.\
    \  If the client receives the\n   Binding Response on socket Y (which is possible\
    \ if the old binding\n   expired, and the NAT allocated the same public address\
    \ and port to\n   the new binding), or receives no response at all, it knows that\
    \ the\n   binding has expired.\n   The client can find the value of the binding\
    \ lifetime by doing a\n   binary search through T, arriving eventually at the\
    \ value where the\n   response is not received for any timer greater than T, but\
    \ is\n   received for any timer less than T.\n   This discovery process takes\
    \ quite a bit of time, and is something\n   that will typically be run in the\
    \ background on a device once it\n   boots.\n   It is possible that the client\
    \ can get inconsistent results each time\n   this process is run.  For example,\
    \ if the NAT should reboot, or be\n   reset for some reason, the process may discover\
    \ a lifetime than is\n   shorter than the actual one.  For this reason, implementations\
    \ are\n   encouraged to run the test numerous times, and be prepared to get\n\
    \   inconsistent results.\n"
- title: 10.3  Binding Acquisition
  contents:
  - "10.3  Binding Acquisition\n   Consider once more the case of a VoIP phone.  It\
    \ used the discovery\n   process above when it started up, to discover its environment.\
    \  Now,\n   it wants to make a call.  As part of the discovery process, it\n \
    \  determined that it was behind a full-cone NAT.\n   Consider further that this\
    \ phone consists of two logically separated\n   components - a control component\
    \ that handles signaling, and a media\n   component that handles the audio, video,\
    \ and RTP [12].  Both are\n   behind the same NAT.  Because of this separation\
    \ of control and\n   media, we wish to minimize the communication required between\
    \ them.\n   In fact, they may not even run on the same host.\n   In order to make\
    \ a voice call, the phone needs to obtain an IP\n   address and port that it can\
    \ place in the call setup message as the\n   destination for receiving audio.\n\
    \   To obtain an address, the control component sends a Shared Secret\n   Request\
    \ to the server, obtains a shared secret, and then sends a\n   Binding Request\
    \ to the server.  No CHANGE-REQUEST attribute is\n   present in the Binding Request,\
    \ and neither is the RESPONSE-ADDRESS\n   attribute.  The Binding Response contains\
    \ a mapped address.  The\n   control component then formulates a second Binding\
    \ Request.  This\n   request contains a RESPONSE-ADDRESS, which is set to the\
    \ mapped\n   address learned from the previous Binding Response.  This Binding\n\
    \   Request is passed to the media component, along with the IP address\n   and\
    \ port of the STUN server.  The media component sends the Binding\n   Request.\
    \  The request goes to the STUN server, which sends the\n   Binding Response back\
    \ to the control component.  The control\n   component receives this, and now\
    \ has learned an IP address and port\n   that will be routed back to the media\
    \ component that sent the\n   request.\n   The client will be able to receive\
    \ media from anywhere on this mapped\n   address.\n   In the case of silence suppression,\
    \ there may be periods where the\n   client receives no media.  In this case,\
    \ the UDP bindings could\n   timeout (UDP bindings in NATs are typically short;\
    \ 30 seconds is\n   common).  To deal with this, the application can periodically\n\
    \   retransmit the query in order to keep the binding fresh.\n   It is possible\
    \ that both participants in the multimedia session are\n   behind the same NAT.\
    \  In that case, both will repeat this procedure\n   above, and both will obtain\
    \ public address bindings.  When one sends\n   media to the other, the media is\
    \ routed to the NAT, and then turns\n   right back around to come back into the\
    \ enterprise, where it is\n   translated to the private address of the recipient.\
    \  This is not\n   particularly efficient, and unfortunately, does not work in\
    \ many\n   commercial NATs.  In such cases, the clients may need to retry using\n\
    \   private addresses.\n"
- title: 11. Protocol Details
  contents:
  - "11. Protocol Details\n   This section presents the detailed encoding of a STUN\
    \ message.\n   STUN is a request-response protocol.  Clients send a request, and\
    \ the\n   server sends a response.  There are two requests, Binding Request,\n\
    \   and Shared Secret Request.  The response to a Binding Request can\n   either\
    \ be the Binding Response or Binding Error Response.  The\n   response to a Shared\
    \ Secret Request can either be a Shared Secret\n   Response or a Shared Secret\
    \ Error Response.\n   STUN messages are encoded using binary fields.  All integer\
    \ fields\n   are carried in network byte order, that is, most significant byte\n\
    \   (octet) first.  This byte order is commonly known as big-endian.  The\n  \
    \ transmission order is described in detail in Appendix B of RFC 791\n   [6].\
    \  Unless otherwise noted, numeric constants are in decimal (base\n   10).\n"
- title: 11.1  Message Header
  contents:
  - "11.1  Message Header\n   All STUN messages consist of a 20 byte header:\n   \
    \ 0                   1                   2                   3\n    0 1 2 3 4\
    \ 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |      STUN Message Type        |         Message Length        |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      \
    \                      Transaction ID\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                                                                   |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   The Message Types can take on the following values:\n      0x0001  :  Binding\
    \ Request\n      0x0101  :  Binding Response\n      0x0111  :  Binding Error Response\n\
    \      0x0002  :  Shared Secret Request\n      0x0102  :  Shared Secret Response\n\
    \      0x0112  :  Shared Secret Error Response\n   The message length is the count,\
    \ in bytes, of the size of the\n   message, not including the 20 byte header.\n\
    \   The transaction ID is a 128 bit identifier.  It also serves as salt\n   to\
    \ randomize the request and the response.  All responses carry the\n   same identifier\
    \ as the request they correspond to.\n"
- title: 11.2  Message Attributes
  contents:
  - "11.2  Message Attributes\n   After the header are 0 or more attributes.  Each\
    \ attribute is TLV\n   encoded, with a 16 bit type, 16 bit length, and variable\
    \ value:\n    0                   1                   2                   3\n\
    \    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |         Type                  |            Length             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                             Value                             ....\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   The following types are defined:\n   0x0001: MAPPED-ADDRESS\n   0x0002: RESPONSE-ADDRESS\n\
    \   0x0003: CHANGE-REQUEST\n   0x0004: SOURCE-ADDRESS\n   0x0005: CHANGED-ADDRESS\n\
    \   0x0006: USERNAME\n   0x0007: PASSWORD\n   0x0008: MESSAGE-INTEGRITY\n   0x0009:\
    \ ERROR-CODE\n   0x000a: UNKNOWN-ATTRIBUTES\n   0x000b: REFLECTED-FROM\n   To\
    \ allow future revisions of this specification to add new attributes\n   if needed,\
    \ the attribute space is divided into optional and mandatory\n   ones.  Attributes\
    \ with values greater than 0x7fff are optional, which\n   means that the message\
    \ can be processed by the client or server even\n   though the attribute is not\
    \ understood.  Attributes with values less\n   than or equal to 0x7fff are mandatory\
    \ to understand, which means that\n   the client or server cannot process the\
    \ message unless it understands\n   the attribute.\n   The MESSAGE-INTEGRITY attribute\
    \ MUST be the last attribute within a\n   message.  Any attributes that are known,\
    \ but are not supposed to be\n   present in a message (MAPPED-ADDRESS in a request,\
    \ for example) MUST\n   be ignored.\n   Table 2 indicates which attributes are\
    \ present in which messages.  An\n   M indicates that inclusion of the attribute\
    \ in the message is\n   mandatory, O means its optional, C means it's conditional\
    \ based on\n   some other aspect of the message, and N/A means that the attribute\
    \ is\n   not applicable to that message type.\n                              \
    \           Binding  Shared  Shared  Shared\n                       Binding  Binding\
    \  Error    Secret  Secret  Secret\n   Att.                Req.     Resp.    Resp.\
    \    Req.    Resp.   Error\n                                                 \
    \                 Resp.\n   _____________________________________________________________________\n\
    \   MAPPED-ADDRESS      N/A      M        N/A      N/A     N/A     N/A\n   RESPONSE-ADDRESS\
    \    O        N/A      N/A      N/A     N/A     N/A\n   CHANGE-REQUEST      O\
    \        N/A      N/A      N/A     N/A     N/A\n   SOURCE-ADDRESS      N/A   \
    \   M        N/A      N/A     N/A     N/A\n   CHANGED-ADDRESS     N/A      M \
    \       N/A      N/A     N/A     N/A\n   USERNAME            O        N/A    \
    \  N/A      N/A     M       N/A\n   PASSWORD            N/A      N/A      N/A\
    \      N/A     M       N/A\n   MESSAGE-INTEGRITY   O        O        N/A     \
    \ N/A     N/A     N/A\n   ERROR-CODE          N/A      N/A      M        N/A \
    \    N/A     M\n   UNKNOWN-ATTRIBUTES  N/A      N/A      C        N/A     N/A\
    \     C\n   REFLECTED-FROM      N/A      C        N/A      N/A     N/A     N/A\n\
    \   Table 2: Summary of Attributes\n   The length refers to the length of the\
    \ value element, expressed as an\n   unsigned integral number of bytes.\n"
- title: 11.2.1 MAPPED-ADDRESS
  contents:
  - "11.2.1 MAPPED-ADDRESS\n   The MAPPED-ADDRESS attribute indicates the mapped IP\
    \ address and\n   port.  It consists of an eight bit address family, and a sixteen\
    \ bit\n   port, followed by a fixed length value representing the IP address.\n\
    \    0                   1                   2                   3\n    0 1 2\
    \ 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |x x x x x x x x|    Family     |           Port                |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                             Address                           |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   The port is a network byte ordered representation of the mapped port.\n  \
    \ The address family is always 0x01, corresponding to IPv4.  The first\n   8 bits\
    \ of the MAPPED-ADDRESS are ignored, for the purposes of\n   aligning parameters\
    \ on natural boundaries.  The IPv4 address is 32\n   bits.\n"
- title: 11.2.2 RESPONSE-ADDRESS
  contents:
  - "11.2.2 RESPONSE-ADDRESS\n   The RESPONSE-ADDRESS attribute indicates where the\
    \ response to a\n   Binding Request should be sent.  Its syntax is identical to\
    \ MAPPED-\n   ADDRESS.\n"
- title: 11.2.3  CHANGED-ADDRESS
  contents:
  - "11.2.3  CHANGED-ADDRESS\n   The CHANGED-ADDRESS attribute indicates the IP address\
    \ and port where\n   responses would have been sent from if the \"change IP\"\
    \ and \"change\n   port\" flags had been set in the CHANGE-REQUEST attribute of\
    \ the\n   Binding Request.  The attribute is always present in a Binding\n   Response,\
    \ independent of the value of the flags.  Its syntax is\n   identical to MAPPED-ADDRESS.\n"
- title: 11.2.4 CHANGE-REQUEST
  contents:
  - "11.2.4 CHANGE-REQUEST\n   The CHANGE-REQUEST attribute is used by the client\
    \ to request that\n   the server use a different address and/or port when sending\
    \ the\n   response.  The attribute is 32 bits long, although only two bits (A\n\
    \   and B) are used:\n    0                   1                   2          \
    \         3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0\
    \ 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n  \
    \ |0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 A B 0|\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   The meaning of the flags is:\n   A: This is the \"change IP\" flag.  If true,\
    \ it requests the server\n      to send the Binding Response with a different\
    \ IP address than the\n      one the Binding Request was received on.\n   B: This\
    \ is the \"change port\" flag.  If true, it requests the\n      server to send\
    \ the Binding Response with a different port than the\n      one the Binding Request\
    \ was received on.\n"
- title: 11.2.5 SOURCE-ADDRESS
  contents:
  - "11.2.5 SOURCE-ADDRESS\n   The SOURCE-ADDRESS attribute is present in Binding\
    \ Responses.  It\n   indicates the source IP address and port that the server\
    \ is sending\n   the response from.  Its syntax is identical to that of MAPPED-\n\
    \   ADDRESS.\n"
- title: 11.2.6 USERNAME
  contents:
  - "11.2.6 USERNAME\n   The USERNAME attribute is used for message integrity.  It\
    \ serves as a\n   means to identify the shared secret used in the message integrity\n\
    \   check.  The USERNAME is always present in a Shared Secret Response,\n   along\
    \ with the PASSWORD.  It is optionally present in a Binding\n   Request when message\
    \ integrity is used.\n   The value of USERNAME is a variable length opaque value.\
    \  Its length\n   MUST be a multiple of 4 (measured in bytes) in order to guarantee\n\
    \   alignment of attributes on word boundaries.\n"
- title: 11.2.7 PASSWORD
  contents:
  - "11.2.7 PASSWORD\n   The PASSWORD attribute is used in Shared Secret Responses.\
    \  It is\n   always present in a Shared Secret Response, along with the USERNAME.\n\
    \   The value of PASSWORD is a variable length value that is to be used\n   as\
    \ a shared secret.  Its length MUST be a multiple of 4 (measured in\n   bytes)\
    \ in order to guarantee alignment of attributes on word\n   boundaries.\n"
- title: 11.2.8 MESSAGE-INTEGRITY
  contents:
  - "11.2.8 MESSAGE-INTEGRITY\n   The MESSAGE-INTEGRITY attribute contains an HMAC-SHA1\
    \ [13] of the\n   STUN message.  It can be present in Binding Requests or Binding\n\
    \   Responses.  Since it uses the SHA1 hash, the HMAC will be 20 bytes.\n   The\
    \ text used as input to HMAC is the STUN message, including the\n   header, up\
    \ to and including the attribute preceding the MESSAGE-\n   INTEGRITY attribute.\
    \ That text is then padded with zeroes so as to be\n   a multiple of 64 bytes.\
    \  As a result, the MESSAGE-INTEGRITY attribute\n   MUST be the last attribute\
    \ in any STUN message.  The key used as\n   input to HMAC depends on the context.\n"
- title: 11.2.9 ERROR-CODE
  contents:
  - "11.2.9 ERROR-CODE\n   The ERROR-CODE attribute is present in the Binding Error\
    \ Response and\n   Shared Secret Error Response.  It is a numeric value in the\
    \ range of\n   100 to 699 plus a textual reason phrase encoded in UTF-8, and is\n\
    \   consistent in its code assignments and semantics with SIP [10] and\n   HTTP\
    \ [15].  The reason phrase is meant for user consumption, and can\n   be anything\
    \ appropriate for the response code.  The lengths of the\n   reason phrases MUST\
    \ be a multiple of 4 (measured in bytes).  This can\n   be accomplished by added\
    \ spaces to the end of the text, if necessary.\n   Recommended reason phrases\
    \ for the defined response codes are\n   presented below.\n   To facilitate processing,\
    \ the class of the error code (the hundreds\n   digit) is encoded separately from\
    \ the rest of the code.\n     0                   1                   2      \
    \             3\n     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7\
    \ 8 9 0 1\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    |                   0                     |Class|     Number    |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    |      Reason Phrase (variable)                                ..\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   The class represents the hundreds digit of the response code.  The\n   value\
    \ MUST be between 1 and 6.  The number represents the response\n   code modulo\
    \ 100, and its value MUST be between 0 and 99.\n   The following response codes,\
    \ along with their recommended reason\n   phrases (in brackets) are defined at\
    \ this time:\n   400 (Bad Request): The request was malformed.  The client should\
    \ not\n        retry the request without modification from the previous\n    \
    \    attempt.\n   401 (Unauthorized): The Binding Request did not contain a MESSAGE-\n\
    \        INTEGRITY attribute.\n   420 (Unknown Attribute): The server did not\
    \ understand a mandatory\n        attribute in the request.\n   430 (Stale Credentials):\
    \ The Binding Request did contain a MESSAGE-\n        INTEGRITY attribute, but\
    \ it used a shared secret that has\n        expired.  The client should obtain\
    \ a new shared secret and try\n        again.\n   431 (Integrity Check Failure):\
    \ The Binding Request contained a\n        MESSAGE-INTEGRITY attribute, but the\
    \ HMAC failed verification.\n        This could be a sign of a potential attack,\
    \ or client\n        implementation error.\n   432 (Missing Username): The Binding\
    \ Request contained a MESSAGE-\n        INTEGRITY attribute, but not a USERNAME\
    \ attribute.  Both must be\n        present for integrity checks.\n   433 (Use\
    \ TLS): The Shared Secret request has to be sent over TLS, but\n        was not\
    \ received over TLS.\n   500 (Server Error): The server has suffered a temporary\
    \ error. The\n        client should try again.\n   600 (Global Failure:) The server\
    \ is refusing to fulfill the request.\n        The client should not retry.\n"
- title: 11.2.10 UNKNOWN-ATTRIBUTES
  contents:
  - "11.2.10 UNKNOWN-ATTRIBUTES\n   The UNKNOWN-ATTRIBUTES attribute is present only\
    \ in a Binding Error\n   Response or Shared Secret Error Response when the response\
    \ code in\n   the ERROR-CODE attribute is 420.\n   The attribute contains a list\
    \ of 16 bit values, each of which\n   represents an attribute type that was not\
    \ understood by the server.\n   If the number of unknown attributes is an odd\
    \ number, one of the\n   attributes MUST be repeated in the list, so that the\
    \ total length of\n   the list is a multiple of 4 bytes.\n   0               \
    \    1                   2                   3\n     0 1 2 3 4 5 6 7 8 9 0 1 2\
    \ 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    |      Attribute 1 Type           |     Attribute 2 Type        |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    |      Attribute 3 Type           |     Attribute 4 Type    ...\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n"
- title: 11.2.11 REFLECTED-FROM
  contents:
  - "11.2.11 REFLECTED-FROM\n   The REFLECTED-FROM attribute is present only in Binding\
    \ Responses,\n   when the Binding Request contained a RESPONSE-ADDRESS attribute.\
    \  The\n   attribute contains the identity (in terms of IP address) of the\n \
    \  source where the request came from.  Its purpose is to provide\n   traceability,\
    \ so that a STUN server cannot be used as a reflector for\n   denial-of-service\
    \ attacks.\n   Its syntax is identical to the MAPPED-ADDRESS attribute.\n"
- title: 12.  Security Considerations
  contents:
  - '12.  Security Considerations

    '
- title: 12.1 Attacks on STUN
  contents:
  - "12.1 Attacks on STUN\n   Generally speaking, attacks on STUN can be classified\
    \ into denial of\n   service attacks and eavesdropping attacks.  Denial of service\
    \ attacks\n   can be launched against a STUN server itself, or against other\n\
    \   elements using the STUN protocol.\n   STUN servers create state through the\
    \ Shared Secret Request\n   mechanism.  To prevent being swamped with traffic,\
    \ a STUN server\n   SHOULD limit the number of simultaneous TLS connections it\
    \ will hold\n   open by dropping an existing connection when a new connection\
    \ request\n   arrives (based on an Least Recently Used (LRU) policy, for example).\n\
    \   Similarly, it SHOULD limit the number of shared secrets it will\n   store,\
    \ in the event that the server is storing the shared secrets.\n   The attacks\
    \ of greater interest are those in which the STUN server\n   and client are used\
    \ to launch DOS attacks against other entities,\n   including the client itself.\n\
    \   Many of the attacks require the attacker to generate a response to a\n   legitimate\
    \ STUN request, in order to provide the client with a faked\n   MAPPED-ADDRESS.\
    \  The attacks that can be launched using such a\n   technique include:\n"
- title: '12.1.1 Attack I: DDOS Against a Target'
  contents:
  - "12.1.1 Attack I: DDOS Against a Target\n   In this case, the attacker provides\
    \ a large number of clients with\n   the same faked MAPPED-ADDRESS that points\
    \ to the intended target.\n   This will trick all the STUN clients into thinking\
    \ that their\n   addresses are equal to that of the target.  The clients then\
    \ hand out\n   that address in order to receive traffic on it (for example, in\
    \ SIP\n   or H.323 messages).  However, all of that traffic becomes focused at\n\
    \   the intended target.  The attack can provide substantial\n   amplification,\
    \ especially when used with clients that are using STUN\n   to enable multimedia\
    \ applications.\n"
- title: '12.1.2 Attack II: Silencing a Client'
  contents:
  - "12.1.2 Attack II: Silencing a Client\n   In this attack, the attacker seeks to\
    \ deny a client access to\n   services enabled by STUN (for example, a client\
    \ using STUN to enable\n   SIP-based multimedia traffic).  To do that, the attacker\
    \ provides\n   that client with a faked MAPPED-ADDRESS.  The MAPPED-ADDRESS it\n\
    \   provides is an IP address that routes to nowhere.  As a result, the\n   client\
    \ won't receive any of the packets it expects to receive when it\n   hands out\
    \ the MAPPED-ADDRESS.\n   This exploitation is not very interesting for the attacker.\
    \  It\n   impacts a single client, which is frequently not the desired target.\n\
    \   Moreover, any attacker that can mount the attack could also deny\n   service\
    \ to the client by other means, such as preventing the client\n   from receiving\
    \ any response from the STUN server, or even a DHCP\n   server.\n"
- title: '12.1.3 Attack III: Assuming the Identity of a Client'
  contents:
  - "12.1.3 Attack III: Assuming the Identity of a Client\n   This attack is similar\
    \ to attack II.  However, the faked MAPPED-\n   ADDRESS points to the attacker\
    \ themself.  This allows the attacker to\n   receive traffic which was destined\
    \ for the client.\n"
- title: '12.1.4 Attack IV: Eavesdropping'
  contents:
  - "12.1.4 Attack IV: Eavesdropping\n   In this attack, the attacker forces the client\
    \ to use a MAPPED-\n   ADDRESS that routes to itself.  It then forwards any packets\
    \ it\n   receives to the client.  This attack would allow the attacker to\n  \
    \ observe all packets sent to the client.  However, in order to launch\n   the\
    \ attack, the attacker must have already been able to observe\n   packets from\
    \ the client to the STUN server.  In most cases (such as\n   when the attack is\
    \ launched from an access network), this means that\n   the attacker could already\
    \ observe packets sent to the client.  This\n   attack is, as a result, only useful\
    \ for observing traffic by\n   attackers on the path from the client to the STUN\
    \ server, but not\n   generally on the path of packets being routed towards the\
    \ client.\n"
- title: 12.2 Launching the Attacks
  contents:
  - "12.2 Launching the Attacks\n   It is important to note that attacks of this nature\
    \ (injecting\n   responses with fake MAPPED-ADDRESSes) require that the attacker\
    \ be\n   capable of eavesdropping requests sent from the client to the server\n\
    \   (or to act as a MITM for such attacks).  This is because STUN\n   requests\
    \ contain a transaction identifier, selected by the client,\n   which is random\
    \ with 128 bits of entropy.  The server echoes this\n   value in the response,\
    \ and the client ignores any responses that\n   don't have a matching transaction\
    \ ID.  Therefore, in order for an\n   attacker to provide a faked response that\
    \ is accepted by the client,\n   the attacker needs to know what the transaction\
    \ ID in the request\n   was.  The large amount of randomness, combined with the\
    \ need to know\n   when the client sends a request, precludes attacks that involve\n\
    \   guessing the transaction ID.\n   Since all of the above attacks rely on this\
    \ one primitive - injecting\n   a response with a faked MAPPED-ADDRESS - preventing\
    \ the attacks is\n   accomplished by preventing this one operation.  To prevent\
    \ it, we\n   need to consider the various ways in which it can be accomplished.\n\
    \   There are several:\n"
- title: '12.2.1 Approach I: Compromise a Legitimate STUN Server'
  contents:
  - "12.2.1 Approach I: Compromise a Legitimate STUN Server\n   In this attack, the\
    \ attacker compromises a legitimate STUN server\n   through a virus or Trojan\
    \ horse.  Presumably, this would allow the\n   attacker to take over the STUN\
    \ server, and control the types of\n   responses it generates.\n   Compromise\
    \ of a STUN server can also lead to discovery of open ports.\n   Knowledge of\
    \ an open port creates an opportunity for DoS attacks on\n   those ports (or DDoS\
    \ attacks if the traversed NAT is a full cone\n   NAT).  Discovering open ports\
    \ is already fairly trivial using port\n   probing, so this does not represent\
    \ a major threat.\n"
- title: '12.2.2 Approach II: DNS Attacks'
  contents:
  - "12.2.2 Approach II: DNS Attacks\n   STUN servers are discovered using DNS SRV\
    \ records.  If an attacker\n   can compromise the DNS, it can inject fake records\
    \ which map a domain\n   name to the IP address of a STUN server run by the attacker.\
    \  This\n   will allow it to inject fake responses to launch any of the attacks\n\
    \   above.\n"
- title: '12.2.3 Approach III: Rogue Router or NAT'
  contents:
  - "12.2.3 Approach III: Rogue Router or NAT\n   Rather than compromise the STUN\
    \ server, an attacker can cause a STUN\n   server to generate responses with the\
    \ wrong MAPPED-ADDRESS by\n   compromising a router or NAT on the path from the\
    \ client to the STUN\n   server.  When the STUN request passes through the rogue\
    \ router or\n   NAT, it rewrites the source address of the packet to be that of\
    \ the\n   desired MAPPED-ADDRESS.  This address cannot be arbitrary.  If the\n\
    \   attacker is on the public Internet (that is, there are no NATs\n   between\
    \ it and the STUN server), and the attacker doesn't modify the\n   STUN request,\
    \ the address has to have the property that packets sent\n   from the STUN server\
    \ to that address would route through the\n   compromised router.  This is because\
    \ the STUN server will send the\n   responses back to the source address of the\
    \ request.  With a modified\n   source address, the only way they can reach the\
    \ client is if the\n   compromised router directs them there.  If the attacker\
    \ is on the\n   public Internet, but they can modify the STUN request, they can\n\
    \   insert a RESPONSE-ADDRESS attribute into the request, containing the\n   actual\
    \ source address of the STUN request.  This will cause the\n   server to send\
    \ the response to the client, independent of the source\n   address the STUN server\
    \ sees.  This gives the attacker the ability to\n   forge an arbitrary source\
    \ address when it forwards the STUN request.\n   If the attacker is on a private\
    \ network (that is, there are NATs\n   between it and the STUN server), the attacker\
    \ will not be able to\n   force the server to generate arbitrary MAPPED-ADRESSes\
    \ in responses.\n   They will only be able force the STUN server to generate MAPPED-\n\
    \   ADDRESSes which route to the private network.  This is because the\n   NAT\
    \ between the attacker and the STUN server will rewrite the source\n   address\
    \ of the STUN request, mapping it to a public address that\n   routes to the private\
    \ network.  Because of this, the attacker can\n   only force the server to generate\
    \ faked mapped addresses that route\n   to the private network.  Unfortunately,\
    \ it is possible that a low\n   quality NAT would be willing to map an allocated\
    \ public address to\n   another public address (as opposed to an internal private\
    \ address),\n   in which case the attacker could forge the source address in a\
    \ STUN\n   request to be an arbitrary public address.  This kind of behavior\n\
    \   from NATs does appear to be rare.\n"
- title: '12.2.4 Approach IV: MITM'
  contents:
  - "12.2.4 Approach IV: MITM\n   As an alternative to approach III, if the attacker\
    \ can place an\n   element on the path from the client to the server, the element\
    \ can\n   act as a man-in-the-middle.  In that case, it can intercept a STUN\n\
    \   request, and generate a STUN response directly with any desired value\n  \
    \ of the MAPPED-ADDRESS field.  Alternatively, it can forward the STUN\n   request\
    \ to the server (after potential modification), receive the\n   response, and\
    \ forward it to the client.  When forwarding the request\n   and response, this\
    \ attack is subject to the same limitations on the\n   MAPPED-ADDRESS described\
    \ in Section 12.2.3.\n"
- title: '12.2.5 Approach V: Response Injection Plus DoS'
  contents:
  - "12.2.5 Approach V: Response Injection Plus DoS\n   In this approach, the attacker\
    \ does not need to be a MITM (as in\n   approaches III and IV).  Rather, it only\
    \ needs to be able to\n   eavesdrop onto a network segment that carries STUN requests.\
    \  This is\n   easily done in multiple access networks such as ethernet or\n \
    \  unprotected 802.11.  To inject the fake response, the attacker\n   listens\
    \ on the network for a STUN request.  When it sees one, it\n   simultaneously\
    \ launches a DoS attack on the STUN server, and\n   generates its own STUN response\
    \ with the desired MAPPED-ADDRESS\n   value.  The STUN response generated by the\
    \ attacker will reach the\n   client, and the DoS attack against the server is\
    \ aimed at preventing\n   the legitimate response from the server from reaching\
    \ the client.\n   Arguably, the attacker can do without the DoS attack on the\
    \ server,\n   so long as the faked response beats the real response back to the\n\
    \   client, and the client uses the first response, and ignores the\n   second\
    \ (even though it's different).\n"
- title: '12.2.6 Approach VI: Duplication'
  contents:
  - "12.2.6 Approach VI: Duplication\n   This approach is similar to approach V. \
    \ The attacker listens on the\n   network for a STUN request.  When it sees it,\
    \ it generates its own\n   STUN request towards the server.  This STUN request\
    \ is identical to\n   the one it saw, but with a spoofed source IP address.  The\
    \ spoofed\n   address is equal to the one that the attacker desires to have placed\n\
    \   in the MAPPED-ADDRESS of the STUN response.  In fact, the attacker\n   generates\
    \ a flood of such packets.  The STUN server will receive the\n   one original\
    \ request, plus a flood of duplicate fake ones.  It\n   generates responses to\
    \ all of them.  If the flood is sufficiently\n   large for the responses to congest\
    \ routers or some other equipment,\n   there is a reasonable probability that\
    \ the one real response is lost\n   (along with many of the faked ones), but the\
    \ net result is that only\n   the faked responses are received by the STUN client.\
    \  These responses\n   are all identical and all contain the MAPPED-ADDRESS that\
    \ the\n   attacker wanted the client to use.\n   The flood of duplicate packets\
    \ is not needed (that is, only one faked\n   request is sent), so long as the\
    \ faked response beats the real\n   response back to the client, and the client\
    \ uses the first response,\n   and ignores the second (even though it's different).\n\
    \   Note that, in this approach, launching a DoS attack against the STUN\n   server\
    \ or the IP network, to prevent the valid response from being\n   sent or received,\
    \ is problematic.  The attacker needs the STUN server\n   to be available to handle\
    \ its own request.  Due to the periodic\n   retransmissions of the request from\
    \ the client, this leaves a very\n   tiny window of opportunity.  The attacker\
    \ must start the DoS attack\n   immediately after the actual request from the\
    \ client, causing the\n   correct response to be discarded, and then cease the\
    \ DoS attack in\n   order to send its own request, all before the next retransmission\n\
    \   from the client.  Due to the close spacing of the retransmits (100ms\n   to\
    \ a few seconds), this is very difficult to do.\n   Besides DoS attacks, there\
    \ may be other ways to prevent the actual\n   request from the client from reaching\
    \ the server.  Layer 2\n   manipulations, for example, might be able to accomplish\
    \ it.\n   Fortunately, Approach IV is subject to the same limitations\n   documented\
    \ in Section 12.2.3, which limit the range of MAPPED-\n   ADDRESSes the attacker\
    \ can cause the STUN server to generate.\n"
- title: 12.3 Countermeasures
  contents:
  - "12.3 Countermeasures\n   STUN provides mechanisms to counter the approaches described\
    \ above,\n   and additional, non-STUN techniques can be used as well.\n   First\
    \ off, it is RECOMMENDED that networks with STUN clients\n   implement ingress\
    \ source filtering (RFC 2827 [7]).  This is\n   particularly important for the\
    \ NATs themselves.  As Section 12.2.3\n   explains, NATs which do not perform\
    \ this check can be used as\n   \"reflectors\" in DDoS attacks.  Most NATs do\
    \ perform this check as a\n   default mode of operation.  We strongly advise people\
    \ that purchase\n   NATs to ensure that this capability is present and enabled.\n\
    \   Secondly, it is RECOMMENDED that STUN servers be run on hosts\n   dedicated\
    \ to STUN, with all UDP and TCP ports disabled except for the\n   STUN ports.\
    \  This is to prevent viruses and Trojan horses from\n   infecting STUN servers,\
    \ in order to prevent their compromise.  This\n   helps mitigate Approach I (Section\
    \ 12.2.1).\n   Thirdly, to prevent the DNS attack of Section 12.2.2, Section 9.2\n\
    \   recommends that the client verify the credentials provided by the\n   server\
    \ with the name used in the DNS lookup.\n   Finally, all of the attacks above\
    \ rely on the client taking the\n   mapped address it learned from STUN, and using\
    \ it in application\n   layer protocols.  If encryption and message integrity\
    \ are provided\n   within those protocols, the eavesdropping and identity assumption\n\
    \   attacks can be prevented.  As such, applications that make use of\n   STUN\
    \ addresses in application protocols SHOULD use integrity and\n   encryption,\
    \ even if a SHOULD level strength is not specified for that\n   protocol.  For\
    \ example, multimedia applications using STUN addresses\n   to receive RTP traffic\
    \ would use secure RTP [16].\n   The above three techniques are non-STUN mechanisms.\
    \  STUN itself\n   provides several countermeasures.\n   Approaches IV (Section\
    \ 12.2.4), when generating the response locally,\n   and V (Section 12.2.5) require\
    \ an attacker to generate a faked\n   response.  This attack is prevented using\
    \ the message integrity\n   mechanism provided in STUN, described in Section 8.1.\n\
    \   Approaches III (Section 12.2.3) IV (Section 12.2.4), when using the\n   relaying\
    \ technique, and VI (12.2.6), however, are not preventable\n   through server\
    \ signatures.  Both approaches are most potent when the\n   attacker can modify\
    \ the request, inserting a RESPONSE-ADDRESS that\n   routes to the client.  Fortunately,\
    \ such modifications are\n   preventable using the message integrity techniques\
    \ described in\n   Section 9.3.  However, these three approaches are still functional\n\
    \   when the attacker modifies nothing but the source address of the STUN\n  \
    \ request. Sadly, this is the one thing that cannot be protected\n   through cryptographic\
    \ means, as this is the change that STUN itself\n   is seeking to detect and report.\
    \  It is therefore an inherent\n   weakness in NAT, and not fixable in STUN. \
    \ To help mitigate these\n   attacks, Section 9.4 provides several heuristics\
    \ for the client to\n   follow.  The client looks for inconsistent or extra responses,\
    \ both\n   of which are signs of the attacks described above.  However, these\n\
    \   heuristics are just that - heuristics, and cannot be guaranteed to\n   prevent\
    \ attacks.  The heuristics appear to prevent the attacks as we\n   know how to\
    \ launch them today.  Implementors should stay posted for\n   information on new\
    \ heuristics that might be required in the future.\n   Such information will be\
    \ distributed on the IETF MIDCOM mailing list,\n   midcom@ietf.org.\n"
- title: 12.4 Residual Threats
  contents:
  - "12.4 Residual Threats\n   None of the countermeasures listed above can prevent\
    \ the attacks\n   described in Section 12.2.3 if the attacker is in the appropriate\n\
    \   network paths.  Specifically, consider the case in which the attacker\n  \
    \ wishes to convince client C that it has address V.  The attacker\n   needs to\
    \ have a network element on the path between A and the server\n   (in order to\
    \ modify the request) and on the path between the server\n   and V so that it\
    \ can forward the response to C.  Furthermore, if\n   there is a NAT between the\
    \ attacker and the server, V must also be\n   behind the same NAT.  In such a\
    \ situation, the attacker can either\n   gain access to all the application-layer\
    \ traffic or mount the DDOS\n   attack described in Section 12.1.1.  Note that\
    \ any host which exists\n   in the correct topological relationship can be DDOSed.\
    \  It need not\n   be using STUN.\n"
- title: 13.  IANA Considerations
  contents:
  - "13.  IANA Considerations\n   STUN cannot be extended.  Changes to the protocol\
    \ are made through a\n   standards track revision of this specification.  As a\
    \ result, no IANA\n   registries are needed.  Any future extensions will establish\
    \ any\n   needed registries.\n"
- title: 14.  IAB Considerations
  contents:
  - "14.  IAB Considerations\n   The IAB has studied the problem of \"Unilateral Self\
    \ Address Fixing\",\n   which is the general process by which a client attempts\
    \ to determine\n   its address in another realm on the other side of a NAT through\
    \ a\n   collaborative protocol reflection mechanism (RFC 3424 [17]).  STUN is\n\
    \   an example of a protocol that performs this type of function.  The\n   IAB\
    \ has mandated that any protocols developed for this purpose\n   document a specific\
    \ set of considerations.  This section meets those\n   requirements.\n"
- title: 14.1 Problem Definition
  contents:
  - "14.1 Problem Definition\n   From RFC 3424 [17], any UNSAF proposal must provide:\n\
    \      Precise definition of a specific, limited-scope problem that is to\n  \
    \    be solved with the UNSAF proposal.  A short term fix should not be\n    \
    \  generalized to solve other problems; this is why \"short term fixes\n     \
    \ usually aren't\".\n   The specific problems being solved by STUN are:\n   o\
    \  Provide a means for a client to detect the presence of one or more\n      NATs\
    \ between it and a server run by a service provider on the\n      public Internet.\
    \  The purpose of such detection is to determine\n      additional steps that\
    \ might be necessary in order to receive\n      service from that particular provider.\n\
    \   o  Provide a means for a client to detect the presence of one or more\n  \
    \    NATs between it and another client, where the second client is\n      reachable\
    \ from the first, but it is not known whether the second\n      client resides\
    \ on the public Internet.\n   o  Provide a means for a client to obtain an address\
    \ on the public\n      Internet from a non-symmetric NAT, for the express purpose\
    \ of\n      receiving incoming UDP traffic from another host, targeted to that\n\
    \      address.\n   STUN does not address TCP, either incoming or outgoing, and\
    \ does not\n   address outgoing UDP communications.\n"
- title: 14.2 Exit Strategy
  contents:
  - "14.2 Exit Strategy\n   From [17], any UNSAF proposal must provide:\n      Description\
    \ of an exit strategy/transition plan.  The better short\n      term fixes are\
    \ the ones that will naturally see less and less use\n      as the appropriate\
    \ technology is deployed.\n   STUN comes with its own built in exit strategy.\
    \  This strategy is the\n   detection operation that is performed as a precursor\
    \ to the actual\n   UNSAF address-fixing operation.  This discovery operation,\
    \ documented\n   in Section 10.1, attempts to discover the existence of, and type\
    \ of,\n   any NATS between the client and the service provider network.  Whilst\n\
    \   the detection of the specific type of NAT may be brittle, the\n   discovery\
    \ of the existence of NAT is itself quite robust.  As NATs\n   are phased out\
    \ through the deployment of IPv6, the discovery\n   operation will return immediately\
    \ with the result that there is no\n   NAT, and no further operations are required.\
    \  Indeed, the discovery\n   operation itself can be used to help motivate deployment\
    \ of IPv6; if\n   a user detects a NAT between themselves and the public Internet,\
    \ they\n   can call up their access provider and complain about it.\n   STUN can\
    \ also help facilitate the introduction of midcom.  As\n   midcom-capable NATs\
    \ are deployed, applications will, instead of using\n   STUN (which also resides\
    \ at the application layer), first allocate an\n   address binding using midcom.\
    \  However, it is a well-known limitation\n   of midcom that it only works when\
    \ the agent knows the middleboxes\n   through which its traffic will flow.  Once\
    \ bindings have been\n   allocated from those middleboxes, a STUN detection procedure\
    \ can\n   validate that there are no additional middleboxes on the path from\n\
    \   the public Internet to the client.  If this is the case, the\n   application\
    \ can continue operation using the address bindings\n   allocated from midcom.\
    \  If it is not the case, STUN provides a\n   mechanism for self-address fixing\
    \ through the remaining midcom-\n   unaware middleboxes.  Thus, STUN provides\
    \ a way to help transition to\n   full midcom-aware networks.\n"
- title: 14.3  Brittleness Introduced by STUN
  contents:
  - "14.3  Brittleness Introduced by STUN\n   From [17], any UNSAF proposal must provide:\n\
    \      Discussion of specific issues that may render systems more\n      \"brittle\"\
    .  For example, approaches that involve using data at\n      multiple network\
    \ layers create more dependencies, increase\n      debugging challenges, and make\
    \ it harder to transition.\n   STUN introduces brittleness into the system in\
    \ several ways:\n   o  The discovery process assumes a certain classification\
    \ of devices\n      based on their treatment of UDP.  There could be other types\
    \ of\n      NATs that are deployed that would not fit into one of these molds.\n\
    \      Therefore, future NATs may not be properly detected by STUN.  STUN\n  \
    \    clients (but not servers) would need to change to accommodate\n      that.\n\
    \   o  The binding acquisition usage of STUN does not work for all NAT\n     \
    \ types.  It will work for any application for full cone NATs only.\n      For\
    \ restricted cone and port restricted cone NAT, it will work for\n      some applications\
    \ depending on the application. Application\n      specific processing will generally\
    \ be needed.  For symmetric NATs,\n      the binding acquisition will not yield\
    \ a usable address.  The\n      tight dependency on the specific type of NAT makes\
    \ the protocol\n      brittle.\n   o  STUN assumes that the server exists on the\
    \ public Internet.  If\n      the server is located in another private address\
    \ realm, the user\n      may or may not be able to use its discovered address\
    \ to\n      communicate with other users.  There is no way to detect such a\n\
    \      condition.\n   o  The bindings allocated from the NAT need to be continuously\n\
    \      refreshed.  Since the timeouts for these bindings is very\n      implementation\
    \ specific, the refresh interval cannot easily be\n      determined.  When the\
    \ binding is not being actively used to\n      receive traffic, but to wait for\
    \ an incoming message, the binding\n      refresh will needlessly consume network\
    \ bandwidth.\n   o  The use of the STUN server as an additional network element\n\
    \      introduces another point of potential security attack.  These\n      attacks\
    \ are largely prevented by the security measures provided by\n      STUN, but\
    \ not entirely.\n   o  The use of the STUN server as an additional network element\n\
    \      introduces another point of failure.  If the client cannot locate\n   \
    \   a STUN server, or if the server should be unavailable due to\n      failure,\
    \ the application cannot function.\n   o  The use of STUN to discover address\
    \ bindings will result in an\n      increase in latency for applications.  For\
    \ example, a Voice over\n      IP application will see an increase of call setup\
    \ delays equal to\n      at least one RTT to the STUN server.\n   o  The discovery\
    \ of binding lifetimes is prone to error.  It assumes\n      that the same lifetime\
    \ will exist for all bindings. This may not\n      be true if the NAT uses dynamic\
    \ binding lifetimes to handle\n      overload, or if the NAT itself reboots during\
    \ the discovery\n      process.\n   o  STUN imposes some restrictions on the network\
    \ topologies for\n      proper operation.  If client A obtains an address from\
    \ STUN server\n      X, and sends it to client B, B may not be able to send to\
    \ A using\n      that IP address.  The address will not work if any of the\n \
    \     following is true:\n      -  The STUN server is not in an address realm\
    \ that is a common\n         ancestor (topologically) of both clients A and B.\
    \  For example,\n         consider client A and B, both of which have residential\
    \ NAT\n         devices.  Both devices connect them to their cable operators,\n\
    \         but both clients have different providers. Each provider has a\n   \
    \      NAT in front of their entire network, connecting it to the\n         public\
    \ Internet.  If the STUN server used by A is in A's cable\n         operator's\
    \ network, an address obtained by it will not be\n         usable by B.  The STUN\
    \ server must be in the network which is a\n         common ancestor to both -\
    \ in this case, the public Internet.\n      -  The STUN server is in an address\
    \ realm that is a common\n         ancestor to both clients, but both clients\
    \ are behind the same\n         NAT connecting to that address realm.  For example,\
    \ if the two\n         clients in the previous example had the same cable operator,\n\
    \         that cable operator had a single NAT connecting their network\n    \
    \     to the public Internet, and the STUN server was on the public\n        \
    \ Internet, the address obtained by A would not be usable by B.\n         That\
    \ is because some NATs will not accept an internal packet\n         sent to a\
    \ public IP address which is mapped back to an internal\n         address.  To\
    \ deal with this, additional protocol mechanisms or\n         configuration parameters\
    \ need to be introduced which detect\n         this case.\n   o  Most significantly,\
    \ STUN introduces potential security threats\n      which cannot be eliminated.\
    \  This specification describes\n      heuristics that can be used to mitigate\
    \ the problem, but it is\n      provably unsolvable given what STUN is trying\
    \ to accomplish.\n      These security problems are described fully in Section\
    \ 12.\n"
- title: 14.4 Requirements for a Long Term Solution
  contents:
  - "14.4 Requirements for a Long Term Solution\n   From [17], any UNSAF proposal\
    \ must provide:\n      Identify requirements for longer term, sound technical\
    \ solutions\n      -- contribute to the process of finding the right longer term\n\
    \      solution.\n   Our experience with STUN has led to the following requirements\
    \ for a\n   long term solution to the NAT problem:\n   Requests for bindings and\
    \ control of other resources in a NAT\n      need to be explicit.  Much of the\
    \ brittleness in STUN derives from\n      its guessing at the parameters of the\
    \ NAT, rather than telling the\n      NAT what parameters to use.\n   Control\
    \ needs to be \"in-band\".  There are far too many scenarios\n      in which the\
    \ client will not know about the location of\n      middleboxes ahead of time.\
    \  Instead, control of such boxes needs\n      to occur in-band, traveling along\
    \ the same path as the data will\n      itself travel.  This guarantees that the\
    \ right set of middleboxes\n      are controlled.  This is only true for first-party\
    \ controls;\n      third-party controls are best handled using the midcom framework.\n\
    \   Control needs to be limited.  Users will need to communicate\n      through\
    \ NATs which are outside of their administrative control.\n      In order for\
    \ providers to be willing to deploy NATs which can be\n      controlled by users\
    \ in different domains, the scope of such\n      controls needs to be extremely\
    \ limited - typically, allocating a\n      binding to reach the address where\
    \ the control packets are coming\n      from.\n   Simplicity is Paramount.  The\
    \ control protocol will need to be\n      implement in very simple clients.  The\
    \ servers will need to\n      support extremely high loads.  The protocol will\
    \ need to be\n      extremely robust, being the precursor to a host of application\n\
    \      protocols.  As such, simplicity is key.\n"
- title: 14.5 Issues with Existing NAPT Boxes
  contents:
  - "14.5 Issues with Existing NAPT Boxes\n   From [17], any UNSAF proposal must provide:\n\
    \      Discussion of the impact of the noted practical issues with\n      existing,\
    \ deployed NA[P]Ts and experience reports.\n   Several of the practical issues\
    \ with STUN involve future proofing -\n   breaking the protocol when new NAT types\
    \ get deployed.  Fortunately,\n   this is not an issue at the current time, since\
    \ most of the deployed\n   NATs are of the types assumed by STUN.  The primary\
    \ usage STUN has\n   found is in the area of VoIP, to facilitate allocation of\
    \ addresses\n   for receiving RTP [12] traffic.  In that application, the periodic\n\
    \   keepalives are provided by the RTP traffic itself.  However, several\n   practical\
    \ problems arise for RTP.  First, RTP assumes that RTCP\n   traffic is on a port\
    \ one higher than the RTP traffic.  This pairing\n   property cannot be guaranteed\
    \ through NATs that are not directly\n   controllable.  As a result, RTCP traffic\
    \ may not be properly\n   received.  Protocol extensions to SDP have been proposed\
    \ which\n   mitigate this by allowing the client to signal a different port for\n\
    \   RTCP [18].  However, there will be interoperability problems for some\n  \
    \ time.\n   For VoIP, silence suppression can cause a gap in the transmission\
    \ of\n   RTP packets.  This could result in the loss of a binding in the\n   middle\
    \ of a call, if that silence period exceeds the binding timeout.\n   This can\
    \ be mitigated by sending occasional silence packets to keep\n   the binding alive.\
    \  However, the result is additional brittleness;\n   proper operation depends\
    \ on the silence suppression algorithm in use,\n   the usage of a comfort noise\
    \ codec, the duration of the silence\n   period, and the binding lifetime in the\
    \ NAT.\n"
- title: 14.6 In Closing
  contents:
  - "14.6 In Closing\n   The problems with STUN are not design flaws in STUN.  The\
    \ problems in\n   STUN have to do with the lack of standardized behaviors and\
    \ controls\n   in NATs.  The result of this lack of standardization has been a\n\
    \   proliferation of devices whose behavior is highly unpredictable,\n   extremely\
    \ variable, and uncontrollable.  STUN does the best it can in\n   such a hostile\
    \ environment.  Ultimately, the solution is to make the\n   environment less hostile,\
    \ and to introduce controls and standardized\n   behaviors into NAT.  However,\
    \ until such time as that happens, STUN\n   provides a good short term solution\
    \ given the terrible conditions\n   under which it is forced to operate.\n"
- title: 15.  Acknowledgments
  contents:
  - "15.  Acknowledgments\n   The authors would like to thank Cedric Aoun, Pete Cordell,\
    \ Cullen\n   Jennings, Bob Penfield and Chris Sullivan for their comments, and\n\
    \   Baruch Sterman and Alan Hawrylyshen for initial implementations.\n   Thanks\
    \ for Leslie Daigle, Allison Mankin, Eric Rescorla, and Henning\n   Schulzrinne\
    \ for IESG and IAB input on this work.\n"
- title: 16.  Normative References
  contents:
  - "16.  Normative References\n   [1]  Bradner, S., \"Key words for use in RFCs to\
    \ indicate requirement\n        levels\", BCP 14, RFC 2119, March 1997.\n   [2]\
    \  Dierks, T. and C. Allen, \"The TLS protocol Version 1.0\", RFC\n        2246,\
    \ January 1999.\n   [3]  Gulbrandsen, A., Vixie, P. and L. Esibov, \"A DNS RR\
    \ for\n        specifying the location of services (DNS SRV)\", RFC 2782,\n  \
    \      February 2000.\n   [4]  Chown, P., \"Advanced Encryption Standard (AES)\
    \ Ciphersuites for\n        Transport Layer Security (TLS)\", RFC 3268, June 2002.\n\
    \   [5]  Rescorla, E., \"HTTP over TLS\", RFC 2818, May 2000.\n   [6]  Postel,\
    \ J., \"Internet Protocol\", STD 5, RFC 791, September 1981.\n   [7]  Ferguson,\
    \ P. and D. Senie, \"Network Ingress Filtering: Defeating\n        Denial of Service\
    \ Attacks which employ IP Source Address\n        Spoofing\", BCP 38, RFC 2827,\
    \ May 2000.\n"
- title: 17.  Informative References
  contents:
  - "17.  Informative References\n   [8]  Senie, D., \"Network Address Translator\
    \ (NAT)-Friendly\n        Application Design Guidelines\", RFC 3235, January 2002.\n\
    \   [9]  Srisuresh, P., Kuthan, J., Rosenberg, J., Molitor, A. and A.\n      \
    \  Rayhan, \"Middlebox Communication Architecture and Framework\",\n        RFC\
    \ 3303, August 2002.\n   [10] Rosenberg, J., Schulzrinne, H., Camarillo, G., Johnston,\
    \ A.,\n        Peterson, J., Sparks, R., Handley, M. and E. Schooler, \"SIP:\n\
    \        Session Initiation Protocol\", RFC 3261, June 2002.\n   [11] Holdrege,\
    \ M. and P. Srisuresh, \"Protocol Complications with the\n        IP Network Address\
    \ Translator\", RFC 3027, January 2001.\n   [12] Schulzrinne, H., Casner, S.,\
    \ Frederick, R. and V. Jacobson,\n        \"RTP:  A Transport Protocol for Real-Time\
    \ Applications\", RFC\n        1889, January 1996.\n   [13] Krawczyk, H., Bellare,\
    \ M. and R. Canetti, \"HMAC: Keyed-Hashing\n        for Message Authentication\"\
    , RFC 2104, February 1997.\n   [14] Kohl, J. and C. Neuman, \"The kerberos Network\
    \ Authentication\n        Service (V5)\", RFC 1510, September 1993.\n   [15] Fielding,\
    \ R., Gettys, J., Mogul, J., Frystyk, H., Masinter, L.,\n        Leach, P. and\
    \ T. Berners-Lee, \"Hypertext Transfer Protocol --\n        HTTP/1.1\", RFC 2616,\
    \ June 1999.\n   [16] Baugher M., et al., \"The secure real-time transport protocol\"\
    ,\n        Work in Progress.\n   [17] Daigle, L., Editor, \"IAB Considerations\
    \ for UNilateral Self-\n        Address Fixing (UNSAF) Across Network Address\
    \ Translation\", RFC\n        3424, November 2002.\n   [18] Huitema, C., \"RTCP\
    \ attribute in SDP\", Work in Progress.\n"
- title: 18. Authors' Addresses
  contents:
  - "18. Authors' Addresses\n   Jonathan Rosenberg\n   dynamicsoft\n   72 Eagle Rock\
    \ Avenue\n   First Floor\n   East Hanover, NJ 07936\n   EMail: jdrosen@dynamicsoft.com\n\
    \   Joel Weinberger\n   dynamicsoft\n   72 Eagle Rock Avenue\n   First Floor\n\
    \   East Hanover, NJ 07936\n   EMail: jweinberger@dynamicsoft.com\n   Christian\
    \ Huitema\n   Microsoft Corporation\n   One Microsoft Way\n   Redmond, WA 98052-6399\n\
    \   EMail: huitema@microsoft.com\n   Rohan Mahy\n   Cisco Systems\n   101 Cooper\
    \ St\n   Santa Cruz, CA 95060\n   EMail: rohan@cisco.com\n"
- title: 19. Full Copyright Statement
  contents:
  - "19. Full Copyright Statement\n   Copyright (C) The Internet Society (2003). \
    \ All Rights Reserved.\n   This document and translations of it may be copied\
    \ and furnished to\n   others, and derivative works that comment on or otherwise\
    \ explain it\n   or assist in its implementation may be prepared, copied, published\n\
    \   and distributed, in whole or in part, without restriction of any\n   kind,\
    \ provided that the above copyright notice and this paragraph are\n   included\
    \ on all such copies and derivative works.  However, this\n   document itself\
    \ may not be modified in any way, such as by removing\n   the copyright notice\
    \ or references to the Internet Society or other\n   Internet organizations, except\
    \ as needed for the purpose of\n   developing Internet standards in which case\
    \ the procedures for\n   copyrights defined in the Internet Standards process\
    \ must be\n   followed, or as required to translate it into languages other than\n\
    \   English.\n   The limited permissions granted above are perpetual and will\
    \ not be\n   revoked by the Internet Society or its successors or assigns.\n \
    \  This document and the information contained herein is provided on an\n   \"\
    AS IS\" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING\n   TASK FORCE\
    \ DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING\n   BUT NOT LIMITED\
    \ TO ANY WARRANTY THAT THE USE OF THE INFORMATION\n   HEREIN WILL NOT INFRINGE\
    \ ANY RIGHTS OR ANY IMPLIED WARRANTIES OF\n   MERCHANTABILITY OR FITNESS FOR A\
    \ PARTICULAR PURPOSE.\n"
- title: Acknowledgement
  contents:
  - "Acknowledgement\n   Funding for the RFC Editor function is currently provided\
    \ by the\n   Internet Society.\n"
