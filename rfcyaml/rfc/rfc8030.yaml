- contents:
  - '                 Generic Event Delivery Using HTTP Push

    '
  title: __initial_text__
- contents:
  - "Abstract\n   This document describes a simple protocol for the delivery of real-\n
    \  time events to user agents.  This scheme uses HTTP/2 server push.\n"
  title: Abstract
- contents:
  - "Status of This Memo\n   This is an Internet Standards Track document.\n   This
    document is a product of the Internet Engineering Task Force\n   (IETF).  It represents
    the consensus of the IETF community.  It has\n   received public review and has
    been approved for publication by the\n   Internet Engineering Steering Group (IESG).
    \ Further information on\n   Internet Standards is available in Section 2 of RFC
    7841.\n   Information about the current status of this document, any errata,\n
    \  and how to provide feedback on it may be obtained at\n   http://www.rfc-editor.org/info/rfc8030.\n"
  title: Status of This Memo
- contents:
  - "Copyright Notice\n   Copyright (c) 2016 IETF Trust and the persons identified
    as the\n   document authors.  All rights reserved.\n   This document is subject
    to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n
    \  (http://trustee.ietf.org/license-info) in effect on the date of\n   publication
    of this document.  Please review these documents\n   carefully, as they describe
    your rights and restrictions with respect\n   to this document.  Code Components
    extracted from this document must\n   include Simplified BSD License text as described
    in Section 4.e of\n   the Trust Legal Provisions and are provided without warranty
    as\n   described in the Simplified BSD License.\n"
  title: Copyright Notice
- contents:
  - "Table of Contents\n   1.  Introduction  . . . . . . . . . . . . . . . . . . .
    . . . . .   3\n     1.1.  Conventions and Terminology . . . . . . . . . . . .
    . . .   4\n   2.  Overview  . . . . . . . . . . . . . . . . . . . . . . . . .
    .   6\n     2.1.  HTTP Resources  . . . . . . . . . . . . . . . . . . . . .   7\n
    \  3.  Connecting to the Push Service  . . . . . . . . . . . . . . .   8\n   4.
    \ Subscribing for Push Messages . . . . . . . . . . . . . . . .   8\n     4.1.
    \ Collecting Subscriptions into Sets  . . . . . . . . . . .   9\n   5.  Requesting
    Push Message Delivery  . . . . . . . . . . . . . .  10\n     5.1.  Requesting
    Push Message Receipts  . . . . . . . . . . . .  10\n     5.2.  Push Message Time-To-Live
    . . . . . . . . . . . . . . . .  11\n     5.3.  Push Message Urgency  . . . .
    . . . . . . . . . . . . . .  13\n     5.4.  Replacing Push Messages . . . . .
    . . . . . . . . . . . .  14\n   6.  Receiving Push Messages for a Subscription
    \ . . . . . . . . .  15\n     6.1.  Receiving Push Messages for a Subscription
    Set  . . . . .  17\n     6.2.  Acknowledging Push Messages . . . . . . . . . .
    . . . . .  18\n     6.3.  Receiving Push Message Receipts . . . . . . . . . .
    . . .  19\n   7.  Operational Considerations  . . . . . . . . . . . . . . . .
    .  20\n     7.1.  Load Management . . . . . . . . . . . . . . . . . . . . .  20\n
    \    7.2.  Push Message Expiration . . . . . . . . . . . . . . . . .  20\n     7.3.
    \ Subscription Expiration . . . . . . . . . . . . . . . . .  21\n       7.3.1.
    \ Subscription Set Expiration . . . . . . . . . . . . .  21\n     7.4.  Implications
    for Application Reliability  . . . . . . . .  22\n     7.5.  Subscription Sets
    and Concurrent HTTP/2 Streams . . . . .  22\n   8.  Security Considerations .
    . . . . . . . . . . . . . . . . . .  22\n     8.1.  Confidentiality from Push
    Service Access  . . . . . . . .  23\n     8.2.  Privacy Considerations  . . .
    . . . . . . . . . . . . . .  23\n     8.3.  Authorization . . . . . . . . . .
    . . . . . . . . . . . .  24\n     8.4.  Denial-of-Service Considerations  . .
    . . . . . . . . . .  25\n     8.5.  Logging Risks . . . . . . . . . . . . . .
    . . . . . . . .  25\n   9.  IANA Considerations . . . . . . . . . . . . . . .
    . . . . . .  26\n     9.1.  Header Field Registrations  . . . . . . . . . . .
    . . . .  26\n     9.2.  Link Relation URNs  . . . . . . . . . . . . . . . . .
    . .  26\n     9.3.  Service Name and Port Number Registration . . . . . . . .
    \ 28\n   10. References  . . . . . . . . . . . . . . . . . . . . . . . . .  28\n
    \    10.1.  Normative References . . . . . . . . . . . . . . . . . .  28\n     10.2.
    \ Informative References . . . . . . . . . . . . . . . . .  30\n   Acknowledgements
    \ . . . . . . . . . . . . . . . . . . . . . . . .  31\n   Authors' Addresses  .
    . . . . . . . . . . . . . . . . . . . . . .  31\n"
  title: Table of Contents
- contents:
  - "1.  Introduction\n   Many applications on mobile and embedded devices require
    continuous\n   access to network communications so that real-time events -- such
    as\n   incoming calls or messages -- can be delivered (or \"pushed\") in a\n   timely
    fashion.  These devices typically have limited power reserves,\n   so finding
    more efficient ways to serve application requirements\n   greatly benefits the
    application ecosystem.\n   One significant contributor to power usage is the radio.
    \ Radio\n   communications consume a significant portion of the energy budget
    on\n   a wireless device.\n   Uncoordinated use of persistent connections or sessions
    from multiple\n   applications can contribute to unnecessary use of the device
    radio,\n   since each independent session can incur its own overhead.  In\n   particular,
    keep-alive traffic used to ensure that middleboxes do not\n   prematurely time
    out sessions can result in significant waste.\n   Maintenance traffic tends to
    dominate over the long term, since\n   events are relatively rare.\n   Consolidating
    all real-time events into a single session ensures more\n   efficient use of network
    and radio resources.  A single service\n   consolidates all events, distributing
    those events to applications as\n   they arrive.  This requires just one session,
    avoiding duplicated\n   overhead costs.\n   The W3C Push API [API] describes an
    API that enables the use of a\n   consolidated push service from web applications.
    \ This document\n   expands on that work by describing a protocol that can be
    used to:\n   o  request the delivery of a push message to a user agent,\n   o
    \ create new push message delivery subscriptions, and\n   o  monitor for new push
    messages.\n   A standardized method of event delivery is particularly important
    for\n   the W3C Push API, where application servers might need to use\n   multiple
    push services.  The subscription, management, and monitoring\n   functions are
    currently fulfilled by proprietary protocols; these are\n   adequate, but do not
    offer any of the advantages that standardization\n   affords.\n   This document
    intentionally does not describe how a push service is\n   discovered.  Discovery
    of push services is left for future efforts,\n   if it turns out to be necessary
    at all.  User agents are expected to\n   be configured with a URL for a push service.\n"
  - contents:
    - "1.1.  Conventions and Terminology\n   The key words \"MUST\", \"MUST NOT\",
      \"REQUIRED\", \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\",
      \"MAY\", and \"OPTIONAL\" in this\n   document are to be interpreted as described
      in [RFC2119].\n   This document defines the following terms:\n   application:
      \ Both the sender and the ultimate consumer of push\n      messages.  Many applications
      have components that are run on a\n      user agent and other components that
      run on servers.\n   application server:  The component of an application that
      usually\n      runs on a server and requests the delivery of a push message.\n
      \  push message subscription:  A message delivery context that is\n      established
      between the user agent and the push service, and\n      shared with the application
      server.  All push messages are\n      associated with a push message subscription.\n
      \  push message subscription set:  A message delivery context that is\n      established
      between the user agent and the push service that\n      collects multiple push
      message subscriptions into a set.\n   push message:  A message sent from an
      application server to a user\n      agent via a push service.\n   push message
      receipt:  A message delivery confirmation sent from the\n      push service
      to the application server.\n   push service:  A service that delivers push messages
      to user agents.\n   user agent:  A device and software that is the recipient
      of push\n      messages.\n   Examples in this document use the HTTP/1.1 message
      format [RFC7230].\n   Many of the exchanges can be completed using HTTP/1.1:\n
      \  o  Subscribing for Push Messages (Section 4)\n   o  Requesting Push Message
      Delivery (Section 5)\n   o  Replacing Push Messages (Section 5.4)\n   o  Acknowledging
      Push Messages (Section 6.2)\n   When an example depends on HTTP/2 server push,
      the more verbose frame\n   format from [RFC7540] is used:\n   o  Receiving Push
      Messages for a Subscription (Section 6)\n   o  Receiving Push Messages for a
      Subscription Set (Section 6.1)\n   o  Receiving Push Message Receipts (Section
      6.3)\n   All examples use HTTPS over the default port (443) rather than the\n
      \  registered port (1001).  A push service deployment might prefer this\n   configuration
      to maximize chances for user agents to reach the\n   service.  A push service
      might use HTTP alternative services to\n   redirect a user agent to the registered
      port (1001) to gain the\n   benefits of the standardized HTTPS port without
      sacrificing\n   reachability (see Section 3).  This would only be apparent in
      the\n   examples through the inclusion of the Alt-Used header field [RFC7838]\n
      \  in requests from the user agent to the push service.\n   Examples do not
      include specific methods for push message encryption\n   or application server
      authentication because the protocol does not\n   define a mandatory system.
      \ The examples in Voluntary Application\n   Server Identification [VAPID] and
      Message Encryption for WebPush\n   [ENCRYPT] demonstrate the approach adopted
      by the W3C Push API [API]\n   for its requirements.\n"
    title: 1.1.  Conventions and Terminology
  title: 1.  Introduction
- contents:
  - "2.  Overview\n   A general model for push services includes three basic actors:
    a user\n   agent, a push service, and an application (server).\n    +-------+
    \          +--------------+       +-------------+\n    |  UA   |           | Push
    Service |       | Application |\n    +-------+           +--------------+       |
    \  Server    |\n        |                      |               +-------------+\n
    \       |      Subscribe       |                      |\n        |--------------------->|
    \                     |\n        |       Monitor        |                      |\n
    \       |<====================>|                      |\n        |                      |
    \                     |\n        |          Distribute Push Resource           |\n
    \       |-------------------------------------------->|\n        |                      |
    \                     |\n        :                      :                      :\n
    \       |                      |     Push Message     |\n        |    Push Message
    \     |<---------------------|\n        |<---------------------|                      |\n
    \       |                      |                      |\n                      Figure
    1: WebPush Architecture\n   At the very beginning of the process, a new message
    subscription is\n   created by the user agent and then distributed to its application\n
    \  server.  This subscription is the basis of all future interactions\n   between
    the actors.  A subscription is used by the application server\n   to send messages
    to the push service for delivery to the user agent.\n   The user agent uses the
    subscription to monitor the push service for\n   any incoming message.\n   To
    offer more control for authorization, a message subscription is\n   modeled as
    two resources with different capabilities:\n   o  A subscription resource is used
    to receive messages from a\n      subscription and to delete a subscription.  It
    is private to the\n      user agent.\n   o  A push resource is used to send messages
    to a subscription.  It is\n      public and shared by the user agent with its
    application server.\n   It is expected that a unique subscription will be distributed
    to each\n   application; however, there are no inherent cardinality constraints\n
    \  in the protocol.  Multiple subscriptions might be created for the\n   same
    application, or multiple applications could use the same\n   subscription.  Note,
    however, that sharing subscriptions has security\n   and privacy implications.\n
    \  Subscriptions have a limited lifetime.  They can also be terminated\n   by
    either the push service or the user agent at any time.  User\n   agents and application
    servers must be prepared to manage changes in\n   the subscription state.\n"
  - contents:
    - "2.1.  HTTP Resources\n   This protocol uses HTTP resources [RFC7230] and link
      relations\n   [RFC5988].  The following resources are defined:\n   push service:
      \ This resource is used to create push message\n      subscriptions (Section
      4).  A URL for the push service is\n      configured into user agents.\n   push
      message subscription:  This resource provides read and delete\n      access
      for a message subscription.  A user agent receives push\n      messages (Section
      6) using a push message subscription.  Every\n      push message subscription
      has exactly one push resource associated\n      with it.\n   push message subscription
      set:  This resource provides read and\n      delete access for a collection
      of push message subscriptions.  A\n      user agent receives push messages (Section
      6.1) for all the push\n      message subscriptions in the set.  A link relation
      of type\n      \"urn:ietf:params:push:set\" identifies a push message subscription\n
      \     set.\n   push:  An application server requests the delivery (Section 5)
      of a\n      push message using a push resource.  A link relation of type\n      \"urn:ietf:params:push\"
      identifies a push resource.\n   push message:  The push service creates a push
      message resource to\n      identify push messages that have been accepted for
      delivery\n      (Section 5).  The push message resource is also deleted by the\n
      \     user agent to acknowledge receipt (Section 6.2) of a push message.\n   receipt
      subscription:  An application server receives delivery\n      confirmations
      (Section 5.1) for push messages using a receipt\n      subscription.  A link
      relation of type\n      \"urn:ietf:params:push:receipt\" identifies a receipt
      subscription.\n"
    title: 2.1.  HTTP Resources
  title: 2.  Overview
- contents:
  - "3.  Connecting to the Push Service\n   The push service MUST use HTTP over Transport
    Layer Security (TLS)\n   [RFC2818] following the recommendations in [RFC7525].
    \ The push\n   service shares the same default port number (443/TCP) with HTTPS,
    but\n   MAY also advertise the IANA-allocated TCP System Port (1001) using\n   HTTP
    alternative services [RFC7838].\n   While the default port (443) offers broad
    reachability\n   characteristics, it is most often used for web-browsing scenarios\n
    \  with a lower idle timeout than other ports configured in middleboxes.\n   For
    WebPush scenarios, this would contribute to unnecessary radio\n   communications
    to maintain the connection on battery-powered devices.\n   Advertising the alternate
    port (1001) allows middleboxes to optimize\n   idle timeouts for connections specific
    to push scenarios with the\n   expectation that data exchange will be infrequent.\n
    \  Middleboxes SHOULD comply with REQ-5 in [RFC5382], which states that\n   \"the
    value of the 'established connection idle-timeout' MUST NOT be\n   less than 2
    hours 4 minutes\".\n"
  title: 3.  Connecting to the Push Service
- contents:
  - "4.  Subscribing for Push Messages\n   A user agent sends a POST request to its
    configured push service\n   resource to create a new subscription.\n   POST /subscribe
    HTTP/1.1\n   Host: push.example.net\n   A 201 (Created) response indicates that
    the push subscription was\n   created.  A URI for the push message subscription
    resource that was\n   created in response to the request MUST be returned in the
    Location\n   header field.\n   The push service MUST provide a URI for the push
    resource\n   corresponding to the push message subscription in a link relation
    of\n   type \"urn:ietf:params:push\".\n   An application-specific method is used
    to distribute the push URI to\n   the application server.  Confidentiality protection
    and application\n   server authentication MUST be used to ensure that this URI
    is not\n   disclosed to unauthorized recipients (Section 8.3).\n   HTTP/1.1 201
    Created\n   Date: Thu, 11 Dec 2014 23:56:52 GMT\n   Link: </push/JzLQ3raZJfFBR0aqvOMsLrt54w4rJUsV>;\n
    \          rel=\"urn:ietf:params:push\"\n   Link: </subscription-set/4UXwi2Rd7jGS7gp5cuutF8ZldnEuvbOy>;\n
    \          rel=\"urn:ietf:params:push:set\"\n   Location: https://push.example.net/subscription/LBhhw0OohO-Wl4Oi971UG\n"
  - contents:
    - "4.1.  Collecting Subscriptions into Sets\n   Collecting multiple push message
      subscriptions into a subscription\n   set can represent a significant efficiency
      improvement for push\n   services and user agents.  The push service MAY provide
      a URI for a\n   subscription set resource in a link relation of type\n   \"urn:ietf:params:push:set\".\n
      \  When a subscription set is returned in a push message subscription\n   response,
      the user agent SHOULD include this subscription set in a\n   link relation of
      type \"urn:ietf:params:push:set\" in subsequent\n   requests to create new push
      message subscriptions.\n   A user agent MAY omit the subscription set if it
      is unable to receive\n   push messages in an aggregated way for the lifetime
      of the\n   subscription.  This might be necessary if the user agent is\n   monitoring
      subscriptions on behalf of other push message receivers.\n   POST /subscribe
      HTTP/1.1\n   Host: push.example.net\n   Link: </subscription-set/4UXwi2Rd7jGS7gp5cuutF8ZldnEuvbOy>;\n
      \          rel=\"urn:ietf:params:push:set\"\n   The push service SHOULD return
      the same subscription set in its\n   response, although it MAY return a new
      subscription set if it is\n   unable to reuse the one provided by the user agent.\n
      \  HTTP/1.1 201 Created\n   Date: Thu, 11 Dec 2014 23:56:52 GMT\n   Link: </push/YBJNBIMwwA_Ag8EtD47J4A>;\n
      \          rel=\"urn:ietf:params:push\"\n   Link: </subscription-set/4UXwi2Rd7jGS7gp5cuutF8ZldnEuvbOy>;\n
      \          rel=\"urn:ietf:params:push:set\"\n   Location: https://push.example.net/subscription/i-nQ3A9Zm4kgSWg8_ZijV\n
      \  A push service MUST return a 400 (Bad Request) status code for\n   requests
      that contain an invalid subscription set.  A push service\n   MAY return a 429
      (Too Many Requests) status code [RFC6585] to reject\n   requests that omit a
      subscription set.\n   How a push service detects that requests originate from
      the same user\n   agent is implementation-specific but could take ambient information\n
      \  into consideration, such as the TLS connection, source IP address,\n   and
      port.  Implementers are reminded that some heuristics can produce\n   false
      positives and hence, cause requests to be rejected incorrectly.\n"
    title: 4.1.  Collecting Subscriptions into Sets
  title: 4.  Subscribing for Push Messages
- contents:
  - "5.  Requesting Push Message Delivery\n   An application server requests the delivery
    of a push message by\n   sending an HTTP POST request to a push resource distributed
    to the\n   application server by a user agent.  The content of the push message\n
    \  is included in the body of the request.\n   POST /push/JzLQ3raZJfFBR0aqvOMsLrt54w4rJUsV
    HTTP/1.1\n   Host: push.example.net\n   TTL: 15\n   Content-Type: text/plain;charset=utf8\n
    \  Content-Length: 36\n   iChYuI3jMzt3ir20P8r_jgRR-dSuN182x7iB\n   A 201 (Created)
    response indicates that the push message was\n   accepted.  A URI for the push
    message resource that was created in\n   response to the request MUST be returned
    in the Location header\n   field.  This does not indicate that the message was
    delivered to the\n   user agent.\n   HTTP/1.1 201 Created\n   Date: Thu, 11 Dec
    2014 23:56:55 GMT\n   Location: https://push.example.net/message/qDIYHNcfAIPP_5ITvURr-d6BGt\n"
  - contents:
    - "5.1.  Requesting Push Message Receipts\n   An application server can include
      the Prefer header field [RFC7240]\n   with the \"respond-async\" preference
      to request confirmation from the\n   push service when a push message is delivered
      and then acknowledged\n   by the user agent.  The push service MUST support
      delivery\n   confirmations.\n   POST /push/JzLQ3raZJfFBR0aqvOMsLrt54w4rJUsV
      HTTP/1.1\n   Host: push.example.net\n   Prefer: respond-async\n   TTL: 15\n
      \  Content-Type: text/plain;charset=utf8\n   Content-Length: 36\n   iChYuI3jMzt3ir20P8r_jgRR-dSuN182x7iB\n
      \  When the push service accepts the message for delivery with\n   confirmation,
      it MUST return a 202 (Accepted) response.  A URI for\n   the push message resource
      that was created in response to the request\n   MUST be returned in the Location
      header field.  The push service MUST\n   also provide a URI for the receipt
      subscription resource in a link\n   relation of type \"urn:ietf:params:push:receipt\".\n
      \  HTTP/1.1 202 Accepted\n   Date: Thu, 11 Dec 2014 23:56:55 GMT\n   Link: </receipt-subscription/3ZtI4YVNBnUUZhuoChl6omUvG4ZM>;\n
      \          rel=\"urn:ietf:params:push:receipt\"\n   Location: https://push.example.net/message/qDIYHNcfAIPP_5ITvURr-d6BGt\n
      \  For subsequent receipt requests to the same origin [RFC6454], the\n   application
      server SHOULD include the returned receipt subscription\n   in a link relation
      of type \"urn:ietf:params:push:receipt\".  This\n   gives the push service the
      option to aggregate the receipts.  The\n   push service SHOULD return the same
      receipt subscription in its\n   response, although it MAY return a new receipt
      subscription if it is\n   unable to reuse the one provided by the application
      server.\n   An application server MAY omit the receipt subscription if it is\n
      \  unable to receive receipts in an aggregated way for the lifetime of\n   the
      receipt subscription.  This might be necessary if the application\n   server
      is monitoring receipt subscriptions on behalf of the other\n   push message
      senders.\n   A push service MUST return a 400 (Bad Request) status code for\n
      \  requests that contain an invalid receipt subscription.  If a push\n   service
      wishes to limit the number of receipt subscriptions that it\n   maintains, it
      MAY return a 429 (Too Many Requests) status code\n   [RFC6585] to reject receipt
      requests that omit a receipt\n   subscription.\n"
    title: 5.1.  Requesting Push Message Receipts
  - contents:
    - "5.2.  Push Message Time-To-Live\n   A push service can improve the reliability
      of push message delivery\n   considerably by storing push messages for a period.
      \ User agents are\n   often only intermittently connected, and so benefit from
      having\n   short-term message storage at the push service.\n   Delaying delivery
      might also be used to batch communication with the\n   user agent, thereby conserving
      radio resources.\n   Some push messages are not useful once a certain period
      of time\n   elapses.  Delivery of messages after they have ceased to be relevant\n
      \  is wasteful.  For example, if the push message contains a call\n   notification,
      receiving a message after the caller has abandoned the\n   call is of no value;
      the application at the user agent is forced to\n   suppress the message so that
      it does not generate a useless alert.\n   An application server MUST include
      the TTL (Time-To-Live) header\n   field in its request for push message delivery.
      \ The TTL header field\n   contains a value in seconds that suggests how long
      a push message is\n   retained by the push service.\n   The TTL rule specifies
      a non-negative integer, representing time in\n   seconds.  A recipient parsing
      and converting a TTL value to binary\n   form SHOULD use an arithmetic type
      of at least 31 bits of non-\n   negative integer range.  If a recipient receives
      a TTL value greater\n   than the greatest integer it can represent, or if any
      of its\n   subsequent calculations overflows, it MUST consider the value to
      be\n   2147483648 (2^31).\n   TTL = 1*DIGIT\n   A push service MUST return a
      400 (Bad Request) status code in\n   response to requests that omit the TTL
      header field.\n   A push service MAY retain a push message for a shorter duration
      than\n   requested.  It indicates this by returning a TTL header field in its\n
      \  response with the actual TTL.  This TTL value MUST be less than or\n   equal
      to the value provided by the application server.\n   Once the TTL period elapses,
      the push service MUST NOT attempt to\n   deliver the push message to the user
      agent.  A push service might\n   adjust the TTL value to account for time accounting
      errors in\n   processing.  For instance, distributing a push message within
      a\n   server cluster might accrue errors due to clock skew or propagation\n
      \  delays.\n   A push service is not obligated to account for time spent by
      the\n   application server in sending a push message to the push service, or\n
      \  delays incurred while sending a push message to the user agent.  An\n   application
      server needs to account for transit delays in selecting a\n   TTL header field
      value.\n   A Push message with a zero TTL is immediately delivered if the user\n
      \  agent is available to receive the message.  After delivery, the push\n   service
      is permitted to immediately remove a push message with a zero\n   TTL.  This
      might occur before the user agent acknowledges receipt of\n   the message by
      performing an HTTP DELETE on the push message\n   resource.  Consequently, an
      application server cannot rely on\n   receiving acknowledgement receipts for
      zero TTL push messages.\n   If the user agent is unavailable, a push message
      with a zero TTL\n   expires and is never delivered.\n"
    title: 5.2.  Push Message Time-To-Live
  - contents:
    - "5.3.  Push Message Urgency\n   For a device that is battery-powered, it is
      often critical that it\n   remains dormant for extended periods.  Radio communication
      in\n   particular consumes significant power and limits the length of time\n
      \  that the device can operate.\n   To avoid consuming resources to receive
      trivial messages, it is\n   helpful if an application server can communicate
      the urgency of a\n   message and if the user agent can request that the push
      server only\n   forwards messages of a specific urgency.\n   An application
      server MAY include an Urgency header field in its\n   request for push message
      delivery.  This header field indicates the\n   message urgency.  The push service
      MUST NOT forward the Urgency\n   header field to the user agent.  A push message
      without the Urgency\n   header field defaults to a value of \"normal\".\n   A
      user agent MAY include the Urgency header field when monitoring for\n   push
      messages to indicate the lowest urgency of push messages that it\n   is willing
      to receive.  A push service MUST NOT deliver push messages\n   with lower urgency
      than the value indicated by the user agent in its\n   monitoring request.  Push
      messages of any urgency are delivered to a\n   user agent that does not include
      an Urgency header field when\n   monitoring for messages.\n   The grammar for
      the Urgency header field is as follows:\n   Urgency = urgency-option\n   urgency-option
      = (\"very-low\" / \"low\" / \"normal\" / \"high\")\n   In order of increasing
      urgency:\n   +----------+-----------------------------+--------------------------+\n
      \  | Urgency  | Device State                | Example Application      |\n   |
      \         |                             | Scenario                 |\n   +----------+-----------------------------+--------------------------+\n
      \  | very-low | On power and Wi-Fi          | Advertisements           |\n   |
      low      | On either power or Wi-Fi    | Topic updates            |\n   | normal
      \  | On neither power nor Wi-Fi  | Chat or Calendar Message |\n   | high     |
      Low battery                 | Incoming phone call or   |\n   |          |                             |
      time-sensitive alert     |\n   +----------+-----------------------------+--------------------------+\n
      \                  Table 1: Illustrative Urgency Values\n   Multiple values
      for the Urgency header field MUST NOT be included in\n   requests; otherwise,
      the push service MUST return a 400 (Bad Request)\n   status code.\n"
    title: 5.3.  Push Message Urgency
  - contents:
    - "5.4.  Replacing Push Messages\n   A push message that has been stored by the
      push service can be\n   replaced with new content.  If the user agent is offline
      during the\n   time that the push messages are sent, updating a push message
      avoids\n   the situation where outdated or redundant messages are sent to the\n
      \  user agent.\n   Only push messages that have been assigned a topic can be
      replaced.\n   A push message with a topic replaces any outstanding push message\n
      \  with an identical topic.\n   A push message topic is a string carried in
      a Topic header field.  A\n   topic is used to correlate push messages sent to
      the same\n   subscription and does not convey any other semantics.\n   The grammar
      for the Topic header field uses the \"token\" rule defined\n   in [RFC7230].\n
      \  Topic = token\n   For use with this protocol, the Topic header field MUST
      be restricted\n   to no more than 32 characters from the URL and a filename-safe
      Base\n   64 alphabet [RFC4648].  A push service that receives a request with
      a\n   Topic header field that does not meet these constraints MUST return a\n
      \  400 (Bad Request) status code to the application server.\n   A push message
      replacement request creates a new push message\n   resource and simultaneously
      deletes any existing message resource\n   that has a matching topic.  If an
      attempt was made to deliver the\n   deleted push message, an acknowledgment
      could arrive at the push\n   service after the push message has been replaced.
      \ Delivery receipts\n   for such deleted messages SHOULD be suppressed.\n   The
      replacement request also replaces the stored TTL, Urgency, and\n   any receipt
      subscription associated with the previous message in the\n   matching topic.\n
      \  A push message with a topic that is not shared by an outstanding\n   message
      to the same subscription is stored or delivered as normal.\n   For example,
      the following message could cause an existing message to\n   be replaced:\n
      \  POST /push/JzLQ3raZJfFBR0aqvOMsLrt54w4rJUsV HTTP/1.1\n   Host: push.example.net\n
      \  TTL: 600\n   Topic: upd\n   Content-Type: text/plain;charset=utf8\n   Content-Length:
      36\n   ZuHSZPKa2b1jtOKLGpWrcrn8cNqt0iVQyroF\n   If the push service identifies
      an outstanding push message with a\n   topic of \"upd\", then that message resource
      is deleted.  A 201\n   (Created) response indicates that the push message replacement
      was\n   accepted.  A URI for the new push message resource that was created\n
      \  in response to the request is included in the Location header field.\n   HTTP/1.1
      201 Created\n   Date: Thu, 11 Dec 2014 23:57:02 GMT\n   Location: https://push.example.net/message/qDIYHNcfAIPP_5ITvURr-d6BGt\n
      \  The value of the Topic header field MUST NOT be forwarded to user\n   agents.
      \ Its value is neither encrypted nor authenticated.\n"
    title: 5.4.  Replacing Push Messages
  title: 5.  Requesting Push Message Delivery
- contents:
  - "6.  Receiving Push Messages for a Subscription\n   A user agent requests the
    delivery of new push messages by making a\n   GET request to a push message subscription
    resource.  The push\n   service does not respond to this request; instead, it
    uses HTTP/2\n   server push [RFC7540] to send the contents of push messages as
    they\n   are sent by application servers.\n   A user agent MAY include an Urgency
    header field in its request.  The\n   push service MUST NOT deliver messages with
    lower urgency than the\n   value of the header field as defined in Table 1 (Illustrative
    Urgency\n   Values).\n   Each push message is pushed as the response to a synthesized
    GET\n   request sent in a PUSH_PROMISE.  This GET request is made to the push\n
    \  message resource that was created by the push service when the\n   application
    server requested message delivery.  The response headers\n   SHOULD provide a
    URI for the push resource corresponding to the push\n   message subscription in
    a link relation of type\n   \"urn:ietf:params:push\".  The response body is the
    entity body from\n   the most recent request sent to the push resource by the
    application\n   server.\n   The following example request is made over HTTP/2:\n
    \  HEADERS      [stream 7] +END_STREAM +END_HEADERS\n     :method        = GET\n
    \    :path          = /subscription/LBhhw0OohO-Wl4Oi971UG\n     :authority     =
    push.example.net\n   The push service permits the request to remain outstanding.
    \ When a\n   push message is sent by an application server, a server push is\n
    \  generated in association with the initial request.  The response for\n   the
    server push includes the push message.\n   PUSH_PROMISE [stream 7; promised stream
    4] +END_HEADERS\n     :method        = GET\n     :path          = /message/qDIYHNcfAIPP_5ITvURr-d6BGt\n
    \    :authority     = push.example.net\n   HEADERS      [stream 4] +END_HEADERS\n
    \    :status        = 200\n     date           = Thu, 11 Dec 2014 23:56:56 GMT\n
    \    last-modified  = Thu, 11 Dec 2014 23:56:55 GMT\n     cache-control  = private\n
    \    link           = </push/JzLQ3raZJfFBR0aqvOMsLrt54w4rJUsV>;\n                       rel=\"urn:ietf:params:push\"\n
    \    content-type   = text/plain;charset=utf8\n     content-length = 36\n   DATA
    \        [stream 4] +END_STREAM\n     iChYuI3jMzt3ir20P8r_jgRR-dSuN182x7iB\n   HEADERS
    \     [stream 7] +END_STREAM +END_HEADERS\n     :status        = 200\n   A user
    agent can also request the contents of the push message\n   subscription resource
    immediately by including a Prefer header field\n   [RFC7240] with a \"wait\" preference
    set to \"0\".  In response to this\n   request, the push service MUST generate
    a server push for all push\n   messages that have not yet been delivered.\n   A
    204 (No Content) status code with no associated server pushes\n   indicates that
    no messages are presently available.  This could be\n   because push messages
    have expired.\n"
  - contents:
    - "6.1.  Receiving Push Messages for a Subscription Set\n   There are minor differences
      between receiving push messages for a\n   subscription and a subscription set.
      \ If a subscription set is\n   available, the user agent SHOULD use the subscription
      set to monitor\n   for push messages rather than individual push message subscriptions.\n
      \  A user agent requests the delivery of new push messages for a\n   collection
      of push message subscriptions by making a GET request to a\n   push message
      subscription set resource.  The push service does not\n   respond to this request;
      instead, it uses HTTP/2 server push\n   [RFC7540] to send the contents of push
      messages as they are sent by\n   application servers.\n   A user agent MAY include
      an Urgency header field in its request.  The\n   push service MUST NOT deliver
      messages with lower urgency than the\n   value of the header field as defined
      in Table 1 (Illustrative Urgency\n   Values).\n   Each push message is pushed
      as the response to a synthesized GET\n   request sent in a PUSH_PROMISE.  This
      GET request is made to the push\n   message resource that was created by the
      push service when the\n   application server requested message delivery.  The
      synthetic request\n   MUST provide a URI for the push resource corresponding
      to the push\n   message subscription in a link relation of type\n   \"urn:ietf:params:push\".
      \ This enables the user agent to differentiate\n   the source of the message.
      \ The response body is the entity body from\n   the most recent request sent
      to the push resource by an application\n   server.\n   The following example
      request is made over HTTP/2.\n   HEADERS      [stream 7] +END_STREAM +END_HEADERS\n
      \    :method        = GET\n     :path          = /subscription-set/4UXwi2Rd7jGS7gp5cuutF8ZldnEuvbOy\n
      \    :authority     = push.example.net\n   The push service permits the request
      to remain outstanding.  When a\n   push message is sent by an application server,
      a server push is\n   generated in association with the initial request.  The
      server push's\n   response includes the push message.\n   PUSH_PROMISE [stream
      7; promised stream 4] +END_HEADERS\n     :method        = GET\n     :path          =
      /message/qDIYHNcfAIPP_5ITvURr-d6BGt\n     :authority     = push.example.net\n
      \  HEADERS      [stream 4] +END_HEADERS\n     :status        = 200\n     date
      \          = Thu, 11 Dec 2014 23:56:56 GMT\n     last-modified  = Thu, 11 Dec
      2014 23:56:55 GMT\n     link           = </push/JzLQ3raZJfFBR0aqvOMsLrt54w4rJUsV>;\n
      \                      rel=\"urn:ietf:params:push\"\n     cache-control  = private\n
      \    content-type   = text/plain;charset=utf8\n     content-length = 36\n   DATA
      \        [stream 4] +END_STREAM\n     iChYuI3jMzt3ir20P8r_jgRR-dSuN182x7iB\n
      \  HEADERS      [stream 7] +END_STREAM +END_HEADERS\n     :status        = 200\n
      \  A user agent can request the contents of the push message\n   subscription
      set resource immediately by including a Prefer header\n   field [RFC7240] with
      a \"wait\" preference set to \"0\".  In response to\n   this request, the push
      service MUST generate a server push for all\n   push messages that have not
      yet been delivered.\n   A 204 (No Content) status code with no associated server
      pushes\n   indicates that no messages are presently available.  This could be\n
      \  because push messages have expired.\n"
    title: 6.1.  Receiving Push Messages for a Subscription Set
  - contents:
    - "6.2.  Acknowledging Push Messages\n   To ensure that a push message is properly
      delivered to the user agent\n   at least once, the user agent MUST acknowledge
      receipt of the message\n   by performing an HTTP DELETE on the push message
      resource.\n   DELETE /message/qDIYHNcfAIPP_5ITvURr-d6BGt HTTP/1.1\n   Host:
      push.example.net\n   If the push service receives the acknowledgement and the
      application\n   has requested a delivery receipt, the push service MUST return
      a 204\n   (No Content) response to the application server monitoring the\n   receipt
      subscription.\n   If the push service does not receive the acknowledgement within
      a\n   reasonable amount of time, then the message is considered to be not\n
      \  yet delivered.  The push service SHOULD continue to retry delivery of\n   the
      message until its advertised expiration.\n   The push service MAY cease to retry
      delivery of the message prior to\n   its advertised expiration due to scenarios
      such as an unresponsive\n   user agent or operational constraints.  If the application
      has\n   requested a delivery receipt, then the push service MUST return a 410\n
      \  (Gone) response to the application server monitoring the receipt\n   subscription.\n"
    title: 6.2.  Acknowledging Push Messages
  - contents:
    - "6.3.  Receiving Push Message Receipts\n   The application server requests the
      delivery of receipts from the\n   push service by making an HTTP GET request
      to the receipt\n   subscription resource.  The push service does not respond
      to this\n   request; instead, it uses HTTP/2 server push [RFC7540] to send push\n
      \  receipts when messages are acknowledged (Section 6.2) by the user\n   agent.\n
      \  Each receipt is pushed as the response to a synthesized GET request\n   sent
      in a PUSH_PROMISE.  This GET request is made to the same push\n   message resource
      that was created by the push service when the\n   application server requested
      message delivery.  The response includes\n   a status code indicating the result
      of the message delivery and\n   carries no data.\n   The following example request
      is made over HTTP/2.\n   HEADERS      [stream 13] +END_STREAM +END_HEADERS\n
      \    :method        = GET\n     :path          = /receipt-subscription/3ZtI4YVNBnUUZhuoChl6omUvG4ZM\n
      \    :authority     = push.example.net\n   The push service permits the request
      to remain outstanding.  When the\n   user agent acknowledges the message, the
      push service pushes a\n   delivery receipt to the application server.  A 204
      (No Content)\n   status code confirms that the message was delivered and acknowledged.\n
      \  PUSH_PROMISE [stream 13; promised stream 82] +END_HEADERS\n     :method        =
      GET\n     :path          = /message/qDIYHNcfAIPP_5ITvURr-d6BGt\n     :authority
      \    = push.example.net\n   HEADERS      [stream 82] +END_STREAM\n                           +END_HEADERS\n
      \    :status        = 204\n     date           = Thu, 11 Dec 2014 23:56:56 GMT\n
      \  If the user agent fails to acknowledge the receipt of the push\n   message
      and the push service ceases to retry delivery of the message\n   prior to its
      advertised expiration, then the push service MUST push a\n   failure response
      with a status code of 410 (Gone).\n"
    title: 6.3.  Receiving Push Message Receipts
  title: 6.  Receiving Push Messages for a Subscription
- contents:
  - '7.  Operational Considerations

    '
  - contents:
    - "7.1.  Load Management\n   A push service is likely to have to maintain a very
      large number of\n   open TCP connections.  Effective management of those connections
      can\n   depend on being able to move connections between server instances.\n
      \  A user agent MUST support the 307 (Temporary Redirect) status code\n   [RFC7231],
      which can be used by a push service to redistribute load\n   at the time that
      a new subscription is requested.\n   A server that wishes to redistribute load
      can do so using HTTP\n   alternative services [RFC7838].  HTTP alternative services
      allows for\n   redistribution of load while maintaining the same URIs for various\n
      \  resources.  A user agent can ensure a graceful transition by using\n   the
      GOAWAY frame once it has established a replacement connection.\n"
    title: 7.1.  Load Management
  - contents:
    - "7.2.  Push Message Expiration\n   Storage of push messages based on the TTL
      header field comprises a\n   potentially significant amount of storage for a
      push service.  A push\n   service is not obligated to store messages indefinitely.
      \ A push\n   service is able to indicate how long it intends to retain a message\n
      \  to an application server using the TTL header field (Section 5.2).\n   A
      user agent that does not actively monitor for push messages will\n   not receive
      messages that expire during that interval.\n   Push messages that are stored
      and have not been delivered to a user\n   agent are delivered when the user
      agent recommences monitoring.\n   Stored push messages SHOULD include a Last-Modified
      header field\n   (Section 2.2 of [RFC7232]) indicating when delivery was requested
      by\n   an application server.\n   A GET request to a push message subscription
      resource with only\n   expired messages results in a response as though no push
      message was\n   ever sent.\n   Push services might need to limit the size and
      number of stored push\n   messages to avoid overloading.  To limit the size
      of messages, the\n   push service MAY return a 413 (Payload Too Large) status
      code\n   [RFC7231] in response to requests that include an entity body that
      is\n   too large.  Push services MUST NOT return a 413 status code in\n   responses
      to an entity body that is 4096 bytes or less in size.\n   To limit the number
      of stored push messages, the push service MAY\n   respond with a shorter Time-To-Live
      than proposed by the application\n   server in its request for push message
      delivery (Section 5.2).  Once\n   a message has been accepted, the push service
      MAY later expire the\n   message prior to its advertised Time-To-Live.  If the
      application\n   server requested a delivery receipt, the push service MUST return
      a\n   failure response (Section 6.2).\n"
    title: 7.2.  Push Message Expiration
  - contents:
    - "7.3.  Subscription Expiration\n   In some cases, it may be necessary to terminate
      subscriptions so that\n   they can be refreshed.  This applies to both push
      message\n   subscriptions and receipt subscriptions.\n   A push service MAY
      expire a subscription at any time.  If there are\n   outstanding requests to
      an expired push message subscription resource\n   (Section 6) from a user agent
      or to an expired receipt subscription\n   resource (Section 6.3) from an application
      server, this MUST be\n   signaled by returning a 404 (Not Found) status code.\n
      \  A push service MUST return a 404 (Not Found) status code if an\n   application
      server attempts to send a push message to an expired push\n   message subscription.\n
      \  A user agent can remove its push message subscription by sending a\n   DELETE
      request to the corresponding URI.  An application server can\n   remove its
      receipt subscription by sending a DELETE request to the\n   corresponding URI.\n"
    - contents:
      - "7.3.1.  Subscription Set Expiration\n   A push service MAY expire a subscription
        set at any time and MUST\n   also expire all push message subscriptions in
        the set.  If a user\n   agent has an outstanding request to a push subscription
        set\n   (Section 6.1), this MUST be signaled by returning a 404 (Not Found)\n
        \  status code.\n   A user agent can request that a subscription set be removed
        by\n   sending a DELETE request to the subscription set URI.  This MUST also\n
        \  remove all push message subscriptions in the set.\n   If a specific push
        message subscription that is a member of a\n   subscription set is expired
        or removed, then it MUST also be removed\n   from its subscription set.\n"
      title: 7.3.1.  Subscription Set Expiration
    title: 7.3.  Subscription Expiration
  - contents:
    - "7.4.  Implications for Application Reliability\n   A push service that does
      not support reliable delivery over\n   intermittent network connections or failing
      applications on devices,\n   forces the device to acknowledge receipt directly
      to the application\n   server, incurring additional power drain in order to
      establish and\n   maintain (usually secure) connections to the individual application\n
      \  servers.\n   Push message reliability can be important if messages contain\n
      \  information critical to the state of an application.  Repairing the\n   state
      can be expensive, particularly for devices with limited\n   communications capacity.
      \ Knowing that a push message has been\n   correctly received avoids retransmissions,
      polling, and state\n   resynchronization.\n   The availability of push message
      delivery receipts ensures that the\n   application developer is not tempted
      to create alternative mechanisms\n   for message delivery in case the push service
      fails to deliver a\n   critical message.  Setting up a polling mechanism or
      a backup\n   messaging channel in order to compensate for these shortcomings\n
      \  negates almost all of the advantages a push service provides.\n   However,
      reliability might not be necessary for messages that are\n   transient (e.g.,
      an incoming call) or messages that are quickly\n   superseded (e.g., the current
      number of unread emails).\n"
    title: 7.4.  Implications for Application Reliability
  - contents:
    - "7.5.  Subscription Sets and Concurrent HTTP/2 Streams\n   If the push service
      requires that the user agent use push message\n   subscription sets, then it
      MAY limit the number of concurrently\n   active streams with the SETTINGS_MAX_CONCURRENT_STREAMS
      parameter\n   within an HTTP/2 SETTINGS frame [RFC7540].  The user agent MAY
      be\n   limited to one concurrent stream to manage push message subscriptions\n
      \  and one concurrent stream for each subscription set returned by the\n   push
      service.  This could force the user agent to serialize\n   subscription requests
      to the push service.\n"
    title: 7.5.  Subscription Sets and Concurrent HTTP/2 Streams
  title: 7.  Operational Considerations
- contents:
  - "8.  Security Considerations\n   This protocol MUST use HTTP over TLS [RFC2818]
    following the\n   recommendations in [RFC7525].  This includes any communications\n
    \  between the user agent and the push service, plus communications\n   between
    the application server and the push service.  All URIs\n   therefore use the \"https\"
    scheme.  This provides confidentiality and\n   integrity protection for subscriptions
    and push messages from\n   external parties.\n"
  - contents:
    - "8.1.  Confidentiality from Push Service Access\n   The protection afforded
      by TLS does not protect content from the push\n   service.  Without additional
      safeguards, a push service can inspect\n   and modify the message content.\n
      \  Applications using this protocol MUST use mechanisms that provide\n   end-to-end
      confidentiality, integrity, and data origin\n   authentication.  The application
      server sending the push message and\n   the application on the user agent that
      receives it are frequently\n   just different instances of the same application,
      so no standardized\n   protocol is needed to establish a proper security context.
      \ The\n   distribution of subscription information from the user agent to its\n
      \  application server also offers a convenient medium for key agreement.\n   For
      this requirement, the W3C Push API [API] has adopted Message\n   Encryption
      for WebPush [ENCRYPT] to secure the content of messages\n   from the push service.
      \ Other scenarios can be addressed by similar\n   policies.\n   The Topic header
      field exposes information that allows more granular\n   correlation of push
      messages on the same subject.  This might be used\n   to aid traffic analysis
      of push messages by the push service.\n"
    title: 8.1.  Confidentiality from Push Service Access
  - contents:
    - "8.2.  Privacy Considerations\n   Push message confidentiality does not ensure
      that the identity of who\n   is communicating and when they are communicating
      is protected.\n   However, the amount of information that is exposed can be
      limited.\n   The URIs provided for push resources MUST NOT provide any basis
      to\n   correlate communications for a given user agent.  It MUST NOT be\n   possible
      to correlate any two push resource URIs based solely on\n   their contents.
      \ This allows a user agent to control correlation\n   across different applications
      or over time.  Of course, this does not\n   prevent correlation using other
      information that a user agent might\n   expose.\n   Similarly, the URIs provided
      by the push service to identify a push\n   message MUST NOT provide any information
      that allows for correlation\n   across subscriptions.  Push message URIs for
      the same subscription\n   MAY contain information that would allow correlation
      with the\n   associated subscription or other push messages for that subscription.\n
      \  User and device information MUST NOT be exposed through a push or\n   push
      message URI.\n   In addition, push URIs established by the same user agent or
      push\n   message URIs for the same subscription MUST NOT include any\n   information
      that allows them to be correlated with the user agent.\n   Note:  This need
      not be perfect as long as the resulting anonymity\n      set ([RFC6973], Section
      6.1.1) is sufficiently large.  A push URI\n      necessarily identifies a push
      service or a single server instance.\n      It is also possible that traffic
      analysis could be used to\n      correlate subscriptions.\n   A user agent MUST
      be able to create new subscriptions with new\n   identifiers at any time.\n"
    title: 8.2.  Privacy Considerations
  - contents:
    - "8.3.  Authorization\n   This protocol does not define how a push service establishes
      whether\n   a user agent is permitted to create a subscription, or whether push\n
      \  messages can be delivered to the user agent.  A push service MAY\n   choose
      to authorize requests based on any HTTP-compatible\n   authorization method
      available, of which there are multiple options\n   (including experimental options)
      with varying levels of security.\n   The authorization process and any associated
      credentials are expected\n   to be configured in the user agent along with the
      URI for the push\n   service.\n   Authorization is managed using capability
      URLs for the push message\n   subscription, push, and receipt subscription resources
      ([CAP-URI]).\n   A capability URL grants access to a resource based solely on\n
      \  knowledge of the URL.\n   Capability URLs are used for their \"easy onward
      sharing\" and \"easy\n   client API\" properties.  These properties make it
      possible to avoid\n   relying on prearranged relationships or additional protocols
      between\n   push services and application servers.\n   Capability URLs act as
      bearer tokens.  Knowledge of a push message\n   subscription URI implies authorization
      to either receive push\n   messages or delete the subscription.  Knowledge of
      a push URI implies\n   authorization to send push messages.  Knowledge of a
      push message URI\n   allows for reading and acknowledging that specific message.\n
      \  Knowledge of a receipt subscription URI implies authorization to\n   receive
      push receipts.\n   Encoding a large amount of random entropy (at least 120 bits)
      in the\n   path component ensures that it is difficult to successfully guess
      a\n   valid capability URL.\n"
    title: 8.3.  Authorization
  - contents:
    - "8.4.  Denial-of-Service Considerations\n   A user agent can control where valid
      push messages originate by\n   limiting the distribution of push URIs to authorized
      application\n   servers.  Ensuring that push URIs are hard to guess ensures
      that only\n   application servers that have received a push URI can use it.\n
      \  Push messages that are not successfully authenticated by the user\n   agent
      will not be delivered, but this can present a denial-of-service\n   risk.  Even
      a relatively small volume of push messages can cause\n   battery-powered devices
      to exhaust power reserves.\n   To address this case, the W3C Push API [API]
      has adopted Voluntary\n   Application Server Identification [VAPID], which allows
      a user agent\n   to restrict a subscription to a specific application server.
      \ The\n   push service can then identify and reject unwanted messages without\n
      \  contacting the user agent.\n   A malicious application with a valid push
      URI could use the greater\n   resources of a push service to mount a denial-of-service
      attack on a\n   user agent.  Push services SHOULD limit the rate at which push\n
      \  messages are sent to individual user agents.\n   A push service MAY return
      a 429 (Too Many Requests) status code\n   [RFC6585] when an application server
      has exceeded its rate limit for\n   push message delivery to a push resource.
      \ The push service SHOULD\n   also include a Retry-After header [RFC7231] to
      indicate how long the\n   application server is requested to wait before it
      makes another\n   request to the push resource.\n   A push service or user agent
      MAY also terminate subscriptions\n   (Section 7.3) that receive too many push
      messages.\n   A push service is also able to deny service to user agents.\n
      \  Intentional failure to deliver messages is difficult to distinguish\n   from
      faults, which might occur due to transient network errors,\n   interruptions
      in user agent availability, or genuine service outages.\n"
    title: 8.4.  Denial-of-Service Considerations
  - contents:
    - "8.5.  Logging Risks\n   Server request logs can reveal subscription-related
      URIs or\n   relationships between subscription-related URIs for the same user\n
      \  agent.  Limitations on log retention and strong access control\n   mechanisms
      can ensure that URIs are not revealed to unauthorized\n   entities.\n"
    title: 8.5.  Logging Risks
  title: 8.  Security Considerations
- contents:
  - "9.  IANA Considerations\n   This protocol defines new HTTP header fields in Section
    9.1.  New\n   link relation types are identified using the URNs defined in\n   Section
    9.2.  Port registration is defined in Section 9.3\n"
  - contents:
    - "9.1.  Header Field Registrations\n   HTTP header fields are registered within
      the \"Message Headers\"\n   registry maintained at <https://www.iana.org/assignments/message-\n
      \  headers/>.\n   This document defines the following HTTP header fields, and
      the\n   following entries have been added to the \"Permanent Message Header\n
      \  Field Names\" registry ([RFC3864]):\n   +-------------------+----------+----------+--------------+\n
      \  | Header Field Name | Protocol | Status   | Reference    |\n   +-------------------+----------+----------+--------------+\n
      \  | TTL               | http     | standard | Section 5.2  |\n   | Urgency
      \          | http     | standard | Section 5.3  |\n   | Topic             |
      http     | standard | Section 5.4  |\n   +-------------------+----------+----------+--------------+\n
      \  The change controller is: \"IETF (iesg@ietf.org) - Internet\n   Engineering
      Task Force\".\n"
    title: 9.1.  Header Field Registrations
  - contents:
    - "9.2.  Link Relation URNs\n   This document registers URNs for use in identifying
      link relation\n   types.  These have been added to a new \"Web Push Identifiers\"\n
      \  registry according to the procedures in Section 4 of [RFC3553]; the\n   corresponding
      \"push\" sub-namespace has been entered in the \"IETF URN\n   Sub-namespace
      for Registered Protocol Parameter Identifiers\"\n   registry.\n   The \"Web
      Push Identifiers\" registry operates under the IETF Review\n   policy [RFC5226].\n
      \  Registry name:  Web Push Identifiers\n   URN Prefix:  urn:ietf:params:push\n
      \  Specification:  RFC 8030 (this document)\n   Repository:  http://www.iana.org/assignments/webpush-parameters/\n
      \  Index Value:  Values in this registry are URNs or URN prefixes that\n      start
      with the prefix \"urn:ietf:params:push\".  Each is registered\n      independently.\n
      \  Registrations in the \"Web Push Identifiers\" registry include the\n   following
      information:\n   URN:  A complete URN or URN prefix.\n   Description:  A summary
      description.\n   Contact:  Email for the person or group making the registration.\n
      \  Index Value:  As described in [RFC3553]\n   Reference:  A reference to a
      specification describing the semantics\n      of the URN or URN prefix.\n      URN
      prefixes that are registered include a description of how the\n      URN is
      constructed.  This is not applicable for specific URNs.\n   These values are
      entered as the initial content of the \"Web Push\n   Identifiers\" registry.\n
      \  URN:  urn:ietf:params:push\n   Description:  This link relation type is used
      to identify a resource\n      for sending push messages.\n   Contact:  The WEBPUSH
      WG of the IETF (webpush@ietf.org)\n   Reference:  RFC 8030 (this document)\n
      \  URN:  urn:ietf:params:push:set\n   Description:  This link relation type
      is used to identify a\n      collection of push message subscriptions.\n   Contact:
      \ The WEBPUSH WG of the IETF (webpush@ietf.org)\n   Reference:  RFC 8030 (this
      document)\n   URN:  urn:ietf:params:push:receipt\n   Description:  This link
      relation type is used to identify a resource\n      for receiving delivery confirmations
      for push messages.\n   Contact:  The WEBPUSH WG of the IETF (webpush@ietf.org)\n
      \  Reference:  RFC 8030 (this document)\n"
    title: 9.2.  Link Relation URNs
  - contents:
    - "9.3.  Service Name and Port Number Registration\n   Service names and port
      numbers are registered within the \"Service\n   Name and Transport Protocol
      Port Number Registry\" maintained at\n   <https://www.iana.org/assignments/service-names-port-numbers/>.\n
      \  In accordance with [RFC6335], IANA has assigned the System Port\n   number
      1001 and the service name \"webpush\".\n   Service Name:\n      webpush\n   Port
      Number:\n      1001\n   Transport Protocol:\n      tcp\n   Description:\n      HTTP
      Web Push\n   Assignee:\n      The IESG (iesg@ietf.org)\n   Contact:\n      The
      IETF Chair (chair@ietf.org)\n   Reference:\n      RFC 8030 (this document)\n"
    title: 9.3.  Service Name and Port Number Registration
  title: 9.  IANA Considerations
- contents:
  - '10.  References

    '
  - contents:
    - "10.1.  Normative References\n   [CAP-URI]  Tennison, J., \"Good Practices for
      Capability URLs\", W3C\n              First Public Working Draft capability-urls,
      February 2014,\n              <http://www.w3.org/TR/capability-urls/>.\n   [RFC2119]
      \ Bradner, S., \"Key words for use in RFCs to Indicate\n              Requirement
      Levels\", BCP 14, RFC 2119,\n              DOI 10.17487/RFC2119, March 1997,\n
      \             <http://www.rfc-editor.org/info/rfc2119>.\n   [RFC2818]  Rescorla,
      E., \"HTTP Over TLS\", RFC 2818,\n              DOI 10.17487/RFC2818, May 2000,\n
      \             <http://www.rfc-editor.org/info/rfc2818>.\n   [RFC3553]  Mealling,
      M., Masinter, L., Hardie, T., and G. Klyne, \"An\n              IETF URN Sub-namespace
      for Registered Protocol\n              Parameters\", BCP 73, RFC 3553, DOI 10.17487/RFC3553,
      June\n              2003, <http://www.rfc-editor.org/info/rfc3553>.\n   [RFC3864]
      \ Klyne, G., Nottingham, M., and J. Mogul, \"Registration\n              Procedures
      for Message Header Fields\", BCP 90, RFC 3864,\n              DOI 10.17487/RFC3864,
      September 2004,\n              <http://www.rfc-editor.org/info/rfc3864>.\n   [RFC4648]
      \ Josefsson, S., \"The Base16, Base32, and Base64 Data\n              Encodings\",
      RFC 4648, DOI 10.17487/RFC4648, October 2006,\n              <http://www.rfc-editor.org/info/rfc4648>.\n
      \  [RFC5226]  Narten, T. and H. Alvestrand, \"Guidelines for Writing an\n              IANA
      Considerations Section in RFCs\", BCP 26, RFC 5226,\n              DOI 10.17487/RFC5226,
      May 2008,\n              <http://www.rfc-editor.org/info/rfc5226>.\n   [RFC5382]
      \ Guha, S., Ed., Biswas, K., Ford, B., Sivakumar, S., and P.\n              Srisuresh,
      \"NAT Behavioral Requirements for TCP\", BCP 142,\n              RFC 5382, DOI
      10.17487/RFC5382, October 2008,\n              <http://www.rfc-editor.org/info/rfc5382>.\n
      \  [RFC5988]  Nottingham, M., \"Web Linking\", RFC 5988,\n              DOI
      10.17487/RFC5988, October 2010,\n              <http://www.rfc-editor.org/info/rfc5988>.\n
      \  [RFC6335]  Cotton, M., Eggert, L., Touch, J., Westerlund, M., and S.\n              Cheshire,
      \"Internet Assigned Numbers Authority (IANA)\n              Procedures for the
      Management of the Service Name and\n              Transport Protocol Port Number
      Registry\", BCP 165,\n              RFC 6335, DOI 10.17487/RFC6335, August 2011,\n
      \             <http://www.rfc-editor.org/info/rfc6335>.\n   [RFC6454]  Barth,
      A., \"The Web Origin Concept\", RFC 6454,\n              DOI 10.17487/RFC6454,
      December 2011,\n              <http://www.rfc-editor.org/info/rfc6454>.\n   [RFC6585]
      \ Nottingham, M. and R. Fielding, \"Additional HTTP Status\n              Codes\",
      RFC 6585, DOI 10.17487/RFC6585, April 2012,\n              <http://www.rfc-editor.org/info/rfc6585>.\n
      \  [RFC7230]  Fielding, R., Ed. and J. Reschke, Ed., \"Hypertext Transfer\n
      \             Protocol (HTTP/1.1): Message Syntax and Routing\",\n              RFC
      7230, DOI 10.17487/RFC7230, June 2014,\n              <http://www.rfc-editor.org/info/rfc7230>.\n
      \  [RFC7231]  Fielding, R., Ed. and J. Reschke, Ed., \"Hypertext Transfer\n
      \             Protocol (HTTP/1.1): Semantics and Content\", RFC 7231,\n              DOI
      10.17487/RFC7231, June 2014,\n              <http://www.rfc-editor.org/info/rfc7231>.\n
      \  [RFC7232]  Fielding, R., Ed. and J. Reschke, Ed., \"Hypertext Transfer\n
      \             Protocol (HTTP/1.1): Conditional Requests\", RFC 7232,\n              DOI
      10.17487/RFC7232, June 2014,\n              <http://www.rfc-editor.org/info/rfc7232>.\n
      \  [RFC7240]  Snell, J., \"Prefer Header for HTTP\", RFC 7240,\n              DOI
      10.17487/RFC7240, June 2014,\n              <http://www.rfc-editor.org/info/rfc7240>.\n
      \  [RFC7525]  Sheffer, Y., Holz, R., and P. Saint-Andre,\n              \"Recommendations
      for Secure Use of Transport Layer\n              Security (TLS) and Datagram
      Transport Layer Security\n              (DTLS)\", BCP 195, RFC 7525, DOI 10.17487/RFC7525,
      May\n              2015, <http://www.rfc-editor.org/info/rfc7525>.\n   [RFC7540]
      \ Belshe, M., Peon, R., and M. Thomson, Ed., \"Hypertext\n              Transfer
      Protocol Version 2 (HTTP/2)\", RFC 7540,\n              DOI 10.17487/RFC7540,
      May 2015,\n              <http://www.rfc-editor.org/info/rfc7540>.\n   [RFC7838]
      \ Nottingham, M., McManus, P., and J. Reschke, \"HTTP\n              Alternative
      Services\", RFC 7838, DOI 10.17487/RFC7838,\n              April 2016, <http://www.rfc-editor.org/info/rfc7838>.\n"
    title: 10.1.  Normative References
  - contents:
    - "10.2.  Informative References\n   [API]      Beverloo, P., Thomson, M., van
      Ouwerkerk, M., Sullivan,\n              B., and E. Fullea, \"Push API\", W3C
      Editor's Draft push-\n              api, November 2016, <https://w3c.github.io/push-api/>.\n
      \  [ENCRYPT]  Thomson, M., \"Message Encryption for Web Push\", Work in\n              Progress,
      draft-ietf-webpush-encryption-06, October 2016.\n   [RFC6973]  Cooper, A., Tschofenig,
      H., Aboba, B., Peterson, J.,\n              Morris, J., Hansen, M., and R. Smith,
      \"Privacy\n              Considerations for Internet Protocols\", RFC 6973,\n
      \             DOI 10.17487/RFC6973, July 2013,\n              <http://www.rfc-editor.org/info/rfc6973>.\n
      \  [VAPID]    Thomson, M. and P. Beverloo, \"Voluntary Application Server\n
      \             Identification for Web Push\", Work in Progress,\n              draft-ietf-webpush-vapid-01,
      June 2016.\n"
    title: 10.2.  Informative References
  title: 10.  References
- contents:
  - "Acknowledgements\n   Significant technical input to this document has been provided
    by Ben\n   Bangert, Peter Beverloo, Kit Cambridge, JR Conlin, Lucas Jenss,\n   Matthew
    Kaufman, Costin Manolache, Mark Nottingham, Idel Pivnitskiy,\n   Robert Sparks,
    Darshak Thakore, and many others.\n"
  title: Acknowledgements
- contents:
  - "Authors' Addresses\n   Martin Thomson\n   Mozilla\n   331 E Evelyn Street\n   Mountain
    View, CA  94041\n   United States of America\n   Email: martin.thomson@gmail.com\n
    \  Elio Damaggio\n   Microsoft\n   One Microsoft Way\n   Redmond, WA  98052\n
    \  United States of America\n   Email: elioda@microsoft.com\n   Brian Raymor (editor)\n
    \  Microsoft\n   One Microsoft Way\n   Redmond, WA  98052\n   United States of
    America\n   Email: brian.raymor@microsoft.com\n"
  title: Authors' Addresses
