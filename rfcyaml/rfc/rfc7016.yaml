- title: __initial_text__
  contents:
  - '              Adobe''s Secure Real-Time Media Flow Protocol

    '
- title: Abstract
  contents:
  - "Abstract\n   This memo describes Adobe's Secure Real-Time Media Flow Protocol\n\
    \   (RTMFP), an endpoint-to-endpoint communication protocol designed to\n   securely\
    \ transport parallel flows of real-time video, audio, and data\n   messages, as\
    \ well as bulk data, over IP networks.  RTMFP has features\n   that make it effective\
    \ for peer-to-peer (P2P) as well as client-\n   server communications, even when\
    \ Network Address Translators (NATs)\n   are used.\n"
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This document is not an Internet Standards Track specification;\
    \ it is\n   published for informational purposes.\n   This document is a product\
    \ of the Internet Engineering Task Force\n   (IETF).  It has been approved for\
    \ publication by the Internet\n   Engineering Steering Group (IESG).  Not all\
    \ documents approved by the\n   IESG are a candidate for any level of Internet\
    \ Standard; see Section\n   2 of RFC 5741.\n   Information about the current status\
    \ of this document, any errata,\n   and how to provide feedback on it may be obtained\
    \ at\n   http://www.rfc-editor.org/info/rfc7016.\n"
- title: IESG Note
  contents:
  - "IESG Note\n   This document represents technology developed outside the processes\n\
    \   of the IETF and the IETF community has determined that it is useful\n   to\
    \ publish it as an RFC in its current form.  It is a product of the\n   IETF only\
    \ in that it has received public review and has been approved\n   for publication\
    \ by the Internet Engineering Steering Group (IESG),\n   but the content of the\
    \ document does not represent a consensus of the\n   IETF.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (c) 2013 IETF Trust and the persons identified\
    \ as the\n   document authors.  All rights reserved.\n   This document is subject\
    \ to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n\
    \   (http://trustee.ietf.org/license-info) in effect on the date of\n   publication\
    \ of this document.  Please review these documents\n   carefully, as they describe\
    \ your rights and restrictions with respect\n   to this document.  Code Components\
    \ extracted from this document must\n   include Simplified BSD License text as\
    \ described in Section 4.e of\n   the Trust Legal Provisions and are provided\
    \ without warranty as\n   described in the Simplified BSD License.\n   This document\
    \ may not be modified, and derivative works of it may not\n   be created, except\
    \ to format it for publication as an RFC or to\n   translate it into languages\
    \ other than English.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1. Introduction ....................................................5\n\
    \      1.1. Design Highlights of RTMFP .................................6\n  \
    \    1.2. Terminology ................................................7\n   2.\
    \ Syntax ..........................................................8\n      2.1.\
    \ Common Elements ............................................8\n           2.1.1.\
    \ Elementary Types and Constructs .....................8\n           2.1.2. Variable\
    \ Length Unsigned Integer (VLU) .............10\n           2.1.3. Option .............................................10\n\
    \           2.1.4. Option List ........................................11\n  \
    \         2.1.5. Internet Socket Address (Address) ..................12\n    \
    \  2.2. Network Layer .............................................13\n      \
    \     2.2.1. Encapsulation ......................................13\n        \
    \   2.2.2. Multiplex ..........................................13\n          \
    \ 2.2.3. Encryption .........................................14\n           2.2.4.\
    \ Packet .............................................15\n      2.3. Chunks ....................................................18\n\
    \           2.3.1. Packet Fragment Chunk ..............................20\n  \
    \         2.3.2. Initiator Hello Chunk (IHello) .....................21\n    \
    \       2.3.3. Forwarded Initiator Hello Chunk (FIHello) ..........22\n      \
    \     2.3.4. Responder Hello Chunk (RHello) .....................23\n        \
    \   2.3.5. Responder Redirect Chunk (Redirect) ................24\n          \
    \ 2.3.6. RHello Cookie Change Chunk .........................26\n           2.3.7.\
    \ Initiator Initial Keying Chunk (IIKeying) ..........27\n           2.3.8. Responder\
    \ Initial Keying Chunk (RIKeying) ..........29\n           2.3.9. Ping Chunk .........................................31\n\
    \           2.3.10. Ping Reply Chunk ..................................32\n  \
    \         2.3.11. User Data Chunk ...................................33\n    \
    \              2.3.11.1. Options for User Data ....................35\n      \
    \                     2.3.11.1.1. User's Per-Flow Metadata ......35\n        \
    \                   2.3.11.1.2. Return Flow Association .......36\n          \
    \ 2.3.12. Next User Data Chunk ..............................37\n           2.3.13.\
    \ Data Acknowledgement Bitmap Chunk (Bitmap Ack) ....39\n           2.3.14. Data\
    \ Acknowledgement Ranges Chunk (Range Ack) .....41\n           2.3.15. Buffer\
    \ Probe Chunk ................................43\n           2.3.16. Flow Exception\
    \ Report Chunk .......................43\n           2.3.17. Session Close Request\
    \ Chunk (Close) ...............44\n           2.3.18. Session Close Acknowledgement\
    \ Chunk (Close Ack) ...44\n   3. Operation ......................................................45\n\
    \      3.1. Overview ..................................................45\n  \
    \    3.2. Endpoint Identity .........................................46\n    \
    \  3.3. Packet Multiplex ..........................................48\n      3.4.\
    \ Packet Fragmentation ......................................48\n      3.5. Sessions\
    \ ..................................................50\n           3.5.1. Startup\
    \ ............................................53\n                  3.5.1.1. Normal\
    \ Handshake ..........................53\n                           3.5.1.1.1.\
    \ Initiator ......................54\n                           3.5.1.1.2. Responder\
    \ ......................55\n                  3.5.1.2. Cookie Change .............................57\n\
    \                  3.5.1.3. Glare .....................................59\n  \
    \                3.5.1.4. Redirector ................................60\n    \
    \              3.5.1.5. Forwarder .................................61\n      \
    \            3.5.1.6. Redirector and Forwarder with NAT .........63\n        \
    \          3.5.1.7. Load Distribution and Fault Tolerance .....66\n          \
    \ 3.5.2. Congestion Control .................................67\n            \
    \      3.5.2.1. Time Critical Reverse Notification ........68\n              \
    \    3.5.2.2. Retransmission Timeout ....................68\n                \
    \  3.5.2.3. Burst Avoidance ...........................71\n           3.5.3. Address\
    \ Mobility ...................................71\n           3.5.4. Ping ...............................................72\n\
    \                  3.5.4.1. Keepalive .................................72\n  \
    \                3.5.4.2. Address Mobility ..........................73\n    \
    \              3.5.4.3. Path MTU Discovery ........................74\n      \
    \     3.5.5. Close ..............................................74\n      3.6.\
    \ Flows .....................................................75\n           3.6.1.\
    \ Overview ...........................................75\n                  3.6.1.1.\
    \ Identity ..................................75\n                  3.6.1.2. Messages\
    \ and Sequencing ...................76\n                  3.6.1.3. Lifetime ..................................77\n\
    \           3.6.2. Sender .............................................78\n  \
    \                3.6.2.1. Startup ...................................80\n    \
    \              3.6.2.2. Queuing Data ..............................80\n      \
    \            3.6.2.3. Sending Data ..............................81\n        \
    \                   3.6.2.3.1. Startup Options ................83\n          \
    \                 3.6.2.3.2. Send Next Data .................83\n            \
    \      3.6.2.4. Processing Acknowledgements ...............83\n              \
    \    3.6.2.5. Negative Acknowledgement and Loss .........84\n                \
    \  3.6.2.6. Timeout ...................................85\n                  3.6.2.7.\
    \ Abandoning Data ...........................86\n                           3.6.2.7.1.\
    \ Forward Sequence Number\n                                      Update .........................86\n\
    \                  3.6.2.8. Examples ..................................87\n  \
    \                3.6.2.9. Flow Control ..............................89\n    \
    \                       3.6.2.9.1. Buffer Probe ...................89\n      \
    \            3.6.2.10. Exception ................................89\n        \
    \          3.6.2.11. Close ....................................90\n          \
    \ 3.6.3. Receiver ...........................................90\n            \
    \      3.6.3.1. Startup ...................................93\n              \
    \    3.6.3.2. Receiving Data ............................94\n                \
    \  3.6.3.3. Buffering and Delivering Data .............95\n                  3.6.3.4.\
    \ Acknowledging Data ........................97\n                           3.6.3.4.1.\
    \ Timing .........................98\n                           3.6.3.4.2. Size\
    \ and Truncation ............99\n                           3.6.3.4.3. Constructing\
    \ ...................99\n                           3.6.3.4.4. Delayed Acknowledgement\
    \ .......100\n                           3.6.3.4.5. Obligatory Acknowledgement\
    \ ....100\n                           3.6.3.4.6. Opportunistic\n             \
    \                         Acknowledgement ...............100\n               \
    \            3.6.3.4.7. Example .......................101\n                 \
    \ 3.6.3.5. Flow Control .............................102\n                  3.6.3.6.\
    \ Receiving a Buffer Probe .................103\n                  3.6.3.7. Rejecting\
    \ a Flow .........................103\n                  3.6.3.8. Close ....................................104\n\
    \   4. IANA Considerations ...........................................104\n  \
    \ 5. Security Considerations .......................................105\n   6.\
    \ Acknowledgements ..............................................106\n   7. References\
    \ ....................................................107\n      7.1. Normative\
    \ References .....................................107\n      7.2. Informative\
    \ References ...................................107\n   Appendix A. Example Congestion\
    \ Control Algorithm .................108\n     A.1. Discussion ................................................108\n\
    \     A.2. Algorithm .................................................110\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   Adobe's Secure Real-Time Media Flow Protocol (RTMFP) is\
    \ intended for\n   use as a general purpose endpoint-to-endpoint data transport\
    \ service\n   in IP networks.  It has features that make it well suited to the\n\
    \   transport of real-time media (such as low-delay video, audio, and\n   data)\
    \ as well as bulk data, and for client-server as well as peer-to-\n   peer (P2P)\
    \ communication.  These features include independent\n   parallel message flows\
    \ that may have different delivery priorities,\n   variable message reliability\
    \ (from TCP-like full reliability to\n   UDP-like best effort), multi-point congestion\
    \ control, and built-in\n   security.  Session multiplexing and facilities to\
    \ support UDP\n   hole-punching simplify Network Address Translator (NAT) traversal\
    \ in\n   peer-to-peer systems.\n   RTMFP is implemented in Flash Player, Adobe\
    \ Integrated Runtime (AIR),\n   and Adobe Media Server (AMS, formerly Flash Media\
    \ Server or FMS), all\n   from Adobe Systems Incorporated, and is used as the\
    \ foundation\n   transport protocol for real-time video, audio, and data\n   communication,\
    \ both client-server and P2P, in those products.  At the\n   time of writing,\
    \ the Adobe Flash Player runtime is installed on more\n   than one billion end-user\
    \ desktop computers.\n   RTMFP was developed by Adobe Systems Incorporated and\
    \ is not the\n   product of an IETF activity.\n   This memo describes the syntax\
    \ and operation of the Secure Real-Time\n   Media Flow Protocol.\n   This memo\
    \ describes a general security framework that, when combined\n   with an application-specific\
    \ Cryptography Profile, can be used to\n   establish a confidential and authenticated\
    \ session between endpoints.\n   The application-specific Cryptography Profile,\
    \ not defined herein,\n   would detail the specific cryptographic algorithms,\
    \ data formats, and\n   semantics to be used within this framework.  Interoperation\
    \ between\n   applications of RTMFP requires common or compatible Cryptography\n\
    \   Profiles.\n   Note to implementers: at the time of writing, the Cryptography\n\
    \   Profile used by the above-mentioned Adobe products is not publicly\n   described\
    \ by Adobe.  Implementers should investigate the availability\n   of documentation\
    \ of that Cryptography Profile prior to implementing\n   RTMFP for the purpose\
    \ of interoperation with the above-mentioned\n   Adobe products.\n"
- title: 1.1.  Design Highlights of RTMFP
  contents:
  - "1.1.  Design Highlights of RTMFP\n   Between any pair of communicating endpoints\
    \ is a single,\n   bidirectional, secured, congestion controlled session.\n  \
    \ Unidirectional flows convey messages from one end to the other within\n   the\
    \ session.  An endpoint can have concurrent sessions with multiple\n   other far\
    \ endpoints.\n   Design highlights of RTMFP include the following:\n   o  The\
    \ security framework is an inherent part of the basic protocol.\n      The application\
    \ designer chooses the cryptographic formats and\n      algorithms to suit the\
    \ needs of the application, and may update\n      them as the state of the security\
    \ arts progresses.\n   o  Cryptographic Endpoint Discriminators can resist port\
    \ scanning.\n   o  All header, control, and framing information, except for network\n\
    \      addressing information and a session identifier, is encrypted\n      according\
    \ to the Cryptography Profile.\n   o  There is a single session and associated\
    \ congestion control state\n      between a pair of endpoints.\n   o  Each session\
    \ may have zero or more unidirectional message-oriented\n      flows in each direction.\
    \  All of a session's sending flows share\n      the session's congestion control\
    \ state.\n   o  Return Flow Association (Section 2.3.11.1.2) generalizes\n   \
    \   bidirectional communication to arbitrarily complex trees of flows.\n   o \
    \ Messages in flows can be arbitrarily large and are fragmented for\n      transmission.\n\
    \   o  Messages of any size may be sent with full, partial, or no\n      reliability\
    \ (sender's choice).  Messages may be delivered to the\n      receiving user in\
    \ original queuing order or network arrival order\n      (receiver's choice).\n\
    \   o  Flows are named with arbitrary, user-defined metadata\n      (Section 2.3.11.1.1)\
    \ rather than port or stream numbers.\n   o  The sequence numbers of each flow\
    \ are independent of all other\n      flows and are not permanently bound to a\
    \ session-wide transmission\n      ordering.  This allows real-time priority decisions\
    \ to be made at\n      transmission or retransmission time.\n   o  Each flow has\
    \ its own receive window and, therefore, independent\n      flow control.\n  \
    \ o  Round trips are expensive and are minimized or eliminated when\n      possible.\n\
    \   o  After a session is established, flows begin by sending the flow's\n   \
    \   messages with no additional handshake (and associated round\n      trips).\n\
    \   o  Transmitting bytes on the network is much more expensive than\n      moving\
    \ bytes in a CPU or memory.  Wasted bytes are minimized or\n      eliminated when\
    \ possible and practical, and variable length\n      encodings are used, even\
    \ at the expense of breaking 32-bit\n      alignment and making the text diagrams\
    \ in this specification look\n      awkward.\n   o  P2P lookup and peer introduction\
    \ (including UDP hole-punching for\n      NAT and firewall traversal) are supported\
    \ directly by the session\n      startup handshake.\n   o  Session identifiers\
    \ allow an endpoint to multiplex many sessions\n      over a single local transport\
    \ address while allowing sessions to\n      survive changes in transport address\
    \ (as may happen in mobile or\n      wireless deployments).\n   The syntax of\
    \ the protocol is detailed in Section 2.  The operation\n   of the protocol is\
    \ detailed in Section 3.\n"
- title: 1.2.  Terminology
  contents:
  - "1.2.  Terminology\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"\
    SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"NOT\
    \ RECOMMENDED\", \"MAY\", and\n   \"OPTIONAL\" in this document are to be interpreted\
    \ as described in\n   [RFC2119].\n"
- title: 2.  Syntax
  contents:
  - "2.  Syntax\n   Definitions of types and structures in this specification use\n\
    \   traditional text diagrams paired with procedural descriptions using a\n  \
    \ C-like syntax.  The C-like procedural descriptions SHALL be construed\n   as\
    \ definitive.\n   Structures are packed to take only as many bytes as explicitly\n\
    \   indicated.  There is no 32-bit alignment constraint, and fields are\n   not\
    \ padded for alignment unless explicitly indicated or described.\n   Text diagrams\
    \ may include a bit ruler across the top; this is a\n   convenience for counting\
    \ bits in individual fields and does not\n   necessarily imply field alignment\
    \ on a multiple of the ruler width.\n   Unless specified otherwise, reserved fields\
    \ SHOULD be set to 0 by a\n   sender and MUST be ignored by a receiver.\n   The\
    \ procedural syntax of this specification defines correct and\n   error-free encoded\
    \ inputs to a parser.  The procedural syntax does\n   not describe a fully featured\
    \ parser, including error detection and\n   handling.  Implementations MUST include\
    \ means to identify error\n   circumstances, including truncations causing elementary\
    \ or composed\n   types to not fit inside containing structures, fields, or elements.\n\
    \   Unless specified otherwise, an error circumstance SHALL abort the\n   parsing\
    \ and processing of an element and its enclosing elements, up\n   to the containing\
    \ packet.\n"
- title: 2.1.  Common Elements
  contents:
  - "2.1.  Common Elements\n   This section lists types and structures that are used\
    \ throughout this\n   specification.\n"
- title: 2.1.1.  Elementary Types and Constructs
  contents:
  - "2.1.1.  Elementary Types and Constructs\n   This section lists the elementary\
    \ types and constructs out of which\n   all of the following sections' definitions\
    \ are built.\n   uint8_t var;\n      An unsigned integer 8 bits (one byte) in\
    \ length and byte aligned.\n   uint16_t var;\n      An unsigned integer 16 bits\
    \ in length, in network byte order (\"big\n      endian\") and byte aligned.\n\
    \   uint32_t var;\n      An unsigned integer 32 bits in length, in network byte\
    \ order and\n      byte aligned.\n   uint128_t var;\n      An unsigned integer\
    \ 128 bits in length, in network byte order and\n      byte aligned.\n   uintn_t\
    \ var :bitsize;\n      An unsigned integer of any other size, potentially not\
    \ byte\n      aligned.  Its size in bits is specified explicitly by bitsize.\n\
    \   bool_t var :1;\n      A boolean flag having the value true (1 or set) or false\
    \ (0 or\n      clear) and being one bit in length.\n   type var[num];\n      A\
    \ packed array of type with length num*sizeof(type)*8 bits.\n   struct name_t\
    \ { ... } name :bitsize;\n      A packed structure.  Its size in bits is specified\
    \ by bitsize.\n   remainder();\n      The number of bytes from the current offset\
    \ to the end of the\n      enclosing structure.\n   type var[remainder()];\n \
    \     A packed array of type, its size extending to the end of the\n      enclosing\
    \ structure.\n   Note that a bitsize of \"variable\" indicates that the size of\
    \ the\n   structure is determined by the sizes of its interior components.  A\n\
    \   bitsize of \"n*8\" indicates that the size of the structure is a whole\n \
    \  number of bytes and is byte aligned.\n"
- title: 2.1.2.  Variable Length Unsigned Integer (VLU)
  contents:
  - "2.1.2.  Variable Length Unsigned Integer (VLU)\n   A VLU encodes any finite non-negative\
    \ integer into one or more bytes.\n   For each encoded byte, if the high bit is\
    \ set, the next byte is also\n   part of the VLU.  If the high bit is clear, this\
    \ is the final byte of\n   the VLU.  The remaining bits encode the number, seven\
    \ bits at a time,\n   from most significant to least significant.\n    0 1 2 3\
    \ 4 5 6 7                 0 1 2 3 4 5 6 7\n   +~+~+~+~+~+~+~+~+              \
    \ +-+-+-+-+-+-+-+-+\n   |1|    digit    |...............|0|    digit    |\n  \
    \ +~+~+~+~+~+~+~+~+               +-+-+-+-+-+-+-+-+\n   ^                    \
    \           ^\n   +--------- zero or more --------+\n   struct vlu_t\n   {\n \
    \      value = 0;\n       do {\n           bool_t  more  :1;\n           uintn_t\
    \ digit :7;\n           value = (value * 128) + digit;\n       } while(more);\n\
    \   } :variable*8;\n                              +-------------/-+\n        \
    \                      |             \\ |\n                              +-------------/-+\n\
    \               Figure 1: VLU Depiction in Following Diagrams\n   Unless stated\
    \ otherwise in this specification, implementations SHOULD\n   handle VLUs encoding\
    \ unsigned integers at least 64 bits in length\n   (that is, encoding a maximum\
    \ value of at least 2^64 - 1).\n"
- title: 2.1.3.  Option
  contents:
  - "2.1.3.  Option\n   An Option is a Length-Type-Value triplet.  Length and Type\
    \ are\n   encoded in VLU format.  Length is the number of bytes of payload\n \
    \  following the Length field.  The payload comprises the Type and Value\n   fields.\
    \  Type identifies the kind of option this is.  The syntax of\n   the Value field\
    \ is determined by the type of option.\n   An Option can have a length of zero,\
    \ in which case it has no type and\n   no value and is empty.  An empty Option\
    \ is called a \"Marker\".\n   +-------------/-+~~~~~~~~~~~~~/~+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~+\n\
    \   |   length    \\ |    type     \\ |            value              |\n   +-------------/-+~~~~~~~~~~~~~/~+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~/\n\
    \                   ^                                               ^\n      \
    \             +-------- length bytes long (may be 0) ---------+\n   struct option_t\n\
    \   {\n       vlu_t length :variable*8; // \"L\"\n       if(length > 0)\n    \
    \   {\n           struct {\n               vlu_t   type :variable*8;   // \"T\"\
    \n               uint8_t value[remainder()]; // \"V\"\n           } payload :length*8;\n\
    \       }\n   } :variable*8;\n                             +---/---/-------+\n\
    \                             | L \\ T \\   V   |\n                          \
    \   +---/---/-------+\n             Figure 2: Option Depiction in Following Diagrams\n"
- title: 2.1.4.  Option List
  contents:
  - "2.1.4.  Option List\n   An Option List is a sequence of zero or more non-empty\
    \ Options\n   terminated by a Marker.\n   +~~~/~~~/~~~~~~~+               +~~~/~~~/~~~~~~~+-------------/-+\n\
    \   | L \\ T \\   V   |...............| L \\ T \\   V   |       0     \\ |\n \
    \  +~~~/~~~/~~~~~~~+               +~~~/~~~/~~~~~~~+-------------/-+\n   ^   \
    \                                            ^     Marker\n   +------- zero or\
    \ more non-empty Options --------+ (empty Option)\n   struct optionList_t\n  \
    \ {\n       do\n       {\n           option_t option :variable*8;\n       } while(option.length\
    \ > 0);\n   } :variable*8;\n"
- title: 2.1.5.  Internet Socket Address (Address)
  contents:
  - "2.1.5.  Internet Socket Address (Address)\n   When communicating an Internet\
    \ socket address (a combination of a\n   32-bit IPv4 [RFC0791] or 128-bit IPv6\
    \ [RFC2460] address and a 16-bit\n   port number) to another RTMFP, this encoding\
    \ is used.  This encoding\n   additionally allows an address to be tagged with\
    \ an origin type,\n   which an RTMFP MAY use to modify the use or disposition\
    \ of the\n   address.\n                                                      \
    \  1\n    0 1 2 3 4 5 6 7                 0 1 2 3 4 5 6 7|8 9 0 1 2 3 4 5\n  \
    \ +-+-+-+-+-+-+-+-+-----/.../-----+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   |I|  \
    \       | O |    Internet   |                               |\n   |P|0 0 0 0 0|\
    \ R |    address    |              port             |\n   |6|   rsv   | I |32\
    \ or 128 bits |                               |\n   +-+-+-+-+-+-+-+-+-----/.../-----+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   struct address_t\n   {\n       bool_t  inet6    :1;     // \"IP6\"\n     \
    \  uintn_t reserved :5 = 0; // \"rsv\"\n       uintn_t origin   :2;     // \"\
    ORI\"\n       if(inet6)\n           uint128_t ipAddress;\n       else\n      \
    \     uint32_t ipAddress;\n       uint16_t port;\n   } :variable*8;\n   inet6:\
    \  If set, the Internet address is a 128-bit IPv6 address.  If\n      clear, the\
    \ Internet address is a 32-bit IPv4 address.\n   origin:  The origin tag of this\
    \ address.  Possible values are:\n      0:    Unknown, unspecified, or \"other\"\
    \n      1:    Address was reported by the origin as a local, directly\n      \
    \      attached interface address\n      2:    Address was observed to be the\
    \ source address from which a\n            packet was received (a \"reflexive\
    \ transport address\" in the\n            terminology of [RFC5389])\n      3:\
    \    Address is a relay, proxy, or introducer (a Redirector\n            and/or\
    \ Forwarder)\n   ipAddress:  The Internet address, in network byte order.\n  \
    \ port:  The 16-bit port number, in network byte order.\n"
- title: 2.2.  Network Layer
  contents:
  - '2.2.  Network Layer

    '
- title: 2.2.1.  Encapsulation
  contents:
  - "2.2.1.  Encapsulation\n   RTMFP Multiplex packets are usually carried in UDP\
    \ [RFC0768]\n   datagrams so that they may transit commonly deployed NATs and\n\
    \   firewalls, and so that RTMFP may be implemented on commonly deployed\n   operating\
    \ systems without special privileges or permissions.\n   RTMFP Multiplex packets\
    \ MAY be carried by any suitable datagram\n   transport or encapsulation where\
    \ endpoints are addressed by an\n   Internet socket address (that is, an IPv4\
    \ or IPv6 address and a\n   16-bit port number).\n   The choice of port numbers\
    \ is not mandated by this specification.\n   Higher protocol layers or the application\
    \ define the port\n   numbers used.\n"
- title: 2.2.2.  Multiplex
  contents:
  - "2.2.2.  Multiplex\n    0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2\
    \ 3 4 5 6 7\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                 Scrambled Session ID (SSID)                   |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |             e             first32[0]                          |\n   |- -\
    \ - - - -  n  - - - - - - - - - - - - - - - - - - - - - - - -|\n   |         \
    \    c             first32[1]                          |\n   +- - - - - -  r \
    \ - - - - - - - - - - - - - - - - - - - - - - - -+\n   |             y       \
    \                                          |\n   |             pted packet   \
    \                                    |\n   +---------------------------------------------------------------/\n\
    \   struct multiplex_t\n   {\n       uint32_t scrambledSessionID; // \"SSID\"\n\
    \       union {\n           uint32_t first32[2]; // see note\n           uint8_t\
    \  encryptedPacket[remainder()];\n       } :(encapsulation.length - 4)*8;\n  \
    \     // if encryptedPacket is less than 8 bytes long, treat it\n       // as\
    \ if it were end-padded with 0s for the following:\n       sessionID = scrambledSessionID\
    \ XOR first32[0] XOR first32[1];\n   } :encapsulation.length*8;\n   The 32-bit\
    \ Scrambled Session ID is the 32-bit session ID modified by\n   performing a bitwise\
    \ exclusive-or with the bitwise exclusive-or of\n   the first two 32-bit words\
    \ of the encrypted packet.\n   The session ID is a 32-bit value that the receiver\
    \ has requested to\n   be used by the sender when sending packets to this receiver\n\
    \   (Sections 2.3.7 and 2.3.8).  The session ID identifies the session to\n  \
    \ which this packet belongs and the decryption key to be used to\n   decrypt the\
    \ encrypted packet.\n   Note: Session ID 0 (prior to scrambling) denotes the startup\
    \ pseudo-\n   session and implies the Default Session Key.\n   Note: If the encrypted\
    \ packet is less than 8 bytes long, then for the\n   scrambling operation, perform\
    \ the exclusive-or as though the\n   encrypted packet were end-padded with enough\
    \ 0-bytes to bring its\n   length to 8.\n"
- title: 2.2.3.  Encryption
  contents:
  - "2.2.3.  Encryption\n   RTMFP packets are encrypted according to a Cryptography\
    \ Profile.\n   This specification doesn't define a Cryptography Profile or mandate\
    \ a\n   particular choice of cryptography.  The application defines the\n   cryptographic\
    \ syntax and algorithms.\n   Packet encryption is RECOMMENDED to be a block cipher\
    \ operating in\n   Cipher Block Chaining [CBC] or similar mode.  Encrypted packets\
    \ MUST\n   be decipherable without inter-packet dependency, since packets may\
    \ be\n   lost, duplicated, or reordered in the network.\n   The packet encryption\
    \ layer is responsible for data integrity and\n   authenticity of packets, for\
    \ example by means of a checksum or\n   cryptographic message authentication code.\
    \  To mitigate replay\n   attacks, data integrity SHOULD comprise duplicate packet\
    \ detection,\n   for example by means of a session-wide packet sequence number.\
    \  The\n   packet encryption layer SHALL discard a received packet that does not\n\
    \   pass integrity or authenticity tests.\n   Note that the structures described\
    \ below are of plain, unencrypted\n   packets.  Encrypted packets MUST be decrypted\
    \ according to the\n   Session Key associated with the Multiplex Session ID before\
    \ being\n   interpreted according to this specification.\n   The Cryptography\
    \ Profile defines a well-known Default Session Key\n   that is used at session\
    \ startup, during which per-session key(s) are\n   negotiated by the two endpoints.\
    \  A session ID of zero denotes use of\n   the Default Session Key.  The Default\
    \ Session Key is also used with\n   non-zero session IDs during the latter phases\
    \ of session startup\n   (Sections 2.3.6 and 2.3.8).  See Security Considerations\
    \ (Section 5)\n   for more about the Default Session Key.\n"
- title: 2.2.4.  Packet
  contents:
  - "2.2.4.  Packet\n   An (unencrypted, plain) RTMFP packet consists of a variable\
    \ sized\n   common header, zero or more chunks, and padding.  Padding can be\n\
    \   inserted by the encryption layer of the sender to meet cipher block\n   size\
    \ constraints and is ignored by the receiver.  A sender's\n   encryption layer\
    \ MAY pad the end of a packet with bytes with value\n   0xff such that the resulting\
    \ packet is a natural and appropriate size\n   for the cipher.  Alternatively,\
    \ the Cryptography Profile MAY define\n   its own framing and padding scheme,\
    \ if needed, such that decrypted\n   packets are compatible with the syntax defined\
    \ in this section.\n    0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2\
    \ 3 4 5 6 7\n   +-+-+-+-+-+-+-+-+\n   |T|T| r |T|T| M |\n   |C|C| s |S|S| O |\n\
    \   | |R| v | |E| D |\n   +-+-+-+-+-+-+-+-+\n   +~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+\n\
    \   |        if(TS) timestamp       |     if(TSE) timestampEcho     |\n   +~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+\n\
    \   +~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~+\n   |  \
    \                           Chunk                             |\n   +~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~/\n\
    \                                   :\n                                   :\n\
    \   +~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~+\n   |  \
    \                           Chunk                             |\n   +~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~/\n\
    \   +~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~+\n   |  \
    \                          padding                            |\n   +~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~/\n\
    \   struct packet_t\n   {\n       bool_t  timeCritical         :1; // \"TC\"\n\
    \       bool_t  timeCriticalReverse  :1; // \"TCR\"\n       uintn_t reserved \
    \            :2; // \"rsv\"\n       bool_t  timestampPresent     :1; // \"TS\"\
    \n       bool_t  timestampEchoPresent :1; // \"TSE\"\n       uintn_t mode    \
    \             :2; // \"MOD\"\n       if(0 != mode)\n       {\n           if(timestampPresent)\n\
    \               uint16_t timestamp;\n           if(timestampEchoPresent)\n   \
    \            uint16_t timestampEcho;\n           while(remainder() > 2)\n    \
    \       {\n               uint8_t  chunkType;\n               uint16_t chunkLength;\n\
    \               if(remainder() < chunkLength)\n                   break;\n   \
    \            uint8_t  chunkPayload[chunkLength];\n           } // chunks\n   \
    \        uint8_t padding[remainder()];\n       }\n   } :plainPacket.length*8;\n\
    \   timeCritical:  Time Critical Forward Notification.  If set, indicates\n  \
    \    that this packet contains real-time user data.\n   timeCriticalReverse: \
    \ Time Critical Reverse Notification.  If set,\n      indicates that the sender\
    \ is currently receiving packets on other\n      sessions that have the timeCritical\
    \ flag set.\n   timestampPresent:  If set, indicates that the timestamp field\
    \ is\n      present.  If clear, there is no timestamp field.\n   timestampEchoPresent:\
    \  If set, indicates that the timestamp echo\n      field is present.  If clear,\
    \ there is no timestamp echo field.\n   mode:  The mode of this packet.  See below\
    \ for additional discussion\n      of packet modes.  Possible values are:\n  \
    \    0:    Forbidden value\n      1:    Initiator Mark\n      2:    Responder\
    \ Mark\n      3:    Startup\n   timestamp:  If the timestampPresent flag is set,\
    \ this field is\n      present and contains the low 16 bits of the sender's 250\
    \ Hz clock\n      (4 milliseconds per tick) at transmit time.  The sender's clock\n\
    \      MAY have its origin at any time in the past.\n   timestampEcho:  If the\
    \ timestampEchoPresent flag is set, this field\n      is present and contains\
    \ the sender's estimate of what the\n      timestamp field of a packet received\
    \ from the other end would be\n      at the time this packet was transmitted,\
    \ using the method\n      described in Section 3.5.2.2.\n   chunks:  Zero or more\
    \ chunks follow the header.  It is RECOMMENDED\n      that a packet contain at\
    \ least one chunk.\n   padding:  Zero or more bytes of padding follow the chunks.\
    \  The\n      following conditions indicate padding:\n      *  Fewer than three\
    \ bytes (the size of a chunk header) remain in\n         the packet.\n      *\
    \  The chunkLength field of what would be the current chunk header\n         indicates\
    \ that the hypothetical chunk payload wouldn't fit in\n         the remaining\
    \ bytes of the packet.\n   Packet mode 0 is not allowed.  Packets marked with\
    \ this mode are\n   invalid and MUST be discarded.\n   The original initiator\
    \ of a session MUST mark all non-startup packets\n   it sends in that session\
    \ with packet mode 1 (\"Initiator Mark\").  It\n   SHOULD ignore any packet received\
    \ in that session with packet mode 1.\n   The original responder of a session\
    \ MUST mark all non-startup packets\n   it sends in that session with packet mode\
    \ 2 (\"Responder Mark\").  It\n   SHOULD ignore any packet received in that session\
    \ with packet mode 2.\n   Packet mode 3 is for session startup.  Session startup\
    \ chunks are\n   only allowed in packets with this mode.\n   Chunks that are not\
    \ for session startup are only allowed in packets\n   with modes 1 or 2.\n"
- title: 2.3.  Chunks
  contents:
  - "2.3.  Chunks\n    0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5\
    \ 6 7\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   |   chunkType\
    \   |          chunkLength          |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   +~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~+\n   |  \
    \      chunkPayload (chunkLength bytes, may be zero)          |\n   +~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~/\n\
    \   struct chunk_t\n   {\n       uint8_t  chunkType;\n       uint16_t chunkLength;\n\
    \       uint8_t  chunkPayload[chunkLength];\n   } :variable*8;\n   chunkType:\
    \  The chunk type code.\n   chunkLength:  The size, in bytes, of the chunk payload.\n\
    \   chunkPayload:  The type-specific payload of this chunk,\n      chunkLength\
    \ bytes in length (may be empty).\n   Defined chunk types are enumerated here\
    \ in the order they might be\n   encountered in the course of a typical session.\
    \  The following chunk\n   type codes are defined:\n   0x7f:  Packet Fragment\
    \ (Section 2.3.1)\n   0x30:  Initiator Hello (Section 2.3.2)\n   0x0f:  Forwarded\
    \ Initiator Hello (Section 2.3.3)\n   0x70:  Responder Hello (Section 2.3.4)\n\
    \   0x71:  Responder Redirect (Section 2.3.5)\n   0x79:  RHello Cookie Change\
    \ (Section 2.3.6)\n   0x38:  Initiator Initial Keying (Section 2.3.7)\n   0x78:\
    \  Responder Initial Keying (Section 2.3.8)\n   0x01:  Ping (Section 2.3.9)\n\
    \   0x41:  Ping Reply (Section 2.3.10)\n   0x10:  User Data (Section 2.3.11)\n\
    \   0x11:  Next User Data (Section 2.3.12)\n   0x50:  Data Acknowledgement Bitmap\
    \ (Section 2.3.13)\n   0x51:  Data Acknowledgement Ranges (Section 2.3.14)\n \
    \  0x18:  Buffer Probe (Section 2.3.15)\n   0x5e:  Flow Exception Report (Section\
    \ 2.3.16)\n   0x0c:  Session Close Request (Section 2.3.17)\n   0x4c:  Session\
    \ Close Acknowledgement (Section 2.3.18)\n   0x00:  Ignore/Padding\n   0xff: \
    \ Ignore/Padding\n   A receiver MUST ignore a chunk having an unrecognized chunk\
    \ type\n   code.  A receiver MUST ignore a chunk appearing in a packet having\
    \ a\n   mode inappropriate to that chunk type.\n   Unless specified otherwise,\
    \ if a chunk has a syntax or processing\n   error (for example, the chunk's payload\
    \ field is not long enough to\n   contain the specified syntax elements), the\
    \ chunk SHALL be ignored as\n   though it was not present in the packet, and parsing\
    \ and processing\n   SHALL commence with the next chunk in the packet, if any.\n"
- title: 2.3.1.  Packet Fragment Chunk
  contents:
  - "2.3.1.  Packet Fragment Chunk\n   This chunk is used to divide a plain RTMFP\
    \ packet (Section 2.2.4)\n   that is unavoidably larger than the path MTU (such\
    \ as session startup\n   packets containing Responder Hello (Section 2.3.4) or\
    \ Initiator\n   Initial Keying (Section 2.3.7) chunks with large certificates)\
    \ into\n   segments that do not exceed the path MTU, and to allow the segments\n\
    \   to be sent through the network at a moderated rate to avoid jamming\n   interfaces,\
    \ links, or paths.\n    0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2\
    \ 3 4 5 6 7\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   |      0x7f\
    \     |          chunkLength          |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   +-+-+-+-+-+-+-+-+-------------/-+-------------/-+\n   |M|  reserved   |  \
    \ packetID  \\ | fragmentNum \\ |\n   +-+-+-+-+-+-+-+-+-------------/-+-------------/-+\n\
    \   +---------------------------------------------------------------+\n   |  \
    \                       packetFragment                        |\n   +---------------------------------------------------------------/\n\
    \   struct fragmentChunkPayload_t\n   {\n       bool_t  moreFragments :1; // M\n\
    \       uintn_t reserved      :7;\n       vlu_t   packetID      :variable*8;\n\
    \       vlu_t   fragmentNum   :variable*8;\n       uint8_t packetFragment[remainder()];\n\
    \   } :chunkLength*8;\n   moreFragments:  If set, the indicated packet comprises\
    \ additional\n      fragments.  If clear, this fragment is the final fragment\
    \ of the\n      packet.\n   reserved:  Reserved for future use.\n   packetID:\
    \  VLU, the identifier of this segmented packet.  All\n      fragments of the\
    \ same packet have the same packetID.\n   fragmentNum:  VLU, the index of this\
    \ fragment of the indicated\n      packet.  The first fragment of the packet MUST\
    \ be index 0.\n      Fragments are numbered consecutively.\n   packetFragment:\
    \  The bytes of the indicated segment of the indicated\n      original plain RTMFP\
    \ packet.  A packetFragment MUST NOT be empty.\n   The use of this mechanism is\
    \ detailed in Section 3.4.\n"
- title: 2.3.2.  Initiator Hello Chunk (IHello)
  contents:
  - "2.3.2.  Initiator Hello Chunk (IHello)\n   This chunk is sent by the initiator\
    \ of a new session to begin the\n   startup handshake.  This chunk is only allowed\
    \ in a packet with\n   Session ID 0, encrypted with the Default Session Key, and\
    \ having\n   packet mode 3 (Startup).\n    0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1\
    \ 2 3 4 5 6 7|0 1 2 3 4 5 6 7\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |      0x30     |          chunkLength          |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   +-------------/-+-----------------------------------------------+\n   |  epdLength\
    \  \\ |    endpointDiscriminator (epdLength bytes)    |\n   +-------------/-+-----------------------------------------------/\n\
    \   +---------------------------------------------------------------+\n   |  \
    \                            tag                              |\n   +---------------------------------------------------------------/\n\
    \   struct ihelloChunkPayload_t\n   {\n       vlu_t   epdLength :variable*8;\n\
    \       uint8_t endpointDiscriminator[epdLength];\n       uint8_t tag[remainder()];\n\
    \   } :chunkLength*8;\n   epdLength:  VLU, the length of the following endpointDiscriminator\n\
    \      field in bytes.\n   endpointDiscriminator:  The Endpoint Discriminator\
    \ for the identity\n      with which the initiator wants to communicate.\n   tag:\
    \  Initiator-provided data to be returned in a Responder Hello's\n      tagEcho\
    \ field.  The tag/tagEcho is used to match Responder Hellos\n      to the initiator's\
    \ session startup state independent of the\n      responder's address.\n   The\
    \ use of IHello is detailed in Section 3.5.1.\n"
- title: 2.3.3.  Forwarded Initiator Hello Chunk (FIHello)
  contents:
  - "2.3.3.  Forwarded Initiator Hello Chunk (FIHello)\n   This chunk is sent on behalf\
    \ of an initiator by a Forwarder.  It is\n   only allowed in packets of an established\
    \ session having packet\n   mode 1 or 2.  A receiver MAY treat this chunk as though\
    \ it was an\n   Initiator Hello received directly from replyAddress.  Alternatively,\n\
    \   if the receiver is selected by the Endpoint Discriminator, it MAY\n   respond\
    \ to replyAddress with an Implied Redirect (Section 2.3.5).\n    0 1 2 3 4 5 6\
    \ 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |      0x0f     |          chunkLength          |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   +-------------/-+-----------------------------------------------+\n   |  epdLength\
    \  \\ |    endpointDiscriminator (epdLength bytes)    |\n   +-------------/-+-----------------------------------------------/\n\
    \   +---------------------------------------------------------------+\n   |  \
    \                        replyAddress                         |\n   +---------------------------------------------------------------/\n\
    \   +---------------------------------------------------------------+\n   |  \
    \                            tag                              |\n   +---------------------------------------------------------------/\n\
    \   struct fihelloChunkPayload_t\n   {\n       vlu_t     epdLength :variable*8;\n\
    \       uint8_t   endpointDiscriminator[epdLength];\n       address_t replyAddress\
    \ :variable*8;\n       uint8_t   tag[remainder()];\n   } :chunkLength*8;\n   epdLength:\
    \  VLU, the length of the following endpointDiscriminator\n      field in bytes.\n\
    \   endpointDiscriminator:  The Endpoint Discriminator for the identity\n    \
    \  with which the original initiator wants to communicate, copied\n      from\
    \ the original Initiator Hello.\n   replyAddress:  Address format (Section 2.1.5),\
    \ the address that the\n      forwarding node derived from the received Initiator\
    \ Hello, to\n      which the receiver should respond.\n   tag:  Copied from the\
    \ original Initiator Hello.\n   The use of FIHello is detailed in Section 3.5.1.5.\n"
- title: 2.3.4.  Responder Hello Chunk (RHello)
  contents:
  - "2.3.4.  Responder Hello Chunk (RHello)\n   This chunk is sent by a responder\
    \ in response to an Initiator Hello\n   or Forwarded Initiator Hello if the Endpoint\
    \ Discriminator indicates\n   the responder's identity.  This chunk is only allowed\
    \ in a packet\n   with Session ID 0, encrypted with the Default Session Key, and\
    \ having\n   packet mode 3 (Startup).\n    0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1\
    \ 2 3 4 5 6 7|0 1 2 3 4 5 6 7\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |      0x70     |          chunkLength          |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   +-------------/-+-----------------------------------------------+\n   |  tagLength\
    \  \\ |            tagEcho (tagLength bytes)          |\n   +-------------/-+-----------------------------------------------/\n\
    \   +-------------/-+-----------------------------------------------+\n   | cookieLength\\\
    \ |           cookie (cookieLength bytes)         |\n   +-------------/-+-----------------------------------------------/\n\
    \   +---------------------------------------------------------------+\n   |  \
    \                   responderCertificate                      |\n   +---------------------------------------------------------------/\n\
    \   struct rhelloChunkPayload_t\n   {\n       vlu_t   tagLength :variable*8;\n\
    \       uint8_t tagEcho[tagLength];\n       vlu_t   cookieLength :variable*8;\n\
    \       uint8_t cookie[cookieLength];\n       uint8_t responderCertificate[remainder()];\n\
    \   } :chunkLength*8;\n   tagLength:  VLU, the length of the following tagEcho\
    \ field in bytes.\n   tagEcho:  The tag from the Initiator Hello, unaltered.\n\
    \   cookieLength:  VLU, the length of the following cookie field\n      in bytes.\n\
    \   cookie:  Responder-created state data to authenticate a future\n      Initiator\
    \ Initial Keying message (in order to prevent denial-of-\n      service attacks).\n\
    \   responderCertificate:  The responder's cryptographic credentials.\n   Note:\
    \ This specification doesn't mandate a specific choice of\n   certificate format.\
    \  The Cryptography Profile determines the syntax,\n   algorithms, and interpretation\
    \ of the responderCertificate.\n   The use of RHello is detailed in Section 3.5.1.\n"
- title: 2.3.5.  Responder Redirect Chunk (Redirect)
  contents:
  - "2.3.5.  Responder Redirect Chunk (Redirect)\n   This chunk is sent in response\
    \ to an Initiator Hello or Forwarded\n   Initiator Hello to indicate that the\
    \ requested endpoint can be\n   reached at one or more of the indicated addresses.\
    \  A receiver can\n   add none, some, or all of the indicated addresses to the\
    \ set of\n   addresses to which it is sending Initiator Hello messages for the\n\
    \   opening session associated with tagEcho.  This chunk is only allowed\n   in\
    \ a packet with Session ID 0, encrypted with the Default Session\n   Key, and\
    \ having packet mode 3 (Startup).\n    0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3\
    \ 4 5 6 7|0 1 2 3 4 5 6 7\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |      0x71     |          chunkLength          |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   +-------------/-+-----------------------------------------------+\n   |  tagLength\
    \  \\ |            tagEcho (tagLength bytes)          |\n   +-------------/-+-----------------------------------------------/\n\
    \   +~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~+\n   |  \
    \                   redirectDestination 1                     |\n   +~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~/\n\
    \                                   :\n                                   :\n\
    \   +~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~+\n   |  \
    \                   redirectDestination N                     |\n   +~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~/\n\
    \   struct responderRedirectChunkPayload_t\n   {\n       vlu_t   tagLength :variable*8;\n\
    \       uint8_t tagEcho[tagLength];\n       addressCount = 0;\n       while(remainder()\
    \ > 0)\n       {\n           address_t redirectDestination :variable*8;\n    \
    \       addressCount++;\n       }\n       if(0 == addressCount)\n           redirectDestination\
    \ = packetSourceAddress();\n   } :chunkLength*8;\n   tagLength:  VLU, the length\
    \ of the following tagEcho field in bytes.\n   tagEcho:  The tag from the Initiator\
    \ Hello, unaltered.\n   redirectDestination:  (Zero or more) Address format (Section\
    \ 2.1.5)\n      addresses to add to the opening set for the indicated session.\n\
    \   If this chunk lists zero redirectDestination addresses, then this is\n   an\
    \ Implied Redirect, and the indicated address is the address from\n   which the\
    \ packet containing this chunk was received.\n   The use of Redirect is detailed\
    \ in Sections 3.5.1.1.1, 3.5.1.1.2,\n   and 3.5.1.4.\n"
- title: 2.3.6.  RHello Cookie Change Chunk
  contents:
  - "2.3.6.  RHello Cookie Change Chunk\n   This chunk SHOULD be sent by a responder\
    \ to an initiator in response\n   to an Initiator Initial Keying if that chunk's\
    \ cookie appears to have\n   been created by the responder but the cookie is incorrect\
    \ (for\n   example, it includes a hash of the initiator's address, but the\n \
    \  initiator's address is different than the one that elicited the\n   Responder\
    \ Hello containing the original cookie).\n   This chunk is only allowed in a packet\
    \ encrypted with the Default\n   Session Key and having packet mode 3, and with\
    \ the session ID\n   indicated in the initiatorSessionID field of the Initiator\
    \ Initial\n   Keying to which this is a response.\n    0 1 2 3 4 5 6 7|0 1 2 3\
    \ 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |      0x79     |          chunkLength          |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   +-------------/-+-----------------------------------------------+\n   | oldCookieLen\\\
    \ |        oldCookie (oldCookieLen bytes)         |\n   +-------------/-+-----------------------------------------------/\n\
    \   +---------------------------------------------------------------+\n   |  \
    \                         newCookie                           |\n   +---------------------------------------------------------------/\n\
    \   struct rhelloCookieChangeChunkPayload_t\n   {\n       vlu_t   oldCookieLen\
    \ :variable*8;\n       uint8_t oldCookie[oldCookieLen];\n       uint8_t newCookie[remainder()];\n\
    \   } :chunkLength*8;\n   oldCookieLen:  VLU, the length of the following oldCookie\
    \ field\n      in bytes.\n   oldCookie:  The cookie that was sent in a previous\
    \ Responder Hello\n      and Initiator Initial Keying.\n   newCookie:  The new\
    \ cookie that the responder would like sent (and\n      signed) in a replacement\
    \ Initiator Initial Keying.  The old and\n      new cookies need not have the\
    \ same lengths.\n   On receipt of this chunk, the initiator SHOULD compute, sign,\
    \ and\n   send a new Initiator Initial Keying having newCookie in place of\n \
    \  oldCookie.  The use of this chunk is detailed in Section 3.5.1.2.\n"
- title: 2.3.7.  Initiator Initial Keying Chunk (IIKeying)
  contents:
  - "2.3.7.  Initiator Initial Keying Chunk (IIKeying)\n   This chunk is sent by an\
    \ initiator to establish a session with a\n   responder.  The initiator MUST have\
    \ obtained a valid cookie to use\n   with the responder, typically by receiving\
    \ a Responder Hello from it.\n   This chunk is only allowed in a packet with Session\
    \ ID 0, encrypted\n   with the Default Session Key, and having packet mode 3 (Startup).\n\
    \    0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |      0x38     |          chunkLength          |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   |  \
    \                     initiatorSessionID                      |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   +-------------/-+-----------------------------------------------+\n   | cookieLength\\\
    \ |                  cookieEcho                   |\n   +-------------/-+-----------------------------------------------/\n\
    \   +-------------/-+-----------------------------------------------+\n   |  certLength\
    \ \\ |             initiatorCertificate              |\n   +-------------/-+-----------------------------------------------/\n\
    \   +-------------/-+-----------------------------------------------+\n   |  skicLength\
    \ \\ |          sessionKeyInitiatorComponent         |\n   +-------------/-+-----------------------------------------------/\n\
    \   +---------------------------------------------------------------+\n   |  \
    \                         signature                           |\n   +---------------------------------------------------------------/\n\
    \   struct iikeyingChunkPayload_t\n   {\n       struct\n       {\n           uint32_t\
    \ initiatorSessionID;\n           vlu_t    cookieLength :variable*8;\n       \
    \    uint8_t  cookieEcho[cookieLength];\n           vlu_t    certLength :variable*8;\n\
    \           uint8_t  initiatorCertificate[certLength];\n           vlu_t    skicLength\
    \ :variable*8;\n           uint8_t  sessionKeyInitiatorComponent[skicLength];\n\
    \       } initiatorSignedParameters :variable*8;\n       uint8_t signature[remainder()];\n\
    \   } :chunkLength*8;\n   initiatorSessionID:  The session ID to be used by the\
    \ responder when\n      sending packets to the initiator.\n   cookieLength:  VLU,\
    \ the length of the following cookieEcho field\n      in bytes.\n   cookieEcho:\
    \  The cookie from the Responder Hello, unaltered.\n   certLength:  VLU, the length\
    \ of the following initiatorCertificate\n      field in bytes.\n   initiatorCertificate:\
    \  The initiator's identity credentials.\n   skicLength:  VLU, the length of the\
    \ following\n      sessionKeyInitiatorComponent field in bytes.\n   sessionKeyInitiatorComponent:\
    \  The initiator's portion of the session\n      key negotiation according to\
    \ the Cryptography Profile.\n   initiatorSignedParameters:  The payload portion\
    \ of this chunk up to\n      the signature field.\n   signature:  The initiator's\
    \ digital signature of the\n      initiatorSignedParameters according to the Cryptography\
    \ Profile.\n   Note: This specification doesn't mandate a specific choice of\n\
    \   cryptography.  The Cryptography Profile determines the syntax,\n   algorithms,\
    \ and interpretation of the initiatorCertificate,\n   responderCertificate, sessionKeyInitiatorComponent,\n\
    \   sessionKeyResponderComponent, and signature, and how the\n   sessionKeyInitiatorComponent\
    \ and sessionKeyResponderComponent are\n   combined to derive the session keys.\n\
    \   The use of IIKeying is detailed in Section 3.5.1.\n"
- title: 2.3.8.  Responder Initial Keying Chunk (RIKeying)
  contents:
  - "2.3.8.  Responder Initial Keying Chunk (RIKeying)\n   This chunk is sent by a\
    \ responder in response to an Initiator Initial\n   Keying as the final phase\
    \ of session startup.  This chunk is only\n   allowed in a packet encrypted with\
    \ the Default Session Key, having\n   packet mode 3 (Startup), and sent to the\
    \ initiator with the\n   session ID specified by the initiatorSessionID field\
    \ from the\n   Initiator Initial Keying.\n    0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0\
    \ 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |      0x78     |          chunkLength          |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   |  \
    \                     responderSessionID                      |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   +-------------/-+-----------------------------------------------+\n   |  skrcLength\
    \ \\ |         sessionKeyResponderComponent          |\n   +-------------/-+-----------------------------------------------/\n\
    \   +---------------------------------------------------------------+\n   |  \
    \                         signature                           |\n   +---------------------------------------------------------------/\n\
    \   struct rikeyingChunkPayload_t\n   {\n       struct\n       {\n           uint32_t\
    \ responderSessionID;\n           vlu_t    skrcLength :variable*8;\n         \
    \  uint8_t  sessionKeyResponderComponent[skrcLength];\n       } responderSignedParametersPortion\
    \ :variable*8;\n       uint8_t  signature[remainder()];\n   } :chunkLength*8;\n\
    \   struct\n   {\n       responderSignedParametersPortion;\n       sessionKeyInitiatorComponent;\n\
    \   } responderSignedParameters;\n   responderSessionID:  The session ID to be\
    \ used by the initiator when\n      sending packets to the responder.\n   skrcLength:\
    \  VLU, the length of the following\n      sessionKeyResponderComponent field\
    \ in bytes.\n   sessionKeyResponderComponent:  The responder's portion of the\
    \ session\n      key negotiation according to the Cryptography Profile.\n   responderSignedParametersPortion:\
    \  The payload portion of this chunk\n      up to the signature field.\n   signature:\
    \  The responder's digital signature of the\n      responderSignedParameters (see\
    \ below) according to the\n      Cryptography Profile.\n   responderSignedParameters:\
    \  The concatenation of the\n      responderSignedParametersPortion (the payload\
    \ portion of this\n      chunk up to the signature field) and the\n      sessionKeyInitiatorComponent\
    \ from the Initiator Initial Keying to\n      which this chunk is a response.\n\
    \   Note: This specification doesn't mandate a specific choice of\n   cryptography.\
    \  The Cryptography Profile determines the syntax,\n   algorithms, and interpretation\
    \ of the initiatorCertificate,\n   responderCertificate, sessionKeyInitiatorComponent,\n\
    \   sessionKeyResponderComponent, and signature, and how the\n   sessionKeyInitiatorComponent\
    \ and sessionKeyResponderComponent are\n   combined to derive the session keys.\n\
    \   Once the responder has computed the sessionKeyResponderComponent, it\n   has\
    \ all of the information and state necessary for an established\n   session with\
    \ the initiator.  Once the responder has sent this chunk\n   to the initiator,\
    \ the session is established and ready to carry flows\n   of user data.\n   Once\
    \ the initiator receives, verifies, and processes this chunk, it\n   has all of\
    \ the information and state necessary for an established\n   session with the\
    \ responder.  The session is established and ready to\n   carry flows of user\
    \ data.\n   The use of RIKeying is detailed in Section 3.5.1.\n"
- title: 2.3.9.  Ping Chunk
  contents:
  - "2.3.9.  Ping Chunk\n   This chunk is sent in order to elicit a Ping Reply from\
    \ the receiver.\n   It is only allowed in a packet belonging to an established\
    \ session\n   and having packet mode 1 or 2.\n    0 1 2 3 4 5 6 7|0 1 2 3 4 5\
    \ 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |      0x01     |          chunkLength          |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   +~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~+\n   |  \
    \                           message                           |\n   +~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~/\n\
    \   struct pingChunkPayload_t\n   {\n       uint8_t message[chunkLength];\n  \
    \ } :chunkLength*8;\n   message:  The (potentially empty) message that is expected\
    \ to be\n      returned by the other end of the session in a Ping Reply.\n   The\
    \ receiver of this chunk SHOULD reply as immediately as is\n   practical with\
    \ a Ping Reply.\n   Ping and the expected Ping Reply are typically used for session\n\
    \   keepalive, endpoint address change verification, and path MTU\n   discovery.\
    \  See Section 3.5.4 for details.\n"
- title: 2.3.10.  Ping Reply Chunk
  contents:
  - "2.3.10.  Ping Reply Chunk\n   This chunk is sent in response to a Ping chunk.\
    \  It is only allowed\n   in a packet belonging to an established session and\
    \ having packet\n   mode 1 or 2.\n    0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3\
    \ 4 5 6 7|0 1 2 3 4 5 6 7\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |      0x41     |          chunkLength          |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   +~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~+\n   |  \
    \                         messageEcho                         |\n   +~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~/\n\
    \   struct pingReplyChunkPayload_t\n   {\n       uint8_t messageEcho[chunkLength];\n\
    \   } :chunkLength*8;\n   messageEcho:  The message from the Ping to which this\
    \ is a response,\n      unaltered.\n"
- title: 2.3.11.  User Data Chunk
  contents:
  - "2.3.11.  User Data Chunk\n   This chunk is the basic unit of transmission for\
    \ the user messages of\n   a flow.  A user message comprises one or more fragments.\
    \  Each\n   fragment is carried in its own chunk and has a unique sequence number\n\
    \   in its flow.  It is only allowed in a packet belonging to an\n   established\
    \ session and having packet mode 1 or 2.\n    0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0\
    \ 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |      0x10     |          chunkLength          |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   +-+-+-+-+-+-+-+-+\n   |O|r| F | r |A|F|\n   |P|s| R | s |B|I|\n   |T|v| A\
    \ | v |N|N|\n   +-+-+-+-+-+-+-+-+\n   +-------------/-+-------------/-+-------------/-+\n\
    \   |   flowID    \\ |     seq#    \\ |  fsnOffset  \\ |\n   +-------------/-+-------------/-+-------------/-+\n\
    \   +~~~/~~~/~~~~~~~+               +~~~/~~~/~~~~~~~+-------------/-+\n   | L\
    \ \\ T \\   V   |... options ...| L \\ T \\   V   |       0     \\ |\n   \\~~~/~~~/~~~~~~~+\
    \   [if(OPT)]   +~~~/~~~/~~~~~~~+-------------/-/\n   +~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~+\n\
    \   |                            userData                           |\n   +~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~/\n\
    \   struct userDataChunkPayload_t\n   {\n       bool_t  optionsPresent :1;  //\
    \ \"OPT\"\n       uintn_t reserved1 :1;       // \"rsv\"\n       uintn_t fragmentControl\
    \ :2; // \"FRA\"\n           // 0=whole, 1=begin, 2=end, 3=middle\n       uintn_t\
    \ reserved2 :2;       // \"rsv\"\n       bool_t  abandon :1;         // \"ABN\"\
    \n       bool_t  final :1;           // \"FIN\"\n       vlu_t   flowID :variable*8;\n\
    \       vlu_t   sequenceNumber :variable*8; // \"seq#\"\n       vlu_t   fsnOffset\
    \ :variable*8;\n       forwardSequenceNumber = sequenceNumber - fsnOffset;\n \
    \      if(optionsPresent)\n           optionList_t options :variable*8;\n    \
    \   uint8_t userData[remainder()];\n   } :chunkLength*8;\n   optionsPresent: \
    \ If set, indicates the presence of an option list\n      before the user data.\
    \  If clear, there is no option list in this\n      chunk.\n   fragmentControl:\
    \  Indicates how this fragment is assembled,\n      potentially with others, into\
    \ a complete user message.  Possible\n      values:\n      0:    This fragment\
    \ is a complete message.\n      1:    This fragment is the first of a multi-fragment\
    \ message.\n      2:    This fragment is the last of a multi-fragment message.\n\
    \      3:    This fragment is in the middle of a multi-fragment message.\n   \
    \   A single-fragment user message has a fragment control of\n      \"0-whole\"\
    .  When a message has more than one fragment, the first\n      fragment has a\
    \ fragment control of \"1-begin\", then zero or more\n      \"3-middle\" fragments,\
    \ and finally a \"2-end\" fragment.  The\n      sequence numbers of a multi-fragment\
    \ message MUST be contiguous.\n   abandon:  If set, this sequence number has been\
    \ abandoned by the\n      sender.  The userData, if any, MUST be ignored.\n  \
    \ final:  If set, this is the last sequence number of the flow.\n   flowID:  VLU,\
    \ the flow identifier.\n   sequenceNumber:  VLU, the sequence number of this fragment.\n\
    \      Fragments are assigned contiguous increasing sequence numbers in a\n  \
    \    flow.  The first sequence number of a flow SHOULD be 1.  The first\n    \
    \  sequence number of a flow MUST be greater than zero.  Sequence\n      numbers\
    \ are unbounded and do not wrap.\n   fsnOffset:  VLU, the difference between the\
    \ sequence number and the\n      Forward Sequence Number.  This field MUST NOT\
    \ be zero if the\n      abandon flag is not set.  This field MUST NOT be greater\
    \ than\n      sequenceNumber.\n   forwardSequenceNumber:  The flow sender will\
    \ not send (or resend) any\n      fragment with a sequence number less than or\
    \ equal to the Forward\n      Sequence Number.\n   options:  If the optionsPresent\
    \ flag is set, a list of zero or more\n      Options terminated by a Marker is\
    \ present.  See Section 2.3.11.1\n      for defined options.\n   userData:  The\
    \ actual user data for this fragment.\n   The use of User Data is detailed in\
    \ Section 3.6.2.\n"
- title: 2.3.11.1.  Options for User Data
  contents:
  - "2.3.11.1.  Options for User Data\n   This section lists options that may appear\
    \ in User Data option lists.\n   A conforming implementation MUST support the\
    \ options in this section.\n   A flow receiver MUST reject a flow containing a\
    \ flow option that is\n   not understood if the option type is less than 8192\
    \ (0x2000).  A flow\n   receiver MUST ignore any flow option that is not understood\
    \ if the\n   option type is 8192 or greater.\n   The following option type codes\
    \ are defined for User Data:\n   0x00:  User's Per-Flow Metadata (Section 2.3.11.1.1)\n\
    \   0x0a:  Return Flow Association (Section 2.3.11.1.2)\n"
- title: 2.3.11.1.1.  User's Per-Flow Metadata
  contents:
  - "2.3.11.1.1.  User's Per-Flow Metadata\n   This option conveys the user's per-flow\
    \ metadata for the flow to\n   which it's attached.\n   +-------------/-+-------------/-+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~+\n\
    \   |   length    \\ |     0x00    \\ |         userMetadata          |\n   +-------------/-+-------------/-+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~/\n\
    \   struct userMetadataOptionValue_t\n   {\n       uint8_t userMetadata[remainder()];\n\
    \   } :remainder()*8;\n   The user associates application-defined metadata with\
    \ each flow.  The\n   metadata does not change over the life of the flow.  Every\
    \ flow MUST\n   have metadata.  A flow sender MUST send this option with the first\n\
    \   User Data chunk for this flow in each packet until an acknowledgement\n  \
    \ for this flow is received.  A flow sender SHOULD NOT send this option\n   more\
    \ than once for each flow in any one packet.  A flow sender SHOULD\n   NOT send\
    \ this option for a flow once the flow has been acknowledged.\n   This specification\
    \ doesn't mandate the encoding, syntax, or\n   interpretation of the user's per-flow\
    \ metadata; this is determined by\n   the application.\n   The userMetadata SHOULD\
    \ NOT exceed 512 bytes.  The userMetadata MAY\n   be 0 bytes in length.\n"
- title: 2.3.11.1.2.  Return Flow Association
  contents:
  - "2.3.11.1.2.  Return Flow Association\n   A new flow can be considered to be in\
    \ return (or response) to a flow\n   sent by the other endpoint.  This option\
    \ encodes the receive flow\n   identifier to which this new sending flow is a\
    \ response.\n   +-------------/-+-------------/-+-------------/-+\n   |   length\
    \    \\ |     0x0a    \\ |    flowID   \\ |\n   +-------------/-+-------------/-+-------------/-+\n\
    \   struct returnFlowAssociationOptionValue_t\n   {\n       vlu_t flowID :variable*8;\n\
    \   } :variable*8;\n   Consider endpoints A and B.  Endpoint A begins a flow with\n\
    \   identifier 5 to endpoint B.  A is the flow sender for A's flowID=5,\n   and\
    \ B is the flow receiver for A's flowID=5.  B begins a return flow\n   with identifier\
    \ 7 to A in response to A's flowID=5.  B is the flow\n   sender for B's flowID=7,\
    \ and A is the flow receiver for B's flowID=7.\n   B sends this option with flowID\
    \ set to 5 to indicate that B's\n   flowID=7 is in response to and associated\
    \ with A's flowID=5.\n   If there is a return association, the flow sender MUST\
    \ send this\n   option with the first User Data chunk for this flow in each packet\n\
    \   until an acknowledgement for this flow is received.  A flow sender\n   SHOULD\
    \ NOT send this option more than once for each flow in any one\n   packet.  A\
    \ flow sender SHOULD NOT send this option for a flow once\n   the flow has been\
    \ acknowledged.\n   A flow MUST NOT indicate more than one return association.\n\
    \   A flow MUST indicate its return association, if any, upon its first\n   transmission\
    \ of a User Data chunk.  A return association can't be\n   added to a sending\
    \ flow after it begins.\n   A flow receiver MUST reject a new receiving flow having\
    \ a return flow\n   association that does not indicate an F_OPEN sending flow.\n"
- title: 2.3.12.  Next User Data Chunk
  contents:
  - "2.3.12.  Next User Data Chunk\n   This chunk is equivalent to the User Data chunk\
    \ for purposes of\n   sending the user messages of a flow.  When used, it MUST\
    \ follow a\n   User Data chunk or another Next User Data chunk in the same packet.\n\
    \    0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |      0x11     |          chunkLength          |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   +-+-+-+-+-+-+-+-+\n   |O|r| F | r |A|F|\n   |P|s| R | s |B|I|\n   |T|v| A\
    \ | v |N|N|\n   +-+-+-+-+-+-+-+-+\n   +~~~/~~~/~~~~~~~+               +~~~/~~~/~~~~~~~+-------------/-+\n\
    \   | L \\ T \\   V   |... options ...| L \\ T \\   V   |       0     \\ |\n \
    \  \\~~~/~~~/~~~~~~~+   [if(OPT)]   +~~~/~~~/~~~~~~~+-------------/-/\n   +~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~+\n\
    \   |                            userData                           |\n   +~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~/\n\
    \   struct nextUserDataChunkPayload_t\n   {\n       bool_t  optionsPresent :1;\
    \  // \"OPT\"\n       uintn_t reserved1 :1;       // \"rsv\"\n       uintn_t fragmentControl\
    \ :2; // \"FRA\"\n           // 0=whole, 1=begin, 2=end, 3=middle\n       uintn_t\
    \ reserved2 :2;       // \"rsv\"\n       bool_t  abandon :1;         // \"ABN\"\
    \n       bool_t  final :1;           // \"FIN\"\n       if(optionsPresent)\n \
    \          optionList_t options :variable*8;\n       uint8_t userData[remainder()];\n\
    \   } :chunkLength*8;\n   This chunk is considered to be for the same flowID as\
    \ the most\n   recently preceding User Data or Next User Data chunk in the same\n\
    \   packet, having the same Forward Sequence Number, and having the next\n   sequence\
    \ number.  The optionsPresent, fragmentControl, abandon, and\n   final flags,\
    \ and the options (if present), have the same\n   interpretation as for the User\
    \ Data chunk.\n               ...\n               ----------+------------------------------------\n\
    \               10 00 07  | User Data chunk, length=7\n               00     \
    \   | OPT=0, FRA=0 \"whole\", ABN=0, FIN=0\n               02 05 03  | flowID=2,\
    \ seq#=5, fsn=(5-3)=2\n               00 01 02  | data 3 bytes: 00, 01, 02\n \
    \              ----------+------------------------------------\n             \
    \  11 00 04  | Next User Data chunk,length=4\n               00        | OPT=0,\
    \ FRA=0 \"whole\", ABN=0, FIN=0\n                         | flowID=2, seq#=6,\
    \ fsn=2\n               03 04 05  | data 3 bytes: 03, 04, 05\n               ----------+------------------------------------\n\
    \               11 00 04  | Next User Data chunk, length=4\n               00\
    \        | OPT=0, FRA=0 \"whole\", ABN=0, FIN=0\n                         | flowID=2,\
    \ seq#=7, fsn=2\n               06 07 08  | data 3 bytes: 06, 07, 08\n       \
    \        ----------+------------------------------------\n     Figure 3: Sequential\
    \ Messages in One Packet Using Next User Data\n   The use of Next User Data is\
    \ detailed in Section 3.6.2.3.2.\n"
- title: 2.3.13.  Data Acknowledgement Bitmap Chunk (Bitmap Ack)
  contents:
  - "2.3.13.  Data Acknowledgement Bitmap Chunk (Bitmap Ack)\n   This chunk is sent\
    \ by the flow receiver to indicate to the flow\n   sender the User Data fragment\
    \ sequence numbers that have been\n   received for one flow.  It is only allowed\
    \ in a packet belonging to\n   an established session and having packet mode 1\
    \ or 2.\n   The flow receiver can choose to acknowledge User Data with this chunk\n\
    \   or with a Range Ack.  It SHOULD choose whichever format has the most\n   compact\
    \ encoding of the sequence numbers received.\n    0 1 2 3 4 5 6 7|0 1 2 3 4 5\
    \ 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |      0x50     |          chunkLength          |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   +-------------/-+-------------/-+-------------/-+\n   |   flowID    \\ | \
    \  bufAvail  \\ |    cumAck   \\ |\n   +-------------/-+-------------/-+-------------/-+\n\
    \   +~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+\n   |C|C|C|C|C|C|C|C|C|C|C|C|C|C|C|C|C|C|C|C|C|C|C|C|\n\
    \   |+|+|+|+|+|+|+|+|+|+|+|+|+|+|+|+|+|+|+|+|+|+|+|+|\n   |9|8|7|6|5|4|3|2|1|1|1|1|1|1|1|1|2|2|2|2|2|2|1|1|\
    \ ....\n   | | | | | | | | |7|6|5|4|3|2|1|0|5|4|3|2|1|0|9|8|\n   +~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+\n\
    \   struct dataAckBitmapChunkPayload_t\n   {\n       vlu_t flowID :variable*8;\n\
    \       vlu_t bufferBlocksAvailable :variable*8; // \"bufAvail\"\n       vlu_t\
    \ cumulativeAck :variable*8; // \"cumAck\"\n       bufferBytesAvailable = bufferBlocksAvailable\
    \ * 1024;\n       acknowledge(0 through cumulativeAck);\n       ackCursor = cumulativeAck\
    \ + 1;\n       while(remainder() > 0)\n       {\n           for(bitPosition =\
    \ 8; bitPosition > 0; bitPosition--)\n           {\n               bool_t bit\
    \ :1;\n               if(bit)\n                   acknowledge(ackCursor + bitPosition);\n\
    \           }\n           ackCursor += 8;\n       }\n   } :chunkLength*8;\n  \
    \ flowID:  VLU, the flow identifier.\n   bufferBlocksAvailable:  VLU, the number\
    \ of 1024-byte blocks of User\n      Data that the receiver is currently able\
    \ to accept.\n      Section 3.6.3.5 describes how to calculate this value.\n \
    \  cumulativeAck:  VLU, the acknowledgement of every fragment sequence\n     \
    \ number in this flow that is less than or equal to this value.\n      This MUST\
    \ NOT be less than the highest Forward Sequence Number\n      received in this\
    \ flow.\n   bit field:  A sequence of zero or more bytes representing a bit field\n\
    \      of received fragment sequence numbers after the cumulative\n      acknowledgement,\
    \ least significant bit first.  A set bit indicates\n      receipt of a sequence\
    \ number.  A clear bit indicates that sequence\n      number was not received.\
    \  The least significant bit of the first\n      byte is the second sequence number\
    \ following the cumulative\n      acknowledgement, the next bit is the third sequence\
    \ number\n      following, and so on.\n      Figure 4 shows an example Bitmap\
    \ Ack indicating acknowledgement of\n      fragment sequence numbers 0 through\
    \ 16, 18, 21 through 24, 27,\n      and 28.\n         50 00 05  | Bitmap Ack,\
    \ length=5 bytes\n         05 7f 10  | flowID=5, bufAvail=127*1024 bytes, cumAck=0..16\n\
    \         79 06     | 01111001 00000110 = 18, 21, 22, 23, 24, 27, 28\n       \
    \                Figure 4: Example Bitmap Ack\n"
- title: 2.3.14.  Data Acknowledgement Ranges Chunk (Range Ack)
  contents:
  - "2.3.14.  Data Acknowledgement Ranges Chunk (Range Ack)\n   This chunk is sent\
    \ by the flow receiver to indicate to the flow\n   sender the User Data fragment\
    \ sequence numbers that have been\n   received for one flow.  It is only allowed\
    \ in a packet belonging to\n   an established session and having packet mode 1\
    \ or 2.\n   The flow receiver can choose to acknowledge User Data with this chunk\n\
    \   or with a Bitmap Ack.  It SHOULD choose whichever format has the most\n  \
    \ compact encoding of the sequence numbers received.\n    0 1 2 3 4 5 6 7|0 1\
    \ 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |      0x51     |          chunkLength          |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   +-------------/-+-------------/-+-------------/-+\n   |   flowID    \\ | \
    \  bufAvail  \\ |    cumAck   \\ |\n   +-------------/-+-------------/-+-------------/-+\n\
    \   +~~~~~~~~~~~~~/~+~~~~~~~~~~~~~/~+\n   |   #holes-1  \\ |   #recv-1   \\ |\n\
    \   +~~~~~~~~~~~~~/~+~~~~~~~~~~~~~/~+\n                   :\n                \
    \   :\n   +~~~~~~~~~~~~~/~+~~~~~~~~~~~~~/~+\n   |   #holes-1  \\ |   #recv-1 \
    \  \\ |\n   +~~~~~~~~~~~~~/~+~~~~~~~~~~~~~/~+\n   struct dataAckRangesChunkPayload_t\n\
    \   {\n       vlu_t flowID :variable*8;\n       vlu_t bufferBlocksAvailable :variable*8;\
    \ // \"bufAvail\"\n       vlu_t cumulativeAck :variable*8; // \"cumAck\"\n   \
    \    bufferBytesAvailable = bufferBlocksAvailable * 1024;\n       acknowledge(0\
    \ through cumulativeAck);\n       ackCursor = cumulativeAck;\n       while(remainder()\
    \ > 0)\n       {\n           vlu_t holesMinusOne :variable*8; // \"#holes-1\"\n\
    \           vlu_t receivedMinusOne :variable*8; // \"#recv-1\"\n           ackCursor++;\n\
    \           rangeFrom = ackCursor + holesMinusOne + 1;\n           rangeTo = rangeFrom\
    \ + receivedMinusOne;\n           acknowledge(rangeFrom through rangeTo);\n  \
    \         ackCursor = rangeTo;\n       }\n   } :chunkLength*8;\n   flowID:  VLU,\
    \ the flow identifier.\n   bufferBlocksAvailable:  VLU, the number of 1024-byte\
    \ blocks of User\n      Data that the receiver is currently able to accept.\n\
    \      Section 3.6.3.5 describes how to calculate this value.\n   cumulativeAck:\
    \  VLU, the acknowledgement of every fragment sequence\n      number in this flow\
    \ that is less than or equal to this value.\n      This MUST NOT be less than\
    \ the highest Forward Sequence Number\n      received in this flow.\n   holesMinusOne\
    \ / receivedMinusOne:  Zero or more acknowledgement\n      ranges, run-length\
    \ encoded.  Runs are encoded as zero or more\n      pairs of VLUs indicating the\
    \ number (minus one) of missing\n      sequence numbers followed by the number\
    \ (minus one) of received\n      sequence numbers, starting at the cumulative\
    \ acknowledgement.\n      NOTE: If a parser syntax error is encountered here (that\
    \ is, if\n      the chunk is truncated such that not enough bytes remain to\n\
    \      completely encode both VLUs of the acknowledgement range), then\n     \
    \ treat and process this chunk as though it was properly formed up\n      to the\
    \ last completely encoded range.\n      Figure 5 shows an example Range Ack indicating\
    \ acknowledgement of\n      fragment sequence numbers 0 through 16, 18, 21, 22,\
    \ 23, and 24.\n      51 00 07  | Range Ack, length=7\n      05 7f 10  | flowID=5,\
    \ bufAvail=127*1024 bytes, cumAck=0..16\n      00 00     | holes=1, received=1\
    \ -- missing 17, received 18\n      01 03     | holes=2, received=4 -- missing\
    \ 19..20, received 21..24\n                        Figure 5: Example Range Ack\n\
    \      Figure 6 shows an example Range Ack indicating acknowledgement of\n   \
    \   fragment sequence numbers 0 through 16 and 18, with a truncated\n      last\
    \ range.  Note that the truncation and parse error does not\n      abort the entire\
    \ chunk in this case.\n       51 00 07  | Range Ack, length=9\n       05 7f 10\
    \  | flowID=5, bufAvail=127*1024 bytes, cumAck=0..16\n       00 00     | holes=1,\
    \ received=1 -- missing 17, received 18\n       01 83     | holes=2, received=VLU\
    \ parse error, ignore this range\n                   Figure 6: Example Truncated\
    \ Range Ack\n"
- title: 2.3.15.  Buffer Probe Chunk
  contents:
  - "2.3.15.  Buffer Probe Chunk\n   This chunk is sent by the flow sender in order\
    \ to request the current\n   available receive buffer (in the form of a Data Acknowledgement)\
    \ for\n   a flow.  It is only allowed in a packet belonging to an established\n\
    \   session and having packet mode 1 or 2.\n    0 1 2 3 4 5 6 7|0 1 2 3 4 5 6\
    \ 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |      0x18     |          chunkLength          |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   +-------------/-+\n   |   flowID    \\ |\n   +-------------/-+\n   struct\
    \ bufferProbeChunkPayload_t\n   {\n       vlu_t flowID :variable*8;\n   } :chunkLength*8;\n\
    \   flowID:  VLU, the flow identifier.\n   The receiver of this chunk SHOULD reply\
    \ as immediately as is\n   practical with a Data Acknowledgement.\n"
- title: 2.3.16.  Flow Exception Report Chunk
  contents:
  - "2.3.16.  Flow Exception Report Chunk\n   This chunk is sent by the flow receiver\
    \ to indicate that it is not\n   (or is no longer) interested in the flow and\
    \ would like the flow\n   sender to close the flow.  This chunk SHOULD precede\
    \ every Data\n   Acknowledgement chunk for the same flow in this condition.\n\
    \   This chunk is only allowed in a packet belonging to an established\n   session\
    \ and having packet mode 1 or 2.\n    0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3\
    \ 4 5 6 7|0 1 2 3 4 5 6 7\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |      0x5e     |          chunkLength          |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   +-------------/-+-------------/-+\n   |   flowID    \\ |  exception  \\ |\n\
    \   +-------------/-+-------------/-+\n   struct flowExceptionReportChunkPayload_t\n\
    \   {\n       vlu_t flowID :variable*8;\n       vlu_t exception :variable*8;\n\
    \   } :chunkLength*8;\n   flowID:  VLU, the flow identifier.\n   exception:  VLU,\
    \ the application-defined exception code being\n      reported.\n   A receiving\
    \ RTMFP might reject a flow automatically, for example if\n   it is missing metadata,\
    \ or if an invalid return association is\n   specified.  In circumstances where\
    \ an RTMFP rejects a flow\n   automatically, the exception code MUST be 0.  The\
    \ application can\n   specify any exception code, including 0, when rejecting\
    \ a flow.  All\n   non-zero exception codes are reserved for the application.\n"
- title: 2.3.17.  Session Close Request Chunk (Close)
  contents:
  - "2.3.17.  Session Close Request Chunk (Close)\n   This chunk is sent to cleanly\
    \ terminate a session.  It is only\n   allowed in a packet belonging to an established\
    \ or closing session\n   and having packet mode 1 or 2.\n    0 1 2 3 4 5 6 7|0\
    \ 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |      0x0c     |               0               |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   This chunk has no payload.\n   The use of Close is detailed in Section 3.5.5.\n"
- title: 2.3.18.  Session Close Acknowledgement Chunk (Close Ack)
  contents:
  - "2.3.18.  Session Close Acknowledgement Chunk (Close Ack)\n   This chunk is sent\
    \ in response to a Session Close Request to indicate\n   that the sender has terminated\
    \ the session.  It is only allowed in a\n   packet belonging to an established\
    \ or closing session and having\n   packet mode 1 or 2.\n    0 1 2 3 4 5 6 7|0\
    \ 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |      0x4c     |               0               |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   This chunk has no payload.\n   The use of Close Ack is detailed in Section\
    \ 3.5.5.\n"
- title: 3.  Operation
  contents:
  - '3.  Operation

    '
- title: 3.1.  Overview
  contents:
  - "3.1.  Overview\n              +--------+                             +--------+\n\
    \              | Peer A |        S E S S I O N        | Peer B |\n           \
    \   |        /=============================\\        |\n              |      \
    \ ||            Flows            ||       |\n              |       ||---------------------------->||\
    \       |\n              |       ||---------------------------->||       |\n \
    \             |       ||<----------------------------||       |\n            \
    \  |       ||<----------------------------||       |\n              |       ||<----------------------------||\
    \       |\n              |        \\=============================/        |\n\
    \              |        |                             |        |\n           \
    \   |        |                             +--------+\n              |       \
    \ |\n              |        |                             +--------+\n       \
    \       |        |        S E S S I O N        | Peer C |\n              |   \
    \     /=============================\\        |\n              |       ||    \
    \        Flows            ||       |\n              |       ||---------------------------->||\
    \       |\n              |       ||<----------------------------||       |\n \
    \             |       ||<----------------------------||       |\n            \
    \  |        \\=============================/        |\n              |       \
    \ |                             |        |\n              +--------+         \
    \                    +--------+\n        Figure 7: Sessions between Pairs of Communicating\
    \ Endpoints\n   Between any pair of communicating endpoints is a single,\n   bidirectional,\
    \ secured, congestion controlled session.\n   Unidirectional flows convey messages\
    \ from one end to the other within\n   the session.\n   An endpoint initiates\
    \ a session to a far end when communication is\n   desired.  An initiator begins\
    \ with one or more candidate destination\n   socket addresses, and it may learn\
    \ and try more candidate addresses\n   during startup handshaking.  Eventually,\
    \ a first suitable response is\n   received, and that endpoint is selected.  Startup\
    \ proceeds to the\n   selected endpoint.  In the case of session startup glare,\
    \ one\n   endpoint is the prevailing initiator and the other assumes the role\n\
    \   of responder.  Encryption keys and session identifiers are negotiated\n  \
    \ between the endpoints, and the session is established.\n   Each endpoint may\
    \ begin sending message flows to the other end.  For\n   each flow, the far end\
    \ may accept it and deliver its messages to the\n   user, or it may reject the\
    \ flow and transmit an exception to the\n   sender.  The flow receiver may close\
    \ and reject a flow at a later\n   time, after first accepting it.  The flow receiver\
    \ acknowledges all\n   data sent to it, regardless of whether the flow was accepted.\n\
    \   Acknowledgements drive a congestion control mechanism.\n   An endpoint may\
    \ have concurrent sessions with other far endpoints.\n   The multiple sessions\
    \ are distinguished by a session identifier\n   rather than by socket address.\
    \  This allows an endpoint's address to\n   change mid-session without having\
    \ to tear down and re-establish a\n   session.  The existing cryptographic state\
    \ for a session can be used\n   to verify a change of address while protecting\
    \ against session\n   hijacking or denial of service.\n   A sender may indicate\
    \ to a receiver that some user messages are of a\n   time critical or real-time\
    \ nature.  A receiver may indicate to\n   senders on concurrent sessions that\
    \ it is receiving time critical\n   messages from another endpoint.  The other\
    \ senders SHOULD modify\n   their congestion control parameters to yield capacity\
    \ to the session\n   carrying time critical messages.\n   A sender may close a\
    \ flow.  The flow is completed when the receiver\n   has no outstanding gaps before\
    \ the final fragment of the flow.  The\n   sender and receiver reserve a completed\
    \ flow's identifier for a time\n   to allow in-flight messages to drain from the\
    \ network.\n   Eventually, neither end will have any flows open to the other.\
    \  The\n   session will be idle and quiescent.  Either end may reliably close\n\
    \   the session to recover its resources.\n   In certain circumstances, an endpoint\
    \ may be ceasing operation and\n   not have time to wait for acknowledgement of\
    \ a reliable session\n   close.  In this case, the halting endpoint may send an\
    \ abrupt session\n   close to advise the far end that it is halting immediately.\n"
- title: 3.2.  Endpoint Identity
  contents:
  - "3.2.  Endpoint Identity\n   Each RTMFP endpoint has an identity.  The identity\
    \ is encoded in a\n   certificate.  This specification doesn't mandate any particular\n\
    \   certificate format, cryptographic algorithms, or cryptographic\n   properties\
    \ for certificates.\n   An endpoint is named by an Endpoint Discriminator.  This\n\
    \   specification doesn't mandate any particular format for Endpoint\n   Discriminators.\n\
    \   An Endpoint Discriminator MAY select more than one identity and MAY\n   match\
    \ more than one distinct certificate.\n   Multiple distinct Endpoint Discriminators\
    \ MAY match one certificate.\n   It is RECOMMENDED that multiple endpoints not\
    \ have the same identity.\n   Entities with the same identity are indistinguishable\
    \ during session\n   startup; this situation could be undesirable in some applications.\n\
    \   An endpoint MAY have more than one address.\n   The Cryptography Profile implements\
    \ the following functions for\n   identities, certificates, and Endpoint Discriminators,\
    \ whose\n   operation MUST be deterministic:\n   o  Test whether a given certificate\
    \ is authentic.  Authenticity can\n      comprise verifying an issuer signature\
    \ chain in a public key\n      infrastructure.\n   o  Test whether a given Endpoint\
    \ Discriminator selects a given\n      certificate.\n   o  Test whether a given\
    \ Endpoint Discriminator selects the local\n      endpoint.\n   o  Generate a\
    \ Canonical Endpoint Discriminator for a given\n      certificate.  Canonical\
    \ Endpoint Discriminators for distinct\n      identities SHOULD be distinct. \
    \ If two distinct identities have\n      the same Canonical Endpoint Discriminator,\
    \ an initiator might\n      abort a new opening session to the second identity\n\
    \      (Section 3.5.1.1.1); this behavior might not be desirable.\n   o  Given\
    \ a certificate, a message, and a digital signature over the\n      message, test\
    \ whether the signature is valid and generated by the\n      owner of the certificate.\n\
    \   o  Generate a digital signature for a given message corresponding to\n   \
    \   the near identity.\n   o  Given the near identity and a far certificate, determine\
    \ which one\n      shall prevail as Initiator and which shall assume the Responder\n\
    \      role in the case of startup glare.  The far end MUST arrive at the\n  \
    \    same conclusion.  A comparison function can comprise performing a\n     \
    \ lexicographic ordering of the binary certificates, declaring the\n      far\
    \ identity the prevailing endpoint if the far certificate is\n      ordered before\
    \ the near certificate, and otherwise declaring the\n      near identity to be\
    \ the prevailing endpoint.\n   o  Given a first certificate and a second certificate,\
    \ test whether a\n      new incoming session from the second shall override an\
    \ existing\n      session with the first.  It is RECOMMENDED that the test comprise\n\
    \      testing whether the certificates are bitwise identical.\n   All other semantics\
    \ for certificates and Endpoint Discriminators are\n   determined by the Cryptography\
    \ Profile and the application.\n"
- title: 3.3.  Packet Multiplex
  contents:
  - "3.3.  Packet Multiplex\n   An RTMFP typically has one or more interfaces through\
    \ which it\n   communicates with other RTMFP endpoints.  RTMFP can communicate\
    \ with\n   multiple distinct other RTMFP endpoints through each local interface.\n\
    \   Session multiplexing over a shared interface can facilitate peer-to-\n   peer\
    \ communications through a NAT, by enabling third-party endpoints\n   such as\
    \ Forwarders (Section 3.5.1.5) and Redirectors\n   (Section 3.5.1.4) to observe\
    \ the translated public address and inform\n   peers of the translation.\n   An\
    \ interface is typically a UDP socket (Section 2.2.1) but MAY be any\n   suitable\
    \ datagram transport service where endpoints can be addressed\n   by IPv4 or IPv6\
    \ socket addresses.\n   RTMFP uses a session ID to multiplex and demultiplex communications\n\
    \   with distinct endpoints (Section 2.2.2), in addition to the endpoint\n   socket\
    \ address.  This allows an RTMFP to detect a far-end address\n   change (as might\
    \ happen, for example, in mobile and wireless\n   scenarios) and allows communication\
    \ sessions to survive address\n   changes.  This also allows an RTMFP to act as\
    \ a Forwarder or\n   Redirector for an endpoint with which it has an active session,\
    \ by\n   distinguishing startup packets from those of the active session.\n  \
    \ On receiving a packet, an RTMFP decodes the session ID to look up the\n   corresponding\
    \ session information context and decryption key.\n   Session ID 0 is reserved\
    \ for session startup and MUST NOT be used for\n   an active session.  A packet\
    \ for Session ID 0 uses the Default\n   Session Key as defined by the Cryptography\
    \ Profile.\n"
- title: 3.4.  Packet Fragmentation
  contents:
  - "3.4.  Packet Fragmentation\n   When an RTMFP packet (Section 2.2.4) is unavoidably\
    \ larger than the\n   path MTU (such as a startup packet containing an RHello\n\
    \   (Section 2.3.4) or IIKeying (Section 2.3.7) chunk with a large\n   certificate),\
    \ it can be fragmented into segments that do not exceed\n   the path MTU by using\
    \ the Packet Fragment chunk (Section 2.3.1).\n   The packet fragmentation mechanism\
    \ SHOULD be used only to segment\n   unavoidably large packets.  Accordingly,\
    \ this mechanism SHOULD be\n   employed only during session startup with Session\
    \ ID 0.  This\n   mechanism MUST NOT be used instead of the natural fragmentation\n\
    \   mechanism of the User Data (Section 2.3.11) and Next User Data\n   (Section\
    \ 2.3.12) chunks for dividing the messages of the user's data\n   flows into segments\
    \ that do not exceed the path MTU.\n   A fragmented plain RTMFP packet is reassembled\
    \ by concatenating the\n   packetFragment fields of the fragments for the packet\
    \ in contiguous\n   ascending order, starting from index 0 through and including\
    \ the\n   final fragment.\n   When reassembling packets for Session ID 0, a receiver\
    \ SHOULD\n   identify the packets by the socket address from which the packet\n\
    \   containing the fragment was received, as well as the indicated\n   packetID.\n\
    \   A receiver SHOULD allow up to 60 seconds to completely receive a\n   fragmented\
    \ packet for which progress is being made.  A packet is\n   progressing if at\
    \ least one new fragment for it was received in the\n   last second.\n   A receiver\
    \ MUST discard a Packet Fragment chunk having an empty\n   packetFragment field.\n\
    \   The mode of each packet containing Packet Fragments for the same\n   fragmented\
    \ packet MUST match the mode of the fragmented packet.  A\n   receiver MUST discard\
    \ any new Packet Fragment chunk received in a\n   packet with a mode different\
    \ from the mode of the packet containing\n   the first received fragment.  A receiver\
    \ MUST discard any reassembled\n   packet with a mode different than the packets\
    \ containing its\n   fragments.\n   In order to avoid jamming the network, the\
    \ sender MUST rate limit\n   packet transmission.  In the absence of specific\
    \ path capacity\n   information (for instance, during session startup), a sender\
    \ SHOULD\n   NOT send more than 4380 bytes nor more than four packets per distinct\n\
    \   endpoint every 200 ms.\n   To avoid resource exhaustion, a receiver SHOULD\
    \ limit the number of\n   concurrent packet reassembly buffers and the size of\
    \ each buffer.\n   Limits can depend, for example, on the expected size of reassembled\n\
    \   packets, on the rate at which fragmented packets are expected to be\n   received,\
    \ on the expected degree of interleaving, and on the expected\n   function of\
    \ the receiver.  Limits can depend on the available\n   resources of the receiver.\
    \  There can be different limits for packets\n   with Session ID 0 and packets\
    \ for established sessions.  For example,\n   a busy server might need to allow\
    \ for several hundred concurrent\n   packet reassembly buffers to accommodate\
    \ hundreds of connection\n   requests per second with potentially interleaved\
    \ fragments, but a\n   client device with constrained resources could allow just\
    \ a few\n   reassembly buffers.  In the absence of specific information regarding\n\
    \   the expected size of reassembled packets, a receiver should set the\n   limit\
    \ for each packet reassembly buffer to 65536 bytes.\n"
- title: 3.5.  Sessions
  contents:
  - "3.5.  Sessions\n   A session is the protocol relationship between a pair of\n\
    \   communicating endpoints, comprising the shared and endpoint-specific\n   information\
    \ context necessary to carry out the communication.  The\n   session context at\
    \ each end includes at least:\n   o  TS_RX: the last timestamp received from the\
    \ far end;\n   o  TS_RX_TIME: the time at which TS_RX was first observed to be\n\
    \      different than its previous value;\n   o  TS_ECHO_TX: the last timestamp\
    \ echo sent to the far end;\n   o  MRTO: the measured retransmission timeout;\n\
    \   o  ERTO: the effective retransmission timeout;\n   o  Cryptographic keys for\
    \ encrypting and decrypting packets, and for\n      verifying the validity of\
    \ packets, according to the Cryptography\n      Profile;\n   o  Cryptographic\
    \ near and far nonces according to the Cryptography\n      Profile, where the\
    \ near nonce is the far end's far nonce, and vice\n      versa;\n   o  The certificate\
    \ of the far end;\n   o  The receive session identifier, used by the far end when\
    \ sending\n      packets to this end;\n   o  The send session identifier to use\
    \ when sending packets to the far\n      end;\n   o  DESTADDR: the destination\
    \ socket address to use when sending\n      packets to the far end;\n   o  The\
    \ set of all sending flow contexts (Section 3.6.2);\n   o  The set of all receiving\
    \ flow contexts (Section 3.6.3);\n   o  The transmission budget, which controls\
    \ the rate at which data is\n      sent into the network (for example, a congestion\
    \ window);\n   o  S_OUTSTANDING_BYTES: the total amount of user message data\n\
    \      outstanding, or in flight, in the network -- that is, the sum of\n    \
    \  the F_OUTSTANDING_BYTES of each sending flow in the session;\n   o  RX_DATA_PACKETS:\
    \ a count of the number of received packets\n      containing at least one User\
    \ Data chunk since the last\n      acknowledgement was sent, initially 0;\n  \
    \ o  ACK_NOW: a boolean flag indicating whether an acknowledgement\n      should\
    \ be sent immediately, initially false;\n   o  DELACK_ALARM: an alarm to trigger\
    \ an acknowledgement after a\n      delay, initially unset;\n   o  The state,\
    \ at any time being one of the following values: the\n      opening states S_IHELLO_SENT\
    \ and S_KEYING_SENT, the open state\n      S_OPEN, the closing states S_NEARCLOSE\
    \ and S_FARCLOSE_LINGER, and\n      the closed states S_CLOSED and S_OPEN_FAILED;\
    \ and\n   o  The role -- either Initiator or Responder -- of this end of the\n\
    \      session.\n   Note: The following diagram is only a summary of state transitions\n\
    \   and their causing events, and is not a complete operational\n   specification.\n\
    \          rcv IIKeying Glare\n          far prevails +-------------+   ultimate\
    \ open timeout\n        +--------------|S_IHELLO_SENT|-------------+\n       \
    \ |              +-------------+             |\n        |                    \
    \ |rcv RHello          |\n        |                     |                    v\n\
    \        |                     v             +-------------+\n        |<-----------(duplicate\
    \ session?)   |S_OPEN_FAILED|\n        |         yes         |no           +-------------+\n\
    \        |                     |                    ^\n        | rcv IIKeying\
    \ Glare  v                    |\n        | far prevails +-------------+      \
    \       |\n        |<-------------|S_KEYING_SENT|-------------+\n        |   \
    \           +-------------+   ultimate open timeout\n        |               \
    \      |rcv RIKeying\n        |                     |\n        |       rcv   \
    \        v\n        |   +-+ IIKeying  +--------+ rcv Close Request\n        |\
    \   |X|---------->| S_OPEN |--------------------+\n        |   +-+           +--------+\
    \                    |\n        |                   |    |ABRUPT CLOSE       \
    \   |\n        |      ORDERLY CLOSE|    |or rcv Close Ack      |\n        |  \
    \                 |    |or rcv IIKeying       |\n        |                   |\
    \    |   session override   |\n        |                   |    +-------+    \
    \          |\n        |                   v            |              v\n    \
    \    |             +-----------+      |     +-----------------+\n        |   \
    \          |S_NEARCLOSE|      |     |S_FARCLOSE_LINGER|\n        |           \
    \  +-----------+      |     +-----------------+\n        |      rcv Close Ack|\
    \            |              |rcv Close Ack\n        |      or 90 seconds|    \
    \        v              |or 19 seconds\n        |                   |       +--------+\
    \          |\n        |                   +------>|S_CLOSED|<---------+\n    \
    \    +-------------------------->|        |\n                                \
    \    +--------+\n                      Figure 8: Session State Diagram\n"
- title: 3.5.1.  Startup
  contents:
  - '3.5.1.  Startup

    '
- title: 3.5.1.1.  Normal Handshake
  contents:
  - "3.5.1.1.  Normal Handshake\n   RTMFP sessions are established with a 4-way handshake\
    \ in two round\n   trips.  The initiator begins by sending an IHello to one or\
    \ more\n   candidate addresses for the desired destination endpoint.  A\n   responder\
    \ statelessly sends an RHello in response.  The first correct\n   RHello received\
    \ at the initiator is selected; all others are ignored.\n   The initiator computes\
    \ its half of the session keying and sends an\n   IIKeying.  The responder receives\
    \ the IIKeying and, if it is\n   acceptable, computes its half of the session\
    \ keying, at which point\n   it can also compute the shared session keying and\
    \ session nonces.\n   The responder creates a new S_OPEN session with the initiator\
    \ and\n   sends an RIKeying.  The initiator receives the RIKeying and, if it is\n\
    \   acceptable, computes the shared session keying and session nonces.\n   The\
    \ initiator's session is now S_OPEN.\n        .     Initiator                \
    \                Responder     .\n                      | IHello             \
    \            |\n                      |(EPD,Tag)                       |\n   \
    \     S_IHELLO_SENT |(SID=0)                         |\n                     \
    \ |------------------------------->|\n                      |                \
    \                |\n                      |                         RHello |\n\
    \                      |              (Tag,Cookie,RCert)|\n                  \
    \    |                         (SID=0)|\n                      |<-------------------------------|\n\
    \        S_KEYING_SENT |                                |\n                  \
    \    | IIKeying                       |\n                      |(ISID,Cookie,ICert,SKIC,ISig)\
    \   |\n                      |(SID=0)                         |\n            \
    \          |------------------------------->|\n                      |       \
    \                         |\n                      |                       RIKeying\
    \ |\n                      |                (RSID,SKRC,RSig)|\n              \
    \        |          (SID=ISID,Key=Default)| S_OPEN\n                      |<-------------------------------|\n\
    \               S_OPEN |                                |\n                  \
    \    |          S E S S I O N         |\n                      |<-------------------(SID=ISID)--|\n\
    \                      |--(SID=RSID)------------------->|\n                  \
    \      Figure 9: Normal Handshake\n   In the following sections, the handshake\
    \ is detailed from the\n   perspectives of the initiator and responder.\n"
- title: 3.5.1.1.1.  Initiator
  contents:
  - "3.5.1.1.1.  Initiator\n   The initiator determines that a session is needed for\
    \ an Endpoint\n   Discriminator.  The initiator creates state for a new opening\
    \ session\n   and begins with a candidate endpoint address set containing at least\n\
    \   one address.  The new session is placed in the S_IHELLO_SENT state.\n   If\
    \ the session does not move to the S_OPEN state before an ultimate\n   open timeout,\
    \ the session has failed and moves to the S_OPEN_FAILED\n   state.  The RECOMMENDED\
    \ ultimate open timeout is 95 seconds.\n   The initiator chooses a new, unique\
    \ tag not used by any currently\n   opening session.  It is RECOMMENDED that the\
    \ tag be cryptographically\n   pseudorandom and be at least 8 bytes in length,\
    \ so that it is hard to\n   guess.  The initiator constructs an IHello chunk (Section\
    \ 2.3.2) with\n   the Endpoint Discriminator and the tag.\n   While the initiator\
    \ is in the S_IHELLO_SENT state, it sends the\n   IHello to each candidate endpoint\
    \ address in the set, on a backoff\n   schedule.  The backoff SHOULD NOT be less\
    \ than multiplicative, with\n   not less than 1.5 seconds added to the interval\
    \ between each attempt.\n   The backoff SHOULD be scheduled separately for each\
    \ candidate\n   address, since new candidates can be added over time.\n   If the\
    \ initiator receives a Redirect chunk (Section 2.3.5) with a tag\n   echo matching\
    \ this session, AND this session is in the S_IHELLO_SENT\n   state, then for each\
    \ redirect destination indicated in the Redirect:\n   if the candidate endpoint\
    \ address set contains fewer than\n   REDIRECT_THRESHOLD addresses, add the indicated\
    \ redirect destination\n   to the candidate endpoint address set.  REDIRECT_THRESHOLD\
    \ SHOULD NOT\n   be more than 24.\n   If the initiator receives an RHello chunk\
    \ (Section 2.3.4) with a tag\n   echo matching this session, AND this session\
    \ is in the S_IHELLO_SENT\n   state, AND the responder certificate matches the\
    \ desired Endpoint\n   Discriminator, AND the certificate is authentic according\
    \ to the\n   Cryptography Profile, then:\n   1.  If the Canonical Endpoint Discriminator\
    \ for the responder\n       certificate matches the Canonical Endpoint Discriminator\
    \ of\n       another existing session in the S_KEYING_SENT or S_OPEN states,\n\
    \       AND the certificate of the other opening session matches the\n       desired\
    \ Endpoint Discriminator, then this session is a duplicate\n       and SHOULD\
    \ be aborted in favor of the other existing session;\n       otherwise,\n   2.\
    \  Move to the S_KEYING_SENT state.  Set DESTADDR, the far-end\n       address\
    \ for the session, to the address from which this RHello\n       was received.\
    \  The initiator chooses a new, unique receive\n       session ID, not used by\
    \ any other session, for the responder to\n       use when sending packets to\
    \ the initiator.  It computes a Session\n       Key Initiator Component appropriate\
    \ to the responder's\n       certificate according to the Cryptography Profile.\
    \  Using this\n       data and the cookie from the RHello, the initiator constructs\
    \ and\n       signs an IIKeying chunk (Section 2.3.7).\n   While the initiator\
    \ is in the S_KEYING_SENT state, it sends the\n   IIKeying to DESTADDR on a backoff\
    \ schedule.  The backoff SHOULD NOT\n   be less than multiplicative, with not\
    \ less than 1.5 seconds added to\n   the interval between each attempt.\n   If\
    \ the initiator receives an RIKeying chunk (Section 2.3.8) in a\n   packet with\
    \ this session's receive session identifier, AND this\n   session is in the S_KEYING_SENT\
    \ state, AND the signature in the chunk\n   is authentic according to the far\
    \ end's certificate (from the\n   RHello), AND the Session Key Responder Component\
    \ successfully\n   combines with the Session Key Initiator Component and the near\
    \ and\n   far certificates to form the shared session keys and nonces according\n\
    \   to the Cryptography Profile, then the session has opened\n   successfully.\
    \  The session moves to the S_OPEN state.  The send\n   session identifier is\
    \ set from the RIKeying.  Packet encryption,\n   decryption, and verification\
    \ now use the newly computed shared\n   session keys, and the session nonces are\
    \ available for application-\n   layer cryptographic challenges.\n"
- title: 3.5.1.1.2.  Responder
  contents:
  - "3.5.1.1.2.  Responder\n   On receipt of an IHello chunk (Section 2.3.2) with\
    \ an Endpoint\n   Discriminator that selects its identity, an endpoint SHOULD\
    \ construct\n   an RHello chunk (Section 2.3.4) and send it to the address from\
    \ which\n   the IHello was received.  To avoid a potential resource exhaustion\n\
    \   denial of service, the endpoint SHOULD NOT create any persistent\n   state\
    \ associated with the IHello.  The endpoint MUST generate the\n   cookie for the\
    \ RHello in such a way that it can be recognized as\n   authentic and valid when\
    \ echoed in an IIKeying.  The endpoint SHOULD\n   use the address from which the\
    \ IHello was received as part of the\n   cookie generation formula.  Cookies SHOULD\
    \ be valid only for a\n   limited time; that lifetime SHOULD NOT be less than\
    \ 95 seconds (the\n   recommended ultimate session open timeout).\n   On receipt\
    \ of an FIHello chunk (Section 2.3.3) from a Forwarder\n   (Section 3.5.1.5) where\
    \ the Endpoint Discriminator selects its\n   identity, an endpoint SHOULD do one\
    \ of the following:\n   1.  Compute, construct, and send an RHello as though the\
    \ FIHello was\n       an IHello received from the indicated reply address; or\n\
    \   2.  Construct and send an Implied Redirect (Section 2.3.5) to the\n      \
    \ FIHello's reply address; or\n   3.  Ignore this FIHello.\n   On receipt of an\
    \ IIKeying chunk (Section 2.3.7), if the cookie is not\n   authentic or if it\
    \ has expired, ignore this IIKeying; otherwise,\n   On receipt of an IIKeying\
    \ chunk, if the cookie appears authentic but\n   does not match the address from\
    \ which the IIKeying's packet was\n   received, perform the special processing\
    \ at Cookie Change\n   (Section 3.5.1.2); otherwise,\n   On receipt of an IIKeying\
    \ with an authentic and valid cookie, if the\n   certificate is authentic according\
    \ to the Cryptography Profile, AND\n   the signature in the chunk is authentic\
    \ according to the far end's\n   certificate and the Cryptography Profile, AND\
    \ the Session Key\n   Initiator Component is acceptable, then:\n   1.  If the\
    \ address from which this IIKeying was received corresponds\n       to an opening\
    \ session in the S_IHELLO_SENT or S_KEYING_SENT\n       state, perform the special\
    \ processing at Glare (Section 3.5.1.3);\n       otherwise,\n   2.  If the address\
    \ from which this IIKeying was received corresponds\n       to a session in the\
    \ S_OPEN state, then:\n       1.  If the receiver was the Responder for the S_OPEN\
    \ session and\n           the session identifier, certificate, and Session Key\n\
    \           Initiator Component are identical to those of the S_OPEN\n       \
    \    session, this IIKeying is a retransmission, so resend the\n           S_OPEN\
    \ session's RIKeying using the Default Session Key as\n           specified below;\
    \ otherwise,\n       2.  If the certificate from this IIKeying does not override\
    \ the\n           certificate of the S_OPEN session, ignore this IIKeying;\n \
    \          otherwise,\n       3.  The certificate from this IIKeying overrides\
    \ the certificate\n           of the S_OPEN session; this is a new opening session\
    \ from the\n           same identity, and the existing S_OPEN session is stale.\n\
    \           Move the existing S_OPEN session to S_CLOSED and abort all of\n  \
    \         its flows (signaling exceptions to the user), then continue\n      \
    \     processing this IIKeying.\n       Otherwise,\n   3.  Compute a Session Key\
    \ Responder Component and choose a new,\n       unique receive session ID not\
    \ used by any other session for the\n       initiator to use when sending packets\
    \ to the responder.  Using\n       this data, construct and, with the Session\
    \ Key Initiator\n       Component, sign an RIKeying chunk (Section 2.3.8).  Using\
    \ the\n       Session Key Initiator and Responder Components and the near and\n\
    \       far certificates, the responder combines and computes the shared\n   \
    \    session keys and nonces according to the Cryptography Profile.\n       The\
    \ responder creates a new session in the S_OPEN state, with the\n       far-endpoint\
    \ address DESTADDR taken from the source address of\n       the packet containing\
    \ the IIKeying and the send session\n       identifier taken from the IIKeying.\
    \  The responder sends the\n       RIKeying to the initiator using the Default\
    \ Session Key and the\n       requested send session identifier.  Packet encryption,\n\
    \       decryption, and verification of all future packets for this\n       session\
    \ use the newly computed keys, and the session nonces are\n       available for\
    \ application-layer cryptographic challenges.\n"
- title: 3.5.1.2.  Cookie Change
  contents:
  - "3.5.1.2.  Cookie Change\n   In some circumstances, the responder may generate\
    \ an RHello cookie\n   for an initiator's address that isn't the address the initiator\
    \ would\n   use when sending packets directly to the responder.  This can happen,\n\
    \   for example, when the initiator has multiple local addresses and uses\n  \
    \ one address to reach a Forwarder (Section 3.5.1.5) but another to\n   reach\
    \ the responder.\n   Consider the following example:\n   Initiator           \
    \         Forwarder                     Responder\n   | IHello               \
    \          |                                 |\n   |(Src=Ix)                 \
    \       |                                 |\n   |------------------------------->|\
    \                                 |\n   |                                | FIHello\
    \                         |\n   |                                |(RA=Ix)    \
    \                      |\n   |                                |-------------------------------->|\n\
    \   |                                                                  |\n   |\
    \                                                           RHello |\n   |   \
    \                                                    (Cookie:Ix)|\n   |<-----------------------------------------------------------------|\n\
    \   |                                                                  |\n   |\
    \ IIKeying                                                         |\n   |(Cookie:Ix,Src=Iy)\
    \                                                |\n   |----------------------------------------------------------------->|\n\
    \   |                                                                  |\n   |\
    \                                             RHello Cookie Change |\n   |   \
    \                                          (Cookie:Ix,Cookie:Iy)|\n   |<-----------------------------------------------------------------|\n\
    \   |                                                                  |\n   |\
    \ IIKeying                                                         |\n   |(Cookie:Iy)\
    \                                                       |\n   |----------------------------------------------------------------->|\n\
    \   |                                                                  |\n   |\
    \                                                         RIKeying |\n   |<-----------------------------------------------------------------|\n\
    \   |                                                                  |\n   |<========================\
    \ S E S S I O N =========================>|\n                  Figure 10: Handshake\
    \ with Cookie Change\n   The initiator has two network interfaces: a first preferred\
    \ interface\n   with address Ix = 192.0.2.100:50000, and a second with address\
    \ Iy =\n   198.51.100.101:50001.  The responder has one interface with address\n\
    \   Ry = 198.51.100.200:51000, on the same network as the initiator's\n   second\
    \ interface.  The initiator uses its first interface to reach a\n   Forwarder.\
    \  The Forwarder observes the initiator's address of Ix and\n   sends a Forwarded\
    \ IHello (Section 2.3.3) to the responder.  The\n   responder treats this as if\
    \ it were an IHello from Ix, calculates a\n   corresponding cookie, and sends\
    \ an RHello to Ix.  The initiator\n   receives this RHello from Ry and selects\
    \ that address as the\n   destination for the session.  It then sends an IIKeying,\
    \ copying the\n   cookie from the RHello.  However, since the source of the RHello\
    \ is\n   Ry, on a network to which the initiator is directly connected, the\n\
    \   initiator uses its second interface Iy to send the IIKeying.  The\n   responder,\
    \ on receiving the IIKeying, will compare the cookie to the\n   expected value\
    \ based on the source address of the packet, and since\n   the IIKeying source\
    \ doesn't match the IHello source used to generate\n   the cookie, the responder\
    \ will reject the IIKeying.\n   If the responder determines that it generated\
    \ the cookie in the\n   IIKeying but the cookie doesn't match the sender's address\
    \ (for\n   example, if the cookie is in two parts, with a first part generated\n\
    \   independently of the initiator's address and a second part dependent\n   on\
    \ the address), the responder SHOULD generate a new cookie based on\n   the address\
    \ from which the IIKeying was received and send an RHello\n   Cookie Change chunk\
    \ (Section 2.3.6) to the source of the IIKeying,\n   using the session ID from\
    \ the IIKeying and the Default Session Key.\n   If the initiator receives an RHello\
    \ Cookie Change chunk for a session\n   in the S_KEYING_SENT state, AND the old\
    \ cookie matches the one\n   originally sent to the responder, then the initiator\
    \ adopts the new\n   cookie, constructs and signs a new IIKeying chunk, and sends\
    \ the new\n   IIKeying to the responder.  The initiator SHOULD NOT change the\n\
    \   cookie for a session more than once.\n"
- title: 3.5.1.3.  Glare
  contents:
  - "3.5.1.3.  Glare\n   Glare occurs when two endpoints attempt to initiate sessions\
    \ to each\n   other concurrently.  Glare is detected by receipt of a valid and\n\
    \   authentic IIKeying from an endpoint address that is a destination for\n  \
    \ an opening session.  Only one session is allowed between a pair of\n   endpoints.\n\
    \   Glare is resolved by comparing the certificate in the received\n   IIKeying\
    \ with the near end's certificate.  The Cryptography Profile\n   defines a certificate\
    \ comparison function to determine the prevailing\n   endpoint when there is glare.\n\
    \   If the near end prevails, discard and ignore the received IIKeying.\n   The\
    \ far end will abort its opening session on receipt of IIKeying\n   from the near\
    \ end.\n   Otherwise, the far end prevails:\n   1.  If the certificate in the\
    \ IIKeying overrides the certificate\n       associated with the near opening\
    \ session according to the\n       Cryptography Profile, then abort and destroy\
    \ the near opening\n       session.  Then,\n   2.  Continue with normal Responder\
    \ IIKeying processing\n       (Section 3.5.1.1.2).\n"
- title: 3.5.1.4.  Redirector
  contents:
  - "3.5.1.4.  Redirector\n        +-----------+           +------------+        \
    \  +-----------+\n        | Initiator |---------->| Redirector |          | Responder\
    \ |\n        |           |<----------|            |          |           |\n \
    \       |           |           +------------+          |           |\n      \
    \  |           |<=================================>|           |\n        +-----------+\
    \                                   +-----------+\n                          \
    \ Figure 11: Redirector\n   A Redirector acts like a name server for Endpoint\
    \ Discriminators.\n   An initiator MAY use a Redirector to discover additional\
    \ candidate\n   endpoint addresses for a desired endpoint.\n   On receipt of an\
    \ IHello chunk with an Endpoint Discriminator that\n   does not select the Redirector's\
    \ identity, the Redirector constructs\n   and sends back to the initiator a Responder\
    \ Redirect chunk\n   (Section 2.3.5) containing one or more additional candidate\
    \ addresses\n   for the indicated endpoint.\n   Initiator                   Redirector\
    \                     Responder\n   | IHello                         |       \
    \                          |\n   |------------------------------->|          \
    \                       |\n   |                                |             \
    \                    |\n   |                       Redirect |                \
    \                 |\n   |<-------------------------------|                   \
    \              |\n   |                                                       \
    \           |\n   | IHello                                                   \
    \        |\n   |----------------------------------------------------------------->|\n\
    \   |                                                                  |\n   |\
    \                                                           RHello |\n   |<-----------------------------------------------------------------|\n\
    \   |                                                                  |\n   |\
    \ IIKeying                                                         |\n   |----------------------------------------------------------------->|\n\
    \   |                                                                  |\n   |\
    \                                                         RIKeying |\n   |<-----------------------------------------------------------------|\n\
    \   |                                                                  |\n   |<========================\
    \ S E S S I O N =========================>|\n                  Figure 12: Handshake\
    \ Using a Redirector\n   Deployment Design Note: Redirectors SHOULD NOT initiate\
    \ new sessions\n   to endpoints that might use the Redirector's address as a candidate\n\
    \   for another endpoint, since the far end might interpret the\n   Redirector's\
    \ IIKeying as glare for the far end's initiation to the\n   other endpoint.\n"
- title: 3.5.1.5.  Forwarder
  contents:
  - "3.5.1.5.  Forwarder\n         +-----------+     +-----------+     +---+     +-----------+\n\
    \         | Initiator |---->| Forwarder |<===>| N |<===>| Responder |\n      \
    \   |           |     +-----------+     | A |     |           |\n         |  \
    \         |<=====================>| T |<===>|           |\n         +-----------+\
    \                       +---+     +-----------+\n                           Figure\
    \ 13: Forwarder\n   A responder might be behind a NAT or firewall that doesn't\
    \ allow\n   inbound packets to reach the endpoint until it first sends an\n  \
    \ outbound packet for a particular far-endpoint address.\n   A Forwarder's endpoint\
    \ address MAY be a candidate address for another\n   endpoint.  A responder MAY\
    \ use a Forwarder to receive FIHello chunks\n   sent on behalf of an initiator.\n\
    \   On receipt of an IHello chunk with an Endpoint Discriminator that\n   does\
    \ not select the Forwarder's identity, if the Forwarder has an\n   S_OPEN session\
    \ with an endpoint whose certificate matches the desired\n   Endpoint Discriminator,\
    \ the Forwarder constructs and sends an FIHello\n   chunk (Section 2.3.3) to the\
    \ selected endpoint over the S_OPEN\n   session, using the tag and Endpoint Discriminator\
    \ from the IHello\n   chunk and the source address of the packet containing the\
    \ IHello for\n   the corresponding fields of the FIHello.\n   On receipt of an\
    \ FIHello chunk, a responder might send an RHello or\n   Implied Redirect to the\
    \ original source of the IHello\n   (Section 3.5.1.1.2), potentially allowing\
    \ future packets to flow\n   directly between the initiator and responder through\
    \ the NAT or\n   firewall.\n   Initiator                    Forwarder        \
    \   NAT       Responder\n   | IHello                         |               \
    \ |                |\n   |------------------------------->|                | \
    \               |\n   |                                | FIHello        |    \
    \            |\n   |                                |--------------->|--------------->|\n\
    \   |                                                 |                |\n   |\
    \                                                 |         RHello |\n   |   \
    \                                              :<---------------|\n   |<------------------------------------------------:\
    \                |\n   |                                                 :   \
    \             |\n   | IIKeying                                        :      \
    \          |\n   |-------------------------------------------------:--------------->|\n\
    \   |                                                 :                |\n   |\
    \                                                 :       RIKeying |\n   |   \
    \                                              :<---------------|\n   |<------------------------------------------------:\
    \                |\n   |                                                 :   \
    \             |\n   |<======================== S E S S I O N ========>:<==============>|\n\
    \      Figure 14: Forwarder Handshake where Responder Sends an RHello\n   Initiator\
    \                    Forwarder           NAT       Responder\n   | IHello    \
    \                     |                |                |\n   |------------------------------->|\
    \                |                |\n   |                                | FIHello\
    \        |                |\n   |                                |--------------->|--------------->|\n\
    \   |                                                 |                |\n   |\
    \                                                 |       Redirect |\n   |   \
    \                                              | (Implied,RD={})|\n   |      \
    \                                           :<---------------|\n   |<------------------------------------------------:\
    \                |\n   |                                                 :   \
    \             |\n   | IHello                                          :      \
    \          |\n   |------------------------------------------------>:--------------->|\n\
    \   |                                                 :                |\n   |\
    \                                                 :         RHello |\n   |   \
    \                                              :<---------------|\n   |<------------------------------------------------:\
    \                |\n   |                                                 :   \
    \             |\n   | IIKeying                                        :      \
    \          |\n   |------------------------------------------------>:--------------->|\n\
    \   |                                                 :                |\n   |\
    \                                                 :       RIKeying |\n   |   \
    \                                              :<---------------|\n   |<------------------------------------------------:\
    \                |\n   |                                                 :   \
    \             |\n   |<======================== S E S S I O N ========>:<==============>|\n\
    \          Figure 15: Forwarder Handshake where Responder Sends an\n         \
    \                    Implied Redirect\n"
- title: 3.5.1.6.  Redirector and Forwarder with NAT
  contents:
  - "3.5.1.6.  Redirector and Forwarder with NAT\n             +---+       +---+ \
    \      +---+      +---+      +---+\n             | I |       | N |       | I |\
    \      | N |      | R |\n             | n |------>| A |------>| n |      | A |\
    \      | e |\n             | i |       | T |       | t |<====>| T |<====>| s |\n\
    \             | t |<------|   |<------| r |      |   |      | p |\n          \
    \   | i |       |   |       | o |      |   |      | o |\n             | a |  \
    \     |   |       +---+      |   |      | n |\n             | t |       |   |\
    \                  |   |      | d |\n             | o |<=====>|   |<================>|\
    \   |<====>| e |\n             | r |       |   |                  |   |      |\
    \ r |\n             +---+       +---+                  +---+      +---+\n    \
    \    Figure 16: Introduction Service for Initiator and Responder\n           \
    \                     behind NATs\n   An initiator and responder might each be\
    \ behind distinct NATs or\n   firewalls that don't allow inbound packets to reach\
    \ the respective\n   endpoints until each first sends an outbound packet for a\
    \ particular\n   far-endpoint address.\n   An introduction service comprising\
    \ Redirector and Forwarder functions\n   may facilitate direct communication between\
    \ endpoints each behind\n   a NAT.\n   The responder is registered with the introduction\
    \ service via an\n   S_OPEN session to it.  The service observes and records the\n\
    \   responder's public NAT address as the DESTADDR of the S_OPEN session.\n  \
    \ The service MAY record other addresses for the responder, for example\n   addresses\
    \ that the responder self-reports as being directly attached.\n   The initiator\
    \ begins with an address of the introduction service as\n   an initial candidate.\
    \  The Redirector portion of the service sends to\n   the initiator a Responder\
    \ Redirect containing at least the\n   responder's public NAT address as previously\
    \ recorded.  The Forwarder\n   portion of the service sends to the responder a\
    \ Forwarded IHello\n   containing the initiator's public NAT address as observed\
    \ to be the\n   source of the IHello.\n   The responder sends an RHello to the\
    \ initiator's public NAT address\n   in response to the FIHello.  This will allow\
    \ inbound packets to the\n   responder through its NAT from the initiator's public\
    \ NAT address.\n   The initiator sends an IHello to the responder's public NAT\
    \ address\n   in response to the Responder Redirect.  This will allow inbound\n\
    \   packets to the initiator through its NAT from the responder's public\n   NAT\
    \ address.\n   With transit paths created in both NATs, normal session startup\
    \ can\n   proceed.\n   Initiator     NAT-I    Redirector+Forwarder     NAT-R \
    \     Responder\n   |               |                |                |      \
    \          |\n   | IHello        |                |                |         \
    \       |\n   |(Dst=Intro)    |                |                |            \
    \    |\n   |-------------->|                |                |               \
    \ |\n   |               |--------------->|                |                |\n\
    \   |               |                | FIHello        |                |\n   |\
    \               |                |(RA=NAT-I-Pub)  |                |\n   |   \
    \            |                |--------------->|--------------->|\n   |      \
    \         |       Redirect |                |                |\n   |         \
    \      | (RD={NAT-R-Pub,|                |                |\n   |            \
    \   |           ...})|                |                |\n   |<--------------|<---------------|\
    \                |                |\n   |               |                    \
    \             |         RHello |\n   |               |                       \
    \          | (Dst=NAT-I-Pub)|\n   |               |                          \
    \       :<---------------|\n   |               | (*)  <--------------------------:\
    \                |\n   | IHello        |                                 :   \
    \             |\n   |(Dst=NAT-R-Pub)|                                 :      \
    \          |\n   |-------------->:                                 :         \
    \       |\n   |               :-------------------------------->:--------------->|\n\
    \   |               :                                 :                |\n   |\
    \               :                                 :         RHello |\n   |   \
    \            :                                 :<---------------|\n   |<--------------:<--------------------------------:\
    \                |\n   |               :                                 :   \
    \             |\n   | IIKeying      :                                 :      \
    \          |\n   |-------------->:                                 :         \
    \       |\n   |               :-------------------------------->:--------------->|\n\
    \   |               :                                 :                |\n   |\
    \               :                                 :       RIKeying |\n   |   \
    \            :                                 :<---------------|\n   |<--------------:<--------------------------------:\
    \                |\n   |               :                                 :   \
    \             |\n   |<=============>:<======== S E S S I O N ========>:<==============>|\n\
    \            Figure 17: Handshake with Redirector and Forwarder\n   At the point\
    \ in Figure 17 marked (*), the responder's RHello from the\n   FIHello might arrive\
    \ at the initiator's NAT before or after the\n   initiator's IHello is sent outbound\
    \ to the responder's public NAT\n   address.  If it arrives before, it may be\
    \ dropped by the NAT.  If it\n   arrives after, it will transit the NAT and trigger\
    \ keying without\n   waiting for another round-trip time.  The timing of this\
    \ race\n   depends, among other factors, on the relative distances of the\n  \
    \ initiator and responder from each other and from the introduction\n   service.\n"
- title: 3.5.1.7.  Load Distribution and Fault Tolerance
  contents:
  - "3.5.1.7.  Load Distribution and Fault Tolerance\n             +---+    IHello/RHello\
    \    +-------------+\n             | I |<------------------->| Responder 1 |\n\
    \             | n |                     +-------------+\n             | i |  SESSION\
    \  +-------------+\n             | t |<=========>| Responder 2 |\n           \
    \  | i |           +-------------+\n             | a |   IHello...           \
    \      +----------------+\n             | t |-------------------------> X | Dead\
    \ Responder |\n             | o |                             +----------------+\n\
    \             | r |  IHello/RHello   +-------------+\n             |   |<---------------->|\
    \ Responder N |\n             +---+                  +-------------+\n       \
    \       Figure 18: Parallel Open to Multiple Endpoints\n   As specified in Section\
    \ 3.2, more than one endpoint is allowed to be\n   selected by one Endpoint Discriminator.\
    \  This will typically be the\n   case for a set of servers, any of which could\
    \ accommodate a\n   connecting client.\n   As specified in Section 3.5.1.1.1,\
    \ an initiator is allowed to use\n   multiple candidate endpoint addresses when\
    \ starting a session, and\n   the sender of the first acceptable RHello chunk\
    \ to be received is\n   selected to complete the session, with later responses\
    \ ignored.  An\n   initiator can start with the multiple candidate endpoint addresses,\n\
    \   or it may learn them during startup from one or more Redirectors\n   (Section\
    \ 3.5.1.4).\n   Parallel open to multiple endpoints for the same Endpoint\n  \
    \ Discriminator, combined with selection by earliest RHello, can be\n   used for\
    \ load distribution and fault tolerance.  The cost at each\n   endpoint that is\
    \ not selected is limited to receiving and processing\n   an IHello, and generating\
    \ and sending an RHello.\n   In one circumstance, multiple servers of similar\
    \ processing and\n   networking capacity may be located in near proximity to each\
    \ other,\n   such as in a data center.  In this circumstance, a less heavily\n\
    \   loaded server can respond to an IHello more quickly than more heavily\n  \
    \ loaded servers and will tend to be selected by a client.\n   In another circumstance,\
    \ multiple servers may be located in different\n   physical locations, such as\
    \ different data centers.  In this\n   circumstance, a server that is located\
    \ nearer (in terms of network\n   distance) to the client can respond earlier\
    \ than more distant servers\n   and will tend to be selected by the client.\n\
    \   Multiple servers, in proximity or distant from one another, can form\n   a\
    \ redundant pool of servers.  A client can perform a parallel open to\n   the\
    \ multiple servers.  In normal operation, the multiple servers will\n   all respond,\
    \ and the client will select one of them as described\n   above.  If one of the\
    \ multiple servers fails, other servers in the\n   pool can still respond to the\
    \ client, allowing the client to succeed\n   to an S_OPEN session with one of\
    \ them.\n"
- title: 3.5.2.  Congestion Control
  contents:
  - "3.5.2.  Congestion Control\n   An RTMFP MUST implement congestion control and\
    \ avoidance algorithms\n   that are \"TCP compatible\", in accordance with Internet\
    \ best current\n   practice [RFC2914].  The algorithms SHOULD NOT be more aggressive\
    \ in\n   sending data than those described in \"TCP Congestion Control\"\n   [RFC5681]\
    \ and MUST NOT be more aggressive in sending data than the\n   \"slow start algorithm\"\
    \ described in Section 3.1 of RFC 5681.\n   An endpoint maintains a transmission\
    \ budget in the session\n   information context of each S_OPEN session (Section\
    \ 3.5), controlling\n   the rate at which the endpoint sends data into the network.\n\
    \   For window-based congestion control and avoidance algorithms, the\n   transmission\
    \ budget is the congestion window, which is the amount of\n   user data that is\
    \ allowed to be outstanding, or in flight, in the\n   network.  Transmission is\
    \ allowed when S_OUTSTANDING_BYTES\n   (Section 3.5) is less than the congestion\
    \ window (Section 3.6.2.3).\n   See Appendix A for an experimental window-based\
    \ congestion control\n   algorithm for real-time and bulk data.\n   An endpoint\
    \ avoids sending large bursts of data or packets into the\n   network (Section\
    \ 3.5.2.3).\n   A sending endpoint increases and decreases its transmission budget\
    \ in\n   response to acknowledgements (Section 3.6.2.4) and loss according to\n\
    \   the congestion control and avoidance algorithms.  Loss is detected by\n  \
    \ negative acknowledgement (Section 3.6.2.5) and timeout\n   (Section 3.6.2.6).\n\
    \   Timeout is determined by the Effective Retransmission Timeout (ERTO)\n   (Section\
    \ 3.5.2.2).  The ERTO is measured using the Timestamp and\n   Timestamp Echo packet\
    \ header fields (Section 2.2.4).\n   A receiving endpoint acknowledges all received\
    \ data (Section 3.6.3.4)\n   to enable the sender to measure receipt of data,\
    \ or lack thereof.\n   A receiving endpoint may be receiving time critical (or\
    \ real-time)\n   data from a first sender while receiving data from other senders.\n\
    \   The receiving endpoint can signal its other senders (Section 2.2.4)\n   to\
    \ cause them to decrease the aggressiveness of their congestion\n   control and\
    \ avoidance algorithms, in order to yield network capacity\n   to the time critical\
    \ data (Section 3.5.2.1).\n"
- title: 3.5.2.1.  Time Critical Reverse Notification
  contents:
  - "3.5.2.1.  Time Critical Reverse Notification\n   A sender can increase its transmission\
    \ budget at a rate compatible\n   with (but not exceeding) the \"slow start algorithm\"\
    \ specified in\n   RFC 5681 (with which the transmission rate is doubled every\
    \ round\n   trip when beginning or restarting transmission, until loss is\n  \
    \ detected).  However, a sender MUST behave as though the slow start\n   threshold\
    \ SSTHRESH is clamped to 0 (disabling the slow start\n   algorithm's exponential\
    \ increase behavior) on a session where a Time\n   Critical Reverse Notification\
    \ (Section 2.2.4) indication has been\n   received from the far end within the\
    \ last 800 milliseconds, unless\n   the sender is itself currently sending time\
    \ critical data to the\n   far end.\n   During each round trip, a sender SHOULD\
    \ NOT increase the transmission\n   budget by more than 0.5% or by 384 bytes per\
    \ round trip (whichever is\n   greater) on a session where a Time Critical Reverse\
    \ Notification\n   indication has been received from the far end within the last\
    \ 800\n   milliseconds, unless the sender is itself currently sending time\n \
    \  critical data to the far end.\n"
- title: 3.5.2.2.  Retransmission Timeout
  contents:
  - "3.5.2.2.  Retransmission Timeout\n   RTMFP uses the ERTO to detect when a user\
    \ data fragment has been lost\n   in the network.  The ERTO is typically calculated\
    \ in a manner similar\n   to that specified in \"Requirements for Internet Hosts\
    \ - Communication\n   Layers\" [RFC1122] and is a function of round-trip time\
    \ measurements\n   and persistent timeout behavior.\n   The ERTO SHOULD be at\
    \ least 250 milliseconds and SHOULD allow for the\n   receiver to delay sending\
    \ an acknowledgement for up to 200\n   milliseconds (Section 3.6.3.4.4).  The\
    \ ERTO MUST NOT be less than the\n   round-trip time.\n   To facilitate round-trip\
    \ time measurement, an endpoint MUST implement\n   the Timestamp Echo facility:\n\
    \   o  On a session entering the S_OPEN state, initialize TS_RX_TIME to\n    \
    \  negative infinity, and initialize TS_RX and TS_ECHO_TX to have no\n      value.\n\
    \   o  On receipt of a packet in an S_OPEN session with the\n      timestampPresent\
    \ (Section 2.2.4) flag set, if the timestamp field\n      in the packet is different\
    \ than TS_RX, set TS_RX to the value of\n      the timestamp field in the packet,\
    \ and set TS_RX_TIME to the\n      current time.\n   o  When sending a packet\
    \ to the far end in an S_OPEN session:\n      1.  Calculate TS_RX_ELAPSED = current\
    \ time - TS_RX_TIME.  If\n          TS_RX_ELAPSED is more than 128 seconds, then\
    \ set TS_RX and\n          TS_ECHO_TX to have no value, and do not include a timestamp\n\
    \          echo; otherwise,\n      2.  Calculate TS_RX_ELAPSED_TICKS to be the\
    \ number of whole\n          4-millisecond periods in TS_RX_ELAPSED; then\n  \
    \    3.  Calculate TS_ECHO = (TS_RX + TS_RX_ELAPSED_TICKS) MODULO\n          65536;\
    \ then\n      4.  If TS_ECHO is not equal to TS_ECHO_TX, then set TS_ECHO_TX to\n\
    \          TS_ECHO, set the timestampEchoPresent flag, and set the\n         \
    \ timestampEcho field to TS_ECHO_TX.\n   The remainder of this section describes\
    \ an OPTIONAL method for\n   calculating the ERTO.  Real-time applications and\
    \ P2P mesh\n   applications often require knowing the round-trip time and RTT\n\
    \   variance.  This section additionally describes a method for measuring\n  \
    \ the round-trip time and RTT variance, and calculating a smoothed\n   round-trip\
    \ time.\n   Let the session information context contain additional variables:\n\
    \   o  TS_TX: the last timestamp sent to the far end, initialized to have\n  \
    \    no value;\n   o  TS_ECHO_RX: the last timestamp echo received from the far\
    \ end,\n      initialized to have no value;\n   o  SRTT: the smoothed round-trip\
    \ time, initialized to have no value;\n   o  RTTVAR: the round-trip time variance,\
    \ initialized to 0.\n   Initialize MRTO to 250 milliseconds.\n   Initialize ERTO\
    \ to 3 seconds.\n   On sending a packet to the far end of an S_OPEN session, if\
    \ the\n   current send timestamp is not equal to TS_TX, then set TS_TX to the\n\
    \   current send timestamp, set the timestampPresent flag in the packet\n   header,\
    \ and set the timestamp field to TS_TX.\n   On receipt of a packet from the far\
    \ end of an S_OPEN session, if the\n   timestampEchoPresent flag is set in the\
    \ packet header, AND the\n   timestampEcho field is not equal to TS_ECHO_RX, then:\n\
    \   1.  Set TS_ECHO_RX to timestampEcho;\n   2.  Calculate RTT_TICKS = (current\
    \ send timestamp - timestampEcho)\n       MODULO 65536;\n   3.  If RTT_TICKS is\
    \ greater than 32767, the measurement is invalid,\n       so discard this measurement;\
    \ otherwise,\n   4.  Calculate RTT = RTT_TICKS * 4 milliseconds;\n   5.  If SRTT\
    \ has a value, then calculate new values of RTTVAR\n       and SRTT:\n       1.\
    \  RTT_DELTA = | SRTT - RTT |;\n       2.  RTTVAR = ((3 * RTTVAR) + RTT_DELTA)\
    \ / 4;\n       3.  SRTT = ((7 * SRTT) + RTT) / 8.\n   6.  If SRTT has no value,\
    \ then set SRTT = RTT and RTTVAR = RTT / 2;\n   7.  Set MRTO = SRTT + 4 * RTTVAR\
    \ + 200 milliseconds;\n   8.  Set ERTO to MRTO or 250 milliseconds, whichever\
    \ is greater.\n   A retransmission timeout occurs when the most recently transmitted\n\
    \   user data fragment has remained outstanding in the network for ERTO.\n   When\
    \ this timeout occurs, increase ERTO on an exponential backoff\n   with an ultimate\
    \ backoff cap of 10 seconds:\n   1.  Calculate ERTO_BACKOFF = ERTO * 1.4142;\n\
    \   2.  Calculate ERTO_CAPPED to be ERTO_BACKOFF or 10 seconds, whichever\n  \
    \     is less;\n   3.  Set ERTO to ERTO_CAPPED or MRTO, whichever is greater.\n"
- title: 3.5.2.3.  Burst Avoidance
  contents:
  - "3.5.2.3.  Burst Avoidance\n   An application's sending patterns may cause the\
    \ transmission budget\n   to grow to a large value, but at times its sending patterns\
    \ will\n   result in a comparatively small amount of data outstanding in the\n\
    \   network.  In this circumstance, especially with a window-based\n   congestion\
    \ avoidance algorithm, if the application then has a large\n   amount of new data\
    \ to send (for example, a new bulk data transfer),\n   it could send data into\
    \ the network all at once to fill the window.\n   This kind of transmission burst\
    \ is undesirable, however, because it\n   can jam interfaces, links, and buffers.\n\
    \   Accordingly, in any session, an endpoint SHOULD NOT send more than\n   six\
    \ packets containing user data between receiving any\n   acknowledgements or retransmission\
    \ timeouts.\n   The following describes an OPTIONAL method to avoid bursting large\n\
    \   numbers of packets into the network:\n   Let the session information context\
    \ contain an additional variable\n   DATA_PACKET_COUNT, initialized to 0.\n  \
    \ Transmission of a user data fragment on this session is not allowed\n   if DATA_PACKET_COUNT\
    \ is greater than or equal to 6, regardless of any\n   other allowance of the\
    \ congestion control algorithm.\n   On transmission of a packet containing at\
    \ least one User Data chunk\n   (Section 2.3.11), set DATA_PACKET_COUNT = DATA_PACKET_COUNT\
    \ + 1.\n   On receipt of an acknowledgement chunk (Sections 2.3.13 and 2.3.14),\n\
    \   set DATA_PACKET_COUNT to 0.\n   On a retransmission timeout, set DATA_PACKET_COUNT\
    \ to 0.\n"
- title: 3.5.3.  Address Mobility
  contents:
  - "3.5.3.  Address Mobility\n   Sessions are demultiplexed with a 32-bit session\
    \ ID, rather than by\n   endpoint address.  This allows an endpoint's address\
    \ to change during\n   an S_OPEN session.  This can happen, for example, when\
    \ switching from\n   a wireless to a wired network, or when moving from one wireless\
    \ base\n   station to another, or when a NAT restarts.\n   If the near end receives\
    \ a valid packet for an S_OPEN session from a\n   source address that doesn't\
    \ match DESTADDR, the far end might have\n   changed addresses.  The near end\
    \ SHOULD verify that the far end is\n   definitively at the new address before\
    \ changing DESTADDR.  A\n   suggested verification method is described in Section\
    \ 3.5.4.2.\n"
- title: 3.5.4.  Ping
  contents:
  - "3.5.4.  Ping\n   If an endpoint receives a Ping chunk (Section 2.3.9) in a session\
    \ in\n   the S_OPEN state, it SHOULD construct and send a Ping Reply chunk\n \
    \  (Section 2.3.10) in response if possible, copying the message\n   unaltered.\
    \  The Ping Reply SHOULD be sent as quickly as possible\n   following receipt\
    \ of a Ping.  The semantics of a Ping's message is\n   reserved for the sender;\
    \ a receiver SHOULD NOT interpret the Ping's\n   message.\n   Endpoints can use\
    \ the mechanism of the Ping chunk and the expected\n   Ping Reply for any purpose.\
    \  This specification doesn't mandate any\n   specific constraints on the format\
    \ or semantics of a Ping message.  A\n   Ping Reply MUST be sent only as a response\
    \ to a Ping.\n   Receipt of a Ping Reply implies live bidirectional connectivity.\n\
    \   This specification doesn't mandate any other semantics for a\n   Ping Reply.\n"
- title: 3.5.4.1.  Keepalive
  contents:
  - "3.5.4.1.  Keepalive\n   An endpoint can use a Ping to test for live bidirectional\n\
    \   connectivity, to test that the far end of a session is still in the\n   S_OPEN\
    \ state, to keep NAT translations alive, and to keep firewall\n   holes open.\n\
    \   An endpoint can use a Ping to hasten detection of a near-end address\n   change\
    \ by the far end.\n   An endpoint may declare a session to be defunct and dead\
    \ after a\n   persistent failure by the far end to return Ping Replies in response\n\
    \   to Pings.\n   If used for these purposes, a Keepalive Ping SHOULD have an\
    \ empty\n   message.\n   A Keepalive Ping SHOULD NOT be sent more often than once\
    \ per ERTO.\n   If a corresponding Ping Reply is not received within ERTO of sending\n\
    \   the Ping, ERTO SHOULD be increased according to Section 3.5.2\n   (\"Congestion\
    \ Control\").\n"
- title: 3.5.4.2.  Address Mobility
  contents:
  - "3.5.4.2.  Address Mobility\n   This section describes an OPTIONAL but suggested\
    \ method for\n   processing and verifying a far-end address change.\n   Let the\
    \ session context contain additional variables MOB_TX_TS,\n   MOB_RX_TS, and MOB_SECRET.\
    \  MOB_TX_TS and MOB_RX_TS have initial\n   values of negative infinity.  MOB_SECRET\
    \ should be a\n   cryptographically pseudorandom value not less than 128 bits\
    \ in length\n   and known only to this end.\n   On receipt of a packet for an\
    \ S_OPEN session, after processing all\n   chunks in the packet: if the session\
    \ is still in the S_OPEN state,\n   AND the source address of the packet does\
    \ not match DESTADDR, AND\n   MOB_TX_TS is at least one second in the past, then:\n\
    \   1.  Set MOB_TX_TS to the current time;\n   2.  Construct a Ping message comprising\
    \ the following: a marking to\n       indicate (to this end when returned in a\
    \ Ping Reply) that it is a\n       mobility check (for example, the first byte\
    \ being ASCII 'M' for\n       \"Mobility\"), a timestamp set to MOB_TX_TS, and\
    \ a cryptographic\n       hash over the following: the preceding items, the address\
    \ from\n       which the packet was received, and MOB_SECRET; and\n   3.  Send\
    \ this Ping to the address from which the packet was received,\n       instead\
    \ of DESTADDR.\n   On receipt of a Ping Reply in an S_OPEN session, if the Ping\
    \ Reply's\n   message satisfies all of these conditions:\n   o  it has this end's\
    \ expected marking to indicate that it is a\n      mobility check, and\n   o \
    \ the timestamp in the message is not more than 120 seconds in the\n      past,\
    \ and\n   o  the timestamp in the message is greater than MOB_RX_TS, and\n   o\
    \  the cryptographic hash matches the expected value according to the\n      contents\
    \ of the message plus the source address of the packet\n      containing this\
    \ Ping Reply and MOB_SECRET,\n   then:\n   1.  Set MOB_RX_TS to the timestamp\
    \ in the message; and\n   2.  Set DESTADDR to the source address of the packet\
    \ containing this\n       Ping Reply.\n"
- title: 3.5.4.3.  Path MTU Discovery
  contents:
  - "3.5.4.3.  Path MTU Discovery\n   \"Packetization Layer Path MTU Discovery\" [RFC4821]\
    \ describes a method\n   for measuring the path MTU between communicating endpoints.\n\
    \   An RTMFP SHOULD perform path MTU discovery.\n   The method described in RFC\
    \ 4821 can be adapted for use in RTMFP by\n   sending a probe packet comprising\
    \ one of the Padding chunk types\n   (type 0x00 or 0xff) and a Ping.  The Ping\
    \ chunk SHOULD come after the\n   Padding chunk, to guard against a false positive\
    \ response in case the\n   probe packet is truncated.\n"
- title: 3.5.5.  Close
  contents:
  - "3.5.5.  Close\n   An endpoint may close a session at any time.  Typically, an\
    \ endpoint\n   will close a session when there have been no open flows in either\n\
    \   direction for a time.  In another circumstance, an endpoint may be\n   ceasing\
    \ operation and will close all of its sessions even if they\n   have open flows.\n\
    \   To close an S_OPEN session in a reliable and orderly fashion, an\n   endpoint\
    \ moves the session to the S_NEARCLOSE state.\n   On a session transitioning from\
    \ S_OPEN to S_NEARCLOSE and every\n   5 seconds thereafter while still in the\
    \ S_NEARCLOSE state, send a\n   Session Close Request chunk (Section 2.3.17).\n\
    \   A session that has been in the S_NEARCLOSE state for at least\n   90 seconds\
    \ (allowing time to retransmit the Session Close Request\n   multiple times) SHOULD\
    \ move to the S_CLOSED state.\n   On a session transitioning from S_OPEN to the\
    \ S_NEARCLOSE,\n   S_FARCLOSE_LINGER or S_CLOSED state, immediately abort and\
    \ terminate\n   all open or closing flows.  Flows only exist in S_OPEN sessions.\n\
    \   To close an S_OPEN session abruptly, send a Session Close\n   Acknowledgement\
    \ chunk (Section 2.3.18), then move to the S_CLOSED\n   state.\n   On receipt\
    \ of a Session Close Request chunk for a session in the\n   S_OPEN, S_NEARCLOSE,\
    \ or S_FARCLOSE_LINGER states, send a Session\n   Close Acknowledgement chunk;\
    \ then, if the session is in the S_OPEN\n   state, move to the S_FARCLOSE_LINGER\
    \ state.\n   A session that has been in the S_FARCLOSE_LINGER state for at least\n\
    \   19 seconds (allowing time to answer 3 retransmissions of a Session\n   Close\
    \ Request) SHOULD move to the S_CLOSED state.\n   On receipt of a Session Close\
    \ Acknowledgement chunk for a session in\n   the S_OPEN, S_NEARCLOSE, or S_FARCLOSE_LINGER\
    \ states, move to the\n   S_CLOSED state.\n"
- title: 3.6.  Flows
  contents:
  - "3.6.  Flows\n   A flow is a unidirectional communication channel in a session\
    \ for\n   transporting a correlated series of user messages from a sender to a\n\
    \   receiver.  Each end of a session may have zero or more sending flows\n   to\
    \ the other end.  Each sending flow at one end has a corresponding\n   receiving\
    \ flow at the other end.\n"
- title: 3.6.1.  Overview
  contents:
  - '3.6.1.  Overview

    '
- title: 3.6.1.1.  Identity
  contents:
  - "3.6.1.1.  Identity\n   Flows are multiplexed in a session by a flow identifier.\
    \  Each end of\n   a session chooses its sending flow identifiers independently\
    \ of the\n   other end.  The choice of similar flow identifiers by both ends does\n\
    \   not imply an association.  A sender MAY choose any identifier for any\n  \
    \ flow; therefore, a flow receiver MUST NOT ascribe any semantic\n   meaning,\
    \ role, or name to a flow based only on its identifier.  There\n   are no \"well\
    \ known\" or reserved flow identifiers.\n   Bidirectional flow association is\
    \ indicated at flow startup with the\n   Return Flow Association option (Section\
    \ 2.3.11.1.2).  An endpoint can\n   indicate that a new sending flow is in return\
    \ (or response) to a\n   receiving flow from the other end.  A sending flow MUST\
    \ NOT indicate\n   more than one return association.  A receiving flow can be\
    \ specified\n   as the return association for any number of sending flows.  The\n\
    \   return flow association, if any, is fixed for the lifetime of the\n   sending\
    \ flow.  Note: Closure of one flow in an association does not\n   automatically\
    \ close other flows in the association, except as\n   specified in Section 3.6.3.1.\n\
    \   Flows are named with arbitrary user metadata.  This specification\n   doesn't\
    \ mandate any particular encoding, syntax, or semantics for the\n   user metadata,\
    \ except for the encoded size (Section 2.3.11.1.1); the\n   user metadata is entirely\
    \ reserved for the application.  The user\n   metadata is fixed for the lifetime\
    \ of the flow.\n"
- title: 3.6.1.2.  Messages and Sequencing
  contents:
  - "3.6.1.2.  Messages and Sequencing\n   Flows provide message-oriented framing.\
    \  Large messages are\n   fragmented for transport in the network.  Receivers\
    \ reassemble\n   fragmented messages and only present complete messages to the\
    \ user.\n   A sender queues messages on a sending flow one after another.  A\n\
    \   receiver can recover the original queuing order of the messages, even\n  \
    \ when they are reordered in transit by the network or as a result of\n   loss\
    \ and retransmission, by means of the messages' fragment sequence\n   numbers.\
    \  Flows are the basic units of message sequencing; each flow\n   is sequenced\
    \ independently of all other flows; inter-flow message\n   arrival and delivery\
    \ sequencing are not guaranteed.\n   Independent flow sequencing allows a sender\
    \ to prioritize the\n   transmission or retransmission of the messages of one\
    \ flow over those\n   of other flows in a session, allocating capacity from the\n\
    \   transmission budget according to priority.  RTMFP is designed for\n   flows\
    \ to be the basic unit of prioritization.  In any flow, fragment\n   sequence\
    \ numbers are unique and monotonically increasing; that is,\n   the fragment sequence\
    \ numbers for any message MUST be greater than\n   the fragment sequence numbers\
    \ of all messages previously queued in\n   that flow.  Receipt of fragments out\
    \ of sequence number order within\n   a flow creates discontiguous gaps at the\
    \ receiver, causing it to send\n   an acknowledgement for every packet and also\
    \ causing the size of the\n   encoded acknowledgements to grow.  Therefore, for\
    \ any flow, the\n   sender SHOULD send lower sequence numbers first.\n   A sender\
    \ can abandon a queued message at any time, even if some\n   fragments of that\
    \ message have been received by the other end.  A\n   receiver MUST be able to\
    \ detect a gap in the flow when a message is\n   abandoned; therefore, each message\
    \ SHOULD take at least one sequence\n   number from the sequence space even if\
    \ no fragments for that message\n   are ever sent.  The sender will transmit the\
    \ fragments of all\n   messages not abandoned, and retransmit any lost fragments\
    \ of all\n   messages not abandoned, until all the fragments of all messages not\n\
    \   abandoned are acknowledged by the receiver.  A sender indicates a\n   Forward\
    \ Sequence Number (FSN) to instruct the receiver that sequence\n   numbers less\
    \ than or equal to the FSN will not be transmitted or\n   retransmitted.  This\
    \ allows the receiver to move forward over gaps\n   and continue sequenced delivery\
    \ of completely received messages to\n   the user.  Any incomplete messages missing\
    \ fragments with sequence\n   numbers less than or equal to the FSN were abandoned\
    \ by the sender\n   and will never be completed.  A gap indication MUST be communicated\n\
    \   to the receiving user.\n"
- title: 3.6.1.3.  Lifetime
  contents:
  - "3.6.1.3.  Lifetime\n   A sender begins a flow by sending user message fragments\
    \ to the other\n   end, and including the user metadata and, if any, the return\
    \ flow\n   association.  The sender continues to include the user metadata and\n\
    \   return flow association until the flow is acknowledged by the far\n   end,\
    \ at which point the sender knows that the receiver has received\n   the user\
    \ metadata and, if any, the return flow association.  After\n   that point, the\
    \ flow identifier alone is sufficient.\n   Flow receivers SHOULD acknowledge all\
    \ sequence numbers received for\n   any flow, whether the flow is accepted or\
    \ rejected.  Flow receivers\n   MUST NOT acknowledge sequence numbers higher than\
    \ the FSN that were\n   not received.  Acknowledgements drive the congestion control\
    \ and\n   avoidance algorithms and therefore must be accurate.\n   An endpoint\
    \ can reject a receiving flow at any time in the flow's\n   lifetime.  To reject\
    \ the flow, the receiving endpoint sends a Flow\n   Exception Report chunk (Section\
    \ 2.3.16) immediately preceding every\n   acknowledgement chunk for the rejected\
    \ receiving flow.\n   An endpoint may eventually conclude and close a sending\
    \ flow.  The\n   last sequence number of the flow is marked with the Final flag.\
    \  The\n   sending flow is complete when all sequence numbers of the flow,\n \
    \  including the final sequence number, have been cumulatively\n   acknowledged\
    \ by the receiver.  The receiving flow is complete when\n   every sequence number\
    \ from the FSN to the final sequence number has\n   been received.  The sending\
    \ flow and corresponding receiving flow at\n   the respective ends hold the flow\
    \ identifier of a completed flow in\n   reserve for a time to allow delayed or\
    \ duplicated fragments and\n   acknowledgements to drain from the network without\
    \ erroneously\n   initiating a new receiving flow or erroneously acknowledging\
    \ a new\n   sending flow.\n   If a flow sender receives a Flow Exception indication\
    \ from the other\n   end, the flow sender SHOULD close the flow and abandon all\
    \ of the\n   undelivered queued messages.  The flow sender SHOULD indicate an\n\
    \   exception to the user.\n"
- title: 3.6.2.  Sender
  contents:
  - "3.6.2.  Sender\n   Each sending flow comprises the flow-specific information\
    \ context\n   necessary to transfer that flow's messages to the other end.  Each\n\
    \   sending flow context includes at least:\n   o  F_FLOW_ID: this flow's identifier;\n\
    \   o  STARTUP_OPTIONS: the set of options to send to the receiver until\n   \
    \   this flow is acknowledged, including the User's Per-Flow Metadata\n      and,\
    \ if set, the Return Flow Association;\n   o  SEND_QUEUE: the unacknowledged message\
    \ fragments queued in this\n      flow, initially empty; each message fragment\
    \ entry comprising the\n      following:\n      *  SEQUENCE_NUMBER: the sequence\
    \ number of this fragment;\n      *  DATA: this fragment's user data;\n      *\
    \  FRA: the fragment control value for this message fragment,\n         having\
    \ one of the values enumerated for that purpose in\n         Section 2.3.11 (\"\
    User Data Chunk\");\n      *  ABANDONED: a boolean flag indicating whether this\
    \ fragment has\n         been abandoned;\n      *  SENT_ABANDONED: a boolean flag\
    \ indicating whether this fragment\n         was abandoned when sent;\n      *\
    \  EVER_SENT: a boolean flag indicating whether this fragment has\n         been\
    \ sent at least once, initially false;\n      *  NAK_COUNT: a count of the number\
    \ of negative acknowledgements\n         detected for this fragment, initially\
    \ 0;\n      *  IN_FLIGHT: a boolean flag indicating whether this fragment is\n\
    \         currently outstanding, or in flight, in the network, initially\n   \
    \      false;\n      *  TRANSMIT_SIZE: the size, in bytes, of the encoded User\
    \ Data\n         chunk (including the chunk header) for this fragment when it\n\
    \         was transmitted into the network.\n   o  F_OUTSTANDING_BYTES: the sum\
    \ of the TRANSMIT_SIZE of each entry in\n      SEND_QUEUE where entry.IN_FLIGHT\
    \ is true;\n   o  RX_BUFFER_SIZE: the most recent available buffer advertisement\n\
    \      from the other end (Sections 2.3.13 and 2.3.14), initially\n      65536\
    \ bytes;\n   o  NEXT_SN: the next sequence number to assign to a message fragment,\n\
    \      initially 1;\n   o  F_FINAL_SN: the sequence number assigned to the final\
    \ message\n      fragment of the flow, initially having no value;\n   o  EXCEPTION:\
    \ a boolean flag indicating whether an exception has been\n      reported by the\
    \ receiver, initially false;\n   o  The state, at any time being one of the following\
    \ values: the open\n      state F_OPEN; the closing states F_CLOSING and F_COMPLETE_LINGER;\n\
    \      and the closed state F_CLOSED.\n   Note: The following diagram is only\
    \ a summary of state transitions\n   and their causing events, and is not a complete\
    \ operational\n   specification.\n                                 +--------+\n\
    \                                 | F_OPEN |\n                               \
    \  +--------+\n                                      |CLOSE or\n             \
    \                         |rcv Flow Exception\n                              \
    \        |\n                                      v\n                        \
    \         +---------+\n                                 |F_CLOSING|\n        \
    \                         +---------+\n                                      |rcv\
    \ Data Ack\n                                      |  0..F_FINAL_SN\n         \
    \                             v\n                             +-----------------+\n\
    \                             |F_COMPLETE_LINGER|\n                          \
    \   +-----------------+\n                                      | 130 seconds\n\
    \                                      v\n                                  +--------+\n\
    \                                  |F_CLOSED|\n                              \
    \    +--------+\n                   Figure 19: Sending Flow State Diagram\n"
- title: 3.6.2.1.  Startup
  contents:
  - "3.6.2.1.  Startup\n   The application opens a new sending flow to the other end\
    \ in an\n   S_OPEN session.  The implementation chooses a new flow ID that is\
    \ not\n   assigned to any other sending flow in that session in the F_OPEN,\n\
    \   F_CLOSING, or F_COMPLETE_LINGER states.  The flow starts in the\n   F_OPEN\
    \ state.  The STARTUP_OPTIONS for the new flow is set with the\n   User's Per-Flow\
    \ Metadata (Section 2.3.11.1.1).  If this flow is in\n   return (or response)\
    \ to a receiving flow from the other end, that\n   flow's ID is encoded in a Return\
    \ Flow Association\n   (Section 2.3.11.1.2) option and added to STARTUP_OPTIONS.\
    \  A new\n   sending flow SHOULD NOT be opened in response to a receiving flow\n\
    \   from the other end that is not in the RF_OPEN state when the sending\n   flow\
    \ is opened.\n   At this point, the flow exists in the sender but not in the receiver.\n\
    \   The flow begins when user data fragments are transmitted to the\n   receiver.\
    \  A sender can begin a flow in the absence of immediate user\n   data by sending\
    \ a Forward Sequence Number Update (Section 3.6.2.7.1),\n   by queuing and transmitting\
    \ a user data fragment that is already\n   abandoned.\n"
- title: 3.6.2.2.  Queuing Data
  contents:
  - "3.6.2.2.  Queuing Data\n   The application queues messages in an F_OPEN sending\
    \ flow for\n   transmission to the far end.  The implementation divides each message\n\
    \   into one or more fragments for transmission in User Data chunks\n   (Section\
    \ 2.3.11).  Each fragment MUST be small enough so that, if\n   assembled into\
    \ a packet (Section 2.2.4) with a maximum-size common\n   header, User Data chunk\
    \ header, and, if not empty, this flow's\n   STARTUP_OPTIONS, the packet will\
    \ not exceed the path MTU\n   (Section 3.5.4.3).\n   For each fragment, create\
    \ a fragment entry and set\n   fragmentEntry.SEQUENCE_NUMBER to flow.NEXT_SN,\
    \ and increment\n   flow.NEXT_SN by one.  Set fragmentEntry.FRA according to the\
    \ encoding\n   in User Data chunks:\n   0: This fragment is a complete message.\n\
    \   1: This fragment is the first of a multi-fragment message.\n   2: This fragment\
    \ is the last of a multi-fragment message.\n   3: This fragment is in the middle\
    \ of a multi-fragment message.\n   Append fragmentEntry to flow.SEND_QUEUE.\n"
- title: 3.6.2.3.  Sending Data
  contents:
  - "3.6.2.3.  Sending Data\n   A sending flow is ready to transmit if the SEND_QUEUE\
    \ contains at\n   least one entry that is eligible to send, and if either\n  \
    \ RX_BUFFER_SIZE is greater than F_OUTSTANDING_BYTES or EXCEPTION is\n   set to\
    \ true.\n   A SEND_QUEUE entry is eligible to send if it is not IN_FLIGHT, AND\
    \ at\n   least one of the following conditions holds:\n   o  The entry is not\
    \ ABANDONED; or\n   o  The entry is the first one in the SEND_QUEUE; or\n   o\
    \  The entry's SEQUENCE_NUMBER is equal to flow.F_FINAL_SN.\n   If the session's\
    \ transmission budget allows, a flow that is ready to\n   transmit is selected\
    \ for transmission according to the\n   implementation's prioritization scheme.\
    \  The manner of flow\n   prioritization is not mandated by this specification.\n\
    \   Trim abandoned messages from the front of the queue, and find the\n   Forward\
    \ Sequence Number (FSN):\n   1.  While the SEND_QUEUE contains at least two entries,\
    \ AND the first\n       entry is not IN_FLIGHT, AND the first entry is ABANDONED,\
    \ remove\n       and discard the first entry from the SEND_QUEUE;\n   2.  If the\
    \ first entry in the SEND_QUEUE is not abandoned, set FSN to\n       entry.SEQUENCE_NUMBER\
    \ - 1; otherwise,\n   3.  If the first entry in the SEND_QUEUE is IN_FLIGHT, AND\n\
    \       entry.SENT_ABANDONED is false, set FSN to\n       entry.SEQUENCE_NUMBER\
    \ - 1; otherwise,\n   4.  The first entry in the SEND_QUEUE is abandoned and either\
    \ is not\n       IN_FLIGHT or was already abandoned when sent; set FSN to\n  \
    \     entry.SEQUENCE_NUMBER.\n   The FSN MUST NOT be greater than any sequence\
    \ number currently\n   outstanding.  The FSN MUST NOT be equal to any sequence\
    \ number\n   currently outstanding that was not abandoned when sent.\n   Assemble\
    \ user data chunks for this flow into a packet to send to the\n   receiver.  While\
    \ enough space remains in the packet and the flow is\n   ready to transmit:\n\
    \   1.   Starting at the head of the SEND_QUEUE, find the first eligible\n   \
    \     fragment entry;\n   2.   Encode the entry into a User Data chunk (Section\
    \ 2.3.11) or, if\n        possible (Section 3.6.2.3.2), a Next User Data chunk\n\
    \        (Section 2.3.12);\n   3.   If present, set chunk.flowID to flow.F_FLOW_ID;\n\
    \   4.   If present, set chunk.sequenceNumber to entry.SEQUENCE_NUMBER;\n   5.\
    \   If present, set chunk.fsnOffset to entry.SEQUENCE_NUMBER - FSN;\n   6.   Set\
    \ chunk.fragmentControl to entry.FRA;\n   7.   Set chunk.abandon to entry.ABANDONED;\n\
    \   8.   If entry.SEQUENCE_NUMBER equals flow.F_FINAL_SN, set chunk.final\n  \
    \      to true; else set chunk.final to false;\n   9.   If any options are being\
    \ sent with this chunk, set\n        chunk.optionsPresent to true, assemble the\
    \ options into the\n        chunk, and assemble a Marker to terminate the option\
    \ list;\n   10.  If entry.ABANDONED is true, set chunk.userData to empty;\n  \
    \      otherwise, set chunk.userData to entry.DATA;\n   11.  If adding the assembled\
    \ chunk to the packet would cause the\n        packet to exceed the path MTU,\
    \ do not assemble this chunk into\n        the packet; enough space no longer\
    \ remains in the packet; stop.\n        Otherwise, continue:\n   12.  Set entry.IN_FLIGHT\
    \ to true;\n   13.  Set entry.EVER_SENT to true;\n   14.  Set entry.NAK_COUNT\
    \ to 0;\n   15.  Set entry.SENT_ABANDONED to entry.ABANDONED;\n   16.  Set entry.TRANSMIT_SIZE\
    \ to the size of the assembled chunk,\n        including the chunk header;\n \
    \  17.  Assemble this chunk into the packet; and\n   18.  If this flow or entry\
    \ is considered Time Critical (real-time),\n        set the timeCritical flag\
    \ in the packet header (Section 2.2.4).\n   Complete any other appropriate packet\
    \ processing, and transmit the\n   packet to the far end.\n"
- title: 3.6.2.3.1.  Startup Options
  contents:
  - "3.6.2.3.1.  Startup Options\n   If STARTUP_OPTIONS is not empty, then when assembling\
    \ the FIRST User\n   Data chunk for this flow into a packet, add the encoded\n\
    \   STARTUP_OPTIONS to that chunk's option list.\n"
- title: 3.6.2.3.2.  Send Next Data
  contents:
  - "3.6.2.3.2.  Send Next Data\n   The Next User Data chunk (Section 2.3.12) is a\
    \ compact encoding for a\n   user message fragment when multiple contiguous fragments\
    \ are\n   assembled into one packet.  Using this chunk where possible can\n  \
    \ conserve space in a packet, potentially reducing transmission\n   overhead or\
    \ allowing additional information to be sent in a packet.\n   If, after assembling\
    \ a user message fragment of a flow into a packet\n   (Section 3.6.2.3), the next\
    \ eligible fragment to be selected for\n   assembly into that packet belongs to\
    \ the same flow, AND its sequence\n   number is one greater than that of the fragment\
    \ just assembled, it is\n   RECOMMENDED that an implementation encode a Next User\
    \ Data chunk\n   instead of a User Data chunk.\n   The FIRST fragment of a flow\
    \ assembled into a packet MUST be encoded\n   as a User Data chunk.\n"
- title: 3.6.2.4.  Processing Acknowledgements
  contents:
  - "3.6.2.4.  Processing Acknowledgements\n   A Data Acknowledgement Bitmap chunk\
    \ (Section 2.3.13) or a Data\n   Acknowledgement Ranges chunk (Section 2.3.14)\
    \ encodes the\n   acknowledgement of receipt of one or more sequence numbers of\
    \ a flow,\n   as well as the receiver's current receive window advertisement.\n\
    \   On receipt of an acknowledgement chunk for a sending flow:\n   1.  Set PRE_ACK_OUTSTANDING_BYTES\
    \ to flow.F_OUTSTANDING_BYTES;\n   2.  Set flow.STARTUP_OPTIONS to empty;\n  \
    \ 3.  Set flow.RX_BUFFER_SIZE to chunk.bufferBytesAvailable;\n   4.  For each\
    \ sequence number encoded in the acknowledgement, if\n       there is an entry\
    \ in flow.SEND_QUEUE with that sequence number\n       and its IN_FLIGHT is true,\
    \ then remove the entry from\n       flow.SEND_QUEUE; and\n   5.  Notify the congestion\
    \ control and avoidance algorithms that\n       PRE_ACK_OUTSTANDING_BYTES - flow.F_OUTSTANDING_BYTES\
    \ were\n       acknowledged.  Note that negative acknowledgements\n       (Section\
    \ 3.6.2.5) affect \"TCP friendly\" congestion control.\n"
- title: 3.6.2.5.  Negative Acknowledgement and Loss
  contents:
  - "3.6.2.5.  Negative Acknowledgement and Loss\n   A negative acknowledgement is\
    \ inferred for an outstanding fragment if\n   an acknowledgement is received for\
    \ any other fragments sent after it\n   in the same session.\n   An implementation\
    \ SHOULD consider a fragment to be lost once that\n   fragment receives three\
    \ negative acknowledgements.  A lost fragment\n   is no longer outstanding in\
    \ the network.\n   The following describes an OPTIONAL method for detecting negative\n\
    \   acknowledgements.\n   Let the session track the order in which fragments are\
    \ transmitted\n   across all its sending flows by way of a monotonically increasing\n\
    \   Transmission Sequence Number (TSN) recorded with each fragment queue\n   entry\
    \ each time that fragment is transmitted.\n   Let the session information context\
    \ contain additional variables:\n   o  NEXT_TSN: the next TSN to record with a\
    \ fragment's queue entry\n      when it is transmitted, initially 1;\n   o  MAX_TSN_ACK:\
    \ the highest acknowledged TSN, initially 0.\n   Let each fragment queue entry\
    \ contain an additional variable TSN,\n   initially 0, to track its transmission\
    \ order.\n   On transmission of a message fragment into the network, set its\n\
    \   entry.TSN to session.NEXT_TSN, and increment session.NEXT_TSN.\n   On acknowledgement\
    \ of an outstanding fragment, if its entry.TSN is\n   greater than session.MAX_TSN_ACK,\
    \ set session.MAX_TSN_ACK to\n   entry.TSN.\n   After processing all acknowledgements\
    \ in a packet containing at least\n   one acknowledgement, then for each sending\
    \ flow in that session, for\n   each entry in that flow's SEND_QUEUE, if entry.IN_FLIGHT\
    \ is true and\n   entry.TSN is less than session.MAX_TSN_ACK, increment entry.NAK_COUNT\n\
    \   and notify the congestion control and avoidance algorithms that a\n   negative\
    \ acknowledgement was detected in this packet.\n   For each sending flow in that\
    \ session, for each entry in that flow's\n   SEND_QUEUE, if entry.IN_FLIGHT is\
    \ true and entry.NAK_COUNT is at\n   least 3, that fragment was lost in the network\
    \ and is no longer\n   considered to be in flight.  Set entry.IN_FLIGHT to false.\
    \  Notify\n   the congestion control and avoidance algorithms of the loss.\n"
- title: 3.6.2.6.  Timeout
  contents:
  - "3.6.2.6.  Timeout\n   A fragment is considered lost and no longer in flight in\
    \ the network\n   if it has remained outstanding for at least ERTO.\n   The following\
    \ describes an OPTIONAL method to manage transmission\n   timeouts.  This method\
    \ REQUIRES that either burst avoidance\n   (Section 3.5.2.3) is implemented or\
    \ the implementation's congestion\n   control and avoidance algorithms will eventually\
    \ stop sending new\n   fragments into the network if acknowledgements are persistently\
    \ not\n   received.\n   Let the session information context contain an alarm TIMEOUT_ALARM,\n\
    \   initially unset.\n   On sending a packet containing at least one User Data\
    \ chunk, set or\n   reset TIMEOUT_ALARM to fire in ERTO.\n   On receiving a packet\
    \ containing at least one acknowledgement, reset\n   TIMEOUT_ALARM (if already\
    \ set) to fire in ERTO.\n   When TIMEOUT_ALARM fires:\n   1.  Set WAS_LOSS = false;\n\
    \   2.  For each sending flow in the session, and for each entry in that\n   \
    \    flow's SEND_QUEUE:\n       1.  If entry.IN_FLIGHT is true, set WAS_LOSS =\
    \ true; and\n       2.  Set entry.IN_FLIGHT to false.\n   3.  If WAS_LOSS is true,\
    \ perform ERTO backoff (Section 3.5.2.2); and\n   4.  Notify the congestion control\
    \ and avoidance algorithms of the\n       timeout and, if WAS_LOSS is true, that\
    \ there was loss.\n"
- title: 3.6.2.7.  Abandoning Data
  contents:
  - "3.6.2.7.  Abandoning Data\n   The application can abandon queued messages at\
    \ any time and for any\n   reason.  Example reasons include (but are not limited\
    \ to) the\n   following: one or more fragments of a message have remained in the\n\
    \   SEND_QUEUE for longer than a specified message lifetime; a fragment\n   has\
    \ been retransmitted more than a specified retransmission limit; a\n   prior message\
    \ on which this message depends (such as a key frame in a\n   prediction chain)\
    \ was abandoned and not delivered.\n   To abandon a message fragment, set its\
    \ SEND_QUEUE entry's ABANDON\n   flag to true.  When abandoning a message fragment,\
    \ abandon all\n   fragments of the message to which it belongs.\n   An abandoned\
    \ fragment MUST NOT be un-abandoned.\n"
- title: 3.6.2.7.1.  Forward Sequence Number Update
  contents:
  - "3.6.2.7.1.  Forward Sequence Number Update\n   Abandoned data may leave gaps\
    \ in the sequence number space of a flow.\n   Gaps may cause the receiver to hold\
    \ completely received messages for\n   ordered delivery to allow for retransmission\
    \ of the missing\n   fragments.  User Data chunks (Section 2.3.11) encode a Forward\n\
    \   Sequence Number (FSN) to instruct the receiver that fragments with\n   sequence\
    \ numbers less than or equal to the FSN will not be\n   transmitted or retransmitted.\n\
    \   When the receiver has gaps in the received sequence number space and\n   no\
    \ non-abandoned message fragments remain in the SEND_QUEUE, the\n   sender SHOULD\
    \ transmit a Forward Sequence Number Update (FSN Update)\n   comprising a User\
    \ Data chunk marked abandoned, whose sequence number\n   is the FSN and whose\
    \ fsnOffset is 0.  An FSN Update allows the\n   receiver to skip gaps that will\
    \ not be repaired and deliver received\n   messages to the user.  An FSN Update\
    \ may be thought of as a\n   transmission or retransmission of abandoned sequence\
    \ numbers without\n   actually sending the data.\n   The method described in Section\
    \ 3.6.2.3 (\"Sending Data\") generates\n   FSN Updates when appropriate.\n"
- title: 3.6.2.8.  Examples
  contents:
  - "3.6.2.8.  Examples\n    Sender\n      |                   :\n    1 |<---  Ack\
    \  ID=2, seq:0-16\n    2 |--->  Data ID=2, seq#=25, fsnOff=9 (fsn=16)\n    3 |--->\
    \  Data ID=2, seq#=26, fsnOff=10 (fsn=16)\n    4 |<---  Ack  ID=2, seq:0-18\n\
    \    5 |--->  Data ID=2, seq#=27, fsnOff=9 (fsn=18)\n    6 |--->  Data ID=2, seq#=28,\
    \ fsnOff=10 (fsn=18)\n      |                   :\n   There are 9 sequence numbers\
    \ in flight with delayed acknowledgements.\n                    Figure 20: Normal\
    \ Flow with No Loss\n    Sender\n      |                   :\n    1 |<---  Ack\
    \  ID=3, seq:0-30\n    2 |--->  Data ID=3, seq#=45, fsnOff=15 (fsn=30)\n    3\
    \ |<---  Ack  ID=3, seq:0-30, 32 (nack 31:1)\n    4 |--->  Data ID=3, seq#=46,\
    \ fsnOff=16 (fsn=30)\n    5 |<---  Ack  ID=3, seq:0-30, 32, 34 (nack 31:2, 33:1)\n\
    \    6 |<---  Ack  ID=3, seq:0-30, 32, 34-35 (nack 31:3=lost, 33:2)\n    7 |--->\
    \  Data ID=3, seq#=47, fsnOff=15 (fsn=32, abandon 31)\n    8 |<---  Ack  ID=3,\
    \ seq:0-30, 32, 34-36 (nack 33:3=lost)\n    9 |--->  Data ID=3, seq#=33, fsnOff=1\
    \ (fsn=32, retransmit 33)\n   10 |<---  Ack  ID=3, seq:0-30, 32, 34-37\n   11\
    \ |--->  Data ID=3, seq#=48, fsnOff=16 (fsn=32)\n      |                   :\n\
    \      |      (continues through seq#=59)\n      |                   :\n   12\
    \ |--->  Data ID=3, seq#=60, fsnOff=28(fsn=32)\n   13 |<---  Ack  ID=3, seq:0-30,\
    \ 34-46\n   14 |--->  Data ID=3, seq#=61, fsnOff=29 (fsn=32)\n   15 |<---  Ack\
    \  ID=3, seq:0-32, 34-47\n   16 |--->  Data ID=3, seq#=62, fsnOff=30 (fsn=32)\n\
    \   17 |<---  Ack  ID=3, seq:0-47\n   18 |--->  Data ID=3, seq#=63, fsnOff=16\
    \ (fsn=47)\n   19 |<---  Ack  ID=3, seq:0-49\n   20 |--->  Data ID=3, seq#=64,\
    \ fsnOff=15 (fsn=49)\n      |                   :\n   21 |<---  Ack  ID=3, seq:0-59\n\
    \   22 |<---  Ack  ID=3, seq:0-59, 61 (nack 60:1)\n   23 |<---  Ack  ID=3, seq:0-59,\
    \ 61-62 (nack 60:2)\n   24 |<---  Ack  ID=3, seq:0-59, 61-63 (nack 60:3=lost)\n\
    \   25 |--->  Data ID=3, ABN=1, seq#=60, fsnOff=0 (fsn=60, abandon 60)\n   26\
    \ |<---  Ack  ID=3, seq:0-59, 61-64\n      |                   :\n   27 |<---\
    \  Ack  ID=3, seq:0-64\n   Flow with sequence numbers 31, 33, and 60 lost in transit,\
    \ and a\n   pause at 64.  33 is retransmitted; 31 and 60 are abandoned.  Note\n\
    \   that line 25 is a Forward Sequence Number Update (Section 3.6.2.7.1).\n  \
    \                       Figure 21: Flow with Loss\n"
- title: 3.6.2.9.  Flow Control
  contents:
  - "3.6.2.9.  Flow Control\n   The flow receiver advertises the amount of new data\
    \ it's willing to\n   accept from the flow sender with the bufferBytesAvailable\
    \ derived\n   field of an acknowledgement (Sections 2.3.13 and 2.3.14).\n   The\
    \ flow sender MUST NOT send new data into the network if\n   flow.F_OUTSTANDING_BYTES\
    \ is greater than or equal to the most\n   recently received buffer advertisement,\
    \ unless flow.EXCEPTION is true\n   (Section 3.6.2.3).\n"
- title: 3.6.2.9.1.  Buffer Probe
  contents:
  - "3.6.2.9.1.  Buffer Probe\n   The flow sender is suspended if the most recently\
    \ received buffer\n   advertisement is zero and the flow hasn't been rejected\
    \ by the\n   receiver -- that is, while RX_BUFFER_SIZE is zero AND EXCEPTION is\n\
    \   false.  To guard against potentially lost acknowledgements that might\n  \
    \ reopen the receive window, a suspended flow sender SHOULD send a\n   packet\
    \ comprising a Buffer Probe chunk (Section 2.3.15) for this flow\n   from time\
    \ to time.\n   If the receive window advertisement transitions from non-zero to\n\
    \   zero, the flow sender MAY send a Buffer Probe immediately and SHOULD\n   send\
    \ a probe within one second.\n   The initial period between Buffer Probes SHOULD\
    \ be at least\n   one second or ERTO, whichever is greater.  The period between\
    \ probes\n   SHOULD increase over time, but the period between probes SHOULD NOT\n\
    \   be more than one minute or ERTO, whichever is greater.\n   The flow sender\
    \ SHOULD stop sending Buffer Probes if it is no longer\n   suspended.\n"
- title: 3.6.2.10.  Exception
  contents:
  - "3.6.2.10.  Exception\n   The flow receiver can reject the flow at any time and\
    \ for any reason.\n   The flow receiver sends a Flow Exception Report (Section\
    \ 2.3.16) when\n   it has rejected a flow.\n   On receiving a Flow Exception Report\
    \ for a sending flow:\n   1.  If the flow is F_OPEN, close the flow (Section 3.6.2.11)\
    \ and\n       notify the user that the far end reported an exception with the\n\
    \       encoded exception code;\n   2.  Set the EXCEPTION flag to true; and\n\
    \   3.  For each entry in SEND_QUEUE, set entry.ABANDONED = true.\n"
- title: 3.6.2.11.  Close
  contents:
  - "3.6.2.11.  Close\n   A sending flow is closed by the user or as a result of an\
    \ exception.\n   To close an F_OPEN flow:\n   1.  Move to the F_CLOSING state;\n\
    \   2.  If the SEND_QUEUE is not empty, AND the tail entry of the\n       SEND_QUEUE\
    \ has a sequence number of NEXT_SN - 1, AND the\n       tail entry.EVER_SENT is\
    \ false, set F_FINAL_SN to\n       entry.SEQUENCE_NUMBER; else\n   3.  The SEND_QUEUE\
    \ is empty, OR the tail entry does not have a\n       sequence number of NEXT_SN\
    \ - 1, OR the tail entry.EVER_SENT is\n       true: enqueue a new SEND_QUEUE entry\
    \ with entry.SEQUENCE_NUMBER =\n       flow.NEXT_SN, entry.FRA = 0, and entry.ABANDONED\
    \ = true, and set\n       flow.F_FINAL_SN to entry.SEQUENCE_NUMBER.\n   An F_CLOSING\
    \ sending flow is complete when its SEND_QUEUE transitions\n   to empty, indicating\
    \ that all sequence numbers, including the\n   FINAL_SN, have been acknowledged\
    \ by the other end.\n   When an F_CLOSING sending flow becomes complete, move\
    \ to the\n   F_COMPLETE_LINGER state.\n   A sending flow MUST remain in the F_COMPLETE_LINGER\
    \ state for at\n   least 130 seconds.  After at least 130 seconds, move to the\
    \ F_CLOSED\n   state.  The sending flow is now closed, its resources can be\n\
    \   reclaimed, and its F_FLOW_ID MAY be used for a new sending flow.\n"
- title: 3.6.3.  Receiver
  contents:
  - "3.6.3.  Receiver\n   Each receiving flow comprises the flow-specific information\
    \ context\n   necessary to receive that flow's messages from the sending end and\n\
    \   deliver completed messages to the user.  Each receiving flow context\n   includes\
    \ at least:\n   o  RF_FLOW_ID: this flow's identifier;\n   o  SEQUENCE_SET: the\
    \ set of all fragment sequence numbers seen in\n      this receiving flow, whether\
    \ received or abandoned, initially\n      empty;\n   o  RF_FINAL_SN: the final\
    \ fragment sequence number of the flow,\n      initially having no value;\n  \
    \ o  RECV_BUFFER: the message fragments waiting to be delivered to the\n     \
    \ user, sorted by sequence number in ascending order, initially\n      empty;\
    \ each message fragment entry comprising the following:\n      *  SEQUENCE_NUMBER:\
    \ the sequence number of this fragment;\n      *  DATA: this fragment's user data;\
    \ and\n      *  FRA: the fragment control value for this message fragment,\n \
    \        having one of the values enumerated for that purpose in\n         Section\
    \ 2.3.11 (\"User Data Chunk\").\n   o  BUFFERED_SIZE: the sum of the lengths of\
    \ each fragment in\n      RECV_BUFFER plus any additional storage overhead for\
    \ the fragments\n      incurred by the implementation, in bytes;\n   o  BUFFER_CAPACITY:\
    \ the desired maximum size for the receive buffer,\n      in bytes;\n   o  PREV_RWND:\
    \ the most recent receive window advertisement sent in an\n      acknowledgement,\
    \ in 1024-byte blocks, initially having no value;\n   o  SHOULD_ACK: whether or\
    \ not an acknowledgement should be sent for\n      this flow, initially false;\n\
    \   o  EXCEPTION_CODE: the exception code to report to the sender when\n     \
    \ the flow has been rejected, initially 0;\n   o  The state, at any time being\
    \ one of the following values: the open\n      state RF_OPEN; the closing states\
    \ RF_REJECTED and\n      RF_COMPLETE_LINGER; and the closed state RF_CLOSED.\n\
    \   Note: The following diagram is only a summary of state transitions\n   and\
    \ their causing events, and is not a complete operational\n   specification.\n\
    \                                       +-+\n                                \
    \       |X|\n                                       +-+\n                    \
    \                    |rcv User Data for\n                                    \
    \    |  no existing flow\n                                        v\n        \
    \                           +---------+\n                                   |\
    \ RF_OPEN |\n                                   +---------+\n              rcv\
    \ all sequence numbers|   |user reject,\n                      0..RF_FINAL_SN\
    \  |   |rcv bad option,\n                                      |   |no metadata\
    \ at open,\n                                      |   |association specified\n\
    \                                      |   |  but not F_OPEN at open\n       \
    \                           +---+   |\n                                  |   \
    \    v\n                                  |  +-----------+\n                 \
    \                 |  |RF_REJECTED|\n                                  |  +-----------+\n\
    \                                  |       |rcv all sequence numbers\n       \
    \                           |       |  0..RF_FINAL_SN\n                      \
    \            v       v\n                             +------------------+\n  \
    \                           |RF_COMPLETE_LINGER|\n                           \
    \  +------------------+\n                                      | 120 seconds\n\
    \                                      v\n                                 +---------+\n\
    \                                 |RF_CLOSED|\n                              \
    \   +---------+\n                  Figure 22: Receiving Flow State Diagram\n"
- title: 3.6.3.1.  Startup
  contents:
  - "3.6.3.1.  Startup\n   A new receiving flow starts on receipt of a User Data chunk\n\
    \   (Section 2.3.11) encoding a flow ID not belonging to any other\n   receiving\
    \ flow in the same session in the RF_OPEN, RF_REJECTED, or\n   RF_COMPLETE_LINGER\
    \ states.\n   On receipt of such a User Data chunk:\n   1.   Set temporary variables\
    \ METADATA, ASSOCIATED_FLOWID, and\n        ASSOCIATION to each have no value;\n\
    \   2.   Create a new receiving flow context in this session, setting its\n  \
    \      RF_FLOW_ID to the flow ID encoded in the opening User Data\n        chunk,\
    \ and set to the RF_OPEN state;\n   3.   If the opening User Data chunk encodes\
    \ a User's Per-Flow\n        Metadata option (Section 2.3.11.1.1), set METADATA\
    \ to\n        option.userMetadata;\n   4.   If the opening User Data chunk encodes\
    \ a Return Flow Association\n        option (Section 2.3.11.1.2), set ASSOCIATED_FLOWID\
    \ to\n        option.flowID;\n   5.   If METADATA has no value, the receiver MUST\
    \ reject the flow\n        (Section 3.6.3.7), moving it to the RF_REJECTED state;\n\
    \   6.   If ASSOCIATED_FLOWID has a value, then if there is no sending\n     \
    \   flow in the same session with a flow ID of ASSOCIATED_FLOWID,\n        the\
    \ receiver MUST reject the flow, moving it to the RF_REJECTED\n        state;\
    \ otherwise, set ASSOCIATION to the indicated sending flow;\n   7.   If ASSOCIATION\
    \ indicates a sending flow, AND that sending flow's\n        state is not F_OPEN,\
    \ the receiver MUST reject this receiving\n        flow, moving it to the RF_REJECTED\
    \ state;\n   8.   If the opening User Data chunk encodes any unrecognized option\n\
    \        with a type code less than 8192 (Section 2.3.11.1), the receiver\n  \
    \      MUST reject the flow, moving it to the RF_REJECTED state;\n   9.   If this\
    \ new receiving flow is still RF_OPEN, then notify the\n        user that a new\
    \ receiving flow has opened, including the\n        METADATA and, if present,\
    \ the ASSOCIATION, and set\n        flow.BUFFER_CAPACITY according to the user;\n\
    \   10.  Perform the normal data processing (Section 3.6.3.2) for the\n      \
    \  opening User Data chunk; and\n   11.  Set this session's ACK_NOW to true.\n"
- title: 3.6.3.2.  Receiving Data
  contents:
  - "3.6.3.2.  Receiving Data\n   A User Data chunk (Section 2.3.11) or a Next User\
    \ Data chunk\n   (Section 2.3.12) encodes one fragment of a user data message\
    \ of a\n   flow, as well as the flow's Forward Sequence Number and potentially\n\
    \   optional parameters (Section 2.3.11.1).\n   On receipt of a User Data or Next\
    \ User Data chunk:\n   1.   If chunk.flowID doesn't indicate an existing receiving\
    \ flow in\n        the same session in the RF_OPEN, RF_REJECTED, or\n        RF_COMPLETE_LINGER\
    \ state, perform the steps of Section 3.6.3.1\n        (\"Startup\") to start\
    \ a new receiving flow;\n   2.   Retrieve the receiving flow context for the flow\
    \ indicated by\n        chunk.flowID;\n   3.   Set flow.SHOULD_ACK to true;\n\
    \   4.   If the flow is RF_OPEN, AND the chunk encodes any unrecognized\n    \
    \    option with a type code less than 8192 (Section 2.3.11.1), the\n        flow\
    \ MUST be rejected: notify the user of an exception, and\n        reject the flow\
    \ (Section 3.6.3.7), moving it to the RF_REJECTED\n        state;\n   5.   If\
    \ the flow is not in the RF_OPEN state, set session.ACK_NOW\n        to true;\n\
    \   6.   If flow.PREV_RWND has a value and that value is less than\n        2\
    \ blocks, set session.ACK_NOW to true;\n   7.   If chunk.abandon is true, set\
    \ session.ACK_NOW to true;\n   8.   If flow.SEQUENCE_SET has any gaps (that is,\
    \ if it doesn't\n        contain every sequence number from 0 through and including\
    \ the\n        highest sequence number in the set), set session.ACK_NOW\n    \
    \    to true;\n   9.   If flow.SEQUENCE_SET contains chunk.sequenceNumber, then\
    \ this\n        chunk is a duplicate: set session.ACK_NOW to true;\n   10.  If\
    \ flow.SEQUENCE_SET doesn't contain chunk.sequenceNumber, AND\n        chunk.final\
    \ is true, AND flow.RF_FINAL_SN has no value, then set\n        flow.RF_FINAL_SN\
    \ to chunk.sequenceNumber, and set\n        session.ACK_NOW to true;\n   11. \
    \ If the flow is in the RF_OPEN state, AND flow.SEQUENCE_SET\n        doesn't\
    \ contain chunk.sequenceNumber, AND chunk.abandon is\n        false, then create\
    \ a new RECV_BUFFER entry for this chunk's data\n        and set entry.SEQUENCE_NUMBER\
    \ to chunk.sequenceNumber,\n        entry.DATA to chunk.userData, and entry.FRA\
    \ to\n        chunk.fragmentControl, and insert this new entry into\n        flow.RECV_BUFFER;\n\
    \   12.  Add to flow.SEQUENCE_SET the range of sequence numbers from 0\n     \
    \   through and including the chunk.forwardSequenceNumber derived\n        field;\n\
    \   13.  Add chunk.sequenceNumber to flow.SEQUENCE_SET;\n   14.  If flow.SEQUENCE_SET\
    \ now has any gaps, set session.ACK_NOW\n        to true;\n   15.  If session.ACK_NOW\
    \ is false and session.DELACK_ALARM is not set,\n        set session.DELACK_ALARM\
    \ to fire in 200 milliseconds; and\n   16.  Attempt delivery of completed messages\
    \ in this flow's\n        RECV_BUFFER to the user (Section 3.6.3.3).\n   After\
    \ processing all chunks in a packet containing at least one User\n   Data chunk,\
    \ increment session.RX_DATA_PACKETS by one.  If\n   session.RX_DATA_PACKETS is\
    \ at least two, set session.ACK_NOW to true.\n   A receiving flow that is not\
    \ in the RF_CLOSED state is ready to send\n   an acknowledgement if its SHOULD_ACK\
    \ flag is set.  Acknowledgements\n   for receiving flows that are ready are sent\
    \ either opportunistically\n   by piggybacking on a packet that's already sending\
    \ user data or an\n   acknowledgement (Section 3.6.3.4.6), or when the session's\
    \ ACK_NOW\n   flag is set (Section 3.6.3.4.5).\n"
- title: 3.6.3.3.  Buffering and Delivering Data
  contents:
  - "3.6.3.3.  Buffering and Delivering Data\n   A receiving flow's information context\
    \ contains a RECV_BUFFER for\n   reordering, reassembling, and holding the user\
    \ data messages of the\n   flow.  Only complete messages are delivered to the\
    \ user; an\n   implementation MUST NOT deliver partially received messages, except\n\
    \   by special arrangement with the user.\n   Let the Cumulative Acknowledgement\
    \ Sequence Number (CSN) be the\n   highest number in the contiguous range of numbers\
    \ in SEQUENCE_SET\n   starting with 0.  For example, if SEQUENCE_SET contains\
    \ {0, 1, 2, 3,\n   5, 6}, the contiguous range starting with 0 is 0..3, so the\
    \ CSN is 3.\n   A message is complete if all of its fragments are present in the\n\
    \   RECV_BUFFER.  The fragments of one message have contiguous sequence\n   numbers.\
    \  A message can be either a single fragment, whose fragment\n   control value\
    \ is 0-whole, or two or more fragments where the first's\n   fragment control\
    \ value is 1-begin, followed by zero or more fragments\n   with control value\
    \ 3-middle, and terminated by a last fragment with\n   control value 2-end.\n\
    \   An incomplete message segment is a contiguous sequence of one or more\n  \
    \ fragments that do not form a complete message -- that is, a 1-begin\n   followed\
    \ by zero or more 3-middle fragments but with no 2-end, or\n   zero or more 3-middle\
    \ fragments followed by a 2-end but with no\n   1-begin, or one or more 3-middle\
    \ fragments with neither a 1-begin nor\n   a 2-end.\n   Incomplete message segments\
    \ can either be in progress or abandoned.\n   An incomplete segment is abandoned\
    \ in the following cases:\n   o  The sequence number of the segment's first fragment\
    \ is less than\n      or equal to the CSN, AND that fragment's control value is\
    \ not\n      1-begin; or\n   o  The sequence number of the segment's last fragment\
    \ is less than\n      the CSN.\n   Abandoned message segments will never be completed,\
    \ so they SHOULD be\n   removed from the RECV_BUFFER to make room in the advertised\
    \ receive\n   window and the receiver's memory for messages that can be completed.\n\
    \   The user can suspend delivery of a flow's messages.  A suspended\n   receiving\
    \ flow holds completed messages in its RECV_BUFFER until the\n   user resumes\
    \ delivery.  A suspended flow can cause the receive window\n   advertisement to\
    \ go to zero even when the BUFFER_CAPACITY is\n   non-zero; this is described\
    \ in detail in Section 3.6.3.5\n   (\"Flow Control\").\n   When the receiving\
    \ flow is not suspended, the original queuing order\n   of the messages is recovered\
    \ by delivering, in ascending sequence\n   number order, complete messages in\
    \ the RECV_BUFFER whose sequence\n   numbers are less than or equal to the CSN.\n\
    \   The following describes a method for discarding abandoned message\n   segments\
    \ and delivering complete messages in original queuing order\n   when the receiving\
    \ flow is not suspended.\n   While the first fragment entry in the RECV_BUFFER\
    \ has a sequence\n   number less than or equal to the CSN and delivery is still\
    \ possible:\n   1.  If entry.FRA is 0-whole, deliver entry.DATA to the user, and\n\
    \       remove this entry from RECV_BUFFER; otherwise,\n   2.  If entry.FRA is\
    \ 2-end or 3-middle, this entry belongs to an\n       abandoned segment, so remove\
    \ and discard this entry from\n       RECV_BUFFER; otherwise,\n   3.  Entry.FRA\
    \ is 1-begin.  Let LAST_ENTRY be the last RECV_BUFFER\n       entry that is part\
    \ of this message segment (LAST_ENTRY can be\n       entry if the segment has\
    \ only one fragment so far).  Then:\n       1.  If LAST_ENTRY.FRA is 2-end, this\
    \ segment is a complete\n           message, so concatenate the DATA fields of\
    \ each fragment\n           entry of this segment in ascending sequence number\
    \ order and\n           deliver the complete message to the user, then remove\
    \ the\n           entries for this complete message from RECV_BUFFER;\n      \
    \     otherwise,\n       2.  If LAST_ENTRY.SEQUENCE_NUMBER is less than CSN, this\
    \ segment\n           is incomplete and abandoned, so remove and discard the\n\
    \           entries for this segment from RECV_BUFFER; otherwise,\n       3. \
    \ LAST_ENTRY.SEQUENCE_NUMBER is equal to CSN and LAST_ENTRY.FRA\n           is\
    \ not 2-end: this segment is incomplete but still in\n           progress.  Ordered\
    \ delivery is no longer possible until at\n           least one more fragment\
    \ is received.  Stop.\n   If flow.RF_FINAL_SN has a value and is equal to the\
    \ CSN, AND\n   RECV_BUFFER is empty, all complete messages have been delivered\
    \ to\n   the user, so notify the user that the flow is complete.\n"
- title: 3.6.3.4.  Acknowledging Data
  contents:
  - "3.6.3.4.  Acknowledging Data\n   A flow receiver SHOULD acknowledge all user\
    \ data fragment sequence\n   numbers seen in that flow.  Acknowledgements drive\
    \ the sender's\n   congestion control and avoidance algorithms, clear data from\
    \ the\n   sender's buffers, and in some sender implementations clock new data\n\
    \   into the network; therefore, the acknowledgements must be accurate\n   and\
    \ timely.\n"
- title: 3.6.3.4.1.  Timing
  contents:
  - "3.6.3.4.1.  Timing\n   For reasons similar to those discussed in Section 4.2.3.2\
    \ of RFC 1122\n   [RFC1122], it is advantageous to delay sending acknowledgements\
    \ for a\n   short time, so that multiple data fragments can be acknowledged in\
    \ a\n   single transmission.  However, it is also advantageous for a sender\n\
    \   to receive timely notification about the receiver's disposition of\n   the\
    \ flow, particularly in unusual or exceptional circumstances, so\n   that the\
    \ circumstances can be addressed if possible.\n   Therefore, a flow receiver SHOULD\
    \ send an acknowledgement for a flow\n   as soon as is practical in any of the\
    \ following circumstances:\n   o  On receipt of a User Data chunk that starts\
    \ a new flow;\n   o  On receipt of a User Data or Next User Data chunk if the\
    \ flow is\n      not in the RF_OPEN state;\n   o  On receipt of a User Data chunk\
    \ where, before processing the\n      chunk, the SEQUENCE_SET of the indicated\
    \ flow does not contain\n      every sequence number between 0 and the highest\
    \ sequence number in\n      the set (that is, if there was a sequence number gap\
    \ before\n      processing the chunk);\n   o  On receipt of a User Data chunk\
    \ where, after processing the chunk,\n      the flow's SEQUENCE_SET does not contain\
    \ every sequence number\n      between 0 and the highest sequence number in the\
    \ set (that is, if\n      this chunk causes a sequence number gap);\n   o  On\
    \ receipt of a Buffer Probe for the flow;\n   o  On receipt of a User Data chunk\
    \ if the last acknowledgement sent\n      for the flow indicated fewer than two\
    \ bufferBlocksAvailable;\n   o  On receipt of a User Data or Next User Data chunk\
    \ for the flow if,\n      after processing the chunk, the flow's BUFFER_CAPACITY\
    \ is not at\n      least 1024 bytes greater than BUFFERED_SIZE;\n   o  On receipt\
    \ of a User Data or Next User Data chunk for any sequence\n      number that was\
    \ already seen (that is, on receipt of a duplicate);\n   o  On the first receipt\
    \ of the final sequence number of the flow;\n   o  On receipt of two packets in\
    \ the session that contain user data\n      for any flows since an acknowledgement\
    \ was last sent, the new\n      acknowledgements being for the flows having any\
    \ User Data chunks\n      in the received packets (that is, for every second packet\n\
    \      containing user data);\n   o  After receipt of a User Data chunk for the\
    \ flow, if an\n      acknowledgement for any other flow is being sent (that is,\n\
    \      consolidate acknowledgements);\n   o  After receipt of a User Data chunk\
    \ for the flow, if any user data\n      for a sending flow is being sent in a\
    \ packet and if there is space\n      available in the same packet (that is, attempt\
    \ to piggyback an\n      acknowledgement with user data if possible);\n   o  No\
    \ longer than 200 milliseconds after receipt of a User Data chunk\n      for the\
    \ flow.\n"
- title: 3.6.3.4.2.  Size and Truncation
  contents:
  - "3.6.3.4.2.  Size and Truncation\n   Including an encoded acknowledgement in a\
    \ packet might cause the\n   packet to exceed the path MTU.  In that case:\n \
    \  o  If the packet is being sent primarily to send an acknowledgement,\n    \
    \  AND this is the first acknowledgement in the packet, truncate the\n      acknowledgement\
    \ so that the packet does not exceed the path MTU;\n      otherwise,\n   o  The\
    \ acknowledgement is being piggybacked in a packet with user\n      data or with\
    \ an acknowledgement for another flow: do not include\n      this acknowledgement\
    \ in the packet, and send it later.\n"
- title: 3.6.3.4.3.  Constructing
  contents:
  - "3.6.3.4.3.  Constructing\n   The Data Acknowledgement Bitmap chunk (Section 2.3.13)\
    \ and Data\n   Acknowledgement Ranges chunk (Section 2.3.14) encode a receiving\n\
    \   flow's SEQUENCE_SET and its receive window advertisement.  The two\n   chunks\
    \ are semantically equivalent; implementations SHOULD send\n   whichever provides\
    \ the most compact encoding of the SEQUENCE_SET.\n   When assembling an acknowledgement\
    \ for a receiving flow:\n   1.  If the flow's state is RF_REJECTED, first assemble\
    \ a Flow\n       Exception Report chunk (Section 2.3.16) for flow.flowID;\n  \
    \ 2.  Choose the acknowledgement chunk type that most compactly encodes\n    \
    \   flow.SEQUENCE_SET;\n   3.  Use the method described in Section 3.6.3.5 (\"\
    Flow Control\") to\n       determine the value for the acknowledgement chunk's\n\
    \       bufferBlocksAvailable field.\n"
- title: 3.6.3.4.4.  Delayed Acknowledgement
  contents:
  - "3.6.3.4.4.  Delayed Acknowledgement\n   As discussed in Section 3.6.3.4.1 (\"\
    Timing\"), a flow receiver can\n   delay sending an acknowledgement for up to\
    \ 200 milliseconds after\n   receiving user data.  The method described in Section\
    \ 3.6.3.2\n   (\"Receiving Data\") sets the session's DELACK_ALARM.\n   When DELACK_ALARM\
    \ fires, set ACK_NOW to true.\n"
- title: 3.6.3.4.5.  Obligatory Acknowledgement
  contents:
  - "3.6.3.4.5.  Obligatory Acknowledgement\n   One or more acknowledgements should\
    \ be sent as soon as is practical\n   when the session's ACK_NOW flag is set.\
    \  While the ACK_NOW flag\n   is set:\n   1.  Choose a receiving flow that is\
    \ ready to send an acknowledgement;\n   2.  If there is no such flow, there is\
    \ no work to do, set ACK_NOW to\n       false, set RX_DATA_PACKETS to 0, clear\
    \ the DELACK_ALARM, and\n       stop; otherwise,\n   3.  Start a new packet;\n\
    \   4.  Assemble an acknowledgement for the flow and include it in the\n     \
    \  packet, truncating it if necessary so that the packet doesn't\n       exceed\
    \ the path MTU;\n   5.  Set flow.SHOULD_ACK to false;\n   6.  Set flow.PREV_RWND\
    \ to the bufferBlocksAvailable field of the\n       included acknowledgement chunk;\n\
    \   7.  Attempt to piggyback acknowledgements for any other flows that\n     \
    \  are ready to send an acknowledgement into the packet, as\n       described\
    \ below; and\n   8.  Send the packet.\n"
- title: 3.6.3.4.6.  Opportunistic Acknowledgement
  contents:
  - "3.6.3.4.6.  Opportunistic Acknowledgement\n   When sending a packet with user\
    \ data or an acknowledgement, any other\n   receiving flows that are ready to\
    \ send an acknowledgement should\n   include their acknowledgements in the packet\
    \ if possible.\n   To piggyback acknowledgements in a packet that is already being\
    \ sent,\n   where the packet contains user data or an acknowledgement, while\n\
    \   there is at least one receiving flow that is ready to send an\n   acknowledgement:\n\
    \   1.  Assemble an acknowledgement for the flow;\n   2.  If the acknowledgement\
    \ cannot be included in the packet without\n       exceeding the path MTU, the\
    \ packet is full; stop.  Otherwise,\n   3.  Include the acknowledgement in the\
    \ packet;\n   4.  Set flow.SHOULD_ACK to false;\n   5.  Set flow.PREV_RWND to\
    \ the bufferBlocksAvailable field of the\n       included acknowledgement chunk;\
    \ and\n   6.  If there are no longer any receiving flows in the session that\n\
    \       are ready to send an acknowledgement, set session.ACK_NOW to\n       false,\
    \ set session.RX_DATA_PACKETS to 0, and clear\n       session.DELACK_ALARM.\n"
- title: 3.6.3.4.7.  Example
  contents:
  - "3.6.3.4.7.  Example\n   Figure 23 shows an example flow with sequence numbers\
    \ 31 and 33 lost\n   in transit; 31 is abandoned, and 33 is retransmitted.\n \
    \  Receiver\n    1 |<---  Data ID=3, seq#=29, fsnOff=11 (fsn=18)\n    2 |<---\
    \  Data ID=3, seq#=30, fsnOff=12 (fsn=18)\n    3 |--->  Ack  ID=3, seq:0-30\n\
    \    4 |<---  Data ID=3, seq#=32, fsnOff=12 (fsn=20)\n    5 |--->  Ack  ID=3,\
    \ seq:0-30, 32\n    6 |<---  Data ID=3, seq#=34, fsnOff=12 (fsn=22)\n    7 |--->\
    \  Ack  ID=3, seq:0-30, 32, 34\n      |                   :\n    8 |<---  Data\
    \ ID=3, seq#=46, fsnOff=16 (fsn=30)\n    9 |--->  Ack  ID=3, seq:0-30, 32, 34-46\n\
    \   10 |<---  Data ID=3, seq#=47, fsnOff=15 (fsn=32)\n   11 |--->  Ack  ID=3,\
    \ seq:0-32, 34-47\n   12 |<---  Data ID=3, seq#=33, fsnOff=1 (fsn=32)\n   13 |--->\
    \  Ack  ID=3, seq#=0-47\n   14 |<---  Data ID=3, seq#=48, fsnOff=16 (fsn=32)\n\
    \   15 |<---  Data ID=3, seq#=49, fsnOff=17 (fsn=32)\n   16 |--->  Ack  ID=3,\
    \ seq#=0-49\n      |                   :\n                     Figure 23: Flow\
    \ Example with Loss\n"
- title: 3.6.3.5.  Flow Control
  contents:
  - "3.6.3.5.  Flow Control\n   The flow receiver maintains a buffer for reassembling\
    \ and reordering\n   messages for delivery to the user (Section 3.6.3.3).  The\n\
    \   implementation and the user may wish to limit the amount of resources\n  \
    \ (including buffer memory) that a flow is allowed to use.\n   RTMFP provides\
    \ a means for each receiving flow to govern the amount\n   of data sent by the\
    \ sender, by way of the bufferBytesAvailable\n   derived field of acknowledgement\
    \ chunks (Sections 2.3.13 and 2.3.14).\n   This derived field indicates the amount\
    \ of data that the sender is\n   allowed to have outstanding in the network, until\
    \ instructed\n   otherwise.  This amount is also called the receive window.\n\
    \   The flow receiver can suspend the sender by advertising a closed\n   (zero\
    \ length) receive window.\n   The user can suspend delivery of messages from the\
    \ receiving flow\n   (Section 3.6.3.3).  This can cause the receive buffer to\
    \ fill.\n   In order for progress to be made on completing a fragmented message\n\
    \   or repairing a gap for sequenced delivery in a flow, the flow\n   receiver\
    \ MUST advertise at least one buffer block in an\n   acknowledgement if it is\
    \ not suspended, even if the amount of data in\n   the buffer exceeds the buffer\
    \ capacity, unless the buffer capacity is\n   0.  Otherwise, deadlock can occur,\
    \ as the receive buffer will stay\n   full and won't drain because of a gap or\
    \ incomplete message, and the\n   gap or incomplete message can't be repaired\
    \ or completed because the\n   sender is suspended.\n   The receive window is\
    \ advertised in units of 1024-byte blocks.  For\n   example, advertisements for\
    \ 1 byte, 1023 bytes, and 1024 bytes each\n   require one block.  An advertisement\
    \ for 1025 bytes requires\n   two blocks.\n   The following describes the RECOMMENDED\
    \ method of calculating the\n   bufferBlocksAvailable field of an acknowledgement\
    \ chunk for a\n   receiving flow:\n   1.  If BUFFERED_SIZE is greater than or\
    \ equal to BUFFER_CAPACITY, set\n       ADVERTISE_BYTES to 0;\n   2.  If BUFFERED_SIZE\
    \ is less than BUFFER_CAPACITY, set\n       ADVERTISE_BYTES to BUFFER_CAPACITY\
    \ - BUFFERED_SIZE;\n   3.  Set ADVERTISE_BLOCKS to CEIL(ADVERTISE_BYTES / 1024);\n\
    \   4.  If ADVERTISE_BLOCKS is 0, AND BUFFER_CAPACITY is greater than 0,\n   \
    \    AND delivery to the user is not suspended, set ADVERTISE_BLOCKS\n       to\
    \ 1; and\n   5.  Set the acknowledgement's bufferBlocksAvailable field to\n  \
    \     ADVERTISE_BLOCKS.\n"
- title: 3.6.3.6.  Receiving a Buffer Probe
  contents:
  - "3.6.3.6.  Receiving a Buffer Probe\n   A Buffer Probe chunk (Section 2.3.15)\
    \ is sent by the flow sender\n   (Section 3.6.2.9.1) to request the current receive\
    \ window\n   advertisement (in the form of an acknowledgement) from the flow\n\
    \   receiver.\n   On receipt of a Buffer Probe chunk:\n   1.  If chunk.flowID\
    \ doesn't belong to a receiving flow in the same\n       session in the RF_OPEN,\
    \ RF_REJECTED, or RF_COMPLETE_LINGER state,\n       ignore this Buffer Probe;\
    \ otherwise,\n   2.  Retrieve the receiving flow context for the flow indicated\
    \ by\n       chunk.flowID; then\n   3.  Set flow.SHOULD_ACK to true; and\n   4.\
    \  Set session.ACK_NOW to true.\n"
- title: 3.6.3.7.  Rejecting a Flow
  contents:
  - "3.6.3.7.  Rejecting a Flow\n   A receiver can reject an RF_OPEN flow at any time\
    \ and for any reason.\n   To reject a receiving flow in the RF_OPEN state:\n \
    \  1.  Move to the RF_REJECTED state;\n   2.  Discard all entries in flow.RECV_BUFFER,\
    \ as they are no longer\n       relevant;\n   3.  If the user rejected the flow,\
    \ set flow.EXCEPTION_CODE to the\n       exception code indicated by the user;\
    \ otherwise, the flow was\n       rejected automatically by the implementation,\
    \ so the exception\n       code is 0;\n   4.  Set flow.SHOULD_ACK to true; and\n\
    \   5.  Set session.ACK_NOW to true.\n   The receiver indicates that it has rejected\
    \ a flow by sending a Flow\n   Exception Report chunk (Section 2.3.16) with every\
    \ acknowledgement\n   (Section 3.6.3.4.3) for a flow in the RF_REJECTED state.\n"
- title: 3.6.3.8.  Close
  contents:
  - "3.6.3.8.  Close\n   A receiving flow is complete when every sequence number from\
    \ 0\n   through and including the final sequence number has been received --\n\
    \   that is, when flow.RF_FINAL_SN has a value and flow.SEQUENCE_SET\n   contains\
    \ every sequence number from 0 through flow.RF_FINAL_SN,\n   inclusive.\n   When\
    \ an RF_OPEN or RF_REJECTED receiving flow becomes complete, move\n   to the RF_COMPLETE_LINGER\
    \ state, set flow.SHOULD_ACK to true, and set\n   session.ACK_NOW to true.\n \
    \  A receiving flow SHOULD remain in the RF_COMPLETE_LINGER state for\n   120\
    \ seconds.  After 120 seconds, move to the RF_CLOSED state.  The\n   receiving\
    \ flow is now closed, and its resources can be reclaimed once\n   all complete\
    \ messages in flow.RECV_BUFFER have been delivered to the\n   user (Section 3.6.3.3).\
    \  The same flow ID might be used for a new\n   flow by the sender after this\
    \ point.\n   Discussion: The flow sender detects that the flow is complete on\n\
    \   receiving an acknowledgement of all fragment sequence numbers of the\n   flow.\
    \  This can't happen until after the receiver has detected that\n   the flow is\
    \ complete and acknowledged all of the sequence numbers.\n   The receiver's RF_COMPLETE_LINGER\
    \ period is two minutes (one Maximum\n   Segment Lifetime (MSL)); this period\
    \ allows any in-flight packets to\n   drain from the network without being misidentified\
    \ and gives the\n   sender an opportunity to retransmit any sequence numbers if\
    \ the\n   completing acknowledgement is lost.  The sender's F_COMPLETE_LINGER\n\
    \   period is at least two minutes plus 10 seconds and doesn't begin\n   until\
    \ the completing acknowledgement is received; therefore, the same\n   flow identifier\
    \ won't be reused by the flow sender for a new sending\n   flow for at least 10\
    \ seconds after the flow receiver has closed the\n   receiving flow context. \
    \ This ensures correct operation independent\n   of network delay, even when the\
    \ sender's clock runs up to 8 percent\n   faster than the receiver's.\n"
- title: 4.  IANA Considerations
  contents:
  - "4.  IANA Considerations\n   This memo specifies chunk type code values (Section\
    \ 2.3) and User\n   Data option type code values (Section 2.3.11.1).  These type\
    \ code\n   values are assigned and maintained by Adobe.  Therefore, this memo\n\
    \   has no IANA actions.\n"
- title: 5.  Security Considerations
  contents:
  - "5.  Security Considerations\n   This memo specifies a general framework that\
    \ can be used to establish\n   a confidential and authenticated session between\
    \ endpoints.  A\n   Cryptography Profile, not specified herein, defines the cryptographic\n\
    \   algorithms, data formats, and semantics as used within this\n   framework.\
    \  Designing a Cryptography Profile to ensure that\n   communications are protected\
    \ to the degree required by the\n   application-specific threat model is outside\
    \ the scope of this\n   specification.\n   A block cipher in CBC mode is RECOMMENDED\
    \ for packet encryption\n   (Section 2.2.3).  An attacker can predict the values\
    \ of some fields\n   from one plain RTMFP packet to the next or predict that some\
    \ fields\n   may be the same from one packet to the next.  This SHOULD be\n  \
    \ considered in choosing and implementing a packet encryption cipher\n   and mode.\n\
    \   The well-known Default Session Key of a Cryptography Profile serves\n   multiple\
    \ purposes, including the scrambling of session startup\n   packets to protect\
    \ interior fields from undesirable modification by\n   middleboxes such as NATs,\
    \ increasing the effort required for casual\n   passive observation of startup\
    \ packets, and allowing different\n   applications of RTMFP using different Default\
    \ Session Keys to\n   (intentionally or not) share network transport addresses\
    \ without\n   interference.  The Default Session Key, being well known, MUST NOT\
    \ be\n   construed to contribute to the security of session startup; session\n\
    \   startup is essentially in the clear.\n   Section 3.5.4.2 describes an OPTIONAL\
    \ method for processing a change\n   of network address of a communicating peer.\
    \  Securely processing\n   address mobility using that method, or any substantially\
    \ similar\n   method, REQUIRES at least that the packet encryption function of\
    \ the\n   Cryptography Profile (Section 2.2.3) employs a cryptographic\n   verification\
    \ mechanism comprising secret information known only to\n   the two endpoints.\
    \  Without this constraint, that method, or any\n   substantially similar method,\
    \ becomes \"session hijacking support\".\n   Flows and packet fragmentation imply\
    \ semantics that could cause\n   unbounded resource utilization in receivers,\
    \ causing a denial of\n   service.  Implementations SHOULD guard against unbounded\
    \ or excessive\n   resource use and abort sessions that appear abusive.\n   A\
    \ rogue but popular Redirector (Section 3.5.1.4) could direct session\n   initiators\
    \ to flood a victim address or network with Initiator Hello\n   packets, potentially\
    \ causing a denial of service.\n   An attacker that can passively observe an IHello\
    \ and that possesses a\n   certificate matching the Endpoint Discriminator (without\
    \ having to\n   know the private key, if any, associated with it) can deny the\n\
    \   initiator access to the desired responder by sending an RHello before\n  \
    \ the desired responder does, since only the first received RHello is\n   selected\
    \ by the initiator.  The attacker needn't forge the desired\n   responder's source\
    \ address, since the RHello is selected based on the\n   tag echo and not the\
    \ packet's source address.  This can simplify the\n   attack in some network or\
    \ host configurations.\n   An attacker that can passively observe and record the\
    \ packets of an\n   established session can use traffic analysis techniques to\
    \ infer the\n   start and completion of flows without decrypting the packets.\
    \  The\n   User Data fragments of flows have unique sequence numbers, so flows\n\
    \   are immune to replay while they are open.  However, once a flow has\n   completed\
    \ and the linger period has concluded, the attacker could\n   replay the recorded\
    \ packets, opening a new flow in the receiver and\n   duplicating the flow's data;\
    \ this replay might have undesirable\n   effects on the receiver's application.\
    \  The attacker could also infer\n   that a new flow has begun reusing the recorded\
    \ flow's identifier and\n   replay the final sequence number or any of the other\
    \ fragments in the\n   flow, potentially denying or interfering with legitimate\
    \ traffic to\n   the receiver.  Therefore, the data integrity aspect of packet\n\
    \   encryption SHOULD comprise anti-replay measures.\n"
- title: 6.  Acknowledgements
  contents:
  - "6.  Acknowledgements\n   Special thanks go to Matthew Kaufman for his contributions\
    \ to the\n   creation and design of RTMFP.\n   Thanks to Jari Arkko, Ben Campbell,\
    \ Wesley Eddy, Stephen Farrell,\n   Philipp Hancke, Bela Lubkin, Hilarie Orman,\
    \ Richard Scheffenegger,\n   and Martin Stiemerling for their detailed reviews\
    \ of this memo.\n"
- title: 7.  References
  contents:
  - '7.  References

    '
- title: 7.1.  Normative References
  contents:
  - "7.1.  Normative References\n   [CBC]      Dworkin, M., \"Recommendation for Block\
    \ Cipher Modes of\n              Operation\", NIST Special Publication 800-38A,\n\
    \              December 2001, <http://csrc.nist.gov/publications/\n          \
    \    nistpubs/800-38a/sp800-38a.pdf>.\n   [RFC0768]  Postel, J., \"User Datagram\
    \ Protocol\", STD 6, RFC 768,\n              August 1980.\n   [RFC0791]  Postel,\
    \ J., \"Internet Protocol\", STD 5, RFC 791,\n              September 1981.\n\
    \   [RFC1122]  Braden, R., \"Requirements for Internet Hosts -\n             \
    \ Communication Layers\", STD 3, RFC 1122, October 1989.\n   [RFC2119]  Bradner,\
    \ S., \"Key words for use in RFCs to Indicate\n              Requirement Levels\"\
    , BCP 14, RFC 2119, March 1997.\n   [RFC2460]  Deering, S. and R. Hinden, \"Internet\
    \ Protocol, Version 6\n              (IPv6) Specification\", RFC 2460, December\
    \ 1998.\n   [RFC2914]  Floyd, S., \"Congestion Control Principles\", BCP 41,\n\
    \              RFC 2914, September 2000.\n   [RFC4821]  Mathis, M. and J. Heffner,\
    \ \"Packetization Layer Path MTU\n              Discovery\", RFC 4821, March 2007.\n\
    \   [RFC5681]  Allman, M., Paxson, V., and E. Blanton, \"TCP Congestion\n    \
    \          Control\", RFC 5681, September 2009.\n"
- title: 7.2.  Informative References
  contents:
  - "7.2.  Informative References\n   [RFC5389]  Rosenberg, J., Mahy, R., Matthews,\
    \ P., and D. Wing,\n              \"Session Traversal Utilities for NAT (STUN)\"\
    , RFC 5389,\n              October 2008.\n   [ScalableTCP]\n              Kelly,\
    \ T., \"Scalable TCP: Improving Performance in\n              Highspeed Wide Area\
    \ Networks\", December 2002,\n              <http://datatag.web.cern.ch/datatag/papers/\n\
    \              pfldnet2003-ctk.pdf>.\n"
- title: Appendix A.  Example Congestion Control Algorithm
  contents:
  - "Appendix A.  Example Congestion Control Algorithm\n   As mandated in Section\
    \ 3.5.2, an RTMFP is required to use TCP-\n   compatible congestion control, but\
    \ flexibility in exact\n   implementation is allowed, within certain limits. \
    \ This section\n   describes an experimental window-based congestion control algorithm\n\
    \   that is appropriate for real-time and bulk data transport in RTMFP.\n   The\
    \ algorithm includes slow start and congestion avoidance phases,\n   including\
    \ modified increase and decrease parameters.  These\n   parameters are further\
    \ adjusted according to whether real-time data\n   is being sent and whether Time\
    \ Critical Reverse Notifications are\n   received.\n"
- title: A.1.  Discussion
  contents:
  - "A.1.  Discussion\n   RFC 5681 defines the standard window-based congestion control\n\
    \   algorithms for TCP.  These algorithms are appropriate for delay-\n   insensitive\
    \ bulk data transport but have undesirable behaviors for\n   delay- and loss-sensitive\
    \ applications.  Among the undesirable\n   behaviors are the cutting of the congestion\
    \ window in half during a\n   loss event, and the rapidity of the slow start algorithm's\n\
    \   exponential growth.  Cutting the congestion window in half requires a\n  \
    \ large channel headroom to support a real-time application and can\n   cause\
    \ a large amount of jitter from sender-side buffering.  Doubling\n   the congestion\
    \ window during the slow start phase can lead to the\n   congestion window temporarily\
    \ growing to twice the size it should be,\n   causing a period of excessive loss\
    \ in the path.\n   We found that a number of deployed TCP implementations use\
    \ the method\n   of equation (3) from Section 3.1 of RFC 5681; this method, when\n\
    \   combined with the recommended behavior of acknowledging every other\n   packet,\
    \ causes the congestion window to grow at approximately half\n   the rate that\
    \ the recommended method specifies.  In order to compete\n   fairly with these\
    \ deployed TCPs, we choose 768 bytes per round trip\n   as the increment during\
    \ the normal congestion avoidance phase; this\n   is approximately half of the\
    \ typical maximum segment size of\n   1500 bytes and is also easily subdivided.\n\
    \   The sender may be sending real-time data to the far end.  When\n   sending\
    \ real-time data, a smoother response to congestion is desired\n   while still\
    \ competing with reasonable fairness to other flows in the\n   Internet.  In order\
    \ to scale the sending rate quickly, the slow start\n   algorithm is desired,\
    \ but slow start's normal rate of increase can\n   cause excessive loss in the\
    \ last round trip.  Accordingly, slow\n   start's exponential increase rate is\
    \ adjusted to double approximately\n   every 3 round trips instead of every round\
    \ trip.  The multiplicative\n   decrease cuts the congestion window by one eighth\
    \ on loss to maintain\n   a smoother sending rate.  The additive increase is done\
    \ at half the\n   normal rate (incrementing at 384 bytes per round trip), to both\n\
    \   compensate for the less aggressive loss response and probe the path\n   capacity\
    \ more gently.\n   The far end may report that it is receiving real-time data\
    \ from other\n   peers, or the sender may be sending real-time data to other far\
    \ ends.\n   In these circumstances (if not sending real-time data to this far\n\
    \   end), it is desirable to respond differently than the standard TCP\n   algorithms\
    \ specify, to both yield capacity to the real-time flows and\n   avoid excessive\
    \ losses while probing the path capacity.  Slow start's\n   exponential increase\
    \ is disabled, and the additive increase is done\n   at half the normal rate (incrementing\
    \ at 384 bytes per round trip).\n   Multiplicative decrease is left at the normal\
    \ rate (cutting by half)\n   to yield to other flows.\n   Since real-time messages\
    \ may be small, and sent regularly, it is\n   advantageous to spread congestion\
    \ window increases out across the\n   round-trip time instead of doing them all\
    \ at once.  We divide the\n   round trip into 16 segments with an additive increase\
    \ of a useful\n   size (48 bytes) per segment.\n   Scalable TCP [ScalableTCP]\
    \ describes experimental methods of\n   modifying the additive increase and multiplicative\
    \ decrease of the\n   congestion window in large delay-bandwidth scenarios.  The\
    \ congestion\n   window is increased by 1% each round trip and decreased by one\
    \ eighth\n   on loss in the congestion avoidance phase in certain circumstances\n\
    \   (specifically, when a 1% increase is larger than the normal additive-\n  \
    \ increase amount).  Those methods are adapted here.  The scalable\n   increase\
    \ amount is 48 bytes for every 4800 bytes acknowledged, to\n   spread the increase\
    \ out over the round trip.  The congestion window\n   is decreased by one eighth\
    \ on loss when it is at least 67200 bytes\n   per round trip, which is seven eighths\
    \ of 76800 (the point at which\n   1% is greater than 768 bytes per round trip).\
    \  When sending real-time\n   data to the far end, the scalable increase is 1%\
    \ or 384 bytes per\n   round trip, whichever is greater.  Otherwise, when notified\
    \ that the\n   far end is receiving real-time data from other peers, the scaled\n\
    \   increase is adjusted to 0.5% or 384 bytes per round trip, whichever\n   is\
    \ greater.\n"
- title: A.2.  Algorithm
  contents:
  - "A.2.  Algorithm\n   Let SMSS denote the Sender Maximum Segment Size [RFC5681],\
    \ for\n   example 1460 bytes.  Let CWND_INIT denote the Initial Congestion\n \
    \  Window (IW) according to Section 3.1 of RFC 5681, for example\n   4380 bytes.\
    \  Let CWND_TIMEDOUT denote the congestion window after a\n   timeout indicating\
    \ lost data, being 1*SMSS (for example, 1460 bytes).\n   Let the session information\
    \ context contain additional variables:\n   o  CWND: the congestion window, initialized\
    \ to CWND_INIT;\n   o  SSTHRESH: the slow start threshold, initialized to positive\n\
    \      infinity;\n   o  ACKED_BYTES_ACCUMULATOR: a count of acknowledged bytes,\n\
    \      initialized to 0;\n   o  ACKED_BYTES_THIS_PACKET: a count of acknowledged\
    \ bytes observed in\n      the current packet;\n   o  PRE_ACK_OUTSTANDING: the\
    \ number of bytes outstanding in the\n      network before processing any acknowledgements\
    \ in the current\n      packet;\n   o  ANY_LOSS: an indication of whether any\
    \ loss has been detected in\n      the current packet;\n   o  ANY_NAKS: an indication\
    \ of whether any negative acknowledgements\n      have been detected in the current\
    \ packet;\n   o  ANY_ACKS: an indication of whether any acknowledgement chunks\
    \ have\n      been received in the current packet.\n   Let FASTGROW_ALLOWED indicate\
    \ whether the congestion window is\n   allowed to grow at the normal rate versus\
    \ a slower rate, being false\n   if a Time Critical Reverse Notification has been\
    \ received on this\n   session within the last 800 milliseconds (Sections 2.2.4\
    \ and 3.5.2.1)\n   or if a Time Critical Forward Notification has been sent on\
    \ ANY\n   session in the last 800 milliseconds, and otherwise being true.\n  \
    \ Let TC_SENT indicate whether a Time Critical Forward Notification has\n   been\
    \ sent on this session within the last 800 milliseconds.\n   Implement the method\
    \ described in Section 3.6.2.6 to manage\n   transmission timeouts, including\
    \ setting the TIMEOUT_ALARM.\n   On being notified that the TIMEOUT_ALARM has\
    \ fired, perform the\n   function shown in Figure 24:\n   on TimeoutNotification(WAS_LOSS):\n\
    \       set SSTHRESH to MAX(SSTHRESH, CWND * 3/4).\n       set ACKED_BYTES_ACCUMULATOR\
    \ to 0.\n       if WAS_LOSS is true:\n           set CWND to CWND_TIMEDOUT.\n\
    \       else:\n           set CWND to CWND_INIT.\n         Figure 24: Pseudocode\
    \ for Handling a Timeout Notification\n   Before processing each received packet\
    \ in this session:\n   1.  Set ANY_LOSS to false;\n   2.  Set ANY_NAKS to false;\n\
    \   3.  Set ACKED_BYTES_THIS_PACKET to 0; and\n   4.  Set PRE_ACK_OUTSTANDING\
    \ to S_OUTSTANDING_BYTES.\n   On notification of loss (Section 3.6.2.5), set ANY_LOSS\
    \ to true.\n   On notification of negative acknowledgement (Section 3.6.2.5),\
    \ set\n   ANY_NAKS to true.\n   On notification of acknowledgement of data (Section\
    \ 3.6.2.4), set\n   ANY_ACKS to true, and add the count of acknowledged bytes\
    \ to\n   ACKED_BYTES_THIS_PACKET.\n   After processing all chunks in each received\
    \ packet for this session,\n   perform the function shown in Figure 25:\n   if\
    \ ANY_LOSS is true:\n       if (TC_SENT is true) OR (PRE_ACK_OUTSTANDING > 67200\
    \ AND \\\n       FASTGROW_ALLOWED is true):\n           set SSTHRESH to MAX(PRE_ACK_OUTSTANDING\
    \ * 7/8, CWND_INIT).\n       else:\n           set SSTHRESH to MAX(PRE_ACK_OUTSTANDING\
    \ * 1/2, CWND_INIT).\n       set CWND to SSTHRESH.\n       set ACKED_BYTES_ACCUMULATOR\
    \ to 0.\n   else if (ANY_ACKS is true) AND (ANY_NAKS is false) AND \\\n   (PRE_ACK_OUTSTANDING\
    \ >= CWND):\n       set var INCREASE to 0.\n       var AITHRESH.\n       if FASTGROW_ALLOWED\
    \ is true:\n           if CWND < SSTHRESH:\n               set INCREASE to ACKED_BYTES_THIS_PACKET.\n\
    \           else:\n               add ACKED_BYTES_THIS_PACKET to ACKED_BYTES_ACCUMULATOR.\n\
    \               set AITHRESH to MIN(MAX(CWND / 16, 64), 4800).\n             \
    \  while ACKED_BYTES_ACCUMULATOR >= AITHRESH:\n                   subtract AITHRESH\
    \ from ACKED_BYTES_ACCUMULATOR.\n                   add 48 to INCREASE.\n    \
    \   else FASTGROW_ALLOWED is false:\n           if CWND < SSTHRESH AND TC_SENT\
    \ is true:\n               set INCREASE to CEIL(ACKED_BYTES_THIS_PACKET / 4).\n\
    \           else:\n               var AITHRESH_CAP.\n               if TC_SENT\
    \ is true:\n                   set AITHRESH_CAP to 2400.\n               else:\n\
    \                   set AITHRESH_CAP to 4800.\n               add ACKED_BYTES_THIS_PACKET\
    \ to ACKED_BYTES_ACCUMULATOR.\n               set AITHRESH to MIN(MAX(CWND / 16,\
    \ 64), AITHRESH_CAP).\n               while ACKED_BYTES_ACCUMULATOR >= AITHRESH:\n\
    \                   subtract AITHRESH from ACKED_BYTES_ACCUMULATOR.\n        \
    \           add 24 to INCREASE.\n       set CWND to MAX(CWND + MIN(INCREASE, SMSS),\
    \ CWND_INIT).\n          Figure 25: Pseudocode for Congestion Window Adjustment\n\
    \                         after Processing a Packet\n"
- title: Author's Address
  contents:
  - "Author's Address\n   Michael C. Thornburgh\n   Adobe Systems Incorporated\n \
    \  345 Park Avenue\n   San Jose, CA  95110-2704\n   US\n   Phone: +1 408 536 6000\n\
    \   EMail: mthornbu@adobe.com\n   URI:   http://www.adobe.com/\n"
