- contents:
  - ' Fail Over Extensions for Layer 2 Tunneling Protocol (L2TP) "failover"

    '
  title: __initial_text__
- contents:
  - "Status of This Memo\n   This document specifies an Internet standards track protocol
    for the\n   Internet community, and requests discussion and suggestions for\n
    \  improvements.  Please refer to the current edition of the \"Internet\n   Official
    Protocol Standards\" (STD 1) for the standardization state\n   and status of this
    protocol.  Distribution of this memo is unlimited.\n"
  title: Status of This Memo
- contents:
  - "Copyright Notice\n   Copyright (C) The IETF Trust (2007).\n"
  title: Copyright Notice
- contents:
  - "Abstract\n   Layer 2 Tunneling Protocol (L2TP) is a connection-oriented protocol\n
    \  that has a shared state between active endpoints.  Some of this\n   shared
    state is vital for operation, but may be volatile in nature,\n   such as packet
    sequence numbers used on the L2TP Control Connection.\n   When failure of one
    side of a control connection occurs, a new\n   control connection is created and
    associated with the old connection\n   by exchanging information about the old
    connection.  Such a mechanism\n   is not intended as a replacement for an active
    fail over with some\n   mirrored connection states, but as an aid for those parameters
    that\n   are particularly difficult to have immediately available.  Protocol\n
    \  extensions to L2TP defined in this document are intended to\n   facilitate
    state recovery, providing additional resiliency in an L2TP\n   network, and improving
    a remote system's layer 2 connectivity.\n"
  title: Abstract
- contents:
  - "Table of Contents\n   1. Introduction ....................................................3\n
    \     1.1. Terminology ................................................4\n      1.2.
    Abbreviations ..............................................5\n      1.3. Specification
    of Requirements ..............................5\n   2. Overview ........................................................5\n
    \  3. Failover Protocol ...............................................7\n      3.1.
    Failover Capability Negotiation ............................7\n      3.2. Failover
    Recovery Procedure ................................7\n           3.2.1. Recovery
    Tunnel Establishment .......................8\n           3.2.2. Control Channel
    Reset ..............................10\n           3.2.3. Data Channel Reset .................................10\n
    \     3.3. Session State Synchronization .............................11\n   4.
    New Control Messages ...........................................12\n      4.1.
    Failover Session Query ....................................13\n      4.2. Failover
    Session Response .................................13\n   5. New Attribute Value
    Pairs ......................................14\n      5.1. Failover Capability
    AVP ...................................14\n      5.2. Tunnel Recovery AVP .......................................15\n
    \     5.3. Suggested Control Sequence AVP ............................16\n      5.4.
    Failover Session State AVP ................................17\n   6. Configuration
    Parameters .......................................18\n   7. IANA Considerations
    ............................................19\n   8. Security Considerations
    ........................................19\n   9. Acknowledgements ...............................................19\n
    \  10. Contributors ..................................................20\n   11.
    References ....................................................20\n      11.1.
    Normative References .....................................20\n      11.2. Informative
    References ...................................20\n   Appendix A ........................................................21\n
    \  Appendix B ........................................................23\n   Appendix
    C ........................................................24\n"
  title: Table of Contents
- contents:
  - "1.  Introduction\n   The goal of this document is to aid the overall resiliency
    of an L2TP\n   endpoint by introducing extensions to RFC 2661 [L2TPv2] and RFC
    3931\n   [L2TPv3] that will minimize the recovery time of the L2TP layer after\n
    \  a failover, while minimizing the impact on its performance.\n   Therefore,
    it is assumed that the endpoint's overall architecture is\n   also supportive
    in the resiliency effort.\n   To ensure proper operation of an L2TP endpoint after
    a failover, the\n   associated information of the control connection and sessions
    between\n   them must be correct and consistent.  This includes both the\n   configured
    and dynamic information.  The configured information is\n   assumed to be correct
    and consistent after a failover, otherwise the\n   tunnels and sessions would
    not have been setup in the first place.\n   The dynamic information, which is
    also referred to as stateful\n   information, changes with the processing of the
    tunnel's control and\n   data packets.  Currently, the only such information that
    is essential\n   to the tunnel's operation is its sequence numbers.  For the tunnel\n
    \  control channel, the inconsistencies in its sequence numbers can\n   result
    in the termination of the entire tunnel.  For tunnel sessions,\n   the inconsistency
    in its sequence numbers, when used, can cause\n   significant data loss, which
    gives the perception of a \"service loss\"\n   to the end user.\n   Thus, an optimal
    resilient architecture that aims to minimize\n   \"service loss\" after a failover,
    must make provisions for the\n   tunnel's essential stateful information, i.e.,
    its sequence numbers.\n   Currently, there are two options available: the first
    option is to\n   ensure that the backup endpoint is completely synchronized with
    the\n   active endpoint, with respect to the control and data sessions\n   sequence
    numbers.  The other option is to reestablish all the tunnels\n   and their sessions
    after a failover.  The drawback of the first\n   option is that it adds significant
    performance and complexity impact\n   to the endpoint's architecture, especially
    as tunnel and session\n   aggregation increases.  The drawback of the second option
    is that it\n   increases the \"service loss\" time, especially as the architecture\n
    \  scales.\n   To alleviate the above-mentioned drawbacks of the current options,\n
    \  this document introduces a mechanism to bring the dynamic stateful\n   information
    of a tunnel to a correct and consistent state after a\n   failure.  The proposed
    mechanism defines the recovery of tunnels and\n   sessions that were in an established
    state prior to the failure.\n"
  - contents:
    - "1.1.  Terminology\n   Endpoint: L2TP control connection endpoint, i.e., either
      LAC or LNS\n   (also known as LCCE in [L2TPv3]).\n   Active Endpoint: An endpoint
      that is currently providing service.\n   Backup Endpoint: A redundant endpoint
      standing by for the active\n   endpoint that has its database of active tunnels
      and sessions in sync\n   with its active endpoint.\n   Failed Endpoint: The
      endpoint that was the active endpoint at the\n   time of the failure.\n   Recovery
      Endpoint: The endpoint that initiates the failover protocol\n   to recover from
      the failure of an active endpoint.\n   Remote Endpoint: The endpoint that peers
      with active endpoint before\n   failure and with recovery endpoint after failure.\n
      \  Failover: The action of a backup endpoint taking over the service of\n   an
      active endpoint.  This could be due to administrative action or\n   failure
      of the active endpoint.\n   Old Tunnel: A control connection that existed before
      failure and is\n   subjected to recovery upon failover.\n   Recovery Tunnel:
      A new control connection established only to recover\n   an old tunnel.\n   Recovered
      Tunnel: After an old tunnel's control connection and\n   sessions are restored
      using the mechanism described in this document,\n   it is referred to as a Recovered
      Tunnel.\n   Control Channel Failure: Failure of the component responsible for\n
      \  establishing/maintaining tunnels and sessions at an endpoint.\n   Data Channel
      Failure: Failure of the component responsible for\n   forwarding the L2TP encapsulated
      data.\n"
    title: 1.1.  Terminology
  - contents:
    - "1.2.  Abbreviations\n   LAC      L2TP Access Concentrator\n   LNS      L2TP
      Network Server\n   LCCE     L2TP Control Connection Endpoint\n   AVP      Attribute
      Value Pair\n   SCCRQ    Start-Control-Connection-Request\n   SCCRP    Start-Control-Connection-Reply\n
      \  ZLB      Zero Length Body Message\n"
    title: 1.2.  Abbreviations
  - contents:
    - "1.3.  Specification of Requirements\n   The key words \"MUST\", \"MUST NOT\",
      \"REQUIRED\", \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\",
      \"MAY\", and \"OPTIONAL\" in this\n   document are to be interpreted as described
      in [RFC2119].\n"
    title: 1.3.  Specification of Requirements
  title: 1.  Introduction
- contents:
  - "2.  Overview\n   The following diagram depicts the redundancy architecture and\n
    \  pertaining entities used to describe the failover protocol:\n                                           +--------------+\n
    \                                          | L2TP active  |\n   +----------+                        ----|
    endpoint (A) |\n   |   L2TP   |                       /    +--------------+\n
    \  | endpoint |----------------------/\n   |    (R)   |                      \\
    \    +--------------+\n   +----------+                       \\    | L2TP backup
    \ |\n                                       ----| endpoint (B) |\n                                           +--------------+\n
    \  Active and backup endpoints may reside on the same device, however,\n   they
    are not required to be that way.  On other hand, some devices\n   may not have
    a standby module altogether, in which case the failed\n   endpoint, after reset,
    can become the recovery endpoint to recover\n   from its prior failure.\n   Therefore,
    in the above diagram, upon A's (active endpoint's)\n   failure:\n      - Endpoint
    A would be called the failed endpoint.\n      - If B is present, then it would
    become the recovery endpoint and\n        also an active endpoint.\n      - If
    B is not present, then A could become the recovery endpoint\n        after it
    restarts, provided it saved the information about\n        active tunnels/sessions
    in some persistent storage.\n      - R does not initiate the failover protocol;
    rather it waits for a\n        failure indication from recovery endpoint.\n   This
    document assumes that the actual detection of a failure in the\n   backup endpoint
    is done in an implementation-specific way.  It also\n   assumes that failure detection
    by the backup endpoint is faster than\n   the L2TP control channel timeout between
    the active and remote\n   endpoints.  Typically, active and backup endpoints reside
    on the same\n   physical device, allowing fast and reliable failure detection
    without\n   the need to communicate between these endpoints over the network.\n
    \  Similarly, an active endpoint that acts also as a backup endpoint can\n   easily
    start the recovery once it has rebooted.  However, when the\n   active and backup
    endpoints reside in separate devices, there is a\n   need for communication between
    them in order to detect failures.  As\n   a solution for such situations, additional
    failure detection\n   protocols, e.g., [BFD-MULTIHOP], may be needed.\n   A device
    could have three kinds of failures:\n        i) Control Channel Failure\n       ii)
    Data Channel Failure\n      iii) Control and Data Channel Failure\n   The protocol
    described in this document specifies the recovery in\n   conditions i) and iii).
    \ It is perceived that not much (stateful\n   information) could be recovered
    via a control protocol exchange in\n   case of ii).\n   The failover protocol
    consists of three phases:\n   1) Failover Capability Negotiation: An active endpoint
    and a remote\n      endpoint exchange failover capabilities and attributes to
    be used\n      during the recovery process.\n   2) Failover Recovery: A recovery
    endpoint establishes a new L2TP\n      control connection (called recovery tunnel)
    for every old tunnel\n      that it wishes to recover.  The recovery tunnel serves
    three\n      purposes:\n      - It identifies the old tunnel that is being recovered.\n
    \     - It provides a means of authentication and a three-way handshake\n        to
    ensure both ends agree on the failover for the specified old\n        tunnel.\n
    \     - It could exchange the Ns and Nr values to be used in the\n        recovered
    tunnel.\n      Upon establishing the recovery tunnel, two endpoints reset the\n
    \     control and data channel(s) on the recovered tunnel using the\n      procedures
    described in Section 3.2.2 and Section 3.2.3,\n      respectively.  The recovery
    tunnel could be torn down after that,\n      and sessions that were established
    resume traffic.\n   3) Session State Synchronization: The session state synchronization\n
    \     process occurs on the recovered or the old tunnel and allows the\n      two
    endpoints to agree on the state of the various sessions in the\n      tunnel after
    failover.  The inconsistency, which could arise due\n      to the failure, is
    handled in the following manner: first, the two\n      endpoints silently clear
    the sessions that were not in the\n      established state.  Then, they utilize
    Failover Session Query\n      (FSQ) and Failover Session Response (FSR) on the
    recovered tunnel\n      to obtain the state of sessions as known to the peer endpoint
    and\n      clear the sessions accordingly.\n"
  title: 2.  Overview
- contents:
  - "3.  Failover Protocol\n   The protocol consists of three steps describing specifications
    during\n   the life of a control connection - before and after failover.\n"
  - contents:
    - "3.1.  Failover Capability Negotiation\n   The active and remote endpoints exchange
      the Failover Capability\n   attribute-value pair (AVP) in Start-Control-Connection-Request\n
      \  (SCCRQ) and Start-Control-Connection-Reply (SCCRP) during control\n   connection
      establishment as a part of the normal (before failover)\n   operation.  The
      Failover Capability AVP, defined in Section 5.1,\n   allows an endpoint to specify
      if it is control and/or data channel\n   failover capable and the time allowed
      for the recovery for the\n   tunnel.\n"
    title: 3.1.  Failover Capability Negotiation
  - contents:
    - "3.2.  Failover Recovery Procedure\n   The Failover Recovery Procedure described
      in this section is\n   performed only if there was a control channel failure.
      \ The selection\n   of the tunnels to be recovered is implementation specific.\n
      \  The Failover Recovery Procedure consists of following three steps,\n   which
      are described in detail in the subsections below:\n      - Recovery tunnel establishment\n
      \     - Control channel reset\n      - Data channel reset\n"
    - contents:
      - "3.2.1.  Recovery Tunnel Establishment\n   The recovery endpoint establishes
        a new control connection, called\n   recovery tunnel, for every old tunnel
        it wishes to recover.  The\n   purpose of the recovery tunnel is solely to
        recover the corresponding\n   old tunnel.  There is a one to one relationship
        between recovery\n   tunnel and recovered/old tunnel\n   Recovery tunnel establishment
        considerations:\n      - An LCCE MUST follow the procedures described in [L2TPv2]
        or\n        [L2TPv3] to establish the recovery tunnel.\n      - The recovery
        tunnel MUST use the same L2TP version (and\n        establishment procedures)
        that was used for the old tunnel.\n      - The SCCRQ for Recovery tunnel MUST
        include the Tunnel Recovery\n        AVP, defined in Section 5.2, to identify
        the old tunnel that is\n        being recovered.\n      - The recovery tunnel
        MUST NOT include the Failover Capability AVP\n        in its SCCRQ or SCCRP
        messages.\n      - An endpoint SHOULD NOT send any message other than the
        following\n        on the recovery tunnel: SCCRQ, SCCRP, SCCCN, StopCCN, HELLO,\n
        \       ZLB, and ACK ([L2TPv3] only).\n      - An endpoint MUST NOT use any
        old Tunnel ID for the recovery\n        tunnel.  The old tunnels MUST be valid
        until the recovery\n        process concludes.\n      - An endpoint MUST use
        the Tie Breaker AVP (Section 4.4.3\n        [L2TPv2]) or Control Connection
        Tie Breaker AVP (Section 5.4.3\n        [L2TPv3]) in the setup of the recovery
        tunnel to ensure that\n        only a single recovery tunnel (when both endpoints
        have\n        simultaneous failover) is established to recover an old tunnel.\n
        \       The tunnel that wins the tie is used to decide the suggested Ns\n
        \       and Nr values on the recovered tunnel.  Therefore, the endpoint\n
        \       that loses the tie, should reset the Ns and Nr values (Section\n        3.2.2)
        as if it were a remote endpoint.  Appendix B illustrates\n        the double
        failover scenario.\n      - Tie Breaker AVP processing: The scope of a tie
        breaker AVP's\n        action for recovery and non recovery tunnels must be\n
        \       independent, and is defined as follows:\n        o  When Tie Breaker
        AVP is used in a non recovery tunnel, the\n           scope of the tie breaker
        AVP's action MUST only be within non\n           recovery tunnels.  Therefore,
        losing a tie against a non\n           recovery tunnel MUST NOT result in
        termination of any\n           recovery tunnel.\n        o  When a Tie Breaker
        AVP is used in a recovery tunnel, the\n           scope of tie breaker AVP's
        action is further restricted to\n           the recovery tunnel(s) for a single
        tunnel to be recovered.\n           Thus, an implementation MUST apply the
        tie breaker received\n           in a recovery tunnel only to those tunnels
        that are a)\n           recovery tunnels, and b) associated with the same
        tunnel to\n           be recovered.  It MUST NOT impact the operation of non-\n
        \          recovery tunnels and recovery tunnels associated with other\n           old
        tunnels to be recovered.\n   Upon getting an SCCRQ with a Tunnel Recovery
        AVP, an endpoint\n   validates the Recover Tunnel ID and the Recover Remote
        Tunnel ID and\n   responds with an SCCRP.  It MUST terminate the recovery
        tunnel if:\n      - The Recover Tunnel ID or the Recover Remote Tunnel ID
        is\n        unknown.\n      - The active or remote endpoint (prior to failover)
        had not\n        indicated that it was failover capable.\n      - The L2TP
        version of recovery tunnel is different from the\n        version used in
        the old tunnel.\n   If the remote endpoint accepts the SCCRQ, it SHOULD include
        the\n   Suggested Control Sequence AVP, defined in Section 5.3, in the SCCRP\n
        \  message.\n   Authentication considerations:\n      - To authenticate a
        peer endpoint during recovery tunnel\n        establishment, an endpoint MUST
        follow the procedure described\n        in either [L2TPv2] Section 5.1.1 or
        [L2TPv3] Section 4.3.  It\n        MUST use the same secret that was used
        to authenticate the old\n        tunnel.\n      - Not being able to authenticate
        could be a reason to terminate\n        the recovery tunnel.\n      - For
        L2TPv3 tunnels, a recovery tunnel MUST use the Control\n        Message authentication
        (i.e., exchange the nonce values), as\n        described in [L2TPv3] Section
        4.3, if the old tunnel was\n        configured to do control message authentication.
        \ An L2TPv3\n        recovered tunnel MUST reset its nonce values (both endpoints)
        to\n        the nonce values exchanged in the recovery tunnel.\n   For any
        reason, if the recovery endpoint could not establish the\n   recovery tunnel,
        then it MUST silently clear the old tunnel and\n   sessions within, concluding
        that the recovery process has failed.\n   Any control packet received on the
        recovered tunnel before control\n   channel reset (Section 3.2.2) MUST be
        silently discarded.\n"
      title: 3.2.1.  Recovery Tunnel Establishment
    - contents:
      - "3.2.2.  Control Channel Reset\n   Control channel reset allows new control
        messages to be sent and\n   received over the recovered tunnel.\n   Control
        channel reset procedure:\n      - An endpoint SHOULD flush the transmit/receive
        windows and reset\n        the control channel sequence numbers (i.e., Ns
        and Nr values) on\n        the recovered tunnel.  The control channel on the
        recovery\n        endpoint is reset upon getting a valid SCCRP on the recovery\n
        \       tunnel, whereas the control channel on the remote endpoint is\n        reset
        upon getting a valid SCCCN on the recovery tunnel.  If the\n        recovery
        endpoint did not receive the Suggested Control Sequence\n        (SCS) AVP
        in the SCCRP then it MUST reset the Ns and Nr values\n        to zero.  If
        the remote endpoint opted to not send the SCS AVP\n        then it MUST reset
        the Ns and Nr values to zero.  Either\n        endpoint can tear down the
        recovery tunnel after the control\n        channel reset procedure is complete.\n
        \     - An endpoint MUST prevent the establishment of new sessions until\n
        \       it has cleared (or marked for clearance) the sessions that were\n
        \       not in an established state, i.e., until after Step I, Section\n        3.3
        is complete.\n"
      title: 3.2.2.  Control Channel Reset
    - contents:
      - "3.2.3.  Data Channel Reset\n   A data channel reset procedure is applicable
        only for the sessions\n   using sequence numbers.  For L2TPv3 data channel,
        the terms Nr and Ns\n   in this document are used to mean \"expected sequence
        number\" and\n   \"sequence number\", respectively.\n   Data channel reset
        procedure:\n      - The recovery endpoint sets the Ns value to zero.\n      -
        The remote endpoint (recovery endpoint's peer) continues to use\n        the
        Ns values it was using previously.\n      - To reset Nr values during failover,
        if an endpoint receives 'n'\n        out of order but in sequence packets,
        then it MUST set the Nr\n        value based on the Ns value of the incoming
        packets, as\n        suggested in Appendix C of [L2TPv3].  The value of 'n'
        SHOULD be\n        configurable.\n      - If one of the endpoints does not
        exhibit the capability\n        (indicated in 'D' bit in the Failover Capability
        AVP) to reset\n        the Nr value, then data channels using sequence numbers
        are\n        considered non recoverable.  Those sessions SHOULD be torn down\n
        \       by the recovery endpoint by sending a Call-Disconnect-Notify\n        (CDN).\n
        \     - For data-channel-only failure, two endpoints MAY use the session\n
        \       state query/response mechanism on the control channel to\n        synchronize
        the state of sessions as described in Section 3.3\n        below.\n"
      title: 3.2.3.  Data Channel Reset
    title: 3.2.  Failover Recovery Procedure
  - contents:
    - "3.3.  Session State Synchronization\n   If a control channel failure happens
      when a session was being\n   established or torn down, then it is possible for
      an endpoint to\n   consider a session in an established state while its peer
      considers\n   the same session non existent.  Two such situations occur when\n
      \  failure on an endpoint occurs immediately after sending:\n      - A CDN message
      that never made it to the peer.\n      - An ICCN message that never made it
      to the peer.\n   The following mechanism MUST be used to identify and clear
      the\n   sessions that exists on an endpoint, but not on its peer:\n   Step I:
      For control channel failure, after the recovery tunnel is\n   established, the
      sessions that were not in an established state MUST\n   be silently cleared
      (i.e., without sending a CDN message) by each\n   endpoint.\n   Step II: Both
      endpoints MAY identify the sessions that might have\n   been in inconsistent
      states, perhaps based on data channel\n   inactivity.  FSQ and FSR messages
      have been introduced to synchronize\n   session state at any given point during
      the life of a session between\n   two endpoints.  These messages are used when
      one endpoint determines\n   or suspects in an implementation specific manner
      that its session\n   state could be inconsistent with that of its peer's.\n
      \  Step III: An endpoint sends a Failover Session Query (FSQ) message to\n   query
      the state of sessions as known to its peer.  An FSQ message\n   contains one
      Failover Session State (FSS) AVP, defined in Section\n   5.4, for each session
      it wishes to query.  Multiple FSS AVPs could be\n   included in one FSQ message.
      \ An FSQ message MUST include at least\n   one FSS AVP.  An endpoint MAY send
      another FSQ message before getting\n   a response for its previous FSQs.\n   An
      inconsistency about a session's existence during failover could\n   result in
      an endpoint selecting the same Session ID for a new\n   session.  In such a
      situation, it would send an ICRQ for an already\n   established session.  Therefore,
      before all sessions are synchronized\n   using an FSQ/FSR mechanism, if endpoint
      receives an ICRQ for a\n   session in an established state, then it MUST respond
      to such an ICRQ\n   with a CDN.  The CDN message must set Assigned/Local Session
      ID AVP\n   ([L2TPv2] Section 4.4.4, [L2TPv3] Section 5.4.4) to its local Session\n
      \  ID and clear the session that it considered established.  Use of a\n   least
      recently used Session ID for the new sessions could help reduce\n   this symptom
      during failover.\n   When an endpoint receives an FSQ message, it MUST ensure
      that for\n   each FSS AVP in the FSQ message, it includes an FSS AVP in the\n
      \  Failover Session Response (FSR) message.  An endpoint could respond\n   to
      multiple FSQs using one FSR message, or it could respond one FSQ\n   with multiple
      FSRs.  FSSs are not required to be responded in the\n   same order in which
      they were received.  For each FSS AVP received in\n   FSQ messages, an endpoint
      MUST validate the Remote Session ID and\n   determine if it is paired with the
      Session ID specified in the\n   message.  If an FSS AVP is not valid (i.e.,
      session is non-existing\n   or it is paired with different remote Session ID),
      then the Session\n   ID field in the FSS AVP in the FSR MUST be set to zero.
      \ When session\n   is discovered to be pairing with mismatching Session ID,
      the local\n   session MUST not be cleared, but rather marked stale, to be queried\n
      \  later using an FSQ message.  Appendix C presents an example dialogue\n   between
      two endpoints with mismatching Session IDs.\n   When responding to an FSQ with
      an FSR message, the Remote Session ID\n   in the FSS AVP of the FSR message
      is always set to the received value\n   of the Session ID in the FSS AVP of
      the FSQ message.\n   When an endpoint receives an FSR message, for each FSS
      AVP it MUST\n   use the Remote Session ID field to identify the local session
      and\n   silently (without sending a CDN) clear the session if the Session ID\n
      \  in the AVP was zero.  Otherwise, it MUST consider the session to be\n   in
      an established state and recovered.\n"
    title: 3.3.  Session State Synchronization
  title: 3.  Failover Protocol
- contents:
  - "4.  New Control Messages\n   This document introduces two new messages that could
    be sent over an\n   established/recovered control connection.\n"
  - contents:
    - "4.1.  Failover Session Query\n   The Failover Session Query (FSQ) control message
      is used by an\n   endpoint during the recovery process to query the state of
      various\n   sessions.  It triggers a response from the peer, which contains
      the\n   requested state of various sessions.\n   This control message is encoded
      as follows:\n      Vendor ID = 0 (IETF)\n      Attribute Type = 21\n   The following
      AVPs MUST be present in the FSQ control message:\n      Message Type\n      Failover
      Session State\n   The following AVPs MAY be present in the FSQ control message:\n
      \     Random Vector\n      Message digest ([L2TPv3] tunnels only)\n   Other
      AVPs MUST NOT be sent in this control message and SHOULD be\n   ignored on receipt.\n
      \  The M-bit on the Message Type AVP for this control message MUST be\n   set
      to 0.\n"
    title: 4.1.  Failover Session Query
  - contents:
    - "4.2.  Failover Session Response\n   The Failover Session Response (FSR) control
      message is used by an\n   endpoint during the recovery process to respond with
      the local state\n   of various sessions.  It is sent as a response to an FSQ
      message.  An\n   endpoint MAY choose to respond to an FSQ message with multiple
      FSR\n   messages.\n   This control message is encoded as follows:\n      Vendor
      ID = 0 (IETF)\n      Attribute Type = 22\n   The following AVPs MUST be present
      in the FSR control message:\n      Message Type\n      Failover Session State\n
      \  The following AVPs MAY be present in the FSR control message:\n      Random
      Vector\n      Message digest ([L2TPv3] tunnels only)\n   Other AVPs MUST NOT
      be sent in this control message and SHOULD be\n   ignored on receipt.\n   The
      M-bit on the Message Type AVP for this control message MUST be\n   set to 0.\n"
    title: 4.2.  Failover Session Response
  title: 4.  New Control Messages
- contents:
  - "5.  New Attribute Value Pairs\n   The following sections contain a list of new
    L2TP AVPs defined in\n   this document.\n"
  - contents:
    - "5.1.  Failover Capability AVP\n   The Failover Capability AVP, Attribute Type
      76, indicates the\n   capabilities of an endpoint required for the recovery
      process.  The\n   AVP format is defined as follows:\n   Failover Capability
      AVP\n    0                   1                   2                   3\n    0
      1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  |M|H| rsvd  |      Length       |                0              |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  |         Attribute Type 76     |         Reserved          |D|C|\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  |              Recovery Time (in milliseconds)                  |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  The AVP MAY be hidden (the H-bit set to 0 or 1).  The AVP is not\n   mandatory
      (the M-bit MUST be set to 0).\n   The C bit governs the failover capability
      for the control channel.\n   When the C bit is set, it indicates that the endpoint
      can recover\n   from a control channel failure using the procedure described
      in\n   Section 3.2.2.\n   When the C bit is not set, it indicates that the endpoint
      cannot\n   recover from a control channel failover.  In this case, the D bit\n
      \  MUST be set.  Note that a control channel failover in this case would\n   be
      fatal for the tunnel and all associated data channels.\n   The D bit governs
      the failover capability for data channels that use\n   sequence numbers.  Data
      channels that do not use sequence numbers do\n   not need help to recover from
      a data channel failure.\n   When the D bit is set, it indicates that the endpoint
      is capable of\n   resetting Nr value of data channels using the procedure described
      in\n   Section 3.2.3 Data Channel reset procedure.\n   When the D bit is not
      set, it indicates that the endpoint cannot\n   recover data channels that use
      sequence numbers.  In the case of a\n   failure, such data channels would be
      lost.\n   The Failover Capability AVP MUST NOT be sent with C bit and D bit\n
      \  cleared.\n   The Recovery Time, applicable only when the C bit is set, is
      the time\n   in milliseconds an endpoint asks its peer to wait before assuming
      the\n   recovery process has failed.  This timer starts when an endpoint's\n
      \  control channel timeout ([L2TPv2] Section 5.8, [L2TPv3] Section 4.2)\n   is
      started, and is not stopped (before expiry) until an endpoint\n   successfully
      authenticates its peer during recovery.  A value of zero\n   does not mean that
      failover will not occur, it means no additional\n   time is requested from the
      peer.  The timer is also stopped if a\n   control channel message is acknowledged
      by the peer in the situation\n   when there was no failover, but the loss of
      the control channel\n   message was a temporary phenomenon.\n   This AVP MUST
      NOT be included in any control message other than SCCRQ\n   and SCCRP messages.\n"
    title: 5.1.  Failover Capability AVP
  - contents:
    - "5.2.  Tunnel Recovery AVP\n   The Tunnel Recovery AVP, Attribute Type 77, indicates
      that a sender\n   would like to recover the tunnel identified in this AVP due
      to a\n   failure.  The AVP format is defined as follows:\n   Tunnel Recovery
      AVP for L2TPv3 tunnels:\n    0                   1                   2                   3\n
      \   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  |M|H| rsvd  |      Length       |                0              |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  |         Attribute Type 77     |           Reserved            |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  |                        Recover Tunnel ID                      |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  |                     Recover Remote Tunnel ID                  |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  Tunnel Recovery AVP for L2TPv2 tunnels:\n    0                   1                   2
      \                  3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4
      5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  |M|H| rsvd  |      Length       |                0              |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  |         Attribute Type 77     |           Reserved            |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  |         Reserved              |     Recover Tunnel ID         |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  |         Reserved              |   Recover Remote Tunnel ID    |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  This AVP MUST not be hidden (the H-bit is set to 0).  The AVP is\n   mandatory
      (the M-bit is set to 1).\n   The Recover Tunnel ID encodes the local Tunnel
      ID that an endpoint\n   wants recovered.  The Recover Remote Tunnel ID encodes
      the remote\n   Tunnel ID corresponding to the old tunnel.\n   This AVP MUST
      NOT be included in any control message other than the\n   SCCRQ message when
      establishing a Recovery Tunnel.\n"
    title: 5.2.  Tunnel Recovery AVP
  - contents:
    - "5.3.  Suggested Control Sequence AVP\n   The Suggested Control Sequence (SCS)
      AVP, Attribute Type 78,\n   specifies the Ns and Nr values to for the recovered
      tunnel.  This AVP\n   is included in an SCCRP message of a recovery tunnel by
      remote\n   endpoint.  The AVP format is defined as follows:\n    0                   1
      \                  2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4
      5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  |M|H| rsvd  |      Length       |                0              |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  |         Attribute Type 78     |            Reserved           |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  |        Suggested Ns           |         Suggested Nr          |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  This AVP MAY be hidden (the H-bit set to 0 or 1).  The AVP is not\n   mandatory
      (the M-bit is set to 0).\n   This is an optional AVP, suggesting Ns and Nr values
      to be used by\n   the recovery endpoint.  If this AVP is present in an SCCRP
      message\n   during recovery tunnel establishment, the recovery endpoint MUST
      set\n   the Ns and Nr values of the recovered tunnel to the respective\n   suggested
      values.  When this AVP is not sent in an SCCRP or not\n   present in an incoming
      SCCRP, the Ns and Nr values for the recovered\n   tunnel are set to zero.  Use
      of this AVP helps avoid the interference\n   in the recovered tunnel's control
      channel with old control packets.\n   This AVP MUST NOT be included in any control
      message other than the\n   SCCRP message when establishing a Recovery Tunnel.\n"
    title: 5.3.  Suggested Control Sequence AVP
  - contents:
    - "5.4.  Failover Session State AVP\n   The Failover Session State (FSS) AVP,
      Attribute Type 79, is used to\n   query the state of a session from the peer
      end to clear the sessions\n   that otherwise would remain in an undefined state
      after failover.\n   The AVP format is defined as follows:\n   FSS AVP format
      for L2TPv3 sessions:\n    0                   1                   2                   3\n
      \   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  |M|H| rsvd  |      Length       |                0              |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  |      Attribute Type 79        |         Reserved              |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  |                          Session ID                           |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  |                       Remote Session ID                       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  FSS AVP format for L2TPv2 sessions:\n    0                   1                   2
      \                  3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4
      5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  |M|H| rsvd  |      Length       |                0              |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  |      Attribute Type 79        |         Reserved              |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  |            Reserved           |        Session ID             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  |            Reserved           |      Remote Session ID        |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  This AVP MAY be hidden (the H-bit set to 0 or 1).  The AVP is\n   mandatory
      (the M-bit is set to 1).\n   The Session ID identifies the local Session ID
      that the sender had\n   assigned, for which it would like to query the state
      on its peer.  A\n   Remote Session Id is the remote Session ID for the same
      session.\n   An FSS AVP MUST NOT be used in any message other than FSQ and FSR\n
      \  messages.\n"
    title: 5.4.  Failover Session State AVP
  title: 5.  New Attribute Value Pairs
- contents:
  - "6.  Configuration Parameters\n   An L2TP endpoint MAY expose the following configuration
    parameters to\n   be specified for control connections:\n      - Control Channel
    Failover Capability: Failover Capability AVP\n        (Section 5.1), C bit.\n
    \     - Data Channel Failover Capability: Failover Capability AVP\n        (Section
    5.1), D bit.\n      - Recovery Time: Failover Capability AVP (Section 5.1).\n
    \  The L2TP MIB defined in [L2TPv2-MIB] and [L2TPv3-MIB], defines a\n   number
    of objects that may be used for monitoring the status L2TP\n   nodes, but is seldom
    used for configuration purposes.  It is expected\n   that the above mentioned
    parameters will be configured by using a\n   Command Line Interface (CLI) or other
    proprietary mechanism.\n   Asynchronous notifications for failover and recovery
    events may be\n   sent by L2TP nodes to network management applications, but the\n
    \  specification of the protocol and format to be used for these\n   notifications
    is out of the scope of this document.\n"
  title: 6.  Configuration Parameters
- contents:
  - "7.  IANA Considerations\n   This document defines the following values assigned
    by IANA.\n   - Four Control Message Attribute Value Pairs (Section 10.1 [L2TPv3]):\n
    \          Failover Capability         : 76\n           Tunnel Recovery             :
    77\n           Suggested Control Sequence  : 78\n           Failover Session State
    \     : 79\n   - Two Message Type (Attribute Type 0) Values (Section 10.2 [L2TPv3]):\n
    \          Failover Session Query      : 21\n           Failover Session Response
    \  : 22\n"
  title: 7.  IANA Considerations
- contents:
  - "8.  Security Considerations\n   A spoofed failover request (SCCRQ with Tunnel
    Recovery AVP) on behalf\n   of an endpoint might cause a control channel termination
    if\n   authentication measures mentioned in Section 3.2.1 are not used.\n   Even
    if the authentication measures (as described in Section 3.2.1)\n   were used,
    it is still possible to learn an identity of an\n   operational tunnel from an
    endpoint by issuing it spoofed failover\n   requests that fail the authentication
    procedure.  The probability of\n   succeeding with a spoofed failover request
    is 1 in (2^16 - 1) for\n   [L2TPv2] and 1 in (2^32 - 1) for [L2TPv3].  The discovered
    identity\n   of an operational tunnel could then be misused to send control\n
    \  messages for a possible hindrance to the control connection.\n   Typically,
    control messages that are outside the endpoint's receive\n   window are discarded.
    \ However, if Suggested Control Sequence AVP\n   (Section 5.3) is not used during
    the actual failover process, the\n   sequence numbers might be reset to zero,
    thereby making the receive\n   window predictable.  To improve security under
    such circumstances, an\n   endpoint may be configured with the possible set of
    recovery\n   endpoints that could recover a tunnel, and use of Suggested Control\n
    \  Sequence AVP when recovering a tunnel.\n"
  title: 8.  Security Considerations
- contents:
  - "9.  Acknowledgements\n   Leo Huber provided suggestions to help define the failover
    concept.\n   Mark Townsley, Carlos Pignataro, and Ignacio Goyret reviewed the\n
    \  document and provided valuable suggestions.\n"
  title: 9.  Acknowledgements
- contents:
  - "10.  Contributors\n   Paul Howard            Juniper Networks\n   Vipin Jain
    \            Riverstone Networks\n   Sam Henderson          Cisco Systems\n   Keyur
    Parikh           Harris Corporations\n"
  title: 10.  Contributors
- contents:
  - '11.  References

    '
  - contents:
    - "11.1.  Normative References\n   [RFC2119]      Bradner, S., \"Key words for
      use in RFCs to Indicate\n                  Requirement Levels\", BCP 14, RFC
      2119, March 1997.\n   [L2TPv2]       Townsley, W., Valencia, A., Rubens, A.,
      Pall, G.,\n                  Zorn, G., and B. Palter, \"Layer Two Tunneling
      Protocol\n                  \"L2TP\"\", RFC 2661, August 1999.\n   [L2TPv3]
      \      Lau, J., Townsley, M., and I. Goyret, \"Layer Two\n                  Tunneling
      Protocol - Version 3 (L2TPv3)\", RFC 3931,\n                  March 2005.\n"
    title: 11.1.  Normative References
  - contents:
    - "11.2.  Informative References\n   [L2TPv2-MIB]   Caves, E., Calhoun, P., and
      R. Wheeler, \"Layer Two\n                  Tunneling Protocol \"L2TP\" Management
      Information\n                  Base\", RFC 3371, August 2002.\n   [L2TPv3-MIB]
      \  Nadeau, T. and K. Koushik, \"Layer Two Tunneling\n                  Protocol
      (version 3) Management Information Base\",\n                  Work in Progress,
      August 2006.\n   [BFD-MULTIHOP] Katz, D. and D. Ward, \"BFD for Multihop Paths\",
      Work\n                  in Progress, March 2007.\n"
    title: 11.2.  Informative References
  title: 11.  References
- contents:
  - "Appendix A\n   Description below outlines the failover protocol operation for
    an\n   example tunnel.  The failover protocol does not preclude an endpoint\n
    \  from recovering multiple tunnels in parallel.  It also allows an\n   endpoint
    to send multiple FSQs, each including multiple FSS AVPs, to\n   recover quickly.\n
    \  Failover Capability Negotiation (Section 3.1):\n  Endpoint                                             Peer\n
    \              (assigned tid = x, failover capable)\n  SCCRQ       -------------------------------------->
    \ validate SCCRQ\n               (assigned tid = y, failover capable)\n  validate
    \   <--------------------------------------  send SCCRP\n  SCCRP, etc.\n   ....
    <after tunnel gets created, sessions are established> ....\n  < This Node fails
    >\n  The Recovery endpoint establishes the recovery tunnel (Section 3.2.1).\n
    \ Initiate recovery tunnel establishment for the old tunnel 'x':\n  Recovery Endpoint
    \                                    Peer\n            (assigned tid = z, Recovery
    AVP)\n  SCCRQ     ----------------------------------->  Detects failover\n          (recover
    tid = x, recover remote tid = y)  validate SCCRQ\n          (Suggested Control
    Sequence AVP, Suggested Ns/Nr = 3/100)\n  validate <-----------------------------------
    \  send SCCRP\n  SCCRP    (recover tid = y, recover remote tid = x)\n  reset Ns
    = 3, Nr = 100\n  on the recovered tunnel\n  SCCCN     ----------------------------------->
    \ validate and reset\n                                                  Ns = 100,
    Nr = 3 on\n                                                  the recovered tunnel\n
    \ Terminate the recovery tunnel\n  tid = 'z'\n  StopCCN  -------------------------------------->
    Cleanup 'w'\n  Session states are synchronized both endpoints may send FSQs and\n
    \ cleanup stale sessions (Section 3.3)\n             (FSS AVP for sessions s1,
    s2, s3..)\n  send FSQ  -------------------------------------> compute the state\n
    \                                                     of sessions in FSQ\n                (FSS
    AVP for sessions s1, s2, s3...)\n     deletes  <--------------------------------------
    send FSR\n     stale sessions, if any\n                (FSS AVP for sessions s7,
    s8, s9...)\n     compute  <-------------------------------------- send FSQ\n     the
    sate of\n     sessions in FSQ\n                (FSS AVP for sessions s7, s8, s9...)\n
    \    send FSR --------------------------------------> delete stale\n                                                      sessions,
    if any\n"
  title: Appendix A
- contents:
  - "Appendix B\n   This section shows an example dialogue to illustrate double failure\n
    \  recovery.  The notable difference, as described in Section 3.2.1, in\n   the
    procedure from single failover scenario is the use of a tie\n   breaker by one
    of the recovery endpoints to use the recovery tunnel\n   established by its peer
    (also a recovery endpoint) as a recovery\n   tunnel.\n      Recovery endpoint
    \                    Recovery endpoint\n      (assume old tid = A)                 (assume
    old tid = B)\n                  Recovery AVP = (A, B)\n      SCCRQ     -----------------------+\n
    \     (with tie  (recovery tunnel 'C') |\n       breaker                         |\n
    \      AVP)                            |\n                 Recovery AVP = (B,
    A) |\n   +- valid    <--------------------------- Send SCCRQ\n   |  SCCRQ      (recovery
    tunnel 'D') |    (with tie breaker AVP)\n   |  This endpoint                    |\n
    \  |  loses tie;                       |\n   |  Discards tunnel 'C'              +-->
    Valid SCCRQ\n   |                                        This endpoint wins tie;\n
    \  |                                        Discards SCCRQ\n   |\n   |              (may
    include SCS AVP)\n   +->Send SCCRP -------------------------> Validate SCCRP\n
    \                                           Reset 'B';\n                                            Set
    Ns, Nr values --+\n                                                                |\n
    \                                                               |\n                                                                |\n
    \     Validate SCCN <---------------------- Send SCCN    -------+\n      Reset
    'A';\n      Set Ns, Nr values\n   FSQs and FSRs for the old tunnel (A, B) are
    exchanged on the\n   recovered tunnel by both endpoints.\n"
  title: Appendix B
- contents:
  - "Appendix C\n   Session ID mismatch could not be a result of failure on one of
    the\n   endpoints.  However, failover session recovery procedure could\n   exacerbate
    the situation, resulting into a permanent mismatch in\n   Session IDs between
    two endpoints.  The dialogue below outlines the\n   behavior described in Section
    3.3, Step III to handle such situations\n   gracefully.\n   Recovery endpoint
    \                   Remote endpoint\n   (assume a mismatch)                  (assume
    a mismatch)\n   Sid = A, Remote Sid = B              Sid = B, Remote Sid = C\n
    \  Sid = C, Remote Sid = D\n                  FSS AVP (A, B)\n   send FSQ  ------------------------->
    No (B, A) pair exist;\n                                        rather (B, C) exist.\n
    \                                       If it clears B then peer doesn't\n                                        know
    if C is stale on other end.\n                                        Instead if
    it marks B stale\n                                        and queries the session
    state\n                                        via FSQ, C would be cleared on\n
    \                                       the other end.\n                  FSS
    AVP (0, A)\n   Clears A <-------------------------- send FSR\n                                        ...
    some time later ...\n                  FSS AVP (B, C)\n   No (C,B) <--------------------------
    send FSQ\n   Mark C Stale\n                  FSS AVP (0, B)\n   Send FSR -------------------------->
    Clears B\n"
  title: Appendix C
- contents:
  - "Author Information\n   Vipin Jain\n   Riverstone Networks\n   5200 Great America
    Parkway\n   Santa Clara, CA 95054\n   EMail: vipinietf@yahoo.com\n   Paul W. Howard\n
    \  Juniper Networks\n   10 Technology Park Drive\n   Westford, MA 01886\n   EMail:
    phoward@juniper.net\n   Sam Henderson\n   Cisco Systems\n   7025 Kit Creek Rd.\n
    \  PO Box 14987\n   Research Triangle Park, NC 27709\n   EMail: samh@cisco.com\n
    \  Keyur Parikh\n   Harris Corporation\n   4393 Digitalway\n   Mason, OH 45040\n
    \  EMail: kparikh@harris.com\n"
  title: Author Information
- contents:
  - "Full Copyright Statement\n   Copyright (C) The IETF Trust (2007).\n   This document
    is subject to the rights, licenses and restrictions\n   contained in BCP 78, and
    except as set forth therein, the authors\n   retain all their rights.\n   This
    document and the information contained herein are provided on an\n   \"AS IS\"
    basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS\n   OR IS SPONSORED
    BY (IF ANY), THE INTERNET SOCIETY, THE IETF TRUST AND\n   THE INTERNET ENGINEERING
    TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS\n   OR IMPLIED, INCLUDING BUT NOT
    LIMITED TO ANY WARRANTY THAT THE USE OF\n   THE INFORMATION HEREIN WILL NOT INFRINGE
    ANY RIGHTS OR ANY IMPLIED\n   WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR
    PURPOSE.\n"
  title: Full Copyright Statement
- contents:
  - "Intellectual Property\n   The IETF takes no position regarding the validity or
    scope of any\n   Intellectual Property Rights or other rights that might be claimed
    to\n   pertain to the implementation or use of the technology described in\n   this
    document or the extent to which any license under such rights\n   might or might
    not be available; nor does it represent that it has\n   made any independent effort
    to identify any such rights.  Information\n   on the procedures with respect to
    rights in RFC documents can be\n   found in BCP 78 and BCP 79.\n   Copies of IPR
    disclosures made to the IETF Secretariat and any\n   assurances of licenses to
    be made available, or the result of an\n   attempt made to obtain a general license
    or permission for the use of\n   such proprietary rights by implementers or users
    of this\n   specification can be obtained from the IETF on-line IPR repository
    at\n   http://www.ietf.org/ipr.\n   The IETF invites any interested party to bring
    to its attention any\n   copyrights, patents or patent applications, or other
    proprietary\n   rights that may cover technology that may be required to implement\n
    \  this standard.  Please address the information to the IETF at\n   ietf-ipr@ietf.org.\n"
  title: Intellectual Property
- contents:
  - "Acknowledgement\n   Funding for the RFC Editor function is currently provided
    by the\n   Internet Society.\n"
  title: Acknowledgement
