- title: __initial_text__
  contents:
  - ''
- title: Independent Submission                                          R. Alimi
  contents:
  - "Independent Submission                                          R. Alimi\n  \
    \            DECoupled Application Data Enroute (DECADE)\n"
- title: Abstract
  contents:
  - "Abstract\n   Content distribution applications, such as those employing peer-to-\n\
    \   peer (P2P) technologies, are widely used on the Internet and make up\n   a\
    \ large portion of the traffic in many networks.  Often, however,\n   content\
    \ distribution applications use network resources\n   inefficiently.  One way\
    \ to improve efficiency is to introduce storage\n   capabilities within the network\
    \ and enable cooperation between end-\n   host and in-network content distribution\
    \ mechanisms.  This is the\n   capability provided by a DECoupled Application\
    \ Data Enroute (DECADE)\n   system, which is introduced in this document.  DECADE\
    \ enables\n   applications to take advantage of in-network storage when\n   distributing\
    \ data objects as opposed to using solely end-to-end\n   resources.  This document\
    \ presents the underlying principles and key\n   functionalities of such a system\
    \ and illustrates operation through a\n   set of examples.\n"
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This document is not an Internet Standards Track specification;\
    \ it is\n   published for informational purposes.\n   This is a contribution to\
    \ the RFC Series, independently of any other\n   RFC stream.  The RFC Editor has\
    \ chosen to publish this document at\n   its discretion and makes no statement\
    \ about its value for\n   implementation or deployment.  Documents approved for\
    \ publication by\n   the RFC Editor are not a candidate for any level of Internet\n\
    \   Standard; see Section 2 of RFC 5741.\n   Information about the current status\
    \ of this document, any errata,\n   and how to provide feedback on it may be obtained\
    \ at\n   http://www.rfc-editor.org/info/rfc7069.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (c) 2013 IETF Trust and the persons identified\
    \ as the\n   document authors.  All rights reserved.\n   This document is subject\
    \ to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n\
    \   (http://trustee.ietf.org/license-info) in effect on the date of\n   publication\
    \ of this document.  Please review these documents\n   carefully, as they describe\
    \ your rights and restrictions with respect\n   to this document.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1.  Introduction  . . . . . . . . . . . . . . . . . . .\
    \ . . . . .   4\n     1.1.  Requirements Language . . . . . . . . . . . . . .\
    \ . . . .   4\n   2.  Terminology . . . . . . . . . . . . . . . . . . . . . .\
    \ . . .   5\n   3.  Overview  . . . . . . . . . . . . . . . . . . . . . . . .\
    \ . .   6\n   4.  Architectural Principles  . . . . . . . . . . . . . . . . .\
    \ .   8\n     4.1.  Data- and Control-Plane Decoupling  . . . . . . . . . . .\
    \   8\n     4.2.  Immutable Data Objects  . . . . . . . . . . . . . . . . .  \
    \ 9\n     4.3.  Data Object Identifiers . . . . . . . . . . . . . . . . .  10\n\
    \     4.4.  Explicit Control  . . . . . . . . . . . . . . . . . . . .  11\n  \
    \   4.5.  Resource and Data Access Control through Delegation . . .  11\n   5.\
    \  System Components . . . . . . . . . . . . . . . . . . . . . .  12\n     5.1.\
    \  Application Endpoint  . . . . . . . . . . . . . . . . . .  13\n     5.2.  DECADE\
    \ Client . . . . . . . . . . . . . . . . . . . . . .  14\n     5.3.  DECADE Server\
    \ . . . . . . . . . . . . . . . . . . . . . .  14\n     5.4.  Data Sequencing\
    \ and Naming  . . . . . . . . . . . . . . .  15\n     5.5.  Token-Based Authorization\
    \ and Resource Control  . . . . .  17\n     5.6.  Discovery . . . . . . . . .\
    \ . . . . . . . . . . . . . . .  18\n   6.  DECADE Protocol Considerations  .\
    \ . . . . . . . . . . . . . .  19\n     6.1.  Naming  . . . . . . . . . . . .\
    \ . . . . . . . . . . . . .  19\n     6.2.  Resource Protocol . . . . . . . .\
    \ . . . . . . . . . . . .  19\n     6.3.  Data Transfer . . . . . . . . . . .\
    \ . . . . . . . . . . .  22\n     6.4.  Server-Server Protocols . . . . . . .\
    \ . . . . . . . . . .  23\n     6.5.  Potential DRP/SDT Candidates  . . . . .\
    \ . . . . . . . . .  23\n   7.  How In-Network Storage Components Map to DECADE\
    \ . . . . . . .  24\n   8.  Security Considerations . . . . . . . . . . . . .\
    \ . . . . . .  25\n     8.1.  Threat: System Denial-of-Service Attacks  . . .\
    \ . . . . .  25\n     8.2.  Threat: Authorization Mechanisms Compromised  . .\
    \ . . . .  25\n     8.3.  Threat: Spoofing of Data Objects  . . . . . . . . .\
    \ . . .  26\n   9.  Acknowledgments . . . . . . . . . . . . . . . . . . . . .\
    \ . .  27\n   10. References  . . . . . . . . . . . . . . . . . . . . . . . .\
    \ .  27\n     10.1.  Normative References . . . . . . . . . . . . . . . . . .\
    \  27\n     10.2.  Informative References . . . . . . . . . . . . . . . . .  27\n\
    \   Appendix A.  Evaluation of Candidate Protocols for DECADE DRP/SDT  29\n  \
    \   A.1.  HTTP  . . . . . . . . . . . . . . . . . . . . . . . . . .  29\n    \
    \ A.2.  CDMI  . . . . . . . . . . . . . . . . . . . . . . . . . .  31\n     A.3.\
    \  OAuth . . . . . . . . . . . . . . . . . . . . . . . . . .  34\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   Content distribution applications, such as peer-to-peer\
    \ (P2P)\n   applications, are widely used on the Internet to distribute data\n\
    \   objects and make up a large portion of the traffic in many networks.\n   Said\
    \ applications can often introduce performance bottlenecks in\n   otherwise well-provisioned\
    \ networks.  In some cases, operators are\n   forced to invest substantially in\
    \ infrastructure to accommodate the\n   use of such applications.  For instance,\
    \ in many subscriber networks,\n   it can be expensive to upgrade network equipment\
    \ in the \"last mile\",\n   because it can involve replacing equipment and upgrading\
    \ wiring and\n   devices at individual homes, businesses, DSLAMs (Digital Subscriber\n\
    \   Line Access Multiplexers), and CMTSs (Cable Modem Termination\n   Systems)\
    \ in remote locations.  It may be more practical and\n   economical to upgrade\
    \ the core infrastructure, instead of the \"last\n   mile\" of the network, as\
    \ this involves fewer components that are\n   shared by many subscribers.  See\
    \ [RFC6646] and [RFC6392] for a more\n   complete discussion of the problem domain\
    \ and general discussions of\n   the capabilities envisioned for a DECADE system.\
    \  As a historical\n   point, it should be noted that [RFC6646] and [RFC6392]\
    \ came out of\n   the now closed DECADE Working Group.  This document aims to\
    \ advance\n   some of the valuable concepts from that now closed Working Group.\n\
    \   This document presents mechanisms for providing in-network storage\n   that\
    \ can be integrated into content distribution applications.  The\n   primary focus\
    \ is P2P-based content distribution, but DECADE may be\n   useful to other applications\
    \ with similar characteristics and\n   requirements (e.g., Content Distribution\
    \ Networks (CDNs) or hybrid\n   P2P/CDNs).  The approach we adopt in this document\
    \ is to define the\n   core functionalities and protocol functions that are needed\
    \ to\n   support a DECADE system.  This document provides illustrative\n   examples\
    \ so that implementers can understand the main concepts in\n   DECADE, but it\
    \ is generally assumed that readers are also familiar\n   with the terms and concepts\
    \ used in [RFC6646] and [RFC6392].\n"
- title: 1.1.  Requirements Language
  contents:
  - "1.1.  Requirements Language\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\"\
    , \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"\
    MAY\", and \"OPTIONAL\" in this\n   document are to be interpreted as described\
    \ in RFC 2119 [RFC2119].\n"
- title: 2.  Terminology
  contents:
  - "2.  Terminology\n   This document uses the following terminology.\n   Application\
    \ Endpoint\n      A host that includes a DECADE client along with other application\n\
    \      functionalities (e.g., peer-to-peer (P2P) client, video streaming\n   \
    \   client).\n   Content Distribution Application\n      A specific type of application\
    \ that may exist in an Application\n      Endpoint.  A content distribution application\
    \ is an application\n      (e.g., P2P) designed for dissemination of large amounts\
    \ of content\n      (e.g., files or video streams) to multiple peers.  Content\n\
    \      distribution applications may divide content into smaller blocks\n    \
    \  for dissemination.\n   Data Object\n      A data object is the unit of data\
    \ stored and retrieved from a\n      DECADE server.  The data object is a sequence\
    \ of raw bytes.  The\n      server maintains metadata associated with each data\
    \ object, but\n      the metadata is physically and logically separate from the\
    \ data\n      object.\n   DECADE Client\n      A DECADE client uploads and/or\
    \ retrieves data from a DECADE\n      server.\n   DECADE Resource Protocol (DRP)\n\
    \      A logical protocol for communication of access control and\n      resource-scheduling\
    \ policies from a DECADE client to a DECADE\n      server, or between DECADE servers.\
    \  In practice, the functionality\n      of the DRP may be distributed over one\
    \ or more actual protocols.\n   DECADE Server\n      A DECADE server stores data\
    \ inside the network for a DECADE client\n      or another DECADE server, and\
    \ thereafter it manages both the\n      stored data and access to that data by\
    \ other DECADE clients.\n   DECADE Storage Provider\n      A DECADE storage provider\
    \ deploys and/or manages DECADE servers\n      within a network.\n   DECADE System\n\
    \      An in-network storage system that is composed of DECADE clients\n     \
    \ and DECADE servers.  The DECADE servers may be deployed by one or\n      more\
    \ DECADE storage providers.\n   In-Network Storage\n      A service inside a network\
    \ that provides storage to applications.\n      In-network storage may reduce\
    \ upload/transit/backbone traffic and\n      improve application performance.\
    \  In-network storage may, for\n      example, be co-located with the border router\
    \ (network-attached\n      storage) or inside a data center.  A DECADE system\
    \ is an example\n      of an in-network storage system.\n   Standard Data Transfer\
    \ (SDT) Protocol\n      A logical protocol used to transfer data objects between\
    \ a DECADE\n      client and DECADE server, or between DECADE servers.  The intent\n\
    \      is that in practice the SDT should map to an existing, well-known\n   \
    \   protocol already in use over the Internet for transporting data.\n"
- title: 3.  Overview
  contents:
  - "3.  Overview\n   A DECADE system provides a distributed storage service for content\n\
    \   distribution applications (e.g., P2P).  The system consists of\n   clients\
    \ and servers.  A client first uploads data objects to one or\n   more selected\
    \ servers and optionally requests distribution of these\n   data objects to other\
    \ servers.  The client then selectively\n   authorizes other clients to download\
    \ these data objects.  Such a\n   system is employed in an overall application\
    \ context (e.g., P2P file\n   sharing), and it is expected that DECADE clients\
    \ take part in\n   application-specific communication sessions.\n   Figure 1 is\
    \ a schematic of a simple DECADE system with two DECADE\n   clients and two DECADE\
    \ servers.  As illustrated, a DECADE client,\n   which is part of an Application\
    \ Endpoint, uses the DECADE Resource\n   Protocol (DRP) to convey to a server\
    \ information related to access\n   control and resource-scheduling policies.\
    \  DRP can also be used\n   between servers for exchanging this type of information.\
    \  A DECADE\n   system employs the Standard Data Transfer (SDT) protocol to transfer\n\
    \   data objects to and from a server, as we will explain later.\n           \
    \              Native Application\n                          Protocol(s)\n   \
    \      .-------------.   (e.g., P2P)        .-------------.\n         | Application\
    \ | <------------------> | Application |\n         |  Endpoint   |           \
    \           |  Endpoint   |\n         |             |                      | \
    \            |\n         | .--------.  |                      | .--------.  |\n\
    \         | | DECADE |  |                      | | DECADE |  |\n         | | Client\
    \ |  |                      | | Client |  |\n         | `--------'  |        \
    \              | `--------'  |\n         `-------------'                     \
    \ `-------------'\n             |     ^                              |     ^\n\
    \     DECADE  |     | Standard                     |     |\n    Resource |   \
    \  |   Data                   DRP |     | SDT\n    Protocol |     | Transfer \
    \                    |     |\n     (DRP)   |     |   (SDT)                   \
    \   |     |\n             |     |                              |     |\n     \
    \        |     |                              |     |\n             |     |  \
    \                            |     |\n             |     |                   \
    \           |     |\n             |     |                              |     |\n\
    \             |     |                              |     |\n             v   \
    \  v                              v     v\n         .=============.         DRP\
    \          .=============.\n         |   DECADE    | <------------------> |  \
    \ DECADE    |\n         |   Server    | <------------------> |   Server    |\n\
    \         `============='         SDT          `============='\n             \
    \            Figure 1: DECADE Overview\n   With Figure 1 at hand, assume that\
    \ Application Endpoint B requests a\n   data object from Application Endpoint\
    \ A using their native\n   application protocols (e.g., P2P protocol) as in Figure\
    \ 2.  In this\n   case, Endpoint A will act as the sender, and Endpoint B as the\n\
    \   receiver for said data object.  S(A) is the DECADE storage server\n   which\
    \ is access controlled.  This means, first, that Endpoint A has a\n   right to\
    \ store the data object in S(A).  Secondly, Endpoint B needs\n   to obtain authorization\
    \ before being able to retrieve the data object\n   from S(A).\n   The four steps\
    \ involved in a DECADE session are illustrated in\n   Figure 2.  The sequence\
    \ starts with the initial contact between\n   Endpoint B and Endpoint A, where\
    \ Endpoint B requests a data object\n   using their native application protocol\
    \ (e.g., P2P).  Next, Endpoint\n   A uses DRP to obtain a token corresponding\
    \ to the data object that\n   was requested by Endpoint B.  There may be several\
    \ ways for Endpoint\n   A to obtain such a token, e.g., compute it locally or\
    \ request one\n   from its DECADE storage server, S(A).  Once obtained, Endpoint\
    \ A then\n   provides the token to Endpoint B (again, using their native\n   application\
    \ protocol).  Finally, Endpoint B provides the received\n   token to S(A) via\
    \ DRP, and subsequently requests and downloads the\n   data object via SDT.  Again,\
    \ it is assumed that DECADE is employed in\n   an overall application context\
    \ (e.g., P2P file-sharing session).\n   For completeness, note that there is an\
    \ important prerequisite step\n   (not shown) to Figure 2, where Endpoint A first\
    \ discovers and then\n   stores the data object(s) of interest in S(A).\n    \
    \                           .----------.\n      2. Obtain      --------> |   S(A)\
    \   | <------\n         Token      /          `----------'        \\   4. Request\
    \ and\n         (DRP)     /                                \\     Download\n \
    \        Locally  /                                  \\    Data Object\n     \
    \    or From /                                    \\   (DRP + SDT)\n         S(A)\
    \   v          1. App Request              v\n       .-------------. <---------------------------\
    \ .-------------.\n       | Application |                              | Application\
    \ |\n       | Endpoint A  |                              | Endpoint B  |\n   \
    \    `-------------' ---------------------------> `-------------'\n          \
    \                3. App Response (token)\n                  Figure 2: Download\
    \ from Storage Server\n"
- title: 4.  Architectural Principles
  contents:
  - "4.  Architectural Principles\n   This section presents the key principles followed\
    \ by any DECADE\n   system.\n"
- title: 4.1.  Data- and Control-Plane Decoupling
  contents:
  - "4.1.  Data- and Control-Plane Decoupling\n   DECADE SDT and DRP can be classified\
    \ as belonging to data-plane\n   functionality.  The algorithms and signaling\
    \ for a P2P application,\n   for example, would belong to control-plane functionality.\n\
    \   A DECADE system aims to be application independent and should support\n  \
    \ multiple content distribution applications.  Typically, a complete\n   content\
    \ distribution application implements a set of control-plane\n   functions including\
    \ content search, indexing and collection, access\n   control, replication, request\
    \ routing, and QoS scheduling.\n   Implementers of different content distribution\
    \ applications may have\n   unique considerations when designing the control-plane\
    \ functions.\n   For example, with respect to the metadata management scheme,\n\
    \   traditional file systems provide a standard metadata abstraction: a\n   recursive\
    \ structure of directories to offer namespace management\n   where each file is\
    \ an opaque byte stream.  Content distribution\n   applications may use different\
    \ metadata management schemes.  For\n   instance, one application might use a\
    \ sequence of blocks (e.g., for\n   file sharing), while another application might\
    \ use a sequence of\n   frames (with different sizes) indexed by time.\n   With\
    \ respect to resource-scheduling algorithms, a major advantage of\n   many successful\
    \ P2P systems is their substantial expertise in\n   achieving efficient utilization\
    \ of peer resources.  For instance,\n   many streaming P2P systems include optimization\
    \ algorithms for\n   constructing overlay topologies that can support low-latency,\
    \ high-\n   bandwidth streaming.  The research community as well as implementers\n\
    \   of such systems continuously fine-tune existing algorithms and invent\n  \
    \ new ones.  A DECADE system should be able to accommodate and benefit\n   from\
    \ all new developments.\n   In short, given the diversity of control-plane functions,\
    \ a DECADE\n   system should allow for as much flexibility as possible to the\n\
    \   control plane to implement specific policies (and be decoupled from\n   data-plane\
    \ DRP/SDT).  Decoupling the control plane from the data\n   plane is not new,\
    \ of course.  For example, OpenFlow [OpenFlow] is an\n   implementation of this\
    \ principle for Internet routing, where the\n   computation of the forwarding\
    \ table and the application of the\n   forwarding table are separated.  The Google\
    \ File System\n   [GoogleFileSystem] applies the same principle to file system\
    \ design\n   by utilizing a Master to handle metadata management and several Chunk\n\
    \   servers to handle data-plane functions (i.e., read and write of\n   chunks\
    \ of data).  Finally, NFSv4.1's parallel NFS (pNFS) extension\n   [RFC5661] also\
    \ adheres to this principle.\n"
- title: 4.2.  Immutable Data Objects
  contents:
  - "4.2.  Immutable Data Objects\n   A common property of bulk content to be broadly\
    \ distributed is that\n   it is immutable -- once content is generated, it is\
    \ typically not\n   modified.  For example, once a movie has been edited and released\
    \ for\n   distribution, it is very uncommon that the corresponding video frames\n\
    \   and images need to be modified.  The same applies to document\n   distribution,\
    \ such as RFCs; audio files, such as podcasts; and\n   program patches.  Focusing\
    \ on immutable data can substantially\n   simplify data-plane design, since consistency\
    \ requirements can be\n   relaxed.  It also simplifies data reuse and the removal\
    \ of\n   duplicates.\n   Depending on its specific requirements, an application\
    \ may store\n   immutable data objects in DECADE servers such that each data object\n\
    \   is completely self-contained (e.g., a complete, independently\n   decodable\
    \ video segment).  An application may also divide data into\n   data objects that\
    \ require application-level assembly.  Many content\n   distribution applications\
    \ divide bulk content into data objects for\n   multiple reasons, including (a)\
    \ fetching different data objects from\n   different sources in parallel and (b)\
    \ faster recovery and\n   verification as individual data objects might be recovered\
    \ and\n   verified.  Typically, applications use a data object size larger than\n\
    \   a single packet in order to reduce control overhead.\n   A DECADE system should\
    \ be agnostic to the nature of the data objects\n   and should not specify a fixed\
    \ size for them.  A protocol\n   specification based on this architecture may\
    \ prescribe requirements\n   on minimum and maximum sizes for compliant implementations.\n\
    \   Note that immutable data objects can still be deleted.  Applications\n   can\
    \ support modification of existing data stored at a DECADE server\n   through\
    \ a combination of storing new data objects and deleting\n   existing data objects.\
    \  For example, a metadata management function\n   of the control plane might\
    \ associate a name with a sequence of\n   immutable data objects.  If one of the\
    \ data objects is modified, the\n   meta-data management function changes the\
    \ mapping of the name to a\n   new sequence of immutable data objects.\n"
- title: 4.3.  Data Object Identifiers
  contents:
  - "4.3.  Data Object Identifiers\n   A data object stored in a DECADE server shall\
    \ be accessed by DECADE\n   clients via a data object identifier.  Each DECADE\
    \ client may be able\n   to access more than one storage server.  A data object\
    \ that is\n   replicated across different storage servers managed by a storage\n\
    \   provider may be accessed through a single identifier.  Since data\n   objects\
    \ are immutable, it shall be possible to support persistent\n   identifiers for\
    \ data objects.\n   Data object identifiers should be created by DECADE clients\
    \ when\n   uploading the corresponding objects to a DECADE server.  The scheme\n\
    \   for the assignment/derivation of the data object identifier to a data\n  \
    \ object depends as the data object naming scheme and is out of scope\n   of this\
    \ document.  One possibility is to name data objects using\n   hashes as described\
    \ in [RFC6920].  Note that [RFC6920] describes\n   naming schemes on a semantic\
    \ level only, but specific SDTs and DRPs\n   use specific representations.\n \
    \  In particular, for some applications, it is important that clients\n   and\
    \ servers be able to validate the name-object binding, i.e., by\n   verifying\
    \ that a received object really corresponds to the name\n   (identifier) that\
    \ was used for requesting it (or that was provided by\n   a sender).  If a specific\
    \ application requires name-object binding\n   validation, the data object identifiers\
    \ can support it by providing\n   message digests or so-called self-certifying\
    \ naming information.\n   Different name-object binding validation mechanisms\
    \ may be supported\n   in a single DECADE system.  Content distribution applications\
    \ can\n   decide what mechanism to use, or to not provide name-object\n   validation\
    \ (e.g., if authenticity and integrity can by ascertained by\n   alternative means).\
    \  We expect that applications may be able to\n   construct unique names (with\
    \ high probability) without requiring a\n   registry or other forms of coordination.\
    \  Names may be self-\n   describing so that a receiving DECADE client understands,\
    \ for\n   example, which hash function to use for validating name-object\n   binding.\n\
    \   Some content distribution applications will derive the name of a data\n  \
    \ object from the hash over the data object; this is made possible by\n   the\
    \ fact that DECADE objects are immutable.  But there may be other\n   applications\
    \ such as live streaming where object names will not based\n   on hashes but rather\
    \ on an enumeration scheme.  The naming scheme\n   will also enable those applications\
    \ to construct unique names.\n   In order to enable the uniqueness, flexibility\
    \ and self-describing\n   properties, the naming scheme used in a DECADE system\
    \ should provide\n   a \"type\" field that indicates the name-object validation\
    \ function\n   type (for example, \"sha-256\" [RFC5754]) and the cryptographic\
    \ data\n   (such as an object hash) that corresponds to the type information.\n\
    \   Moreover, the naming scheme may additionally provide application or\n   publisher\
    \ information.\n"
- title: 4.4.  Explicit Control
  contents:
  - "4.4.  Explicit Control\n   To support the functions of an application's control\
    \ plane,\n   applications should be able to keep track and coordinate which data\n\
    \   is stored at particular servers.  Thus, in contrast with traditional\n   caches,\
    \ applications are given explicit control over the placement\n   (selection of\
    \ a DECADE server), deletion (or expiration policy), and\n   access control for\
    \ stored data objects.  Consider deletion/expiration\n   policy as a simple example.\
    \  An application might require that a\n   DECADE server stores data objects for\
    \ a relatively short period of\n   time (e.g., for live-streaming data).  Another\
    \ application might need\n   to store data objects for a longer duration (e.g.,\
    \ for video on\n   demand), and so on.\n"
- title: 4.5.  Resource and Data Access Control through Delegation
  contents:
  - "4.5.  Resource and Data Access Control through Delegation\n   A DECADE system\
    \ provides a shared infrastructure to be used by\n   multiple Application Endpoints.\
    \  Thus, it needs to provide both\n   resource and data access control, as discussed\
    \ in the following\n   subsections.\n"
- title: 4.5.1.  Resource Allocation
  contents:
  - "4.5.1.  Resource Allocation\n   There are two primary interacting entities in\
    \ a DECADE system.\n   First, storage providers coordinate DECADE server provisioning,\n\
    \   including their total available resources.  Second, applications\n   coordinate\
    \ data transfers amongst available DECADE servers and\n   between servers and\
    \ clients.  A form of isolation is required to\n   enable each of the concurrently\
    \ running applications to explicitly\n   manage its own data objects and share\
    \ of resources at the available\n   servers.  Therefore, a storage provider should\
    \ delegate resource\n   management on a DECADE server to uploading DECADE clients,\
    \ enabling\n   them to explicitly and independently manage their own share of\n\
    \   resources on a server.\n"
- title: 4.5.2.  User Delegation
  contents:
  - "4.5.2.  User Delegation\n   DECADE storage providers will have the ability to\
    \ explicitly manage\n   the entities allowed to utilize the resources available\
    \ on a DECADE\n   server.  This is needed for reasons such as capacity-planning\
    \ and\n   legal considerations in certain deployment scenarios.  The DECADE\n\
    \   server should grant a share of the resources to a DECADE client.  The\n  \
    \ client can in turn share the granted resources amongst its (possibly)\n   multiple\
    \ applications.  The share of resources granted by a server is\n   called a User\
    \ Delegation.  As a simple example, a DECADE server\n   operated by an ISP might\
    \ be configured to grant each ISP subscriber\n   1.5 Mbit/s of network capacity\
    \ and 1 GB of memory.  The ISP\n   subscriber might in turn divide this share\
    \ of resources amongst a\n   video-streaming application and file-sharing application\
    \ that are\n   running concurrently.\n"
- title: 5.  System Components
  contents:
  - "5.  System Components\n   As noted earlier, the primary focus of this document\
    \ is the\n   architectural principles and the system components that implement\n\
    \   them.  While specific system components might differ between\n   implementations,\
    \ this document details the major components and their\n   overall roles in the\
    \ architecture.  To keep the scope narrow, we only\n   discuss the primary components\
    \ related to protocol development.\n   Particular deployments will require additional\
    \ components (e.g.,\n   monitoring and accounting at a server), but they are intentionally\n\
    \   omitted from this document.\n"
- title: 5.1.  Application Endpoint
  contents:
  - "5.1.  Application Endpoint\n   Content distribution applications have many functional\
    \ components.\n   For example, many P2P applications have components and algorithms\
    \ to\n   manage overlay topology, rate allocation, piece selection, and so on.\n\
    \   In this document, we focus on the components directly engaged in a\n   DECADE\
    \ system.  Figure 3 illustrates the components discussed in this\n   section from\
    \ the perspective of a single Application Endpoint.\n                        \
    \       Native Application Protocol(s)\n                            (with other\
    \ Application Endpoints)\n                                    .--------------------->\n\
    \                                    |\n                                    V\n\
    \   .----------------------------------------------------------------.\n   | Application\
    \ Endpoint                                           |\n   | .-------------------.\
    \          .-------------------.           |\n   | | Application-Layer |   ...\
    \    | App Data Assembly |           |\n   | |    Algorithms     |          |\
    \    Sequencing     |           |\n   | `-------------------'          `-------------------'\
    \           |\n   |                                                          \
    \      |\n   |  .==========================================================. \
    \ |\n   |  | DECADE Client                                            |  |\n \
    \  |  | .-------------------------. .--------------------------. |  |\n   |  |\
    \ | Resource Controller     | | Data Controller          | |  |\n   |  | | .--------.\
    \ .----------. | | .------------. .-------. | |  |\n   |  | | |  Data  | | Resource-|\
    \ | | |    Data    | | Data  | | |  |\n   |  | | | Access | | Sharing  | | | |\
    \ Scheduling | | Index | | |  |\n   |  | | | Policy | |  Policy  | | | |     \
    \       | |       | | |  |\n   |  | | `--------' `----------' | | `------------'\
    \ `-------' | |  |\n   |  | `-------------------------' `--------------------------'\
    \ |  |\n   |  |   |                                ^                     |  |\n\
    \   |  `== | ============================== | ===================='  |\n   `-----\
    \ | ------------------------------ | -----------------------'\n          |   \
    \                             |\n          | DECADE Resource Protocol       |\
    \ Standard Data Transfer\n          |    (DRP)                       |    (SDT)\n\
    \          v                                V\n            Figure 3: Application\
    \ and DECADE Client Components\n   A DECADE system is geared towards supporting\
    \ applications that can\n   distribute content using data objects (e.g., P2P).\
    \  To accomplish\n   this, applications can include a component responsible for\
    \ creating\n   the individual data objects before distribution and for reassembling\n\
    \   them later.  We call this component Application Data Assembly.  In\n   producing\
    \ and assembling data objects, two important considerations\n   are sequencing\
    \ and naming.  A DECADE system assumes that applications\n   implement this functionality\
    \ themselves.  In addition to DECADE\n   DRP/SDT, applications will most likely\
    \ also support other, native\n   application protocols (e.g., P2P control and\
    \ data transfer\n   protocols).\n"
- title: 5.2.  DECADE Client
  contents:
  - "5.2.  DECADE Client\n   The DECADE client provides the local support to an application,\
    \ and\n   it can be implemented standalone, embedded into the application, or\n\
    \   integrated in other software entities within network devices (i.e.,\n   hosts).\
    \  In general, applications may have different resource-sharing\n   policies and\
    \ data access policies with regard to DECADE servers.\n   These policies may be\
    \ existing policies of applications or custom\n   policies.  The specific implementation\
    \ is decided by the application.\n   Recall that DECADE decouples the control\
    \ and the data transfer of\n   applications.  A data-scheduling component schedules\
    \ data transfers\n   according to network conditions, available servers, and/or\
    \ available\n   server resources.  The Data Index indicates data available at\
    \ remote\n   servers.  The Data Index (or a subset of it) can be advertised to\n\
    \   other clients.  A common use case for this is to provide the ability\n   to\
    \ locate data amongst distributed Application Endpoints (i.e., a\n   data search\
    \ mechanism such as a Distributed Hash Table (DHT)).\n"
- title: 5.3.  DECADE Server
  contents:
  - "5.3.  DECADE Server\n   Figure 4 illustrates the primary components of a DECADE\
    \ server.  Note\n   that the description below does not assume a single-host or\n\
    \   centralized implementation -- a DECADE server is not necessarily a\n   single\
    \ physical machine; it can also be implemented in a distributed\n   manner on\
    \ a cluster of machines.\n          | DECADE Resource   | Standard Data\n    \
    \      | Protocol (DRP)    | Transfer (SDT)\n          |                   |\n\
    \       .= | ================= | ===========================.\n       |  |   \
    \                v              DECADE Server |\n       |  |      .----------------.\
    \                        |\n       |  |----> | Access Control | <--------.   \
    \          |\n       |  |      `----------------'          |             |\n \
    \      |  |                   ^              |             |\n       |  |    \
    \               |              |             |\n       |  |                  \
    \ v              |             |\n       |  |   .---------------------.      \
    \  |             |\n       |  `-> | Resource Scheduling | <------|           \
    \  |\n       |      `---------------------'        |             |\n       | \
    \                     ^              |             |\n       |               \
    \       |              |             |\n       |                      v      \
    \  .-----------------. |\n       |        .-----------------.    | User Delegation\
    \ | |\n       |        |    Data Store   |    |   Management    | |\n       |\
    \        `-----------------'    `-----------------' |\n       `==================================================='\n\
    \                    Figure 4: DECADE Server Components\n   Provided sufficient\
    \ authorization, a client shall be able to access\n   its own data or other client's\
    \ data in a DECADE server.  Clients may\n   also authorize other clients to store\
    \ data.  If access is authorized\n   by a client, the server should provide access.\
    \  Applications may\n   apply resource-sharing policies or use a custom policy.\
    \  DECADE\n   servers will then perform resource scheduling according to the\n\
    \   resource-sharing policies indicated by the client as well as any\n   other\
    \ previously configured User Delegations.  Data from applications\n   will be\
    \ stored at a DECADE server.  Data may be deleted from storage\n   either explicitly\
    \ or automatically (e.g., after a Time To Live (TTL)\n   expiration).\n"
- title: 5.4.  Data Sequencing and Naming
  contents:
  - "5.4.  Data Sequencing and Naming\n   The DECADE naming scheme implies no sequencing\
    \ or grouping of\n   objects, even if this is done at the application layer. \
    \ To\n   illustrate these properties, this section presents several examples\n\
    \   of use.\n"
- title: 5.4.1.  Application with Fixed-Size Chunks
  contents:
  - "5.4.1.  Application with Fixed-Size Chunks\n   Consider an application in which\
    \ each individual application-layer\n   segment of data is called a \"chunk\"\
    \ and has a name of the form:\n   \"CONTENT_ID:SEQUENCE_NUMBER\".  Furthermore,\
    \ assume that the\n   application's native protocol uses chunks of size 16 KB.\
    \  Now, assume\n   that this application wishes to store data in a DECADE server\
    \ in data\n   objects of size 64 KB.  To accomplish this, it can map a sequence\
    \ of\n   4 chunks into a single data object, as shown in Figure 5.\n     Application\
    \ Chunks\n   .---------.---------.---------.---------.---------.---------.--------\n\
    \   |         |         |         |         |         |         |\n   | Chunk_0\
    \ | Chunk_1 | Chunk_2 | Chunk_3 | Chunk_4 | Chunk_5 | Chunk_6\n   |         |\
    \         |         |         |         |         |\n   `---------`---------`---------`---------`---------`---------`--------\n\
    \     DECADE Data Objects\n   .---------------------------------------.----------------------------\n\
    \   |                                       |\n   |               Object_0   \
    \             |               Object_1\n   |                                 \
    \      |\n   `---------------------------------------`----------------------------\n\
    \        Figure 5: Mapping Application Chunks to DECADE Data Objects\n   In this\
    \ example, the application maintains a logical mapping that is\n   able to determine\
    \ the name of a DECADE data object given the chunks\n   contained within that\
    \ data object.  The name may be conveyed from\n   either the original uploading\
    \ DECADE client, another Endpoint with\n   which the application is communicating,\
    \ etc.  As long as the data\n   contained within each sequence of chunks is globally\
    \ unique, the\n   corresponding data objects have globally unique names.\n"
- title: 5.4.2.  Application with Continuous Streaming Data
  contents:
  - "5.4.2.  Application with Continuous Streaming Data\n   Consider an application\
    \ whose native protocol retrieves a continuous\n   data stream (e.g., an MPEG2\
    \ stream) instead of downloading and\n   redistributing chunks of data.  Such\
    \ an application could segment the\n   continuous data stream to produce either\
    \ fixed-sized or variable-\n   sized data objects.  Figure 6 depicts how a video\
    \ streaming\n   application might produce variable-sized data objects such that\
    \ each\n   data object contains 10 seconds of video data.  In a manner similar\n\
    \   to the previous example, the application may maintain a mapping that\n   is\
    \ able to determine the name of a data object given the time offset\n   of the\
    \ video chunk.\n     Application's Video Stream\n   .--------------------------------------------------------------------\n\
    \   |\n   |\n   |\n   `--------------------------------------------------------------------\n\
    \   ^              ^              ^              ^              ^\n   |      \
    \        |              |              |              |\n   0 seconds     10 seconds\
    \     20 seconds     30 seconds     40 seconds\n   0 B          400 KB       \
    \  900 KB        1200 KB        1500 KB\n     DECADE Data Objects\n   .--------------.--------------.--------------.--------------.--------\n\
    \   |              |              |              |              |\n   |   Object_0\
    \   |   Object_1   |   Object_2   |   Object_3   |\n   |   (400 KB)   |   (500\
    \ KB)   |   (300 KB)   |   (300 KB)   |\n   `--------------`--------------`--------------`--------------`--------\n\
    \     Figure 6: Mapping a Continuous Data Stream to DECADE Data Objects\n"
- title: 5.5.  Token-Based Authorization and Resource Control
  contents:
  - "5.5.  Token-Based Authorization and Resource Control\n   A key feature of a DECADE\
    \ system is that an Application Endpoint can\n   authorize other Application Endpoints\
    \ to store or retrieve data\n   objects from its in-network storage via tokens.\
    \  The peer client then\n   uses the token when sending requests to the DECADE\
    \ server.  Upon\n   receiving a token, the server validates the signature and\
    \ the\n   operation being performed.\n   This is a simple scheme, but has some\
    \ important advantages over an\n   alternative approach, for example, in which\
    \ a client explicitly\n   manipulates an Access Control List (ACL) associated\
    \ with each data\n   object.  In particular, it has the following advantages when\
    \ applied\n   to DECADE systems.  First, authorization policies are implemented\n\
    \   within the application, thus the Application Endpoint explicitly\n   controls\
    \ when tokens are generated, to whom they are distributed, and\n   for how long\
    \ they will be valid.  Second, fine-grained access and\n   resource control can\
    \ be applied to data objects.  Third, there is no\n   messaging between a client\
    \ and server to manipulate data object\n   permissions.  This can simplify, in\
    \ particular, applications that\n   share data objects with many dynamic peers\
    \ and need to frequently\n   adjust access control policies attached to data objects.\
    \  Finally,\n   tokens can provide anonymous access, in which a server does not\
    \ need\n   to know the identity of each client that accesses it.  This enables\
    \ a\n   client to send tokens to clients belonging to other storage\n   providers,\
    \ and to allow them to read or write data objects from the\n   storage of its\
    \ own storage provider.  In addition to clients' ability\n   to apply access control\
    \ policies to data objects, the server may be\n   configured to apply additional\
    \ policies based on user, object\n   properties, geographic location, etc.  A\
    \ client might thus be denied\n   access even though it possesses a valid token.\n"
- title: 5.6.  Discovery
  contents:
  - "5.6.  Discovery\n   A DECADE system should include a discovery mechanism through\
    \ which\n   DECADE clients locate an appropriate DECADE server.  A discovery\n\
    \   mechanism should allow a client to determine an IP address or some\n   other\
    \ identifier that can be resolved to locate the server for which\n   the client\
    \ will be authorized to generate tokens (via DRP).  (The\n   discovery mechanism\
    \ might also result in an error if no such servers\n   can be located.)  After\
    \ discovering one or more servers, a DECADE\n   client can distribute load and\
    \ requests across them (subject to\n   resource limitations and policies of the\
    \ servers themselves)\n   according to the policies of the Application Endpoint\
    \ in which it is\n   embedded.  The discovery mechanism outlined here does not\
    \ provide the\n   ability to locate arbitrary DECADE servers to which a client\
    \ might\n   obtain tokens from others.  To do so will require application-level\n\
    \   knowledge, and it is assumed that this functionality is implemented\n   in\
    \ the content distribution application.\n   As noted above, the discovered DECADE\
    \ server should be authorized to\n   allow the client to store data objects and\
    \ then generate tokens to\n   allow other clients to retrieve these data objects.\
    \  This\n   authorization may be:\n   -  a result of off-line administrative procedures;\n\
    \   -  access network dependent (e.g., all the subscribers to a\n      particular\
    \ ISP may be allowed by the ISP);\n   -  due to a prior subscription;\n   -  etc.\n\
    \   The particular protocol used for discovery is out of scope of this\n   document,\
    \ but any specification should reuse well-known protocols\n   wherever possible.\n"
- title: 6.  DECADE Protocol Considerations
  contents:
  - "6.  DECADE Protocol Considerations\n   This section presents the DRP and the\
    \ SDT protocol in terms of\n   abstract protocol interactions that are intended\
    \ to be mapped to\n   specific protocols in an implementation.  In general, the\
    \ DRP/SDT\n   functionality for DECADE client-server interaction is very similar\
    \ to\n   that for server-server interaction.  Any differences are highlighted\n\
    \   below.  DRP is used by a DECADE client to configure the resources and\n  \
    \ authorization used to satisfy requests (reading, writing, and\n   management\
    \ operations concerning data objects) at a server.  SDT will\n   be used to transport\
    \ data between a client and a server, as\n   illustrated in Figure 1.\n"
- title: 6.1.  Naming
  contents:
  - "6.1.  Naming\n   A DECADE system SHOULD use [RFC6920] as the recommended and\
    \ default\n   naming scheme.  Other naming schemes that meet the guidelines in\n\
    \   Section 4.3 MAY alternatively be used.  In order to provide a simple\n   and\
    \ generic interface, the DECADE server will be responsible only for\n   storing\
    \ and retrieving individual data objects.\n   The DECADE naming format SHOULD\
    \ NOT attempt to replace any naming or\n   sequencing of data objects already\
    \ performed by an application.\n   Instead, naming is intended to apply only to\
    \ data objects referenced\n   by DECADE-specific purposes.  An application using\
    \ a DECADE client\n   may use a naming and sequencing scheme independent of DECADE\
    \ names.\n   The DECADE client SHOULD maintain a mapping from its own data objects\n\
    \   and their names to the DECADE-specific data objects and names.\n   Furthermore,\
    \ the DECADE naming scheme implies no sequencing or\n   grouping of objects, even\
    \ if this is done at the application layer.\n"
- title: 6.2.  Resource Protocol
  contents:
  - "6.2.  Resource Protocol\n   DRP will provide configuration of access control\
    \ and resource-sharing\n   policies on DECADE servers.  A content distribution\
    \ application\n   (e.g., a live P2P streaming session) can have permission to\
    \ manage\n   data at several servers, for instance, servers belonging to different\n\
    \   storage providers.  DRP allows one instance of such an application,\n   i.e.,\
    \ an Application Endpoint, to apply access control and resource-\n   sharing policies\
    \ on each of them.\n   On a single DECADE server, the following resources SHOULD\
    \ be managed:\n   a) communication resources in terms of bandwidth (upload/download)\n\
    \   and also in terms of number of active clients (simultaneous\n   connections);\
    \ and b) storage resources.\n"
- title: 6.2.1.  Access and Resource Control Token
  contents:
  - "6.2.1.  Access and Resource Control Token\n   The tokens SHOULD be generated\
    \ by an entity trusted by both the\n   DECADE client and the server at the request\
    \ of a DECADE client.  For\n   example, this entity could be the client, a server\
    \ trusted by the\n   client, or another server managed by a storage provider and\
    \ trusted\n   by the client.  It is important for a server to trust the entity\n\
    \   generating the tokens since each token may incur a resource cost on\n   the\
    \ server when used.  Likewise, it is important for a client to\n   trust the entity\
    \ generating the tokens since the tokens grant access\n   to the data stored at\
    \ the server.\n   The token does not normally include information about the identity\
    \ of\n   the authorized client (i.e., it is typically an anonymous token).\n \
    \  However, it is not prohibited to have a binding of the token to an\n   identity\
    \ if desired (e.g., binding of the token to the IP address of\n   the authorized\
    \ party).\n   Upon generating a token, a DECADE client can distribute it to another\n\
    \   client.  Token confidentiality SHOULD be provided by whatever\n   protocol\
    \ it is carried in (i.e., Application Protocol, DRP, or SDT).\n   The receiving\
    \ client can then connect to the server specified in the\n   token and perform\
    \ any operation permitted by the token.  The token\n   SHOULD be sent along with\
    \ the operation.  The server SHOULD validate\n   the token to identify the client\
    \ that issued it and whether the\n   requested operation is permitted by the contents\
    \ of the token.  If\n   the token is successfully validated, the server SHOULD\
    \ apply the\n   resource control policies indicated in the token while performing\
    \ the\n   operation.\n   Tokens SHOULD include a unique identifier to allow a\
    \ server to detect\n   when a token is used multiple times and reject the additional\
    \ usage\n   attempts.  Since usage of a token incurs resource costs to a server\n\
    \   (e.g., bandwidth and storage) and an uploading DECADE client may have\n  \
    \ a limited budget, the uploading DECADE client should be able to\n   indicate\
    \ if a token may be used multiple times.\n   It SHOULD be possible to revoke tokens\
    \ after they are generated.\n   This could be accomplished by supplying the server\
    \ the unique\n   identifiers of the tokens that are to be revoked.\n"
- title: 6.2.2.  Status Information
  contents:
  - "6.2.2.  Status Information\n   DRP SHOULD provide a status request service that\
    \ clients can use to\n   request status information of a server.  Access to such\
    \ status\n   information SHOULD require client authorization; that is, clients\n\
    \   need to be authorized to access the requested status information.\n   This\
    \ authorization is based on the user delegation concept as\n   described in Section\
    \ 4.5.  The following status information elements\n   SHOULD be obtained: a) list\
    \ of associated data objects (with\n   properties); and b) resources used/available.\
    \  In addition, the\n   following information elements MAY be available: c) list\
    \ of servers\n   to which data objects have been distributed (in a certain time\n\
    \   frame); and d) list of clients to which data objects have been\n   distributed\
    \ (in a certain time frame).\n   For the list of servers/clients to which data\
    \ objects have been\n   distributed to, the server SHOULD be able to decide on\
    \ time bounds\n   for which this information is stored and specify the corresponding\n\
    \   time frame in the response to such requests.  Some of this\n   information\
    \ may be used for accounting purposes, e.g., the list of\n   clients to which\
    \ data objects have been distributed.\n   Access information MAY be provided for\
    \ accounting purposes, for\n   example, when uploading DECADE clients are interested\
    \ in access\n   statistics for resources and/or to perform accounting per user.\n\
    \   Again, access to such information requires client authorization and\n   SHOULD\
    \ be based on the delegation concept as described in\n   Section 4.5.  The following\
    \ type of access information elements MAY\n   be requested: a) what data objects\
    \ have been accessed by whom and how\n   many times; and b) access tokens that\
    \ a server has seen for a given\n   data object.\n   The server SHOULD decide\
    \ on time bounds for which this information is\n   stored and specify the corresponding\
    \ time frame in the response to\n   such requests.\n"
- title: 6.2.3.  Data Object Attributes
  contents:
  - "6.2.3.  Data Object Attributes\n   Data objects that are stored on a DECADE server\
    \ SHOULD have\n   associated attributes (in addition to the object identifier)\
    \ that\n   relate to the data storage and its management.  These attributes may\n\
    \   be used by the server (and possibly the underlying storage system) to\n  \
    \ perform specialized processing or handling for the data object, or to\n   attach\
    \ related server or storage-layer properties to the data object.\n   These attributes\
    \ have a scope local to a server.  In particular,\n   these attributes SHOULD\
    \ NOT be applied to a server or client to which\n   a data object is copied.\n\
    \   Depending on authorization, clients SHOULD be permitted to get or set\n  \
    \ such attributes.  This authorization is based on the delegation as\n   per Section\
    \ 4.5.  DECADE does not limit the set of permissible\n   attributes, but rather\
    \ specifies a set of baseline attributes that\n   SHOULD be supported:\n   Expiration\
    \ Time:  time at which the data object can be deleted\n   Data Object size:  in\
    \ bytes\n   Media type:  labeling of type as per [RFC6838]\n   Access statistics:\
    \  how often the data object has been accessed (and\n      what tokens have been\
    \ used)\n   The data object attributes defined here are distinct from application\n\
    \   metadata.  Application metadata is custom information that an\n   application\
    \ might wish to associate with a data object to understand\n   its semantic meaning\
    \ (e.g., whether it is video and/or audio, its\n   playback length in time, or\
    \ its index in a stream).  If an\n   application wishes to store such metadata\
    \ persistently, it can be\n   stored within data objects themselves.\n"
- title: 6.3.  Data Transfer
  contents:
  - "6.3.  Data Transfer\n   A DECADE server will provide a data access interface,\
    \ and SDT will be\n   used to write data objects to a server and to read (download)\
    \ data\n   objects from a server.  Semantically, SDT is a client-server\n   protocol;\
    \ that is, the server always responds to client requests.\n   To write a data\
    \ object, a client first generates the object's name\n   (see Section 6.1), and\
    \ then uploads the object to a server and\n   supplies the generated name.  The\
    \ name can be used to access\n   (download) the object later; for example, the\
    \ client can pass the\n   name as a reference to other clients that can then refer\
    \ to the\n   object.  Data objects can be self-contained objects such as\n   multimedia\
    \ resources, files, etc., but also chunks, such as chunks of\n   a P2P distribution\
    \ protocol that can be part of a containing object\n   or a stream.  If supported,\
    \ a server can verify the integrity and\n   other security properties of uploaded\
    \ objects.\n   A client can request named data objects from a server.  In a\n\
    \   corresponding request message, a client specifies the object name and\n  \
    \ a suitable access and resource control token.  The server checks the\n   validity\
    \ of the received token and its associated properties related\n   to resource\
    \ usage.  If the named data object exists on the server and\n   the token can\
    \ be validated, the server delivers the requested object\n   in a response message.\
    \  If the data object cannot be delivered, the\n   server provides a corresponding\
    \ status/reason information in a\n   response message.  Specifics regarding error\
    \ handling, including\n   additional error conditions (e.g., overload), precedence\
    \ for returned\n   errors and its relation with server policy, are deferred to\
    \ eventual\n   protocol specification.\n"
- title: 6.4.  Server-Server Protocols
  contents:
  - "6.4.  Server-Server Protocols\n   An important feature of a DECADE system is\
    \ the capability for one\n   server to directly download data objects from another\
    \ server.  This\n   capability allows applications to directly replicate data\
    \ objects\n   between servers without requiring end-hosts to use uplink capacity\
    \ to\n   upload data objects to a different server.\n   DRP and SDT SHOULD support\
    \ operations directly between servers.\n   Servers are not assumed to trust each\
    \ other nor are they configured\n   to do so.  All data operations are performed\
    \ on behalf of clients via\n   explicit instruction.  However, the objects being\
    \ processed do not\n   necessarily have to originate or terminate at the client\
    \ (i.e., the\n   data object might be limited to being exchanged between servers\
    \ even\n   if the instruction is triggered by the client).  Clients thus will\
    \ be\n   able to indicate to a server which remote server(s) to access, what\n\
    \   operation is to be performed, or in which server the object is to be\n   stored,\
    \ and the credentials indicating access and resource control to\n   perform the\
    \ operation at the remote server.\n   Server-server support is focused on reading\
    \ and writing data objects\n   between servers.  The data object referred to at\
    \ the remote server is\n   the same as the original data object requested by the\
    \ client.  Object\n   attributes might also be specified in the request to the\
    \ remote\n   server.  In this way, a server acts as a proxy for a client, and\
    \ a\n   client can instantiate requests via that proxy.  The operations will\n\
    \   be performed as if the original requester had its own client co-\n   located\
    \ with the server.  When a client sends a request to a server\n   with these additional\
    \ parameters, it is giving the server permission\n   to act (proxy) on its behalf.\
    \  Thus, it would be prudent for the\n   supplied token to have narrow privileges\
    \ (e.g., limited to only the\n   necessary data objects) or validity time (e.g.,\
    \ a small expiration\n   time).\n   In the case of a retrieval operation, the\
    \ server is to retrieve the\n   data object from the remote server using the specified\
    \ credentials,\n   and then optionally return the object to a client.  In the\
    \ case of a\n   storage operation, the server is to store the object to the remote\n\
    \   server using the specified credentials.  The object might optionally\n   be\
    \ uploaded from the client or might already exist at the server.\n"
- title: 6.5.  Potential DRP/SDT Candidates
  contents:
  - "6.5.  Potential DRP/SDT Candidates\n   Having covered the key DRP/SDT functionalities\
    \ above, it is useful to\n   consider some potential DRP/SDT candidates as guidance\
    \ for future\n   DECADE protocol implementations.  To recap, the DRP is a protocol\
    \ for\n   communication of access control and resource-scheduling policies from\n\
    \   a DECADE client to a DECADE server, or between DECADE servers.  The\n   SDT\
    \ is a protocol used to transfer data objects between a DECADE\n   client and\
    \ DECADE server, or between DECADE servers.  An evaluation\n   of existing protocols\
    \ for their suitability for DRP and SDT is given\n   in Appendix A.  Also, [INTEGRATION-EX]\
    \ provides some experimental\n   examples of how to integrate DECADE-like in-network\
    \ storage\n   infrastructure into P2P applications.\n"
- title: 7.  How In-Network Storage Components Map to DECADE
  contents:
  - "7.  How In-Network Storage Components Map to DECADE\n   This section evaluates\
    \ how the basic components of an in-network\n   storage system (see Section 3\
    \ of [RFC6392]) map into a DECADE system.\n   With respect to the data access\
    \ interface, DECADE clients can read\n   and write objects of arbitrary size through\
    \ the client's Data\n   Controller, making use of standard data transfer (SDT).\
    \  With respect\n   to data management operations, clients can move or delete\
    \ previously\n   stored objects via the client's Data Controller, making use of\
    \ SDT.\n   Clients can enumerate or search contents of servers to find objects\n\
    \   matching desired criteria through services provided by the content\n   distribution\
    \ application (e.g., buffer-map exchanges, a DHT, or peer\n   exchange).  In doing\
    \ so, Application Endpoints might consult their\n   local Data Index in the client's\
    \ Data Controller (Data Search\n   Capability).\n   With respect to access control\
    \ authorization, all methods of access\n   control are supported: public-unrestricted,\
    \ public-restricted, and\n   private.  Access control policies are generated by\
    \ a content\n   distribution application and provided to the client's Resource\n\
    \   Controller.  The server is responsible for implementing the access\n   control\
    \ checks.  Clients can manage the resources (e.g., bandwidth)\n   on the DECADE\
    \ server that can be used by other Application Endpoints\n   (Resource Control\
    \ Interface).  Resource-sharing policies are\n   generated by a content distribution\
    \ application and provided to the\n   client's Resource Controller.  The server\
    \ is responsible for\n   implementing the resource-sharing policies.\n   Although\
    \ the particular protocol used for discovery is outside the\n   scope of this\
    \ document, different options and considerations have\n   been discussed in Section\
    \ 5.6.  Finally, with respect to the storage\n   mode, DECADE servers provide\
    \ an object-based storage mode.  Immutable\n   data objects might be stored at\
    \ a server.  Applications might\n   consider existing blocks as data objects,\
    \ or they might adjust block\n   sizes before storing in a server.\n"
- title: 8.  Security Considerations
  contents:
  - "8.  Security Considerations\n   In general, the security considerations mentioned\
    \ in [RFC6646] apply\n   to this document as well.  A DECADE system provides a\
    \ distributed\n   storage service for content distribution and similar applications.\n\
    \   The system consists of servers and clients that use these servers to\n   upload\
    \ data objects, to request distribution of data objects, and to\n   download data\
    \ objects.  Such a system is employed in an overall\n   application context (for\
    \ example, in a P2P application), and it is\n   expected that DECADE clients take\
    \ part in application-specific\n   communication sessions.  The security considerations\
    \ here focus on\n   threats related to the DECADE system and its communication\
    \ services,\n   i.e., the DRP/SDT protocols that have been described in an abstract\n\
    \   fashion in this document.\n"
- title: '8.1.  Threat: System Denial-of-Service Attacks'
  contents:
  - "8.1.  Threat: System Denial-of-Service Attacks\n   A DECADE network might be\
    \ used to distribute data objects from one\n   client to a set of servers using\
    \ the server-server communication\n   feature that a client can request when uploading\
    \ an object.  Multiple\n   clients uploading many objects at different servers\
    \ at the same time\n   and requesting server-server distribution for them could\
    \ thus mount\n   massive distributed denial-of-service (DDOS) attacks, overloading\
    \ a\n   network of servers.  This threat is addressed by the server's access\n\
    \   control and resource control framework.  Servers can require\n   Application\
    \ Endpoints to be authorized to store and to download\n   objects, and Application\
    \ Endpoints can delegate authorization to\n   other Application Endpoints using\
    \ the token mechanism.  Of course the\n   effective security of this approach\
    \ depends on the strength of the\n   token mechanism.  See below for a discussion\
    \ of this and related\n   communication security threats.\n   Denial-of-service\
    \ attacks against a single server (directing many\n   requests to that server)\
    \ might still lead to considerable load for\n   processing requests and invalidating\
    \ tokens.  SDT therefore MUST\n   provide a redirection mechanism to allow requests\
    \ to other servers.\n   Analogous to how an HTTP reverse proxy can redirect and\
    \ load balance\n   across multiple HTTP origin servers [RFC2616].\n"
- title: '8.2.  Threat: Authorization Mechanisms Compromised'
  contents:
  - "8.2.  Threat: Authorization Mechanisms Compromised\n   A DECADE system does not\
    \ require Application Endpoints to\n   authenticate in order to access a server\
    \ for downloading objects,\n   since authorization is not based on Endpoint or\
    \ user identities but\n   on a delegation-based authorization mechanism.  Hence,\
    \ most protocol\n   security threats are related to the authorization scheme.\
    \  The\n   security of the token mechanism depends on the strength of the token\n\
    \   mechanism and on the secrecy of the tokens.  A token can represent\n   authorization\
    \ to store a certain amount of data, to download certain\n   objects, to download\
    \ a certain amount of data per time, etc.  If it\n   is possible for an attacker\
    \ to guess, construct, or simply obtain\n   tokens, the integrity of the data\
    \ maintained by the servers is\n   compromised.\n   This is a general security\
    \ threat that applies to authorization\n   delegation schemes.  Specifications\
    \ of existing delegation schemes\n   such as [RFC6749] discuss these general threats\
    \ in detail.  We can\n   say that the DRP has to specify appropriate algorithms\
    \ for token\n   generation.  Moreover, authorization tokens should have a limited\n\
    \   validity period that should be specified by the application.  Token\n   confidentiality\
    \ should be provided by application protocols that\n   carry tokens, and the SDT\
    \ and DRP should provide secure\n   (confidential) communication modes.\n"
- title: '8.3.  Threat: Spoofing of Data Objects'
  contents:
  - "8.3.  Threat: Spoofing of Data Objects\n   In a DECADE system, an Application\
    \ Endpoint is referring other\n   Application Endpoints to servers to download\
    \ a specified data object.\n   An attacker could \"inject\" a faked version of\
    \ the object into this\n   process, so that the downloading Endpoint effectively\
    \ receives a\n   different object (compared to what the uploading Endpoint provided).\n\
    \   As a result, the downloading Endpoint believes that is has received\n   an\
    \ object that corresponds to the name it was provided earlier,\n   whereas in\
    \ fact it is a faked object.  Corresponding attacks could be\n   mounted against\
    \ the application protocol (that is used for referring\n   other Endpoints to\
    \ servers), servers themselves (and their storage\n   subsystems), and the SDT\
    \ by which the object is uploaded,\n   distributed, and downloaded.\n   A DECADE\
    \ systems fundamental mechanism against object spoofing is\n   name-object binding\
    \ validation, i.e., the ability of a receiver to\n   check whether the name it\
    \ was provided and that it used to request an\n   object actually corresponds\
    \ to the bits it received.  As described\n   above, this allows for different\
    \ forms of name-object binding, for\n   example, using hashes of data objects,\
    \ with different hash functions\n   (different algorithms, different digest lengths).\
    \  For those\n   application scenarios where hashes of data objects are not applicable\n\
    \   (for example, live streaming), other forms of name-object binding can\n  \
    \ be used.  This flexibility also addresses cryptographic algorithm\n   evolution:\
    \ hash functions might get deprecated, better alternatives\n   might be invented,\
    \ etc., so that applications can choose appropriate\n   mechanisms that meet their\
    \ security requirements.\n   DECADE servers MAY perform name-object binding validation\
    \ on stored\n   objects, but Application Endpoints MUST NOT rely on that.  In\
    \ other\n   words, Application Endpoints SHOULD perform name-object binding\n\
    \   validation on received objects.\n"
- title: 9.  Acknowledgments
  contents:
  - "9.  Acknowledgments\n   We thank the following people for their contributions\
    \ to and/or\n   detailed reviews of this document or earlier drafts of this document:\n\
    \   Carlos Bernardos, Carsten Bormann, David Bryan, Dave Crocker, Yingjie\n  \
    \ Gu, David Harrington, Hongqiang (Harry) Liu, David McDysan, Borje\n   Ohlman,\
    \ Martin Stiemerling, Richard Woundy, and Ning Zong.\n"
- title: 10.  References
  contents:
  - '10.  References

    '
- title: 10.1.  Normative References
  contents:
  - "10.1.  Normative References\n   [RFC2119]  Bradner, S., \"Key words for use in\
    \ RFCs to Indicate\n              Requirement Levels\", BCP 14, RFC 2119, March\
    \ 1997.\n"
- title: 10.2.  Informative References
  contents:
  - "10.2.  Informative References\n   [RFC2616]  Fielding, R., Gettys, J., Mogul,\
    \ J., Frystyk, H.,\n              Masinter, L., Leach, P., and T. Berners-Lee,\
    \ \"Hypertext\n              Transfer Protocol -- HTTP/1.1\", RFC 2616, June 1999.\n\
    \   [RFC5661]  Shepler, S., Eisler, M., and D. Noveck, \"Network File\n      \
    \        System (NFS) Version 4 Minor Version 1 Protocol\", RFC\n            \
    \  5661, January 2010.\n   [RFC5754]  Turner, S., \"Using SHA2 Algorithms with\
    \ Cryptographic\n              Message Syntax\", RFC 5754, January 2010.\n   [RFC6392]\
    \  Alimi, R., Rahman, A., and Y. Yang, \"A Survey of In-\n              Network\
    \ Storage Systems\", RFC 6392, October 2011.\n   [RFC6646]  Song, H., Zong, N.,\
    \ Yang, Y., and R. Alimi, \"DECoupled\n              Application Data Enroute\
    \ (DECADE) Problem Statement\", RFC\n              6646, July 2012.\n   [RFC6749]\
    \  Hardt, D., \"The OAuth 2.0 Authorization Framework\", RFC\n              6749,\
    \ October 2012.\n   [RFC6838]  Freed, N., Klensin, J., and T. Hansen, \"Media\
    \ Type\n              Specifications and Registration Procedures\", BCP 13, RFC\n\
    \              6838, January 2013.\n   [RFC6920]  Farrell, S., Kutscher, D., Dannewitz,\
    \ C., Ohlman, B.,\n              Keranen, A., and P. Hallam-Baker, \"Naming Things\
    \ with\n              Hashes\", RFC 6920, April 2013.\n   [INTEGRATION-EX]\n \
    \             Zong, N., Ed., Chen, X., Huang, Z., Chen, L., and H. Liu,\n    \
    \          \"Integration Examples of DECADE System\", Work in Progress,\n    \
    \          August 2013.\n   [GoogleFileSystem]\n              Ghemawat, S., Gobioff,\
    \ H., and S. Leung, \"The Google File\n              System\", SOSP '03, Proceedings\
    \ of the 19th ACM Symposium\n              on Operating Systems Principles, October\
    \ 2003.\n   [GoogleStorageDevGuide]\n              Google, \"Google Cloud Storage\
    \ - Developer's Guide\",\n              <https://developers.google.com/storage/docs/\n\
    \              concepts-techniques>.\n   [OpenFlow]\n              Open Networking\
    \ Foundation, \"Software-Defined Networking:\n              The New Norm for Networks\"\
    , April 2013,\n              <https://www.opennetworking.org/images/stories/downloads/\n\
    \              sdn-resources/white-papers/wp-sdn-newnorm.pdf>.\n   [CDMI]    \
    \ Storage Networking Industry Association (SNIA), \"Cloud\n              Data\
    \ Management Interface (CDMI (TM)), Version 1.0.2\",\n              June 2012,\n\
    \              <http://snia.org/sites/default/files/CDMI%20v1.0.2.pdf>.\n"
- title: Appendix A.  Evaluation of Candidate Protocols for DECADE DRP/SDT
  contents:
  - "Appendix A.  Evaluation of Candidate Protocols for DECADE DRP/SDT\n   In this\
    \ section we evaluate how well the abstract protocol\n   interactions specified\
    \ in this document for DECADE DRP and SDT can be\n   fulfilled by the existing\
    \ protocols of HTTP, CDMI, and OAuth.\n"
- title: A.1.  HTTP
  contents:
  - "A.1.  HTTP\n   HTTP [RFC2616] is a key protocol for the Internet in general and\n\
    \   especially for the World Wide Web.  HTTP is a request-response\n   protocol.\
    \  A typical transaction involves a client (e.g., web\n   browser) requesting\
    \ content (resources) from a web server.  Another\n   example is when a client\
    \ stores or deletes content from a server.\n"
- title: A.1.1.  HTTP Support for DRP Primitives
  contents:
  - "A.1.1.  HTTP Support for DRP Primitives\n   DRP provides configuration of access\
    \ control and resource-sharing\n   policies on DECADE servers.\n"
- title: A.1.1.1.  Access Control Primitives
  contents:
  - "A.1.1.1.  Access Control Primitives\n   Access control requires mechanisms for\
    \ defining the access policies\n   for the server and then checking the authorization\
    \ of a user before\n   it stores or retrieves content.  HTTP supports a rudimentary\
    \ access\n   control via \"HTTP Secure\" (HTTPS).  HTTPS is a combination of HTTP\n\
    \   with SSL/TLS.  The main use of HTTPS is to authenticate the server\n   and\
    \ encrypt all traffic between the client and the server.  There is\n   also a\
    \ mode to support client authentication, though this is less\n   frequently used.\n"
- title: A.1.1.2.  Resource Control Primitives for Communication
  contents:
  - "A.1.1.2.  Resource Control Primitives for Communication\n   Communication resources\
    \ include bandwidth (upload/download) and the\n   number of simultaneously connected\
    \ clients (connections).  HTTP\n   supports bandwidth control indirectly through\
    \ \"persistent\" HTTP\n   connections.  Persistent HTTP connections allows a client\
    \ to keep\n   open the underlying TCP connection to the server to allow streaming\n\
    \   and pipelining (multiple simultaneous requests for a given client).\n   HTTP\
    \ does not have direct support for controlling the communication\n   resources\
    \ for a given client.  However, servers typically perform\n   this function via\
    \ implementation algorithms.\n"
- title: A.1.1.3.  Resource Control Primitives for Storage
  contents:
  - "A.1.1.3.  Resource Control Primitives for Storage\n   Storage resources include\
    \ the amount of memory and lifetime of\n   storage.  HTTP does not allow direct\
    \ control of storage at the server\n   endpoint.  However, HTTP supports caching\
    \ at intermediate points such\n   as a web proxy.  For this purpose, HTTP defines\
    \ cache control\n   mechanisms that define how long and in what situations the\n\
    \   intermediate point may store and use the content.\n"
- title: A.1.2.  HTTP Support for SDT Primitives
  contents:
  - "A.1.2.  HTTP Support for SDT Primitives\n   SDT is used to write objects and\
    \ read (download) objects from a\n   DECADE server.  The object can be either\
    \ a self-contained object such\n   as a multimedia file or a chunk from a P2P\
    \ system.\n"
- title: A.1.2.1.  Writing Primitives
  contents:
  - "A.1.2.1.  Writing Primitives\n   Writing involves uploading objects to the server.\
    \  HTTP supports two\n   methods of writing called PUT and POST.  In HTTP, the\
    \ object is\n   called a resource and is identified by a URI.  PUT uploads a resource\n\
    \   to a specific location on the server.  POST, on the other hand,\n   submits\
    \ the object to the server, and the server decides whether to\n   update an existing\
    \ resource or to create a new resource.\n   For DECADE, the choice of whether\
    \ to use PUT or POST will be\n   influenced by which entity is responsible for\
    \ the naming.  If the\n   client performs the naming, then PUT is appropriate.\
    \  If the server\n   performs the naming, then POST should be used (to allow the\
    \ server to\n   define the URI).\n"
- title: A.1.2.2.  Downloading Primitives
  contents:
  - "A.1.2.2.  Downloading Primitives\n   Downloading involves fetching of an object\
    \ from the server.  HTTP\n   supports downloading through the GET and HEAD methods.\
    \  GET fetches a\n   specific resource as identified by the URL.  HEAD is similar\
    \ but only\n   fetches the metadata (\"header\") associated with the resource,\
    \ not the\n   resource itself.\n"
- title: A.1.3.  Primitives for Removing Duplicate Traffic
  contents:
  - "A.1.3.  Primitives for Removing Duplicate Traffic\n   To challenge a remote entity\
    \ for an object, the DECADE server should\n   provide a seed number, which is\
    \ generated by the server randomly, and\n   ask the remote entity to return a\
    \ hash calculated from the seed\n   number and the content of the object.  The\
    \ server may also specify\n   the hash function that the remote entity should\
    \ use.  HTTP supports\n   the challenge message through the GET methods.  The\
    \ message type\n   (\"challenge\"), the seed number, and the hash function name\
    \ are put in\n   a URL.  In the reply, the hash is sent in an Entity Tag (ETag)\n\
    \   header.\n"
- title: A.1.4.  Other Operations
  contents:
  - "A.1.4.  Other Operations\n   HTTP supports deleting of content on the server\
    \ through the DELETE\n   method.\n"
- title: A.1.5.  Conclusions
  contents:
  - "A.1.5.  Conclusions\n   HTTP can provide a rudimentary DRP and SDT for some aspects\
    \ of\n   DECADE, but it will not be able to satisfy all the DECADE\n   requirements.\
    \  For example, HTTP does not provide a complete access\n   control mechanism\
    \ nor does it support storage resource controls at\n   the endpoint server.\n\
    \   It is possible, however, to envision combining HTTP with a custom\n   suite\
    \ of other protocols to fulfill most of the DECADE requirements\n   for DRP and\
    \ SDT.  For example, Google Storage for Developers is built\n   using HTTP (with\
    \ extensive proprietary extensions such as custom HTTP\n   headers).  Google Storage\
    \ also uses OAuth [RFC6749] (for access\n   control) in combination with HTTP\
    \ [GoogleStorageDevGuide].  An\n   example of using OAuth for DRP is given in\
    \ Appendix A.3.\n"
- title: A.2.  CDMI
  contents:
  - "A.2.  CDMI\n   The Cloud Data Management Interface (CDMI) specification defines\
    \ a\n   functional interface through which applications can store and manage\n\
    \   data objects in a cloud storage environment.  The CDMI interface for\n   reading/writing\
    \ data is based on standard HTTP requests, with CDMI-\n   specific encodings using\
    \ JavaScript Object Notation (JSON).  CDMI is\n   specified by the Storage Networking\
    \ Industry Association (SNIA)\n   [CDMI].\n"
- title: A.2.1.  CDMI Support for DRP Primitives
  contents:
  - "A.2.1.  CDMI Support for DRP Primitives\n   DRP provides configuration of access\
    \ control and resource-sharing\n   policies on DECADE servers.\n"
- title: A.2.1.1.  Access Control Primitives
  contents:
  - "A.2.1.1.  Access Control Primitives\n   Access control includes mechanisms for\
    \ defining the access policies\n   for the server and then checking the authorization\
    \ of a user before\n   allowing content storage or retrieval.  CDMI defines an\
    \ Access\n   Control List (ACL) per data object and thus supports access control\n\
    \   (read and/or write) at the granularity of data objects.  An ACL\n   contains\
    \ a set of Access Control Entries (ACEs), where each ACE\n   specifies a principal\
    \ (i.e., user or group of users) and a set of\n   privileges that are granted\
    \ to that principal.\n   CDMI requires that an HTTP authentication mechanism be\
    \ available for\n   the server to validate the identity of a principal (client).\n\
    \   Specifically, CDMI requires that either HTTP Basic Authentication or\n   HTTP\
    \ Digest Authentication be supported.  CDMI recommends that HTTP\n   over TLS\
    \ (HTTPS) is supported to encrypt the data sent over the\n   network.\n"
- title: A.2.1.2.  Resource Control Primitives for Communication
  contents:
  - "A.2.1.2.  Resource Control Primitives for Communication\n   Communication resources\
    \ include bandwidth (upload/download) and the\n   number of simultaneously connected\
    \ clients (connections).  CDMI\n   supports two key data attributes that provide\
    \ control over the\n   communication resources to a client: \"cdmi_max_throughput\"\
    \ and\n   \"cdmi_max_latency\".  These attributes are defined in the metadata\
    \ for\n   data objects and indicate the desired bandwidth or delay for\n   transmission\
    \ of the data object from the cloud server to the client.\n"
- title: A.2.1.3.  Resource Control Primitives for Storage
  contents:
  - "A.2.1.3.  Resource Control Primitives for Storage\n   Storage resources include\
    \ amount of quantity and lifetime of storage.\n   CDMI defines metadata for individual\
    \ data objects and general storage\n   system configuration that can be used for\
    \ storage resource control.\n   In particular, CDMI defines the following metadata\
    \ fields:\n   -cdmi_data_redundancy:  desired number of copies to be maintained\n\
    \   -cdmi_geographic_placement:  region where object is permitted to be\n    \
    \  stored\n   -cdmi_retention_period:  time interval object is to be retained\n\
    \   -cdmi_retention_autodelete:  whether object should be automatically\n    \
    \  deleted after retention period\n"
- title: A.2.2.  CDMI Support for SDT Primitives
  contents:
  - "A.2.2.  CDMI Support for SDT Primitives\n   SDT is used to write objects and\
    \ read (download) objects from a\n   DECADE server.  The object can be either\
    \ a self-contained object such\n   as a multimedia file or a chunk from a P2P\
    \ system.\n"
- title: A.2.2.1.  Writing Primitives
  contents:
  - "A.2.2.1.  Writing Primitives\n   Writing involves uploading objects to the server.\
    \  CDMI supports\n   standard HTTP methods for PUT and POST as described in\n\
    \   Appendix A.1.2.1.\n"
- title: A.2.2.2.  Downloading Primitives
  contents:
  - "A.2.2.2.  Downloading Primitives\n   Downloading involves fetching of an object\
    \ from the server.  CDMI\n   supports the standard HTTP GET method as described\
    \ in\n   Appendix A.1.2.2.\n"
- title: A.2.3.  Other Operations
  contents:
  - "A.2.3.  Other Operations\n   CDMI supports DELETE as described in Appendix A.1.4.\
    \  CDMI also\n   supports COPY and MOVE operations.\n   CDMI supports the concept\
    \ of containers of data objects to support\n   joint operations on related objects.\
    \  For example, GET may be done on\n   a single data object or an entire container.\n\
    \   CDMI supports a global naming scheme.  Every object stored within a\n   CDMI\
    \ system will have a globally unique object string identifier\n   (ObjectID) assigned\
    \ at creation time.\n"
- title: A.2.4.  Conclusions
  contents:
  - "A.2.4.  Conclusions\n   CDMI has a rich array of features that can provide a\
    \ good base for\n   DRP and SDT for DECADE.  An initial analysis finds that the\
    \ following\n   CDMI features may be useful for DECADE:\n   -  access control\n\
    \   -  storage resource control\n   -  communication resource control\n   -  COPY/MOVE\
    \ operations\n   -  data containers\n   -  naming scheme\n"
- title: A.3.  OAuth
  contents:
  - "A.3.  OAuth\n   As mentioned in Appendix A.1, OAuth [RFC6749] may be used as\
    \ part of\n   the access and resource control of a DECADE system.  In this section,\n\
    \   we provide an example of how to configure OAuth requests and\n   responses\
    \ for DRP.\n   An OAuth request to access DECADE data objects should include the\n\
    \   following fields:\n      response_type: Value should be set to \"token\".\n\
    \      client_id: The client_id indicates either the application that is\n   \
    \   using the DECADE service or the end user who is using the DECADE\n      service\
    \ from a DECADE storage service provider.  DECADE storage\n      service providers\
    \ should provide the ID distribution and\n      management function.\n      scope:\
    \ Data object names that are requested.\n   An OAuth response should include the\
    \ following information:\n      token_type: \"Bearer\"\n      expires_in: The\
    \ lifetime in seconds of the access token.\n      access_token: A token denotes\
    \ the following information.\n      service_uri: The server address or URI which\
    \ is providing the\n      service;\n      permitted_operations (e.g., read, write)\
    \ and objects (e.g., names\n      of data objects that might be read or written);\n\
    \      priority: Value should be set to be either \"Urgent\", \"High\",\n    \
    \  \"Normal\" or \"Low\".\n      bandwidth: Given to requested operation, a weight\
    \ value used in a\n      weighted bandwidth sharing scheme, or an integer in number\
    \ of bits\n      per second;\n      amount: Data size in number of bytes that\
    \ might be read or\n      written.\n      token_signature: The signature of the\
    \ access token.\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Richard Alimi\n   Google\n   EMail: ralimi@google.com\n\
    \   Akbar Rahman\n   InterDigital Communications, LLC\n   EMail: akbar.rahman@interdigital.com\n\
    \   Dirk Kutscher\n   NEC\n   EMail: dirk.kutscher@neclab.eu\n   Y. Richard Yang\n\
    \   Yale University\n   EMail: yry@cs.yale.edu\n   Haibin Song\n   Huawei Technologies\n\
    \   EMail: haibin.song@huawei.com\n   Kostas Pentikousis\n   EICT\n   EMail: k.pentikousis@eict.de\n"
