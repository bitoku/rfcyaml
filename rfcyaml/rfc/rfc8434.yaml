- contents:
  - '           Requirements for Parallel NFS (pNFS) Layout Types

    '
  title: __initial_text__
- contents:
  - "Abstract\n   This document defines the requirements that individual Parallel
    NFS\n   (pNFS) layout types need to meet in order to work within the pNFS\n   framework
    as defined in RFC 5661.  In so doing, this document aims to\n   clearly distinguish
    between requirements for pNFS as a whole and\n   those specifically directed to
    the pNFS file layout.  The lack of a\n   clear separation between the two sets
    of requirements has been\n   troublesome for those specifying and evaluating new
    layout types.  In\n   this regard, this document updates RFC 5661.\n"
  title: Abstract
- contents:
  - "Status of This Memo\n   This is an Internet Standards Track document.\n   This
    document is a product of the Internet Engineering Task Force\n   (IETF).  It represents
    the consensus of the IETF community.  It has\n   received public review and has
    been approved for publication by the\n   Internet Engineering Steering Group (IESG).
    \ Further information on\n   Internet Standards is available in Section 2 of RFC
    7841.\n   Information about the current status of this document, any errata,\n
    \  and how to provide feedback on it may be obtained at\n   https://www.rfc-editor.org/info/rfc8434.\n"
  title: Status of This Memo
- contents:
  - "Copyright Notice\n   Copyright (c) 2018 IETF Trust and the persons identified
    as the\n   document authors.  All rights reserved.\n   This document is subject
    to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n
    \  (https://trustee.ietf.org/license-info) in effect on the date of\n   publication
    of this document.  Please review these documents\n   carefully, as they describe
    your rights and restrictions with respect\n   to this document.  Code Components
    extracted from this document must\n   include Simplified BSD License text as described
    in Section 4.e of\n   the Trust Legal Provisions and are provided without warranty
    as\n   described in the Simplified BSD License.\n"
  title: Copyright Notice
- contents:
  - "Table of Contents\n   1. Introduction ....................................................2\n
    \  2. Definitions .....................................................3\n      2.1.
    Use of the Terms \"Data Server\" and \"Storage Device\" ........5\n      2.2.
    Requirements Language ......................................6\n   3. The Control
    Protocol ............................................6\n      3.1. Control Protocol
    Requirements ..............................8\n      3.2. Previously Undocumented
    Protocol Requirements ..............9\n      3.3. Editorial Requirements ....................................10\n
    \  4. Specifications of Original Layout Types ........................11\n      4.1.
    File Layout Type ..........................................11\n      4.2. Block
    Layout Type .........................................12\n      4.3. Object Layout
    Type ........................................13\n   5. Summary ........................................................14\n
    \  6. Security Considerations ........................................15\n   7.
    IANA Considerations ............................................15\n   8. References
    .....................................................16\n      8.1. Normative
    References ......................................16\n      8.2. Informative References
    ....................................16\n   Acknowledgments ...................................................17\n
    \  Author's Address ..................................................17\n"
  title: Table of Contents
- contents:
  - "1.  Introduction\n   The concept of \"layout type\" has a central role in the
    definition and\n   implementation of Parallel NFS (pNFS) (see [RFC5661]).  Clients
    and\n   servers implementing different layout types behave differently in\n   many
    ways while conforming to the overall pNFS framework defined in\n   [RFC5661] and
    this document.  Layout types may differ as to:\n   o  The method used to do I/O
    operations directed to data storage\n      devices.\n   o  The requirements for
    communication between the metadata server\n      (MDS) and the storage devices.\n
    \  o  The means used to ensure that I/O requests are only processed when\n      the
    client holds an appropriate layout.\n   o  The format and interpretation of nominally
    opaque data fields in\n      pNFS-related NFSv4.x data structures.\n   Each layout
    type will define the needed details for its usage in the\n   specification for
    that layout type; layout type specifications are\n   always Standards Track RFCs.
    \ Except for the file layout type defined\n   in Section 13 of [RFC5661], existing
    layout types are defined in\n   their own Standards Track documents, and it is
    anticipated that new\n   layout types will be defined in similar documents.\n
    \  The file layout type was defined in the Network File System (NFS)\n   version
    4.1 protocol specification [RFC5661].  The block layout type\n   was defined in
    [RFC5663], and the object layout type was defined in\n   [RFC5664].  Subsequently,
    the Small Computer System Interface (SCSI)\n   layout type was defined in [RFC8154].\n
    \  Some implementers have interpreted the text in Sections 12 (\"Parallel\n   NFS
    (pNFS)\") and 13 (\"NFSv4.1 as a Storage Protocol in pNFS: the File\n   Layout
    Type\") of [RFC5661] as applying only to the file layout type.\n   Because Section
    13 was not covered in a separate Standards Track\n   document such as those for
    both the block and object layout types,\n   there was some confusion as to the
    responsibilities of both the\n   metadata server and the data servers (DSs) that
    were laid out in\n   Section 12.\n   As a consequence, authors of new specifications
    (see [RFC8435] and\n   [Lustre]) may struggle to meet the requirements to be a
    pNFS layout\n   type.  This document gathers the requirements from all of the\n
    \  original Standards Track documents regarding layout type and then\n   specifies
    the requirements placed on all layout types independent of\n   the particular
    type chosen.\n"
  title: 1.  Introduction
- contents:
  - "2.  Definitions\n   control communication requirement:  the specification for
    information\n      on layouts, stateids, file metadata, and file data that must
    be\n      communicated between the metadata server and the storage devices.\n
    \     There is a separate set of requirements for each layout type.\n   control
    protocol:  the particular mechanism that an implementation of\n      a layout
    type would use to meet the control communication\n      requirement for that layout
    type.  This need not be a protocol as\n      normally understood.  In some cases,
    the same protocol may be used\n      as both a control protocol and storage protocol.\n
    \  storage protocol:  the protocol used by clients to do I/O operations\n      to
    the storage device.  Each layout type specifies the set of\n      storage protocols.\n
    \  loose coupling:  when the control protocol is a storage protocol.\n   tight
    coupling:  an arrangement in which the control protocol is one\n      designed
    specifically for control communication.  It may be either\n      a proprietary
    protocol adapted specifically to a particular\n      metadata server or a protocol
    based on a Standards Track document.\n   (file) data:  that part of the file system
    object that contains the\n      data to be read or written.  It is the contents
    of the object\n      rather than the attributes of the object.\n   data server
    (DS):  a pNFS server that provides the file's data when\n      the file system
    object is accessed over a file-based protocol.\n      Note that this usage differs
    from that in [RFC5661], which applies\n      the term in some cases even when
    other sorts of protocols are\n      being used.  Depending on the layout, there
    might be one or more\n      data servers over which the data is striped.  While
    the metadata\n      server is strictly accessed over the NFSv4.1 protocol, the
    data\n      server could be accessed via any file access protocol that meets\n
    \     the pNFS requirements.\n      See Section 2.1 for a comparison of this term
    and \"storage\n      device\".\n   storage device:  the target to which clients
    may direct I/O requests\n      when they hold an appropriate layout.  Note that
    each data server\n      is a storage device but that some storage device are not
    data\n      servers.  See Section 2.1 for further discussion.\n   fencing:  the
    process by which the metadata server prevents the\n      storage devices from
    processing I/O from a specific client to a\n      specific file.\n   layout:  the
    information a client uses to access file data on a\n      storage device.  This
    information includes specification of the\n      protocol (layout type) and the
    identity of the storage devices to\n      be used.\n      The bulk of the contents
    of the layout are defined in [RFC5661] as\n      nominally opaque, but individual
    layout types are responsible for\n      specifying the format of the layout data.\n
    \  layout iomode:  a grant of either read-only or read/write I/O to the\n      client.\n
    \  layout stateid:  a 128-bit quantity returned by a server that\n      uniquely
    defines the layout state provided by the server for a\n      specific layout that
    describes a layout type and file (see\n      Section 12.5.2 of [RFC5661]).  Further,
    Section 12.5.3 of\n      [RFC5661] describes differences in handling between layout\n
    \     stateids and other stateid types.\n   layout type:  a specification of both
    the storage protocol used to\n      access the data and the aggregation scheme
    used to lay out the\n      file data on the underlying storage devices.\n   recalling
    a layout:  a graceful recall, via a callback, of a specific\n      layout by the
    metadata server to the client.  Graceful here means\n      that the client would
    have the opportunity to flush any WRITEs,\n      etc., before returning the layout
    to the metadata server.\n   revoking a layout:  an invalidation of a specific
    layout by the\n      metadata server.  Once revocation occurs, the metadata server
    will\n      not accept as valid any reference to the revoked layout, and a\n      storage
    device will not accept any client access based on the\n      layout.\n   (file)
    metadata:  the part of the file system object that contains\n      various descriptive
    data relevant to the file object, as opposed\n      to the file data itself.  This
    could include the time of last\n      modification, access time, EOF position,
    etc.\n   metadata server (MDS):  the pNFS server that provides metadata\n      information
    for a file system object.  It is also responsible for\n      generating, recalling,
    and revoking layouts for file system\n      objects, for performing directory
    operations, and for performing\n      I/O operations to regular files when the
    clients direct these to\n      the metadata server itself.\n   stateid:  a 128-bit
    quantity returned by a server that uniquely\n      defines the set of locking-related
    state provided by the server.\n      Stateids may designate state related to open
    files, byte-range\n      locks, delegations, or layouts.\n"
  - contents:
    - "2.1.  Use of the Terms \"Data Server\" and \"Storage Device\"\n   In [RFC5661],
      the terms \"data server\" and \"storage device\" are used\n   somewhat inconsistently:\n
      \  o  In Section 12, where pNFS in general is discussed, the term\n      \"storage
      device\" is used.\n   o  In Section 13, where the file layout type is discussed,
      the term\n      \"data server\" is used.\n   o  In other sections, the term
      \"data server\" is used, even in\n      contexts where the storage access type
      is not NFSv4.1 or any other\n      file access protocol.\n   As this document
      deals with pNFS in general, it uses the more generic\n   term \"storage device\"
      in preference to \"data server\".  The term \"data\n   server\" is used only
      in contexts in which a file server is used as a\n   storage device.  Note that
      every data server is a storage device, but\n   storage devices that use protocols
      that are not file access protocols\n   (such as NFS) are not data servers.\n
      \  Since a given storage device may support multiple layout types, a\n   given
      device can potentially act as a data server for some set of\n   storage protocols
      while simultaneously acting as a storage device for\n   others.\n"
    title: 2.1.  Use of the Terms "Data Server" and "Storage Device"
  - contents:
    - "2.2.  Requirements Language\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\",
      \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"NOT
      RECOMMENDED\", \"MAY\", and\n   \"OPTIONAL\" in this document are to be interpreted
      as described in\n   BCP 14 [RFC2119] [RFC8174] when, and only when, they appear
      in all\n   capitals, as shown here.\n   This document differs from most Standards
      Track documents in that it\n   specifies requirements for those defining future
      layout types rather\n   than defining the requirements for implementations directly.
      \ This\n   document makes clear whether:\n   (1)  any particular requirement
      applies to implementations.\n   (2)  any particular requirement applies to those
      defining layout\n        types.\n   (3)  the requirement is a general requirement
      that implementations\n        need to conform to, with the specific means left
      to layout type\n        definitions type to specify.\n"
    title: 2.2.  Requirements Language
  title: 2.  Definitions
- contents:
  - "3.  The Control Protocol\n   A layout type has to meet the requirements that
    apply to the\n   interaction between the metadata server and the storage device
    such\n   that they present to the client a consistent view of stored data and\n
    \  locking state (Section 12.2.6 of [RFC5661]).  Particular\n   implementations
    may satisfy these requirements in any manner they\n   choose, and the mechanism
    chosen need not be described as a protocol.\n   Specifications defining layout
    types need to clearly show how\n   implementations can meet the requirements discussed
    below, especially\n   with respect to those that have security implications.  In
    addition,\n   such specifications may find it necessary to impose requirements
    on\n   implementations of the layout type to ensure appropriate\n   interoperability.\n
    \  In some cases, there may be no control protocol other than the\n   storage
    protocol.  This is often described as using a \"loosely\n   coupled\" model.  In
    such cases, the assumption is that the metadata\n   server, storage devices, and
    client may be changed independently and\n   that the implementation requirements
    in the layout type specification\n   need to ensure this degree of interoperability.
    \ This model is used\n   in the block and object layout type specification.\n
    \  In other cases, it is assumed that there will be a purpose-built\n   control
    protocol that may be different for different implementations\n   of the metadata
    server and data server.  The assumption here is that\n   the metadata server and
    data servers are designed and implemented as\n   a unit and interoperability needs
    to be assured between clients and\n   metadata-data server pairs, developed independently.
    \ This is the\n   model used for the file layout.\n   Another possibility is for
    the definition of a control protocol to be\n   specified in a Standards Track
    document.  There are two subcases to\n   consider:\n   o  A new layout type includes
    a definition of a particular control\n      protocol whose use is obligatory for
    metadata servers and storage\n      devices implementing the layout type.  In
    this case, the\n      interoperability model is similar to the first case above,
    and the\n      defining document should assure interoperability among metadata\n
    \     servers, storage devices, and clients developed independently.\n   o  A
    control protocol is defined in a Standards Track document that\n      meets the
    control protocol requirements for one of the existing\n      layout types.  In
    this case, the new document's job is to assure\n      interoperability between
    metadata servers and storage devices\n      developed separately.  The existing
    definition document for the\n      selected layout type retains the function of
    assuring\n      interoperability between clients and a given collection of\n      metadata
    servers and storage devices.  In this context,\n      implementations that implement
    the new protocol are treated in the\n      same way as those that use an internal
    control protocol or a\n      functional equivalent.\n   An example of this last
    case is the SCSI layout type [RFC8154], which\n   extends the block layout type.
    \ The block layout type had a\n   requirement for fencing of clients but did not
    present a way for the\n   control protocol (in this case, the SCSI storage protocol)
    to fence\n   the client.  The SCSI layout type remedies that in [RFC8154] and,
    in\n   effect, has a tightly coupled model.\n"
  - contents:
    - "3.1.  Control Protocol Requirements\n   The requirements of interactions between
      the metadata server and the\n   storage devices are:\n   (1)  The metadata server
      MUST be able to service the client's I/O\n        requests if the client decides
      to make such requests to the\n        metadata server instead of to the storage
      device.  The metadata\n        server must be able to retrieve the data from
      the constituent\n        storage devices and present it back to the client.
      \ A corollary\n        to this is that even though the metadata server has successfully\n
      \       given the client a layout, the client MAY still send I/O\n        requests
      to the metadata server.\n   (2)  The metadata server MUST be able to restrict
      access to a file on\n        the storage devices when it revokes a layout.  The
      metadata\n        server typically would revoke a layout whenever a client fails\n
      \       to respond to a recall or a client's lease is expired due to\n        non-renewal.
      \ It might also revoke the layout as a means of\n        enforcing a change
      in locking state or access permissions that\n        the storage device cannot
      directly enforce.\n        Effective revocation may require client cooperation
      in using a\n        particular stateid (file layout) or principal (e.g., flexible\n
      \       file layout) when performing I/O.\n        In contrast, there is no
      requirement to restrict access to a\n        file on the storage devices when
      a layout is recalled.  It is\n        only after the metadata server determines
      that the client is not\n        gracefully returning the layout and starts the
      revocation that\n        this requirement is enforced.\n   (3)  A pNFS implementation
      MUST NOT allow the violation of NFSv4.1's\n        access controls: Access Control
      Lists (ACLs) and file open\n        modes.  Section 12.9 of [RFC5661] specifically
      lays this burden\n        on the combination of clients, storage devices, and
      the metadata\n        server.  However, the specification of the individual
      layout\n        type might create requirements as to how this is to be done.\n
      \       This may include a possible requirement for the metadata server\n        to
      update the storage device so that it can enforce security.\n        The file
      layout requires the storage device to enforce access\n        whereas the flexible
      file layout requires both the storage\n        device and the client to enforce
      security.\n   (4)  Interactions between locking and I/O operations MUST obey\n
      \       existing semantic restrictions.  In particular, if an I/O\n        operation
      would be invalid when directed at the metadata server,\n        it is not to
      be allowed when performed on the storage device.\n        For the block and
      SCSI layouts, as the storage device is not\n        able to reject the I/O operation,
      the client is responsible for\n        enforcing this requirement.\n   (5)  Any
      disagreement between the metadata server and the data server\n        as to
      the value of attributes such as modify time, the change\n        attribute,
      and the EOF position MUST be of limited duration with\n        clear means of
      resolution of any discrepancies being provided.\n        Note the following:\n
      \       (a)  Discrepancies need not be resolved unless any client has\n             accessed
      the file in question via the metadata server,\n             typically by performing
      a GETATTR.\n        (b)  A particular storage device might be striped, and as
      such,\n             its local view of the EOF position does not match the\n
      \            global EOF position.\n        (c)  Both clock skew and network
      delay can lead to the metadata\n             server and the storage device having
      different values of\n             the time attributes.  As long as those differences
      can be\n             accounted for in what is presented to the client in a\n
      \            GETATTR, then no violation results.\n        (d)  A LAYOUTCOMMIT
      requires that changes in attributes\n             resulting from operations
      on the storage device need to be\n             reflected in the metadata server
      by the completion of the\n             operation.\n   These requirements may
      be satisfied in different ways by different\n   layout types.  As an example,
      while the file layout type uses the\n   stateid to fence off the client, there
      is no requirement that other\n   layout types use this stateid approach.\n   Each
      new Standards Track document for a layout type MUST address how\n   the client,
      metadata server, and storage devices are to interact to\n   meet these requirements.\n"
    title: 3.1.  Control Protocol Requirements
  - contents:
    - "3.2.  Previously Undocumented Protocol Requirements\n   While not explicitly
      stated as requirements in Section 12 of\n   [RFC5661], the existing layout types
      do have more requirements that\n   they need to enforce.\n   The client has
      these obligations when making I/O requests to the\n   storage devices:\n   (1)
      \ Clients MUST NOT perform I/O to the storage device if they do\n        not
      have layouts for the files in question.\n   (2)  Clients MUST NOT perform I/O
      operations outside of the specified\n        ranges in the layout segment.\n
      \  (3)  Clients MUST NOT perform I/O operations that would be\n        inconsistent
      with the iomode specified in the layout segments it\n        holds.\n   Under
      the file layout type, the storage devices are able to reject\n   any request
      made not conforming to these requirements.  This may not\n   be possible for
      other known layout types, which puts the burden of\n   enforcing such violations
      solely on the client.  For these layout\n   types:\n   (1)  The metadata server
      MAY use fencing operations to the storage\n        devices to enforce layout
      revocation against the client.\n   (2)  The metadata server MUST allow the clients
      to perform data I/O\n        against it, even if it has already granted the
      client a layout.\n        A layout type might discourage such I/O, but it cannot
      forbid\n        it.\n   (3)  The metadata server MUST be able to do storage
      allocation,\n        whether that is to create, delete, extend, or truncate
      files.\n   The means to address these requirements will vary with the layout\n
      \  type.  A control protocol will be used to effect these; the control\n   protocol
      could be a purpose-built one, one identical to the storage\n   protocol, or
      a new Standards Track control protocol.\n"
    title: 3.2.  Previously Undocumented Protocol Requirements
  - contents:
    - "3.3.  Editorial Requirements\n   This section discusses how the protocol requirements
      discussed above\n   need to be addressed in documents specifying a new layout
      type.\n   Depending on the interoperability model for the layout type in\n   question,
      this may involve the imposition of layout-type-specific\n   requirements that
      ensure appropriate interoperability of pNFS\n   components that are developed
      separately.\n   The specification of the layout type needs to make clear how
      the\n   client, metadata server, and storage device act together to meet the\n
      \  protocol requirements discussed previously.  If the document does not\n   impose
      implementation requirements sufficient to ensure that these\n   semantic requirements
      are met, it is not appropriate for publication\n   as an RFC from the IETF stream.\n
      \  Some examples include:\n   o  If the metadata server does not have a means
      to invalidate a\n      stateid issued to the storage device to keep a particular
      client\n      from accessing a specific file, then the layout type specification\n
      \     has to document how the metadata server is going to fence the\n      client
      from access to the file on that storage device.\n   o  If the metadata server
      implements mandatory byte-range locking\n      when accessed directly by the
      client, then the layout type\n      specification must require that this also
      be done when data is\n      read or written using the designated storage protocol.\n"
    title: 3.3.  Editorial Requirements
  title: 3.  The Control Protocol
- contents:
  - "4.  Specifications of Original Layout Types\n   This section discusses how the
    original layout types interact with\n   Section 12 of [RFC5661], which enumerates
    the requirements of pNFS\n   layout type specifications.  It is not normative
    with regards to the\n   file layout type presented in Section 13 of [RFC5661],
    the block\n   layout type [RFC5663], and the object layout type [RFC5664].  These\n
    \  are discussed here only to illuminate the updates Section 3 of this\n   document
    makes to Section 12 of [RFC5661].\n"
  - contents:
    - "4.1.  File Layout Type\n   Because the storage protocol is a subset of NFSv4.1,
      the semantics of\n   the file layout type comes closest to the semantics of
      NFSv4.1 in the\n   absence of pNFS.  In particular, the stateid and principal
      used for\n   I/O MUST have the same effect and be subject to the same validation\n
      \  on a data server as it would have if the I/O were being performed on\n   the
      metadata server itself.  The same set of validations are applied\n   whether
      or not pNFS is in effect.\n   While for most implementations, the storage devices
      can do the\n   following validations that are each presented as a \"SHOULD\"
      and not a\n   \"MUST\" in [RFC5661]:\n   (1)  client holds a valid layout,\n
      \  (2)  client I/O matches the layout iomode, and\n   (3)  client does not go
      out of the byte ranges,\n   Actually, the first point is presented in [RFC5661]
      as both:\n   \"MUST\":  in Section 13.6\n      As described in Section 12.5.1,
      a client MUST NOT send an I/O to a\n      data server for which it does not
      hold a valid layout; the data\n      server MUST reject such an I/O.\n   \"SHOULD\":
      \ in Section 13.8\n      The iomode need not be checked by the data servers
      when clients\n      perform I/O.  However, the data servers SHOULD still validate
      that\n      the client holds a valid layout and return an error if the client\n
      \     does not.\n   It should be noted that it is just these layout-specific
      checks that\n   are optional, not the normal file access semantics.  The storage\n
      \  devices MUST make all of the required access checks on each READ or\n   WRITE
      I/O as determined by the NFSv4.1 protocol.  If the metadata\n   server would
      deny a READ or WRITE operation on a file due to its ACL,\n   mode attribute,
      open access mode, open deny mode, mandatory byte-\n   range locking state, or
      any other attributes and state, the storage\n   device MUST also deny the READ
      or WRITE operation.  Also, while the\n   NFSv4.1 protocol does not mandate export
      access checks based on the\n   client's IP address, if the metadata server implements
      such a policy,\n   then that counts as such state as outlined above.\n   The
      data filehandle provided by the PUTFH operation to the data\n   server provides
      sufficient context to enable the data server to\n   ensure that the client has
      a valid layout for the I/O being performed\n   for the subsequent READ or WRITE
      operation in the compound.\n   Finally, the data server can check the stateid
      presented in the READ\n   or WRITE operation to see if that stateid has been
      rejected by the\n   metadata server; if so, the data server will cause the I/O
      to be\n   fenced.  Whilst it might just be the open owner or lock owner on that\n
      \  client being fenced, the client should take the NFS4ERR_BAD_STATEID\n   error
      code to mean it has been fenced from the file and contact the\n   metadata server.\n"
    title: 4.1.  File Layout Type
  - contents:
    - "4.2.  Block Layout Type\n   With the block layout type, the storage devices
      are generally not\n   able to enforce file-based security.  Typically, storage
      area network\n   (SAN) disk arrays and SAN protocols provide coarse-grained
      access\n   control mechanisms (e.g., Logical Unit Number (LUN) mapping and/or\n
      \  masking), with a target granularity of disks rather than individual\n   blocks
      and a source granularity of individual hosts rather than of\n   users or owners.
      \ Access to block storage is logically at a lower\n   layer of the I/O stack
      than NFSv4.  Since NFSv4 security is not\n   directly applicable to protocols
      that access such storage directly,\n   Section 2.1 of [RFC5663] specifies that:\n
      \     in environments where pNFS clients cannot be trusted to enforce\n      such
      policies, pNFS block layout types SHOULD NOT be used.\n   Due to these granularity
      issues, the security burden has been shifted\n   from the storage devices to
      the client.  Those deploying\n   implementations of this layout type need to
      be sure that the client\n   implementation can be trusted.  This is not a new
      sort of requirement\n   in the context of SAN protocols.  In such environments,
      the client is\n   expected to provide block-based protection.\n   This shift
      of the burden also extends to locks and layouts.  The\n   storage devices are
      not able to enforce any of these, and the burden\n   is pushed to the client
      to make the appropriate checks before sending\n   I/O to the storage devices.
      \ For example, the server may use a layout\n   iomode only allowing reading
      to enforce a mandatory read-only lock.\n   In such cases, the client has to
      support that use by not sending\n   WRITEs to the storage devices.  The fundamental
      issue here is that\n   the storage device is treated by this layout type in
      the same fashion\n   as a local disk device.  Once the client has access to
      the storage\n   device, it is able to perform both READ and WRITE I/O to the
      entire\n   storage device.  The byte ranges in the layout, any locks, the layout\n
      \  iomode, etc., can only be enforced by the client.  Therefore, the\n   client
      is required to provide that enforcement.\n   In the context of fencing off of
      the client upon revocation of a\n   layout, these limitations come into play
      again, i.e., the granularity\n   of the fencing can only be at the level of
      the host and logical unit.\n   Thus, if one of a client's layouts is revoked
      by the server, it will\n   effectively revoke all of the client's layouts for
      files located on\n   the storage units comprising the logical volume.  This
      may extend to\n   the client's layouts for files in other file systems.  Clients
      need\n   to be prepared for such revocations and reacquire layouts as needed.\n"
    title: 4.2.  Block Layout Type
  - contents:
    - "4.3.  Object Layout Type\n   With the object layout type, security checks occur
      during the\n   allocation of the layout.  The client will typically ask for
      layouts\n   covering all of the file and may do so for either READ or READ/WRITE.\n
      \  This enables it to do subsequent I/O operations without the need to\n   obtain
      layouts for specific byte ranges.  At that time, the metadata\n   server should
      verify permissions against the layout iomode, the file\n   mode bits or ACLs,
      etc.  As the client may be acting for multiple\n   local users, it MUST authenticate
      and authorize the user by issuing\n   respective OPEN and ACCESS calls to the
      metadata server, similar to\n   having NFSv4 data delegations.\n   Upon successful
      authorization, the client receives within the layout\n   a set of object capabilities
      allowing it I/O access to the specified\n   objects corresponding to the requested
      iomode.  These capabilities\n   are used to enforce access control and locking
      semantics at the\n   storage devices.  Whenever one of the following occurs
      on the\n   metadata server, then the metadata server MUST change the capability\n
      \  version attribute on all objects comprising the file in order to\n   invalidate
      any outstanding capabilities before committing to one of\n   these changes:\n
      \  o  the permissions on the object change,\n   o  a conflicting mandatory byte-range
      lock is granted, or\n   o  a layout is revoked and reassigned to another client.\n
      \  When the metadata server wishes to fence off a client to a particular\n   object,
      then it can use the above approach to invalidate the\n   capability attribute
      on the given object.  The client can be informed\n   via the storage device
      that the capability has been rejected and is\n   allowed to fetch a refreshed
      set of capabilities, i.e., reacquire the\n   layout.\n"
    title: 4.3.  Object Layout Type
  title: 4.  Specifications of Original Layout Types
- contents:
  - "5.  Summary\n   In the three original layout types, the burden of enforcing the\n
    \  security of NFSv4.1 can fall to either the storage devices (files),\n   the
    client (blocks), or the metadata server (objects).  Such choices\n   are conditioned
    by the native capabilities of the storage devices --\n   if a control protocol
    can be implemented, then the burden can be\n   shifted primarily to the storage
    devices.\n   In the context of this document, we treat the control protocol as
    a\n   set of requirements.  As new layout types are published, the defining\n
    \  documents MUST address:\n   (1)  The fencing of clients after a layout is revoked.\n
    \  (2)  The security implications of the native capabilities of the\n        storage
    devices with respect to the requirements of the NFSv4.1\n        security model.\n
    \  In addition, these defining documents need to make clear how other\n   semantic
    requirements of NFSv4.1 (e.g., locking) are met in the\n   context of the proposed
    layout type.\n"
  title: 5.  Summary
- contents:
  - "6.  Security Considerations\n   This section does not deal directly with security
    considerations for\n   existing or new layout types.  Instead, it provides a general\n
    \  framework for understating security-related issues within the pNFS\n   framework.
    \ Specific security considerations will be addressed in the\n   Security Considerations
    sections of documents specifying layout\n   types.  For example, in Section 3
    of [RFC5663], the lack of finer-\n   than-physical disk access control necessitates
    that the client is\n   delegated the responsibility to enforce the access provided
    to them\n   in the layout extent that they were granted by the metadata server.\n
    \  The layout type specification must ensure that only data access\n   consistent
    with the NFSV4.1 security model is allowed.  It may do\n   this directly, by providing
    that appropriate checks be performed at\n   the time each access is performed.
    \ It may do it indirectly by\n   allowing the client or the storage device to
    be responsible for\n   making the appropriate checks.  In the latter case, I/O
    access rights\n   are reflected in layouts, and the layout type must provide a
    way to\n   prevent inappropriate access due to permissions changes between the\n
    \  time a layout is granted and the time the access is performed.\n   The metadata
    server MUST be able to fence off a client's access to\n   the data file on a storage
    device.  When it revokes the layout, the\n   client's access MUST be terminated
    at the storage devices.  The\n   client has a subsequent opportunity to reacquire
    the layout and\n   perform the security check in the context of the newly current
    access\n   permissions.\n"
  title: 6.  Security Considerations
- contents:
  - "7.  IANA Considerations\n   This document has no IANA actions.\n"
  title: 7.  IANA Considerations
- contents:
  - '8.  References

    '
  - contents:
    - "8.1.  Normative References\n   [RFC2119]  Bradner, S., \"Key words for use
      in RFCs to Indicate\n              Requirement Levels\", BCP 14, RFC 2119,\n
      \             DOI 10.17487/RFC2119, March 1997,\n              <https://www.rfc-editor.org/info/rfc2119>.\n
      \  [RFC5661]  Shepler, S., Ed., Eisler, M., Ed., and D. Noveck, Ed.,\n              \"Network
      File System (NFS) Version 4 Minor Version 1\n              Protocol\", RFC 5661,
      DOI 10.17487/RFC5661, January 2010,\n              <https://www.rfc-editor.org/info/rfc5661>.\n
      \  [RFC5663]  Black, D., Fridella, S., and J. Glasgow, \"Parallel NFS\n              (pNFS)
      Block/Volume Layout\", RFC 5663,\n              DOI 10.17487/RFC5663, January
      2010,\n              <https://www.rfc-editor.org/info/rfc5663>.\n   [RFC5664]
      \ Halevy, B., Welch, B., and J. Zelenka, \"Object-Based\n              Parallel
      NFS (pNFS) Operations\", RFC 5664,\n              DOI 10.17487/RFC5664, January
      2010,\n              <https://www.rfc-editor.org/info/rfc5664>.\n   [RFC8154]
      \ Hellwig, C., \"Parallel NFS (pNFS) Small Computer System\n              Interface
      (SCSI) Layout\", RFC 8154, DOI 10.17487/RFC8154,\n              May 2017, <https://www.rfc-editor.org/info/rfc8154>.\n
      \  [RFC8174]  Leiba, B., \"Ambiguity of Uppercase vs Lowercase in RFC\n              2119
      Key Words\", BCP 14, RFC 8174, DOI 10.17487/RFC8174,\n              May 2017,
      <https://www.rfc-editor.org/info/rfc8174>.\n"
    title: 8.1.  Normative References
  - contents:
    - "8.2.  Informative References\n   [Lustre]   Faibish, S., Cote, D., and P. Tao,
      \"Parallel NFS (pNFS)\n              Lustre Layout Operations\", Work in Progress,\n
      \             draft-faibish-nfsv4-pnfs-lustre-layout-07, May 2014.\n   [RFC8435]
      \ Halevy, B. and T. Haynes, \"Parallel NFS (pNFS) Flexible\n              File
      Layout\", RFC 8435, DOI 10.17487/RFC8435, August 2018,\n              <https://www.rfc-editor.org/info/rfc8435>.\n"
    title: 8.2.  Informative References
  title: 8.  References
- contents:
  - "Acknowledgments\n   Dave Noveck provided an early review that sharpened the clarity
    of\n   the definitions.  He also provided a more comprehensive review of the\n
    \  document.\n   Both Chuck Lever and Christoph Helwig provided insightful comments\n
    \  during the working group last call.\n"
  title: Acknowledgments
- contents:
  - "Author's Address\n   Thomas Haynes\n   Hammerspace\n   4300 El Camino Real Ste
    105\n   Los Altos, CA  94022\n   United States of America\n   Email: loghyr@gmail.com\n"
  title: Author's Address
