- title: __initial_text__
  contents:
  - '        Salted Challenge Response HTTP Authentication Mechanism

    '
- title: Abstract
  contents:
  - "Abstract\n   This specification describes a family of HTTP authentication\n \
    \  mechanisms called the Salted Challenge Response Authentication\n   Mechanism\
    \ (SCRAM), which provides a more robust authentication\n   mechanism than a plaintext\
    \ password protected by Transport Layer\n   Security (TLS) and avoids the deployment\
    \ obstacles presented by\n   earlier TLS-protected challenge response authentication\
    \ mechanisms.\n"
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This document is not an Internet Standards Track specification;\
    \ it is\n   published for examination, experimental implementation, and\n   evaluation.\n\
    \   This document defines an Experimental Protocol for the Internet\n   community.\
    \  This document is a product of the Internet Engineering\n   Task Force (IETF).\
    \  It represents the consensus of the IETF\n   community.  It has received public\
    \ review and has been approved for\n   publication by the Internet Engineering\
    \ Steering Group (IESG).  Not\n   all documents approved by the IESG are a candidate\
    \ for any level of\n   Internet Standard; see Section 2 of RFC 5741.\n   Information\
    \ about the current status of this document, any errata,\n   and how to provide\
    \ feedback on it may be obtained at\n   http://www.rfc-editor.org/info/rfc7804.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (c) 2016 IETF Trust and the persons identified\
    \ as the\n   document authors.  All rights reserved.\n   This document is subject\
    \ to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n\
    \   (http://trustee.ietf.org/license-info) in effect on the date of\n   publication\
    \ of this document.  Please review these documents\n   carefully, as they describe\
    \ your rights and restrictions with respect\n   to this document.  Code Components\
    \ extracted from this document must\n   include Simplified BSD License text as\
    \ described in Section 4.e of\n   the Trust Legal Provisions and are provided\
    \ without warranty as\n   described in the Simplified BSD License.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1.  Introduction  . . . . . . . . . . . . . . . . . . .\
    \ . . . . .   2\n   2.  Conventions Used in This Document . . . . . . . . . .\
    \ . . . .   3\n     2.1.  Terminology . . . . . . . . . . . . . . . . . . . .\
    \ . . .   4\n     2.2.  Notation  . . . . . . . . . . . . . . . . . . . . . .\
    \ . .   4\n   3.  SCRAM Algorithm Overview  . . . . . . . . . . . . . . . . .\
    \ .   6\n   4.  SCRAM Mechanism Names . . . . . . . . . . . . . . . . . . . .\
    \   7\n   5.  SCRAM Authentication Exchange . . . . . . . . . . . . . . . .  \
    \ 7\n     5.1.  One Round-Trip Reauthentication . . . . . . . . . . . . .  10\n\
    \   6.  Use of the Authentication-Info Header Field with SCRAM  . . .  12\n  \
    \ 7.  Formal Syntax . . . . . . . . . . . . . . . . . . . . . . . .  13\n   8.\
    \  Security Considerations . . . . . . . . . . . . . . . . . . .  14\n   9.  IANA\
    \ Considerations . . . . . . . . . . . . . . . . . . . . .  15\n   10. Design\
    \ Motivations  . . . . . . . . . . . . . . . . . . . . .  15\n   11. References\
    \  . . . . . . . . . . . . . . . . . . . . . . . . .  16\n     11.1.  Normative\
    \ References . . . . . . . . . . . . . . . . . .  16\n     11.2.  Informative\
    \ References . . . . . . . . . . . . . . . . .  17\n   Acknowledgements  . . .\
    \ . . . . . . . . . . . . . . . . . . . . .  18\n   Author's Address  . . . .\
    \ . . . . . . . . . . . . . . . . . . . .  18\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   The authentication mechanism most widely deployed and used\
    \ by\n   Internet application protocols is the transmission of clear-text\n  \
    \ passwords over a channel protected by Transport Layer Security (TLS).\n   There\
    \ are some significant security concerns with that mechanism,\n   which could\
    \ be addressed by the use of a challenge response\n   authentication mechanism\
    \ protected by TLS.  Unfortunately, the HTTP\n   Digest challenge response mechanism\
    \ presently on the Standards Track\n   failed widespread deployment and has had\
    \ only limited success.\n   This specification describes a family of authentication\
    \ mechanisms\n   called the Salted Challenge Response Authentication Mechanism\n\
    \   (SCRAM), which addresses the requirements necessary to deploy a\n   challenge\
    \ response mechanism more widely than past attempts (see\n   [RFC5802]).  In particular,\
    \ it addresses some of the issues\n   identified with HTTP Digest, as described\
    \ in [RFC6331], such as the\n   complexity of implementation and protection of\
    \ the whole\n   authentication exchange in order to protect against certain man-in-\n\
    \   the-middle attacks.\n   HTTP SCRAM is an adaptation of [RFC5802] for use in\
    \ HTTP.  The SCRAM\n   data exchanged is identical to what is defined in [RFC5802].\
    \  This\n   document also adds a 1 round-trip reauthentication mode.\n   HTTP\
    \ SCRAM provides the following protocol features:\n   o  The authentication information\
    \ stored in the authentication\n      database is not sufficient by itself (without\
    \ a dictionary attack)\n      to impersonate the client.  The information is salted\
    \ to make it\n      harder to do a pre-stored dictionary attack if the database\
    \ is\n      stolen.\n   o  The server does not gain the ability to impersonate\
    \ the client to\n      other servers (with an exception for server-authorized\
    \ proxies),\n      unless it performs a dictionary attack.\n   o  The mechanism\
    \ permits the use of a server-authorized proxy without\n      requiring that proxy\
    \ to have super-user rights with the back-end\n      server.\n   o  Mutual authentication\
    \ is supported, but only the client is named\n      (i.e., the server has no name).\n"
- title: 2.  Conventions Used in This Document
  contents:
  - "2.  Conventions Used in This Document\n   The key words \"MUST\", \"MUST NOT\"\
    , \"REQUIRED\", \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\"\
    , \"MAY\", and \"OPTIONAL\" in this\n   document are to be interpreted as described\
    \ in [RFC2119].\n   Formal syntax is defined by [RFC5234] including the core rules\n\
    \   defined in Appendix B of [RFC5234].\n   Example lines prefaced by \"C:\" are\
    \ sent by the client and ones\n   prefaced by \"S:\" by the server.  If a single\
    \ \"C:\" or \"S:\" label\n   applies to multiple lines, then the line breaks between\
    \ those lines\n   are for editorial clarity only and are not part of the actual\n\
    \   protocol exchange.\n"
- title: 2.1.  Terminology
  contents:
  - "2.1.  Terminology\n   This document uses several terms defined in the \"Internet\
    \ Security\n   Glossary\" [RFC4949], including the following: authentication,\n\
    \   authentication exchange, authentication information, brute force,\n   challenge-response,\
    \ cryptographic hash function, dictionary attack,\n   eavesdropping, hash result,\
    \ keyed hash, man-in-the-middle, nonce,\n   one-way encryption function, password,\
    \ replay attack, and salt.\n   Readers not familiar with these terms should use\
    \ that glossary as a\n   reference.\n   Some clarifications and additional definitions\
    \ follow:\n   o  Authentication information: Information used to verify an identity\n\
    \      claimed by a SCRAM client.  The authentication information for a\n    \
    \  SCRAM identity consists of salt, iteration count, the StoredKey,\n      and\
    \ the ServerKey (as defined in the algorithm overview) for each\n      supported\
    \ cryptographic hash function.\n   o  Authentication database: The database used\
    \ to look up the\n      authentication information associated with a particular\
    \ identity.\n      For application protocols, LDAPv3 (see [RFC4510]) is frequently\n\
    \      used as the authentication database.  For lower-layer protocols\n     \
    \ such as PPP or 802.11x, the use of RADIUS [RFC2865] is more\n      common.\n\
    \   o  Base64: An encoding mechanism defined in Section 4 of [RFC4648]\n     \
    \ that converts an octet string input to a textual output string\n      that can\
    \ be easily displayed to a human.  The use of base64 in\n      SCRAM is restricted\
    \ to the canonical form with no whitespace.\n   o  Octet: An 8-bit byte.\n   o\
    \  Octet string: A sequence of 8-bit bytes.\n   o  Salt: A random octet string\
    \ that is combined with a password\n      before applying a one-way encryption\
    \ function.  This value is used\n      to protect passwords that are stored in\
    \ an authentication\n      database.\n"
- title: 2.2.  Notation
  contents:
  - "2.2.  Notation\n   The pseudocode description of the algorithm uses the following\n\
    \   notation:\n   o  \":=\": The variable on the left-hand side represents the\
    \ octet\n      string resulting from the expression on the right-hand side.\n\
    \   o  \"+\": Octet string concatenation.\n   o  \"[ ]\": A portion of an expression\
    \ enclosed in \"[\" and \"]\" is\n      optional in the result under some circumstances.\
    \  See the\n      associated text for a description of those circumstances.\n\
    \   o  Normalize(str): Apply the Preparation and Enforcement steps\n      according\
    \ to the OpaqueString profile (see [RFC7613]) to a UTF-8\n      [RFC3629] encoded\
    \ \"str\".  The resulting string is also in UTF-8.\n      Note that implementations\
    \ MUST either implement OpaqueString\n      profile operations from [RFC7613]\
    \ or disallow the use of non\n      US-ASCII Unicode codepoints in \"str\".  The\
    \ latter is a particular\n      case of compliance with [RFC7613].\n   o  HMAC(key,\
    \ str): Apply the HMAC-keyed hash algorithm (defined in\n      [RFC2104]) using\
    \ the octet string represented by \"key\" as the key\n      and the octet string\
    \ \"str\" as the input string.  The size of the\n      result is the hash result\
    \ size for the hash function in use.  For\n      example, it is 32 octets for\
    \ SHA-256 and 20 octets for SHA-1 (see\n      [RFC6234]).\n   o  H(str): Apply\
    \ the cryptographic hash function to the octet string\n      \"str\", producing\
    \ an octet string as a result.  The size of the\n      result depends on the hash\
    \ result size for the hash function in\n      use.\n   o  XOR: Apply the exclusive-or\
    \ operation to combine the octet string\n      on the left of this operator with\
    \ the octet string on the right of\n      this operator.  The length of the output\
    \ and each of the two\n      inputs will be the same for this use.\n   o  Hi(str,\
    \ salt, i):\n      U1   := HMAC(str, salt + INT(1))\n      U2   := HMAC(str, U1)\n\
    \      ...\n      Ui-1 := HMAC(str, Ui-2)\n      Ui   := HMAC(str, Ui-1)\n   \
    \   Hi := U1 XOR U2 XOR ... XOR Ui\n      where \"i\" is the iteration count,\
    \ \"+\" is the string concatenation\n      operator, and INT(g) is a four-octet\
    \ encoding of the integer g,\n      most significant octet first.\n      Hi()\
    \ is, essentially, PBKDF2 [RFC2898] with HMAC() as the\n      Pseudorandom Function\
    \ (PRF) and with dkLen == output length of\n      HMAC() == output length of H().\n"
- title: 3.  SCRAM Algorithm Overview
  contents:
  - "3.  SCRAM Algorithm Overview\n   The following is a description of a full HTTP\
    \ SCRAM authentication\n   exchange.  Note that this section omits some details,\
    \ such as client\n   and server nonces.  See Section 5 for more details.\n   To\
    \ begin with, the SCRAM client is in possession of a username and\n   password,\
    \ both encoded in UTF-8 [RFC3629] (or a ClientKey/ServerKey,\n   or SaltedPassword).\
    \  It sends the username to the server, which\n   retrieves the corresponding\
    \ authentication information: a salt, a\n   StoredKey, a ServerKey, and an iteration\
    \ count (\"i\").  (Note that a\n   server implementation may choose to use the\
    \ same iteration count for\n   all accounts.)  The server sends the salt and the\
    \ iteration count to\n   the client, which then computes the following values\
    \ and sends a\n   ClientProof to the server:\n   Informative Note: Implementors\
    \ are encouraged to create test cases\n   that use both usernames and passwords\
    \ with non-ASCII codepoints.  In\n   particular, it is useful to test codepoints\
    \ whose Unicode\n   Normalization Canonical Composition (NFC) and Unicode Normalization\n\
    \   Form Compatibility Composition (NFKC) are different (see\n   [Unicode-UAX15]).\
    \  Some examples of such codepoints include Vulgar\n   Fraction One Half (U+00BD)\
    \ and Acute Accent (U+00B4).\n      SaltedPassword  := Hi(Normalize(password),\
    \ salt, i)\n      ClientKey       := HMAC(SaltedPassword, \"Client Key\")\n  \
    \    StoredKey       := H(ClientKey)\n      AuthMessage     := client-first-message-bare\
    \ + \",\" +\n                         server-first-message + \",\" +\n       \
    \                  client-final-message-without-proof\n      ClientSignature :=\
    \ HMAC(StoredKey, AuthMessage)\n      ClientProof     := ClientKey XOR ClientSignature\n\
    \      ServerKey       := HMAC(SaltedPassword, \"Server Key\")\n      ServerSignature\
    \ := HMAC(ServerKey, AuthMessage)\n   The server authenticates the client by computing\
    \ the ClientSignature,\n   exclusive-ORing that with the ClientProof to recover\
    \ the ClientKey,\n   and verifying the correctness of the ClientKey by applying\
    \ the hash\n   function and comparing the result to the StoredKey.  If the ClientKey\n\
    \   is correct, this proves that the client has access to the user's\n   password.\n\
    \   Similarly, the client authenticates the server by computing the\n   ServerSignature\
    \ and comparing it to the value sent by the server.  If\n   the two are equal,\
    \ this proves that the server had access to the\n   user's ServerKey.\n   For\
    \ initial authentication, the AuthMessage is computed by\n   concatenating decoded\
    \ \"data\" attribute values from the authentication\n   exchange.  The format\
    \ of each of these 3 decoded \"data\" attributes is\n   defined in [RFC5802].\n"
- title: 4.  SCRAM Mechanism Names
  contents:
  - "4.  SCRAM Mechanism Names\n   A SCRAM mechanism name (authentication scheme)\
    \ is a string \"SCRAM-\"\n   followed by the uppercased name of the underlying\
    \ hash function taken\n   from the IANA \"Hash Function Textual Names\" registry\
    \ (see\n   <http://www.iana.org/assignments/hash-function-text-names>).\n   For\
    \ interoperability, all HTTP clients and servers supporting SCRAM\n   MUST implement\
    \ the SCRAM-SHA-256 authentication mechanism, i.e., an\n   authentication mechanism\
    \ from the SCRAM family that uses the SHA-256\n   hash function as defined in\
    \ [RFC7677].\n"
- title: 5.  SCRAM Authentication Exchange
  contents:
  - "5.  SCRAM Authentication Exchange\n   HTTP SCRAM is an HTTP Authentication mechanism\
    \ whose client response\n   (<credentials-scram>) and server challenge (<challenge-scram>)\n\
    \   messages are text-based messages containing one or more attribute-\n   value\
    \ pairs separated by commas.  The messages and their attributes\n   are described\
    \ below and defined in Section 7.\n    challenge-scram   = scram-name [1*SP 1#auth-param]\n\
    \          ; Complies with <challenge> ABNF from RFC 7235.\n          ; Included\
    \ in the WWW-Authenticate header field.\n    credentials-scram = scram-name [1*SP\
    \ 1#auth-param]\n          ; Complies with <credentials> from RFC 7235.\n    \
    \      ; Included in the Authorization header field.\n    scram-name = \"SCRAM-SHA-256\"\
    \ / \"SCRAM-SHA-1\" / other-scram-name\n          ; SCRAM-SHA-256 and SCRAM-SHA-1\
    \ are registered by this RFC.\n          ;\n          ; SCRAM-SHA-1 is registered\
    \ for database compatibility\n          ; with implementations of RFC 5802 (such\
    \ as IMAP or Extensible\n            Messaging and Presence Protocol (XMPP)\n\
    \          ; servers), but it is not recommended for new deployments.\n    other-scram-name\
    \ = \"SCRAM-\" hash-name\n          ; hash-name is a capitalized form of names\
    \ from IANA.\n          ; \"Hash Function Textual Names\" registry.\n        \
    \  ; Additional SCRAM names must be registered in both\n          ; the IANA \"\
    SASL Mechanisms\" registry\n          ; and the IANA \"HTTP Authentication Schemes\"\
    \ registry.\n   This is a simple example of a SCRAM-SHA-256 authentication exchange\n\
    \   (no support for channel bindings, as this feature is not currently\n   supported\
    \ by HTTP).  Username 'user' and password 'pencil' are used.\n   Note that long\
    \ lines are folded for readability.\n   C: GET /resource HTTP/1.1\n   C: Host:\
    \ server.example.com\n   C: [...]\n   S: HTTP/1.1 401 Unauthorized\n   S: WWW-Authenticate:\
    \ Digest realm=\"realm1@example.com\",\n          Digest realm=\"realm2@example.com\"\
    ,\n          Digest realm=\"realm3@example.com\",\n          SCRAM-SHA-256 realm=\"\
    realm3@example.com\",\n          SCRAM-SHA-256 realm=\"testrealm@example.com\"\
    \n   S: [...]\n   C: GET /resource HTTP/1.1\n   C: Host: server.example.com\n\
    \   C: Authorization: SCRAM-SHA-256 realm=\"testrealm@example.com\",\n       \
    \   data=biwsbj11c2VyLHI9ck9wck5HZndFYmVSV2diTkVrcU8K\n   C: [...]\n   S: HTTP/1.1\
    \ 401 Unauthorized\n   S: WWW-Authenticate: SCRAM-SHA-256\n           sid=AAAABBBBCCCCDDDD,\n\
    \           data=cj1yT3ByTkdmd0ViZVJXZ2JORWtxTyVodllEcFdVYTJSYVRDQWZ1eEZJ\n  \
    \            bGopaE5sRixzPVcyMlphSjBTTlk3c29Fc1VFamI2Z1E9PSxpPTQwOTYK\n   S: [...]\n\
    \   C: GET /resource HTTP/1.1\n   C: Host: server.example.com\n   C: Authorization:\
    \ SCRAM-SHA-256 sid=AAAABBBBCCCCDDDD,\n          data=Yz1iaXdzLHI9ck9wck5HZndFYmVSV2diTkVrcU8laHZZRHBXVWEyUmFUQ\n\
    \             0FmdXhGSWxqKWhObEYscD1kSHpiWmFwV0lrNGpVaE4rVXRlOXl0YWc5empm\n  \
    \           TUhnc3FtbWl6N0FuZFZRPQo=\n   C: [...]\n   S: HTTP/1.1 200 Ok\n   S:\
    \ Authentication-Info: sid=AAAABBBBCCCCDDDD,\n          data=dj02cnJpVFJCaTIzV3BSUi93dHVwK21NaFVaVW4vZEI1bkxUSlJzamw5N\n\
    \             Uc0PQo=\n   S: [...Other header fields and resource body...]\n \
    \  In the above example, the first client request contains a \"data\"\n   attribute\
    \ that base64 decodes as follows:\n      n,,n=user,r=rOprNGfwEbeRWgbNEkqO\n  \
    \ The server then responds with a \"data\" attribute that base64 decodes\n   as\
    \ follows:\n      r=rOprNGfwEbeRWgbNEkqO%hvYDpWUa2RaTCAfuxFIlj)hNlF,s=W22ZaJ0SNY7soE\n\
    \      sUEjb6gQ==,i=4096\n   The next client request contains a \"data\" attribute\
    \ that base64\n   decodes as follows:\n      c=biws,r=rOprNGfwEbeRWgbNEkqO%hvYDpWUa2RaTCAfuxFIlj)hNlF,p=dHzbZap\n\
    \      WIk4jUhN+Ute9ytag9zjfMHgsqmmiz7AndVQ=\n   The final server response contains\
    \ a \"data\" attribute that base64\n   decodes as follows:\n      v=6rriTRBi23WpRR/wtup+mMhUZUn/dB5nLTJRsjl95G4=\n\
    \   Note that in the example above, the client can also initiate SCRAM\n   authentication\
    \ without first being prompted by the server.\n   Initial \"SCRAM-SHA-256\" authentication\
    \ starts with sending the\n   Authorization request header field (defined by HTTP/1.1,\
    \ Part 7\n   [RFC7235]) containing the \"SCRAM-SHA-256\" authentication scheme\
    \ and\n   the following attributes:\n   o  A \"realm\" attribute MAY be included\
    \ to indicate the scope of\n      protection in the manner described in HTTP/1.1,\
    \ Part 7 [RFC7235].\n      As specified in [RFC7235], the \"realm\" attribute\
    \ MUST NOT appear\n      more than once.  The \"realm\" attribute only appears\
    \ in the first\n      SCRAM message to the server and in the first SCRAM response\
    \ from\n      the server.\n   o  The client also includes the \"data\" attribute\
    \ that contains the\n      base64-encoded \"client-first-message\" [RFC5802] containing:\n\
    \      *  a header consisting of a flag indicating whether channel\n         binding\
    \ is supported-but-not-used, not supported, or used.\n         Note that this\
    \ version of SCRAM doesn't support HTTP channel\n         bindings, so this header\
    \ always starts with \"n\"; otherwise, the\n         message is invalid and authentication\
    \ MUST fail.\n      *  SCRAM username and a random, unique \"nonce\" attribute.\n\
    \   In an HTTP response, the server sends the WWW-Authenticate header\n   field\
    \ containing a unique session identifier (the \"sid\" attribute)\n   plus the\
    \ \"data\" attribute containing the base64-encoded \"server-\n   first-message\"\
    \ [RFC5802].  The \"server-first-message\" contains the\n   user's iteration count\
    \ i, the user's salt, and the nonce with a\n   concatenation of the client-specified\
    \ one (taken from the \"client-\n   first-message\") with a freshly generated\
    \ server nonce.\n   The client then responds with another HTTP request with the\n\
    \   Authorization header field, which includes the \"sid\" attribute\n   received\
    \ in the previous server response, together with the \"data\"\n   attribute containing\
    \ base64-encoded \"client-final-message\" data.  The\n   latter has the same nonce\
    \ as in \"server-first-message\" and a\n   ClientProof computed using the selected\
    \ hash function (e.g., SHA-256)\n   as explained earlier.\n   The server verifies\
    \ the nonce and the proof, and, finally, it\n   responds with a 200 HTTP response\
    \ with the Authentication-Info header\n   field [RFC7615] containing the \"sid\"\
    \ attribute (as received from the\n   client) and the \"data\" attribute containing\
    \ the base64-encoded\n   \"server-final-message\", concluding the authentication\
    \ exchange.\n   The client then authenticates the server by computing the\n  \
    \ ServerSignature and comparing it to the value sent by the server.  If\n   the\
    \ two are different, the client MUST consider the authentication\n   exchange\
    \ to be unsuccessful, and it might have to drop the\n   connection.\n"
- title: 5.1.  One Round-Trip Reauthentication
  contents:
  - "5.1.  One Round-Trip Reauthentication\n   If the server supports SCRAM reauthentication,\
    \ the server sends in\n   its initial HTTP response a WWW-Authenticate header\
    \ field containing\n   the \"realm\" attribute (as defined earlier), the \"sr\"\
    \ attribute that\n   contains the server part of the \"r\" attribute (see s-nonce\
    \ in\n   [RFC5802]), and an optional \"ttl\" attribute (which contains the \"\
    sr\"\n   value validity in seconds).\n   If the client has authenticated to the\
    \ same realm before (i.e., it\n   remembers \"i\" and \"s\" attributes for the\
    \ user from earlier\n   authentication exchanges with the server), it can respond\
    \ to that\n   with \"client-final-message\".  When constructing the \"client-final-\n\
    \   message\", the client constructs the c-nonce part of the \"r\" attribute\n\
    \   as on initial authentication and the s-nonce part as follows: s-nonce\n  \
    \ is a concatenation of nonce-count and the \"sr\" attribute (in that\n   order).\
    \  The nonce-count is a positive integer that is equal to the\n   user's \"i\"\
    \ attribute on first reauthentication and is incremented by\n   1 on each successful\
    \ reauthentication.\n      The purpose of the nonce-count is to allow the server\
    \ to detect\n      request replays by maintaining its own copy of this count --\
    \ if\n      the same nonce-count value is seen twice, then the request is a\n\
    \      replay.\n   If the server considers the s-nonce part of the \"nonce\" attribute\n\
    \   (the \"r\" attribute) to still be valid (i.e., the nonce-count part is\n \
    \  as expected (see above) and the \"sr\" part is still fresh), it will\n   provide\
    \ access to the requested resource (assuming the client hash\n   verifies correctly,\
    \ of course).  However, if the server considers\n   that the server part of the\
    \ nonce is stale (for example, if the \"sr\"\n   value is used after the \"ttl\"\
    \ seconds), the server returns \"401\n   Unauthorized\" containing the SCRAM mechanism\
    \ name with the following\n   attributes: a new \"sr\", \"stale=true\", and an\
    \ optional \"ttl\".  The\n   \"stale\" attribute signals to the client that there\
    \ is no need to ask\n   the user for the password.\n      Formally, the \"stale\"\
    \ attribute is defined as a flag, indicating\n      that the previous request\
    \ from the client was rejected because the\n      nonce value was stale.  If stale\
    \ is TRUE (case-insensitive), the\n      client may wish to simply retry the request\
    \ with a new encrypted\n      response without reprompting the user for a new\
    \ username and\n      password.  The server should only set stale to TRUE if it\
    \ receives\n      a request for which the nonce is invalid but with a valid digest\n\
    \      for that nonce (indicating that the client knows the correct\n      username/password).\
    \  If stale is FALSE or anything other than\n      TRUE, or the stale directive\
    \ is not present, the username and/or\n      password are invalid, and new values\
    \ must be obtained.\n   When constructing AuthMessage (see Section 3) to be used\
    \ for\n   calculating client and server proofs, \"client-first-message-bare\"\
    \ and\n   \"server-first-message\" are reconstructed from data known to the\n\
    \   client and the server.\n   Reauthentication can look like this:\n   C: GET\
    \ /resource HTTP/1.1\n   C: Host: server.example.com\n   C: [...]\n   S: HTTP/1.1\
    \ 401 Unauthorized\n   S: WWW-Authenticate: Digest realm=\"realm1@example.com\"\
    ,\n          Digest realm=\"realm2@example.com\",\n          Digest realm=\"realm3@example.com\"\
    ,\n          SCRAM-SHA-256 realm=\"realm3@example.com\",\n          SCRAM-SHA-256\
    \ realm=\"testrealm@example.com\", sr=%hvYDpWUa2RaTC\n           AfuxFIlj)hNlF\n\
    \          SCRAM-SHA-256 realm=\"testrealm2@example.com\", sr=AAABBBCCCDDD,\n\
    \           ttl=120\n   S: [...]\n   [The client authenticates as usual to realm\
    \ \"testrealm@example.com\"]\n   [Some time later, client decides to reauthenticate.\n\
    \   It will use the cached \"i\" (4096) and \"s\" (W22ZaJ0SNY7soEsUEjb6gQ==)\n\
    \   from earlier exchanges.  It will use the nonce-value of 4096 together\n  \
    \ with the server advertised \"sr\" value as the server part of the \"r\".]\n\
    \   C: GET /resource HTTP/1.1\n   C: Host: server.example.com\n   C: Authorization:\
    \ SCRAM-SHA-256 realm=\"testrealm@example.com\",\n          data=Yz1iaXdzLHI9ck9wck5HZndFYmVSV2diTkVrcU80MDk2JWh2WURwV1VhM\n\
    \           lJhVENBZnV4RklsailoTmxGLHA9ZEh6YlphcFdJazRqVWhOK1V0ZTl5dGFnOX\n  \
    \         pqZk1IZ3NxbW1pejdBbmRWUT0K\n   C: [...]\n   S: HTTP/1.1 200 Ok\n   S:\
    \ Authentication-Info: sid=AAAABBBBCCCCDDDD,\n          data=dj02cnJpVFJCaTIzV3BSUi93dHVwK21NaFVaVW4vZEI1bkxUSlJzamw5N\n\
    \           Uc0PQo=\n   S: [...Other header fields and resource body...]\n"
- title: 6.  Use of the Authentication-Info Header Field with SCRAM
  contents:
  - "6.  Use of the Authentication-Info Header Field with SCRAM\n   When used with\
    \ SCRAM, the Authentication-Info header field is allowed\n   in the trailer of\
    \ an HTTP message transferred via chunked transfer-\n   coding.\n"
- title: 7.  Formal Syntax
  contents:
  - "7.  Formal Syntax\n   The following syntax specification uses the Augmented Backus-Naur\n\
    \   Form (ABNF) notation as specified in [RFC5234].\n      ALPHA = <as defined\
    \ in RFC 5234 Appendix B.1>\n      DIGIT = <as defined in RFC 5234 Appendix B.1>\n\
    \      base64-char     = ALPHA / DIGIT / \"/\" / \"+\"\n      base64-4       \
    \ = 4base64-char\n      base64-3        = 3base64-char \"=\"\n      base64-2 \
    \       = 2base64-char \"==\"\n      base64          = *base64-4 [base64-3 / base64-2]\n\
    \      sr              = \"sr=\" s-nonce\n                        ;; s-nonce is\
    \ defined in RFC 5802.\n      data            = \"data=\" base64\n           \
    \             ;; The \"data\" attribute value is base64-encoded\n            \
    \            ;; SCRAM challenge or response defined in\n                     \
    \   ;; RFC 5802.\n      ttl             = \"ttl=\" 1*DIGIT\n                 \
    \       ;; \"sr\" value validity in seconds.\n                        ;; No leading\
    \ 0s.\n      reauth-s-nonce  = nonce-count s-nonce\n      nonce-count     = posit-number\n\
    \                        ;; posit-number is defined in RFC 5802.\n           \
    \             ;; The initial value is taken from the \"i\"\n                 \
    \       ;; attribute for the user and is incremented\n                       \
    \ ;; by 1 on each successful reauthentication.\n      sid             = \"sid=\"\
    \ token\n                        ;; See token definition in RFC 7235.\n      stale\
    \           = \"stale=\" ( \"true\" / \"false\" )\n      realm           = \"\
    realm=\" <as defined in RFC 7235>\n"
- title: 8.  Security Considerations
  contents:
  - "8.  Security Considerations\n   If the authentication exchange is performed without\
    \ a strong session\n   encryption (such as TLS with data confidentiality), then\
    \ a passive\n   eavesdropper can gain sufficient information to mount an offline\n\
    \   dictionary or brute-force attack that can be used to recover the\n   user's\
    \ password.  The amount of time necessary for this attack\n   depends on the cryptographic\
    \ hash function selected, the strength of\n   the password, and the iteration\
    \ count supplied by the server.  SCRAM\n   allows the server/server administrator\
    \ to increase the iteration\n   count over time in order to slow down the above\
    \ attacks.  (Note that\n   a server that is only in possession of StoredKey and\
    \ ServerKey can't\n   automatically increase the iteration count upon successful\n\
    \   authentication.  Such an increase would require resetting the user's\n   password.)\
    \  An external security layer with strong encryption will\n   prevent these attacks.\n\
    \   If the authentication information is stolen from the authentication\n   database,\
    \ then an offline dictionary or brute-force attack can be\n   used to recover\
    \ the user's password.  The use of salt mitigates this\n   attack somewhat by\
    \ requiring a separate attack on each password.\n   Authentication mechanisms\
    \ that protect against this attack are\n   available (e.g., the Encrypted Key\
    \ Exchange (EKE) class of\n   mechanisms).  RFC 2945 [RFC2945] is an example of\
    \ such technology.\n   If an attacker obtains the authentication information from\
    \ the\n   authentication repository and either eavesdrops on one authentication\n\
    \   exchange or impersonates a server, the attacker gains the ability to\n   impersonate\
    \ that user to all servers providing SCRAM access using the\n   same hash function,\
    \ password, iteration count, and salt.  For this\n   reason, it is important to\
    \ use randomly generated salt values.\n   SCRAM does not negotiate which hash\
    \ function to use.  Hash function\n   negotiation is left to the HTTP authentication\
    \ mechanism negotiation.\n   It is important that clients be able to sort a locally\
    \ available list\n   of mechanisms by preference so that the client may pick the\
    \ most\n   preferred of a server's advertised mechanism list.  This preference\n\
    \   order is not specified here as it is a local matter.  The preference\n   order\
    \ should include objective and subjective notions of mechanism\n   cryptographic\
    \ strength (e.g., SCRAM with SHA-256 should be preferred\n   over SCRAM with SHA-1).\n\
    \   This document recommends use of SCRAM with SHA-256 hash.  SCRAM-SHA-1\n  \
    \ is registered for database compatibility with implementations of RFC\n   5802\
    \ (such as IMAP or XMPP servers) that want to also expose HTTP\n   access to a\
    \ related service, but it is not recommended for new\n   deployments.\n   A hostile\
    \ server can perform a computational denial-of-service attack\n   on clients by\
    \ sending a big iteration count value.  In order to\n   defend against that, a\
    \ client implementation can pick a maximum\n   iteration count that it is willing\
    \ to use and reject any values that\n   exceed that threshold (in such cases,\
    \ the client, of course, has to\n   fail the authentication).\n   See [RFC4086]\
    \ for more information about generating randomness.\n"
- title: 9.  IANA Considerations
  contents:
  - "9.  IANA Considerations\n   New mechanisms in the SCRAM family are registered\
    \ according to the\n   IANA procedure specified in [RFC5802].\n   Note to future\
    \ \"SCRAM-\" mechanism designers: Each new \"SCRAM-\" HTTP\n   authentication\
    \ mechanism MUST be explicitly registered with IANA and\n   MUST comply with \"\
    SCRAM-\" mechanism naming convention defined in\n   Section 4 of this document.\n\
    \   IANA has added the following entries to the \"HTTP Authentication\n   Schemes\"\
    \ registry defined in HTTP/1.1, Part 7 [RFC7235]:\n      Authentication Scheme\
    \ Name: SCRAM-SHA-256\n      Pointer to specification text: RFC 7804\n      Notes\
    \ (optional): (none)\n      Authentication Scheme Name: SCRAM-SHA-1\n      Pointer\
    \ to specification text: RFC 7804\n      Notes (optional): (none)\n"
- title: 10.  Design Motivations
  contents:
  - "10.  Design Motivations\n   The following design goals shaped this document.\
    \  Note that some of\n   the goals have changed since the initial draft version\
    \ of the\n   document.\n   o  The HTTP authentication mechanism has all modern\
    \ features: support\n      for internationalized usernames and passwords.\n  \
    \ o  The protocol supports mutual authentication.\n   o  The authentication information\
    \ stored in the authentication\n      database is not sufficient by itself to\
    \ impersonate the client.\n   o  The server does not gain the ability to impersonate\
    \ the client to\n      other servers (with an exception for server-authorized\
    \ proxies),\n      unless such other servers allow SCRAM authentication and use\
    \ the\n      same salt and iteration count for the user.\n   o  The mechanism\
    \ is extensible, but (hopefully) not over-engineered\n      in this respect.\n\
    \   o  The mechanism is easier to implement than HTTP Digest in both\n      clients\
    \ and servers.\n   o  The protocol supports 1 round-trip reauthentication.\n"
- title: 11.  References
  contents:
  - '11.  References

    '
- title: 11.1.  Normative References
  contents:
  - "11.1.  Normative References\n   [RFC2104]  Krawczyk, H., Bellare, M., and R.\
    \ Canetti, \"HMAC: Keyed-\n              Hashing for Message Authentication\"\
    , RFC 2104,\n              DOI 10.17487/RFC2104, February 1997,\n            \
    \  <http://www.rfc-editor.org/info/rfc2104>.\n   [RFC2119]  Bradner, S., \"Key\
    \ words for use in RFCs to Indicate\n              Requirement Levels\", BCP 14,\
    \ RFC 2119,\n              DOI 10.17487/RFC2119, March 1997,\n              <http://www.rfc-editor.org/info/rfc2119>.\n\
    \   [RFC3629]  Yergeau, F., \"UTF-8, a transformation format of ISO\n        \
    \      10646\", STD 63, RFC 3629, DOI 10.17487/RFC3629, November\n           \
    \   2003, <http://www.rfc-editor.org/info/rfc3629>.\n   [RFC4648]  Josefsson,\
    \ S., \"The Base16, Base32, and Base64 Data\n              Encodings\", RFC 4648,\
    \ DOI 10.17487/RFC4648, October 2006,\n              <http://www.rfc-editor.org/info/rfc4648>.\n\
    \   [RFC5234]  Crocker, D., Ed. and P. Overell, \"Augmented BNF for Syntax\n \
    \             Specifications: ABNF\", STD 68, RFC 5234,\n              DOI 10.17487/RFC5234,\
    \ January 2008,\n              <http://www.rfc-editor.org/info/rfc5234>.\n   [RFC5802]\
    \  Newman, C., Menon-Sen, A., Melnikov, A., and N. Williams,\n              \"\
    Salted Challenge Response Authentication Mechanism\n              (SCRAM) SASL\
    \ and GSS-API Mechanisms\", RFC 5802,\n              DOI 10.17487/RFC5802, July\
    \ 2010,\n              <http://www.rfc-editor.org/info/rfc5802>.\n   [RFC6234]\
    \  Eastlake 3rd, D. and T. Hansen, \"US Secure Hash Algorithms\n             \
    \ (SHA and SHA-based HMAC and HKDF)\", RFC 6234,\n              DOI 10.17487/RFC6234,\
    \ May 2011,\n              <http://www.rfc-editor.org/info/rfc6234>.\n   [RFC7235]\
    \  Fielding, R., Ed. and J. Reschke, Ed., \"Hypertext Transfer\n             \
    \ Protocol (HTTP/1.1): Authentication\", RFC 7235,\n              DOI 10.17487/RFC7235,\
    \ June 2014,\n              <http://www.rfc-editor.org/info/rfc7235>.\n   [RFC7613]\
    \  Saint-Andre, P. and A. Melnikov, \"Preparation,\n              Enforcement,\
    \ and Comparison of Internationalized Strings\n              Representing Usernames\
    \ and Passwords\", RFC 7613,\n              DOI 10.17487/RFC7613, August 2015,\n\
    \              <http://www.rfc-editor.org/info/rfc7613>.\n   [RFC7615]  Reschke,\
    \ J., \"HTTP Authentication-Info and Proxy-\n              Authentication-Info\
    \ Response Header Fields\", RFC 7615,\n              DOI 10.17487/RFC7615, September\
    \ 2015,\n              <http://www.rfc-editor.org/info/rfc7615>.\n   [RFC7677]\
    \  Hansen, T., \"SCRAM-SHA-256 and SCRAM-SHA-256-PLUS Simple\n              Authentication\
    \ and Security Layer (SASL) Mechanisms\",\n              RFC 7677, DOI 10.17487/RFC7677,\
    \ November 2015,\n              <http://www.rfc-editor.org/info/rfc7677>.\n"
- title: 11.2.  Informative References
  contents:
  - "11.2.  Informative References\n   [RFC2865]  Rigney, C., Willens, S., Rubens,\
    \ A., and W. Simpson,\n              \"Remote Authentication Dial In User Service\
    \ (RADIUS)\",\n              RFC 2865, DOI 10.17487/RFC2865, June 2000,\n    \
    \          <http://www.rfc-editor.org/info/rfc2865>.\n   [RFC2898]  Kaliski, B.,\
    \ \"PKCS #5: Password-Based Cryptography\n              Specification Version\
    \ 2.0\", RFC 2898,\n              DOI 10.17487/RFC2898, September 2000,\n    \
    \          <http://www.rfc-editor.org/info/rfc2898>.\n   [RFC2945]  Wu, T., \"\
    The SRP Authentication and Key Exchange System\",\n              RFC 2945, DOI\
    \ 10.17487/RFC2945, September 2000,\n              <http://www.rfc-editor.org/info/rfc2945>.\n\
    \   [RFC4086]  Eastlake 3rd, D., Schiller, J., and S. Crocker,\n             \
    \ \"Randomness Requirements for Security\", BCP 106, RFC 4086,\n             \
    \ DOI 10.17487/RFC4086, June 2005,\n              <http://www.rfc-editor.org/info/rfc4086>.\n\
    \   [RFC4510]  Zeilenga, K., Ed., \"Lightweight Directory Access Protocol\n  \
    \            (LDAP): Technical Specification Road Map\", RFC 4510,\n         \
    \     DOI 10.17487/RFC4510, June 2006,\n              <http://www.rfc-editor.org/info/rfc4510>.\n\
    \   [RFC4949]  Shirey, R., \"Internet Security Glossary, Version 2\",\n      \
    \        FYI 36, RFC 4949, DOI 10.17487/RFC4949, August 2007,\n              <http://www.rfc-editor.org/info/rfc4949>.\n\
    \   [RFC6331]  Melnikov, A., \"Moving DIGEST-MD5 to Historic\", RFC 6331,\n  \
    \            DOI 10.17487/RFC6331, July 2011,\n              <http://www.rfc-editor.org/info/rfc6331>.\n\
    \   [Unicode-UAX15]\n              The Unicode Consortium, \"Unicode Standard\
    \ Annex #15:\n              Unicode Normalization Forms\", June 2015,\n      \
    \        <http://www.unicode.org/reports/tr15/>.\n"
- title: Acknowledgements
  contents:
  - "Acknowledgements\n   This document benefited from discussions on the mailing\
    \ lists for the\n   HTTPAuth, SASL, and Kitten working groups.  The author would\
    \ like to\n   specially thank the co-authors of [RFC5802] from which lots of text\n\
    \   was copied.\n   Thank you to Martin Thomson for the idea of adding the \"\
    ttl\"\n   attribute.\n   Thank you to Julian F. Reschke for corrections regarding\
    \ use of the\n   Authentication-Info header field.\n   A special thank you to\
    \ Tony Hansen for doing an early implementation\n   and providing extensive comments\
    \ on the document.\n   Thank you to Russ Housley, Stephen Farrell, Barry Leiba,\
    \ and Tim\n   Chown for doing detailed reviews of the document.\n"
- title: Author's Address
  contents:
  - "Author's Address\n   Alexey Melnikov\n   Isode Ltd\n   Email: Alexey.Melnikov@isode.com\n"
