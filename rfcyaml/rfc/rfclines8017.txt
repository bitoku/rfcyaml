Abstract This document provides recommendations for the implementation of public key cryptography based on the RSA algorithm, covering cryptographic primitives, encryption schemes, signature schemes with appendix, and ASN.1 syntax for representing keys and for identifying the schemes.
This document represents a republication of PKCS #1 v2.2 from RSA Laboratories' Public Key Cryptography Standards (PKCS) series.
By publishing this RFC, change control is transferred to the IETF.
This document also obsoletes RFC 3447.
This document provides recommendations for the implementation of public key cryptography based on the RSA algorithm [RSA], covering the following aspects:
Encryption schemes  Signature schemes with appendix  ASN.1 syntax for representing keys and for identifying the schemes The recommendations are intended for general application within computer and communications systems and
as such include a fair amount of flexibility.
It is expected that application standards based on these specifications may include additional constraints.
The recommendations are intended to be compatible with the standards IEEE 1363
[IEEE1363], IEEE 1363a [IEEE1363A], and ANSI X9.44
This document supersedes PKCS #1 version 2.1 [RFC3447] but includes compatible techniques.
The organization of this document is as follows:
Section 1 is an introduction.
Section 2 defines some notation used in this document.
Section 3 defines the RSA public and private key types.
Sections 4 and 5 define several primitives, or basic mathematical operations.
Data conversion primitives are in Section 4, and cryptographic primitives (encryption decryption and signature  verification) are in Section 5.
Sections 6, 7, and 8 deal with the encryption and signature schemes in this document.
Section 6 gives an overview.
Along with the methods found in PKCS #1 v1.5, Section 7 defines an encryption scheme based on Optimal Asymmetric Encryption Padding (OAEP) [OAEP], and Section 8 defines a signature scheme with appendix based on the Probabilistic Signature Scheme (PSS) [RSARABIN] [PSS].
Section 9 defines the encoding methods for the signature schemes in Section 8.
Appendix A defines the ASN.1 syntax for the keys defined in Section 3 and the schemes in Sections 7 and 8.
Appendix B defines the hash functions and the mask generation function (MGF) used in this document, including ASN.1 syntax for the techniques.
Appendix C gives an ASN.1 module.
Appendices D and E outline the revision history of PKCS #1 and provide general information about the Public Key Cryptography Standards.
This document represents a republication of PKCS #1 v2.2 [PKCS1 22] from RSA Laboratories' Public Key Cryptography Standards (PKCS) series.
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in [RFC2119].
i's CRT exponent, a positive integer such that e
q's CRT exponent, a positive integer such that e
greatest common divisor of two nonnegative integers
r u , u >
a positive integer less than p such that q
: "0x48" denotes the octet with hexadecimal value 48; "
(0x)48 09 0e" denotes the string of three consecutive octets with hexadecimal values 48, 09, and 0e, respectively \lambda(n)
The Chinese Remainder Theorem (CRT) can be applied in a non  recursive as well as a recursive way.
In this document, a recursive approach following Garner's algorithm [GARNER] is used.
See also Note 1 in Section 3.2.
Two key types are employed in the primitives and schemes defined in this document: RSA public key and RSA private key.
Together, an RSA public key and an RSA private key form an RSA key pair.
This specification supports so called "multi prime" RSA where the modulus may have more than two prime factors.
The benefit of multi  prime RSA is lower computational cost for the decryption and signature primitives, provided that the CRT is used.
Better performance can be achieved on single processor platforms, but to a greater extent on multiprocessor platforms, where the modular exponentiations involved can be done in parallel.
For a discussion on how multi prime affects the security of the RSA cryptosystem, the reader is referred to [SILVERMAN].
For the purposes of this document, an RSA public key consists of two components:
By convention, the first two primes r 1 and r 2 may also be denoted p and q, respectively.
A recommended syntax for interchanging RSA public keys between implementations is given in Appendix A.1.1; an implementation's internal representation may differ.
For the purposes of this document, an RSA private key may have either of two representations.
The first representation consists of the pair (n, d), where the components have the following meanings:
The second representation consists of a quintuple (p, q, dP, dQ, qInv) and a (possibly empty) sequence of triplets (r i, d i, t i),
the second factor's CRT exponent, a positive integer qInv
the (first) CRT coefficient, a positive integer r i
th factor, a positive integer d
th factor's CRT exponent, a positive integer t
i    the i th factor's CRT coefficient, a positive integer In a valid RSA private key with the first representation, the RSA modulus n is the same as in the corresponding RSA public key and is the product of u distinct odd primes r i,
The RSA private exponent d is a positive integer less than n satisfying e
(mod \lambda(n)), where e is the corresponding RSA public exponent and \lambda(n) is defined as in Section 3.1.
In a valid RSA private key with the second representation, the two factors p and q are the first two prime factors of the RSA modulus n (i.e., r 1 and r 2); the CRT exponents dP and dQ are positive integers less than p and q, respectively, satisfying e
i are the additional prime factors of the RSA modulus n.
A recommended syntax for interchanging RSA private keys between implementations, which includes components from both representations, is given in Appendix A.1.2; an implementation's internal representation may differ.
The definition of the CRT coefficients here and the formulas that use them in the primitives in Section 5 generally follow Garner's algorithm [GARNER] (see also Algorithm 14.71 in [HANDBOOK]).
However, for compatibility with the representations of RSA private keys in PKCS #1 v2.0 and previous versions, the roles of p and q are reversed compared to the rest of the primes.
Thus, the first CRT coefficient, qInv, is defined as the inverse of q mod p, rather than as the inverse of R 1 mod r 2, i.e., of p mod q. 2.
Quisquater and Couvreur [FASTDEC] observed the benefit of applying the CRT to RSA operations.
Two data conversion primitives are employed in the schemes defined in this document:
to Octet String primitive  OS2IP Octet String to Integer primitive For the purposes of this document, and consistent with ASN.1 syntax, an octet string is an ordered sequence of octets (eight bit bytes).
The sequence is indexed from first (conventionally, leftmost) to last (rightmost).
For purposes of conversion to and from integers, the first octet is considered the most significant in the following conversion primitives.
I2OSP I2OSP converts a nonnegative integer to an octet string of a specified length.
X corresponding octet string of length xLen Error:  "integer too large" Steps: 1.
If x >  256^xLen, output "integer too large" and stop.
x in its unique xLen digit representation in base 256:
x (xLen 1) 256^(xLen 1)
x 0, where 0 <
(note that one or more leading digits will be zero if x is less than 256^(xLen 1)).
i have the integer value
for 1 <  i <  xLen.
the octet string X   X 1
OS2IP OS2IP converts an octet string to a nonnegative integer.
X octet string to be converted Output:
X xLen be the octets of X from first to last, and let x (xLen
i) be the integer value of the octet X i for 1 <
x (xLen 1) 256^(xLen 1)
Cryptographic Primitives Cryptographic primitives are basic mathematical operations on which cryptographic schemes can be built.
They are intended for implementation in hardware or as software modules and are not intended to provide security apart from a scheme.
Four types of primitive are specified in this document, organized in pairs: encryption and decryption; and signature and verification.
The specifications of the primitives assume that certain conditions are met by the inputs, in particular that RSA public and private keys are valid.
An encryption primitive produces a ciphertext representative from a message representative under the control of a public key, and a decryption primitive recovers the message representative from the ciphertext representative under the control of the corresponding private key.
One pair of encryption and decryption primitives is employed in the encryption schemes defined in this document and is specified here: RSA Encryption Primitive (RSAEP) /
RSAEP and RSADP involve the same mathematical operation, with different keys as input.
The primitives defined here are the same as Integer Factorization Encryption Primitive using RSA (IFEP RSA) / Integer Factorization Decryption Primitive using RSA (IFDP RSA) in IEEE 1363
[IEEE1363] (except that support for multi prime RSA has been added) and are compatible with PKCS #1 v1.5.
The main mathematical operation in each primitive is exponentiation.
RSAEP RSAEP ((n, e), m)
RSA public key m message representative, an integer between 0 and n 1 Output:  c ciphertext representative, an integer between 0 and n 1 Error:  "message representative out of range" Assumption:  RSA public key (n, e) is valid Steps: 1.
If the message representative m is not between 0 and n 1, output "message representative out of range" and stop.
private key K is valid Steps: 1.
If the ciphertext representative c is not between 0 and n 1, output "ciphertext representative out of range" and stop.
The message representative m is computed as follows.
If the first form (n, d) of K is used, let m
If the second form (p, q, dP, dQ, qInv) and (r i, d i, t i) of K is used, proceed as follows:
mod p and m 2
If u > 2, let m i   c^(d i)
Let h   (m 1 m 2)   qInv mod p. iv.
If u > 2, let R   r 1 and for i   3 to u do 1.
Let R   R   r (i 1).
i mod r i. 3.
Step 2.b can be rewritten as a single loop, provided that one reverses the order of p and q.  For consistency with PKCS #1 v2.0, however, the first two primes p and q are treated separately from the additional primes.
5.2.  Signature and Verification Primitives A signature primitive produces a signature representative from a message representative under the control of a private key, and a verification primitive recovers the message representative from the signature representative under the control of the corresponding public key.
One pair of signature and verification primitives is employed in the signature schemes defined in this document and is specified here: RSA Signature Primitive, version 1 (RSASP1)
/ RSA Verification Primitive, version 1 (RSAVP1).
The primitives defined here are the same as Integer Factorization Signature Primitive using RSA, version 1 (IFSP RSA1) /
Integer Factorization Verification Primitive using RSA, version 1 (IFVP RSA1) in IEEE 1363
[IEEE1363] (except that support for multi prime RSA has been added) and are compatible with PKCS #1 v1.5.
The main mathematical operation in each primitive is exponentiation, as in the encryption and decryption primitives of Section 5.1.
RSASP1 and RSAVP1 are the same as RSADP and RSAEP except for the names of their input and output arguments; they are distinguished as they are intended for different purposes.
private key K is valid Steps: 1.
If the message representative m is not between 0 and n 1, output "message representative out of range" and stop.
The signature representative s is computed as follows.
If the first form (n, d) of K is used, let s
If the second form (p, q, dP, dQ, qInv) and (r i, d i, t i) of K is used, proceed as follows:
If u > 2, let s i
Let h   (s 1 s 2)
If u > 2, let R   r 1 and for i   3 to u do a.
Let R   R   r (i 1).
Step 2.b can be rewritten as a single loop, provided that one reverses the order of p and q.  For consistency with PKCS #1 v2.0, however, the first two primes p and q are treated separately from the additional primes.
RSA public key s signature representative, an integer between 0 and n 1 Output: m message representative, an integer between 0 and n 1 Error:  "signature representative out of range" Assumption:  RSA public key (n, e) is valid Steps: 1.
If the signature representative s is not between 0 and n 1, output "signature representative out of range" and stop.
A scheme combines cryptographic primitives and other techniques to achieve a particular security goal.
Two types of scheme are specified in this document: encryption schemes and signature schemes with appendix.
The schemes specified in this document are limited in scope in that their operations consist only of steps to process data with an RSA public or private key, and they do not include steps for obtaining or validating the key.
Thus, in addition to the scheme operations, an application will typically include key management operations by which parties may select RSA public and private keys for a scheme operation.
The specific additional operations and other details are outside the scope of this document.
As was the case for the cryptographic primitives (Section 5), the specifications of scheme operations assume that certain conditions are met by the inputs, in particular that RSA public and private keys are valid.
The behavior of an implementation is thus unspecified when a key is invalid.
The impact of such unspecified behavior depends on the application.
Possible means of addressing key validation include explicit key validation by the application; key validation within the public key infrastructure; and assignment of liability for operations performed with an invalid key to the party who generated the key.
A generally good cryptographic practice is to employ a given RSA key pair in only one scheme.
This avoids the risk that vulnerability in one scheme may compromise the security of the other and may be essential to maintain provable security.
While RSAES PKCS1 v1 5 (Section 7.2) and RSASSA PKCS1 v1 5 (Section 8.2) have traditionally been employed together without any known bad interactions (indeed, this is the model introduced by PKCS #1 v1.5), such a combined use of an RSA key pair is NOT RECOMMENDED for new applications.
To illustrate the risks related to the employment of an RSA key pair in more than one scheme, suppose an RSA key pair is employed in both RSAES OAEP (Section 7.1) and RSAES PKCS1 v1 5.
Although RSAES OAEP by itself would resist attack, an opponent might be able to exploit a weakness in the implementation of RSAES PKCS1 v1 5 to recover messages encrypted with either scheme.
As another example, suppose an RSA key pair is employed in both RSASSA PSS (Section 8.1) and RSASSA PKCS1 v1 5.
Then the security proof for RSASSA PSS would no longer be sufficient since the proof does not account for the possibility that signatures might be generated with a second scheme.
Similar considerations may apply if an RSA key pair is employed in one of the schemes defined here and in a variant defined elsewhere.
For the purposes of this document, an encryption scheme consists of an encryption operation and a decryption operation, where the encryption operation produces a ciphertext from a message with a recipient's RSA public key, and the decryption operation recovers the message from the ciphertext with the recipient's corresponding RSA private key.
An encryption scheme can be employed in a variety of applications.
A typical application is a key establishment protocol, where the message contains key material to be delivered confidentially from one party to another.
[RFC2315] employs such a protocol to deliver a content encryption key from a sender to a recipient; the encryption schemes defined here would be suitable key  encryption algorithms in that context.
Two encryption schemes are specified in this document: RSAES OAEP and RSAES PKCS1 v1 5.
RSAES OAEP is REQUIRED to be supported for new applications;
RSAES PKCS1 v1 5 is included only for compatibility with existing applications.
The encryption schemes given here follow a general model similar to that employed in IEEE 1363
[IEEE1363], combining encryption and decryption primitives with an encoding method for encryption.
The encryption operations apply a message encoding operation to a message to produce an encoded message, which is then converted to an integer message representative.
An encryption primitive is applied to the message representative to produce the ciphertext.
Reversing this, the decryption operations apply a decryption primitive to the ciphertext to recover a message representative, which is then converted to an octet string encoded message.
A message decoding operation is applied to the encoded message to recover the message and verify the correctness of the decryption.
To avoid implementation weaknesses related to the way errors are handled within the decoding operation (see [BLEICHENBACHER] and [MANGER]), the encoding and decoding operations for RSAES OAEP and RSAES PKCS1 v1 5 are embedded in the specifications of the respective encryption schemes rather than defined in separate specifications.
Both encryption schemes are compatible with the corresponding schemes in PKCS #1 v2.1. 7.1.
RSAES OAEP RSAES OAEP combines the RSAEP and RSADP primitives (Sections 5.1.1 and 5.1.2) with the EME OAEP encoding method (Step 2 in Section 7.1.1, and Step 3 in Section 7.1.2).
EME OAEP is based on Bellare and Rogaway's Optimal Asymmetric Encryption scheme [OAEP].
It is compatible with the Integer Factorization Encryption Scheme (IFES) defined in IEEE 1363
[IEEE1363], where the encryption and decryption primitives are IFEP RSA and IFDP RSA and the message encoding method is EME OAEP.
RSAES OAEP can operate on messages of length up to k 2hLen
2 octets, where hLen is the length of the output from the underlying hash function and k is the length in octets of the recipient's RSA modulus.
Assuming that computing e th roots modulo n is infeasible and the mask generation function in RSAES OAEP has appropriate properties, RSAES OAEP is semantically secure against adaptive chosen ciphertext attacks.
This assurance is provable in the sense that the difficulty of breaking RSAES OAEP can be directly related to the difficulty of inverting the RSA function, provided that the mask generation function is viewed as a black box or random oracle; see [FOPS] and the note below for further discussion.
Both the encryption and the decryption operations of RSAES OAEP take the value of a label L as input.
In this version of PKCS #1, L is the empty string; other uses of the label are outside the scope of this document.
See Appendix A.2.1 for the relevant ASN.1 syntax.
RSAES OAEP is parameterized by the choice of hash function and mask generation function.
This choice should be fixed for a given RSA key.
Suggested hash and mask generation functions are given in Appendix B. Note: Past results have helpfully clarified the security properties of the OAEP encoding method [OAEP]  (roughly the procedure described in Step 2 in Section 7.1.1).
The background is as follows.
In 1994, Bellare and Rogaway [OAEP] introduced a security concept that they denoted plaintext awareness (PA94).
They proved that if a deterministic public key encryption primitive (e.g., RSAEP) is hard to invert without the private key, then the corresponding OAEP based encryption scheme is plaintext aware (in the random oracle model), meaning roughly that an adversary cannot produce a valid ciphertext without actually "knowing" the underlying plaintext.
Plaintext awareness of an encryption scheme is closely related to the resistance of the scheme against chosen ciphertext attacks.
In such attacks, an adversary is given the opportunity to send queries to an oracle simulating the decryption primitive.
Using the results of these queries, the adversary attempts to decrypt a challenge ciphertext.
However, there are two flavors of chosen ciphertext attacks, and PA94 implies security against only one of them.
The difference relies on what the adversary is allowed to do after she is given the challenge ciphertext.
The indifferent attack scenario (denoted CCA1) does not admit any queries to the decryption oracle after the adversary is given the challenge ciphertext, whereas the adaptive scenario (denoted CCA2) does (except that the decryption oracle refuses to decrypt the challenge ciphertext once it is published).
In 1998, Bellare and Rogaway, together with Desai and Pointcheval [PA98], came up with a new, stronger notion of plaintext awareness (PA98) that does imply security against CCA2.
To summarize, there have been two potential sources for misconception: that PA94 and PA98 are equivalent concepts, or that CCA1 and CCA2 are equivalent concepts.
Either assumption leads to the conclusion that the Bellare Rogaway paper implies security of OAEP against CCA2, which it does not.
(Footnote: It might be fair to mention that PKCS #1
v2.0 cites [OAEP] and claims that "a chosen ciphertext attack is ineffective against a plaintext aware encryption scheme such as RSAES OAEP" without specifying the kind of plaintext awareness or chosen ciphertext attack considered.)
OAEP has never been proven secure against CCA2; in fact, Victor Shoup [SHOUP] has demonstrated that such a proof does not exist in the general case.
Put briefly, Shoup showed that an adversary in the CCA2 scenario who knows how to partially invert the encryption primitive but does not know how to invert it completely may well be able to break the scheme.
For example, one may imagine an attacker who is able to break RSAES OAEP if she knows how to recover all but the first 20 bytes of a random integer encrypted with RSAEP.
Such an attacker does not need to be able to fully invert RSAEP, because she does not use the first 20 octets in her attack.
Still, RSAES OAEP is secure against CCA2, which was proved by Fujisaki, Okamoto, Pointcheval, and Stern [FOPS] shortly after the announcement of Shoup's result.
Using clever lattice reduction techniques, they managed to show how to invert RSAEP completely given a sufficiently large part of the pre image.
This observation, combined with a proof that OAEP is secure against CCA2 if the underlying encryption primitive is hard to partially invert, fills the gap between what Bellare and Rogaway proved about RSAES OAEP and what some may have believed that they proved.
Somewhat paradoxically, we are hence saved by an ostensible weakness in RSAEP
(i.e., the whole inverse can be deduced from parts of it).
Unfortunately, however, the security reduction is not efficient for concrete parameters.
While the proof successfully relates an adversary A against the CCA2 security of RSAES OAEP to an algorithm I inverting RSA, the probability of success for I is only approximately \epsilon^2 / 2^18, where \epsilon is the probability of success for A.
(Footnote: In [FOPS], the probability of success for the inverter was \epsilon^2 / 4.
The additional factor 1 / 2^16 is due to the eight fixed zero bits at the beginning of the encoded message EM, which are not present in the variant of OAEP considered in [FOPS].
(A must be applied twice to invert RSA, and each application corresponds to a factor 1 / 2^8.))
In addition, the running time for I is approximately t^2, where t is the running time of the adversary.
The consequence is that we cannot exclude the possibility that attacking RSAES OAEP is considerably easier than inverting RSA for concrete parameters.
Still, the existence of a security proof provides some assurance that the RSAES OAEP construction is sounder than ad hoc constructions such as RSAES PKCS1 v1 5.
Hybrid encryption schemes based on the RSA Key Encapsulation Mechanism (RSA KEM) paradigm offer tight proofs of security directly applicable to concrete parameters; see [ISO18033] for discussion.
Future versions of PKCS #1 may specify schemes based on this paradigm.
Encryption Operation RSAES OAEP ENCRYPT (
(n, e), M, L) Options:
If the length of L is greater than the input limitation for the hash function
(2^61 1 octets for SHA 1), output "label too long" and stop.
k 2hLen 2, output "message too long" and stop.
EME OAEP encoding (see Figure 1 below)
If the label L is not provided, let L be the empty string.
Let lHash   Hash(L), an octet string of length hLen (see the note below).
Generate a padding string PS consisting of k mLen 2hLen 2 zero octets.
The length of PS may be zero.
Concatenate lHash, PS, a single octet with hexadecimal value 0x01, and the message M to form a data block DB of length k hLen 1 octets as DB   lHash
Generate a random octet string seed of length hLen.
Let dbMask   MGF(seed, k hLen 1).
Let maskedDB   DB \xor dbMask.
i.  Concatenate a single octet with hexadecimal value 0x00, maskedSeed, and maskedDB to form an encoded message EM of length k octets as EM   0x00
RSA encryption: a.  Convert the encoded message EM to an integer message representative m (see Section 4.2):
Apply the RSAEP encryption primitive (Section 5.1.1) to the RSA public key (n, e) and the message representative m to produce an integer ciphertext representative c:
c   RSAEP ((n, e), m).
Convert the ciphertext representative c to a ciphertext C of length
k octets (see Section 4.1):
: EME OAEP Encoding Operation Notes:
lHash is the hash of the optional label L.
The decoding operation follows reverse steps to recover M and verify lHash and PS.
If L is the empty string, the corresponding hash value lHash has the following hexadecimal representation for different choices of Hash: SHA 1:
afd80709 SHA 256: (0x)e3b0c442 98fc1c14
b1b1e36a 21fdb711 14be0743 4c0cc7bf 63f6e1da
SHA 512: (0x)cf83e135 7eefb8bd f1542850 d66d8007
d36ce9ce 47d0d13c 5d85f2b0 ff8318d2 877eec2f
63b931bd 47417a81 a538327a f927da3e 7.1.2.
Decryption Operation RSAES OAEP DECRYPT (K, C, L) Options:
If the length of L is greater than the input limitation for the hash function
(2^61 1 octets for SHA 1), output "decryption error" and stop.
If the length of the ciphertext C is not k octets, output "decryption error" and stop.
If k < 2hLen   2, output "decryption error" and stop.
RSA decryption: a.  Convert the ciphertext C to an integer ciphertext representative c
Apply the RSADP decryption primitive (Section 5.1.2) to the RSA private key K and the ciphertext representative c to produce an integer message representative m:
If RSADP outputs "ciphertext representative out of range" (meaning that c >  n), output "decryption error" and stop.
Convert the message representative m to an encoded message
k octets (see Section 4.1):
If the label L is not provided, let L be the empty string.
Let lHash   Hash(L), an octet string of length hLen (see the note in Section 7.1.1).
the encoded message EM into a single octet Y, an octet string maskedSeed of length hLen, and an octet string maskedDB of length
k hLen 1 as EM
Let dbMask   MGF(seed, k hLen 1).
Let DB   maskedDB \xor dbMask.
g.  Separate DB into an octet string lHash' of length hLen, a (possibly empty) padding string PS consisting of octets with hexadecimal value 0x00, and a message M as DB   lHash'
If there is no octet with hexadecimal value 0x01 to separate PS from M, if lHash does not equal lHash', or if Y is nonzero, output "decryption error" and stop.
Output the message M. Note
: Care must be taken to ensure that an opponent cannot distinguish the different error conditions in Step 3.g, whether by error message or timing, and, more generally, that an opponent cannot learn partial information about the encoded message EM.
Otherwise, an opponent may be able to obtain useful information about the decryption of the ciphertext C, leading to a chosen  ciphertext attack such as the one observed by Manger [MANGER].
PKCS1 v1 5 combines the RSAEP and RSADP primitives (Sections 5.1.1 and 5.1.2) with the EME PKCS1 v1 5 encoding method (Step 2 in Section 7.2.1, and Step 3 in Section 7.2.2).
It is mathematically equivalent to the encryption scheme in PKCS #1 v1.5.
RSAES PKCS1 v1 5 can operate on messages of length up to k 11 octets
(k is the octet length of the RSA modulus), although care should be taken to avoid certain attacks on low exponent RSA due to Coppersmith, Franklin, Patarin, and Reiter when long messages are encrypted (see the third bullet in the notes below and [LOWEXP]; [NEWATTACK] contains an improved attack).
As a general rule, the use of this scheme for encrypting an arbitrary message, as opposed to a randomly generated key, is NOT RECOMMENDED.
It is possible to generate valid RSAES PKCS1 v1 5 ciphertexts without knowing the corresponding plaintexts, with a reasonable probability of success.
This ability can be exploited in a chosen ciphertext attack as shown in [BLEICHENBACHER].
Therefore, if RSAES PKCS1 v1 5 is to be used, certain easily implemented countermeasures should be taken to thwart the attack found in [BLEICHENBACHER].
Typical examples include the addition of structure to the data to be encoded, rigorous checking of PKCS #1 v1.5 conformance (and other redundancy) in decrypted messages, and the consolidation of error messages in a client server protocol based on PKCS #1 v1.5.
These can all be effective countermeasures and do not involve changes to a protocol based on PKCS #1 v1.5.
See [BKS] for a further discussion of these and other countermeasures.
It has recently been shown that the security of the SSL/TLS handshake protocol [RFC5246], which uses RSAES PKCS1 v1 5 and certain countermeasures, can be related to a variant of the RSA problem; see [RSATLS] for discussion.
Note: The following passages describe some security recommendations pertaining to the use of RSAES PKCS1 v1 5.
Recommendations from PKCS #1 v1.5 are included as well as new recommendations motivated by cryptanalytic advances made in the intervening years.
It is RECOMMENDED that the pseudorandom octets in Step 2 in Section 7.2.1 be generated independently for each encryption process, especially if the same data is input to more than one encryption process.
Haastad's results [HAASTAD] are one motivation for this recommendation.
The padding string PS in Step 2 in Section 7.2.1 is at least eight octets long, which is a security condition for public key operations that makes it difficult for an attacker to recover data by trying all possible encryption blocks.
The pseudorandom octets can also help thwart an attack due to Coppersmith et al.
(see [NEWATTACK] for an improvement of the attack) when the size of the message to be encrypted is kept small.
The attack works on low exponent RSA when similar messages are encrypted with the same RSA public key.
More specifically, in one flavor of the attack, when two inputs to RSAEP agree on a large fraction of bits (8/9) and low exponent RSA (e   3) is used to encrypt both of them, it may be possible to recover both inputs with the attack.
Another flavor of the attack is successful in decrypting a single ciphertext when a large fraction (2/3) of the input to RSAEP is already known.
For typical applications, the message to be encrypted is short (e.g., a 128 bit symmetric key), so not enough information will be known or common between two messages to enable the attack.
However, if a long message is encrypted, or if part of a message is known, then the attack may be a concern.
In any case, the RSAES OAEP scheme overcomes the attack.
Encryption Operation RSAES PKCS1 V1 5 ENCRYPT ((n, e), M
) Input: (n, e)   recipient's RSA public key (k denotes the length in octets of the modulus n)
If mLen > k 11, output "message too long" and stop.
an octet string PS of length k mLen 3 consisting of pseudo randomly generated nonzero octets.
The length of PS will be at least eight octets.
Concatenate PS, the message M, and other padding to form an encoded message EM of length k octets as EM   0x00    0x02    PS    0x00    M. 3.
RSA encryption: a.  Convert the encoded message EM to an integer message representative m (see Section 4.2):
Apply the RSAEP encryption primitive (Section 5.1.1) to the RSA public key (n, e) and the message representative m to produce an integer ciphertext representative c:
c   RSAEP ((n, e), m).
Convert the ciphertext representative c to a ciphertext C of length
k octets (see Section 4.1):
Output the ciphertext C. 7.2.2.
Decryption Operation RSAES PKCS1 V1 5 DECRYPT (K, C)
Length checking: If the length of the ciphertext C is not k octets (or if k < 11), output "decryption error" and stop.
RSA decryption: a.  Convert the ciphertext C to an integer ciphertext representative c
Apply the RSADP decryption primitive (Section 5.1.2) to the RSA private key (n, d) and the ciphertext representative c to produce an integer message representative m: m   RSADP ((n, d), c).
If RSADP outputs "ciphertext representative out of range" (meaning that c >  n), output "decryption error" and stop.
Convert the message representative m to an encoded message
k octets (see Section 4.1):
Separate the encoded message EM into an octet string PS consisting of nonzero octets and a message M as EM
If the first octet of EM does not have hexadecimal value 0x00, if the second octet of EM does not have hexadecimal value 0x02, if there is no octet with hexadecimal value 0x00 to separate PS from M, or if the length of PS is less than 8 octets, output "decryption error" and stop.
Care shall be taken to ensure that an opponent cannot distinguish the different error conditions in Step 3, whether by error message or timing.
Otherwise, an opponent may be able to obtain useful information about the decryption of the ciphertext C, leading to a strengthened version of Bleichenbacher's attack [BLEICHENBACHER]; compare to Manger's attack [MANGER].
For the purposes of this document, a signature scheme with appendix consists of a signature generation operation and a signature verification operation, where the signature generation operation produces a signature from a message with a signer's RSA private key, and the signature verification operation verifies the signature on the message with the signer's corresponding RSA public key.
To verify a signature constructed with this type of scheme, it is necessary to have the message itself.
In this way, signature schemes with appendix are distinguished from signature schemes with message recovery, which are not supported in this document.
A signature scheme with appendix can be employed in a variety of applications.
For instance, the signature schemes with appendix defined here would be suitable signature algorithms for X.509 certificates [
Related signature schemes could be employed in PKCS #7
, although for technical reasons the current version of PKCS #7 separates a hash function from a signature scheme, which is different than what is done here; see the note in Appendix A.2.3 for more discussion.
Two signature schemes with appendix are specified in this document: RSASSA PSS and RSASSA PKCS1 v1 5.
Although no attacks are known against RSASSA PKCS1 v1 5, in the interest of increased robustness, RSASSA PSS is REQUIRED in new applications.
RSASSA PKCS1 v1 5 is included only for compatibility with existing applications.
The signature schemes with appendix given here follow a general model similar to that employed in IEEE 1363
[IEEE1363], combining signature and verification primitives with an encoding method for signatures.
The signature generation operations apply a message encoding operation to a message to produce an encoded message, which is then converted to an integer message representative.
A signature primitive is applied to the message representative to produce the signature.
Reversing this, the signature verification operations apply a signature verification primitive to the signature to recover a message representative, which is then converted to an octet string  encoded message.
A verification operation is applied to the message and the encoded message to determine whether they are consistent.
If the encoding method is deterministic (e.g., EMSA PKCS1 v1 5), the verification operation may apply the message encoding operation to the message and compare the resulting encoded message to the previously derived encoded message.
If there is a match, the signature is considered valid.
If the method is randomized (e.g., EMSA PSS), the verification operation is typically more complicated.
For example, the verification operation in EMSA PSS extracts the random salt and a hash output from the encoded message and checks whether the hash output, the salt, and the message are consistent; the hash output is a deterministic function in terms of the message and the salt.
For both signature schemes with appendix defined in this document, the signature generation and signature verification operations are readily implemented as "single pass" operations if the signature is placed after the message.
#7 [RFC2315] for an example format in the case of RSASSA PKCS1 v1 5. 8.1.
RSASSA PSS RSASSA PSS combines the RSASP1 and RSAVP1 primitives with the EMSA PSS encoding method.
It is compatible with the Integer Factorization Signature Scheme with Appendix (IFSSA) as amended in IEEE 1363a
[IEEE1363A], where the signature and verification primitives are IFSP RSA1 and IFVP RSA1 as defined in IEEE 1363
[IEEE1363], and the message encoding method is EMSA4.
EMSA4 is slightly more general than EMSA PSS as it acts on bit strings rather than on octet strings.
EMSA PSS is equivalent to EMSA4 restricted to the case that the operands as well as the hash and salt values are octet strings.
The length of messages on which RSASSA PSS can operate is either unrestricted or constrained by a very large number, depending on the hash function underlying the EMSA PSS encoding method.
Assuming that computing e th roots modulo n is infeasible and the hash and mask generation functions in EMSA PSS have appropriate properties, RSASSA PSS provides secure signatures.
This assurance is provable in the sense that the difficulty of forging signatures can be directly related to the difficulty of inverting the RSA function, provided that the hash and mask generation functions are viewed as black boxes or random oracles.
The bounds in the security proof are essentially "tight", meaning that the success probability and running time for the best forger against RSASSA PSS are very close to the corresponding parameters for the best RSA inversion algorithm; see [RSARABIN]
In contrast to the RSASSA PKCS1 v1 5 signature scheme, a hash function identifier is not embedded in the EMSA PSS encoded message, so in theory it is possible for an adversary to substitute a different (and potentially weaker) hash function than the one selected by the signer.
Therefore, it is RECOMMENDED that the EMSA PSS mask generation function be based on the same hash function.
In this manner, the entire encoded message will be dependent on the hash function, and it will be difficult for an opponent to substitute a different hash function than the one intended by the signer.
This matching of hash functions is only for the purpose of preventing hash function substitution and is not necessary if hash function substitution is addressed by other means (e.g., the verifier accepts only a designated hash function).
See [HASHID] for further discussion of these points.
The provable security of RSASSA PSS does not rely on the hash function in the mask generation function being the same as the hash function applied to the message.
RSASSA PSS is different from other RSA based signature schemes in that it is probabilistic rather than deterministic, incorporating a randomly generated salt value.
The salt value enhances the security of the scheme by affording a "tighter" security proof than deterministic alternatives such as Full Domain Hashing (FDH); see [RSARABIN] for discussion.
However, the randomness is not critical to security.
In situations where random generation is not possible, a fixed value or a sequence number could be employed instead, with the resulting provable security similar to that of FDH [FDH].
Signature Generation Operation RSASSA PSS SIGN
Apply the EMSA PSS encoding operation (Section 9.1.1) to the message M to produce an encoded message EM of length
such that the bit length of the integer OS2IP (EM) (see Section 4.2) is at most modBits 1, where modBits is the length in bits of the RSA modulus n:
PSS ENCODE (M, modBits 1).
Note that the octet length of EM will be one less than k
if modBits 1 is divisible by 8 and equal to k otherwise.
If the encoding operation outputs "message too long", output "message too long" and stop.
If the encoding operation outputs "encoding error", output "encoding error" and stop.
the encoded message EM to an integer message representative m (see Section 4.2):
Apply the RSASP1 signature primitive (Section 5.2.1) to the RSA private key K and the message representative
m to produce an integer signature representative
k octets (see Section 4.1):
Output the signature S. 8.1.2.
Signature Verification Operation RSASSA PSS VERIFY ((n, e), M, S)
If the length of the signature S is not k octets, output "invalid signature" and stop.
RSA verification: a.  Convert the signature S to an integer signature representative s (see Section 4.2)
Apply the RSAVP1 verification primitive (Section 5.2.2) to the RSA public key (n, e) and the signature representative s to produce an integer message representative m:
m   RSAVP1 ((n, e), s).
If RSAVP1 output "signature representative out of range", output "invalid signature" and stop.
Convert the message representative m to an encoded message
((modBits 1)/8) octets, where modBits is the length in bits of the RSA modulus n (see Section 4.1):
Note that emLen will be one less than k
if modBits 1 is divisible by 8 and equal to k otherwise.
If I2OSP outputs "integer too large", output "invalid signature" and stop.
EMSA PSS verification: Apply the EMSA PSS verification operation (Section 9.1.2) to the message M and the encoded message EM to determine whether they are consistent:
EMSA PSS VERIFY (M, EM, modBits 1).
If Result   "consistent", output "valid signature".
RSASSA PKCS1 v1 5 RSASSA
PKCS1 v1 5 combines the RSASP1 and RSAVP1 primitives with the EMSA PKCS1 v1 5 encoding method.
It is compatible with the IFSSA scheme defined in IEEE 1363
[IEEE1363], where the signature and verification primitives are IFSP RSA1 and IFVP RSA1, and the message encoding method is EMSA PKCS1 v1 5 (which is not defined in IEEE 1363 but is in IEEE 1363a [IEEE1363A]).
The length of messages on which RSASSA PKCS1 v1 5 can operate is either unrestricted or constrained by a very large number, depending on the hash function underlying the EMSA PKCS1 v1 5 method.
Assuming that computing e th roots modulo n is infeasible and the hash function in EMSA
PKCS1 v1 5 has appropriate properties, RSASSA PKCS1 v1 5 is conjectured to provide secure signatures.
More precisely, forging signatures without knowing the RSA private key is conjectured to be computationally infeasible.
Also, in the encoding method EMSA PKCS1 v1 5, a hash function identifier is embedded in the encoding.
Because of this feature, an adversary trying to find a message with the same signature as a previously signed message must find collisions of the particular hash function being used; attacking a different hash function than the one selected by the signer is not useful to the adversary.
See [HASHID] for further discussion.
Note: As noted in PKCS #1 v1.5, the EMSA PKCS1 v1 5 encoding method has the property that the encoded message, converted to an integer message representative, is guaranteed to be large and at least somewhat "random".
This prevents attacks of the kind proposed by Desmedt and Odlyzko [CHOSEN] where multiplicative relationships between message representatives are developed by factoring the message representatives into a set of small values (e.g., a set of small primes).
Coron, Naccache, and Stern [PADDING] showed that a stronger form of this type of attack could be quite effective against some instances of the ISO/IEC 9796 2 signature scheme.
They also analyzed the complexity of this type of attack against the EMSA PKCS1 v1 5 encoding method and concluded that an attack would be impractical, requiring more operations than a collision search on the underlying hash function (i.e., more than 2^80 operations).
Coppersmith, Halevi, and Jutla [FORGERY] subsequently extended Coron et al.'s attack to break the ISO/IEC 9796 1 signature scheme with message recovery.
The various attacks illustrate the importance of carefully constructing the input to the RSA signature primitive, particularly in a signature scheme with message recovery.
Accordingly, the EMSA PKCS v1 5 encoding method explicitly includes a hash operation and is not intended for signature schemes with message recovery.
Moreover, while no attack is known against the EMSA PKCS v1 5 encoding method, a gradual transition to EMSA PSS is recommended as a precaution against future developments.
: Apply the EMSA PKCS1 v1 5 encoding operation (Section 9.2) to the message M to produce an encoded message EM of length k octets:
EM   EMSA PKCS1 V1 5 ENCODE (M, k).
If the encoding operation outputs "message too long", output "message too long" and stop.
If the encoding operation outputs "intended encoded message length too short", output "RSA modulus too short" and stop.
the encoded message EM to an integer message representative m (see Section 4.2):
Apply the RSASP1 signature primitive (Section 5.2.1) to the RSA private key K and the message representative
m to produce an integer signature representative
k octets (see Section 4.1):
Output the signature S. 8.2.2.
5 VERIFY ((n, e), M, S
If the length of the signature S is not k octets, output "invalid signature" and stop.
RSA verification: a.  Convert the signature S to an integer signature representative s (see Section 4.2)
Apply the RSAVP1 verification primitive (Section 5.2.2) to the RSA public key (n, e) and the signature representative s to produce an integer message representative m:
m   RSAVP1 ((n, e), s).
If RSAVP1 outputs "signature representative out of range", output "invalid signature" and stop.
Convert the message representative m to an encoded message
k octets (see Section 4.1):
If I2OSP outputs "integer too large", output "invalid signature" and stop.
: Apply the EMSA PKCS1 v1 5 encoding operation (Section 9.2) to the message M to produce a second encoded message EM' of length
EM'   EMSA PKCS1 V1 5 ENCODE (M, k).
If the encoding operation outputs "message too long", output "message too long" and stop.
If the encoding operation outputs "intended encoded message length too short", output "RSA modulus too short" and stop.
Compare the encoded message EM and
the second encoded message EM'.
If they are the same, output "valid signature"; otherwise, output "invalid signature".
Another way to implement the signature verification operation is to apply a "decoding" operation (not specified in this document) to the encoded message to recover the underlying hash value, and then compare it to a newly computed hash value.
This has the advantage that it requires less intermediate storage (two hash values rather than two encoded messages), but the disadvantage that it requires additional code.
9.  Encoding Methods for Signatures with Appendix Encoding methods consist of operations that map between octet string messages and octet string encoded messages, which are converted to and from integer message representatives in the schemes.
The integer message representatives are processed via the primitives.
The encoding methods thus provide the connection between the schemes, which process messages, and the primitives.
An encoding method for signatures with appendix, for the purposes of this document, consists of an encoding operation and optionally a verification operation.
An encoding operation maps a message M to an encoded message EM of a specified length.
A verification operation determines whether a message M and an encoded message EM are consistent, i.e., whether the encoded message EM is a valid encoding of the message M.
The encoding operation may introduce some randomness, so that different applications of the encoding operation to the same message will produce different encoded messages, which has benefits for provable security.
For such an encoding method, both an encoding and a verification operation are needed unless the verifier can reproduce the randomness (e.g., by obtaining the salt value from the signer).
For a deterministic encoding method, only an encoding operation is needed.
Two encoding methods for signatures with appendix are employed in the signature schemes and are specified here: EMSA PSS and EMSA
This encoding method is parameterized by the choice of hash function, mask generation function, and salt length.
These options should be fixed for a given RSA key, except that the salt length can be variable (see [JONSSON] for discussion).
Suggested hash and mask generation functions are given in Appendix B.
The encoding method is based on Bellare and Rogaway's Probabilistic Signature Scheme (PSS) [RSARABIN][PSS].
It is randomized and has an encoding operation and a verification operation.
Figure 2 illustrates the encoding operation.
EMSA PSS Encoding Operation Note that the verification operation follows reverse steps to recover salt and
then forward steps to recompute and compare H. Notes: 1.
The encoding method defined here differs from the one in Bellare and Rogaway's submission to IEEE 1363a [PSS] in three respects:
It applies a hash function rather than a mask generation function to the message.
Even though the mask generation function is based on a hash function, it seems more natural to apply a hash function directly.
The value that is hashed together with the salt value is the string (0x)00 00 00 00 00 00
mHash rather than the message M itself.
Here, mHash is the hash of M.  Note that the hash function is the same in both steps.
See Note 3 below for further discussion.
(Also, the name "salt" is used instead of "seed", as it is more reflective of the value's role.)
The encoded message in EMSA PSS has nine fixed bits; the first bit is 0 and the last eight bits form a "trailer field", the octet 0xbc.
In the original scheme, only the first bit is fixed.
The rationale for the trailer field is for compatibility with the Integer Factorization Signature Primitive using Rabin Williams (IFSP RW) in IEEE 1363
[IEEE1363] and the corresponding primitive in ISO/IEC 9796 2:2010
Assuming that the mask generation function is based on a hash function, it is RECOMMENDED that the hash function be the same as the one that is applied to the message; see Section 8.1 for further discussion.
Without compromising the security proof for RSASSA PSS, one may perform Steps 1 and 2 of EMSA PSS ENCODE and EMSA PSS VERIFY (
the application of the hash function to the message) outside the module that computes the rest of the signature operation, so that mHash rather than the message M itself is input to the module.
In other words, the security proof for RSASSA PSS still holds even if an opponent can control the value of mHash.
This is convenient if the module has limited
I/O bandwidth, e.g., a smart card.
Note that previous versions of PSS [RSARABIN][PSS] did not have this property.
Of course, it may be desirable for other security reasons to have the module process the full message.
For instance, the module may need to "see" what it is signing if it does not trust the component that computes the hash value.
Typical salt lengths in octets are hLen (the length of the output of the hash function Hash) and 0.
In both cases, the security of RSASSA PSS can be closely related to the hardness of inverting RSAVP1.
Bellare and Rogaway [RSARABIN] give a tight lower bound for the security of the original RSA PSS scheme, which corresponds roughly to the former case, while Coron [FDH] gives a lower bound for the related Full Domain Hashing scheme, which corresponds roughly to the latter case.
In [PSSPROOF], Coron provides a general treatment with various salt lengths ranging from 0 to hLen; see [IEEE1363A] for discussion.
See also [JONSSON], which adapts the security proofs in [RSARABIN]
[PSSPROOF] to address the differences between the original and the present version of RSA PSS as listed in Note 1 above.
As noted in IEEE 1363a
[IEEE1363A], the use of randomization in signature schemes   such as the salt value in EMSA PSS   may provide a "covert channel" for transmitting information other than the message being signed.
For more on covert channels, see [SIMMONS].
Encoding Operation EMSA PSS ENCODE (M, emBits) Options:
(see Section 4.2), at least 8hLen   8sLen
(emBits/8) Errors:  "Encoding error"; "message too long" Steps: 1.
If the length of M is greater than the input limitation for the hash function
(2^61 1 octets for SHA 1), output "message too long" and stop.
Let mHash   Hash(M), an octet string of length hLen.
sLen   2, output "encoding error" and stop.
Generate a random octet string salt of length sLen; if sLen   0, then salt is the empty string.
; M' is an octet string of length 8   hLen   sLen with eight initial zero octets.
Let H   Hash(M'), an octet string of length hLen.
Generate an octet string PS consisting of emLen sLen hLen 2 zero octets.
The length of PS may be 0.
Let DB   PS    0x01    salt; DB is an octet string of length emLen hLen 1.
Let dbMask   MGF(H, emLen hLen 1).
Let maskedDB   DB \xor dbMask.
Set the leftmost 8emLen emBits bits of the leftmost octet in maskedDB to zero.
EM   maskedDB    H    0xbc. 13.
Verification Operation EMSA PSS VERIFY (M, EM, emBits) Options:
(emBits/8) emBits   maximal bit length of the integer OS2IP (EM) (see Section 4.2), at least 8hLen   8sLen   9 Output:  "consistent" or "inconsistent"
If the length of M is greater than the input limitation for the hash function
(2^61 1 octets for SHA 1), output "inconsistent" and stop.
Let mHash   Hash(M), an octet string of length hLen.
sLen   2, output "inconsistent" and stop.
If the rightmost octet of EM does not have hexadecimal value 0xbc, output "inconsistent" and stop.
Let maskedDB be the leftmost emLen hLen 1 octets of EM, and let H be the next hLen octets.
If the leftmost 8emLen emBits bits of the leftmost octet in maskedDB are not all equal to zero, output "inconsistent" and stop.
Let dbMask   MGF(H, emLen hLen 1).
Let DB   maskedDB \xor dbMask.
Set the leftmost 8emLen emBits bits of the leftmost octet in DB to zero.
If the emLen hLen sLen 2 leftmost octets of DB are not zero or if the octet at position emLen hLen sLen 1 (the leftmost position is "position 1") does not have hexadecimal value 0x01, output "inconsistent" and stop.
Let salt be the last sLen octets of DB.
; M' is an octet string of length 8   hLen   sLen with eight initial zero octets.
Hash(M'), an octet string of length hLen.
If H   H', output "consistent".
This encoding method is deterministic and only has an encoding operation.
v1 5 ENCODE (M, emLen) Option:
emLen    intended length in octets of the encoded message, at least tLen   11, where tLen is the octet length of the Distinguished Encoding Rules (DER) encoding T of a certain value computed during the encoding operation Output:
Apply the hash function to the message M to produce a hash value H:
If the hash function outputs "message too long", output "message too long" and stop.
The first field identifies the hash function and the second contains the hash value.
Let T be the DER encoding of the DigestInfo value (see the notes below), and let tLen be the length in octets of T. 3.
If emLen < tLen   11, output "intended encoded message length too short" and stop.
Generate an octet string PS consisting of emLen tLen 3 octets with hexadecimal value 0xff.
The length of PS will be at least 8 octets.
Concatenate PS, the DER encoding T, and other padding to form the encoded message EM as EM   0x00
For the nine hash functions mentioned in Appendix B.1, the DER encoding T of the DigestInfo value is equal to the following:
0x)30 20 30 0c 06 08 2a 86
48 86 f7 0d 02
48 86 f7 0d 02
(0x)30 21 30 09 06 05
2b 0e 03 02 1a 05
14    H. SHA 224:  (0x)30 2d 30 0d 06 09 60 86 48 01 65 03 04 02 04 05 00 04 1c    H. SHA 256: (0x)30 31 30 0d 06 09 60 86 48 01 65 03 04 02 01 05 00 04 20    H. SHA 384:
(0x)30 41 30 0d 06 09 60 86 48 01 65 03 04 02 02 05 00 04 30    H. SHA 512:
(0x)30 51 30 0d 06 09 60 86 48 01 65 03 04 02 03 05 00 04
(0x)30 2d 30 0d 06 09 60 86 48 01 65 03 04 02 05
(0x)30 31 30 0d 06 09 60 86 48 01 65 03 04 02 06 05 00 04 20    H. 2.
In version 1.5 of this document, T was defined as the BER encoding, rather than the DER encoding, of the DigestInfo value.
In particular, it is possible   at least in theory   that the verification operation defined in this document (as well as in version 2.0) rejects a signature that is valid with respect to the specification given in PKCS #1 v1.5.
This occurs if other rules than DER are applied to DigestInfo (e.g., an indefinite length encoding of the underlying SEQUENCE type).
While this is unlikely to be a concern in practice, a cautious implementor may choose to employ a verification operation based on a BER decoding operation as specified in PKCS #1 v1.5.
In this manner, compatibility with any valid implementation based on PKCS #1 v1.5 is obtained.
Such a verification operation should indicate whether the underlying BER encoding is a DER encoding and hence whether the signature is valid with respect to the specification given in this document.
Security Considerations Security considerations are discussed throughout this memo.
This section defines ASN.1 object identifiers for RSA public and private keys and defines the types RSAPublicKey and RSAPrivateKey.
The intended application of these definitions includes X.509 certificates, PKCS #8 [RFC5958], and PKCS #12 [RFC7292].
The object identifier rsaEncryption identifies RSA public and private keys as defined in Appendices A.1.1 and A.1.2.
The parameters field has associated with this OID in a value of type AlgorithmIdentifier SHALL have a value of type NULL.
The definitions in this section have been extended to support multi  prime RSA, but they are backward compatible with previous versions.
An RSA public key should be represented with the ASN.1 type RSAPublicKey:
The fields of type RSAPublicKey have the following meanings:
the RSA modulus n.  publicExponent is the RSA public exponent e. A.1.2.
An RSA private key should be represented with the ASN.1 type
The fields of type RSAPrivateKey have the following meanings:  version is the version number, for compatibility with future revisions of this document.
It SHALL be 0 for this version of the document, unless multi prime is used; in which case, it SHALL be 1.
version must be multi if otherPrimeInfos present  })
the RSA modulus n.  publicExponent is
the RSA public exponent e.  privateExponent is the RSA private exponent d.
prime1 is the prime factor p of n.  prime2
is the prime factor q of n.
exponent1 is d mod (p 1).
exponent2 is d mod (q 1).
coefficient is the CRT coefficient q^( 1)
It SHALL be omitted if version is 0 and SHALL contain at least one instance of OtherPrimeInfo if version is 1.
The fields of type OtherPrimeInfo have the following meanings:
prime is a prime factor r i of n,
d mod (r i 1).
coefficient is the CRT coefficient t i
It is important to protect the RSA private key against both disclosure and modification.
Techniques for such protection are outside the scope of this document.
Methods for storing and distributing private keys and other cryptographic data are described in PKCS #12 and #15.
This section defines object identifiers for the encryption and signature schemes.
The schemes compatible with PKCS #1 v1.5 have the same definitions as in PKCS #1 v1.5.
The intended application of these definitions includes X.509 certificates and PKCS #7.
Here are type identifier definitions for the PKCS #1 OIDs: PKCS1Algorithms
{ OID id RSAES OAEP   PARAMETERS RSAES OAEP params }
id RSAES OAEP identifies the RSAES OAEP encryption scheme.
[1] MaskGenAlgorithm  DEFAULT mgf1SHA1, pSourceAlgorithm
} The fields of type RSAES OAEP params have the following meanings:
hashAlgorithm identifies the hash function.
It SHALL be an algorithm ID with an OID in the set OAEP PSSDigestAlgorithms.
For a discussion of supported hash functions, see Appendix B.1.
Allows for future expansion   }
The default hash function is SHA 1:
maskGenAlgorithm identifies the mask generation function.
It SHALL be an algorithm ID with an OID in the set PKCS1MGFAlgorithms, which for this version SHALL consist of id mgf1, identifying the MGF1 mask generation function (see Appendix B.2.1).
The parameters field associated with id mgf1 SHALL be an algorithm ID with an OID in the set OAEP PSSDigestAlgorithms, identifying the hash function on which MGF1 is based.
Allows for future expansion   }
The default mask generation function is MGF1 with SHA 1:
sha1 }  pSourceAlgorithm identifies the source (and possibly the value) of the label L.
It SHALL be an algorithm ID with an OID in the set PKCS1PSourceAlgorithms, which for this version SHALL consist of id pSpecified, indicating that the label is specified explicitly.
The parameters field associated with i
SHALL have a value of type OCTET STRING, containing the label.
In previous versions of this specification, the term "encoding parameters" was used rather than "label", hence the name of the type below.
Allows for future expansion   }
The default label is an empty string (so that lHash will contain the hash of the empty string)
d pSpecified, parameters  EncodingParameters :
The object identifier rsaEncryption (see Appendix A.1) identifies the RSAES PKCS1 v1 5 encryption scheme.
The parameters field associated with this OID in a value of type AlgorithmIdentifier SHALL have a value of type NULL.
This is the same as in PKCS #1
id RSASSA PSS identifies the RSASSA PSS encryption scheme.
The fields of type RSASSA PSS params have the following meanings:  hashAlgorithm identifies the hash function.
It SHALL be an algorithm ID with an OID in the set OAEP PSSDigestAlgorithms (see Appendix A.2.1).
The default hash function is SHA 1.
maskGenAlgorithm identifies the mask generation function.
It SHALL be an algorithm ID with an OID in the set
The default mask generation function is MGF1 with SHA 1.
(and more generally, for other mask generation functions based on a hash function), it is RECOMMENDED that the underlying hash function be the same as the one identified by hashAlgorithm; see Note 2 in Section 9.1 for further comments.
saltLength is the octet length of the salt.
It SHALL be an integer.
For a given hashAlgorithm, the default value of saltLength is the octet length of the hash value.
Unlike the other fields of type RSASSA PSS params, saltLength does not need to be fixed for a given RSA key pair.
trailerField is the trailer field number, for compatibility with IEEE 1363a [IEEE1363A].
It SHALL be 1 for this version of the document, which represents the trailer field with hexadecimal value 0xbc.
Other trailer fields (including the trailer field HashID    0xcc
in IEEE 1363a) are not supported in this document.
In some applications, the hash function underlying a signature scheme is identified separately from the rest of the operations in the signature scheme.
For instance, in PKCS #7 [RFC2315]
, a hash function identifier is placed before the message and a "digest encryption" algorithm identifier (indicating the rest of the operations) is carried with the signature.
In order for PKCS #7 to support the RSASSA PSS signature scheme, an object identifier would need to be defined for the operations in RSASSA PSS after the hash function (analogous to the RSAEncryption OID for the RSASSA PKCS1 v1 5 scheme).
S/MIME Cryptographic Message Syntax (CMS)
[RFC5652] takes a different approach.
Although a hash function identifier is placed before the message, an algorithm identifier for the full signature scheme may be carried with a CMS signature (this is done for DSA signatures).
Following this convention, the id RSASSA PSS OID can be used to identify RSASSA PSS signatures in CMS.
Since CMS is considered the successor to PKCS #7 and new developments such as the addition of support for RSASSA PSS will be pursued with respect to CMS rather than PKCS #7, an OID for the "rest of" RSASSA PSS is not defined in this version of PKCS #1. A.2.4.
The object identifier for RSASSA
SHALL be one of the following.
The choice of OID depends on the choice of hash algorithm:
MD2, MD5, SHA 1, SHA 224, SHA 256, SHA 384, SHA 512, SHA 512/224, or SHA 512/256.
Note that if either MD2 or MD5 is used, then the OID is just as in PKCS #1 v1.5.
For each OID, the parameters field associated with this OID in a value of type AlgorithmIdentifier SHALL have a value of type NULL.
The OID should be chosen in accordance with the following table:
digest OCTET STRING } digestAlgorithm identifies the hash function and SHALL be an algorithm ID with an OID in the set PKCS1 v1
For a discussion of supported hash functions, see Appendix B.1.
sha512 256 PARAMETERS NULL } }
This section gives several examples of underlying functions supporting the encryption schemes in Section 7 and the encoding methods in Section 9.
A range of techniques is given here to allow compatibility with existing applications as well as migration to new techniques.
While these supporting techniques are appropriate for applications to implement, none of them is required to be implemented.
It is expected that profiles for PKCS #1 v2.2 will be developed that specify particular supporting techniques.
This section also gives object identifiers for the supporting techniques.
Hash Functions Hash functions are used in the operations contained in Sections 7 and 9.
Hash functions are deterministic, meaning that the output is completely determined by the input.
Hash functions take octet strings of variable length and generate fixed length octet strings.
The hash functions used in the operations contained in Sections 7 and 9 should generally be collision resistant.
This means that it is infeasible to find two distinct inputs to the hash function that produce the same output.
A collision resistant hash function also has the desirable property of being one way; this means that given an output, it is infeasible to find an input whose hash is the specified output.
In addition to the requirements, the hash function should yield a mask generation function (Appendix B.2) with pseudorandom output.
Nine hash functions are given as examples for the encoding methods in this document:
MD2 [RFC1319] (which was retired by [RFC6149]), MD5 [RFC1321], SHA 1, SHA 224, SHA 256, SHA 384, SHA 512, SHA 512/224, and SHA 512/256 [SHS].
For the RSAES OAEP encryption scheme and EMSA PSS encoding method, only SHA 1, SHA 224, SHA 256, SHA 384, SHA  512, SHA 512/224, and SHA 512/256 are RECOMMENDED.
PKCS1 v1 5 encoding method, SHA 224, SHA 256, SHA 384, SHA 512, SHA  512/224, and SHA 512/256 are RECOMMENDED for new applications.
MD2, MD5, and SHA 1 are recommended only for compatibility with existing applications based on PKCS #1 v1.5.
d sha512/256 identify the respective hash functions: id
} The parameters field associated with these OIDs in a value of type AlgorithmIdentifier SHALL have a value of type NULL.
The parameters field associated with id md2 and id md5 in a value of type AlgorithmIdentifier shall have a value of type NULL.
The parameters field associated with id sha1, id sha224, id sha256, id sha384,
sha512/256 should generally be omitted, but if present, it shall have a value of type NULL.
This is to align with the definitions originally promulgated by NIST.
For the SHA algorithms, implementations MUST accept AlgorithmIdentifier values both without parameters and with NULL parameters.
When formatting the DigestInfoValue in EMSA PKCS1 v1 5 (see Section 9.2), the parameters field associated with id sha1, id sha224, id sha256, id sha384,
d sha512/256 shall have a value of type NULL.
This is to maintain compatibility with existing implementations and with the numeric information values already published for EMSA
PKCS1 v1 5, which are also reflected in IEEE 1363a
Version 1.5 of PKCS #1 also allowed for the use of MD4 in signature schemes.
The cryptanalysis of MD4 has progressed significantly in the intervening years.
For example, Dobbertin [MD4] demonstrated how to find collisions for MD4 and that the first two rounds of MD4 are not one way
Because of these results and others (e.g., [MD4LAST]), MD4 is NOT RECOMMENDED.
Further advances have been made in the cryptanalysis of MD2 and MD5, especially after the findings of Stevens et al.
[PREFIX] on chosen  prefix collisions on MD5.
MD2 and MD5 should be considered cryptographically broken and removed from existing applications.
This version of the standard supports MD2 and MD5 just for backwards  compatibility reasons.
There have also been advances in the cryptanalysis of SHA 1.
Particularly, the results of Wang et al.
[SHA1CRYPT] (which have been independently verified by M.  Cochran in his analysis [COCHRAN]) on using a differential path to find collisions in SHA 1, which conclude that the security strength of the SHA 1 hashing algorithm is significantly reduced.
However, this reduction is not significant enough to warrant the removal of SHA 1 from existing applications, but its usage is only recommended for backwards compatibility reasons.
To address these concerns, only SHA 224, SHA 256, SHA 384, SHA 512, SHA 512/224, and SHA 512/256 are RECOMMENDED for new applications.
As of today, the best (known) collision attacks against these hash functions are generic attacks with complexity 2L/2, where L is the bit length of the hash output.
For the signature schemes in this document, a collision attack is easily translated into a signature forgery.
Therefore, the value L / 2 should be at least equal to the desired security level in bits of the signature scheme (a security level of B bits
means that the best attack has complexity 2B).
The same rule of thumb can be applied to RSAES OAEP; it is RECOMMENDED that the bit length of the seed (which is equal to the bit length of the hash output) be twice the desired security level in bits.
A mask generation function takes an octet string of variable length and a desired output length as input and outputs an octet string of the desired length.
There may be restrictions on the length of the input and output octet strings, but such bounds are generally very large.
Mask generation functions are deterministic; the octet string output is completely determined by the input octet string.
The output of a mask generation function should be pseudorandom:
Given one part of the output but not the input, it should be infeasible to predict another part of the output.
The provable security of RSAES OAEP and RSASSA PSS relies on the random nature of the output of the mask generation function, which in turn relies on the random nature of the underlying hash.
One mask generation function is given here: MGF1, which is based on a hash function.
MGF1 coincides with the mask generation functions defined in IEEE 1363
Future versions of this document may define other mask generation functions.
MGF1 MGF1 is a mask generation function based on a hash function.
If maskLen > 2^32 hLen, output "mask too long" and stop.
Let T be the empty octet string.
For counter from 0 to \ceil
(maskLen / hLen) 1, do the following: A.  Convert counter to an octet string C of length 4 octets (see Section 4.1):
C   I2OSP (counter, 4) .
B.  Concatenate the hash of the seed mgfSeed and C to the octet string T:
T   T    Hash(mgfSeed    C) .
Output the leading maskLen octets of T as the octet string mask.
The object identifier id mgf1 identifies the MGF1 mask generation function: id
The parameters field associated with this OID in a value of type AlgorithmIdentifier shall have a value of type hashAlgorithm, identifying the hash function on which MGF1 is based.
This module has been checked for conformance with the   ASN.1 standard by the OSS ASN.1 Tools PKCS 1
{ iso(1) member body(2) us(840)
} DEFINITIONS EXPLICIT TAGS ::
All types and values defined in this module are exported for use   in other ASN.1 modules.
FROM NIST SHA2 { joint iso itu t(2)
When id RSAES OAEP is used in an AlgorithmIdentifier, the   parameters MUST be present and MUST be RSAES OAEP params.
When id pSpecified is used in an AlgorithmIdentifier, the   parameters MUST be an OCTET STRING.
When id RSASSA PSS is used in an AlgorithmIdentifier, the   parameters MUST be present and MUST be RSASSA PSS params.
When the following OIDs are used in an AlgorithmIdentifier,   the parameters MUST be present and MUST be NULL.
{ pkcs 1 14 } sha256WithRSAEncryption
{ pkcs 1 12 } sha512WithRSAEncryption
This OID really belongs in a module with the secsig OIDs.
When id mgf1 is used in an AlgorithmIdentifier, the parameters
MUST be present and MUST be a HashAlgorithm, for example, sha1.
OBJECT IDENTIFIER  UNIQUE, &Type  OPTIONAL }
WITH SYNTAX { OID &id [PARAMETERS &Type] }
the parameter InfoObjectSet in the following definitions   allows a distinct information object set to be specified for sets   of algorithms such as:
Allows for future expansion   }
Allowed EMSA PKCS1 v1 5 digest algorithms.
sha512 256 PARAMETERS NULL } }
md2 and id md5 are used in an AlgorithmIdentifier, the   parameters field shall have a value of type NULL.
When id sha1, id sha224, id sha256, id sha384,
d sha512 224, and i
sha512 256 are used in an   AlgorithmIdentifier, the parameters (which are optional) SHOULD be   omitted, but if present, they SHALL have a value of type NULL.
However, implementations MUST accept AlgorithmIdentifier values
both without parameters and with NULL parameters.
When formatting the DigestInfoValue in EMSA PKCS1 v1 5
(see Section 9.2), the parameters field associated with id sha1,   id sha224, id sha256, id sha384,
id sha512 224, and   i
SHALL have a value of type NULL.
This is to   maintain compatibility with existing implementations and with the   numeric information values already published for EMSA PKCS1 v1 5,   which are also reflected in IEEE 1363a.
AlgorithmIdentifier { {OAEP PSSDigestAlgorithms} } SHA1Parameters ::
If the identifier is id mgf1, the parameters are a HashAlgorithm.
: sha1 } MaskGenAlgorithm ::
Allows for future expansion   }
This identifier means that the label L is an empty string, so the   digest of the empty string appears in the RSA block before   masking.
{ OID id RSAES OAEP   PARAMETERS RSAES OAEP params }
Representation of RSA private key with information for the CRT   algorithm.
(CONSTRAINED BY {  version MUST be multi if otherPrimeInfos present  }
Note that the tags in this Sequence are explicit.
[1] MaskGenAlgorithm  DEFAULT mgf1SHA1, pSourceAlgorithm
The DER encoding of this is in hexadecimal:
Notice that the DER encoding of default values is "empty".
Note that the tags in this Sequence are explicit.
The DER encoding of this is in hexadecimal:
Notice that the DER encoding of default values is "empty".
Versions 1.0 1.3 were distributed to participants in RSA Data Security, Inc.'s Public Key Cryptography Standards meetings in February and March 1991.
Version 1.4 was part of the June 3, 1991 initial public release of PKCS.
Version 1.4 was published as NIST/OSI Implementors' Workshop document SEC SIG 91 18.
Version 1.5 incorporated several editorial changes, including updates to the references and the addition of a revision history.
md4WithRSAEncryption object identifier was added.
Version 1.5 was republished as [RFC2313] (which was later obsoleted by [RFC2437]).
Version 2.0 incorporated major editorial changes in terms of the document structure and introduced the RSAES OAEP encryption scheme.
This version continued to support the encryption and signature processes in version 1.5, although the hash algorithm MD4 was no longer allowed due to cryptanalytic advances in the intervening years.
Version 2.0 was republished as [RFC2437] (which was later obsoleted by [RFC3447]).
Version 2.1 introduced multi prime RSA and the RSASSA PSS signature scheme with appendix along with several editorial improvements.
This version continued to support the schemes in version 2.0.
Version 2.1 was republished as [RFC3447].
Version 2.2 updates the list of allowed hashing algorithms to align them with FIPS 180 4 [SHS], therefore adding SHA 224, SHA 512/224, and SHA 512/256.
This version continues to support the schemes in version 2.1.
The Public Key Cryptography Standards are specifications produced by RSA Laboratories in cooperation with secure systems developers worldwide for the purpose of accelerating the deployment of public  key cryptography.
First published in 1991 as a result of meetings with a small group of early adopters of public key technology, the PKCS documents have become widely referenced and implemented.
Contributions from the PKCS series have become part of many formal and de facto standards, including ANSI X9 and IEEE P1363 documents, PKIX, Secure Electronic Transaction (SET), S/MIME, SSL/TLS, and Wireless Application Protocol (WAP) / WAP Transport Layer Security (WTLS).
Further development of most PKCS documents occurs through the IETF.
Suggestions for improvement are welcome.
